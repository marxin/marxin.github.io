<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - gcc.info - gcc/cp/parser.c</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">gcc/cp</a> - parser.c<span style="font-size: 80%;"> (source / <a href="parser.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">gcc.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">14213</td>
            <td class="headerCovTableEntry">16198</td>
            <td class="headerCovTableEntryMed">87.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-09-22 10:58:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">432</td>
            <td class="headerCovTableEntry">560</td>
            <td class="headerCovTableEntryMed">77.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- C++ -*- Parser.</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 2000-2018 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            :    Written by Mark Mitchell &lt;mark@codesourcery.com&gt;.
<span class="lineNum">       4 </span>            : 
<span class="lineNum">       5 </span>            :    This file is part of GCC.
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            :    GCC is free software; you can redistribute it and/or modify it
<span class="lineNum">       8 </span>            :    under the terms of the GNU General Public License as published by
<span class="lineNum">       9 </span>            :    the Free Software Foundation; either version 3, or (at your option)
<span class="lineNum">      10 </span>            :    any later version.
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            :    GCC is distributed in the hope that it will be useful, but
<span class="lineNum">      13 </span>            :    WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      14 </span>            :    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
<span class="lineNum">      15 </span>            :    General Public License for more details.
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : You should have received a copy of the GNU General Public License
<span class="lineNum">      18 </span>            : along with GCC; see the file COPYING3.  If not see
<span class="lineNum">      19 </span>            : &lt;http://www.gnu.org/licenses/&gt;.  */
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            : #include &quot;config.h&quot;
<span class="lineNum">      22 </span>            : #define INCLUDE_UNIQUE_PTR
<span class="lineNum">      23 </span>            : #include &quot;system.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;coretypes.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;cp-tree.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;c-family/c-common.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;timevar.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;stringpool.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;cgraph.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;print-tree.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;attribs.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;trans-mem.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;intl.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;decl.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;c-family/c-objc.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;plugin.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;tree-pretty-print.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;parser.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;gomp-constants.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;omp-general.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;omp-offload.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;c-family/c-indentation.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;context.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;gcc-rich-location.h&quot;
<span class="lineNum">      45 </span>            : #include &quot;tree-iterator.h&quot;
<span class="lineNum">      46 </span>            : #include &quot;c-family/name-hint.h&quot;
<span class="lineNum">      47 </span>            : 
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            : /* The lexer.  */
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : /* The cp_lexer_* routines mediate between the lexer proper (in libcpp
<span class="lineNum">      52 </span>            :    and c-lex.c) and the C++ parser.  */
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span>            : static cp_token eof_token =
<span class="lineNum">      55 </span>            : {
<span class="lineNum">      56 </span>            :   CPP_EOF, RID_MAX, 0, false, false, false, 0, { NULL }
<span class="lineNum">      57 </span>            : };
<span class="lineNum">      58 </span>            : 
<span class="lineNum">      59 </span>            : /* The various kinds of non integral constant we encounter. */
<span class="lineNum">      60 </span>            : enum non_integral_constant {
<span class="lineNum">      61 </span>            :   NIC_NONE,
<span class="lineNum">      62 </span>            :   /* floating-point literal */
<span class="lineNum">      63 </span>            :   NIC_FLOAT,
<span class="lineNum">      64 </span>            :   /* %&lt;this%&gt; */
<span class="lineNum">      65 </span>            :   NIC_THIS,
<span class="lineNum">      66 </span>            :   /* %&lt;__FUNCTION__%&gt; */
<span class="lineNum">      67 </span>            :   NIC_FUNC_NAME,
<span class="lineNum">      68 </span>            :   /* %&lt;__PRETTY_FUNCTION__%&gt; */
<span class="lineNum">      69 </span>            :   NIC_PRETTY_FUNC,
<span class="lineNum">      70 </span>            :   /* %&lt;__func__%&gt; */
<span class="lineNum">      71 </span>            :   NIC_C99_FUNC,
<span class="lineNum">      72 </span>            :   /* &quot;%&lt;va_arg%&gt; */
<span class="lineNum">      73 </span>            :   NIC_VA_ARG,
<span class="lineNum">      74 </span>            :   /* a cast */
<span class="lineNum">      75 </span>            :   NIC_CAST,
<span class="lineNum">      76 </span>            :   /* %&lt;typeid%&gt; operator */
<span class="lineNum">      77 </span>            :   NIC_TYPEID,
<span class="lineNum">      78 </span>            :   /* non-constant compound literals */
<span class="lineNum">      79 </span>            :   NIC_NCC,
<span class="lineNum">      80 </span>            :   /* a function call */
<span class="lineNum">      81 </span>            :   NIC_FUNC_CALL,
<span class="lineNum">      82 </span>            :   /* an increment */
<span class="lineNum">      83 </span>            :   NIC_INC,
<span class="lineNum">      84 </span>            :   /* an decrement */
<span class="lineNum">      85 </span>            :   NIC_DEC,
<span class="lineNum">      86 </span>            :   /* an array reference */
<span class="lineNum">      87 </span>            :   NIC_ARRAY_REF,
<span class="lineNum">      88 </span>            :   /* %&lt;-&gt;%&gt; */
<span class="lineNum">      89 </span>            :   NIC_ARROW,
<span class="lineNum">      90 </span>            :   /* %&lt;.%&gt; */
<span class="lineNum">      91 </span>            :   NIC_POINT,
<span class="lineNum">      92 </span>            :   /* the address of a label */
<span class="lineNum">      93 </span>            :   NIC_ADDR_LABEL,
<span class="lineNum">      94 </span>            :   /* %&lt;*%&gt; */
<span class="lineNum">      95 </span>            :   NIC_STAR,
<span class="lineNum">      96 </span>            :   /* %&lt;&amp;%&gt; */
<span class="lineNum">      97 </span>            :   NIC_ADDR,
<span class="lineNum">      98 </span>            :   /* %&lt;++%&gt; */
<span class="lineNum">      99 </span>            :   NIC_PREINCREMENT,
<span class="lineNum">     100 </span>            :   /* %&lt;--%&gt; */
<span class="lineNum">     101 </span>            :   NIC_PREDECREMENT,
<span class="lineNum">     102 </span>            :   /* %&lt;new%&gt; */
<span class="lineNum">     103 </span>            :   NIC_NEW,
<span class="lineNum">     104 </span>            :   /* %&lt;delete%&gt; */
<span class="lineNum">     105 </span>            :   NIC_DEL,
<span class="lineNum">     106 </span>            :   /* calls to overloaded operators */
<span class="lineNum">     107 </span>            :   NIC_OVERLOADED,
<span class="lineNum">     108 </span>            :   /* an assignment */
<span class="lineNum">     109 </span>            :   NIC_ASSIGNMENT,
<span class="lineNum">     110 </span>            :   /* a comma operator */
<span class="lineNum">     111 </span>            :   NIC_COMMA,
<span class="lineNum">     112 </span>            :   /* a call to a constructor */
<span class="lineNum">     113 </span>            :   NIC_CONSTRUCTOR,
<span class="lineNum">     114 </span>            :   /* a transaction expression */
<span class="lineNum">     115 </span>            :   NIC_TRANSACTION
<span class="lineNum">     116 </span>            : };
<span class="lineNum">     117 </span>            : 
<span class="lineNum">     118 </span>            : /* The various kinds of errors about name-lookup failing. */
<span class="lineNum">     119 </span>            : enum name_lookup_error {
<span class="lineNum">     120 </span>            :   /* NULL */
<span class="lineNum">     121 </span>            :   NLE_NULL,
<span class="lineNum">     122 </span>            :   /* is not a type */
<span class="lineNum">     123 </span>            :   NLE_TYPE,
<span class="lineNum">     124 </span>            :   /* is not a class or namespace */
<span class="lineNum">     125 </span>            :   NLE_CXX98,
<span class="lineNum">     126 </span>            :   /* is not a class, namespace, or enumeration */
<span class="lineNum">     127 </span>            :   NLE_NOT_CXX98
<span class="lineNum">     128 </span>            : };
<span class="lineNum">     129 </span>            : 
<span class="lineNum">     130 </span>            : /* The various kinds of required token */
<span class="lineNum">     131 </span>            : enum required_token {
<span class="lineNum">     132 </span>            :   RT_NONE,
<span class="lineNum">     133 </span>            :   RT_SEMICOLON,  /* ';' */
<span class="lineNum">     134 </span>            :   RT_OPEN_PAREN, /* '(' */
<span class="lineNum">     135 </span>            :   RT_CLOSE_BRACE, /* '}' */
<span class="lineNum">     136 </span>            :   RT_OPEN_BRACE,  /* '{' */
<span class="lineNum">     137 </span>            :   RT_CLOSE_SQUARE, /* ']' */
<span class="lineNum">     138 </span>            :   RT_OPEN_SQUARE,  /* '[' */
<span class="lineNum">     139 </span>            :   RT_COMMA, /* ',' */
<span class="lineNum">     140 </span>            :   RT_SCOPE, /* '::' */
<span class="lineNum">     141 </span>            :   RT_LESS, /* '&lt;' */
<span class="lineNum">     142 </span>            :   RT_GREATER, /* '&gt;' */
<span class="lineNum">     143 </span>            :   RT_EQ, /* '=' */
<span class="lineNum">     144 </span>            :   RT_ELLIPSIS, /* '...' */
<span class="lineNum">     145 </span>            :   RT_MULT, /* '*' */
<span class="lineNum">     146 </span>            :   RT_COMPL, /* '~' */
<span class="lineNum">     147 </span>            :   RT_COLON, /* ':' */
<span class="lineNum">     148 </span>            :   RT_COLON_SCOPE, /* ':' or '::' */
<span class="lineNum">     149 </span>            :   RT_CLOSE_PAREN, /* ')' */
<span class="lineNum">     150 </span>            :   RT_COMMA_CLOSE_PAREN, /* ',' or ')' */
<span class="lineNum">     151 </span>            :   RT_PRAGMA_EOL, /* end of line */
<span class="lineNum">     152 </span>            :   RT_NAME, /* identifier */
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span>            :   /* The type is CPP_KEYWORD */
<span class="lineNum">     155 </span>            :   RT_NEW, /* new */
<span class="lineNum">     156 </span>            :   RT_DELETE, /* delete */
<span class="lineNum">     157 </span>            :   RT_RETURN, /* return */
<span class="lineNum">     158 </span>            :   RT_WHILE, /* while */
<span class="lineNum">     159 </span>            :   RT_EXTERN, /* extern */
<span class="lineNum">     160 </span>            :   RT_STATIC_ASSERT, /* static_assert */
<span class="lineNum">     161 </span>            :   RT_DECLTYPE, /* decltype */
<span class="lineNum">     162 </span>            :   RT_OPERATOR, /* operator */
<span class="lineNum">     163 </span>            :   RT_CLASS, /* class */
<span class="lineNum">     164 </span>            :   RT_TEMPLATE, /* template */
<span class="lineNum">     165 </span>            :   RT_NAMESPACE, /* namespace */
<span class="lineNum">     166 </span>            :   RT_USING, /* using */
<span class="lineNum">     167 </span>            :   RT_ASM, /* asm */
<span class="lineNum">     168 </span>            :   RT_TRY, /* try */
<span class="lineNum">     169 </span>            :   RT_CATCH, /* catch */
<span class="lineNum">     170 </span>            :   RT_THROW, /* throw */
<span class="lineNum">     171 </span>            :   RT_LABEL, /* __label__ */
<span class="lineNum">     172 </span>            :   RT_AT_TRY, /* @try */
<span class="lineNum">     173 </span>            :   RT_AT_SYNCHRONIZED, /* @synchronized */
<span class="lineNum">     174 </span>            :   RT_AT_THROW, /* @throw */
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span>            :   RT_SELECT,  /* selection-statement */
<span class="lineNum">     177 </span>            :   RT_ITERATION, /* iteration-statement */
<span class="lineNum">     178 </span>            :   RT_JUMP, /* jump-statement */
<span class="lineNum">     179 </span>            :   RT_CLASS_KEY, /* class-key */
<span class="lineNum">     180 </span>            :   RT_CLASS_TYPENAME_TEMPLATE, /* class, typename, or template */
<span class="lineNum">     181 </span>            :   RT_TRANSACTION_ATOMIC, /* __transaction_atomic */
<span class="lineNum">     182 </span>            :   RT_TRANSACTION_RELAXED, /* __transaction_relaxed */
<span class="lineNum">     183 </span>            :   RT_TRANSACTION_CANCEL /* __transaction_cancel */
<span class="lineNum">     184 </span>            : };
<span class="lineNum">     185 </span>            : 
<span class="lineNum">     186 </span>            : /* RAII wrapper for parser-&gt;in_type_id_in_expr_p, setting it on creation and
<span class="lineNum">     187 </span>            :    reverting it on destruction.  */
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span>            : class type_id_in_expr_sentinel
<span class="lineNum">     190 </span>            : {
<span class="lineNum">     191 </span>            :   cp_parser *parser;
<span class="lineNum">     192 </span>            :   bool saved;
<span class="lineNum">     193 </span>            : public:
<span class="lineNum">     194 </span>            :   type_id_in_expr_sentinel (cp_parser *parser, bool set = true)
<span class="lineNum">     195 </span>            :     : parser (parser),
<span class="lineNum">     196 </span><span class="lineCov">     115318 :       saved (parser-&gt;in_type_id_in_expr_p)</span>
<span class="lineNum">     197 </span><span class="lineCov">     115318 :   { parser-&gt;in_type_id_in_expr_p = set; }</span>
<span class="lineNum">     198 </span>            :   ~type_id_in_expr_sentinel ()
<span class="lineNum">     199 </span><span class="lineCov">     115318 :   { parser-&gt;in_type_id_in_expr_p = saved; }</span>
<span class="lineNum">     200 </span>            : };
<span class="lineNum">     201 </span>            : 
<span class="lineNum">     202 </span>            : /* Prototypes.  */
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span>            : static cp_lexer *cp_lexer_new_main
<span class="lineNum">     205 </span>            :   (void);
<span class="lineNum">     206 </span>            : static cp_lexer *cp_lexer_new_from_tokens
<span class="lineNum">     207 </span>            :   (cp_token_cache *tokens);
<span class="lineNum">     208 </span>            : static void cp_lexer_destroy
<span class="lineNum">     209 </span>            :   (cp_lexer *);
<span class="lineNum">     210 </span>            : static int cp_lexer_saving_tokens
<span class="lineNum">     211 </span>            :   (const cp_lexer *);
<span class="lineNum">     212 </span>            : static cp_token *cp_lexer_token_at
<span class="lineNum">     213 </span>            :   (cp_lexer *, cp_token_position);
<span class="lineNum">     214 </span>            : static void cp_lexer_get_preprocessor_token
<span class="lineNum">     215 </span>            :   (cp_lexer *, cp_token *);
<span class="lineNum">     216 </span>            : static inline cp_token *cp_lexer_peek_token
<span class="lineNum">     217 </span>            :   (cp_lexer *);
<span class="lineNum">     218 </span>            : static cp_token *cp_lexer_peek_nth_token
<span class="lineNum">     219 </span>            :   (cp_lexer *, size_t);
<span class="lineNum">     220 </span>            : static inline bool cp_lexer_next_token_is
<span class="lineNum">     221 </span>            :   (cp_lexer *, enum cpp_ttype);
<span class="lineNum">     222 </span>            : static bool cp_lexer_next_token_is_not
<span class="lineNum">     223 </span>            :   (cp_lexer *, enum cpp_ttype);
<span class="lineNum">     224 </span>            : static bool cp_lexer_next_token_is_keyword
<span class="lineNum">     225 </span>            :   (cp_lexer *, enum rid);
<span class="lineNum">     226 </span>            : static cp_token *cp_lexer_consume_token
<span class="lineNum">     227 </span>            :   (cp_lexer *);
<span class="lineNum">     228 </span>            : static void cp_lexer_purge_token
<span class="lineNum">     229 </span>            :   (cp_lexer *);
<span class="lineNum">     230 </span>            : static void cp_lexer_purge_tokens_after
<span class="lineNum">     231 </span>            :   (cp_lexer *, cp_token_position);
<span class="lineNum">     232 </span>            : static void cp_lexer_save_tokens
<span class="lineNum">     233 </span>            :   (cp_lexer *);
<span class="lineNum">     234 </span>            : static void cp_lexer_commit_tokens
<span class="lineNum">     235 </span>            :   (cp_lexer *);
<span class="lineNum">     236 </span>            : static void cp_lexer_rollback_tokens
<span class="lineNum">     237 </span>            :   (cp_lexer *);
<span class="lineNum">     238 </span>            : static void cp_lexer_print_token
<span class="lineNum">     239 </span>            :   (FILE *, cp_token *);
<span class="lineNum">     240 </span>            : static inline bool cp_lexer_debugging_p
<span class="lineNum">     241 </span>            :   (cp_lexer *);
<span class="lineNum">     242 </span>            : static void cp_lexer_start_debugging
<span class="lineNum">     243 </span>            :   (cp_lexer *) ATTRIBUTE_UNUSED;
<span class="lineNum">     244 </span>            : static void cp_lexer_stop_debugging
<span class="lineNum">     245 </span>            :   (cp_lexer *) ATTRIBUTE_UNUSED;
<span class="lineNum">     246 </span>            : 
<span class="lineNum">     247 </span>            : static cp_token_cache *cp_token_cache_new
<span class="lineNum">     248 </span>            :   (cp_token *, cp_token *);
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span>            : static void cp_parser_initial_pragma
<span class="lineNum">     251 </span>            :   (cp_token *);
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span>            : static bool cp_parser_omp_declare_reduction_exprs
<span class="lineNum">     254 </span>            :   (tree, cp_parser *);
<span class="lineNum">     255 </span>            : static void cp_finalize_oacc_routine
<span class="lineNum">     256 </span>            :   (cp_parser *, tree, bool);
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span>            : /* Manifest constants.  */
<span class="lineNum">     259 </span>            : #define CP_LEXER_BUFFER_SIZE ((256 * 1024) / sizeof (cp_token))
<span class="lineNum">     260 </span>            : #define CP_SAVED_TOKEN_STACK 5
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span>            : /* Variables.  */
<span class="lineNum">     263 </span>            : 
<span class="lineNum">     264 </span>            : /* The stream to which debugging output should be written.  */
<span class="lineNum">     265 </span>            : static FILE *cp_lexer_debug_stream;
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span>            : /* Nonzero if we are parsing an unevaluated operand: an operand to
<span class="lineNum">     268 </span>            :    sizeof, typeof, or alignof.  */
<span class="lineNum">     269 </span>            : int cp_unevaluated_operand;
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span>            : /* Dump up to NUM tokens in BUFFER to FILE starting with token
<span class="lineNum">     272 </span>            :    START_TOKEN.  If START_TOKEN is NULL, the dump starts with the
<span class="lineNum">     273 </span>            :    first token in BUFFER.  If NUM is 0, dump all the tokens.  If
<span class="lineNum">     274 </span>            :    CURR_TOKEN is set and it is one of the tokens in BUFFER, it will be
<span class="lineNum">     275 </span>            :    highlighted by surrounding it in [[ ]].  */
<a name="276"><span class="lineNum">     276 </span>            : </a>
<span class="lineNum">     277 </span>            : static void
<span class="lineNum">     278 </span><span class="lineNoCov">          0 : cp_lexer_dump_tokens (FILE *file, vec&lt;cp_token, va_gc&gt; *buffer,</span>
<span class="lineNum">     279 </span>            :                       cp_token *start_token, unsigned num,
<span class="lineNum">     280 </span>            :                       cp_token *curr_token)
<span class="lineNum">     281 </span>            : {
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :   unsigned i, nprinted;</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :   cp_token *token;</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :   bool do_print;</span>
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :   fprintf (file, &quot;%u tokens\n&quot;, vec_safe_length (buffer));</span>
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :   if (buffer == NULL)</span>
<span class="lineNum">     289 </span>            :     return;
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :   if (num == 0)</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :     num = buffer-&gt;length ();</span>
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :   if (start_token == NULL)</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :     start_token = buffer-&gt;address ();</span>
<span class="lineNum">     296 </span>            : 
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :   if (start_token &gt; buffer-&gt;address ())</span>
<span class="lineNum">     298 </span>            :     {
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :       cp_lexer_print_token (file, &amp;(*buffer)[0]);</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :       fprintf (file, &quot; ... &quot;);</span>
<span class="lineNum">     301 </span>            :     }
<span class="lineNum">     302 </span>            : 
<span class="lineNum">     303 </span>            :   do_print = false;
<span class="lineNum">     304 </span>            :   nprinted = 0;
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :   for (i = 0; buffer-&gt;iterate (i, &amp;token) &amp;&amp; nprinted &lt; num; i++)</span>
<span class="lineNum">     306 </span>            :     {
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :       if (token == start_token)</span>
<span class="lineNum">     308 </span>            :         do_print = true;
<span class="lineNum">     309 </span>            : 
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :       if (!do_print)</span>
<span class="lineNum">     311 </span>            :         continue;
<span class="lineNum">     312 </span>            : 
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :       nprinted++;</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :       if (token == curr_token)</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :         fprintf (file, &quot;[[&quot;);</span>
<span class="lineNum">     316 </span>            : 
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :       cp_lexer_print_token (file, token);</span>
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :       if (token == curr_token)</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :         fprintf (file, &quot;]]&quot;);</span>
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :       switch (token-&gt;type)</span>
<span class="lineNum">     323 </span>            :         {
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :           case CPP_SEMICOLON:</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :           case CPP_OPEN_BRACE:</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :           case CPP_CLOSE_BRACE:</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :           case CPP_EOF:</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :             fputc ('\n', file);</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     330 </span>            : 
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :           default:</span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :             fputc (' ', file);</span>
<span class="lineNum">     333 </span>            :         }
<span class="lineNum">     334 </span>            :     }
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :   if (i == num &amp;&amp; i &lt; buffer-&gt;length ())</span>
<span class="lineNum">     337 </span>            :     {
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :       fprintf (file, &quot; ... &quot;);</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :       cp_lexer_print_token (file, &amp;buffer-&gt;last ());</span>
<span class="lineNum">     340 </span>            :     }
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :   fprintf (file, &quot;\n&quot;);</span>
<span class="lineNum">     343 </span>            : }
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span>            : 
<span class="lineNum">     346 </span>            : /* Dump all tokens in BUFFER to stderr.  */
<a name="347"><span class="lineNum">     347 </span>            : </a>
<span class="lineNum">     348 </span>            : void
<span class="lineNum">     349 </span><span class="lineNoCov">          0 : cp_lexer_debug_tokens (vec&lt;cp_token, va_gc&gt; *buffer)</span>
<span class="lineNum">     350 </span>            : {
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :   cp_lexer_dump_tokens (stderr, buffer, NULL, 0, NULL);</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 : }</span>
<a name="353"><span class="lineNum">     353 </span>            : </a>
<span class="lineNum">     354 </span>            : DEBUG_FUNCTION void
<span class="lineNum">     355 </span><span class="lineNoCov">          0 : debug (vec&lt;cp_token, va_gc&gt; &amp;ref)</span>
<span class="lineNum">     356 </span>            : {
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :   cp_lexer_dump_tokens (stderr, &amp;ref, NULL, 0, NULL);</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 : }</span>
<a name="359"><span class="lineNum">     359 </span>            : </a>
<span class="lineNum">     360 </span>            : DEBUG_FUNCTION void
<span class="lineNum">     361 </span><span class="lineNoCov">          0 : debug (vec&lt;cp_token, va_gc&gt; *ptr)</span>
<span class="lineNum">     362 </span>            : {
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :   if (ptr)</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :     debug (*ptr);</span>
<span class="lineNum">     365 </span>            :   else
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :     fprintf (stderr, &quot;&lt;nil&gt;\n&quot;);</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     368 </span>            : 
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span>            : /* Dump the cp_parser tree field T to FILE if T is non-NULL.  DESC is the
<span class="lineNum">     371 </span>            :    description for T.  */
<a name="372"><span class="lineNum">     372 </span>            : </a>
<span class="lineNum">     373 </span>            : static void
<span class="lineNum">     374 </span><span class="lineNoCov">          0 : cp_debug_print_tree_if_set (FILE *file, const char *desc, tree t)</span>
<span class="lineNum">     375 </span>            : {
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :   if (t)</span>
<span class="lineNum">     377 </span>            :     {
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :       fprintf (file, &quot;%s: &quot;, desc);</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :       print_node_brief (file, &quot;&quot;, t, 0);</span>
<span class="lineNum">     380 </span>            :     }
<span class="lineNum">     381 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     382 </span>            : 
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span>            : /* Dump parser context C to FILE.  */
<a name="385"><span class="lineNum">     385 </span>            : </a>
<span class="lineNum">     386 </span>            : static void
<span class="lineNum">     387 </span><span class="lineNoCov">          0 : cp_debug_print_context (FILE *file, cp_parser_context *c)</span>
<span class="lineNum">     388 </span>            : {
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :   const char *status_s[] = { &quot;OK&quot;, &quot;ERROR&quot;, &quot;COMMITTED&quot; };</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :   fprintf (file, &quot;{ status = %s, scope = &quot;, status_s[c-&gt;status]);</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :   print_node_brief (file, &quot;&quot;, c-&gt;object_type, 0);</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :   fprintf (file, &quot;}\n&quot;);</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     394 </span>            : 
<span class="lineNum">     395 </span>            : 
<span class="lineNum">     396 </span>            : /* Print the stack of parsing contexts to FILE starting with FIRST.  */
<a name="397"><span class="lineNum">     397 </span>            : </a>
<span class="lineNum">     398 </span>            : static void
<span class="lineNum">     399 </span><span class="lineNoCov">          0 : cp_debug_print_context_stack (FILE *file, cp_parser_context *first)</span>
<span class="lineNum">     400 </span>            : {
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :   unsigned i;</span>
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :   cp_parser_context *c;</span>
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :   fprintf (file, &quot;Parsing context stack:\n&quot;);</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :   for (i = 0, c = first; c; c = c-&gt;next, i++)</span>
<span class="lineNum">     406 </span>            :     {
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :       fprintf (file, &quot;\t#%u: &quot;, i);</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :       cp_debug_print_context (file, c);</span>
<span class="lineNum">     409 </span>            :     }
<span class="lineNum">     410 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     411 </span>            : 
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span>            : /* Print the value of FLAG to FILE.  DESC is a string describing the flag.  */
<a name="414"><span class="lineNum">     414 </span>            : </a>
<span class="lineNum">     415 </span>            : static void
<span class="lineNum">     416 </span><span class="lineNoCov">          0 : cp_debug_print_flag (FILE *file, const char *desc, bool flag)</span>
<span class="lineNum">     417 </span>            : {
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :   if (flag)</span>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :     fprintf (file, &quot;%s: true\n&quot;, desc);</span>
<span class="lineNum">     420 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     421 </span>            : 
<span class="lineNum">     422 </span>            : 
<span class="lineNum">     423 </span>            : /* Print an unparsed function entry UF to FILE.  */
<a name="424"><span class="lineNum">     424 </span>            : </a>
<span class="lineNum">     425 </span>            : static void
<span class="lineNum">     426 </span><span class="lineNoCov">          0 : cp_debug_print_unparsed_function (FILE *file, cp_unparsed_functions_entry *uf)</span>
<span class="lineNum">     427 </span>            : {
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :   unsigned i;</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :   cp_default_arg_entry *default_arg_fn;</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :   tree fn;</span>
<span class="lineNum">     431 </span>            : 
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :   fprintf (file, &quot;\tFunctions with default args:\n&quot;);</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :   for (i = 0;</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :        vec_safe_iterate (uf-&gt;funs_with_default_args, i, &amp;default_arg_fn);</span>
<span class="lineNum">     435 </span>            :        i++)
<span class="lineNum">     436 </span>            :     {
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :       fprintf (file, &quot;\t\tClass type: &quot;);</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :       print_node_brief (file, &quot;&quot;, default_arg_fn-&gt;class_type, 0);</span>
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :       fprintf (file, &quot;\t\tDeclaration: &quot;);</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :       print_node_brief (file, &quot;&quot;, default_arg_fn-&gt;decl, 0);</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :       fprintf (file, &quot;\n&quot;);</span>
<span class="lineNum">     442 </span>            :     }
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :   fprintf (file, &quot;\n\tFunctions with definitions that require &quot;</span>
<span class="lineNum">     445 </span>            :            &quot;post-processing\n\t\t&quot;);
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :   for (i = 0; vec_safe_iterate (uf-&gt;funs_with_definitions, i, &amp;fn); i++)</span>
<span class="lineNum">     447 </span>            :     {
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :       print_node_brief (file, &quot;&quot;, fn, 0);</span>
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :       fprintf (file, &quot; &quot;);</span>
<span class="lineNum">     450 </span>            :     }
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :   fprintf (file, &quot;\n&quot;);</span>
<span class="lineNum">     452 </span>            : 
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :   fprintf (file, &quot;\n\tNon-static data members with initializers that require &quot;</span>
<span class="lineNum">     454 </span>            :            &quot;post-processing\n\t\t&quot;);
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :   for (i = 0; vec_safe_iterate (uf-&gt;nsdmis, i, &amp;fn); i++)</span>
<span class="lineNum">     456 </span>            :     {
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :       print_node_brief (file, &quot;&quot;, fn, 0);</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :       fprintf (file, &quot; &quot;);</span>
<span class="lineNum">     459 </span>            :     }
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :   fprintf (file, &quot;\n&quot;);</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     462 </span>            : 
<span class="lineNum">     463 </span>            : 
<span class="lineNum">     464 </span>            : /* Print the stack of unparsed member functions S to FILE.  */
<a name="465"><span class="lineNum">     465 </span>            : </a>
<span class="lineNum">     466 </span>            : static void
<span class="lineNum">     467 </span><span class="lineNoCov">          0 : cp_debug_print_unparsed_queues (FILE *file,</span>
<span class="lineNum">     468 </span>            :                                 vec&lt;cp_unparsed_functions_entry, va_gc&gt; *s)
<span class="lineNum">     469 </span>            : {
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :   unsigned i;</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :   cp_unparsed_functions_entry *uf;</span>
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :   fprintf (file, &quot;Unparsed functions\n&quot;);</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :   for (i = 0; vec_safe_iterate (s, i, &amp;uf); i++)</span>
<span class="lineNum">     475 </span>            :     {
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :       fprintf (file, &quot;#%u:\n&quot;, i);</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :       cp_debug_print_unparsed_function (file, uf);</span>
<span class="lineNum">     478 </span>            :     }
<span class="lineNum">     479 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span>            : /* Dump the tokens in a window of size WINDOW_SIZE around the next_token for
<span class="lineNum">     483 </span>            :    the given PARSER.  If FILE is NULL, the output is printed on stderr. */
<a name="484"><span class="lineNum">     484 </span>            : </a>
<span class="lineNum">     485 </span>            : static void
<span class="lineNum">     486 </span><span class="lineNoCov">          0 : cp_debug_parser_tokens (FILE *file, cp_parser *parser, int window_size)</span>
<span class="lineNum">     487 </span>            : {
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :   cp_token *next_token, *first_token, *start_token;</span>
<span class="lineNum">     489 </span>            : 
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :   if (file == NULL)</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :     file = stderr;</span>
<span class="lineNum">     492 </span>            : 
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :   next_token = parser-&gt;lexer-&gt;next_token;</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :   first_token = parser-&gt;lexer-&gt;buffer-&gt;address ();</span>
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :   start_token = (next_token &gt; first_token + window_size / 2)</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :                 ? next_token - window_size / 2</span>
<span class="lineNum">     497 </span>            :                 : first_token;
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :   cp_lexer_dump_tokens (file, parser-&gt;lexer-&gt;buffer, start_token, window_size,</span>
<span class="lineNum">     499 </span>            :                         next_token);
<span class="lineNum">     500 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     501 </span>            : 
<span class="lineNum">     502 </span>            : 
<span class="lineNum">     503 </span>            : /* Dump debugging information for the given PARSER.  If FILE is NULL,
<span class="lineNum">     504 </span>            :    the output is printed on stderr.  */
<a name="505"><span class="lineNum">     505 </span>            : </a>
<span class="lineNum">     506 </span>            : void
<span class="lineNum">     507 </span><span class="lineNoCov">          0 : cp_debug_parser (FILE *file, cp_parser *parser)</span>
<span class="lineNum">     508 </span>            : {
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :   const size_t window_size = 20;</span>
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :   cp_token *token;</span>
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :   expanded_location eloc;</span>
<span class="lineNum">     512 </span>            : 
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :   if (file == NULL)</span>
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :     file = stderr;</span>
<span class="lineNum">     515 </span>            : 
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :   fprintf (file, &quot;Parser state\n\n&quot;);</span>
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :   fprintf (file, &quot;Number of tokens: %u\n&quot;,</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :            vec_safe_length (parser-&gt;lexer-&gt;buffer));</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :   cp_debug_print_tree_if_set (file, &quot;Lookup scope&quot;, parser-&gt;scope);</span>
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :   cp_debug_print_tree_if_set (file, &quot;Object scope&quot;,</span>
<span class="lineNum">     521 </span>            :                                      parser-&gt;object_scope);
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :   cp_debug_print_tree_if_set (file, &quot;Qualifying scope&quot;,</span>
<span class="lineNum">     523 </span>            :                                      parser-&gt;qualifying_scope);
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :   cp_debug_print_context_stack (file, parser-&gt;context);</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :   cp_debug_print_flag (file, &quot;Allow GNU extensions&quot;,</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :                               parser-&gt;allow_gnu_extensions_p);</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :   cp_debug_print_flag (file, &quot;'&gt;' token is greater-than&quot;,</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :                               parser-&gt;greater_than_is_operator_p);</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :   cp_debug_print_flag (file, &quot;Default args allowed in current &quot;</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :                               &quot;parameter list&quot;, parser-&gt;default_arg_ok_p);</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :   cp_debug_print_flag (file, &quot;Parsing integral constant-expression&quot;,</span>
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :                               parser-&gt;integral_constant_expression_p);</span>
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :   cp_debug_print_flag (file, &quot;Allow non-constant expression in current &quot;</span>
<span class="lineNum">     534 </span>            :                               &quot;constant-expression&quot;,
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :                               parser-&gt;allow_non_integral_constant_expression_p);</span>
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :   cp_debug_print_flag (file, &quot;Seen non-constant expression&quot;,</span>
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :                               parser-&gt;non_integral_constant_expression_p);</span>
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :   cp_debug_print_flag (file, &quot;Local names and 'this' forbidden in &quot;</span>
<span class="lineNum">     539 </span>            :                               &quot;current context&quot;,
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :                               parser-&gt;local_variables_forbidden_p);</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :   cp_debug_print_flag (file, &quot;In unbraced linkage specification&quot;,</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :                               parser-&gt;in_unbraced_linkage_specification_p);</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :   cp_debug_print_flag (file, &quot;Parsing a declarator&quot;,</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :                               parser-&gt;in_declarator_p);</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :   cp_debug_print_flag (file, &quot;In template argument list&quot;,</span>
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :                               parser-&gt;in_template_argument_list_p);</span>
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :   cp_debug_print_flag (file, &quot;Parsing an iteration statement&quot;,</span>
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :                               parser-&gt;in_statement &amp; IN_ITERATION_STMT);</span>
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :   cp_debug_print_flag (file, &quot;Parsing a switch statement&quot;,</span>
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :                               parser-&gt;in_statement &amp; IN_SWITCH_STMT);</span>
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :   cp_debug_print_flag (file, &quot;Parsing a structured OpenMP block&quot;,</span>
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :                               parser-&gt;in_statement &amp; IN_OMP_BLOCK);</span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :   cp_debug_print_flag (file, &quot;Parsing a an OpenMP loop&quot;,</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :                               parser-&gt;in_statement &amp; IN_OMP_FOR);</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :   cp_debug_print_flag (file, &quot;Parsing an if statement&quot;,</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :                               parser-&gt;in_statement &amp; IN_IF_STMT);</span>
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :   cp_debug_print_flag (file, &quot;Parsing a type-id in an expression &quot;</span>
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :                               &quot;context&quot;, parser-&gt;in_type_id_in_expr_p);</span>
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :   cp_debug_print_flag (file, &quot;Declarations are implicitly extern \&quot;C\&quot;&quot;,</span>
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :                               parser-&gt;implicit_extern_c);</span>
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :   cp_debug_print_flag (file, &quot;String expressions should be translated &quot;</span>
<span class="lineNum">     562 </span>            :                               &quot;to execution character set&quot;,
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :                               parser-&gt;translate_strings_p);</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :   cp_debug_print_flag (file, &quot;Parsing function body outside of a &quot;</span>
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :                               &quot;local class&quot;, parser-&gt;in_function_body);</span>
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :   cp_debug_print_flag (file, &quot;Auto correct a colon to a scope operator&quot;,</span>
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :                               parser-&gt;colon_corrects_to_scope_p);</span>
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :   cp_debug_print_flag (file, &quot;Colon doesn't start a class definition&quot;,</span>
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :                               parser-&gt;colon_doesnt_start_class_def_p);</span>
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :   if (parser-&gt;type_definition_forbidden_message)</span>
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :     fprintf (file, &quot;Error message for forbidden type definitions: %s\n&quot;,</span>
<span class="lineNum">     572 </span>            :              parser-&gt;type_definition_forbidden_message);
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :   cp_debug_print_unparsed_queues (file, parser-&gt;unparsed_queues);</span>
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :   fprintf (file, &quot;Number of class definitions in progress: %u\n&quot;,</span>
<span class="lineNum">     575 </span>            :            parser-&gt;num_classes_being_defined);
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :   fprintf (file, &quot;Number of template parameter lists for the current &quot;</span>
<span class="lineNum">     577 </span>            :            &quot;declaration: %u\n&quot;, parser-&gt;num_template_parameter_lists);
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :   cp_debug_parser_tokens (file, parser, window_size);</span>
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :   token = parser-&gt;lexer-&gt;next_token;</span>
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :   fprintf (file, &quot;Next token to parse:\n&quot;);</span>
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :   fprintf (file, &quot;\tToken:  &quot;);</span>
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :   cp_lexer_print_token (file, token);</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :   eloc = expand_location (token-&gt;location);</span>
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :   fprintf (file, &quot;\n\tFile:   %s\n&quot;, eloc.file);</span>
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :   fprintf (file, &quot;\tLine:   %d\n&quot;, eloc.line);</span>
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :   fprintf (file, &quot;\tColumn: %d\n&quot;, eloc.column);</span>
<span class="lineNum">     587 </span><span class="lineNoCov">          0 : }</span>
<a name="588"><span class="lineNum">     588 </span>            : </a>
<span class="lineNum">     589 </span>            : DEBUG_FUNCTION void
<span class="lineNum">     590 </span><span class="lineNoCov">          0 : debug (cp_parser &amp;ref)</span>
<span class="lineNum">     591 </span>            : {
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :   cp_debug_parser (stderr, &amp;ref);</span>
<span class="lineNum">     593 </span><span class="lineNoCov">          0 : }</span>
<a name="594"><span class="lineNum">     594 </span>            : </a>
<span class="lineNum">     595 </span>            : DEBUG_FUNCTION void
<span class="lineNum">     596 </span><span class="lineNoCov">          0 : debug (cp_parser *ptr)</span>
<span class="lineNum">     597 </span>            : {
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :   if (ptr)</span>
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :     debug (*ptr);</span>
<span class="lineNum">     600 </span>            :   else
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :     fprintf (stderr, &quot;&lt;nil&gt;\n&quot;);</span>
<span class="lineNum">     602 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     603 </span>            : 
<span class="lineNum">     604 </span>            : /* Allocate memory for a new lexer object and return it.  */
<a name="605"><span class="lineNum">     605 </span>            : </a>
<span class="lineNum">     606 </span>            : static cp_lexer *
<span class="lineNum">     607 </span><span class="lineCov">      56241 : cp_lexer_alloc (void)</span>
<span class="lineNum">     608 </span>            : {
<span class="lineNum">     609 </span><span class="lineCov">      56241 :   cp_lexer *lexer;</span>
<span class="lineNum">     610 </span>            : 
<span class="lineNum">     611 </span><span class="lineCov">      56241 :   c_common_no_more_pch ();</span>
<span class="lineNum">     612 </span>            : 
<span class="lineNum">     613 </span>            :   /* Allocate the memory.  */
<span class="lineNum">     614 </span><span class="lineCov">      56241 :   lexer = ggc_cleared_alloc&lt;cp_lexer&gt; ();</span>
<span class="lineNum">     615 </span>            : 
<span class="lineNum">     616 </span>            :   /* Initially we are not debugging.  */
<span class="lineNum">     617 </span><span class="lineCov">      56241 :   lexer-&gt;debugging_p = false;</span>
<span class="lineNum">     618 </span>            : 
<span class="lineNum">     619 </span><span class="lineCov">      56241 :   lexer-&gt;saved_tokens.create (CP_SAVED_TOKEN_STACK);</span>
<span class="lineNum">     620 </span>            : 
<span class="lineNum">     621 </span>            :   /* Create the buffer.  */
<span class="lineNum">     622 </span><span class="lineCov">      56241 :   vec_alloc (lexer-&gt;buffer, CP_LEXER_BUFFER_SIZE);</span>
<span class="lineNum">     623 </span>            : 
<span class="lineNum">     624 </span><span class="lineCov">      56241 :   return lexer;</span>
<span class="lineNum">     625 </span>            : }
<span class="lineNum">     626 </span>            : 
<span class="lineNum">     627 </span>            : 
<span class="lineNum">     628 </span>            : /* Create a new main C++ lexer, the lexer that gets tokens from the
<span class="lineNum">     629 </span>            :    preprocessor.  */
<a name="630"><span class="lineNum">     630 </span>            : </a>
<span class="lineNum">     631 </span>            : static cp_lexer *
<span class="lineNum">     632 </span><span class="lineCov">      56260 : cp_lexer_new_main (void)</span>
<span class="lineNum">     633 </span>            : {
<span class="lineNum">     634 </span><span class="lineCov">      56260 :   cp_lexer *lexer;</span>
<span class="lineNum">     635 </span><span class="lineCov">      56260 :   cp_token token;</span>
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span>            :   /* It's possible that parsing the first pragma will load a PCH file,
<span class="lineNum">     638 </span>            :      which is a GC collection point.  So we have to do that before
<span class="lineNum">     639 </span>            :      allocating any memory.  */
<span class="lineNum">     640 </span><span class="lineCov">      56260 :   cp_parser_initial_pragma (&amp;token);</span>
<span class="lineNum">     641 </span>            : 
<span class="lineNum">     642 </span><span class="lineCov">      56241 :   lexer = cp_lexer_alloc ();</span>
<span class="lineNum">     643 </span>            : 
<span class="lineNum">     644 </span>            :   /* Put the first token in the buffer.  */
<span class="lineNum">     645 </span><span class="lineCov">      56241 :   lexer-&gt;buffer-&gt;quick_push (token);</span>
<span class="lineNum">     646 </span>            : 
<span class="lineNum">     647 </span>            :   /* Get the remaining tokens from the preprocessor.  */
<span class="lineNum">     648 </span><span class="lineCov">  445813483 :   while (token.type != CPP_EOF)</span>
<span class="lineNum">     649 </span>            :     {
<span class="lineNum">     650 </span><span class="lineCov">  445757242 :       cp_lexer_get_preprocessor_token (lexer, &amp;token);</span>
<span class="lineNum">     651 </span><span class="lineCov">  445757242 :       vec_safe_push (lexer-&gt;buffer, token);</span>
<span class="lineNum">     652 </span>            :     }
<span class="lineNum">     653 </span>            : 
<span class="lineNum">     654 </span><span class="lineCov">      56241 :   lexer-&gt;last_token = lexer-&gt;buffer-&gt;address ()</span>
<span class="lineNum">     655 </span><span class="lineCov">      56241 :                       + lexer-&gt;buffer-&gt;length ()</span>
<span class="lineNum">     656 </span><span class="lineCov">      56241 :                       - 1;</span>
<span class="lineNum">     657 </span><span class="lineCov">     112482 :   lexer-&gt;next_token = lexer-&gt;buffer-&gt;length ()</span>
<span class="lineNum">     658 </span><span class="lineCov">      56241 :                       ? lexer-&gt;buffer-&gt;address ()</span>
<span class="lineNum">     659 </span>            :                       : &amp;eof_token;
<span class="lineNum">     660 </span>            : 
<span class="lineNum">     661 </span>            :   /* Subsequent preprocessor diagnostics should use compiler
<span class="lineNum">     662 </span>            :      diagnostic functions to get the compiler source location.  */
<span class="lineNum">     663 </span><span class="lineCov">      56241 :   done_lexing = true;</span>
<span class="lineNum">     664 </span>            : 
<span class="lineNum">     665 </span><span class="lineCov">      56241 :   gcc_assert (!lexer-&gt;next_token-&gt;purged_p);</span>
<span class="lineNum">     666 </span><span class="lineCov">      56241 :   return lexer;</span>
<span class="lineNum">     667 </span>            : }
<span class="lineNum">     668 </span>            : 
<span class="lineNum">     669 </span>            : /* Create a new lexer whose token stream is primed with the tokens in
<span class="lineNum">     670 </span>            :    CACHE.  When these tokens are exhausted, no new tokens will be read.  */
<a name="671"><span class="lineNum">     671 </span>            : </a>
<span class="lineNum">     672 </span>            : static cp_lexer *
<span class="lineNum">     673 </span><span class="lineCov">    3315688 : cp_lexer_new_from_tokens (cp_token_cache *cache)</span>
<span class="lineNum">     674 </span>            : {
<span class="lineNum">     675 </span><span class="lineCov">    3315688 :   cp_token *first = cache-&gt;first;</span>
<span class="lineNum">     676 </span><span class="lineCov">    3315688 :   cp_token *last = cache-&gt;last;</span>
<span class="lineNum">     677 </span><span class="lineCov">    3315688 :   cp_lexer *lexer = ggc_cleared_alloc&lt;cp_lexer&gt; ();</span>
<span class="lineNum">     678 </span>            : 
<span class="lineNum">     679 </span>            :   /* We do not own the buffer.  */
<span class="lineNum">     680 </span><span class="lineCov">    3315688 :   lexer-&gt;buffer = NULL;</span>
<span class="lineNum">     681 </span><span class="lineCov">    3315688 :   lexer-&gt;next_token = first == last ? &amp;eof_token : first;</span>
<span class="lineNum">     682 </span><span class="lineCov">    3315688 :   lexer-&gt;last_token = last;</span>
<span class="lineNum">     683 </span>            : 
<span class="lineNum">     684 </span><span class="lineCov">    3315688 :   lexer-&gt;saved_tokens.create (CP_SAVED_TOKEN_STACK);</span>
<span class="lineNum">     685 </span>            : 
<span class="lineNum">     686 </span>            :   /* Initially we are not debugging.  */
<span class="lineNum">     687 </span><span class="lineCov">    3315688 :   lexer-&gt;debugging_p = false;</span>
<span class="lineNum">     688 </span>            : 
<span class="lineNum">     689 </span><span class="lineCov">    3315688 :   gcc_assert (!lexer-&gt;next_token-&gt;purged_p);</span>
<span class="lineNum">     690 </span><span class="lineCov">    3315688 :   return lexer;</span>
<span class="lineNum">     691 </span>            : }
<span class="lineNum">     692 </span>            : 
<span class="lineNum">     693 </span>            : /* Frees all resources associated with LEXER.  */
<a name="694"><span class="lineNum">     694 </span>            : </a>
<span class="lineNum">     695 </span>            : static void
<span class="lineNum">     696 </span><span class="lineCov">    3371860 : cp_lexer_destroy (cp_lexer *lexer)</span>
<span class="lineNum">     697 </span>            : {
<span class="lineNum">     698 </span><span class="lineCov">    3371860 :   vec_free (lexer-&gt;buffer);</span>
<span class="lineNum">     699 </span><span class="lineCov">    3371860 :   lexer-&gt;saved_tokens.release ();</span>
<span class="lineNum">     700 </span><span class="lineCov">    3371860 :   ggc_free (lexer);</span>
<span class="lineNum">     701 </span><span class="lineCov">    3371860 : }</span>
<span class="lineNum">     702 </span>            : 
<span class="lineNum">     703 </span>            : /* This needs to be set to TRUE before the lexer-debugging infrastructure can
<span class="lineNum">     704 </span>            :    be used.  The point of this flag is to help the compiler to fold away calls
<span class="lineNum">     705 </span>            :    to cp_lexer_debugging_p within this source file at compile time, when the
<span class="lineNum">     706 </span>            :    lexer is not being debugged.  */
<span class="lineNum">     707 </span>            : 
<span class="lineNum">     708 </span>            : #define LEXER_DEBUGGING_ENABLED_P false
<span class="lineNum">     709 </span>            : 
<span class="lineNum">     710 </span>            : /* Returns nonzero if debugging information should be output.  */
<a name="711"><span class="lineNum">     711 </span>            : </a>
<span class="lineNum">     712 </span>            : static inline bool
<span class="lineNum">     713 </span><span class="lineNoCov">          0 : cp_lexer_debugging_p (cp_lexer *lexer)</span>
<span class="lineNum">     714 </span>            : {
<span class="lineNum">     715 </span><span class="lineCov"> 9071597609 :   if (!LEXER_DEBUGGING_ENABLED_P)</span>
<span class="lineNum">     716 </span><span class="lineCov"> 9071597609 :     return false;</span>
<span class="lineNum">     717 </span>            : 
<span class="lineNum">     718 </span>            :   return lexer-&gt;debugging_p;
<span class="lineNum">     719 </span>            : }
<span class="lineNum">     720 </span>            : 
<span class="lineNum">     721 </span>            : 
<span class="lineNum">     722 </span>            : static inline cp_token_position
<span class="lineNum">     723 </span>            : cp_lexer_token_position (cp_lexer *lexer, bool previous_p)
<span class="lineNum">     724 </span>            : {
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :   gcc_assert (!previous_p || lexer-&gt;next_token != &amp;eof_token);</span>
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span><span class="lineCov">  233398376 :   return lexer-&gt;next_token - previous_p;</span>
<span class="lineNum">     728 </span>            : }
<a name="729"><span class="lineNum">     729 </span>            : </a>
<span class="lineNum">     730 </span>            : static inline cp_token *
<span class="lineNum">     731 </span><span class="lineNoCov">          0 : cp_lexer_token_at (cp_lexer * /*lexer*/, cp_token_position pos)</span>
<span class="lineNum">     732 </span>            : {
<span class="lineNum">     733 </span><span class="lineCov">   24421776 :   return pos;</span>
<span class="lineNum">     734 </span>            : }
<a name="735"><span class="lineNum">     735 </span>            : </a>
<span class="lineNum">     736 </span>            : static inline void
<span class="lineNum">     737 </span><span class="lineNoCov">          0 : cp_lexer_set_token_position (cp_lexer *lexer, cp_token_position pos)</span>
<span class="lineNum">     738 </span>            : {
<span class="lineNum">     739 </span><span class="lineCov">     380692 :   lexer-&gt;next_token = cp_lexer_token_at (lexer, pos);</span>
<span class="lineNum">     740 </span><span class="lineNoCov">          0 : }</span>
<a name="741"><span class="lineNum">     741 </span>            : </a>
<span class="lineNum">     742 </span>            : static inline cp_token_position
<span class="lineNum">     743 </span><span class="lineNoCov">          0 : cp_lexer_previous_token_position (cp_lexer *lexer)</span>
<span class="lineNum">     744 </span>            : {
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :   if (lexer-&gt;next_token == &amp;eof_token)</span>
<span class="lineNum">     746 </span><span class="lineCov">      54759 :     return lexer-&gt;last_token - 1;</span>
<span class="lineNum">     747 </span>            :   else
<span class="lineNum">     748 </span><span class="lineCov">   14918612 :     return cp_lexer_token_position (lexer, true);</span>
<span class="lineNum">     749 </span>            : }
<a name="750"><span class="lineNum">     750 </span>            : </a>
<span class="lineNum">     751 </span>            : static inline cp_token *
<span class="lineNum">     752 </span><span class="lineCov">   14973273 : cp_lexer_previous_token (cp_lexer *lexer)</span>
<span class="lineNum">     753 </span>            : {
<span class="lineNum">     754 </span><span class="lineCov">   14973273 :   cp_token_position tp = cp_lexer_previous_token_position (lexer);</span>
<span class="lineNum">     755 </span>            : 
<span class="lineNum">     756 </span>            :   /* Skip past purged tokens.  */
<span class="lineNum">     757 </span><span class="lineCov">   15396939 :   while (tp-&gt;purged_p)</span>
<span class="lineNum">     758 </span>            :     {
<span class="lineNum">     759 </span><span class="lineCov">     808357 :       gcc_assert (tp != vec_safe_address (lexer-&gt;buffer));</span>
<span class="lineNum">     760 </span><span class="lineCov">     423666 :       tp--;</span>
<span class="lineNum">     761 </span>            :     }
<span class="lineNum">     762 </span>            : 
<span class="lineNum">     763 </span><span class="lineCov">   29946546 :   return cp_lexer_token_at (lexer, tp);</span>
<span class="lineNum">     764 </span>            : }
<span class="lineNum">     765 </span>            : 
<span class="lineNum">     766 </span>            : /* nonzero if we are presently saving tokens.  */
<span class="lineNum">     767 </span>            : 
<span class="lineNum">     768 </span>            : static inline int
<span class="lineNum">     769 </span>            : cp_lexer_saving_tokens (const cp_lexer* lexer)
<span class="lineNum">     770 </span>            : {
<span class="lineNum">     771 </span><span class="lineCov">   22565877 :   return lexer-&gt;saved_tokens.length () != 0;</span>
<span class="lineNum">     772 </span>            : }
<span class="lineNum">     773 </span>            : 
<span class="lineNum">     774 </span>            : /* Store the next token from the preprocessor in *TOKEN.  Return true
<span class="lineNum">     775 </span>            :    if we reach EOF.  If LEXER is NULL, assume we are handling an
<span class="lineNum">     776 </span>            :    initial #pragma pch_preprocess, and thus want the lexer to return
<span class="lineNum">     777 </span>            :    processed strings.  */
<a name="778"><span class="lineNum">     778 </span>            : </a>
<span class="lineNum">     779 </span>            : static void
<span class="lineNum">     780 </span><span class="lineCov">  445813511 : cp_lexer_get_preprocessor_token (cp_lexer *lexer, cp_token *token)</span>
<span class="lineNum">     781 </span>            : {
<span class="lineNum">     782 </span><span class="lineCov">  445813511 :   static int is_extern_c = 0;</span>
<span class="lineNum">     783 </span>            : 
<span class="lineNum">     784 </span>            :    /* Get a new token from the preprocessor.  */
<span class="lineNum">     785 </span><span class="lineCov">  445813511 :   token-&gt;type</span>
<span class="lineNum">     786 </span><span class="lineCov">  891570753 :     = c_lex_with_flags (&amp;token-&gt;u.value, &amp;token-&gt;location, &amp;token-&gt;flags,</span>
<span class="lineNum">     787 </span>            :                         lexer == NULL ? 0 : C_LEX_STRING_NO_JOIN);
<span class="lineNum">     788 </span><span class="lineCov">  445813492 :   token-&gt;keyword = RID_MAX;</span>
<span class="lineNum">     789 </span><span class="lineCov">  445813492 :   token-&gt;purged_p = false;</span>
<span class="lineNum">     790 </span><span class="lineCov">  445813492 :   token-&gt;error_reported = false;</span>
<span class="lineNum">     791 </span>            : 
<span class="lineNum">     792 </span>            :   /* On some systems, some header files are surrounded by an
<span class="lineNum">     793 </span>            :      implicit extern &quot;C&quot; block.  Set a flag in the token if it
<span class="lineNum">     794 </span>            :      comes from such a header.  */
<span class="lineNum">     795 </span><span class="lineCov">  445813492 :   is_extern_c += pending_lang_change;</span>
<span class="lineNum">     796 </span><span class="lineCov">  445813492 :   pending_lang_change = 0;</span>
<span class="lineNum">     797 </span><span class="lineCov">  445813492 :   token-&gt;implicit_extern_c = is_extern_c &gt; 0;</span>
<span class="lineNum">     798 </span>            : 
<span class="lineNum">     799 </span>            :   /* Check to see if this token is a keyword.  */
<span class="lineNum">     800 </span><span class="lineCov">  445813492 :   if (token-&gt;type == CPP_NAME)</span>
<span class="lineNum">     801 </span>            :     {
<span class="lineNum">     802 </span><span class="lineCov">  206889421 :       if (IDENTIFIER_KEYWORD_P (token-&gt;u.value))</span>
<span class="lineNum">     803 </span>            :         {
<span class="lineNum">     804 </span>            :           /* Mark this token as a keyword.  */
<span class="lineNum">     805 </span><span class="lineCov">   77961343 :           token-&gt;type = CPP_KEYWORD;</span>
<span class="lineNum">     806 </span>            :           /* Record which keyword.  */
<span class="lineNum">     807 </span><span class="lineCov">   77961343 :           token-&gt;keyword = C_RID_CODE (token-&gt;u.value);</span>
<span class="lineNum">     808 </span>            :         }
<span class="lineNum">     809 </span>            :       else
<span class="lineNum">     810 </span>            :         {
<span class="lineNum">     811 </span><span class="lineCov">  128928078 :           if (warn_cxx11_compat</span>
<span class="lineNum">     812 </span><span class="lineCov">    2040274 :               &amp;&amp; C_RID_CODE (token-&gt;u.value) &gt;= RID_FIRST_CXX11</span>
<span class="lineNum">     813 </span><span class="lineCov">       2187 :               &amp;&amp; C_RID_CODE (token-&gt;u.value) &lt;= RID_LAST_CXX11)</span>
<span class="lineNum">     814 </span>            :             {
<span class="lineNum">     815 </span>            :               /* Warn about the C++0x keyword (but still treat it as
<span class="lineNum">     816 </span>            :                  an identifier).  */
<span class="lineNum">     817 </span><span class="lineCov">          2 :               warning (OPT_Wc__11_compat, </span>
<span class="lineNum">     818 </span>            :                        &quot;identifier %qE is a keyword in C++11&quot;,
<span class="lineNum">     819 </span>            :                        token-&gt;u.value);
<span class="lineNum">     820 </span>            : 
<span class="lineNum">     821 </span>            :               /* Clear out the C_RID_CODE so we don't warn about this
<span class="lineNum">     822 </span>            :                  particular identifier-turned-keyword again.  */
<span class="lineNum">     823 </span><span class="lineCov">          2 :               C_SET_RID_CODE (token-&gt;u.value, RID_MAX);</span>
<span class="lineNum">     824 </span>            :             }
<span class="lineNum">     825 </span>            : 
<span class="lineNum">     826 </span><span class="lineCov">  128928078 :           token-&gt;keyword = RID_MAX;</span>
<span class="lineNum">     827 </span>            :         }
<span class="lineNum">     828 </span>            :     }
<span class="lineNum">     829 </span><span class="lineCov">  238924071 :   else if (token-&gt;type == CPP_AT_NAME)</span>
<span class="lineNum">     830 </span>            :     {
<span class="lineNum">     831 </span>            :       /* This only happens in Objective-C++; it must be a keyword.  */
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :       token-&gt;type = CPP_KEYWORD;</span>
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :       switch (C_RID_CODE (token-&gt;u.value))</span>
<span class="lineNum">     834 </span>            :         {
<span class="lineNum">     835 </span>            :           /* Replace 'class' with '@class', 'private' with '@private',
<span class="lineNum">     836 </span>            :              etc.  This prevents confusion with the C++ keyword
<span class="lineNum">     837 </span>            :              'class', and makes the tokens consistent with other
<span class="lineNum">     838 </span>            :              Objective-C 'AT' keywords.  For example '@class' is
<span class="lineNum">     839 </span>            :              reported as RID_AT_CLASS which is consistent with
<span class="lineNum">     840 </span>            :              '@synchronized', which is reported as
<span class="lineNum">     841 </span>            :              RID_AT_SYNCHRONIZED.
<span class="lineNum">     842 </span>            :           */
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :         case RID_CLASS:     token-&gt;keyword = RID_AT_CLASS; break;</span>
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :         case RID_PRIVATE:   token-&gt;keyword = RID_AT_PRIVATE; break;</span>
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :         case RID_PROTECTED: token-&gt;keyword = RID_AT_PROTECTED; break;</span>
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :         case RID_PUBLIC:    token-&gt;keyword = RID_AT_PUBLIC; break;</span>
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :         case RID_THROW:     token-&gt;keyword = RID_AT_THROW; break;</span>
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :         case RID_TRY:       token-&gt;keyword = RID_AT_TRY; break;</span>
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :         case RID_CATCH:     token-&gt;keyword = RID_AT_CATCH; break;</span>
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :         case RID_SYNCHRONIZED: token-&gt;keyword = RID_AT_SYNCHRONIZED; break;</span>
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :         default:            token-&gt;keyword = C_RID_CODE (token-&gt;u.value);</span>
<span class="lineNum">     852 </span>            :         }
<span class="lineNum">     853 </span>            :     }
<span class="lineNum">     854 </span><span class="lineCov">  445813492 : }</span>
<span class="lineNum">     855 </span>            : 
<span class="lineNum">     856 </span>            : /* Update the globals input_location and the input file stack from TOKEN.  */
<span class="lineNum">     857 </span>            : static inline void
<span class="lineNum">     858 </span>            : cp_lexer_set_source_position_from_token (cp_token *token)
<span class="lineNum">     859 </span>            : {
<span class="lineNum">     860 </span><span class="lineCov">  827239723 :   if (token-&gt;type != CPP_EOF)</span>
<span class="lineNum">     861 </span>            :     {
<span class="lineNum">     862 </span><span class="lineCov">  827147943 :       input_location = token-&gt;location;</span>
<span class="lineNum">     863 </span>            :     }
<span class="lineNum">     864 </span>            : }
<span class="lineNum">     865 </span>            : 
<span class="lineNum">     866 </span>            : /* Update the globals input_location and the input file stack from LEXER.  */
<span class="lineNum">     867 </span>            : static inline void
<span class="lineNum">     868 </span>            : cp_lexer_set_source_position (cp_lexer *lexer)
<span class="lineNum">     869 </span>            : {
<span class="lineNum">     870 </span><span class="lineCov">     183000 :   cp_token *token = cp_lexer_peek_token (lexer);</span>
<span class="lineNum">     871 </span><span class="lineCov">     183000 :   cp_lexer_set_source_position_from_token (token);</span>
<span class="lineNum">     872 </span>            : }
<span class="lineNum">     873 </span>            : 
<span class="lineNum">     874 </span>            : /* Return a pointer to the next token in the token stream, but do not
<span class="lineNum">     875 </span>            :    consume it.  */
<a name="876"><span class="lineNum">     876 </span>            : </a>
<span class="lineNum">     877 </span>            : static inline cp_token *
<span class="lineNum">     878 </span><span class="lineNoCov">          0 : cp_lexer_peek_token (cp_lexer *lexer)</span>
<span class="lineNum">     879 </span>            : {
<span class="lineNum">     880 </span><span class="lineCov"> 4811812683 :   if (cp_lexer_debugging_p (lexer))</span>
<span class="lineNum">     881 </span>            :     {
<span class="lineNum">     882 </span>            :       fputs (&quot;cp_lexer: peeking at token: &quot;, cp_lexer_debug_stream);
<span class="lineNum">     883 </span>            :       cp_lexer_print_token (cp_lexer_debug_stream, lexer-&gt;next_token);
<span class="lineNum">     884 </span>            :       putc ('\n', cp_lexer_debug_stream);
<span class="lineNum">     885 </span>            :     }
<span class="lineNum">     886 </span><span class="lineCov"> 4811812683 :   return lexer-&gt;next_token;</span>
<span class="lineNum">     887 </span>            : }
<span class="lineNum">     888 </span>            : 
<span class="lineNum">     889 </span>            : /* Return true if the next token has the indicated TYPE.  */
<span class="lineNum">     890 </span>            : 
<span class="lineNum">     891 </span>            : static inline bool
<span class="lineNum">     892 </span>            : cp_lexer_next_token_is (cp_lexer* lexer, enum cpp_ttype type)
<span class="lineNum">     893 </span>            : {
<span class="lineNum">     894 </span><span class="lineCov"> 2439271978 :   return cp_lexer_peek_token (lexer)-&gt;type == type;</span>
<span class="lineNum">     895 </span>            : }
<span class="lineNum">     896 </span>            : 
<span class="lineNum">     897 </span>            : /* Return true if the next token does not have the indicated TYPE.  */
<span class="lineNum">     898 </span>            : 
<span class="lineNum">     899 </span>            : static inline bool
<span class="lineNum">     900 </span>            : cp_lexer_next_token_is_not (cp_lexer* lexer, enum cpp_ttype type)
<span class="lineNum">     901 </span>            : {
<span class="lineNum">     902 </span><span class="lineCov">  319951824 :   return !cp_lexer_next_token_is (lexer, type);</span>
<span class="lineNum">     903 </span>            : }
<span class="lineNum">     904 </span>            : 
<span class="lineNum">     905 </span>            : /* Return true if the next token is the indicated KEYWORD.  */
<span class="lineNum">     906 </span>            : 
<span class="lineNum">     907 </span>            : static inline bool
<span class="lineNum">     908 </span>            : cp_lexer_next_token_is_keyword (cp_lexer* lexer, enum rid keyword)
<span class="lineNum">     909 </span>            : {
<span class="lineNum">     910 </span><span class="lineCov">  380266630 :   return cp_lexer_peek_token (lexer)-&gt;keyword == keyword;</span>
<span class="lineNum">     911 </span>            : }
<span class="lineNum">     912 </span>            : 
<span class="lineNum">     913 </span>            : static inline bool
<span class="lineNum">     914 </span>            : cp_lexer_nth_token_is (cp_lexer* lexer, size_t n, enum cpp_ttype type)
<span class="lineNum">     915 </span>            : {
<span class="lineNum">     916 </span><span class="lineCov">   85639696 :   return cp_lexer_peek_nth_token (lexer, n)-&gt;type == type;</span>
<span class="lineNum">     917 </span>            : }
<span class="lineNum">     918 </span>            : 
<span class="lineNum">     919 </span>            : static inline bool
<span class="lineNum">     920 </span>            : cp_lexer_nth_token_is_keyword (cp_lexer* lexer, size_t n, enum rid keyword)
<span class="lineNum">     921 </span>            : {
<span class="lineNum">     922 </span><span class="lineCov">      67933 :   return cp_lexer_peek_nth_token (lexer, n)-&gt;keyword == keyword;</span>
<span class="lineNum">     923 </span>            : }
<span class="lineNum">     924 </span>            : 
<span class="lineNum">     925 </span>            : /* Return true if the next token is not the indicated KEYWORD.  */
<span class="lineNum">     926 </span>            : 
<span class="lineNum">     927 </span>            : static inline bool
<span class="lineNum">     928 </span>            : cp_lexer_next_token_is_not_keyword (cp_lexer* lexer, enum rid keyword)
<span class="lineNum">     929 </span>            : {
<span class="lineNum">     930 </span>            :   return cp_lexer_peek_token (lexer)-&gt;keyword != keyword;
<span class="lineNum">     931 </span>            : }
<span class="lineNum">     932 </span>            : 
<span class="lineNum">     933 </span>            : /* Return true if KEYWORD can start a decl-specifier.  */
<a name="934"><span class="lineNum">     934 </span>            : </a>
<span class="lineNum">     935 </span>            : bool
<span class="lineNum">     936 </span><span class="lineCov">     997296 : cp_keyword_starts_decl_specifier_p (enum rid keyword)</span>
<span class="lineNum">     937 </span>            : {
<span class="lineNum">     938 </span><span class="lineCov">     997296 :   switch (keyword)</span>
<span class="lineNum">     939 </span>            :     {
<span class="lineNum">     940 </span>            :       /* auto specifier: storage-class-specifier in C++,
<span class="lineNum">     941 </span>            :          simple-type-specifier in C++0x.  */
<span class="lineNum">     942 </span>            :     case RID_AUTO:
<span class="lineNum">     943 </span>            :       /* Storage classes.  */
<span class="lineNum">     944 </span>            :     case RID_REGISTER:
<span class="lineNum">     945 </span>            :     case RID_STATIC:
<span class="lineNum">     946 </span>            :     case RID_EXTERN:
<span class="lineNum">     947 </span>            :     case RID_MUTABLE:
<span class="lineNum">     948 </span>            :     case RID_THREAD:
<span class="lineNum">     949 </span>            :       /* Elaborated type specifiers.  */
<span class="lineNum">     950 </span>            :     case RID_ENUM:
<span class="lineNum">     951 </span>            :     case RID_CLASS:
<span class="lineNum">     952 </span>            :     case RID_STRUCT:
<span class="lineNum">     953 </span>            :     case RID_UNION:
<span class="lineNum">     954 </span>            :     case RID_TYPENAME:
<span class="lineNum">     955 </span>            :       /* Simple type specifiers.  */
<span class="lineNum">     956 </span>            :     case RID_CHAR:
<span class="lineNum">     957 </span>            :     case RID_CHAR16:
<span class="lineNum">     958 </span>            :     case RID_CHAR32:
<span class="lineNum">     959 </span>            :     case RID_WCHAR:
<span class="lineNum">     960 </span>            :     case RID_BOOL:
<span class="lineNum">     961 </span>            :     case RID_SHORT:
<span class="lineNum">     962 </span>            :     case RID_INT:
<span class="lineNum">     963 </span>            :     case RID_LONG:
<span class="lineNum">     964 </span>            :     case RID_SIGNED:
<span class="lineNum">     965 </span>            :     case RID_UNSIGNED:
<span class="lineNum">     966 </span>            :     case RID_FLOAT:
<span class="lineNum">     967 </span>            :     case RID_DOUBLE:
<span class="lineNum">     968 </span>            :     case RID_VOID:
<span class="lineNum">     969 </span>            :       /* GNU extensions.  */ 
<span class="lineNum">     970 </span>            :     case RID_ATTRIBUTE:
<span class="lineNum">     971 </span>            :     case RID_TYPEOF:
<span class="lineNum">     972 </span>            :       /* C++0x extensions.  */
<span class="lineNum">     973 </span>            :     case RID_DECLTYPE:
<span class="lineNum">     974 </span>            :     case RID_UNDERLYING_TYPE:
<span class="lineNum">     975 </span>            :     case RID_CONSTEXPR:
<span class="lineNum">     976 </span>            :       return true;
<span class="lineNum">     977 </span>            : 
<span class="lineNum">     978 </span><span class="lineCov">     917667 :     default:</span>
<span class="lineNum">     979 </span><span class="lineCov">     917667 :       if (keyword &gt;= RID_FIRST_INT_N</span>
<span class="lineNum">     980 </span>            :           &amp;&amp; keyword &lt; RID_FIRST_INT_N + NUM_INT_N_ENTS
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :           &amp;&amp; int_n_enabled_p[keyword - RID_FIRST_INT_N])</span>
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">     983 </span>            :       return false;
<span class="lineNum">     984 </span>            :     }
<span class="lineNum">     985 </span>            : }
<span class="lineNum">     986 </span>            : 
<span class="lineNum">     987 </span>            : /* Return true if the next token is a keyword for a decl-specifier.  */
<a name="988"><span class="lineNum">     988 </span>            : </a>
<span class="lineNum">     989 </span>            : static bool
<span class="lineNum">     990 </span><span class="lineNoCov">          0 : cp_lexer_next_token_is_decl_specifier_keyword (cp_lexer *lexer)</span>
<span class="lineNum">     991 </span>            : {
<span class="lineNum">     992 </span><span class="lineCov">     741986 :   cp_token *token;</span>
<span class="lineNum">     993 </span>            : 
<span class="lineNum">     994 </span><span class="lineCov">    1483972 :   token = cp_lexer_peek_token (lexer);</span>
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :   return cp_keyword_starts_decl_specifier_p (token-&gt;keyword);</span>
<span class="lineNum">     996 </span>            : }
<span class="lineNum">     997 </span>            : 
<span class="lineNum">     998 </span>            : /* Returns TRUE iff the token T begins a decltype type.  */
<a name="999"><span class="lineNum">     999 </span>            : </a>
<span class="lineNum">    1000 </span>            : static bool
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 : token_is_decltype (cp_token *t)</span>
<span class="lineNum">    1002 </span>            : {
<span class="lineNum">    1003 </span><span class="lineCov">  290044780 :   return (t-&gt;keyword == RID_DECLTYPE</span>
<span class="lineNum">    1004 </span><span class="lineCov">  290044106 :           || t-&gt;type == CPP_DECLTYPE);</span>
<span class="lineNum">    1005 </span>            : }
<span class="lineNum">    1006 </span>            : 
<span class="lineNum">    1007 </span>            : /* Returns TRUE iff the next token begins a decltype type.  */
<a name="1008"><span class="lineNum">    1008 </span>            : </a>
<span class="lineNum">    1009 </span>            : static bool
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 : cp_lexer_next_token_is_decltype (cp_lexer *lexer)</span>
<span class="lineNum">    1011 </span>            : {
<span class="lineNum">    1012 </span><span class="lineCov">   38189384 :   cp_token *t = cp_lexer_peek_token (lexer);</span>
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :   return token_is_decltype (t);</span>
<span class="lineNum">    1014 </span>            : }
<span class="lineNum">    1015 </span>            : 
<span class="lineNum">    1016 </span>            : /* Called when processing a token with tree_check_value; perform or defer the
<span class="lineNum">    1017 </span>            :    associated checks and return the value.  */
<a name="1018"><span class="lineNum">    1018 </span>            : </a>
<span class="lineNum">    1019 </span>            : static tree
<span class="lineNum">    1020 </span><span class="lineCov">   18909458 : saved_checks_value (struct tree_check *check_value)</span>
<span class="lineNum">    1021 </span>            : {
<span class="lineNum">    1022 </span>            :   /* Perform any access checks that were deferred.  */
<span class="lineNum">    1023 </span><span class="lineCov">   18909458 :   vec&lt;deferred_access_check, va_gc&gt; *checks;</span>
<span class="lineNum">    1024 </span><span class="lineCov">   18909458 :   deferred_access_check *chk;</span>
<span class="lineNum">    1025 </span><span class="lineCov">   18909458 :   checks = check_value-&gt;checks;</span>
<span class="lineNum">    1026 </span><span class="lineCov">   18909458 :   if (checks)</span>
<span class="lineNum">    1027 </span>            :     {
<span class="lineNum">    1028 </span>            :       int i;
<span class="lineNum">    1029 </span><span class="lineCov">     199331 :       FOR_EACH_VEC_SAFE_ELT (checks, i, chk)</span>
<span class="lineNum">    1030 </span><span class="lineCov">     139409 :         perform_or_defer_access_check (chk-&gt;binfo,</span>
<span class="lineNum">    1031 </span>            :                                        chk-&gt;decl,
<span class="lineNum">    1032 </span>            :                                        chk-&gt;diag_decl, tf_warning_or_error);
<span class="lineNum">    1033 </span>            :     }
<span class="lineNum">    1034 </span>            :   /* Return the stored value.  */
<span class="lineNum">    1035 </span><span class="lineCov">   18909458 :   return check_value-&gt;value;</span>
<span class="lineNum">    1036 </span>            : }
<span class="lineNum">    1037 </span>            : 
<span class="lineNum">    1038 </span>            : /* Return a pointer to the Nth token in the token stream.  If N is 1,
<span class="lineNum">    1039 </span>            :    then this is precisely equivalent to cp_lexer_peek_token (except
<span class="lineNum">    1040 </span>            :    that it is not inline).  One would like to disallow that case, but
<span class="lineNum">    1041 </span>            :    there is one case (cp_parser_nth_token_starts_template_id) where
<span class="lineNum">    1042 </span>            :    the caller passes a variable for N and it might be 1.  */
<a name="1043"><span class="lineNum">    1043 </span>            : </a>
<span class="lineNum">    1044 </span>            : static cp_token *
<span class="lineNum">    1045 </span><span class="lineCov"> 1056734435 : cp_lexer_peek_nth_token (cp_lexer* lexer, size_t n)</span>
<span class="lineNum">    1046 </span>            : {
<span class="lineNum">    1047 </span><span class="lineCov"> 1056734435 :   cp_token *token;</span>
<span class="lineNum">    1048 </span>            : 
<span class="lineNum">    1049 </span>            :   /* N is 1-based, not zero-based.  */
<span class="lineNum">    1050 </span><span class="lineCov"> 1056734435 :   gcc_assert (n &gt; 0);</span>
<span class="lineNum">    1051 </span>            : 
<span class="lineNum">    1052 </span><span class="lineCov"> 1056734435 :   if (cp_lexer_debugging_p (lexer))</span>
<span class="lineNum">    1053 </span>            :     fprintf (cp_lexer_debug_stream,
<span class="lineNum">    1054 </span>            :              &quot;cp_lexer: peeking ahead %ld at token: &quot;, (long)n);
<span class="lineNum">    1055 </span>            : 
<span class="lineNum">    1056 </span><span class="lineCov"> 1056734435 :   --n;</span>
<span class="lineNum">    1057 </span><span class="lineCov"> 1056734435 :   token = lexer-&gt;next_token;</span>
<span class="lineNum">    1058 </span><span class="lineCov"> 1056734435 :   gcc_assert (!n || token != &amp;eof_token);</span>
<span class="lineNum">    1059 </span><span class="lineCov"> 1815435184 :   while (n != 0)</span>
<span class="lineNum">    1060 </span>            :     {
<span class="lineNum">    1061 </span><span class="lineCov">  759259325 :       ++token;</span>
<span class="lineNum">    1062 </span><span class="lineCov">  759259325 :       if (token == lexer-&gt;last_token)</span>
<span class="lineNum">    1063 </span>            :         {
<span class="lineNum">    1064 </span>            :           token = &amp;eof_token;
<span class="lineNum">    1065 </span>            :           break;
<span class="lineNum">    1066 </span>            :         }
<span class="lineNum">    1067 </span>            : 
<span class="lineNum">    1068 </span><span class="lineCov">  758700749 :       if (!token-&gt;purged_p)</span>
<span class="lineNum">    1069 </span><span class="lineCov">  711504790 :         --n;</span>
<span class="lineNum">    1070 </span>            :     }
<span class="lineNum">    1071 </span>            : 
<span class="lineNum">    1072 </span><span class="lineCov"> 1056734435 :   if (cp_lexer_debugging_p (lexer))</span>
<span class="lineNum">    1073 </span>            :     {
<span class="lineNum">    1074 </span>            :       cp_lexer_print_token (cp_lexer_debug_stream, token);
<span class="lineNum">    1075 </span>            :       putc ('\n', cp_lexer_debug_stream);
<span class="lineNum">    1076 </span>            :     }
<span class="lineNum">    1077 </span>            : 
<span class="lineNum">    1078 </span><span class="lineCov"> 1056734435 :   return token;</span>
<span class="lineNum">    1079 </span>            : }
<span class="lineNum">    1080 </span>            : 
<span class="lineNum">    1081 </span>            : /* Return the next token, and advance the lexer's next_token pointer
<span class="lineNum">    1082 </span>            :    to point to the next non-purged token.  */
<a name="1083"><span class="lineNum">    1083 </span>            : </a>
<span class="lineNum">    1084 </span>            : static cp_token *
<span class="lineNum">    1085 </span><span class="lineCov">  820513203 : cp_lexer_consume_token (cp_lexer* lexer)</span>
<span class="lineNum">    1086 </span>            : {
<span class="lineNum">    1087 </span><span class="lineCov">  820513203 :   cp_token *token = lexer-&gt;next_token;</span>
<span class="lineNum">    1088 </span>            : 
<span class="lineNum">    1089 </span><span class="lineCov">  820513203 :   gcc_assert (token != &amp;eof_token);</span>
<span class="lineNum">    1090 </span><span class="lineCov">  820513203 :   gcc_assert (!lexer-&gt;in_pragma || token-&gt;type != CPP_PRAGMA_EOL);</span>
<span class="lineNum">    1091 </span>            : 
<span class="lineNum">    1092 </span><span class="lineCov">  903041054 :   do</span>
<span class="lineNum">    1093 </span>            :     {
<span class="lineNum">    1094 </span><span class="lineCov">  903041054 :       lexer-&gt;next_token++;</span>
<span class="lineNum">    1095 </span><span class="lineCov">  903041054 :       if (lexer-&gt;next_token == lexer-&gt;last_token)</span>
<span class="lineNum">    1096 </span>            :         {
<span class="lineNum">    1097 </span><span class="lineCov">    3542164 :           lexer-&gt;next_token = &amp;eof_token;</span>
<span class="lineNum">    1098 </span><span class="lineCov">    3542164 :           break;</span>
<span class="lineNum">    1099 </span>            :         }
<span class="lineNum">    1100 </span>            : 
<span class="lineNum">    1101 </span>            :     }
<span class="lineNum">    1102 </span><span class="lineCov">  899498890 :   while (lexer-&gt;next_token-&gt;purged_p);</span>
<span class="lineNum">    1103 </span>            : 
<span class="lineNum">    1104 </span><span class="lineCov">  820513203 :   cp_lexer_set_source_position_from_token (token);</span>
<span class="lineNum">    1105 </span>            : 
<span class="lineNum">    1106 </span>            :   /* Provide debugging output.  */
<span class="lineNum">    1107 </span><span class="lineCov">  820513203 :   if (cp_lexer_debugging_p (lexer))</span>
<span class="lineNum">    1108 </span>            :     {
<span class="lineNum">    1109 </span>            :       fputs (&quot;cp_lexer: consuming token: &quot;, cp_lexer_debug_stream);
<span class="lineNum">    1110 </span>            :       cp_lexer_print_token (cp_lexer_debug_stream, token);
<span class="lineNum">    1111 </span>            :       putc ('\n', cp_lexer_debug_stream);
<span class="lineNum">    1112 </span>            :     }
<span class="lineNum">    1113 </span>            : 
<span class="lineNum">    1114 </span><span class="lineCov">  820513203 :   return token;</span>
<span class="lineNum">    1115 </span>            : }
<span class="lineNum">    1116 </span>            : 
<span class="lineNum">    1117 </span>            : /* Permanently remove the next token from the token stream, and
<span class="lineNum">    1118 </span>            :    advance the next_token pointer to refer to the next non-purged
<span class="lineNum">    1119 </span>            :    token.  */
<a name="1120"><span class="lineNum">    1120 </span>            : </a>
<span class="lineNum">    1121 </span>            : static void
<span class="lineNum">    1122 </span><span class="lineCov">         34 : cp_lexer_purge_token (cp_lexer *lexer)</span>
<span class="lineNum">    1123 </span>            : {
<span class="lineNum">    1124 </span><span class="lineCov">         34 :   cp_token *tok = lexer-&gt;next_token;</span>
<span class="lineNum">    1125 </span>            : 
<span class="lineNum">    1126 </span><span class="lineCov">         34 :   gcc_assert (tok != &amp;eof_token);</span>
<span class="lineNum">    1127 </span><span class="lineCov">         34 :   tok-&gt;purged_p = true;</span>
<span class="lineNum">    1128 </span><span class="lineCov">         34 :   tok-&gt;location = UNKNOWN_LOCATION;</span>
<span class="lineNum">    1129 </span><span class="lineCov">         34 :   tok-&gt;u.value = NULL_TREE;</span>
<span class="lineNum">    1130 </span><span class="lineCov">         34 :   tok-&gt;keyword = RID_MAX;</span>
<span class="lineNum">    1131 </span>            : 
<span class="lineNum">    1132 </span><span class="lineCov">         34 :   do</span>
<span class="lineNum">    1133 </span>            :     {
<span class="lineNum">    1134 </span><span class="lineCov">         34 :       tok++;</span>
<span class="lineNum">    1135 </span><span class="lineCov">         34 :       if (tok == lexer-&gt;last_token)</span>
<span class="lineNum">    1136 </span>            :         {
<span class="lineNum">    1137 </span>            :           tok = &amp;eof_token;
<span class="lineNum">    1138 </span>            :           break;
<span class="lineNum">    1139 </span>            :         }
<span class="lineNum">    1140 </span>            :     }
<span class="lineNum">    1141 </span><span class="lineCov">         34 :   while (tok-&gt;purged_p);</span>
<span class="lineNum">    1142 </span><span class="lineCov">         34 :   lexer-&gt;next_token = tok;</span>
<span class="lineNum">    1143 </span><span class="lineCov">         34 : }</span>
<span class="lineNum">    1144 </span>            : 
<span class="lineNum">    1145 </span>            : /* Permanently remove all tokens after TOK, up to, but not
<span class="lineNum">    1146 </span>            :    including, the token that will be returned next by
<span class="lineNum">    1147 </span>            :    cp_lexer_peek_token.  */
<a name="1148"><span class="lineNum">    1148 </span>            : </a>
<span class="lineNum">    1149 </span>            : static void
<span class="lineNum">    1150 </span><span class="lineCov">   17937652 : cp_lexer_purge_tokens_after (cp_lexer *lexer, cp_token *tok)</span>
<span class="lineNum">    1151 </span>            : {
<span class="lineNum">    1152 </span><span class="lineCov">   17937652 :   cp_token *peek = lexer-&gt;next_token;</span>
<span class="lineNum">    1153 </span>            : 
<span class="lineNum">    1154 </span><span class="lineCov">   17937652 :   if (peek == &amp;eof_token)</span>
<span class="lineNum">    1155 </span><span class="lineCov">        885 :     peek = lexer-&gt;last_token;</span>
<span class="lineNum">    1156 </span>            : 
<span class="lineNum">    1157 </span><span class="lineCov">   17937652 :   gcc_assert (tok &lt; peek);</span>
<span class="lineNum">    1158 </span>            : 
<span class="lineNum">    1159 </span><span class="lineCov">   97646214 :   for ( tok += 1; tok != peek; tok += 1)</span>
<span class="lineNum">    1160 </span>            :     {
<span class="lineNum">    1161 </span><span class="lineCov">   79708562 :       tok-&gt;purged_p = true;</span>
<span class="lineNum">    1162 </span><span class="lineCov">   79708562 :       tok-&gt;location = UNKNOWN_LOCATION;</span>
<span class="lineNum">    1163 </span><span class="lineCov">   79708562 :       tok-&gt;u.value = NULL_TREE;</span>
<span class="lineNum">    1164 </span><span class="lineCov">   79708562 :       tok-&gt;keyword = RID_MAX;</span>
<span class="lineNum">    1165 </span>            :     }
<span class="lineNum">    1166 </span><span class="lineCov">   17937652 : }</span>
<span class="lineNum">    1167 </span>            : 
<span class="lineNum">    1168 </span>            : /* Begin saving tokens.  All tokens consumed after this point will be
<span class="lineNum">    1169 </span>            :    preserved.  */
<a name="1170"><span class="lineNum">    1170 </span>            : </a>
<span class="lineNum">    1171 </span>            : static void
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 : cp_lexer_save_tokens (cp_lexer* lexer)</span>
<span class="lineNum">    1173 </span>            : {
<span class="lineNum">    1174 </span>            :   /* Provide debugging output.  */
<span class="lineNum">    1175 </span><span class="lineCov">  662901439 :   if (cp_lexer_debugging_p (lexer))</span>
<span class="lineNum">    1176 </span>            :     fprintf (cp_lexer_debug_stream, &quot;cp_lexer: saving tokens\n&quot;);
<span class="lineNum">    1177 </span>            : 
<span class="lineNum">    1178 </span><span class="lineNoCov">          0 :   lexer-&gt;saved_tokens.safe_push (lexer-&gt;next_token);</span>
<span class="lineNum">    1179 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1180 </span>            : 
<span class="lineNum">    1181 </span>            : /* Commit to the portion of the token stream most recently saved.  */
<a name="1182"><span class="lineNum">    1182 </span>            : </a>
<span class="lineNum">    1183 </span>            : static void
<span class="lineNum">    1184 </span><span class="lineCov">  170083690 : cp_lexer_commit_tokens (cp_lexer* lexer)</span>
<span class="lineNum">    1185 </span>            : {
<span class="lineNum">    1186 </span>            :   /* Provide debugging output.  */
<span class="lineNum">    1187 </span><span class="lineCov">  170083690 :   if (cp_lexer_debugging_p (lexer))</span>
<span class="lineNum">    1188 </span>            :     fprintf (cp_lexer_debug_stream, &quot;cp_lexer: committing tokens\n&quot;);
<span class="lineNum">    1189 </span>            : 
<span class="lineNum">    1190 </span><span class="lineCov">  170083690 :   lexer-&gt;saved_tokens.pop ();</span>
<span class="lineNum">    1191 </span><span class="lineCov">  170083690 : }</span>
<span class="lineNum">    1192 </span>            : 
<span class="lineNum">    1193 </span>            : /* Return all tokens saved since the last call to cp_lexer_save_tokens
<span class="lineNum">    1194 </span>            :    to the token stream.  Stop saving tokens.  */
<a name="1195"><span class="lineNum">    1195 </span>            : </a>
<span class="lineNum">    1196 </span>            : static void
<span class="lineNum">    1197 </span><span class="lineCov">  492817724 : cp_lexer_rollback_tokens (cp_lexer* lexer)</span>
<span class="lineNum">    1198 </span>            : {
<span class="lineNum">    1199 </span>            :   /* Provide debugging output.  */
<span class="lineNum">    1200 </span><span class="lineCov">  492817724 :   if (cp_lexer_debugging_p (lexer))</span>
<span class="lineNum">    1201 </span>            :     fprintf (cp_lexer_debug_stream, &quot;cp_lexer: restoring tokens\n&quot;);
<span class="lineNum">    1202 </span>            : 
<span class="lineNum">    1203 </span><span class="lineCov">  492817724 :   lexer-&gt;next_token = lexer-&gt;saved_tokens.pop ();</span>
<span class="lineNum">    1204 </span><span class="lineCov">  492817724 : }</span>
<span class="lineNum">    1205 </span>            : 
<span class="lineNum">    1206 </span>            : /* RAII wrapper around the above functions, with sanity checking.  Creating
<span class="lineNum">    1207 </span>            :    a variable saves tokens, which are committed when the variable is
<span class="lineNum">    1208 </span>            :    destroyed unless they are explicitly rolled back by calling the rollback
<span class="lineNum">    1209 </span>            :    member function.  */
<span class="lineNum">    1210 </span>            : 
<span class="lineNum">    1211 </span>            : struct saved_token_sentinel
<span class="lineNum">    1212 </span>            : {
<span class="lineNum">    1213 </span>            :   cp_lexer *lexer;
<span class="lineNum">    1214 </span>            :   unsigned len;
<span class="lineNum">    1215 </span>            :   bool commit;
<span class="lineNum">    1216 </span><span class="lineCov">   13955614 :   saved_token_sentinel(cp_lexer *lexer): lexer(lexer), commit(true)</span>
<span class="lineNum">    1217 </span>            :   {
<span class="lineNum">    1218 </span><span class="lineCov">   27911228 :     len = lexer-&gt;saved_tokens.length ();</span>
<a name="1219"><span class="lineNum">    1219 </span><span class="lineCov">   13955614 :     cp_lexer_save_tokens (lexer);</span></a>
<span class="lineNum">    1220 </span>            :   }
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :   void rollback ()</span>
<span class="lineNum">    1222 </span>            :   {
<span class="lineNum">    1223 </span><span class="lineNoCov">          0 :     cp_lexer_rollback_tokens (lexer);</span>
<a name="1224"><span class="lineNum">    1224 </span><span class="lineCov">        746 :     commit = false;</span></a>
<span class="lineNum">    1225 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1226 </span><span class="lineCov">   13955595 :   ~saved_token_sentinel()</span>
<span class="lineNum">    1227 </span><span class="lineCov">   13955595 :   {</span>
<span class="lineNum">    1228 </span><span class="lineCov">   13955595 :     if (commit)</span>
<span class="lineNum">    1229 </span><span class="lineCov">   13954849 :       cp_lexer_commit_tokens (lexer);</span>
<span class="lineNum">    1230 </span><span class="lineCov">   27911190 :     gcc_assert (lexer-&gt;saved_tokens.length () == len);</span>
<span class="lineNum">    1231 </span><span class="lineCov">   13955595 :   }</span>
<span class="lineNum">    1232 </span>            : };
<span class="lineNum">    1233 </span>            : 
<span class="lineNum">    1234 </span>            : /* Print a representation of the TOKEN on the STREAM.  */
<a name="1235"><span class="lineNum">    1235 </span>            : </a>
<span class="lineNum">    1236 </span>            : static void
<span class="lineNum">    1237 </span><span class="lineNoCov">          0 : cp_lexer_print_token (FILE * stream, cp_token *token)</span>
<span class="lineNum">    1238 </span>            : {
<span class="lineNum">    1239 </span>            :   /* We don't use cpp_type2name here because the parser defines
<span class="lineNum">    1240 </span>            :      a few tokens of its own.  */
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :   static const char *const token_names[] = {</span>
<span class="lineNum">    1242 </span>            :     /* cpplib-defined token types */
<span class="lineNum">    1243 </span>            : #define OP(e, s) #e,
<span class="lineNum">    1244 </span>            : #define TK(e, s) #e,
<span class="lineNum">    1245 </span>            :     TTYPE_TABLE
<span class="lineNum">    1246 </span>            : #undef OP
<span class="lineNum">    1247 </span>            : #undef TK
<span class="lineNum">    1248 </span>            :     /* C++ parser token types - see &quot;Manifest constants&quot;, above.  */
<span class="lineNum">    1249 </span>            :     &quot;KEYWORD&quot;,
<span class="lineNum">    1250 </span>            :     &quot;TEMPLATE_ID&quot;,
<span class="lineNum">    1251 </span>            :     &quot;NESTED_NAME_SPECIFIER&quot;,
<span class="lineNum">    1252 </span>            :   };
<span class="lineNum">    1253 </span>            : 
<span class="lineNum">    1254 </span>            :   /* For some tokens, print the associated data.  */
<span class="lineNum">    1255 </span><span class="lineNoCov">          0 :   switch (token-&gt;type)</span>
<span class="lineNum">    1256 </span>            :     {
<span class="lineNum">    1257 </span><span class="lineNoCov">          0 :     case CPP_KEYWORD:</span>
<span class="lineNum">    1258 </span>            :       /* Some keywords have a value that is not an IDENTIFIER_NODE.
<span class="lineNum">    1259 </span>            :          For example, `struct' is mapped to an INTEGER_CST.  */
<span class="lineNum">    1260 </span><span class="lineNoCov">          0 :       if (!identifier_p (token-&gt;u.value))</span>
<span class="lineNum">    1261 </span>            :         break;
<span class="lineNum">    1262 </span>            :       /* fall through */
<span class="lineNum">    1263 </span><span class="lineNoCov">          0 :     case CPP_NAME:</span>
<span class="lineNum">    1264 </span><span class="lineNoCov">          0 :       fputs (IDENTIFIER_POINTER (token-&gt;u.value), stream);</span>
<span class="lineNum">    1265 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1266 </span>            : 
<span class="lineNum">    1267 </span><span class="lineNoCov">          0 :     case CPP_STRING:</span>
<span class="lineNum">    1268 </span><span class="lineNoCov">          0 :     case CPP_STRING16:</span>
<span class="lineNum">    1269 </span><span class="lineNoCov">          0 :     case CPP_STRING32:</span>
<span class="lineNum">    1270 </span><span class="lineNoCov">          0 :     case CPP_WSTRING:</span>
<span class="lineNum">    1271 </span><span class="lineNoCov">          0 :     case CPP_UTF8STRING:</span>
<span class="lineNum">    1272 </span><span class="lineNoCov">          0 :       fprintf (stream, &quot; \&quot;%s\&quot;&quot;, TREE_STRING_POINTER (token-&gt;u.value));</span>
<span class="lineNum">    1273 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1274 </span>            : 
<span class="lineNum">    1275 </span><span class="lineNoCov">          0 :     case CPP_NUMBER:</span>
<span class="lineNum">    1276 </span><span class="lineNoCov">          0 :       print_generic_expr (stream, token-&gt;u.value);</span>
<span class="lineNum">    1277 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1278 </span>            : 
<span class="lineNum">    1279 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">    1280 </span>            :       /* If we have a name for the token, print it out.  Otherwise, we
<span class="lineNum">    1281 </span>            :          simply give the numeric code.  */
<span class="lineNum">    1282 </span><span class="lineNoCov">          0 :       if (token-&gt;type &lt; ARRAY_SIZE(token_names))</span>
<span class="lineNum">    1283 </span><span class="lineNoCov">          0 :         fputs (token_names[token-&gt;type], stream);</span>
<span class="lineNum">    1284 </span>            :       else
<span class="lineNum">    1285 </span><span class="lineNoCov">          0 :         fprintf (stream, &quot;[%d]&quot;, token-&gt;type);</span>
<span class="lineNum">    1286 </span>            :       break;
<span class="lineNum">    1287 </span>            :     }
<span class="lineNum">    1288 </span><span class="lineNoCov">          0 : }</span>
<a name="1289"><span class="lineNum">    1289 </span>            : </a>
<span class="lineNum">    1290 </span>            : DEBUG_FUNCTION void
<span class="lineNum">    1291 </span><span class="lineNoCov">          0 : debug (cp_token &amp;ref)</span>
<span class="lineNum">    1292 </span>            : {
<span class="lineNum">    1293 </span><span class="lineNoCov">          0 :   cp_lexer_print_token (stderr, &amp;ref);</span>
<span class="lineNum">    1294 </span><span class="lineNoCov">          0 :   fprintf (stderr, &quot;\n&quot;);</span>
<span class="lineNum">    1295 </span><span class="lineNoCov">          0 : }</span>
<a name="1296"><span class="lineNum">    1296 </span>            : </a>
<span class="lineNum">    1297 </span>            : DEBUG_FUNCTION void
<span class="lineNum">    1298 </span><span class="lineNoCov">          0 : debug (cp_token *ptr)</span>
<span class="lineNum">    1299 </span>            : {
<span class="lineNum">    1300 </span><span class="lineNoCov">          0 :   if (ptr)</span>
<span class="lineNum">    1301 </span><span class="lineNoCov">          0 :     debug (*ptr);</span>
<span class="lineNum">    1302 </span>            :   else
<span class="lineNum">    1303 </span><span class="lineNoCov">          0 :     fprintf (stderr, &quot;&lt;nil&gt;\n&quot;);</span>
<span class="lineNum">    1304 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1305 </span>            : 
<span class="lineNum">    1306 </span>            : 
<span class="lineNum">    1307 </span>            : /* Start emitting debugging information.  */
<a name="1308"><span class="lineNum">    1308 </span>            : </a>
<span class="lineNum">    1309 </span>            : static void
<span class="lineNum">    1310 </span><span class="lineNoCov">          0 : cp_lexer_start_debugging (cp_lexer* lexer)</span>
<span class="lineNum">    1311 </span>            : {
<span class="lineNum">    1312 </span><span class="lineNoCov">          0 :   if (!LEXER_DEBUGGING_ENABLED_P)</span>
<span class="lineNum">    1313 </span><span class="lineNoCov">          0 :     fatal_error (input_location,</span>
<span class="lineNum">    1314 </span>            :                  &quot;LEXER_DEBUGGING_ENABLED_P is not set to true&quot;);
<span class="lineNum">    1315 </span>            : 
<span class="lineNum">    1316 </span>            :   lexer-&gt;debugging_p = true;
<span class="lineNum">    1317 </span>            :   cp_lexer_debug_stream = stderr;
<span class="lineNum">    1318 </span>            : }
<span class="lineNum">    1319 </span>            : 
<span class="lineNum">    1320 </span>            : /* Stop emitting debugging information.  */
<a name="1321"><span class="lineNum">    1321 </span>            : </a>
<span class="lineNum">    1322 </span>            : static void
<span class="lineNum">    1323 </span><span class="lineNoCov">          0 : cp_lexer_stop_debugging (cp_lexer* lexer)</span>
<span class="lineNum">    1324 </span>            : {
<span class="lineNum">    1325 </span><span class="lineNoCov">          0 :   if (!LEXER_DEBUGGING_ENABLED_P)</span>
<span class="lineNum">    1326 </span><span class="lineNoCov">          0 :     fatal_error (input_location,</span>
<span class="lineNum">    1327 </span>            :                  &quot;LEXER_DEBUGGING_ENABLED_P is not set to true&quot;);
<span class="lineNum">    1328 </span>            : 
<span class="lineNum">    1329 </span>            :   lexer-&gt;debugging_p = false;
<span class="lineNum">    1330 </span>            :   cp_lexer_debug_stream = NULL;
<span class="lineNum">    1331 </span>            : }
<span class="lineNum">    1332 </span>            : 
<span class="lineNum">    1333 </span>            : /* Create a new cp_token_cache, representing a range of tokens.  */
<a name="1334"><span class="lineNum">    1334 </span>            : </a>
<span class="lineNum">    1335 </span>            : static cp_token_cache *
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 : cp_token_cache_new (cp_token *first, cp_token *last)</span>
<span class="lineNum">    1337 </span>            : {
<span class="lineNum">    1338 </span><span class="lineNoCov">          0 :   cp_token_cache *cache = ggc_alloc&lt;cp_token_cache&gt; ();</span>
<span class="lineNum">    1339 </span><span class="lineCov">    3315877 :   cache-&gt;first = first;</span>
<span class="lineNum">    1340 </span><span class="lineCov">    3315877 :   cache-&gt;last = last;</span>
<span class="lineNum">    1341 </span><span class="lineCov">    3315877 :   return cache;</span>
<span class="lineNum">    1342 </span>            : }
<span class="lineNum">    1343 </span>            : 
<span class="lineNum">    1344 </span>            : /* Diagnose if #pragma omp declare simd isn't followed immediately
<span class="lineNum">    1345 </span>            :    by function declaration or definition.  */
<a name="1346"><span class="lineNum">    1346 </span>            : </a>
<span class="lineNum">    1347 </span>            : static inline void
<span class="lineNum">    1348 </span><span class="lineNoCov">          0 : cp_ensure_no_omp_declare_simd (cp_parser *parser)</span>
<span class="lineNum">    1349 </span>            : {
<span class="lineNum">    1350 </span><span class="lineCov">         24 :   if (parser-&gt;omp_declare_simd &amp;&amp; !parser-&gt;omp_declare_simd-&gt;error_seen)</span>
<span class="lineNum">    1351 </span>            :     {
<span class="lineNum">    1352 </span><span class="lineCov">         24 :       error (&quot;%&lt;#pragma omp declare simd%&gt; not immediately followed by &quot;</span>
<span class="lineNum">    1353 </span>            :              &quot;function declaration or definition&quot;);
<span class="lineNum">    1354 </span><span class="lineCov">         24 :       parser-&gt;omp_declare_simd = NULL;</span>
<span class="lineNum">    1355 </span>            :     }
<span class="lineNum">    1356 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1357 </span>            : 
<span class="lineNum">    1358 </span>            : /* Finalize #pragma omp declare simd clauses after FNDECL has been parsed,
<span class="lineNum">    1359 </span>            :    and put that into &quot;omp declare simd&quot; attribute.  */
<a name="1360"><span class="lineNum">    1360 </span>            : </a>
<span class="lineNum">    1361 </span>            : static inline void
<span class="lineNum">    1362 </span><span class="lineCov">   17142147 : cp_finalize_omp_declare_simd (cp_parser *parser, tree fndecl)</span>
<span class="lineNum">    1363 </span>            : {
<span class="lineNum">    1364 </span><span class="lineCov">   17142147 :   if (__builtin_expect (parser-&gt;omp_declare_simd != NULL, 0))</span>
<span class="lineNum">    1365 </span>            :     {
<span class="lineNum">    1366 </span><span class="lineCov">        518 :       if (fndecl == error_mark_node)</span>
<span class="lineNum">    1367 </span>            :         {
<span class="lineNum">    1368 </span><span class="lineNoCov">          0 :           parser-&gt;omp_declare_simd = NULL;</span>
<span class="lineNum">    1369 </span><span class="lineNoCov">          0 :           return;</span>
<span class="lineNum">    1370 </span>            :         }
<span class="lineNum">    1371 </span><span class="lineCov">        518 :       if (TREE_CODE (fndecl) != FUNCTION_DECL)</span>
<span class="lineNum">    1372 </span>            :         {
<span class="lineNum">    1373 </span><span class="lineCov">          9 :           cp_ensure_no_omp_declare_simd (parser);</span>
<span class="lineNum">    1374 </span><span class="lineCov">          9 :           return;</span>
<span class="lineNum">    1375 </span>            :         }
<span class="lineNum">    1376 </span>            :     }
<span class="lineNum">    1377 </span>            : }
<span class="lineNum">    1378 </span>            : 
<span class="lineNum">    1379 </span>            : /* Diagnose if #pragma acc routine isn't followed immediately by function
<span class="lineNum">    1380 </span>            :    declaration or definition.  */
<a name="1381"><span class="lineNum">    1381 </span>            : </a>
<span class="lineNum">    1382 </span>            : static inline void
<span class="lineNum">    1383 </span><span class="lineNoCov">          0 : cp_ensure_no_oacc_routine (cp_parser *parser)</span>
<span class="lineNum">    1384 </span>            : {
<span class="lineNum">    1385 </span><span class="lineNoCov">          0 :   if (parser-&gt;oacc_routine &amp;&amp; !parser-&gt;oacc_routine-&gt;error_seen)</span>
<span class="lineNum">    1386 </span>            :     {
<span class="lineNum">    1387 </span><span class="lineNoCov">          0 :       error_at (parser-&gt;oacc_routine-&gt;loc,</span>
<span class="lineNum">    1388 </span>            :                 &quot;%&lt;#pragma acc routine%&gt; not immediately followed by &quot;
<span class="lineNum">    1389 </span>            :                 &quot;function declaration or definition&quot;);
<span class="lineNum">    1390 </span><span class="lineNoCov">          0 :       parser-&gt;oacc_routine = NULL;</span>
<span class="lineNum">    1391 </span>            :     }
<span class="lineNum">    1392 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1393 </span>            : 
<span class="lineNum">    1394 </span>            : /* Decl-specifiers.  */
<span class="lineNum">    1395 </span>            : 
<span class="lineNum">    1396 </span>            : /* Set *DECL_SPECS to represent an empty decl-specifier-seq.  */
<a name="1397"><span class="lineNum">    1397 </span>            : </a>
<span class="lineNum">    1398 </span>            : static void
<span class="lineNum">    1399 </span><span class="lineNoCov">          0 : clear_decl_specs (cp_decl_specifier_seq *decl_specs)</span>
<span class="lineNum">    1400 </span>            : {
<span class="lineNum">    1401 </span><span class="lineCov">   64084207 :   memset (decl_specs, 0, sizeof (cp_decl_specifier_seq));</span>
<span class="lineNum">    1402 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1403 </span>            : 
<span class="lineNum">    1404 </span>            : /* Declarators.  */
<span class="lineNum">    1405 </span>            : 
<span class="lineNum">    1406 </span>            : /* Nothing other than the parser should be creating declarators;
<span class="lineNum">    1407 </span>            :    declarators are a semi-syntactic representation of C++ entities.
<span class="lineNum">    1408 </span>            :    Other parts of the front end that need to create entities (like
<span class="lineNum">    1409 </span>            :    VAR_DECLs or FUNCTION_DECLs) should do that directly.  */
<span class="lineNum">    1410 </span>            : 
<span class="lineNum">    1411 </span>            : static cp_declarator *make_call_declarator
<span class="lineNum">    1412 </span>            :   (cp_declarator *, tree, cp_cv_quals, cp_virt_specifiers, cp_ref_qualifier, tree, tree, tree, tree);
<span class="lineNum">    1413 </span>            : static cp_declarator *make_array_declarator
<span class="lineNum">    1414 </span>            :   (cp_declarator *, tree);
<span class="lineNum">    1415 </span>            : static cp_declarator *make_pointer_declarator
<span class="lineNum">    1416 </span>            :   (cp_cv_quals, cp_declarator *, tree);
<span class="lineNum">    1417 </span>            : static cp_declarator *make_reference_declarator
<span class="lineNum">    1418 </span>            :   (cp_cv_quals, cp_declarator *, bool, tree);
<span class="lineNum">    1419 </span>            : static cp_declarator *make_ptrmem_declarator
<span class="lineNum">    1420 </span>            :   (cp_cv_quals, tree, cp_declarator *, tree);
<span class="lineNum">    1421 </span>            : 
<span class="lineNum">    1422 </span>            : /* An erroneous declarator.  */
<span class="lineNum">    1423 </span>            : static cp_declarator *cp_error_declarator;
<span class="lineNum">    1424 </span>            : 
<span class="lineNum">    1425 </span>            : /* The obstack on which declarators and related data structures are
<span class="lineNum">    1426 </span>            :    allocated.  */
<span class="lineNum">    1427 </span>            : static struct obstack declarator_obstack;
<span class="lineNum">    1428 </span>            : 
<span class="lineNum">    1429 </span>            : /* Alloc BYTES from the declarator memory pool.  */
<a name="1430"><span class="lineNum">    1430 </span>            : </a>
<span class="lineNum">    1431 </span>            : static inline void *
<span class="lineNum">    1432 </span><span class="lineCov">   71351825 : alloc_declarator (size_t bytes)</span>
<span class="lineNum">    1433 </span>            : {
<span class="lineNum">    1434 </span><span class="lineCov">   71351825 :   return obstack_alloc (&amp;declarator_obstack, bytes);</span>
<span class="lineNum">    1435 </span>            : }
<span class="lineNum">    1436 </span>            : 
<span class="lineNum">    1437 </span>            : /* Allocate a declarator of the indicated KIND.  Clear fields that are
<span class="lineNum">    1438 </span>            :    common to all declarators.  */
<a name="1439"><span class="lineNum">    1439 </span>            : </a>
<span class="lineNum">    1440 </span>            : static cp_declarator *
<span class="lineNum">    1441 </span><span class="lineNoCov">          0 : make_declarator (cp_declarator_kind kind)</span>
<span class="lineNum">    1442 </span>            : {
<span class="lineNum">    1443 </span><span class="lineCov">   54106193 :   cp_declarator *declarator;</span>
<span class="lineNum">    1444 </span>            : 
<span class="lineNum">    1445 </span><span class="lineNoCov">          0 :   declarator = (cp_declarator *) alloc_declarator (sizeof (cp_declarator));</span>
<span class="lineNum">    1446 </span><span class="lineCov">   54106193 :   declarator-&gt;kind = kind;</span>
<span class="lineNum">    1447 </span><span class="lineCov">   54106193 :   declarator-&gt;parenthesized = UNKNOWN_LOCATION;</span>
<span class="lineNum">    1448 </span><span class="lineCov">   54106193 :   declarator-&gt;attributes = NULL_TREE;</span>
<span class="lineNum">    1449 </span><span class="lineCov">   54106193 :   declarator-&gt;std_attributes = NULL_TREE;</span>
<span class="lineNum">    1450 </span><span class="lineCov">   54106193 :   declarator-&gt;declarator = NULL;</span>
<span class="lineNum">    1451 </span><span class="lineCov">   54106193 :   declarator-&gt;parameter_pack_p = false;</span>
<span class="lineNum">    1452 </span><span class="lineCov">   54106193 :   declarator-&gt;id_loc = UNKNOWN_LOCATION;</span>
<span class="lineNum">    1453 </span>            : 
<span class="lineNum">    1454 </span><span class="lineCov">   54106193 :   return declarator;</span>
<span class="lineNum">    1455 </span>            : }
<span class="lineNum">    1456 </span>            : 
<span class="lineNum">    1457 </span>            : /* Make a declarator for a generalized identifier.  If
<span class="lineNum">    1458 </span>            :    QUALIFYING_SCOPE is non-NULL, the identifier is
<span class="lineNum">    1459 </span>            :    QUALIFYING_SCOPE::UNQUALIFIED_NAME; otherwise, it is just
<span class="lineNum">    1460 </span>            :    UNQUALIFIED_NAME.  SFK indicates the kind of special function this
<span class="lineNum">    1461 </span>            :    is, if any.   */
<a name="1462"><span class="lineNum">    1462 </span>            : </a>
<span class="lineNum">    1463 </span>            : static cp_declarator *
<span class="lineNum">    1464 </span><span class="lineCov">   32518165 : make_id_declarator (tree qualifying_scope, tree unqualified_name,</span>
<span class="lineNum">    1465 </span>            :                     special_function_kind sfk)
<span class="lineNum">    1466 </span>            : {
<span class="lineNum">    1467 </span><span class="lineCov">   32518165 :   cp_declarator *declarator;</span>
<span class="lineNum">    1468 </span>            : 
<span class="lineNum">    1469 </span>            :   /* It is valid to write:
<span class="lineNum">    1470 </span>            : 
<span class="lineNum">    1471 </span>            :        class C { void f(); };
<span class="lineNum">    1472 </span>            :        typedef C D;
<span class="lineNum">    1473 </span>            :        void D::f();
<span class="lineNum">    1474 </span>            : 
<span class="lineNum">    1475 </span>            :      The standard is not clear about whether `typedef const C D' is
<span class="lineNum">    1476 </span>            :      legal; as of 2002-09-15 the committee is considering that
<span class="lineNum">    1477 </span>            :      question.  EDG 3.0 allows that syntax.  Therefore, we do as
<span class="lineNum">    1478 </span>            :      well.  */
<span class="lineNum">    1479 </span><span class="lineCov">   32518165 :   if (qualifying_scope &amp;&amp; TYPE_P (qualifying_scope))</span>
<span class="lineNum">    1480 </span><span class="lineCov">     934172 :     qualifying_scope = TYPE_MAIN_VARIANT (qualifying_scope);</span>
<span class="lineNum">    1481 </span>            : 
<span class="lineNum">    1482 </span><span class="lineCov">   32518165 :   gcc_assert (identifier_p (unqualified_name)</span>
<span class="lineNum">    1483 </span>            :               || TREE_CODE (unqualified_name) == BIT_NOT_EXPR
<span class="lineNum">    1484 </span>            :               || TREE_CODE (unqualified_name) == TEMPLATE_ID_EXPR);
<span class="lineNum">    1485 </span>            : 
<span class="lineNum">    1486 </span><span class="lineCov">   32518165 :   declarator = make_declarator (cdk_id);</span>
<span class="lineNum">    1487 </span><span class="lineCov">   32518165 :   declarator-&gt;u.id.qualifying_scope = qualifying_scope;</span>
<span class="lineNum">    1488 </span><span class="lineCov">   32518165 :   declarator-&gt;u.id.unqualified_name = unqualified_name;</span>
<span class="lineNum">    1489 </span><span class="lineCov">   32518165 :   declarator-&gt;u.id.sfk = sfk;</span>
<span class="lineNum">    1490 </span>            :   
<span class="lineNum">    1491 </span><span class="lineCov">   32518165 :   return declarator;</span>
<span class="lineNum">    1492 </span>            : }
<span class="lineNum">    1493 </span>            : 
<span class="lineNum">    1494 </span>            : /* Make a declarator for a pointer to TARGET.  CV_QUALIFIERS is a list
<span class="lineNum">    1495 </span>            :    of modifiers such as const or volatile to apply to the pointer
<span class="lineNum">    1496 </span>            :    type, represented as identifiers.  ATTRIBUTES represent the attributes that
<span class="lineNum">    1497 </span>            :    appertain to the pointer or reference.  */
<a name="1498"><span class="lineNum">    1498 </span>            : </a>
<span class="lineNum">    1499 </span>            : cp_declarator *
<span class="lineNum">    1500 </span><span class="lineCov">    5921525 : make_pointer_declarator (cp_cv_quals cv_qualifiers, cp_declarator *target,</span>
<span class="lineNum">    1501 </span>            :                          tree attributes)
<span class="lineNum">    1502 </span>            : {
<span class="lineNum">    1503 </span><span class="lineCov">    5921525 :   cp_declarator *declarator;</span>
<span class="lineNum">    1504 </span>            : 
<span class="lineNum">    1505 </span><span class="lineCov">    5921525 :   declarator = make_declarator (cdk_pointer);</span>
<span class="lineNum">    1506 </span><span class="lineCov">    5921525 :   declarator-&gt;declarator = target;</span>
<span class="lineNum">    1507 </span><span class="lineCov">    5921525 :   declarator-&gt;u.pointer.qualifiers = cv_qualifiers;</span>
<span class="lineNum">    1508 </span><span class="lineCov">    5921525 :   declarator-&gt;u.pointer.class_type = NULL_TREE;</span>
<span class="lineNum">    1509 </span><span class="lineCov">    5921525 :   if (target)</span>
<span class="lineNum">    1510 </span>            :     {
<span class="lineNum">    1511 </span><span class="lineCov">    5175605 :       declarator-&gt;id_loc = target-&gt;id_loc;</span>
<span class="lineNum">    1512 </span><span class="lineCov">    5175605 :       declarator-&gt;parameter_pack_p = target-&gt;parameter_pack_p;</span>
<span class="lineNum">    1513 </span><span class="lineCov">    5175605 :       target-&gt;parameter_pack_p = false;</span>
<span class="lineNum">    1514 </span>            :     }
<span class="lineNum">    1515 </span>            :   else
<span class="lineNum">    1516 </span>            :     declarator-&gt;parameter_pack_p = false;
<span class="lineNum">    1517 </span>            : 
<span class="lineNum">    1518 </span><span class="lineCov">    5921525 :   declarator-&gt;std_attributes = attributes;</span>
<span class="lineNum">    1519 </span>            : 
<span class="lineNum">    1520 </span><span class="lineCov">    5921525 :   return declarator;</span>
<span class="lineNum">    1521 </span>            : }
<span class="lineNum">    1522 </span>            : 
<span class="lineNum">    1523 </span>            : /* Like make_pointer_declarator -- but for references.  ATTRIBUTES
<span class="lineNum">    1524 </span>            :    represent the attributes that appertain to the pointer or
<span class="lineNum">    1525 </span>            :    reference.  */
<a name="1526"><span class="lineNum">    1526 </span>            : </a>
<span class="lineNum">    1527 </span>            : cp_declarator *
<span class="lineNum">    1528 </span><span class="lineCov">    4682957 : make_reference_declarator (cp_cv_quals cv_qualifiers, cp_declarator *target,</span>
<span class="lineNum">    1529 </span>            :                            bool rvalue_ref, tree attributes)
<span class="lineNum">    1530 </span>            : {
<span class="lineNum">    1531 </span><span class="lineCov">    4682957 :   cp_declarator *declarator;</span>
<span class="lineNum">    1532 </span>            : 
<span class="lineNum">    1533 </span><span class="lineCov">    4682957 :   declarator = make_declarator (cdk_reference);</span>
<span class="lineNum">    1534 </span><span class="lineCov">    4682957 :   declarator-&gt;declarator = target;</span>
<span class="lineNum">    1535 </span><span class="lineCov">    4682957 :   declarator-&gt;u.reference.qualifiers = cv_qualifiers;</span>
<span class="lineNum">    1536 </span><span class="lineCov">    4682957 :   declarator-&gt;u.reference.rvalue_ref = rvalue_ref;</span>
<span class="lineNum">    1537 </span><span class="lineCov">    4682957 :   if (target)</span>
<span class="lineNum">    1538 </span>            :     {
<span class="lineNum">    1539 </span><span class="lineCov">    3592522 :       declarator-&gt;id_loc = target-&gt;id_loc;</span>
<span class="lineNum">    1540 </span><span class="lineCov">    3592522 :       declarator-&gt;parameter_pack_p = target-&gt;parameter_pack_p;</span>
<span class="lineNum">    1541 </span><span class="lineCov">    3592522 :       target-&gt;parameter_pack_p = false;</span>
<span class="lineNum">    1542 </span>            :     }
<span class="lineNum">    1543 </span>            :   else
<span class="lineNum">    1544 </span>            :     declarator-&gt;parameter_pack_p = false;
<span class="lineNum">    1545 </span>            : 
<span class="lineNum">    1546 </span><span class="lineCov">    4682957 :   declarator-&gt;std_attributes = attributes;</span>
<span class="lineNum">    1547 </span>            : 
<span class="lineNum">    1548 </span><span class="lineCov">    4682957 :   return declarator;</span>
<span class="lineNum">    1549 </span>            : }
<span class="lineNum">    1550 </span>            : 
<span class="lineNum">    1551 </span>            : /* Like make_pointer_declarator -- but for a pointer to a non-static
<span class="lineNum">    1552 </span>            :    member of CLASS_TYPE.  ATTRIBUTES represent the attributes that
<span class="lineNum">    1553 </span>            :    appertain to the pointer or reference.  */
<a name="1554"><span class="lineNum">    1554 </span>            : </a>
<span class="lineNum">    1555 </span>            : cp_declarator *
<span class="lineNum">    1556 </span><span class="lineCov">     101721 : make_ptrmem_declarator (cp_cv_quals cv_qualifiers, tree class_type,</span>
<span class="lineNum">    1557 </span>            :                         cp_declarator *pointee,
<span class="lineNum">    1558 </span>            :                         tree attributes)
<span class="lineNum">    1559 </span>            : {
<span class="lineNum">    1560 </span><span class="lineCov">     101721 :   cp_declarator *declarator;</span>
<span class="lineNum">    1561 </span>            : 
<span class="lineNum">    1562 </span><span class="lineCov">     101721 :   declarator = make_declarator (cdk_ptrmem);</span>
<span class="lineNum">    1563 </span><span class="lineCov">     101721 :   declarator-&gt;declarator = pointee;</span>
<span class="lineNum">    1564 </span><span class="lineCov">     101721 :   declarator-&gt;u.pointer.qualifiers = cv_qualifiers;</span>
<span class="lineNum">    1565 </span><span class="lineCov">     101721 :   declarator-&gt;u.pointer.class_type = class_type;</span>
<span class="lineNum">    1566 </span>            : 
<span class="lineNum">    1567 </span><span class="lineCov">     101721 :   if (pointee)</span>
<span class="lineNum">    1568 </span>            :     {
<span class="lineNum">    1569 </span><span class="lineCov">      55736 :       declarator-&gt;parameter_pack_p = pointee-&gt;parameter_pack_p;</span>
<span class="lineNum">    1570 </span><span class="lineCov">      55736 :       pointee-&gt;parameter_pack_p = false;</span>
<span class="lineNum">    1571 </span>            :     }
<span class="lineNum">    1572 </span>            :   else
<span class="lineNum">    1573 </span>            :     declarator-&gt;parameter_pack_p = false;
<span class="lineNum">    1574 </span>            : 
<span class="lineNum">    1575 </span><span class="lineCov">     101721 :   declarator-&gt;std_attributes = attributes;</span>
<span class="lineNum">    1576 </span>            : 
<span class="lineNum">    1577 </span><span class="lineCov">     101721 :   return declarator;</span>
<span class="lineNum">    1578 </span>            : }
<span class="lineNum">    1579 </span>            : 
<span class="lineNum">    1580 </span>            : /* Make a declarator for the function given by TARGET, with the
<span class="lineNum">    1581 </span>            :    indicated PARMS.  The CV_QUALIFIERS apply to the function, as in
<span class="lineNum">    1582 </span>            :    &quot;const&quot;-qualified member function.  The EXCEPTION_SPECIFICATION
<span class="lineNum">    1583 </span>            :    indicates what exceptions can be thrown.  */
<a name="1584"><span class="lineNum">    1584 </span>            : </a>
<span class="lineNum">    1585 </span>            : cp_declarator *
<span class="lineNum">    1586 </span><span class="lineCov">   10411290 : make_call_declarator (cp_declarator *target,</span>
<span class="lineNum">    1587 </span>            :                       tree parms,
<span class="lineNum">    1588 </span>            :                       cp_cv_quals cv_qualifiers,
<span class="lineNum">    1589 </span>            :                       cp_virt_specifiers virt_specifiers,
<span class="lineNum">    1590 </span>            :                       cp_ref_qualifier ref_qualifier,
<span class="lineNum">    1591 </span>            :                       tree tx_qualifier,
<span class="lineNum">    1592 </span>            :                       tree exception_specification,
<span class="lineNum">    1593 </span>            :                       tree late_return_type,
<span class="lineNum">    1594 </span>            :                       tree requires_clause)
<span class="lineNum">    1595 </span>            : {
<span class="lineNum">    1596 </span><span class="lineCov">   10411290 :   cp_declarator *declarator;</span>
<span class="lineNum">    1597 </span>            : 
<span class="lineNum">    1598 </span><span class="lineCov">   10411290 :   declarator = make_declarator (cdk_function);</span>
<span class="lineNum">    1599 </span><span class="lineCov">   10411290 :   declarator-&gt;declarator = target;</span>
<span class="lineNum">    1600 </span><span class="lineCov">   10411290 :   declarator-&gt;u.function.parameters = parms;</span>
<span class="lineNum">    1601 </span><span class="lineCov">   10411290 :   declarator-&gt;u.function.qualifiers = cv_qualifiers;</span>
<span class="lineNum">    1602 </span><span class="lineCov">   10411290 :   declarator-&gt;u.function.virt_specifiers = virt_specifiers;</span>
<span class="lineNum">    1603 </span><span class="lineCov">   10411290 :   declarator-&gt;u.function.ref_qualifier = ref_qualifier;</span>
<span class="lineNum">    1604 </span><span class="lineCov">   10411290 :   declarator-&gt;u.function.tx_qualifier = tx_qualifier;</span>
<span class="lineNum">    1605 </span><span class="lineCov">   10411290 :   declarator-&gt;u.function.exception_specification = exception_specification;</span>
<span class="lineNum">    1606 </span><span class="lineCov">   10411290 :   declarator-&gt;u.function.late_return_type = late_return_type;</span>
<span class="lineNum">    1607 </span><span class="lineCov">   10411290 :   declarator-&gt;u.function.requires_clause = requires_clause;</span>
<span class="lineNum">    1608 </span><span class="lineCov">   10411290 :   if (target)</span>
<span class="lineNum">    1609 </span>            :     {
<span class="lineNum">    1610 </span><span class="lineCov">   10302600 :       declarator-&gt;id_loc = target-&gt;id_loc;</span>
<span class="lineNum">    1611 </span><span class="lineCov">   10302600 :       declarator-&gt;parameter_pack_p = target-&gt;parameter_pack_p;</span>
<span class="lineNum">    1612 </span><span class="lineCov">   10302600 :       target-&gt;parameter_pack_p = false;</span>
<span class="lineNum">    1613 </span>            :     }
<span class="lineNum">    1614 </span>            :   else
<span class="lineNum">    1615 </span>            :     declarator-&gt;parameter_pack_p = false;
<span class="lineNum">    1616 </span>            : 
<span class="lineNum">    1617 </span><span class="lineCov">   10411290 :   return declarator;</span>
<span class="lineNum">    1618 </span>            : }
<span class="lineNum">    1619 </span>            : 
<span class="lineNum">    1620 </span>            : /* Make a declarator for an array of BOUNDS elements, each of which is
<span class="lineNum">    1621 </span>            :    defined by ELEMENT.  */
<a name="1622"><span class="lineNum">    1622 </span>            : </a>
<span class="lineNum">    1623 </span>            : cp_declarator *
<span class="lineNum">    1624 </span><span class="lineCov">     413979 : make_array_declarator (cp_declarator *element, tree bounds)</span>
<span class="lineNum">    1625 </span>            : {
<span class="lineNum">    1626 </span><span class="lineCov">     413979 :   cp_declarator *declarator;</span>
<span class="lineNum">    1627 </span>            : 
<span class="lineNum">    1628 </span><span class="lineCov">     413979 :   declarator = make_declarator (cdk_array);</span>
<span class="lineNum">    1629 </span><span class="lineCov">     413979 :   declarator-&gt;declarator = element;</span>
<span class="lineNum">    1630 </span><span class="lineCov">     413979 :   declarator-&gt;u.array.bounds = bounds;</span>
<span class="lineNum">    1631 </span><span class="lineCov">     413979 :   if (element)</span>
<span class="lineNum">    1632 </span>            :     {
<span class="lineNum">    1633 </span><span class="lineCov">     360552 :       declarator-&gt;id_loc = element-&gt;id_loc;</span>
<span class="lineNum">    1634 </span><span class="lineCov">     360552 :       declarator-&gt;parameter_pack_p = element-&gt;parameter_pack_p;</span>
<span class="lineNum">    1635 </span><span class="lineCov">     360552 :       element-&gt;parameter_pack_p = false;</span>
<span class="lineNum">    1636 </span>            :     }
<span class="lineNum">    1637 </span>            :   else
<span class="lineNum">    1638 </span>            :     declarator-&gt;parameter_pack_p = false;
<span class="lineNum">    1639 </span>            : 
<span class="lineNum">    1640 </span><span class="lineCov">     413979 :   return declarator;</span>
<span class="lineNum">    1641 </span>            : }
<span class="lineNum">    1642 </span>            : 
<span class="lineNum">    1643 </span>            : /* Determine whether the declarator we've seen so far can be a
<a name="1644"><span class="lineNum">    1644 </span>            :    parameter pack, when followed by an ellipsis.  */</a>
<span class="lineNum">    1645 </span>            : static bool 
<span class="lineNum">    1646 </span><span class="lineCov">     123476 : declarator_can_be_parameter_pack (cp_declarator *declarator)</span>
<span class="lineNum">    1647 </span>            : {
<span class="lineNum">    1648 </span><span class="lineCov">     123476 :   if (declarator &amp;&amp; declarator-&gt;parameter_pack_p)</span>
<span class="lineNum">    1649 </span>            :     /* We already saw an ellipsis.  */
<span class="lineNum">    1650 </span>            :     return false;
<span class="lineNum">    1651 </span>            : 
<span class="lineNum">    1652 </span>            :   /* Search for a declarator name, or any other declarator that goes
<span class="lineNum">    1653 </span>            :      after the point where the ellipsis could appear in a parameter
<span class="lineNum">    1654 </span>            :      pack. If we find any of these, then this declarator can not be
<span class="lineNum">    1655 </span>            :      made into a parameter pack.  */
<span class="lineNum">    1656 </span>            :   bool found = false;
<span class="lineNum">    1657 </span><span class="lineCov">     126421 :   while (declarator &amp;&amp; !found)</span>
<span class="lineNum">    1658 </span>            :     {
<span class="lineNum">    1659 </span><span class="lineCov">       2945 :       switch ((int)declarator-&gt;kind)</span>
<span class="lineNum">    1660 </span>            :         {
<span class="lineNum">    1661 </span>            :         case cdk_id:
<span class="lineNum">    1662 </span>            :         case cdk_array:
<span class="lineNum">    1663 </span>            :         case cdk_decomp:
<span class="lineNum">    1664 </span>            :           found = true;
<span class="lineNum">    1665 </span>            :           break;
<span class="lineNum">    1666 </span>            : 
<span class="lineNum">    1667 </span>            :         case cdk_error:
<span class="lineNum">    1668 </span>            :           return true;
<span class="lineNum">    1669 </span>            : 
<span class="lineNum">    1670 </span><span class="lineCov">       2944 :         default:</span>
<span class="lineNum">    1671 </span><span class="lineCov">       2944 :           declarator = declarator-&gt;declarator;</span>
<span class="lineNum">    1672 </span><span class="lineCov">       2944 :           break;</span>
<span class="lineNum">    1673 </span>            :         }
<span class="lineNum">    1674 </span>            :     }
<span class="lineNum">    1675 </span>            : 
<span class="lineNum">    1676 </span><span class="lineCov">     123476 :   return !found;</span>
<span class="lineNum">    1677 </span>            : }
<span class="lineNum">    1678 </span>            : 
<span class="lineNum">    1679 </span>            : cp_parameter_declarator *no_parameters;
<span class="lineNum">    1680 </span>            : 
<span class="lineNum">    1681 </span>            : /* Create a parameter declarator with the indicated DECL_SPECIFIERS,
<span class="lineNum">    1682 </span>            :    DECLARATOR and DEFAULT_ARGUMENT.  */
<a name="1683"><span class="lineNum">    1683 </span>            : </a>
<span class="lineNum">    1684 </span>            : cp_parameter_declarator *
<span class="lineNum">    1685 </span><span class="lineCov">   17245632 : make_parameter_declarator (cp_decl_specifier_seq *decl_specifiers,</span>
<span class="lineNum">    1686 </span>            :                            cp_declarator *declarator,
<span class="lineNum">    1687 </span>            :                            tree default_argument,
<span class="lineNum">    1688 </span>            :                            location_t loc,
<span class="lineNum">    1689 </span>            :                            bool template_parameter_pack_p = false)
<span class="lineNum">    1690 </span>            : {
<span class="lineNum">    1691 </span><span class="lineCov">   17245632 :   cp_parameter_declarator *parameter;</span>
<span class="lineNum">    1692 </span>            : 
<span class="lineNum">    1693 </span><span class="lineCov">   17245632 :   parameter = ((cp_parameter_declarator *)</span>
<span class="lineNum">    1694 </span><span class="lineCov">   17245632 :                alloc_declarator (sizeof (cp_parameter_declarator)));</span>
<span class="lineNum">    1695 </span><span class="lineCov">   17245632 :   parameter-&gt;next = NULL;</span>
<span class="lineNum">    1696 </span><span class="lineCov">   17245632 :   if (decl_specifiers)</span>
<span class="lineNum">    1697 </span><span class="lineCov">   17189391 :     parameter-&gt;decl_specifiers = *decl_specifiers;</span>
<span class="lineNum">    1698 </span>            :   else
<span class="lineNum">    1699 </span><span class="lineCov">      56241 :     clear_decl_specs (&amp;parameter-&gt;decl_specifiers);</span>
<span class="lineNum">    1700 </span><span class="lineCov">   17245632 :   parameter-&gt;declarator = declarator;</span>
<span class="lineNum">    1701 </span><span class="lineCov">   17245632 :   parameter-&gt;default_argument = default_argument;</span>
<span class="lineNum">    1702 </span><span class="lineCov">   17245632 :   parameter-&gt;template_parameter_pack_p = template_parameter_pack_p;</span>
<span class="lineNum">    1703 </span><span class="lineCov">   17245632 :   parameter-&gt;loc = loc;</span>
<span class="lineNum">    1704 </span>            : 
<span class="lineNum">    1705 </span><span class="lineCov">   17245632 :   return parameter;</span>
<span class="lineNum">    1706 </span>            : }
<span class="lineNum">    1707 </span>            : 
<span class="lineNum">    1708 </span>            : /* Returns true iff DECLARATOR  is a declaration for a function.  */
<a name="1709"><span class="lineNum">    1709 </span>            : </a>
<span class="lineNum">    1710 </span>            : static bool
<span class="lineNum">    1711 </span><span class="lineCov">   23937336 : function_declarator_p (const cp_declarator *declarator)</span>
<span class="lineNum">    1712 </span>            : {
<span class="lineNum">    1713 </span><span class="lineCov">   27029220 :   while (declarator)</span>
<span class="lineNum">    1714 </span>            :     {
<span class="lineNum">    1715 </span><span class="lineCov">   27029220 :       if (declarator-&gt;kind == cdk_function</span>
<span class="lineNum">    1716 </span><span class="lineCov">   12332569 :           &amp;&amp; declarator-&gt;declarator-&gt;kind == cdk_id)</span>
<span class="lineNum">    1717 </span>            :         return true;
<span class="lineNum">    1718 </span><span class="lineCov">   29515236 :       if (declarator-&gt;kind == cdk_id</span>
<span class="lineNum">    1719 </span><span class="lineCov">   14757618 :           || declarator-&gt;kind == cdk_decomp</span>
<span class="lineNum">    1720 </span><span class="lineCov">    3091884 :           || declarator-&gt;kind == cdk_error)</span>
<span class="lineNum">    1721 </span>            :         return false;
<span class="lineNum">    1722 </span><span class="lineCov">    3091884 :       declarator = declarator-&gt;declarator;</span>
<span class="lineNum">    1723 </span>            :     }
<span class="lineNum">    1724 </span>            :   return false;
<span class="lineNum">    1725 </span>            : }
<span class="lineNum">    1726 </span>            :  
<span class="lineNum">    1727 </span>            : /* The parser.  */
<span class="lineNum">    1728 </span>            : 
<span class="lineNum">    1729 </span>            : /* Overview
<span class="lineNum">    1730 </span>            :    --------
<span class="lineNum">    1731 </span>            : 
<span class="lineNum">    1732 </span>            :    A cp_parser parses the token stream as specified by the C++
<span class="lineNum">    1733 </span>            :    grammar.  Its job is purely parsing, not semantic analysis.  For
<span class="lineNum">    1734 </span>            :    example, the parser breaks the token stream into declarators,
<span class="lineNum">    1735 </span>            :    expressions, statements, and other similar syntactic constructs.
<span class="lineNum">    1736 </span>            :    It does not check that the types of the expressions on either side
<span class="lineNum">    1737 </span>            :    of an assignment-statement are compatible, or that a function is
<span class="lineNum">    1738 </span>            :    not declared with a parameter of type `void'.
<span class="lineNum">    1739 </span>            : 
<span class="lineNum">    1740 </span>            :    The parser invokes routines elsewhere in the compiler to perform
<span class="lineNum">    1741 </span>            :    semantic analysis and to build up the abstract syntax tree for the
<span class="lineNum">    1742 </span>            :    code processed.
<span class="lineNum">    1743 </span>            : 
<span class="lineNum">    1744 </span>            :    The parser (and the template instantiation code, which is, in a
<span class="lineNum">    1745 </span>            :    way, a close relative of parsing) are the only parts of the
<span class="lineNum">    1746 </span>            :    compiler that should be calling push_scope and pop_scope, or
<span class="lineNum">    1747 </span>            :    related functions.  The parser (and template instantiation code)
<span class="lineNum">    1748 </span>            :    keeps track of what scope is presently active; everything else
<span class="lineNum">    1749 </span>            :    should simply honor that.  (The code that generates static
<span class="lineNum">    1750 </span>            :    initializers may also need to set the scope, in order to check
<span class="lineNum">    1751 </span>            :    access control correctly when emitting the initializers.)
<span class="lineNum">    1752 </span>            : 
<span class="lineNum">    1753 </span>            :    Methodology
<span class="lineNum">    1754 </span>            :    -----------
<span class="lineNum">    1755 </span>            : 
<span class="lineNum">    1756 </span>            :    The parser is of the standard recursive-descent variety.  Upcoming
<span class="lineNum">    1757 </span>            :    tokens in the token stream are examined in order to determine which
<span class="lineNum">    1758 </span>            :    production to use when parsing a non-terminal.  Some C++ constructs
<span class="lineNum">    1759 </span>            :    require arbitrary look ahead to disambiguate.  For example, it is
<span class="lineNum">    1760 </span>            :    impossible, in the general case, to tell whether a statement is an
<span class="lineNum">    1761 </span>            :    expression or declaration without scanning the entire statement.
<span class="lineNum">    1762 </span>            :    Therefore, the parser is capable of &quot;parsing tentatively.&quot;  When the
<span class="lineNum">    1763 </span>            :    parser is not sure what construct comes next, it enters this mode.
<span class="lineNum">    1764 </span>            :    Then, while we attempt to parse the construct, the parser queues up
<span class="lineNum">    1765 </span>            :    error messages, rather than issuing them immediately, and saves the
<span class="lineNum">    1766 </span>            :    tokens it consumes.  If the construct is parsed successfully, the
<span class="lineNum">    1767 </span>            :    parser &quot;commits&quot;, i.e., it issues any queued error messages and
<span class="lineNum">    1768 </span>            :    the tokens that were being preserved are permanently discarded.
<span class="lineNum">    1769 </span>            :    If, however, the construct is not parsed successfully, the parser
<span class="lineNum">    1770 </span>            :    rolls back its state completely so that it can resume parsing using
<span class="lineNum">    1771 </span>            :    a different alternative.
<span class="lineNum">    1772 </span>            : 
<span class="lineNum">    1773 </span>            :    Future Improvements
<span class="lineNum">    1774 </span>            :    -------------------
<span class="lineNum">    1775 </span>            : 
<span class="lineNum">    1776 </span>            :    The performance of the parser could probably be improved substantially.
<span class="lineNum">    1777 </span>            :    We could often eliminate the need to parse tentatively by looking ahead
<span class="lineNum">    1778 </span>            :    a little bit.  In some places, this approach might not entirely eliminate
<span class="lineNum">    1779 </span>            :    the need to parse tentatively, but it might still speed up the average
<span class="lineNum">    1780 </span>            :    case.  */
<span class="lineNum">    1781 </span>            : 
<span class="lineNum">    1782 </span>            : /* Flags that are passed to some parsing functions.  These values can
<span class="lineNum">    1783 </span>            :    be bitwise-ored together.  */
<span class="lineNum">    1784 </span>            : 
<span class="lineNum">    1785 </span>            : enum
<span class="lineNum">    1786 </span>            : {
<span class="lineNum">    1787 </span>            :   /* No flags.  */
<span class="lineNum">    1788 </span>            :   CP_PARSER_FLAGS_NONE = 0x0,
<span class="lineNum">    1789 </span>            :   /* The construct is optional.  If it is not present, then no error
<span class="lineNum">    1790 </span>            :      should be issued.  */
<span class="lineNum">    1791 </span>            :   CP_PARSER_FLAGS_OPTIONAL = 0x1,
<span class="lineNum">    1792 </span>            :   /* When parsing a type-specifier, treat user-defined type-names
<span class="lineNum">    1793 </span>            :      as non-type identifiers.  */
<span class="lineNum">    1794 </span>            :   CP_PARSER_FLAGS_NO_USER_DEFINED_TYPES = 0x2,
<span class="lineNum">    1795 </span>            :   /* When parsing a type-specifier, do not try to parse a class-specifier
<span class="lineNum">    1796 </span>            :      or enum-specifier.  */
<span class="lineNum">    1797 </span>            :   CP_PARSER_FLAGS_NO_TYPE_DEFINITIONS = 0x4,
<span class="lineNum">    1798 </span>            :   /* When parsing a decl-specifier-seq, only allow type-specifier or
<span class="lineNum">    1799 </span>            :      constexpr.  */
<span class="lineNum">    1800 </span>            :   CP_PARSER_FLAGS_ONLY_TYPE_OR_CONSTEXPR = 0x8,
<span class="lineNum">    1801 </span>            :   /* When parsing a decl-specifier-seq, only allow mutable or constexpr.  */
<span class="lineNum">    1802 </span>            :   CP_PARSER_FLAGS_ONLY_MUTABLE_OR_CONSTEXPR = 0x10
<span class="lineNum">    1803 </span>            : };
<span class="lineNum">    1804 </span>            : 
<span class="lineNum">    1805 </span>            : /* This type is used for parameters and variables which hold
<span class="lineNum">    1806 </span>            :    combinations of the above flags.  */
<span class="lineNum">    1807 </span>            : typedef int cp_parser_flags;
<span class="lineNum">    1808 </span>            : 
<span class="lineNum">    1809 </span>            : /* The different kinds of declarators we want to parse.  */
<span class="lineNum">    1810 </span>            : 
<span class="lineNum">    1811 </span>            : enum cp_parser_declarator_kind
<span class="lineNum">    1812 </span>            : {
<span class="lineNum">    1813 </span>            :   /* We want an abstract declarator.  */
<span class="lineNum">    1814 </span>            :   CP_PARSER_DECLARATOR_ABSTRACT,
<span class="lineNum">    1815 </span>            :   /* We want a named declarator.  */
<span class="lineNum">    1816 </span>            :   CP_PARSER_DECLARATOR_NAMED,
<span class="lineNum">    1817 </span>            :   /* We don't mind, but the name must be an unqualified-id.  */
<span class="lineNum">    1818 </span>            :   CP_PARSER_DECLARATOR_EITHER
<span class="lineNum">    1819 </span>            : };
<span class="lineNum">    1820 </span>            : 
<span class="lineNum">    1821 </span>            : /* The precedence values used to parse binary expressions.  The minimum value
<span class="lineNum">    1822 </span>            :    of PREC must be 1, because zero is reserved to quickly discriminate
<span class="lineNum">    1823 </span>            :    binary operators from other tokens.  */
<span class="lineNum">    1824 </span>            : 
<span class="lineNum">    1825 </span>            : enum cp_parser_prec
<span class="lineNum">    1826 </span>            : {
<span class="lineNum">    1827 </span>            :   PREC_NOT_OPERATOR,
<span class="lineNum">    1828 </span>            :   PREC_LOGICAL_OR_EXPRESSION,
<span class="lineNum">    1829 </span>            :   PREC_LOGICAL_AND_EXPRESSION,
<span class="lineNum">    1830 </span>            :   PREC_INCLUSIVE_OR_EXPRESSION,
<span class="lineNum">    1831 </span>            :   PREC_EXCLUSIVE_OR_EXPRESSION,
<span class="lineNum">    1832 </span>            :   PREC_AND_EXPRESSION,
<span class="lineNum">    1833 </span>            :   PREC_EQUALITY_EXPRESSION,
<span class="lineNum">    1834 </span>            :   PREC_RELATIONAL_EXPRESSION,
<span class="lineNum">    1835 </span>            :   PREC_SHIFT_EXPRESSION,
<span class="lineNum">    1836 </span>            :   PREC_ADDITIVE_EXPRESSION,
<span class="lineNum">    1837 </span>            :   PREC_MULTIPLICATIVE_EXPRESSION,
<span class="lineNum">    1838 </span>            :   PREC_PM_EXPRESSION,
<span class="lineNum">    1839 </span>            :   NUM_PREC_VALUES = PREC_PM_EXPRESSION
<span class="lineNum">    1840 </span>            : };
<span class="lineNum">    1841 </span>            : 
<span class="lineNum">    1842 </span>            : /* A mapping from a token type to a corresponding tree node type, with a
<span class="lineNum">    1843 </span>            :    precedence value.  */
<span class="lineNum">    1844 </span>            : 
<span class="lineNum">    1845 </span>            : struct cp_parser_binary_operations_map_node
<span class="lineNum">    1846 </span>            : {
<span class="lineNum">    1847 </span>            :   /* The token type.  */
<span class="lineNum">    1848 </span>            :   enum cpp_ttype token_type;
<span class="lineNum">    1849 </span>            :   /* The corresponding tree code.  */
<span class="lineNum">    1850 </span>            :   enum tree_code tree_type;
<span class="lineNum">    1851 </span>            :   /* The precedence of this operator.  */
<span class="lineNum">    1852 </span>            :   enum cp_parser_prec prec;
<span class="lineNum">    1853 </span>            : };
<span class="lineNum">    1854 </span>            : 
<span class="lineNum">    1855 </span><span class="lineCov">  948369288 : struct cp_parser_expression_stack_entry</span>
<span class="lineNum">    1856 </span>            : {
<span class="lineNum">    1857 </span>            :   /* Left hand side of the binary operation we are currently
<span class="lineNum">    1858 </span>            :      parsing.  */
<span class="lineNum">    1859 </span>            :   cp_expr lhs;
<span class="lineNum">    1860 </span>            :   /* Original tree code for left hand side, if it was a binary
<span class="lineNum">    1861 </span>            :      expression itself (used for -Wparentheses).  */
<span class="lineNum">    1862 </span>            :   enum tree_code lhs_type;
<span class="lineNum">    1863 </span>            :   /* Tree code for the binary operation we are parsing.  */
<span class="lineNum">    1864 </span>            :   enum tree_code tree_type;
<span class="lineNum">    1865 </span>            :   /* Precedence of the binary operation we are parsing.  */
<span class="lineNum">    1866 </span>            :   enum cp_parser_prec prec;
<span class="lineNum">    1867 </span>            :   /* Location of the binary operation we are parsing.  */
<span class="lineNum">    1868 </span>            :   location_t loc;
<span class="lineNum">    1869 </span>            : };
<span class="lineNum">    1870 </span>            : 
<span class="lineNum">    1871 </span>            : /* The stack for storing partial expressions.  We only need NUM_PREC_VALUES
<span class="lineNum">    1872 </span>            :    entries because precedence levels on the stack are monotonically
<span class="lineNum">    1873 </span>            :    increasing.  */
<span class="lineNum">    1874 </span>            : typedef struct cp_parser_expression_stack_entry
<span class="lineNum">    1875 </span>            :   cp_parser_expression_stack[NUM_PREC_VALUES];
<span class="lineNum">    1876 </span>            : 
<span class="lineNum">    1877 </span>            : /* Prototypes.  */
<span class="lineNum">    1878 </span>            : 
<span class="lineNum">    1879 </span>            : /* Constructors and destructors.  */
<span class="lineNum">    1880 </span>            : 
<span class="lineNum">    1881 </span>            : static cp_parser_context *cp_parser_context_new
<span class="lineNum">    1882 </span>            :   (cp_parser_context *);
<span class="lineNum">    1883 </span>            : 
<span class="lineNum">    1884 </span>            : /* Class variables.  */
<span class="lineNum">    1885 </span>            : 
<span class="lineNum">    1886 </span>            : static GTY((deletable)) cp_parser_context* cp_parser_context_free_list;
<span class="lineNum">    1887 </span>            : 
<span class="lineNum">    1888 </span>            : /* The operator-precedence table used by cp_parser_binary_expression.
<span class="lineNum">    1889 </span>            :    Transformed into an associative array (binops_by_token) by
<span class="lineNum">    1890 </span>            :    cp_parser_new.  */
<span class="lineNum">    1891 </span>            : 
<span class="lineNum">    1892 </span>            : static const cp_parser_binary_operations_map_node binops[] = {
<span class="lineNum">    1893 </span>            :   { CPP_DEREF_STAR, MEMBER_REF, PREC_PM_EXPRESSION },
<span class="lineNum">    1894 </span>            :   { CPP_DOT_STAR, DOTSTAR_EXPR, PREC_PM_EXPRESSION },
<span class="lineNum">    1895 </span>            : 
<span class="lineNum">    1896 </span>            :   { CPP_MULT, MULT_EXPR, PREC_MULTIPLICATIVE_EXPRESSION },
<span class="lineNum">    1897 </span>            :   { CPP_DIV, TRUNC_DIV_EXPR, PREC_MULTIPLICATIVE_EXPRESSION },
<span class="lineNum">    1898 </span>            :   { CPP_MOD, TRUNC_MOD_EXPR, PREC_MULTIPLICATIVE_EXPRESSION },
<span class="lineNum">    1899 </span>            : 
<span class="lineNum">    1900 </span>            :   { CPP_PLUS, PLUS_EXPR, PREC_ADDITIVE_EXPRESSION },
<span class="lineNum">    1901 </span>            :   { CPP_MINUS, MINUS_EXPR, PREC_ADDITIVE_EXPRESSION },
<span class="lineNum">    1902 </span>            : 
<span class="lineNum">    1903 </span>            :   { CPP_LSHIFT, LSHIFT_EXPR, PREC_SHIFT_EXPRESSION },
<span class="lineNum">    1904 </span>            :   { CPP_RSHIFT, RSHIFT_EXPR, PREC_SHIFT_EXPRESSION },
<span class="lineNum">    1905 </span>            : 
<span class="lineNum">    1906 </span>            :   { CPP_LESS, LT_EXPR, PREC_RELATIONAL_EXPRESSION },
<span class="lineNum">    1907 </span>            :   { CPP_GREATER, GT_EXPR, PREC_RELATIONAL_EXPRESSION },
<span class="lineNum">    1908 </span>            :   { CPP_LESS_EQ, LE_EXPR, PREC_RELATIONAL_EXPRESSION },
<span class="lineNum">    1909 </span>            :   { CPP_GREATER_EQ, GE_EXPR, PREC_RELATIONAL_EXPRESSION },
<span class="lineNum">    1910 </span>            : 
<span class="lineNum">    1911 </span>            :   { CPP_EQ_EQ, EQ_EXPR, PREC_EQUALITY_EXPRESSION },
<span class="lineNum">    1912 </span>            :   { CPP_NOT_EQ, NE_EXPR, PREC_EQUALITY_EXPRESSION },
<span class="lineNum">    1913 </span>            : 
<span class="lineNum">    1914 </span>            :   { CPP_AND, BIT_AND_EXPR, PREC_AND_EXPRESSION },
<span class="lineNum">    1915 </span>            : 
<span class="lineNum">    1916 </span>            :   { CPP_XOR, BIT_XOR_EXPR, PREC_EXCLUSIVE_OR_EXPRESSION },
<span class="lineNum">    1917 </span>            : 
<span class="lineNum">    1918 </span>            :   { CPP_OR, BIT_IOR_EXPR, PREC_INCLUSIVE_OR_EXPRESSION },
<span class="lineNum">    1919 </span>            : 
<span class="lineNum">    1920 </span>            :   { CPP_AND_AND, TRUTH_ANDIF_EXPR, PREC_LOGICAL_AND_EXPRESSION },
<span class="lineNum">    1921 </span>            : 
<span class="lineNum">    1922 </span>            :   { CPP_OR_OR, TRUTH_ORIF_EXPR, PREC_LOGICAL_OR_EXPRESSION }
<span class="lineNum">    1923 </span>            : };
<span class="lineNum">    1924 </span>            : 
<span class="lineNum">    1925 </span>            : /* The same as binops, but initialized by cp_parser_new so that
<span class="lineNum">    1926 </span>            :    binops_by_token[N].token_type == N.  Used in cp_parser_binary_expression
<span class="lineNum">    1927 </span>            :    for speed.  */
<span class="lineNum">    1928 </span>            : static cp_parser_binary_operations_map_node binops_by_token[N_CP_TTYPES];
<span class="lineNum">    1929 </span>            : 
<span class="lineNum">    1930 </span>            : /* Constructors and destructors.  */
<span class="lineNum">    1931 </span>            : 
<span class="lineNum">    1932 </span>            : /* Construct a new context.  The context below this one on the stack
<span class="lineNum">    1933 </span>            :    is given by NEXT.  */
<a name="1934"><span class="lineNum">    1934 </span>            : </a>
<span class="lineNum">    1935 </span>            : static cp_parser_context *
<span class="lineNum">    1936 </span><span class="lineCov">  637722230 : cp_parser_context_new (cp_parser_context* next)</span>
<span class="lineNum">    1937 </span>            : {
<span class="lineNum">    1938 </span><span class="lineCov">  637722230 :   cp_parser_context *context;</span>
<span class="lineNum">    1939 </span>            : 
<span class="lineNum">    1940 </span>            :   /* Allocate the storage.  */
<span class="lineNum">    1941 </span><span class="lineCov">  637722230 :   if (cp_parser_context_free_list != NULL)</span>
<span class="lineNum">    1942 </span>            :     {
<span class="lineNum">    1943 </span>            :       /* Pull the first entry from the free list.  */
<span class="lineNum">    1944 </span><span class="lineCov">  636929038 :       context = cp_parser_context_free_list;</span>
<span class="lineNum">    1945 </span><span class="lineCov">  636929038 :       cp_parser_context_free_list = context-&gt;next;</span>
<span class="lineNum">    1946 </span><span class="lineCov">  636929038 :       memset (context, 0, sizeof (*context));</span>
<span class="lineNum">    1947 </span>            :     }
<span class="lineNum">    1948 </span>            :   else
<span class="lineNum">    1949 </span><span class="lineCov">    1586384 :     context = ggc_cleared_alloc&lt;cp_parser_context&gt; ();</span>
<span class="lineNum">    1950 </span>            : 
<span class="lineNum">    1951 </span>            :   /* No errors have occurred yet in this context.  */
<span class="lineNum">    1952 </span><span class="lineCov">  637722230 :   context-&gt;status = CP_PARSER_STATUS_KIND_NO_ERROR;</span>
<span class="lineNum">    1953 </span>            :   /* If this is not the bottommost context, copy information that we
<span class="lineNum">    1954 </span>            :      need from the previous context.  */
<span class="lineNum">    1955 </span><span class="lineCov">  637722230 :   if (next)</span>
<span class="lineNum">    1956 </span>            :     {
<span class="lineNum">    1957 </span>            :       /* If, in the NEXT context, we are parsing an `x-&gt;' or `x.'
<span class="lineNum">    1958 </span>            :          expression, then we are parsing one in this context, too.  */
<span class="lineNum">    1959 </span><span class="lineCov">  637665989 :       context-&gt;object_type = next-&gt;object_type;</span>
<span class="lineNum">    1960 </span>            :       /* Thread the stack.  */
<span class="lineNum">    1961 </span><span class="lineCov">  637665989 :       context-&gt;next = next;</span>
<span class="lineNum">    1962 </span>            :     }
<span class="lineNum">    1963 </span>            : 
<span class="lineNum">    1964 </span><span class="lineCov">  637722230 :   return context;</span>
<span class="lineNum">    1965 </span>            : }
<span class="lineNum">    1966 </span>            : 
<span class="lineNum">    1967 </span>            : /* Managing the unparsed function queues.  */
<span class="lineNum">    1968 </span>            : 
<span class="lineNum">    1969 </span>            : #define unparsed_funs_with_default_args \
<span class="lineNum">    1970 </span>            :   parser-&gt;unparsed_queues-&gt;last ().funs_with_default_args
<span class="lineNum">    1971 </span>            : #define unparsed_funs_with_definitions \
<span class="lineNum">    1972 </span>            :   parser-&gt;unparsed_queues-&gt;last ().funs_with_definitions
<span class="lineNum">    1973 </span>            : #define unparsed_nsdmis \
<span class="lineNum">    1974 </span>            :   parser-&gt;unparsed_queues-&gt;last ().nsdmis
<span class="lineNum">    1975 </span>            : #define unparsed_classes \
<span class="lineNum">    1976 </span>            :   parser-&gt;unparsed_queues-&gt;last ().classes
<a name="1977"><span class="lineNum">    1977 </span>            : </a>
<span class="lineNum">    1978 </span>            : static void
<span class="lineNum">    1979 </span><span class="lineCov">    4059948 : push_unparsed_function_queues (cp_parser *parser)</span>
<span class="lineNum">    1980 </span>            : {
<span class="lineNum">    1981 </span><span class="lineCov">    4059948 :   cp_unparsed_functions_entry e = {NULL, make_tree_vector (), NULL, NULL};</span>
<span class="lineNum">    1982 </span><span class="lineCov">    4059948 :   vec_safe_push (parser-&gt;unparsed_queues, e);</span>
<span class="lineNum">    1983 </span><span class="lineCov">    4059948 : }</span>
<a name="1984"><span class="lineNum">    1984 </span>            : </a>
<span class="lineNum">    1985 </span>            : static void
<span class="lineNum">    1986 </span><span class="lineCov">    4003707 : pop_unparsed_function_queues (cp_parser *parser)</span>
<span class="lineNum">    1987 </span>            : {
<span class="lineNum">    1988 </span><span class="lineCov">    4003707 :   release_tree_vector (unparsed_funs_with_definitions);</span>
<span class="lineNum">    1989 </span><span class="lineCov">    4003707 :   parser-&gt;unparsed_queues-&gt;pop ();</span>
<span class="lineNum">    1990 </span><span class="lineCov">    4003707 : }</span>
<span class="lineNum">    1991 </span>            : 
<span class="lineNum">    1992 </span>            : /* Prototypes.  */
<span class="lineNum">    1993 </span>            : 
<span class="lineNum">    1994 </span>            : /* Constructors and destructors.  */
<span class="lineNum">    1995 </span>            : 
<span class="lineNum">    1996 </span>            : static cp_parser *cp_parser_new
<span class="lineNum">    1997 </span>            :   (void);
<span class="lineNum">    1998 </span>            : 
<span class="lineNum">    1999 </span>            : /* Routines to parse various constructs.
<span class="lineNum">    2000 </span>            : 
<span class="lineNum">    2001 </span>            :    Those that return `tree' will return the error_mark_node (rather
<span class="lineNum">    2002 </span>            :    than NULL_TREE) if a parse error occurs, unless otherwise noted.
<span class="lineNum">    2003 </span>            :    Sometimes, they will return an ordinary node if error-recovery was
<span class="lineNum">    2004 </span>            :    attempted, even though a parse error occurred.  So, to check
<span class="lineNum">    2005 </span>            :    whether or not a parse error occurred, you should always use
<span class="lineNum">    2006 </span>            :    cp_parser_error_occurred.  If the construct is optional (indicated
<span class="lineNum">    2007 </span>            :    either by an `_opt' in the name of the function that does the
<span class="lineNum">    2008 </span>            :    parsing or via a FLAGS parameter), then NULL_TREE is returned if
<span class="lineNum">    2009 </span>            :    the construct is not present.  */
<span class="lineNum">    2010 </span>            : 
<span class="lineNum">    2011 </span>            : /* Lexical conventions [gram.lex]  */
<span class="lineNum">    2012 </span>            : 
<span class="lineNum">    2013 </span>            : static cp_expr cp_parser_identifier
<span class="lineNum">    2014 </span>            :   (cp_parser *);
<span class="lineNum">    2015 </span>            : static cp_expr cp_parser_string_literal
<span class="lineNum">    2016 </span>            :   (cp_parser *, bool, bool, bool);
<span class="lineNum">    2017 </span>            : static cp_expr cp_parser_userdef_char_literal
<span class="lineNum">    2018 </span>            :   (cp_parser *);
<span class="lineNum">    2019 </span>            : static tree cp_parser_userdef_string_literal
<span class="lineNum">    2020 </span>            :   (tree);
<span class="lineNum">    2021 </span>            : static cp_expr cp_parser_userdef_numeric_literal
<span class="lineNum">    2022 </span>            :   (cp_parser *);
<span class="lineNum">    2023 </span>            : 
<span class="lineNum">    2024 </span>            : /* Basic concepts [gram.basic]  */
<span class="lineNum">    2025 </span>            : 
<span class="lineNum">    2026 </span>            : static bool cp_parser_translation_unit
<span class="lineNum">    2027 </span>            :   (cp_parser *);
<span class="lineNum">    2028 </span>            : 
<span class="lineNum">    2029 </span>            : /* Expressions [gram.expr]  */
<span class="lineNum">    2030 </span>            : 
<span class="lineNum">    2031 </span>            : static cp_expr cp_parser_primary_expression
<span class="lineNum">    2032 </span>            :   (cp_parser *, bool, bool, bool, cp_id_kind *);
<span class="lineNum">    2033 </span>            : static cp_expr cp_parser_id_expression
<span class="lineNum">    2034 </span>            :   (cp_parser *, bool, bool, bool *, bool, bool);
<span class="lineNum">    2035 </span>            : static cp_expr cp_parser_unqualified_id
<span class="lineNum">    2036 </span>            :   (cp_parser *, bool, bool, bool, bool);
<span class="lineNum">    2037 </span>            : static tree cp_parser_nested_name_specifier_opt
<span class="lineNum">    2038 </span>            :   (cp_parser *, bool, bool, bool, bool, bool = false);
<span class="lineNum">    2039 </span>            : static tree cp_parser_nested_name_specifier
<span class="lineNum">    2040 </span>            :   (cp_parser *, bool, bool, bool, bool);
<span class="lineNum">    2041 </span>            : static tree cp_parser_qualifying_entity
<span class="lineNum">    2042 </span>            :   (cp_parser *, bool, bool, bool, bool, bool);
<span class="lineNum">    2043 </span>            : static cp_expr cp_parser_postfix_expression
<span class="lineNum">    2044 </span>            :   (cp_parser *, bool, bool, bool, bool, cp_id_kind *);
<span class="lineNum">    2045 </span>            : static tree cp_parser_postfix_open_square_expression
<span class="lineNum">    2046 </span>            :   (cp_parser *, tree, bool, bool);
<span class="lineNum">    2047 </span>            : static tree cp_parser_postfix_dot_deref_expression
<span class="lineNum">    2048 </span>            :   (cp_parser *, enum cpp_ttype, cp_expr, bool, cp_id_kind *, location_t);
<span class="lineNum">    2049 </span>            : static vec&lt;tree, va_gc&gt; *cp_parser_parenthesized_expression_list
<span class="lineNum">    2050 </span>            :   (cp_parser *, int, bool, bool, bool *, location_t * = NULL,
<span class="lineNum">    2051 </span>            :    bool = false);
<span class="lineNum">    2052 </span>            : /* Values for the second parameter of cp_parser_parenthesized_expression_list.  */
<span class="lineNum">    2053 </span>            : enum { non_attr = 0, normal_attr = 1, id_attr = 2 };
<span class="lineNum">    2054 </span>            : static void cp_parser_pseudo_destructor_name
<span class="lineNum">    2055 </span>            :   (cp_parser *, tree, tree *, tree *);
<span class="lineNum">    2056 </span>            : static cp_expr cp_parser_unary_expression
<span class="lineNum">    2057 </span>            :   (cp_parser *, cp_id_kind * = NULL, bool = false, bool = false, bool = false);
<span class="lineNum">    2058 </span>            : static enum tree_code cp_parser_unary_operator
<span class="lineNum">    2059 </span>            :   (cp_token *);
<span class="lineNum">    2060 </span>            : static tree cp_parser_new_expression
<span class="lineNum">    2061 </span>            :   (cp_parser *);
<span class="lineNum">    2062 </span>            : static vec&lt;tree, va_gc&gt; *cp_parser_new_placement
<span class="lineNum">    2063 </span>            :   (cp_parser *);
<span class="lineNum">    2064 </span>            : static tree cp_parser_new_type_id
<span class="lineNum">    2065 </span>            :   (cp_parser *, tree *);
<span class="lineNum">    2066 </span>            : static cp_declarator *cp_parser_new_declarator_opt
<span class="lineNum">    2067 </span>            :   (cp_parser *);
<span class="lineNum">    2068 </span>            : static cp_declarator *cp_parser_direct_new_declarator
<span class="lineNum">    2069 </span>            :   (cp_parser *);
<span class="lineNum">    2070 </span>            : static vec&lt;tree, va_gc&gt; *cp_parser_new_initializer
<span class="lineNum">    2071 </span>            :   (cp_parser *);
<span class="lineNum">    2072 </span>            : static tree cp_parser_delete_expression
<span class="lineNum">    2073 </span>            :   (cp_parser *);
<span class="lineNum">    2074 </span>            : static cp_expr cp_parser_cast_expression
<span class="lineNum">    2075 </span>            :   (cp_parser *, bool, bool, bool, cp_id_kind *);
<span class="lineNum">    2076 </span>            : static cp_expr cp_parser_binary_expression
<span class="lineNum">    2077 </span>            :   (cp_parser *, bool, bool, enum cp_parser_prec, cp_id_kind *);
<span class="lineNum">    2078 </span>            : static tree cp_parser_question_colon_clause
<span class="lineNum">    2079 </span>            :   (cp_parser *, cp_expr);
<span class="lineNum">    2080 </span>            : static cp_expr cp_parser_assignment_expression
<span class="lineNum">    2081 </span>            :   (cp_parser *, cp_id_kind * = NULL, bool = false, bool = false);
<span class="lineNum">    2082 </span>            : static enum tree_code cp_parser_assignment_operator_opt
<span class="lineNum">    2083 </span>            :   (cp_parser *);
<span class="lineNum">    2084 </span>            : static cp_expr cp_parser_expression
<span class="lineNum">    2085 </span>            :   (cp_parser *, cp_id_kind * = NULL, bool = false, bool = false);
<span class="lineNum">    2086 </span>            : static cp_expr cp_parser_constant_expression
<span class="lineNum">    2087 </span>            :   (cp_parser *, bool = false, bool * = NULL, bool = false);
<span class="lineNum">    2088 </span>            : static cp_expr cp_parser_builtin_offsetof
<span class="lineNum">    2089 </span>            :   (cp_parser *);
<span class="lineNum">    2090 </span>            : static cp_expr cp_parser_lambda_expression
<span class="lineNum">    2091 </span>            :   (cp_parser *);
<span class="lineNum">    2092 </span>            : static void cp_parser_lambda_introducer
<span class="lineNum">    2093 </span>            :   (cp_parser *, tree);
<span class="lineNum">    2094 </span>            : static bool cp_parser_lambda_declarator_opt
<span class="lineNum">    2095 </span>            :   (cp_parser *, tree);
<span class="lineNum">    2096 </span>            : static void cp_parser_lambda_body
<span class="lineNum">    2097 </span>            :   (cp_parser *, tree);
<span class="lineNum">    2098 </span>            : 
<span class="lineNum">    2099 </span>            : /* Statements [gram.stmt.stmt]  */
<span class="lineNum">    2100 </span>            : 
<span class="lineNum">    2101 </span>            : static void cp_parser_statement
<span class="lineNum">    2102 </span>            :   (cp_parser *, tree, bool, bool *, vec&lt;tree&gt; * = NULL, location_t * = NULL);
<span class="lineNum">    2103 </span>            : static void cp_parser_label_for_labeled_statement
<span class="lineNum">    2104 </span>            : (cp_parser *, tree);
<span class="lineNum">    2105 </span>            : static tree cp_parser_expression_statement
<span class="lineNum">    2106 </span>            :   (cp_parser *, tree);
<span class="lineNum">    2107 </span>            : static tree cp_parser_compound_statement
<span class="lineNum">    2108 </span>            :   (cp_parser *, tree, int, bool);
<span class="lineNum">    2109 </span>            : static void cp_parser_statement_seq_opt
<span class="lineNum">    2110 </span>            :   (cp_parser *, tree);
<span class="lineNum">    2111 </span>            : static tree cp_parser_selection_statement
<span class="lineNum">    2112 </span>            :   (cp_parser *, bool *, vec&lt;tree&gt; *);
<span class="lineNum">    2113 </span>            : static tree cp_parser_condition
<span class="lineNum">    2114 </span>            :   (cp_parser *);
<span class="lineNum">    2115 </span>            : static tree cp_parser_iteration_statement
<span class="lineNum">    2116 </span>            :   (cp_parser *, bool *, bool, unsigned short);
<span class="lineNum">    2117 </span>            : static bool cp_parser_init_statement
<span class="lineNum">    2118 </span>            :   (cp_parser *, tree *decl);
<span class="lineNum">    2119 </span>            : static tree cp_parser_for
<span class="lineNum">    2120 </span>            :   (cp_parser *, bool, unsigned short);
<span class="lineNum">    2121 </span>            : static tree cp_parser_c_for
<span class="lineNum">    2122 </span>            :   (cp_parser *, tree, tree, bool, unsigned short);
<span class="lineNum">    2123 </span>            : static tree cp_parser_range_for
<span class="lineNum">    2124 </span>            :   (cp_parser *, tree, tree, tree, bool, unsigned short);
<span class="lineNum">    2125 </span>            : static void do_range_for_auto_deduction
<span class="lineNum">    2126 </span>            :   (tree, tree);
<span class="lineNum">    2127 </span>            : static tree cp_parser_perform_range_for_lookup
<span class="lineNum">    2128 </span>            :   (tree, tree *, tree *);
<span class="lineNum">    2129 </span>            : static tree cp_parser_range_for_member_function
<span class="lineNum">    2130 </span>            :   (tree, tree);
<span class="lineNum">    2131 </span>            : static tree cp_parser_jump_statement
<span class="lineNum">    2132 </span>            :   (cp_parser *);
<span class="lineNum">    2133 </span>            : static void cp_parser_declaration_statement
<span class="lineNum">    2134 </span>            :   (cp_parser *);
<span class="lineNum">    2135 </span>            : 
<span class="lineNum">    2136 </span>            : static tree cp_parser_implicitly_scoped_statement
<span class="lineNum">    2137 </span>            :   (cp_parser *, bool *, const token_indent_info &amp;, vec&lt;tree&gt; * = NULL);
<span class="lineNum">    2138 </span>            : static void cp_parser_already_scoped_statement
<span class="lineNum">    2139 </span>            :   (cp_parser *, bool *, const token_indent_info &amp;);
<span class="lineNum">    2140 </span>            : 
<span class="lineNum">    2141 </span>            : /* Declarations [gram.dcl.dcl] */
<span class="lineNum">    2142 </span>            : 
<span class="lineNum">    2143 </span>            : static void cp_parser_declaration_seq_opt
<span class="lineNum">    2144 </span>            :   (cp_parser *);
<span class="lineNum">    2145 </span>            : static void cp_parser_declaration
<span class="lineNum">    2146 </span>            :   (cp_parser *);
<span class="lineNum">    2147 </span>            : static void cp_parser_block_declaration
<span class="lineNum">    2148 </span>            :   (cp_parser *, bool);
<span class="lineNum">    2149 </span>            : static void cp_parser_simple_declaration
<span class="lineNum">    2150 </span>            :   (cp_parser *, bool, tree *);
<span class="lineNum">    2151 </span>            : static void cp_parser_decl_specifier_seq
<span class="lineNum">    2152 </span>            :   (cp_parser *, cp_parser_flags, cp_decl_specifier_seq *, int *);
<span class="lineNum">    2153 </span>            : static tree cp_parser_storage_class_specifier_opt
<span class="lineNum">    2154 </span>            :   (cp_parser *);
<span class="lineNum">    2155 </span>            : static tree cp_parser_function_specifier_opt
<span class="lineNum">    2156 </span>            :   (cp_parser *, cp_decl_specifier_seq *);
<span class="lineNum">    2157 </span>            : static tree cp_parser_type_specifier
<span class="lineNum">    2158 </span>            :   (cp_parser *, cp_parser_flags, cp_decl_specifier_seq *, bool,
<span class="lineNum">    2159 </span>            :    int *, bool *);
<span class="lineNum">    2160 </span>            : static tree cp_parser_simple_type_specifier
<span class="lineNum">    2161 </span>            :   (cp_parser *, cp_decl_specifier_seq *, cp_parser_flags);
<span class="lineNum">    2162 </span>            : static tree cp_parser_type_name
<span class="lineNum">    2163 </span>            :   (cp_parser *, bool);
<span class="lineNum">    2164 </span>            : static tree cp_parser_type_name
<span class="lineNum">    2165 </span>            :   (cp_parser *);
<span class="lineNum">    2166 </span>            : static tree cp_parser_nonclass_name 
<span class="lineNum">    2167 </span>            :   (cp_parser* parser);
<span class="lineNum">    2168 </span>            : static tree cp_parser_elaborated_type_specifier
<span class="lineNum">    2169 </span>            :   (cp_parser *, bool, bool);
<span class="lineNum">    2170 </span>            : static tree cp_parser_enum_specifier
<span class="lineNum">    2171 </span>            :   (cp_parser *);
<span class="lineNum">    2172 </span>            : static void cp_parser_enumerator_list
<span class="lineNum">    2173 </span>            :   (cp_parser *, tree);
<span class="lineNum">    2174 </span>            : static void cp_parser_enumerator_definition
<span class="lineNum">    2175 </span>            :   (cp_parser *, tree);
<span class="lineNum">    2176 </span>            : static tree cp_parser_namespace_name
<span class="lineNum">    2177 </span>            :   (cp_parser *);
<span class="lineNum">    2178 </span>            : static void cp_parser_namespace_definition
<span class="lineNum">    2179 </span>            :   (cp_parser *);
<span class="lineNum">    2180 </span>            : static void cp_parser_namespace_body
<span class="lineNum">    2181 </span>            :   (cp_parser *);
<span class="lineNum">    2182 </span>            : static tree cp_parser_qualified_namespace_specifier
<span class="lineNum">    2183 </span>            :   (cp_parser *);
<span class="lineNum">    2184 </span>            : static void cp_parser_namespace_alias_definition
<span class="lineNum">    2185 </span>            :   (cp_parser *);
<span class="lineNum">    2186 </span>            : static bool cp_parser_using_declaration
<span class="lineNum">    2187 </span>            :   (cp_parser *, bool);
<span class="lineNum">    2188 </span>            : static void cp_parser_using_directive
<span class="lineNum">    2189 </span>            :   (cp_parser *);
<span class="lineNum">    2190 </span>            : static tree cp_parser_alias_declaration
<span class="lineNum">    2191 </span>            :   (cp_parser *);
<span class="lineNum">    2192 </span>            : static void cp_parser_asm_definition
<span class="lineNum">    2193 </span>            :   (cp_parser *);
<span class="lineNum">    2194 </span>            : static void cp_parser_linkage_specification
<span class="lineNum">    2195 </span>            :   (cp_parser *);
<span class="lineNum">    2196 </span>            : static void cp_parser_static_assert
<span class="lineNum">    2197 </span>            :   (cp_parser *, bool);
<span class="lineNum">    2198 </span>            : static tree cp_parser_decltype
<span class="lineNum">    2199 </span>            :   (cp_parser *);
<span class="lineNum">    2200 </span>            : static tree cp_parser_decomposition_declaration
<span class="lineNum">    2201 </span>            :   (cp_parser *, cp_decl_specifier_seq *, tree *, location_t *);
<span class="lineNum">    2202 </span>            : 
<span class="lineNum">    2203 </span>            : /* Declarators [gram.dcl.decl] */
<span class="lineNum">    2204 </span>            : 
<span class="lineNum">    2205 </span>            : static tree cp_parser_init_declarator
<span class="lineNum">    2206 </span>            :   (cp_parser *, cp_decl_specifier_seq *, vec&lt;deferred_access_check, va_gc&gt; *,
<span class="lineNum">    2207 </span>            :    bool, bool, int, bool *, tree *, location_t *, tree *);
<span class="lineNum">    2208 </span>            : static cp_declarator *cp_parser_declarator
<span class="lineNum">    2209 </span>            :   (cp_parser *, cp_parser_declarator_kind, int *, bool *, bool, bool);
<span class="lineNum">    2210 </span>            : static cp_declarator *cp_parser_direct_declarator
<span class="lineNum">    2211 </span>            :   (cp_parser *, cp_parser_declarator_kind, int *, bool, bool);
<span class="lineNum">    2212 </span>            : static enum tree_code cp_parser_ptr_operator
<span class="lineNum">    2213 </span>            :   (cp_parser *, tree *, cp_cv_quals *, tree *);
<span class="lineNum">    2214 </span>            : static cp_cv_quals cp_parser_cv_qualifier_seq_opt
<span class="lineNum">    2215 </span>            :   (cp_parser *);
<span class="lineNum">    2216 </span>            : static cp_virt_specifiers cp_parser_virt_specifier_seq_opt
<span class="lineNum">    2217 </span>            :   (cp_parser *);
<span class="lineNum">    2218 </span>            : static cp_ref_qualifier cp_parser_ref_qualifier_opt
<span class="lineNum">    2219 </span>            :   (cp_parser *);
<span class="lineNum">    2220 </span>            : static tree cp_parser_tx_qualifier_opt
<span class="lineNum">    2221 </span>            :   (cp_parser *);
<span class="lineNum">    2222 </span>            : static tree cp_parser_late_return_type_opt
<span class="lineNum">    2223 </span>            :   (cp_parser *, cp_declarator *, tree &amp;, cp_cv_quals);
<span class="lineNum">    2224 </span>            : static tree cp_parser_declarator_id
<span class="lineNum">    2225 </span>            :   (cp_parser *, bool);
<span class="lineNum">    2226 </span>            : static tree cp_parser_type_id
<span class="lineNum">    2227 </span>            :   (cp_parser *);
<span class="lineNum">    2228 </span>            : static tree cp_parser_template_type_arg
<span class="lineNum">    2229 </span>            :   (cp_parser *);
<span class="lineNum">    2230 </span>            : static tree cp_parser_trailing_type_id (cp_parser *);
<span class="lineNum">    2231 </span>            : static tree cp_parser_type_id_1
<span class="lineNum">    2232 </span>            :   (cp_parser *, bool, bool);
<span class="lineNum">    2233 </span>            : static void cp_parser_type_specifier_seq
<span class="lineNum">    2234 </span>            :   (cp_parser *, bool, bool, cp_decl_specifier_seq *);
<span class="lineNum">    2235 </span>            : static tree cp_parser_parameter_declaration_clause
<span class="lineNum">    2236 </span>            :   (cp_parser *);
<span class="lineNum">    2237 </span>            : static tree cp_parser_parameter_declaration_list
<span class="lineNum">    2238 </span>            :   (cp_parser *);
<span class="lineNum">    2239 </span>            : static cp_parameter_declarator *cp_parser_parameter_declaration
<span class="lineNum">    2240 </span>            :   (cp_parser *, bool, bool *);
<span class="lineNum">    2241 </span>            : static tree cp_parser_default_argument 
<span class="lineNum">    2242 </span>            :   (cp_parser *, bool);
<span class="lineNum">    2243 </span>            : static void cp_parser_function_body
<span class="lineNum">    2244 </span>            :   (cp_parser *, bool);
<span class="lineNum">    2245 </span>            : static tree cp_parser_initializer
<span class="lineNum">    2246 </span>            :   (cp_parser *, bool *, bool *, bool = false);
<span class="lineNum">    2247 </span>            : static cp_expr cp_parser_initializer_clause
<span class="lineNum">    2248 </span>            :   (cp_parser *, bool *);
<span class="lineNum">    2249 </span>            : static cp_expr cp_parser_braced_list
<span class="lineNum">    2250 </span>            :   (cp_parser*, bool*);
<span class="lineNum">    2251 </span>            : static vec&lt;constructor_elt, va_gc&gt; *cp_parser_initializer_list
<span class="lineNum">    2252 </span>            :   (cp_parser *, bool *);
<span class="lineNum">    2253 </span>            : 
<span class="lineNum">    2254 </span>            : static void cp_parser_ctor_initializer_opt_and_function_body
<span class="lineNum">    2255 </span>            :   (cp_parser *, bool);
<span class="lineNum">    2256 </span>            : 
<span class="lineNum">    2257 </span>            : static tree cp_parser_late_parsing_omp_declare_simd
<span class="lineNum">    2258 </span>            :   (cp_parser *, tree);
<span class="lineNum">    2259 </span>            : 
<span class="lineNum">    2260 </span>            : static tree cp_parser_late_parsing_oacc_routine
<span class="lineNum">    2261 </span>            :   (cp_parser *, tree);
<span class="lineNum">    2262 </span>            : 
<span class="lineNum">    2263 </span>            : static tree synthesize_implicit_template_parm
<span class="lineNum">    2264 </span>            :   (cp_parser *, tree);
<span class="lineNum">    2265 </span>            : static tree finish_fully_implicit_template
<span class="lineNum">    2266 </span>            :   (cp_parser *, tree);
<span class="lineNum">    2267 </span>            : static void abort_fully_implicit_template
<span class="lineNum">    2268 </span>            :   (cp_parser *);
<span class="lineNum">    2269 </span>            : 
<span class="lineNum">    2270 </span>            : /* Classes [gram.class] */
<span class="lineNum">    2271 </span>            : 
<span class="lineNum">    2272 </span>            : static tree cp_parser_class_name
<span class="lineNum">    2273 </span>            :   (cp_parser *, bool, bool, enum tag_types, bool, bool, bool, bool = false);
<span class="lineNum">    2274 </span>            : static tree cp_parser_class_specifier
<span class="lineNum">    2275 </span>            :   (cp_parser *);
<span class="lineNum">    2276 </span>            : static tree cp_parser_class_head
<span class="lineNum">    2277 </span>            :   (cp_parser *, bool *);
<span class="lineNum">    2278 </span>            : static enum tag_types cp_parser_class_key
<span class="lineNum">    2279 </span>            :   (cp_parser *);
<span class="lineNum">    2280 </span>            : static void cp_parser_type_parameter_key
<span class="lineNum">    2281 </span>            :   (cp_parser* parser);
<span class="lineNum">    2282 </span>            : static void cp_parser_member_specification_opt
<span class="lineNum">    2283 </span>            :   (cp_parser *);
<span class="lineNum">    2284 </span>            : static void cp_parser_member_declaration
<span class="lineNum">    2285 </span>            :   (cp_parser *);
<span class="lineNum">    2286 </span>            : static tree cp_parser_pure_specifier
<span class="lineNum">    2287 </span>            :   (cp_parser *);
<span class="lineNum">    2288 </span>            : static tree cp_parser_constant_initializer
<span class="lineNum">    2289 </span>            :   (cp_parser *);
<span class="lineNum">    2290 </span>            : 
<span class="lineNum">    2291 </span>            : /* Derived classes [gram.class.derived] */
<span class="lineNum">    2292 </span>            : 
<span class="lineNum">    2293 </span>            : static tree cp_parser_base_clause
<span class="lineNum">    2294 </span>            :   (cp_parser *);
<span class="lineNum">    2295 </span>            : static tree cp_parser_base_specifier
<span class="lineNum">    2296 </span>            :   (cp_parser *);
<span class="lineNum">    2297 </span>            : 
<span class="lineNum">    2298 </span>            : /* Special member functions [gram.special] */
<span class="lineNum">    2299 </span>            : 
<span class="lineNum">    2300 </span>            : static tree cp_parser_conversion_function_id
<span class="lineNum">    2301 </span>            :   (cp_parser *);
<span class="lineNum">    2302 </span>            : static tree cp_parser_conversion_type_id
<span class="lineNum">    2303 </span>            :   (cp_parser *);
<span class="lineNum">    2304 </span>            : static cp_declarator *cp_parser_conversion_declarator_opt
<span class="lineNum">    2305 </span>            :   (cp_parser *);
<span class="lineNum">    2306 </span>            : static void cp_parser_ctor_initializer_opt
<span class="lineNum">    2307 </span>            :   (cp_parser *);
<span class="lineNum">    2308 </span>            : static void cp_parser_mem_initializer_list
<span class="lineNum">    2309 </span>            :   (cp_parser *);
<span class="lineNum">    2310 </span>            : static tree cp_parser_mem_initializer
<span class="lineNum">    2311 </span>            :   (cp_parser *);
<span class="lineNum">    2312 </span>            : static tree cp_parser_mem_initializer_id
<span class="lineNum">    2313 </span>            :   (cp_parser *);
<span class="lineNum">    2314 </span>            : 
<span class="lineNum">    2315 </span>            : /* Overloading [gram.over] */
<span class="lineNum">    2316 </span>            : 
<span class="lineNum">    2317 </span>            : static cp_expr cp_parser_operator_function_id
<span class="lineNum">    2318 </span>            :   (cp_parser *);
<span class="lineNum">    2319 </span>            : static cp_expr cp_parser_operator
<span class="lineNum">    2320 </span>            :   (cp_parser *);
<span class="lineNum">    2321 </span>            : 
<span class="lineNum">    2322 </span>            : /* Templates [gram.temp] */
<span class="lineNum">    2323 </span>            : 
<span class="lineNum">    2324 </span>            : static void cp_parser_template_declaration
<span class="lineNum">    2325 </span>            :   (cp_parser *, bool);
<span class="lineNum">    2326 </span>            : static tree cp_parser_template_parameter_list
<span class="lineNum">    2327 </span>            :   (cp_parser *);
<span class="lineNum">    2328 </span>            : static tree cp_parser_template_parameter
<span class="lineNum">    2329 </span>            :   (cp_parser *, bool *, bool *);
<span class="lineNum">    2330 </span>            : static tree cp_parser_type_parameter
<span class="lineNum">    2331 </span>            :   (cp_parser *, bool *);
<span class="lineNum">    2332 </span>            : static tree cp_parser_template_id
<span class="lineNum">    2333 </span>            :   (cp_parser *, bool, bool, enum tag_types, bool);
<span class="lineNum">    2334 </span>            : static tree cp_parser_template_name
<span class="lineNum">    2335 </span>            :   (cp_parser *, bool, bool, bool, enum tag_types, bool *);
<span class="lineNum">    2336 </span>            : static tree cp_parser_template_argument_list
<span class="lineNum">    2337 </span>            :   (cp_parser *);
<span class="lineNum">    2338 </span>            : static tree cp_parser_template_argument
<span class="lineNum">    2339 </span>            :   (cp_parser *);
<span class="lineNum">    2340 </span>            : static void cp_parser_explicit_instantiation
<span class="lineNum">    2341 </span>            :   (cp_parser *);
<span class="lineNum">    2342 </span>            : static void cp_parser_explicit_specialization
<span class="lineNum">    2343 </span>            :   (cp_parser *);
<span class="lineNum">    2344 </span>            : 
<span class="lineNum">    2345 </span>            : /* Exception handling [gram.exception] */
<span class="lineNum">    2346 </span>            : 
<span class="lineNum">    2347 </span>            : static tree cp_parser_try_block
<span class="lineNum">    2348 </span>            :   (cp_parser *);
<span class="lineNum">    2349 </span>            : static void cp_parser_function_try_block
<span class="lineNum">    2350 </span>            :   (cp_parser *);
<span class="lineNum">    2351 </span>            : static void cp_parser_handler_seq
<span class="lineNum">    2352 </span>            :   (cp_parser *);
<span class="lineNum">    2353 </span>            : static void cp_parser_handler
<span class="lineNum">    2354 </span>            :   (cp_parser *);
<span class="lineNum">    2355 </span>            : static tree cp_parser_exception_declaration
<span class="lineNum">    2356 </span>            :   (cp_parser *);
<span class="lineNum">    2357 </span>            : static tree cp_parser_throw_expression
<span class="lineNum">    2358 </span>            :   (cp_parser *);
<span class="lineNum">    2359 </span>            : static tree cp_parser_exception_specification_opt
<span class="lineNum">    2360 </span>            :   (cp_parser *);
<span class="lineNum">    2361 </span>            : static tree cp_parser_type_id_list
<span class="lineNum">    2362 </span>            :   (cp_parser *);
<span class="lineNum">    2363 </span>            : 
<span class="lineNum">    2364 </span>            : /* GNU Extensions */
<span class="lineNum">    2365 </span>            : 
<span class="lineNum">    2366 </span>            : static tree cp_parser_asm_specification_opt
<span class="lineNum">    2367 </span>            :   (cp_parser *);
<span class="lineNum">    2368 </span>            : static tree cp_parser_asm_operand_list
<span class="lineNum">    2369 </span>            :   (cp_parser *);
<span class="lineNum">    2370 </span>            : static tree cp_parser_asm_clobber_list
<span class="lineNum">    2371 </span>            :   (cp_parser *);
<span class="lineNum">    2372 </span>            : static tree cp_parser_asm_label_list
<span class="lineNum">    2373 </span>            :   (cp_parser *);
<span class="lineNum">    2374 </span>            : static bool cp_next_tokens_can_be_attribute_p
<span class="lineNum">    2375 </span>            :   (cp_parser *);
<span class="lineNum">    2376 </span>            : static bool cp_next_tokens_can_be_gnu_attribute_p
<span class="lineNum">    2377 </span>            :   (cp_parser *);
<span class="lineNum">    2378 </span>            : static bool cp_next_tokens_can_be_std_attribute_p
<span class="lineNum">    2379 </span>            :   (cp_parser *);
<span class="lineNum">    2380 </span>            : static bool cp_nth_tokens_can_be_std_attribute_p
<span class="lineNum">    2381 </span>            :   (cp_parser *, size_t);
<span class="lineNum">    2382 </span>            : static bool cp_nth_tokens_can_be_gnu_attribute_p
<span class="lineNum">    2383 </span>            :   (cp_parser *, size_t);
<span class="lineNum">    2384 </span>            : static bool cp_nth_tokens_can_be_attribute_p
<span class="lineNum">    2385 </span>            :   (cp_parser *, size_t);
<span class="lineNum">    2386 </span>            : static tree cp_parser_attributes_opt
<span class="lineNum">    2387 </span>            :   (cp_parser *);
<span class="lineNum">    2388 </span>            : static tree cp_parser_gnu_attributes_opt
<span class="lineNum">    2389 </span>            :   (cp_parser *);
<span class="lineNum">    2390 </span>            : static tree cp_parser_gnu_attribute_list
<span class="lineNum">    2391 </span>            :   (cp_parser *);
<span class="lineNum">    2392 </span>            : static tree cp_parser_std_attribute
<span class="lineNum">    2393 </span>            :   (cp_parser *, tree);
<span class="lineNum">    2394 </span>            : static tree cp_parser_std_attribute_spec
<span class="lineNum">    2395 </span>            :   (cp_parser *);
<span class="lineNum">    2396 </span>            : static tree cp_parser_std_attribute_spec_seq
<span class="lineNum">    2397 </span>            :   (cp_parser *);
<span class="lineNum">    2398 </span>            : static size_t cp_parser_skip_attributes_opt
<span class="lineNum">    2399 </span>            :   (cp_parser *, size_t);
<span class="lineNum">    2400 </span>            : static bool cp_parser_extension_opt
<span class="lineNum">    2401 </span>            :   (cp_parser *, int *);
<span class="lineNum">    2402 </span>            : static void cp_parser_label_declaration
<span class="lineNum">    2403 </span>            :   (cp_parser *);
<span class="lineNum">    2404 </span>            : 
<span class="lineNum">    2405 </span>            : /* Concept Extensions */
<span class="lineNum">    2406 </span>            : 
<span class="lineNum">    2407 </span>            : static tree cp_parser_requires_clause
<span class="lineNum">    2408 </span>            :   (cp_parser *);
<span class="lineNum">    2409 </span>            : static tree cp_parser_requires_clause_opt
<span class="lineNum">    2410 </span>            :   (cp_parser *);
<span class="lineNum">    2411 </span>            : static tree cp_parser_requires_expression
<span class="lineNum">    2412 </span>            :   (cp_parser *);
<span class="lineNum">    2413 </span>            : static tree cp_parser_requirement_parameter_list
<span class="lineNum">    2414 </span>            :   (cp_parser *);
<span class="lineNum">    2415 </span>            : static tree cp_parser_requirement_body
<span class="lineNum">    2416 </span>            :   (cp_parser *);
<span class="lineNum">    2417 </span>            : static tree cp_parser_requirement_list
<span class="lineNum">    2418 </span>            :   (cp_parser *);
<span class="lineNum">    2419 </span>            : static tree cp_parser_requirement
<span class="lineNum">    2420 </span>            :   (cp_parser *);
<span class="lineNum">    2421 </span>            : static tree cp_parser_simple_requirement
<span class="lineNum">    2422 </span>            :   (cp_parser *);
<span class="lineNum">    2423 </span>            : static tree cp_parser_compound_requirement
<span class="lineNum">    2424 </span>            :   (cp_parser *);
<span class="lineNum">    2425 </span>            : static tree cp_parser_type_requirement
<span class="lineNum">    2426 </span>            :   (cp_parser *);
<span class="lineNum">    2427 </span>            : static tree cp_parser_nested_requirement
<span class="lineNum">    2428 </span>            :   (cp_parser *);
<span class="lineNum">    2429 </span>            : 
<span class="lineNum">    2430 </span>            : /* Transactional Memory Extensions */
<span class="lineNum">    2431 </span>            : 
<span class="lineNum">    2432 </span>            : static tree cp_parser_transaction
<span class="lineNum">    2433 </span>            :   (cp_parser *, cp_token *);
<span class="lineNum">    2434 </span>            : static tree cp_parser_transaction_expression
<span class="lineNum">    2435 </span>            :   (cp_parser *, enum rid);
<span class="lineNum">    2436 </span>            : static void cp_parser_function_transaction
<span class="lineNum">    2437 </span>            :   (cp_parser *, enum rid);
<span class="lineNum">    2438 </span>            : static tree cp_parser_transaction_cancel
<span class="lineNum">    2439 </span>            :   (cp_parser *);
<span class="lineNum">    2440 </span>            : 
<span class="lineNum">    2441 </span>            : enum pragma_context {
<span class="lineNum">    2442 </span>            :   pragma_external,
<span class="lineNum">    2443 </span>            :   pragma_member,
<span class="lineNum">    2444 </span>            :   pragma_objc_icode,
<span class="lineNum">    2445 </span>            :   pragma_stmt,
<span class="lineNum">    2446 </span>            :   pragma_compound
<span class="lineNum">    2447 </span>            : };
<span class="lineNum">    2448 </span>            : static bool cp_parser_pragma
<span class="lineNum">    2449 </span>            :   (cp_parser *, enum pragma_context, bool *);
<span class="lineNum">    2450 </span>            : 
<span class="lineNum">    2451 </span>            : /* Objective-C++ Productions */
<span class="lineNum">    2452 </span>            : 
<span class="lineNum">    2453 </span>            : static tree cp_parser_objc_message_receiver
<span class="lineNum">    2454 </span>            :   (cp_parser *);
<span class="lineNum">    2455 </span>            : static tree cp_parser_objc_message_args
<span class="lineNum">    2456 </span>            :   (cp_parser *);
<span class="lineNum">    2457 </span>            : static tree cp_parser_objc_message_expression
<span class="lineNum">    2458 </span>            :   (cp_parser *);
<span class="lineNum">    2459 </span>            : static cp_expr cp_parser_objc_encode_expression
<span class="lineNum">    2460 </span>            :   (cp_parser *);
<span class="lineNum">    2461 </span>            : static tree cp_parser_objc_defs_expression
<span class="lineNum">    2462 </span>            :   (cp_parser *);
<span class="lineNum">    2463 </span>            : static tree cp_parser_objc_protocol_expression
<span class="lineNum">    2464 </span>            :   (cp_parser *);
<span class="lineNum">    2465 </span>            : static tree cp_parser_objc_selector_expression
<span class="lineNum">    2466 </span>            :   (cp_parser *);
<span class="lineNum">    2467 </span>            : static cp_expr cp_parser_objc_expression
<span class="lineNum">    2468 </span>            :   (cp_parser *);
<span class="lineNum">    2469 </span>            : static bool cp_parser_objc_selector_p
<span class="lineNum">    2470 </span>            :   (enum cpp_ttype);
<span class="lineNum">    2471 </span>            : static tree cp_parser_objc_selector
<span class="lineNum">    2472 </span>            :   (cp_parser *);
<span class="lineNum">    2473 </span>            : static tree cp_parser_objc_protocol_refs_opt
<span class="lineNum">    2474 </span>            :   (cp_parser *);
<span class="lineNum">    2475 </span>            : static void cp_parser_objc_declaration
<span class="lineNum">    2476 </span>            :   (cp_parser *, tree);
<span class="lineNum">    2477 </span>            : static tree cp_parser_objc_statement
<span class="lineNum">    2478 </span>            :   (cp_parser *);
<span class="lineNum">    2479 </span>            : static bool cp_parser_objc_valid_prefix_attributes
<span class="lineNum">    2480 </span>            :   (cp_parser *, tree *);
<span class="lineNum">    2481 </span>            : static void cp_parser_objc_at_property_declaration 
<span class="lineNum">    2482 </span>            :   (cp_parser *) ;
<span class="lineNum">    2483 </span>            : static void cp_parser_objc_at_synthesize_declaration 
<span class="lineNum">    2484 </span>            :   (cp_parser *) ;
<span class="lineNum">    2485 </span>            : static void cp_parser_objc_at_dynamic_declaration
<span class="lineNum">    2486 </span>            :   (cp_parser *) ;
<span class="lineNum">    2487 </span>            : static tree cp_parser_objc_struct_declaration
<span class="lineNum">    2488 </span>            :   (cp_parser *) ;
<span class="lineNum">    2489 </span>            : 
<span class="lineNum">    2490 </span>            : /* Utility Routines */
<span class="lineNum">    2491 </span>            : 
<span class="lineNum">    2492 </span>            : static cp_expr cp_parser_lookup_name
<span class="lineNum">    2493 </span>            :   (cp_parser *, tree, enum tag_types, bool, bool, bool, tree *, location_t);
<span class="lineNum">    2494 </span>            : static tree cp_parser_lookup_name_simple
<span class="lineNum">    2495 </span>            :   (cp_parser *, tree, location_t);
<span class="lineNum">    2496 </span>            : static tree cp_parser_maybe_treat_template_as_class
<span class="lineNum">    2497 </span>            :   (tree, bool);
<span class="lineNum">    2498 </span>            : static bool cp_parser_check_declarator_template_parameters
<span class="lineNum">    2499 </span>            :   (cp_parser *, cp_declarator *, location_t);
<span class="lineNum">    2500 </span>            : static bool cp_parser_check_template_parameters
<span class="lineNum">    2501 </span>            :   (cp_parser *, unsigned, bool, location_t, cp_declarator *);
<span class="lineNum">    2502 </span>            : static cp_expr cp_parser_simple_cast_expression
<span class="lineNum">    2503 </span>            :   (cp_parser *);
<span class="lineNum">    2504 </span>            : static tree cp_parser_global_scope_opt
<span class="lineNum">    2505 </span>            :   (cp_parser *, bool);
<span class="lineNum">    2506 </span>            : static bool cp_parser_constructor_declarator_p
<span class="lineNum">    2507 </span>            :   (cp_parser *, bool);
<span class="lineNum">    2508 </span>            : static tree cp_parser_function_definition_from_specifiers_and_declarator
<span class="lineNum">    2509 </span>            :   (cp_parser *, cp_decl_specifier_seq *, tree, const cp_declarator *);
<span class="lineNum">    2510 </span>            : static tree cp_parser_function_definition_after_declarator
<span class="lineNum">    2511 </span>            :   (cp_parser *, bool);
<span class="lineNum">    2512 </span>            : static bool cp_parser_template_declaration_after_export
<span class="lineNum">    2513 </span>            :   (cp_parser *, bool);
<span class="lineNum">    2514 </span>            : static void cp_parser_perform_template_parameter_access_checks
<span class="lineNum">    2515 </span>            :   (vec&lt;deferred_access_check, va_gc&gt; *);
<span class="lineNum">    2516 </span>            : static tree cp_parser_single_declaration
<span class="lineNum">    2517 </span>            :   (cp_parser *, vec&lt;deferred_access_check, va_gc&gt; *, bool, bool, bool *);
<span class="lineNum">    2518 </span>            : static cp_expr cp_parser_functional_cast
<span class="lineNum">    2519 </span>            :   (cp_parser *, tree);
<span class="lineNum">    2520 </span>            : static tree cp_parser_save_member_function_body
<span class="lineNum">    2521 </span>            :   (cp_parser *, cp_decl_specifier_seq *, cp_declarator *, tree);
<span class="lineNum">    2522 </span>            : static tree cp_parser_save_nsdmi
<span class="lineNum">    2523 </span>            :   (cp_parser *);
<span class="lineNum">    2524 </span>            : static tree cp_parser_enclosed_template_argument_list
<span class="lineNum">    2525 </span>            :   (cp_parser *);
<span class="lineNum">    2526 </span>            : static void cp_parser_save_default_args
<span class="lineNum">    2527 </span>            :   (cp_parser *, tree);
<span class="lineNum">    2528 </span>            : static void cp_parser_late_parsing_for_member
<span class="lineNum">    2529 </span>            :   (cp_parser *, tree);
<span class="lineNum">    2530 </span>            : static tree cp_parser_late_parse_one_default_arg
<span class="lineNum">    2531 </span>            :   (cp_parser *, tree, tree, tree);
<span class="lineNum">    2532 </span>            : static void cp_parser_late_parsing_nsdmi
<span class="lineNum">    2533 </span>            :   (cp_parser *, tree);
<span class="lineNum">    2534 </span>            : static void cp_parser_late_parsing_default_args
<span class="lineNum">    2535 </span>            :   (cp_parser *, tree);
<span class="lineNum">    2536 </span>            : static tree cp_parser_sizeof_operand
<span class="lineNum">    2537 </span>            :   (cp_parser *, enum rid);
<span class="lineNum">    2538 </span>            : static cp_expr cp_parser_trait_expr
<span class="lineNum">    2539 </span>            :   (cp_parser *, enum rid);
<span class="lineNum">    2540 </span>            : static bool cp_parser_declares_only_class_p
<span class="lineNum">    2541 </span>            :   (cp_parser *);
<span class="lineNum">    2542 </span>            : static void cp_parser_set_storage_class
<span class="lineNum">    2543 </span>            :   (cp_parser *, cp_decl_specifier_seq *, enum rid, cp_token *);
<span class="lineNum">    2544 </span>            : static void cp_parser_set_decl_spec_type
<span class="lineNum">    2545 </span>            :   (cp_decl_specifier_seq *, tree, cp_token *, bool);
<span class="lineNum">    2546 </span>            : static void set_and_check_decl_spec_loc
<span class="lineNum">    2547 </span>            :   (cp_decl_specifier_seq *decl_specs,
<span class="lineNum">    2548 </span>            :    cp_decl_spec ds, cp_token *);
<span class="lineNum">    2549 </span>            : static bool cp_parser_friend_p
<span class="lineNum">    2550 </span>            :   (const cp_decl_specifier_seq *);
<span class="lineNum">    2551 </span>            : static void cp_parser_required_error
<span class="lineNum">    2552 </span>            :   (cp_parser *, required_token, bool, location_t);
<span class="lineNum">    2553 </span>            : static cp_token *cp_parser_require
<span class="lineNum">    2554 </span>            :   (cp_parser *, enum cpp_ttype, required_token, location_t = UNKNOWN_LOCATION);
<span class="lineNum">    2555 </span>            : static cp_token *cp_parser_require_keyword
<span class="lineNum">    2556 </span>            :   (cp_parser *, enum rid, required_token);
<span class="lineNum">    2557 </span>            : static bool cp_parser_token_starts_function_definition_p
<span class="lineNum">    2558 </span>            :   (cp_token *);
<span class="lineNum">    2559 </span>            : static bool cp_parser_next_token_starts_class_definition_p
<span class="lineNum">    2560 </span>            :   (cp_parser *);
<span class="lineNum">    2561 </span>            : static bool cp_parser_next_token_ends_template_argument_p
<span class="lineNum">    2562 </span>            :   (cp_parser *);
<span class="lineNum">    2563 </span>            : static bool cp_parser_nth_token_starts_template_argument_list_p
<span class="lineNum">    2564 </span>            :   (cp_parser *, size_t);
<span class="lineNum">    2565 </span>            : static enum tag_types cp_parser_token_is_class_key
<span class="lineNum">    2566 </span>            :   (cp_token *);
<span class="lineNum">    2567 </span>            : static enum tag_types cp_parser_token_is_type_parameter_key
<span class="lineNum">    2568 </span>            :   (cp_token *);
<span class="lineNum">    2569 </span>            : static void cp_parser_check_class_key
<span class="lineNum">    2570 </span>            :   (enum tag_types, tree type);
<span class="lineNum">    2571 </span>            : static void cp_parser_check_access_in_redeclaration
<span class="lineNum">    2572 </span>            :   (tree type, location_t location);
<span class="lineNum">    2573 </span>            : static bool cp_parser_optional_template_keyword
<span class="lineNum">    2574 </span>            :   (cp_parser *);
<span class="lineNum">    2575 </span>            : static void cp_parser_pre_parsed_nested_name_specifier
<span class="lineNum">    2576 </span>            :   (cp_parser *);
<span class="lineNum">    2577 </span>            : static bool cp_parser_cache_group
<span class="lineNum">    2578 </span>            :   (cp_parser *, enum cpp_ttype, unsigned);
<span class="lineNum">    2579 </span>            : static tree cp_parser_cache_defarg
<span class="lineNum">    2580 </span>            :   (cp_parser *parser, bool nsdmi);
<span class="lineNum">    2581 </span>            : static void cp_parser_parse_tentatively
<span class="lineNum">    2582 </span>            :   (cp_parser *);
<span class="lineNum">    2583 </span>            : static void cp_parser_commit_to_tentative_parse
<span class="lineNum">    2584 </span>            :   (cp_parser *);
<span class="lineNum">    2585 </span>            : static void cp_parser_commit_to_topmost_tentative_parse
<span class="lineNum">    2586 </span>            :   (cp_parser *);
<span class="lineNum">    2587 </span>            : static void cp_parser_abort_tentative_parse
<span class="lineNum">    2588 </span>            :   (cp_parser *);
<span class="lineNum">    2589 </span>            : static bool cp_parser_parse_definitely
<span class="lineNum">    2590 </span>            :   (cp_parser *);
<span class="lineNum">    2591 </span>            : static inline bool cp_parser_parsing_tentatively
<span class="lineNum">    2592 </span>            :   (cp_parser *);
<span class="lineNum">    2593 </span>            : static bool cp_parser_uncommitted_to_tentative_parse_p
<span class="lineNum">    2594 </span>            :   (cp_parser *);
<span class="lineNum">    2595 </span>            : static void cp_parser_error
<span class="lineNum">    2596 </span>            :   (cp_parser *, const char *);
<span class="lineNum">    2597 </span>            : static void cp_parser_name_lookup_error
<span class="lineNum">    2598 </span>            :   (cp_parser *, tree, tree, name_lookup_error, location_t);
<span class="lineNum">    2599 </span>            : static bool cp_parser_simulate_error
<span class="lineNum">    2600 </span>            :   (cp_parser *);
<span class="lineNum">    2601 </span>            : static bool cp_parser_check_type_definition
<span class="lineNum">    2602 </span>            :   (cp_parser *);
<span class="lineNum">    2603 </span>            : static void cp_parser_check_for_definition_in_return_type
<span class="lineNum">    2604 </span>            :   (cp_declarator *, tree, location_t type_location);
<span class="lineNum">    2605 </span>            : static void cp_parser_check_for_invalid_template_id
<span class="lineNum">    2606 </span>            :   (cp_parser *, tree, enum tag_types, location_t location);
<span class="lineNum">    2607 </span>            : static bool cp_parser_non_integral_constant_expression
<span class="lineNum">    2608 </span>            :   (cp_parser *, non_integral_constant);
<span class="lineNum">    2609 </span>            : static void cp_parser_diagnose_invalid_type_name
<span class="lineNum">    2610 </span>            :   (cp_parser *, tree, location_t);
<span class="lineNum">    2611 </span>            : static bool cp_parser_parse_and_diagnose_invalid_type_name
<span class="lineNum">    2612 </span>            :   (cp_parser *);
<span class="lineNum">    2613 </span>            : static int cp_parser_skip_to_closing_parenthesis
<span class="lineNum">    2614 </span>            :   (cp_parser *, bool, bool, bool);
<span class="lineNum">    2615 </span>            : static void cp_parser_skip_to_end_of_statement
<span class="lineNum">    2616 </span>            :   (cp_parser *);
<span class="lineNum">    2617 </span>            : static void cp_parser_consume_semicolon_at_end_of_statement
<span class="lineNum">    2618 </span>            :   (cp_parser *);
<span class="lineNum">    2619 </span>            : static void cp_parser_skip_to_end_of_block_or_statement
<span class="lineNum">    2620 </span>            :   (cp_parser *);
<span class="lineNum">    2621 </span>            : static bool cp_parser_skip_to_closing_brace
<span class="lineNum">    2622 </span>            :   (cp_parser *);
<span class="lineNum">    2623 </span>            : static void cp_parser_skip_to_end_of_template_parameter_list
<span class="lineNum">    2624 </span>            :   (cp_parser *);
<span class="lineNum">    2625 </span>            : static void cp_parser_skip_to_pragma_eol
<span class="lineNum">    2626 </span>            :   (cp_parser*, cp_token *);
<span class="lineNum">    2627 </span>            : static bool cp_parser_error_occurred
<span class="lineNum">    2628 </span>            :   (cp_parser *);
<span class="lineNum">    2629 </span>            : static bool cp_parser_allow_gnu_extensions_p
<span class="lineNum">    2630 </span>            :   (cp_parser *);
<span class="lineNum">    2631 </span>            : static bool cp_parser_is_pure_string_literal
<span class="lineNum">    2632 </span>            :   (cp_token *);
<span class="lineNum">    2633 </span>            : static bool cp_parser_is_string_literal
<span class="lineNum">    2634 </span>            :   (cp_token *);
<span class="lineNum">    2635 </span>            : static bool cp_parser_is_keyword
<span class="lineNum">    2636 </span>            :   (cp_token *, enum rid);
<span class="lineNum">    2637 </span>            : static tree cp_parser_make_typename_type
<span class="lineNum">    2638 </span>            :   (cp_parser *, tree, location_t location);
<span class="lineNum">    2639 </span>            : static cp_declarator * cp_parser_make_indirect_declarator
<span class="lineNum">    2640 </span>            :   (enum tree_code, tree, cp_cv_quals, cp_declarator *, tree);
<span class="lineNum">    2641 </span>            : static bool cp_parser_compound_literal_p
<span class="lineNum">    2642 </span>            :   (cp_parser *);
<span class="lineNum">    2643 </span>            : static bool cp_parser_array_designator_p
<span class="lineNum">    2644 </span>            :   (cp_parser *);
<span class="lineNum">    2645 </span>            : static bool cp_parser_init_statement_p
<span class="lineNum">    2646 </span>            :   (cp_parser *);
<span class="lineNum">    2647 </span>            : static bool cp_parser_skip_to_closing_square_bracket
<span class="lineNum">    2648 </span>            :   (cp_parser *);
<span class="lineNum">    2649 </span>            : 
<span class="lineNum">    2650 </span>            : /* Concept-related syntactic transformations */
<span class="lineNum">    2651 </span>            : 
<span class="lineNum">    2652 </span>            : static tree cp_parser_maybe_concept_name       (cp_parser *, tree);
<span class="lineNum">    2653 </span>            : static tree cp_parser_maybe_partial_concept_id (cp_parser *, tree, tree);
<span class="lineNum">    2654 </span>            : 
<span class="lineNum">    2655 </span>            : // -------------------------------------------------------------------------- //
<span class="lineNum">    2656 </span>            : // Unevaluated Operand Guard
<a name="2657"><span class="lineNum">    2657 </span>            : //</a>
<span class="lineNum">    2658 </span>            : // Implementation of an RAII helper for unevaluated operand parsing.
<span class="lineNum">    2659 </span><span class="lineCov">     147525 : cp_unevaluated::cp_unevaluated ()</span>
<span class="lineNum">    2660 </span>            : {
<span class="lineNum">    2661 </span><span class="lineCov">     147525 :   ++cp_unevaluated_operand;</span>
<span class="lineNum">    2662 </span><span class="lineCov">     147525 :   ++c_inhibit_evaluation_warnings;</span>
<a name="2663"><span class="lineNum">    2663 </span><span class="lineCov">     147525 : }</span></a>
<span class="lineNum">    2664 </span>            : 
<span class="lineNum">    2665 </span><span class="lineCov">     147525 : cp_unevaluated::~cp_unevaluated ()</span>
<span class="lineNum">    2666 </span>            : {
<span class="lineNum">    2667 </span><span class="lineCov">     147525 :   --c_inhibit_evaluation_warnings;</span>
<span class="lineNum">    2668 </span><span class="lineCov">     147525 :   --cp_unevaluated_operand;</span>
<span class="lineNum">    2669 </span><span class="lineCov">     147525 : }</span>
<span class="lineNum">    2670 </span>            : 
<span class="lineNum">    2671 </span>            : // -------------------------------------------------------------------------- //
<span class="lineNum">    2672 </span>            : // Tentative Parsing
<span class="lineNum">    2673 </span>            : 
<span class="lineNum">    2674 </span>            : /* Returns nonzero if we are parsing tentatively.  */
<a name="2675"><span class="lineNum">    2675 </span>            : </a>
<span class="lineNum">    2676 </span>            : static inline bool
<span class="lineNum">    2677 </span><span class="lineNoCov">          0 : cp_parser_parsing_tentatively (cp_parser* parser)</span>
<span class="lineNum">    2678 </span>            : {
<span class="lineNum">    2679 </span><span class="lineCov"> 1777352803 :   return parser-&gt;context-&gt;next != NULL;</span>
<span class="lineNum">    2680 </span>            : }
<span class="lineNum">    2681 </span>            : 
<span class="lineNum">    2682 </span>            : /* Returns nonzero if TOKEN is a string literal.  */
<a name="2683"><span class="lineNum">    2683 </span>            : </a>
<span class="lineNum">    2684 </span>            : static bool
<span class="lineNum">    2685 </span><span class="lineNoCov">          0 : cp_parser_is_pure_string_literal (cp_token* token)</span>
<span class="lineNum">    2686 </span>            : {
<span class="lineNum">    2687 </span><span class="lineCov">    6888696 :   return (token-&gt;type == CPP_STRING ||</span>
<span class="lineNum">    2688 </span><span class="lineCov">    4989218 :           token-&gt;type == CPP_STRING16 ||</span>
<span class="lineNum">    2689 </span><span class="lineCov">    4988903 :           token-&gt;type == CPP_STRING32 ||</span>
<span class="lineNum">    2690 </span><span class="lineCov">    4971228 :           token-&gt;type == CPP_WSTRING ||</span>
<span class="lineNum">    2691 </span><span class="lineNoCov">          0 :           token-&gt;type == CPP_UTF8STRING);</span>
<span class="lineNum">    2692 </span>            : }
<span class="lineNum">    2693 </span>            : 
<span class="lineNum">    2694 </span>            : /* Returns nonzero if TOKEN is a string literal
<span class="lineNum">    2695 </span>            :    of a user-defined string literal.  */
<a name="2696"><span class="lineNum">    2696 </span>            : </a>
<span class="lineNum">    2697 </span>            : static bool
<span class="lineNum">    2698 </span><span class="lineCov">    2954147 : cp_parser_is_string_literal (cp_token* token)</span>
<span class="lineNum">    2699 </span>            : {
<span class="lineNum">    2700 </span><span class="lineCov">    4130828 :   return (cp_parser_is_pure_string_literal (token) ||</span>
<span class="lineNum">    2701 </span><span class="lineCov">    1151420 :           token-&gt;type == CPP_STRING_USERDEF ||</span>
<span class="lineNum">    2702 </span><span class="lineCov">    1151387 :           token-&gt;type == CPP_STRING16_USERDEF ||</span>
<span class="lineNum">    2703 </span><span class="lineCov">    1151334 :           token-&gt;type == CPP_STRING32_USERDEF ||</span>
<span class="lineNum">    2704 </span><span class="lineCov">    1151300 :           token-&gt;type == CPP_WSTRING_USERDEF ||</span>
<span class="lineNum">    2705 </span><span class="lineCov">    2954147 :           token-&gt;type == CPP_UTF8STRING_USERDEF);</span>
<span class="lineNum">    2706 </span>            : }
<span class="lineNum">    2707 </span>            : 
<span class="lineNum">    2708 </span>            : /* Returns nonzero if TOKEN is the indicated KEYWORD.  */
<a name="2709"><span class="lineNum">    2709 </span>            : </a>
<span class="lineNum">    2710 </span>            : static bool
<span class="lineNum">    2711 </span><span class="lineNoCov">          0 : cp_parser_is_keyword (cp_token* token, enum rid keyword)</span>
<span class="lineNum">    2712 </span>            : {
<span class="lineNum">    2713 </span><span class="lineCov">   36996130 :   return token-&gt;keyword == keyword;</span>
<span class="lineNum">    2714 </span>            : }
<span class="lineNum">    2715 </span>            : 
<span class="lineNum">    2716 </span>            : /* Return TOKEN's pragma_kind if it is CPP_PRAGMA, otherwise
<span class="lineNum">    2717 </span>            :    PRAGMA_NONE.  */
<a name="2718"><span class="lineNum">    2718 </span>            : </a>
<span class="lineNum">    2719 </span>            : static enum pragma_kind
<span class="lineNum">    2720 </span><span class="lineCov">     193487 : cp_parser_pragma_kind (cp_token *token)</span>
<span class="lineNum">    2721 </span>            : {
<span class="lineNum">    2722 </span><span class="lineCov">     193487 :   if (token-&gt;type != CPP_PRAGMA)</span>
<span class="lineNum">    2723 </span>            :     return PRAGMA_NONE;
<span class="lineNum">    2724 </span>            :   /* We smuggled the cpp_token-&gt;u.pragma value in an INTEGER_CST.  */
<span class="lineNum">    2725 </span><span class="lineCov">     138004 :   return (enum pragma_kind) TREE_INT_CST_LOW (token-&gt;u.value);</span>
<span class="lineNum">    2726 </span>            : }
<span class="lineNum">    2727 </span>            : 
<span class="lineNum">    2728 </span>            : /* Helper function for cp_parser_error.
<span class="lineNum">    2729 </span>            :    Having peeked a token of kind TOK1_KIND that might signify
<span class="lineNum">    2730 </span>            :    a conflict marker, peek successor tokens to determine
<span class="lineNum">    2731 </span>            :    if we actually do have a conflict marker.
<span class="lineNum">    2732 </span>            :    Specifically, we consider a run of 7 '&lt;', '=' or '&gt;' characters
<span class="lineNum">    2733 </span>            :    at the start of a line as a conflict marker.
<span class="lineNum">    2734 </span>            :    These come through the lexer as three pairs and a single,
<span class="lineNum">    2735 </span>            :    e.g. three CPP_LSHIFT tokens (&quot;&lt;&lt;&quot;) and a CPP_LESS token ('&lt;').
<span class="lineNum">    2736 </span>            :    If it returns true, *OUT_LOC is written to with the location/range
<span class="lineNum">    2737 </span>            :    of the marker.  */
<a name="2738"><span class="lineNum">    2738 </span>            : </a>
<span class="lineNum">    2739 </span>            : static bool
<span class="lineNum">    2740 </span><span class="lineCov">         78 : cp_lexer_peek_conflict_marker (cp_lexer *lexer, enum cpp_ttype tok1_kind,</span>
<span class="lineNum">    2741 </span>            :                                location_t *out_loc)
<span class="lineNum">    2742 </span>            : {
<span class="lineNum">    2743 </span><span class="lineCov">         78 :   cp_token *token2 = cp_lexer_peek_nth_token (lexer, 2);</span>
<span class="lineNum">    2744 </span><span class="lineCov">         78 :   if (token2-&gt;type != tok1_kind)</span>
<span class="lineNum">    2745 </span>            :     return false;
<span class="lineNum">    2746 </span><span class="lineCov">         69 :   cp_token *token3 = cp_lexer_peek_nth_token (lexer, 3);</span>
<span class="lineNum">    2747 </span><span class="lineCov">         69 :   if (token3-&gt;type != tok1_kind)</span>
<span class="lineNum">    2748 </span>            :     return false;
<span class="lineNum">    2749 </span><span class="lineCov">         60 :   cp_token *token4 = cp_lexer_peek_nth_token (lexer, 4);</span>
<span class="lineNum">    2750 </span><span class="lineCov">         60 :   if (token4-&gt;type != conflict_marker_get_final_tok_kind (tok1_kind))</span>
<span class="lineNum">    2751 </span>            :     return false;
<span class="lineNum">    2752 </span>            : 
<span class="lineNum">    2753 </span>            :   /* It must be at the start of the line.  */
<span class="lineNum">    2754 </span><span class="lineCov">        102 :   location_t start_loc = cp_lexer_peek_token (lexer)-&gt;location;</span>
<span class="lineNum">    2755 </span><span class="lineCov">         51 :   if (LOCATION_COLUMN (start_loc) != 1)</span>
<span class="lineNum">    2756 </span>            :     return false;
<span class="lineNum">    2757 </span>            : 
<span class="lineNum">    2758 </span>            :   /* We have a conflict marker.  Construct a location of the form:
<span class="lineNum">    2759 </span>            :        &lt;&lt;&lt;&lt;&lt;&lt;&lt;
<span class="lineNum">    2760 </span>            :        ^~~~~~~
<span class="lineNum">    2761 </span>            :      with start == caret, finishing at the end of the marker.  */
<span class="lineNum">    2762 </span><span class="lineCov">         42 :   location_t finish_loc = get_finish (token4-&gt;location);</span>
<span class="lineNum">    2763 </span><span class="lineCov">         42 :   *out_loc = make_location (start_loc, start_loc, finish_loc);</span>
<span class="lineNum">    2764 </span>            : 
<span class="lineNum">    2765 </span><span class="lineCov">         42 :   return true;</span>
<span class="lineNum">    2766 </span>            : }
<span class="lineNum">    2767 </span>            : 
<span class="lineNum">    2768 </span>            : /* Get a description of the matching symbol to TOKEN_DESC e.g. &quot;(&quot; for
<span class="lineNum">    2769 </span>            :    RT_CLOSE_PAREN.  */
<a name="2770"><span class="lineNum">    2770 </span>            : </a>
<span class="lineNum">    2771 </span>            : static const char *
<span class="lineNum">    2772 </span><span class="lineNoCov">          0 : get_matching_symbol (required_token token_desc)</span>
<span class="lineNum">    2773 </span>            : {
<span class="lineNum">    2774 </span><span class="lineNoCov">          0 :   switch (token_desc)</span>
<span class="lineNum">    2775 </span>            :     {
<span class="lineNum">    2776 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">    2777 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">    2778 </span>            :       return &quot;&quot;;
<span class="lineNum">    2779 </span>            :     case RT_CLOSE_BRACE:
<span class="lineNum">    2780 </span>            :       return &quot;{&quot;;
<span class="lineNum">    2781 </span><span class="lineCov">         12 :     case RT_CLOSE_PAREN:</span>
<span class="lineNum">    2782 </span><span class="lineCov">         12 :       return &quot;(&quot;;</span>
<span class="lineNum">    2783 </span>            :     }
<span class="lineNum">    2784 </span>            : }
<span class="lineNum">    2785 </span>            : 
<span class="lineNum">    2786 </span>            : /* Attempt to convert TOKEN_DESC from a required_token to an
<span class="lineNum">    2787 </span>            :    enum cpp_ttype, returning CPP_EOF if there is no good conversion.  */
<a name="2788"><span class="lineNum">    2788 </span>            : </a>
<span class="lineNum">    2789 </span>            : static enum cpp_ttype
<span class="lineNum">    2790 </span><span class="lineNoCov">          0 : get_required_cpp_ttype (required_token token_desc)</span>
<span class="lineNum">    2791 </span>            : {
<span class="lineNum">    2792 </span><span class="lineNoCov">          0 :   switch (token_desc)</span>
<span class="lineNum">    2793 </span>            :     {
<span class="lineNum">    2794 </span>            :     case RT_SEMICOLON:
<span class="lineNum">    2795 </span>            :       return CPP_SEMICOLON;
<span class="lineNum">    2796 </span>            :     case RT_OPEN_PAREN:
<span class="lineNum">    2797 </span>            :       return CPP_OPEN_PAREN;
<span class="lineNum">    2798 </span>            :     case RT_CLOSE_BRACE:
<span class="lineNum">    2799 </span>            :       return CPP_CLOSE_BRACE;
<span class="lineNum">    2800 </span>            :     case RT_OPEN_BRACE:
<span class="lineNum">    2801 </span>            :       return CPP_OPEN_BRACE;
<span class="lineNum">    2802 </span>            :     case RT_CLOSE_SQUARE:
<span class="lineNum">    2803 </span>            :       return CPP_CLOSE_SQUARE;
<span class="lineNum">    2804 </span>            :     case RT_OPEN_SQUARE:
<span class="lineNum">    2805 </span>            :       return CPP_OPEN_SQUARE;
<span class="lineNum">    2806 </span>            :     case RT_COMMA:
<span class="lineNum">    2807 </span>            :       return CPP_COMMA;
<span class="lineNum">    2808 </span>            :     case RT_COLON:
<span class="lineNum">    2809 </span>            :       return CPP_COLON;
<span class="lineNum">    2810 </span>            :     case RT_CLOSE_PAREN:
<span class="lineNum">    2811 </span>            :       return CPP_CLOSE_PAREN;
<span class="lineNum">    2812 </span>            : 
<span class="lineNum">    2813 </span>            :     default:
<span class="lineNum">    2814 </span>            :       /* Use CPP_EOF as a &quot;no completions possible&quot; code.  */
<span class="lineNum">    2815 </span>            :       return CPP_EOF;
<span class="lineNum">    2816 </span>            :     }
<span class="lineNum">    2817 </span>            : }
<span class="lineNum">    2818 </span>            : 
<span class="lineNum">    2819 </span>            : 
<span class="lineNum">    2820 </span>            : /* Subroutine of cp_parser_error and cp_parser_required_error.
<span class="lineNum">    2821 </span>            : 
<span class="lineNum">    2822 </span>            :    Issue a diagnostic of the form
<span class="lineNum">    2823 </span>            :       FILE:LINE: MESSAGE before TOKEN
<span class="lineNum">    2824 </span>            :    where TOKEN is the next token in the input stream.  MESSAGE
<span class="lineNum">    2825 </span>            :    (specified by the caller) is usually of the form &quot;expected
<span class="lineNum">    2826 </span>            :    OTHER-TOKEN&quot;.
<span class="lineNum">    2827 </span>            : 
<span class="lineNum">    2828 </span>            :    This bypasses the check for tentative passing, and potentially
<span class="lineNum">    2829 </span>            :    adds material needed by cp_parser_required_error.
<span class="lineNum">    2830 </span>            : 
<span class="lineNum">    2831 </span>            :    If MISSING_TOKEN_DESC is not RT_NONE, then potentially add fix-it hints
<span class="lineNum">    2832 </span>            :    suggesting insertion of the missing token.
<span class="lineNum">    2833 </span>            : 
<span class="lineNum">    2834 </span>            :    Additionally, if MATCHING_LOCATION is not UNKNOWN_LOCATION, then we
<span class="lineNum">    2835 </span>            :    have an unmatched symbol at MATCHING_LOCATION; highlight this secondary
<span class="lineNum">    2836 </span>            :    location.  */
<a name="2837"><span class="lineNum">    2837 </span>            : </a>
<span class="lineNum">    2838 </span>            : static void
<span class="lineNum">    2839 </span><span class="lineCov">       3644 : cp_parser_error_1 (cp_parser* parser, const char* gmsgid,</span>
<span class="lineNum">    2840 </span>            :                    required_token missing_token_desc,
<span class="lineNum">    2841 </span>            :                    location_t matching_location)
<span class="lineNum">    2842 </span>            : {
<span class="lineNum">    2843 </span><span class="lineCov">       7288 :   cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">    2844 </span>            :   /* This diagnostic makes more sense if it is tagged to the line
<span class="lineNum">    2845 </span>            :      of the token we just peeked at.  */
<span class="lineNum">    2846 </span><span class="lineCov">       3644 :   cp_lexer_set_source_position_from_token (token);</span>
<span class="lineNum">    2847 </span>            : 
<span class="lineNum">    2848 </span><span class="lineCov">       3644 :   if (token-&gt;type == CPP_PRAGMA)</span>
<span class="lineNum">    2849 </span>            :     {
<span class="lineNum">    2850 </span><span class="lineCov">         12 :       error_at (token-&gt;location,</span>
<span class="lineNum">    2851 </span>            :                 &quot;%&lt;#pragma%&gt; is not allowed here&quot;);
<span class="lineNum">    2852 </span><span class="lineCov">         12 :       cp_parser_skip_to_pragma_eol (parser, token);</span>
<span class="lineNum">    2853 </span><span class="lineCov">         54 :       return;</span>
<span class="lineNum">    2854 </span>            :     }
<span class="lineNum">    2855 </span>            : 
<span class="lineNum">    2856 </span>            :   /* If this is actually a conflict marker, report it as such.  */
<span class="lineNum">    2857 </span><span class="lineCov">       7264 :   if (token-&gt;type == CPP_LSHIFT</span>
<span class="lineNum">    2858 </span><span class="lineCov">       3632 :       || token-&gt;type == CPP_RSHIFT</span>
<span class="lineNum">    2859 </span><span class="lineCov">       3580 :       || token-&gt;type == CPP_EQ_EQ)</span>
<span class="lineNum">    2860 </span>            :     {
<span class="lineNum">    2861 </span><span class="lineCov">         78 :       location_t loc;</span>
<span class="lineNum">    2862 </span><span class="lineCov">         78 :       if (cp_lexer_peek_conflict_marker (parser-&gt;lexer, token-&gt;type, &amp;loc))</span>
<span class="lineNum">    2863 </span>            :         {
<span class="lineNum">    2864 </span><span class="lineCov">         42 :           error_at (loc, &quot;version control conflict marker in file&quot;);</span>
<span class="lineNum">    2865 </span><span class="lineCov">         42 :           expanded_location token_exploc = expand_location (token-&gt;location);</span>
<span class="lineNum">    2866 </span>            :           /* Consume tokens until the end of the source line.  */
<span class="lineNum">    2867 </span><span class="lineCov">        229 :           while (1)</span>
<span class="lineNum">    2868 </span>            :             {
<span class="lineNum">    2869 </span><span class="lineCov">        229 :               cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    2870 </span><span class="lineCov">        458 :               cp_token *next = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">    2871 </span><span class="lineCov">        229 :               if (next == NULL)</span>
<span class="lineNum">    2872 </span>            :                 break;
<span class="lineNum">    2873 </span><span class="lineCov">        229 :               expanded_location next_exploc = expand_location (next-&gt;location);</span>
<span class="lineNum">    2874 </span><span class="lineCov">        229 :               if (next_exploc.file != token_exploc.file)</span>
<span class="lineNum">    2875 </span>            :                 break;
<span class="lineNum">    2876 </span><span class="lineCov">        226 :               if (next_exploc.line != token_exploc.line)</span>
<span class="lineNum">    2877 </span>            :                 break;
<span class="lineNum">    2878 </span><span class="lineCov">        187 :             }</span>
<span class="lineNum">    2879 </span><span class="lineCov">         42 :           return;</span>
<span class="lineNum">    2880 </span>            :         }
<span class="lineNum">    2881 </span>            :     }
<span class="lineNum">    2882 </span>            : 
<span class="lineNum">    2883 </span><span class="lineCov">       7180 :   gcc_rich_location richloc (input_location);</span>
<span class="lineNum">    2884 </span>            : 
<span class="lineNum">    2885 </span><span class="lineCov">       3590 :   bool added_matching_location = false;</span>
<span class="lineNum">    2886 </span>            : 
<span class="lineNum">    2887 </span><span class="lineCov">       3590 :   if (missing_token_desc != RT_NONE)</span>
<span class="lineNum">    2888 </span>            :     {
<span class="lineNum">    2889 </span>            :       /* Potentially supply a fix-it hint, suggesting to add the
<span class="lineNum">    2890 </span>            :          missing token immediately after the *previous* token.
<span class="lineNum">    2891 </span>            :          This may move the primary location within richloc.  */
<span class="lineNum">    2892 </span><span class="lineCov">       1455 :       enum cpp_ttype ttype = get_required_cpp_ttype (missing_token_desc);</span>
<span class="lineNum">    2893 </span><span class="lineCov">       1455 :       location_t prev_token_loc</span>
<span class="lineNum">    2894 </span><span class="lineCov">       1455 :         = cp_lexer_previous_token (parser-&gt;lexer)-&gt;location;</span>
<span class="lineNum">    2895 </span><span class="lineCov">       1455 :       maybe_suggest_missing_token_insertion (&amp;richloc, ttype, prev_token_loc);</span>
<span class="lineNum">    2896 </span>            : 
<span class="lineNum">    2897 </span>            :       /* If matching_location != UNKNOWN_LOCATION, highlight it.
<span class="lineNum">    2898 </span>            :          Attempt to consolidate diagnostics by printing it as a
<span class="lineNum">    2899 </span>            :         secondary range within the main diagnostic.  */
<span class="lineNum">    2900 </span><span class="lineCov">       1455 :       if (matching_location != UNKNOWN_LOCATION)</span>
<span class="lineNum">    2901 </span><span class="lineCov">        548 :         added_matching_location</span>
<span class="lineNum">    2902 </span><span class="lineCov">        548 :           = richloc.add_location_if_nearby (matching_location);</span>
<span class="lineNum">    2903 </span>            :     }
<span class="lineNum">    2904 </span>            : 
<span class="lineNum">    2905 </span>            :   /* Actually emit the error.  */
<span class="lineNum">    2906 </span><span class="lineCov">       3590 :   c_parse_error (gmsgid,</span>
<span class="lineNum">    2907 </span>            :                  /* Because c_parser_error does not understand
<span class="lineNum">    2908 </span>            :                     CPP_KEYWORD, keywords are treated like
<span class="lineNum">    2909 </span>            :                     identifiers.  */
<span class="lineNum">    2910 </span><span class="lineCov">       3590 :                  (token-&gt;type == CPP_KEYWORD ? CPP_NAME : token-&gt;type),</span>
<span class="lineNum">    2911 </span><span class="lineCov">       3590 :                  token-&gt;u.value, token-&gt;flags, &amp;richloc);</span>
<span class="lineNum">    2912 </span>            : 
<span class="lineNum">    2913 </span><span class="lineCov">       3590 :   if (missing_token_desc != RT_NONE)</span>
<span class="lineNum">    2914 </span>            :     {
<span class="lineNum">    2915 </span>            :       /* If we weren't able to consolidate matching_location, then
<span class="lineNum">    2916 </span>            :          print it as a secondary diagnostic.  */
<span class="lineNum">    2917 </span><span class="lineCov">       2910 :       if (matching_location != UNKNOWN_LOCATION</span>
<span class="lineNum">    2918 </span><span class="lineCov">       1455 :           &amp;&amp; !added_matching_location)</span>
<span class="lineNum">    2919 </span><span class="lineCov">        115 :         inform (matching_location, &quot;to match this %qs&quot;,</span>
<span class="lineNum">    2920 </span>            :                 get_matching_symbol (missing_token_desc));
<span class="lineNum">    2921 </span>            :     }
<span class="lineNum">    2922 </span>            : }
<span class="lineNum">    2923 </span>            : 
<span class="lineNum">    2924 </span>            : /* If not parsing tentatively, issue a diagnostic of the form
<span class="lineNum">    2925 </span>            :       FILE:LINE: MESSAGE before TOKEN
<span class="lineNum">    2926 </span>            :    where TOKEN is the next token in the input stream.  MESSAGE
<span class="lineNum">    2927 </span>            :    (specified by the caller) is usually of the form &quot;expected
<span class="lineNum">    2928 </span>            :    OTHER-TOKEN&quot;.  */
<a name="2929"><span class="lineNum">    2929 </span>            : </a>
<span class="lineNum">    2930 </span>            : static void
<span class="lineNum">    2931 </span><span class="lineCov">  375880191 : cp_parser_error (cp_parser* parser, const char* gmsgid)</span>
<span class="lineNum">    2932 </span>            : {
<span class="lineNum">    2933 </span><span class="lineCov">  751758199 :   if (!cp_parser_simulate_error (parser))</span>
<span class="lineNum">    2934 </span><span class="lineCov">       2183 :     cp_parser_error_1 (parser, gmsgid, RT_NONE, UNKNOWN_LOCATION);</span>
<span class="lineNum">    2935 </span><span class="lineCov">  375880191 : }</span>
<span class="lineNum">    2936 </span>            : 
<span class="lineNum">    2937 </span>            : /* Issue an error about name-lookup failing.  NAME is the
<span class="lineNum">    2938 </span>            :    IDENTIFIER_NODE DECL is the result of
<span class="lineNum">    2939 </span>            :    the lookup (as returned from cp_parser_lookup_name).  DESIRED is
<span class="lineNum">    2940 </span>            :    the thing that we hoped to find.  */
<a name="2941"><span class="lineNum">    2941 </span>            : </a>
<span class="lineNum">    2942 </span>            : static void
<span class="lineNum">    2943 </span><span class="lineCov">        229 : cp_parser_name_lookup_error (cp_parser* parser,</span>
<span class="lineNum">    2944 </span>            :                              tree name,
<span class="lineNum">    2945 </span>            :                              tree decl,
<span class="lineNum">    2946 </span>            :                              name_lookup_error desired,
<span class="lineNum">    2947 </span>            :                              location_t location)
<span class="lineNum">    2948 </span>            : {
<span class="lineNum">    2949 </span>            :   /* If name lookup completely failed, tell the user that NAME was not
<span class="lineNum">    2950 </span>            :      declared.  */
<span class="lineNum">    2951 </span><span class="lineCov">        229 :   if (decl == error_mark_node)</span>
<span class="lineNum">    2952 </span>            :     {
<span class="lineNum">    2953 </span><span class="lineCov">        192 :       if (parser-&gt;scope &amp;&amp; parser-&gt;scope != global_namespace)</span>
<span class="lineNum">    2954 </span><span class="lineCov">         59 :         error_at (location, &quot;%&lt;%E::%E%&gt; has not been declared&quot;,</span>
<span class="lineNum">    2955 </span>            :                   parser-&gt;scope, name);
<span class="lineNum">    2956 </span><span class="lineCov">        133 :       else if (parser-&gt;scope == global_namespace)</span>
<span class="lineNum">    2957 </span><span class="lineCov">          7 :         error_at (location, &quot;%&lt;::%E%&gt; has not been declared&quot;, name);</span>
<span class="lineNum">    2958 </span><span class="lineCov">        126 :       else if (parser-&gt;object_scope</span>
<span class="lineNum">    2959 </span><span class="lineCov">        126 :                &amp;&amp; !CLASS_TYPE_P (parser-&gt;object_scope))</span>
<span class="lineNum">    2960 </span><span class="lineNoCov">          0 :         error_at (location, &quot;request for member %qE in non-class type %qT&quot;,</span>
<span class="lineNum">    2961 </span>            :                   name, parser-&gt;object_scope);
<span class="lineNum">    2962 </span><span class="lineCov">        126 :       else if (parser-&gt;object_scope)</span>
<span class="lineNum">    2963 </span><span class="lineNoCov">          0 :         error_at (location, &quot;%&lt;%T::%E%&gt; has not been declared&quot;,</span>
<span class="lineNum">    2964 </span>            :                   parser-&gt;object_scope, name);
<span class="lineNum">    2965 </span>            :       else
<span class="lineNum">    2966 </span><span class="lineCov">        126 :         error_at (location, &quot;%qE has not been declared&quot;, name);</span>
<span class="lineNum">    2967 </span>            :     }
<span class="lineNum">    2968 </span><span class="lineCov">         37 :   else if (parser-&gt;scope &amp;&amp; parser-&gt;scope != global_namespace)</span>
<span class="lineNum">    2969 </span>            :     {
<span class="lineNum">    2970 </span><span class="lineCov">         14 :       switch (desired)</span>
<span class="lineNum">    2971 </span>            :         {
<span class="lineNum">    2972 </span><span class="lineCov">         14 :           case NLE_TYPE:</span>
<span class="lineNum">    2973 </span><span class="lineCov">         14 :             error_at (location, &quot;%&lt;%E::%E%&gt; is not a type&quot;,</span>
<span class="lineNum">    2974 </span>            :                                 parser-&gt;scope, name);
<span class="lineNum">    2975 </span><span class="lineCov">         14 :             break;</span>
<span class="lineNum">    2976 </span><span class="lineNoCov">          0 :           case NLE_CXX98:</span>
<span class="lineNum">    2977 </span><span class="lineNoCov">          0 :             error_at (location, &quot;%&lt;%E::%E%&gt; is not a class or namespace&quot;,</span>
<span class="lineNum">    2978 </span>            :                                 parser-&gt;scope, name);
<span class="lineNum">    2979 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    2980 </span><span class="lineNoCov">          0 :           case NLE_NOT_CXX98:</span>
<span class="lineNum">    2981 </span><span class="lineNoCov">          0 :             error_at (location,</span>
<span class="lineNum">    2982 </span>            :                       &quot;%&lt;%E::%E%&gt; is not a class, namespace, or enumeration&quot;,
<span class="lineNum">    2983 </span>            :                       parser-&gt;scope, name);
<span class="lineNum">    2984 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    2985 </span><span class="lineNoCov">          0 :           default:</span>
<span class="lineNum">    2986 </span><span class="lineNoCov">          0 :             gcc_unreachable ();</span>
<span class="lineNum">    2987 </span>            :             
<span class="lineNum">    2988 </span>            :         }
<span class="lineNum">    2989 </span>            :     }
<span class="lineNum">    2990 </span><span class="lineCov">         23 :   else if (parser-&gt;scope == global_namespace)</span>
<span class="lineNum">    2991 </span>            :     {
<span class="lineNum">    2992 </span><span class="lineNoCov">          0 :       switch (desired)</span>
<span class="lineNum">    2993 </span>            :         {
<span class="lineNum">    2994 </span><span class="lineNoCov">          0 :           case NLE_TYPE:</span>
<span class="lineNum">    2995 </span><span class="lineNoCov">          0 :             error_at (location, &quot;%&lt;::%E%&gt; is not a type&quot;, name);</span>
<span class="lineNum">    2996 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    2997 </span><span class="lineNoCov">          0 :           case NLE_CXX98:</span>
<span class="lineNum">    2998 </span><span class="lineNoCov">          0 :             error_at (location, &quot;%&lt;::%E%&gt; is not a class or namespace&quot;, name);</span>
<span class="lineNum">    2999 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    3000 </span><span class="lineNoCov">          0 :           case NLE_NOT_CXX98:</span>
<span class="lineNum">    3001 </span><span class="lineNoCov">          0 :             error_at (location,</span>
<span class="lineNum">    3002 </span>            :                       &quot;%&lt;::%E%&gt; is not a class, namespace, or enumeration&quot;,
<span class="lineNum">    3003 </span>            :                       name);
<span class="lineNum">    3004 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    3005 </span><span class="lineNoCov">          0 :           default:</span>
<span class="lineNum">    3006 </span><span class="lineNoCov">          0 :             gcc_unreachable ();</span>
<span class="lineNum">    3007 </span>            :         }
<span class="lineNum">    3008 </span>            :     }
<span class="lineNum">    3009 </span>            :   else
<span class="lineNum">    3010 </span>            :     {
<span class="lineNum">    3011 </span><span class="lineCov">         23 :       switch (desired)</span>
<span class="lineNum">    3012 </span>            :         {
<span class="lineNum">    3013 </span><span class="lineCov">         11 :           case NLE_TYPE:</span>
<span class="lineNum">    3014 </span><span class="lineCov">         11 :             error_at (location, &quot;%qE is not a type&quot;, name);</span>
<span class="lineNum">    3015 </span><span class="lineCov">         11 :             break;</span>
<span class="lineNum">    3016 </span><span class="lineCov">          4 :           case NLE_CXX98:</span>
<span class="lineNum">    3017 </span><span class="lineCov">          4 :             error_at (location, &quot;%qE is not a class or namespace&quot;, name);</span>
<span class="lineNum">    3018 </span><span class="lineCov">          4 :             break;</span>
<span class="lineNum">    3019 </span><span class="lineCov">          8 :           case NLE_NOT_CXX98:</span>
<span class="lineNum">    3020 </span><span class="lineCov">          8 :             error_at (location,</span>
<span class="lineNum">    3021 </span>            :                       &quot;%qE is not a class, namespace, or enumeration&quot;, name);
<span class="lineNum">    3022 </span><span class="lineCov">          8 :             break;</span>
<span class="lineNum">    3023 </span><span class="lineNoCov">          0 :           default:</span>
<span class="lineNum">    3024 </span><span class="lineNoCov">          0 :             gcc_unreachable ();</span>
<span class="lineNum">    3025 </span>            :         }
<span class="lineNum">    3026 </span>            :     }
<span class="lineNum">    3027 </span><span class="lineCov">        229 : }</span>
<span class="lineNum">    3028 </span>            : 
<span class="lineNum">    3029 </span>            : /* If we are parsing tentatively, remember that an error has occurred
<span class="lineNum">    3030 </span>            :    during this tentative parse.  Returns true if the error was
<span class="lineNum">    3031 </span>            :    simulated; false if a message should be issued by the caller.  */
<a name="3032"><span class="lineNum">    3032 </span>            : </a>
<span class="lineNum">    3033 </span>            : static bool
<span class="lineNum">    3034 </span><span class="lineNoCov">          0 : cp_parser_simulate_error (cp_parser* parser)</span>
<span class="lineNum">    3035 </span>            : {
<span class="lineNum">    3036 </span><span class="lineCov"> 1140708678 :   if (cp_parser_uncommitted_to_tentative_parse_p (parser))</span>
<span class="lineNum">    3037 </span>            :     {
<span class="lineNum">    3038 </span><span class="lineCov">  570351683 :       parser-&gt;context-&gt;status = CP_PARSER_STATUS_KIND_ERROR;</span>
<span class="lineNum">    3039 </span><span class="lineCov">  472601356 :       return true;</span>
<span class="lineNum">    3040 </span>            :     }
<span class="lineNum">    3041 </span>            :   return false;
<span class="lineNum">    3042 </span>            : }
<span class="lineNum">    3043 </span>            : 
<span class="lineNum">    3044 </span>            : /* This function is called when a type is defined.  If type
<span class="lineNum">    3045 </span>            :    definitions are forbidden at this point, an error message is
<span class="lineNum">    3046 </span>            :    issued.  */
<a name="3047"><span class="lineNum">    3047 </span>            : </a>
<span class="lineNum">    3048 </span>            : static bool
<span class="lineNum">    3049 </span><span class="lineNoCov">          0 : cp_parser_check_type_definition (cp_parser* parser)</span>
<span class="lineNum">    3050 </span>            : {
<span class="lineNum">    3051 </span>            :   /* If types are forbidden here, issue a message.  */
<span class="lineNum">    3052 </span><span class="lineNoCov">          0 :   if (parser-&gt;type_definition_forbidden_message)</span>
<span class="lineNum">    3053 </span>            :     {
<span class="lineNum">    3054 </span>            :       /* Don't use `%s' to print the string, because quotations (`%&lt;', `%&gt;')
<span class="lineNum">    3055 </span>            :          in the message need to be interpreted.  */
<span class="lineNum">    3056 </span><span class="lineCov">         11 :       error (parser-&gt;type_definition_forbidden_message);</span>
<span class="lineNum">    3057 </span><span class="lineCov">         82 :       return false;</span>
<span class="lineNum">    3058 </span>            :     }
<span class="lineNum">    3059 </span>            :   return true;
<span class="lineNum">    3060 </span>            : }
<span class="lineNum">    3061 </span>            : 
<span class="lineNum">    3062 </span>            : /* This function is called when the DECLARATOR is processed.  The TYPE
<span class="lineNum">    3063 </span>            :    was a type defined in the decl-specifiers.  If it is invalid to
<span class="lineNum">    3064 </span>            :    define a type in the decl-specifiers for DECLARATOR, an error is
<span class="lineNum">    3065 </span>            :    issued. TYPE_LOCATION is the location of TYPE and is used
<span class="lineNum">    3066 </span>            :    for error reporting.  */
<a name="3067"><span class="lineNum">    3067 </span>            : </a>
<span class="lineNum">    3068 </span>            : static void
<span class="lineNum">    3069 </span><span class="lineCov">     101049 : cp_parser_check_for_definition_in_return_type (cp_declarator *declarator,</span>
<span class="lineNum">    3070 </span>            :                                                tree type, location_t type_location)
<span class="lineNum">    3071 </span>            : {
<span class="lineNum">    3072 </span>            :   /* [dcl.fct] forbids type definitions in return types.
<span class="lineNum">    3073 </span>            :      Unfortunately, it's not easy to know whether or not we are
<span class="lineNum">    3074 </span>            :      processing a return type until after the fact.  */
<span class="lineNum">    3075 </span><span class="lineCov">     101895 :   while (declarator</span>
<span class="lineNum">    3076 </span><span class="lineCov">     101472 :          &amp;&amp; (declarator-&gt;kind == cdk_pointer</span>
<span class="lineNum">    3077 </span>            :              || declarator-&gt;kind == cdk_reference
<span class="lineNum">    3078 </span><span class="lineCov">     101472 :              || declarator-&gt;kind == cdk_ptrmem))</span>
<span class="lineNum">    3079 </span><span class="lineCov">        423 :     declarator = declarator-&gt;declarator;</span>
<span class="lineNum">    3080 </span><span class="lineCov">     101049 :   if (declarator</span>
<span class="lineNum">    3081 </span><span class="lineCov">     101049 :       &amp;&amp; declarator-&gt;kind == cdk_function)</span>
<span class="lineNum">    3082 </span>            :     {
<span class="lineNum">    3083 </span><span class="lineCov">         24 :       error_at (type_location,</span>
<span class="lineNum">    3084 </span>            :                 &quot;new types may not be defined in a return type&quot;);
<span class="lineNum">    3085 </span><span class="lineCov">         24 :       inform (type_location, </span>
<span class="lineNum">    3086 </span>            :               &quot;(perhaps a semicolon is missing after the definition of %qT)&quot;,
<span class="lineNum">    3087 </span>            :               type);
<span class="lineNum">    3088 </span>            :     }
<span class="lineNum">    3089 </span><span class="lineCov">     101049 : }</span>
<span class="lineNum">    3090 </span>            : 
<span class="lineNum">    3091 </span>            : /* A type-specifier (TYPE) has been parsed which cannot be followed by
<span class="lineNum">    3092 </span>            :    &quot;&lt;&quot; in any valid C++ program.  If the next token is indeed &quot;&lt;&quot;,
<span class="lineNum">    3093 </span>            :    issue a message warning the user about what appears to be an
<span class="lineNum">    3094 </span>            :    invalid attempt to form a template-id. LOCATION is the location
<span class="lineNum">    3095 </span>            :    of the type-specifier (TYPE) */
<a name="3096"><span class="lineNum">    3096 </span>            : </a>
<span class="lineNum">    3097 </span>            : static void
<span class="lineNum">    3098 </span><span class="lineCov">   55962261 : cp_parser_check_for_invalid_template_id (cp_parser* parser,</span>
<span class="lineNum">    3099 </span>            :                                          tree type,
<span class="lineNum">    3100 </span>            :                                          enum tag_types tag_type,
<span class="lineNum">    3101 </span>            :                                          location_t location)
<span class="lineNum">    3102 </span>            : {
<span class="lineNum">    3103 </span><span class="lineCov">   55962261 :   cp_token_position start = 0;</span>
<span class="lineNum">    3104 </span>            : 
<span class="lineNum">    3105 </span><span class="lineCov">   55962261 :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_LESS))</span>
<span class="lineNum">    3106 </span>            :     {
<span class="lineNum">    3107 </span><span class="lineCov">         92 :       if (TREE_CODE (type) == TYPE_DECL)</span>
<span class="lineNum">    3108 </span><span class="lineCov">         51 :         type = TREE_TYPE (type);</span>
<span class="lineNum">    3109 </span><span class="lineCov">         92 :       if (TYPE_P (type) &amp;&amp; !template_placeholder_p (type))</span>
<span class="lineNum">    3110 </span><span class="lineCov">         57 :         error_at (location, &quot;%qT is not a template&quot;, type);</span>
<span class="lineNum">    3111 </span><span class="lineCov">         35 :       else if (identifier_p (type))</span>
<span class="lineNum">    3112 </span>            :         {
<span class="lineNum">    3113 </span><span class="lineCov">         35 :           if (tag_type != none_type)</span>
<span class="lineNum">    3114 </span><span class="lineCov">         35 :             error_at (location, &quot;%qE is not a class template&quot;, type);</span>
<span class="lineNum">    3115 </span>            :           else
<span class="lineNum">    3116 </span><span class="lineNoCov">          0 :             error_at (location, &quot;%qE is not a template&quot;, type);</span>
<span class="lineNum">    3117 </span>            :         }
<span class="lineNum">    3118 </span>            :       else
<span class="lineNum">    3119 </span><span class="lineNoCov">          0 :         error_at (location, &quot;invalid template-id&quot;);</span>
<span class="lineNum">    3120 </span>            :       /* Remember the location of the invalid &quot;&lt;&quot;.  */
<span class="lineNum">    3121 </span><span class="lineCov">        151 :       if (cp_parser_uncommitted_to_tentative_parse_p (parser))</span>
<span class="lineNum">    3122 </span><span class="lineCov">         59 :         start = cp_lexer_token_position (parser-&gt;lexer, true);</span>
<span class="lineNum">    3123 </span>            :       /* Consume the &quot;&lt;&quot;.  */
<span class="lineNum">    3124 </span><span class="lineCov">         92 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    3125 </span>            :       /* Parse the template arguments.  */
<span class="lineNum">    3126 </span><span class="lineCov">         92 :       cp_parser_enclosed_template_argument_list (parser);</span>
<span class="lineNum">    3127 </span>            :       /* Permanently remove the invalid template arguments so that
<span class="lineNum">    3128 </span>            :          this error message is not issued again.  */
<span class="lineNum">    3129 </span><span class="lineCov">         92 :       if (start)</span>
<span class="lineNum">    3130 </span><span class="lineCov">         59 :         cp_lexer_purge_tokens_after (parser-&gt;lexer, start);</span>
<span class="lineNum">    3131 </span>            :     }
<span class="lineNum">    3132 </span><span class="lineCov">   55962261 : }</span>
<span class="lineNum">    3133 </span>            : 
<span class="lineNum">    3134 </span>            : /* If parsing an integral constant-expression, issue an error message
<span class="lineNum">    3135 </span>            :    about the fact that THING appeared and return true.  Otherwise,
<span class="lineNum">    3136 </span>            :    return false.  In either case, set
<span class="lineNum">    3137 </span>            :    PARSER-&gt;NON_INTEGRAL_CONSTANT_EXPRESSION_P.  */
<a name="3138"><span class="lineNum">    3138 </span>            : </a>
<span class="lineNum">    3139 </span>            : static bool
<span class="lineNum">    3140 </span><span class="lineCov">   20613691 : cp_parser_non_integral_constant_expression (cp_parser  *parser,</span>
<span class="lineNum">    3141 </span>            :                                             non_integral_constant thing)
<span class="lineNum">    3142 </span>            : {
<span class="lineNum">    3143 </span><span class="lineCov">   20613691 :   parser-&gt;non_integral_constant_expression_p = true;</span>
<span class="lineNum">    3144 </span><span class="lineCov">   20613691 :   if (parser-&gt;integral_constant_expression_p)</span>
<span class="lineNum">    3145 </span>            :     {
<span class="lineNum">    3146 </span><span class="lineCov">    3110109 :       if (!parser-&gt;allow_non_integral_constant_expression_p)</span>
<span class="lineNum">    3147 </span>            :         {
<span class="lineNum">    3148 </span><span class="lineCov">         62 :           const char *msg = NULL;</span>
<span class="lineNum">    3149 </span><span class="lineCov">         62 :           switch (thing)</span>
<span class="lineNum">    3150 </span>            :             {
<span class="lineNum">    3151 </span><span class="lineCov">         10 :               case NIC_FLOAT:</span>
<span class="lineNum">    3152 </span><span class="lineCov">         10 :                 pedwarn (input_location, OPT_Wpedantic,</span>
<span class="lineNum">    3153 </span>            :                          &quot;ISO C++ forbids using a floating-point literal &quot;
<span class="lineNum">    3154 </span>            :                          &quot;in a constant-expression&quot;);
<span class="lineNum">    3155 </span><span class="lineCov">         10 :                 return true;</span>
<span class="lineNum">    3156 </span><span class="lineCov">         18 :               case NIC_CAST:</span>
<span class="lineNum">    3157 </span><span class="lineCov">         18 :                 error (&quot;a cast to a type other than an integral or &quot;</span>
<span class="lineNum">    3158 </span>            :                        &quot;enumeration type cannot appear in a &quot;
<span class="lineNum">    3159 </span>            :                        &quot;constant-expression&quot;);
<span class="lineNum">    3160 </span><span class="lineCov">         18 :                 return true;</span>
<span class="lineNum">    3161 </span><span class="lineCov">          1 :               case NIC_TYPEID:</span>
<span class="lineNum">    3162 </span><span class="lineCov">          1 :                 error (&quot;%&lt;typeid%&gt; operator &quot;</span>
<span class="lineNum">    3163 </span>            :                        &quot;cannot appear in a constant-expression&quot;);
<span class="lineNum">    3164 </span><span class="lineCov">          1 :                 return true;</span>
<span class="lineNum">    3165 </span><span class="lineNoCov">          0 :               case NIC_NCC:</span>
<span class="lineNum">    3166 </span><span class="lineNoCov">          0 :                 error (&quot;non-constant compound literals &quot;</span>
<span class="lineNum">    3167 </span>            :                        &quot;cannot appear in a constant-expression&quot;);
<span class="lineNum">    3168 </span><span class="lineNoCov">          0 :                 return true;</span>
<span class="lineNum">    3169 </span><span class="lineCov">          4 :               case NIC_FUNC_CALL:</span>
<span class="lineNum">    3170 </span><span class="lineCov">          4 :                 error (&quot;a function call &quot;</span>
<span class="lineNum">    3171 </span>            :                        &quot;cannot appear in a constant-expression&quot;);
<span class="lineNum">    3172 </span><span class="lineCov">          4 :                 return true;</span>
<span class="lineNum">    3173 </span><span class="lineNoCov">          0 :               case NIC_INC:</span>
<span class="lineNum">    3174 </span><span class="lineNoCov">          0 :                 error (&quot;an increment &quot;</span>
<span class="lineNum">    3175 </span>            :                        &quot;cannot appear in a constant-expression&quot;);
<span class="lineNum">    3176 </span><span class="lineNoCov">          0 :                 return true;</span>
<span class="lineNum">    3177 </span><span class="lineNoCov">          0 :               case NIC_DEC:</span>
<span class="lineNum">    3178 </span><span class="lineNoCov">          0 :                 error (&quot;an decrement &quot;</span>
<span class="lineNum">    3179 </span>            :                        &quot;cannot appear in a constant-expression&quot;);
<span class="lineNum">    3180 </span><span class="lineNoCov">          0 :                 return true;</span>
<span class="lineNum">    3181 </span><span class="lineCov">          5 :               case NIC_ARRAY_REF:</span>
<span class="lineNum">    3182 </span><span class="lineCov">          5 :                 error (&quot;an array reference &quot;</span>
<span class="lineNum">    3183 </span>            :                        &quot;cannot appear in a constant-expression&quot;);
<span class="lineNum">    3184 </span><span class="lineCov">          5 :                 return true;</span>
<span class="lineNum">    3185 </span><span class="lineCov">          2 :               case NIC_ADDR_LABEL:</span>
<span class="lineNum">    3186 </span><span class="lineCov">          2 :                 error (&quot;the address of a label &quot;</span>
<span class="lineNum">    3187 </span>            :                        &quot;cannot appear in a constant-expression&quot;);
<span class="lineNum">    3188 </span><span class="lineCov">          2 :                 return true;</span>
<span class="lineNum">    3189 </span><span class="lineNoCov">          0 :               case NIC_OVERLOADED:</span>
<span class="lineNum">    3190 </span><span class="lineNoCov">          0 :                 error (&quot;calls to overloaded operators &quot;</span>
<span class="lineNum">    3191 </span>            :                        &quot;cannot appear in a constant-expression&quot;);
<span class="lineNum">    3192 </span><span class="lineNoCov">          0 :                 return true;</span>
<span class="lineNum">    3193 </span><span class="lineCov">          1 :               case NIC_ASSIGNMENT:</span>
<span class="lineNum">    3194 </span><span class="lineCov">          1 :                 error (&quot;an assignment cannot appear in a constant-expression&quot;);</span>
<span class="lineNum">    3195 </span><span class="lineCov">          1 :                 return true;</span>
<span class="lineNum">    3196 </span><span class="lineCov">          2 :               case NIC_COMMA:</span>
<span class="lineNum">    3197 </span><span class="lineCov">          2 :                 error (&quot;a comma operator &quot;</span>
<span class="lineNum">    3198 </span>            :                        &quot;cannot appear in a constant-expression&quot;);
<span class="lineNum">    3199 </span><span class="lineCov">          2 :                 return true;</span>
<span class="lineNum">    3200 </span><span class="lineCov">          1 :               case NIC_CONSTRUCTOR:</span>
<span class="lineNum">    3201 </span><span class="lineCov">          1 :                 error (&quot;a call to a constructor &quot;</span>
<span class="lineNum">    3202 </span>            :                        &quot;cannot appear in a constant-expression&quot;);
<span class="lineNum">    3203 </span><span class="lineCov">          1 :                 return true;</span>
<span class="lineNum">    3204 </span><span class="lineNoCov">          0 :               case NIC_TRANSACTION:</span>
<span class="lineNum">    3205 </span><span class="lineNoCov">          0 :                 error (&quot;a transaction expression &quot;</span>
<span class="lineNum">    3206 </span>            :                        &quot;cannot appear in a constant-expression&quot;);
<span class="lineNum">    3207 </span><span class="lineNoCov">          0 :                 return true;</span>
<span class="lineNum">    3208 </span>            :               case NIC_THIS:
<span class="lineNum">    3209 </span>            :                 msg = &quot;this&quot;;
<span class="lineNum">    3210 </span>            :                 break;
<span class="lineNum">    3211 </span><span class="lineCov">          1 :               case NIC_FUNC_NAME:</span>
<span class="lineNum">    3212 </span><span class="lineCov">          1 :                 msg = &quot;__FUNCTION__&quot;;</span>
<span class="lineNum">    3213 </span><span class="lineCov">          1 :                 break;</span>
<span class="lineNum">    3214 </span><span class="lineCov">          1 :               case NIC_PRETTY_FUNC:</span>
<span class="lineNum">    3215 </span><span class="lineCov">          1 :                 msg = &quot;__PRETTY_FUNCTION__&quot;;</span>
<span class="lineNum">    3216 </span><span class="lineCov">          1 :                 break;</span>
<span class="lineNum">    3217 </span><span class="lineCov">          1 :               case NIC_C99_FUNC:</span>
<span class="lineNum">    3218 </span><span class="lineCov">          1 :                 msg = &quot;__func__&quot;;</span>
<span class="lineNum">    3219 </span><span class="lineCov">          1 :                 break;</span>
<span class="lineNum">    3220 </span><span class="lineNoCov">          0 :               case NIC_VA_ARG:</span>
<span class="lineNum">    3221 </span><span class="lineNoCov">          0 :                 msg = &quot;va_arg&quot;;</span>
<span class="lineNum">    3222 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    3223 </span><span class="lineCov">          1 :               case NIC_ARROW:</span>
<span class="lineNum">    3224 </span><span class="lineCov">          1 :                 msg = &quot;-&gt;&quot;;</span>
<span class="lineNum">    3225 </span><span class="lineCov">          1 :                 break;</span>
<span class="lineNum">    3226 </span><span class="lineCov">          1 :               case NIC_POINT:</span>
<span class="lineNum">    3227 </span><span class="lineCov">          1 :                 msg = &quot;.&quot;;</span>
<span class="lineNum">    3228 </span><span class="lineCov">          1 :                 break;</span>
<span class="lineNum">    3229 </span><span class="lineCov">          4 :               case NIC_STAR:</span>
<span class="lineNum">    3230 </span><span class="lineCov">          4 :                 msg = &quot;*&quot;;</span>
<span class="lineNum">    3231 </span><span class="lineCov">          4 :                 break;</span>
<span class="lineNum">    3232 </span><span class="lineCov">          9 :               case NIC_ADDR:</span>
<span class="lineNum">    3233 </span><span class="lineCov">          9 :                 msg = &quot;&amp;&quot;;</span>
<span class="lineNum">    3234 </span><span class="lineCov">          9 :                 break;</span>
<span class="lineNum">    3235 </span><span class="lineNoCov">          0 :               case NIC_PREINCREMENT:</span>
<span class="lineNum">    3236 </span><span class="lineNoCov">          0 :                 msg = &quot;++&quot;;</span>
<span class="lineNum">    3237 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    3238 </span><span class="lineNoCov">          0 :               case NIC_PREDECREMENT:</span>
<span class="lineNum">    3239 </span><span class="lineNoCov">          0 :                 msg = &quot;--&quot;;</span>
<span class="lineNum">    3240 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    3241 </span><span class="lineNoCov">          0 :               case NIC_NEW:</span>
<span class="lineNum">    3242 </span><span class="lineNoCov">          0 :                 msg = &quot;new&quot;;</span>
<span class="lineNum">    3243 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    3244 </span><span class="lineNoCov">          0 :               case NIC_DEL:</span>
<span class="lineNum">    3245 </span><span class="lineNoCov">          0 :                 msg = &quot;delete&quot;;</span>
<span class="lineNum">    3246 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    3247 </span><span class="lineNoCov">          0 :               default:</span>
<span class="lineNum">    3248 </span><span class="lineNoCov">          0 :                 gcc_unreachable ();</span>
<span class="lineNum">    3249 </span>            :             }
<span class="lineNum">    3250 </span><span class="lineCov">         18 :           if (msg)</span>
<span class="lineNum">    3251 </span><span class="lineCov">         18 :             error (&quot;%qs cannot appear in a constant-expression&quot;, msg);</span>
<span class="lineNum">    3252 </span><span class="lineCov">         18 :           return true;</span>
<span class="lineNum">    3253 </span>            :         }
<span class="lineNum">    3254 </span>            :     }
<span class="lineNum">    3255 </span>            :   return false;
<span class="lineNum">    3256 </span>            : }
<span class="lineNum">    3257 </span>            : 
<span class="lineNum">    3258 </span>            : /* Emit a diagnostic for an invalid type name.  This function commits
<span class="lineNum">    3259 </span>            :    to the current active tentative parse, if any.  (Otherwise, the
<span class="lineNum">    3260 </span>            :    problematic construct might be encountered again later, resulting
<span class="lineNum">    3261 </span>            :    in duplicate error messages.) LOCATION is the location of ID.  */
<a name="3262"><span class="lineNum">    3262 </span>            : </a>
<span class="lineNum">    3263 </span>            : static void
<span class="lineNum">    3264 </span><span class="lineCov">        553 : cp_parser_diagnose_invalid_type_name (cp_parser *parser, tree id,</span>
<span class="lineNum">    3265 </span>            :                                       location_t location)
<span class="lineNum">    3266 </span>            : {
<span class="lineNum">    3267 </span><span class="lineCov">        553 :   tree decl, ambiguous_decls;</span>
<span class="lineNum">    3268 </span><span class="lineCov">        553 :   cp_parser_commit_to_tentative_parse (parser);</span>
<span class="lineNum">    3269 </span>            :   /* Try to lookup the identifier.  */
<span class="lineNum">    3270 </span><span class="lineCov">       1106 :   decl = cp_parser_lookup_name (parser, id, none_type,</span>
<span class="lineNum">    3271 </span>            :                                 /*is_template=*/false,
<span class="lineNum">    3272 </span>            :                                 /*is_namespace=*/false,
<span class="lineNum">    3273 </span>            :                                 /*check_dependency=*/true,
<span class="lineNum">    3274 </span><span class="lineCov">        553 :                                 &amp;ambiguous_decls, location);</span>
<span class="lineNum">    3275 </span><span class="lineCov">        553 :   if (ambiguous_decls)</span>
<span class="lineNum">    3276 </span>            :     /* If the lookup was ambiguous, an error will already have
<span class="lineNum">    3277 </span>            :        been issued.  */
<span class="lineNum">    3278 </span><span class="lineCov">         18 :     return;</span>
<span class="lineNum">    3279 </span>            :   /* If the lookup found a template-name, it means that the user forgot
<span class="lineNum">    3280 </span>            :   to specify an argument list. Emit a useful error message.  */
<span class="lineNum">    3281 </span><span class="lineCov">        535 :   if (DECL_TYPE_TEMPLATE_P (decl))</span>
<span class="lineNum">    3282 </span>            :     {
<span class="lineNum">    3283 </span><span class="lineCov">        102 :       auto_diagnostic_group d;</span>
<span class="lineNum">    3284 </span><span class="lineCov">         51 :       error_at (location,</span>
<span class="lineNum">    3285 </span>            :                 &quot;invalid use of template-name %qE without an argument list&quot;,
<span class="lineNum">    3286 </span>            :                 decl);
<span class="lineNum">    3287 </span><span class="lineCov">         51 :       if (DECL_CLASS_TEMPLATE_P (decl) &amp;&amp; cxx_dialect &lt; cxx17)</span>
<span class="lineNum">    3288 </span><span class="lineCov">         48 :         inform (location, &quot;class template argument deduction is only available &quot;</span>
<span class="lineNum">    3289 </span>            :                 &quot;with -std=c++17 or -std=gnu++17&quot;);
<span class="lineNum">    3290 </span><span class="lineCov">         51 :       inform (DECL_SOURCE_LOCATION (decl), &quot;%qD declared here&quot;, decl);</span>
<span class="lineNum">    3291 </span>            :     }
<span class="lineNum">    3292 </span><span class="lineCov">        484 :   else if (TREE_CODE (id) == BIT_NOT_EXPR)</span>
<span class="lineNum">    3293 </span><span class="lineCov">          6 :     error_at (location, &quot;invalid use of destructor %qD as a type&quot;, id);</span>
<span class="lineNum">    3294 </span><span class="lineCov">        478 :   else if (TREE_CODE (decl) == TYPE_DECL)</span>
<span class="lineNum">    3295 </span>            :     /* Something like 'unsigned A a;'  */
<span class="lineNum">    3296 </span><span class="lineNoCov">          0 :     error_at (location, &quot;invalid combination of multiple type-specifiers&quot;);</span>
<span class="lineNum">    3297 </span><span class="lineCov">        478 :   else if (!parser-&gt;scope)</span>
<span class="lineNum">    3298 </span>            :     {
<span class="lineNum">    3299 </span>            :       /* Issue an error message.  */
<span class="lineNum">    3300 </span><span class="lineCov">        268 :       auto_diagnostic_group d;</span>
<span class="lineNum">    3301 </span><span class="lineCov">        545 :       name_hint hint;</span>
<span class="lineNum">    3302 </span><span class="lineCov">        268 :       if (TREE_CODE (id) == IDENTIFIER_NODE)</span>
<span class="lineNum">    3303 </span><span class="lineCov">        267 :         hint = lookup_name_fuzzy (id, FUZZY_LOOKUP_TYPENAME, location);</span>
<span class="lineNum">    3304 </span><span class="lineCov">        536 :       if (hint)</span>
<span class="lineNum">    3305 </span>            :         {
<span class="lineNum">    3306 </span><span class="lineCov">         38 :           gcc_rich_location richloc (location);</span>
<span class="lineNum">    3307 </span><span class="lineCov">         38 :           richloc.add_fixit_replace (hint.suggestion ());</span>
<span class="lineNum">    3308 </span><span class="lineCov">         38 :           error_at (&amp;richloc,</span>
<span class="lineNum">    3309 </span>            :                     &quot;%qE does not name a type; did you mean %qs?&quot;,
<span class="lineNum">    3310 </span>            :                     id, hint.suggestion ());
<span class="lineNum">    3311 </span>            :         }
<span class="lineNum">    3312 </span>            :       else
<span class="lineNum">    3313 </span><span class="lineCov">        249 :         error_at (location, &quot;%qE does not name a type&quot;, id);</span>
<span class="lineNum">    3314 </span>            :       /* If we're in a template class, it's possible that the user was
<span class="lineNum">    3315 </span>            :          referring to a type from a base class.  For example:
<span class="lineNum">    3316 </span>            : 
<span class="lineNum">    3317 </span>            :            template &lt;typename T&gt; struct A { typedef T X; };
<span class="lineNum">    3318 </span>            :            template &lt;typename T&gt; struct B : public A&lt;T&gt; { X x; };
<span class="lineNum">    3319 </span>            : 
<span class="lineNum">    3320 </span>            :          The user should have said &quot;typename A&lt;T&gt;::X&quot;.  */
<span class="lineNum">    3321 </span><span class="lineCov">        268 :       if (cxx_dialect &lt; cxx11 &amp;&amp; id == ridpointers[(int)RID_CONSTEXPR])</span>
<span class="lineNum">    3322 </span><span class="lineCov">          3 :         inform (location, &quot;C++11 %&lt;constexpr%&gt; only available with &quot;</span>
<span class="lineNum">    3323 </span>            :                 &quot;-std=c++11 or -std=gnu++11&quot;);
<span class="lineNum">    3324 </span><span class="lineCov">        265 :       else if (cxx_dialect &lt; cxx11 &amp;&amp; id == ridpointers[(int)RID_NOEXCEPT])</span>
<span class="lineNum">    3325 </span><span class="lineCov">          1 :         inform (location, &quot;C++11 %&lt;noexcept%&gt; only available with &quot;</span>
<span class="lineNum">    3326 </span>            :                 &quot;-std=c++11 or -std=gnu++11&quot;);
<span class="lineNum">    3327 </span><span class="lineCov">        264 :       else if (cxx_dialect &lt; cxx11</span>
<span class="lineNum">    3328 </span><span class="lineCov">         88 :                &amp;&amp; TREE_CODE (id) == IDENTIFIER_NODE</span>
<span class="lineNum">    3329 </span><span class="lineCov">        351 :                &amp;&amp; id_equal (id, &quot;thread_local&quot;))</span>
<span class="lineNum">    3330 </span><span class="lineNoCov">          0 :         inform (location, &quot;C++11 %&lt;thread_local%&gt; only available with &quot;</span>
<span class="lineNum">    3331 </span>            :                 &quot;-std=c++11 or -std=gnu++11&quot;);
<span class="lineNum">    3332 </span><span class="lineCov">        264 :       else if (!flag_concepts &amp;&amp; id == ridpointers[(int)RID_CONCEPT])</span>
<span class="lineNum">    3333 </span><span class="lineNoCov">          0 :         inform (location, &quot;%&lt;concept%&gt; only available with -fconcepts&quot;);</span>
<span class="lineNum">    3334 </span><span class="lineCov">         46 :       else if (processing_template_decl &amp;&amp; current_class_type</span>
<span class="lineNum">    3335 </span><span class="lineCov">        298 :                &amp;&amp; TYPE_BINFO (current_class_type))</span>
<span class="lineNum">    3336 </span>            :         {
<span class="lineNum">    3337 </span><span class="lineCov">         34 :           tree b;</span>
<span class="lineNum">    3338 </span>            : 
<span class="lineNum">    3339 </span><span class="lineCov">         34 :           for (b = TREE_CHAIN (TYPE_BINFO (current_class_type));</span>
<span class="lineNum">    3340 </span><span class="lineCov">         40 :                b;</span>
<span class="lineNum">    3341 </span><span class="lineCov">          6 :                b = TREE_CHAIN (b))</span>
<span class="lineNum">    3342 </span>            :             {
<span class="lineNum">    3343 </span><span class="lineCov">         21 :               tree base_type = BINFO_TYPE (b);</span>
<span class="lineNum">    3344 </span><span class="lineCov">         21 :               if (CLASS_TYPE_P (base_type)</span>
<span class="lineNum">    3345 </span><span class="lineCov">         42 :                   &amp;&amp; dependent_type_p (base_type))</span>
<span class="lineNum">    3346 </span>            :                 {
<span class="lineNum">    3347 </span><span class="lineCov">         21 :                   tree field;</span>
<span class="lineNum">    3348 </span>            :                   /* Go from a particular instantiation of the
<span class="lineNum">    3349 </span>            :                      template (which will have an empty TYPE_FIELDs),
<span class="lineNum">    3350 </span>            :                      to the main version.  */
<span class="lineNum">    3351 </span><span class="lineCov">         21 :                   base_type = CLASSTYPE_PRIMARY_TEMPLATE_TYPE (base_type);</span>
<span class="lineNum">    3352 </span><span class="lineCov">         21 :                   for (field = TYPE_FIELDS (base_type);</span>
<span class="lineNum">    3353 </span><span class="lineCov">         42 :                        field;</span>
<span class="lineNum">    3354 </span><span class="lineCov">         21 :                        field = DECL_CHAIN (field))</span>
<span class="lineNum">    3355 </span><span class="lineCov">         36 :                     if (TREE_CODE (field) == TYPE_DECL</span>
<span class="lineNum">    3356 </span><span class="lineCov">         36 :                         &amp;&amp; DECL_NAME (field) == id)</span>
<span class="lineNum">    3357 </span>            :                       {
<span class="lineNum">    3358 </span><span class="lineCov">         30 :                         inform (location, </span>
<span class="lineNum">    3359 </span>            :                                 &quot;(perhaps %&lt;typename %T::%E%&gt; was intended)&quot;,
<span class="lineNum">    3360 </span><span class="lineCov">         15 :                                 BINFO_TYPE (b), id);</span>
<span class="lineNum">    3361 </span><span class="lineCov">         15 :                         break;</span>
<span class="lineNum">    3362 </span>            :                       }
<span class="lineNum">    3363 </span><span class="lineCov">         21 :                   if (field)</span>
<span class="lineNum">    3364 </span>            :                     break;
<span class="lineNum">    3365 </span>            :                 }
<span class="lineNum">    3366 </span>            :             }
<span class="lineNum">    3367 </span>            :         }
<span class="lineNum">    3368 </span>            :     }
<span class="lineNum">    3369 </span>            :   /* Here we diagnose qualified-ids where the scope is actually correct,
<span class="lineNum">    3370 </span>            :      but the identifier does not resolve to a valid type name.  */
<span class="lineNum">    3371 </span><span class="lineCov">        210 :   else if (parser-&gt;scope != error_mark_node)</span>
<span class="lineNum">    3372 </span>            :     {
<span class="lineNum">    3373 </span><span class="lineCov">        183 :       if (TREE_CODE (parser-&gt;scope) == NAMESPACE_DECL)</span>
<span class="lineNum">    3374 </span>            :         {
<span class="lineNum">    3375 </span><span class="lineCov">        132 :           auto_diagnostic_group d;</span>
<span class="lineNum">    3376 </span><span class="lineCov">         66 :           if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_LESS))</span>
<span class="lineNum">    3377 </span><span class="lineCov">         28 :             error_at (location_of (id),</span>
<span class="lineNum">    3378 </span>            :                       &quot;%qE in namespace %qE does not name a template type&quot;,
<span class="lineNum">    3379 </span>            :                       id, parser-&gt;scope);
<span class="lineNum">    3380 </span><span class="lineCov">         38 :           else if (TREE_CODE (id) == TEMPLATE_ID_EXPR)</span>
<span class="lineNum">    3381 </span><span class="lineNoCov">          0 :             error_at (location_of (id),</span>
<span class="lineNum">    3382 </span>            :                       &quot;%qE in namespace %qE does not name a template type&quot;,
<span class="lineNum">    3383 </span><span class="lineNoCov">          0 :                       TREE_OPERAND (id, 0), parser-&gt;scope);</span>
<span class="lineNum">    3384 </span>            :           else
<span class="lineNum">    3385 </span><span class="lineCov">         38 :             error_at (location_of (id),</span>
<span class="lineNum">    3386 </span>            :                       &quot;%qE in namespace %qE does not name a type&quot;,
<span class="lineNum">    3387 </span>            :                       id, parser-&gt;scope);
<span class="lineNum">    3388 </span><span class="lineCov">         66 :           if (DECL_P (decl))</span>
<span class="lineNum">    3389 </span><span class="lineCov">         13 :             inform (DECL_SOURCE_LOCATION (decl), &quot;%qD declared here&quot;, decl);</span>
<span class="lineNum">    3390 </span><span class="lineCov">         53 :           else if (decl == error_mark_node)</span>
<span class="lineNum">    3391 </span><span class="lineCov">         50 :             suggest_alternative_in_explicit_scope (location, id,</span>
<span class="lineNum">    3392 </span>            :                                                    parser-&gt;scope);
<span class="lineNum">    3393 </span>            :         }
<span class="lineNum">    3394 </span><span class="lineCov">        103 :       else if (CLASS_TYPE_P (parser-&gt;scope)</span>
<span class="lineNum">    3395 </span><span class="lineCov">        220 :                &amp;&amp; constructor_name_p (id, parser-&gt;scope))</span>
<span class="lineNum">    3396 </span>            :         {
<span class="lineNum">    3397 </span>            :           /* A&lt;T&gt;::A&lt;T&gt;() */
<span class="lineNum">    3398 </span><span class="lineCov">         18 :           auto_diagnostic_group d;</span>
<span class="lineNum">    3399 </span><span class="lineCov">          9 :           error_at (location, &quot;%&lt;%T::%E%&gt; names the constructor, not&quot;</span>
<span class="lineNum">    3400 </span>            :                     &quot; the type&quot;, parser-&gt;scope, id);
<span class="lineNum">    3401 </span><span class="lineCov">          9 :           if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_LESS))</span>
<span class="lineNum">    3402 </span><span class="lineCov">          6 :             error_at (location, &quot;and %qT has no template constructors&quot;,</span>
<span class="lineNum">    3403 </span>            :                       parser-&gt;scope);
<span class="lineNum">    3404 </span>            :         }
<span class="lineNum">    3405 </span><span class="lineCov">        108 :       else if (TYPE_P (parser-&gt;scope)</span>
<span class="lineNum">    3406 </span><span class="lineCov">        108 :                &amp;&amp; dependent_scope_p (parser-&gt;scope))</span>
<span class="lineNum">    3407 </span>            :         {
<span class="lineNum">    3408 </span><span class="lineCov">         94 :           gcc_rich_location richloc (location);</span>
<span class="lineNum">    3409 </span><span class="lineCov">         47 :           richloc.add_fixit_insert_before (&quot;typename &quot;);</span>
<span class="lineNum">    3410 </span><span class="lineCov">         47 :           if (TREE_CODE (parser-&gt;scope) == TYPENAME_TYPE)</span>
<span class="lineNum">    3411 </span><span class="lineCov">         36 :             error_at (&amp;richloc,</span>
<span class="lineNum">    3412 </span>            :                       &quot;need %&lt;typename%&gt; before %&lt;%T::%D::%E%&gt; because &quot;
<span class="lineNum">    3413 </span>            :                       &quot;%&lt;%T::%D%&gt; is a dependent scope&quot;,
<span class="lineNum">    3414 </span><span class="lineCov">          9 :                       TYPE_CONTEXT (parser-&gt;scope),</span>
<span class="lineNum">    3415 </span><span class="lineCov">         18 :                       TYPENAME_TYPE_FULLNAME (parser-&gt;scope),</span>
<span class="lineNum">    3416 </span>            :                       id,
<span class="lineNum">    3417 </span><span class="lineCov">          9 :                       TYPE_CONTEXT (parser-&gt;scope),</span>
<span class="lineNum">    3418 </span><span class="lineCov">         18 :                       TYPENAME_TYPE_FULLNAME (parser-&gt;scope));</span>
<span class="lineNum">    3419 </span>            :           else
<span class="lineNum">    3420 </span><span class="lineCov">         38 :             error_at (&amp;richloc, &quot;need %&lt;typename%&gt; before %&lt;%T::%E%&gt; because &quot;</span>
<span class="lineNum">    3421 </span>            :                       &quot;%qT is a dependent scope&quot;,
<span class="lineNum">    3422 </span>            :                       parser-&gt;scope, id, parser-&gt;scope);
<span class="lineNum">    3423 </span>            :         }
<span class="lineNum">    3424 </span><span class="lineCov">         61 :       else if (TYPE_P (parser-&gt;scope))</span>
<span class="lineNum">    3425 </span>            :         {
<span class="lineNum">    3426 </span><span class="lineCov">        122 :           auto_diagnostic_group d;</span>
<span class="lineNum">    3427 </span><span class="lineCov">         61 :           if (!COMPLETE_TYPE_P (parser-&gt;scope))</span>
<span class="lineNum">    3428 </span><span class="lineCov">         17 :             cxx_incomplete_type_error (location_of (id), NULL_TREE,</span>
<span class="lineNum">    3429 </span>            :                                        parser-&gt;scope);
<span class="lineNum">    3430 </span><span class="lineCov">         44 :           else if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_LESS))</span>
<span class="lineNum">    3431 </span><span class="lineCov">          8 :             error_at (location_of (id),</span>
<span class="lineNum">    3432 </span>            :                       &quot;%qE in %q#T does not name a template type&quot;,
<span class="lineNum">    3433 </span>            :                       id, parser-&gt;scope);
<span class="lineNum">    3434 </span><span class="lineCov">         36 :           else if (TREE_CODE (id) == TEMPLATE_ID_EXPR)</span>
<span class="lineNum">    3435 </span><span class="lineNoCov">          0 :             error_at (location_of (id),</span>
<span class="lineNum">    3436 </span>            :                       &quot;%qE in %q#T does not name a template type&quot;,
<span class="lineNum">    3437 </span><span class="lineNoCov">          0 :                       TREE_OPERAND (id, 0), parser-&gt;scope);</span>
<span class="lineNum">    3438 </span>            :           else
<span class="lineNum">    3439 </span><span class="lineCov">         36 :             error_at (location_of (id),</span>
<span class="lineNum">    3440 </span>            :                       &quot;%qE in %q#T does not name a type&quot;,
<span class="lineNum">    3441 </span>            :                       id, parser-&gt;scope);
<span class="lineNum">    3442 </span><span class="lineCov">         61 :           if (DECL_P (decl))</span>
<span class="lineNum">    3443 </span><span class="lineCov">          3 :             inform (DECL_SOURCE_LOCATION (decl), &quot;%qD declared here&quot;, decl);</span>
<span class="lineNum">    3444 </span>            :         }
<span class="lineNum">    3445 </span>            :       else
<span class="lineNum">    3446 </span><span class="lineNoCov">          0 :         gcc_unreachable ();</span>
<span class="lineNum">    3447 </span>            :     }
<span class="lineNum">    3448 </span>            : }
<span class="lineNum">    3449 </span>            : 
<span class="lineNum">    3450 </span>            : /* Check for a common situation where a type-name should be present,
<span class="lineNum">    3451 </span>            :    but is not, and issue a sensible error message.  Returns true if an
<span class="lineNum">    3452 </span>            :    invalid type-name was detected.
<span class="lineNum">    3453 </span>            : 
<span class="lineNum">    3454 </span>            :    The situation handled by this function are variable declarations of the
<span class="lineNum">    3455 </span>            :    form `ID a', where `ID' is an id-expression and `a' is a plain identifier.
<span class="lineNum">    3456 </span>            :    Usually, `ID' should name a type, but if we got here it means that it
<span class="lineNum">    3457 </span>            :    does not. We try to emit the best possible error message depending on
<span class="lineNum">    3458 </span>            :    how exactly the id-expression looks like.  */
<a name="3459"><span class="lineNum">    3459 </span>            : </a>
<span class="lineNum">    3460 </span>            : static bool
<span class="lineNum">    3461 </span><span class="lineCov">    1147228 : cp_parser_parse_and_diagnose_invalid_type_name (cp_parser *parser)</span>
<span class="lineNum">    3462 </span>            : {
<span class="lineNum">    3463 </span><span class="lineCov">    1147228 :   tree id;</span>
<span class="lineNum">    3464 </span><span class="lineCov">    2294456 :   cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">    3465 </span>            : 
<span class="lineNum">    3466 </span>            :   /* Avoid duplicate error about ambiguous lookup.  */
<span class="lineNum">    3467 </span><span class="lineCov">    1147228 :   if (token-&gt;type == CPP_NESTED_NAME_SPECIFIER)</span>
<span class="lineNum">    3468 </span>            :     {
<span class="lineNum">    3469 </span><span class="lineCov">      38402 :       cp_token *next = cp_lexer_peek_nth_token (parser-&gt;lexer, 2);</span>
<span class="lineNum">    3470 </span><span class="lineCov">      38402 :       if (next-&gt;type == CPP_NAME &amp;&amp; next-&gt;error_reported)</span>
<span class="lineNum">    3471 </span>            :         goto out;
<span class="lineNum">    3472 </span>            :     }
<span class="lineNum">    3473 </span>            : 
<span class="lineNum">    3474 </span><span class="lineCov">    1147228 :   cp_parser_parse_tentatively (parser);</span>
<span class="lineNum">    3475 </span><span class="lineCov">    2294456 :   id = cp_parser_id_expression (parser,</span>
<span class="lineNum">    3476 </span>            :                                 /*template_keyword_p=*/false,
<span class="lineNum">    3477 </span>            :                                 /*check_dependency_p=*/true,
<span class="lineNum">    3478 </span>            :                                 /*template_p=*/NULL,
<span class="lineNum">    3479 </span>            :                                 /*declarator_p=*/false,
<span class="lineNum">    3480 </span><span class="lineCov">    1147228 :                                 /*optional_p=*/false);</span>
<span class="lineNum">    3481 </span>            :   /* If the next token is a (, this is a function with no explicit return
<span class="lineNum">    3482 </span>            :      type, i.e. constructor, destructor or conversion op.  */
<span class="lineNum">    3483 </span><span class="lineCov">    2294456 :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_PAREN)</span>
<span class="lineNum">    3484 </span><span class="lineCov">    1147228 :       || TREE_CODE (id) == TYPE_DECL)</span>
<span class="lineNum">    3485 </span>            :     {
<span class="lineNum">    3486 </span><span class="lineCov">    1146321 :       cp_parser_abort_tentative_parse (parser);</span>
<span class="lineNum">    3487 </span><span class="lineCov">    1146321 :       return false;</span>
<span class="lineNum">    3488 </span>            :     }
<span class="lineNum">    3489 </span><span class="lineCov">        907 :   if (!cp_parser_parse_definitely (parser))</span>
<span class="lineNum">    3490 </span>            :     return false;
<span class="lineNum">    3491 </span>            : 
<span class="lineNum">    3492 </span>            :   /* Emit a diagnostic for the invalid type.  */
<span class="lineNum">    3493 </span><span class="lineCov">        478 :   cp_parser_diagnose_invalid_type_name (parser, id, token-&gt;location);</span>
<span class="lineNum">    3494 </span><span class="lineCov">        478 :  out:</span>
<span class="lineNum">    3495 </span>            :   /* If we aren't in the middle of a declarator (i.e. in a
<span class="lineNum">    3496 </span>            :      parameter-declaration-clause), skip to the end of the declaration;
<span class="lineNum">    3497 </span>            :      there's no point in trying to process it.  */
<span class="lineNum">    3498 </span><span class="lineCov">        478 :   if (!parser-&gt;in_declarator_p)</span>
<span class="lineNum">    3499 </span><span class="lineCov">        397 :     cp_parser_skip_to_end_of_block_or_statement (parser);</span>
<span class="lineNum">    3500 </span>            :   return true;
<span class="lineNum">    3501 </span>            : }
<span class="lineNum">    3502 </span>            : 
<span class="lineNum">    3503 </span>            : /* Consume tokens up to, and including, the next non-nested closing `)'.
<span class="lineNum">    3504 </span>            :    Returns 1 iff we found a closing `)'.  RECOVERING is true, if we
<span class="lineNum">    3505 </span>            :    are doing error recovery. Returns -1 if OR_TTYPE is not CPP_EOF and we
<span class="lineNum">    3506 </span>            :    found an unnested token of that type.  */
<a name="3507"><span class="lineNum">    3507 </span>            : </a>
<span class="lineNum">    3508 </span>            : static int
<span class="lineNum">    3509 </span><span class="lineCov">   11406419 : cp_parser_skip_to_closing_parenthesis_1 (cp_parser *parser,</span>
<span class="lineNum">    3510 </span>            :                                          bool recovering,
<span class="lineNum">    3511 </span>            :                                          cpp_ttype or_ttype,
<span class="lineNum">    3512 </span>            :                                          bool consume_paren)
<span class="lineNum">    3513 </span>            : {
<span class="lineNum">    3514 </span><span class="lineCov">   11406419 :   unsigned paren_depth = 0;</span>
<span class="lineNum">    3515 </span><span class="lineCov">   11406419 :   unsigned brace_depth = 0;</span>
<span class="lineNum">    3516 </span><span class="lineCov">   11406419 :   unsigned square_depth = 0;</span>
<span class="lineNum">    3517 </span><span class="lineCov">   11406419 :   unsigned condop_depth = 0;</span>
<span class="lineNum">    3518 </span>            : 
<span class="lineNum">    3519 </span><span class="lineCov">   11406419 :   if (recovering &amp;&amp; or_ttype == CPP_EOF</span>
<span class="lineNum">    3520 </span><span class="lineCov">   11406419 :       &amp;&amp; cp_parser_uncommitted_to_tentative_parse_p (parser))</span>
<span class="lineNum">    3521 </span>            :     return 0;
<span class="lineNum">    3522 </span>            : 
<span class="lineNum">    3523 </span><span class="lineCov">  185170604 :   while (true)</span>
<span class="lineNum">    3524 </span>            :     {
<span class="lineNum">    3525 </span><span class="lineCov">  370341208 :       cp_token * token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">    3526 </span>            : 
<span class="lineNum">    3527 </span>            :       /* Have we found what we're looking for before the closing paren?  */
<span class="lineNum">    3528 </span><span class="lineCov">  185170604 :       if (token-&gt;type == or_ttype &amp;&amp; or_ttype != CPP_EOF</span>
<span class="lineNum">    3529 </span><span class="lineCov">     136611 :           &amp;&amp; !brace_depth &amp;&amp; !paren_depth &amp;&amp; !square_depth &amp;&amp; !condop_depth)</span>
<span class="lineNum">    3530 </span>            :         return -1;
<span class="lineNum">    3531 </span>            : 
<span class="lineNum">    3532 </span><span class="lineCov">  185044948 :       switch (token-&gt;type)</span>
<span class="lineNum">    3533 </span>            :         {
<span class="lineNum">    3534 </span>            :         case CPP_EOF:
<span class="lineNum">    3535 </span>            :         case CPP_PRAGMA_EOL:
<span class="lineNum">    3536 </span>            :           /* If we've run out of tokens, then there is no closing `)'.  */
<span class="lineNum">    3537 </span>            :           return 0;
<span class="lineNum">    3538 </span>            : 
<span class="lineNum">    3539 </span>            :         /* This is good for lambda expression capture-lists.  */
<span class="lineNum">    3540 </span><span class="lineCov">     748683 :         case CPP_OPEN_SQUARE:</span>
<span class="lineNum">    3541 </span><span class="lineCov">     748683 :           ++square_depth;</span>
<span class="lineNum">    3542 </span><span class="lineCov">     748683 :           break;</span>
<span class="lineNum">    3543 </span><span class="lineCov">     748692 :         case CPP_CLOSE_SQUARE:</span>
<span class="lineNum">    3544 </span><span class="lineCov">     748692 :           if (!square_depth--)</span>
<span class="lineNum">    3545 </span>            :             return 0;
<span class="lineNum">    3546 </span>            :           break;
<span class="lineNum">    3547 </span>            : 
<span class="lineNum">    3548 </span><span class="lineCov">     674326 :         case CPP_SEMICOLON:</span>
<span class="lineNum">    3549 </span>            :           /* This matches the processing in skip_to_end_of_statement.  */
<span class="lineNum">    3550 </span><span class="lineCov">     674326 :           if (!brace_depth)</span>
<span class="lineNum">    3551 </span>            :             return 0;
<span class="lineNum">    3552 </span>            :           break;
<span class="lineNum">    3553 </span>            : 
<span class="lineNum">    3554 </span><span class="lineCov">      55202 :         case CPP_OPEN_BRACE:</span>
<span class="lineNum">    3555 </span><span class="lineCov">      55202 :           ++brace_depth;</span>
<span class="lineNum">    3556 </span><span class="lineCov">      55202 :           break;</span>
<span class="lineNum">    3557 </span><span class="lineCov">      55220 :         case CPP_CLOSE_BRACE:</span>
<span class="lineNum">    3558 </span><span class="lineCov">      55220 :           if (!brace_depth--)</span>
<span class="lineNum">    3559 </span>            :             return 0;
<span class="lineNum">    3560 </span>            :           break;
<span class="lineNum">    3561 </span>            : 
<span class="lineNum">    3562 </span><span class="lineCov">   34179369 :         case CPP_OPEN_PAREN:</span>
<span class="lineNum">    3563 </span><span class="lineCov">   34179369 :           if (!brace_depth)</span>
<span class="lineNum">    3564 </span><span class="lineCov">   33702101 :             ++paren_depth;</span>
<span class="lineNum">    3565 </span>            :           break;
<span class="lineNum">    3566 </span>            : 
<span class="lineNum">    3567 </span><span class="lineCov">   45334313 :         case CPP_CLOSE_PAREN:</span>
<span class="lineNum">    3568 </span><span class="lineCov">   45334313 :           if (!brace_depth &amp;&amp; !paren_depth--)</span>
<span class="lineNum">    3569 </span>            :             {
<span class="lineNum">    3570 </span><span class="lineCov">   11154946 :               if (consume_paren)</span>
<span class="lineNum">    3571 </span><span class="lineCov">    9496452 :                 cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    3572 </span><span class="lineCov">   11154946 :               return 1;</span>
<span class="lineNum">    3573 </span>            :             }
<span class="lineNum">    3574 </span>            :           break;
<span class="lineNum">    3575 </span>            : 
<span class="lineNum">    3576 </span><span class="lineCov">     385649 :         case CPP_QUERY:</span>
<span class="lineNum">    3577 </span><span class="lineCov">     385649 :           if (!brace_depth &amp;&amp; !paren_depth &amp;&amp; !square_depth)</span>
<span class="lineNum">    3578 </span><span class="lineCov">     292141 :             ++condop_depth;</span>
<span class="lineNum">    3579 </span>            :           break;
<span class="lineNum">    3580 </span>            : 
<span class="lineNum">    3581 </span><span class="lineCov">     398251 :         case CPP_COLON:</span>
<span class="lineNum">    3582 </span><span class="lineCov">     398251 :           if (!brace_depth &amp;&amp; !paren_depth &amp;&amp; !square_depth &amp;&amp; condop_depth &gt; 0)</span>
<span class="lineNum">    3583 </span><span class="lineCov">     292129 :             condop_depth--;</span>
<span class="lineNum">    3584 </span>            :           break;
<span class="lineNum">    3585 </span>            : 
<span class="lineNum">    3586 </span>            :         default:
<span class="lineNum">    3587 </span>            :           break;
<span class="lineNum">    3588 </span>            :         }
<span class="lineNum">    3589 </span>            : 
<span class="lineNum">    3590 </span>            :       /* Consume the token.  */
<span class="lineNum">    3591 </span><span class="lineCov">  173764207 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    3592 </span><span class="lineCov">  173764207 :     }</span>
<span class="lineNum">    3593 </span>            : }
<span class="lineNum">    3594 </span>            : 
<span class="lineNum">    3595 </span>            : /* Consume tokens up to, and including, the next non-nested closing `)'.
<span class="lineNum">    3596 </span>            :    Returns 1 iff we found a closing `)'.  RECOVERING is true, if we
<span class="lineNum">    3597 </span>            :    are doing error recovery. Returns -1 if OR_COMMA is true and we
<span class="lineNum">    3598 </span>            :    found an unnested token of that type.  */
<a name="3599"><span class="lineNum">    3599 </span>            : </a>
<span class="lineNum">    3600 </span>            : static int
<span class="lineNum">    3601 </span><span class="lineNoCov">          0 : cp_parser_skip_to_closing_parenthesis (cp_parser *parser,</span>
<span class="lineNum">    3602 </span>            :                                        bool recovering,
<span class="lineNum">    3603 </span>            :                                        bool or_comma,
<span class="lineNum">    3604 </span>            :                                        bool consume_paren)
<span class="lineNum">    3605 </span>            : {
<span class="lineNum">    3606 </span><span class="lineNoCov">          0 :   cpp_ttype ttype = or_comma ? CPP_COMMA : CPP_EOF;</span>
<span class="lineNum">    3607 </span><span class="lineNoCov">          0 :   return cp_parser_skip_to_closing_parenthesis_1 (parser, recovering,</span>
<span class="lineNum">    3608 </span><span class="lineNoCov">          0 :                                                   ttype, consume_paren);</span>
<span class="lineNum">    3609 </span>            : }
<span class="lineNum">    3610 </span>            : 
<span class="lineNum">    3611 </span>            : /* Consume tokens until we reach the end of the current statement.
<span class="lineNum">    3612 </span>            :    Normally, that will be just before consuming a `;'.  However, if a
<span class="lineNum">    3613 </span>            :    non-nested `}' comes first, then we stop before consuming that.  */
<a name="3614"><span class="lineNum">    3614 </span>            : </a>
<span class="lineNum">    3615 </span>            : static void
<span class="lineNum">    3616 </span><span class="lineCov">       1997 : cp_parser_skip_to_end_of_statement (cp_parser* parser)</span>
<span class="lineNum">    3617 </span>            : {
<span class="lineNum">    3618 </span><span class="lineCov">       1997 :   unsigned nesting_depth = 0;</span>
<span class="lineNum">    3619 </span>            : 
<span class="lineNum">    3620 </span>            :   /* Unwind generic function template scope if necessary.  */
<span class="lineNum">    3621 </span><span class="lineCov">       1997 :   if (parser-&gt;fully_implicit_function_template_p)</span>
<span class="lineNum">    3622 </span><span class="lineCov">          1 :     abort_fully_implicit_template (parser);</span>
<span class="lineNum">    3623 </span>            : 
<span class="lineNum">    3624 </span><span class="lineCov">       5098 :   while (true)</span>
<span class="lineNum">    3625 </span>            :     {
<span class="lineNum">    3626 </span><span class="lineCov">      10196 :       cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">    3627 </span>            : 
<span class="lineNum">    3628 </span><span class="lineCov">       5098 :       switch (token-&gt;type)</span>
<span class="lineNum">    3629 </span>            :         {
<span class="lineNum">    3630 </span>            :         case CPP_EOF:
<span class="lineNum">    3631 </span>            :         case CPP_PRAGMA_EOL:
<span class="lineNum">    3632 </span>            :           /* If we've run out of tokens, stop.  */
<span class="lineNum">    3633 </span>            :           return;
<span class="lineNum">    3634 </span>            : 
<span class="lineNum">    3635 </span><span class="lineCov">       1675 :         case CPP_SEMICOLON:</span>
<span class="lineNum">    3636 </span>            :           /* If the next token is a `;', we have reached the end of the
<span class="lineNum">    3637 </span>            :              statement.  */
<span class="lineNum">    3638 </span><span class="lineCov">       1675 :           if (!nesting_depth)</span>
<span class="lineNum">    3639 </span>            :             return;
<span class="lineNum">    3640 </span>            :           break;
<span class="lineNum">    3641 </span>            : 
<span class="lineNum">    3642 </span><span class="lineCov">        226 :         case CPP_CLOSE_BRACE:</span>
<span class="lineNum">    3643 </span>            :           /* If this is a non-nested '}', stop before consuming it.
<span class="lineNum">    3644 </span>            :              That way, when confronted with something like:
<span class="lineNum">    3645 </span>            : 
<span class="lineNum">    3646 </span>            :                { 3 + }
<span class="lineNum">    3647 </span>            : 
<span class="lineNum">    3648 </span>            :              we stop before consuming the closing '}', even though we
<span class="lineNum">    3649 </span>            :              have not yet reached a `;'.  */
<span class="lineNum">    3650 </span><span class="lineCov">        226 :           if (nesting_depth == 0)</span>
<span class="lineNum">    3651 </span>            :             return;
<span class="lineNum">    3652 </span>            : 
<span class="lineNum">    3653 </span>            :           /* If it is the closing '}' for a block that we have
<span class="lineNum">    3654 </span>            :              scanned, stop -- but only after consuming the token.
<span class="lineNum">    3655 </span>            :              That way given:
<span class="lineNum">    3656 </span>            : 
<span class="lineNum">    3657 </span>            :                 void f g () { ... }
<span class="lineNum">    3658 </span>            :                 typedef int I;
<span class="lineNum">    3659 </span>            : 
<span class="lineNum">    3660 </span>            :              we will stop after the body of the erroneously declared
<span class="lineNum">    3661 </span>            :              function, but before consuming the following `typedef'
<span class="lineNum">    3662 </span>            :              declaration.  */
<span class="lineNum">    3663 </span><span class="lineCov">        209 :           if (--nesting_depth == 0)</span>
<span class="lineNum">    3664 </span>            :             {
<span class="lineNum">    3665 </span><span class="lineCov">        200 :               cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    3666 </span><span class="lineCov">        200 :               return;</span>
<span class="lineNum">    3667 </span>            :             }
<span class="lineNum">    3668 </span>            :           break;
<span class="lineNum">    3669 </span>            : 
<span class="lineNum">    3670 </span><span class="lineCov">        209 :         case CPP_OPEN_BRACE:</span>
<span class="lineNum">    3671 </span><span class="lineCov">        209 :           ++nesting_depth;</span>
<span class="lineNum">    3672 </span><span class="lineCov">        209 :           break;</span>
<span class="lineNum">    3673 </span>            : 
<span class="lineNum">    3674 </span>            :         default:
<span class="lineNum">    3675 </span>            :           break;
<span class="lineNum">    3676 </span>            :         }
<span class="lineNum">    3677 </span>            : 
<span class="lineNum">    3678 </span>            :       /* Consume the token.  */
<span class="lineNum">    3679 </span><span class="lineCov">       3101 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    3680 </span><span class="lineCov">       3101 :     }</span>
<span class="lineNum">    3681 </span>            : }
<span class="lineNum">    3682 </span>            : 
<span class="lineNum">    3683 </span>            : /* This function is called at the end of a statement or declaration.
<span class="lineNum">    3684 </span>            :    If the next token is a semicolon, it is consumed; otherwise, error
<span class="lineNum">    3685 </span>            :    recovery is attempted.  */
<a name="3686"><span class="lineNum">    3686 </span>            : </a>
<span class="lineNum">    3687 </span>            : static void
<span class="lineNum">    3688 </span><span class="lineCov">    4980504 : cp_parser_consume_semicolon_at_end_of_statement (cp_parser *parser)</span>
<span class="lineNum">    3689 </span>            : {
<span class="lineNum">    3690 </span>            :   /* Look for the trailing `;'.  */
<span class="lineNum">    3691 </span><span class="lineCov">    4980504 :   if (!cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON))</span>
<span class="lineNum">    3692 </span>            :     {
<span class="lineNum">    3693 </span>            :       /* If there is additional (erroneous) input, skip to the end of
<span class="lineNum">    3694 </span>            :          the statement.  */
<span class="lineNum">    3695 </span><span class="lineCov">         81 :       cp_parser_skip_to_end_of_statement (parser);</span>
<span class="lineNum">    3696 </span>            :       /* If the next token is now a `;', consume it.  */
<span class="lineNum">    3697 </span><span class="lineCov">         81 :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_SEMICOLON))</span>
<span class="lineNum">    3698 </span><span class="lineCov">         68 :         cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    3699 </span>            :     }
<span class="lineNum">    3700 </span><span class="lineCov">    4980504 : }</span>
<span class="lineNum">    3701 </span>            : 
<span class="lineNum">    3702 </span>            : /* Skip tokens until we have consumed an entire block, or until we
<span class="lineNum">    3703 </span>            :    have consumed a non-nested `;'.  */
<a name="3704"><span class="lineNum">    3704 </span>            : </a>
<span class="lineNum">    3705 </span>            : static void
<span class="lineNum">    3706 </span><span class="lineCov">       9208 : cp_parser_skip_to_end_of_block_or_statement (cp_parser* parser)</span>
<span class="lineNum">    3707 </span>            : {
<span class="lineNum">    3708 </span><span class="lineCov">       9208 :   int nesting_depth = 0;</span>
<span class="lineNum">    3709 </span>            : 
<span class="lineNum">    3710 </span>            :   /* Unwind generic function template scope if necessary.  */
<span class="lineNum">    3711 </span><span class="lineCov">       9208 :   if (parser-&gt;fully_implicit_function_template_p)</span>
<span class="lineNum">    3712 </span><span class="lineCov">          4 :     abort_fully_implicit_template (parser);</span>
<span class="lineNum">    3713 </span>            : 
<span class="lineNum">    3714 </span><span class="lineCov">      22594 :   while (nesting_depth &gt;= 0)</span>
<span class="lineNum">    3715 </span>            :     {
<span class="lineNum">    3716 </span><span class="lineCov">      27032 :       cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">    3717 </span>            : 
<span class="lineNum">    3718 </span><span class="lineCov">      13516 :       switch (token-&gt;type)</span>
<span class="lineNum">    3719 </span>            :         {
<span class="lineNum">    3720 </span>            :         case CPP_EOF:
<span class="lineNum">    3721 </span>            :         case CPP_PRAGMA_EOL:
<span class="lineNum">    3722 </span>            :           /* If we've run out of tokens, stop.  */
<span class="lineNum">    3723 </span>            :           return;
<span class="lineNum">    3724 </span>            : 
<span class="lineNum">    3725 </span><span class="lineCov">       8614 :         case CPP_SEMICOLON:</span>
<span class="lineNum">    3726 </span>            :           /* Stop if this is an unnested ';'. */
<span class="lineNum">    3727 </span><span class="lineCov">       8614 :           if (!nesting_depth)</span>
<span class="lineNum">    3728 </span><span class="lineCov">       8376 :             nesting_depth = -1;</span>
<span class="lineNum">    3729 </span>            :           break;
<span class="lineNum">    3730 </span>            : 
<span class="lineNum">    3731 </span><span class="lineCov">        818 :         case CPP_CLOSE_BRACE:</span>
<span class="lineNum">    3732 </span>            :           /* Stop if this is an unnested '}', or closes the outermost
<span class="lineNum">    3733 </span>            :              nesting level.  */
<span class="lineNum">    3734 </span><span class="lineCov">        818 :           nesting_depth--;</span>
<span class="lineNum">    3735 </span><span class="lineCov">        818 :           if (nesting_depth &lt; 0)</span>
<span class="lineNum">    3736 </span>            :             return;
<span class="lineNum">    3737 </span><span class="lineCov">        739 :           if (!nesting_depth)</span>
<span class="lineNum">    3738 </span><span class="lineCov">        702 :             nesting_depth = -1;</span>
<span class="lineNum">    3739 </span>            :           break;
<span class="lineNum">    3740 </span>            : 
<span class="lineNum">    3741 </span><span class="lineCov">        745 :         case CPP_OPEN_BRACE:</span>
<span class="lineNum">    3742 </span>            :           /* Nest. */
<span class="lineNum">    3743 </span><span class="lineCov">        745 :           nesting_depth++;</span>
<span class="lineNum">    3744 </span><span class="lineCov">        745 :           break;</span>
<span class="lineNum">    3745 </span>            : 
<span class="lineNum">    3746 </span>            :         default:
<span class="lineNum">    3747 </span>            :           break;
<span class="lineNum">    3748 </span>            :         }
<span class="lineNum">    3749 </span>            : 
<span class="lineNum">    3750 </span>            :       /* Consume the token.  */
<span class="lineNum">    3751 </span><span class="lineCov">      13386 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    3752 </span>            :     }
<span class="lineNum">    3753 </span>            : }
<span class="lineNum">    3754 </span>            : 
<span class="lineNum">    3755 </span>            : /* Skip tokens until a non-nested closing curly brace is the next
<span class="lineNum">    3756 </span>            :    token, or there are no more tokens. Return true in the first case,
<span class="lineNum">    3757 </span>            :    false otherwise.  */
<a name="3758"><span class="lineNum">    3758 </span>            : </a>
<span class="lineNum">    3759 </span>            : static bool
<span class="lineNum">    3760 </span><span class="lineCov">         62 : cp_parser_skip_to_closing_brace (cp_parser *parser)</span>
<span class="lineNum">    3761 </span>            : {
<span class="lineNum">    3762 </span><span class="lineCov">         62 :   unsigned nesting_depth = 0;</span>
<span class="lineNum">    3763 </span>            : 
<span class="lineNum">    3764 </span><span class="lineCov">        219 :   while (true)</span>
<span class="lineNum">    3765 </span>            :     {
<span class="lineNum">    3766 </span><span class="lineCov">        438 :       cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">    3767 </span>            : 
<span class="lineNum">    3768 </span><span class="lineCov">        219 :       switch (token-&gt;type)</span>
<span class="lineNum">    3769 </span>            :         {
<span class="lineNum">    3770 </span>            :         case CPP_EOF:
<span class="lineNum">    3771 </span>            :         case CPP_PRAGMA_EOL:
<span class="lineNum">    3772 </span>            :           /* If we've run out of tokens, stop.  */
<span class="lineNum">    3773 </span>            :           return false;
<span class="lineNum">    3774 </span>            : 
<span class="lineNum">    3775 </span><span class="lineCov">         59 :         case CPP_CLOSE_BRACE:</span>
<span class="lineNum">    3776 </span>            :           /* If the next token is a non-nested `}', then we have reached
<span class="lineNum">    3777 </span>            :              the end of the current block.  */
<span class="lineNum">    3778 </span><span class="lineCov">         59 :           if (nesting_depth-- == 0)</span>
<span class="lineNum">    3779 </span>            :             return true;
<span class="lineNum">    3780 </span>            :           break;
<span class="lineNum">    3781 </span>            : 
<span class="lineNum">    3782 </span><span class="lineCov">          3 :         case CPP_OPEN_BRACE:</span>
<span class="lineNum">    3783 </span>            :           /* If it the next token is a `{', then we are entering a new
<span class="lineNum">    3784 </span>            :              block.  Consume the entire block.  */
<span class="lineNum">    3785 </span><span class="lineCov">          3 :           ++nesting_depth;</span>
<span class="lineNum">    3786 </span><span class="lineCov">          3 :           break;</span>
<span class="lineNum">    3787 </span>            : 
<span class="lineNum">    3788 </span>            :         default:
<span class="lineNum">    3789 </span>            :           break;
<span class="lineNum">    3790 </span>            :         }
<span class="lineNum">    3791 </span>            : 
<span class="lineNum">    3792 </span>            :       /* Consume the token.  */
<span class="lineNum">    3793 </span><span class="lineCov">        157 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    3794 </span><span class="lineCov">        157 :     }</span>
<span class="lineNum">    3795 </span>            : }
<span class="lineNum">    3796 </span>            : 
<span class="lineNum">    3797 </span>            : /* Consume tokens until we reach the end of the pragma.  The PRAGMA_TOK
<span class="lineNum">    3798 </span>            :    parameter is the PRAGMA token, allowing us to purge the entire pragma
<span class="lineNum">    3799 </span>            :    sequence.  */
<a name="3800"><span class="lineNum">    3800 </span>            : </a>
<span class="lineNum">    3801 </span>            : static void
<span class="lineNum">    3802 </span><span class="lineCov">     115890 : cp_parser_skip_to_pragma_eol (cp_parser* parser, cp_token *pragma_tok)</span>
<span class="lineNum">    3803 </span>            : {
<span class="lineNum">    3804 </span><span class="lineCov">     115890 :   cp_token *token;</span>
<span class="lineNum">    3805 </span>            : 
<span class="lineNum">    3806 </span><span class="lineCov">     115890 :   parser-&gt;lexer-&gt;in_pragma = false;</span>
<span class="lineNum">    3807 </span>            : 
<span class="lineNum">    3808 </span><span class="lineCov">     117834 :   do</span>
<span class="lineNum">    3809 </span><span class="lineCov">     117834 :     token = cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    3810 </span><span class="lineCov">     117834 :   while (token-&gt;type != CPP_PRAGMA_EOL &amp;&amp; token-&gt;type != CPP_EOF);</span>
<span class="lineNum">    3811 </span>            : 
<span class="lineNum">    3812 </span>            :   /* Ensure that the pragma is not parsed again.  */
<span class="lineNum">    3813 </span><span class="lineCov">     115890 :   cp_lexer_purge_tokens_after (parser-&gt;lexer, pragma_tok);</span>
<span class="lineNum">    3814 </span><span class="lineCov">     115890 : }</span>
<span class="lineNum">    3815 </span>            : 
<span class="lineNum">    3816 </span>            : /* Require pragma end of line, resyncing with it as necessary.  The
<span class="lineNum">    3817 </span>            :    arguments are as for cp_parser_skip_to_pragma_eol.  */
<a name="3818"><span class="lineNum">    3818 </span>            : </a>
<span class="lineNum">    3819 </span>            : static void
<span class="lineNum">    3820 </span><span class="lineCov">       4737 : cp_parser_require_pragma_eol (cp_parser *parser, cp_token *pragma_tok)</span>
<span class="lineNum">    3821 </span>            : {
<span class="lineNum">    3822 </span><span class="lineCov">       4737 :   parser-&gt;lexer-&gt;in_pragma = false;</span>
<span class="lineNum">    3823 </span><span class="lineCov">       4737 :   if (!cp_parser_require (parser, CPP_PRAGMA_EOL, RT_PRAGMA_EOL))</span>
<span class="lineNum">    3824 </span><span class="lineCov">         36 :     cp_parser_skip_to_pragma_eol (parser, pragma_tok);</span>
<span class="lineNum">    3825 </span><span class="lineCov">       4737 : }</span>
<span class="lineNum">    3826 </span>            : 
<span class="lineNum">    3827 </span>            : /* This is a simple wrapper around make_typename_type. When the id is
<span class="lineNum">    3828 </span>            :    an unresolved identifier node, we can provide a superior diagnostic
<span class="lineNum">    3829 </span>            :    using cp_parser_diagnose_invalid_type_name.  */
<a name="3830"><span class="lineNum">    3830 </span>            : </a>
<span class="lineNum">    3831 </span>            : static tree
<span class="lineNum">    3832 </span><span class="lineCov">    1439033 : cp_parser_make_typename_type (cp_parser *parser, tree id,</span>
<span class="lineNum">    3833 </span>            :                               location_t id_location)
<span class="lineNum">    3834 </span>            : {
<span class="lineNum">    3835 </span><span class="lineCov">    1439033 :   tree result;</span>
<span class="lineNum">    3836 </span><span class="lineCov">    1439033 :   if (identifier_p (id))</span>
<span class="lineNum">    3837 </span>            :     {
<span class="lineNum">    3838 </span><span class="lineCov">    1439033 :       result = make_typename_type (parser-&gt;scope, id, typename_type,</span>
<span class="lineNum">    3839 </span>            :                                    /*complain=*/tf_none);
<span class="lineNum">    3840 </span><span class="lineCov">    1439033 :       if (result == error_mark_node)</span>
<span class="lineNum">    3841 </span><span class="lineCov">         18 :         cp_parser_diagnose_invalid_type_name (parser, id, id_location);</span>
<span class="lineNum">    3842 </span><span class="lineCov">    1439033 :       return result;</span>
<span class="lineNum">    3843 </span>            :     }
<span class="lineNum">    3844 </span><span class="lineNoCov">          0 :   return make_typename_type (parser-&gt;scope, id, typename_type, tf_error);</span>
<span class="lineNum">    3845 </span>            : }
<span class="lineNum">    3846 </span>            : 
<span class="lineNum">    3847 </span>            : /* This is a wrapper around the
<span class="lineNum">    3848 </span>            :    make_{pointer,ptrmem,reference}_declarator functions that decides
<span class="lineNum">    3849 </span>            :    which one to call based on the CODE and CLASS_TYPE arguments. The
<span class="lineNum">    3850 </span>            :    CODE argument should be one of the values returned by
<span class="lineNum">    3851 </span>            :    cp_parser_ptr_operator.  ATTRIBUTES represent the attributes that
<span class="lineNum">    3852 </span>            :    appertain to the pointer or reference.  */
<a name="3853"><span class="lineNum">    3853 </span>            : </a>
<span class="lineNum">    3854 </span>            : static cp_declarator *
<span class="lineNum">    3855 </span><span class="lineCov">   10706139 : cp_parser_make_indirect_declarator (enum tree_code code, tree class_type,</span>
<span class="lineNum">    3856 </span>            :                                     cp_cv_quals cv_qualifiers,
<span class="lineNum">    3857 </span>            :                                     cp_declarator *target,
<span class="lineNum">    3858 </span>            :                                     tree attributes)
<span class="lineNum">    3859 </span>            : {
<span class="lineNum">    3860 </span><span class="lineCov">   10706139 :   if (code == ERROR_MARK || target == cp_error_declarator)</span>
<span class="lineNum">    3861 </span><span class="lineCov">         29 :     return cp_error_declarator;</span>
<span class="lineNum">    3862 </span>            : 
<span class="lineNum">    3863 </span><span class="lineCov">   10706110 :   if (code == INDIRECT_REF)</span>
<span class="lineNum">    3864 </span><span class="lineCov">    6023246 :     if (class_type == NULL_TREE)</span>
<span class="lineNum">    3865 </span><span class="lineCov">    5921525 :       return make_pointer_declarator (cv_qualifiers, target, attributes);</span>
<span class="lineNum">    3866 </span>            :     else
<span class="lineNum">    3867 </span><span class="lineCov">     101721 :       return make_ptrmem_declarator (cv_qualifiers, class_type,</span>
<span class="lineNum">    3868 </span><span class="lineCov">     101721 :                                      target, attributes);</span>
<span class="lineNum">    3869 </span><span class="lineCov">    4682864 :   else if (code == ADDR_EXPR &amp;&amp; class_type == NULL_TREE)</span>
<span class="lineNum">    3870 </span><span class="lineCov">    4128545 :     return make_reference_declarator (cv_qualifiers, target,</span>
<span class="lineNum">    3871 </span><span class="lineCov">    4128545 :                                       false, attributes);</span>
<span class="lineNum">    3872 </span><span class="lineCov">     554319 :   else if (code == NON_LVALUE_EXPR &amp;&amp; class_type == NULL_TREE)</span>
<span class="lineNum">    3873 </span><span class="lineCov">     554319 :     return make_reference_declarator (cv_qualifiers, target,</span>
<span class="lineNum">    3874 </span><span class="lineCov">     554319 :                                       true, attributes);</span>
<span class="lineNum">    3875 </span><span class="lineNoCov">          0 :   gcc_unreachable ();</span>
<span class="lineNum">    3876 </span>            : }
<span class="lineNum">    3877 </span>            : 
<span class="lineNum">    3878 </span>            : /* Create a new C++ parser.  */
<a name="3879"><span class="lineNum">    3879 </span>            : </a>
<span class="lineNum">    3880 </span>            : static cp_parser *
<span class="lineNum">    3881 </span><span class="lineCov">      56260 : cp_parser_new (void)</span>
<span class="lineNum">    3882 </span>            : {
<span class="lineNum">    3883 </span><span class="lineCov">      56260 :   cp_parser *parser;</span>
<span class="lineNum">    3884 </span><span class="lineCov">      56260 :   cp_lexer *lexer;</span>
<span class="lineNum">    3885 </span><span class="lineCov">      56260 :   unsigned i;</span>
<span class="lineNum">    3886 </span>            : 
<span class="lineNum">    3887 </span>            :   /* cp_lexer_new_main is called before doing GC allocation because
<span class="lineNum">    3888 </span>            :      cp_lexer_new_main might load a PCH file.  */
<span class="lineNum">    3889 </span><span class="lineCov">      56260 :   lexer = cp_lexer_new_main ();</span>
<span class="lineNum">    3890 </span>            : 
<span class="lineNum">    3891 </span>            :   /* Initialize the binops_by_token so that we can get the tree
<span class="lineNum">    3892 </span>            :      directly from the token.  */
<span class="lineNum">    3893 </span><span class="lineCov">    1181080 :   for (i = 0; i &lt; sizeof (binops) / sizeof (binops[0]); i++)</span>
<span class="lineNum">    3894 </span><span class="lineCov">    1124820 :     binops_by_token[binops[i].token_type] = binops[i];</span>
<span class="lineNum">    3895 </span>            : 
<span class="lineNum">    3896 </span><span class="lineCov">      56241 :   parser = ggc_cleared_alloc&lt;cp_parser&gt; ();</span>
<span class="lineNum">    3897 </span><span class="lineCov">      56241 :   parser-&gt;lexer = lexer;</span>
<span class="lineNum">    3898 </span><span class="lineCov">      56241 :   parser-&gt;context = cp_parser_context_new (NULL);</span>
<span class="lineNum">    3899 </span>            : 
<span class="lineNum">    3900 </span>            :   /* For now, we always accept GNU extensions.  */
<span class="lineNum">    3901 </span><span class="lineCov">      56241 :   parser-&gt;allow_gnu_extensions_p = 1;</span>
<span class="lineNum">    3902 </span>            : 
<span class="lineNum">    3903 </span>            :   /* The `&gt;' token is a greater-than operator, not the end of a
<span class="lineNum">    3904 </span>            :      template-id.  */
<span class="lineNum">    3905 </span><span class="lineCov">      56241 :   parser-&gt;greater_than_is_operator_p = true;</span>
<span class="lineNum">    3906 </span>            : 
<span class="lineNum">    3907 </span><span class="lineCov">      56241 :   parser-&gt;default_arg_ok_p = true;</span>
<span class="lineNum">    3908 </span>            : 
<span class="lineNum">    3909 </span>            :   /* We are not parsing a constant-expression.  */
<span class="lineNum">    3910 </span><span class="lineCov">      56241 :   parser-&gt;integral_constant_expression_p = false;</span>
<span class="lineNum">    3911 </span><span class="lineCov">      56241 :   parser-&gt;allow_non_integral_constant_expression_p = false;</span>
<span class="lineNum">    3912 </span><span class="lineCov">      56241 :   parser-&gt;non_integral_constant_expression_p = false;</span>
<span class="lineNum">    3913 </span>            : 
<span class="lineNum">    3914 </span>            :   /* Local variable names are not forbidden.  */
<span class="lineNum">    3915 </span><span class="lineCov">      56241 :   parser-&gt;local_variables_forbidden_p = false;</span>
<span class="lineNum">    3916 </span>            : 
<span class="lineNum">    3917 </span>            :   /* We are not processing an `extern &quot;C&quot;' declaration.  */
<span class="lineNum">    3918 </span><span class="lineCov">      56241 :   parser-&gt;in_unbraced_linkage_specification_p = false;</span>
<span class="lineNum">    3919 </span>            : 
<span class="lineNum">    3920 </span>            :   /* We are not processing a declarator.  */
<span class="lineNum">    3921 </span><span class="lineCov">      56241 :   parser-&gt;in_declarator_p = false;</span>
<span class="lineNum">    3922 </span>            : 
<span class="lineNum">    3923 </span>            :   /* We are not processing a template-argument-list.  */
<span class="lineNum">    3924 </span><span class="lineCov">      56241 :   parser-&gt;in_template_argument_list_p = false;</span>
<span class="lineNum">    3925 </span>            : 
<span class="lineNum">    3926 </span>            :   /* We are not in an iteration statement.  */
<span class="lineNum">    3927 </span><span class="lineCov">      56241 :   parser-&gt;in_statement = 0;</span>
<span class="lineNum">    3928 </span>            : 
<span class="lineNum">    3929 </span>            :   /* We are not in a switch statement.  */
<span class="lineNum">    3930 </span><span class="lineCov">      56241 :   parser-&gt;in_switch_statement_p = false;</span>
<span class="lineNum">    3931 </span>            : 
<span class="lineNum">    3932 </span>            :   /* We are not parsing a type-id inside an expression.  */
<span class="lineNum">    3933 </span><span class="lineCov">      56241 :   parser-&gt;in_type_id_in_expr_p = false;</span>
<span class="lineNum">    3934 </span>            : 
<span class="lineNum">    3935 </span>            :   /* Declarations aren't implicitly extern &quot;C&quot;.  */
<span class="lineNum">    3936 </span><span class="lineCov">      56241 :   parser-&gt;implicit_extern_c = false;</span>
<span class="lineNum">    3937 </span>            : 
<span class="lineNum">    3938 </span>            :   /* String literals should be translated to the execution character set.  */
<span class="lineNum">    3939 </span><span class="lineCov">      56241 :   parser-&gt;translate_strings_p = true;</span>
<span class="lineNum">    3940 </span>            : 
<span class="lineNum">    3941 </span>            :   /* We are not parsing a function body.  */
<span class="lineNum">    3942 </span><span class="lineCov">      56241 :   parser-&gt;in_function_body = false;</span>
<span class="lineNum">    3943 </span>            : 
<span class="lineNum">    3944 </span>            :   /* We can correct until told otherwise.  */
<span class="lineNum">    3945 </span><span class="lineCov">      56241 :   parser-&gt;colon_corrects_to_scope_p = true;</span>
<span class="lineNum">    3946 </span>            : 
<span class="lineNum">    3947 </span>            :   /* The unparsed function queue is empty.  */
<span class="lineNum">    3948 </span><span class="lineCov">      56241 :   push_unparsed_function_queues (parser);</span>
<span class="lineNum">    3949 </span>            : 
<span class="lineNum">    3950 </span>            :   /* There are no classes being defined.  */
<span class="lineNum">    3951 </span><span class="lineCov">      56241 :   parser-&gt;num_classes_being_defined = 0;</span>
<span class="lineNum">    3952 </span>            : 
<span class="lineNum">    3953 </span>            :   /* No template parameters apply.  */
<span class="lineNum">    3954 </span><span class="lineCov">      56241 :   parser-&gt;num_template_parameter_lists = 0;</span>
<span class="lineNum">    3955 </span>            : 
<span class="lineNum">    3956 </span>            :   /* Special parsing data structures.  */
<span class="lineNum">    3957 </span><span class="lineCov">      56241 :   parser-&gt;omp_declare_simd = NULL;</span>
<span class="lineNum">    3958 </span><span class="lineCov">      56241 :   parser-&gt;oacc_routine = NULL;</span>
<span class="lineNum">    3959 </span>            : 
<span class="lineNum">    3960 </span>            :   /* Not declaring an implicit function template.  */
<span class="lineNum">    3961 </span><span class="lineCov">      56241 :   parser-&gt;auto_is_implicit_function_template_parm_p = false;</span>
<span class="lineNum">    3962 </span><span class="lineCov">      56241 :   parser-&gt;fully_implicit_function_template_p = false;</span>
<span class="lineNum">    3963 </span><span class="lineCov">      56241 :   parser-&gt;implicit_template_parms = 0;</span>
<span class="lineNum">    3964 </span><span class="lineCov">      56241 :   parser-&gt;implicit_template_scope = 0;</span>
<span class="lineNum">    3965 </span>            : 
<span class="lineNum">    3966 </span>            :   /* Allow constrained-type-specifiers. */
<span class="lineNum">    3967 </span><span class="lineCov">      56241 :   parser-&gt;prevent_constrained_type_specifiers = 0;</span>
<span class="lineNum">    3968 </span>            : 
<span class="lineNum">    3969 </span>            :   /* We haven't yet seen an 'extern &quot;C&quot;'.  */
<span class="lineNum">    3970 </span><span class="lineCov">      56241 :   parser-&gt;innermost_linkage_specification_location = UNKNOWN_LOCATION;</span>
<span class="lineNum">    3971 </span>            : 
<span class="lineNum">    3972 </span><span class="lineCov">      56241 :   return parser;</span>
<span class="lineNum">    3973 </span>            : }
<span class="lineNum">    3974 </span>            : 
<span class="lineNum">    3975 </span>            : /* Create a cp_lexer structure which will emit the tokens in CACHE
<span class="lineNum">    3976 </span>            :    and push it onto the parser's lexer stack.  This is used for delayed
<span class="lineNum">    3977 </span>            :    parsing of in-class method bodies and default arguments, and should
<a name="3978"><span class="lineNum">    3978 </span>            :    not be confused with tentative parsing.  */</a>
<span class="lineNum">    3979 </span>            : static void
<span class="lineNum">    3980 </span><span class="lineCov">    3315688 : cp_parser_push_lexer_for_tokens (cp_parser *parser, cp_token_cache *cache)</span>
<span class="lineNum">    3981 </span>            : {
<span class="lineNum">    3982 </span><span class="lineCov">    3315688 :   cp_lexer *lexer = cp_lexer_new_from_tokens (cache);</span>
<span class="lineNum">    3983 </span><span class="lineCov">    3315688 :   lexer-&gt;next = parser-&gt;lexer;</span>
<span class="lineNum">    3984 </span><span class="lineCov">    3315688 :   parser-&gt;lexer = lexer;</span>
<span class="lineNum">    3985 </span>            : 
<span class="lineNum">    3986 </span>            :   /* Move the current source position to that of the first token in the
<span class="lineNum">    3987 </span>            :      new lexer.  */
<span class="lineNum">    3988 </span><span class="lineCov">    3315688 :   cp_lexer_set_source_position_from_token (lexer-&gt;next_token);</span>
<span class="lineNum">    3989 </span><span class="lineCov">    3315688 : }</span>
<span class="lineNum">    3990 </span>            : 
<span class="lineNum">    3991 </span>            : /* Pop the top lexer off the parser stack.  This is never used for the
<a name="3992"><span class="lineNum">    3992 </span>            :    &quot;main&quot; lexer, only for those pushed by cp_parser_push_lexer_for_tokens.  */</a>
<span class="lineNum">    3993 </span>            : static void
<span class="lineNum">    3994 </span><span class="lineCov">    3315688 : cp_parser_pop_lexer (cp_parser *parser)</span>
<span class="lineNum">    3995 </span>            : {
<span class="lineNum">    3996 </span><span class="lineCov">    3315688 :   cp_lexer *lexer = parser-&gt;lexer;</span>
<span class="lineNum">    3997 </span><span class="lineCov">    3315688 :   parser-&gt;lexer = lexer-&gt;next;</span>
<span class="lineNum">    3998 </span><span class="lineCov">    3315688 :   cp_lexer_destroy (lexer);</span>
<span class="lineNum">    3999 </span>            : 
<span class="lineNum">    4000 </span>            :   /* Put the current source position back where it was before this
<span class="lineNum">    4001 </span>            :      lexer was pushed.  */
<span class="lineNum">    4002 </span><span class="lineCov">    3315688 :   cp_lexer_set_source_position_from_token (parser-&gt;lexer-&gt;next_token);</span>
<span class="lineNum">    4003 </span><span class="lineCov">    3315688 : }</span>
<span class="lineNum">    4004 </span>            : 
<span class="lineNum">    4005 </span>            : /* Lexical conventions [gram.lex]  */
<span class="lineNum">    4006 </span>            : 
<span class="lineNum">    4007 </span>            : /* Parse an identifier.  Returns an IDENTIFIER_NODE representing the
<span class="lineNum">    4008 </span>            :    identifier.  */
<a name="4009"><span class="lineNum">    4009 </span>            : </a>
<span class="lineNum">    4010 </span>            : static cp_expr
<span class="lineNum">    4011 </span><span class="lineCov">  268554483 : cp_parser_identifier (cp_parser* parser)</span>
<span class="lineNum">    4012 </span>            : {
<span class="lineNum">    4013 </span><span class="lineCov">  268554483 :   cp_token *token;</span>
<span class="lineNum">    4014 </span>            : 
<span class="lineNum">    4015 </span>            :   /* Look for the identifier.  */
<span class="lineNum">    4016 </span><span class="lineCov">  268554483 :   token = cp_parser_require (parser, CPP_NAME, RT_NAME);</span>
<span class="lineNum">    4017 </span>            :   /* Return the value.  */
<span class="lineNum">    4018 </span><span class="lineCov">  268554483 :   if (token)</span>
<span class="lineNum">    4019 </span><span class="lineCov">  226208589 :     return cp_expr (token-&gt;u.value, token-&gt;location);</span>
<span class="lineNum">    4020 </span>            :   else
<span class="lineNum">    4021 </span><span class="lineCov">   42345894 :     return error_mark_node;</span>
<span class="lineNum">    4022 </span>            : }
<span class="lineNum">    4023 </span>            : 
<span class="lineNum">    4024 </span>            : /* Parse a sequence of adjacent string constants.  Returns a
<span class="lineNum">    4025 </span>            :    TREE_STRING representing the combined, nul-terminated string
<span class="lineNum">    4026 </span>            :    constant.  If TRANSLATE is true, translate the string to the
<span class="lineNum">    4027 </span>            :    execution character set.  If WIDE_OK is true, a wide string is
<span class="lineNum">    4028 </span>            :    invalid here.
<span class="lineNum">    4029 </span>            : 
<span class="lineNum">    4030 </span>            :    C++98 [lex.string] says that if a narrow string literal token is
<span class="lineNum">    4031 </span>            :    adjacent to a wide string literal token, the behavior is undefined.
<span class="lineNum">    4032 </span>            :    However, C99 6.4.5p4 says that this results in a wide string literal.
<span class="lineNum">    4033 </span>            :    We follow C99 here, for consistency with the C front end.
<span class="lineNum">    4034 </span>            : 
<span class="lineNum">    4035 </span>            :    This code is largely lifted from lex_string() in c-lex.c.
<span class="lineNum">    4036 </span>            : 
<a name="4037"><span class="lineNum">    4037 </span>            :    FUTURE: ObjC++ will need to handle @-strings here.  */</a>
<span class="lineNum">    4038 </span>            : static cp_expr
<span class="lineNum">    4039 </span><span class="lineCov">    1151269 : cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok,</span>
<span class="lineNum">    4040 </span>            :                           bool lookup_udlit = true)
<span class="lineNum">    4041 </span>            : {
<span class="lineNum">    4042 </span><span class="lineCov">    1151269 :   tree value;</span>
<span class="lineNum">    4043 </span><span class="lineCov">    1151269 :   size_t count;</span>
<span class="lineNum">    4044 </span><span class="lineCov">    1151269 :   struct obstack str_ob;</span>
<span class="lineNum">    4045 </span><span class="lineCov">    1151269 :   cpp_string str, istr, *strs;</span>
<span class="lineNum">    4046 </span><span class="lineCov">    1151269 :   cp_token *tok;</span>
<span class="lineNum">    4047 </span><span class="lineCov">    1151269 :   enum cpp_ttype type, curr_type;</span>
<span class="lineNum">    4048 </span><span class="lineCov">    1151269 :   int have_suffix_p = 0;</span>
<span class="lineNum">    4049 </span><span class="lineCov">    1151269 :   tree string_tree;</span>
<span class="lineNum">    4050 </span><span class="lineCov">    1151269 :   tree suffix_id = NULL_TREE;</span>
<span class="lineNum">    4051 </span><span class="lineCov">    1151269 :   bool curr_tok_is_userdef_p = false;</span>
<span class="lineNum">    4052 </span>            : 
<span class="lineNum">    4053 </span><span class="lineCov">    2302538 :   tok = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">    4054 </span><span class="lineCov">    1151269 :   if (!cp_parser_is_string_literal (tok))</span>
<span class="lineNum">    4055 </span>            :     {
<span class="lineNum">    4056 </span><span class="lineCov">         53 :       cp_parser_error (parser, &quot;expected string-literal&quot;);</span>
<span class="lineNum">    4057 </span><span class="lineCov">         53 :       return error_mark_node;</span>
<span class="lineNum">    4058 </span>            :     }
<span class="lineNum">    4059 </span>            : 
<span class="lineNum">    4060 </span><span class="lineCov">    1151216 :   location_t loc = tok-&gt;location;</span>
<span class="lineNum">    4061 </span>            : 
<span class="lineNum">    4062 </span><span class="lineCov">    1151216 :   if (cpp_userdef_string_p (tok-&gt;type))</span>
<span class="lineNum">    4063 </span>            :     {
<span class="lineNum">    4064 </span><span class="lineCov">      25364 :       string_tree = USERDEF_LITERAL_VALUE (tok-&gt;u.value);</span>
<span class="lineNum">    4065 </span><span class="lineCov">      25364 :       curr_type = cpp_userdef_string_remove_type (tok-&gt;type);</span>
<span class="lineNum">    4066 </span><span class="lineCov">      25364 :       curr_tok_is_userdef_p = true;</span>
<span class="lineNum">    4067 </span>            :     }
<span class="lineNum">    4068 </span>            :   else
<span class="lineNum">    4069 </span>            :     {
<span class="lineNum">    4070 </span><span class="lineCov">    1125852 :       string_tree = tok-&gt;u.value;</span>
<span class="lineNum">    4071 </span><span class="lineCov">    1125852 :       curr_type = tok-&gt;type;</span>
<span class="lineNum">    4072 </span>            :     }
<span class="lineNum">    4073 </span><span class="lineCov">    1151216 :   type = curr_type;</span>
<span class="lineNum">    4074 </span>            : 
<span class="lineNum">    4075 </span>            :   /* Try to avoid the overhead of creating and destroying an obstack
<span class="lineNum">    4076 </span>            :      for the common case of just one string.  */
<span class="lineNum">    4077 </span><span class="lineCov">    2302432 :   if (!cp_parser_is_string_literal</span>
<span class="lineNum">    4078 </span><span class="lineCov">    1151216 :       (cp_lexer_peek_nth_token (parser-&gt;lexer, 2)))</span>
<span class="lineNum">    4079 </span>            :     {
<span class="lineNum">    4080 </span><span class="lineCov">    1071237 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    4081 </span>            : 
<span class="lineNum">    4082 </span><span class="lineCov">    1071237 :       str.text = (const unsigned char *)TREE_STRING_POINTER (string_tree);</span>
<span class="lineNum">    4083 </span><span class="lineCov">    1071237 :       str.len = TREE_STRING_LENGTH (string_tree);</span>
<span class="lineNum">    4084 </span><span class="lineCov">    1071237 :       count = 1;</span>
<span class="lineNum">    4085 </span>            : 
<span class="lineNum">    4086 </span><span class="lineCov">    1071237 :       if (curr_tok_is_userdef_p)</span>
<span class="lineNum">    4087 </span>            :         {
<span class="lineNum">    4088 </span><span class="lineCov">      25350 :           suffix_id = USERDEF_LITERAL_SUFFIX_ID (tok-&gt;u.value);</span>
<span class="lineNum">    4089 </span><span class="lineCov">      25350 :           have_suffix_p = 1;</span>
<span class="lineNum">    4090 </span><span class="lineCov">      25350 :           curr_type = cpp_userdef_string_remove_type (tok-&gt;type);</span>
<span class="lineNum">    4091 </span>            :         }
<span class="lineNum">    4092 </span>            :       else
<span class="lineNum">    4093 </span>            :         curr_type = tok-&gt;type;
<span class="lineNum">    4094 </span>            : 
<span class="lineNum">    4095 </span>            :       strs = &amp;str;
<span class="lineNum">    4096 </span>            :     }
<span class="lineNum">    4097 </span>            :   else
<span class="lineNum">    4098 </span>            :     {
<span class="lineNum">    4099 </span><span class="lineCov">      79979 :       location_t last_tok_loc = tok-&gt;location;</span>
<span class="lineNum">    4100 </span><span class="lineCov">      79979 :       gcc_obstack_init (&amp;str_ob);</span>
<span class="lineNum">    4101 </span><span class="lineCov">      79979 :       count = 0;</span>
<span class="lineNum">    4102 </span>            : 
<span class="lineNum">    4103 </span><span class="lineCov">     651662 :       do</span>
<span class="lineNum">    4104 </span>            :         {
<span class="lineNum">    4105 </span><span class="lineCov">     651662 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    4106 </span><span class="lineCov">     651662 :           count++;</span>
<span class="lineNum">    4107 </span><span class="lineCov">     651662 :           str.text = (const unsigned char *)TREE_STRING_POINTER (string_tree);</span>
<span class="lineNum">    4108 </span><span class="lineCov">     651662 :           str.len = TREE_STRING_LENGTH (string_tree);</span>
<span class="lineNum">    4109 </span>            : 
<span class="lineNum">    4110 </span><span class="lineCov">     651662 :           if (curr_tok_is_userdef_p)</span>
<span class="lineNum">    4111 </span>            :             {
<span class="lineNum">    4112 </span><span class="lineCov">         38 :               tree curr_suffix_id = USERDEF_LITERAL_SUFFIX_ID (tok-&gt;u.value);</span>
<span class="lineNum">    4113 </span><span class="lineCov">         38 :               if (have_suffix_p == 0)</span>
<span class="lineNum">    4114 </span>            :                 {
<span class="lineNum">    4115 </span>            :                   suffix_id = curr_suffix_id;
<span class="lineNum">    4116 </span>            :                   have_suffix_p = 1;
<span class="lineNum">    4117 </span>            :                 }
<span class="lineNum">    4118 </span><span class="lineCov">         20 :               else if (have_suffix_p == 1</span>
<span class="lineNum">    4119 </span><span class="lineCov">         10 :                        &amp;&amp; curr_suffix_id != suffix_id)</span>
<span class="lineNum">    4120 </span>            :                 {
<span class="lineNum">    4121 </span><span class="lineCov">          6 :                   error (&quot;inconsistent user-defined literal suffixes&quot;</span>
<span class="lineNum">    4122 </span>            :                          &quot; %qD and %qD in string literal&quot;,
<span class="lineNum">    4123 </span>            :                          suffix_id, curr_suffix_id);
<span class="lineNum">    4124 </span><span class="lineCov">          6 :                   have_suffix_p = -1;</span>
<span class="lineNum">    4125 </span>            :                 }
<span class="lineNum">    4126 </span><span class="lineCov">         38 :               curr_type = cpp_userdef_string_remove_type (tok-&gt;type);</span>
<span class="lineNum">    4127 </span>            :             }
<span class="lineNum">    4128 </span>            :           else
<span class="lineNum">    4129 </span><span class="lineCov">     651624 :             curr_type = tok-&gt;type;</span>
<span class="lineNum">    4130 </span>            : 
<span class="lineNum">    4131 </span><span class="lineCov">     651662 :           if (type != curr_type)</span>
<span class="lineNum">    4132 </span>            :             {
<span class="lineNum">    4133 </span><span class="lineCov">        347 :               if (type == CPP_STRING)</span>
<span class="lineNum">    4134 </span>            :                 type = curr_type;
<span class="lineNum">    4135 </span><span class="lineCov">        297 :               else if (curr_type != CPP_STRING)</span>
<span class="lineNum">    4136 </span>            :                 {
<span class="lineNum">    4137 </span><span class="lineCov">         58 :                   rich_location rich_loc (line_table, tok-&gt;location);</span>
<span class="lineNum">    4138 </span><span class="lineCov">         29 :                   rich_loc.add_range (last_tok_loc);</span>
<span class="lineNum">    4139 </span><span class="lineCov">         29 :                   error_at (&amp;rich_loc,</span>
<span class="lineNum">    4140 </span>            :                             &quot;unsupported non-standard concatenation &quot;
<span class="lineNum">    4141 </span>            :                             &quot;of string literals&quot;);
<span class="lineNum">    4142 </span>            :                 }
<span class="lineNum">    4143 </span>            :             }
<span class="lineNum">    4144 </span>            : 
<span class="lineNum">    4145 </span><span class="lineCov">     651662 :           obstack_grow (&amp;str_ob, &amp;str, sizeof (cpp_string));</span>
<span class="lineNum">    4146 </span>            : 
<span class="lineNum">    4147 </span><span class="lineCov">     651662 :           last_tok_loc = tok-&gt;location;</span>
<span class="lineNum">    4148 </span>            : 
<span class="lineNum">    4149 </span><span class="lineCov">    1303324 :           tok = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">    4150 </span><span class="lineCov">     651662 :           if (cpp_userdef_string_p (tok-&gt;type))</span>
<span class="lineNum">    4151 </span>            :             {
<span class="lineNum">    4152 </span><span class="lineCov">         24 :               string_tree = USERDEF_LITERAL_VALUE (tok-&gt;u.value);</span>
<span class="lineNum">    4153 </span><span class="lineCov">         24 :               curr_type = cpp_userdef_string_remove_type (tok-&gt;type);</span>
<span class="lineNum">    4154 </span><span class="lineCov">         24 :               curr_tok_is_userdef_p = true;</span>
<span class="lineNum">    4155 </span>            :             }
<span class="lineNum">    4156 </span>            :           else
<span class="lineNum">    4157 </span>            :             {
<span class="lineNum">    4158 </span><span class="lineCov">     651638 :               string_tree = tok-&gt;u.value;</span>
<span class="lineNum">    4159 </span><span class="lineCov">     651638 :               curr_type = tok-&gt;type;</span>
<span class="lineNum">    4160 </span><span class="lineCov">     651638 :               curr_tok_is_userdef_p = false;</span>
<span class="lineNum">    4161 </span>            :             }
<span class="lineNum">    4162 </span>            :         }
<span class="lineNum">    4163 </span><span class="lineCov">     651662 :       while (cp_parser_is_string_literal (tok));</span>
<span class="lineNum">    4164 </span>            : 
<span class="lineNum">    4165 </span>            :       /* A string literal built by concatenation has its caret=start at
<span class="lineNum">    4166 </span>            :          the start of the initial string, and its finish at the finish of
<span class="lineNum">    4167 </span>            :          the final string literal.  */
<span class="lineNum">    4168 </span><span class="lineCov">      79979 :       loc = make_location (loc, loc, get_finish (last_tok_loc));</span>
<span class="lineNum">    4169 </span>            : 
<span class="lineNum">    4170 </span><span class="lineCov">      79979 :       strs = (cpp_string *) obstack_finish (&amp;str_ob);</span>
<span class="lineNum">    4171 </span>            :     }
<span class="lineNum">    4172 </span>            : 
<span class="lineNum">    4173 </span><span class="lineCov">    1151216 :   if (type != CPP_STRING &amp;&amp; !wide_ok)</span>
<span class="lineNum">    4174 </span>            :     {
<span class="lineNum">    4175 </span><span class="lineNoCov">          0 :       cp_parser_error (parser, &quot;a wide string is invalid in this context&quot;);</span>
<span class="lineNum">    4176 </span><span class="lineNoCov">          0 :       type = CPP_STRING;</span>
<span class="lineNum">    4177 </span>            :     }
<span class="lineNum">    4178 </span>            : 
<span class="lineNum">    4179 </span><span class="lineCov">    2302432 :   if ((translate ? cpp_interpret_string : cpp_interpret_string_notranslate)</span>
<span class="lineNum">    4180 </span><span class="lineCov">    1151216 :       (parse_in, strs, count, &amp;istr, type))</span>
<span class="lineNum">    4181 </span>            :     {
<span class="lineNum">    4182 </span><span class="lineCov">    1151216 :       value = build_string (istr.len, (const char *)istr.text);</span>
<span class="lineNum">    4183 </span><span class="lineCov">    1151216 :       free (CONST_CAST (unsigned char *, istr.text));</span>
<span class="lineNum">    4184 </span>            : 
<span class="lineNum">    4185 </span><span class="lineCov">    1151216 :       switch (type)</span>
<span class="lineNum">    4186 </span>            :         {
<span class="lineNum">    4187 </span><span class="lineCov">    1133044 :         default:</span>
<span class="lineNum">    4188 </span><span class="lineCov">    1133044 :         case CPP_STRING:</span>
<span class="lineNum">    4189 </span><span class="lineCov">    1133044 :         case CPP_UTF8STRING:</span>
<span class="lineNum">    4190 </span><span class="lineCov">    1133044 :           TREE_TYPE (value) = char_array_type_node;</span>
<span class="lineNum">    4191 </span><span class="lineCov">    1133044 :           break;</span>
<span class="lineNum">    4192 </span><span class="lineCov">        309 :         case CPP_STRING16:</span>
<span class="lineNum">    4193 </span><span class="lineCov">        309 :           TREE_TYPE (value) = char16_array_type_node;</span>
<span class="lineNum">    4194 </span><span class="lineCov">        309 :           break;</span>
<span class="lineNum">    4195 </span><span class="lineCov">        315 :         case CPP_STRING32:</span>
<span class="lineNum">    4196 </span><span class="lineCov">        315 :           TREE_TYPE (value) = char32_array_type_node;</span>
<span class="lineNum">    4197 </span><span class="lineCov">        315 :           break;</span>
<span class="lineNum">    4198 </span><span class="lineCov">      17548 :         case CPP_WSTRING:</span>
<span class="lineNum">    4199 </span><span class="lineCov">      17548 :           TREE_TYPE (value) = wchar_array_type_node;</span>
<span class="lineNum">    4200 </span><span class="lineCov">      17548 :           break;</span>
<span class="lineNum">    4201 </span>            :         }
<span class="lineNum">    4202 </span>            : 
<span class="lineNum">    4203 </span><span class="lineCov">    1151216 :       value = fix_string_type (value);</span>
<span class="lineNum">    4204 </span>            : 
<span class="lineNum">    4205 </span><span class="lineCov">    1151216 :       if (have_suffix_p)</span>
<span class="lineNum">    4206 </span>            :         {
<span class="lineNum">    4207 </span><span class="lineCov">      25378 :           tree literal = build_userdef_literal (suffix_id, value,</span>
<span class="lineNum">    4208 </span>            :                                                 OT_NONE, NULL_TREE);
<span class="lineNum">    4209 </span><span class="lineCov">      25378 :           if (lookup_udlit)</span>
<span class="lineNum">    4210 </span><span class="lineCov">        225 :             value = cp_parser_userdef_string_literal (literal);</span>
<span class="lineNum">    4211 </span>            :           else
<span class="lineNum">    4212 </span>            :             value = literal;
<span class="lineNum">    4213 </span>            :         }
<span class="lineNum">    4214 </span>            :     }
<span class="lineNum">    4215 </span>            :   else
<span class="lineNum">    4216 </span>            :     /* cpp_interpret_string has issued an error.  */
<span class="lineNum">    4217 </span><span class="lineNoCov">          0 :     value = error_mark_node;</span>
<span class="lineNum">    4218 </span>            : 
<span class="lineNum">    4219 </span><span class="lineCov">    1151216 :   if (count &gt; 1)</span>
<span class="lineNum">    4220 </span><span class="lineCov">      79979 :     obstack_free (&amp;str_ob, 0);</span>
<span class="lineNum">    4221 </span>            : 
<span class="lineNum">    4222 </span><span class="lineCov">    1151216 :   return cp_expr (value, loc);</span>
<span class="lineNum">    4223 </span>            : }
<span class="lineNum">    4224 </span>            : 
<span class="lineNum">    4225 </span>            : /* Look up a literal operator with the name and the exact arguments.  */
<a name="4226"><span class="lineNum">    4226 </span>            : </a>
<span class="lineNum">    4227 </span>            : static tree
<span class="lineNum">    4228 </span><span class="lineCov">      95703 : lookup_literal_operator (tree name, vec&lt;tree, va_gc&gt; *args)</span>
<span class="lineNum">    4229 </span>            : {
<span class="lineNum">    4230 </span><span class="lineCov">      95703 :   tree decl;</span>
<span class="lineNum">    4231 </span><span class="lineCov">      95703 :   decl = lookup_name (name);</span>
<span class="lineNum">    4232 </span><span class="lineCov">      95703 :   if (!decl || !is_overloaded_fn (decl))</span>
<span class="lineNum">    4233 </span><span class="lineCov">      94732 :     return error_mark_node;</span>
<span class="lineNum">    4234 </span>            : 
<span class="lineNum">    4235 </span><span class="lineCov">       4035 :   for (lkp_iterator iter (decl); iter; ++iter)</span>
<span class="lineNum">    4236 </span>            :     {
<span class="lineNum">    4237 </span><span class="lineCov">       1638 :       unsigned int ix;</span>
<span class="lineNum">    4238 </span><span class="lineCov">       1638 :       bool found = true;</span>
<span class="lineNum">    4239 </span><span class="lineCov">       1638 :       tree fn = *iter;</span>
<span class="lineNum">    4240 </span><span class="lineCov">       1638 :       tree parmtypes = TYPE_ARG_TYPES (TREE_TYPE (fn));</span>
<span class="lineNum">    4241 </span><span class="lineCov">       1638 :       if (parmtypes != NULL_TREE)</span>
<span class="lineNum">    4242 </span>            :         {
<span class="lineNum">    4243 </span><span class="lineCov">       6926 :           for (ix = 0; ix &lt; vec_safe_length (args) &amp;&amp; parmtypes != NULL_TREE;</span>
<span class="lineNum">    4244 </span><span class="lineCov">       1825 :                ++ix, parmtypes = TREE_CHAIN (parmtypes))</span>
<span class="lineNum">    4245 </span>            :             {
<span class="lineNum">    4246 </span><span class="lineCov">       1825 :               tree tparm = TREE_VALUE (parmtypes);</span>
<span class="lineNum">    4247 </span><span class="lineCov">       1825 :               tree targ = TREE_TYPE ((*args)[ix]);</span>
<span class="lineNum">    4248 </span><span class="lineCov">       1825 :               bool ptr = TYPE_PTR_P (tparm);</span>
<span class="lineNum">    4249 </span><span class="lineCov">       1825 :               bool arr = TREE_CODE (targ) == ARRAY_TYPE;</span>
<span class="lineNum">    4250 </span><span class="lineCov">        974 :               if ((ptr || arr || !same_type_p (tparm, targ))</span>
<span class="lineNum">    4251 </span><span class="lineCov">       2247 :                   &amp;&amp; (!ptr || !arr</span>
<span class="lineNum">    4252 </span><span class="lineCov">        432 :                       || !same_type_p (TREE_TYPE (tparm),</span>
<span class="lineNum">    4253 </span>            :                                        TREE_TYPE (targ))))
<span class="lineNum">    4254 </span>            :                 found = false;
<span class="lineNum">    4255 </span>            :             }
<span class="lineNum">    4256 </span><span class="lineCov">       1638 :           if (found</span>
<span class="lineNum">    4257 </span><span class="lineCov">        561 :               &amp;&amp; ix == vec_safe_length (args)</span>
<span class="lineNum">    4258 </span>            :               /* May be this should be sufficient_parms_p instead,
<span class="lineNum">    4259 </span>            :                  depending on how exactly should user-defined literals
<span class="lineNum">    4260 </span>            :                  work in presence of default arguments on the literal
<span class="lineNum">    4261 </span>            :                  operator parameters.  */
<span class="lineNum">    4262 </span><span class="lineCov">       2199 :               &amp;&amp; parmtypes == void_list_node)</span>
<span class="lineNum">    4263 </span><span class="lineCov">        516 :             return decl;</span>
<span class="lineNum">    4264 </span>            :         }
<span class="lineNum">    4265 </span>            :     }
<span class="lineNum">    4266 </span>            : 
<span class="lineNum">    4267 </span><span class="lineCov">        455 :   return error_mark_node;</span>
<span class="lineNum">    4268 </span>            : }
<span class="lineNum">    4269 </span>            : 
<span class="lineNum">    4270 </span>            : /* Parse a user-defined char constant.  Returns a call to a user-defined
<span class="lineNum">    4271 </span>            :    literal operator taking the character as an argument.  */
<a name="4272"><span class="lineNum">    4272 </span>            : </a>
<span class="lineNum">    4273 </span>            : static cp_expr
<span class="lineNum">    4274 </span><span class="lineCov">         45 : cp_parser_userdef_char_literal (cp_parser *parser)</span>
<span class="lineNum">    4275 </span>            : {
<span class="lineNum">    4276 </span><span class="lineCov">         45 :   cp_token *token = cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    4277 </span><span class="lineCov">         45 :   tree literal = token-&gt;u.value;</span>
<span class="lineNum">    4278 </span><span class="lineCov">         45 :   tree suffix_id = USERDEF_LITERAL_SUFFIX_ID (literal);</span>
<span class="lineNum">    4279 </span><span class="lineCov">         45 :   tree value = USERDEF_LITERAL_VALUE (literal);</span>
<span class="lineNum">    4280 </span><span class="lineCov">         45 :   tree name = cp_literal_operator_id (IDENTIFIER_POINTER (suffix_id));</span>
<span class="lineNum">    4281 </span><span class="lineCov">         45 :   tree decl, result;</span>
<span class="lineNum">    4282 </span>            : 
<span class="lineNum">    4283 </span>            :   /* Build up a call to the user-defined operator  */
<span class="lineNum">    4284 </span>            :   /* Lookup the name we got back from the id-expression.  */
<span class="lineNum">    4285 </span><span class="lineCov">         45 :   vec&lt;tree, va_gc&gt; *args = make_tree_vector ();</span>
<span class="lineNum">    4286 </span><span class="lineCov">         45 :   vec_safe_push (args, value);</span>
<span class="lineNum">    4287 </span><span class="lineCov">         45 :   decl = lookup_literal_operator (name, args);</span>
<span class="lineNum">    4288 </span><span class="lineCov">         45 :   if (!decl || decl == error_mark_node)</span>
<span class="lineNum">    4289 </span>            :     {
<span class="lineNum">    4290 </span><span class="lineCov">         56 :       error (&quot;unable to find character literal operator %qD with %qT argument&quot;,</span>
<span class="lineNum">    4291 </span><span class="lineCov">         28 :              name, TREE_TYPE (value));</span>
<span class="lineNum">    4292 </span><span class="lineCov">         28 :       release_tree_vector (args);</span>
<span class="lineNum">    4293 </span><span class="lineCov">         28 :       return error_mark_node;</span>
<span class="lineNum">    4294 </span>            :     }
<span class="lineNum">    4295 </span><span class="lineCov">         17 :   result = finish_call_expr (decl, &amp;args, false, true, tf_warning_or_error);</span>
<span class="lineNum">    4296 </span><span class="lineCov">         17 :   release_tree_vector (args);</span>
<span class="lineNum">    4297 </span><span class="lineCov">         17 :   return result;</span>
<span class="lineNum">    4298 </span>            : }
<span class="lineNum">    4299 </span>            : 
<span class="lineNum">    4300 </span>            : /* A subroutine of cp_parser_userdef_numeric_literal to
<span class="lineNum">    4301 </span>            :    create a char... template parameter pack from a string node.  */
<a name="4302"><span class="lineNum">    4302 </span>            : </a>
<span class="lineNum">    4303 </span>            : static tree
<span class="lineNum">    4304 </span><span class="lineCov">        155 : make_char_string_pack (tree value)</span>
<span class="lineNum">    4305 </span>            : {
<span class="lineNum">    4306 </span><span class="lineCov">        155 :   tree charvec;</span>
<span class="lineNum">    4307 </span><span class="lineCov">        155 :   tree argpack = make_node (NONTYPE_ARGUMENT_PACK);</span>
<span class="lineNum">    4308 </span><span class="lineCov">        155 :   const char *str = TREE_STRING_POINTER (value);</span>
<span class="lineNum">    4309 </span><span class="lineCov">        155 :   int i, len = TREE_STRING_LENGTH (value) - 1;</span>
<span class="lineNum">    4310 </span><span class="lineCov">        155 :   tree argvec = make_tree_vec (1);</span>
<span class="lineNum">    4311 </span>            : 
<span class="lineNum">    4312 </span>            :   /* Fill in CHARVEC with all of the parameters.  */
<span class="lineNum">    4313 </span><span class="lineCov">        155 :   charvec = make_tree_vec (len);</span>
<span class="lineNum">    4314 </span><span class="lineCov">        897 :   for (i = 0; i &lt; len; ++i)</span>
<span class="lineNum">    4315 </span>            :     {
<span class="lineNum">    4316 </span><span class="lineCov">        742 :       unsigned char s[3] = { '\'', str[i], '\'' };</span>
<span class="lineNum">    4317 </span><span class="lineCov">        742 :       cpp_string in = { 3, s };</span>
<span class="lineNum">    4318 </span><span class="lineCov">        742 :       cpp_string out = { 0, 0 };</span>
<span class="lineNum">    4319 </span><span class="lineCov">        742 :       if (!cpp_interpret_string (parse_in, &amp;in, 1, &amp;out, CPP_STRING))</span>
<span class="lineNum">    4320 </span><span class="lineNoCov">          0 :         return NULL_TREE;</span>
<span class="lineNum">    4321 </span><span class="lineCov">        742 :       gcc_assert (out.len == 2);</span>
<span class="lineNum">    4322 </span><span class="lineCov">        742 :       TREE_VEC_ELT (charvec, i) = build_int_cst (char_type_node,</span>
<span class="lineNum">    4323 </span><span class="lineCov">        742 :                                                  out.text[0]);</span>
<span class="lineNum">    4324 </span>            :     }
<span class="lineNum">    4325 </span>            : 
<span class="lineNum">    4326 </span>            :   /* Build the argument packs.  */
<span class="lineNum">    4327 </span><span class="lineCov">        155 :   SET_ARGUMENT_PACK_ARGS (argpack, charvec);</span>
<span class="lineNum">    4328 </span>            : 
<span class="lineNum">    4329 </span><span class="lineCov">        155 :   TREE_VEC_ELT (argvec, 0) = argpack;</span>
<span class="lineNum">    4330 </span>            : 
<span class="lineNum">    4331 </span><span class="lineCov">        155 :   return argvec;</span>
<span class="lineNum">    4332 </span>            : }
<span class="lineNum">    4333 </span>            : 
<span class="lineNum">    4334 </span>            : /* A subroutine of cp_parser_userdef_numeric_literal to
<span class="lineNum">    4335 </span>            :    create a char... template parameter pack from a string node.  */
<a name="4336"><span class="lineNum">    4336 </span>            : </a>
<span class="lineNum">    4337 </span>            : static tree
<span class="lineNum">    4338 </span><span class="lineCov">         21 : make_string_pack (tree value)</span>
<span class="lineNum">    4339 </span>            : {
<span class="lineNum">    4340 </span><span class="lineCov">         21 :   tree charvec;</span>
<span class="lineNum">    4341 </span><span class="lineCov">         21 :   tree argpack = make_node (NONTYPE_ARGUMENT_PACK);</span>
<span class="lineNum">    4342 </span><span class="lineCov">         21 :   const unsigned char *str</span>
<span class="lineNum">    4343 </span><span class="lineCov">         21 :     = (const unsigned char *) TREE_STRING_POINTER (value);</span>
<span class="lineNum">    4344 </span><span class="lineCov">         21 :   int sz = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (value))));</span>
<span class="lineNum">    4345 </span><span class="lineCov">         21 :   int len = TREE_STRING_LENGTH (value) / sz - 1;</span>
<span class="lineNum">    4346 </span><span class="lineCov">         21 :   tree argvec = make_tree_vec (2);</span>
<span class="lineNum">    4347 </span>            : 
<span class="lineNum">    4348 </span><span class="lineCov">         21 :   tree str_char_type_node = TREE_TYPE (TREE_TYPE (value));</span>
<span class="lineNum">    4349 </span><span class="lineCov">         21 :   str_char_type_node = TYPE_MAIN_VARIANT (str_char_type_node);</span>
<span class="lineNum">    4350 </span>            : 
<span class="lineNum">    4351 </span>            :   /* First template parm is character type.  */
<span class="lineNum">    4352 </span><span class="lineCov">         21 :   TREE_VEC_ELT (argvec, 0) = str_char_type_node;</span>
<span class="lineNum">    4353 </span>            : 
<span class="lineNum">    4354 </span>            :   /* Fill in CHARVEC with all of the parameters.  */
<span class="lineNum">    4355 </span><span class="lineCov">         21 :   charvec = make_tree_vec (len);</span>
<span class="lineNum">    4356 </span><span class="lineCov">         83 :   for (int i = 0; i &lt; len; ++i)</span>
<span class="lineNum">    4357 </span><span class="lineCov">         62 :     TREE_VEC_ELT (charvec, i)</span>
<span class="lineNum">    4358 </span><span class="lineCov">         62 :       = double_int_to_tree (str_char_type_node,</span>
<span class="lineNum">    4359 </span><span class="lineCov">         62 :                             double_int::from_buffer (str + i * sz, sz));</span>
<span class="lineNum">    4360 </span>            : 
<span class="lineNum">    4361 </span>            :   /* Build the argument packs.  */
<span class="lineNum">    4362 </span><span class="lineCov">         21 :   SET_ARGUMENT_PACK_ARGS (argpack, charvec);</span>
<span class="lineNum">    4363 </span>            : 
<span class="lineNum">    4364 </span><span class="lineCov">         21 :   TREE_VEC_ELT (argvec, 1) = argpack;</span>
<span class="lineNum">    4365 </span>            : 
<span class="lineNum">    4366 </span><span class="lineCov">         21 :   return argvec;</span>
<span class="lineNum">    4367 </span>            : }
<span class="lineNum">    4368 </span>            : 
<span class="lineNum">    4369 </span>            : /* Parse a user-defined numeric constant.  returns a call to a user-defined
<span class="lineNum">    4370 </span>            :    literal operator.  */
<a name="4371"><span class="lineNum">    4371 </span>            : </a>
<span class="lineNum">    4372 </span>            : static cp_expr
<span class="lineNum">    4373 </span><span class="lineCov">      31888 : cp_parser_userdef_numeric_literal (cp_parser *parser)</span>
<span class="lineNum">    4374 </span>            : {
<span class="lineNum">    4375 </span><span class="lineCov">      31888 :   cp_token *token = cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    4376 </span><span class="lineCov">      31888 :   tree literal = token-&gt;u.value;</span>
<span class="lineNum">    4377 </span><span class="lineCov">      31888 :   tree suffix_id = USERDEF_LITERAL_SUFFIX_ID (literal);</span>
<span class="lineNum">    4378 </span><span class="lineCov">      31888 :   tree value = USERDEF_LITERAL_VALUE (literal);</span>
<span class="lineNum">    4379 </span><span class="lineCov">      31888 :   int overflow = USERDEF_LITERAL_OVERFLOW (literal);</span>
<span class="lineNum">    4380 </span><span class="lineCov">      31888 :   tree num_string = USERDEF_LITERAL_NUM_STRING (literal);</span>
<span class="lineNum">    4381 </span><span class="lineCov">      31888 :   tree name = cp_literal_operator_id (IDENTIFIER_POINTER (suffix_id));</span>
<span class="lineNum">    4382 </span><span class="lineCov">      31888 :   tree decl, result;</span>
<span class="lineNum">    4383 </span><span class="lineCov">      31888 :   vec&lt;tree, va_gc&gt; *args;</span>
<span class="lineNum">    4384 </span>            : 
<span class="lineNum">    4385 </span>            :   /* Look for a literal operator taking the exact type of numeric argument
<span class="lineNum">    4386 </span>            :      as the literal value.  */
<span class="lineNum">    4387 </span><span class="lineCov">      31888 :   args = make_tree_vector ();</span>
<span class="lineNum">    4388 </span><span class="lineCov">      31888 :   vec_safe_push (args, value);</span>
<span class="lineNum">    4389 </span><span class="lineCov">      31888 :   decl = lookup_literal_operator (name, args);</span>
<span class="lineNum">    4390 </span><span class="lineCov">      31888 :   if (decl &amp;&amp; decl != error_mark_node)</span>
<span class="lineNum">    4391 </span>            :     {
<span class="lineNum">    4392 </span><span class="lineCov">        133 :       result = finish_call_expr (decl, &amp;args, false, true,</span>
<span class="lineNum">    4393 </span>            :                                  tf_warning_or_error);
<span class="lineNum">    4394 </span>            : 
<span class="lineNum">    4395 </span><span class="lineCov">        133 :       if (TREE_CODE (TREE_TYPE (value)) == INTEGER_TYPE &amp;&amp; overflow &gt; 0)</span>
<span class="lineNum">    4396 </span>            :         {
<span class="lineNum">    4397 </span><span class="lineCov">          2 :           warning_at (token-&gt;location, OPT_Woverflow,</span>
<span class="lineNum">    4398 </span>            :                       &quot;integer literal exceeds range of %qT type&quot;,
<span class="lineNum">    4399 </span>            :                       long_long_unsigned_type_node);
<span class="lineNum">    4400 </span>            :         }
<span class="lineNum">    4401 </span>            :       else
<span class="lineNum">    4402 </span>            :         {
<span class="lineNum">    4403 </span><span class="lineCov">        131 :           if (overflow &gt; 0)</span>
<span class="lineNum">    4404 </span><span class="lineCov">          2 :             warning_at (token-&gt;location, OPT_Woverflow,</span>
<span class="lineNum">    4405 </span>            :                         &quot;floating literal exceeds range of %qT type&quot;,
<span class="lineNum">    4406 </span>            :                         long_double_type_node);
<span class="lineNum">    4407 </span><span class="lineCov">        129 :           else if (overflow &lt; 0)</span>
<span class="lineNum">    4408 </span><span class="lineCov">          2 :             warning_at (token-&gt;location, OPT_Woverflow,</span>
<span class="lineNum">    4409 </span>            :                         &quot;floating literal truncated to zero&quot;);
<span class="lineNum">    4410 </span>            :         }
<span class="lineNum">    4411 </span>            : 
<span class="lineNum">    4412 </span><span class="lineCov">        133 :       release_tree_vector (args);</span>
<span class="lineNum">    4413 </span><span class="lineCov">        133 :       return result;</span>
<span class="lineNum">    4414 </span>            :     }
<span class="lineNum">    4415 </span><span class="lineCov">      31755 :   release_tree_vector (args);</span>
<span class="lineNum">    4416 </span>            : 
<span class="lineNum">    4417 </span>            :   /* If the numeric argument didn't work, look for a raw literal
<span class="lineNum">    4418 </span>            :      operator taking a const char* argument consisting of the number
<span class="lineNum">    4419 </span>            :      in string format.  */
<span class="lineNum">    4420 </span><span class="lineCov">      31755 :   args = make_tree_vector ();</span>
<span class="lineNum">    4421 </span><span class="lineCov">      31755 :   vec_safe_push (args, num_string);</span>
<span class="lineNum">    4422 </span><span class="lineCov">      31755 :   decl = lookup_literal_operator (name, args);</span>
<span class="lineNum">    4423 </span><span class="lineCov">      31755 :   if (decl &amp;&amp; decl != error_mark_node)</span>
<span class="lineNum">    4424 </span>            :     {
<span class="lineNum">    4425 </span><span class="lineCov">         24 :       result = finish_call_expr (decl, &amp;args, false, true,</span>
<span class="lineNum">    4426 </span>            :                                  tf_warning_or_error);
<span class="lineNum">    4427 </span><span class="lineCov">         24 :       release_tree_vector (args);</span>
<span class="lineNum">    4428 </span><span class="lineCov">         24 :       return result;</span>
<span class="lineNum">    4429 </span>            :     }
<span class="lineNum">    4430 </span><span class="lineCov">      31731 :   release_tree_vector (args);</span>
<span class="lineNum">    4431 </span>            : 
<span class="lineNum">    4432 </span>            :   /* If the raw literal didn't work, look for a non-type template
<span class="lineNum">    4433 </span>            :      function with parameter pack char....  Call the function with
<span class="lineNum">    4434 </span>            :      template parameter characters representing the number.  */
<span class="lineNum">    4435 </span><span class="lineCov">      31731 :   args = make_tree_vector ();</span>
<span class="lineNum">    4436 </span><span class="lineCov">      31731 :   decl = lookup_literal_operator (name, args);</span>
<span class="lineNum">    4437 </span><span class="lineCov">      31731 :   if (decl &amp;&amp; decl != error_mark_node)</span>
<span class="lineNum">    4438 </span>            :     {
<span class="lineNum">    4439 </span><span class="lineCov">        155 :       tree tmpl_args = make_char_string_pack (num_string);</span>
<span class="lineNum">    4440 </span><span class="lineCov">        155 :       if (tmpl_args == NULL_TREE)</span>
<span class="lineNum">    4441 </span>            :         {
<span class="lineNum">    4442 </span><span class="lineNoCov">          0 :           error (&quot;failed to translate literal to execution character set %qT&quot;,</span>
<span class="lineNum">    4443 </span>            :                  num_string);
<span class="lineNum">    4444 </span><span class="lineNoCov">          0 :           return error_mark_node;</span>
<span class="lineNum">    4445 </span>            :         }
<span class="lineNum">    4446 </span><span class="lineCov">        155 :       decl = lookup_template_function (decl, tmpl_args);</span>
<span class="lineNum">    4447 </span><span class="lineCov">        155 :       result = finish_call_expr (decl, &amp;args, false, true,</span>
<span class="lineNum">    4448 </span>            :                                  tf_warning_or_error);
<span class="lineNum">    4449 </span><span class="lineCov">        155 :       release_tree_vector (args);</span>
<span class="lineNum">    4450 </span><span class="lineCov">        155 :       return result;</span>
<span class="lineNum">    4451 </span>            :     }
<span class="lineNum">    4452 </span>            : 
<span class="lineNum">    4453 </span><span class="lineCov">      31576 :   release_tree_vector (args);</span>
<span class="lineNum">    4454 </span>            : 
<span class="lineNum">    4455 </span>            :   /* In C++14 the standard library defines complex number suffixes that
<span class="lineNum">    4456 </span>            :      conflict with GNU extensions.  Prefer them if &lt;complex&gt; is #included.  */
<span class="lineNum">    4457 </span><span class="lineCov">      31576 :   bool ext = cpp_get_options (parse_in)-&gt;ext_numeric_literals;</span>
<span class="lineNum">    4458 </span><span class="lineCov">      31576 :   bool i14 = (cxx_dialect &gt; cxx11</span>
<span class="lineNum">    4459 </span><span class="lineCov">      31576 :               &amp;&amp; (id_equal (suffix_id, &quot;i&quot;)</span>
<span class="lineNum">    4460 </span><span class="lineCov">      21007 :                   || id_equal (suffix_id, &quot;if&quot;)</span>
<span class="lineNum">    4461 </span><span class="lineCov">      10509 :                   || id_equal (suffix_id, &quot;il&quot;)));</span>
<span class="lineNum">    4462 </span><span class="lineCov">      31576 :   diagnostic_t kind = DK_ERROR;</span>
<span class="lineNum">    4463 </span><span class="lineCov">      31576 :   int opt = 0;</span>
<span class="lineNum">    4464 </span>            : 
<span class="lineNum">    4465 </span><span class="lineCov">      31576 :   if (i14 &amp;&amp; ext)</span>
<span class="lineNum">    4466 </span>            :     {
<span class="lineNum">    4467 </span><span class="lineCov">      31544 :       tree cxlit = lookup_qualified_name (std_node,</span>
<span class="lineNum">    4468 </span>            :                                           get_identifier (&quot;complex_literals&quot;),
<span class="lineNum">    4469 </span>            :                                           0, false, false);
<span class="lineNum">    4470 </span><span class="lineCov">      31544 :       if (cxlit == error_mark_node)</span>
<span class="lineNum">    4471 </span>            :         {
<span class="lineNum">    4472 </span>            :           /* No &lt;complex&gt;, so pedwarn and use GNU semantics.  */
<span class="lineNum">    4473 </span><span class="lineCov">      31543 :           kind = DK_PEDWARN;</span>
<span class="lineNum">    4474 </span><span class="lineCov">      31543 :           opt = OPT_Wpedantic;</span>
<span class="lineNum">    4475 </span>            :         }
<span class="lineNum">    4476 </span>            :     }
<span class="lineNum">    4477 </span>            : 
<span class="lineNum">    4478 </span><span class="lineCov">      31576 :   bool complained</span>
<span class="lineNum">    4479 </span><span class="lineCov">      31576 :     = emit_diagnostic (kind, input_location, opt,</span>
<span class="lineNum">    4480 </span>            :                        &quot;unable to find numeric literal operator %qD&quot;, name);
<span class="lineNum">    4481 </span>            : 
<span class="lineNum">    4482 </span><span class="lineCov">      31576 :   if (!complained)</span>
<span class="lineNum">    4483 </span>            :     /* Don't inform either.  */;
<span class="lineNum">    4484 </span><span class="lineCov">         37 :   else if (i14)</span>
<span class="lineNum">    4485 </span>            :     {
<span class="lineNum">    4486 </span><span class="lineCov">          7 :       inform (token-&gt;location, &quot;add %&lt;using namespace std::complex_literals%&gt; &quot;</span>
<span class="lineNum">    4487 </span>            :               &quot;(from &lt;complex&gt;) to enable the C++14 user-defined literal &quot;
<span class="lineNum">    4488 </span>            :               &quot;suffixes&quot;);
<span class="lineNum">    4489 </span><span class="lineCov">          7 :       if (ext)</span>
<span class="lineNum">    4490 </span><span class="lineCov">          5 :         inform (token-&gt;location, &quot;or use %&lt;j%&gt; instead of %&lt;i%&gt; for the &quot;</span>
<span class="lineNum">    4491 </span>            :                 &quot;GNU built-in suffix&quot;);
<span class="lineNum">    4492 </span>            :     }
<span class="lineNum">    4493 </span><span class="lineCov">         30 :   else if (!ext)</span>
<span class="lineNum">    4494 </span><span class="lineCov">         30 :     inform (token-&gt;location, &quot;use -fext-numeric-literals &quot;</span>
<span class="lineNum">    4495 </span>            :             &quot;to enable more built-in suffixes&quot;);
<span class="lineNum">    4496 </span>            : 
<span class="lineNum">    4497 </span><span class="lineCov">      31576 :   if (kind == DK_ERROR)</span>
<span class="lineNum">    4498 </span><span class="lineCov">         33 :     value = error_mark_node;</span>
<span class="lineNum">    4499 </span>            :   else
<span class="lineNum">    4500 </span>            :     {
<span class="lineNum">    4501 </span>            :       /* Use the built-in semantics.  */
<span class="lineNum">    4502 </span><span class="lineCov">      31543 :       tree type;</span>
<span class="lineNum">    4503 </span><span class="lineCov">      31543 :       if (id_equal (suffix_id, &quot;i&quot;))</span>
<span class="lineNum">    4504 </span>            :         {
<span class="lineNum">    4505 </span><span class="lineCov">      10547 :           if (TREE_CODE (value) == INTEGER_CST)</span>
<span class="lineNum">    4506 </span><span class="lineCov">         37 :             type = integer_type_node;</span>
<span class="lineNum">    4507 </span>            :           else
<span class="lineNum">    4508 </span><span class="lineCov">      10510 :             type = double_type_node;</span>
<span class="lineNum">    4509 </span>            :         }
<span class="lineNum">    4510 </span><span class="lineCov">      20996 :       else if (id_equal (suffix_id, &quot;if&quot;))</span>
<span class="lineNum">    4511 </span><span class="lineCov">      10498 :         type = float_type_node;</span>
<span class="lineNum">    4512 </span>            :       else /* if (id_equal (suffix_id, &quot;il&quot;)) */
<span class="lineNum">    4513 </span><span class="lineCov">      10498 :         type = long_double_type_node;</span>
<span class="lineNum">    4514 </span>            : 
<span class="lineNum">    4515 </span><span class="lineCov">      31543 :       value = build_complex (build_complex_type (type),</span>
<span class="lineNum">    4516 </span>            :                              fold_convert (type, integer_zero_node),
<span class="lineNum">    4517 </span>            :                              fold_convert (type, value));
<span class="lineNum">    4518 </span>            :     }
<span class="lineNum">    4519 </span>            : 
<span class="lineNum">    4520 </span><span class="lineCov">      31590 :   if (cp_parser_uncommitted_to_tentative_parse_p (parser))</span>
<span class="lineNum">    4521 </span>            :     /* Avoid repeated diagnostics.  */
<span class="lineNum">    4522 </span><span class="lineCov">         14 :     token-&gt;u.value = value;</span>
<span class="lineNum">    4523 </span><span class="lineCov">      31576 :   return value;</span>
<span class="lineNum">    4524 </span>            : }
<span class="lineNum">    4525 </span>            : 
<span class="lineNum">    4526 </span>            : /* Parse a user-defined string constant.  Returns a call to a user-defined
<span class="lineNum">    4527 </span>            :    literal operator taking a character pointer and the length of the string
<span class="lineNum">    4528 </span>            :    as arguments.  */
<a name="4529"><span class="lineNum">    4529 </span>            : </a>
<span class="lineNum">    4530 </span>            : static tree
<span class="lineNum">    4531 </span><span class="lineCov">        225 : cp_parser_userdef_string_literal (tree literal)</span>
<span class="lineNum">    4532 </span>            : {
<span class="lineNum">    4533 </span><span class="lineCov">        225 :   tree suffix_id = USERDEF_LITERAL_SUFFIX_ID (literal);</span>
<span class="lineNum">    4534 </span><span class="lineCov">        225 :   tree name = cp_literal_operator_id (IDENTIFIER_POINTER (suffix_id));</span>
<span class="lineNum">    4535 </span><span class="lineCov">        225 :   tree value = USERDEF_LITERAL_VALUE (literal);</span>
<span class="lineNum">    4536 </span><span class="lineCov">        225 :   int len = TREE_STRING_LENGTH (value)</span>
<span class="lineNum">    4537 </span><span class="lineCov">        225 :         / TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (value)))) - 1;</span>
<span class="lineNum">    4538 </span><span class="lineCov">        225 :   tree decl, result;</span>
<span class="lineNum">    4539 </span><span class="lineCov">        225 :   vec&lt;tree, va_gc&gt; *args;</span>
<span class="lineNum">    4540 </span>            : 
<span class="lineNum">    4541 </span>            :   /* Build up a call to the user-defined operator.  */
<span class="lineNum">    4542 </span>            :   /* Lookup the name we got back from the id-expression.  */
<span class="lineNum">    4543 </span><span class="lineCov">        225 :   args = make_tree_vector ();</span>
<span class="lineNum">    4544 </span><span class="lineCov">        225 :   vec_safe_push (args, value);</span>
<span class="lineNum">    4545 </span><span class="lineCov">        450 :   vec_safe_push (args, build_int_cst (size_type_node, len));</span>
<span class="lineNum">    4546 </span><span class="lineCov">        225 :   decl = lookup_literal_operator (name, args);</span>
<span class="lineNum">    4547 </span>            : 
<span class="lineNum">    4548 </span><span class="lineCov">        225 :   if (decl &amp;&amp; decl != error_mark_node)</span>
<span class="lineNum">    4549 </span>            :     {
<span class="lineNum">    4550 </span><span class="lineCov">        166 :       result = finish_call_expr (decl, &amp;args, false, true,</span>
<span class="lineNum">    4551 </span>            :                                  tf_warning_or_error);
<span class="lineNum">    4552 </span><span class="lineCov">        166 :       release_tree_vector (args);</span>
<span class="lineNum">    4553 </span><span class="lineCov">        166 :       return result;</span>
<span class="lineNum">    4554 </span>            :     }
<span class="lineNum">    4555 </span><span class="lineCov">         59 :   release_tree_vector (args);</span>
<span class="lineNum">    4556 </span>            : 
<span class="lineNum">    4557 </span>            :   /* Look for a template function with typename parameter CharT
<span class="lineNum">    4558 </span>            :      and parameter pack CharT...  Call the function with
<span class="lineNum">    4559 </span>            :      template parameter characters representing the string.  */
<span class="lineNum">    4560 </span><span class="lineCov">         59 :   args = make_tree_vector ();</span>
<span class="lineNum">    4561 </span><span class="lineCov">         59 :   decl = lookup_literal_operator (name, args);</span>
<span class="lineNum">    4562 </span><span class="lineCov">         59 :   if (decl &amp;&amp; decl != error_mark_node)</span>
<span class="lineNum">    4563 </span>            :     {
<span class="lineNum">    4564 </span><span class="lineCov">         21 :       tree tmpl_args = make_string_pack (value);</span>
<span class="lineNum">    4565 </span><span class="lineCov">         21 :       decl = lookup_template_function (decl, tmpl_args);</span>
<span class="lineNum">    4566 </span><span class="lineCov">         21 :       result = finish_call_expr (decl, &amp;args, false, true,</span>
<span class="lineNum">    4567 </span>            :                                  tf_warning_or_error);
<span class="lineNum">    4568 </span><span class="lineCov">         21 :       release_tree_vector (args);</span>
<span class="lineNum">    4569 </span><span class="lineCov">         21 :       return result;</span>
<span class="lineNum">    4570 </span>            :     }
<span class="lineNum">    4571 </span><span class="lineCov">         38 :   release_tree_vector (args);</span>
<span class="lineNum">    4572 </span>            : 
<span class="lineNum">    4573 </span><span class="lineCov">         76 :   error (&quot;unable to find string literal operator %qD with %qT, %qT arguments&quot;,</span>
<span class="lineNum">    4574 </span><span class="lineCov">         38 :          name, TREE_TYPE (value), size_type_node);</span>
<span class="lineNum">    4575 </span><span class="lineCov">         38 :   return error_mark_node;</span>
<span class="lineNum">    4576 </span>            : }
<span class="lineNum">    4577 </span>            : 
<span class="lineNum">    4578 </span>            : 
<span class="lineNum">    4579 </span>            : /* Basic concepts [gram.basic]  */
<span class="lineNum">    4580 </span>            : 
<span class="lineNum">    4581 </span>            : /* Parse a translation-unit.
<span class="lineNum">    4582 </span>            : 
<span class="lineNum">    4583 </span>            :    translation-unit:
<span class="lineNum">    4584 </span>            :      declaration-seq [opt]
<span class="lineNum">    4585 </span>            : 
<span class="lineNum">    4586 </span>            :    Returns TRUE if all went well.  */
<a name="4587"><span class="lineNum">    4587 </span>            : </a>
<span class="lineNum">    4588 </span>            : static bool
<span class="lineNum">    4589 </span><span class="lineCov">      56241 : cp_parser_translation_unit (cp_parser* parser)</span>
<span class="lineNum">    4590 </span>            : {
<span class="lineNum">    4591 </span>            :   /* The address of the first non-permanent object on the declarator
<span class="lineNum">    4592 </span>            :      obstack.  */
<span class="lineNum">    4593 </span><span class="lineCov">      56241 :   static void *declarator_obstack_base;</span>
<span class="lineNum">    4594 </span>            : 
<span class="lineNum">    4595 </span><span class="lineCov">      56241 :   bool success;</span>
<span class="lineNum">    4596 </span>            : 
<span class="lineNum">    4597 </span>            :   /* Create the declarator obstack, if necessary.  */
<span class="lineNum">    4598 </span><span class="lineCov">      56241 :   if (!cp_error_declarator)</span>
<span class="lineNum">    4599 </span>            :     {
<span class="lineNum">    4600 </span><span class="lineCov">      56241 :       gcc_obstack_init (&amp;declarator_obstack);</span>
<span class="lineNum">    4601 </span>            :       /* Create the error declarator.  */
<span class="lineNum">    4602 </span><span class="lineCov">      56241 :       cp_error_declarator = make_declarator (cdk_error);</span>
<span class="lineNum">    4603 </span>            :       /* Create the empty parameter list.  */
<span class="lineNum">    4604 </span><span class="lineCov">      56241 :       no_parameters = make_parameter_declarator (NULL, NULL, NULL_TREE,</span>
<span class="lineNum">    4605 </span>            :                                                  UNKNOWN_LOCATION);
<span class="lineNum">    4606 </span>            :       /* Remember where the base of the declarator obstack lies.  */
<span class="lineNum">    4607 </span><span class="lineCov">      56241 :       declarator_obstack_base = obstack_next_free (&amp;declarator_obstack);</span>
<span class="lineNum">    4608 </span>            :     }
<span class="lineNum">    4609 </span>            : 
<span class="lineNum">    4610 </span><span class="lineCov">      56241 :   cp_parser_declaration_seq_opt (parser);</span>
<span class="lineNum">    4611 </span>            : 
<span class="lineNum">    4612 </span>            :   /* If there are no tokens left then all went well.  */
<span class="lineNum">    4613 </span><span class="lineCov">      56204 :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_EOF))</span>
<span class="lineNum">    4614 </span>            :     {
<span class="lineNum">    4615 </span>            :       /* Get rid of the token array; we don't need it any more.  */
<span class="lineNum">    4616 </span><span class="lineCov">      56172 :       cp_lexer_destroy (parser-&gt;lexer);</span>
<span class="lineNum">    4617 </span><span class="lineCov">      56172 :       parser-&gt;lexer = NULL;</span>
<span class="lineNum">    4618 </span>            : 
<span class="lineNum">    4619 </span>            :       /* This file might have been a context that's implicitly extern
<span class="lineNum">    4620 </span>            :          &quot;C&quot;.  If so, pop the lang context.  (Only relevant for PCH.) */
<span class="lineNum">    4621 </span><span class="lineCov">      56172 :       if (parser-&gt;implicit_extern_c)</span>
<span class="lineNum">    4622 </span>            :         {
<span class="lineNum">    4623 </span><span class="lineNoCov">          0 :           pop_lang_context ();</span>
<span class="lineNum">    4624 </span><span class="lineNoCov">          0 :           parser-&gt;implicit_extern_c = false;</span>
<span class="lineNum">    4625 </span>            :         }
<span class="lineNum">    4626 </span>            : 
<span class="lineNum">    4627 </span>            :       /* Finish up.  */
<span class="lineNum">    4628 </span><span class="lineCov">      56172 :       finish_translation_unit ();</span>
<span class="lineNum">    4629 </span>            : 
<span class="lineNum">    4630 </span><span class="lineCov">      56172 :       success = true;</span>
<span class="lineNum">    4631 </span>            :     }
<span class="lineNum">    4632 </span>            :   else
<span class="lineNum">    4633 </span>            :     {
<span class="lineNum">    4634 </span><span class="lineCov">         32 :       cp_parser_error (parser, &quot;expected declaration&quot;);</span>
<span class="lineNum">    4635 </span><span class="lineCov">         32 :       success = false;</span>
<span class="lineNum">    4636 </span>            :     }
<span class="lineNum">    4637 </span>            : 
<span class="lineNum">    4638 </span>            :   /* Make sure the declarator obstack was fully cleaned up.  */
<span class="lineNum">    4639 </span><span class="lineCov">      56204 :   gcc_assert (obstack_next_free (&amp;declarator_obstack)</span>
<span class="lineNum">    4640 </span>            :               == declarator_obstack_base);
<span class="lineNum">    4641 </span>            : 
<span class="lineNum">    4642 </span>            :   /* All went well.  */
<span class="lineNum">    4643 </span><span class="lineCov">      56204 :   return success;</span>
<span class="lineNum">    4644 </span>            : }
<span class="lineNum">    4645 </span>            : 
<span class="lineNum">    4646 </span>            : /* Return the appropriate tsubst flags for parsing, possibly in N3276
<span class="lineNum">    4647 </span>            :    decltype context.  */
<span class="lineNum">    4648 </span>            : 
<span class="lineNum">    4649 </span>            : static inline tsubst_flags_t
<span class="lineNum">    4650 </span>            : complain_flags (bool decltype_p)
<span class="lineNum">    4651 </span>            : {
<span class="lineNum">    4652 </span><span class="lineCov">   20893518 :   tsubst_flags_t complain = tf_warning_or_error;</span>
<span class="lineNum">    4653 </span><span class="lineCov">   20893518 :   if (decltype_p)</span>
<span class="lineNum">    4654 </span><span class="lineCov">     407462 :     complain |= tf_decltype;</span>
<span class="lineNum">    4655 </span><span class="lineCov">   20893518 :   return complain;</span>
<span class="lineNum">    4656 </span>            : }
<span class="lineNum">    4657 </span>            : 
<span class="lineNum">    4658 </span>            : /* We're about to parse a collection of statements.  If we're currently
<span class="lineNum">    4659 </span>            :    parsing tentatively, set up a firewall so that any nested
<span class="lineNum">    4660 </span>            :    cp_parser_commit_to_tentative_parse won't affect the current context.  */
<a name="4661"><span class="lineNum">    4661 </span>            : </a>
<span class="lineNum">    4662 </span>            : static cp_token_position
<span class="lineNum">    4663 </span><span class="lineCov">      22966 : cp_parser_start_tentative_firewall (cp_parser *parser)</span>
<span class="lineNum">    4664 </span>            : {
<span class="lineNum">    4665 </span><span class="lineCov">      23089 :   if (!cp_parser_uncommitted_to_tentative_parse_p (parser))</span>
<span class="lineNum">    4666 </span>            :     return 0;
<span class="lineNum">    4667 </span>            : 
<span class="lineNum">    4668 </span><span class="lineCov">        123 :   cp_parser_parse_tentatively (parser);</span>
<span class="lineNum">    4669 </span><span class="lineCov">        123 :   cp_parser_commit_to_topmost_tentative_parse (parser);</span>
<span class="lineNum">    4670 </span><span class="lineCov">        123 :   return cp_lexer_token_position (parser-&gt;lexer, false);</span>
<span class="lineNum">    4671 </span>            : }
<span class="lineNum">    4672 </span>            : 
<span class="lineNum">    4673 </span>            : /* We've finished parsing the collection of statements.  Wrap up the
<span class="lineNum">    4674 </span>            :    firewall and replace the relevant tokens with the parsed form.  */
<a name="4675"><span class="lineNum">    4675 </span>            : </a>
<span class="lineNum">    4676 </span>            : static void
<span class="lineNum">    4677 </span><span class="lineCov">      22990 : cp_parser_end_tentative_firewall (cp_parser *parser, cp_token_position start,</span>
<span class="lineNum">    4678 </span>            :                                   tree expr)
<span class="lineNum">    4679 </span>            : {
<span class="lineNum">    4680 </span><span class="lineCov">      22990 :   if (!start)</span>
<span class="lineNum">    4681 </span>            :     return;
<span class="lineNum">    4682 </span>            : 
<span class="lineNum">    4683 </span>            :   /* Finish the firewall level.  */
<span class="lineNum">    4684 </span><span class="lineCov">        123 :   cp_parser_parse_definitely (parser);</span>
<span class="lineNum">    4685 </span>            :   /* And remember the result of the parse for when we try again.  */
<span class="lineNum">    4686 </span><span class="lineCov">        246 :   cp_token *token = cp_lexer_token_at (parser-&gt;lexer, start);</span>
<span class="lineNum">    4687 </span><span class="lineCov">        123 :   token-&gt;type = CPP_PREPARSED_EXPR;</span>
<span class="lineNum">    4688 </span><span class="lineCov">        123 :   token-&gt;u.value = expr;</span>
<span class="lineNum">    4689 </span><span class="lineCov">        123 :   token-&gt;keyword = RID_MAX;</span>
<span class="lineNum">    4690 </span><span class="lineCov">        123 :   cp_lexer_purge_tokens_after (parser-&gt;lexer, start);</span>
<span class="lineNum">    4691 </span>            : }
<span class="lineNum">    4692 </span>            : 
<span class="lineNum">    4693 </span>            : /* Like the above functions, but let the user modify the tokens.  Used by
<span class="lineNum">    4694 </span>            :    CPP_DECLTYPE and CPP_TEMPLATE_ID, where we are saving the side-effects for
<span class="lineNum">    4695 </span>            :    later parses, so it makes sense to localize the effects of
<span class="lineNum">    4696 </span>            :    cp_parser_commit_to_tentative_parse.  */
<span class="lineNum">    4697 </span>            : 
<span class="lineNum">    4698 </span>            : struct tentative_firewall
<span class="lineNum">    4699 </span>            : {
<span class="lineNum">    4700 </span>            :   cp_parser *parser;
<a name="4701"><span class="lineNum">    4701 </span>            :   bool set;</a>
<span class="lineNum">    4702 </span>            : 
<span class="lineNum">    4703 </span><span class="lineCov">    9025788 :   tentative_firewall (cp_parser *p): parser(p)</span>
<span class="lineNum">    4704 </span>            :   {
<span class="lineNum">    4705 </span>            :     /* If we're currently parsing tentatively, start a committed level as a
<span class="lineNum">    4706 </span>            :        firewall and then an inner tentative parse.  */
<span class="lineNum">    4707 </span><span class="lineCov">    9025788 :     if ((set = cp_parser_uncommitted_to_tentative_parse_p (parser)))</span>
<span class="lineNum">    4708 </span>            :       {
<span class="lineNum">    4709 </span><span class="lineCov">    8879142 :         cp_parser_parse_tentatively (parser);</span>
<span class="lineNum">    4710 </span><span class="lineCov">    8879142 :         cp_parser_commit_to_topmost_tentative_parse (parser);</span>
<span class="lineNum">    4711 </span><span class="lineCov">    8879142 :         cp_parser_parse_tentatively (parser);</span>
<span class="lineNum">    4712 </span>            :       }
<a name="4713"><span class="lineNum">    4713 </span><span class="lineCov">    9025788 :   }</span></a>
<span class="lineNum">    4714 </span>            : 
<span class="lineNum">    4715 </span><span class="lineCov">    9025788 :   ~tentative_firewall()</span>
<span class="lineNum">    4716 </span><span class="lineCov">    9025788 :   {</span>
<span class="lineNum">    4717 </span><span class="lineCov">    9025788 :     if (set)</span>
<span class="lineNum">    4718 </span>            :       {
<span class="lineNum">    4719 </span>            :         /* Finish the inner tentative parse and the firewall, propagating any
<span class="lineNum">    4720 </span>            :            uncommitted error state to the outer tentative parse.  */
<span class="lineNum">    4721 </span><span class="lineCov">   17758284 :         bool err = cp_parser_error_occurred (parser);</span>
<span class="lineNum">    4722 </span><span class="lineCov">    8879142 :         cp_parser_parse_definitely (parser);</span>
<span class="lineNum">    4723 </span><span class="lineCov">    8879142 :         cp_parser_parse_definitely (parser);</span>
<span class="lineNum">    4724 </span><span class="lineCov">    8879142 :         if (err)</span>
<span class="lineNum">    4725 </span><span class="lineCov">     467825 :           cp_parser_simulate_error (parser);</span>
<span class="lineNum">    4726 </span>            :       }
<span class="lineNum">    4727 </span><span class="lineCov">    9025788 :   }</span>
<span class="lineNum">    4728 </span>            : };
<span class="lineNum">    4729 </span>            : 
<span class="lineNum">    4730 </span>            : /* Some tokens naturally come in pairs e.g.'(' and ')'.
<span class="lineNum">    4731 </span>            :    This class is for tracking such a matching pair of symbols.
<span class="lineNum">    4732 </span>            :    In particular, it tracks the location of the first token,
<span class="lineNum">    4733 </span>            :    so that if the second token is missing, we can highlight the
<span class="lineNum">    4734 </span>            :    location of the first token when notifying the user about the
<span class="lineNum">    4735 </span>            :    problem.  */
<span class="lineNum">    4736 </span>            : 
<span class="lineNum">    4737 </span>            : template &lt;typename traits_t&gt;
<span class="lineNum">    4738 </span>            : class token_pair
<span class="lineNum">    4739 </span>            : {
<span class="lineNum">    4740 </span>            :  public:
<span class="lineNum">    4741 </span>            :   /* token_pair's ctor.  */
<span class="lineNum">    4742 </span><span class="lineCov">   58844906 :   token_pair () : m_open_loc (UNKNOWN_LOCATION) {}</span>
<span class="lineNum">    4743 </span>            : 
<span class="lineNum">    4744 </span>            :   /* If the next token is the opening symbol for this pair, consume it and
<span class="lineNum">    4745 </span>            :      return true.
<span class="lineNum">    4746 </span>            :      Otherwise, issue an error and return false.
<a name="4747"><span class="lineNum">    4747 </span>            :      In either case, record the location of the opening token.  */</a>
<span class="lineNum">    4748 </span>            : 
<span class="lineNum">    4749 </span><span class="lineNoCov">          0 :   bool require_open (cp_parser *parser)</span>
<span class="lineNum">    4750 </span>            :   {
<span class="lineNum">    4751 </span><span class="lineCov">   68526324 :     m_open_loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;</span>
<span class="lineNum">    4752 </span><span class="lineCov">   34263162 :     return cp_parser_require (parser, traits_t::open_token_type,</span>
<span class="lineNum">    4753 </span><span class="lineNoCov">          0 :                               traits_t::required_token_open);</span>
<span class="lineNum">    4754 </span>            :   }
<span class="lineNum">    4755 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    4756 </span>            :   /* Consume the next token from PARSER, recording its location as
<a name="4757"><span class="lineNum">    4757 </span><span class="lineNoCov">          0 :      that of the opening token within the pair.  */</span></a>
<span class="lineNum">    4758 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    4759 </span><span class="lineNoCov">          0 :   cp_token * consume_open (cp_parser *parser)</span>
<span class="lineNum">    4760 </span>            :   {
<span class="lineNum">    4761 </span><span class="lineNoCov">          0 :     cp_token *tok = cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    4762 </span>            :     gcc_assert (tok-&gt;type == traits_t::open_token_type);
<span class="lineNum">    4763 </span><span class="lineNoCov">          0 :     m_open_loc = tok-&gt;location;</span>
<span class="lineNum">    4764 </span><span class="lineNoCov">          0 :     return tok;</span>
<span class="lineNum">    4765 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    4766 </span>            : 
<span class="lineNum">    4767 </span>            :   /* If the next token is the closing symbol for this pair, consume it
<span class="lineNum">    4768 </span>            :      and return it.
<span class="lineNum">    4769 </span>            :      Otherwise, issue an error, highlighting the location of the
<a name="4770"><span class="lineNum">    4770 </span>            :      corresponding opening token, and return NULL.  */</a>
<span class="lineNum">    4771 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    4772 </span>            :   cp_token *require_close (cp_parser *parser) const
<span class="lineNum">    4773 </span><span class="lineNoCov">          0 :   {</span>
<span class="lineNum">    4774 </span><span class="lineNoCov">          0 :     return cp_parser_require (parser, traits_t::close_token_type,</span>
<span class="lineNum">    4775 </span><span class="lineNoCov">          0 :                               traits_t::required_token_close,</span>
<span class="lineNum">    4776 </span><span class="lineNoCov">          0 :                               m_open_loc);</span>
<span class="lineNum">    4777 </span>            :   }
<span class="lineNum">    4778 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    4779 </span>            :  private:
<span class="lineNum">    4780 </span><span class="lineNoCov">          0 :   location_t m_open_loc;</span>
<span class="lineNum">    4781 </span><span class="lineNoCov">          0 : };</span>
<span class="lineNum">    4782 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    4783 </span><span class="lineNoCov">          0 : /* Traits for token_pair&lt;T&gt; for tracking matching pairs of parentheses.  */</span>
<span class="lineNum">    4784 </span>            : 
<span class="lineNum">    4785 </span><span class="lineNoCov">          0 : struct matching_paren_traits</span>
<span class="lineNum">    4786 </span>            : {
<span class="lineNum">    4787 </span><span class="lineNoCov">          0 :   static const enum cpp_ttype open_token_type = CPP_OPEN_PAREN;</span>
<span class="lineNum">    4788 </span><span class="lineNoCov">          0 :   static const enum required_token required_token_open  = RT_OPEN_PAREN;</span>
<span class="lineNum">    4789 </span><span class="lineNoCov">          0 :   static const enum cpp_ttype close_token_type = CPP_CLOSE_PAREN;</span>
<span class="lineNum">    4790 </span><span class="lineNoCov">          0 :   static const enum required_token required_token_close = RT_CLOSE_PAREN;</span>
<span class="lineNum">    4791 </span>            : };
<span class="lineNum">    4792 </span>            : 
<span class="lineNum">    4793 </span>            : /* &quot;matching_parens&quot; is a token_pair&lt;T&gt; class for tracking matching
<span class="lineNum">    4794 </span>            :    pairs of parentheses.  */
<span class="lineNum">    4795 </span>            : 
<span class="lineNum">    4796 </span>            : typedef token_pair&lt;matching_paren_traits&gt; matching_parens;
<span class="lineNum">    4797 </span>            : 
<span class="lineNum">    4798 </span><span class="lineNoCov">          0 : /* Traits for token_pair&lt;T&gt; for tracking matching pairs of braces.  */</span>
<span class="lineNum">    4799 </span>            : 
<span class="lineNum">    4800 </span><span class="lineCov">   51902865 : struct matching_brace_traits</span>
<span class="lineNum">    4801 </span>            : {
<span class="lineNum">    4802 </span><span class="lineNoCov">          0 :   static const enum cpp_ttype open_token_type = CPP_OPEN_BRACE;</span>
<span class="lineNum">    4803 </span>            :   static const enum required_token required_token_open = RT_OPEN_BRACE;
<span class="lineNum">    4804 </span><span class="lineNoCov">          0 :   static const enum cpp_ttype close_token_type = CPP_CLOSE_BRACE;</span>
<span class="lineNum">    4805 </span>            :   static const enum required_token required_token_close = RT_CLOSE_BRACE;
<span class="lineNum">    4806 </span><span class="lineNoCov">          0 : };</span>
<span class="lineNum">    4807 </span>            : 
<span class="lineNum">    4808 </span><span class="lineNoCov">          0 : /* &quot;matching_braces&quot; is a token_pair&lt;T&gt; class for tracking matching</span>
<span class="lineNum">    4809 </span>            :    pairs of braces.  */
<span class="lineNum">    4810 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    4811 </span>            : typedef token_pair&lt;matching_brace_traits&gt; matching_braces;
<span class="lineNum">    4812 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    4813 </span>            : 
<span class="lineNum">    4814 </span><span class="lineNoCov">          0 : /* Parse a GNU statement-expression, i.e. ({ stmts }), except for the</span>
<span class="lineNum">    4815 </span>            :    enclosing parentheses.  */
<a name="4816"><span class="lineNum">    4816 </span>            : </a>
<span class="lineNum">    4817 </span>            : static cp_expr
<span class="lineNum">    4818 </span>            : cp_parser_statement_expr (cp_parser *parser)
<span class="lineNum">    4819 </span>            : {
<span class="lineNum">    4820 </span>            :   cp_token_position start = cp_parser_start_tentative_firewall (parser);
<span class="lineNum">    4821 </span>            : 
<span class="lineNum">    4822 </span>            :   /* Consume the '('.  */
<span class="lineNum">    4823 </span>            :   location_t start_loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">    4824 </span>            :   matching_parens parens;
<span class="lineNum">    4825 </span>            :   parens.consume_open (parser);
<span class="lineNum">    4826 </span>            :   /* Start the statement-expression.  */
<span class="lineNum">    4827 </span>            :   tree expr = begin_stmt_expr ();
<span class="lineNum">    4828 </span>            :   /* Parse the compound-statement.  */
<span class="lineNum">    4829 </span>            :   cp_parser_compound_statement (parser, expr, BCS_NORMAL, false);
<span class="lineNum">    4830 </span>            :   /* Finish up.  */
<span class="lineNum">    4831 </span>            :   expr = finish_stmt_expr (expr, false);
<span class="lineNum">    4832 </span>            :   /* Consume the ')'.  */
<span class="lineNum">    4833 </span>            :   location_t finish_loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">    4834 </span>            :   if (!parens.require_close (parser))
<span class="lineNum">    4835 </span>            :     cp_parser_skip_to_end_of_statement (parser);
<span class="lineNum">    4836 </span>            : 
<span class="lineNum">    4837 </span>            :   cp_parser_end_tentative_firewall (parser, start, expr);
<span class="lineNum">    4838 </span>            :   location_t combined_loc = make_location (start_loc, start_loc, finish_loc);
<span class="lineNum">    4839 </span>            :   return cp_expr (expr, combined_loc);
<span class="lineNum">    4840 </span>            : }
<span class="lineNum">    4841 </span>            : 
<span class="lineNum">    4842 </span>            : /* Expressions [gram.expr] */
<span class="lineNum">    4843 </span>            : 
<span class="lineNum">    4844 </span>            : /* Parse a fold-operator.
<span class="lineNum">    4845 </span>            : 
<span class="lineNum">    4846 </span>            :     fold-operator:
<span class="lineNum">    4847 </span>            :         -  *  /  %  ^  &amp;  |  =  &lt;  &gt;  &lt;&lt;  &gt;&gt;
<span class="lineNum">    4848 </span>            :       =  -=  *=  /=  %=  ^=  &amp;=  |=  &lt;&lt;=  &gt;&gt;=
<span class="lineNum">    4849 </span>            :       ==  !=  &lt;=  &gt;=  &amp;&amp;  ||  ,  .*  -&gt;*
<span class="lineNum">    4850 </span>            : 
<span class="lineNum">    4851 </span>            :    This returns the tree code corresponding to the matched operator
<span class="lineNum">    4852 </span>            :    as an int. When the current token matches a compound assignment
<span class="lineNum">    4853 </span>            :    opertor, the resulting tree code is the negative value of the
<span class="lineNum">    4854 </span>            :    non-assignment operator. */
<a name="4855"><span class="lineNum">    4855 </span>            : </a>
<span class="lineNum">    4856 </span><span class="lineCov">      18232 : static int</span>
<span class="lineNum">    4857 </span>            : cp_parser_fold_operator (cp_token *token)
<span class="lineNum">    4858 </span><span class="lineCov">      18232 : {</span>
<span class="lineNum">    4859 </span>            :   switch (token-&gt;type)
<span class="lineNum">    4860 </span>            :     {
<span class="lineNum">    4861 </span><span class="lineCov">      36464 :     case CPP_PLUS: return PLUS_EXPR;</span>
<span class="lineNum">    4862 </span><span class="lineCov">      36464 :     case CPP_MINUS: return MINUS_EXPR;</span>
<span class="lineNum">    4863 </span><span class="lineCov">      18232 :     case CPP_MULT: return MULT_EXPR;</span>
<span class="lineNum">    4864 </span>            :     case CPP_DIV: return TRUNC_DIV_EXPR;
<span class="lineNum">    4865 </span><span class="lineCov">      18232 :     case CPP_MOD: return TRUNC_MOD_EXPR;</span>
<span class="lineNum">    4866 </span>            :     case CPP_XOR: return BIT_XOR_EXPR;
<span class="lineNum">    4867 </span><span class="lineCov">      18232 :     case CPP_AND: return BIT_AND_EXPR;</span>
<span class="lineNum">    4868 </span>            :     case CPP_OR: return BIT_IOR_EXPR;
<span class="lineNum">    4869 </span><span class="lineCov">      18232 :     case CPP_LSHIFT: return LSHIFT_EXPR;</span>
<span class="lineNum">    4870 </span>            :     case CPP_RSHIFT: return RSHIFT_EXPR;
<span class="lineNum">    4871 </span><span class="lineCov">      36464 : </span>
<span class="lineNum">    4872 </span><span class="lineCov">      18232 :     case CPP_EQ: return -NOP_EXPR;</span>
<span class="lineNum">    4873 </span><span class="lineNoCov">          0 :     case CPP_PLUS_EQ: return -PLUS_EXPR;</span>
<span class="lineNum">    4874 </span>            :     case CPP_MINUS_EQ: return -MINUS_EXPR;
<span class="lineNum">    4875 </span><span class="lineCov">      18232 :     case CPP_MULT_EQ: return -MULT_EXPR;</span>
<span class="lineNum">    4876 </span><span class="lineCov">      18232 :     case CPP_DIV_EQ: return -TRUNC_DIV_EXPR;</span>
<span class="lineNum">    4877 </span><span class="lineCov">      18232 :     case CPP_MOD_EQ: return -TRUNC_MOD_EXPR;</span>
<span class="lineNum">    4878 </span>            :     case CPP_XOR_EQ: return -BIT_XOR_EXPR;
<span class="lineNum">    4879 </span>            :     case CPP_AND_EQ: return -BIT_AND_EXPR;
<span class="lineNum">    4880 </span>            :     case CPP_OR_EQ: return -BIT_IOR_EXPR;
<span class="lineNum">    4881 </span>            :     case CPP_LSHIFT_EQ: return -LSHIFT_EXPR;
<span class="lineNum">    4882 </span>            :     case CPP_RSHIFT_EQ: return -RSHIFT_EXPR;
<span class="lineNum">    4883 </span>            : 
<span class="lineNum">    4884 </span>            :     case CPP_EQ_EQ: return EQ_EXPR;
<span class="lineNum">    4885 </span>            :     case CPP_NOT_EQ: return NE_EXPR;
<span class="lineNum">    4886 </span>            :     case CPP_LESS: return LT_EXPR;
<span class="lineNum">    4887 </span>            :     case CPP_GREATER: return GT_EXPR;
<span class="lineNum">    4888 </span>            :     case CPP_LESS_EQ: return LE_EXPR;
<span class="lineNum">    4889 </span>            :     case CPP_GREATER_EQ: return GE_EXPR;
<span class="lineNum">    4890 </span>            : 
<span class="lineNum">    4891 </span>            :     case CPP_AND_AND: return TRUTH_ANDIF_EXPR;
<span class="lineNum">    4892 </span>            :     case CPP_OR_OR: return TRUTH_ORIF_EXPR;
<span class="lineNum">    4893 </span>            : 
<span class="lineNum">    4894 </span>            :     case CPP_COMMA: return COMPOUND_EXPR;
<span class="lineNum">    4895 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    4896 </span>            :     case CPP_DOT_STAR: return DOTSTAR_EXPR;
<span class="lineNum">    4897 </span><span class="lineNoCov">          0 :     case CPP_DEREF_STAR: return MEMBER_REF;</span>
<span class="lineNum">    4898 </span>            : 
<span class="lineNum">    4899 </span>            :     default: return ERROR_MARK;
<span class="lineNum">    4900 </span>            :     }
<span class="lineNum">    4901 </span>            : }
<span class="lineNum">    4902 </span>            : 
<span class="lineNum">    4903 </span>            : /* Returns true if CODE indicates a binary expression, which is not allowed in
<span class="lineNum">    4904 </span>            :    the LHS of a fold-expression.  More codes will need to be added to use this
<span class="lineNum">    4905 </span>            :    function in other contexts.  */
<a name="4906"><span class="lineNum">    4906 </span>            : </a>
<span class="lineNum">    4907 </span>            : static bool
<span class="lineNum">    4908 </span>            : is_binary_op (tree_code code)
<span class="lineNum">    4909 </span>            : {
<span class="lineNum">    4910 </span>            :   switch (code)
<span class="lineNum">    4911 </span>            :     {
<span class="lineNum">    4912 </span>            :     case PLUS_EXPR:
<span class="lineNum">    4913 </span>            :     case POINTER_PLUS_EXPR:
<span class="lineNum">    4914 </span>            :     case MINUS_EXPR:
<span class="lineNum">    4915 </span>            :     case MULT_EXPR:
<span class="lineNum">    4916 </span>            :     case TRUNC_DIV_EXPR:
<span class="lineNum">    4917 </span>            :     case TRUNC_MOD_EXPR:
<span class="lineNum">    4918 </span>            :     case BIT_XOR_EXPR:
<span class="lineNum">    4919 </span>            :     case BIT_AND_EXPR:
<span class="lineNum">    4920 </span>            :     case BIT_IOR_EXPR:
<span class="lineNum">    4921 </span>            :     case LSHIFT_EXPR:
<span class="lineNum">    4922 </span>            :     case RSHIFT_EXPR:
<span class="lineNum">    4923 </span>            : 
<span class="lineNum">    4924 </span>            :     case MODOP_EXPR:
<span class="lineNum">    4925 </span>            : 
<span class="lineNum">    4926 </span>            :     case EQ_EXPR:
<span class="lineNum">    4927 </span>            :     case NE_EXPR:
<span class="lineNum">    4928 </span>            :     case LE_EXPR:
<span class="lineNum">    4929 </span>            :     case GE_EXPR:
<span class="lineNum">    4930 </span>            :     case LT_EXPR:
<span class="lineNum">    4931 </span>            :     case GT_EXPR:
<span class="lineNum">    4932 </span>            : 
<span class="lineNum">    4933 </span>            :     case TRUTH_ANDIF_EXPR:
<span class="lineNum">    4934 </span>            :     case TRUTH_ORIF_EXPR:
<span class="lineNum">    4935 </span>            : 
<span class="lineNum">    4936 </span>            :     case COMPOUND_EXPR:
<span class="lineNum">    4937 </span>            : 
<span class="lineNum">    4938 </span>            :     case DOTSTAR_EXPR:
<span class="lineNum">    4939 </span>            :     case MEMBER_REF:
<span class="lineNum">    4940 </span>            :       return true;
<span class="lineNum">    4941 </span>            : 
<span class="lineNum">    4942 </span>            :     default:
<span class="lineNum">    4943 </span>            :       return false;
<span class="lineNum">    4944 </span>            :     }
<span class="lineNum">    4945 </span>            : }
<span class="lineNum">    4946 </span><span class="lineCov">       1029 : </span>
<span class="lineNum">    4947 </span>            : /* If the next token is a suitable fold operator, consume it and return as
<span class="lineNum">    4948 </span><span class="lineCov">       1029 :    the function above.  */</span>
<a name="4949"><span class="lineNum">    4949 </span>            : </a>
<span class="lineNum">    4950 </span>            : static int
<span class="lineNum">    4951 </span>            : cp_parser_fold_operator (cp_parser *parser)
<span class="lineNum">    4952 </span>            : {
<span class="lineNum">    4953 </span>            :   cp_token* token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">    4954 </span>            :   int code = cp_parser_fold_operator (token);
<span class="lineNum">    4955 </span>            :   if (code != ERROR_MARK)
<span class="lineNum">    4956 </span>            :     cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">    4957 </span>            :   return code;
<span class="lineNum">    4958 </span>            : }
<span class="lineNum">    4959 </span>            : 
<span class="lineNum">    4960 </span>            : /* Parse a fold-expression.
<span class="lineNum">    4961 </span>            : 
<span class="lineNum">    4962 </span>            :      fold-expression:
<span class="lineNum">    4963 </span>            :        ( ... folding-operator cast-expression)
<span class="lineNum">    4964 </span>            :        ( cast-expression folding-operator ... )
<span class="lineNum">    4965 </span>            :        ( cast-expression folding operator ... folding-operator cast-expression)
<span class="lineNum">    4966 </span>            : 
<span class="lineNum">    4967 </span>            :    Note that the '(' and ')' are matched in primary expression. */
<a name="4968"><span class="lineNum">    4968 </span>            : </a>
<span class="lineNum">    4969 </span>            : static cp_expr
<span class="lineNum">    4970 </span>            : cp_parser_fold_expression (cp_parser *parser, tree expr1)
<span class="lineNum">    4971 </span>            : {
<span class="lineNum">    4972 </span>            :   cp_id_kind pidk;
<span class="lineNum">    4973 </span>            : 
<span class="lineNum">    4974 </span>            :   // Left fold.
<span class="lineNum">    4975 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_ELLIPSIS))
<span class="lineNum">    4976 </span>            :     {
<span class="lineNum">    4977 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">    4978 </span>            :       int op = cp_parser_fold_operator (parser);
<span class="lineNum">    4979 </span>            :       if (op == ERROR_MARK)
<span class="lineNum">    4980 </span><span class="lineCov">        999 :         {</span>
<span class="lineNum">    4981 </span><span class="lineCov">        999 :           cp_parser_error (parser, &quot;expected binary operator&quot;);</span>
<span class="lineNum">    4982 </span>            :           return error_mark_node;
<span class="lineNum">    4983 </span>            :         }
<span class="lineNum">    4984 </span>            : 
<span class="lineNum">    4985 </span>            :       tree expr = cp_parser_cast_expression (parser, false, false,
<span class="lineNum">    4986 </span>            :                                              false, &amp;pidk);
<span class="lineNum">    4987 </span>            :       if (expr == error_mark_node)
<span class="lineNum">    4988 </span>            :         return error_mark_node;
<span class="lineNum">    4989 </span><span class="lineNoCov">          0 :       return finish_left_unary_fold_expr (expr, op);</span>
<span class="lineNum">    4990 </span>            :     }
<span class="lineNum">    4991 </span><span class="lineCov">       2210 : </span>
<span class="lineNum">    4992 </span><span class="lineNoCov">          0 :   const cp_token* token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">    4993 </span><span class="lineCov">       1105 :   int op = cp_parser_fold_operator (parser);</span>
<span class="lineNum">    4994 </span><span class="lineCov">       1103 :   if (op == ERROR_MARK)</span>
<span class="lineNum">    4995 </span><span class="lineCov">       1105 :     {</span>
<span class="lineNum">    4996 </span>            :       cp_parser_error (parser, &quot;expected binary operator&quot;);
<span class="lineNum">    4997 </span>            :       return error_mark_node;
<span class="lineNum">    4998 </span>            :     }
<span class="lineNum">    4999 </span>            : 
<span class="lineNum">    5000 </span>            :   if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_ELLIPSIS))
<span class="lineNum">    5001 </span>            :     {
<span class="lineNum">    5002 </span>            :       cp_parser_error (parser, &quot;expected ...&quot;);
<span class="lineNum">    5003 </span>            :       return error_mark_node;
<span class="lineNum">    5004 </span>            :     }
<span class="lineNum">    5005 </span>            :   cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">    5006 </span>            : 
<span class="lineNum">    5007 </span>            :   /* The operands of a fold-expression are cast-expressions, so binary or
<span class="lineNum">    5008 </span><span class="lineCov">       1105 :      conditional expressions are not allowed.  We check this here to avoid</span>
<span class="lineNum">    5009 </span>            :      tentative parsing.  */
<span class="lineNum">    5010 </span><span class="lineCov">       1105 :   if (EXPR_P (expr1) &amp;&amp; TREE_NO_WARNING (expr1))</span>
<span class="lineNum">    5011 </span>            :     /* OK, the expression was parenthesized.  */;
<span class="lineNum">    5012 </span>            :   else if (is_binary_op (TREE_CODE (expr1)))
<span class="lineNum">    5013 </span><span class="lineCov">       1105 :     error_at (location_of (expr1),</span>
<span class="lineNum">    5014 </span>            :               &quot;binary expression in operand of fold-expression&quot;);
<span class="lineNum">    5015 </span><span class="lineCov">         75 :   else if (TREE_CODE (expr1) == COND_EXPR</span>
<span class="lineNum">    5016 </span><span class="lineCov">         75 :            || (REFERENCE_REF_P (expr1)</span>
<span class="lineNum">    5017 </span><span class="lineCov">         75 :                &amp;&amp; TREE_CODE (TREE_OPERAND (expr1, 0)) == COND_EXPR))</span>
<span class="lineNum">    5018 </span>            :     error_at (location_of (expr1),
<span class="lineNum">    5019 </span><span class="lineCov">          2 :               &quot;conditional expression in operand of fold-expression&quot;);</span>
<span class="lineNum">    5020 </span><span class="lineCov">          2 : </span>
<span class="lineNum">    5021 </span>            :   // Right fold.
<span class="lineNum">    5022 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_CLOSE_PAREN))
<span class="lineNum">    5023 </span><span class="lineCov">        146 :     return finish_right_unary_fold_expr (expr1, op);</span>
<span class="lineNum">    5024 </span><span class="lineCov">         73 : </span>
<span class="lineNum">    5025 </span><span class="lineCov">         73 :   if (cp_lexer_next_token_is_not (parser-&gt;lexer, token-&gt;type))</span>
<span class="lineNum">    5026 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">    5027 </span><span class="lineCov">         73 :       cp_parser_error (parser, &quot;mismatched operator in fold-expression&quot;);</span>
<span class="lineNum">    5028 </span>            :       return error_mark_node;
<span class="lineNum">    5029 </span>            :     }
<span class="lineNum">    5030 </span><span class="lineCov">       2060 :   cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    5031 </span><span class="lineCov">       1030 : </span>
<span class="lineNum">    5032 </span><span class="lineCov">       1030 :   // Binary left or right fold.</span>
<span class="lineNum">    5033 </span>            :   tree expr2 = cp_parser_cast_expression (parser, false, false, false, &amp;pidk);
<span class="lineNum">    5034 </span><span class="lineNoCov">          0 :   if (expr2 == error_mark_node)</span>
<span class="lineNum">    5035 </span><span class="lineNoCov">          0 :     return error_mark_node;</span>
<span class="lineNum">    5036 </span>            :   return finish_binary_fold_expr (expr1, expr2, op);
<span class="lineNum">    5037 </span>            : }
<span class="lineNum">    5038 </span><span class="lineCov">       1030 : </span>
<span class="lineNum">    5039 </span>            : /* Parse a primary-expression.
<span class="lineNum">    5040 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    5041 </span><span class="lineNoCov">          0 :    primary-expression:</span>
<span class="lineNum">    5042 </span>            :      literal
<span class="lineNum">    5043 </span><span class="lineCov">       1030 :      this</span>
<span class="lineNum">    5044 </span>            :      ( expression )
<span class="lineNum">    5045 </span>            :      id-expression
<span class="lineNum">    5046 </span>            :      lambda-expression (C++11)
<span class="lineNum">    5047 </span>            : 
<span class="lineNum">    5048 </span><span class="lineCov">       1030 :    GNU Extensions:</span>
<span class="lineNum">    5049 </span>            : 
<span class="lineNum">    5050 </span><span class="lineCov">       1029 :    primary-expression:</span>
<span class="lineNum">    5051 </span><span class="lineCov">         30 :      ( compound-statement )</span>
<span class="lineNum">    5052 </span>            :      __builtin_va_arg ( assignment-expression , type-id )
<span class="lineNum">    5053 </span><span class="lineCov">        999 :      __builtin_offsetof ( type-id , offsetof-expression )</span>
<span class="lineNum">    5054 </span><span class="lineCov">        999 : </span>
<span class="lineNum">    5055 </span><span class="lineNoCov">          0 :    C++ Extensions:</span>
<span class="lineNum">    5056 </span><span class="lineCov">          1 :      __has_nothrow_assign ( type-id )   </span>
<span class="lineNum">    5057 </span>            :      __has_nothrow_constructor ( type-id )
<span class="lineNum">    5058 </span>            :      __has_nothrow_copy ( type-id )
<span class="lineNum">    5059 </span>            :      __has_trivial_assign ( type-id )   
<span class="lineNum">    5060 </span><span class="lineCov">       1030 :      __has_trivial_constructor ( type-id )</span>
<span class="lineNum">    5061 </span><span class="lineCov">        958 :      __has_trivial_copy ( type-id )</span>
<span class="lineNum">    5062 </span>            :      __has_trivial_destructor ( type-id )
<span class="lineNum">    5063 </span><span class="lineCov">         72 :      __has_virtual_destructor ( type-id )     </span>
<span class="lineNum">    5064 </span>            :      __is_abstract ( type-id )
<span class="lineNum">    5065 </span><span class="lineNoCov">          0 :      __is_base_of ( type-id , type-id )</span>
<span class="lineNum">    5066 </span><span class="lineNoCov">          0 :      __is_class ( type-id )</span>
<span class="lineNum">    5067 </span>            :      __is_empty ( type-id )
<span class="lineNum">    5068 </span><span class="lineCov">         72 :      __is_enum ( type-id )</span>
<span class="lineNum">    5069 </span>            :      __is_final ( type-id )
<span class="lineNum">    5070 </span>            :      __is_literal_type ( type-id )
<span class="lineNum">    5071 </span><span class="lineCov">         72 :      __is_pod ( type-id )</span>
<span class="lineNum">    5072 </span><span class="lineCov">         72 :      __is_polymorphic ( type-id )</span>
<span class="lineNum">    5073 </span><span class="lineNoCov">          0 :      __is_std_layout ( type-id )</span>
<span class="lineNum">    5074 </span><span class="lineCov">         72 :      __is_trivial ( type-id )</span>
<span class="lineNum">    5075 </span>            :      __is_union ( type-id )
<span class="lineNum">    5076 </span>            : 
<span class="lineNum">    5077 </span>            :    Objective-C++ Extension:
<span class="lineNum">    5078 </span>            : 
<span class="lineNum">    5079 </span>            :    primary-expression:
<span class="lineNum">    5080 </span>            :      objc-expression
<span class="lineNum">    5081 </span>            : 
<span class="lineNum">    5082 </span>            :    literal:
<span class="lineNum">    5083 </span>            :      __null
<span class="lineNum">    5084 </span>            : 
<span class="lineNum">    5085 </span>            :    ADDRESS_P is true iff this expression was immediately preceded by
<span class="lineNum">    5086 </span>            :    &quot;&amp;&quot; and therefore might denote a pointer-to-member.  CAST_P is true
<span class="lineNum">    5087 </span>            :    iff this expression is the target of a cast.  TEMPLATE_ARG_P is
<span class="lineNum">    5088 </span>            :    true iff this expression is a template argument.
<span class="lineNum">    5089 </span>            : 
<span class="lineNum">    5090 </span>            :    Returns a representation of the expression.  Upon return, *IDK
<span class="lineNum">    5091 </span>            :    indicates what kind of id-expression (if any) was present.  */
<a name="5092"><span class="lineNum">    5092 </span>            : </a>
<span class="lineNum">    5093 </span>            : static cp_expr
<span class="lineNum">    5094 </span>            : cp_parser_primary_expression (cp_parser *parser,
<span class="lineNum">    5095 </span>            :                               bool address_p,
<span class="lineNum">    5096 </span>            :                               bool cast_p,
<span class="lineNum">    5097 </span>            :                               bool template_arg_p,
<span class="lineNum">    5098 </span>            :                               bool decltype_p,
<span class="lineNum">    5099 </span>            :                               cp_id_kind *idk)
<span class="lineNum">    5100 </span>            : {
<span class="lineNum">    5101 </span>            :   cp_token *token = NULL;
<span class="lineNum">    5102 </span>            : 
<span class="lineNum">    5103 </span>            :   /* Assume the primary expression is not an id-expression.  */
<span class="lineNum">    5104 </span>            :   *idk = CP_ID_KIND_NONE;
<span class="lineNum">    5105 </span>            : 
<span class="lineNum">    5106 </span>            :   /* Peek at the next token.  */
<span class="lineNum">    5107 </span>            :   token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">    5108 </span>            :   switch ((int) token-&gt;type)
<span class="lineNum">    5109 </span>            :     {
<span class="lineNum">    5110 </span>            :       /* literal:
<span class="lineNum">    5111 </span>            :            integer-literal
<span class="lineNum">    5112 </span>            :            character-literal
<span class="lineNum">    5113 </span>            :            floating-literal
<span class="lineNum">    5114 </span>            :            string-literal
<span class="lineNum">    5115 </span>            :            boolean-literal
<span class="lineNum">    5116 </span>            :            pointer-literal
<span class="lineNum">    5117 </span>            :            user-defined-literal  */
<span class="lineNum">    5118 </span>            :     case CPP_CHAR:
<span class="lineNum">    5119 </span>            :     case CPP_CHAR16:
<span class="lineNum">    5120 </span>            :     case CPP_CHAR32:
<span class="lineNum">    5121 </span>            :     case CPP_WCHAR:
<span class="lineNum">    5122 </span>            :     case CPP_UTF8CHAR:
<span class="lineNum">    5123 </span>            :     case CPP_NUMBER:
<span class="lineNum">    5124 </span>            :     case CPP_PREPARSED_EXPR:
<span class="lineNum">    5125 </span>            :       if (TREE_CODE (token-&gt;u.value) == USERDEF_LITERAL)
<span class="lineNum">    5126 </span>            :         return cp_parser_userdef_numeric_literal (parser);
<span class="lineNum">    5127 </span>            :       token = cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">    5128 </span>            :       if (TREE_CODE (token-&gt;u.value) == FIXED_CST)
<span class="lineNum">    5129 </span>            :         {
<span class="lineNum">    5130 </span>            :           error_at (token-&gt;location,
<span class="lineNum">    5131 </span>            :                     &quot;fixed-point types not supported in C++&quot;);
<span class="lineNum">    5132 </span><span class="lineCov">   45094624 :           return error_mark_node;</span>
<span class="lineNum">    5133 </span>            :         }
<span class="lineNum">    5134 </span>            :       /* Floating-point literals are only allowed in an integral
<span class="lineNum">    5135 </span>            :          constant expression if they are cast to an integral or
<span class="lineNum">    5136 </span>            :          enumeration type.  */
<span class="lineNum">    5137 </span>            :       if (TREE_CODE (token-&gt;u.value) == REAL_CST
<span class="lineNum">    5138 </span>            :           &amp;&amp; parser-&gt;integral_constant_expression_p
<span class="lineNum">    5139 </span><span class="lineCov">   45094624 :           &amp;&amp; pedantic)</span>
<span class="lineNum">    5140 </span>            :         {
<span class="lineNum">    5141 </span>            :           /* CAST_P will be set even in invalid code like &quot;int(2.7 +
<span class="lineNum">    5142 </span><span class="lineCov">   45094624 :              ...)&quot;.   Therefore, we have to check that the next token</span>
<span class="lineNum">    5143 </span>            :              is sure to end the cast.  */
<span class="lineNum">    5144 </span>            :           if (cast_p)
<span class="lineNum">    5145 </span><span class="lineCov">   90189248 :             {</span>
<span class="lineNum">    5146 </span><span class="lineCov">   45094624 :               cp_token *next_token;</span>
<span class="lineNum">    5147 </span>            : 
<span class="lineNum">    5148 </span>            :               next_token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">    5149 </span>            :               if (/* The comma at the end of an
<span class="lineNum">    5150 </span>            :                      enumerator-definition.  */
<span class="lineNum">    5151 </span>            :                   next_token-&gt;type != CPP_COMMA
<span class="lineNum">    5152 </span>            :                   /* The curly brace at the end of an enum-specifier.  */
<span class="lineNum">    5153 </span>            :                   &amp;&amp; next_token-&gt;type != CPP_CLOSE_BRACE
<span class="lineNum">    5154 </span>            :                   /* The end of a statement.  */
<span class="lineNum">    5155 </span>            :                   &amp;&amp; next_token-&gt;type != CPP_SEMICOLON
<span class="lineNum">    5156 </span><span class="lineCov">    7330334 :                   /* The end of the cast-expression.  */</span>
<span class="lineNum">    5157 </span><span class="lineCov">    7330334 :                   &amp;&amp; next_token-&gt;type != CPP_CLOSE_PAREN</span>
<span class="lineNum">    5158 </span><span class="lineCov">    7330334 :                   /* The end of an array bound.  */</span>
<span class="lineNum">    5159 </span><span class="lineCov">    7330334 :                   &amp;&amp; next_token-&gt;type != CPP_CLOSE_SQUARE</span>
<span class="lineNum">    5160 </span><span class="lineCov">    7330334 :                   /* The closing &quot;&gt;&quot; in a template-argument-list.  */</span>
<span class="lineNum">    5161 </span><span class="lineCov">    7330334 :                   &amp;&amp; (next_token-&gt;type != CPP_GREATER</span>
<span class="lineNum">    5162 </span><span class="lineCov">    7330334 :                       || parser-&gt;greater_than_is_operator_p)</span>
<span class="lineNum">    5163 </span><span class="lineCov">    7330334 :                   /* C++0x only: A &quot;&gt;&gt;&quot; treated like two &quot;&gt;&quot; tokens,</span>
<span class="lineNum">    5164 </span><span class="lineCov">      31888 :                      in a template-argument-list.  */</span>
<span class="lineNum">    5165 </span><span class="lineCov">    7298446 :                   &amp;&amp; (next_token-&gt;type != CPP_RSHIFT</span>
<span class="lineNum">    5166 </span><span class="lineCov">    7298446 :                       || (cxx_dialect == cxx98)</span>
<span class="lineNum">    5167 </span>            :                       || parser-&gt;greater_than_is_operator_p))
<span class="lineNum">    5168 </span><span class="lineCov">         40 :                 cast_p = false;</span>
<span class="lineNum">    5169 </span>            :             }
<span class="lineNum">    5170 </span><span class="lineCov">         40 : </span>
<span class="lineNum">    5171 </span>            :           /* If we are within a cast, then the constraint that the
<span class="lineNum">    5172 </span>            :              cast is to an integral or enumeration type will be
<span class="lineNum">    5173 </span>            :              checked at that point.  If we are not within a cast, then
<span class="lineNum">    5174 </span>            :              this code is invalid.  */
<span class="lineNum">    5175 </span><span class="lineCov">    7298406 :           if (!cast_p)</span>
<span class="lineNum">    5176 </span><span class="lineCov">     363036 :             cp_parser_non_integral_constant_expression (parser, NIC_FLOAT);</span>
<span class="lineNum">    5177 </span><span class="lineCov">     241905 :         }</span>
<span class="lineNum">    5178 </span>            :       return cp_expr (token-&gt;u.value, token-&gt;location);
<span class="lineNum">    5179 </span>            : 
<span class="lineNum">    5180 </span>            :     case CPP_CHAR_USERDEF:
<span class="lineNum">    5181 </span>            :     case CPP_CHAR16_USERDEF:
<span class="lineNum">    5182 </span><span class="lineCov">       1788 :     case CPP_CHAR32_USERDEF:</span>
<span class="lineNum">    5183 </span>            :     case CPP_WCHAR_USERDEF:
<span class="lineNum">    5184 </span><span class="lineCov">        467 :     case CPP_UTF8CHAR_USERDEF:</span>
<span class="lineNum">    5185 </span>            :       return cp_parser_userdef_char_literal (parser);
<span class="lineNum">    5186 </span><span class="lineCov">        934 : </span>
<span class="lineNum">    5187 </span><span class="lineCov">        934 :     case CPP_STRING:</span>
<span class="lineNum">    5188 </span>            :     case CPP_STRING16:
<span class="lineNum">    5189 </span><span class="lineCov">        467 :     case CPP_STRING32:</span>
<span class="lineNum">    5190 </span>            :     case CPP_WSTRING:
<span class="lineNum">    5191 </span><span class="lineCov">        460 :     case CPP_UTF8STRING:</span>
<span class="lineNum">    5192 </span>            :     case CPP_STRING_USERDEF:
<span class="lineNum">    5193 </span><span class="lineCov">        459 :     case CPP_STRING16_USERDEF:</span>
<span class="lineNum">    5194 </span>            :     case CPP_STRING32_USERDEF:
<span class="lineNum">    5195 </span><span class="lineCov">        458 :     case CPP_WSTRING_USERDEF:</span>
<span class="lineNum">    5196 </span>            :     case CPP_UTF8STRING_USERDEF:
<span class="lineNum">    5197 </span><span class="lineCov">         11 :       /* ??? Should wide strings be allowed when parser-&gt;translate_strings_p</span>
<span class="lineNum">    5198 </span>            :          is false (i.e. in attributes)?  If not, we can kill the third
<span class="lineNum">    5199 </span><span class="lineCov">         10 :          argument to cp_parser_string_literal.  */</span>
<span class="lineNum">    5200 </span><span class="lineCov">          3 :       return cp_parser_string_literal (parser,</span>
<span class="lineNum">    5201 </span>            :                                        parser-&gt;translate_strings_p,
<span class="lineNum">    5202 </span>            :                                        true);
<span class="lineNum">    5203 </span><span class="lineCov">          7 : </span>
<span class="lineNum">    5204 </span><span class="lineNoCov">          0 :     case CPP_OPEN_PAREN:</span>
<span class="lineNum">    5205 </span><span class="lineNoCov">          0 :       /* If we see `( { ' then we are looking at the beginning of</span>
<span class="lineNum">    5206 </span>            :          a GNU statement-expression.  */
<span class="lineNum">    5207 </span>            :       if (cp_parser_allow_gnu_extensions_p (parser)
<span class="lineNum">    5208 </span>            :           &amp;&amp; cp_lexer_nth_token_is (parser-&gt;lexer, 2, CPP_OPEN_BRACE))
<span class="lineNum">    5209 </span>            :         {
<span class="lineNum">    5210 </span>            :           /* Statement-expressions are not allowed by the standard.  */
<span class="lineNum">    5211 </span>            :           pedwarn (token-&gt;location, OPT_Wpedantic,
<span class="lineNum">    5212 </span>            :                    &quot;ISO C++ forbids braced-groups within expressions&quot;);
<span class="lineNum">    5213 </span><span class="lineCov">       1781 : </span>
<span class="lineNum">    5214 </span><span class="lineCov">       1328 :           /* And they're not allowed outside of a function-body; you</span>
<span class="lineNum">    5215 </span>            :              cannot, for example, write:
<span class="lineNum">    5216 </span><span class="lineCov">    7298406 : </span>
<span class="lineNum">    5217 </span>            :              int i = ({ int j = 3; j + 1; });
<span class="lineNum">    5218 </span><span class="lineCov">         45 : </span>
<span class="lineNum">    5219 </span><span class="lineCov">         45 :              at class or namespace scope.  */</span>
<span class="lineNum">    5220 </span><span class="lineCov">         45 :           if (!parser-&gt;in_function_body</span>
<span class="lineNum">    5221 </span><span class="lineCov">         45 :               || parser-&gt;in_template_argument_list_p)</span>
<span class="lineNum">    5222 </span><span class="lineCov">         45 :             {</span>
<span class="lineNum">    5223 </span><span class="lineCov">         45 :               error_at (token-&gt;location,</span>
<span class="lineNum">    5224 </span>            :                         &quot;statement-expressions are not allowed outside &quot;
<span class="lineNum">    5225 </span><span class="lineCov">     797427 :                         &quot;functions nor in template-argument lists&quot;);</span>
<span class="lineNum">    5226 </span><span class="lineCov">     797427 :               cp_parser_skip_to_end_of_block_or_statement (parser);</span>
<span class="lineNum">    5227 </span><span class="lineCov">     797427 :               if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_CLOSE_PAREN))</span>
<span class="lineNum">    5228 </span><span class="lineCov">     797427 :                 cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    5229 </span><span class="lineCov">     797427 :               return error_mark_node;</span>
<span class="lineNum">    5230 </span><span class="lineCov">     797427 :             }</span>
<span class="lineNum">    5231 </span><span class="lineCov">     797427 :           else</span>
<span class="lineNum">    5232 </span><span class="lineCov">     797427 :             return cp_parser_statement_expr (parser);</span>
<span class="lineNum">    5233 </span><span class="lineCov">     797427 :         }</span>
<span class="lineNum">    5234 </span><span class="lineCov">     797427 :       /* Otherwise it's a normal parenthesized expression.  */</span>
<span class="lineNum">    5235 </span>            :       {
<span class="lineNum">    5236 </span>            :         cp_expr expr;
<span class="lineNum">    5237 </span>            :         bool saved_greater_than_is_operator_p;
<span class="lineNum">    5238 </span><span class="lineCov">     797427 : </span>
<span class="lineNum">    5239 </span><span class="lineCov">     797427 :         location_t open_paren_loc = token-&gt;location;</span>
<span class="lineNum">    5240 </span><span class="lineCov">     797427 : </span>
<span class="lineNum">    5241 </span>            :         /* Consume the `('.  */
<span class="lineNum">    5242 </span><span class="lineCov">    3203257 :         matching_parens parens;</span>
<span class="lineNum">    5243 </span>            :         parens.consume_open (parser);
<span class="lineNum">    5244 </span>            :         /* Within a parenthesized expression, a `&gt;' token is always
<span class="lineNum">    5245 </span><span class="lineCov">    6406514 :            the greater-than operator.  */</span>
<span class="lineNum">    5246 </span><span class="lineCov">    3203257 :         saved_greater_than_is_operator_p</span>
<span class="lineNum">    5247 </span>            :           = parser-&gt;greater_than_is_operator_p;
<span class="lineNum">    5248 </span>            :         parser-&gt;greater_than_is_operator_p = true;
<span class="lineNum">    5249 </span><span class="lineCov">      18238 : </span>
<span class="lineNum">    5250 </span>            :         if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_ELLIPSIS))
<span class="lineNum">    5251 </span>            :           /* Left fold expression. */
<span class="lineNum">    5252 </span>            :           expr = NULL_TREE;
<span class="lineNum">    5253 </span>            :         else
<span class="lineNum">    5254 </span>            :           /* Parse the parenthesized expression.  */
<span class="lineNum">    5255 </span>            :           expr = cp_parser_expression (parser, idk, cast_p, decltype_p);
<span class="lineNum">    5256 </span>            : 
<span class="lineNum">    5257 </span>            :         token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">    5258 </span><span class="lineCov">      18238 :         if (token-&gt;type == CPP_ELLIPSIS || cp_parser_fold_operator (token))</span>
<span class="lineNum">    5259 </span><span class="lineCov">      18235 :           {</span>
<span class="lineNum">    5260 </span>            :             expr = cp_parser_fold_expression (parser, expr);
<span class="lineNum">    5261 </span><span class="lineCov">          6 :             if (expr != error_mark_node</span>
<span class="lineNum">    5262 </span>            :                 &amp;&amp; cxx_dialect &lt; cxx17
<span class="lineNum">    5263 </span>            :                 &amp;&amp; !in_system_header_at (input_location))
<span class="lineNum">    5264 </span><span class="lineCov">          6 :               pedwarn (input_location, 0, &quot;fold-expressions only available &quot;</span>
<span class="lineNum">    5265 </span><span class="lineCov">          6 :                        &quot;with -std=c++17 or -std=gnu++17&quot;);</span>
<span class="lineNum">    5266 </span><span class="lineCov">          6 :           }</span>
<span class="lineNum">    5267 </span><span class="lineCov">          6 :         else</span>
<span class="lineNum">    5268 </span>            :           /* Let the front end know that this expression was
<span class="lineNum">    5269 </span>            :              enclosed in parentheses. This matters in case, for
<span class="lineNum">    5270 </span><span class="lineCov">      18232 :              example, the expression is of the form `A::B', since</span>
<span class="lineNum">    5271 </span>            :              `&amp;A::B' might be a pointer-to-member, but `&amp;(A::B)' is
<span class="lineNum">    5272 </span>            :              not.  */
<span class="lineNum">    5273 </span><span class="lineCov">    3185019 :           expr = finish_parenthesized_expr (expr);</span>
<span class="lineNum">    5274 </span><span class="lineCov">    3185019 : </span>
<span class="lineNum">    5275 </span><span class="lineCov">    3185019 :         /* DR 705: Wrapping an unqualified name in parentheses</span>
<span class="lineNum">    5276 </span>            :            suppresses arg-dependent lookup.  We want to pass back
<span class="lineNum">    5277 </span><span class="lineCov">    3185019 :            CP_ID_KIND_QUALIFIED for suppressing vtable lookup</span>
<span class="lineNum">    5278 </span>            :            (c++/37862), but none of the others.  */
<span class="lineNum">    5279 </span>            :         if (*idk != CP_ID_KIND_QUALIFIED)
<span class="lineNum">    5280 </span><span class="lineCov">    6370038 :           *idk = CP_ID_KIND_NONE;</span>
<span class="lineNum">    5281 </span><span class="lineCov">    3185019 : </span>
<span class="lineNum">    5282 </span>            :         /* The `&gt;' token might be the end of a template-id or
<span class="lineNum">    5283 </span>            :            template-parameter-list now.  */
<span class="lineNum">    5284 </span><span class="lineCov">    3185019 :         parser-&gt;greater_than_is_operator_p</span>
<span class="lineNum">    5285 </span><span class="lineCov">    3185019 :           = saved_greater_than_is_operator_p;</span>
<span class="lineNum">    5286 </span><span class="lineCov">    3185019 : </span>
<span class="lineNum">    5287 </span>            :         /* Consume the `)'.  */
<span class="lineNum">    5288 </span><span class="lineCov">    3185019 :         token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">    5289 </span>            :         location_t close_paren_loc = token-&gt;location;
<span class="lineNum">    5290 </span><span class="lineCov">         73 :         expr.set_range (open_paren_loc, close_paren_loc);</span>
<span class="lineNum">    5291 </span>            :         if (!parens.require_close (parser)
<span class="lineNum">    5292 </span>            :             &amp;&amp; !cp_parser_uncommitted_to_tentative_parse_p (parser))
<span class="lineNum">    5293 </span><span class="lineCov">    3184946 :           cp_parser_skip_to_end_of_statement (parser);</span>
<span class="lineNum">    5294 </span>            : 
<span class="lineNum">    5295 </span><span class="lineCov">    6370038 :         return expr;</span>
<span class="lineNum">    5296 </span><span class="lineCov">    3185019 :       }</span>
<span class="lineNum">    5297 </span>            : 
<span class="lineNum">    5298 </span><span class="lineCov">       2210 :     case CPP_OPEN_SQUARE:</span>
<span class="lineNum">    5299 </span><span class="lineCov">       1105 :       {</span>
<span class="lineNum">    5300 </span><span class="lineCov">       1103 :         if (c_dialect_objc ())</span>
<span class="lineNum">    5301 </span><span class="lineCov">       1107 :           {</span>
<span class="lineNum">    5302 </span><span class="lineCov">          2 :             /* We might have an Objective-C++ message. */</span>
<span class="lineNum">    5303 </span>            :             cp_parser_parse_tentatively (parser);
<span class="lineNum">    5304 </span>            :             tree msg = cp_parser_objc_message_expression (parser);
<span class="lineNum">    5305 </span>            :             /* If that works out, we're done ... */
<span class="lineNum">    5306 </span>            :             if (cp_parser_parse_definitely (parser))
<span class="lineNum">    5307 </span>            :               return msg;
<span class="lineNum">    5308 </span>            :             /* ... else, fall though to see if it's a lambda.  */
<span class="lineNum">    5309 </span>            :           }
<span class="lineNum">    5310 </span>            :         cp_expr lam = cp_parser_lambda_expression (parser);
<span class="lineNum">    5311 </span><span class="lineCov">    3183914 :         /* Don't warn about a failed tentative parse.  */</span>
<span class="lineNum">    5312 </span>            :         if (cp_parser_error_occurred (parser))
<span class="lineNum">    5313 </span>            :           return error_mark_node;
<span class="lineNum">    5314 </span>            :         maybe_warn_cpp0x (CPP0X_LAMBDA_EXPR);
<span class="lineNum">    5315 </span>            :         return lam;
<span class="lineNum">    5316 </span>            :       }
<span class="lineNum">    5317 </span><span class="lineCov">    3185019 : </span>
<span class="lineNum">    5318 </span><span class="lineCov">    3172016 :     case CPP_OBJC_STRING:</span>
<span class="lineNum">    5319 </span>            :       if (c_dialect_objc ())
<span class="lineNum">    5320 </span>            :         /* We have an Objective-C++ string literal. */
<span class="lineNum">    5321 </span>            :         return cp_parser_objc_expression (parser);
<span class="lineNum">    5322 </span><span class="lineCov">    3185019 :       cp_parser_error (parser, &quot;expected primary-expression&quot;);</span>
<span class="lineNum">    5323 </span><span class="lineCov">    3185019 :       return error_mark_node;</span>
<span class="lineNum">    5324 </span>            : 
<span class="lineNum">    5325 </span>            :     case CPP_KEYWORD:
<span class="lineNum">    5326 </span><span class="lineCov">    6370038 :       switch (token-&gt;keyword)</span>
<span class="lineNum">    5327 </span><span class="lineCov">    3185019 :         {</span>
<span class="lineNum">    5328 </span><span class="lineCov">    3185019 :           /* These two are the boolean literals.  */</span>
<span class="lineNum">    5329 </span><span class="lineCov">    3185019 :         case RID_TRUE:</span>
<span class="lineNum">    5330 </span><span class="lineCov">    3185019 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    5331 </span><span class="lineCov">         12 :           return cp_expr (boolean_true_node, token-&gt;location);</span>
<span class="lineNum">    5332 </span>            :         case RID_FALSE:
<span class="lineNum">    5333 </span><span class="lineCov">    3185019 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    5334 </span>            :           return cp_expr (boolean_false_node, token-&gt;location);
<span class="lineNum">    5335 </span>            : 
<span class="lineNum">    5336 </span><span class="lineCov">       4760 :           /* The `__null' literal.  */</span>
<span class="lineNum">    5337 </span><span class="lineCov">       4760 :         case RID_NULL:</span>
<span class="lineNum">    5338 </span><span class="lineCov">       4760 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    5339 </span>            :           return cp_expr (null_node, token-&gt;location);
<span class="lineNum">    5340 </span>            : 
<span class="lineNum">    5341 </span><span class="lineNoCov">          0 :           /* The `nullptr' literal.  */</span>
<span class="lineNum">    5342 </span><span class="lineNoCov">          0 :         case RID_NULLPTR:</span>
<span class="lineNum">    5343 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">    5344 </span><span class="lineNoCov">          0 :           return cp_expr (nullptr_node, token-&gt;location);</span>
<span class="lineNum">    5345 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    5346 </span>            :           /* Recognize the `this' keyword.  */
<span class="lineNum">    5347 </span>            :         case RID_THIS:
<span class="lineNum">    5348 </span><span class="lineCov">       4760 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    5349 </span>            :           if (parser-&gt;local_variables_forbidden_p)
<span class="lineNum">    5350 </span><span class="lineCov">       9520 :             {</span>
<span class="lineNum">    5351 </span><span class="lineCov">          6 :               error_at (token-&gt;location,</span>
<span class="lineNum">    5352 </span><span class="lineCov">       4754 :                         &quot;%&lt;this%&gt; may not be used in this context&quot;);</span>
<span class="lineNum">    5353 </span><span class="lineCov">       4754 :               return error_mark_node;</span>
<span class="lineNum">    5354 </span>            :             }
<span class="lineNum">    5355 </span>            :           /* Pointers cannot appear in constant-expressions.  */
<span class="lineNum">    5356 </span><span class="lineNoCov">          0 :           if (cp_parser_non_integral_constant_expression (parser, NIC_THIS))</span>
<span class="lineNum">    5357 </span><span class="lineNoCov">          0 :             return error_mark_node;</span>
<span class="lineNum">    5358 </span>            :           return cp_expr (finish_this_expr (), token-&gt;location);
<span class="lineNum">    5359 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    5360 </span><span class="lineNoCov">          0 :           /* The `operator' keyword can be the beginning of an</span>
<span class="lineNum">    5361 </span><span class="lineNoCov">          0 :              id-expression.  */</span>
<span class="lineNum">    5362 </span>            :         case RID_OPERATOR:
<span class="lineNum">    5363 </span><span class="lineCov">    2941580 :           goto id_expression;</span>
<span class="lineNum">    5364 </span><span class="lineCov">    2941580 : </span>
<span class="lineNum">    5365 </span>            :         case RID_FUNCTION_NAME:
<span class="lineNum">    5366 </span>            :         case RID_PRETTY_FUNCTION_NAME:
<span class="lineNum">    5367 </span><span class="lineCov">     537685 :         case RID_C99_FUNCTION_NAME:</span>
<span class="lineNum">    5368 </span><span class="lineCov">     537685 :           {</span>
<span class="lineNum">    5369 </span><span class="lineCov">     537685 :             non_integral_constant name;</span>
<span class="lineNum">    5370 </span><span class="lineCov">     676585 : </span>
<span class="lineNum">    5371 </span><span class="lineCov">     676585 :             /* The symbols __FUNCTION__, __PRETTY_FUNCTION__, and</span>
<span class="lineNum">    5372 </span><span class="lineCov">     676585 :                __func__ are the names of variables -- but they are</span>
<span class="lineNum">    5373 </span>            :                treated specially.  Therefore, they are handled here,
<span class="lineNum">    5374 </span>            :                rather than relying on the generic id-expression logic
<span class="lineNum">    5375 </span><span class="lineCov">      23431 :                below.  Grammatically, these names are id-expressions.</span>
<span class="lineNum">    5376 </span><span class="lineCov">      23431 : </span>
<span class="lineNum">    5377 </span><span class="lineCov">      23431 :                Consume the token.  */</span>
<span class="lineNum">    5378 </span>            :             token = cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">    5379 </span>            : 
<span class="lineNum">    5380 </span><span class="lineCov">      82835 :             switch (token-&gt;keyword)</span>
<span class="lineNum">    5381 </span><span class="lineCov">      82835 :               {</span>
<span class="lineNum">    5382 </span><span class="lineCov">      82835 :               case RID_FUNCTION_NAME:</span>
<span class="lineNum">    5383 </span>            :                 name = NIC_FUNC_NAME;
<span class="lineNum">    5384 </span>            :                 break;
<span class="lineNum">    5385 </span><span class="lineCov">    1435541 :               case RID_PRETTY_FUNCTION_NAME:</span>
<span class="lineNum">    5386 </span><span class="lineCov">    1435541 :                 name = NIC_PRETTY_FUNC;</span>
<span class="lineNum">    5387 </span><span class="lineCov">    1435541 :                 break;</span>
<span class="lineNum">    5388 </span>            :               case RID_C99_FUNCTION_NAME:
<span class="lineNum">    5389 </span><span class="lineNoCov">          0 :                 name = NIC_C99_FUNC;</span>
<span class="lineNum">    5390 </span>            :                 break;
<span class="lineNum">    5391 </span><span class="lineNoCov">          0 :               default:</span>
<span class="lineNum">    5392 </span>            :                 gcc_unreachable ();
<span class="lineNum">    5393 </span>            :               }
<span class="lineNum">    5394 </span><span class="lineCov">    1435541 : </span>
<span class="lineNum">    5395 </span><span class="lineNoCov">          0 :             if (cp_parser_non_integral_constant_expression (parser, name))</span>
<span class="lineNum">    5396 </span><span class="lineCov">    1435541 :               return error_mark_node;</span>
<span class="lineNum">    5397 </span>            : 
<span class="lineNum">    5398 </span>            :             /* Look up the name.  */
<span class="lineNum">    5399 </span>            :             return finish_fname (token-&gt;u.value);
<span class="lineNum">    5400 </span>            :           }
<span class="lineNum">    5401 </span>            : 
<span class="lineNum">    5402 </span>            :         case RID_VA_ARG:
<span class="lineNum">    5403 </span><span class="lineCov">      62418 :           {</span>
<span class="lineNum">    5404 </span><span class="lineCov">      62418 :             tree expression;</span>
<span class="lineNum">    5405 </span><span class="lineCov">      62418 :             tree type;</span>
<span class="lineNum">    5406 </span><span class="lineCov">      62418 :             source_location type_location;</span>
<span class="lineNum">    5407 </span><span class="lineCov">      62418 :             location_t start_loc</span>
<span class="lineNum">    5408 </span>            :               = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">    5409 </span>            :             /* The `__builtin_va_arg' construct is used to handle
<span class="lineNum">    5410 </span>            :                `va_arg'.  Consume the `__builtin_va_arg' token.  */
<span class="lineNum">    5411 </span>            :             cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">    5412 </span>            :             /* Look for the opening `('.  */
<span class="lineNum">    5413 </span>            :             matching_parens parens;
<span class="lineNum">    5414 </span>            :             parens.require_open (parser);
<span class="lineNum">    5415 </span>            :             /* Now, parse the assignment-expression.  */
<span class="lineNum">    5416 </span><span class="lineCov">      62418 :             expression = cp_parser_assignment_expression (parser);</span>
<span class="lineNum">    5417 </span>            :             /* Look for the `,'.  */
<span class="lineNum">    5418 </span><span class="lineCov">      62418 :             cp_parser_require (parser, CPP_COMMA, RT_COMMA);</span>
<span class="lineNum">    5419 </span>            :             type_location = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">    5420 </span>            :             /* Parse the type-id.  */
<span class="lineNum">    5421 </span>            :             {
<span class="lineNum">    5422 </span>            :               type_id_in_expr_sentinel s (parser);
<span class="lineNum">    5423 </span>            :               type = cp_parser_type_id (parser);
<span class="lineNum">    5424 </span>            :             }
<span class="lineNum">    5425 </span>            :             /* Look for the closing `)'.  */
<span class="lineNum">    5426 </span>            :             location_t finish_loc
<span class="lineNum">    5427 </span>            :               = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">    5428 </span>            :             parens.require_close (parser);
<span class="lineNum">    5429 </span><span class="lineNoCov">          0 :             /* Using `va_arg' in a constant-expression is not</span>
<span class="lineNum">    5430 </span><span class="lineNoCov">          0 :                allowed.  */</span>
<span class="lineNum">    5431 </span>            :             if (cp_parser_non_integral_constant_expression (parser,
<span class="lineNum">    5432 </span>            :                                                             NIC_VA_ARG))
<span class="lineNum">    5433 </span><span class="lineCov">      62418 :               return error_mark_node;</span>
<span class="lineNum">    5434 </span><span class="lineCov">          3 :             /* Construct a location of the form:</span>
<span class="lineNum">    5435 </span>            :                  __builtin_va_arg (v, int)
<span class="lineNum">    5436 </span>            :                  ~~~~~~~~~~~~~~~~~~~~~^~~~
<span class="lineNum">    5437 </span><span class="lineCov">      62415 :                with the caret at the type, ranging from the start of the</span>
<span class="lineNum">    5438 </span>            :                &quot;__builtin_va_arg&quot; token to the close paren.  */
<span class="lineNum">    5439 </span>            :             location_t combined_loc
<span class="lineNum">    5440 </span><span class="lineCov">      15766 :               = make_location (type_location, start_loc, finish_loc);</span>
<span class="lineNum">    5441 </span><span class="lineCov">      15766 :             return build_x_va_arg (combined_loc, expression, type);</span>
<span class="lineNum">    5442 </span><span class="lineCov">      15766 :           }</span>
<span class="lineNum">    5443 </span><span class="lineCov">      15766 : </span>
<span class="lineNum">    5444 </span><span class="lineCov">      15766 :         case RID_OFFSETOF:</span>
<span class="lineNum">    5445 </span><span class="lineCov">      15766 :           return cp_parser_builtin_offsetof (parser);</span>
<span class="lineNum">    5446 </span><span class="lineCov">      31532 : </span>
<span class="lineNum">    5447 </span>            :         case RID_HAS_NOTHROW_ASSIGN:
<span class="lineNum">    5448 </span>            :         case RID_HAS_NOTHROW_CONSTRUCTOR:
<span class="lineNum">    5449 </span><span class="lineCov">      15766 :         case RID_HAS_NOTHROW_COPY:        </span>
<span class="lineNum">    5450 </span>            :         case RID_HAS_TRIVIAL_ASSIGN:
<span class="lineNum">    5451 </span><span class="lineCov">      31532 :         case RID_HAS_TRIVIAL_CONSTRUCTOR:</span>
<span class="lineNum">    5452 </span><span class="lineCov">      15766 :         case RID_HAS_TRIVIAL_COPY:        </span>
<span class="lineNum">    5453 </span>            :         case RID_HAS_TRIVIAL_DESTRUCTOR:
<span class="lineNum">    5454 </span><span class="lineCov">      15766 :         case RID_HAS_UNIQUE_OBJ_REPRESENTATIONS:</span>
<span class="lineNum">    5455 </span>            :         case RID_HAS_VIRTUAL_DESTRUCTOR:
<span class="lineNum">    5456 </span><span class="lineCov">      15766 :         case RID_IS_ABSTRACT:</span>
<span class="lineNum">    5457 </span><span class="lineCov">      31532 :         case RID_IS_AGGREGATE:</span>
<span class="lineNum">    5458 </span>            :         case RID_IS_BASE_OF:
<span class="lineNum">    5459 </span><span class="lineCov">      15766 :         case RID_IS_CLASS:</span>
<span class="lineNum">    5460 </span><span class="lineCov">      63064 :         case RID_IS_EMPTY:</span>
<span class="lineNum">    5461 </span><span class="lineCov">      31532 :         case RID_IS_ENUM:</span>
<span class="lineNum">    5462 </span>            :         case RID_IS_FINAL:
<span class="lineNum">    5463 </span>            :         case RID_IS_LITERAL_TYPE:
<span class="lineNum">    5464 </span><span class="lineCov">      15766 :         case RID_IS_POD:</span>
<span class="lineNum">    5465 </span><span class="lineCov">      31532 :         case RID_IS_POLYMORPHIC:</span>
<span class="lineNum">    5466 </span><span class="lineCov">      15766 :         case RID_IS_SAME_AS:</span>
<span class="lineNum">    5467 </span>            :         case RID_IS_STD_LAYOUT:
<span class="lineNum">    5468 </span>            :         case RID_IS_TRIVIAL:
<span class="lineNum">    5469 </span><span class="lineCov">      15766 :         case RID_IS_TRIVIALLY_ASSIGNABLE:</span>
<span class="lineNum">    5470 </span>            :         case RID_IS_TRIVIALLY_CONSTRUCTIBLE:
<span class="lineNum">    5471 </span><span class="lineNoCov">          0 :         case RID_IS_TRIVIALLY_COPYABLE:</span>
<span class="lineNum">    5472 </span>            :         case RID_IS_UNION:
<span class="lineNum">    5473 </span>            :         case RID_IS_ASSIGNABLE:
<span class="lineNum">    5474 </span>            :         case RID_IS_CONSTRUCTIBLE:
<span class="lineNum">    5475 </span>            :           return cp_parser_trait_expr (parser, token-&gt;keyword);
<span class="lineNum">    5476 </span>            : 
<span class="lineNum">    5477 </span><span class="lineCov">      15766 :         // C++ concepts</span>
<span class="lineNum">    5478 </span><span class="lineCov">      15766 :         case RID_REQUIRES:</span>
<span class="lineNum">    5479 </span><span class="lineCov">      15766 :           return cp_parser_requires_expression (parser);</span>
<span class="lineNum">    5480 </span>            : 
<span class="lineNum">    5481 </span>            :         /* Objective-C++ expressions.  */
<span class="lineNum">    5482 </span><span class="lineCov">       2007 :         case RID_AT_ENCODE:</span>
<span class="lineNum">    5483 </span><span class="lineCov">       2007 :         case RID_AT_PROTOCOL:</span>
<span class="lineNum">    5484 </span>            :         case RID_AT_SELECTOR:
<span class="lineNum">    5485 </span><span class="lineCov">      84332 :           return cp_parser_objc_expression (parser);</span>
<span class="lineNum">    5486 </span><span class="lineCov">      84332 : </span>
<span class="lineNum">    5487 </span><span class="lineCov">      84332 :         case RID_TEMPLATE:</span>
<span class="lineNum">    5488 </span><span class="lineCov">      84332 :           if (parser-&gt;in_function_body</span>
<span class="lineNum">    5489 </span><span class="lineCov">      84332 :               &amp;&amp; (cp_lexer_peek_nth_token (parser-&gt;lexer, 2)-&gt;type</span>
<span class="lineNum">    5490 </span><span class="lineCov">      84332 :                   == CPP_LESS))</span>
<span class="lineNum">    5491 </span><span class="lineCov">      84332 :             {</span>
<span class="lineNum">    5492 </span><span class="lineCov">      84332 :               error_at (token-&gt;location,</span>
<span class="lineNum">    5493 </span><span class="lineCov">      84332 :                         &quot;a template declaration cannot appear at block scope&quot;);</span>
<span class="lineNum">    5494 </span><span class="lineCov">      84332 :               cp_parser_skip_to_end_of_block_or_statement (parser);</span>
<span class="lineNum">    5495 </span><span class="lineCov">      84332 :               return error_mark_node;</span>
<span class="lineNum">    5496 </span><span class="lineCov">      84332 :             }</span>
<span class="lineNum">    5497 </span><span class="lineCov">      84332 :           /* FALLTHRU */</span>
<span class="lineNum">    5498 </span><span class="lineCov">      84332 :         default:</span>
<span class="lineNum">    5499 </span><span class="lineCov">      84332 :           cp_parser_error (parser, &quot;expected primary-expression&quot;);</span>
<span class="lineNum">    5500 </span><span class="lineCov">      84332 :           return error_mark_node;</span>
<span class="lineNum">    5501 </span><span class="lineCov">      84332 :         }</span>
<span class="lineNum">    5502 </span><span class="lineCov">      84332 : </span>
<span class="lineNum">    5503 </span><span class="lineCov">      84332 :       /* An id-expression can start with either an identifier, a</span>
<span class="lineNum">    5504 </span><span class="lineCov">      84332 :          `::' as the beginning of a qualified-id, or the &quot;operator&quot;</span>
<span class="lineNum">    5505 </span><span class="lineCov">      84332 :          keyword.  */</span>
<span class="lineNum">    5506 </span><span class="lineCov">      84332 :     case CPP_NAME:</span>
<span class="lineNum">    5507 </span><span class="lineCov">      84332 :     case CPP_SCOPE:</span>
<span class="lineNum">    5508 </span><span class="lineCov">      84332 :     case CPP_TEMPLATE_ID:</span>
<span class="lineNum">    5509 </span><span class="lineCov">      84332 :     case CPP_NESTED_NAME_SPECIFIER:</span>
<span class="lineNum">    5510 </span><span class="lineCov">      84332 :       {</span>
<span class="lineNum">    5511 </span><span class="lineCov">      84332 :       id_expression:</span>
<span class="lineNum">    5512 </span><span class="lineCov">      84332 :         cp_expr id_expression;</span>
<span class="lineNum">    5513 </span><span class="lineCov">      84332 :         cp_expr decl;</span>
<span class="lineNum">    5514 </span>            :         const char *error_msg;
<span class="lineNum">    5515 </span>            :         bool template_p;
<span class="lineNum">    5516 </span><span class="lineCov">         72 :         bool done;</span>
<span class="lineNum">    5517 </span><span class="lineCov">         72 :         cp_token *id_expr_token;</span>
<span class="lineNum">    5518 </span>            : 
<span class="lineNum">    5519 </span>            :         /* Parse the id-expression.  */
<span class="lineNum">    5520 </span><span class="lineNoCov">          0 :         id_expression</span>
<span class="lineNum">    5521 </span><span class="lineNoCov">          0 :           = cp_parser_id_expression (parser,</span>
<span class="lineNum">    5522 </span><span class="lineNoCov">          0 :                                      /*template_keyword_p=*/false,</span>
<span class="lineNum">    5523 </span><span class="lineNoCov">          0 :                                      /*check_dependency_p=*/true,</span>
<span class="lineNum">    5524 </span>            :                                      &amp;template_p,
<span class="lineNum">    5525 </span><span class="lineCov">          6 :                                      /*declarator_p=*/false,</span>
<span class="lineNum">    5526 </span><span class="lineCov">          6 :                                      /*optional_p=*/false);</span>
<span class="lineNum">    5527 </span><span class="lineCov">          6 :         if (id_expression == error_mark_node)</span>
<span class="lineNum">    5528 </span>            :           return error_mark_node;
<span class="lineNum">    5529 </span>            :         id_expr_token = token;
<span class="lineNum">    5530 </span><span class="lineCov">          3 :         token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">    5531 </span>            :         done = (token-&gt;type != CPP_OPEN_SQUARE
<span class="lineNum">    5532 </span><span class="lineCov">          3 :                 &amp;&amp; token-&gt;type != CPP_OPEN_PAREN</span>
<span class="lineNum">    5533 </span><span class="lineCov">          3 :                 &amp;&amp; token-&gt;type != CPP_DOT</span>
<span class="lineNum">    5534 </span>            :                 &amp;&amp; token-&gt;type != CPP_DEREF
<span class="lineNum">    5535 </span>            :                 &amp;&amp; token-&gt;type != CPP_PLUS_PLUS
<span class="lineNum">    5536 </span><span class="lineCov">        237 :                 &amp;&amp; token-&gt;type != CPP_MINUS_MINUS);</span>
<span class="lineNum">    5537 </span><span class="lineCov">        237 :         /* If we have a template-id, then no further lookup is</span>
<span class="lineNum">    5538 </span><span class="lineCov">        237 :            required.  If the template-id was for a template-class, we</span>
<span class="lineNum">    5539 </span>            :            will sometimes have a TYPE_DECL at this point.  */
<span class="lineNum">    5540 </span>            :         if (TREE_CODE (id_expression) == TEMPLATE_ID_EXPR
<span class="lineNum">    5541 </span>            :                  || TREE_CODE (id_expression) == TYPE_DECL)
<span class="lineNum">    5542 </span>            :           decl = id_expression;
<span class="lineNum">    5543 </span>            :         /* Look up the name.  */
<span class="lineNum">    5544 </span><span class="lineCov">   30833360 :         else</span>
<span class="lineNum">    5545 </span><span class="lineCov">   30833360 :           {</span>
<span class="lineNum">    5546 </span><span class="lineCov">   30833360 :             tree ambiguous_decls;</span>
<span class="lineNum">    5547 </span><span class="lineCov">   30833360 : </span>
<span class="lineNum">    5548 </span><span class="lineCov">   30833360 :             /* If we already know that this lookup is ambiguous, then</span>
<span class="lineNum">    5549 </span><span class="lineCov">   61666720 :                we've already issued an error message; there's no reason</span>
<span class="lineNum">    5550 </span><span class="lineCov">   30833360 :                to check again.  */</span>
<span class="lineNum">    5551 </span><span class="lineCov">   30833360 :             if (id_expr_token-&gt;type == CPP_NAME</span>
<span class="lineNum">    5552 </span><span class="lineCov">   30833360 :                 &amp;&amp; id_expr_token-&gt;error_reported)</span>
<span class="lineNum">    5553 </span><span class="lineCov">   30833360 :               {</span>
<span class="lineNum">    5554 </span><span class="lineCov">   30833360 :                 cp_parser_simulate_error (parser);</span>
<span class="lineNum">    5555 </span><span class="lineCov">   30833360 :                 return error_mark_node;</span>
<span class="lineNum">    5556 </span>            :               }
<span class="lineNum">    5557 </span>            : 
<span class="lineNum">    5558 </span><span class="lineCov">   30833360 :             decl = cp_parser_lookup_name (parser, id_expression,</span>
<span class="lineNum">    5559 </span><span class="lineCov">   30833360 :                                           none_type,</span>
<span class="lineNum">    5560 </span>            :                                           template_p,
<span class="lineNum">    5561 </span>            :                                           /*is_namespace=*/false,
<span class="lineNum">    5562 </span>            :                                           /*check_dependency=*/true,
<span class="lineNum">    5563 </span>            :                                           &amp;ambiguous_decls,
<span class="lineNum">    5564 </span><span class="lineCov">   30833360 :                                           id_expr_token-&gt;location);</span>
<span class="lineNum">    5565 </span><span class="lineCov">   61666720 :             /* If the lookup was ambiguous, an error will already have</span>
<span class="lineNum">    5566 </span><span class="lineCov">         33 :                been issued.  */</span>
<span class="lineNum">    5567 </span><span class="lineCov">   30833327 :             if (ambiguous_decls)</span>
<span class="lineNum">    5568 </span><span class="lineCov">   61666654 :               return error_mark_node;</span>
<span class="lineNum">    5569 </span><span class="lineCov">   61666654 : </span>
<span class="lineNum">    5570 </span><span class="lineCov">   30419017 :             /* In Objective-C++, we may have an Objective-C 2.0</span>
<span class="lineNum">    5571 </span><span class="lineCov">   23933724 :                dot-syntax for classes here.  */</span>
<span class="lineNum">    5572 </span><span class="lineCov">   21217117 :             if (c_dialect_objc ()</span>
<span class="lineNum">    5573 </span><span class="lineCov">   20706248 :                 &amp;&amp; cp_lexer_peek_token (parser-&gt;lexer)-&gt;type == CPP_DOT</span>
<span class="lineNum">    5574 </span><span class="lineCov">   51438053 :                 &amp;&amp; TREE_CODE (decl) == TYPE_DECL</span>
<span class="lineNum">    5575 </span>            :                 &amp;&amp; objc_is_class_name (decl))
<span class="lineNum">    5576 </span>            :               {
<span class="lineNum">    5577 </span>            :                 tree component;
<span class="lineNum">    5578 </span><span class="lineCov">   30833327 :                 cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    5579 </span><span class="lineCov">   30833327 :                 component = cp_parser_identifier (parser);</span>
<span class="lineNum">    5580 </span>            :                 if (component == error_mark_node)
<span class="lineNum">    5581 </span>            :                   return error_mark_node;
<span class="lineNum">    5582 </span>            : 
<span class="lineNum">    5583 </span>            :                 tree result = objc_build_class_component_ref (id_expression,
<span class="lineNum">    5584 </span><span class="lineCov">   29778861 :                                                               component);</span>
<span class="lineNum">    5585 </span>            :                 /* Build a location of the form:
<span class="lineNum">    5586 </span>            :                      expr.component
<span class="lineNum">    5587 </span>            :                      ~~~~~^~~~~~~~~
<span class="lineNum">    5588 </span>            :                    with caret at the start of the component name (at
<span class="lineNum">    5589 </span><span class="lineCov">   59557722 :                    input_location), ranging from the start of the id_expression</span>
<span class="lineNum">    5590 </span><span class="lineCov">   29778861 :                    to the end of the component name.  */</span>
<span class="lineNum">    5591 </span>            :                 location_t combined_loc
<span class="lineNum">    5592 </span><span class="lineNoCov">          0 :                   = make_location (input_location, id_expression.get_start (),</span>
<span class="lineNum">    5593 </span><span class="lineNoCov">          0 :                                    get_finish (input_location));</span>
<span class="lineNum">    5594 </span>            :                 protected_set_expr_location (result, combined_loc);
<span class="lineNum">    5595 </span>            :                 return result;
<span class="lineNum">    5596 </span><span class="lineCov">   59557722 :               }</span>
<span class="lineNum">    5597 </span>            : 
<span class="lineNum">    5598 </span>            :             /* In Objective-C++, an instance variable (ivar) may be preferred
<span class="lineNum">    5599 </span>            :                to whatever cp_parser_lookup_name() found.
<span class="lineNum">    5600 </span>            :                Call objc_lookup_ivar.  To avoid exposing cp_expr to the
<span class="lineNum">    5601 </span>            :                rest of c-family, we have to do a little extra work to preserve
<span class="lineNum">    5602 </span><span class="lineCov">   59557722 :                any location information in cp_expr &quot;decl&quot;.  Given that</span>
<span class="lineNum">    5603 </span>            :                objc_lookup_ivar is implemented in &quot;c-family&quot; and &quot;objc&quot;, we
<span class="lineNum">    5604 </span>            :                have a trip through the pure &quot;tree&quot; type, rather than cp_expr.
<span class="lineNum">    5605 </span><span class="lineCov">   29778861 :                Naively copying it back to &quot;decl&quot; would implicitly give the</span>
<span class="lineNum">    5606 </span><span class="lineCov">         21 :                new cp_expr value an UNKNOWN_LOCATION for nodes that don't</span>
<span class="lineNum">    5607 </span>            :                store an EXPR_LOCATION.  Hence we only update &quot;decl&quot; (and
<span class="lineNum">    5608 </span>            :                hence its location_t) if we get back a different tree node.  */
<span class="lineNum">    5609 </span>            :             tree decl_tree = objc_lookup_ivar (decl.get_value (),
<span class="lineNum">    5610 </span><span class="lineCov">   29778840 :                                                id_expression);</span>
<span class="lineNum">    5611 </span><span class="lineNoCov">          0 :             if (decl_tree != decl.get_value ())</span>
<span class="lineNum">    5612 </span><span class="lineNoCov">          0 :               decl = cp_expr (decl_tree);</span>
<span class="lineNum">    5613 </span><span class="lineCov">   29778840 : </span>
<span class="lineNum">    5614 </span>            :             /* If name lookup gives us a SCOPE_REF, then the
<span class="lineNum">    5615 </span><span class="lineNoCov">          0 :                qualifying scope was dependent.  */</span>
<span class="lineNum">    5616 </span><span class="lineNoCov">          0 :             if (TREE_CODE (decl) == SCOPE_REF)</span>
<span class="lineNum">    5617 </span><span class="lineNoCov">          0 :               {</span>
<span class="lineNum">    5618 </span><span class="lineNoCov">          0 :                 /* At this point, we do not know if DECL is a valid</span>
<span class="lineNum">    5619 </span><span class="lineNoCov">          0 :                    integral constant expression.  We assume that it is</span>
<span class="lineNum">    5620 </span>            :                    in fact such an expression, so that code like:
<span class="lineNum">    5621 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    5622 </span><span class="lineNoCov">          0 :                       template &lt;int N&gt; struct A {</span>
<span class="lineNum">    5623 </span>            :                         int a[B&lt;N&gt;::i];
<span class="lineNum">    5624 </span>            :                       };
<span class="lineNum">    5625 </span>            :                      
<span class="lineNum">    5626 </span>            :                    is accepted.  At template-instantiation time, we
<span class="lineNum">    5627 </span>            :                    will check that B&lt;N&gt;::i is actually a constant.  */
<span class="lineNum">    5628 </span>            :                 return decl;
<span class="lineNum">    5629 </span><span class="lineNoCov">          0 :               }</span>
<span class="lineNum">    5630 </span><span class="lineNoCov">          0 :             /* Check to see if DECL is a local variable in a context</span>
<span class="lineNum">    5631 </span>            :                where that is forbidden.  */
<span class="lineNum">    5632 </span><span class="lineNoCov">          0 :             if (parser-&gt;local_variables_forbidden_p</span>
<span class="lineNum">    5633 </span><span class="lineNoCov">          0 :                 &amp;&amp; local_variable_p (decl))</span>
<span class="lineNum">    5634 </span>            :               {
<span class="lineNum">    5635 </span>            :                 error_at (id_expr_token-&gt;location,
<span class="lineNum">    5636 </span>            :                           &quot;local variable %qD may not appear in this context&quot;,
<span class="lineNum">    5637 </span>            :                           decl.get_value ());
<span class="lineNum">    5638 </span>            :                 return error_mark_node;
<span class="lineNum">    5639 </span>            :               }
<span class="lineNum">    5640 </span>            :           }
<span class="lineNum">    5641 </span>            : 
<span class="lineNum">    5642 </span>            :         if (processing_template_decl)
<span class="lineNum">    5643 </span>            :           if (tree fns = maybe_get_fns (decl))
<span class="lineNum">    5644 </span>            :             /* It's too difficult to mark ths in all the places where
<span class="lineNum">    5645 </span>            :                we know for sure we need to keep the lookup, so do it
<span class="lineNum">    5646 </span>            :                now.  The cost is extra GC to recycle the lookups
<span class="lineNum">    5647 </span><span class="lineCov">   89336520 :                resolved at parse time.  */</span>
<span class="lineNum">    5648 </span>            :             lookup_keep (fns);
<span class="lineNum">    5649 </span><span class="lineCov">   59557680 : </span>
<span class="lineNum">    5650 </span><span class="lineNoCov">          0 :         decl = (finish_id_expression</span>
<span class="lineNum">    5651 </span>            :                 (id_expression, decl, parser-&gt;scope,
<span class="lineNum">    5652 </span>            :                  idk,
<span class="lineNum">    5653 </span>            :                  parser-&gt;integral_constant_expression_p,
<span class="lineNum">    5654 </span><span class="lineCov">   59557680 :                  parser-&gt;allow_non_integral_constant_expression_p,</span>
<span class="lineNum">    5655 </span>            :                  &amp;parser-&gt;non_integral_constant_expression_p,
<span class="lineNum">    5656 </span>            :                  template_p, done, address_p,
<span class="lineNum">    5657 </span>            :                  template_arg_p,
<span class="lineNum">    5658 </span>            :                  &amp;error_msg,
<span class="lineNum">    5659 </span>            :                  id_expression.get_location ()));
<span class="lineNum">    5660 </span>            :         if (error_msg)
<span class="lineNum">    5661 </span>            :           cp_parser_error (parser, error_msg);
<span class="lineNum">    5662 </span>            :         decl.set_location (id_expr_token-&gt;location);
<span class="lineNum">    5663 </span>            :         return decl;
<span class="lineNum">    5664 </span>            :       }
<span class="lineNum">    5665 </span>            : 
<span class="lineNum">    5666 </span><span class="lineCov">    1526438 :       /* Anything else is an error.  */</span>
<span class="lineNum">    5667 </span>            :     default:
<span class="lineNum">    5668 </span>            :       cp_parser_error (parser, &quot;expected primary-expression&quot;);
<span class="lineNum">    5669 </span>            :       return error_mark_node;
<span class="lineNum">    5670 </span><span class="lineCov">   28252402 :     }</span>
<span class="lineNum">    5671 </span><span class="lineCov">   28252402 : }</span>
<span class="lineNum">    5672 </span>            : 
<span class="lineNum">    5673 </span><span class="lineCov">         18 : static inline cp_expr</span>
<span class="lineNum">    5674 </span>            : cp_parser_primary_expression (cp_parser *parser,
<span class="lineNum">    5675 </span>            :                               bool address_p,
<span class="lineNum">    5676 </span><span class="lineCov">          9 :                               bool cast_p,</span>
<span class="lineNum">    5677 </span>            :                               bool template_arg_p,
<span class="lineNum">    5678 </span>            :                               cp_id_kind *idk)
<span class="lineNum">    5679 </span>            : {
<span class="lineNum">    5680 </span><span class="lineCov">   29306859 :   return cp_parser_primary_expression (parser, address_p, cast_p, template_arg_p,</span>
<span class="lineNum">    5681 </span><span class="lineCov">   39210874 :                                        /*decltype*/false, idk);</span>
<span class="lineNum">    5682 </span>            : }
<span class="lineNum">    5683 </span>            : 
<span class="lineNum">    5684 </span>            : /* Parse an id-expression.
<span class="lineNum">    5685 </span>            : 
<span class="lineNum">    5686 </span><span class="lineCov">    3402909 :    id-expression:</span>
<span class="lineNum">    5687 </span>            :      unqualified-id
<span class="lineNum">    5688 </span><span class="lineCov">   58613718 :      qualified-id</span>
<span class="lineNum">    5689 </span><span class="lineCov">   29306859 : </span>
<span class="lineNum">    5690 </span>            :    qualified-id:
<span class="lineNum">    5691 </span><span class="lineCov">   29306859 :      :: [opt] nested-name-specifier template [opt] unqualified-id</span>
<span class="lineNum">    5692 </span><span class="lineCov">   29306859 :      :: identifier</span>
<span class="lineNum">    5693 </span>            :      :: operator-function-id
<span class="lineNum">    5694 </span>            :      :: template-id
<span class="lineNum">    5695 </span>            : 
<span class="lineNum">    5696 </span>            :    Return a representation of the unqualified portion of the
<span class="lineNum">    5697 </span><span class="lineCov">  117227436 :    identifier.  Sets PARSER-&gt;SCOPE to the qualifying scope if there is</span>
<span class="lineNum">    5698 </span><span class="lineCov">   29306859 :    a `::' or nested-name-specifier.</span>
<span class="lineNum">    5699 </span><span class="lineCov">       3746 : </span>
<span class="lineNum">    5700 </span><span class="lineCov">   29306859 :    Often, if the id-expression was a qualified-id, the caller will</span>
<span class="lineNum">    5701 </span><span class="lineCov">   29306859 :    want to make a SCOPE_REF to represent the qualified-id.  This</span>
<span class="lineNum">    5702 </span>            :    function does not do this in order to avoid wastefully creating
<span class="lineNum">    5703 </span>            :    SCOPE_REFs when they are not required.
<span class="lineNum">    5704 </span>            : 
<span class="lineNum">    5705 </span><span class="lineCov">       4529 :    If TEMPLATE_KEYWORD_P is true, then we have just seen the</span>
<span class="lineNum">    5706 </span><span class="lineCov">       4529 :    `template' keyword.</span>
<span class="lineNum">    5707 </span><span class="lineCov">       4529 : </span>
<span class="lineNum">    5708 </span>            :    If CHECK_DEPENDENCY_P is false, then names are looked up inside
<span class="lineNum">    5709 </span>            :    uninstantiated templates.
<span class="lineNum">    5710 </span>            : 
<span class="lineNum">    5711 </span>            :    If *TEMPLATE_P is non-NULL, it is set to true iff the
<span class="lineNum">    5712 </span>            :    `template' keyword is used to explicitly indicate that the entity
<span class="lineNum">    5713 </span>            :    named is a template.
<span class="lineNum">    5714 </span>            : 
<span class="lineNum">    5715 </span>            :    If DECLARATOR_P is true, the id-expression is appearing as part of
<span class="lineNum">    5716 </span>            :    a declarator, rather than as part of an expression.  */
<a name="5717"><span class="lineNum">    5717 </span>            : </a>
<span class="lineNum">    5718 </span><span class="lineCov">     807239 : static cp_expr</span>
<span class="lineNum">    5719 </span><span class="lineCov">     807239 : cp_parser_id_expression (cp_parser *parser,</span>
<span class="lineNum">    5720 </span>            :                          bool template_keyword_p,
<span class="lineNum">    5721 </span>            :                          bool check_dependency_p,
<span class="lineNum">    5722 </span>            :                          bool *template_p,
<span class="lineNum">    5723 </span>            :                          bool declarator_p,
<span class="lineNum">    5724 </span>            :                          bool optional_p)
<span class="lineNum">    5725 </span>            : {
<span class="lineNum">    5726 </span>            :   bool global_scope_p;
<span class="lineNum">    5727 </span>            :   bool nested_name_specifier_p;
<span class="lineNum">    5728 </span>            : 
<span class="lineNum">    5729 </span>            :   /* Assume the `template' keyword was not used.  */
<span class="lineNum">    5730 </span>            :   if (template_p)
<span class="lineNum">    5731 </span>            :     *template_p = template_keyword_p;
<span class="lineNum">    5732 </span>            : 
<span class="lineNum">    5733 </span>            :   /* Look for the optional `::' operator.  */
<span class="lineNum">    5734 </span>            :   global_scope_p
<span class="lineNum">    5735 </span>            :     = (!template_keyword_p
<span class="lineNum">    5736 </span>            :        &amp;&amp; (cp_parser_global_scope_opt (parser,
<span class="lineNum">    5737 </span>            :                                        /*current_scope_valid_p=*/false)
<span class="lineNum">    5738 </span>            :            != NULL_TREE));
<span class="lineNum">    5739 </span>            : 
<span class="lineNum">    5740 </span>            :   /* Look for the optional nested-name-specifier.  */
<span class="lineNum">    5741 </span>            :   nested_name_specifier_p
<span class="lineNum">    5742 </span>            :     = (cp_parser_nested_name_specifier_opt (parser,
<span class="lineNum">    5743 </span>            :                                             /*typename_keyword_p=*/false,
<span class="lineNum">    5744 </span>            :                                             check_dependency_p,
<span class="lineNum">    5745 </span>            :                                             /*type_p=*/false,
<span class="lineNum">    5746 </span>            :                                             declarator_p,
<span class="lineNum">    5747 </span>            :                                             template_keyword_p)
<span class="lineNum">    5748 </span>            :        != NULL_TREE);
<span class="lineNum">    5749 </span>            : 
<span class="lineNum">    5750 </span>            :   /* If there is a nested-name-specifier, then we are looking at
<span class="lineNum">    5751 </span>            :      the first qualified-id production.  */
<span class="lineNum">    5752 </span>            :   if (nested_name_specifier_p)
<span class="lineNum">    5753 </span>            :     {
<span class="lineNum">    5754 </span>            :       tree saved_scope;
<span class="lineNum">    5755 </span>            :       tree saved_object_scope;
<span class="lineNum">    5756 </span>            :       tree saved_qualifying_scope;
<span class="lineNum">    5757 </span><span class="lineCov">   72242727 :       cp_expr unqualified_id;</span>
<span class="lineNum">    5758 </span>            :       bool is_template;
<span class="lineNum">    5759 </span>            : 
<span class="lineNum">    5760 </span>            :       /* See if the next token is the `template' keyword.  */
<span class="lineNum">    5761 </span>            :       if (!template_p)
<span class="lineNum">    5762 </span>            :         template_p = &amp;is_template;
<span class="lineNum">    5763 </span>            :       *template_p = cp_parser_optional_template_keyword (parser);
<span class="lineNum">    5764 </span><span class="lineCov">   72242727 :       /* Name lookup we do during the processing of the</span>
<span class="lineNum">    5765 </span><span class="lineCov">   72242727 :          unqualified-id might obliterate SCOPE.  */</span>
<span class="lineNum">    5766 </span>            :       saved_scope = parser-&gt;scope;
<span class="lineNum">    5767 </span>            :       saved_object_scope = parser-&gt;object_scope;
<span class="lineNum">    5768 </span><span class="lineCov">   72242727 :       saved_qualifying_scope = parser-&gt;qualifying_scope;</span>
<span class="lineNum">    5769 </span><span class="lineCov">   37595985 :       /* Process the final unqualified-id.  */</span>
<span class="lineNum">    5770 </span>            :       unqualified_id = cp_parser_unqualified_id (parser, *template_p,
<span class="lineNum">    5771 </span>            :                                                  check_dependency_p,
<span class="lineNum">    5772 </span><span class="lineCov">   72242727 :                                                  declarator_p,</span>
<span class="lineNum">    5773 </span><span class="lineCov">   72242727 :                                                  /*optional_p=*/false);</span>
<span class="lineNum">    5774 </span><span class="lineCov">   72242727 :       /* Restore the SAVED_SCOPE for our caller.  */</span>
<span class="lineNum">    5775 </span>            :       parser-&gt;scope = saved_scope;
<span class="lineNum">    5776 </span>            :       parser-&gt;object_scope = saved_object_scope;
<span class="lineNum">    5777 </span>            :       parser-&gt;qualifying_scope = saved_qualifying_scope;
<span class="lineNum">    5778 </span>            : 
<span class="lineNum">    5779 </span><span class="lineCov">   72242727 :       return unqualified_id;</span>
<span class="lineNum">    5780 </span><span class="lineCov">   72242727 :     }</span>
<span class="lineNum">    5781 </span>            :   /* Otherwise, if we are in global scope, then we are looking at one
<span class="lineNum">    5782 </span>            :      of the other qualified-id productions.  */
<span class="lineNum">    5783 </span>            :   else if (global_scope_p)
<span class="lineNum">    5784 </span>            :     {
<span class="lineNum">    5785 </span>            :       cp_token *token;
<span class="lineNum">    5786 </span>            :       tree id;
<span class="lineNum">    5787 </span>            : 
<span class="lineNum">    5788 </span>            :       /* Peek at the next token.  */
<span class="lineNum">    5789 </span>            :       token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">    5790 </span><span class="lineCov">   72242727 : </span>
<span class="lineNum">    5791 </span>            :       /* If it's an identifier, and the next token is not a &quot;&lt;&quot;, then
<span class="lineNum">    5792 </span><span class="lineCov">    4820935 :          we can avoid the template-id case.  This is an optimization</span>
<span class="lineNum">    5793 </span><span class="lineCov">    4820935 :          for this common case.  */</span>
<span class="lineNum">    5794 </span><span class="lineCov">    4820935 :       if (token-&gt;type == CPP_NAME</span>
<span class="lineNum">    5795 </span><span class="lineCov">    4820935 :           &amp;&amp; !cp_parser_nth_token_starts_template_argument_list_p</span>
<span class="lineNum">    5796 </span><span class="lineCov">    4820935 :                (parser, 2))</span>
<span class="lineNum">    5797 </span>            :         return cp_parser_identifier (parser);
<span class="lineNum">    5798 </span>            : 
<span class="lineNum">    5799 </span><span class="lineCov">    4820935 :       cp_parser_parse_tentatively (parser);</span>
<span class="lineNum">    5800 </span><span class="lineCov">     558587 :       /* Try a template-id.  */</span>
<span class="lineNum">    5801 </span><span class="lineCov">    4820935 :       id = cp_parser_template_id (parser,</span>
<span class="lineNum">    5802 </span>            :                                   /*template_keyword_p=*/false,
<span class="lineNum">    5803 </span>            :                                   /*check_dependency_p=*/true,
<span class="lineNum">    5804 </span><span class="lineCov">    4820935 :                                   none_type,</span>
<span class="lineNum">    5805 </span><span class="lineCov">    4820935 :                                   declarator_p);</span>
<span class="lineNum">    5806 </span><span class="lineCov">    4820935 :       /* If that worked, we're done.  */</span>
<span class="lineNum">    5807 </span>            :       if (cp_parser_parse_definitely (parser))
<span class="lineNum">    5808 </span><span class="lineCov">    9641870 :         return id;</span>
<span class="lineNum">    5809 </span>            : 
<span class="lineNum">    5810 </span>            :       /* Peek at the next token.  (Changes in the token buffer may
<span class="lineNum">    5811 </span><span class="lineCov">    4820935 :          have invalidated the pointer obtained above.)  */</span>
<span class="lineNum">    5812 </span>            :       token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">    5813 </span><span class="lineCov">    4820935 : </span>
<span class="lineNum">    5814 </span><span class="lineCov">    4820935 :       switch (token-&gt;type)</span>
<span class="lineNum">    5815 </span><span class="lineCov">    4820935 :         {</span>
<span class="lineNum">    5816 </span>            :         case CPP_NAME:
<span class="lineNum">    5817 </span><span class="lineCov">    4820935 :           return cp_parser_identifier (parser);</span>
<span class="lineNum">    5818 </span>            : 
<span class="lineNum">    5819 </span>            :         case CPP_KEYWORD:
<span class="lineNum">    5820 </span>            :           if (token-&gt;keyword == RID_OPERATOR)
<span class="lineNum">    5821 </span><span class="lineCov">   67421792 :             return cp_parser_operator_function_id (parser);</span>
<span class="lineNum">    5822 </span>            :           /* Fall through.  */
<span class="lineNum">    5823 </span><span class="lineCov">       8948 : </span>
<span class="lineNum">    5824 </span><span class="lineCov">       8948 :         default:</span>
<span class="lineNum">    5825 </span>            :           cp_parser_error (parser, &quot;expected id-expression&quot;);
<span class="lineNum">    5826 </span>            :           return error_mark_node;
<span class="lineNum">    5827 </span><span class="lineCov">      17896 :         }</span>
<span class="lineNum">    5828 </span>            :     }
<span class="lineNum">    5829 </span>            :   else
<span class="lineNum">    5830 </span>            :     return cp_parser_unqualified_id (parser, template_keyword_p,
<span class="lineNum">    5831 </span>            :                                      /*check_dependency_p=*/true,
<span class="lineNum">    5832 </span><span class="lineCov">       8948 :                                      declarator_p,</span>
<span class="lineNum">    5833 </span><span class="lineCov">      10071 :                                      optional_p);</span>
<span class="lineNum">    5834 </span><span class="lineCov">       1123 : }</span>
<span class="lineNum">    5835 </span><span class="lineCov">       1123 : </span>
<span class="lineNum">    5836 </span>            : /* Parse an unqualified-id.
<span class="lineNum">    5837 </span><span class="lineCov">       7825 : </span>
<span class="lineNum">    5838 </span>            :    unqualified-id:
<span class="lineNum">    5839 </span><span class="lineCov">       7825 :      identifier</span>
<span class="lineNum">    5840 </span>            :      operator-function-id
<span class="lineNum">    5841 </span>            :      conversion-function-id
<span class="lineNum">    5842 </span>            :      ~ class-name
<span class="lineNum">    5843 </span>            :      template-id
<span class="lineNum">    5844 </span>            : 
<span class="lineNum">    5845 </span><span class="lineCov">       7825 :    If TEMPLATE_KEYWORD_P is TRUE, we have just seen the `template'</span>
<span class="lineNum">    5846 </span><span class="lineCov">         10 :    keyword, in a construct like `A::template ...'.</span>
<span class="lineNum">    5847 </span>            : 
<span class="lineNum">    5848 </span>            :    Returns a representation of unqualified-id.  For the `identifier'
<span class="lineNum">    5849 </span>            :    production, an IDENTIFIER_NODE is returned.  For the `~ class-name'
<span class="lineNum">    5850 </span><span class="lineCov">      15630 :    production a BIT_NOT_EXPR is returned; the operand of the</span>
<span class="lineNum">    5851 </span>            :    BIT_NOT_EXPR is an IDENTIFIER_NODE for the class-name.  For the
<span class="lineNum">    5852 </span><span class="lineCov">       7815 :    other productions, see the documentation accompanying the</span>
<span class="lineNum">    5853 </span>            :    corresponding parsing functions.  If CHECK_DEPENDENCY_P is false,
<span class="lineNum">    5854 </span><span class="lineNoCov">          0 :    names are looked up in uninstantiated templates.  If DECLARATOR_P</span>
<span class="lineNum">    5855 </span><span class="lineNoCov">          0 :    is true, the unqualified-id is appearing as part of a declarator,</span>
<span class="lineNum">    5856 </span>            :    rather than as part of an expression.  */
<a name="5857"><span class="lineNum">    5857 </span><span class="lineCov">       7776 : </span></a>
<span class="lineNum">    5858 </span><span class="lineCov">       7776 : static cp_expr</span>
<span class="lineNum">    5859 </span><span class="lineCov">       7729 : cp_parser_unqualified_id (cp_parser* parser,</span>
<span class="lineNum">    5860 </span>            :                           bool template_keyword_p,
<span class="lineNum">    5861 </span>            :                           bool check_dependency_p,
<span class="lineNum">    5862 </span><span class="lineCov">         86 :                           bool declarator_p,</span>
<span class="lineNum">    5863 </span><span class="lineCov">         86 :                           bool optional_p)</span>
<span class="lineNum">    5864 </span><span class="lineCov">         86 : {</span>
<span class="lineNum">    5865 </span>            :   cp_token *token;
<span class="lineNum">    5866 </span>            : 
<span class="lineNum">    5867 </span>            :   /* Peek at the next token.  */
<span class="lineNum">    5868 </span><span class="lineCov">   67412844 :   token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">    5869 </span>            : 
<span class="lineNum">    5870 </span>            :   switch ((int) token-&gt;type)
<span class="lineNum">    5871 </span><span class="lineCov">   67412844 :     {</span>
<span class="lineNum">    5872 </span>            :     case CPP_NAME:
<span class="lineNum">    5873 </span>            :       {
<span class="lineNum">    5874 </span>            :         tree id;
<span class="lineNum">    5875 </span>            : 
<span class="lineNum">    5876 </span>            :         /* We don't know yet whether or not this will be a
<span class="lineNum">    5877 </span>            :            template-id.  */
<span class="lineNum">    5878 </span>            :         cp_parser_parse_tentatively (parser);
<span class="lineNum">    5879 </span>            :         /* Try a template-id.  */
<span class="lineNum">    5880 </span>            :         id = cp_parser_template_id (parser, template_keyword_p,
<span class="lineNum">    5881 </span>            :                                     check_dependency_p,
<span class="lineNum">    5882 </span>            :                                     none_type,
<span class="lineNum">    5883 </span>            :                                     declarator_p);
<span class="lineNum">    5884 </span>            :         /* If it worked, we're done.  */
<span class="lineNum">    5885 </span>            :         if (cp_parser_parse_definitely (parser))
<span class="lineNum">    5886 </span>            :           return id;
<span class="lineNum">    5887 </span>            :         /* Otherwise, it's an ordinary identifier.  */
<span class="lineNum">    5888 </span>            :         return cp_parser_identifier (parser);
<span class="lineNum">    5889 </span>            :       }
<span class="lineNum">    5890 </span>            : 
<span class="lineNum">    5891 </span>            :     case CPP_TEMPLATE_ID:
<span class="lineNum">    5892 </span>            :       return cp_parser_template_id (parser, template_keyword_p,
<span class="lineNum">    5893 </span>            :                                     check_dependency_p,
<span class="lineNum">    5894 </span>            :                                     none_type,
<span class="lineNum">    5895 </span>            :                                     declarator_p);
<span class="lineNum">    5896 </span>            : 
<span class="lineNum">    5897 </span><span class="lineCov">   72950550 :     case CPP_COMPL:</span>
<span class="lineNum">    5898 </span>            :       {
<span class="lineNum">    5899 </span>            :         tree type_decl;
<span class="lineNum">    5900 </span>            :         tree qualifying_scope;
<span class="lineNum">    5901 </span>            :         tree object_scope;
<span class="lineNum">    5902 </span>            :         tree scope;
<span class="lineNum">    5903 </span><span class="lineCov">   72950550 :         bool done;</span>
<span class="lineNum">    5904 </span>            : 
<span class="lineNum">    5905 </span>            :         /* Consume the `~' token.  */
<span class="lineNum">    5906 </span><span class="lineCov">  145901100 :         cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    5907 </span>            :         /* Parse the class-name.  The standard, as written, seems to
<span class="lineNum">    5908 </span><span class="lineCov">   72950550 :            say that:</span>
<span class="lineNum">    5909 </span>            : 
<span class="lineNum">    5910 </span><span class="lineCov">   67857857 :              template &lt;typename T&gt; struct S { ~S (); };</span>
<span class="lineNum">    5911 </span><span class="lineCov">   67857857 :              template &lt;typename T&gt; S&lt;T&gt;::~S() {}</span>
<span class="lineNum">    5912 </span><span class="lineCov">   67857857 : </span>
<span class="lineNum">    5913 </span>            :            is invalid, since `~' must be followed by a class-name, but
<span class="lineNum">    5914 </span>            :            `S&lt;T&gt;' is dependent, and so not known to be a class.
<span class="lineNum">    5915 </span>            :            That's not right; we need to look in uninstantiated
<span class="lineNum">    5916 </span><span class="lineCov">   67857857 :            templates.  A further complication arises from:</span>
<span class="lineNum">    5917 </span>            : 
<span class="lineNum">    5918 </span><span class="lineCov">   67857857 :              template &lt;typename T&gt; void f(T t) {</span>
<span class="lineNum">    5919 </span>            :                t.T::~T();
<span class="lineNum">    5920 </span>            :              }
<span class="lineNum">    5921 </span>            : 
<span class="lineNum">    5922 </span>            :            Here, it is not possible to look up `T' in the scope of `T'
<span class="lineNum">    5923 </span><span class="lineCov">   67857857 :            itself.  We must look in both the current scope, and the</span>
<span class="lineNum">    5924 </span><span class="lineNoCov">          0 :            scope of the containing complete expression.</span>
<span class="lineNum">    5925 </span>            : 
<span class="lineNum">    5926 </span><span class="lineCov">   67857857 :            Yet another issue is:</span>
<span class="lineNum">    5927 </span>            : 
<span class="lineNum">    5928 </span>            :              struct S {
<span class="lineNum">    5929 </span><span class="lineCov">    1274850 :                int S;</span>
<span class="lineNum">    5930 </span><span class="lineCov">    1274850 :                ~S();</span>
<span class="lineNum">    5931 </span>            :              };
<span class="lineNum">    5932 </span>            : 
<span class="lineNum">    5933 </span><span class="lineCov">    1274850 :              S::~S() {}</span>
<span class="lineNum">    5934 </span>            : 
<span class="lineNum">    5935 </span><span class="lineCov">     371768 :            The standard does not seem to say that the `S' in `~S'</span>
<span class="lineNum">    5936 </span><span class="lineCov">     371768 :            should refer to the type `S' and not the data member</span>
<span class="lineNum">    5937 </span><span class="lineCov">     371768 :            `S::S'.  */</span>
<span class="lineNum">    5938 </span><span class="lineCov">     371768 : </span>
<span class="lineNum">    5939 </span><span class="lineCov">     371768 :         /* DR 244 says that we look up the name after the &quot;~&quot; in the</span>
<span class="lineNum">    5940 </span><span class="lineCov">     371768 :            same scope as we looked up the qualifying name.  That idea</span>
<span class="lineNum">    5941 </span><span class="lineCov">     371768 :            isn't fully worked out; it's more complicated than that.  */</span>
<span class="lineNum">    5942 </span>            :         scope = parser-&gt;scope;
<span class="lineNum">    5943 </span>            :         object_scope = parser-&gt;object_scope;
<span class="lineNum">    5944 </span><span class="lineCov">     371768 :         qualifying_scope = parser-&gt;qualifying_scope;</span>
<span class="lineNum">    5945 </span>            : 
<span class="lineNum">    5946 </span>            :         /* Check for invalid scopes.  */
<span class="lineNum">    5947 </span>            :         if (scope == error_mark_node)
<span class="lineNum">    5948 </span>            :           {
<span class="lineNum">    5949 </span>            :             if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))
<span class="lineNum">    5950 </span>            :               cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">    5951 </span>            :             return error_mark_node;
<span class="lineNum">    5952 </span>            :           }
<span class="lineNum">    5953 </span>            :         if (scope &amp;&amp; TREE_CODE (scope) == NAMESPACE_DECL)
<span class="lineNum">    5954 </span>            :           {
<span class="lineNum">    5955 </span>            :             if (!cp_parser_uncommitted_to_tentative_parse_p (parser))
<span class="lineNum">    5956 </span>            :               error_at (token-&gt;location,
<span class="lineNum">    5957 </span>            :                         &quot;scope %qT before %&lt;~%&gt; is not a class-name&quot;,
<span class="lineNum">    5958 </span>            :                         scope);
<span class="lineNum">    5959 </span>            :             cp_parser_simulate_error (parser);
<span class="lineNum">    5960 </span>            :             if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))
<span class="lineNum">    5961 </span>            :               cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">    5962 </span>            :             return error_mark_node;
<span class="lineNum">    5963 </span>            :           }
<span class="lineNum">    5964 </span>            :         gcc_assert (!scope || TYPE_P (scope));
<span class="lineNum">    5965 </span>            : 
<span class="lineNum">    5966 </span>            :         /* If the name is of the form &quot;X::~X&quot; it's OK even if X is a
<span class="lineNum">    5967 </span>            :            typedef.  */
<span class="lineNum">    5968 </span>            :         token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">    5969 </span>            :         if (scope
<span class="lineNum">    5970 </span>            :             &amp;&amp; token-&gt;type == CPP_NAME
<span class="lineNum">    5971 </span>            :             &amp;&amp; (cp_lexer_peek_nth_token (parser-&gt;lexer, 2)-&gt;type
<span class="lineNum">    5972 </span>            :                 != CPP_LESS)
<span class="lineNum">    5973 </span>            :             &amp;&amp; (token-&gt;u.value == TYPE_IDENTIFIER (scope)
<span class="lineNum">    5974 </span>            :                 || (CLASS_TYPE_P (scope)
<span class="lineNum">    5975 </span>            :                     &amp;&amp; constructor_name_p (token-&gt;u.value, scope))))
<span class="lineNum">    5976 </span>            :           {
<span class="lineNum">    5977 </span>            :             cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">    5978 </span>            :             return build_nt (BIT_NOT_EXPR, scope);
<span class="lineNum">    5979 </span>            :           }
<span class="lineNum">    5980 </span><span class="lineCov">     371768 : </span>
<span class="lineNum">    5981 </span><span class="lineCov">     371768 :         /* ~auto means the destructor of whatever the object is.  */</span>
<span class="lineNum">    5982 </span><span class="lineCov">     371768 :         if (cp_parser_is_keyword (token, RID_AUTO))</span>
<span class="lineNum">    5983 </span>            :           {
<span class="lineNum">    5984 </span>            :             if (cxx_dialect &lt; cxx14)
<span class="lineNum">    5985 </span><span class="lineCov">     371768 :               pedwarn (input_location, 0,</span>
<span class="lineNum">    5986 </span>            :                        &quot;%&lt;~auto%&gt; only available with &quot;
<span class="lineNum">    5987 </span><span class="lineCov">          3 :                        &quot;-std=c++14 or -std=gnu++14&quot;);</span>
<span class="lineNum">    5988 </span><span class="lineCov">          3 :             cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    5989 </span><span class="lineCov">          3 :             return build_nt (BIT_NOT_EXPR, make_auto ());</span>
<span class="lineNum">    5990 </span>            :           }
<span class="lineNum">    5991 </span><span class="lineCov">     371765 : </span>
<span class="lineNum">    5992 </span>            :         /* If there was an explicit qualification (S::~T), first look
<span class="lineNum">    5993 </span><span class="lineCov">         21 :            in the scope given by the qualification (i.e., S).</span>
<span class="lineNum">    5994 </span><span class="lineCov">          9 : </span>
<span class="lineNum">    5995 </span>            :            Note: in the calls to cp_parser_class_name below we pass
<span class="lineNum">    5996 </span>            :            typename_type so that lookup finds the injected-class-name
<span class="lineNum">    5997 </span><span class="lineCov">         24 :            rather than the constructor.  */</span>
<span class="lineNum">    5998 </span><span class="lineCov">         12 :         done = false;</span>
<span class="lineNum">    5999 </span><span class="lineCov">         12 :         type_decl = NULL_TREE;</span>
<span class="lineNum">    6000 </span><span class="lineCov">         12 :         if (scope)</span>
<span class="lineNum">    6001 </span>            :           {
<span class="lineNum">    6002 </span><span class="lineCov">     371753 :             cp_parser_parse_tentatively (parser);</span>
<span class="lineNum">    6003 </span>            :             type_decl = cp_parser_class_name (parser,
<span class="lineNum">    6004 </span>            :                                               /*typename_keyword_p=*/false,
<span class="lineNum">    6005 </span>            :                                               /*template_keyword_p=*/false,
<span class="lineNum">    6006 </span><span class="lineCov">     743506 :                                               typename_type,</span>
<span class="lineNum">    6007 </span><span class="lineCov">     371753 :                                               /*check_dependency=*/false,</span>
<span class="lineNum">    6008 </span><span class="lineCov">      27310 :                                               /*class_head_p=*/false,</span>
<span class="lineNum">    6009 </span><span class="lineCov">      27304 :                                               declarator_p);</span>
<span class="lineNum">    6010 </span>            :             if (cp_parser_parse_definitely (parser))
<span class="lineNum">    6011 </span><span class="lineCov">     399054 :               done = true;</span>
<span class="lineNum">    6012 </span><span class="lineCov">         61 :           }</span>
<span class="lineNum">    6013 </span><span class="lineCov">         54 :         /* In &quot;N::S::~S&quot;, look in &quot;N&quot; as well.  */</span>
<span class="lineNum">    6014 </span>            :         if (!done &amp;&amp; scope &amp;&amp; qualifying_scope)
<span class="lineNum">    6015 </span><span class="lineCov">      27240 :           {</span>
<span class="lineNum">    6016 </span><span class="lineCov">      27240 :             cp_parser_parse_tentatively (parser);</span>
<span class="lineNum">    6017 </span>            :             parser-&gt;scope = qualifying_scope;
<span class="lineNum">    6018 </span>            :             parser-&gt;object_scope = NULL_TREE;
<span class="lineNum">    6019 </span>            :             parser-&gt;qualifying_scope = NULL_TREE;
<span class="lineNum">    6020 </span><span class="lineCov">     344513 :             type_decl</span>
<span class="lineNum">    6021 </span>            :               = cp_parser_class_name (parser,
<span class="lineNum">    6022 </span><span class="lineCov">          1 :                                       /*typename_keyword_p=*/false,</span>
<span class="lineNum">    6023 </span><span class="lineNoCov">          0 :                                       /*template_keyword_p=*/false,</span>
<span class="lineNum">    6024 </span>            :                                       typename_type,
<span class="lineNum">    6025 </span>            :                                       /*check_dependency=*/false,
<span class="lineNum">    6026 </span><span class="lineCov">          1 :                                       /*class_head_p=*/false,</span>
<span class="lineNum">    6027 </span><span class="lineCov">          1 :                                       declarator_p);</span>
<span class="lineNum">    6028 </span>            :             if (cp_parser_parse_definitely (parser))
<span class="lineNum">    6029 </span>            :               done = true;
<span class="lineNum">    6030 </span>            :           }
<span class="lineNum">    6031 </span>            :         /* In &quot;p-&gt;S::~T&quot;, look in the scope given by &quot;*p&quot; as well.  */
<span class="lineNum">    6032 </span>            :         else if (!done &amp;&amp; object_scope)
<span class="lineNum">    6033 </span>            :           {
<span class="lineNum">    6034 </span>            :             cp_parser_parse_tentatively (parser);
<span class="lineNum">    6035 </span>            :             parser-&gt;scope = object_scope;
<span class="lineNum">    6036 </span><span class="lineCov">     344512 :             parser-&gt;object_scope = NULL_TREE;</span>
<span class="lineNum">    6037 </span><span class="lineCov">     344512 :             parser-&gt;qualifying_scope = NULL_TREE;</span>
<span class="lineNum">    6038 </span><span class="lineCov">     344512 :             type_decl</span>
<span class="lineNum">    6039 </span>            :               = cp_parser_class_name (parser,
<span class="lineNum">    6040 </span><span class="lineCov">         70 :                                       /*typename_keyword_p=*/false,</span>
<span class="lineNum">    6041 </span><span class="lineCov">         70 :                                       /*template_keyword_p=*/false,</span>
<span class="lineNum">    6042 </span>            :                                       typename_type,
<span class="lineNum">    6043 </span>            :                                       /*check_dependency=*/false,
<span class="lineNum">    6044 </span>            :                                       /*class_head_p=*/false,
<span class="lineNum">    6045 </span>            :                                       declarator_p);
<span class="lineNum">    6046 </span>            :             if (cp_parser_parse_definitely (parser))
<span class="lineNum">    6047 </span>            :               done = true;
<span class="lineNum">    6048 </span><span class="lineCov">         70 :           }</span>
<span class="lineNum">    6049 </span><span class="lineCov">         23 :         /* Look in the surrounding context.  */</span>
<span class="lineNum">    6050 </span>            :         if (!done)
<span class="lineNum">    6051 </span>            :           {
<span class="lineNum">    6052 </span><span class="lineCov">     344512 :             parser-&gt;scope = NULL_TREE;</span>
<span class="lineNum">    6053 </span>            :             parser-&gt;object_scope = NULL_TREE;
<span class="lineNum">    6054 </span><span class="lineNoCov">          0 :             parser-&gt;qualifying_scope = NULL_TREE;</span>
<span class="lineNum">    6055 </span><span class="lineNoCov">          0 :             if (processing_template_decl)</span>
<span class="lineNum">    6056 </span><span class="lineNoCov">          0 :               cp_parser_parse_tentatively (parser);</span>
<span class="lineNum">    6057 </span><span class="lineNoCov">          0 :             type_decl</span>
<span class="lineNum">    6058 </span><span class="lineNoCov">          0 :               = cp_parser_class_name (parser,</span>
<span class="lineNum">    6059 </span><span class="lineNoCov">          0 :                                       /*typename_keyword_p=*/false,</span>
<span class="lineNum">    6060 </span>            :                                       /*template_keyword_p=*/false,
<span class="lineNum">    6061 </span>            :                                       typename_type,
<span class="lineNum">    6062 </span>            :                                       /*check_dependency=*/false,
<span class="lineNum">    6063 </span>            :                                       /*class_head_p=*/false,
<span class="lineNum">    6064 </span>            :                                       declarator_p);
<span class="lineNum">    6065 </span>            :             if (processing_template_decl
<span class="lineNum">    6066 </span><span class="lineNoCov">          0 :                 &amp;&amp; ! cp_parser_parse_definitely (parser))</span>
<span class="lineNum">    6067 </span><span class="lineNoCov">          0 :               {</span>
<span class="lineNum">    6068 </span>            :                 /* We couldn't find a type with this name.  If we're parsing
<span class="lineNum">    6069 </span>            :                    tentatively, fail and try something else.  */
<span class="lineNum">    6070 </span><span class="lineCov">     344512 :                 if (cp_parser_uncommitted_to_tentative_parse_p (parser))</span>
<span class="lineNum">    6071 </span>            :                   {
<span class="lineNum">    6072 </span><span class="lineCov">         18 :                     cp_parser_simulate_error (parser);</span>
<span class="lineNum">    6073 </span><span class="lineCov">         18 :                     return error_mark_node;</span>
<span class="lineNum">    6074 </span><span class="lineCov">         18 :                   }</span>
<span class="lineNum">    6075 </span><span class="lineCov">         18 :                 /* Otherwise, accept it and check for a match at instantiation</span>
<span class="lineNum">    6076 </span><span class="lineCov">         18 :                    time.  */</span>
<span class="lineNum">    6077 </span><span class="lineCov">         18 :                 type_decl = cp_parser_identifier (parser);</span>
<span class="lineNum">    6078 </span>            :                 if (type_decl != error_mark_node)
<span class="lineNum">    6079 </span>            :                   type_decl = build_nt (BIT_NOT_EXPR, type_decl);
<span class="lineNum">    6080 </span>            :                 return type_decl;
<span class="lineNum">    6081 </span>            :               }
<span class="lineNum">    6082 </span>            :           }
<span class="lineNum">    6083 </span>            :         /* If an error occurred, assume that the name of the
<span class="lineNum">    6084 </span><span class="lineCov">         18 :            destructor is the same as the name of the qualifying</span>
<span class="lineNum">    6085 </span><span class="lineNoCov">          0 :            class.  That allows us to keep parsing after running</span>
<span class="lineNum">    6086 </span>            :            into ill-formed destructor names.  */
<span class="lineNum">    6087 </span>            :         if (type_decl == error_mark_node &amp;&amp; scope)
<span class="lineNum">    6088 </span><span class="lineCov">     344512 :           return build_nt (BIT_NOT_EXPR, scope);</span>
<span class="lineNum">    6089 </span>            :         else if (type_decl == error_mark_node)
<span class="lineNum">    6090 </span><span class="lineCov">     344489 :           return error_mark_node;</span>
<span class="lineNum">    6091 </span><span class="lineCov">     344489 : </span>
<span class="lineNum">    6092 </span><span class="lineCov">     344489 :         /* Check that destructor name and scope match.  */</span>
<span class="lineNum">    6093 </span><span class="lineCov">     344489 :         if (declarator_p &amp;&amp; scope &amp;&amp; !check_dtor_name (scope, type_decl))</span>
<span class="lineNum">    6094 </span><span class="lineCov">     146199 :           {</span>
<span class="lineNum">    6095 </span><span class="lineCov">     344489 :             if (!cp_parser_uncommitted_to_tentative_parse_p (parser))</span>
<span class="lineNum">    6096 </span><span class="lineCov">     344489 :               error_at (token-&gt;location,</span>
<span class="lineNum">    6097 </span>            :                         &quot;declaration of %&lt;~%T%&gt; as member of %qT&quot;,
<span class="lineNum">    6098 </span>            :                         type_decl, scope);
<span class="lineNum">    6099 </span>            :             cp_parser_simulate_error (parser);
<span class="lineNum">    6100 </span>            :             return error_mark_node;
<span class="lineNum">    6101 </span>            :           }
<span class="lineNum">    6102 </span>            : 
<span class="lineNum">    6103 </span><span class="lineCov">     344489 :         /* [class.dtor]</span>
<span class="lineNum">    6104 </span><span class="lineCov">     344489 : </span>
<span class="lineNum">    6105 </span>            :            A typedef-name that names a class shall not be used as the
<span class="lineNum">    6106 </span>            :            identifier in the declarator for a destructor declaration.  */
<span class="lineNum">    6107 </span>            :         if (declarator_p
<span class="lineNum">    6108 </span><span class="lineCov">       2452 :             &amp;&amp; !DECL_IMPLICIT_TYPEDEF_P (type_decl)</span>
<span class="lineNum">    6109 </span>            :             &amp;&amp; !DECL_SELF_REFERENCE_P (type_decl)
<span class="lineNum">    6110 </span><span class="lineCov">       2410 :             &amp;&amp; !cp_parser_uncommitted_to_tentative_parse_p (parser))</span>
<span class="lineNum">    6111 </span><span class="lineCov">       1205 :           error_at (token-&gt;location,</span>
<span class="lineNum">    6112 </span>            :                     &quot;typedef-name %qD used as destructor declarator&quot;,
<span class="lineNum">    6113 </span>            :                     type_decl);
<span class="lineNum">    6114 </span>            : 
<span class="lineNum">    6115 </span><span class="lineCov">         21 :         return build_nt (BIT_NOT_EXPR, TREE_TYPE (type_decl));</span>
<span class="lineNum">    6116 </span><span class="lineCov">         21 :       }</span>
<span class="lineNum">    6117 </span><span class="lineCov">         18 : </span>
<span class="lineNum">    6118 </span><span class="lineCov">         21 :     case CPP_KEYWORD:</span>
<span class="lineNum">    6119 </span>            :       if (token-&gt;keyword == RID_OPERATOR)
<span class="lineNum">    6120 </span>            :         {
<span class="lineNum">    6121 </span>            :           cp_expr id;
<span class="lineNum">    6122 </span>            : 
<span class="lineNum">    6123 </span>            :           /* This could be a template-id, so we try that first.  */
<span class="lineNum">    6124 </span>            :           cp_parser_parse_tentatively (parser);
<span class="lineNum">    6125 </span><span class="lineCov">     343286 :           /* Try a template-id.  */</span>
<span class="lineNum">    6126 </span><span class="lineCov">          9 :           id = cp_parser_template_id (parser, template_keyword_p,</span>
<span class="lineNum">    6127 </span><span class="lineCov">     343277 :                                       /*check_dependency_p=*/true,</span>
<span class="lineNum">    6128 </span><span class="lineCov">         11 :                                       none_type,</span>
<span class="lineNum">    6129 </span>            :                                       declarator_p);
<span class="lineNum">    6130 </span>            :           /* If that worked, we're done.  */
<span class="lineNum">    6131 </span><span class="lineCov">     343266 :           if (cp_parser_parse_definitely (parser))</span>
<span class="lineNum">    6132 </span>            :             return id;
<span class="lineNum">    6133 </span><span class="lineCov">         15 :           /* We still don't know whether we're looking at an</span>
<span class="lineNum">    6134 </span><span class="lineCov">          3 :              operator-function-id or a conversion-function-id.  */</span>
<span class="lineNum">    6135 </span>            :           cp_parser_parse_tentatively (parser);
<span class="lineNum">    6136 </span>            :           /* Try an operator-function-id.  */
<span class="lineNum">    6137 </span><span class="lineCov">         24 :           id = cp_parser_operator_function_id (parser);</span>
<span class="lineNum">    6138 </span><span class="lineCov">         12 :           /* If that didn't work, try a conversion-function-id.  */</span>
<span class="lineNum">    6139 </span>            :           if (!cp_parser_parse_definitely (parser))
<span class="lineNum">    6140 </span>            :             id = cp_parser_conversion_function_id (parser);
<span class="lineNum">    6141 </span>            : 
<span class="lineNum">    6142 </span>            :           return id;
<span class="lineNum">    6143 </span>            :         }
<span class="lineNum">    6144 </span>            :       /* Fall through.  */
<span class="lineNum">    6145 </span><span class="lineCov">     343254 : </span>
<span class="lineNum">    6146 </span><span class="lineCov">     160700 :     default:</span>
<span class="lineNum">    6147 </span><span class="lineCov">     160580 :       if (optional_p)</span>
<span class="lineNum">    6148 </span><span class="lineCov">     343254 :         return NULL_TREE;</span>
<span class="lineNum">    6149 </span><span class="lineCov">          3 :       cp_parser_error (parser, &quot;expected unqualified-id&quot;);</span>
<span class="lineNum">    6150 </span>            :       return error_mark_node;
<span class="lineNum">    6151 </span>            :     }
<span class="lineNum">    6152 </span>            : }
<span class="lineNum">    6153 </span><span class="lineCov">     343254 : </span>
<span class="lineNum">    6154 </span>            : /* Parse an (optional) nested-name-specifier.
<span class="lineNum">    6155 </span>            : 
<span class="lineNum">    6156 </span><span class="lineCov">    1970943 :    nested-name-specifier: [C++98]</span>
<span class="lineNum">    6157 </span><span class="lineCov">    1970943 :      class-or-namespace-name :: nested-name-specifier [opt]</span>
<span class="lineNum">    6158 </span>            :      class-or-namespace-name :: template nested-name-specifier [opt]
<span class="lineNum">    6159 </span><span class="lineCov">    1437668 : </span>
<span class="lineNum">    6160 </span>            :    nested-name-specifier: [C++0x]
<span class="lineNum">    6161 </span>            :      type-name ::
<span class="lineNum">    6162 </span><span class="lineCov">    1437668 :      namespace-name ::</span>
<span class="lineNum">    6163 </span>            :      nested-name-specifier identifier ::
<span class="lineNum">    6164 </span><span class="lineCov">    1437668 :      nested-name-specifier template [opt] simple-template-id ::</span>
<span class="lineNum">    6165 </span>            : 
<span class="lineNum">    6166 </span>            :    PARSER-&gt;SCOPE should be set appropriately before this function is
<span class="lineNum">    6167 </span>            :    called.  TYPENAME_KEYWORD_P is TRUE if the `typename' keyword is in
<span class="lineNum">    6168 </span>            :    effect.  TYPE_P is TRUE if we non-type bindings should be ignored
<span class="lineNum">    6169 </span><span class="lineCov">    1437668 :    in name lookups.</span>
<span class="lineNum">    6170 </span><span class="lineCov">        753 : </span>
<span class="lineNum">    6171 </span>            :    Sets PARSER-&gt;SCOPE to the class (TYPE) or namespace
<span class="lineNum">    6172 </span>            :    (NAMESPACE_DECL) specified by the nested-name-specifier, or leaves
<span class="lineNum">    6173 </span><span class="lineCov">    1436915 :    it unchanged if there is no nested-name-specifier.  Returns the new</span>
<span class="lineNum">    6174 </span>            :    scope iff there is a nested-name-specifier, or NULL_TREE otherwise.
<span class="lineNum">    6175 </span><span class="lineCov">    1436915 : </span>
<span class="lineNum">    6176 </span>            :    If IS_DECLARATION is TRUE, the nested-name-specifier is known to be
<span class="lineNum">    6177 </span><span class="lineCov">    1436915 :    part of a declaration and/or decl-specifier.  */</span>
<a name="6178"><span class="lineNum">    6178 </span><span class="lineCov">      55190 : </span></a>
<span class="lineNum">    6179 </span>            : static tree
<span class="lineNum">    6180 </span><span class="lineCov">    1436915 : cp_parser_nested_name_specifier_opt (cp_parser *parser,</span>
<span class="lineNum">    6181 </span><span class="lineCov">     533275 :                                      bool typename_keyword_p,</span>
<span class="lineNum">    6182 </span>            :                                      bool check_dependency_p,
<span class="lineNum">    6183 </span>            :                                      bool type_p,
<span class="lineNum">    6184 </span><span class="lineCov">    2008407 :                                      bool is_declaration,</span>
<span class="lineNum">    6185 </span><span class="lineCov">    2008407 :                                      bool template_keyword_p /* = false */)</span>
<span class="lineNum">    6186 </span><span class="lineCov">    1210533 : {</span>
<span class="lineNum">    6187 </span><span class="lineCov">     797874 :   bool success = false;</span>
<span class="lineNum">    6188 </span><span class="lineCov">     797874 :   cp_token_position start = 0;</span>
<span class="lineNum">    6189 </span>            :   cp_token *token;
<span class="lineNum">    6190 </span>            : 
<span class="lineNum">    6191 </span>            :   /* Remember where the nested-name-specifier starts.  */
<span class="lineNum">    6192 </span>            :   if (cp_parser_uncommitted_to_tentative_parse_p (parser))
<span class="lineNum">    6193 </span>            :     {
<span class="lineNum">    6194 </span>            :       start = cp_lexer_token_position (parser-&gt;lexer, false);
<span class="lineNum">    6195 </span>            :       push_deferring_access_checks (dk_deferred);
<span class="lineNum">    6196 </span>            :     }
<span class="lineNum">    6197 </span>            : 
<span class="lineNum">    6198 </span>            :   while (true)
<span class="lineNum">    6199 </span>            :     {
<span class="lineNum">    6200 </span>            :       tree new_scope;
<span class="lineNum">    6201 </span>            :       tree old_scope;
<span class="lineNum">    6202 </span>            :       tree saved_qualifying_scope;
<span class="lineNum">    6203 </span>            : 
<span class="lineNum">    6204 </span>            :       /* Spot cases that cannot be the beginning of a
<span class="lineNum">    6205 </span>            :          nested-name-specifier.  */
<span class="lineNum">    6206 </span>            :       token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">    6207 </span>            : 
<span class="lineNum">    6208 </span>            :       /* If the next token is CPP_NESTED_NAME_SPECIFIER, just process
<span class="lineNum">    6209 </span>            :          the already parsed nested-name-specifier.  */
<span class="lineNum">    6210 </span>            :       if (token-&gt;type == CPP_NESTED_NAME_SPECIFIER)
<span class="lineNum">    6211 </span>            :         {
<span class="lineNum">    6212 </span>            :           /* Grab the nested-name-specifier and continue the loop.  */
<span class="lineNum">    6213 </span>            :           cp_parser_pre_parsed_nested_name_specifier (parser);
<span class="lineNum">    6214 </span>            :           /* If we originally encountered this nested-name-specifier
<span class="lineNum">    6215 </span>            :              with IS_DECLARATION set to false, we will not have
<span class="lineNum">    6216 </span>            :              resolved TYPENAME_TYPEs, so we must do so here.  */
<span class="lineNum">    6217 </span>            :           if (is_declaration
<span class="lineNum">    6218 </span><span class="lineCov">  265831349 :               &amp;&amp; TREE_CODE (parser-&gt;scope) == TYPENAME_TYPE)</span>
<span class="lineNum">    6219 </span>            :             {
<span class="lineNum">    6220 </span>            :               new_scope = resolve_typename_type (parser-&gt;scope,
<span class="lineNum">    6221 </span>            :                                                  /*only_current_p=*/false);
<span class="lineNum">    6222 </span>            :               if (TREE_CODE (new_scope) != TYPENAME_TYPE)
<span class="lineNum">    6223 </span>            :                 parser-&gt;scope = new_scope;
<span class="lineNum">    6224 </span>            :             }
<span class="lineNum">    6225 </span><span class="lineCov">  265831349 :           success = true;</span>
<span class="lineNum">    6226 </span><span class="lineCov">  265831349 :           continue;</span>
<span class="lineNum">    6227 </span><span class="lineCov">  265831349 :         }</span>
<span class="lineNum">    6228 </span>            : 
<span class="lineNum">    6229 </span>            :       /* Spot cases that cannot be the beginning of a
<span class="lineNum">    6230 </span><span class="lineCov">  472176932 :          nested-name-specifier.  On the second and subsequent times</span>
<span class="lineNum">    6231 </span>            :          through the loop, we look for the `template' keyword.  */
<span class="lineNum">    6232 </span><span class="lineCov">  412691166 :       if (success &amp;&amp; token-&gt;keyword == RID_TEMPLATE)</span>
<span class="lineNum">    6233 </span><span class="lineCov">  206345583 :         ;</span>
<span class="lineNum">    6234 </span>            :       /* A template-id can start a nested-name-specifier.  */
<span class="lineNum">    6235 </span>            :       else if (token-&gt;type == CPP_TEMPLATE_ID)
<span class="lineNum">    6236 </span><span class="lineCov">  280906068 :         ;</span>
<span class="lineNum">    6237 </span>            :       /* DR 743: decltype can be used in a nested-name-specifier.  */
<span class="lineNum">    6238 </span><span class="lineCov">  280906068 :       else if (token_is_decltype (token))</span>
<span class="lineNum">    6239 </span><span class="lineCov">  280906068 :         ;</span>
<span class="lineNum">    6240 </span><span class="lineCov">  280906068 :       else</span>
<span class="lineNum">    6241 </span>            :         {
<span class="lineNum">    6242 </span>            :           /* If the next token is not an identifier, then it is
<span class="lineNum">    6243 </span>            :              definitely not a type-name or namespace-name.  */
<span class="lineNum">    6244 </span><span class="lineCov">  561812136 :           if (token-&gt;type != CPP_NAME)</span>
<span class="lineNum">    6245 </span>            :             break;
<span class="lineNum">    6246 </span>            :           /* If the following token is neither a `&lt;' (to begin a
<span class="lineNum">    6247 </span>            :              template-id), nor a `::', then we are not looking at a
<span class="lineNum">    6248 </span><span class="lineCov">  280906068 :              nested-name-specifier.  */</span>
<span class="lineNum">    6249 </span>            :           token = cp_lexer_peek_nth_token (parser-&gt;lexer, 2);
<span class="lineNum">    6250 </span>            : 
<span class="lineNum">    6251 </span><span class="lineCov">    7326627 :           if (token-&gt;type == CPP_COLON</span>
<span class="lineNum">    6252 </span>            :               &amp;&amp; parser-&gt;colon_corrects_to_scope_p
<span class="lineNum">    6253 </span>            :               &amp;&amp; cp_lexer_peek_nth_token (parser-&gt;lexer, 3)-&gt;type == CPP_NAME)
<span class="lineNum">    6254 </span>            :             {
<span class="lineNum">    6255 </span><span class="lineCov">    7326627 :               gcc_rich_location richloc (token-&gt;location);</span>
<span class="lineNum">    6256 </span><span class="lineCov">     490968 :               richloc.add_fixit_replace (&quot;::&quot;);</span>
<span class="lineNum">    6257 </span>            :               error_at (&amp;richloc,
<span class="lineNum">    6258 </span><span class="lineCov">       1815 :                         &quot;found %&lt;:%&gt; in nested-name-specifier, &quot;</span>
<span class="lineNum">    6259 </span>            :                         &quot;expected %&lt;::%&gt;&quot;);
<span class="lineNum">    6260 </span><span class="lineCov">       1815 :               token-&gt;type = CPP_SCOPE;</span>
<span class="lineNum">    6261 </span><span class="lineCov">       1787 :             }</span>
<span class="lineNum">    6262 </span>            : 
<span class="lineNum">    6263 </span><span class="lineCov">    7326627 :           if (token-&gt;type != CPP_SCOPE</span>
<span class="lineNum">    6264 </span><span class="lineCov">    7326627 :               &amp;&amp; !cp_parser_nth_token_starts_template_argument_list_p</span>
<span class="lineNum">    6265 </span>            :                   (parser, 2))
<span class="lineNum">    6266 </span>            :             break;
<span class="lineNum">    6267 </span>            :         }
<span class="lineNum">    6268 </span>            : 
<span class="lineNum">    6269 </span>            :       /* The nested-name-specifier is optional, so we parse
<span class="lineNum">    6270 </span><span class="lineCov">  273579441 :          tentatively.  */</span>
<span class="lineNum">    6271 </span>            :       cp_parser_parse_tentatively (parser);
<span class="lineNum">    6272 </span>            : 
<span class="lineNum">    6273 </span><span class="lineCov">  273122531 :       /* Look for the optional `template' keyword, if this isn't the</span>
<span class="lineNum">    6274 </span>            :          first time through the loop.  */
<span class="lineNum">    6275 </span>            :       if (success)
<span class="lineNum">    6276 </span><span class="lineCov">  270950088 :         template_keyword_p = cp_parser_optional_template_keyword (parser);</span>
<span class="lineNum">    6277 </span>            : 
<span class="lineNum">    6278 </span>            :       /* Save the old scope since the name lookup we are about to do
<span class="lineNum">    6279 </span>            :          might destroy it.  */
<span class="lineNum">    6280 </span>            :       old_scope = parser-&gt;scope;
<span class="lineNum">    6281 </span>            :       saved_qualifying_scope = parser-&gt;qualifying_scope;
<span class="lineNum">    6282 </span><span class="lineCov">  270949676 :       /* In a declarator-id like &quot;X&lt;T&gt;::I::Y&lt;T&gt;&quot; we must be able to</span>
<span class="lineNum">    6283 </span>            :          look up names in &quot;X&lt;T&gt;::I&quot; in order to determine that &quot;Y&quot; is
<span class="lineNum">    6284 </span>            :          a template.  So, if we have a typename at this point, we make
<span class="lineNum">    6285 </span>            :          an effort to look through it.  */
<span class="lineNum">    6286 </span>            :       if (is_declaration
<span class="lineNum">    6287 </span><span class="lineCov">  200865709 :           &amp;&amp; !typename_keyword_p</span>
<span class="lineNum">    6288 </span>            :           &amp;&amp; parser-&gt;scope
<span class="lineNum">    6289 </span><span class="lineCov">  200865709 :           &amp;&amp; TREE_CODE (parser-&gt;scope) == TYPENAME_TYPE)</span>
<span class="lineNum">    6290 </span><span class="lineCov">     777457 :         parser-&gt;scope = resolve_typename_type (parser-&gt;scope,</span>
<span class="lineNum">    6291 </span><span class="lineCov">  200865757 :                                                /*only_current_p=*/false);</span>
<span class="lineNum">    6292 </span>            :       /* Parse the qualifying entity.  */
<span class="lineNum">    6293 </span><span class="lineCov">         72 :       new_scope</span>
<span class="lineNum">    6294 </span><span class="lineCov">         36 :         = cp_parser_qualifying_entity (parser,</span>
<span class="lineNum">    6295 </span><span class="lineCov">         36 :                                        typename_keyword_p,</span>
<span class="lineNum">    6296 </span>            :                                        template_keyword_p,
<span class="lineNum">    6297 </span>            :                                        check_dependency_p,
<span class="lineNum">    6298 </span><span class="lineCov">         36 :                                        type_p,</span>
<span class="lineNum">    6299 </span>            :                                        is_declaration);
<span class="lineNum">    6300 </span>            :       /* Look for the `::' token.  */
<span class="lineNum">    6301 </span><span class="lineCov">  200865709 :       cp_parser_require (parser, CPP_SCOPE, RT_SCOPE);</span>
<span class="lineNum">    6302 </span><span class="lineCov">  396264036 : </span>
<span class="lineNum">    6303 </span><span class="lineCov">  195398327 :       /* If we found what we wanted, we keep going; otherwise, we're</span>
<span class="lineNum">    6304 </span>            :          done.  */
<span class="lineNum">    6305 </span>            :       if (!cp_parser_parse_definitely (parser))
<span class="lineNum">    6306 </span>            :         {
<span class="lineNum">    6307 </span>            :           bool error_p = false;
<span class="lineNum">    6308 </span>            : 
<span class="lineNum">    6309 </span><span class="lineCov">   17264712 :           /* Restore the OLD_SCOPE since it was valid before the</span>
<span class="lineNum">    6310 </span>            :              failed attempt at finding the last
<span class="lineNum">    6311 </span>            :              class-or-namespace-name.  */
<span class="lineNum">    6312 </span>            :           parser-&gt;scope = old_scope;
<span class="lineNum">    6313 </span><span class="lineCov">   17264712 :           parser-&gt;qualifying_scope = saved_qualifying_scope;</span>
<span class="lineNum">    6314 </span><span class="lineCov">    2912669 : </span>
<span class="lineNum">    6315 </span>            :           /* If the next token is a decltype, and the one after that is a
<span class="lineNum">    6316 </span>            :              `::', then the decltype has failed to resolve to a class or
<span class="lineNum">    6317 </span>            :              enumeration type.  Give this error even when parsing
<span class="lineNum">    6318 </span><span class="lineCov">   17264712 :              tentatively since it can't possibly be valid--and we're going</span>
<span class="lineNum">    6319 </span><span class="lineCov">   17264712 :              to replace it with a CPP_NESTED_NAME_SPECIFIER below, so we</span>
<span class="lineNum">    6320 </span>            :              won't get another chance.*/
<span class="lineNum">    6321 </span>            :           if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_DECLTYPE)
<span class="lineNum">    6322 </span>            :               &amp;&amp; (cp_lexer_peek_nth_token (parser-&gt;lexer, 2)-&gt;type
<span class="lineNum">    6323 </span>            :                   == CPP_SCOPE))
<span class="lineNum">    6324 </span><span class="lineCov">   34529424 :             {</span>
<span class="lineNum">    6325 </span><span class="lineCov">   17264712 :               token = cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    6326 </span><span class="lineCov">     296433 :               error_at (token-&gt;location, &quot;decltype evaluates to %qT, &quot;</span>
<span class="lineNum">    6327 </span><span class="lineCov">      56299 :                         &quot;which is not a class or enumeration type&quot;,</span>
<span class="lineNum">    6328 </span><span class="lineCov">          6 :                         token-&gt;u.tree_check_value-&gt;value);</span>
<span class="lineNum">    6329 </span>            :               parser-&gt;scope = error_mark_node;
<span class="lineNum">    6330 </span>            :               error_p = true;
<span class="lineNum">    6331 </span><span class="lineCov">   17264712 :               /* As below.  */</span>
<span class="lineNum">    6332 </span><span class="lineCov">   17264712 :               success = true;</span>
<span class="lineNum">    6333 </span>            :               cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">    6334 </span>            :             }
<span class="lineNum">    6335 </span>            : 
<span class="lineNum">    6336 </span>            :           if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_TEMPLATE_ID)
<span class="lineNum">    6337 </span>            :               &amp;&amp; cp_lexer_nth_token_is (parser-&gt;lexer, 2, CPP_SCOPE))
<span class="lineNum">    6338 </span>            :             {
<span class="lineNum">    6339 </span><span class="lineCov">   17264712 :               /* If we have a non-type template-id followed by ::, it can't</span>
<span class="lineNum">    6340 </span>            :                  possibly be valid.  */
<span class="lineNum">    6341 </span>            :               token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">    6342 </span>            :               tree tid = token-&gt;u.tree_check_value-&gt;value;
<span class="lineNum">    6343 </span><span class="lineCov">   17264712 :               if (TREE_CODE (tid) == TEMPLATE_ID_EXPR</span>
<span class="lineNum">    6344 </span>            :                   &amp;&amp; TREE_CODE (TREE_OPERAND (tid, 0)) != IDENTIFIER_NODE)
<span class="lineNum">    6345 </span><span class="lineCov">    9516617 :                 {</span>
<span class="lineNum">    6346 </span>            :                   tree tmpl = NULL_TREE;
<span class="lineNum">    6347 </span>            :                   if (is_overloaded_fn (tid))
<span class="lineNum">    6348 </span>            :                     {
<span class="lineNum">    6349 </span>            :                       tree fns = get_fns (tid);
<span class="lineNum">    6350 </span><span class="lineCov">    9516617 :                       if (OVL_SINGLE_P (fns))</span>
<span class="lineNum">    6351 </span><span class="lineCov">    9516617 :                         tmpl = OVL_FIRST (fns);</span>
<span class="lineNum">    6352 </span>            :                       error_at (token-&gt;location, &quot;function template-id %qD &quot;
<span class="lineNum">    6353 </span>            :                                 &quot;in nested-name-specifier&quot;, tid);
<span class="lineNum">    6354 </span>            :                     }
<span class="lineNum">    6355 </span>            :                   else
<span class="lineNum">    6356 </span>            :                     {
<span class="lineNum">    6357 </span>            :                       /* Variable template.  */
<span class="lineNum">    6358 </span>            :                       tmpl = TREE_OPERAND (tid, 0);
<span class="lineNum">    6359 </span><span class="lineCov">   19033234 :                       gcc_assert (variable_template_p (tmpl));</span>
<span class="lineNum">    6360 </span><span class="lineCov">    9516617 :                       error_at (token-&gt;location, &quot;variable template-id %qD &quot;</span>
<span class="lineNum">    6361 </span>            :                                 &quot;in nested-name-specifier&quot;, tid);
<span class="lineNum">    6362 </span>            :                     }
<span class="lineNum">    6363 </span><span class="lineCov">          2 :                   if (tmpl)</span>
<span class="lineNum">    6364 </span><span class="lineCov">          4 :                     inform (DECL_SOURCE_LOCATION (tmpl),</span>
<span class="lineNum">    6365 </span>            :                             &quot;%qD declared here&quot;, tmpl);
<span class="lineNum">    6366 </span><span class="lineCov">          2 : </span>
<span class="lineNum">    6367 </span><span class="lineCov">          2 :                   parser-&gt;scope = error_mark_node;</span>
<span class="lineNum">    6368 </span><span class="lineCov">          2 :                   error_p = true;</span>
<span class="lineNum">    6369 </span>            :                   /* As below.  */
<span class="lineNum">    6370 </span><span class="lineCov">          2 :                   success = true;</span>
<span class="lineNum">    6371 </span><span class="lineCov">          2 :                   cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    6372 </span>            :                   cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">    6373 </span>            :                 }
<span class="lineNum">    6374 </span><span class="lineCov">   19033234 :             }</span>
<span class="lineNum">    6375 </span><span class="lineCov">    9516617 : </span>
<span class="lineNum">    6376 </span>            :           if (cp_parser_uncommitted_to_tentative_parse_p (parser))
<span class="lineNum">    6377 </span>            :             break;
<span class="lineNum">    6378 </span>            :           /* If the next token is an identifier, and the one after
<span class="lineNum">    6379 </span><span class="lineCov">         68 :              that is a `::', then any valid interpretation would have</span>
<span class="lineNum">    6380 </span><span class="lineCov">         34 :              found a class-or-namespace-name.  */</span>
<span class="lineNum">    6381 </span><span class="lineCov">         34 :           while (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME)</span>
<span class="lineNum">    6382 </span><span class="lineCov">         34 :                  &amp;&amp; (cp_lexer_peek_nth_token (parser-&gt;lexer, 2)-&gt;type</span>
<span class="lineNum">    6383 </span>            :                      == CPP_SCOPE)
<span class="lineNum">    6384 </span><span class="lineCov">          2 :                  &amp;&amp; (cp_lexer_peek_nth_token (parser-&gt;lexer, 3)-&gt;type</span>
<span class="lineNum">    6385 </span><span class="lineCov">          2 :                      != CPP_COMPL))</span>
<span class="lineNum">    6386 </span>            :             {
<span class="lineNum">    6387 </span><span class="lineCov">          1 :               token = cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    6388 </span><span class="lineCov">          1 :               if (!error_p)</span>
<span class="lineNum">    6389 </span>            :                 {
<span class="lineNum">    6390 </span><span class="lineCov">          1 :                   if (!token-&gt;error_reported)</span>
<span class="lineNum">    6391 </span>            :                     {
<span class="lineNum">    6392 </span>            :                       tree decl;
<span class="lineNum">    6393 </span>            :                       tree ambiguous_decls;
<span class="lineNum">    6394 </span>            : 
<span class="lineNum">    6395 </span>            :                       decl = cp_parser_lookup_name (parser, token-&gt;u.value,
<span class="lineNum">    6396 </span><span class="lineCov">          1 :                                                     none_type,</span>
<span class="lineNum">    6397 </span><span class="lineCov">          1 :                                                     /*is_template=*/false,</span>
<span class="lineNum">    6398 </span><span class="lineCov">          1 :                                                     /*is_namespace=*/false,</span>
<span class="lineNum">    6399 </span>            :                                                     /*check_dependency=*/true,
<span class="lineNum">    6400 </span>            :                                                     &amp;ambiguous_decls,
<span class="lineNum">    6401 </span><span class="lineCov">          2 :                                                     token-&gt;location);</span>
<span class="lineNum">    6402 </span><span class="lineCov">          2 :                       if (TREE_CODE (decl) == TEMPLATE_DECL)</span>
<span class="lineNum">    6403 </span>            :                         error_at (token-&gt;location,
<span class="lineNum">    6404 </span>            :                                   &quot;%qD used without template arguments&quot;,
<span class="lineNum">    6405 </span><span class="lineCov">          2 :                                   decl);</span>
<span class="lineNum">    6406 </span><span class="lineCov">          2 :                       else if (ambiguous_decls)</span>
<span class="lineNum">    6407 </span>            :                         {
<span class="lineNum">    6408 </span><span class="lineCov">          2 :                           // cp_parser_lookup_name has the same diagnostic,</span>
<span class="lineNum">    6409 </span><span class="lineCov">          2 :                           // thus make sure to emit it at most once.</span>
<span class="lineNum">    6410 </span><span class="lineCov">          2 :                           if (cp_parser_uncommitted_to_tentative_parse_p</span>
<span class="lineNum">    6411 </span>            :                               (parser))
<span class="lineNum">    6412 </span>            :                             {
<span class="lineNum">    6413 </span>            :                               error_at (token-&gt;location,
<span class="lineNum">    6414 </span><span class="lineCov">    9516617 :                                         &quot;reference to %qD is ambiguous&quot;,</span>
<span class="lineNum">    6415 </span>            :                                         token-&gt;u.value);
<span class="lineNum">    6416 </span>            :                               print_candidates (ambiguous_decls);
<span class="lineNum">    6417 </span>            :                             }
<span class="lineNum">    6418 </span>            :                           decl = error_mark_node;
<span class="lineNum">    6419 </span><span class="lineCov">         77 :                         }</span>
<span class="lineNum">    6420 </span><span class="lineCov">     341170 :                       else</span>
<span class="lineNum">    6421 </span>            :                         {
<span class="lineNum">    6422 </span><span class="lineCov">    1972568 :                           if (cxx_dialect != cxx98)</span>
<span class="lineNum">    6423 </span>            :                             cp_parser_name_lookup_error
<span class="lineNum">    6424 </span>            :                             (parser, token-&gt;u.value, decl, NLE_NOT_CXX98,
<span class="lineNum">    6425 </span><span class="lineCov">         77 :                              token-&gt;location);</span>
<span class="lineNum">    6426 </span><span class="lineCov">         77 :                           else</span>
<span class="lineNum">    6427 </span>            :                             cp_parser_name_lookup_error
<span class="lineNum">    6428 </span><span class="lineCov">         74 :                             (parser, token-&gt;u.value, decl, NLE_CXX98,</span>
<span class="lineNum">    6429 </span>            :                              token-&gt;location);
<span class="lineNum">    6430 </span><span class="lineCov">         74 :                         }</span>
<span class="lineNum">    6431 </span><span class="lineCov">         74 :                     }</span>
<span class="lineNum">    6432 </span>            :                   parser-&gt;scope = error_mark_node;
<span class="lineNum">    6433 </span><span class="lineCov">        148 :                   error_p = true;</span>
<span class="lineNum">    6434 </span>            :                   /* Treat this as a successful nested-name-specifier
<span class="lineNum">    6435 </span>            :                      due to:
<span class="lineNum">    6436 </span>            : 
<span class="lineNum">    6437 </span>            :                      [basic.lookup.qual]
<span class="lineNum">    6438 </span>            : 
<span class="lineNum">    6439 </span><span class="lineCov">         74 :                      If the name found is not a class-name (clause</span>
<span class="lineNum">    6440 </span><span class="lineCov">         74 :                      _class_) or namespace-name (_namespace.def_), the</span>
<span class="lineNum">    6441 </span><span class="lineCov">          8 :                      program is ill-formed.  */</span>
<span class="lineNum">    6442 </span>            :                   success = true;
<span class="lineNum">    6443 </span>            :                 }
<span class="lineNum">    6444 </span><span class="lineCov">         66 :               cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    6445 </span>            :             }
<span class="lineNum">    6446 </span>            :           break;
<span class="lineNum">    6447 </span>            :         }
<span class="lineNum">    6448 </span><span class="lineCov">          9 :       /* We've found one valid nested-name-specifier.  */</span>
<span class="lineNum">    6449 </span><span class="lineCov">          9 :       success = true;</span>
<span class="lineNum">    6450 </span>            :       /* Name lookup always gives us a DECL.  */
<span class="lineNum">    6451 </span><span class="lineNoCov">          0 :       if (TREE_CODE (new_scope) == TYPE_DECL)</span>
<span class="lineNum">    6452 </span>            :         new_scope = TREE_TYPE (new_scope);
<span class="lineNum">    6453 </span>            :       /* Uses of &quot;template&quot; must be followed by actual templates.  */
<span class="lineNum">    6454 </span><span class="lineNoCov">          0 :       if (template_keyword_p</span>
<span class="lineNum">    6455 </span>            :           &amp;&amp; !(CLASS_TYPE_P (new_scope)
<span class="lineNum">    6456 </span><span class="lineCov">          9 :                &amp;&amp; ((CLASSTYPE_USE_TEMPLATE (new_scope)</span>
<span class="lineNum">    6457 </span>            :                     &amp;&amp; PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (new_scope)))
<span class="lineNum">    6458 </span>            :                    || CLASSTYPE_IS_TEMPLATE (new_scope)))
<span class="lineNum">    6459 </span>            :           &amp;&amp; !(TREE_CODE (new_scope) == TYPENAME_TYPE
<span class="lineNum">    6460 </span><span class="lineCov">         57 :                &amp;&amp; (TREE_CODE (TYPENAME_TYPE_FULLNAME (new_scope))</span>
<span class="lineNum">    6461 </span><span class="lineCov">         38 :                    == TEMPLATE_ID_EXPR)))</span>
<span class="lineNum">    6462 </span><span class="lineCov">         38 :         permerror (input_location, TYPE_P (new_scope)</span>
<span class="lineNum">    6463 </span>            :                    ? G_(&quot;%qT is not a template&quot;)
<span class="lineNum">    6464 </span>            :                    : G_(&quot;%qD is not a template&quot;),
<span class="lineNum">    6465 </span><span class="lineCov">         19 :                    new_scope);</span>
<span class="lineNum">    6466 </span><span class="lineCov">         19 :       /* If it is a class scope, try to complete it; we are about to</span>
<span class="lineNum">    6467 </span>            :          be looking up names inside the class.  */
<span class="lineNum">    6468 </span>            :       if (TYPE_P (new_scope)
<span class="lineNum">    6469 </span>            :           /* Since checking types for dependency can be expensive,
<span class="lineNum">    6470 </span><span class="lineCov">         74 :              avoid doing it if the type is already complete.  */</span>
<span class="lineNum">    6471 </span><span class="lineCov">         74 :           &amp;&amp; !COMPLETE_TYPE_P (new_scope)</span>
<span class="lineNum">    6472 </span>            :           /* Do not try to complete dependent types.  */
<span class="lineNum">    6473 </span>            :           &amp;&amp; !dependent_type_p (new_scope))
<span class="lineNum">    6474 </span>            :         {
<span class="lineNum">    6475 </span>            :           new_scope = complete_type (new_scope);
<span class="lineNum">    6476 </span>            :           /* If it is a typedef to current class, use the current
<span class="lineNum">    6477 </span>            :              class instead, as the typedef won't have any names inside
<span class="lineNum">    6478 </span>            :              it yet.  */
<span class="lineNum">    6479 </span>            :           if (!COMPLETE_TYPE_P (new_scope)
<span class="lineNum">    6480 </span><span class="lineCov">         74 :               &amp;&amp; currently_open_class (new_scope))</span>
<span class="lineNum">    6481 </span>            :             new_scope = TYPE_MAIN_VARIANT (new_scope);
<span class="lineNum">    6482 </span><span class="lineCov">         77 :         }</span>
<span class="lineNum">    6483 </span>            :       /* Make sure we look in the right scope the next time through
<span class="lineNum">    6484 </span>            :          the loop.  */
<span class="lineNum">    6485 </span>            :       parser-&gt;scope = new_scope;
<span class="lineNum">    6486 </span>            :     }
<span class="lineNum">    6487 </span><span class="lineCov">    7748095 : </span>
<span class="lineNum">    6488 </span>            :   /* If parsing tentatively, replace the sequence of tokens that makes
<span class="lineNum">    6489 </span><span class="lineCov">    7748095 :      up the nested-name-specifier with a CPP_NESTED_NAME_SPECIFIER</span>
<span class="lineNum">    6490 </span><span class="lineCov">    4453232 :      token.  That way, should we re-parse the token stream, we will</span>
<span class="lineNum">    6491 </span>            :      not have to repeat the effort required to do the parse, nor will
<span class="lineNum">    6492 </span><span class="lineCov">    7748095 :      we issue duplicate error messages.  */</span>
<span class="lineNum">    6493 </span><span class="lineCov">      20451 :   if (success &amp;&amp; start)</span>
<span class="lineNum">    6494 </span><span class="lineCov">       1660 :     {</span>
<span class="lineNum">    6495 </span><span class="lineCov">       1660 :       cp_token *token;</span>
<span class="lineNum">    6496 </span><span class="lineCov">          9 : </span>
<span class="lineNum">    6497 </span><span class="lineCov">    7766889 :       token = cp_lexer_token_at (parser-&gt;lexer, start);</span>
<span class="lineNum">    6498 </span><span class="lineCov">      37582 :       /* Reset the contents of the START token.  */</span>
<span class="lineNum">    6499 </span>            :       token-&gt;type = CPP_NESTED_NAME_SPECIFIER;
<span class="lineNum">    6500 </span><span class="lineCov">          3 :       /* Retrieve any deferred checks.  Do not pop this access checks yet</span>
<span class="lineNum">    6501 </span>            :          so the memory will not be reclaimed during token replacing below.  */
<span class="lineNum">    6502 </span>            :       token-&gt;u.tree_check_value = ggc_cleared_alloc&lt;struct tree_check&gt; ();
<span class="lineNum">    6503 </span>            :       token-&gt;u.tree_check_value-&gt;value = parser-&gt;scope;
<span class="lineNum">    6504 </span>            :       token-&gt;u.tree_check_value-&gt;checks = get_deferred_access_checks ();
<span class="lineNum">    6505 </span>            :       token-&gt;u.tree_check_value-&gt;qualifying_scope =
<span class="lineNum">    6506 </span><span class="lineCov">    7748095 :         parser-&gt;qualifying_scope;</span>
<span class="lineNum">    6507 </span>            :       token-&gt;keyword = RID_MAX;
<span class="lineNum">    6508 </span>            : 
<span class="lineNum">    6509 </span><span class="lineCov">    8906568 :       /* Purge all subsequent tokens.  */</span>
<span class="lineNum">    6510 </span>            :       cp_lexer_purge_tokens_after (parser-&gt;lexer, start);
<span class="lineNum">    6511 </span><span class="lineCov">   10624506 :     }</span>
<span class="lineNum">    6512 </span>            : 
<span class="lineNum">    6513 </span><span class="lineCov">      68823 :   if (start)</span>
<span class="lineNum">    6514 </span>            :     pop_to_parent_deferring_access_checks ();
<span class="lineNum">    6515 </span>            : 
<span class="lineNum">    6516 </span>            :   return success ? parser-&gt;scope : NULL_TREE;
<span class="lineNum">    6517 </span><span class="lineCov">      68820 : }</span>
<span class="lineNum">    6518 </span><span class="lineCov">      68820 : </span>
<span class="lineNum">    6519 </span><span class="lineCov">       4515 : /* Parse a nested-name-specifier.  See</span>
<span class="lineNum">    6520 </span>            :    cp_parser_nested_name_specifier_opt for details.  This function
<span class="lineNum">    6521 </span>            :    behaves identically, except that it will an issue an error if no
<span class="lineNum">    6522 </span>            :    nested-name-specifier is present.  */
<a name="6523"><span class="lineNum">    6523 </span><span class="lineCov">    7748092 : </span></a>
<span class="lineNum">    6524 </span>            : static tree
<span class="lineNum">    6525 </span>            : cp_parser_nested_name_specifier (cp_parser *parser,
<span class="lineNum">    6526 </span>            :                                  bool typename_keyword_p,
<span class="lineNum">    6527 </span>            :                                  bool check_dependency_p,
<span class="lineNum">    6528 </span>            :                                  bool type_p,
<span class="lineNum">    6529 </span>            :                                  bool is_declaration)
<span class="lineNum">    6530 </span>            : {
<span class="lineNum">    6531 </span><span class="lineCov">  265831346 :   tree scope;</span>
<span class="lineNum">    6532 </span>            : 
<span class="lineNum">    6533 </span><span class="lineCov">    9257936 :   /* Look for the nested-name-specifier.  */</span>
<span class="lineNum">    6534 </span>            :   scope = cp_parser_nested_name_specifier_opt (parser,
<span class="lineNum">    6535 </span><span class="lineCov">   18515872 :                                                typename_keyword_p,</span>
<span class="lineNum">    6536 </span>            :                                                check_dependency_p,
<span class="lineNum">    6537 </span><span class="lineCov">    9257936 :                                                type_p,</span>
<span class="lineNum">    6538 </span>            :                                                is_declaration);
<span class="lineNum">    6539 </span>            :   /* If it was not present, issue an error message.  */
<span class="lineNum">    6540 </span><span class="lineCov">    9257936 :   if (!scope)</span>
<span class="lineNum">    6541 </span><span class="lineCov">    9257936 :     {</span>
<span class="lineNum">    6542 </span><span class="lineCov">    9257936 :       cp_parser_error (parser, &quot;expected nested-name-specifier&quot;);</span>
<span class="lineNum">    6543 </span><span class="lineCov">   18515872 :       parser-&gt;scope = NULL_TREE;</span>
<span class="lineNum">    6544 </span><span class="lineCov">    9257936 :     }</span>
<span class="lineNum">    6545 </span><span class="lineCov">    9257936 : </span>
<span class="lineNum">    6546 </span>            :   return scope;
<span class="lineNum">    6547 </span>            : }
<span class="lineNum">    6548 </span><span class="lineCov">    9257936 : </span>
<span class="lineNum">    6549 </span>            : /* Parse the qualifying entity in a nested-name-specifier. For C++98,
<span class="lineNum">    6550 </span>            :    this is either a class-name or a namespace-name (which corresponds
<span class="lineNum">    6551 </span><span class="lineCov">  265831346 :    to the class-or-namespace-name production in the grammar). For</span>
<span class="lineNum">    6552 </span><span class="lineCov">  206345580 :    C++0x, it can also be a type-name that refers to an enumeration</span>
<span class="lineNum">    6553 </span>            :    type or a simple-template-id.
<span class="lineNum">    6554 </span><span class="lineCov">  265831346 : </span>
<span class="lineNum">    6555 </span>            :    TYPENAME_KEYWORD_P is TRUE iff the `typename' keyword is in effect.
<span class="lineNum">    6556 </span>            :    TEMPLATE_KEYWORD_P is TRUE iff the `template' keyword is in effect.
<span class="lineNum">    6557 </span>            :    CHECK_DEPENDENCY_P is FALSE iff dependent names should be looked up.
<span class="lineNum">    6558 </span>            :    TYPE_P is TRUE iff the next name should be taken as a class-name,
<span class="lineNum">    6559 </span>            :    even the same name is declared to be another entity in the same
<span class="lineNum">    6560 </span>            :    scope.
<span class="lineNum">    6561 </span>            : 
<span class="lineNum">    6562 </span>            :    Returns the class (TYPE_DECL) or namespace (NAMESPACE_DECL)
<span class="lineNum">    6563 </span><span class="lineCov">   59090428 :    specified by the class-or-namespace-name.  If neither is found the</span>
<span class="lineNum">    6564 </span>            :    ERROR_MARK_NODE is returned.  */
<a name="6565"><span class="lineNum">    6565 </span>            : </a>
<span class="lineNum">    6566 </span>            : static tree
<span class="lineNum">    6567 </span>            : cp_parser_qualifying_entity (cp_parser *parser,
<span class="lineNum">    6568 </span>            :                              bool typename_keyword_p,
<span class="lineNum">    6569 </span><span class="lineCov">   59090428 :                              bool template_keyword_p,</span>
<span class="lineNum">    6570 </span>            :                              bool check_dependency_p,
<span class="lineNum">    6571 </span>            :                              bool type_p,
<span class="lineNum">    6572 </span><span class="lineCov">   59090428 :                              bool is_declaration)</span>
<span class="lineNum">    6573 </span>            : {
<span class="lineNum">    6574 </span>            :   tree saved_scope;
<span class="lineNum">    6575 </span>            :   tree saved_qualifying_scope;
<span class="lineNum">    6576 </span>            :   tree saved_object_scope;
<span class="lineNum">    6577 </span>            :   tree scope;
<span class="lineNum">    6578 </span><span class="lineCov">   59090428 :   bool only_class_p;</span>
<span class="lineNum">    6579 </span>            :   bool successful_parse_p;
<span class="lineNum">    6580 </span><span class="lineCov">   56888401 : </span>
<span class="lineNum">    6581 </span><span class="lineCov">   56888401 :   /* DR 743: decltype can appear in a nested-name-specifier.  */</span>
<span class="lineNum">    6582 </span>            :   if (cp_lexer_next_token_is_decltype (parser-&gt;lexer))
<span class="lineNum">    6583 </span>            :     {
<span class="lineNum">    6584 </span><span class="lineCov">   59090428 :       scope = cp_parser_decltype (parser);</span>
<span class="lineNum">    6585 </span>            :       if (TREE_CODE (scope) != ENUMERAL_TYPE
<span class="lineNum">    6586 </span>            :           &amp;&amp; !MAYBE_CLASS_TYPE_P (scope))
<span class="lineNum">    6587 </span>            :         {
<span class="lineNum">    6588 </span>            :           cp_parser_simulate_error (parser);
<span class="lineNum">    6589 </span>            :           return error_mark_node;
<span class="lineNum">    6590 </span>            :         }
<span class="lineNum">    6591 </span>            :       if (TYPE_NAME (scope))
<span class="lineNum">    6592 </span>            :         scope = TYPE_NAME (scope);
<span class="lineNum">    6593 </span>            :       return scope;
<span class="lineNum">    6594 </span>            :     }
<span class="lineNum">    6595 </span>            : 
<span class="lineNum">    6596 </span>            :   /* Before we try to parse the class-name, we must save away the
<span class="lineNum">    6597 </span>            :      current PARSER-&gt;SCOPE since cp_parser_class_name will destroy
<span class="lineNum">    6598 </span>            :      it.  */
<span class="lineNum">    6599 </span>            :   saved_scope = parser-&gt;scope;
<span class="lineNum">    6600 </span>            :   saved_qualifying_scope = parser-&gt;qualifying_scope;
<span class="lineNum">    6601 </span>            :   saved_object_scope = parser-&gt;object_scope;
<span class="lineNum">    6602 </span>            :   /* Try for a class-name first.  If the SAVED_SCOPE is a type, then
<span class="lineNum">    6603 </span>            :      there is no need to look for a namespace-name.  */
<span class="lineNum">    6604 </span>            :   only_class_p = template_keyword_p 
<span class="lineNum">    6605 </span><span class="lineCov">   17264712 :     || (saved_scope &amp;&amp; TYPE_P (saved_scope) &amp;&amp; cxx_dialect == cxx98);</span>
<span class="lineNum">    6606 </span>            :   if (!only_class_p)
<span class="lineNum">    6607 </span>            :     cp_parser_parse_tentatively (parser);
<span class="lineNum">    6608 </span>            :   scope = cp_parser_class_name (parser,
<span class="lineNum">    6609 </span>            :                                 typename_keyword_p,
<span class="lineNum">    6610 </span>            :                                 template_keyword_p,
<span class="lineNum">    6611 </span>            :                                 type_p ? class_type : none_type,
<span class="lineNum">    6612 </span><span class="lineCov">   17264712 :                                 check_dependency_p,</span>
<span class="lineNum">    6613 </span><span class="lineCov">   17264712 :                                 /*class_head_p=*/false,</span>
<span class="lineNum">    6614 </span><span class="lineCov">   17264712 :                                 is_declaration,</span>
<span class="lineNum">    6615 </span><span class="lineCov">   17264712 :                                 /*enum_ok=*/cxx_dialect &gt; cxx98);</span>
<span class="lineNum">    6616 </span><span class="lineCov">   17264712 :   successful_parse_p = only_class_p || cp_parser_parse_definitely (parser);</span>
<span class="lineNum">    6617 </span><span class="lineCov">   17264712 :   /* If that didn't work, try for a namespace-name.  */</span>
<span class="lineNum">    6618 </span>            :   if (!only_class_p &amp;&amp; !successful_parse_p)
<span class="lineNum">    6619 </span>            :     {
<span class="lineNum">    6620 </span><span class="lineCov">   17264712 :       /* Restore the saved scope.  */</span>
<span class="lineNum">    6621 </span>            :       parser-&gt;scope = saved_scope;
<span class="lineNum">    6622 </span><span class="lineCov">        412 :       parser-&gt;qualifying_scope = saved_qualifying_scope;</span>
<span class="lineNum">    6623 </span><span class="lineCov">        412 :       parser-&gt;object_scope = saved_object_scope;</span>
<span class="lineNum">    6624 </span><span class="lineCov">        412 :       /* If we are not looking at an identifier followed by the scope</span>
<span class="lineNum">    6625 </span>            :          resolution operator, then this is not part of a
<span class="lineNum">    6626 </span><span class="lineCov">        122 :          nested-name-specifier.  (Note that this function is only used</span>
<span class="lineNum">    6627 </span><span class="lineCov">         61 :          to parse the components of a nested-name-specifier.)  */</span>
<span class="lineNum">    6628 </span>            :       if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_NAME)
<span class="lineNum">    6629 </span><span class="lineCov">        351 :           || cp_lexer_peek_nth_token (parser-&gt;lexer, 2)-&gt;type != CPP_SCOPE)</span>
<span class="lineNum">    6630 </span><span class="lineCov">        146 :         return error_mark_node;</span>
<span class="lineNum">    6631 </span><span class="lineCov">        351 :       scope = cp_parser_namespace_name (parser);</span>
<span class="lineNum">    6632 </span>            :     }
<span class="lineNum">    6633 </span>            : 
<span class="lineNum">    6634 </span>            :   return scope;
<span class="lineNum">    6635 </span>            : }
<span class="lineNum">    6636 </span>            : 
<span class="lineNum">    6637 </span><span class="lineCov">   17264300 : /* Return true if we are looking at a compound-literal, false otherwise.  */</span>
<a name="6638"><span class="lineNum">    6638 </span><span class="lineCov">   17264300 : </span></a>
<span class="lineNum">    6639 </span><span class="lineCov">   17264300 : static bool</span>
<span class="lineNum">    6640 </span>            : cp_parser_compound_literal_p (cp_parser *parser)
<span class="lineNum">    6641 </span>            : {
<span class="lineNum">    6642 </span><span class="lineCov">   34069784 :   cp_lexer_save_tokens (parser-&gt;lexer);</span>
<span class="lineNum">    6643 </span><span class="lineCov">   17264300 : </span>
<span class="lineNum">    6644 </span><span class="lineCov">   16805484 :   /* Skip tokens until the next token is a closing parenthesis.</span>
<span class="lineNum">    6645 </span><span class="lineCov">   16805484 :      If we find the closing `)', and the next token is a `{', then</span>
<span class="lineNum">    6646 </span><span class="lineCov">   30904900 :      we are looking at a compound-literal.  */</span>
<span class="lineNum">    6647 </span>            :   bool compound_literal_p
<span class="lineNum">    6648 </span>            :     = (cp_parser_skip_to_closing_parenthesis (parser, false, false,
<span class="lineNum">    6649 </span>            :                                               /*consume_paren=*/true)
<span class="lineNum">    6650 </span>            :        &amp;&amp; cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_BRACE));
<span class="lineNum">    6651 </span>            :   
<span class="lineNum">    6652 </span>            :   /* Roll back the tokens we skipped.  */
<span class="lineNum">    6653 </span>            :   cp_lexer_rollback_tokens (parser-&gt;lexer);
<span class="lineNum">    6654 </span><span class="lineCov">   17264300 : </span>
<span class="lineNum">    6655 </span>            :   return compound_literal_p;
<span class="lineNum">    6656 </span><span class="lineCov">   17264300 : }</span>
<span class="lineNum">    6657 </span>            : 
<span class="lineNum">    6658 </span>            : /* Return true if EXPR is the integer constant zero or a complex constant
<span class="lineNum">    6659 </span><span class="lineCov">    6593411 :    of zero, without any folding, but ignoring location wrappers.  */</span>
<a name="6660"><span class="lineNum">    6660 </span><span class="lineCov">    6593411 : </span></a>
<span class="lineNum">    6661 </span><span class="lineCov">    6593411 : bool</span>
<span class="lineNum">    6662 </span>            : literal_integer_zerop (const_tree expr)
<span class="lineNum">    6663 </span>            : {
<span class="lineNum">    6664 </span>            :   return (location_wrapper_p (expr)
<span class="lineNum">    6665 </span>            :           &amp;&amp; integer_zerop (TREE_OPERAND (expr, 0)));
<span class="lineNum">    6666 </span><span class="lineCov">   13186822 : }</span>
<span class="lineNum">    6667 </span><span class="lineCov">    6593411 : </span>
<span class="lineNum">    6668 </span><span class="lineCov">    3298435 : /* Parse a postfix-expression.</span>
<span class="lineNum">    6669 </span><span class="lineCov">    3294976 : </span>
<span class="lineNum">    6670 </span>            :    postfix-expression:
<span class="lineNum">    6671 </span>            :      primary-expression
<span class="lineNum">    6672 </span>            :      postfix-expression [ expression ]
<span class="lineNum">    6673 </span>            :      postfix-expression ( expression-list [opt] )
<span class="lineNum">    6674 </span>            :      simple-type-specifier ( expression-list [opt] )
<span class="lineNum">    6675 </span>            :      typename :: [opt] nested-name-specifier identifier
<span class="lineNum">    6676 </span>            :        ( expression-list [opt] )
<span class="lineNum">    6677 </span>            :      typename :: [opt] nested-name-specifier template [opt] template-id
<span class="lineNum">    6678 </span><span class="lineCov">    3658256 :        ( expression-list [opt] )</span>
<span class="lineNum">    6679 </span>            :      postfix-expression . template [opt] id-expression
<span class="lineNum">    6680 </span><span class="lineCov">    3658256 :      postfix-expression -&gt; template [opt] id-expression</span>
<span class="lineNum">    6681 </span>            :      postfix-expression . pseudo-destructor-name
<span class="lineNum">    6682 </span>            :      postfix-expression -&gt; pseudo-destructor-name
<span class="lineNum">    6683 </span>            :      postfix-expression ++
<span class="lineNum">    6684 </span>            :      postfix-expression --
<span class="lineNum">    6685 </span><span class="lineCov">    3658256 :      dynamic_cast &lt; type-id &gt; ( expression )</span>
<span class="lineNum">    6686 </span><span class="lineCov">    3658256 :      static_cast &lt; type-id &gt; ( expression )</span>
<span class="lineNum">    6687 </span>            :      reinterpret_cast &lt; type-id &gt; ( expression )
<span class="lineNum">    6688 </span><span class="lineCov">    3658256 :      const_cast &lt; type-id &gt; ( expression )</span>
<span class="lineNum">    6689 </span>            :      typeid ( expression )
<span class="lineNum">    6690 </span>            :      typeid ( type-id )
<span class="lineNum">    6691 </span><span class="lineCov">    3658256 : </span>
<span class="lineNum">    6692 </span>            :    GNU Extension:
<span class="lineNum">    6693 </span><span class="lineCov">    3658256 : </span>
<span class="lineNum">    6694 </span>            :    postfix-expression:
<span class="lineNum">    6695 </span>            :      ( type-id ) { initializer-list , [opt] }
<span class="lineNum">    6696 </span>            : 
<span class="lineNum">    6697 </span>            :    This extension is a GNU version of the C99 compound-literal
<span class="lineNum">    6698 </span>            :    construct.  (The C99 grammar uses `type-name' instead of `type-id',
<span class="lineNum">    6699 </span>            :    but they are essentially the same concept.)
<span class="lineNum">    6700 </span><span class="lineCov">      45912 : </span>
<span class="lineNum">    6701 </span>            :    If ADDRESS_P is true, the postfix expression is the operand of the
<span class="lineNum">    6702 </span><span class="lineCov">      45912 :    `&amp;' operator.  CAST_P is true if this expression is the target of a</span>
<span class="lineNum">    6703 </span><span class="lineCov">      45912 :    cast.</span>
<span class="lineNum">    6704 </span>            : 
<span class="lineNum">    6705 </span>            :    If MEMBER_ACCESS_ONLY_P, we only allow postfix expressions that are
<span class="lineNum">    6706 </span>            :    class member access expressions [expr.ref].
<span class="lineNum">    6707 </span>            : 
<span class="lineNum">    6708 </span>            :    Returns a representation of the expression.  */
<a name="6709"><span class="lineNum">    6709 </span>            : </a>
<span class="lineNum">    6710 </span>            : static cp_expr
<span class="lineNum">    6711 </span>            : cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,
<span class="lineNum">    6712 </span>            :                               bool member_access_only_p, bool decltype_p,
<span class="lineNum">    6713 </span>            :                               cp_id_kind * pidk_return)
<span class="lineNum">    6714 </span>            : {
<span class="lineNum">    6715 </span>            :   cp_token *token;
<span class="lineNum">    6716 </span>            :   location_t loc;
<span class="lineNum">    6717 </span>            :   enum rid keyword;
<span class="lineNum">    6718 </span>            :   cp_id_kind idk = CP_ID_KIND_NONE;
<span class="lineNum">    6719 </span>            :   cp_expr postfix_expression = NULL_TREE;
<span class="lineNum">    6720 </span>            :   bool is_member_access = false;
<span class="lineNum">    6721 </span>            : 
<span class="lineNum">    6722 </span>            :   /* Peek at the next token.  */
<span class="lineNum">    6723 </span>            :   token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">    6724 </span>            :   loc = token-&gt;location;
<span class="lineNum">    6725 </span>            :   location_t start_loc = get_range_from_loc (line_table, loc).m_start;
<span class="lineNum">    6726 </span>            : 
<span class="lineNum">    6727 </span>            :   /* Some of the productions are determined by keywords.  */
<span class="lineNum">    6728 </span>            :   keyword = token-&gt;keyword;
<span class="lineNum">    6729 </span>            :   switch (keyword)
<span class="lineNum">    6730 </span>            :     {
<span class="lineNum">    6731 </span>            :     case RID_DYNCAST:
<span class="lineNum">    6732 </span>            :     case RID_STATCAST:
<span class="lineNum">    6733 </span>            :     case RID_REINTCAST:
<span class="lineNum">    6734 </span>            :     case RID_CONSTCAST:
<span class="lineNum">    6735 </span>            :       {
<span class="lineNum">    6736 </span>            :         tree type;
<span class="lineNum">    6737 </span>            :         cp_expr expression;
<span class="lineNum">    6738 </span>            :         const char *saved_message;
<span class="lineNum">    6739 </span>            :         bool saved_in_type_id_in_expr_p;
<span class="lineNum">    6740 </span>            : 
<span class="lineNum">    6741 </span>            :         /* All of these can be handled in the same way from the point
<span class="lineNum">    6742 </span>            :            of view of parsing.  Begin by consuming the token
<span class="lineNum">    6743 </span>            :            identifying the cast.  */
<span class="lineNum">    6744 </span>            :         cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">    6745 </span>            : 
<span class="lineNum">    6746 </span>            :         /* New types cannot be defined in the cast.  */
<span class="lineNum">    6747 </span>            :         saved_message = parser-&gt;type_definition_forbidden_message;
<span class="lineNum">    6748 </span>            :         parser-&gt;type_definition_forbidden_message
<span class="lineNum">    6749 </span><span class="lineCov">   46009677 :           = G_(&quot;types may not be defined in casts&quot;);</span>
<span class="lineNum">    6750 </span>            : 
<span class="lineNum">    6751 </span>            :         /* Look for the opening `&lt;'.  */
<span class="lineNum">    6752 </span>            :         cp_parser_require (parser, CPP_LESS, RT_LESS);
<span class="lineNum">    6753 </span><span class="lineCov">   46009677 :         /* Parse the type to which we are casting.  */</span>
<span class="lineNum">    6754 </span><span class="lineCov">   46009677 :         saved_in_type_id_in_expr_p = parser-&gt;in_type_id_in_expr_p;</span>
<span class="lineNum">    6755 </span><span class="lineCov">   46009677 :         parser-&gt;in_type_id_in_expr_p = true;</span>
<span class="lineNum">    6756 </span><span class="lineCov">   46009677 :         type = cp_parser_type_id (parser);</span>
<span class="lineNum">    6757 </span><span class="lineCov">   46009677 :         parser-&gt;in_type_id_in_expr_p = saved_in_type_id_in_expr_p;</span>
<span class="lineNum">    6758 </span><span class="lineCov">   46009677 :         /* Look for the closing `&gt;'.  */</span>
<span class="lineNum">    6759 </span>            :         cp_parser_require (parser, CPP_GREATER, RT_GREATER);
<span class="lineNum">    6760 </span>            :         /* Restore the old message.  */
<span class="lineNum">    6761 </span><span class="lineCov">   92019354 :         parser-&gt;type_definition_forbidden_message = saved_message;</span>
<span class="lineNum">    6762 </span><span class="lineCov">   46009677 : </span>
<span class="lineNum">    6763 </span><span class="lineCov">   46009677 :         bool saved_greater_than_is_operator_p</span>
<span class="lineNum">    6764 </span>            :           = parser-&gt;greater_than_is_operator_p;
<span class="lineNum">    6765 </span>            :         parser-&gt;greater_than_is_operator_p = true;
<span class="lineNum">    6766 </span><span class="lineCov">   46009677 : </span>
<span class="lineNum">    6767 </span><span class="lineCov">   46009677 :         /* And the expression which is being cast.  */</span>
<span class="lineNum">    6768 </span>            :         matching_parens parens;
<span class="lineNum">    6769 </span><span class="lineCov">     428609 :         parens.require_open (parser);</span>
<span class="lineNum">    6770 </span><span class="lineCov">     428609 :         expression = cp_parser_expression (parser, &amp; idk, /*cast_p=*/true);</span>
<span class="lineNum">    6771 </span><span class="lineCov">     428609 :         cp_token *close_paren = cp_parser_require (parser, CPP_CLOSE_PAREN,</span>
<span class="lineNum">    6772 </span><span class="lineCov">     428609 :                                                    RT_CLOSE_PAREN);</span>
<span class="lineNum">    6773 </span><span class="lineCov">     428609 :         location_t end_loc = close_paren ?</span>
<span class="lineNum">    6774 </span><span class="lineCov">     428609 :           close_paren-&gt;location : UNKNOWN_LOCATION;</span>
<span class="lineNum">    6775 </span><span class="lineCov">     428609 : </span>
<span class="lineNum">    6776 </span><span class="lineCov">     428609 :         parser-&gt;greater_than_is_operator_p</span>
<span class="lineNum">    6777 </span><span class="lineCov">     428609 :           = saved_greater_than_is_operator_p;</span>
<span class="lineNum">    6778 </span>            : 
<span class="lineNum">    6779 </span>            :         /* Only type conversions to integral or enumeration types
<span class="lineNum">    6780 </span>            :            can be used in constant-expressions.  */
<span class="lineNum">    6781 </span>            :         if (!cast_valid_in_integral_constant_expression_p (type)
<span class="lineNum">    6782 </span><span class="lineCov">     428609 :             &amp;&amp; cp_parser_non_integral_constant_expression (parser, NIC_CAST))</span>
<span class="lineNum">    6783 </span>            :           {
<span class="lineNum">    6784 </span>            :             postfix_expression = error_mark_node;
<span class="lineNum">    6785 </span><span class="lineCov">     428609 :             break;</span>
<span class="lineNum">    6786 </span><span class="lineCov">     428609 :           }</span>
<span class="lineNum">    6787 </span><span class="lineCov">     428609 : </span>
<span class="lineNum">    6788 </span>            :         switch (keyword)
<span class="lineNum">    6789 </span>            :           {
<span class="lineNum">    6790 </span><span class="lineCov">     428609 :           case RID_DYNCAST:</span>
<span class="lineNum">    6791 </span>            :             postfix_expression
<span class="lineNum">    6792 </span><span class="lineCov">     428609 :               = build_dynamic_cast (type, expression, tf_warning_or_error);</span>
<span class="lineNum">    6793 </span><span class="lineCov">     428609 :             break;</span>
<span class="lineNum">    6794 </span><span class="lineCov">     857218 :           case RID_STATCAST:</span>
<span class="lineNum">    6795 </span><span class="lineCov">     428609 :             postfix_expression</span>
<span class="lineNum">    6796 </span>            :               = build_static_cast (type, expression, tf_warning_or_error);
<span class="lineNum">    6797 </span><span class="lineCov">     428609 :             break;</span>
<span class="lineNum">    6798 </span>            :           case RID_REINTCAST:
<span class="lineNum">    6799 </span><span class="lineCov">     428609 :             postfix_expression</span>
<span class="lineNum">    6800 </span>            :               = build_reinterpret_cast (type, expression, 
<span class="lineNum">    6801 </span><span class="lineCov">     428609 :                                         tf_warning_or_error);</span>
<span class="lineNum">    6802 </span>            :             break;
<span class="lineNum">    6803 </span><span class="lineCov">     428609 :           case RID_CONSTCAST:</span>
<span class="lineNum">    6804 </span>            :             postfix_expression
<span class="lineNum">    6805 </span>            :               = build_const_cast (type, expression, tf_warning_or_error);
<span class="lineNum">    6806 </span><span class="lineCov">     857218 :             break;</span>
<span class="lineNum">    6807 </span><span class="lineCov">     428609 :           default:</span>
<span class="lineNum">    6808 </span><span class="lineCov">     428609 :             gcc_unreachable ();</span>
<span class="lineNum">    6809 </span><span class="lineCov">     428609 :           }</span>
<span class="lineNum">    6810 </span>            : 
<span class="lineNum">    6811 </span><span class="lineCov">     428609 :         /* Construct a location e.g. :</span>
<span class="lineNum">    6812 </span>            :              reinterpret_cast &lt;int *&gt; (expr)
<span class="lineNum">    6813 </span>            :              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<span class="lineNum">    6814 </span><span class="lineCov">     428609 :            ranging from the start of the &quot;*_cast&quot; token to the final closing</span>
<span class="lineNum">    6815 </span><span class="lineCov">     428609 :            paren, with the caret at the start.  */</span>
<span class="lineNum">    6816 </span>            :         location_t cp_cast_loc = make_location (start_loc, start_loc, end_loc);
<span class="lineNum">    6817 </span>            :         postfix_expression.set_location (cp_cast_loc);
<span class="lineNum">    6818 </span>            :       }
<span class="lineNum">    6819 </span><span class="lineCov">     428609 :       break;</span>
<span class="lineNum">    6820 </span><span class="lineCov">     428609 : </span>
<span class="lineNum">    6821 </span>            :     case RID_TYPEID:
<span class="lineNum">    6822 </span><span class="lineCov">          6 :       {</span>
<span class="lineNum">    6823 </span><span class="lineCov">          6 :         tree type;</span>
<span class="lineNum">    6824 </span>            :         const char *saved_message;
<span class="lineNum">    6825 </span>            :         bool saved_in_type_id_in_expr_p;
<span class="lineNum">    6826 </span><span class="lineCov">     428603 : </span>
<span class="lineNum">    6827 </span>            :         /* Consume the `typeid' token.  */
<span class="lineNum">    6828 </span><span class="lineCov">       6152 :         cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    6829 </span><span class="lineCov">       6152 :         /* Look for the `(' token.  */</span>
<span class="lineNum">    6830 </span><span class="lineCov">      12304 :         matching_parens parens;</span>
<span class="lineNum">    6831 </span><span class="lineCov">       6152 :         parens.require_open (parser);</span>
<span class="lineNum">    6832 </span><span class="lineCov">     355648 :         /* Types cannot be defined in a `typeid' expression.  */</span>
<span class="lineNum">    6833 </span><span class="lineCov">     355648 :         saved_message = parser-&gt;type_definition_forbidden_message;</span>
<span class="lineNum">    6834 </span><span class="lineCov">     711296 :         parser-&gt;type_definition_forbidden_message</span>
<span class="lineNum">    6835 </span><span class="lineCov">     355648 :           = G_(&quot;types may not be defined in a %&lt;typeid%&gt; expression&quot;);</span>
<span class="lineNum">    6836 </span><span class="lineCov">      44981 :         /* We can't be sure yet whether we're looking at a type-id or an</span>
<span class="lineNum">    6837 </span><span class="lineCov">      44981 :            expression.  */</span>
<span class="lineNum">    6838 </span><span class="lineCov">      89962 :         cp_parser_parse_tentatively (parser);</span>
<span class="lineNum">    6839 </span>            :         /* Try a type-id first.  */
<span class="lineNum">    6840 </span><span class="lineCov">      44981 :         saved_in_type_id_in_expr_p = parser-&gt;in_type_id_in_expr_p;</span>
<span class="lineNum">    6841 </span><span class="lineCov">      21822 :         parser-&gt;in_type_id_in_expr_p = true;</span>
<span class="lineNum">    6842 </span><span class="lineCov">      21822 :         type = cp_parser_type_id (parser);</span>
<span class="lineNum">    6843 </span><span class="lineCov">      43644 :         parser-&gt;in_type_id_in_expr_p = saved_in_type_id_in_expr_p;</span>
<span class="lineNum">    6844 </span><span class="lineCov">      21822 :         /* Look for the `)' token.  Otherwise, we can't be sure that</span>
<span class="lineNum">    6845 </span><span class="lineNoCov">          0 :            we're not looking at an expression: consider `typeid (int</span>
<span class="lineNum">    6846 </span><span class="lineNoCov">          0 :            (3))', for example.  */</span>
<span class="lineNum">    6847 </span>            :         cp_token *close_paren = parens.require_close (parser);
<span class="lineNum">    6848 </span>            :         /* If all went well, simply lookup the type-id.  */
<span class="lineNum">    6849 </span>            :         if (cp_parser_parse_definitely (parser))
<span class="lineNum">    6850 </span>            :           postfix_expression = get_typeid (type, tf_warning_or_error);
<span class="lineNum">    6851 </span>            :         /* Otherwise, fall back to the expression variant.  */
<span class="lineNum">    6852 </span>            :         else
<span class="lineNum">    6853 </span>            :           {
<span class="lineNum">    6854 </span><span class="lineCov">     428603 :             tree expression;</span>
<span class="lineNum">    6855 </span><span class="lineCov">     428603 : </span>
<span class="lineNum">    6856 </span>            :             /* Look for an expression.  */
<span class="lineNum">    6857 </span><span class="lineCov">     428603 :             expression = cp_parser_expression (parser, &amp; idk);</span>
<span class="lineNum">    6858 </span>            :             /* Compute its typeid.  */
<span class="lineNum">    6859 </span><span class="lineCov">      10200 :             postfix_expression = build_typeid (expression, tf_warning_or_error);</span>
<span class="lineNum">    6860 </span><span class="lineCov">      10200 :             /* Look for the `)' token.  */</span>
<span class="lineNum">    6861 </span><span class="lineCov">      10200 :             close_paren = parens.require_close (parser);</span>
<span class="lineNum">    6862 </span><span class="lineCov">      10200 :           }</span>
<span class="lineNum">    6863 </span><span class="lineCov">      10200 :         /* Restore the saved message.  */</span>
<span class="lineNum">    6864 </span>            :         parser-&gt;type_definition_forbidden_message = saved_message;
<span class="lineNum">    6865 </span>            :         /* `typeid' may not appear in an integral constant expression.  */
<span class="lineNum">    6866 </span><span class="lineCov">      10200 :         if (cp_parser_non_integral_constant_expression (parser, NIC_TYPEID))</span>
<span class="lineNum">    6867 </span>            :           postfix_expression = error_mark_node;
<span class="lineNum">    6868 </span><span class="lineCov">      20400 : </span>
<span class="lineNum">    6869 </span><span class="lineCov">      10200 :         /* Construct a location e.g. :</span>
<span class="lineNum">    6870 </span>            :              typeid (expr)
<span class="lineNum">    6871 </span><span class="lineCov">      10200 :              ^~~~~~~~~~~~~</span>
<span class="lineNum">    6872 </span><span class="lineCov">      10200 :            ranging from the start of the &quot;typeid&quot; token to the final closing</span>
<span class="lineNum">    6873 </span><span class="lineCov">      10200 :            paren, with the caret at the start.  */</span>
<span class="lineNum">    6874 </span>            :         if (close_paren)
<span class="lineNum">    6875 </span>            :           {
<span class="lineNum">    6876 </span><span class="lineCov">      10200 :             location_t typeid_loc</span>
<span class="lineNum">    6877 </span>            :               = make_location (start_loc, start_loc, close_paren-&gt;location);
<span class="lineNum">    6878 </span><span class="lineCov">      10200 :             postfix_expression.set_location (typeid_loc);</span>
<span class="lineNum">    6879 </span><span class="lineCov">      10200 :             postfix_expression.maybe_add_location_wrapper ();</span>
<span class="lineNum">    6880 </span><span class="lineCov">      20400 :           }</span>
<span class="lineNum">    6881 </span><span class="lineCov">      10200 :       }</span>
<span class="lineNum">    6882 </span>            :       break;
<span class="lineNum">    6883 </span>            : 
<span class="lineNum">    6884 </span>            :     case RID_TYPENAME:
<span class="lineNum">    6885 </span><span class="lineCov">      10200 :       {</span>
<span class="lineNum">    6886 </span>            :         tree type;
<span class="lineNum">    6887 </span><span class="lineCov">      10200 :         /* The syntax permitted here is the same permitted for an</span>
<span class="lineNum">    6888 </span><span class="lineCov">       6513 :            elaborated-type-specifier.  */</span>
<span class="lineNum">    6889 </span>            :         ++parser-&gt;prevent_constrained_type_specifiers;
<span class="lineNum">    6890 </span>            :         type = cp_parser_elaborated_type_specifier (parser,
<span class="lineNum">    6891 </span>            :                                                     /*is_friend=*/false,
<span class="lineNum">    6892 </span><span class="lineCov">       3687 :                                                     /*is_declaration=*/false);</span>
<span class="lineNum">    6893 </span>            :         --parser-&gt;prevent_constrained_type_specifiers;
<span class="lineNum">    6894 </span>            :         postfix_expression = cp_parser_functional_cast (parser, type);
<span class="lineNum">    6895 </span><span class="lineCov">       3687 :       }</span>
<span class="lineNum">    6896 </span>            :       break;
<span class="lineNum">    6897 </span><span class="lineCov">       3687 : </span>
<span class="lineNum">    6898 </span>            :     case RID_ADDRESSOF:
<span class="lineNum">    6899 </span><span class="lineCov">       3687 :     case RID_BUILTIN_SHUFFLE:</span>
<span class="lineNum">    6900 </span>            :     case RID_BUILTIN_LAUNDER:
<span class="lineNum">    6901 </span>            :       {
<span class="lineNum">    6902 </span><span class="lineCov">      10200 :         vec&lt;tree, va_gc&gt; *vec;</span>
<span class="lineNum">    6903 </span>            :         unsigned int i;
<span class="lineNum">    6904 </span><span class="lineCov">      10200 :         tree p;</span>
<span class="lineNum">    6905 </span><span class="lineCov">          1 : </span>
<span class="lineNum">    6906 </span>            :         cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">    6907 </span>            :         vec = cp_parser_parenthesized_expression_list (parser, non_attr,
<span class="lineNum">    6908 </span>            :                     /*cast_p=*/false, /*allow_expansion_p=*/true,
<span class="lineNum">    6909 </span>            :                     /*non_constant_p=*/NULL);
<span class="lineNum">    6910 </span>            :         if (vec == NULL)
<span class="lineNum">    6911 </span>            :           {
<span class="lineNum">    6912 </span><span class="lineCov">      10200 :             postfix_expression = error_mark_node;</span>
<span class="lineNum">    6913 </span>            :             break;
<span class="lineNum">    6914 </span><span class="lineCov">      10197 :           }</span>
<span class="lineNum">    6915 </span><span class="lineCov">      10197 : </span>
<span class="lineNum">    6916 </span><span class="lineCov">      10197 :         FOR_EACH_VEC_ELT (*vec, i, p)</span>
<span class="lineNum">    6917 </span><span class="lineCov">      10197 :           mark_exp_read (p);</span>
<span class="lineNum">    6918 </span>            : 
<span class="lineNum">    6919 </span>            :         switch (keyword)
<span class="lineNum">    6920 </span>            :           {
<span class="lineNum">    6921 </span>            :           case RID_ADDRESSOF:
<span class="lineNum">    6922 </span><span class="lineCov">      13782 :             if (vec-&gt;length () == 1)</span>
<span class="lineNum">    6923 </span><span class="lineCov">      13782 :               postfix_expression</span>
<span class="lineNum">    6924 </span><span class="lineCov">      13782 :                 = cp_build_addressof (loc, (*vec)[0], tf_warning_or_error);</span>
<span class="lineNum">    6925 </span>            :             else
<span class="lineNum">    6926 </span>            :               {
<span class="lineNum">    6927 </span><span class="lineCov">      13782 :                 error_at (loc, &quot;wrong number of arguments to &quot;</span>
<span class="lineNum">    6928 </span><span class="lineCov">      13782 :                                &quot;%&lt;__builtin_addressof%&gt;&quot;);</span>
<span class="lineNum">    6929 </span>            :                 postfix_expression = error_mark_node;
<span class="lineNum">    6930 </span>            :               }
<span class="lineNum">    6931 </span><span class="lineCov">      13782 :             break;</span>
<span class="lineNum">    6932 </span><span class="lineCov">      13782 : </span>
<span class="lineNum">    6933 </span>            :           case RID_BUILTIN_LAUNDER:
<span class="lineNum">    6934 </span><span class="lineCov">      13782 :             if (vec-&gt;length () == 1)</span>
<span class="lineNum">    6935 </span>            :               postfix_expression = finish_builtin_launder (loc, (*vec)[0],
<span class="lineNum">    6936 </span><span class="lineCov">      10301 :                                                            tf_warning_or_error);</span>
<span class="lineNum">    6937 </span><span class="lineCov">      10301 :             else</span>
<span class="lineNum">    6938 </span><span class="lineCov">      10301 :               {</span>
<span class="lineNum">    6939 </span><span class="lineCov">      10301 :                 error_at (loc, &quot;wrong number of arguments to &quot;</span>
<span class="lineNum">    6940 </span><span class="lineCov">      10301 :                                &quot;%&lt;__builtin_launder%&gt;&quot;);</span>
<span class="lineNum">    6941 </span><span class="lineCov">      10301 :                 postfix_expression = error_mark_node;</span>
<span class="lineNum">    6942 </span><span class="lineCov">      10301 :               }</span>
<span class="lineNum">    6943 </span>            :             break;
<span class="lineNum">    6944 </span><span class="lineCov">      10301 : </span>
<span class="lineNum">    6945 </span><span class="lineCov">      10301 :           case RID_BUILTIN_SHUFFLE:</span>
<span class="lineNum">    6946 </span>            :             if (vec-&gt;length () == 2)
<span class="lineNum">    6947 </span>            :               postfix_expression
<span class="lineNum">    6948 </span><span class="lineCov">      10301 :                 = build_x_vec_perm_expr (loc, (*vec)[0], NULL_TREE,</span>
<span class="lineNum">    6949 </span>            :                                          (*vec)[1], tf_warning_or_error);
<span class="lineNum">    6950 </span><span class="lineNoCov">          0 :             else if (vec-&gt;length () == 3)</span>
<span class="lineNum">    6951 </span><span class="lineNoCov">          0 :               postfix_expression</span>
<span class="lineNum">    6952 </span>            :                 = build_x_vec_perm_expr (loc, (*vec)[0], (*vec)[1],
<span class="lineNum">    6953 </span>            :                                          (*vec)[2], tf_warning_or_error);
<span class="lineNum">    6954 </span><span class="lineCov">      28554 :             else</span>
<span class="lineNum">    6955 </span><span class="lineCov">      18253 :               {</span>
<span class="lineNum">    6956 </span>            :                 error_at (loc, &quot;wrong number of arguments to &quot;
<span class="lineNum">    6957 </span><span class="lineCov">      10301 :                                &quot;%&lt;__builtin_shuffle%&gt;&quot;);</span>
<span class="lineNum">    6958 </span>            :                 postfix_expression = error_mark_node;
<span class="lineNum">    6959 </span><span class="lineCov">       2564 :               }</span>
<span class="lineNum">    6960 </span><span class="lineCov">       2564 :             break;</span>
<span class="lineNum">    6961 </span><span class="lineCov">       2564 : </span>
<span class="lineNum">    6962 </span><span class="lineCov">       2564 :           default:</span>
<span class="lineNum">    6963 </span>            :             gcc_unreachable ();
<span class="lineNum">    6964 </span>            :           }
<span class="lineNum">    6965 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    6966 </span>            :       }
<span class="lineNum">    6967 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    6968 </span>            :     default:
<span class="lineNum">    6969 </span>            :       {
<span class="lineNum">    6970 </span>            :         tree type;
<span class="lineNum">    6971 </span><span class="lineCov">        523 : </span>
<span class="lineNum">    6972 </span><span class="lineCov">        523 :         /* If the next thing is a simple-type-specifier, we may be</span>
<span class="lineNum">    6973 </span><span class="lineCov">        517 :            looking at a functional cast.  We could also be looking at</span>
<span class="lineNum">    6974 </span>            :            an id-expression.  So, we try the functional cast, and if
<span class="lineNum">    6975 </span>            :            that doesn't work we fall back to the primary-expression.  */
<span class="lineNum">    6976 </span>            :         cp_parser_parse_tentatively (parser);
<span class="lineNum">    6977 </span><span class="lineCov">          6 :         /* Look for the simple-type-specifier.  */</span>
<span class="lineNum">    6978 </span>            :         ++parser-&gt;prevent_constrained_type_specifiers;
<span class="lineNum">    6979 </span><span class="lineCov">          6 :         type = cp_parser_simple_type_specifier (parser,</span>
<span class="lineNum">    6980 </span>            :                                                 /*decl_specs=*/NULL,
<span class="lineNum">    6981 </span>            :                                                 CP_PARSER_FLAGS_NONE);
<span class="lineNum">    6982 </span>            :         --parser-&gt;prevent_constrained_type_specifiers;
<span class="lineNum">    6983 </span><span class="lineCov">       7214 :         /* Parse the cast itself.  */</span>
<span class="lineNum">    6984 </span><span class="lineCov">       7214 :         if (!cp_parser_error_occurred (parser))</span>
<span class="lineNum">    6985 </span><span class="lineCov">       6478 :           postfix_expression</span>
<span class="lineNum">    6986 </span><span class="lineCov">       6478 :             = cp_parser_functional_cast (parser, type);</span>
<span class="lineNum">    6987 </span><span class="lineCov">       6478 :         /* If that worked, we're done.  */</span>
<span class="lineNum">    6988 </span><span class="lineCov">        736 :         if (cp_parser_parse_definitely (parser))</span>
<span class="lineNum">    6989 </span><span class="lineCov">        736 :           break;</span>
<span class="lineNum">    6990 </span><span class="lineCov">        736 : </span>
<span class="lineNum">    6991 </span><span class="lineCov">        736 :         /* If the functional-cast didn't work out, try a</span>
<span class="lineNum">    6992 </span>            :            compound-literal.  */
<span class="lineNum">    6993 </span>            :         if (cp_parser_allow_gnu_extensions_p (parser)
<span class="lineNum">    6994 </span><span class="lineNoCov">          0 :             &amp;&amp; cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_PAREN))</span>
<span class="lineNum">    6995 </span>            :           {
<span class="lineNum">    6996 </span><span class="lineNoCov">          0 :             cp_expr initializer = NULL_TREE;</span>
<span class="lineNum">    6997 </span>            : 
<span class="lineNum">    6998 </span>            :             cp_parser_parse_tentatively (parser);
<span class="lineNum">    6999 </span>            : 
<span class="lineNum">    7000 </span><span class="lineNoCov">          0 :             matching_parens parens;</span>
<span class="lineNum">    7001 </span><span class="lineNoCov">          0 :             parens.consume_open (parser);</span>
<span class="lineNum">    7002 </span>            : 
<span class="lineNum">    7003 </span>            :             /* Avoid calling cp_parser_type_id pointlessly, see comment
<span class="lineNum">    7004 </span>            :                in cp_parser_cast_expression about c++/29234.  */
<span class="lineNum">    7005 </span>            :             if (!cp_parser_compound_literal_p (parser))
<span class="lineNum">    7006 </span><span class="lineCov">   45546785 :               cp_parser_simulate_error (parser);</span>
<span class="lineNum">    7007 </span><span class="lineCov">   45546785 :             else</span>
<span class="lineNum">    7008 </span><span class="lineCov">   45546785 :               {</span>
<span class="lineNum">    7009 </span>            :                 /* Parse the type.  */
<span class="lineNum">    7010 </span>            :                 bool saved_in_type_id_in_expr_p = parser-&gt;in_type_id_in_expr_p;
<span class="lineNum">    7011 </span>            :                 parser-&gt;in_type_id_in_expr_p = true;
<span class="lineNum">    7012 </span>            :                 type = cp_parser_type_id (parser);
<span class="lineNum">    7013 </span>            :                 parser-&gt;in_type_id_in_expr_p = saved_in_type_id_in_expr_p;
<span class="lineNum">    7014 </span><span class="lineCov">   45546785 :                 parens.require_close (parser);</span>
<span class="lineNum">    7015 </span>            :               }
<span class="lineNum">    7016 </span><span class="lineCov">   45546785 : </span>
<span class="lineNum">    7017 </span><span class="lineCov">   45546785 :             /* If things aren't going well, there's no need to</span>
<span class="lineNum">    7018 </span>            :                keep going.  */
<span class="lineNum">    7019 </span>            :             if (!cp_parser_error_occurred (parser))
<span class="lineNum">    7020 </span><span class="lineCov">   45546785 :               {</span>
<span class="lineNum">    7021 </span>            :                 bool non_constant_p;
<span class="lineNum">    7022 </span><span class="lineCov">   46789131 :                 /* Parse the brace-enclosed initializer list.  */</span>
<span class="lineNum">    7023 </span><span class="lineCov">    1242346 :                 initializer = cp_parser_braced_list (parser,</span>
<span class="lineNum">    7024 </span><span class="lineCov">    1242346 :                                                      &amp;non_constant_p);</span>
<span class="lineNum">    7025 </span>            :               }
<span class="lineNum">    7026 </span><span class="lineCov">   45546785 :             /* If that worked, we're definitely looking at a</span>
<span class="lineNum">    7027 </span>            :                compound-literal expression.  */
<span class="lineNum">    7028 </span>            :             if (cp_parser_parse_definitely (parser))
<span class="lineNum">    7029 </span>            :               {
<span class="lineNum">    7030 </span>            :                 /* Warn the user that a compound literal is not
<span class="lineNum">    7031 </span><span class="lineCov">   88609326 :                    allowed in standard C++.  */</span>
<span class="lineNum">    7032 </span><span class="lineCov">   44304663 :                 pedwarn (input_location, OPT_Wpedantic,</span>
<span class="lineNum">    7033 </span>            :                          &quot;ISO C++ forbids compound-literals&quot;);
<span class="lineNum">    7034 </span><span class="lineCov">    3220535 :                 /* For simplicity, we disallow compound literals in</span>
<span class="lineNum">    7035 </span>            :                    constant-expressions.  We could
<span class="lineNum">    7036 </span><span class="lineCov">    3220535 :                    allow compound literals of integer type, whose</span>
<span class="lineNum">    7037 </span>            :                    initializer was a constant, in constant
<span class="lineNum">    7038 </span><span class="lineCov">    6441070 :                    expressions.  Permitting that usage, as a further</span>
<span class="lineNum">    7039 </span><span class="lineCov">    3220535 :                    extension, would not change the meaning of any</span>
<span class="lineNum">    7040 </span>            :                    currently accepted programs.  (Of course, as
<span class="lineNum">    7041 </span>            :                    compound literals are not part of ISO C++, the
<span class="lineNum">    7042 </span>            :                    standard has nothing to say.)  */
<span class="lineNum">    7043 </span><span class="lineCov">    3220535 :                 if (cp_parser_non_integral_constant_expression (parser,</span>
<span class="lineNum">    7044 </span><span class="lineCov">    3203247 :                                                                 NIC_NCC))</span>
<span class="lineNum">    7045 </span>            :                   {
<span class="lineNum">    7046 </span>            :                     postfix_expression = error_mark_node;
<span class="lineNum">    7047 </span>            :                     break;
<span class="lineNum">    7048 </span><span class="lineCov">      17288 :                   }</span>
<span class="lineNum">    7049 </span><span class="lineCov">      17288 :                 /* Form the representation of the compound-literal.  */</span>
<span class="lineNum">    7050 </span><span class="lineCov">      34576 :                 postfix_expression</span>
<span class="lineNum">    7051 </span><span class="lineCov">      17288 :                   = finish_compound_literal (type, initializer,</span>
<span class="lineNum">    7052 </span><span class="lineCov">      17288 :                                              tf_warning_or_error, fcl_c99);</span>
<span class="lineNum">    7053 </span>            :                 postfix_expression.set_location (initializer.get_location ());
<span class="lineNum">    7054 </span>            :                 break;
<span class="lineNum">    7055 </span>            :               }
<span class="lineNum">    7056 </span>            :           }
<span class="lineNum">    7057 </span><span class="lineCov">    3237813 : </span>
<span class="lineNum">    7058 </span>            :         /* It must be a primary-expression.  */
<span class="lineNum">    7059 </span><span class="lineCov">      17278 :         postfix_expression</span>
<span class="lineNum">    7060 </span>            :           = cp_parser_primary_expression (parser, address_p, cast_p,
<span class="lineNum">    7061 </span><span class="lineCov">      17278 :                                           /*template_arg_p=*/false,</span>
<span class="lineNum">    7062 </span><span class="lineCov">      17278 :                                           decltype_p,</span>
<span class="lineNum">    7063 </span>            :                                           &amp;idk);
<span class="lineNum">    7064 </span>            :       }
<span class="lineNum">    7065 </span>            :       break;
<span class="lineNum">    7066 </span><span class="lineCov">    3220535 :     }</span>
<span class="lineNum">    7067 </span>            : 
<span class="lineNum">    7068 </span>            :   /* Note that we don't need to worry about calling build_cplus_new on a
<span class="lineNum">    7069 </span>            :      class-valued CALL_EXPR in decltype when it isn't the end of the
<span class="lineNum">    7070 </span><span class="lineCov">      17278 :      postfix-expression; unary_complex_lvalue will take care of that for</span>
<span class="lineNum">    7071 </span>            :      all these cases.  */
<span class="lineNum">    7072 </span>            : 
<span class="lineNum">    7073 </span>            :   /* Keep looping until the postfix-expression is complete.  */
<span class="lineNum">    7074 </span>            :   while (true)
<span class="lineNum">    7075 </span>            :     {
<span class="lineNum">    7076 </span>            :       if (idk == CP_ID_KIND_UNQUALIFIED
<span class="lineNum">    7077 </span>            :           &amp;&amp; identifier_p (postfix_expression)
<span class="lineNum">    7078 </span>            :           &amp;&amp; cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_OPEN_PAREN))
<span class="lineNum">    7079 </span>            :         /* It is not a Koenig lookup function call.  */
<span class="lineNum">    7080 </span>            :         postfix_expression
<span class="lineNum">    7081 </span><span class="lineCov">      17278 :           = unqualified_name_lookup_error (postfix_expression);</span>
<span class="lineNum">    7082 </span>            : 
<span class="lineNum">    7083 </span>            :       /* Peek at the next token.  */
<span class="lineNum">    7084 </span><span class="lineNoCov">          0 :       token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">    7085 </span><span class="lineCov">      17278 : </span>
<span class="lineNum">    7086 </span>            :       switch (token-&gt;type)
<span class="lineNum">    7087 </span>            :         {
<span class="lineNum">    7088 </span><span class="lineCov">      17278 :         case CPP_OPEN_SQUARE:</span>
<span class="lineNum">    7089 </span><span class="lineCov">      34556 :           if (cp_next_tokens_can_be_std_attribute_p (parser))</span>
<span class="lineNum">    7090 </span>            :             {
<span class="lineNum">    7091 </span><span class="lineCov">      34556 :               cp_parser_error (parser,</span>
<span class="lineNum">    7092 </span>            :                                &quot;two consecutive %&lt;[%&gt; shall &quot;
<span class="lineNum">    7093 </span>            :                                &quot;only introduce an attribute&quot;);
<span class="lineNum">    7094 </span>            :               return error_mark_node;
<span class="lineNum">    7095 </span>            :             }
<span class="lineNum">    7096 </span>            :           postfix_expression
<span class="lineNum">    7097 </span><span class="lineCov">   44287385 :             = cp_parser_postfix_open_square_expression (parser,</span>
<span class="lineNum">    7098 </span><span class="lineCov">   44287385 :                                                         postfix_expression,</span>
<span class="lineNum">    7099 </span>            :                                                         false,
<span class="lineNum">    7100 </span>            :                                                         decltype_p);
<span class="lineNum">    7101 </span><span class="lineCov">   44287385 :           postfix_expression.set_range (start_loc,</span>
<span class="lineNum">    7102 </span>            :                                         postfix_expression.get_location ());
<span class="lineNum">    7103 </span><span class="lineCov">   44287385 : </span>
<span class="lineNum">    7104 </span>            :           idk = CP_ID_KIND_NONE;
<span class="lineNum">    7105 </span>            :           is_member_access = false;
<span class="lineNum">    7106 </span>            :           break;
<span class="lineNum">    7107 </span>            : 
<span class="lineNum">    7108 </span>            :         case CPP_OPEN_PAREN:
<span class="lineNum">    7109 </span>            :           /* postfix-expression ( expression-list [opt] ) */
<span class="lineNum">    7110 </span>            :           {
<span class="lineNum">    7111 </span>            :             bool koenig_p;
<span class="lineNum">    7112 </span><span class="lineCov">   61049938 :             bool is_builtin_constant_p;</span>
<span class="lineNum">    7113 </span>            :             bool saved_integral_constant_expression_p = false;
<span class="lineNum">    7114 </span><span class="lineCov">   61049938 :             bool saved_non_integral_constant_expression_p = false;</span>
<span class="lineNum">    7115 </span><span class="lineCov">   26329836 :             tsubst_flags_t complain = complain_flags (decltype_p);</span>
<span class="lineNum">    7116 </span><span class="lineCov">   61060633 :             vec&lt;tree, va_gc&gt; *args;</span>
<span class="lineNum">    7117 </span>            :             location_t close_paren_loc = UNKNOWN_LOCATION;
<span class="lineNum">    7118 </span><span class="lineCov">        863 : </span>
<span class="lineNum">    7119 </span><span class="lineCov">       1726 :             is_member_access = false;</span>
<span class="lineNum">    7120 </span>            : 
<span class="lineNum">    7121 </span>            :             is_builtin_constant_p
<span class="lineNum">    7122 </span><span class="lineCov">  122099876 :               = DECL_IS_BUILTIN_CONSTANT_P (postfix_expression);</span>
<span class="lineNum">    7123 </span>            :             if (is_builtin_constant_p)
<span class="lineNum">    7124 </span><span class="lineCov">   61049938 :               {</span>
<span class="lineNum">    7125 </span>            :                 /* The whole point of __builtin_constant_p is to allow
<span class="lineNum">    7126 </span><span class="lineCov">     633157 :                    non-constant expressions to appear as arguments.  */</span>
<span class="lineNum">    7127 </span><span class="lineCov">     633157 :                 saved_integral_constant_expression_p</span>
<span class="lineNum">    7128 </span>            :                   = parser-&gt;integral_constant_expression_p;
<span class="lineNum">    7129 </span><span class="lineCov">          6 :                 saved_non_integral_constant_expression_p</span>
<span class="lineNum">    7130 </span>            :                   = parser-&gt;non_integral_constant_expression_p;
<span class="lineNum">    7131 </span>            :                 parser-&gt;integral_constant_expression_p = false;
<span class="lineNum">    7132 </span><span class="lineCov">          6 :               }</span>
<span class="lineNum">    7133 </span>            :             args = (cp_parser_parenthesized_expression_list
<span class="lineNum">    7134 </span><span class="lineCov">     633151 :                     (parser, non_attr,</span>
<span class="lineNum">    7135 </span><span class="lineCov">    1266302 :                      /*cast_p=*/false, /*allow_expansion_p=*/true,</span>
<span class="lineNum">    7136 </span>            :                      /*non_constant_p=*/NULL,
<span class="lineNum">    7137 </span>            :                      /*close_paren_loc=*/&amp;close_paren_loc,
<span class="lineNum">    7138 </span>            :                      /*wrap_locations_p=*/true));
<span class="lineNum">    7139 </span><span class="lineCov">    1266302 :             if (is_builtin_constant_p)</span>
<span class="lineNum">    7140 </span>            :               {
<span class="lineNum">    7141 </span>            :                 parser-&gt;integral_constant_expression_p
<span class="lineNum">    7142 </span><span class="lineCov">     633151 :                   = saved_integral_constant_expression_p;</span>
<span class="lineNum">    7143 </span><span class="lineCov">     633151 :                 parser-&gt;non_integral_constant_expression_p</span>
<span class="lineNum">    7144 </span><span class="lineCov">     633151 :                   = saved_non_integral_constant_expression_p;</span>
<span class="lineNum">    7145 </span>            :               }
<span class="lineNum">    7146 </span><span class="lineCov">    9360827 : </span>
<span class="lineNum">    7147 </span>            :             if (args == NULL)
<span class="lineNum">    7148 </span><span class="lineCov">    9360827 :               {</span>
<span class="lineNum">    7149 </span><span class="lineCov">    9360827 :                 postfix_expression = error_mark_node;</span>
<span class="lineNum">    7150 </span><span class="lineCov">    9360827 :                 break;</span>
<span class="lineNum">    7151 </span><span class="lineCov">    9360827 :               }</span>
<span class="lineNum">    7152 </span><span class="lineCov">    9360827 : </span>
<span class="lineNum">    7153 </span><span class="lineCov">    9360827 :             /* Function calls are not permitted in</span>
<span class="lineNum">    7154 </span><span class="lineCov">    9360827 :                constant-expressions.  */</span>
<span class="lineNum">    7155 </span><span class="lineCov">    9360827 :             if (! builtin_valid_in_constant_expr_p (postfix_expression)</span>
<span class="lineNum">    7156 </span>            :                 &amp;&amp; cp_parser_non_integral_constant_expression (parser,
<span class="lineNum">    7157 </span><span class="lineCov">    9360827 :                                                                NIC_FUNC_CALL))</span>
<span class="lineNum">    7158 </span>            :               {
<span class="lineNum">    7159 </span><span class="lineCov">    9360827 :                 postfix_expression = error_mark_node;</span>
<span class="lineNum">    7160 </span><span class="lineCov">   18721654 :                 release_tree_vector (args);</span>
<span class="lineNum">    7161 </span><span class="lineCov">      18515 :                 break;</span>
<span class="lineNum">    7162 </span>            :               }
<span class="lineNum">    7163 </span>            : 
<span class="lineNum">    7164 </span>            :             koenig_p = false;
<span class="lineNum">    7165 </span><span class="lineCov">      18515 :             if (idk == CP_ID_KIND_UNQUALIFIED</span>
<span class="lineNum">    7166 </span><span class="lineCov">      18515 :                 || idk == CP_ID_KIND_TEMPLATE_ID)</span>
<span class="lineNum">    7167 </span><span class="lineCov">      18515 :               {</span>
<span class="lineNum">    7168 </span><span class="lineCov">      18515 :                 if (identifier_p (postfix_expression))</span>
<span class="lineNum">    7169 </span><span class="lineCov">      18515 :                   {</span>
<span class="lineNum">    7170 </span>            :                     if (!args-&gt;is_empty ())
<span class="lineNum">    7171 </span><span class="lineCov">   18721654 :                       {</span>
<span class="lineNum">    7172 </span><span class="lineCov">    9360827 :                         koenig_p = true;</span>
<span class="lineNum">    7173 </span>            :                         if (!any_type_dependent_arguments_p (args))
<span class="lineNum">    7174 </span>            :                           postfix_expression
<span class="lineNum">    7175 </span>            :                             = perform_koenig_lookup (postfix_expression, args,
<span class="lineNum">    7176 </span>            :                                                      complain);
<span class="lineNum">    7177 </span><span class="lineCov">    9360827 :                       }</span>
<span class="lineNum">    7178 </span>            :                     else
<span class="lineNum">    7179 </span><span class="lineCov">      18515 :                       postfix_expression</span>
<span class="lineNum">    7180 </span><span class="lineCov">      18515 :                         = unqualified_fn_lookup_error (postfix_expression);</span>
<span class="lineNum">    7181 </span><span class="lineCov">      18515 :                   }</span>
<span class="lineNum">    7182 </span><span class="lineCov">      18515 :                 /* We do not perform argument-dependent lookup if</span>
<span class="lineNum">    7183 </span>            :                    normal lookup finds a non-function, in accordance
<span class="lineNum">    7184 </span>            :                    with the expected resolution of DR 218.  */
<span class="lineNum">    7185 </span><span class="lineCov">    9360827 :                 else if (!args-&gt;is_empty ()</span>
<span class="lineNum">    7186 </span>            :                          &amp;&amp; is_overloaded_fn (postfix_expression))
<span class="lineNum">    7187 </span><span class="lineCov">         10 :                   {</span>
<span class="lineNum">    7188 </span><span class="lineCov">         10 :                     tree fn = get_first_fn (postfix_expression);</span>
<span class="lineNum">    7189 </span>            :                     fn = STRIP_TEMPLATE (fn);
<span class="lineNum">    7190 </span>            : 
<span class="lineNum">    7191 </span>            :                     /* Do not do argument dependent lookup if regular
<span class="lineNum">    7192 </span>            :                        lookup finds a member function or a block-scope
<span class="lineNum">    7193 </span><span class="lineCov">   18721634 :                        function declaration.  [basic.lookup.argdep]/3  */</span>
<span class="lineNum">    7194 </span><span class="lineCov">    9360817 :                     if (!DECL_FUNCTION_MEMBER_P (fn)</span>
<span class="lineNum">    7195 </span>            :                         &amp;&amp; !DECL_LOCAL_FUNCTION_P (fn))
<span class="lineNum">    7196 </span>            :                       {
<span class="lineNum">    7197 </span><span class="lineCov">          4 :                         koenig_p = true;</span>
<span class="lineNum">    7198 </span><span class="lineCov">          4 :                         if (!any_type_dependent_arguments_p (args))</span>
<span class="lineNum">    7199 </span><span class="lineCov">          4 :                           postfix_expression</span>
<span class="lineNum">    7200 </span>            :                             = perform_koenig_lookup (postfix_expression, args,
<span class="lineNum">    7201 </span>            :                                                      complain);
<span class="lineNum">    7202 </span><span class="lineCov">    9360813 :                       }</span>
<span class="lineNum">    7203 </span><span class="lineCov">    9360813 :                   }</span>
<span class="lineNum">    7204 </span><span class="lineCov">    6948833 :               }</span>
<span class="lineNum">    7205 </span>            : 
<span class="lineNum">    7206 </span><span class="lineCov">    5315202 :             if (TREE_CODE (postfix_expression) == COMPONENT_REF)</span>
<span class="lineNum">    7207 </span>            :               {
<span class="lineNum">    7208 </span><span class="lineCov">       9824 :                 tree instance = TREE_OPERAND (postfix_expression, 0);</span>
<span class="lineNum">    7209 </span>            :                 tree fn = TREE_OPERAND (postfix_expression, 1);
<span class="lineNum">    7210 </span><span class="lineCov">       9743 : </span>
<span class="lineNum">    7211 </span><span class="lineCov">       9743 :                 if (processing_template_decl</span>
<span class="lineNum">    7212 </span><span class="lineCov">       1347 :                     &amp;&amp; (type_dependent_object_expression_p (instance)</span>
<span class="lineNum">    7213 </span><span class="lineCov">       1347 :                         || (!BASELINK_P (fn)</span>
<span class="lineNum">    7214 </span><span class="lineCov">       1347 :                             &amp;&amp; TREE_CODE (fn) != FIELD_DECL)</span>
<span class="lineNum">    7215 </span>            :                         || type_dependent_expression_p (fn)
<span class="lineNum">    7216 </span>            :                         || any_type_dependent_arguments_p (args)))
<span class="lineNum">    7217 </span><span class="lineCov">         81 :                   {</span>
<span class="lineNum">    7218 </span><span class="lineCov">         81 :                     maybe_generic_this_capture (instance, fn);</span>
<span class="lineNum">    7219 </span>            :                     postfix_expression
<span class="lineNum">    7220 </span>            :                       = build_min_nt_call_vec (postfix_expression, args);
<span class="lineNum">    7221 </span>            :                     release_tree_vector (args);
<span class="lineNum">    7222 </span>            :                     break;
<span class="lineNum">    7223 </span><span class="lineCov">    2647777 :                   }</span>
<span class="lineNum">    7224 </span><span class="lineCov">    2647777 : </span>
<span class="lineNum">    7225 </span>            :                 if (BASELINK_P (fn))
<span class="lineNum">    7226 </span><span class="lineCov">    2022395 :                   {</span>
<span class="lineNum">    7227 </span><span class="lineCov">    2022395 :                   postfix_expression</span>
<span class="lineNum">    7228 </span>            :                     = (build_new_method_call
<span class="lineNum">    7229 </span>            :                        (instance, fn, &amp;args, NULL_TREE,
<span class="lineNum">    7230 </span>            :                         (idk == CP_ID_KIND_QUALIFIED
<span class="lineNum">    7231 </span>            :                          ? LOOKUP_NORMAL|LOOKUP_NONVIRTUAL
<span class="lineNum">    7232 </span><span class="lineCov">    4016338 :                          : LOOKUP_NORMAL),</span>
<span class="lineNum">    7233 </span><span class="lineCov">    3878239 :                         /*fn_p=*/NULL,</span>
<span class="lineNum">    7234 </span>            :                         complain));
<span class="lineNum">    7235 </span><span class="lineCov">    1855796 :                   }</span>
<span class="lineNum">    7236 </span><span class="lineCov">    1855796 :                 else</span>
<span class="lineNum">    7237 </span><span class="lineCov">    1510860 :                   postfix_expression</span>
<span class="lineNum">    7238 </span><span class="lineCov">    1510860 :                     = finish_call_expr (postfix_expression, &amp;args,</span>
<span class="lineNum">    7239 </span><span class="lineCov">    1510860 :                                         /*disallow_virtual=*/false,</span>
<span class="lineNum">    7240 </span>            :                                         /*koenig_p=*/false,
<span class="lineNum">    7241 </span>            :                                         complain);
<span class="lineNum">    7242 </span>            :               }
<span class="lineNum">    7243 </span>            :             else if (TREE_CODE (postfix_expression) == OFFSET_REF
<span class="lineNum">    7244 </span><span class="lineCov">   18721626 :                      || TREE_CODE (postfix_expression) == MEMBER_REF</span>
<span class="lineNum">    7245 </span>            :                      || TREE_CODE (postfix_expression) == DOTSTAR_EXPR)
<span class="lineNum">    7246 </span><span class="lineCov">    7917774 :               postfix_expression = (build_offset_ref_call_from_tree</span>
<span class="lineNum">    7247 </span><span class="lineCov">    7917774 :                                     (postfix_expression, &amp;args,</span>
<span class="lineNum">    7248 </span>            :                                      complain));
<span class="lineNum">    7249 </span><span class="lineCov">    3958887 :             else if (idk == CP_ID_KIND_QUALIFIED)</span>
<span class="lineNum">    7250 </span><span class="lineCov">    3958887 :               /* A call to a static class member, or a namespace-scope</span>
<span class="lineNum">    7251 </span><span class="lineCov">    2233488 :                  function.  */</span>
<span class="lineNum">    7252 </span><span class="lineCov">     381179 :               postfix_expression</span>
<span class="lineNum">    7253 </span><span class="lineCov">    1899255 :                 = finish_call_expr (postfix_expression, &amp;args,</span>
<span class="lineNum">    7254 </span><span class="lineCov">     135321 :                                     /*disallow_virtual=*/true,</span>
<span class="lineNum">    7255 </span>            :                                     koenig_p,
<span class="lineNum">    7256 </span><span class="lineCov">    3502857 :                                     complain);</span>
<span class="lineNum">    7257 </span><span class="lineCov">    3502857 :             else</span>
<span class="lineNum">    7258 </span><span class="lineCov">    7005714 :               /* All other function calls.  */</span>
<span class="lineNum">    7259 </span><span class="lineCov">    3502857 :               postfix_expression</span>
<span class="lineNum">    7260 </span><span class="lineCov">    3502857 :                 = finish_call_expr (postfix_expression, &amp;args,</span>
<span class="lineNum">    7261 </span>            :                                     /*disallow_virtual=*/false,
<span class="lineNum">    7262 </span>            :                                     koenig_p,
<span class="lineNum">    7263 </span><span class="lineCov">     456030 :                                     complain);</span>
<span class="lineNum">    7264 </span>            : 
<span class="lineNum">    7265 </span><span class="lineCov">     451244 :             if (close_paren_loc != UNKNOWN_LOCATION)</span>
<span class="lineNum">    7266 </span><span class="lineCov">     451244 :               {</span>
<span class="lineNum">    7267 </span>            :                 location_t combined_loc = make_location (token-&gt;location,
<span class="lineNum">    7268 </span><span class="lineCov">     451244 :                                                          start_loc,</span>
<span class="lineNum">    7269 </span>            :                                                          close_paren_loc);
<span class="lineNum">    7270 </span>            :                 postfix_expression.set_location (combined_loc);
<span class="lineNum">    7271 </span>            :               }
<span class="lineNum">    7272 </span>            : 
<span class="lineNum">    7273 </span>            :             /* The POSTFIX_EXPRESSION is certainly no longer an id.  */
<span class="lineNum">    7274 </span>            :             idk = CP_ID_KIND_NONE;
<span class="lineNum">    7275 </span><span class="lineCov">       4786 : </span>
<span class="lineNum">    7276 </span><span class="lineCov">       9572 :             release_tree_vector (args);</span>
<span class="lineNum">    7277 </span>            :           }
<span class="lineNum">    7278 </span>            :           break;
<span class="lineNum">    7279 </span>            : 
<span class="lineNum">    7280 </span>            :         case CPP_DOT:
<span class="lineNum">    7281 </span><span class="lineCov">    5401926 :         case CPP_DEREF:</span>
<span class="lineNum">    7282 </span><span class="lineCov">   10803118 :           /* postfix-expression . template [opt] id-expression</span>
<span class="lineNum">    7283 </span><span class="lineCov">   16188814 :              postfix-expression . pseudo-destructor-name</span>
<span class="lineNum">    7284 </span><span class="lineCov">      69866 :              postfix-expression -&gt; template [opt] id-expression</span>
<span class="lineNum">    7285 </span>            :              postfix-expression -&gt; pseudo-destructor-name */
<span class="lineNum">    7286 </span>            : 
<span class="lineNum">    7287 </span><span class="lineCov">    5366993 :           /* Consume the `.' or `-&gt;' operator.  */</span>
<span class="lineNum">    7288 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">    7289 </span>            : 
<span class="lineNum">    7290 </span><span class="lineCov">    1907268 :           postfix_expression</span>
<span class="lineNum">    7291 </span><span class="lineCov">    3814536 :             = cp_parser_postfix_dot_deref_expression (parser, token-&gt;type,</span>
<span class="lineNum">    7292 </span>            :                                                       postfix_expression,
<span class="lineNum">    7293 </span>            :                                                       false, &amp;idk, loc);
<span class="lineNum">    7294 </span>            : 
<span class="lineNum">    7295 </span>            :           is_member_access = true;
<span class="lineNum">    7296 </span>            :           break;
<span class="lineNum">    7297 </span><span class="lineCov">    3459725 : </span>
<span class="lineNum">    7298 </span><span class="lineCov">    6919450 :         case CPP_PLUS_PLUS:</span>
<span class="lineNum">    7299 </span>            :           /* postfix-expression ++  */
<span class="lineNum">    7300 </span>            :           /* Consume the `++' token.  */
<span class="lineNum">    7301 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">    7302 </span>            :           /* Generate a representation for the complete expression.  */
<span class="lineNum">    7303 </span><span class="lineCov">    5857946 :           postfix_expression</span>
<span class="lineNum">    7304 </span>            :             = finish_increment_expr (postfix_expression,
<span class="lineNum">    7305 </span><span class="lineCov">    5857820 :                                      POSTINCREMENT_EXPR);</span>
<span class="lineNum">    7306 </span>            :           /* Increments may not appear in constant-expressions.  */
<span class="lineNum">    7307 </span>            :           if (cp_parser_non_integral_constant_expression (parser, NIC_INC))
<span class="lineNum">    7308 </span><span class="lineCov">    5857820 :             postfix_expression = error_mark_node;</span>
<span class="lineNum">    7309 </span>            :           idk = CP_ID_KIND_NONE;
<span class="lineNum">    7310 </span>            :           is_member_access = false;
<span class="lineNum">    7311 </span>            :           break;
<span class="lineNum">    7312 </span><span class="lineCov">    5857946 : </span>
<span class="lineNum">    7313 </span>            :         case CPP_MINUS_MINUS:
<span class="lineNum">    7314 </span><span class="lineCov">    9360817 :           /* postfix-expression -- */</span>
<span class="lineNum">    7315 </span>            :           /* Consume the `--' token.  */
<span class="lineNum">    7316 </span><span class="lineCov">    5857946 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    7317 </span>            :           /* Generate a representation for the complete expression.  */
<span class="lineNum">    7318 </span><span class="lineCov">    4900788 :           postfix_expression</span>
<span class="lineNum">    7319 </span><span class="lineCov">    4900788 :             = finish_increment_expr (postfix_expression,</span>
<span class="lineNum">    7320 </span>            :                                      POSTDECREMENT_EXPR);
<span class="lineNum">    7321 </span>            :           /* Decrements may not appear in constant-expressions.  */
<span class="lineNum">    7322 </span>            :           if (cp_parser_non_integral_constant_expression (parser, NIC_DEC))
<span class="lineNum">    7323 </span>            :             postfix_expression = error_mark_node;
<span class="lineNum">    7324 </span>            :           idk = CP_ID_KIND_NONE;
<span class="lineNum">    7325 </span>            :           is_member_access = false;
<span class="lineNum">    7326 </span><span class="lineCov">    4900788 :           break;</span>
<span class="lineNum">    7327 </span>            : 
<span class="lineNum">    7328 </span><span class="lineCov">    4900788 :         default:</span>
<span class="lineNum">    7329 </span><span class="lineCov">    4900788 :           if (pidk_return != NULL)</span>
<span class="lineNum">    7330 </span>            :             * pidk_return = idk;
<span class="lineNum">    7331 </span>            :           if (member_access_only_p)
<span class="lineNum">    7332 </span>            :             return is_member_access
<span class="lineNum">    7333 </span><span class="lineCov">    4900785 :               ? postfix_expression</span>
<span class="lineNum">    7334 </span><span class="lineCov">    4900785 :               : cp_expr (error_mark_node);</span>
<span class="lineNum">    7335 </span>            :           else
<span class="lineNum">    7336 </span><span class="lineCov">     113341 :             return postfix_expression;</span>
<span class="lineNum">    7337 </span>            :         }
<span class="lineNum">    7338 </span>            :     }
<span class="lineNum">    7339 </span><span class="lineCov">     113341 : </span>
<span class="lineNum">    7340 </span>            :   /* We should never get here.  */
<span class="lineNum">    7341 </span><span class="lineCov">     113341 :   gcc_unreachable ();</span>
<span class="lineNum">    7342 </span><span class="lineCov">     113341 :   return error_mark_node;</span>
<span class="lineNum">    7343 </span><span class="lineCov">     113341 : }</span>
<span class="lineNum">    7344 </span>            : 
<span class="lineNum">    7345 </span><span class="lineCov">     113341 : /* A subroutine of cp_parser_postfix_expression that also gets hijacked</span>
<span class="lineNum">    7346 </span><span class="lineNoCov">          0 :    by cp_parser_builtin_offsetof.  We're looking for</span>
<span class="lineNum">    7347 </span><span class="lineCov">     113341 : </span>
<span class="lineNum">    7348 </span><span class="lineCov">     113341 :      postfix-expression [ expression ]</span>
<span class="lineNum">    7349 </span><span class="lineCov">     113341 :      postfix-expression [ braced-init-list ] (C++11)</span>
<span class="lineNum">    7350 </span>            : 
<span class="lineNum">    7351 </span><span class="lineCov">      32167 :    FOR_OFFSETOF is set if we're being called in that context, which</span>
<span class="lineNum">    7352 </span>            :    changes how we deal with integer constant expressions.  */
<a name="7353"><span class="lineNum">    7353 </span>            : </a>
<span class="lineNum">    7354 </span><span class="lineCov">      32167 : static tree</span>
<span class="lineNum">    7355 </span>            : cp_parser_postfix_open_square_expression (cp_parser *parser,
<span class="lineNum">    7356 </span><span class="lineCov">      32167 :                                           tree postfix_expression,</span>
<span class="lineNum">    7357 </span><span class="lineCov">      32167 :                                           bool for_offsetof,</span>
<span class="lineNum">    7358 </span><span class="lineCov">      32167 :                                           bool decltype_p)</span>
<span class="lineNum">    7359 </span>            : {
<span class="lineNum">    7360 </span><span class="lineCov">      32167 :   tree index = NULL_TREE;</span>
<span class="lineNum">    7361 </span><span class="lineNoCov">          0 :   location_t loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;</span>
<span class="lineNum">    7362 </span><span class="lineCov">      32167 :   bool saved_greater_than_is_operator_p;</span>
<span class="lineNum">    7363 </span><span class="lineCov">      32167 : </span>
<span class="lineNum">    7364 </span><span class="lineCov">      32167 :   /* Consume the `[' token.  */</span>
<span class="lineNum">    7365 </span>            :   cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">    7366 </span><span class="lineCov">   46009658 : </span>
<span class="lineNum">    7367 </span><span class="lineCov">   46009658 :   saved_greater_than_is_operator_p = parser-&gt;greater_than_is_operator_p;</span>
<span class="lineNum">    7368 </span><span class="lineCov">    3555029 :   parser-&gt;greater_than_is_operator_p = true;</span>
<span class="lineNum">    7369 </span><span class="lineCov">   46009658 : </span>
<span class="lineNum">    7370 </span><span class="lineCov">     182338 :   /* Parse the index expression.  */</span>
<span class="lineNum">    7371 </span>            :   /* ??? For offsetof, there is a question of what to allow here.  If
<span class="lineNum">    7372 </span><span class="lineCov">     182338 :      offsetof is not being used in an integral constant expression context,</span>
<span class="lineNum">    7373 </span>            :      then we *could* get the right answer by computing the value at runtime.
<span class="lineNum">    7374 </span><span class="lineCov">   45827320 :      If we are in an integral constant expression context, then we might</span>
<span class="lineNum">    7375 </span>            :      could accept any constant expression; hard to say without analysis.
<span class="lineNum">    7376 </span>            :      Rather than open the barn door too wide right away, allow only integer
<span class="lineNum">    7377 </span>            :      constant expressions here.  */
<span class="lineNum">    7378 </span>            :   if (for_offsetof)
<span class="lineNum">    7379 </span>            :     index = cp_parser_constant_expression (parser);
<span class="lineNum">    7380 </span>            :   else
<span class="lineNum">    7381 </span>            :     {
<span class="lineNum">    7382 </span>            :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_BRACE))
<span class="lineNum">    7383 </span>            :         {
<span class="lineNum">    7384 </span>            :           bool expr_nonconst_p;
<span class="lineNum">    7385 </span>            :           cp_lexer_set_source_position (parser-&gt;lexer);
<span class="lineNum">    7386 </span>            :           maybe_warn_cpp0x (CPP0X_INITIALIZER_LISTS);
<span class="lineNum">    7387 </span>            :           index = cp_parser_braced_list (parser, &amp;expr_nonconst_p);
<span class="lineNum">    7388 </span>            :         }
<span class="lineNum">    7389 </span>            :       else
<span class="lineNum">    7390 </span>            :         index = cp_parser_expression (parser);
<span class="lineNum">    7391 </span>            :     }
<span class="lineNum">    7392 </span>            : 
<span class="lineNum">    7393 </span><span class="lineCov">     633834 :   parser-&gt;greater_than_is_operator_p = saved_greater_than_is_operator_p;</span>
<span class="lineNum">    7394 </span>            : 
<span class="lineNum">    7395 </span>            :   /* Look for the closing `]'.  */
<span class="lineNum">    7396 </span>            :   cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);
<span class="lineNum">    7397 </span>            : 
<span class="lineNum">    7398 </span><span class="lineCov">     633834 :   /* Build the ARRAY_REF.  */</span>
<span class="lineNum">    7399 </span><span class="lineCov">    1267668 :   postfix_expression = grok_array_decl (loc, postfix_expression,</span>
<span class="lineNum">    7400 </span><span class="lineCov">     633834 :                                         index, decltype_p);</span>
<span class="lineNum">    7401 </span>            : 
<span class="lineNum">    7402 </span>            :   /* When not doing offsetof, array references are not permitted in
<span class="lineNum">    7403 </span><span class="lineCov">     633834 :      constant-expressions.  */</span>
<span class="lineNum">    7404 </span>            :   if (!for_offsetof
<span class="lineNum">    7405 </span><span class="lineCov">     633834 :       &amp;&amp; (cp_parser_non_integral_constant_expression (parser, NIC_ARRAY_REF)))</span>
<span class="lineNum">    7406 </span><span class="lineCov">     633834 :     postfix_expression = error_mark_node;</span>
<span class="lineNum">    7407 </span>            : 
<span class="lineNum">    7408 </span>            :   return postfix_expression;
<span class="lineNum">    7409 </span>            : }
<span class="lineNum">    7410 </span>            : 
<span class="lineNum">    7411 </span>            : /* A subroutine of cp_parser_postfix_dot_deref_expression.  Handle dot
<span class="lineNum">    7412 </span>            :    dereference of incomplete type, returns true if error_mark_node should
<span class="lineNum">    7413 </span>            :    be returned from caller, otherwise adjusts *SCOPE, *POSTFIX_EXPRESSION
<span class="lineNum">    7414 </span>            :    and *DEPENDENT_P.  */
<a name="7415"><span class="lineNum">    7415 </span>            : </a>
<span class="lineNum">    7416 </span><span class="lineCov">     633834 : bool</span>
<span class="lineNum">    7417 </span><span class="lineCov">        683 : cp_parser_dot_deref_incomplete (tree *scope, cp_expr *postfix_expression,</span>
<span class="lineNum">    7418 </span>            :                                 bool *dependent_p)
<span class="lineNum">    7419 </span>            : {
<span class="lineNum">    7420 </span><span class="lineCov">     633151 :   /* In a template, be permissive by treating an object expression</span>
<span class="lineNum">    7421 </span>            :      of incomplete type as dependent (after a pedwarn).  */
<span class="lineNum">    7422 </span><span class="lineCov">          9 :   diagnostic_t kind = (processing_template_decl</span>
<span class="lineNum">    7423 </span><span class="lineCov">         18 :                        &amp;&amp; MAYBE_CLASS_TYPE_P (*scope) ? DK_PEDWARN : DK_ERROR);</span>
<span class="lineNum">    7424 </span><span class="lineCov">          9 : </span>
<span class="lineNum">    7425 </span><span class="lineCov">          9 :   switch (TREE_CODE (*postfix_expression))</span>
<span class="lineNum">    7426 </span>            :     {
<span class="lineNum">    7427 </span>            :     case CAST_EXPR:
<span class="lineNum">    7428 </span><span class="lineCov">     633142 :     case REINTERPRET_CAST_EXPR:</span>
<span class="lineNum">    7429 </span>            :     case CONST_CAST_EXPR:
<span class="lineNum">    7430 </span>            :     case STATIC_CAST_EXPR:
<span class="lineNum">    7431 </span><span class="lineCov">     633834 :     case DYNAMIC_CAST_EXPR:</span>
<span class="lineNum">    7432 </span>            :     case IMPLICIT_CONV_EXPR:
<span class="lineNum">    7433 </span>            :     case VIEW_CONVERT_EXPR:
<span class="lineNum">    7434 </span><span class="lineCov">     633834 :     case NON_LVALUE_EXPR:</span>
<span class="lineNum">    7435 </span>            :       kind = DK_ERROR;
<span class="lineNum">    7436 </span>            :       break;
<span class="lineNum">    7437 </span><span class="lineCov">     633834 :     case OVERLOAD:</span>
<span class="lineNum">    7438 </span>            :       /* Don't emit any diagnostic for OVERLOADs.  */
<span class="lineNum">    7439 </span>            :       kind = DK_IGNORED;
<span class="lineNum">    7440 </span>            :       break;
<span class="lineNum">    7441 </span>            :     default:
<span class="lineNum">    7442 </span><span class="lineCov">     633834 :       /* Avoid clobbering e.g. DECLs.  */</span>
<span class="lineNum">    7443 </span><span class="lineCov">     633834 :       if (!EXPR_P (*postfix_expression))</span>
<span class="lineNum">    7444 </span><span class="lineCov">          5 :         kind = DK_ERROR;</span>
<span class="lineNum">    7445 </span>            :       break;
<span class="lineNum">    7446 </span><span class="lineCov">     633834 :     }</span>
<span class="lineNum">    7447 </span>            : 
<span class="lineNum">    7448 </span>            :   if (kind == DK_IGNORED)
<span class="lineNum">    7449 </span>            :     return false;
<span class="lineNum">    7450 </span>            : 
<span class="lineNum">    7451 </span>            :   location_t exploc = location_of (*postfix_expression);
<span class="lineNum">    7452 </span>            :   cxx_incomplete_type_diagnostic (exploc, *postfix_expression, *scope, kind);
<span class="lineNum">    7453 </span>            :   if (!MAYBE_CLASS_TYPE_P (*scope))
<span class="lineNum">    7454 </span>            :     return true;
<span class="lineNum">    7455 </span><span class="lineCov">         41 :   if (kind == DK_ERROR)</span>
<span class="lineNum">    7456 </span>            :     *scope = *postfix_expression = error_mark_node;
<span class="lineNum">    7457 </span>            :   else if (processing_template_decl)
<span class="lineNum">    7458 </span>            :     {
<span class="lineNum">    7459 </span>            :       *dependent_p = true;
<span class="lineNum">    7460 </span><span class="lineCov">         41 :       *scope = TREE_TYPE (*postfix_expression) = NULL_TREE;</span>
<span class="lineNum">    7461 </span><span class="lineCov">         41 :     }</span>
<span class="lineNum">    7462 </span>            :   return false;
<span class="lineNum">    7463 </span><span class="lineCov">         82 : }</span>
<span class="lineNum">    7464 </span>            : 
<span class="lineNum">    7465 </span>            : /* A subroutine of cp_parser_postfix_expression that also gets hijacked
<span class="lineNum">    7466 </span>            :    by cp_parser_builtin_offsetof.  We're looking for
<span class="lineNum">    7467 </span>            : 
<span class="lineNum">    7468 </span>            :      postfix-expression . template [opt] id-expression
<span class="lineNum">    7469 </span>            :      postfix-expression . pseudo-destructor-name
<span class="lineNum">    7470 </span>            :      postfix-expression -&gt; template [opt] id-expression
<span class="lineNum">    7471 </span>            :      postfix-expression -&gt; pseudo-destructor-name
<span class="lineNum">    7472 </span>            : 
<span class="lineNum">    7473 </span>            :    FOR_OFFSETOF is set if we're being called in that context.  That sorta
<span class="lineNum">    7474 </span>            :    limits what of the above we'll actually accept, but nevermind.
<span class="lineNum">    7475 </span>            :    TOKEN_TYPE is the &quot;.&quot; or &quot;-&gt;&quot; token, which will already have been
<span class="lineNum">    7476 </span>            :    removed from the stream.  */
<a name="7477"><span class="lineNum">    7477 </span>            : </a>
<span class="lineNum">    7478 </span>            : static tree
<span class="lineNum">    7479 </span><span class="lineCov">         35 : cp_parser_postfix_dot_deref_expression (cp_parser *parser,</span>
<span class="lineNum">    7480 </span>            :                                         enum cpp_ttype token_type,
<span class="lineNum">    7481 </span><span class="lineCov">         70 :                                         cp_expr postfix_expression,</span>
<span class="lineNum">    7482 </span>            :                                         bool for_offsetof, cp_id_kind *idk,
<span class="lineNum">    7483 </span>            :                                         location_t location)
<span class="lineNum">    7484 </span>            : {
<span class="lineNum">    7485 </span>            :   tree name;
<span class="lineNum">    7486 </span>            :   bool dependent_p;
<span class="lineNum">    7487 </span>            :   bool pseudo_destructor_p;
<span class="lineNum">    7488 </span>            :   tree scope = NULL_TREE;
<span class="lineNum">    7489 </span><span class="lineCov">         76 :   location_t start_loc = postfix_expression.get_start ();</span>
<span class="lineNum">    7490 </span><span class="lineCov">         76 : </span>
<span class="lineNum">    7491 </span><span class="lineCov">         38 :   /* If this is a `-&gt;' operator, dereference the pointer.  */</span>
<span class="lineNum">    7492 </span>            :   if (token_type == CPP_DEREF)
<span class="lineNum">    7493 </span><span class="lineCov">         23 :     postfix_expression = build_x_arrow (location, postfix_expression,</span>
<span class="lineNum">    7494 </span><span class="lineCov">         20 :                                         tf_warning_or_error);</span>
<span class="lineNum">    7495 </span><span class="lineCov">          3 :   /* Check to see whether or not the expression is type-dependent and</span>
<span class="lineNum">    7496 </span>            :      not the current instantiation.  */
<span class="lineNum">    7497 </span><span class="lineCov">          3 :   dependent_p = type_dependent_object_expression_p (postfix_expression);</span>
<span class="lineNum">    7498 </span><span class="lineCov">          6 :   /* The identifier following the `-&gt;' or `.' is not qualified.  */</span>
<span class="lineNum">    7499 </span>            :   parser-&gt;scope = NULL_TREE;
<span class="lineNum">    7500 </span>            :   parser-&gt;qualifying_scope = NULL_TREE;
<span class="lineNum">    7501 </span>            :   parser-&gt;object_scope = NULL_TREE;
<span class="lineNum">    7502 </span>            :   *idk = CP_ID_KIND_NONE;
<span class="lineNum">    7503 </span>            : 
<span class="lineNum">    7504 </span>            :   /* Enter the scope corresponding to the type of the object
<span class="lineNum">    7505 </span>            :      given by the POSTFIX_EXPRESSION.  */
<span class="lineNum">    7506 </span>            :   if (!dependent_p)
<span class="lineNum">    7507 </span>            :     {
<span class="lineNum">    7508 </span>            :       scope = TREE_TYPE (postfix_expression);
<span class="lineNum">    7509 </span>            :       /* According to the standard, no expression should ever have
<span class="lineNum">    7510 </span>            :          reference type.  Unfortunately, we do not currently match
<span class="lineNum">    7511 </span>            :          the standard in this respect in that our internal representation
<span class="lineNum">    7512 </span>            :          of an expression may have reference type even when the standard
<span class="lineNum">    7513 </span>            :          says it does not.  Therefore, we have to manually obtain the
<span class="lineNum">    7514 </span>            :          underlying type here.  */
<span class="lineNum">    7515 </span>            :       scope = non_reference (scope);
<span class="lineNum">    7516 </span>            :       /* The type of the POSTFIX_EXPRESSION must be complete.  */
<span class="lineNum">    7517 </span><span class="lineCov">    4903577 :       /* Unlike the object expression in other contexts, *this is not</span>
<span class="lineNum">    7518 </span>            :          required to be of complete type for purposes of class member
<span class="lineNum">    7519 </span>            :          access (5.2.5) outside the member function body.  */
<span class="lineNum">    7520 </span>            :       if (postfix_expression != current_class_ref
<span class="lineNum">    7521 </span>            :           &amp;&amp; scope != error_mark_node
<span class="lineNum">    7522 </span>            :           &amp;&amp; !currently_open_class (scope))
<span class="lineNum">    7523 </span><span class="lineCov">    4903577 :         {</span>
<span class="lineNum">    7524 </span><span class="lineCov">    4903577 :           scope = complete_type (scope);</span>
<span class="lineNum">    7525 </span><span class="lineCov">    4903577 :           if (!COMPLETE_TYPE_P (scope)</span>
<span class="lineNum">    7526 </span><span class="lineCov">    4903577 :               &amp;&amp; cp_parser_dot_deref_incomplete (&amp;scope, &amp;postfix_expression,</span>
<span class="lineNum">    7527 </span><span class="lineCov">    4903577 :                                                  &amp;dependent_p))</span>
<span class="lineNum">    7528 </span>            :             return error_mark_node;
<span class="lineNum">    7529 </span>            :         }
<span class="lineNum">    7530 </span><span class="lineCov">    4903577 : </span>
<span class="lineNum">    7531 </span><span class="lineCov">    3341442 :       if (!dependent_p)</span>
<span class="lineNum">    7532 </span>            :         {
<span class="lineNum">    7533 </span>            :           /* Let the name lookup machinery know that we are processing a
<span class="lineNum">    7534 </span>            :              class member access expression.  */
<span class="lineNum">    7535 </span><span class="lineCov">    9807148 :           parser-&gt;context-&gt;object_type = scope;</span>
<span class="lineNum">    7536 </span>            :           /* If something went wrong, we want to be able to discern that case,
<span class="lineNum">    7537 </span><span class="lineCov">    4903574 :              as opposed to the case where there was no SCOPE due to the type</span>
<span class="lineNum">    7538 </span><span class="lineCov">    4903574 :              of expression being dependent.  */</span>
<span class="lineNum">    7539 </span><span class="lineCov">    4903574 :           if (!scope)</span>
<span class="lineNum">    7540 </span><span class="lineCov">    4903574 :             scope = error_mark_node;</span>
<span class="lineNum">    7541 </span>            :           /* If the SCOPE was erroneous, make the various semantic analysis
<span class="lineNum">    7542 </span>            :              functions exit quickly -- and without issuing additional error
<span class="lineNum">    7543 </span>            :              messages.  */
<span class="lineNum">    7544 </span><span class="lineCov">    4903574 :           if (scope == error_mark_node)</span>
<span class="lineNum">    7545 </span>            :             postfix_expression = error_mark_node;
<span class="lineNum">    7546 </span><span class="lineCov">    5385576 :         }</span>
<span class="lineNum">    7547 </span>            :     }
<span class="lineNum">    7548 </span>            : 
<span class="lineNum">    7549 </span>            :   if (dependent_p)
<span class="lineNum">    7550 </span>            :     /* Tell cp_parser_lookup_name that there was an object, even though it's
<span class="lineNum">    7551 </span>            :        type-dependent.  */
<span class="lineNum">    7552 </span>            :     parser-&gt;context-&gt;object_type = unknown_type_node;
<span class="lineNum">    7553 </span><span class="lineCov">    2692788 : </span>
<span class="lineNum">    7554 </span>            :   /* Assume this expression is not a pseudo-destructor access.  */
<span class="lineNum">    7555 </span>            :   pseudo_destructor_p = false;
<span class="lineNum">    7556 </span>            : 
<span class="lineNum">    7557 </span>            :   /* If the SCOPE is a scalar type, then, if this is a valid program,
<span class="lineNum">    7558 </span><span class="lineCov">    5385576 :      we must be looking at a pseudo-destructor-name.  If POSTFIX_EXPRESSION</span>
<span class="lineNum">    7559 </span><span class="lineCov">    2678188 :      is type dependent, it can be pseudo-destructor-name or something else.</span>
<span class="lineNum">    7560 </span><span class="lineCov">    5370860 :      Try to parse it as pseudo-destructor-name first.  */</span>
<span class="lineNum">    7561 </span>            :   if ((scope &amp;&amp; SCALAR_TYPE_P (scope)) || dependent_p)
<span class="lineNum">    7562 </span><span class="lineCov">    1067996 :     {</span>
<span class="lineNum">    7563 </span><span class="lineCov">    1067996 :       tree s;</span>
<span class="lineNum">    7564 </span><span class="lineCov">    1067996 :       tree type;</span>
<span class="lineNum">    7565 </span>            : 
<span class="lineNum">    7566 </span><span class="lineCov">         15 :       cp_parser_parse_tentatively (parser);</span>
<span class="lineNum">    7567 </span>            :       /* Parse the pseudo-destructor-name.  */
<span class="lineNum">    7568 </span>            :       s = NULL_TREE;
<span class="lineNum">    7569 </span><span class="lineCov">    2692773 :       cp_parser_pseudo_destructor_name (parser, postfix_expression,</span>
<span class="lineNum">    7570 </span>            :                                         &amp;s, &amp;type);
<span class="lineNum">    7571 </span>            :       if (dependent_p
<span class="lineNum">    7572 </span>            :           &amp;&amp; (cp_parser_error_occurred (parser)
<span class="lineNum">    7573 </span><span class="lineCov">    2692770 :               || !SCALAR_TYPE_P (type)))</span>
<span class="lineNum">    7574 </span>            :         cp_parser_abort_tentative_parse (parser);
<span class="lineNum">    7575 </span>            :       else if (cp_parser_parse_definitely (parser))
<span class="lineNum">    7576 </span>            :         {
<span class="lineNum">    7577 </span><span class="lineCov">    2692770 :           pseudo_destructor_p = true;</span>
<span class="lineNum">    7578 </span><span class="lineNoCov">          0 :           postfix_expression</span>
<span class="lineNum">    7579 </span>            :             = finish_pseudo_destructor_expr (postfix_expression,
<span class="lineNum">    7580 </span>            :                                              s, type, location);
<span class="lineNum">    7581 </span>            :         }
<span class="lineNum">    7582 </span><span class="lineCov">    2692770 :     }</span>
<span class="lineNum">    7583 </span><span class="lineCov">        136 : </span>
<span class="lineNum">    7584 </span>            :   if (!pseudo_destructor_p)
<span class="lineNum">    7585 </span>            :     {
<span class="lineNum">    7586 </span>            :       /* If the SCOPE is not a scalar type, we are looking at an
<span class="lineNum">    7587 </span><span class="lineCov">    4903559 :          ordinary class member access expression, rather than a</span>
<span class="lineNum">    7588 </span>            :          pseudo-destructor-name.  */
<span class="lineNum">    7589 </span>            :       bool template_p;
<span class="lineNum">    7590 </span><span class="lineCov">    2210789 :       cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">    7591 </span>            :       /* Parse the id-expression.  */
<span class="lineNum">    7592 </span>            :       name = (cp_parser_id_expression
<span class="lineNum">    7593 </span><span class="lineCov">    4903559 :               (parser,</span>
<span class="lineNum">    7594 </span>            :                cp_parser_optional_template_keyword (parser),
<span class="lineNum">    7595 </span>            :                /*check_dependency_p=*/true,
<span class="lineNum">    7596 </span>            :                &amp;template_p,
<span class="lineNum">    7597 </span>            :                /*declarator_p=*/false,
<span class="lineNum">    7598 </span>            :                /*optional_p=*/false));
<span class="lineNum">    7599 </span><span class="lineCov">    4903559 :       /* In general, build a SCOPE_REF if the member name is qualified.</span>
<span class="lineNum">    7600 </span>            :          However, if the name was not dependent and has already been
<span class="lineNum">    7601 </span><span class="lineCov">    2210894 :          resolved; there is no need to build the SCOPE_REF.  For example;</span>
<span class="lineNum">    7602 </span><span class="lineCov">    2210894 : </span>
<span class="lineNum">    7603 </span>            :              struct X { void f(); };
<span class="lineNum">    7604 </span><span class="lineCov">    2210894 :              template &lt;typename T&gt; void f(T* t) { t-&gt;X::f(); }</span>
<span class="lineNum">    7605 </span>            : 
<span class="lineNum">    7606 </span><span class="lineCov">    2210894 :          Even though &quot;t&quot; is dependent, &quot;X::f&quot; is not and has been resolved</span>
<span class="lineNum">    7607 </span><span class="lineCov">    4421788 :          to a BASELINK; there is no need to include scope information.  */</span>
<span class="lineNum">    7608 </span>            : 
<span class="lineNum">    7609 </span><span class="lineCov">    2210894 :       /* But we do need to remember that there was an explicit scope for</span>
<span class="lineNum">    7610 </span><span class="lineCov">    2210894 :          virtual function calls.  */</span>
<span class="lineNum">    7611 </span><span class="lineCov">      20140 :       if (parser-&gt;scope)</span>
<span class="lineNum">    7612 </span><span class="lineCov">    2210774 :         *idk = CP_ID_KIND_QUALIFIED;</span>
<span class="lineNum">    7613 </span><span class="lineCov">        120 : </span>
<span class="lineNum">    7614 </span>            :       /* If the name is a template-id that names a type, we will get a
<span class="lineNum">    7615 </span><span class="lineCov">         88 :          TYPE_DECL here.  That is invalid code.  */</span>
<span class="lineNum">    7616 </span><span class="lineCov">         88 :       if (TREE_CODE (name) == TYPE_DECL)</span>
<span class="lineNum">    7617 </span><span class="lineCov">        176 :         {</span>
<span class="lineNum">    7618 </span>            :           error_at (token-&gt;location, &quot;invalid use of %qD&quot;, name);
<span class="lineNum">    7619 </span>            :           postfix_expression = error_mark_node;
<span class="lineNum">    7620 </span>            :         }
<span class="lineNum">    7621 </span>            :       else
<span class="lineNum">    7622 </span><span class="lineCov">    2210894 :         {</span>
<span class="lineNum">    7623 </span>            :           if (name != error_mark_node &amp;&amp; !BASELINK_P (name) &amp;&amp; parser-&gt;scope)
<span class="lineNum">    7624 </span>            :             {
<span class="lineNum">    7625 </span>            :               if (TREE_CODE (parser-&gt;scope) == NAMESPACE_DECL)
<span class="lineNum">    7626 </span>            :                 {
<span class="lineNum">    7627 </span><span class="lineCov">    4903471 :                   error_at (token-&gt;location, &quot;%&lt;%D::%D%&gt; is not a class member&quot;,</span>
<span class="lineNum">    7628 </span><span class="lineCov">    9806942 :                             parser-&gt;scope, name);</span>
<span class="lineNum">    7629 </span>            :                   postfix_expression = error_mark_node;
<span class="lineNum">    7630 </span><span class="lineCov">    9806942 :                 }</span>
<span class="lineNum">    7631 </span><span class="lineCov">    4903471 :               else</span>
<span class="lineNum">    7632 </span><span class="lineCov">    4903471 :                 name = build_qualified_name (/*type=*/NULL_TREE,</span>
<span class="lineNum">    7633 </span>            :                                              parser-&gt;scope,
<span class="lineNum">    7634 </span>            :                                              name,
<span class="lineNum">    7635 </span>            :                                              template_p);
<span class="lineNum">    7636 </span><span class="lineCov">    4903471 :               parser-&gt;scope = NULL_TREE;</span>
<span class="lineNum">    7637 </span>            :               parser-&gt;qualifying_scope = NULL_TREE;
<span class="lineNum">    7638 </span>            :               parser-&gt;object_scope = NULL_TREE;
<span class="lineNum">    7639 </span>            :             }
<span class="lineNum">    7640 </span>            :           if (parser-&gt;scope &amp;&amp; name &amp;&amp; BASELINK_P (name))
<span class="lineNum">    7641 </span>            :             adjust_result_of_qualified_name_lookup
<span class="lineNum">    7642 </span>            :               (name, parser-&gt;scope, scope);
<span class="lineNum">    7643 </span>            :           postfix_expression
<span class="lineNum">    7644 </span>            :             = finish_class_member_access_expr (postfix_expression, name,
<span class="lineNum">    7645 </span>            :                                                template_p, 
<span class="lineNum">    7646 </span>            :                                                tf_warning_or_error);
<span class="lineNum">    7647 </span>            :           /* Build a location e.g.:
<span class="lineNum">    7648 </span>            :                ptr-&gt;access_expr
<span class="lineNum">    7649 </span><span class="lineCov">    4903471 :                ~~~^~~~~~~~~~~~~</span>
<span class="lineNum">    7650 </span><span class="lineCov">       7942 :              where the caret is at the deref token, ranging from</span>
<span class="lineNum">    7651 </span>            :              the start of postfix_expression to the end of the access expr.  */
<span class="lineNum">    7652 </span>            :           location_t end_loc
<span class="lineNum">    7653 </span>            :             = get_finish (cp_lexer_previous_token (parser-&gt;lexer)-&gt;location);
<span class="lineNum">    7654 </span><span class="lineCov">    4903471 :           location_t combined_loc</span>
<span class="lineNum">    7655 </span>            :             = make_location (input_location, start_loc, end_loc);
<span class="lineNum">    7656 </span><span class="lineCov">          3 :           protected_set_expr_location (postfix_expression, combined_loc);</span>
<span class="lineNum">    7657 </span><span class="lineCov">          3 :         }</span>
<span class="lineNum">    7658 </span>            :     }
<span class="lineNum">    7659 </span>            : 
<span class="lineNum">    7660 </span>            :   /* We no longer need to look up names in the scope of the object on
<span class="lineNum">    7661 </span><span class="lineCov">    4903468 :      the left-hand side of the `.' or `-&gt;' operator.  */</span>
<span class="lineNum">    7662 </span>            :   parser-&gt;context-&gt;object_type = NULL_TREE;
<span class="lineNum">    7663 </span><span class="lineCov">       7896 : </span>
<span class="lineNum">    7664 </span>            :   /* Outside of offsetof, these operators may not appear in
<span class="lineNum">    7665 </span><span class="lineCov">         12 :      constant-expressions.  */</span>
<span class="lineNum">    7666 </span>            :   if (!for_offsetof
<span class="lineNum">    7667 </span><span class="lineCov">         12 :       &amp;&amp; (cp_parser_non_integral_constant_expression</span>
<span class="lineNum">    7668 </span>            :           (parser, token_type == CPP_DEREF ? NIC_ARROW : NIC_POINT)))
<span class="lineNum">    7669 </span>            :     postfix_expression = error_mark_node;
<span class="lineNum">    7670 </span><span class="lineCov">       7884 : </span>
<span class="lineNum">    7671 </span>            :   return postfix_expression;
<span class="lineNum">    7672 </span>            : }
<span class="lineNum">    7673 </span>            : 
<span class="lineNum">    7674 </span><span class="lineCov">       7896 : /* Parse a parenthesized expression-list.</span>
<span class="lineNum">    7675 </span><span class="lineCov">       7896 : </span>
<span class="lineNum">    7676 </span><span class="lineCov">       7896 :    expression-list:</span>
<span class="lineNum">    7677 </span>            :      assignment-expression
<span class="lineNum">    7678 </span><span class="lineCov">    4903468 :      expression-list, assignment-expression</span>
<span class="lineNum">    7679 </span><span class="lineCov">         46 : </span>
<span class="lineNum">    7680 </span><span class="lineCov">         46 :    attribute-list:</span>
<span class="lineNum">    7681 </span><span class="lineCov">    4903468 :      expression-list</span>
<span class="lineNum">    7682 </span><span class="lineCov">    4903468 :      identifier</span>
<span class="lineNum">    7683 </span>            :      identifier, expression-list
<span class="lineNum">    7684 </span>            : 
<span class="lineNum">    7685 </span>            :    CAST_P is true if this expression is the target of a cast.
<span class="lineNum">    7686 </span>            : 
<span class="lineNum">    7687 </span>            :    ALLOW_EXPANSION_P is true if this expression allows expansion of an
<span class="lineNum">    7688 </span>            :    argument pack.
<span class="lineNum">    7689 </span>            : 
<span class="lineNum">    7690 </span><span class="lineCov">    4903468 :    WRAP_LOCATIONS_P is true if expressions within this list for which</span>
<span class="lineNum">    7691 </span><span class="lineCov">    4903468 :    CAN_HAVE_LOCATION_P is false should be wrapped with nodes expressing</span>
<span class="lineNum">    7692 </span><span class="lineCov">    4903468 :    their source locations.</span>
<span class="lineNum">    7693 </span><span class="lineCov">    4903468 : </span>
<span class="lineNum">    7694 </span><span class="lineCov">    9806936 :    Returns a vector of trees.  Each element is a representation of an</span>
<span class="lineNum">    7695 </span>            :    assignment-expression.  NULL is returned if the ( and or ) are
<span class="lineNum">    7696 </span>            :    missing.  An empty, but allocated, vector is returned on no
<span class="lineNum">    7697 </span>            :    expressions.  The parentheses are eaten.  IS_ATTRIBUTE_LIST is id_attr
<span class="lineNum">    7698 </span>            :    if we are parsing an attribute list for an attribute that wants a
<span class="lineNum">    7699 </span>            :    plain identifier argument, normal_attr for an attribute that wants
<span class="lineNum">    7700 </span><span class="lineCov">    4903559 :    an expression, or non_attr if we aren't parsing an attribute list.  If</span>
<span class="lineNum">    7701 </span>            :    NON_CONSTANT_P is non-NULL, *NON_CONSTANT_P indicates whether or
<span class="lineNum">    7702 </span>            :    not all of the expressions in the list were constant.
<span class="lineNum">    7703 </span>            :    If CLOSE_PAREN_LOC is non-NULL, and no errors occur, then *CLOSE_PAREN_LOC
<span class="lineNum">    7704 </span><span class="lineCov">    4903559 :    will be written to with the location of the closing parenthesis.  If</span>
<span class="lineNum">    7705 </span><span class="lineCov">    9804869 :    an error occurs, it may or may not be written to.  */</span>
<a name="7706"><span class="lineNum">    7706 </span><span class="lineCov">    8133909 : </span></a>
<span class="lineNum">    7707 </span><span class="lineCov">          2 : static vec&lt;tree, va_gc&gt; *</span>
<span class="lineNum">    7708 </span>            : cp_parser_parenthesized_expression_list (cp_parser* parser,
<span class="lineNum">    7709 </span><span class="lineCov">    9807118 :                                          int is_attribute_list,</span>
<span class="lineNum">    7710 </span>            :                                          bool cast_p,
<span class="lineNum">    7711 </span>            :                                          bool allow_expansion_p,
<span class="lineNum">    7712 </span>            :                                          bool *non_constant_p,
<span class="lineNum">    7713 </span>            :                                          location_t *close_paren_loc,
<span class="lineNum">    7714 </span>            :                                          bool wrap_locations_p)
<span class="lineNum">    7715 </span>            : {
<span class="lineNum">    7716 </span>            :   vec&lt;tree, va_gc&gt; *expression_list;
<span class="lineNum">    7717 </span>            :   bool fold_expr_p = is_attribute_list != non_attr;
<span class="lineNum">    7718 </span>            :   tree identifier = NULL_TREE;
<span class="lineNum">    7719 </span>            :   bool saved_greater_than_is_operator_p;
<span class="lineNum">    7720 </span>            : 
<span class="lineNum">    7721 </span>            :   /* Assume all the expressions will be constant.  */
<span class="lineNum">    7722 </span>            :   if (non_constant_p)
<span class="lineNum">    7723 </span>            :     *non_constant_p = false;
<span class="lineNum">    7724 </span>            : 
<span class="lineNum">    7725 </span>            :   matching_parens parens;
<span class="lineNum">    7726 </span>            :   if (!parens.require_open (parser))
<span class="lineNum">    7727 </span>            :     return NULL;
<span class="lineNum">    7728 </span>            : 
<span class="lineNum">    7729 </span>            :   expression_list = make_tree_vector ();
<span class="lineNum">    7730 </span>            : 
<span class="lineNum">    7731 </span>            :   /* Within a parenthesized expression, a `&gt;' token is always
<span class="lineNum">    7732 </span>            :      the greater-than operator.  */
<span class="lineNum">    7733 </span>            :   saved_greater_than_is_operator_p
<span class="lineNum">    7734 </span>            :     = parser-&gt;greater_than_is_operator_p;
<span class="lineNum">    7735 </span>            :   parser-&gt;greater_than_is_operator_p = true;
<span class="lineNum">    7736 </span>            : 
<span class="lineNum">    7737 </span>            :   cp_expr expr (NULL_TREE);
<span class="lineNum">    7738 </span>            : 
<span class="lineNum">    7739 </span>            :   /* Consume expressions until there are no more.  */
<span class="lineNum">    7740 </span>            :   if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_CLOSE_PAREN))
<span class="lineNum">    7741 </span>            :     while (true)
<span class="lineNum">    7742 </span>            :       {
<span class="lineNum">    7743 </span>            :         /* At the beginning of attribute lists, check to see if the
<span class="lineNum">    7744 </span>            :            next token is an identifier.  */
<span class="lineNum">    7745 </span>            :         if (is_attribute_list == id_attr
<span class="lineNum">    7746 </span><span class="lineCov">   12851694 :             &amp;&amp; cp_lexer_peek_token (parser-&gt;lexer)-&gt;type == CPP_NAME)</span>
<span class="lineNum">    7747 </span>            :           {
<span class="lineNum">    7748 </span>            :             cp_token *token;
<span class="lineNum">    7749 </span>            : 
<span class="lineNum">    7750 </span>            :             /* Consume the identifier.  */
<span class="lineNum">    7751 </span>            :             token = cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">    7752 </span>            :             /* Save the identifier.  */
<span class="lineNum">    7753 </span>            :             identifier = token-&gt;u.value;
<span class="lineNum">    7754 </span><span class="lineCov">   12851694 :           }</span>
<span class="lineNum">    7755 </span><span class="lineCov">   12851694 :         else</span>
<span class="lineNum">    7756 </span><span class="lineCov">   12851694 :           {</span>
<span class="lineNum">    7757 </span><span class="lineCov">   12851694 :             bool expr_non_constant_p;</span>
<span class="lineNum">    7758 </span>            : 
<span class="lineNum">    7759 </span>            :             /* Parse the next assignment-expression.  */
<span class="lineNum">    7760 </span><span class="lineCov">   12851694 :             if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_BRACE))</span>
<span class="lineNum">    7761 </span><span class="lineCov">     127776 :               {</span>
<span class="lineNum">    7762 </span>            :                 /* A braced-init-list.  */
<span class="lineNum">    7763 </span><span class="lineCov">   25703388 :                 cp_lexer_set_source_position (parser-&gt;lexer);</span>
<span class="lineNum">    7764 </span><span class="lineCov">   12851694 :                 maybe_warn_cpp0x (CPP0X_INITIALIZER_LISTS);</span>
<span class="lineNum">    7765 </span>            :                 expr = cp_parser_braced_list (parser, &amp;expr_non_constant_p);
<span class="lineNum">    7766 </span>            :                 if (non_constant_p &amp;&amp; expr_non_constant_p)
<span class="lineNum">    7767 </span><span class="lineCov">   12829183 :                   *non_constant_p = true;</span>
<span class="lineNum">    7768 </span>            :               }
<span class="lineNum">    7769 </span>            :             else if (non_constant_p)
<span class="lineNum">    7770 </span>            :               {
<span class="lineNum">    7771 </span><span class="lineCov">   12829183 :                 expr = (cp_parser_constant_expression</span>
<span class="lineNum">    7772 </span><span class="lineCov">   12829183 :                         (parser, /*allow_non_constant_p=*/true,</span>
<span class="lineNum">    7773 </span><span class="lineCov">   12829183 :                          &amp;expr_non_constant_p));</span>
<span class="lineNum">    7774 </span>            :                 if (expr_non_constant_p)
<span class="lineNum">    7775 </span><span class="lineCov">   12829183 :                   *non_constant_p = true;</span>
<span class="lineNum">    7776 </span>            :               }
<span class="lineNum">    7777 </span>            :             else
<span class="lineNum">    7778 </span><span class="lineCov">   12829183 :               expr = cp_parser_assignment_expression (parser, /*pidk=*/NULL,</span>
<span class="lineNum">    7779 </span><span class="lineCov">   15871040 :                                                       cast_p);</span>
<span class="lineNum">    7780 </span>            : 
<span class="lineNum">    7781 </span>            :             if (fold_expr_p)
<span class="lineNum">    7782 </span>            :               expr = instantiate_non_dependent_expr (expr);
<span class="lineNum">    7783 </span><span class="lineCov">   15871040 : </span>
<span class="lineNum">    7784 </span><span class="lineCov">   15871040 :             /* If we have an ellipsis, then this is an expression</span>
<span class="lineNum">    7785 </span>            :                expansion.  */
<span class="lineNum">    7786 </span><span class="lineCov">      48201 :             if (allow_expansion_p</span>
<span class="lineNum">    7787 </span>            :                 &amp;&amp; cp_lexer_next_token_is (parser-&gt;lexer, CPP_ELLIPSIS))
<span class="lineNum">    7788 </span>            :               {
<span class="lineNum">    7789 </span><span class="lineCov">      48201 :                 /* Consume the `...'.  */</span>
<span class="lineNum">    7790 </span>            :                 cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">    7791 </span><span class="lineCov">      48201 : </span>
<span class="lineNum">    7792 </span>            :                 /* Build the argument pack.  */
<span class="lineNum">    7793 </span>            :                 expr = make_pack_expansion (expr);
<span class="lineNum">    7794 </span>            :               }
<span class="lineNum">    7795 </span><span class="lineCov">   15822839 : </span>
<span class="lineNum">    7796 </span>            :             if (wrap_locations_p)
<span class="lineNum">    7797 </span>            :               expr.maybe_add_location_wrapper ();
<span class="lineNum">    7798 </span><span class="lineCov">   15822839 : </span>
<span class="lineNum">    7799 </span>            :              /* Add it to the list.  We add error_mark_node
<span class="lineNum">    7800 </span>            :                 expressions to the list, so that we can still tell if
<span class="lineNum">    7801 </span><span class="lineCov">      11090 :                 the correct form for a parenthesized expression-list</span>
<span class="lineNum">    7802 </span><span class="lineCov">       5545 :                 is found. That gives better errors.  */</span>
<span class="lineNum">    7803 </span><span class="lineCov">       5545 :             vec_safe_push (expression_list, expr.get_value ());</span>
<span class="lineNum">    7804 </span><span class="lineCov">       5545 : </span>
<span class="lineNum">    7805 </span><span class="lineCov">          3 :             if (expr == error_mark_node)</span>
<span class="lineNum">    7806 </span>            :               goto skip_comma;
<span class="lineNum">    7807 </span><span class="lineCov">   15817294 :           }</span>
<span class="lineNum">    7808 </span>            : 
<span class="lineNum">    7809 </span><span class="lineCov">     363676 :         /* After the first item, attribute lists look the same as</span>
<span class="lineNum">    7810 </span><span class="lineCov">     181838 :            expression lists.  */</span>
<span class="lineNum">    7811 </span><span class="lineCov">     181838 :         is_attribute_list = non_attr;</span>
<span class="lineNum">    7812 </span><span class="lineCov">     181838 : </span>
<span class="lineNum">    7813 </span><span class="lineCov">      56206 :       get_comma:;</span>
<span class="lineNum">    7814 </span>            :         /* If the next token isn't a `,', then we are done.  */
<span class="lineNum">    7815 </span>            :         if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_COMMA))
<span class="lineNum">    7816 </span><span class="lineCov">   15635456 :           break;</span>
<span class="lineNum">    7817 </span><span class="lineCov">   15635456 : </span>
<span class="lineNum">    7818 </span>            :         /* Otherwise, consume the `,' and keep going.  */
<span class="lineNum">    7819 </span><span class="lineCov">   15822839 :         cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    7820 </span><span class="lineCov">    3165286 :       }</span>
<span class="lineNum">    7821 </span>            : 
<span class="lineNum">    7822 </span>            :   if (close_paren_loc)
<span class="lineNum">    7823 </span>            :     *close_paren_loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">    7824 </span><span class="lineCov">   15822839 : </span>
<span class="lineNum">    7825 </span><span class="lineCov">   15822839 :   if (!parens.require_close (parser))</span>
<span class="lineNum">    7826 </span>            :     {
<span class="lineNum">    7827 </span>            :       int ending;
<span class="lineNum">    7828 </span><span class="lineCov">     115174 : </span>
<span class="lineNum">    7829 </span>            :     skip_comma:;
<span class="lineNum">    7830 </span>            :       /* We try and resync to an unnested comma, as that will give the
<span class="lineNum">    7831 </span><span class="lineCov">     230348 :          user better diagnostics.  */</span>
<span class="lineNum">    7832 </span>            :       ending = cp_parser_skip_to_closing_parenthesis (parser,
<span class="lineNum">    7833 </span>            :                                                       /*recovering=*/true,
<span class="lineNum">    7834 </span><span class="lineCov">   15822839 :                                                       /*or_comma=*/true,</span>
<span class="lineNum">    7835 </span><span class="lineCov">   11935280 :                                                       /*consume_paren=*/true);</span>
<span class="lineNum">    7836 </span>            :       if (ending &lt; 0)
<span class="lineNum">    7837 </span>            :         goto get_comma;
<span class="lineNum">    7838 </span>            :       if (!ending)
<span class="lineNum">    7839 </span>            :         {
<span class="lineNum">    7840 </span>            :           parser-&gt;greater_than_is_operator_p
<span class="lineNum">    7841 </span><span class="lineCov">   31645678 :             = saved_greater_than_is_operator_p;</span>
<span class="lineNum">    7842 </span>            :           return NULL;
<span class="lineNum">    7843 </span><span class="lineCov">   31645678 :         }</span>
<span class="lineNum">    7844 </span><span class="lineCov">        452 :     }</span>
<span class="lineNum">    7845 </span>            : 
<span class="lineNum">    7846 </span>            :   parser-&gt;greater_than_is_operator_p
<span class="lineNum">    7847 </span>            :     = saved_greater_than_is_operator_p;
<span class="lineNum">    7848 </span>            : 
<span class="lineNum">    7849 </span>            :   if (identifier)
<span class="lineNum">    7850 </span>            :     vec_safe_insert (expression_list, 0, identifier);
<span class="lineNum">    7851 </span><span class="lineCov">   15870603 : </span>
<span class="lineNum">    7852 </span>            :   return expression_list;
<span class="lineNum">    7853 </span><span class="lineCov">   15870603 : }</span>
<span class="lineNum">    7854 </span>            : 
<span class="lineNum">    7855 </span>            : /* Parse a pseudo-destructor-name.
<span class="lineNum">    7856 </span>            : 
<span class="lineNum">    7857 </span><span class="lineCov">    6802290 :    pseudo-destructor-name:</span>
<span class="lineNum">    7858 </span><span class="lineCov">    6802290 :      :: [opt] nested-name-specifier [opt] type-name :: ~ type-name</span>
<span class="lineNum">    7859 </span>            :      :: [opt] nested-name-specifier template template-id :: ~ type-name
<span class="lineNum">    7860 </span><span class="lineCov">   12828746 :      :: [opt] nested-name-specifier [opt] ~ type-name</span>
<span class="lineNum">    7861 </span><span class="lineCov">    9360696 : </span>
<span class="lineNum">    7862 </span>            :    If either of the first two productions is used, sets *SCOPE to the
<span class="lineNum">    7863 </span><span class="lineCov">   12828746 :    TYPE specified before the final `::'.  Otherwise, *SCOPE is set to</span>
<span class="lineNum">    7864 </span>            :    NULL_TREE.  *TYPE is set to the TYPE_DECL for the final type-name,
<span class="lineNum">    7865 </span><span class="lineCov">        486 :    or ERROR_MARK_NODE if the parse fails.  */</span>
<a name="7866"><span class="lineNum">    7866 </span>            : </a>
<span class="lineNum">    7867 </span><span class="lineCov">         34 : static void</span>
<span class="lineNum">    7868 </span>            : cp_parser_pseudo_destructor_name (cp_parser* parser,
<span class="lineNum">    7869 </span>            :                                   tree object,
<span class="lineNum">    7870 </span><span class="lineCov">        486 :                                   tree* scope,</span>
<span class="lineNum">    7871 </span>            :                                   tree* type)
<span class="lineNum">    7872 </span>            : {
<span class="lineNum">    7873 </span>            :   bool nested_name_specifier_p;
<span class="lineNum">    7874 </span><span class="lineCov">        486 : </span>
<span class="lineNum">    7875 </span>            :   /* Handle ~auto.  */
<span class="lineNum">    7876 </span><span class="lineCov">        471 :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_COMPL)</span>
<span class="lineNum">    7877 </span>            :       &amp;&amp; cp_lexer_nth_token_is_keyword (parser-&gt;lexer, 2, RID_AUTO)
<span class="lineNum">    7878 </span><span class="lineCov">         82 :       &amp;&amp; !type_dependent_expression_p (object))</span>
<span class="lineNum">    7879 </span><span class="lineCov">         82 :     {</span>
<span class="lineNum">    7880 </span><span class="lineCov">         82 :       if (cxx_dialect &lt; cxx14)</span>
<span class="lineNum">    7881 </span>            :         pedwarn (input_location, 0,
<span class="lineNum">    7882 </span>            :                  &quot;%&lt;~auto%&gt; only available with &quot;
<span class="lineNum">    7883 </span>            :                  &quot;-std=c++14 or -std=gnu++14&quot;);
<span class="lineNum">    7884 </span><span class="lineCov">   12829101 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    7885 </span><span class="lineCov">   12829101 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    7886 </span>            :       *scope = NULL_TREE;
<span class="lineNum">    7887 </span><span class="lineCov">   12829101 :       *type = TREE_TYPE (object);</span>
<span class="lineNum">    7888 </span><span class="lineCov">      48201 :       return;</span>
<span class="lineNum">    7889 </span>            :     }
<span class="lineNum">    7890 </span><span class="lineCov">   12829101 : </span>
<span class="lineNum">    7891 </span>            :   /* Assume that things will not work out.  */
<span class="lineNum">    7892 </span>            :   *type = error_mark_node;
<span class="lineNum">    7893 </span>            : 
<span class="lineNum">    7894 </span>            :   /* Look for the optional `::' operator.  */
<span class="lineNum">    7895 </span>            :   cp_parser_global_scope_opt (parser, /*current_scope_valid_p=*/true);
<span class="lineNum">    7896 </span>            :   /* Look for the optional nested-name-specifier.  */
<span class="lineNum">    7897 </span>            :   nested_name_specifier_p
<span class="lineNum">    7898 </span>            :     = (cp_parser_nested_name_specifier_opt (parser,
<span class="lineNum">    7899 </span>            :                                             /*typename_keyword_p=*/false,
<span class="lineNum">    7900 </span>            :                                             /*check_dependency_p=*/true,
<span class="lineNum">    7901 </span>            :                                             /*type_p=*/false,
<span class="lineNum">    7902 </span>            :                                             /*is_declaration=*/false)
<span class="lineNum">    7903 </span>            :        != NULL_TREE);
<span class="lineNum">    7904 </span>            :   /* Now, if we saw a nested-name-specifier, we might be doing the
<span class="lineNum">    7905 </span>            :      second production.  */
<span class="lineNum">    7906 </span><span class="lineCov">    2210894 :   if (nested_name_specifier_p</span>
<span class="lineNum">    7907 </span>            :       &amp;&amp; cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_TEMPLATE))
<span class="lineNum">    7908 </span>            :     {
<span class="lineNum">    7909 </span>            :       /* Consume the `template' keyword.  */
<span class="lineNum">    7910 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">    7911 </span><span class="lineCov">    2210894 :       /* Parse the template-id.  */</span>
<span class="lineNum">    7912 </span>            :       cp_parser_template_id (parser,
<span class="lineNum">    7913 </span>            :                              /*template_keyword_p=*/true,
<span class="lineNum">    7914 </span><span class="lineCov">    4421788 :                              /*check_dependency_p=*/false,</span>
<span class="lineNum">    7915 </span><span class="lineCov">      20438 :                              class_type,</span>
<span class="lineNum">    7916 </span><span class="lineCov">    2210896 :                              /*is_declaration=*/true);</span>
<span class="lineNum">    7917 </span>            :       /* Look for the `::' token.  */
<span class="lineNum">    7918 </span><span class="lineCov">          1 :       cp_parser_require (parser, CPP_SCOPE, RT_SCOPE);</span>
<span class="lineNum">    7919 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    7920 </span>            :   /* If the next token is not a `~', then there might be some
<span class="lineNum">    7921 </span>            :      additional qualification.  */
<span class="lineNum">    7922 </span><span class="lineCov">          1 :   else if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_COMPL))</span>
<span class="lineNum">    7923 </span><span class="lineCov">          1 :     {</span>
<span class="lineNum">    7924 </span><span class="lineCov">          1 :       /* At this point, we're looking for &quot;type-name :: ~&quot;.  The type-name</span>
<span class="lineNum">    7925 </span><span class="lineCov">          1 :          must not be a class-name, since this is a pseudo-destructor.  So,</span>
<span class="lineNum">    7926 </span><span class="lineCov">          1 :          it must be either an enum-name, or a typedef-name -- both of which</span>
<span class="lineNum">    7927 </span>            :          are just identifiers.  So, we peek ahead to check that the &quot;::&quot;
<span class="lineNum">    7928 </span>            :          and &quot;~&quot; tokens are present; if they are not, then we can avoid
<span class="lineNum">    7929 </span>            :          calling type_name.  */
<span class="lineNum">    7930 </span><span class="lineCov">    2210893 :       if (cp_lexer_peek_token (parser-&gt;lexer)-&gt;type != CPP_NAME</span>
<span class="lineNum">    7931 </span>            :           || cp_lexer_peek_nth_token (parser-&gt;lexer, 2)-&gt;type != CPP_SCOPE
<span class="lineNum">    7932 </span>            :           || cp_lexer_peek_nth_token (parser-&gt;lexer, 3)-&gt;type != CPP_COMPL)
<span class="lineNum">    7933 </span><span class="lineCov">    2210893 :         {</span>
<span class="lineNum">    7934 </span>            :           cp_parser_error (parser, &quot;non-scalar type&quot;);
<span class="lineNum">    7935 </span><span class="lineCov">    2210893 :           return;</span>
<span class="lineNum">    7936 </span><span class="lineCov">    2210893 :         }</span>
<span class="lineNum">    7937 </span>            : 
<span class="lineNum">    7938 </span>            :       /* Look for the type-name.  */
<span class="lineNum">    7939 </span>            :       *scope = TREE_TYPE (cp_parser_nonclass_name (parser));
<span class="lineNum">    7940 </span>            :       if (*scope == error_mark_node)
<span class="lineNum">    7941 </span>            :         return;
<span class="lineNum">    7942 </span>            : 
<span class="lineNum">    7943 </span>            :       /* Look for the `::' token.  */
<span class="lineNum">    7944 </span><span class="lineCov">    2210893 :       cp_parser_require (parser, CPP_SCOPE, RT_SCOPE);</span>
<span class="lineNum">    7945 </span><span class="lineCov">    2210893 :     }</span>
<span class="lineNum">    7946 </span>            :   else
<span class="lineNum">    7947 </span>            :     *scope = NULL_TREE;
<span class="lineNum">    7948 </span><span class="lineCov">         10 : </span>
<span class="lineNum">    7949 </span>            :   /* Look for the `~'.  */
<span class="lineNum">    7950 </span><span class="lineCov">         10 :   cp_parser_require (parser, CPP_COMPL, RT_COMPL);</span>
<span class="lineNum">    7951 </span>            : 
<span class="lineNum">    7952 </span>            :   /* Once we see the ~, this has to be a pseudo-destructor.  */
<span class="lineNum">    7953 </span>            :   if (!processing_template_decl &amp;&amp; !cp_parser_error_occurred (parser))
<span class="lineNum">    7954 </span>            :     cp_parser_commit_to_topmost_tentative_parse (parser);
<span class="lineNum">    7955 </span>            : 
<span class="lineNum">    7956 </span><span class="lineCov">         10 :   /* Look for the type-name again.  We are not responsible for</span>
<span class="lineNum">    7957 </span>            :      checking that it matches the first type-name.  */
<span class="lineNum">    7958 </span>            :   *type = TREE_TYPE (cp_parser_nonclass_name (parser));
<span class="lineNum">    7959 </span>            : }
<span class="lineNum">    7960 </span><span class="lineCov">    2210883 : </span>
<span class="lineNum">    7961 </span>            : /* Parse a unary-expression.
<span class="lineNum">    7962 </span>            : 
<span class="lineNum">    7963 </span>            :    unary-expression:
<span class="lineNum">    7964 </span>            :      postfix-expression
<span class="lineNum">    7965 </span>            :      ++ cast-expression
<span class="lineNum">    7966 </span>            :      -- cast-expression
<span class="lineNum">    7967 </span>            :      unary-operator cast-expression
<span class="lineNum">    7968 </span><span class="lineCov">    2190230 :      sizeof unary-expression</span>
<span class="lineNum">    7969 </span><span class="lineCov">    2171653 :      sizeof ( type-id )</span>
<span class="lineNum">    7970 </span><span class="lineCov">    2190270 :      alignof ( type-id )  [C++0x]</span>
<span class="lineNum">    7971 </span>            :      new-expression
<span class="lineNum">    7972 </span><span class="lineCov">    2190190 :      delete-expression</span>
<span class="lineNum">    7973 </span><span class="lineCov">    2190190 : </span>
<span class="lineNum">    7974 </span>            :    GNU Extensions:
<span class="lineNum">    7975 </span>            : 
<span class="lineNum">    7976 </span>            :    unary-expression:
<span class="lineNum">    7977 </span><span class="lineCov">         40 :      __extension__ cast-expression</span>
<span class="lineNum">    7978 </span><span class="lineCov">         40 :      __alignof__ unary-expression</span>
<span class="lineNum">    7979 </span>            :      __alignof__ ( type-id )
<span class="lineNum">    7980 </span>            :      alignof unary-expression  [C++0x]
<span class="lineNum">    7981 </span>            :      __real__ cast-expression
<span class="lineNum">    7982 </span><span class="lineCov">         37 :      __imag__ cast-expression</span>
<span class="lineNum">    7983 </span>            :      &amp;&amp; identifier
<span class="lineNum">    7984 </span>            :      sizeof ( type-id ) { initializer-list , [opt] }
<span class="lineNum">    7985 </span><span class="lineCov">      20653 :      alignof ( type-id ) { initializer-list , [opt] } [C++0x]</span>
<span class="lineNum">    7986 </span>            :      __alignof__ ( type-id ) { initializer-list , [opt] }
<span class="lineNum">    7987 </span>            : 
<span class="lineNum">    7988 </span><span class="lineCov">      20700 :    ADDRESS_P is true iff the unary-expression is appearing as the</span>
<span class="lineNum">    7989 </span>            :    operand of the `&amp;' operator.   CAST_P is true if this expression is
<span class="lineNum">    7990 </span>            :    the target of a cast.
<span class="lineNum">    7991 </span><span class="lineCov">      20700 : </span>
<span class="lineNum">    7992 </span><span class="lineCov">         66 :    Returns a representation of the expression.  */</span>
<a name="7993"><span class="lineNum">    7993 </span>            : </a>
<span class="lineNum">    7994 </span>            : static cp_expr
<span class="lineNum">    7995 </span>            : cp_parser_unary_expression (cp_parser *parser, cp_id_kind * pidk,
<span class="lineNum">    7996 </span><span class="lineCov">      20700 :                             bool address_p, bool cast_p, bool decltype_p)</span>
<span class="lineNum">    7997 </span>            : {
<span class="lineNum">    7998 </span>            :   cp_token *token;
<span class="lineNum">    7999 </span>            :   enum tree_code unary_operator;
<span class="lineNum">    8000 </span>            : 
<span class="lineNum">    8001 </span>            :   /* Peek at the next token.  */
<span class="lineNum">    8002 </span>            :   token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">    8003 </span>            :   /* Some keywords give away the kind of expression.  */
<span class="lineNum">    8004 </span>            :   if (token-&gt;type == CPP_KEYWORD)
<span class="lineNum">    8005 </span>            :     {
<span class="lineNum">    8006 </span>            :       enum rid keyword = token-&gt;keyword;
<span class="lineNum">    8007 </span>            : 
<span class="lineNum">    8008 </span>            :       switch (keyword)
<span class="lineNum">    8009 </span>            :         {
<span class="lineNum">    8010 </span>            :         case RID_ALIGNOF:
<span class="lineNum">    8011 </span>            :         case RID_SIZEOF:
<span class="lineNum">    8012 </span>            :           {
<span class="lineNum">    8013 </span>            :             tree operand, ret;
<span class="lineNum">    8014 </span>            :             enum tree_code op;
<span class="lineNum">    8015 </span>            :             location_t start_loc = token-&gt;location;
<span class="lineNum">    8016 </span>            : 
<span class="lineNum">    8017 </span>            :             op = keyword == RID_ALIGNOF ? ALIGNOF_EXPR : SIZEOF_EXPR;
<span class="lineNum">    8018 </span>            :             bool std_alignof = id_equal (token-&gt;u.value, &quot;alignof&quot;);
<span class="lineNum">    8019 </span>            : 
<span class="lineNum">    8020 </span>            :             /* Consume the token.  */
<span class="lineNum">    8021 </span>            :             cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">    8022 </span>            :             /* Parse the operand.  */
<span class="lineNum">    8023 </span>            :             operand = cp_parser_sizeof_operand (parser, keyword);
<span class="lineNum">    8024 </span>            : 
<span class="lineNum">    8025 </span>            :             if (TYPE_P (operand))
<span class="lineNum">    8026 </span>            :               ret = cxx_sizeof_or_alignof_type (operand, op, std_alignof,
<span class="lineNum">    8027 </span>            :                                                 true);
<span class="lineNum">    8028 </span>            :             else
<span class="lineNum">    8029 </span>            :               {
<span class="lineNum">    8030 </span>            :                 /* ISO C++ defines alignof only with types, not with
<span class="lineNum">    8031 </span>            :                    expressions. So pedwarn if alignof is used with a non-
<span class="lineNum">    8032 </span>            :                    type expression. However, __alignof__ is ok.  */
<span class="lineNum">    8033 </span><span class="lineCov">   49521980 :                 if (std_alignof)</span>
<span class="lineNum">    8034 </span>            :                   pedwarn (token-&gt;location, OPT_Wpedantic,
<span class="lineNum">    8035 </span>            :                            &quot;ISO C++ does not allow %&lt;alignof%&gt; &quot;
<span class="lineNum">    8036 </span><span class="lineCov">   49521980 :                            &quot;with a non-type&quot;);</span>
<span class="lineNum">    8037 </span><span class="lineCov">   49521980 : </span>
<span class="lineNum">    8038 </span>            :                 ret = cxx_sizeof_or_alignof_expr (operand, op, true);
<span class="lineNum">    8039 </span>            :               }
<span class="lineNum">    8040 </span><span class="lineCov">   99043960 :             /* For SIZEOF_EXPR, just issue diagnostics, but keep</span>
<span class="lineNum">    8041 </span>            :                SIZEOF_EXPR with the original operand.  */
<span class="lineNum">    8042 </span><span class="lineCov">   49521980 :             if (op == SIZEOF_EXPR &amp;&amp; ret != error_mark_node)</span>
<span class="lineNum">    8043 </span>            :               {
<span class="lineNum">    8044 </span><span class="lineCov">    4044555 :                 if (TREE_CODE (ret) != SIZEOF_EXPR || TYPE_P (operand))</span>
<span class="lineNum">    8045 </span>            :                   {
<span class="lineNum">    8046 </span><span class="lineCov">    4044555 :                     if (!processing_template_decl &amp;&amp; TYPE_P (operand))</span>
<span class="lineNum">    8047 </span>            :                       {
<span class="lineNum">    8048 </span><span class="lineCov">     387755 :                         ret = build_min (SIZEOF_EXPR, size_type_node,</span>
<span class="lineNum">    8049 </span><span class="lineCov">     387755 :                                          build1 (NOP_EXPR, operand,</span>
<span class="lineNum">    8050 </span><span class="lineCov">     387755 :                                                  error_mark_node));</span>
<span class="lineNum">    8051 </span><span class="lineCov">     387755 :                         SIZEOF_EXPR_TYPE_P (ret) = 1;</span>
<span class="lineNum">    8052 </span><span class="lineCov">     387755 :                       }</span>
<span class="lineNum">    8053 </span><span class="lineCov">     387755 :                     else</span>
<span class="lineNum">    8054 </span>            :                       ret = build_min (SIZEOF_EXPR, size_type_node, operand);
<span class="lineNum">    8055 </span><span class="lineCov">     387755 :                     TREE_SIDE_EFFECTS (ret) = 0;</span>
<span class="lineNum">    8056 </span><span class="lineCov">     387755 :                     TREE_READONLY (ret) = 1;</span>
<span class="lineNum">    8057 </span>            :                   }
<span class="lineNum">    8058 </span>            :               }
<span class="lineNum">    8059 </span><span class="lineCov">     387755 : </span>
<span class="lineNum">    8060 </span>            :             /* Construct a location e.g. :
<span class="lineNum">    8061 </span><span class="lineCov">     387755 :                alignof (expr)</span>
<span class="lineNum">    8062 </span>            :                ^~~~~~~~~~~~~~
<span class="lineNum">    8063 </span><span class="lineCov">     387755 :                with start == caret at the start of the &quot;alignof&quot;/&quot;sizeof&quot;</span>
<span class="lineNum">    8064 </span><span class="lineCov">     261283 :                token, with the endpoint at the final closing paren.  */</span>
<span class="lineNum">    8065 </span>            :             location_t finish_loc
<span class="lineNum">    8066 </span>            :               = cp_lexer_previous_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">    8067 </span>            :             location_t compound_loc
<span class="lineNum">    8068 </span>            :               = make_location (start_loc, start_loc, finish_loc);
<span class="lineNum">    8069 </span>            : 
<span class="lineNum">    8070 </span>            :             cp_expr ret_expr (ret);
<span class="lineNum">    8071 </span><span class="lineCov">     126472 :             ret_expr.set_location (compound_loc);</span>
<span class="lineNum">    8072 </span><span class="lineCov">          2 :             ret_expr = ret_expr.maybe_add_location_wrapper ();</span>
<span class="lineNum">    8073 </span>            :             return ret_expr;
<span class="lineNum">    8074 </span>            :           }
<span class="lineNum">    8075 </span>            : 
<span class="lineNum">    8076 </span><span class="lineCov">     126472 :         case RID_NEW:</span>
<span class="lineNum">    8077 </span>            :           return cp_parser_new_expression (parser);
<span class="lineNum">    8078 </span>            : 
<span class="lineNum">    8079 </span>            :         case RID_DELETE:
<span class="lineNum">    8080 </span><span class="lineCov">     387755 :           return cp_parser_delete_expression (parser);</span>
<span class="lineNum">    8081 </span>            : 
<span class="lineNum">    8082 </span><span class="lineCov">     322195 :         case RID_EXTENSION:</span>
<span class="lineNum">    8083 </span>            :           {
<span class="lineNum">    8084 </span><span class="lineCov">     299226 :             /* The saved value of the PEDANTIC flag.  */</span>
<span class="lineNum">    8085 </span>            :             int saved_pedantic;
<span class="lineNum">    8086 </span><span class="lineCov">     121990 :             tree expr;</span>
<span class="lineNum">    8087 </span>            : 
<span class="lineNum">    8088 </span>            :             /* Save away the PEDANTIC flag.  */
<span class="lineNum">    8089 </span><span class="lineCov">     121990 :             cp_parser_extension_opt (parser, &amp;saved_pedantic);</span>
<span class="lineNum">    8090 </span>            :             /* Parse the cast-expression.  */
<span class="lineNum">    8091 </span>            :             expr = cp_parser_simple_cast_expression (parser);
<span class="lineNum">    8092 </span><span class="lineCov">     177236 :             /* Restore the PEDANTIC flag.  */</span>
<span class="lineNum">    8093 </span><span class="lineCov">     299226 :             pedantic = saved_pedantic;</span>
<span class="lineNum">    8094 </span><span class="lineCov">     299226 : </span>
<span class="lineNum">    8095 </span>            :             return expr;
<span class="lineNum">    8096 </span>            :           }
<span class="lineNum">    8097 </span>            : 
<span class="lineNum">    8098 </span>            :         case RID_REALPART:
<span class="lineNum">    8099 </span>            :         case RID_IMAGPART:
<span class="lineNum">    8100 </span>            :           {
<span class="lineNum">    8101 </span>            :             tree expression;
<span class="lineNum">    8102 </span>            : 
<span class="lineNum">    8103 </span><span class="lineCov">     387755 :             /* Consume the `__real__' or `__imag__' token.  */</span>
<span class="lineNum">    8104 </span><span class="lineCov">     387755 :             cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    8105 </span><span class="lineCov">     387755 :             /* Parse the cast-expression.  */</span>
<span class="lineNum">    8106 </span><span class="lineCov">     387755 :             expression = cp_parser_simple_cast_expression (parser);</span>
<span class="lineNum">    8107 </span>            :             /* Create the complete representation.  */
<span class="lineNum">    8108 </span><span class="lineCov">     387755 :             return build_x_unary_op (token-&gt;location,</span>
<span class="lineNum">    8109 </span><span class="lineCov">     387755 :                                      (keyword == RID_REALPART</span>
<span class="lineNum">    8110 </span><span class="lineCov">     387755 :                                       ? REALPART_EXPR : IMAGPART_EXPR),</span>
<span class="lineNum">    8111 </span><span class="lineCov">     387755 :                                      expression,</span>
<span class="lineNum">    8112 </span>            :                                      tf_warning_or_error);
<span class="lineNum">    8113 </span>            :           }
<span class="lineNum">    8114 </span><span class="lineCov">      30629 :           break;</span>
<span class="lineNum">    8115 </span><span class="lineCov">      30629 : </span>
<span class="lineNum">    8116 </span>            :         case RID_TRANSACTION_ATOMIC:
<span class="lineNum">    8117 </span><span class="lineCov">      26471 :         case RID_TRANSACTION_RELAXED:</span>
<span class="lineNum">    8118 </span><span class="lineCov">      26471 :           return cp_parser_transaction_expression (parser, keyword);</span>
<span class="lineNum">    8119 </span>            : 
<span class="lineNum">    8120 </span><span class="lineCov">      15854 :         case RID_NOEXCEPT:</span>
<span class="lineNum">    8121 </span><span class="lineCov">      15854 :           {</span>
<span class="lineNum">    8122 </span>            :             tree expr;
<span class="lineNum">    8123 </span><span class="lineCov">      15854 :             const char *saved_message;</span>
<span class="lineNum">    8124 </span><span class="lineCov">      15854 :             bool saved_integral_constant_expression_p;</span>
<span class="lineNum">    8125 </span>            :             bool saved_non_integral_constant_expression_p;
<span class="lineNum">    8126 </span>            :             bool saved_greater_than_is_operator_p;
<span class="lineNum">    8127 </span><span class="lineCov">      31708 : </span>
<span class="lineNum">    8128 </span>            :             location_t start_loc = token-&gt;location;
<span class="lineNum">    8129 </span><span class="lineCov">      15854 : </span>
<span class="lineNum">    8130 </span>            :             cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">    8131 </span><span class="lineCov">      15854 :             matching_parens parens;</span>
<span class="lineNum">    8132 </span>            :             parens.require_open (parser);
<span class="lineNum">    8133 </span><span class="lineCov">      15854 : </span>
<span class="lineNum">    8134 </span>            :             saved_message = parser-&gt;type_definition_forbidden_message;
<span class="lineNum">    8135 </span>            :             parser-&gt;type_definition_forbidden_message
<span class="lineNum">    8136 </span><span class="lineCov">      31228 :               = G_(&quot;types may not be defined in %&lt;noexcept%&gt; expressions&quot;);</span>
<span class="lineNum">    8137 </span><span class="lineCov">      31228 : </span>
<span class="lineNum">    8138 </span><span class="lineCov">      31228 :             saved_integral_constant_expression_p</span>
<span class="lineNum">    8139 </span><span class="lineCov">      31228 :               = parser-&gt;integral_constant_expression_p;</span>
<span class="lineNum">    8140 </span>            :             saved_non_integral_constant_expression_p
<span class="lineNum">    8141 </span>            :               = parser-&gt;non_integral_constant_expression_p;
<span class="lineNum">    8142 </span><span class="lineCov">      31228 :             parser-&gt;integral_constant_expression_p = false;</span>
<span class="lineNum">    8143 </span>            : 
<span class="lineNum">    8144 </span><span class="lineCov">      31228 :             saved_greater_than_is_operator_p</span>
<span class="lineNum">    8145 </span>            :               = parser-&gt;greater_than_is_operator_p;
<span class="lineNum">    8146 </span><span class="lineCov">      31228 :             parser-&gt;greater_than_is_operator_p = true;</span>
<span class="lineNum">    8147 </span>            : 
<span class="lineNum">    8148 </span>            :             ++cp_unevaluated_operand;
<span class="lineNum">    8149 </span>            :             ++c_inhibit_evaluation_warnings;
<span class="lineNum">    8150 </span><span class="lineCov">      46841 :             ++cp_noexcept_operand;</span>
<span class="lineNum">    8151 </span>            :             expr = cp_parser_expression (parser);
<span class="lineNum">    8152 </span><span class="lineCov">         62 :             --cp_noexcept_operand;</span>
<span class="lineNum">    8153 </span>            :             --c_inhibit_evaluation_warnings;
<span class="lineNum">    8154 </span><span class="lineCov">        124 :             --cp_unevaluated_operand;</span>
<span class="lineNum">    8155 </span><span class="lineCov">         62 : </span>
<span class="lineNum">    8156 </span><span class="lineCov">         62 :             parser-&gt;greater_than_is_operator_p</span>
<span class="lineNum">    8157 </span>            :               = saved_greater_than_is_operator_p;
<span class="lineNum">    8158 </span><span class="lineCov">      68838 : </span>
<span class="lineNum">    8159 </span><span class="lineCov">      68838 :             parser-&gt;integral_constant_expression_p</span>
<span class="lineNum">    8160 </span><span class="lineCov">      68838 :               = saved_integral_constant_expression_p;</span>
<span class="lineNum">    8161 </span><span class="lineCov">      68838 :             parser-&gt;non_integral_constant_expression_p</span>
<span class="lineNum">    8162 </span><span class="lineCov">      68838 :               = saved_non_integral_constant_expression_p;</span>
<span class="lineNum">    8163 </span><span class="lineCov">      68838 : </span>
<span class="lineNum">    8164 </span><span class="lineCov">      68838 :             parser-&gt;type_definition_forbidden_message = saved_message;</span>
<span class="lineNum">    8165 </span>            : 
<span class="lineNum">    8166 </span><span class="lineCov">      68838 :             location_t finish_loc</span>
<span class="lineNum">    8167 </span>            :               = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">    8168 </span><span class="lineCov">      68838 :             parens.require_close (parser);</span>
<span class="lineNum">    8169 </span><span class="lineCov">     137676 : </span>
<span class="lineNum">    8170 </span><span class="lineCov">      68838 :             /* Construct a location of the form:</span>
<span class="lineNum">    8171 </span>            :                noexcept (expr)
<span class="lineNum">    8172 </span><span class="lineCov">      68838 :                ^~~~~~~~~~~~~~~</span>
<span class="lineNum">    8173 </span><span class="lineCov">      68838 :                with start == caret, finishing at the close-paren.  */</span>
<span class="lineNum">    8174 </span><span class="lineCov">      68838 :             location_t noexcept_loc</span>
<span class="lineNum">    8175 </span>            :               = make_location (start_loc, start_loc, finish_loc);
<span class="lineNum">    8176 </span><span class="lineCov">      68838 : </span>
<span class="lineNum">    8177 </span><span class="lineCov">      68838 :             return cp_expr (finish_noexcept_expr (expr, tf_warning_or_error),</span>
<span class="lineNum">    8178 </span><span class="lineCov">      68838 :                             noexcept_loc);</span>
<span class="lineNum">    8179 </span><span class="lineCov">      68838 :           }</span>
<span class="lineNum">    8180 </span><span class="lineCov">      68838 : </span>
<span class="lineNum">    8181 </span>            :         default:
<span class="lineNum">    8182 </span><span class="lineCov">      68838 :           break;</span>
<span class="lineNum">    8183 </span><span class="lineCov">      68838 :         }</span>
<span class="lineNum">    8184 </span><span class="lineCov">      68838 :     }</span>
<span class="lineNum">    8185 </span>            : 
<span class="lineNum">    8186 </span><span class="lineCov">      68838 :   /* Look for the `:: new' and `:: delete', which also signal the</span>
<span class="lineNum">    8187 </span><span class="lineCov">      68838 :      beginning of a new-expression, or delete-expression,</span>
<span class="lineNum">    8188 </span><span class="lineCov">      68838 :      respectively.  If the next token is `::', then it might be one of</span>
<span class="lineNum">    8189 </span><span class="lineCov">      68838 :      these.  */</span>
<span class="lineNum">    8190 </span><span class="lineCov">      68838 :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_SCOPE))</span>
<span class="lineNum">    8191 </span><span class="lineCov">      68838 :     {</span>
<span class="lineNum">    8192 </span><span class="lineCov">      68838 :       enum rid keyword;</span>
<span class="lineNum">    8193 </span>            : 
<span class="lineNum">    8194 </span><span class="lineCov">      68838 :       /* See if the token after the `::' is one of the keywords in</span>
<span class="lineNum">    8195 </span><span class="lineCov">      68838 :          which we're interested.  */</span>
<span class="lineNum">    8196 </span>            :       keyword = cp_lexer_peek_nth_token (parser-&gt;lexer, 2)-&gt;keyword;
<span class="lineNum">    8197 </span><span class="lineCov">      68838 :       /* If it's `new', we have a new-expression.  */</span>
<span class="lineNum">    8198 </span><span class="lineCov">      68838 :       if (keyword == RID_NEW)</span>
<span class="lineNum">    8199 </span><span class="lineCov">      68838 :         return cp_parser_new_expression (parser);</span>
<span class="lineNum">    8200 </span><span class="lineCov">      68838 :       /* Similarly, for `delete'.  */</span>
<span class="lineNum">    8201 </span>            :       else if (keyword == RID_DELETE)
<span class="lineNum">    8202 </span><span class="lineCov">      68838 :         return cp_parser_delete_expression (parser);</span>
<span class="lineNum">    8203 </span>            :     }
<span class="lineNum">    8204 </span><span class="lineCov">      68838 : </span>
<span class="lineNum">    8205 </span><span class="lineCov">     137676 :   /* Look for a unary operator.  */</span>
<span class="lineNum">    8206 </span><span class="lineCov">      68838 :   unary_operator = cp_parser_unary_operator (token);</span>
<span class="lineNum">    8207 </span>            :   /* The `++' and `--' operators can be handled similarly, even though
<span class="lineNum">    8208 </span>            :      they are not technically unary-operators in the grammar.  */
<span class="lineNum">    8209 </span>            :   if (unary_operator == ERROR_MARK)
<span class="lineNum">    8210 </span>            :     {
<span class="lineNum">    8211 </span>            :       if (token-&gt;type == CPP_PLUS_PLUS)
<span class="lineNum">    8212 </span><span class="lineCov">      68838 :         unary_operator = PREINCREMENT_EXPR;</span>
<span class="lineNum">    8213 </span><span class="lineCov">      68838 :       else if (token-&gt;type == CPP_MINUS_MINUS)</span>
<span class="lineNum">    8214 </span>            :         unary_operator = PREDECREMENT_EXPR;
<span class="lineNum">    8215 </span><span class="lineCov">      68838 :       /* Handle the GNU address-of-label extension.  */</span>
<span class="lineNum">    8216 </span><span class="lineCov">      68838 :       else if (cp_parser_allow_gnu_extensions_p (parser)</span>
<span class="lineNum">    8217 </span>            :                &amp;&amp; token-&gt;type == CPP_AND_AND)
<span class="lineNum">    8218 </span>            :         {
<span class="lineNum">    8219 </span>            :           tree identifier;
<span class="lineNum">    8220 </span>            :           tree expression;
<span class="lineNum">    8221 </span>            :           location_t start_loc = token-&gt;location;
<span class="lineNum">    8222 </span>            : 
<span class="lineNum">    8223 </span>            :           /* Consume the '&amp;&amp;' token.  */
<span class="lineNum">    8224 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">    8225 </span>            :           /* Look for the identifier.  */
<span class="lineNum">    8226 </span>            :           location_t finish_loc
<span class="lineNum">    8227 </span>            :             = get_finish (cp_lexer_peek_token (parser-&gt;lexer)-&gt;location);
<span class="lineNum">    8228 </span><span class="lineCov">   48961143 :           identifier = cp_parser_identifier (parser);</span>
<span class="lineNum">    8229 </span>            :           /* Construct a location of the form:
<span class="lineNum">    8230 </span><span class="lineCov">      39456 :                &amp;&amp;label</span>
<span class="lineNum">    8231 </span>            :                ^~~~~~~
<span class="lineNum">    8232 </span>            :              with caret==start at the &quot;&amp;&amp;&quot;, finish at the end of the label.  */
<span class="lineNum">    8233 </span>            :           location_t combined_loc
<span class="lineNum">    8234 </span><span class="lineCov">      39456 :             = make_location (start_loc, start_loc, finish_loc);</span>
<span class="lineNum">    8235 </span>            :           /* Create an expression representing the address.  */
<span class="lineNum">    8236 </span><span class="lineCov">      39456 :           expression = finish_label_address_expr (identifier, combined_loc);</span>
<span class="lineNum">    8237 </span><span class="lineCov">      15791 :           if (cp_parser_non_integral_constant_expression (parser,</span>
<span class="lineNum">    8238 </span>            :                                                           NIC_ADDR_LABEL))
<span class="lineNum">    8239 </span><span class="lineCov">      23665 :             expression = error_mark_node;</span>
<span class="lineNum">    8240 </span><span class="lineCov">         33 :           return expression;</span>
<span class="lineNum">    8241 </span>            :         }
<span class="lineNum">    8242 </span>            :     }
<span class="lineNum">    8243 </span>            :   if (unary_operator != ERROR_MARK)
<span class="lineNum">    8244 </span><span class="lineCov">   51388900 :     {</span>
<span class="lineNum">    8245 </span>            :       cp_expr cast_expression;
<span class="lineNum">    8246 </span>            :       cp_expr expression = error_mark_node;
<span class="lineNum">    8247 </span><span class="lineCov">    2443581 :       non_integral_constant non_constant_p = NIC_NONE;</span>
<span class="lineNum">    8248 </span>            :       location_t loc = token-&gt;location;
<span class="lineNum">    8249 </span><span class="lineCov">   46501750 :       tsubst_flags_t complain = complain_flags (decltype_p);</span>
<span class="lineNum">    8250 </span>            : 
<span class="lineNum">    8251 </span><span class="lineCov">   45938568 :       /* Consume the operator token.  */</span>
<span class="lineNum">    8252 </span>            :       token = cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">    8253 </span>            :       enum cpp_ttype op_ttype = cp_lexer_peek_token (parser-&gt;lexer)-&gt;type;
<span class="lineNum">    8254 </span><span class="lineCov">   91654808 : </span>
<span class="lineNum">    8255 </span><span class="lineCov">   45827404 :       /* Parse the cast-expression.  */</span>
<span class="lineNum">    8256 </span>            :       cast_expression
<span class="lineNum">    8257 </span><span class="lineCov">        148 :         = cp_parser_cast_expression (parser,</span>
<span class="lineNum">    8258 </span><span class="lineCov">        148 :                                      unary_operator == ADDR_EXPR,</span>
<span class="lineNum">    8259 </span><span class="lineCov">        148 :                                      /*cast_p=*/false,</span>
<span class="lineNum">    8260 </span>            :                                      /*decltype*/false,
<span class="lineNum">    8261 </span>            :                                      pidk);
<span class="lineNum">    8262 </span><span class="lineCov">        148 : </span>
<span class="lineNum">    8263 </span>            :       /* Make a location:
<span class="lineNum">    8264 </span><span class="lineCov">        148 :             OP_TOKEN  CAST_EXPRESSION</span>
<span class="lineNum">    8265 </span><span class="lineCov">        148 :             ^~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="lineNum">    8266 </span><span class="lineCov">        148 :          with start==caret at the operator token, and</span>
<span class="lineNum">    8267 </span>            :          extending to the end of the cast_expression.  */
<span class="lineNum">    8268 </span>            :       loc = make_location (loc, loc, cast_expression.get_finish ());
<span class="lineNum">    8269 </span>            : 
<span class="lineNum">    8270 </span>            :       /* Now, build an appropriate representation.  */
<span class="lineNum">    8271 </span><span class="lineCov">        148 :       switch (unary_operator)</span>
<span class="lineNum">    8272 </span><span class="lineCov">        148 :         {</span>
<span class="lineNum">    8273 </span>            :         case INDIRECT_REF:
<span class="lineNum">    8274 </span><span class="lineCov">        148 :           non_constant_p = NIC_STAR;</span>
<span class="lineNum">    8275 </span><span class="lineCov">        148 :           expression = build_x_indirect_ref (loc, cast_expression,</span>
<span class="lineNum">    8276 </span>            :                                              RO_UNARY_STAR,
<span class="lineNum">    8277 </span><span class="lineCov">          2 :                                              complain);</span>
<span class="lineNum">    8278 </span><span class="lineCov">        148 :           /* TODO: build_x_indirect_ref does not always honor the</span>
<span class="lineNum">    8279 </span>            :              location, so ensure it is set.  */
<span class="lineNum">    8280 </span>            :           expression.set_location (loc);
<span class="lineNum">    8281 </span><span class="lineCov">   48270825 :           break;</span>
<span class="lineNum">    8282 </span>            : 
<span class="lineNum">    8283 </span><span class="lineCov">    3117915 :         case ADDR_EXPR:</span>
<span class="lineNum">    8284 </span><span class="lineCov">    3117915 :            non_constant_p = NIC_ADDR;</span>
<span class="lineNum">    8285 </span><span class="lineCov">    3117915 :           /* Fall through.  */</span>
<span class="lineNum">    8286 </span><span class="lineCov">    3117915 :         case BIT_NOT_EXPR:</span>
<span class="lineNum">    8287 </span><span class="lineCov">    3117915 :           expression = build_x_unary_op (loc, unary_operator,</span>
<span class="lineNum">    8288 </span>            :                                          cast_expression,
<span class="lineNum">    8289 </span>            :                                          complain);
<span class="lineNum">    8290 </span><span class="lineCov">    3117915 :           /* TODO: build_x_unary_op does not always honor the location,</span>
<span class="lineNum">    8291 </span><span class="lineCov">    6235830 :              so ensure it is set.  */</span>
<span class="lineNum">    8292 </span>            :           expression.set_location (loc);
<span class="lineNum">    8293 </span>            :           break;
<span class="lineNum">    8294 </span><span class="lineCov">    3117915 : </span>
<span class="lineNum">    8295 </span><span class="lineCov">    3117915 :         case PREINCREMENT_EXPR:</span>
<span class="lineNum">    8296 </span>            :         case PREDECREMENT_EXPR:
<span class="lineNum">    8297 </span>            :           non_constant_p = unary_operator == PREINCREMENT_EXPR
<span class="lineNum">    8298 </span>            :                            ? NIC_PREINCREMENT : NIC_PREDECREMENT;
<span class="lineNum">    8299 </span><span class="lineCov">    3117915 :           /* Fall through.  */</span>
<span class="lineNum">    8300 </span>            :         case NEGATE_EXPR:
<span class="lineNum">    8301 </span>            :           /* Immediately fold negation of a constant, unless the constant is 0
<span class="lineNum">    8302 </span>            :              (since -0 == 0) or it would overflow.  */
<span class="lineNum">    8303 </span>            :           if (unary_operator == NEGATE_EXPR &amp;&amp; op_ttype == CPP_NUMBER
<span class="lineNum">    8304 </span>            :               &amp;&amp; CONSTANT_CLASS_P (cast_expression)
<span class="lineNum">    8305 </span>            :               &amp;&amp; !integer_zerop (cast_expression)
<span class="lineNum">    8306 </span><span class="lineCov">    3117915 :               &amp;&amp; !TREE_OVERFLOW (cast_expression))</span>
<span class="lineNum">    8307 </span>            :             {
<span class="lineNum">    8308 </span>            :               tree folded = fold_build1 (unary_operator,
<span class="lineNum">    8309 </span><span class="lineCov">    3117915 :                                          TREE_TYPE (cast_expression),</span>
<span class="lineNum">    8310 </span>            :                                          cast_expression);
<span class="lineNum">    8311 </span><span class="lineCov">     840647 :               if (CONSTANT_CLASS_P (folded) &amp;&amp; !TREE_OVERFLOW (folded))</span>
<span class="lineNum">    8312 </span><span class="lineCov">     840647 :                 {</span>
<span class="lineNum">    8313 </span><span class="lineCov">    1681294 :                   expression = cp_expr (folded, loc);</span>
<span class="lineNum">    8314 </span>            :                   break;
<span class="lineNum">    8315 </span>            :                 }
<span class="lineNum">    8316 </span>            :             }
<span class="lineNum">    8317 </span>            :           /* Fall through.  */
<span class="lineNum">    8318 </span><span class="lineCov">     840647 :         case UNARY_PLUS_EXPR:</span>
<span class="lineNum">    8319 </span>            :         case TRUTH_NOT_EXPR:
<span class="lineNum">    8320 </span>            :           expression = finish_unary_op_expr (loc, unary_operator,
<span class="lineNum">    8321 </span><span class="lineCov">     389509 :                                              cast_expression, complain);</span>
<span class="lineNum">    8322 </span><span class="lineCov">     389509 :           break;</span>
<span class="lineNum">    8323 </span>            : 
<span class="lineNum">    8324 </span><span class="lineCov">     444442 :         default:</span>
<span class="lineNum">    8325 </span><span class="lineCov">     444442 :           gcc_unreachable ();</span>
<span class="lineNum">    8326 </span>            :         }
<span class="lineNum">    8327 </span>            : 
<span class="lineNum">    8328 </span>            :       if (non_constant_p != NIC_NONE
<span class="lineNum">    8329 </span>            :           &amp;&amp; cp_parser_non_integral_constant_expression (parser,
<span class="lineNum">    8330 </span><span class="lineCov">     444442 :                                                          non_constant_p))</span>
<span class="lineNum">    8331 </span>            :         expression = error_mark_node;
<span class="lineNum">    8332 </span>            : 
<span class="lineNum">    8333 </span><span class="lineCov">     674346 :       return expression;</span>
<span class="lineNum">    8334 </span><span class="lineCov">     674346 :     }</span>
<span class="lineNum">    8335 </span><span class="lineCov">     674346 : </span>
<span class="lineNum">    8336 </span><span class="lineCov">     674346 :   return cp_parser_postfix_expression (parser, address_p, cast_p,</span>
<span class="lineNum">    8337 </span>            :                                        /*member_access_only_p=*/false,
<span class="lineNum">    8338 </span><span class="lineCov">    1131485 :                                        decltype_p,</span>
<span class="lineNum">    8339 </span>            :                                        pidk);
<span class="lineNum">    8340 </span>            : }
<span class="lineNum">    8341 </span><span class="lineCov">    1131485 : </span>
<span class="lineNum">    8342 </span><span class="lineCov">     709800 : /* Returns ERROR_MARK if TOKEN is not a unary-operator.  If TOKEN is a</span>
<span class="lineNum">    8343 </span><span class="lineCov">     709796 :    unary-operator, the corresponding tree code is returned.  */</span>
<a name="8344"><span class="lineNum">    8344 </span><span class="lineCov">    1840893 : </span></a>
<span class="lineNum">    8345 </span>            : static enum tree_code
<span class="lineNum">    8346 </span><span class="lineCov">    1064112 : cp_parser_unary_operator (cp_token* token)</span>
<span class="lineNum">    8347 </span>            : {
<span class="lineNum">    8348 </span>            :   switch (token-&gt;type)
<span class="lineNum">    8349 </span><span class="lineCov">     354704 :     {</span>
<span class="lineNum">    8350 </span>            :     case CPP_MULT:
<span class="lineNum">    8351 </span>            :       return INDIRECT_REF;
<span class="lineNum">    8352 </span>            : 
<span class="lineNum">    8353 </span>            :     case CPP_AND:
<span class="lineNum">    8354 </span>            :       return ADDR_EXPR;
<span class="lineNum">    8355 </span>            : 
<span class="lineNum">    8356 </span><span class="lineCov">    1478122 :     case CPP_PLUS:</span>
<span class="lineNum">    8357 </span><span class="lineCov">    1478122 :       return UNARY_PLUS_EXPR;</span>
<span class="lineNum">    8358 </span><span class="lineCov">    2956244 : </span>
<span class="lineNum">    8359 </span><span class="lineCov">    1478122 :     case CPP_MINUS:</span>
<span class="lineNum">    8360 </span><span class="lineCov">    1478122 :       return NEGATE_EXPR;</span>
<span class="lineNum">    8361 </span>            : 
<span class="lineNum">    8362 </span><span class="lineNoCov">          0 :     case CPP_NOT:</span>
<span class="lineNum">    8363 </span><span class="lineNoCov">          0 :       return TRUTH_NOT_EXPR;</span>
<span class="lineNum">    8364 </span>            : 
<span class="lineNum">    8365 </span>            :     case CPP_COMPL:
<span class="lineNum">    8366 </span><span class="lineCov">     840647 :       return BIT_NOT_EXPR;</span>
<span class="lineNum">    8367 </span><span class="lineCov">    3117915 : </span>
<span class="lineNum">    8368 </span>            :     default:
<span class="lineNum">    8369 </span><span class="lineCov">         26 :       return ERROR_MARK;</span>
<span class="lineNum">    8370 </span>            :     }
<span class="lineNum">    8371 </span><span class="lineCov">    3117915 : }</span>
<span class="lineNum">    8372 </span>            : 
<span class="lineNum">    8373 </span>            : /* Parse a new-expression.
<span class="lineNum">    8374 </span><span class="lineCov">   45827256 : </span>
<span class="lineNum">    8375 </span>            :    new-expression:
<span class="lineNum">    8376 </span>            :      :: [opt] new new-placement [opt] new-type-id new-initializer [opt]
<span class="lineNum">    8377 </span><span class="lineCov">   45827256 :      :: [opt] new new-placement [opt] ( type-id ) new-initializer [opt]</span>
<span class="lineNum">    8378 </span>            : 
<span class="lineNum">    8379 </span>            :    Returns a representation of the expression.  */
<a name="8380"><span class="lineNum">    8380 </span>            : </a>
<span class="lineNum">    8381 </span>            : static tree
<span class="lineNum">    8382 </span>            : cp_parser_new_expression (cp_parser* parser)
<span class="lineNum">    8383 </span>            : {
<span class="lineNum">    8384 </span><span class="lineNoCov">          0 :   bool global_scope_p;</span>
<span class="lineNum">    8385 </span>            :   vec&lt;tree, va_gc&gt; *placement;
<span class="lineNum">    8386 </span><span class="lineCov">   48945319 :   tree type;</span>
<span class="lineNum">    8387 </span>            :   vec&lt;tree, va_gc&gt; *initializer;
<span class="lineNum">    8388 </span>            :   tree nelts = NULL_TREE;
<span class="lineNum">    8389 </span>            :   tree ret;
<span class="lineNum">    8390 </span>            : 
<span class="lineNum">    8391 </span>            :   location_t start_loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">    8392 </span>            : 
<span class="lineNum">    8393 </span>            :   /* Look for the optional `::' operator.  */
<span class="lineNum">    8394 </span>            :   global_scope_p
<span class="lineNum">    8395 </span>            :     = (cp_parser_global_scope_opt (parser,
<span class="lineNum">    8396 </span>            :                                    /*current_scope_valid_p=*/false)
<span class="lineNum">    8397 </span>            :        != NULL_TREE);
<span class="lineNum">    8398 </span>            :   /* Look for the `new' operator.  */
<span class="lineNum">    8399 </span>            :   cp_parser_require_keyword (parser, RID_NEW, RT_NEW);
<span class="lineNum">    8400 </span>            :   /* There's no easy way to tell a new-placement from the
<span class="lineNum">    8401 </span>            :      `( type-id )' construct.  */
<span class="lineNum">    8402 </span>            :   cp_parser_parse_tentatively (parser);
<span class="lineNum">    8403 </span>            :   /* Look for a new-placement.  */
<span class="lineNum">    8404 </span>            :   placement = cp_parser_new_placement (parser);
<span class="lineNum">    8405 </span>            :   /* If that didn't work out, there's no new-placement.  */
<span class="lineNum">    8406 </span>            :   if (!cp_parser_parse_definitely (parser))
<span class="lineNum">    8407 </span>            :     {
<span class="lineNum">    8408 </span>            :       if (placement != NULL)
<span class="lineNum">    8409 </span>            :         release_tree_vector (placement);
<span class="lineNum">    8410 </span>            :       placement = NULL;
<span class="lineNum">    8411 </span>            :     }
<span class="lineNum">    8412 </span>            : 
<span class="lineNum">    8413 </span>            :   /* If the next token is a `(', then we have a parenthesized
<span class="lineNum">    8414 </span>            :      type-id.  */
<span class="lineNum">    8415 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_PAREN))
<span class="lineNum">    8416 </span>            :     {
<span class="lineNum">    8417 </span>            :       cp_token *token;
<span class="lineNum">    8418 </span>            :       const char *saved_message = parser-&gt;type_definition_forbidden_message;
<span class="lineNum">    8419 </span>            : 
<span class="lineNum">    8420 </span><span class="lineCov">      46420 :       /* Consume the `('.  */</span>
<span class="lineNum">    8421 </span>            :       matching_parens parens;
<span class="lineNum">    8422 </span><span class="lineCov">      46420 :       parens.consume_open (parser);</span>
<span class="lineNum">    8423 </span><span class="lineCov">      46420 : </span>
<span class="lineNum">    8424 </span><span class="lineCov">      46420 :       /* Parse the type-id.  */</span>
<span class="lineNum">    8425 </span><span class="lineCov">      46420 :       parser-&gt;type_definition_forbidden_message</span>
<span class="lineNum">    8426 </span><span class="lineCov">      46420 :         = G_(&quot;types may not be defined in a new-expression&quot;);</span>
<span class="lineNum">    8427 </span><span class="lineCov">      46420 :       {</span>
<span class="lineNum">    8428 </span>            :         type_id_in_expr_sentinel s (parser);
<span class="lineNum">    8429 </span><span class="lineCov">      92840 :         type = cp_parser_type_id (parser);</span>
<span class="lineNum">    8430 </span>            :       }
<span class="lineNum">    8431 </span>            :       parser-&gt;type_definition_forbidden_message = saved_message;
<span class="lineNum">    8432 </span><span class="lineCov">      46420 : </span>
<span class="lineNum">    8433 </span><span class="lineCov">      92840 :       /* Look for the closing `)'.  */</span>
<span class="lineNum">    8434 </span>            :       parens.require_close (parser);
<span class="lineNum">    8435 </span>            :       token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">    8436 </span>            :       /* There should not be a direct-new-declarator in this production,
<span class="lineNum">    8437 </span><span class="lineCov">      46420 :          but GCC used to allowed this, so we check and emit a sensible error</span>
<span class="lineNum">    8438 </span>            :          message for this case.  */
<span class="lineNum">    8439 </span>            :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_SQUARE))
<span class="lineNum">    8440 </span><span class="lineCov">      46420 :         {</span>
<span class="lineNum">    8441 </span>            :           error_at (token-&gt;location,
<span class="lineNum">    8442 </span><span class="lineCov">      46420 :                     &quot;array bound forbidden after parenthesized type-id&quot;);</span>
<span class="lineNum">    8443 </span>            :           inform (token-&gt;location, 
<span class="lineNum">    8444 </span><span class="lineCov">      46420 :                   &quot;try removing the parentheses around the type-id&quot;);</span>
<span class="lineNum">    8445 </span>            :           cp_parser_direct_new_declarator (parser);
<span class="lineNum">    8446 </span><span class="lineCov">      22332 :         }</span>
<span class="lineNum">    8447 </span><span class="lineCov">         65 :     }</span>
<span class="lineNum">    8448 </span><span class="lineCov">      22332 :   /* Otherwise, there must be a new-type-id.  */</span>
<span class="lineNum">    8449 </span>            :   else
<span class="lineNum">    8450 </span>            :     type = cp_parser_new_type_id (parser, &amp;nelts);
<span class="lineNum">    8451 </span>            : 
<span class="lineNum">    8452 </span>            :   /* If the next token is a `(' or '{', then we have a new-initializer.  */
<span class="lineNum">    8453 </span><span class="lineCov">      46420 :   cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">    8454 </span>            :   if (token-&gt;type == CPP_OPEN_PAREN
<span class="lineNum">    8455 </span><span class="lineCov">         68 :       || token-&gt;type == CPP_OPEN_BRACE)</span>
<span class="lineNum">    8456 </span><span class="lineCov">         68 :     initializer = cp_parser_new_initializer (parser);</span>
<span class="lineNum">    8457 </span>            :   else
<span class="lineNum">    8458 </span>            :     initializer = NULL;
<span class="lineNum">    8459 </span><span class="lineCov">        136 : </span>
<span class="lineNum">    8460 </span><span class="lineCov">         68 :   /* A new-expression may not appear in an integral constant</span>
<span class="lineNum">    8461 </span>            :      expression.  */
<span class="lineNum">    8462 </span>            :   if (cp_parser_non_integral_constant_expression (parser, NIC_NEW))
<span class="lineNum">    8463 </span><span class="lineCov">         68 :     ret = error_mark_node;</span>
<span class="lineNum">    8464 </span><span class="lineCov">         68 :   /* 5.3.4/2: &quot;If the auto type-specifier appears in the type-specifier-seq</span>
<span class="lineNum">    8465 </span><span class="lineCov">         68 :      of a new-type-id or type-id of a new-expression, the new-expression shall</span>
<span class="lineNum">    8466 </span><span class="lineCov">        272 :      contain a new-initializer of the form ( assignment-expression )&quot;.</span>
<span class="lineNum">    8467 </span><span class="lineCov">        136 :      Additionally, consistently with the spirit of DR 1467, we want to accept</span>
<span class="lineNum">    8468 </span>            :      'new auto { 2 }' too.  */
<span class="lineNum">    8469 </span><span class="lineCov">         68 :   else if ((ret = type_uses_auto (type))</span>
<span class="lineNum">    8470 </span>            :            &amp;&amp; !CLASS_PLACEHOLDER_TEMPLATE (ret)
<span class="lineNum">    8471 </span>            :            &amp;&amp; (vec_safe_length (initializer) != 1
<span class="lineNum">    8472 </span><span class="lineCov">         68 :                || (BRACE_ENCLOSED_INITIALIZER_P ((*initializer)[0])</span>
<span class="lineNum">    8473 </span><span class="lineCov">        136 :                    &amp;&amp; CONSTRUCTOR_NELTS ((*initializer)[0]) != 1)))</span>
<span class="lineNum">    8474 </span>            :     {
<span class="lineNum">    8475 </span>            :       error_at (token-&gt;location,
<span class="lineNum">    8476 </span>            :                 &quot;initialization of new-expression for type %&lt;auto%&gt; &quot;
<span class="lineNum">    8477 </span><span class="lineCov">         68 :                 &quot;requires exactly one element&quot;);</span>
<span class="lineNum">    8478 </span>            :       ret = error_mark_node;
<span class="lineNum">    8479 </span><span class="lineCov">          3 :     }</span>
<span class="lineNum">    8480 </span>            :   else
<span class="lineNum">    8481 </span><span class="lineCov">          3 :     {</span>
<span class="lineNum">    8482 </span>            :       /* Construct a location e.g.:
<span class="lineNum">    8483 </span><span class="lineCov">          3 :            ptr = new int[100]</span>
<span class="lineNum">    8484 </span>            :                  ^~~~~~~~~~~~
<span class="lineNum">    8485 </span>            :          with caret == start at the start of the &quot;new&quot; token, and the end
<span class="lineNum">    8486 </span>            :          at the end of the final token we consumed.  */
<span class="lineNum">    8487 </span>            :       cp_token *end_tok = cp_lexer_previous_token (parser-&gt;lexer);
<span class="lineNum">    8488 </span><span class="lineCov">      46352 :       location_t end_loc = get_finish (end_tok-&gt;location);</span>
<span class="lineNum">    8489 </span>            :       location_t combined_loc = make_location (start_loc, start_loc, end_loc);
<span class="lineNum">    8490 </span>            : 
<span class="lineNum">    8491 </span><span class="lineCov">      92840 :       /* Create a representation of the new-expression.  */</span>
<span class="lineNum">    8492 </span><span class="lineCov">      46420 :       ret = build_new (&amp;placement, type, nelts, &amp;initializer, global_scope_p,</span>
<span class="lineNum">    8493 </span><span class="lineCov">      19063 :                        tf_warning_or_error);</span>
<span class="lineNum">    8494 </span><span class="lineCov">      27819 :       protected_set_expr_location (ret, combined_loc);</span>
<span class="lineNum">    8495 </span>            :     }
<span class="lineNum">    8496 </span><span class="lineCov">      18601 : </span>
<span class="lineNum">    8497 </span>            :   if (placement != NULL)
<span class="lineNum">    8498 </span>            :     release_tree_vector (placement);
<span class="lineNum">    8499 </span>            :   if (initializer != NULL)
<span class="lineNum">    8500 </span><span class="lineCov">      46420 :     release_tree_vector (initializer);</span>
<span class="lineNum">    8501 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    8502 </span>            :   return ret;
<span class="lineNum">    8503 </span>            : }
<span class="lineNum">    8504 </span>            : 
<span class="lineNum">    8505 </span>            : /* Parse a new-placement.
<span class="lineNum">    8506 </span>            : 
<span class="lineNum">    8507 </span><span class="lineCov">      46420 :    new-placement:</span>
<span class="lineNum">    8508 </span><span class="lineCov">         25 :      ( expression-list )</span>
<span class="lineNum">    8509 </span><span class="lineCov">      46440 : </span>
<span class="lineNum">    8510 </span><span class="lineCov">         18 :    Returns the same representation as for an expression-list.  */</span>
<a name="8511"><span class="lineNum">    8511 </span><span class="lineCov">          8 : </span></a>
<span class="lineNum">    8512 </span>            : static vec&lt;tree, va_gc&gt; *
<span class="lineNum">    8513 </span><span class="lineCov">          4 : cp_parser_new_placement (cp_parser* parser)</span>
<span class="lineNum">    8514 </span>            : {
<span class="lineNum">    8515 </span>            :   vec&lt;tree, va_gc&gt; *expression_list;
<span class="lineNum">    8516 </span><span class="lineCov">          4 : </span>
<span class="lineNum">    8517 </span>            :   /* Parse the expression-list.  */
<span class="lineNum">    8518 </span>            :   expression_list = (cp_parser_parenthesized_expression_list
<span class="lineNum">    8519 </span>            :                      (parser, non_attr, /*cast_p=*/false,
<span class="lineNum">    8520 </span>            :                       /*allow_expansion_p=*/true,
<span class="lineNum">    8521 </span>            :                       /*non_constant_p=*/NULL));
<span class="lineNum">    8522 </span>            : 
<span class="lineNum">    8523 </span>            :   if (expression_list &amp;&amp; expression_list-&gt;is_empty ())
<span class="lineNum">    8524 </span>            :     error (&quot;expected expression-list or type-id&quot;);
<span class="lineNum">    8525 </span><span class="lineCov">      46416 : </span>
<span class="lineNum">    8526 </span><span class="lineCov">      46416 :   return expression_list;</span>
<span class="lineNum">    8527 </span><span class="lineCov">      46416 : }</span>
<span class="lineNum">    8528 </span>            : 
<span class="lineNum">    8529 </span>            : /* Parse a new-type-id.
<span class="lineNum">    8530 </span><span class="lineCov">      46416 : </span>
<span class="lineNum">    8531 </span>            :    new-type-id:
<span class="lineNum">    8532 </span><span class="lineCov">      46416 :      type-specifier-seq new-declarator [opt]</span>
<span class="lineNum">    8533 </span>            : 
<span class="lineNum">    8534 </span>            :    Returns the TYPE allocated.  If the new-type-id indicates an array
<span class="lineNum">    8535 </span><span class="lineCov">      46420 :    type, *NELTS is set to the number of elements in the last array</span>
<span class="lineNum">    8536 </span><span class="lineCov">      33234 :    bound; the TYPE will not include the last array bound.  */</span>
<a name="8537"><span class="lineNum">    8537 </span><span class="lineCov">      46420 : </span></a>
<span class="lineNum">    8538 </span><span class="lineCov">      27106 : static tree</span>
<span class="lineNum">    8539 </span>            : cp_parser_new_type_id (cp_parser* parser, tree *nelts)
<span class="lineNum">    8540 </span><span class="lineCov">      46420 : {</span>
<span class="lineNum">    8541 </span>            :   cp_decl_specifier_seq type_specifier_seq;
<span class="lineNum">    8542 </span>            :   cp_declarator *new_declarator;
<span class="lineNum">    8543 </span>            :   cp_declarator *declarator;
<span class="lineNum">    8544 </span>            :   cp_declarator *outer_declarator;
<span class="lineNum">    8545 </span>            :   const char *saved_message;
<span class="lineNum">    8546 </span>            : 
<span class="lineNum">    8547 </span>            :   /* The type-specifier sequence must not contain type definitions.
<span class="lineNum">    8548 </span>            :      (It cannot contain declarations of new types either, but if they
<span class="lineNum">    8549 </span>            :      are not definitions we will catch that because they are not
<span class="lineNum">    8550 </span>            :      complete.)  */
<span class="lineNum">    8551 </span><span class="lineCov">      46420 :   saved_message = parser-&gt;type_definition_forbidden_message;</span>
<span class="lineNum">    8552 </span>            :   parser-&gt;type_definition_forbidden_message
<span class="lineNum">    8553 </span><span class="lineCov">      46420 :     = G_(&quot;types may not be defined in a new-type-id&quot;);</span>
<span class="lineNum">    8554 </span>            :   /* Parse the type-specifier-seq.  */
<span class="lineNum">    8555 </span>            :   cp_parser_type_specifier_seq (parser, /*is_declaration=*/false,
<span class="lineNum">    8556 </span><span class="lineCov">      46420 :                                 /*is_trailing_return=*/false,</span>
<span class="lineNum">    8557 </span><span class="lineCov">      46420 :                                 &amp;type_specifier_seq);</span>
<span class="lineNum">    8558 </span>            :   /* Restore the old message.  */
<span class="lineNum">    8559 </span>            :   parser-&gt;type_definition_forbidden_message = saved_message;
<span class="lineNum">    8560 </span>            : 
<span class="lineNum">    8561 </span><span class="lineCov">      46420 :   if (type_specifier_seq.type == error_mark_node)</span>
<span class="lineNum">    8562 </span><span class="lineCov">          3 :     return error_mark_node;</span>
<span class="lineNum">    8563 </span>            : 
<span class="lineNum">    8564 </span><span class="lineCov">      46420 :   /* Parse the new-declarator.  */</span>
<span class="lineNum">    8565 </span>            :   new_declarator = cp_parser_new_declarator_opt (parser);
<span class="lineNum">    8566 </span>            : 
<span class="lineNum">    8567 </span>            :   /* Determine the number of elements in the last array dimension, if
<span class="lineNum">    8568 </span>            :      any.  */
<span class="lineNum">    8569 </span>            :   *nelts = NULL_TREE;
<span class="lineNum">    8570 </span>            :   /* Skip down to the last array dimension.  */
<span class="lineNum">    8571 </span>            :   declarator = new_declarator;
<span class="lineNum">    8572 </span>            :   outer_declarator = NULL;
<span class="lineNum">    8573 </span>            :   while (declarator &amp;&amp; (declarator-&gt;kind == cdk_pointer
<span class="lineNum">    8574 </span>            :                         || declarator-&gt;kind == cdk_ptrmem))
<span class="lineNum">    8575 </span>            :     {
<span class="lineNum">    8576 </span>            :       outer_declarator = declarator;
<span class="lineNum">    8577 </span><span class="lineCov">      46352 :       declarator = declarator-&gt;declarator;</span>
<span class="lineNum">    8578 </span>            :     }
<span class="lineNum">    8579 </span><span class="lineCov">      46352 :   while (declarator</span>
<span class="lineNum">    8580 </span><span class="lineCov">      46352 :          &amp;&amp; declarator-&gt;kind == cdk_array</span>
<span class="lineNum">    8581 </span><span class="lineCov">      46352 :          &amp;&amp; declarator-&gt;declarator</span>
<span class="lineNum">    8582 </span><span class="lineCov">      46352 :          &amp;&amp; declarator-&gt;declarator-&gt;kind == cdk_array)</span>
<span class="lineNum">    8583 </span><span class="lineCov">      46352 :     {</span>
<span class="lineNum">    8584 </span>            :       outer_declarator = declarator;
<span class="lineNum">    8585 </span>            :       declarator = declarator-&gt;declarator;
<span class="lineNum">    8586 </span>            :     }
<span class="lineNum">    8587 </span>            : 
<span class="lineNum">    8588 </span>            :   if (declarator &amp;&amp; declarator-&gt;kind == cdk_array)
<span class="lineNum">    8589 </span><span class="lineCov">      46352 :     {</span>
<span class="lineNum">    8590 </span><span class="lineCov">      46352 :       *nelts = declarator-&gt;u.array.bounds;</span>
<span class="lineNum">    8591 </span><span class="lineCov">      46352 :       if (*nelts == error_mark_node)</span>
<span class="lineNum">    8592 </span>            :         *nelts = integer_one_node;
<span class="lineNum">    8593 </span><span class="lineCov">      46352 : </span>
<span class="lineNum">    8594 </span>            :       if (outer_declarator)
<span class="lineNum">    8595 </span>            :         outer_declarator-&gt;declarator = declarator-&gt;declarator;
<span class="lineNum">    8596 </span>            :       else
<span class="lineNum">    8597 </span><span class="lineCov">      46352 :         new_declarator = NULL;</span>
<span class="lineNum">    8598 </span>            :     }
<span class="lineNum">    8599 </span><span class="lineCov">      46352 : </span>
<span class="lineNum">    8600 </span>            :   return groktypename (&amp;type_specifier_seq, new_declarator, false);
<span class="lineNum">    8601 </span>            : }
<span class="lineNum">    8602 </span>            : 
<span class="lineNum">    8603 </span><span class="lineCov">      46341 : /* Parse an (optional) new-declarator.</span>
<span class="lineNum">    8604 </span>            : 
<span class="lineNum">    8605 </span>            :    new-declarator:
<span class="lineNum">    8606 </span>            :      ptr-operator new-declarator [opt]
<span class="lineNum">    8607 </span><span class="lineCov">      46341 :      direct-new-declarator</span>
<span class="lineNum">    8608 </span>            : 
<span class="lineNum">    8609 </span><span class="lineCov">      46341 :    Returns the declarator.  */</span>
<a name="8610"><span class="lineNum">    8610 </span><span class="lineCov">      46341 : </span></a>
<span class="lineNum">    8611 </span><span class="lineCov">      46401 : static cp_declarator *</span>
<span class="lineNum">    8612 </span><span class="lineCov">      12612 : cp_parser_new_declarator_opt (cp_parser* parser)</span>
<span class="lineNum">    8613 </span>            : {
<span class="lineNum">    8614 </span><span class="lineCov">         60 :   enum tree_code code;</span>
<span class="lineNum">    8615 </span><span class="lineCov">         60 :   tree type, std_attributes = NULL_TREE;</span>
<span class="lineNum">    8616 </span>            :   cp_cv_quals cv_quals;  
<span class="lineNum">    8617 </span><span class="lineCov">      48215 : </span>
<span class="lineNum">    8618 </span><span class="lineCov">      14486 :   /* We don't know if there's a ptr-operator next, or not.  */</span>
<span class="lineNum">    8619 </span><span class="lineCov">      14477 :   cp_parser_parse_tentatively (parser);</span>
<span class="lineNum">    8620 </span><span class="lineCov">      48215 :   /* Look for a ptr-operator.  */</span>
<span class="lineNum">    8621 </span>            :   code = cp_parser_ptr_operator (parser, &amp;type, &amp;cv_quals, &amp;std_attributes);
<span class="lineNum">    8622 </span>            :   /* If that worked, look for more new-declarators.  */
<span class="lineNum">    8623 </span>            :   if (cp_parser_parse_definitely (parser))
<span class="lineNum">    8624 </span>            :     {
<span class="lineNum">    8625 </span>            :       cp_declarator *declarator;
<span class="lineNum">    8626 </span><span class="lineCov">      46341 : </span>
<span class="lineNum">    8627 </span>            :       /* Parse another optional declarator.  */
<span class="lineNum">    8628 </span><span class="lineCov">      12603 :       declarator = cp_parser_new_declarator_opt (parser);</span>
<span class="lineNum">    8629 </span><span class="lineCov">      12603 : </span>
<span class="lineNum">    8630 </span><span class="lineCov">         24 :       declarator = cp_parser_make_indirect_declarator</span>
<span class="lineNum">    8631 </span>            :         (code, type, cv_quals, declarator, std_attributes);
<span class="lineNum">    8632 </span><span class="lineCov">      12603 : </span>
<span class="lineNum">    8633 </span><span class="lineCov">       1181 :       return declarator;</span>
<span class="lineNum">    8634 </span>            :     }
<span class="lineNum">    8635 </span>            : 
<span class="lineNum">    8636 </span>            :   /* If the next token is a `[', there is a direct-new-declarator.  */
<span class="lineNum">    8637 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_SQUARE))
<span class="lineNum">    8638 </span><span class="lineCov">      46341 :     return cp_parser_direct_new_declarator (parser);</span>
<span class="lineNum">    8639 </span>            : 
<span class="lineNum">    8640 </span>            :   return NULL;
<span class="lineNum">    8641 </span>            : }
<span class="lineNum">    8642 </span>            : 
<span class="lineNum">    8643 </span>            : /* Parse a direct-new-declarator.
<span class="lineNum">    8644 </span>            : 
<span class="lineNum">    8645 </span>            :    direct-new-declarator:
<span class="lineNum">    8646 </span>            :      [ expression ]
<span class="lineNum">    8647 </span>            :      direct-new-declarator [constant-expression]
<span class="lineNum">    8648 </span>            : 
<span class="lineNum">    8649 </span>            :    */
<a name="8650"><span class="lineNum">    8650 </span><span class="lineCov">      46410 : </span></a>
<span class="lineNum">    8651 </span>            : static cp_declarator *
<span class="lineNum">    8652 </span><span class="lineCov">      46410 : cp_parser_direct_new_declarator (cp_parser* parser)</span>
<span class="lineNum">    8653 </span><span class="lineCov">      46410 : {</span>
<span class="lineNum">    8654 </span><span class="lineCov">      46410 :   cp_declarator *declarator = NULL;</span>
<span class="lineNum">    8655 </span>            : 
<span class="lineNum">    8656 </span>            :   while (true)
<span class="lineNum">    8657 </span><span class="lineCov">      46410 :     {</span>
<span class="lineNum">    8658 </span>            :       tree expression;
<span class="lineNum">    8659 </span><span class="lineCov">      46410 :       cp_token *token;</span>
<span class="lineNum">    8660 </span>            : 
<span class="lineNum">    8661 </span><span class="lineCov">      46410 :       /* Look for the opening `['.  */</span>
<span class="lineNum">    8662 </span>            :       cp_parser_require (parser, CPP_OPEN_SQUARE, RT_OPEN_SQUARE);
<span class="lineNum">    8663 </span><span class="lineCov">         69 : </span>
<span class="lineNum">    8664 </span>            :       token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">    8665 </span>            :       expression = cp_parser_expression (parser);
<span class="lineNum">    8666 </span><span class="lineCov">         69 :       /* The standard requires that the expression have integral</span>
<span class="lineNum">    8667 </span>            :          type.  DR 74 adds enumeration types.  We believe that the
<span class="lineNum">    8668 </span><span class="lineCov">         69 :          real intent is that these expressions be handled like the</span>
<span class="lineNum">    8669 </span><span class="lineCov">         69 :          expression in a `switch' condition, which also allows</span>
<span class="lineNum">    8670 </span>            :          classes with a single conversion to integral or
<span class="lineNum">    8671 </span><span class="lineCov">         69 :          enumeration type.  */</span>
<span class="lineNum">    8672 </span>            :       if (!processing_template_decl)
<span class="lineNum">    8673 </span>            :         {
<span class="lineNum">    8674 </span>            :           expression
<span class="lineNum">    8675 </span><span class="lineCov">      46341 :             = build_expr_type_conversion (WANT_INT | WANT_ENUM,</span>
<span class="lineNum">    8676 </span><span class="lineCov">      12609 :                                           expression,</span>
<span class="lineNum">    8677 </span>            :                                           /*complain=*/true);
<span class="lineNum">    8678 </span>            :           if (!expression)
<span class="lineNum">    8679 </span>            :             {
<span class="lineNum">    8680 </span>            :               error_at (token-&gt;location,
<span class="lineNum">    8681 </span>            :                         &quot;expression in new-declarator must have integral &quot;
<span class="lineNum">    8682 </span>            :                         &quot;or enumeration type&quot;);
<span class="lineNum">    8683 </span>            :               expression = error_mark_node;
<span class="lineNum">    8684 </span>            :             }
<span class="lineNum">    8685 </span>            :         }
<span class="lineNum">    8686 </span>            : 
<span class="lineNum">    8687 </span>            :       /* Look for the closing `]'.  */
<span class="lineNum">    8688 </span>            :       cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);
<span class="lineNum">    8689 </span>            : 
<span class="lineNum">    8690 </span><span class="lineCov">      12612 :       /* Add this bound to the declarator.  */</span>
<span class="lineNum">    8691 </span>            :       declarator = make_array_declarator (declarator, expression);
<span class="lineNum">    8692 </span><span class="lineCov">      12612 : </span>
<span class="lineNum">    8693 </span>            :       /* If the next token is not a `[', then there are no more
<span class="lineNum">    8694 </span><span class="lineCov">      14486 :          bounds.  */</span>
<span class="lineNum">    8695 </span>            :       if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_OPEN_SQUARE))
<span class="lineNum">    8696 </span><span class="lineCov">      14486 :         break;</span>
<span class="lineNum">    8697 </span><span class="lineCov">      14486 :     }</span>
<span class="lineNum">    8698 </span>            : 
<span class="lineNum">    8699 </span>            :   return declarator;
<span class="lineNum">    8700 </span><span class="lineCov">      14486 : }</span>
<span class="lineNum">    8701 </span>            : 
<span class="lineNum">    8702 </span><span class="lineCov">      28972 : /* Parse a new-initializer.</span>
<span class="lineNum">    8703 </span><span class="lineCov">      14486 : </span>
<span class="lineNum">    8704 </span>            :    new-initializer:
<span class="lineNum">    8705 </span>            :      ( expression-list [opt] )
<span class="lineNum">    8706 </span>            :      braced-init-list
<span class="lineNum">    8707 </span>            : 
<span class="lineNum">    8708 </span>            :    Returns a representation of the expression-list.  */
<a name="8709"><span class="lineNum">    8709 </span>            : </a>
<span class="lineNum">    8710 </span><span class="lineCov">      14486 : static vec&lt;tree, va_gc&gt; *</span>
<span class="lineNum">    8711 </span>            : cp_parser_new_initializer (cp_parser* parser)
<span class="lineNum">    8712 </span><span class="lineCov">       4514 : {</span>
<span class="lineNum">    8713 </span><span class="lineCov">       4514 :   vec&lt;tree, va_gc&gt; *expression_list;</span>
<span class="lineNum">    8714 </span>            : 
<span class="lineNum">    8715 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_BRACE))
<span class="lineNum">    8716 </span><span class="lineCov">       4514 :     {</span>
<span class="lineNum">    8717 </span>            :       tree t;
<span class="lineNum">    8718 </span><span class="lineCov">         15 :       bool expr_non_constant_p;</span>
<span class="lineNum">    8719 </span>            :       cp_lexer_set_source_position (parser-&gt;lexer);
<span class="lineNum">    8720 </span>            :       maybe_warn_cpp0x (CPP0X_INITIALIZER_LISTS);
<span class="lineNum">    8721 </span><span class="lineCov">         15 :       t = cp_parser_braced_list (parser, &amp;expr_non_constant_p);</span>
<span class="lineNum">    8722 </span>            :       CONSTRUCTOR_IS_DIRECT_INIT (t) = 1;
<span class="lineNum">    8723 </span>            :       expression_list = make_tree_vector_single (t);
<span class="lineNum">    8724 </span>            :     }
<span class="lineNum">    8725 </span>            :   else
<span class="lineNum">    8726 </span><span class="lineCov">      14486 :     expression_list = (cp_parser_parenthesized_expression_list</span>
<span class="lineNum">    8727 </span>            :                        (parser, non_attr, /*cast_p=*/false,
<span class="lineNum">    8728 </span>            :                         /*allow_expansion_p=*/true,
<span class="lineNum">    8729 </span><span class="lineCov">      14486 :                         /*non_constant_p=*/NULL));</span>
<span class="lineNum">    8730 </span>            : 
<span class="lineNum">    8731 </span>            :   return expression_list;
<span class="lineNum">    8732 </span>            : }
<span class="lineNum">    8733 </span><span class="lineCov">      14486 : </span>
<span class="lineNum">    8734 </span>            : /* Parse a delete-expression.
<span class="lineNum">    8735 </span>            : 
<span class="lineNum">    8736 </span>            :    delete-expression:
<span class="lineNum">    8737 </span><span class="lineCov">      12612 :      :: [opt] delete cast-expression</span>
<span class="lineNum">    8738 </span>            :      :: [opt] delete [ ] cast-expression
<span class="lineNum">    8739 </span>            : 
<span class="lineNum">    8740 </span>            :    Returns a representation of the expression.  */
<a name="8741"><span class="lineNum">    8741 </span>            : </a>
<span class="lineNum">    8742 </span>            : static tree
<span class="lineNum">    8743 </span>            : cp_parser_delete_expression (cp_parser* parser)
<span class="lineNum">    8744 </span>            : {
<span class="lineNum">    8745 </span>            :   bool global_scope_p;
<span class="lineNum">    8746 </span>            :   bool array_p;
<span class="lineNum">    8747 </span>            :   tree expression;
<span class="lineNum">    8748 </span>            : 
<span class="lineNum">    8749 </span><span class="lineCov">      27819 :   /* Look for the optional `::' operator.  */</span>
<span class="lineNum">    8750 </span>            :   global_scope_p
<span class="lineNum">    8751 </span><span class="lineCov">      27819 :     = (cp_parser_global_scope_opt (parser,</span>
<span class="lineNum">    8752 </span>            :                                    /*current_scope_valid_p=*/false)
<span class="lineNum">    8753 </span><span class="lineCov">      27819 :        != NULL_TREE);</span>
<span class="lineNum">    8754 </span>            :   /* Look for the `delete' keyword.  */
<span class="lineNum">    8755 </span><span class="lineCov">        462 :   cp_parser_require_keyword (parser, RID_DELETE, RT_DELETE);</span>
<span class="lineNum">    8756 </span><span class="lineCov">        462 :   /* See if the array syntax is in use.  */</span>
<span class="lineNum">    8757 </span><span class="lineCov">        924 :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_SQUARE))</span>
<span class="lineNum">    8758 </span><span class="lineCov">        462 :     {</span>
<span class="lineNum">    8759 </span><span class="lineCov">        462 :       /* Consume the `[' token.  */</span>
<span class="lineNum">    8760 </span><span class="lineCov">        462 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    8761 </span><span class="lineCov">        462 :       /* Look for the `]' token.  */</span>
<span class="lineNum">    8762 </span>            :       cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);
<span class="lineNum">    8763 </span>            :       /* Remember that this is the `[]' construct.  */
<span class="lineNum">    8764 </span><span class="lineCov">      27357 :       array_p = true;</span>
<span class="lineNum">    8765 </span><span class="lineCov">      27357 :     }</span>
<span class="lineNum">    8766 </span>            :   else
<span class="lineNum">    8767 </span>            :     array_p = false;
<span class="lineNum">    8768 </span>            : 
<span class="lineNum">    8769 </span><span class="lineCov">      27819 :   /* Parse the cast-expression.  */</span>
<span class="lineNum">    8770 </span>            :   expression = cp_parser_simple_cast_expression (parser);
<span class="lineNum">    8771 </span>            : 
<span class="lineNum">    8772 </span>            :   /* A delete-expression may not appear in an integral constant
<span class="lineNum">    8773 </span>            :      expression.  */
<span class="lineNum">    8774 </span>            :   if (cp_parser_non_integral_constant_expression (parser, NIC_DEL))
<span class="lineNum">    8775 </span>            :     return error_mark_node;
<span class="lineNum">    8776 </span>            : 
<span class="lineNum">    8777 </span>            :   return delete_sanity (expression, NULL_TREE, array_p, global_scope_p,
<span class="lineNum">    8778 </span>            :                         tf_warning_or_error);
<span class="lineNum">    8779 </span>            : }
<span class="lineNum">    8780 </span>            : 
<span class="lineNum">    8781 </span><span class="lineCov">      26504 : /* Returns 1 if TOKEN may start a cast-expression and isn't '++', '--',</span>
<span class="lineNum">    8782 </span>            :    neither '[' in C++11; -1 if TOKEN is '++', '--', or '[' in C++11;
<span class="lineNum">    8783 </span><span class="lineCov">      26504 :    0 otherwise.  */</span>
<a name="8784"><span class="lineNum">    8784 </span><span class="lineCov">      26504 : </span></a>
<span class="lineNum">    8785 </span><span class="lineCov">      26504 : static int</span>
<span class="lineNum">    8786 </span>            : cp_parser_tokens_start_cast_expression (cp_parser *parser)
<span class="lineNum">    8787 </span>            : {
<span class="lineNum">    8788 </span><span class="lineCov">      26504 :   cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">    8789 </span><span class="lineCov">      53008 :   switch (token-&gt;type)</span>
<span class="lineNum">    8790 </span>            :     {
<span class="lineNum">    8791 </span>            :     case CPP_COMMA:
<span class="lineNum">    8792 </span>            :     case CPP_SEMICOLON:
<span class="lineNum">    8793 </span><span class="lineCov">      26504 :     case CPP_QUERY:</span>
<span class="lineNum">    8794 </span>            :     case CPP_COLON:
<span class="lineNum">    8795 </span><span class="lineCov">      26504 :     case CPP_CLOSE_SQUARE:</span>
<span class="lineNum">    8796 </span>            :     case CPP_CLOSE_PAREN:
<span class="lineNum">    8797 </span>            :     case CPP_CLOSE_BRACE:
<span class="lineNum">    8798 </span><span class="lineCov">      17268 :     case CPP_OPEN_BRACE:</span>
<span class="lineNum">    8799 </span>            :     case CPP_DOT:
<span class="lineNum">    8800 </span><span class="lineCov">      17268 :     case CPP_DOT_STAR:</span>
<span class="lineNum">    8801 </span>            :     case CPP_DEREF:
<span class="lineNum">    8802 </span><span class="lineCov">      17268 :     case CPP_DEREF_STAR:</span>
<span class="lineNum">    8803 </span>            :     case CPP_DIV:
<span class="lineNum">    8804 </span>            :     case CPP_MOD:
<span class="lineNum">    8805 </span>            :     case CPP_LSHIFT:
<span class="lineNum">    8806 </span>            :     case CPP_RSHIFT:
<span class="lineNum">    8807 </span>            :     case CPP_LESS:
<span class="lineNum">    8808 </span><span class="lineCov">      26504 :     case CPP_GREATER:</span>
<span class="lineNum">    8809 </span>            :     case CPP_LESS_EQ:
<span class="lineNum">    8810 </span>            :     case CPP_GREATER_EQ:
<span class="lineNum">    8811 </span>            :     case CPP_EQ_EQ:
<span class="lineNum">    8812 </span><span class="lineCov">      26504 :     case CPP_NOT_EQ:</span>
<span class="lineNum">    8813 </span><span class="lineNoCov">          0 :     case CPP_EQ:</span>
<span class="lineNum">    8814 </span>            :     case CPP_MULT_EQ:
<span class="lineNum">    8815 </span><span class="lineCov">      26504 :     case CPP_DIV_EQ:</span>
<span class="lineNum">    8816 </span><span class="lineCov">      26504 :     case CPP_MOD_EQ:</span>
<span class="lineNum">    8817 </span>            :     case CPP_PLUS_EQ:
<span class="lineNum">    8818 </span>            :     case CPP_MINUS_EQ:
<span class="lineNum">    8819 </span>            :     case CPP_RSHIFT_EQ:
<span class="lineNum">    8820 </span>            :     case CPP_LSHIFT_EQ:
<span class="lineNum">    8821 </span>            :     case CPP_AND_EQ:
<span class="lineNum">    8822 </span>            :     case CPP_XOR_EQ:
<span class="lineNum">    8823 </span>            :     case CPP_OR_EQ:
<span class="lineNum">    8824 </span><span class="lineCov">    5837402 :     case CPP_XOR:</span>
<span class="lineNum">    8825 </span>            :     case CPP_OR:
<span class="lineNum">    8826 </span><span class="lineCov">   11674804 :     case CPP_OR_OR:</span>
<span class="lineNum">    8827 </span><span class="lineCov">    5837402 :     case CPP_EOF:</span>
<span class="lineNum">    8828 </span>            :     case CPP_ELLIPSIS:
<span class="lineNum">    8829 </span>            :       return 0;
<span class="lineNum">    8830 </span>            : 
<span class="lineNum">    8831 </span>            :     case CPP_OPEN_PAREN:
<span class="lineNum">    8832 </span>            :       /* In ((type ()) () the last () isn't a valid cast-expression,
<span class="lineNum">    8833 </span>            :          so the whole must be parsed as postfix-expression.  */
<span class="lineNum">    8834 </span>            :       return cp_lexer_peek_nth_token (parser-&gt;lexer, 2)-&gt;type
<span class="lineNum">    8835 </span>            :              != CPP_CLOSE_PAREN;
<span class="lineNum">    8836 </span>            : 
<span class="lineNum">    8837 </span>            :     case CPP_OPEN_SQUARE:
<span class="lineNum">    8838 </span>            :       /* '[' may start a primary-expression in obj-c++ and in C++11,
<span class="lineNum">    8839 </span>            :          as a lambda-expression, eg, '(void)[]{}'.  */
<span class="lineNum">    8840 </span>            :       if (cxx_dialect &gt;= cxx11)
<span class="lineNum">    8841 </span>            :         return -1;
<span class="lineNum">    8842 </span>            :       return c_dialect_objc ();
<span class="lineNum">    8843 </span>            : 
<span class="lineNum">    8844 </span>            :     case CPP_PLUS_PLUS:
<span class="lineNum">    8845 </span>            :     case CPP_MINUS_MINUS:
<span class="lineNum">    8846 </span>            :       /* '++' and '--' may or may not start a cast-expression:
<span class="lineNum">    8847 </span>            : 
<span class="lineNum">    8848 </span>            :          struct T { void operator++(int); };
<span class="lineNum">    8849 </span>            :          void f() { (T())++; }
<span class="lineNum">    8850 </span>            : 
<span class="lineNum">    8851 </span>            :          vs
<span class="lineNum">    8852 </span>            : 
<span class="lineNum">    8853 </span>            :          int a;
<span class="lineNum">    8854 </span>            :          (int)++a;  */
<span class="lineNum">    8855 </span>            :       return -1;
<span class="lineNum">    8856 </span>            : 
<span class="lineNum">    8857 </span>            :     default:
<span class="lineNum">    8858 </span>            :       return 1;
<span class="lineNum">    8859 </span>            :     }
<span class="lineNum">    8860 </span>            : }
<span class="lineNum">    8861 </span>            : 
<span class="lineNum">    8862 </span>            : /* Try to find a legal C++-style cast to DST_TYPE for ORIG_EXPR, trying them
<span class="lineNum">    8863 </span>            :    in the order: const_cast, static_cast, reinterpret_cast.
<span class="lineNum">    8864 </span>            : 
<span class="lineNum">    8865 </span>            :    Don't suggest dynamic_cast.
<span class="lineNum">    8866 </span>            : 
<span class="lineNum">    8867 </span>            :    Return the first legal cast kind found, or NULL otherwise.  */
<a name="8868"><span class="lineNum">    8868 </span>            : </a>
<span class="lineNum">    8869 </span><span class="lineCov">     357214 : static const char *</span>
<span class="lineNum">    8870 </span>            : get_cast_suggestion (tree dst_type, tree orig_expr)
<span class="lineNum">    8871 </span>            : {
<span class="lineNum">    8872 </span><span class="lineCov">     357214 :   tree trial;</span>
<span class="lineNum">    8873 </span><span class="lineCov">     357214 : </span>
<span class="lineNum">    8874 </span>            :   /* Reuse the parser logic by attempting to build the various kinds of
<span class="lineNum">    8875 </span><span class="lineCov">      14293 :      cast, with &quot;complain&quot; disabled.</span>
<span class="lineNum">    8876 </span>            :      Identify the first such cast that is valid.  */
<span class="lineNum">    8877 </span>            : 
<span class="lineNum">    8878 </span><span class="lineCov">      14293 :   /* Don't attempt to run such logic within template processing.  */</span>
<span class="lineNum">    8879 </span>            :   if (processing_template_decl)
<span class="lineNum">    8880 </span><span class="lineCov">        572 :     return NULL;</span>
<span class="lineNum">    8881 </span>            : 
<span class="lineNum">    8882 </span><span class="lineCov">      34510 :   /* First try const_cast.  */</span>
<span class="lineNum">    8883 </span><span class="lineCov">      34510 :   trial = build_const_cast (dst_type, orig_expr, tf_none);</span>
<span class="lineNum">    8884 </span>            :   if (trial != error_mark_node)
<span class="lineNum">    8885 </span>            :     return &quot;const_cast&quot;;
<span class="lineNum">    8886 </span>            : 
<span class="lineNum">    8887 </span>            :   /* If that fails, try static_cast.  */
<span class="lineNum">    8888 </span>            :   trial = build_static_cast (dst_type, orig_expr, tf_none);
<span class="lineNum">    8889 </span>            :   if (trial != error_mark_node)
<span class="lineNum">    8890 </span>            :     return &quot;static_cast&quot;;
<span class="lineNum">    8891 </span>            : 
<span class="lineNum">    8892 </span>            :   /* Finally, try reinterpret_cast.  */
<span class="lineNum">    8893 </span><span class="lineCov">      34510 :   trial = build_reinterpret_cast (dst_type, orig_expr, tf_none);</span>
<span class="lineNum">    8894 </span>            :   if (trial != error_mark_node)
<span class="lineNum">    8895 </span><span class="lineCov">    3050252 :     return &quot;reinterpret_cast&quot;;</span>
<span class="lineNum">    8896 </span><span class="lineCov">    3050252 : </span>
<span class="lineNum">    8897 </span>            :   /* No such cast possible.  */
<span class="lineNum">    8898 </span>            :   return NULL;
<span class="lineNum">    8899 </span>            : }
<span class="lineNum">    8900 </span>            : 
<span class="lineNum">    8901 </span>            : /* If -Wold-style-cast is enabled, add fix-its to RICHLOC,
<span class="lineNum">    8902 </span>            :    suggesting how to convert a C-style cast of the form:
<span class="lineNum">    8903 </span>            : 
<span class="lineNum">    8904 </span>            :      (DST_TYPE)ORIG_EXPR
<span class="lineNum">    8905 </span>            : 
<span class="lineNum">    8906 </span>            :    to a C++-style cast.
<span class="lineNum">    8907 </span>            : 
<span class="lineNum">    8908 </span><span class="lineCov">         27 :    The primary range of RICHLOC is asssumed to be that of the original</span>
<span class="lineNum">    8909 </span>            :    expression.  OPEN_PAREN_LOC and CLOSE_PAREN_LOC give the locations
<span class="lineNum">    8910 </span><span class="lineCov">         27 :    of the parens in the C-style cast.  */</span>
<a name="8911"><span class="lineNum">    8911 </span>            : </a>
<span class="lineNum">    8912 </span>            : static void
<span class="lineNum">    8913 </span>            : maybe_add_cast_fixit (rich_location *rich_loc, location_t open_paren_loc,
<span class="lineNum">    8914 </span>            :                       location_t close_paren_loc, tree orig_expr,
<span class="lineNum">    8915 </span>            :                       tree dst_type)
<span class="lineNum">    8916 </span>            : {
<span class="lineNum">    8917 </span><span class="lineCov">         27 :   /* This function is non-trivial, so bail out now if the warning isn't</span>
<span class="lineNum">    8918 </span>            :      going to be emitted.  */
<span class="lineNum">    8919 </span>            :   if (!warn_old_style_cast)
<span class="lineNum">    8920 </span>            :     return;
<span class="lineNum">    8921 </span><span class="lineCov">         24 : </span>
<span class="lineNum">    8922 </span><span class="lineCov">         24 :   /* Try to find a legal C++ cast, trying them in order:</span>
<span class="lineNum">    8923 </span>            :      const_cast, static_cast, reinterpret_cast.  */
<span class="lineNum">    8924 </span>            :   const char *cast_suggestion = get_cast_suggestion (dst_type, orig_expr);
<span class="lineNum">    8925 </span>            :   if (!cast_suggestion)
<span class="lineNum">    8926 </span><span class="lineCov">         18 :     return;</span>
<span class="lineNum">    8927 </span><span class="lineCov">         18 : </span>
<span class="lineNum">    8928 </span>            :   /* Replace the open paren with &quot;CAST_SUGGESTION&lt;&quot;.  */
<span class="lineNum">    8929 </span>            :   pretty_printer pp;
<span class="lineNum">    8930 </span>            :   pp_printf (&amp;pp, &quot;%s&lt;&quot;, cast_suggestion);
<span class="lineNum">    8931 </span><span class="lineCov">         12 :   rich_loc-&gt;add_fixit_replace (open_paren_loc, pp_formatted_text (&amp;pp));</span>
<span class="lineNum">    8932 </span><span class="lineCov">         12 : </span>
<span class="lineNum">    8933 </span><span class="lineCov">          6 :   /* Replace the close paren with &quot;&gt; (&quot;.  */</span>
<span class="lineNum">    8934 </span>            :   rich_loc-&gt;add_fixit_replace (close_paren_loc, &quot;&gt; (&quot;);
<span class="lineNum">    8935 </span>            : 
<span class="lineNum">    8936 </span>            :   /* Add a closing paren after the expr (the primary range of RICH_LOC).  */
<span class="lineNum">    8937 </span>            :   rich_loc-&gt;add_fixit_insert_after (&quot;)&quot;);
<span class="lineNum">    8938 </span>            : }
<span class="lineNum">    8939 </span>            : 
<span class="lineNum">    8940 </span>            : 
<span class="lineNum">    8941 </span>            : /* Parse a cast-expression.
<span class="lineNum">    8942 </span>            : 
<span class="lineNum">    8943 </span>            :    cast-expression:
<span class="lineNum">    8944 </span>            :      unary-expression
<span class="lineNum">    8945 </span>            :      ( type-id ) cast-expression
<span class="lineNum">    8946 </span>            : 
<span class="lineNum">    8947 </span>            :    ADDRESS_P is true iff the unary-expression is appearing as the
<span class="lineNum">    8948 </span>            :    operand of the `&amp;' operator.   CAST_P is true if this expression is
<span class="lineNum">    8949 </span>            :    the target of a cast.
<span class="lineNum">    8950 </span>            : 
<span class="lineNum">    8951 </span><span class="lineCov">         27 :    Returns a representation of the expression.  */</span>
<a name="8952"><span class="lineNum">    8952 </span>            : </a>
<span class="lineNum">    8953 </span>            : static cp_expr
<span class="lineNum">    8954 </span>            : cp_parser_cast_expression (cp_parser *parser, bool address_p, bool cast_p,
<span class="lineNum">    8955 </span>            :                            bool decltype_p, cp_id_kind * pidk)
<span class="lineNum">    8956 </span>            : {
<span class="lineNum">    8957 </span><span class="lineCov">         27 :   /* If it's a `(', then we might be looking at a cast.  */</span>
<span class="lineNum">    8958 </span><span class="lineCov">          9 :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_PAREN))</span>
<span class="lineNum">    8959 </span>            :     {
<span class="lineNum">    8960 </span>            :       tree type = NULL_TREE;
<span class="lineNum">    8961 </span>            :       cp_expr expr (NULL_TREE);
<span class="lineNum">    8962 </span><span class="lineCov">         27 :       int cast_expression = 0;</span>
<span class="lineNum">    8963 </span><span class="lineCov">         27 :       const char *saved_message;</span>
<span class="lineNum">    8964 </span>            : 
<span class="lineNum">    8965 </span>            :       /* There's no way to know yet whether or not this is a cast.
<span class="lineNum">    8966 </span>            :          For example, `(int (3))' is a unary-expression, while `(int)
<span class="lineNum">    8967 </span><span class="lineCov">         36 :          3' is a cast.  So, we resort to parsing tentatively.  */</span>
<span class="lineNum">    8968 </span><span class="lineCov">         18 :       cp_parser_parse_tentatively (parser);</span>
<span class="lineNum">    8969 </span><span class="lineCov">         18 :       /* Types may not be defined in a cast.  */</span>
<span class="lineNum">    8970 </span>            :       saved_message = parser-&gt;type_definition_forbidden_message;
<span class="lineNum">    8971 </span>            :       parser-&gt;type_definition_forbidden_message
<span class="lineNum">    8972 </span><span class="lineCov">         18 :         = G_(&quot;types may not be defined in casts&quot;);</span>
<span class="lineNum">    8973 </span>            :       /* Consume the `('.  */
<span class="lineNum">    8974 </span>            :       matching_parens parens;
<span class="lineNum">    8975 </span><span class="lineCov">         18 :       cp_token *open_paren = parens.consume_open (parser);</span>
<span class="lineNum">    8976 </span>            :       location_t open_paren_loc = open_paren-&gt;location;
<span class="lineNum">    8977 </span>            :       location_t close_paren_loc = UNKNOWN_LOCATION;
<span class="lineNum">    8978 </span>            : 
<span class="lineNum">    8979 </span>            :       /* A very tricky bit is that `(struct S) { 3 }' is a
<span class="lineNum">    8980 </span>            :          compound-literal (which we permit in C++ as an extension).
<span class="lineNum">    8981 </span>            :          But, that construct is not a cast-expression -- it is a
<span class="lineNum">    8982 </span>            :          postfix-expression.  (The reason is that `(struct S) { 3 }.i'
<span class="lineNum">    8983 </span>            :          is legal; if the compound-literal were a cast-expression,
<span class="lineNum">    8984 </span>            :          you'd need an extra set of parentheses.)  But, if we parse
<span class="lineNum">    8985 </span>            :          the type-id, and it happens to be a class-specifier, then we
<span class="lineNum">    8986 </span>            :          will commit to the parse at that point, because we cannot
<span class="lineNum">    8987 </span>            :          undo the action that is done when creating a new class.  So,
<span class="lineNum">    8988 </span>            :          then we cannot back up and do a postfix-expression.
<span class="lineNum">    8989 </span>            : 
<span class="lineNum">    8990 </span>            :          Another tricky case is the following (c++/29234):
<span class="lineNum">    8991 </span>            : 
<span class="lineNum">    8992 </span><span class="lineCov">   52140545 :          struct S { void operator () (); };</span>
<span class="lineNum">    8993 </span>            : 
<span class="lineNum">    8994 </span>            :          void foo ()
<span class="lineNum">    8995 </span>            :          {
<span class="lineNum">    8996 </span><span class="lineCov">   52140545 :            ( S()() );</span>
<span class="lineNum">    8997 </span>            :          }
<span class="lineNum">    8998 </span><span class="lineCov">    5837405 : </span>
<span class="lineNum">    8999 </span><span class="lineCov">    5837405 :          As a type-id we parse the parenthesized S()() as a function</span>
<span class="lineNum">    9000 </span><span class="lineCov">    5837405 :          returning a function, groktypename complains and we cannot</span>
<span class="lineNum">    9001 </span><span class="lineCov">    5837405 :          back up in this case either.</span>
<span class="lineNum">    9002 </span>            : 
<span class="lineNum">    9003 </span>            :          Therefore, we scan ahead to the closing `)', and check to see
<span class="lineNum">    9004 </span>            :          if the tokens after the `)' can start a cast-expression.  Otherwise
<span class="lineNum">    9005 </span>            :          we are dealing with an unary-expression, a postfix-expression
<span class="lineNum">    9006 </span><span class="lineCov">    5837405 :          or something else.</span>
<span class="lineNum">    9007 </span>            : 
<span class="lineNum">    9008 </span><span class="lineCov">    5837405 :          Yet another tricky case, in C++11, is the following (c++/54891):</span>
<span class="lineNum">    9009 </span><span class="lineCov">    5837405 : </span>
<span class="lineNum">    9010 </span><span class="lineCov">    5837405 :          (void)[]{};</span>
<span class="lineNum">    9011 </span>            : 
<span class="lineNum">    9012 </span><span class="lineCov">   11674810 :          The issue is that usually, besides the case of lambda-expressions,</span>
<span class="lineNum">    9013 </span><span class="lineCov">    5837405 :          the parenthesized type-id cannot be followed by '[', and, eg, we</span>
<span class="lineNum">    9014 </span><span class="lineCov">    5837405 :          want to parse '(C ())[2];' in parse/pr26997.C as unary-expression.</span>
<span class="lineNum">    9015 </span><span class="lineCov">    5837405 :          Thus, if cp_parser_tokens_start_cast_expression returns -1, below</span>
<span class="lineNum">    9016 </span>            :          we don't commit, we try a cast-expression, then an unary-expression.
<span class="lineNum">    9017 </span>            : 
<span class="lineNum">    9018 </span>            :          Save tokens so that we can put them back.  */
<span class="lineNum">    9019 </span>            :       cp_lexer_save_tokens (parser-&gt;lexer);
<span class="lineNum">    9020 </span>            : 
<span class="lineNum">    9021 </span>            :       /* We may be looking at a cast-expression.  */
<span class="lineNum">    9022 </span>            :       if (cp_parser_skip_to_closing_parenthesis (parser, false, false,
<span class="lineNum">    9023 </span>            :                                                  /*consume_paren=*/true))
<span class="lineNum">    9024 </span>            :         cast_expression
<span class="lineNum">    9025 </span>            :           = cp_parser_tokens_start_cast_expression (parser);
<span class="lineNum">    9026 </span>            : 
<span class="lineNum">    9027 </span>            :       /* Roll back the tokens we skipped.  */
<span class="lineNum">    9028 </span>            :       cp_lexer_rollback_tokens (parser-&gt;lexer);
<span class="lineNum">    9029 </span>            :       /* If we aren't looking at a cast-expression, simulate an error so
<span class="lineNum">    9030 </span>            :          that the call to cp_parser_error_occurred below returns true.  */
<span class="lineNum">    9031 </span>            :       if (!cast_expression)
<span class="lineNum">    9032 </span>            :         cp_parser_simulate_error (parser);
<span class="lineNum">    9033 </span>            :       else
<span class="lineNum">    9034 </span>            :         {
<span class="lineNum">    9035 </span>            :           bool saved_in_type_id_in_expr_p = parser-&gt;in_type_id_in_expr_p;
<span class="lineNum">    9036 </span>            :           parser-&gt;in_type_id_in_expr_p = true;
<span class="lineNum">    9037 </span>            :           /* Look for the type-id.  */
<span class="lineNum">    9038 </span>            :           type = cp_parser_type_id (parser);
<span class="lineNum">    9039 </span>            :           /* Look for the closing `)'.  */
<span class="lineNum">    9040 </span>            :           cp_token *close_paren = parens.require_close (parser);
<span class="lineNum">    9041 </span>            :           if (close_paren)
<span class="lineNum">    9042 </span>            :             close_paren_loc = close_paren-&gt;location;
<span class="lineNum">    9043 </span>            :           parser-&gt;in_type_id_in_expr_p = saved_in_type_id_in_expr_p;
<span class="lineNum">    9044 </span>            :         }
<span class="lineNum">    9045 </span>            : 
<span class="lineNum">    9046 </span>            :       /* Restore the saved message.  */
<span class="lineNum">    9047 </span>            :       parser-&gt;type_definition_forbidden_message = saved_message;
<span class="lineNum">    9048 </span>            : 
<span class="lineNum">    9049 </span>            :       /* At this point this can only be either a cast or a
<span class="lineNum">    9050 </span>            :          parenthesized ctor such as `(T ())' that looks like a cast to
<span class="lineNum">    9051 </span>            :          function returning T.  */
<span class="lineNum">    9052 </span>            :       if (!cp_parser_error_occurred (parser))
<span class="lineNum">    9053 </span>            :         {
<span class="lineNum">    9054 </span>            :           /* Only commit if the cast-expression doesn't start with
<span class="lineNum">    9055 </span>            :              '++', '--', or '[' in C++11.  */
<span class="lineNum">    9056 </span>            :           if (cast_expression &gt; 0)
<span class="lineNum">    9057 </span><span class="lineCov">    5837405 :             cp_parser_commit_to_topmost_tentative_parse (parser);</span>
<span class="lineNum">    9058 </span>            : 
<span class="lineNum">    9059 </span>            :           expr = cp_parser_cast_expression (parser,
<span class="lineNum">    9060 </span><span class="lineCov">    5837405 :                                             /*address_p=*/false,</span>
<span class="lineNum">    9061 </span>            :                                             /*cast_p=*/true,
<span class="lineNum">    9062 </span><span class="lineCov">    5837402 :                                             /*decltype_p=*/false,</span>
<span class="lineNum">    9063 </span><span class="lineCov">    5837402 :                                             pidk);</span>
<span class="lineNum">    9064 </span>            : 
<span class="lineNum">    9065 </span>            :           if (cp_parser_parse_definitely (parser))
<span class="lineNum">    9066 </span><span class="lineCov">    5837405 :             {</span>
<span class="lineNum">    9067 </span>            :               /* Warn about old-style casts, if so requested.  */
<span class="lineNum">    9068 </span>            :               if (warn_old_style_cast
<span class="lineNum">    9069 </span><span class="lineCov">    5837405 :                   &amp;&amp; !in_system_header_at (input_location)</span>
<span class="lineNum">    9070 </span><span class="lineCov">    2390565 :                   &amp;&amp; !VOID_TYPE_P (type)</span>
<span class="lineNum">    9071 </span>            :                   &amp;&amp; current_lang_name != lang_name_c)
<span class="lineNum">    9072 </span>            :                 {
<span class="lineNum">    9073 </span><span class="lineCov">    3446840 :                   gcc_rich_location rich_loc (input_location);</span>
<span class="lineNum">    9074 </span><span class="lineCov">    3446840 :                   maybe_add_cast_fixit (&amp;rich_loc, open_paren_loc, close_paren_loc,</span>
<span class="lineNum">    9075 </span>            :                                         expr, type);
<span class="lineNum">    9076 </span><span class="lineCov">    3446840 :                   warning_at (&amp;rich_loc, OPT_Wold_style_cast,</span>
<span class="lineNum">    9077 </span>            :                               &quot;use of old-style cast to %q#T&quot;, type);
<span class="lineNum">    9078 </span><span class="lineCov">    3446840 :                 }</span>
<span class="lineNum">    9079 </span><span class="lineCov">    3446840 : </span>
<span class="lineNum">    9080 </span><span class="lineCov">    2828585 :               /* Only type conversions to integral or enumeration types</span>
<span class="lineNum">    9081 </span><span class="lineCov">    3446840 :                  can be used in constant-expressions.  */</span>
<span class="lineNum">    9082 </span>            :               if (!cast_valid_in_integral_constant_expression_p (type)
<span class="lineNum">    9083 </span>            :                   &amp;&amp; cp_parser_non_integral_constant_expression (parser,
<span class="lineNum">    9084 </span>            :                                                                  NIC_CAST))
<span class="lineNum">    9085 </span><span class="lineCov">    5837405 :                 return error_mark_node;</span>
<span class="lineNum">    9086 </span>            : 
<span class="lineNum">    9087 </span>            :               /* Perform the cast.  */
<span class="lineNum">    9088 </span>            :               /* Make a location:
<span class="lineNum">    9089 </span>            :                    (TYPE) EXPR
<span class="lineNum">    9090 </span><span class="lineCov">   11674810 :                    ^~~~~~~~~~~</span>
<span class="lineNum">    9091 </span>            :                  with start==caret at the open paren, extending to the
<span class="lineNum">    9092 </span>            :                  end of &quot;expr&quot;.  */
<span class="lineNum">    9093 </span>            :               location_t cast_loc = make_location (open_paren_loc,
<span class="lineNum">    9094 </span><span class="lineCov">    2828585 :                                                    open_paren_loc,</span>
<span class="lineNum">    9095 </span><span class="lineCov">    2794110 :                                                    expr.get_finish ());</span>
<span class="lineNum">    9096 </span>            :               expr = build_c_cast (cast_loc, type, expr);
<span class="lineNum">    9097 </span><span class="lineCov">    5657170 :               return expr;</span>
<span class="lineNum">    9098 </span>            :             }
<span class="lineNum">    9099 </span>            :         }
<span class="lineNum">    9100 </span>            :       else 
<span class="lineNum">    9101 </span><span class="lineCov">    2828585 :         cp_parser_abort_tentative_parse (parser);</span>
<span class="lineNum">    9102 </span>            :     }
<span class="lineNum">    9103 </span><span class="lineCov">    2828585 : </span>
<span class="lineNum">    9104 </span>            :   /* If we get here, then it's not a cast, so it must be a
<span class="lineNum">    9105 </span>            :      unary-expression.  */
<span class="lineNum">    9106 </span><span class="lineCov">    2828577 :   return cp_parser_unary_expression (parser, pidk, address_p,</span>
<span class="lineNum">    9107 </span><span class="lineCov">         30 :                                      cast_p, decltype_p);</span>
<span class="lineNum">    9108 </span><span class="lineCov">         30 : }</span>
<span class="lineNum">    9109 </span><span class="lineCov">    2828604 : </span>
<span class="lineNum">    9110 </span>            : /* Parse a binary expression of the general form:
<span class="lineNum">    9111 </span><span class="lineCov">         54 : </span>
<span class="lineNum">    9112 </span><span class="lineCov">         54 :    pm-expression:</span>
<span class="lineNum">    9113 </span>            :      cast-expression
<span class="lineNum">    9114 </span><span class="lineCov">         27 :      pm-expression .* cast-expression</span>
<span class="lineNum">    9115 </span>            :      pm-expression -&gt;* cast-expression
<span class="lineNum">    9116 </span>            : 
<span class="lineNum">    9117 </span>            :    multiplicative-expression:
<span class="lineNum">    9118 </span>            :      pm-expression
<span class="lineNum">    9119 </span>            :      multiplicative-expression * pm-expression
<span class="lineNum">    9120 </span><span class="lineCov">    2828577 :      multiplicative-expression / pm-expression</span>
<span class="lineNum">    9121 </span><span class="lineCov">    2828577 :      multiplicative-expression % pm-expression</span>
<span class="lineNum">    9122 </span>            : 
<span class="lineNum">    9123 </span><span class="lineCov">         12 :    additive-expression:</span>
<span class="lineNum">    9124 </span>            :      multiplicative-expression
<span class="lineNum">    9125 </span>            :      additive-expression + multiplicative-expression
<span class="lineNum">    9126 </span>            :      additive-expression - multiplicative-expression
<span class="lineNum">    9127 </span>            : 
<span class="lineNum">    9128 </span>            :    shift-expression:
<span class="lineNum">    9129 </span>            :      additive-expression
<span class="lineNum">    9130 </span>            :      shift-expression &lt;&lt; additive-expression
<span class="lineNum">    9131 </span><span class="lineCov">    2828565 :      shift-expression &gt;&gt; additive-expression</span>
<span class="lineNum">    9132 </span>            : 
<span class="lineNum">    9133 </span>            :    relational-expression:
<span class="lineNum">    9134 </span><span class="lineCov">    2828565 :      shift-expression</span>
<span class="lineNum">    9135 </span><span class="lineCov">    2828565 :      relational-expression &lt; shift-expression</span>
<span class="lineNum">    9136 </span>            :      relational-expression &gt; shift-expression
<span class="lineNum">    9137 </span>            :      relational-expression &lt;= shift-expression
<span class="lineNum">    9138 </span>            :      relational-expression &gt;= shift-expression
<span class="lineNum">    9139 </span><span class="lineCov">    3008820 : </span>
<span class="lineNum">    9140 </span>            :   GNU Extension:
<span class="lineNum">    9141 </span>            : 
<span class="lineNum">    9142 </span>            :    relational-expression:
<span class="lineNum">    9143 </span>            :      relational-expression &lt;? shift-expression
<span class="lineNum">    9144 </span><span class="lineCov">   49311968 :      relational-expression &gt;? shift-expression</span>
<span class="lineNum">    9145 </span><span class="lineCov">   49311968 : </span>
<span class="lineNum">    9146 </span>            :    equality-expression:
<span class="lineNum">    9147 </span>            :      relational-expression
<span class="lineNum">    9148 </span>            :      equality-expression == relational-expression
<span class="lineNum">    9149 </span>            :      equality-expression != relational-expression
<span class="lineNum">    9150 </span>            : 
<span class="lineNum">    9151 </span>            :    and-expression:
<span class="lineNum">    9152 </span>            :      equality-expression
<span class="lineNum">    9153 </span>            :      and-expression &amp; equality-expression
<span class="lineNum">    9154 </span>            : 
<span class="lineNum">    9155 </span>            :    exclusive-or-expression:
<span class="lineNum">    9156 </span>            :      and-expression
<span class="lineNum">    9157 </span>            :      exclusive-or-expression ^ and-expression
<span class="lineNum">    9158 </span>            : 
<span class="lineNum">    9159 </span>            :    inclusive-or-expression:
<span class="lineNum">    9160 </span>            :      exclusive-or-expression
<span class="lineNum">    9161 </span>            :      inclusive-or-expression | exclusive-or-expression
<span class="lineNum">    9162 </span>            : 
<span class="lineNum">    9163 </span>            :    logical-and-expression:
<span class="lineNum">    9164 </span>            :      inclusive-or-expression
<span class="lineNum">    9165 </span>            :      logical-and-expression &amp;&amp; inclusive-or-expression
<span class="lineNum">    9166 </span>            : 
<span class="lineNum">    9167 </span>            :    logical-or-expression:
<span class="lineNum">    9168 </span>            :      logical-and-expression
<span class="lineNum">    9169 </span>            :      logical-or-expression || logical-and-expression
<span class="lineNum">    9170 </span>            : 
<span class="lineNum">    9171 </span>            :    All these are implemented with a single function like:
<span class="lineNum">    9172 </span>            : 
<span class="lineNum">    9173 </span>            :    binary-expression:
<span class="lineNum">    9174 </span>            :      simple-cast-expression
<span class="lineNum">    9175 </span>            :      binary-expression &lt;token&gt; binary-expression
<span class="lineNum">    9176 </span>            : 
<span class="lineNum">    9177 </span>            :    CAST_P is true if this expression is the target of a cast.
<span class="lineNum">    9178 </span>            : 
<span class="lineNum">    9179 </span>            :    The binops_by_token map is used to get the tree codes for each &lt;token&gt; type.
<span class="lineNum">    9180 </span>            :    binary-expressions are associated according to a precedence table.  */
<span class="lineNum">    9181 </span>            : 
<span class="lineNum">    9182 </span>            : #define TOKEN_PRECEDENCE(token)                              \
<span class="lineNum">    9183 </span>            : (((token-&gt;type == CPP_GREATER                                     \
<span class="lineNum">    9184 </span>            :    || ((cxx_dialect != cxx98) &amp;&amp; token-&gt;type == CPP_RSHIFT)) \
<span class="lineNum">    9185 </span>            :   &amp;&amp; !parser-&gt;greater_than_is_operator_p)                 \
<span class="lineNum">    9186 </span>            :  ? PREC_NOT_OPERATOR                                         \
<span class="lineNum">    9187 </span>            :  : binops_by_token[token-&gt;type].prec)
<a name="9188"><span class="lineNum">    9188 </span>            : </a>
<span class="lineNum">    9189 </span>            : static cp_expr
<span class="lineNum">    9190 </span>            : cp_parser_binary_expression (cp_parser* parser, bool cast_p,
<span class="lineNum">    9191 </span>            :                              bool no_toplevel_fold_p,
<span class="lineNum">    9192 </span>            :                              bool decltype_p,
<span class="lineNum">    9193 </span>            :                              enum cp_parser_prec prec,
<span class="lineNum">    9194 </span>            :                              cp_id_kind * pidk)
<span class="lineNum">    9195 </span>            : {
<span class="lineNum">    9196 </span>            :   cp_parser_expression_stack stack;
<span class="lineNum">    9197 </span>            :   cp_parser_expression_stack_entry *sp = &amp;stack[0];
<span class="lineNum">    9198 </span>            :   cp_parser_expression_stack_entry current;
<span class="lineNum">    9199 </span>            :   cp_expr rhs;
<span class="lineNum">    9200 </span>            :   cp_token *token;
<span class="lineNum">    9201 </span>            :   enum tree_code rhs_type;
<span class="lineNum">    9202 </span>            :   enum cp_parser_prec new_prec, lookahead_prec;
<span class="lineNum">    9203 </span>            :   tree overload;
<span class="lineNum">    9204 </span>            : 
<span class="lineNum">    9205 </span>            :   /* Parse the first expression.  */
<span class="lineNum">    9206 </span>            :   current.lhs_type = (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NOT)
<span class="lineNum">    9207 </span>            :                       ? TRUTH_NOT_EXPR : ERROR_MARK);
<span class="lineNum">    9208 </span>            :   current.lhs = cp_parser_cast_expression (parser, /*address_p=*/false,
<span class="lineNum">    9209 </span>            :                                            cast_p, decltype_p, pidk);
<span class="lineNum">    9210 </span>            :   current.prec = prec;
<span class="lineNum">    9211 </span>            : 
<span class="lineNum">    9212 </span>            :   if (cp_parser_error_occurred (parser))
<span class="lineNum">    9213 </span>            :     return error_mark_node;
<span class="lineNum">    9214 </span>            : 
<span class="lineNum">    9215 </span>            :   for (;;)
<span class="lineNum">    9216 </span>            :     {
<span class="lineNum">    9217 </span>            :       /* Get an operator token.  */
<span class="lineNum">    9218 </span>            :       token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">    9219 </span>            : 
<span class="lineNum">    9220 </span>            :       if (warn_cxx11_compat
<span class="lineNum">    9221 </span>            :           &amp;&amp; token-&gt;type == CPP_RSHIFT
<span class="lineNum">    9222 </span>            :           &amp;&amp; !parser-&gt;greater_than_is_operator_p)
<span class="lineNum">    9223 </span>            :         {
<span class="lineNum">    9224 </span>            :           if (warning_at (token-&gt;location, OPT_Wc__11_compat,
<span class="lineNum">    9225 </span>            :                           &quot;%&lt;&gt;&gt;%&gt; operator is treated&quot;
<span class="lineNum">    9226 </span>            :                           &quot; as two right angle brackets in C++11&quot;))
<span class="lineNum">    9227 </span>            :             inform (token-&gt;location,
<span class="lineNum">    9228 </span><span class="lineCov">   39515387 :                     &quot;suggest parentheses around %&lt;&gt;&gt;%&gt; expression&quot;);</span>
<span class="lineNum">    9229 </span>            :         }
<span class="lineNum">    9230 </span>            : 
<span class="lineNum">    9231 </span>            :       new_prec = TOKEN_PRECEDENCE (token);
<span class="lineNum">    9232 </span>            :       if (new_prec != PREC_NOT_OPERATOR
<span class="lineNum">    9233 </span>            :           &amp;&amp; cp_lexer_nth_token_is (parser-&gt;lexer, 2, CPP_ELLIPSIS))
<span class="lineNum">    9234 </span><span class="lineCov">  474184644 :         /* This is a fold-expression; handle it later.  */</span>
<span class="lineNum">    9235 </span><span class="lineCov">   39515387 :         new_prec = PREC_NOT_OPERATOR;</span>
<span class="lineNum">    9236 </span><span class="lineCov">   39515387 : </span>
<span class="lineNum">    9237 </span><span class="lineCov">   39515387 :       /* Popping an entry off the stack means we completed a subexpression:</span>
<span class="lineNum">    9238 </span><span class="lineCov">   39515387 :          - either we found a token which is not an operator (`&gt;' where it is not</span>
<span class="lineNum">    9239 </span><span class="lineCov">   39515387 :            an operator, or prec == PREC_NOT_OPERATOR), in which case popping</span>
<span class="lineNum">    9240 </span><span class="lineCov">   39515387 :            will happen repeatedly;</span>
<span class="lineNum">    9241 </span><span class="lineCov">   39515387 :          - or, we found an operator which has lower priority.  This is the case</span>
<span class="lineNum">    9242 </span>            :            where the recursive descent *ascends*, as in `3 * 4 + 5' after
<span class="lineNum">    9243 </span>            :            parsing `3 * 4'.  */
<span class="lineNum">    9244 </span><span class="lineCov">  118546161 :       if (new_prec &lt;= current.prec)</span>
<span class="lineNum">    9245 </span><span class="lineCov">   39515387 :         {</span>
<span class="lineNum">    9246 </span><span class="lineCov">   79030761 :           if (sp == stack)</span>
<span class="lineNum">    9247 </span><span class="lineCov">   39515387 :             break;</span>
<span class="lineNum">    9248 </span><span class="lineCov">   39515374 :           else</span>
<span class="lineNum">    9249 </span>            :             goto pop;
<span class="lineNum">    9250 </span><span class="lineCov">   39515588 :         }</span>
<span class="lineNum">    9251 </span><span class="lineCov">        214 : </span>
<span class="lineNum">    9252 </span>            :      get_rhs:
<span class="lineNum">    9253 </span><span class="lineCov">   46119540 :       current.tree_type = binops_by_token[token-&gt;type].tree_type;</span>
<span class="lineNum">    9254 </span>            :       current.loc = token-&gt;location;
<span class="lineNum">    9255 </span>            : 
<span class="lineNum">    9256 </span><span class="lineCov">   92239080 :       /* We used the operator token.  */</span>
<span class="lineNum">    9257 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">    9258 </span><span class="lineCov">   46119540 : </span>
<span class="lineNum">    9259 </span><span class="lineCov">     756455 :       /* For &quot;false &amp;&amp; x&quot; or &quot;true || x&quot;, x will never be executed;</span>
<span class="lineNum">    9260 </span><span class="lineCov">       2779 :          disable warnings while evaluating it.  */</span>
<span class="lineNum">    9261 </span>            :       if (current.tree_type == TRUTH_ANDIF_EXPR)
<span class="lineNum">    9262 </span><span class="lineCov">          2 :         c_inhibit_evaluation_warnings +=</span>
<span class="lineNum">    9263 </span>            :           cp_fully_fold (current.lhs) == truthvalue_false_node;
<span class="lineNum">    9264 </span>            :       else if (current.tree_type == TRUTH_ORIF_EXPR)
<span class="lineNum">    9265 </span><span class="lineCov">          2 :         c_inhibit_evaluation_warnings +=</span>
<span class="lineNum">    9266 </span>            :           cp_fully_fold (current.lhs) == truthvalue_true_node;
<span class="lineNum">    9267 </span>            : 
<span class="lineNum">    9268 </span>            :       /* Extract another operand.  It may be the RHS of this expression
<span class="lineNum">    9269 </span><span class="lineCov">   46119540 :          or the LHS of a new, higher priority expression.  */</span>
<span class="lineNum">    9270 </span><span class="lineCov">   45281920 :       rhs_type = (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NOT)</span>
<span class="lineNum">    9271 </span><span class="lineCov">   45281920 :                   ? TRUTH_NOT_EXPR : ERROR_MARK);</span>
<span class="lineNum">    9272 </span>            :       rhs = cp_parser_simple_cast_expression (parser);
<span class="lineNum">    9273 </span>            : 
<span class="lineNum">    9274 </span>            :       /* Get another operator token.  Look up its precedence to avoid
<span class="lineNum">    9275 </span>            :          building a useless (immediately popped) stack entry for common
<span class="lineNum">    9276 </span>            :          cases such as 3 + 4 + 5 or 3 * 4 + 5.  */
<span class="lineNum">    9277 </span>            :       token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">    9278 </span>            :       lookahead_prec = TOKEN_PRECEDENCE (token);
<span class="lineNum">    9279 </span>            :       if (lookahead_prec != PREC_NOT_OPERATOR
<span class="lineNum">    9280 </span>            :           &amp;&amp; cp_lexer_nth_token_is (parser-&gt;lexer, 2, CPP_ELLIPSIS))
<span class="lineNum">    9281 </span>            :         lookahead_prec = PREC_NOT_OPERATOR;
<span class="lineNum">    9282 </span><span class="lineCov">   46119540 :       if (lookahead_prec &gt; new_prec)</span>
<span class="lineNum">    9283 </span>            :         {
<span class="lineNum">    9284 </span><span class="lineCov">   39924370 :           /* ... and prepare to parse the RHS of the new, higher priority</span>
<span class="lineNum">    9285 </span>            :              expression.  Since precedence levels on the stack are
<span class="lineNum">    9286 </span>            :              monotonically increasing, we do not have to care about
<span class="lineNum">    9287 </span><span class="lineCov">     409212 :              stack overflows.  */</span>
<span class="lineNum">    9288 </span>            :           *sp = current;
<span class="lineNum">    9289 </span>            :           ++sp;
<span class="lineNum">    9290 </span><span class="lineCov">    6195170 :           current.lhs = rhs;</span>
<span class="lineNum">    9291 </span><span class="lineCov">    6604382 :           current.lhs_type = rhs_type;</span>
<span class="lineNum">    9292 </span><span class="lineCov">    6604382 :           current.prec = new_prec;</span>
<span class="lineNum">    9293 </span>            :           new_prec = lookahead_prec;
<span class="lineNum">    9294 </span>            :           goto get_rhs;
<span class="lineNum">    9295 </span><span class="lineCov">    6604382 : </span>
<span class="lineNum">    9296 </span>            :          pop:
<span class="lineNum">    9297 </span>            :           lookahead_prec = new_prec;
<span class="lineNum">    9298 </span>            :           /* If the stack is not empty, we have parsed into LHS the right side
<span class="lineNum">    9299 </span><span class="lineCov">    6604382 :              (`4' in the example above) of an expression we had suspended.</span>
<span class="lineNum">    9300 </span><span class="lineCov">     864016 :              We can use the information on the stack to recover the LHS (`3')</span>
<span class="lineNum">    9301 </span><span class="lineCov">     864016 :              from the stack together with the tree code (`MULT_EXPR'), and</span>
<span class="lineNum">    9302 </span><span class="lineCov">    6172374 :              the precedence of the higher level subexpression</span>
<span class="lineNum">    9303 </span><span class="lineCov">     379038 :              (`PREC_ADDITIVE_EXPRESSION').  TOKEN is the CPP_PLUS token,</span>
<span class="lineNum">    9304 </span><span class="lineCov">     379038 :              which will be used to actually build the additive expression.  */</span>
<span class="lineNum">    9305 </span>            :           rhs = current.lhs;
<span class="lineNum">    9306 </span>            :           rhs_type = current.lhs_type;
<span class="lineNum">    9307 </span>            :           --sp;
<span class="lineNum">    9308 </span><span class="lineCov">   19813146 :           current = *sp;</span>
<span class="lineNum">    9309 </span><span class="lineCov">    6604382 :         }</span>
<span class="lineNum">    9310 </span><span class="lineCov">   13208764 : </span>
<span class="lineNum">    9311 </span>            :       /* Undo the disabling of warnings done above.  */
<span class="lineNum">    9312 </span>            :       if (current.tree_type == TRUTH_ANDIF_EXPR)
<span class="lineNum">    9313 </span>            :         c_inhibit_evaluation_warnings -=
<span class="lineNum">    9314 </span>            :           cp_fully_fold (current.lhs) == truthvalue_false_node;
<span class="lineNum">    9315 </span><span class="lineCov">   13208764 :       else if (current.tree_type == TRUTH_ORIF_EXPR)</span>
<span class="lineNum">    9316 </span><span class="lineCov">    6604382 :         c_inhibit_evaluation_warnings -=</span>
<span class="lineNum">    9317 </span><span class="lineCov">    6567393 :           cp_fully_fold (current.lhs) == truthvalue_true_node;</span>
<span class="lineNum">    9318 </span><span class="lineCov">    6567393 : </span>
<span class="lineNum">    9319 </span>            :       if (warn_logical_not_paren
<span class="lineNum">    9320 </span><span class="lineCov">    6604382 :           &amp;&amp; TREE_CODE_CLASS (current.tree_type) == tcc_comparison</span>
<span class="lineNum">    9321 </span>            :           &amp;&amp; current.lhs_type == TRUTH_NOT_EXPR
<span class="lineNum">    9322 </span>            :           /* Avoid warning for !!x == y.  */
<span class="lineNum">    9323 </span>            :           &amp;&amp; (TREE_CODE (current.lhs) != NE_EXPR
<span class="lineNum">    9324 </span>            :               || !integer_zerop (TREE_OPERAND (current.lhs, 1)))
<span class="lineNum">    9325 </span>            :           &amp;&amp; (TREE_CODE (current.lhs) != TRUTH_NOT_EXPR
<span class="lineNum">    9326 </span><span class="lineCov">     409212 :               || (TREE_CODE (TREE_OPERAND (current.lhs, 0)) != TRUTH_NOT_EXPR</span>
<span class="lineNum">    9327 </span><span class="lineCov">     409212 :                   /* Avoid warning for !b == y where b is boolean.  */</span>
<span class="lineNum">    9328 </span><span class="lineCov">     409212 :                   &amp;&amp; (TREE_TYPE (TREE_OPERAND (current.lhs, 0)) == NULL_TREE</span>
<span class="lineNum">    9329 </span><span class="lineCov">     409212 :                       || (TREE_CODE (TREE_TYPE (TREE_OPERAND (current.lhs, 0)))</span>
<span class="lineNum">    9330 </span><span class="lineCov">     409212 :                           != BOOLEAN_TYPE))))</span>
<span class="lineNum">    9331 </span><span class="lineCov">     409212 :           /* Avoid warning for !!b == y where b is boolean.  */</span>
<span class="lineNum">    9332 </span><span class="lineCov">     409212 :           &amp;&amp; (!DECL_P (current.lhs)</span>
<span class="lineNum">    9333 </span>            :               || TREE_TYPE (current.lhs) == NULL_TREE
<span class="lineNum">    9334 </span><span class="lineCov">     409212 :               || TREE_CODE (TREE_TYPE (current.lhs)) != BOOLEAN_TYPE))</span>
<span class="lineNum">    9335 </span><span class="lineCov">     409212 :         warn_logical_not_parentheses (current.loc, current.tree_type,</span>
<span class="lineNum">    9336 </span>            :                                       current.lhs, maybe_constant_value (rhs));
<span class="lineNum">    9337 </span>            : 
<span class="lineNum">    9338 </span>            :       overload = NULL;
<span class="lineNum">    9339 </span>            : 
<span class="lineNum">    9340 </span>            :       location_t combined_loc = make_location (current.loc,
<span class="lineNum">    9341 </span>            :                                                current.lhs.get_start (),
<span class="lineNum">    9342 </span>            :                                                rhs.get_finish ());
<span class="lineNum">    9343 </span><span class="lineCov">     409212 : </span>
<span class="lineNum">    9344 </span><span class="lineCov">     409212 :       /* ??? Currently we pass lhs_type == ERROR_MARK and rhs_type ==</span>
<span class="lineNum">    9345 </span><span class="lineCov">     409212 :          ERROR_MARK for everything that is not a binary expression.</span>
<span class="lineNum">    9346 </span><span class="lineCov">     409212 :          This makes warn_about_parentheses miss some warnings that</span>
<span class="lineNum">    9347 </span>            :          involve unary operators.  For unary expressions we should
<span class="lineNum">    9348 </span>            :          pass the correct tree_code unless the unary expression was
<span class="lineNum">    9349 </span>            :          surrounded by parentheses.
<span class="lineNum">    9350 </span><span class="lineCov">    6604382 :       */</span>
<span class="lineNum">    9351 </span><span class="lineCov">     864016 :       if (no_toplevel_fold_p</span>
<span class="lineNum">    9352 </span><span class="lineCov">     864016 :           &amp;&amp; lookahead_prec &lt;= current.prec</span>
<span class="lineNum">    9353 </span><span class="lineCov">    6172374 :           &amp;&amp; sp == stack)</span>
<span class="lineNum">    9354 </span><span class="lineCov">     379038 :         {</span>
<span class="lineNum">    9355 </span><span class="lineCov">     379038 :           if (current.lhs == error_mark_node || rhs == error_mark_node)</span>
<span class="lineNum">    9356 </span>            :             current.lhs = error_mark_node;
<span class="lineNum">    9357 </span><span class="lineCov">    6604382 :           else</span>
<span class="lineNum">    9358 </span><span class="lineCov">     806551 :             {</span>
<span class="lineNum">    9359 </span><span class="lineCov">     317921 :               current.lhs</span>
<span class="lineNum">    9360 </span>            :                 = build_min (current.tree_type,
<span class="lineNum">    9361 </span><span class="lineCov">        810 :                              TREE_CODE_CLASS (current.tree_type)</span>
<span class="lineNum">    9362 </span><span class="lineCov">         90 :                              == tcc_comparison</span>
<span class="lineNum">    9363 </span><span class="lineCov">        720 :                              ? boolean_type_node : TREE_TYPE (current.lhs),</span>
<span class="lineNum">    9364 </span><span class="lineCov">        144 :                              current.lhs.get_value (), rhs.get_value ());</span>
<span class="lineNum">    9365 </span>            :               SET_EXPR_LOCATION (current.lhs, combined_loc);
<span class="lineNum">    9366 </span><span class="lineCov">        132 :             }</span>
<span class="lineNum">    9367 </span><span class="lineCov">        126 :         }</span>
<span class="lineNum">    9368 </span>            :       else
<span class="lineNum">    9369 </span>            :         {
<span class="lineNum">    9370 </span><span class="lineCov">    6604976 :           current.lhs = build_x_binary_op (combined_loc, current.tree_type,</span>
<span class="lineNum">    9371 </span><span class="lineCov">         36 :                                            current.lhs, current.lhs_type,</span>
<span class="lineNum">    9372 </span><span class="lineCov">         54 :                                            rhs, rhs_type, &amp;overload,</span>
<span class="lineNum">    9373 </span><span class="lineCov">        558 :                                            complain_flags (decltype_p));</span>
<span class="lineNum">    9374 </span>            :           /* TODO: build_x_binary_op doesn't always honor the location.  */
<span class="lineNum">    9375 </span>            :           current.lhs.set_location (combined_loc);
<span class="lineNum">    9376 </span><span class="lineCov">    6604382 :         }</span>
<span class="lineNum">    9377 </span>            :       current.lhs_type = current.tree_type;
<span class="lineNum">    9378 </span><span class="lineCov">    6604382 : </span>
<span class="lineNum">    9379 </span>            :       /* If the binary operator required the use of an overloaded operator,
<span class="lineNum">    9380 </span><span class="lineCov">    6604382 :          then this expression cannot be an integral constant-expression.</span>
<span class="lineNum">    9381 </span>            :          An overloaded operator can be used even if both operands are
<span class="lineNum">    9382 </span>            :          otherwise permissible in an integral constant-expression if at
<span class="lineNum">    9383 </span>            :          least one of the operands is of enumeration type.  */
<span class="lineNum">    9384 </span>            : 
<span class="lineNum">    9385 </span>            :       if (overload
<span class="lineNum">    9386 </span>            :           &amp;&amp; cp_parser_non_integral_constant_expression (parser,
<span class="lineNum">    9387 </span>            :                                                          NIC_OVERLOADED))
<span class="lineNum">    9388 </span>            :         return error_mark_node;
<span class="lineNum">    9389 </span><span class="lineCov">    6604382 :     }</span>
<span class="lineNum">    9390 </span><span class="lineCov">      10900 : </span>
<span class="lineNum">    9391 </span><span class="lineCov">      10766 :   return current.lhs;</span>
<span class="lineNum">    9392 </span>            : }
<a name="9393"><span class="lineNum">    9393 </span><span class="lineCov">      19982 : </span></a>
<span class="lineNum">    9394 </span><span class="lineCov">          6 : static cp_expr</span>
<span class="lineNum">    9395 </span>            : cp_parser_binary_expression (cp_parser* parser, bool cast_p,
<span class="lineNum">    9396 </span>            :                              bool no_toplevel_fold_p,
<span class="lineNum">    9397 </span><span class="lineCov">       9985 :                              enum cp_parser_prec prec,</span>
<span class="lineNum">    9398 </span><span class="lineCov">      20096 :                              cp_id_kind * pidk)</span>
<span class="lineNum">    9399 </span><span class="lineCov">       9985 : {</span>
<span class="lineNum">    9400 </span>            :   return cp_parser_binary_expression (parser, cast_p, no_toplevel_fold_p,
<span class="lineNum">    9401 </span><span class="lineCov">        252 :                                       /*decltype*/false, prec, pidk);</span>
<span class="lineNum">    9402 </span>            : }
<span class="lineNum">    9403 </span><span class="lineCov">      19970 : </span>
<span class="lineNum">    9404 </span>            : /* Parse the `? expression : assignment-expression' part of a
<span class="lineNum">    9405 </span>            :    conditional-expression.  The LOGICAL_OR_EXPR is the
<span class="lineNum">    9406 </span>            :    logical-or-expression that started the conditional-expression.
<span class="lineNum">    9407 </span>            :    Returns a representation of the entire conditional-expression.
<span class="lineNum">    9408 </span><span class="lineCov">    6740530 : </span>
<span class="lineNum">    9409 </span>            :    This routine is used by cp_parser_assignment_expression.
<span class="lineNum">    9410 </span>            : 
<span class="lineNum">    9411 </span>            :      ? expression : assignment-expression
<span class="lineNum">    9412 </span>            : 
<span class="lineNum">    9413 </span><span class="lineCov">    6594389 :    GNU Extensions:</span>
<span class="lineNum">    9414 </span>            : 
<span class="lineNum">    9415 </span><span class="lineCov">    6604380 :      ? : assignment-expression */</span>
<a name="9416"><span class="lineNum">    9416 </span>            : </a>
<span class="lineNum">    9417 </span>            : static tree
<span class="lineNum">    9418 </span>            : cp_parser_question_colon_clause (cp_parser* parser, cp_expr logical_or_expr)
<span class="lineNum">    9419 </span>            : {
<span class="lineNum">    9420 </span>            :   tree expr, folded_logical_or_expr = cp_fully_fold (logical_or_expr);
<span class="lineNum">    9421 </span>            :   cp_expr assignment_expr;
<span class="lineNum">    9422 </span>            :   struct cp_token *token;
<span class="lineNum">    9423 </span><span class="lineCov">    6604380 :   location_t loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;</span>
<span class="lineNum">    9424 </span><span class="lineCov">     135835 : </span>
<span class="lineNum">    9425 </span><span class="lineCov">    6604380 :   /* Consume the `?' token.  */</span>
<span class="lineNum">    9426 </span><span class="lineNoCov">          0 :   cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    9427 </span>            :   token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">    9428 </span>            :   if (cp_parser_allow_gnu_extensions_p (parser)
<span class="lineNum">    9429 </span><span class="lineCov">   39515158 :       &amp;&amp; token-&gt;type == CPP_COLON)</span>
<span class="lineNum">    9430 </span>            :     {
<span class="lineNum">    9431 </span>            :       pedwarn (token-&gt;location, OPT_Wpedantic, 
<span class="lineNum">    9432 </span>            :                &quot;ISO C++ does not allow ?: with omitted middle operand&quot;);
<span class="lineNum">    9433 </span><span class="lineNoCov">          0 :       /* Implicit true clause.  */</span>
<span class="lineNum">    9434 </span>            :       expr = NULL_TREE;
<span class="lineNum">    9435 </span>            :       c_inhibit_evaluation_warnings +=
<span class="lineNum">    9436 </span>            :         folded_logical_or_expr == truthvalue_true_node;
<span class="lineNum">    9437 </span>            :       warn_for_omitted_condop (token-&gt;location, logical_or_expr);
<span class="lineNum">    9438 </span><span class="lineCov">      10744 :     }</span>
<span class="lineNum">    9439 </span><span class="lineNoCov">          0 :   else</span>
<span class="lineNum">    9440 </span>            :     {
<span class="lineNum">    9441 </span>            :       bool saved_colon_corrects_to_scope_p = parser-&gt;colon_corrects_to_scope_p;
<span class="lineNum">    9442 </span>            :       parser-&gt;colon_corrects_to_scope_p = false;
<span class="lineNum">    9443 </span>            :       /* Parse the expression.  */
<span class="lineNum">    9444 </span>            :       c_inhibit_evaluation_warnings +=
<span class="lineNum">    9445 </span>            :         folded_logical_or_expr == truthvalue_false_node;
<span class="lineNum">    9446 </span>            :       expr = cp_parser_expression (parser);
<span class="lineNum">    9447 </span>            :       c_inhibit_evaluation_warnings +=
<span class="lineNum">    9448 </span>            :         ((folded_logical_or_expr == truthvalue_true_node)
<span class="lineNum">    9449 </span>            :          - (folded_logical_or_expr == truthvalue_false_node));
<span class="lineNum">    9450 </span>            :       parser-&gt;colon_corrects_to_scope_p = saved_colon_corrects_to_scope_p;
<span class="lineNum">    9451 </span>            :     }
<span class="lineNum">    9452 </span>            : 
<span class="lineNum">    9453 </span>            :   /* The next token should be a `:'.  */
<span class="lineNum">    9454 </span>            :   cp_parser_require (parser, CPP_COLON, RT_COLON);
<span class="lineNum">    9455 </span>            :   /* Parse the assignment-expression.  */
<span class="lineNum">    9456 </span><span class="lineCov">     273868 :   assignment_expr = cp_parser_assignment_expression (parser);</span>
<span class="lineNum">    9457 </span>            :   c_inhibit_evaluation_warnings -=
<span class="lineNum">    9458 </span><span class="lineCov">     547736 :     folded_logical_or_expr == truthvalue_true_node;</span>
<span class="lineNum">    9459 </span><span class="lineCov">     273868 : </span>
<span class="lineNum">    9460 </span><span class="lineCov">     273868 :   /* Make a location:</span>
<span class="lineNum">    9461 </span><span class="lineCov">     547736 :        LOGICAL_OR_EXPR ? EXPR : ASSIGNMENT_EXPR</span>
<span class="lineNum">    9462 </span>            :        ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~
<span class="lineNum">    9463 </span>            :      with the caret at the &quot;?&quot;, ranging from the start of
<span class="lineNum">    9464 </span><span class="lineCov">     273868 :      the logical_or_expr to the end of the assignment_expr.  */</span>
<span class="lineNum">    9465 </span><span class="lineCov">     547736 :   loc = make_location (loc,</span>
<span class="lineNum">    9466 </span><span class="lineCov">     547736 :                        logical_or_expr.get_start (),</span>
<span class="lineNum">    9467 </span><span class="lineCov">     273868 :                        assignment_expr.get_finish ());</span>
<span class="lineNum">    9468 </span>            : 
<span class="lineNum">    9469 </span><span class="lineCov">        220 :   /* Build the conditional-expression.  */</span>
<span class="lineNum">    9470 </span>            :   return build_x_conditional_expr (loc, logical_or_expr,
<span class="lineNum">    9471 </span>            :                                    expr,
<span class="lineNum">    9472 </span><span class="lineCov">        220 :                                    assignment_expr,</span>
<span class="lineNum">    9473 </span><span class="lineCov">        440 :                                    tf_warning_or_error);</span>
<span class="lineNum">    9474 </span><span class="lineCov">        220 : }</span>
<span class="lineNum">    9475 </span><span class="lineCov">        440 : </span>
<span class="lineNum">    9476 </span>            : /* Parse an assignment-expression.
<span class="lineNum">    9477 </span>            : 
<span class="lineNum">    9478 </span>            :    assignment-expression:
<span class="lineNum">    9479 </span><span class="lineCov">     273648 :      conditional-expression</span>
<span class="lineNum">    9480 </span><span class="lineCov">     273648 :      logical-or-expression assignment-operator assignment_expression</span>
<span class="lineNum">    9481 </span>            :      throw-expression
<span class="lineNum">    9482 </span><span class="lineCov">     547296 : </span>
<span class="lineNum">    9483 </span><span class="lineCov">     273648 :    CAST_P is true if this expression is the target of a cast.</span>
<span class="lineNum">    9484 </span><span class="lineCov">     273648 :    DECLTYPE_P is true if this expression is the operand of decltype.</span>
<span class="lineNum">    9485 </span><span class="lineCov">     547296 : </span>
<span class="lineNum">    9486 </span><span class="lineCov">     273648 :    Returns a representation for the expression.  */</span>
<a name="9487"><span class="lineNum">    9487 </span><span class="lineCov">     273648 : </span></a>
<span class="lineNum">    9488 </span><span class="lineCov">     273648 : static cp_expr</span>
<span class="lineNum">    9489 </span>            : cp_parser_assignment_expression (cp_parser* parser, cp_id_kind * pidk,
<span class="lineNum">    9490 </span>            :                                  bool cast_p, bool decltype_p)
<span class="lineNum">    9491 </span>            : {
<span class="lineNum">    9492 </span><span class="lineCov">     273868 :   cp_expr expr;</span>
<span class="lineNum">    9493 </span>            : 
<span class="lineNum">    9494 </span><span class="lineCov">     273868 :   /* If the next token is the `throw' keyword, then we're looking at</span>
<span class="lineNum">    9495 </span><span class="lineCov">     547736 :      a throw-expression.  */</span>
<span class="lineNum">    9496 </span><span class="lineCov">     273868 :   if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_THROW))</span>
<span class="lineNum">    9497 </span>            :     expr = cp_parser_throw_expression (parser);
<span class="lineNum">    9498 </span>            :   /* Otherwise, it must be that we are looking at a
<span class="lineNum">    9499 </span>            :      logical-or-expression.  */
<span class="lineNum">    9500 </span>            :   else
<span class="lineNum">    9501 </span>            :     {
<span class="lineNum">    9502 </span>            :       /* Parse the binary expressions (logical-or-expression).  */
<span class="lineNum">    9503 </span><span class="lineCov">     273868 :       expr = cp_parser_binary_expression (parser, cast_p, false,</span>
<span class="lineNum">    9504 </span>            :                                           decltype_p,
<span class="lineNum">    9505 </span>            :                                           PREC_NOT_OPERATOR, pidk);
<span class="lineNum">    9506 </span>            :       /* If the next token is a `?' then we're actually looking at a
<span class="lineNum">    9507 </span>            :          conditional-expression.  */
<span class="lineNum">    9508 </span><span class="lineCov">     821604 :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_QUERY))</span>
<span class="lineNum">    9509 </span>            :         return cp_parser_question_colon_clause (parser, expr);
<span class="lineNum">    9510 </span>            :       else
<span class="lineNum">    9511 </span><span class="lineCov">     273868 :         {</span>
<span class="lineNum">    9512 </span>            :           location_t loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">    9513 </span>            : 
<span class="lineNum">    9514 </span>            :           /* If it's an assignment-operator, we're using the second
<span class="lineNum">    9515 </span>            :              production.  */
<span class="lineNum">    9516 </span>            :           enum tree_code assignment_operator
<span class="lineNum">    9517 </span>            :             = cp_parser_assignment_operator_opt (parser);
<span class="lineNum">    9518 </span>            :           if (assignment_operator != ERROR_MARK)
<span class="lineNum">    9519 </span>            :             {
<span class="lineNum">    9520 </span>            :               bool non_constant_p;
<span class="lineNum">    9521 </span>            : 
<span class="lineNum">    9522 </span>            :               /* Parse the right-hand side of the assignment.  */
<span class="lineNum">    9523 </span>            :               cp_expr rhs = cp_parser_initializer_clause (parser,
<span class="lineNum">    9524 </span>            :                                                           &amp;non_constant_p);
<span class="lineNum">    9525 </span>            : 
<span class="lineNum">    9526 </span>            :               if (BRACE_ENCLOSED_INITIALIZER_P (rhs))
<span class="lineNum">    9527 </span><span class="lineCov">   39559882 :                 maybe_warn_cpp0x (CPP0X_INITIALIZER_LISTS);</span>
<span class="lineNum">    9528 </span>            : 
<span class="lineNum">    9529 </span>            :               /* An assignment may not appear in a
<span class="lineNum">    9530 </span><span class="lineCov">   39559882 :                  constant-expression.  */</span>
<span class="lineNum">    9531 </span>            :               if (cp_parser_non_integral_constant_expression (parser,
<span class="lineNum">    9532 </span>            :                                                               NIC_ASSIGNMENT))
<span class="lineNum">    9533 </span>            :                 return error_mark_node;
<span class="lineNum">    9534 </span><span class="lineCov">   39559882 :               /* Build the assignment expression.  Its default</span>
<span class="lineNum">    9535 </span><span class="lineCov">      88856 :                  location:</span>
<span class="lineNum">    9536 </span>            :                    LHS = RHS
<span class="lineNum">    9537 </span>            :                    ~~~~^~~~~
<span class="lineNum">    9538 </span>            :                  is the location of the '=' token as the
<span class="lineNum">    9539 </span>            :                  caret, ranging from the start of the lhs to the
<span class="lineNum">    9540 </span>            :                  end of the rhs.  */
<span class="lineNum">    9541 </span><span class="lineCov">   78942037 :               loc = make_location (loc,</span>
<span class="lineNum">    9542 </span>            :                                    expr.get_start (),
<span class="lineNum">    9543 </span><span class="lineCov">   39471026 :                                    rhs.get_finish ());</span>
<span class="lineNum">    9544 </span>            :               expr = build_x_modify_expr (loc, expr,
<span class="lineNum">    9545 </span>            :                                           assignment_operator,
<span class="lineNum">    9546 </span><span class="lineCov">   39471011 :                                           rhs,</span>
<span class="lineNum">    9547 </span><span class="lineCov">     273856 :                                           complain_flags (decltype_p));</span>
<span class="lineNum">    9548 </span>            :               /* TODO: build_x_modify_expr doesn't honor the location,
<span class="lineNum">    9549 </span>            :                  so we must set it here.  */
<span class="lineNum">    9550 </span><span class="lineCov">   78394310 :               expr.set_location (loc);</span>
<span class="lineNum">    9551 </span>            :             }
<span class="lineNum">    9552 </span>            :         }
<span class="lineNum">    9553 </span>            :     }
<span class="lineNum">    9554 </span><span class="lineCov">   39197155 : </span>
<span class="lineNum">    9555 </span><span class="lineCov">   39197155 :   return expr;</span>
<span class="lineNum">    9556 </span><span class="lineCov">   39197155 : }</span>
<span class="lineNum">    9557 </span>            : 
<span class="lineNum">    9558 </span><span class="lineCov">    1759858 : /* Parse an (optional) assignment-operator.</span>
<span class="lineNum">    9559 </span>            : 
<span class="lineNum">    9560 </span>            :    assignment-operator: one of
<span class="lineNum">    9561 </span><span class="lineCov">    1759858 :      = *= /= %= += -= &gt;&gt;= &lt;&lt;= &amp;= ^= |=</span>
<span class="lineNum">    9562 </span><span class="lineCov">    1759858 : </span>
<span class="lineNum">    9563 </span>            :    GNU Extension:
<span class="lineNum">    9564 </span><span class="lineCov">    3519716 : </span>
<span class="lineNum">    9565 </span><span class="lineCov">        447 :    assignment-operator: one of</span>
<span class="lineNum">    9566 </span>            :      &lt;?= &gt;?=
<span class="lineNum">    9567 </span>            : 
<span class="lineNum">    9568 </span>            :    If the next token is an assignment operator, the corresponding tree
<span class="lineNum">    9569 </span><span class="lineCov">    1759858 :    code is returned, and the token is consumed.  For example, for</span>
<span class="lineNum">    9570 </span>            :    `+=', PLUS_EXPR is returned.  For `=' itself, the code returned is
<span class="lineNum">    9571 </span><span class="lineCov">          1 :    NOP_EXPR.  For `/', TRUNC_DIV_EXPR is returned; for `%',</span>
<span class="lineNum">    9572 </span>            :    TRUNC_MOD_EXPR is returned.  If TOKEN is not an assignment
<span class="lineNum">    9573 </span>            :    operator, ERROR_MARK is returned.  */
<a name="9574"><span class="lineNum">    9574 </span>            : </a>
<span class="lineNum">    9575 </span>            : static enum tree_code
<span class="lineNum">    9576 </span>            : cp_parser_assignment_operator_opt (cp_parser* parser)
<span class="lineNum">    9577 </span>            : {
<span class="lineNum">    9578 </span>            :   enum tree_code op;
<span class="lineNum">    9579 </span><span class="lineCov">    1759857 :   cp_token *token;</span>
<span class="lineNum">    9580 </span>            : 
<span class="lineNum">    9581 </span>            :   /* Peek at the next token.  */
<span class="lineNum">    9582 </span><span class="lineCov">    3519714 :   token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">    9583 </span>            : 
<span class="lineNum">    9584 </span>            :   switch (token-&gt;type)
<span class="lineNum">    9585 </span><span class="lineCov">    1760007 :     {</span>
<span class="lineNum">    9586 </span>            :     case CPP_EQ:
<span class="lineNum">    9587 </span>            :       op = NOP_EXPR;
<span class="lineNum">    9588 </span><span class="lineCov">    1759857 :       break;</span>
<span class="lineNum">    9589 </span>            : 
<span class="lineNum">    9590 </span>            :     case CPP_MULT_EQ:
<span class="lineNum">    9591 </span>            :       op = MULT_EXPR;
<span class="lineNum">    9592 </span>            :       break;
<span class="lineNum">    9593 </span><span class="lineCov">   39286010 : </span>
<span class="lineNum">    9594 </span>            :     case CPP_DIV_EQ:
<span class="lineNum">    9595 </span>            :       op = TRUNC_DIV_EXPR;
<span class="lineNum">    9596 </span>            :       break;
<span class="lineNum">    9597 </span>            : 
<span class="lineNum">    9598 </span>            :     case CPP_MOD_EQ:
<span class="lineNum">    9599 </span>            :       op = TRUNC_MOD_EXPR;
<span class="lineNum">    9600 </span>            :       break;
<span class="lineNum">    9601 </span>            : 
<span class="lineNum">    9602 </span>            :     case CPP_PLUS_EQ:
<span class="lineNum">    9603 </span>            :       op = PLUS_EXPR;
<span class="lineNum">    9604 </span>            :       break;
<span class="lineNum">    9605 </span>            : 
<span class="lineNum">    9606 </span>            :     case CPP_MINUS_EQ:
<span class="lineNum">    9607 </span>            :       op = MINUS_EXPR;
<span class="lineNum">    9608 </span>            :       break;
<span class="lineNum">    9609 </span>            : 
<span class="lineNum">    9610 </span>            :     case CPP_RSHIFT_EQ:
<span class="lineNum">    9611 </span>            :       op = RSHIFT_EXPR;
<span class="lineNum">    9612 </span>            :       break;
<span class="lineNum">    9613 </span>            : 
<span class="lineNum">    9614 </span><span class="lineCov">   39197574 :     case CPP_LSHIFT_EQ:</span>
<span class="lineNum">    9615 </span>            :       op = LSHIFT_EXPR;
<span class="lineNum">    9616 </span><span class="lineCov">   39197574 :       break;</span>
<span class="lineNum">    9617 </span><span class="lineCov">   39197574 : </span>
<span class="lineNum">    9618 </span>            :     case CPP_AND_EQ:
<span class="lineNum">    9619 </span>            :       op = BIT_AND_EXPR;
<span class="lineNum">    9620 </span><span class="lineCov">   78395148 :       break;</span>
<span class="lineNum">    9621 </span>            : 
<span class="lineNum">    9622 </span><span class="lineCov">   39197574 :     case CPP_XOR_EQ:</span>
<span class="lineNum">    9623 </span>            :       op = BIT_XOR_EXPR;
<span class="lineNum">    9624 </span>            :       break;
<span class="lineNum">    9625 </span>            : 
<span class="lineNum">    9626 </span>            :     case CPP_OR_EQ:
<span class="lineNum">    9627 </span>            :       op = BIT_IOR_EXPR;
<span class="lineNum">    9628 </span><span class="lineCov">      33243 :       break;</span>
<span class="lineNum">    9629 </span><span class="lineCov">      33243 : </span>
<span class="lineNum">    9630 </span><span class="lineCov">      33243 :     default:</span>
<span class="lineNum">    9631 </span>            :       /* Nothing else is an assignment operator.  */
<span class="lineNum">    9632 </span><span class="lineCov">      14670 :       op = ERROR_MARK;</span>
<span class="lineNum">    9633 </span><span class="lineCov">      14670 :     }</span>
<span class="lineNum">    9634 </span><span class="lineCov">      14670 : </span>
<span class="lineNum">    9635 </span>            :   /* An operator followed by ... is a fold-expression, handled elsewhere.  */
<span class="lineNum">    9636 </span><span class="lineCov">       2296 :   if (op != ERROR_MARK</span>
<span class="lineNum">    9637 </span><span class="lineCov">       2296 :       &amp;&amp; cp_lexer_nth_token_is (parser-&gt;lexer, 2, CPP_ELLIPSIS))</span>
<span class="lineNum">    9638 </span><span class="lineCov">       2296 :     op = ERROR_MARK;</span>
<span class="lineNum">    9639 </span>            : 
<span class="lineNum">    9640 </span><span class="lineCov">     115652 :   /* If it was an assignment operator, consume it.  */</span>
<span class="lineNum">    9641 </span><span class="lineCov">     115652 :   if (op != ERROR_MARK)</span>
<span class="lineNum">    9642 </span><span class="lineCov">     115652 :     cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    9643 </span>            : 
<span class="lineNum">    9644 </span><span class="lineCov">      29674 :   return op;</span>
<span class="lineNum">    9645 </span><span class="lineCov">      29674 : }</span>
<span class="lineNum">    9646 </span><span class="lineCov">      29674 : </span>
<span class="lineNum">    9647 </span>            : /* Parse an expression.
<span class="lineNum">    9648 </span><span class="lineCov">       2952 : </span>
<span class="lineNum">    9649 </span><span class="lineCov">       2952 :    expression:</span>
<span class="lineNum">    9650 </span><span class="lineCov">       2952 :      assignment-expression</span>
<span class="lineNum">    9651 </span>            :      expression , assignment-expression
<span class="lineNum">    9652 </span><span class="lineCov">       1180 : </span>
<span class="lineNum">    9653 </span><span class="lineCov">       1180 :    CAST_P is true if this expression is the target of a cast.</span>
<span class="lineNum">    9654 </span><span class="lineCov">       1180 :    DECLTYPE_P is true if this expression is the immediate operand of decltype,</span>
<span class="lineNum">    9655 </span>            :      except possibly parenthesized or on the RHS of a comma (N3276).
<span class="lineNum">    9656 </span><span class="lineCov">       6953 : </span>
<span class="lineNum">    9657 </span><span class="lineCov">       6953 :    Returns a representation of the expression.  */</span>
<a name="9658"><span class="lineNum">    9658 </span><span class="lineCov">       6953 : </span></a>
<span class="lineNum">    9659 </span>            : static cp_expr
<span class="lineNum">    9660 </span><span class="lineCov">       4572 : cp_parser_expression (cp_parser* parser, cp_id_kind * pidk,</span>
<span class="lineNum">    9661 </span><span class="lineCov">       4572 :                       bool cast_p, bool decltype_p)</span>
<span class="lineNum">    9662 </span><span class="lineCov">       4572 : {</span>
<span class="lineNum">    9663 </span>            :   cp_expr expression = NULL_TREE;
<span class="lineNum">    9664 </span><span class="lineCov">      72203 :   location_t loc = UNKNOWN_LOCATION;</span>
<span class="lineNum">    9665 </span><span class="lineCov">      72203 : </span>
<span class="lineNum">    9666 </span><span class="lineCov">      72203 :   while (true)</span>
<span class="lineNum">    9667 </span>            :     {
<span class="lineNum">    9668 </span>            :       cp_expr assignment_expression;
<span class="lineNum">    9669 </span>            : 
<span class="lineNum">    9670 </span>            :       /* Parse the next assignment-expression.  */
<span class="lineNum">    9671 </span>            :       assignment_expression
<span class="lineNum">    9672 </span>            :         = cp_parser_assignment_expression (parser, pidk, cast_p, decltype_p);
<span class="lineNum">    9673 </span>            : 
<span class="lineNum">    9674 </span><span class="lineCov">     283395 :       /* We don't create a temporary for a call that is the immediate operand</span>
<span class="lineNum">    9675 </span><span class="lineCov">    1760310 :          of decltype or on the RHS of a comma.  But when we see a comma, we</span>
<span class="lineNum">    9676 </span>            :          need to create a temporary for a call on the LHS.  */
<span class="lineNum">    9677 </span>            :       if (decltype_p &amp;&amp; !processing_template_decl
<span class="lineNum">    9678 </span>            :           &amp;&amp; TREE_CODE (assignment_expression) == CALL_EXPR
<span class="lineNum">    9679 </span><span class="lineCov">   39197541 :           &amp;&amp; CLASS_TYPE_P (TREE_TYPE (assignment_expression))</span>
<span class="lineNum">    9680 </span><span class="lineCov">    1760277 :           &amp;&amp; cp_lexer_next_token_is (parser-&gt;lexer, CPP_COMMA))</span>
<span class="lineNum">    9681 </span>            :         assignment_expression
<span class="lineNum">    9682 </span><span class="lineCov">   39197574 :           = build_cplus_new (TREE_TYPE (assignment_expression),</span>
<span class="lineNum">    9683 </span>            :                              assignment_expression, tf_warning_or_error);
<span class="lineNum">    9684 </span>            : 
<span class="lineNum">    9685 </span>            :       /* If this is the first assignment-expression, we can just
<span class="lineNum">    9686 </span>            :          save it away.  */
<span class="lineNum">    9687 </span>            :       if (!expression)
<span class="lineNum">    9688 </span>            :         expression = assignment_expression;
<span class="lineNum">    9689 </span>            :       else
<span class="lineNum">    9690 </span>            :         {
<span class="lineNum">    9691 </span>            :           /* Create a location with caret at the comma, ranging
<span class="lineNum">    9692 </span>            :              from the start of the LHS to the end of the RHS.  */
<span class="lineNum">    9693 </span>            :           loc = make_location (loc,
<span class="lineNum">    9694 </span>            :                                expression.get_start (),
<span class="lineNum">    9695 </span>            :                                assignment_expression.get_finish ());
<span class="lineNum">    9696 </span>            :           expression = build_x_compound_expr (loc, expression,
<span class="lineNum">    9697 </span>            :                                               assignment_expression,
<span class="lineNum">    9698 </span><span class="lineCov">   16000480 :                                               complain_flags (decltype_p));</span>
<span class="lineNum">    9699 </span>            :           expression.set_location (loc);
<span class="lineNum">    9700 </span>            :         }
<span class="lineNum">    9701 </span><span class="lineCov">   16000480 :       /* If the next token is not a comma, or we're in a fold-expression, then</span>
<span class="lineNum">    9702 </span><span class="lineCov">   16000480 :          we are done with the expression.  */</span>
<span class="lineNum">    9703 </span>            :       if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_COMMA)
<span class="lineNum">    9704 </span><span class="lineCov">   16061008 :           || cp_lexer_nth_token_is (parser-&gt;lexer, 2, CPP_ELLIPSIS))</span>
<span class="lineNum">    9705 </span>            :         break;
<span class="lineNum">    9706 </span><span class="lineCov">   16061008 :       /* Consume the `,'.  */</span>
<span class="lineNum">    9707 </span>            :       loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">    9708 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">    9709 </span><span class="lineCov">   16061008 :       /* A comma operator cannot appear in a constant-expression.  */</span>
<span class="lineNum">    9710 </span><span class="lineCov">   16061008 :       if (cp_parser_non_integral_constant_expression (parser, NIC_COMMA))</span>
<span class="lineNum">    9711 </span>            :         expression = error_mark_node;
<span class="lineNum">    9712 </span>            :     }
<span class="lineNum">    9713 </span>            : 
<span class="lineNum">    9714 </span>            :   return expression;
<span class="lineNum">    9715 </span><span class="lineCov">     202630 : }</span>
<span class="lineNum">    9716 </span><span class="lineCov">      14380 : </span>
<span class="lineNum">    9717 </span><span class="lineCov">        666 : /* Parse a constant-expression.</span>
<span class="lineNum">    9718 </span><span class="lineCov">   16061194 : </span>
<span class="lineNum">    9719 </span><span class="lineCov">          4 :    constant-expression:</span>
<span class="lineNum">    9720 </span><span class="lineCov">         16 :      conditional-expression</span>
<span class="lineNum">    9721 </span>            : 
<span class="lineNum">    9722 </span>            :   If ALLOW_NON_CONSTANT_P a non-constant expression is silently
<span class="lineNum">    9723 </span>            :   accepted.  If ALLOW_NON_CONSTANT_P is true and the expression is not
<span class="lineNum">    9724 </span>            :   constant, *NON_CONSTANT_P is set to TRUE.  If ALLOW_NON_CONSTANT_P
<span class="lineNum">    9725 </span><span class="lineCov">   32121994 :   is false, NON_CONSTANT_P should be NULL.  If STRICT_P is true,</span>
<span class="lineNum">    9726 </span>            :   only parse a conditional-expression, otherwise parse an
<span class="lineNum">    9727 </span>            :   assignment-expression.  See below for rationale.  */
<a name="9728"><span class="lineNum">    9728 </span>            : </a>
<span class="lineNum">    9729 </span>            : static cp_expr
<span class="lineNum">    9730 </span>            : cp_parser_constant_expression (cp_parser* parser,
<span class="lineNum">    9731 </span><span class="lineCov">      60528 :                                bool allow_non_constant_p,</span>
<span class="lineNum">    9732 </span>            :                                bool *non_constant_p,
<span class="lineNum">    9733 </span>            :                                bool strict_p)
<span class="lineNum">    9734 </span><span class="lineCov">      61092 : {</span>
<span class="lineNum">    9735 </span>            :   bool saved_integral_constant_expression_p;
<span class="lineNum">    9736 </span>            :   bool saved_allow_non_integral_constant_expression_p;
<span class="lineNum">    9737 </span><span class="lineCov">      60528 :   bool saved_non_integral_constant_expression_p;</span>
<span class="lineNum">    9738 </span>            :   cp_expr expression;
<span class="lineNum">    9739 </span>            : 
<span class="lineNum">    9740 </span>            :   /* It might seem that we could simply parse the
<span class="lineNum">    9741 </span><span class="lineCov">   32121994 :      conditional-expression, and then check to see if it were</span>
<span class="lineNum">    9742 </span><span class="lineCov">   16060997 :      TREE_CONSTANT.  However, an expression that is TREE_CONSTANT is</span>
<span class="lineNum">    9743 </span>            :      one that the compiler can figure out is constant, possibly after
<span class="lineNum">    9744 </span>            :      doing some simplifications or optimizations.  The standard has a
<span class="lineNum">    9745 </span><span class="lineCov">     121056 :      precise definition of constant-expression, and we must honor</span>
<span class="lineNum">    9746 </span><span class="lineCov">      60528 :      that, even though it is somewhat more restrictive.</span>
<span class="lineNum">    9747 </span>            : 
<span class="lineNum">    9748 </span><span class="lineCov">      60528 :      For example:</span>
<span class="lineNum">    9749 </span><span class="lineCov">          4 : </span>
<span class="lineNum">    9750 </span><span class="lineCov">      60528 :        int i[(2, 3)];</span>
<span class="lineNum">    9751 </span>            : 
<span class="lineNum">    9752 </span><span class="lineCov">   16000469 :      is not a legal declaration, because `(2, 3)' is not a</span>
<span class="lineNum">    9753 </span>            :      constant-expression.  The `,' operator is forbidden in a
<span class="lineNum">    9754 </span>            :      constant-expression.  However, GCC's constant-folding machinery
<span class="lineNum">    9755 </span>            :      will fold this operation to an INTEGER_CST for `3'.  */
<span class="lineNum">    9756 </span>            : 
<span class="lineNum">    9757 </span>            :   /* Save the old settings.  */
<span class="lineNum">    9758 </span>            :   saved_integral_constant_expression_p = parser-&gt;integral_constant_expression_p;
<span class="lineNum">    9759 </span>            :   saved_allow_non_integral_constant_expression_p
<span class="lineNum">    9760 </span>            :     = parser-&gt;allow_non_integral_constant_expression_p;
<span class="lineNum">    9761 </span>            :   saved_non_integral_constant_expression_p = parser-&gt;non_integral_constant_expression_p;
<span class="lineNum">    9762 </span>            :   /* We are now parsing a constant-expression.  */
<span class="lineNum">    9763 </span>            :   parser-&gt;integral_constant_expression_p = true;
<span class="lineNum">    9764 </span>            :   parser-&gt;allow_non_integral_constant_expression_p
<span class="lineNum">    9765 </span>            :     = (allow_non_constant_p || cxx_dialect &gt;= cxx11);
<span class="lineNum">    9766 </span>            :   parser-&gt;non_integral_constant_expression_p = false;
<span class="lineNum">    9767 </span>            :   /* Although the grammar says &quot;conditional-expression&quot;, when not STRICT_P,
<span class="lineNum">    9768 </span><span class="lineCov">    7149201 :      we parse an &quot;assignment-expression&quot;, which also permits</span>
<span class="lineNum">    9769 </span>            :      &quot;throw-expression&quot; and the use of assignment operators.  In the case
<span class="lineNum">    9770 </span>            :      that ALLOW_NON_CONSTANT_P is false, we get better errors than we would
<span class="lineNum">    9771 </span>            :      otherwise.  In the case that ALLOW_NON_CONSTANT_P is true, it is
<span class="lineNum">    9772 </span>            :      actually essential that we look for an assignment-expression.
<span class="lineNum">    9773 </span><span class="lineCov">    7149201 :      For example, cp_parser_initializer_clauses uses this function to</span>
<span class="lineNum">    9774 </span><span class="lineCov">    7149201 :      determine whether a particular assignment-expression is in fact</span>
<span class="lineNum">    9775 </span><span class="lineCov">    7149201 :      constant.  */</span>
<span class="lineNum">    9776 </span><span class="lineCov">    7149201 :   if (strict_p)</span>
<span class="lineNum">    9777 </span>            :     {
<span class="lineNum">    9778 </span>            :       /* Parse the binary expressions (logical-or-expression).  */
<span class="lineNum">    9779 </span>            :       expression = cp_parser_binary_expression (parser, false, false, false,
<span class="lineNum">    9780 </span>            :                                                 PREC_NOT_OPERATOR, NULL);
<span class="lineNum">    9781 </span>            :       /* If the next token is a `?' then we're actually looking at
<span class="lineNum">    9782 </span>            :          a conditional-expression; otherwise we're done.  */
<span class="lineNum">    9783 </span>            :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_QUERY))
<span class="lineNum">    9784 </span>            :         expression = cp_parser_question_colon_clause (parser, expression);
<span class="lineNum">    9785 </span>            :     }
<span class="lineNum">    9786 </span>            :   else
<span class="lineNum">    9787 </span>            :     expression = cp_parser_assignment_expression (parser);
<span class="lineNum">    9788 </span>            :   /* Restore the old settings.  */
<span class="lineNum">    9789 </span>            :   parser-&gt;integral_constant_expression_p
<span class="lineNum">    9790 </span>            :     = saved_integral_constant_expression_p;
<span class="lineNum">    9791 </span>            :   parser-&gt;allow_non_integral_constant_expression_p
<span class="lineNum">    9792 </span>            :     = saved_allow_non_integral_constant_expression_p;
<span class="lineNum">    9793 </span>            :   if (cxx_dialect &gt;= cxx11)
<span class="lineNum">    9794 </span>            :     {
<span class="lineNum">    9795 </span>            :       /* Require an rvalue constant expression here; that's what our
<span class="lineNum">    9796 </span><span class="lineCov">    7149201 :          callers expect.  Reference constant expressions are handled</span>
<span class="lineNum">    9797 </span><span class="lineCov">    7149201 :          separately in e.g. cp_parser_template_argument.  */</span>
<span class="lineNum">    9798 </span><span class="lineCov">    7149201 :       tree decay = expression;</span>
<span class="lineNum">    9799 </span><span class="lineCov">    7149201 :       if (TREE_TYPE (expression)</span>
<span class="lineNum">    9800 </span>            :           &amp;&amp; TREE_CODE (TREE_TYPE (expression)) == ARRAY_TYPE)
<span class="lineNum">    9801 </span><span class="lineCov">    7149201 :         decay = build_address (expression);</span>
<span class="lineNum">    9802 </span><span class="lineCov">    7149201 :       bool is_const = potential_rvalue_constant_expression (decay);</span>
<span class="lineNum">    9803 </span><span class="lineCov">    7149201 :       parser-&gt;non_integral_constant_expression_p = !is_const;</span>
<span class="lineNum">    9804 </span><span class="lineCov">    7149201 :       if (!is_const &amp;&amp; !allow_non_constant_p)</span>
<span class="lineNum">    9805 </span>            :         require_potential_rvalue_constant_expression (decay);
<span class="lineNum">    9806 </span>            :     }
<span class="lineNum">    9807 </span>            :   if (allow_non_constant_p)
<span class="lineNum">    9808 </span>            :     *non_constant_p = parser-&gt;non_integral_constant_expression_p;
<span class="lineNum">    9809 </span>            :   parser-&gt;non_integral_constant_expression_p
<span class="lineNum">    9810 </span>            :     = saved_non_integral_constant_expression_p;
<span class="lineNum">    9811 </span>            : 
<span class="lineNum">    9812 </span>            :   return expression;
<span class="lineNum">    9813 </span>            : }
<span class="lineNum">    9814 </span><span class="lineCov">    7149201 : </span>
<span class="lineNum">    9815 </span>            : /* Parse __builtin_offsetof.
<span class="lineNum">    9816 </span>            : 
<span class="lineNum">    9817 </span><span class="lineCov">      67234 :    offsetof-expression:</span>
<span class="lineNum">    9818 </span><span class="lineCov">      33617 :      &quot;__builtin_offsetof&quot; &quot;(&quot; type-id &quot;,&quot; offsetof-member-designator &quot;)&quot;</span>
<span class="lineNum">    9819 </span>            : 
<span class="lineNum">    9820 </span>            :    offsetof-member-designator:
<span class="lineNum">    9821 </span><span class="lineCov">      33617 :      id-expression</span>
<span class="lineNum">    9822 </span><span class="lineCov">         12 :      | offsetof-member-designator &quot;.&quot; id-expression</span>
<span class="lineNum">    9823 </span>            :      | offsetof-member-designator &quot;[&quot; expression &quot;]&quot;
<span class="lineNum">    9824 </span>            :      | offsetof-member-designator &quot;-&gt;&quot; id-expression  */
<a name="9825"><span class="lineNum">    9825 </span><span class="lineCov">    7115584 : </span></a>
<span class="lineNum">    9826 </span>            : static cp_expr
<span class="lineNum">    9827 </span><span class="lineCov">    7149197 : cp_parser_builtin_offsetof (cp_parser *parser)</span>
<span class="lineNum">    9828 </span><span class="lineCov">    7149197 : {</span>
<span class="lineNum">    9829 </span><span class="lineCov">    7149197 :   int save_ice_p, save_non_ice_p;</span>
<span class="lineNum">    9830 </span><span class="lineCov">    7149197 :   tree type;</span>
<span class="lineNum">    9831 </span><span class="lineCov">    7149197 :   cp_expr expr;</span>
<span class="lineNum">    9832 </span>            :   cp_id_kind dummy;
<span class="lineNum">    9833 </span>            :   cp_token *token;
<span class="lineNum">    9834 </span>            :   location_t finish_loc;
<span class="lineNum">    9835 </span>            : 
<span class="lineNum">    9836 </span><span class="lineCov">    6746248 :   /* We're about to accept non-integral-constant things, but will</span>
<span class="lineNum">    9837 </span><span class="lineCov">   13492496 :      definitely yield an integral constant expression.  Save and</span>
<span class="lineNum">    9838 </span><span class="lineCov">    6746248 :      restore these values around our local parsing.  */</span>
<span class="lineNum">    9839 </span><span class="lineCov">     101674 :   save_ice_p = parser-&gt;integral_constant_expression_p;</span>
<span class="lineNum">    9840 </span><span class="lineCov">    6746248 :   save_non_ice_p = parser-&gt;non_integral_constant_expression_p;</span>
<span class="lineNum">    9841 </span><span class="lineCov">    6746248 : </span>
<span class="lineNum">    9842 </span><span class="lineCov">    6746248 :   location_t start_loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;</span>
<span class="lineNum">    9843 </span><span class="lineCov">        210 : </span>
<span class="lineNum">    9844 </span>            :   /* Consume the &quot;__builtin_offsetof&quot; token.  */
<span class="lineNum">    9845 </span><span class="lineCov">    7149197 :   cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    9846 </span><span class="lineCov">    5711342 :   /* Consume the opening `('.  */</span>
<span class="lineNum">    9847 </span><span class="lineCov">    7149197 :   matching_parens parens;</span>
<span class="lineNum">    9848 </span><span class="lineCov">    7149197 :   parens.require_open (parser);</span>
<span class="lineNum">    9849 </span>            :   /* Parse the type-id.  */
<span class="lineNum">    9850 </span><span class="lineCov">    7149197 :   location_t loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;</span>
<span class="lineNum">    9851 </span>            :   {
<span class="lineNum">    9852 </span>            :     const char *saved_message = parser-&gt;type_definition_forbidden_message;
<span class="lineNum">    9853 </span>            :     parser-&gt;type_definition_forbidden_message
<span class="lineNum">    9854 </span>            :       = G_(&quot;types may not be defined within __builtin_offsetof&quot;);
<span class="lineNum">    9855 </span>            :     type = cp_parser_type_id (parser);
<span class="lineNum">    9856 </span>            :     parser-&gt;type_definition_forbidden_message = saved_message;
<span class="lineNum">    9857 </span>            :   }
<span class="lineNum">    9858 </span>            :   /* Look for the `,'.  */
<span class="lineNum">    9859 </span>            :   cp_parser_require (parser, CPP_COMMA, RT_COMMA);
<span class="lineNum">    9860 </span>            :   token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">    9861 </span>            : 
<span class="lineNum">    9862 </span>            :   /* Build the (type *)null that begins the traditional offsetof macro.  */
<span class="lineNum">    9863 </span>            :   tree object_ptr
<span class="lineNum">    9864 </span>            :     = build_static_cast (build_pointer_type (type), null_pointer_node,
<span class="lineNum">    9865 </span><span class="lineCov">       2007 :                          tf_warning_or_error);</span>
<span class="lineNum">    9866 </span>            : 
<span class="lineNum">    9867 </span><span class="lineCov">       2007 :   /* Parse the offsetof-member-designator.  We begin as if we saw &quot;expr-&gt;&quot;.  */</span>
<span class="lineNum">    9868 </span><span class="lineCov">       2007 :   expr = cp_parser_postfix_dot_deref_expression (parser, CPP_DEREF, object_ptr,</span>
<span class="lineNum">    9869 </span><span class="lineCov">       2007 :                                                  true, &amp;dummy, token-&gt;location);</span>
<span class="lineNum">    9870 </span><span class="lineCov">       2007 :   while (true)</span>
<span class="lineNum">    9871 </span><span class="lineCov">       2007 :     {</span>
<span class="lineNum">    9872 </span><span class="lineCov">       2007 :       token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">    9873 </span>            :       switch (token-&gt;type)
<span class="lineNum">    9874 </span>            :         {
<span class="lineNum">    9875 </span>            :         case CPP_OPEN_SQUARE:
<span class="lineNum">    9876 </span>            :           /* offsetof-member-designator &quot;[&quot; expression &quot;]&quot; */
<span class="lineNum">    9877 </span><span class="lineCov">       2007 :           expr = cp_parser_postfix_open_square_expression (parser, expr,</span>
<span class="lineNum">    9878 </span><span class="lineCov">       2007 :                                                            true, false);</span>
<span class="lineNum">    9879 </span>            :           break;
<span class="lineNum">    9880 </span><span class="lineCov">       4014 : </span>
<span class="lineNum">    9881 </span>            :         case CPP_DEREF:
<span class="lineNum">    9882 </span>            :           /* offsetof-member-designator &quot;-&gt;&quot; identifier */
<span class="lineNum">    9883 </span><span class="lineCov">       2007 :           expr = grok_array_decl (token-&gt;location, expr,</span>
<span class="lineNum">    9884 </span>            :                                   integer_zero_node, false);
<span class="lineNum">    9885 </span><span class="lineCov">       4014 :           /* FALLTHRU */</span>
<span class="lineNum">    9886 </span><span class="lineCov">       2007 : </span>
<span class="lineNum">    9887 </span>            :         case CPP_DOT:
<span class="lineNum">    9888 </span><span class="lineCov">       4014 :           /* offsetof-member-designator &quot;.&quot; identifier */</span>
<span class="lineNum">    9889 </span><span class="lineCov">       2007 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    9890 </span><span class="lineCov">       2007 :           expr = cp_parser_postfix_dot_deref_expression (parser, CPP_DOT,</span>
<span class="lineNum">    9891 </span><span class="lineCov">       2007 :                                                          expr, true, &amp;dummy,</span>
<span class="lineNum">    9892 </span><span class="lineCov">       2007 :                                                          token-&gt;location);</span>
<span class="lineNum">    9893 </span><span class="lineCov">       4014 :           break;</span>
<span class="lineNum">    9894 </span><span class="lineCov">       2007 : </span>
<span class="lineNum">    9895 </span>            :         case CPP_CLOSE_PAREN:
<span class="lineNum">    9896 </span>            :           /* Consume the &quot;)&quot; token.  */
<span class="lineNum">    9897 </span><span class="lineCov">       2007 :           finish_loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;</span>
<span class="lineNum">    9898 </span><span class="lineCov">       4014 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">    9899 </span>            :           goto success;
<span class="lineNum">    9900 </span>            : 
<span class="lineNum">    9901 </span><span class="lineCov">       2007 :         default:</span>
<span class="lineNum">    9902 </span><span class="lineCov">       2007 :           /* Error.  We know the following require will fail, but</span>
<span class="lineNum">    9903 </span>            :              that gives the proper error message.  */
<span class="lineNum">    9904 </span>            :           parens.require_close (parser);
<span class="lineNum">    9905 </span>            :           cp_parser_skip_to_closing_parenthesis (parser, true, false, true);
<span class="lineNum">    9906 </span><span class="lineCov">       2007 :           expr = error_mark_node;</span>
<span class="lineNum">    9907 </span>            :           goto failure;
<span class="lineNum">    9908 </span><span class="lineCov">       2932 :         }</span>
<span class="lineNum">    9909 </span>            :     }
<span class="lineNum">    9910 </span><span class="lineCov">       5864 : </span>
<span class="lineNum">    9911 </span><span class="lineCov">       2932 :  success:</span>
<span class="lineNum">    9912 </span>            :   /* Make a location of the form:
<span class="lineNum">    9913 </span><span class="lineCov">        683 :        __builtin_offsetof (struct s, f)</span>
<span class="lineNum">    9914 </span>            :        ~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~
<span class="lineNum">    9915 </span><span class="lineCov">       1366 :      with caret at the type-id, ranging from the start of the</span>
<span class="lineNum">    9916 </span>            :      &quot;_builtin_offsetof&quot; token to the close paren.  */
<span class="lineNum">    9917 </span><span class="lineCov">        683 :   loc = make_location (loc, start_loc, finish_loc);</span>
<span class="lineNum">    9918 </span>            :   /* The result will be an INTEGER_CST, so we need to explicitly
<span class="lineNum">    9919 </span><span class="lineCov">          9 :      preserve the location.  */</span>
<span class="lineNum">    9920 </span>            :   expr = cp_expr (finish_offsetof (object_ptr, expr, loc), loc);
<span class="lineNum">    9921 </span><span class="lineCov">         18 : </span>
<span class="lineNum">    9922 </span>            :  failure:
<span class="lineNum">    9923 </span>            :   parser-&gt;integral_constant_expression_p = save_ice_p;
<span class="lineNum">    9924 </span>            :   parser-&gt;non_integral_constant_expression_p = save_non_ice_p;
<span class="lineNum">    9925 </span><span class="lineCov">        242 : </span>
<span class="lineNum">    9926 </span>            :   expr = expr.maybe_add_location_wrapper ();
<span class="lineNum">    9927 </span><span class="lineCov">        242 :   return expr;</span>
<span class="lineNum">    9928 </span><span class="lineCov">        242 : }</span>
<span class="lineNum">    9929 </span>            : 
<span class="lineNum">    9930 </span>            : /* Parse a trait expression.
<span class="lineNum">    9931 </span><span class="lineCov">        242 : </span>
<span class="lineNum">    9932 </span>            :    Returns a representation of the expression, the underlying type
<span class="lineNum">    9933 </span><span class="lineCov">       2007 :    of the type at issue when KEYWORD is RID_UNDERLYING_TYPE.  */</span>
<a name="9934"><span class="lineNum">    9934 </span>            : </a>
<span class="lineNum">    9935 </span><span class="lineCov">       4014 : static cp_expr</span>
<span class="lineNum">    9936 </span><span class="lineCov">       2007 : cp_parser_trait_expr (cp_parser* parser, enum rid keyword)</span>
<span class="lineNum">    9937 </span><span class="lineCov">       2007 : {</span>
<span class="lineNum">    9938 </span>            :   cp_trait_kind kind;
<span class="lineNum">    9939 </span><span class="lineNoCov">          0 :   tree type1, type2 = NULL_TREE;</span>
<span class="lineNum">    9940 </span>            :   bool binary = false;
<span class="lineNum">    9941 </span>            :   bool variadic = false;
<span class="lineNum">    9942 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    9943 </span><span class="lineNoCov">          0 :   switch (keyword)</span>
<span class="lineNum">    9944 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">    9945 </span><span class="lineNoCov">          0 :     case RID_HAS_NOTHROW_ASSIGN:</span>
<span class="lineNum">    9946 </span>            :       kind = CPTK_HAS_NOTHROW_ASSIGN;
<span class="lineNum">    9947 </span>            :       break;
<span class="lineNum">    9948 </span>            :     case RID_HAS_NOTHROW_CONSTRUCTOR:
<span class="lineNum">    9949 </span><span class="lineCov">       2007 :       kind = CPTK_HAS_NOTHROW_CONSTRUCTOR;</span>
<span class="lineNum">    9950 </span>            :       break;
<span class="lineNum">    9951 </span>            :     case RID_HAS_NOTHROW_COPY:
<span class="lineNum">    9952 </span>            :       kind = CPTK_HAS_NOTHROW_COPY;
<span class="lineNum">    9953 </span>            :       break;
<span class="lineNum">    9954 </span>            :     case RID_HAS_TRIVIAL_ASSIGN:
<span class="lineNum">    9955 </span><span class="lineCov">       2007 :       kind = CPTK_HAS_TRIVIAL_ASSIGN;</span>
<span class="lineNum">    9956 </span>            :       break;
<span class="lineNum">    9957 </span>            :     case RID_HAS_TRIVIAL_CONSTRUCTOR:
<span class="lineNum">    9958 </span><span class="lineCov">       4014 :       kind = CPTK_HAS_TRIVIAL_CONSTRUCTOR;</span>
<span class="lineNum">    9959 </span>            :       break;
<span class="lineNum">    9960 </span><span class="lineCov">       2007 :     case RID_HAS_TRIVIAL_COPY:</span>
<span class="lineNum">    9961 </span><span class="lineCov">       2007 :       kind = CPTK_HAS_TRIVIAL_COPY;</span>
<span class="lineNum">    9962 </span><span class="lineCov">       2007 :       break;</span>
<span class="lineNum">    9963 </span>            :     case RID_HAS_TRIVIAL_DESTRUCTOR:
<span class="lineNum">    9964 </span><span class="lineCov">       2007 :       kind = CPTK_HAS_TRIVIAL_DESTRUCTOR;</span>
<span class="lineNum">    9965 </span><span class="lineCov">       2007 :       break;</span>
<span class="lineNum">    9966 </span>            :     case RID_HAS_UNIQUE_OBJ_REPRESENTATIONS:
<span class="lineNum">    9967 </span>            :       kind = CPTK_HAS_UNIQUE_OBJ_REPRESENTATIONS;
<span class="lineNum">    9968 </span>            :       break;
<span class="lineNum">    9969 </span>            :     case RID_HAS_VIRTUAL_DESTRUCTOR:
<span class="lineNum">    9970 </span>            :       kind = CPTK_HAS_VIRTUAL_DESTRUCTOR;
<span class="lineNum">    9971 </span>            :       break;
<span class="lineNum">    9972 </span>            :     case RID_IS_ABSTRACT:
<span class="lineNum">    9973 </span>            :       kind = CPTK_IS_ABSTRACT;
<span class="lineNum">    9974 </span><span class="lineCov">      86778 :       break;</span>
<span class="lineNum">    9975 </span>            :     case RID_IS_AGGREGATE:
<span class="lineNum">    9976 </span><span class="lineCov">      86778 :       kind = CPTK_IS_AGGREGATE;</span>
<span class="lineNum">    9977 </span><span class="lineCov">      86778 :       break;</span>
<span class="lineNum">    9978 </span><span class="lineCov">      86778 :     case RID_IS_BASE_OF:</span>
<span class="lineNum">    9979 </span><span class="lineCov">      86778 :       kind = CPTK_IS_BASE_OF;</span>
<span class="lineNum">    9980 </span>            :       binary = true;
<span class="lineNum">    9981 </span><span class="lineCov">      86778 :       break;</span>
<span class="lineNum">    9982 </span>            :     case RID_IS_CLASS:
<span class="lineNum">    9983 </span>            :       kind = CPTK_IS_CLASS;
<span class="lineNum">    9984 </span>            :       break;
<span class="lineNum">    9985 </span>            :     case RID_IS_EMPTY:
<span class="lineNum">    9986 </span><span class="lineCov">         76 :       kind = CPTK_IS_EMPTY;</span>
<span class="lineNum">    9987 </span><span class="lineCov">         76 :       break;</span>
<span class="lineNum">    9988 </span><span class="lineCov">         76 :     case RID_IS_ENUM:</span>
<span class="lineNum">    9989 </span><span class="lineCov">        111 :       kind = CPTK_IS_ENUM;</span>
<span class="lineNum">    9990 </span><span class="lineCov">        111 :       break;</span>
<span class="lineNum">    9991 </span><span class="lineCov">        111 :     case RID_IS_FINAL:</span>
<span class="lineNum">    9992 </span><span class="lineCov">         76 :       kind = CPTK_IS_FINAL;</span>
<span class="lineNum">    9993 </span><span class="lineCov">         76 :       break;</span>
<span class="lineNum">    9994 </span><span class="lineCov">         76 :     case RID_IS_LITERAL_TYPE:</span>
<span class="lineNum">    9995 </span><span class="lineCov">        516 :       kind = CPTK_IS_LITERAL_TYPE;</span>
<span class="lineNum">    9996 </span><span class="lineCov">        516 :       break;</span>
<span class="lineNum">    9997 </span><span class="lineCov">        516 :     case RID_IS_POD:</span>
<span class="lineNum">    9998 </span><span class="lineCov">         73 :       kind = CPTK_IS_POD;</span>
<span class="lineNum">    9999 </span><span class="lineCov">         73 :       break;</span>
<span class="lineNum">   10000 </span><span class="lineCov">         73 :     case RID_IS_POLYMORPHIC:</span>
<span class="lineNum">   10001 </span><span class="lineCov">       4201 :       kind = CPTK_IS_POLYMORPHIC;</span>
<span class="lineNum">   10002 </span><span class="lineCov">       4201 :       break;</span>
<span class="lineNum">   10003 </span><span class="lineCov">       4201 :     case RID_IS_SAME_AS:</span>
<span class="lineNum">   10004 </span><span class="lineCov">        700 :       kind = CPTK_IS_SAME_AS;</span>
<span class="lineNum">   10005 </span><span class="lineCov">        700 :       binary = true;</span>
<span class="lineNum">   10006 </span><span class="lineCov">        700 :       break;</span>
<span class="lineNum">   10007 </span><span class="lineCov">       3386 :     case RID_IS_STD_LAYOUT:</span>
<span class="lineNum">   10008 </span><span class="lineCov">       3386 :       kind = CPTK_IS_STD_LAYOUT;</span>
<span class="lineNum">   10009 </span><span class="lineCov">       3386 :       break;</span>
<span class="lineNum">   10010 </span><span class="lineCov">       3432 :     case RID_IS_TRIVIAL:</span>
<span class="lineNum">   10011 </span><span class="lineCov">       3432 :       kind = CPTK_IS_TRIVIAL;</span>
<span class="lineNum">   10012 </span><span class="lineCov">       3432 :       break;</span>
<span class="lineNum">   10013 </span><span class="lineCov">        722 :     case RID_IS_TRIVIALLY_ASSIGNABLE:</span>
<span class="lineNum">   10014 </span><span class="lineCov">        722 :       kind = CPTK_IS_TRIVIALLY_ASSIGNABLE;</span>
<span class="lineNum">   10015 </span><span class="lineCov">        722 :       binary = true;</span>
<span class="lineNum">   10016 </span><span class="lineCov">       3415 :       break;</span>
<span class="lineNum">   10017 </span><span class="lineCov">       3415 :     case RID_IS_TRIVIALLY_CONSTRUCTIBLE:</span>
<span class="lineNum">   10018 </span><span class="lineCov">       3415 :       kind = CPTK_IS_TRIVIALLY_CONSTRUCTIBLE;</span>
<span class="lineNum">   10019 </span><span class="lineCov">       3415 :       variadic = true;</span>
<span class="lineNum">   10020 </span><span class="lineCov">       3416 :       break;</span>
<span class="lineNum">   10021 </span><span class="lineCov">       3416 :     case RID_IS_TRIVIALLY_COPYABLE:</span>
<span class="lineNum">   10022 </span><span class="lineCov">       3416 :       kind = CPTK_IS_TRIVIALLY_COPYABLE;</span>
<span class="lineNum">   10023 </span><span class="lineCov">       7749 :       break;</span>
<span class="lineNum">   10024 </span><span class="lineCov">       7749 :     case RID_IS_UNION:</span>
<span class="lineNum">   10025 </span><span class="lineCov">       7749 :       kind = CPTK_IS_UNION;</span>
<span class="lineNum">   10026 </span><span class="lineCov">       3364 :       break;</span>
<span class="lineNum">   10027 </span><span class="lineCov">       3364 :     case RID_UNDERLYING_TYPE:</span>
<span class="lineNum">   10028 </span><span class="lineCov">       3364 :       kind = CPTK_UNDERLYING_TYPE;</span>
<span class="lineNum">   10029 </span><span class="lineCov">       5238 :       break;</span>
<span class="lineNum">   10030 </span><span class="lineCov">       5238 :     case RID_BASES:</span>
<span class="lineNum">   10031 </span><span class="lineCov">       5238 :       kind = CPTK_BASES;</span>
<span class="lineNum">   10032 </span><span class="lineCov">       2326 :       break;</span>
<span class="lineNum">   10033 </span><span class="lineCov">       2326 :     case RID_DIRECT_BASES:</span>
<span class="lineNum">   10034 </span><span class="lineCov">       2326 :       kind = CPTK_DIRECT_BASES;</span>
<span class="lineNum">   10035 </span><span class="lineCov">       3951 :       break;</span>
<span class="lineNum">   10036 </span><span class="lineCov">       3951 :     case RID_IS_ASSIGNABLE:</span>
<span class="lineNum">   10037 </span><span class="lineCov">       3951 :       kind = CPTK_IS_ASSIGNABLE;</span>
<span class="lineNum">   10038 </span><span class="lineCov">       3383 :       binary = true;</span>
<span class="lineNum">   10039 </span><span class="lineCov">       3383 :       break;</span>
<span class="lineNum">   10040 </span><span class="lineCov">       3383 :     case RID_IS_CONSTRUCTIBLE:</span>
<span class="lineNum">   10041 </span><span class="lineCov">         24 :       kind = CPTK_IS_CONSTRUCTIBLE;</span>
<span class="lineNum">   10042 </span><span class="lineCov">         24 :       variadic = true;</span>
<span class="lineNum">   10043 </span><span class="lineCov">         24 :       break;</span>
<span class="lineNum">   10044 </span><span class="lineCov">         24 :     default:</span>
<span class="lineNum">   10045 </span><span class="lineCov">       2320 :       gcc_unreachable ();</span>
<span class="lineNum">   10046 </span><span class="lineCov">       2320 :     }</span>
<span class="lineNum">   10047 </span><span class="lineCov">       2320 : </span>
<span class="lineNum">   10048 </span><span class="lineCov">       7148 :   /* Get location of initial token.  */</span>
<span class="lineNum">   10049 </span><span class="lineCov">       7148 :   location_t start_loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;</span>
<span class="lineNum">   10050 </span><span class="lineCov">       7148 : </span>
<span class="lineNum">   10051 </span><span class="lineCov">       6957 :   /* Consume the token.  */</span>
<span class="lineNum">   10052 </span><span class="lineCov">       6957 :   cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   10053 </span><span class="lineCov">       6957 : </span>
<span class="lineNum">   10054 </span><span class="lineCov">       6957 :   matching_parens parens;</span>
<span class="lineNum">   10055 </span><span class="lineCov">       7001 :   parens.require_open (parser);</span>
<span class="lineNum">   10056 </span><span class="lineCov">       7001 : </span>
<span class="lineNum">   10057 </span><span class="lineCov">       7001 :   {</span>
<span class="lineNum">   10058 </span><span class="lineCov">       7001 :     type_id_in_expr_sentinel s (parser);</span>
<span class="lineNum">   10059 </span><span class="lineCov">       6656 :     type1 = cp_parser_type_id (parser);</span>
<span class="lineNum">   10060 </span><span class="lineCov">       6656 :   }</span>
<span class="lineNum">   10061 </span><span class="lineCov">       6656 : </span>
<span class="lineNum">   10062 </span><span class="lineCov">       3361 :   if (type1 == error_mark_node)</span>
<span class="lineNum">   10063 </span><span class="lineCov">       3361 :     return error_mark_node;</span>
<span class="lineNum">   10064 </span><span class="lineCov">       3361 : </span>
<span class="lineNum">   10065 </span><span class="lineCov">       2422 :   if (binary)</span>
<span class="lineNum">   10066 </span><span class="lineCov">       2422 :     {</span>
<span class="lineNum">   10067 </span><span class="lineCov">       2422 :       cp_parser_require (parser, CPP_COMMA, RT_COMMA);</span>
<span class="lineNum">   10068 </span><span class="lineCov">         12 :  </span>
<span class="lineNum">   10069 </span><span class="lineCov">         12 :       {</span>
<span class="lineNum">   10070 </span><span class="lineCov">         12 :         type_id_in_expr_sentinel s (parser);</span>
<span class="lineNum">   10071 </span><span class="lineCov">         12 :         type2 = cp_parser_type_id (parser);</span>
<span class="lineNum">   10072 </span><span class="lineCov">         12 :       }</span>
<span class="lineNum">   10073 </span><span class="lineCov">         12 : </span>
<span class="lineNum">   10074 </span><span class="lineCov">       2314 :       if (type2 == error_mark_node)</span>
<span class="lineNum">   10075 </span><span class="lineCov">       2314 :         return error_mark_node;</span>
<span class="lineNum">   10076 </span><span class="lineCov">       2314 :     }</span>
<span class="lineNum">   10077 </span><span class="lineCov">       2314 :   else if (variadic)</span>
<span class="lineNum">   10078 </span><span class="lineCov">       2318 :     {</span>
<span class="lineNum">   10079 </span><span class="lineCov">       2318 :       while (cp_lexer_next_token_is (parser-&gt;lexer, CPP_COMMA))</span>
<span class="lineNum">   10080 </span><span class="lineCov">       2318 :         {</span>
<span class="lineNum">   10081 </span><span class="lineCov">       2318 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   10082 </span><span class="lineNoCov">          0 :           tree elt = cp_parser_type_id (parser);</span>
<span class="lineNum">   10083 </span><span class="lineNoCov">          0 :           if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_ELLIPSIS))</span>
<span class="lineNum">   10084 </span>            :             {
<span class="lineNum">   10085 </span>            :               cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   10086 </span>            :               elt = make_pack_expansion (elt);
<span class="lineNum">   10087 </span><span class="lineCov">     173556 :             }</span>
<span class="lineNum">   10088 </span>            :           if (elt == error_mark_node)
<span class="lineNum">   10089 </span>            :             return error_mark_node;
<span class="lineNum">   10090 </span><span class="lineCov">      86778 :           type2 = tree_cons (NULL_TREE, elt, type2);</span>
<span class="lineNum">   10091 </span>            :         }
<span class="lineNum">   10092 </span><span class="lineCov">     173556 :     }</span>
<span class="lineNum">   10093 </span><span class="lineCov">      86778 : </span>
<span class="lineNum">   10094 </span>            :   location_t finish_loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">   10095 </span><span class="lineCov">      86778 :   parens.require_close (parser);</span>
<span class="lineNum">   10096 </span><span class="lineCov">     347112 : </span>
<span class="lineNum">   10097 </span><span class="lineCov">     173556 :   /* Construct a location of the form:</span>
<span class="lineNum">   10098 </span>            :        __is_trivially_copyable(_Tp)
<span class="lineNum">   10099 </span>            :        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
<span class="lineNum">   10100 </span><span class="lineCov">      86778 :      with start == caret, finishing at the close-paren.  */</span>
<span class="lineNum">   10101 </span><span class="lineCov">         14 :   location_t trait_loc = make_location (start_loc, start_loc, finish_loc);</span>
<span class="lineNum">   10102 </span>            : 
<span class="lineNum">   10103 </span><span class="lineCov">      86764 :   /* Complete the trait expression, which may mean either processing</span>
<span class="lineNum">   10104 </span>            :      the trait expr now or saving it for template instantiation.  */
<span class="lineNum">   10105 </span><span class="lineCov">      12706 :   switch (kind)</span>
<span class="lineNum">   10106 </span>            :     {
<span class="lineNum">   10107 </span><span class="lineCov">      12706 :     case CPTK_UNDERLYING_TYPE:</span>
<span class="lineNum">   10108 </span><span class="lineCov">      50824 :       return cp_expr (finish_underlying_type (type1), trait_loc);</span>
<span class="lineNum">   10109 </span><span class="lineCov">      25412 :     case CPTK_BASES:</span>
<span class="lineNum">   10110 </span>            :       return cp_expr (finish_bases (type1, false), trait_loc);
<span class="lineNum">   10111 </span>            :     case CPTK_DIRECT_BASES:
<span class="lineNum">   10112 </span><span class="lineCov">      12706 :       return cp_expr (finish_bases (type1, true), trait_loc);</span>
<span class="lineNum">   10113 </span><span class="lineCov">          2 :     default:</span>
<span class="lineNum">   10114 </span>            :       return cp_expr (finish_trait_expr (kind, type1, type2), trait_loc);
<span class="lineNum">   10115 </span><span class="lineCov">      74058 :     }</span>
<span class="lineNum">   10116 </span>            : }
<span class="lineNum">   10117 </span><span class="lineCov">      18621 : </span>
<span class="lineNum">   10118 </span>            : /* Parse a lambda expression.
<span class="lineNum">   10119 </span><span class="lineCov">       9302 : </span>
<span class="lineNum">   10120 </span><span class="lineCov">      18604 :    lambda-expression:</span>
<span class="lineNum">   10121 </span><span class="lineCov">       9302 :      lambda-introducer lambda-declarator [opt] compound-statement</span>
<span class="lineNum">   10122 </span>            : 
<span class="lineNum">   10123 </span><span class="lineCov">       4630 :    Returns a representation of the expression.  */</span>
<a name="10124"><span class="lineNum">   10124 </span><span class="lineCov">       4630 : </span></a>
<span class="lineNum">   10125 </span>            : static cp_expr
<span class="lineNum">   10126 </span><span class="lineCov">       9302 : cp_parser_lambda_expression (cp_parser* parser)</span>
<span class="lineNum">   10127 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   10128 </span><span class="lineCov">       9302 :   tree lambda_expr = build_lambda_expr ();</span>
<span class="lineNum">   10129 </span>            :   tree type;
<span class="lineNum">   10130 </span>            :   bool ok = true;
<span class="lineNum">   10131 </span>            :   cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   10132 </span><span class="lineCov">     173524 :   cp_token_position start = 0;</span>
<span class="lineNum">   10133 </span><span class="lineCov">      86762 : </span>
<span class="lineNum">   10134 </span>            :   LAMBDA_EXPR_LOCATION (lambda_expr) = token-&gt;location;
<span class="lineNum">   10135 </span>            : 
<span class="lineNum">   10136 </span>            :   if (cp_unevaluated_operand)
<span class="lineNum">   10137 </span>            :     {
<span class="lineNum">   10138 </span>            :       if (!token-&gt;error_reported)
<span class="lineNum">   10139 </span><span class="lineCov">      86762 :         {</span>
<span class="lineNum">   10140 </span>            :           error_at (LAMBDA_EXPR_LOCATION (lambda_expr),
<span class="lineNum">   10141 </span>            :                     &quot;lambda-expression in unevaluated context&quot;);
<span class="lineNum">   10142 </span>            :           token-&gt;error_reported = true;
<span class="lineNum">   10143 </span><span class="lineCov">      86762 :         }</span>
<span class="lineNum">   10144 </span>            :       ok = false;
<span class="lineNum">   10145 </span><span class="lineCov">       2419 :     }</span>
<span class="lineNum">   10146 </span><span class="lineCov">       2419 :   else if (parser-&gt;in_template_argument_list_p)</span>
<span class="lineNum">   10147 </span><span class="lineCov">         12 :     {</span>
<span class="lineNum">   10148 </span><span class="lineCov">         12 :       if (!token-&gt;error_reported)</span>
<span class="lineNum">   10149 </span><span class="lineCov">         12 :         {</span>
<span class="lineNum">   10150 </span><span class="lineCov">         12 :           error_at (token-&gt;location, &quot;lambda-expression in template-argument&quot;);</span>
<span class="lineNum">   10151 </span><span class="lineCov">      84319 :           token-&gt;error_reported = true;</span>
<span class="lineNum">   10152 </span><span class="lineCov">      84319 :         }</span>
<span class="lineNum">   10153 </span>            :       ok = false;
<span class="lineNum">   10154 </span>            :     }
<span class="lineNum">   10155 </span>            : 
<span class="lineNum">   10156 </span>            :   /* We may be in the middle of deferred access check.  Disable
<span class="lineNum">   10157 </span>            :      it now.  */
<span class="lineNum">   10158 </span>            :   push_deferring_access_checks (dk_no_deferred);
<span class="lineNum">   10159 </span>            : 
<span class="lineNum">   10160 </span>            :   cp_parser_lambda_introducer (parser, lambda_expr);
<span class="lineNum">   10161 </span>            : 
<span class="lineNum">   10162 </span>            :   type = begin_lambda_type (lambda_expr);
<span class="lineNum">   10163 </span>            :   if (type == error_mark_node)
<span class="lineNum">   10164 </span><span class="lineCov">       4760 :     return error_mark_node;</span>
<span class="lineNum">   10165 </span>            : 
<span class="lineNum">   10166 </span><span class="lineCov">       4760 :   record_lambda_scope (lambda_expr);</span>
<span class="lineNum">   10167 </span><span class="lineCov">       4760 : </span>
<span class="lineNum">   10168 </span><span class="lineCov">       4760 :   /* Do this again now that LAMBDA_EXPR_EXTRA_SCOPE is set.  */</span>
<span class="lineNum">   10169 </span><span class="lineCov">       9520 :   determine_visibility (TYPE_NAME (type));</span>
<span class="lineNum">   10170 </span><span class="lineCov">       4760 : </span>
<span class="lineNum">   10171 </span>            :   /* Now that we've started the type, add the capture fields for any
<span class="lineNum">   10172 </span><span class="lineCov">       4760 :      explicit captures.  */</span>
<span class="lineNum">   10173 </span>            :   register_capture_members (LAMBDA_EXPR_CAPTURE_LIST (lambda_expr));
<span class="lineNum">   10174 </span><span class="lineCov">       4760 : </span>
<span class="lineNum">   10175 </span>            :   {
<span class="lineNum">   10176 </span><span class="lineCov">         10 :     /* Inside the class, surrounding template-parameter-lists do not apply.  */</span>
<span class="lineNum">   10177 </span>            :     unsigned int saved_num_template_parameter_lists
<span class="lineNum">   10178 </span><span class="lineCov">         12 :         = parser-&gt;num_template_parameter_lists;</span>
<span class="lineNum">   10179 </span>            :     unsigned char in_statement = parser-&gt;in_statement;
<span class="lineNum">   10180 </span><span class="lineCov">          6 :     bool in_switch_statement_p = parser-&gt;in_switch_statement_p;</span>
<span class="lineNum">   10181 </span>            :     bool fully_implicit_function_template_p
<span class="lineNum">   10182 </span>            :         = parser-&gt;fully_implicit_function_template_p;
<span class="lineNum">   10183 </span>            :     tree implicit_template_parms = parser-&gt;implicit_template_parms;
<span class="lineNum">   10184 </span><span class="lineCov">       4750 :     cp_binding_level* implicit_template_scope = parser-&gt;implicit_template_scope;</span>
<span class="lineNum">   10185 </span>            :     bool auto_is_implicit_function_template_parm_p
<span class="lineNum">   10186 </span><span class="lineCov">          4 :         = parser-&gt;auto_is_implicit_function_template_parm_p;</span>
<span class="lineNum">   10187 </span>            : 
<span class="lineNum">   10188 </span><span class="lineCov">          4 :     parser-&gt;num_template_parameter_lists = 0;</span>
<span class="lineNum">   10189 </span><span class="lineCov">          4 :     parser-&gt;in_statement = 0;</span>
<span class="lineNum">   10190 </span>            :     parser-&gt;in_switch_statement_p = false;
<span class="lineNum">   10191 </span>            :     parser-&gt;fully_implicit_function_template_p = false;
<span class="lineNum">   10192 </span>            :     parser-&gt;implicit_template_parms = 0;
<span class="lineNum">   10193 </span>            :     parser-&gt;implicit_template_scope = 0;
<span class="lineNum">   10194 </span>            :     parser-&gt;auto_is_implicit_function_template_parm_p = false;
<span class="lineNum">   10195 </span>            : 
<span class="lineNum">   10196 </span><span class="lineCov">       4760 :     /* By virtue of defining a local class, a lambda expression has access to</span>
<span class="lineNum">   10197 </span>            :        the private variables of enclosing classes.  */
<span class="lineNum">   10198 </span><span class="lineCov">       4760 : </span>
<span class="lineNum">   10199 </span>            :     ok &amp;= cp_parser_lambda_declarator_opt (parser, lambda_expr);
<span class="lineNum">   10200 </span><span class="lineCov">       4760 : </span>
<span class="lineNum">   10201 </span><span class="lineCov">       4760 :     if (ok &amp;&amp; cp_parser_error_occurred (parser))</span>
<span class="lineNum">   10202 </span><span class="lineCov">          2 :       ok = false;</span>
<span class="lineNum">   10203 </span>            : 
<span class="lineNum">   10204 </span><span class="lineCov">       4758 :     if (ok)</span>
<span class="lineNum">   10205 </span>            :       {
<span class="lineNum">   10206 </span>            :         if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_BRACE)
<span class="lineNum">   10207 </span><span class="lineCov">       4758 :             &amp;&amp; cp_parser_start_tentative_firewall (parser))</span>
<span class="lineNum">   10208 </span>            :           start = token;
<span class="lineNum">   10209 </span>            :         cp_parser_lambda_body (parser, lambda_expr);
<span class="lineNum">   10210 </span>            :       }
<span class="lineNum">   10211 </span><span class="lineCov">       4758 :     else if (cp_parser_require (parser, CPP_OPEN_BRACE, RT_OPEN_BRACE))</span>
<span class="lineNum">   10212 </span>            :       {
<span class="lineNum">   10213 </span><span class="lineCov">       4758 :         if (cp_parser_skip_to_closing_brace (parser))</span>
<span class="lineNum">   10214 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   10215 </span><span class="lineCov">       4758 :       }</span>
<span class="lineNum">   10216 </span>            : 
<span class="lineNum">   10217 </span><span class="lineCov">       4758 :     /* The capture list was built up in reverse order; fix that now.  */</span>
<span class="lineNum">   10218 </span><span class="lineCov">       4758 :     LAMBDA_EXPR_CAPTURE_LIST (lambda_expr)</span>
<span class="lineNum">   10219 </span><span class="lineCov">       4758 :       = nreverse (LAMBDA_EXPR_CAPTURE_LIST (lambda_expr));</span>
<span class="lineNum">   10220 </span>            : 
<span class="lineNum">   10221 </span><span class="lineCov">       4758 :     if (ok)</span>
<span class="lineNum">   10222 </span><span class="lineCov">       4758 :       maybe_add_lambda_conv_op (type);</span>
<span class="lineNum">   10223 </span><span class="lineCov">       4758 : </span>
<span class="lineNum">   10224 </span>            :     type = finish_struct (type, /*attributes=*/NULL_TREE);
<span class="lineNum">   10225 </span>            : 
<span class="lineNum">   10226 </span><span class="lineCov">       4758 :     parser-&gt;num_template_parameter_lists = saved_num_template_parameter_lists;</span>
<span class="lineNum">   10227 </span><span class="lineCov">       4758 :     parser-&gt;in_statement = in_statement;</span>
<span class="lineNum">   10228 </span><span class="lineCov">       4758 :     parser-&gt;in_switch_statement_p = in_switch_statement_p;</span>
<span class="lineNum">   10229 </span><span class="lineCov">       4758 :     parser-&gt;fully_implicit_function_template_p</span>
<span class="lineNum">   10230 </span><span class="lineCov">       4758 :         = fully_implicit_function_template_p;</span>
<span class="lineNum">   10231 </span><span class="lineCov">       4758 :     parser-&gt;implicit_template_parms = implicit_template_parms;</span>
<span class="lineNum">   10232 </span><span class="lineCov">       4758 :     parser-&gt;implicit_template_scope = implicit_template_scope;</span>
<span class="lineNum">   10233 </span>            :     parser-&gt;auto_is_implicit_function_template_parm_p
<span class="lineNum">   10234 </span>            :         = auto_is_implicit_function_template_parm_p;
<span class="lineNum">   10235 </span>            :   }
<span class="lineNum">   10236 </span>            : 
<span class="lineNum">   10237 </span><span class="lineCov">       4758 :   /* This field is only used during parsing of the lambda.  */</span>
<span class="lineNum">   10238 </span>            :   LAMBDA_EXPR_THIS_CAPTURE (lambda_expr) = NULL_TREE;
<span class="lineNum">   10239 </span><span class="lineCov">       4758 : </span>
<span class="lineNum">   10240 </span>            :   /* This lambda shouldn't have any proxies left at this point.  */
<span class="lineNum">   10241 </span>            :   gcc_assert (LAMBDA_EXPR_PENDING_PROXIES (lambda_expr) == NULL);
<span class="lineNum">   10242 </span><span class="lineCov">       4752 :   /* And now that we're done, push proxies for an enclosing lambda.  */</span>
<span class="lineNum">   10243 </span>            :   insert_pending_capture_proxies ();
<span class="lineNum">   10244 </span><span class="lineCov">       9474 : </span>
<span class="lineNum">   10245 </span><span class="lineCov">       4737 :   /* Update the lambda expression to a range.  */</span>
<span class="lineNum">   10246 </span>            :   cp_token *end_tok = cp_lexer_previous_token (parser-&gt;lexer);
<span class="lineNum">   10247 </span><span class="lineCov">       4737 :   LAMBDA_EXPR_LOCATION (lambda_expr) = make_location (token-&gt;location,</span>
<span class="lineNum">   10248 </span>            :                                                       token-&gt;location,
<span class="lineNum">   10249 </span><span class="lineCov">         21 :                                                       end_tok-&gt;location);</span>
<span class="lineNum">   10250 </span>            : 
<span class="lineNum">   10251 </span><span class="lineCov">         15 :   if (ok)</span>
<span class="lineNum">   10252 </span><span class="lineCov">         15 :     lambda_expr = build_lambda_object (lambda_expr);</span>
<span class="lineNum">   10253 </span>            :   else
<span class="lineNum">   10254 </span>            :     lambda_expr = error_mark_node;
<span class="lineNum">   10255 </span>            : 
<span class="lineNum">   10256 </span><span class="lineCov">      14274 :   cp_parser_end_tentative_firewall (parser, start, lambda_expr);</span>
<span class="lineNum">   10257 </span><span class="lineCov">       4758 : </span>
<span class="lineNum">   10258 </span>            :   pop_deferring_access_checks ();
<span class="lineNum">   10259 </span><span class="lineCov">       4758 : </span>
<span class="lineNum">   10260 </span><span class="lineCov">       4737 :   return lambda_expr;</span>
<span class="lineNum">   10261 </span>            : }
<span class="lineNum">   10262 </span><span class="lineCov">       4758 : </span>
<span class="lineNum">   10263 </span>            : /* Parse the beginning of a lambda expression.
<span class="lineNum">   10264 </span><span class="lineCov">       4758 : </span>
<span class="lineNum">   10265 </span><span class="lineCov">       4758 :    lambda-introducer:</span>
<span class="lineNum">   10266 </span><span class="lineCov">       4758 :      [ lambda-capture [opt] ]</span>
<span class="lineNum">   10267 </span><span class="lineCov">       4758 : </span>
<span class="lineNum">   10268 </span><span class="lineCov">       4758 :    LAMBDA_EXPR is the current representation of the lambda expression.  */</span>
<a name="10269"><span class="lineNum">   10269 </span><span class="lineCov">       4758 : </span></a>
<span class="lineNum">   10270 </span><span class="lineCov">       4758 : static void</span>
<span class="lineNum">   10271 </span><span class="lineCov">       4758 : cp_parser_lambda_introducer (cp_parser* parser, tree lambda_expr)</span>
<span class="lineNum">   10272 </span><span class="lineCov">       4758 : {</span>
<span class="lineNum">   10273 </span>            :   /* Need commas after the first capture.  */
<span class="lineNum">   10274 </span>            :   bool first = true;
<span class="lineNum">   10275 </span>            : 
<span class="lineNum">   10276 </span><span class="lineCov">       4758 :   /* Eat the leading `['.  */</span>
<span class="lineNum">   10277 </span>            :   cp_parser_require (parser, CPP_OPEN_SQUARE, RT_OPEN_SQUARE);
<span class="lineNum">   10278 </span>            : 
<span class="lineNum">   10279 </span><span class="lineCov">       9516 :   /* Record default capture mode.  &quot;[&amp;&quot; &quot;[=&quot; &quot;[&amp;,&quot; &quot;[=,&quot;  */</span>
<span class="lineNum">   10280 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_AND)
<span class="lineNum">   10281 </span><span class="lineCov">       4758 :       &amp;&amp; cp_lexer_peek_nth_token (parser-&gt;lexer, 2)-&gt;type != CPP_NAME)</span>
<span class="lineNum">   10282 </span>            :     LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda_expr) = CPLD_REFERENCE;
<span class="lineNum">   10283 </span>            :   else if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_EQ))
<span class="lineNum">   10284 </span><span class="lineCov">       4758 :     LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda_expr) = CPLD_COPY;</span>
<span class="lineNum">   10285 </span><span class="lineCov">       4758 : </span>
<span class="lineNum">   10286 </span>            :   if (LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda_expr) != CPLD_NONE)
<span class="lineNum">   10287 </span>            :     {
<span class="lineNum">   10288 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   10289 </span><span class="lineCov">       4758 :       first = false;</span>
<span class="lineNum">   10290 </span><span class="lineCov">       4737 : </span>
<span class="lineNum">   10291 </span>            :       if (!(at_function_scope_p () || parsing_nsdmi ()))
<span class="lineNum">   10292 </span><span class="lineCov">         21 :         error (&quot;non-local lambda expression cannot have a capture-default&quot;);</span>
<span class="lineNum">   10293 </span>            :     }
<span class="lineNum">   10294 </span><span class="lineCov">       4758 : </span>
<span class="lineNum">   10295 </span>            :   while (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_CLOSE_SQUARE))
<span class="lineNum">   10296 </span><span class="lineCov">       4758 :     {</span>
<span class="lineNum">   10297 </span>            :       cp_token* capture_token;
<span class="lineNum">   10298 </span><span class="lineCov">       4758 :       tree capture_id;</span>
<span class="lineNum">   10299 </span>            :       tree capture_init_expr;
<span class="lineNum">   10300 </span>            :       cp_id_kind idk = CP_ID_KIND_NONE;
<span class="lineNum">   10301 </span>            :       bool explicit_init_p = false;
<span class="lineNum">   10302 </span>            : 
<span class="lineNum">   10303 </span>            :       enum capture_kind_type
<span class="lineNum">   10304 </span>            :       {
<span class="lineNum">   10305 </span>            :         BY_COPY,
<span class="lineNum">   10306 </span>            :         BY_REFERENCE
<span class="lineNum">   10307 </span>            :       };
<span class="lineNum">   10308 </span>            :       enum capture_kind_type capture_kind = BY_COPY;
<span class="lineNum">   10309 </span><span class="lineCov">       4760 : </span>
<span class="lineNum">   10310 </span>            :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_EOF))
<span class="lineNum">   10311 </span>            :         {
<span class="lineNum">   10312 </span><span class="lineCov">       4760 :           error (&quot;expected end of capture-list&quot;);</span>
<span class="lineNum">   10313 </span>            :           return;
<span class="lineNum">   10314 </span>            :         }
<span class="lineNum">   10315 </span><span class="lineCov">       4760 : </span>
<span class="lineNum">   10316 </span>            :       if (first)
<span class="lineNum">   10317 </span>            :         first = false;
<span class="lineNum">   10318 </span><span class="lineCov">       9520 :       else</span>
<span class="lineNum">   10319 </span><span class="lineCov">       4760 :         cp_parser_require (parser, CPP_COMMA, RT_COMMA);</span>
<span class="lineNum">   10320 </span><span class="lineCov">        936 : </span>
<span class="lineNum">   10321 </span><span class="lineCov">       3824 :       /* Possibly capture `this'.  */</span>
<span class="lineNum">   10322 </span><span class="lineCov">        282 :       if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_THIS))</span>
<span class="lineNum">   10323 </span>            :         {
<span class="lineNum">   10324 </span><span class="lineCov">       4760 :           location_t loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;</span>
<span class="lineNum">   10325 </span>            :           if (cxx_dialect &lt; cxx2a
<span class="lineNum">   10326 </span><span class="lineCov">       1218 :               &amp;&amp; LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda_expr) == CPLD_COPY)</span>
<span class="lineNum">   10327 </span><span class="lineCov">       1218 :             pedwarn (loc, 0, &quot;explicit by-copy capture of %&lt;this%&gt; redundant &quot;</span>
<span class="lineNum">   10328 </span>            :                      &quot;with by-copy capture default&quot;);
<span class="lineNum">   10329 </span><span class="lineCov">       1218 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   10330 </span><span class="lineCov">         10 :           add_capture (lambda_expr,</span>
<span class="lineNum">   10331 </span>            :                        /*id=*/this_identifier,
<span class="lineNum">   10332 </span>            :                        /*initializer=*/finish_this_expr (),
<span class="lineNum">   10333 </span><span class="lineCov">       7823 :                        /*by_reference_p=*/true,</span>
<span class="lineNum">   10334 </span>            :                        explicit_init_p);
<span class="lineNum">   10335 </span><span class="lineCov">       3074 :           continue;</span>
<span class="lineNum">   10336 </span><span class="lineCov">       3074 :         }</span>
<span class="lineNum">   10337 </span><span class="lineCov">       3074 : </span>
<span class="lineNum">   10338 </span><span class="lineCov">       3074 :       /* Possibly capture `*this'.  */</span>
<span class="lineNum">   10339 </span><span class="lineCov">       3074 :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_MULT)</span>
<span class="lineNum">   10340 </span>            :           &amp;&amp; cp_lexer_nth_token_is_keyword (parser-&gt;lexer, 2, RID_THIS))
<span class="lineNum">   10341 </span><span class="lineCov">       3074 :         {</span>
<span class="lineNum">   10342 </span>            :           location_t loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">   10343 </span>            :           if (cxx_dialect &lt; cxx17)
<span class="lineNum">   10344 </span>            :             pedwarn (loc, 0, &quot;%&lt;*this%&gt; capture only available with &quot;
<span class="lineNum">   10345 </span>            :                              &quot;-std=c++17 or -std=gnu++17&quot;);
<span class="lineNum">   10346 </span><span class="lineCov">       3074 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   10347 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   10348 </span><span class="lineCov">       3074 :           add_capture (lambda_expr,</span>
<span class="lineNum">   10349 </span>            :                        /*id=*/this_identifier,
<span class="lineNum">   10350 </span><span class="lineCov">          2 :                        /*initializer=*/finish_this_expr (),</span>
<span class="lineNum">   10351 </span><span class="lineCov">          2 :                        /*by_reference_p=*/false,</span>
<span class="lineNum">   10352 </span>            :                        explicit_init_p);
<span class="lineNum">   10353 </span>            :           continue;
<span class="lineNum">   10354 </span><span class="lineCov">       3072 :         }</span>
<span class="lineNum">   10355 </span>            : 
<span class="lineNum">   10356 </span>            :       /* Remember whether we want to capture as a reference or not.  */
<span class="lineNum">   10357 </span><span class="lineCov">        576 :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_AND))</span>
<span class="lineNum">   10358 </span>            :         {
<span class="lineNum">   10359 </span>            :           capture_kind = BY_REFERENCE;
<span class="lineNum">   10360 </span><span class="lineCov">       3072 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   10361 </span>            :         }
<span class="lineNum">   10362 </span><span class="lineCov">       1662 : </span>
<span class="lineNum">   10363 </span><span class="lineCov">        831 :       /* Get the identifier.  */</span>
<span class="lineNum">   10364 </span><span class="lineCov">        831 :       capture_token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   10365 </span><span class="lineCov">         16 :       capture_id = cp_parser_identifier (parser);</span>
<span class="lineNum">   10366 </span>            : 
<span class="lineNum">   10367 </span><span class="lineCov">        831 :       if (capture_id == error_mark_node)</span>
<span class="lineNum">   10368 </span><span class="lineCov">        831 :         /* Would be nice to have a cp_parser_skip_to_closing_x for general</span>
<span class="lineNum">   10369 </span>            :            delimiters, but I modified this to stop on unnested ']' as well.  It
<span class="lineNum">   10370 </span>            :            was already changed to stop on unnested '}', so the
<span class="lineNum">   10371 </span>            :            &quot;closing_parenthesis&quot; name is no more misleading with my change.  */
<span class="lineNum">   10372 </span>            :         {
<span class="lineNum">   10373 </span><span class="lineCov">        930 :           cp_parser_skip_to_closing_parenthesis (parser,</span>
<span class="lineNum">   10374 </span>            :                                                  /*recovering=*/true,
<span class="lineNum">   10375 </span>            :                                                  /*or_comma=*/true,
<span class="lineNum">   10376 </span>            :                                                  /*consume_paren=*/true);
<span class="lineNum">   10377 </span><span class="lineCov">       4482 :           break;</span>
<span class="lineNum">   10378 </span><span class="lineCov">       2241 :         }</span>
<span class="lineNum">   10379 </span>            : 
<span class="lineNum">   10380 </span><span class="lineCov">        158 :       /* Find the initializer for this capture.  */</span>
<span class="lineNum">   10381 </span><span class="lineCov">         79 :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_EQ)</span>
<span class="lineNum">   10382 </span><span class="lineCov">         54 :           || cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_PAREN)</span>
<span class="lineNum">   10383 </span>            :           || cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_BRACE))
<span class="lineNum">   10384 </span><span class="lineCov">         79 :         {</span>
<span class="lineNum">   10385 </span><span class="lineCov">         79 :           bool direct, non_constant;</span>
<span class="lineNum">   10386 </span><span class="lineCov">         79 :           /* An explicit initializer exists.  */</span>
<span class="lineNum">   10387 </span>            :           if (cxx_dialect &lt; cxx14)
<span class="lineNum">   10388 </span>            :             pedwarn (input_location, 0,
<span class="lineNum">   10389 </span>            :                      &quot;lambda capture initializers &quot;
<span class="lineNum">   10390 </span>            :                      &quot;only available with -std=c++14 or -std=gnu++14&quot;);
<span class="lineNum">   10391 </span><span class="lineCov">         79 :           capture_init_expr = cp_parser_initializer (parser, &amp;direct,</span>
<span class="lineNum">   10392 </span>            :                                                      &amp;non_constant, true);
<span class="lineNum">   10393 </span>            :           explicit_init_p = true;
<span class="lineNum">   10394 </span>            :           if (capture_init_expr == NULL_TREE)
<span class="lineNum">   10395 </span><span class="lineCov">       2162 :             {</span>
<span class="lineNum">   10396 </span>            :               error (&quot;empty initializer for lambda init-capture&quot;);
<span class="lineNum">   10397 </span><span class="lineCov">       1106 :               capture_init_expr = error_mark_node;</span>
<span class="lineNum">   10398 </span><span class="lineCov">       1106 :             }</span>
<span class="lineNum">   10399 </span>            :         }
<span class="lineNum">   10400 </span>            :       else
<span class="lineNum">   10401 </span>            :         {
<span class="lineNum">   10402 </span><span class="lineCov">       4324 :           const char* error_msg;</span>
<span class="lineNum">   10403 </span><span class="lineCov">       2162 : </span>
<span class="lineNum">   10404 </span>            :           /* Turn the identifier into an id-expression.  */
<span class="lineNum">   10405 </span><span class="lineCov">       2162 :           capture_init_expr</span>
<span class="lineNum">   10406 </span>            :             = cp_parser_lookup_name_simple (parser, capture_id,
<span class="lineNum">   10407 </span>            :                                             capture_token-&gt;location);
<span class="lineNum">   10408 </span>            : 
<span class="lineNum">   10409 </span>            :           if (capture_init_expr == error_mark_node)
<span class="lineNum">   10410 </span>            :             {
<span class="lineNum">   10411 </span><span class="lineCov">          9 :               unqualified_name_lookup_error (capture_id);</span>
<span class="lineNum">   10412 </span>            :               continue;
<span class="lineNum">   10413 </span>            :             }
<span class="lineNum">   10414 </span>            :           else if (!VAR_P (capture_init_expr)
<span class="lineNum">   10415 </span><span class="lineCov">          9 :                    &amp;&amp; TREE_CODE (capture_init_expr) != PARM_DECL)</span>
<span class="lineNum">   10416 </span>            :             {
<span class="lineNum">   10417 </span>            :               error_at (capture_token-&gt;location,
<span class="lineNum">   10418 </span>            :                         &quot;capture of non-variable %qE&quot;,
<span class="lineNum">   10419 </span><span class="lineCov">       4306 :                         capture_init_expr);</span>
<span class="lineNum">   10420 </span><span class="lineCov">       2122 :               if (DECL_P (capture_init_expr))</span>
<span class="lineNum">   10421 </span><span class="lineCov">       4269 :                 inform (DECL_SOURCE_LOCATION (capture_init_expr),</span>
<span class="lineNum">   10422 </span>            :                         &quot;%q#D declared here&quot;, capture_init_expr);
<span class="lineNum">   10423 </span><span class="lineCov">         39 :               continue;</span>
<span class="lineNum">   10424 </span>            :             }
<span class="lineNum">   10425 </span><span class="lineCov">         39 :           if (VAR_P (capture_init_expr)</span>
<span class="lineNum">   10426 </span><span class="lineNoCov">          0 :               &amp;&amp; decl_storage_duration (capture_init_expr) != dk_auto)</span>
<span class="lineNum">   10427 </span>            :             {
<span class="lineNum">   10428 </span>            :               if (pedwarn (capture_token-&gt;location, 0, &quot;capture of variable &quot;
<span class="lineNum">   10429 </span><span class="lineCov">         39 :                            &quot;%qD with non-automatic storage duration&quot;,</span>
<span class="lineNum">   10430 </span>            :                            capture_init_expr))
<span class="lineNum">   10431 </span><span class="lineCov">         39 :                 inform (DECL_SOURCE_LOCATION (capture_init_expr),</span>
<span class="lineNum">   10432 </span><span class="lineCov">         39 :                         &quot;%q#D declared here&quot;, capture_init_expr);</span>
<span class="lineNum">   10433 </span>            :               continue;
<span class="lineNum">   10434 </span><span class="lineCov">          1 :             }</span>
<span class="lineNum">   10435 </span><span class="lineCov">          1 : </span>
<span class="lineNum">   10436 </span>            :           capture_init_expr
<span class="lineNum">   10437 </span>            :             = finish_id_expression
<span class="lineNum">   10438 </span>            :                 (capture_id,
<span class="lineNum">   10439 </span>            :                  capture_init_expr,
<span class="lineNum">   10440 </span><span class="lineCov">       2114 :                  parser-&gt;scope,</span>
<span class="lineNum">   10441 </span>            :                  &amp;idk,
<span class="lineNum">   10442 </span>            :                  /*integral_constant_expression_p=*/false,
<span class="lineNum">   10443 </span><span class="lineCov">       2114 :                  /*allow_non_integral_constant_expression_p=*/false,</span>
<span class="lineNum">   10444 </span><span class="lineCov">       4228 :                  /*non_integral_constant_expression_p=*/NULL,</span>
<span class="lineNum">   10445 </span>            :                  /*template_p=*/false,
<span class="lineNum">   10446 </span>            :                  /*done=*/true,
<span class="lineNum">   10447 </span><span class="lineCov">       2114 :                  /*address_p=*/false,</span>
<span class="lineNum">   10448 </span>            :                  /*template_arg_p=*/false,
<span class="lineNum">   10449 </span><span class="lineCov">          8 :                  &amp;error_msg,</span>
<span class="lineNum">   10450 </span><span class="lineCov">         20 :                  capture_token-&gt;location);</span>
<span class="lineNum">   10451 </span>            : 
<span class="lineNum">   10452 </span><span class="lineCov">       2106 :           if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_ELLIPSIS))</span>
<span class="lineNum">   10453 </span><span class="lineCov">        429 :             {</span>
<span class="lineNum">   10454 </span>            :               cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   10455 </span><span class="lineCov">         10 :               capture_init_expr = make_pack_expansion (capture_init_expr);</span>
<span class="lineNum">   10456 </span>            :             }
<span class="lineNum">   10457 </span>            :         }
<span class="lineNum">   10458 </span><span class="lineCov">         10 : </span>
<span class="lineNum">   10459 </span><span class="lineCov">          4 :       if (LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda_expr) != CPLD_NONE</span>
<span class="lineNum">   10460 </span>            :           &amp;&amp; !explicit_init_p)
<span class="lineNum">   10461 </span><span class="lineCov">         10 :         {</span>
<span class="lineNum">   10462 </span>            :           if (LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda_expr) == CPLD_COPY
<span class="lineNum">   10463 </span><span class="lineCov">       2096 :               &amp;&amp; capture_kind == BY_COPY)</span>
<span class="lineNum">   10464 </span><span class="lineCov">       2096 :             pedwarn (capture_token-&gt;location, 0, &quot;explicit by-copy capture &quot;</span>
<span class="lineNum">   10465 </span>            :                      &quot;of %qD redundant with by-copy capture default&quot;,
<span class="lineNum">   10466 </span><span class="lineCov">          2 :                      capture_id);</span>
<span class="lineNum">   10467 </span>            :           if (LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda_expr) == CPLD_REFERENCE
<span class="lineNum">   10468 </span>            :               &amp;&amp; capture_kind == BY_REFERENCE)
<span class="lineNum">   10469 </span><span class="lineCov">          2 :             pedwarn (capture_token-&gt;location, 0, &quot;explicit by-reference &quot;</span>
<span class="lineNum">   10470 </span>            :                      &quot;capture of %qD redundant with by-reference capture &quot;
<span class="lineNum">   10471 </span><span class="lineCov">          2 :                      &quot;default&quot;, capture_id);</span>
<span class="lineNum">   10472 </span>            :         }
<span class="lineNum">   10473 </span>            : 
<span class="lineNum">   10474 </span><span class="lineCov">       2094 :       add_capture (lambda_expr,</span>
<span class="lineNum">   10475 </span><span class="lineCov">       2094 :                    capture_id,</span>
<span class="lineNum">   10476 </span><span class="lineCov">       2094 :                    capture_init_expr,</span>
<span class="lineNum">   10477 </span>            :                    /*by_reference_p=*/capture_kind == BY_REFERENCE,
<span class="lineNum">   10478 </span>            :                    explicit_init_p);
<span class="lineNum">   10479 </span>            : 
<span class="lineNum">   10480 </span>            :       /* If there is any qualification still in effect, clear it
<span class="lineNum">   10481 </span>            :          now; we will be starting fresh with the next capture.  */
<span class="lineNum">   10482 </span>            :       parser-&gt;scope = NULL_TREE;
<span class="lineNum">   10483 </span>            :       parser-&gt;qualifying_scope = NULL_TREE;
<span class="lineNum">   10484 </span>            :       parser-&gt;object_scope = NULL_TREE;
<span class="lineNum">   10485 </span>            :     }
<span class="lineNum">   10486 </span>            : 
<span class="lineNum">   10487 </span>            :   cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);
<span class="lineNum">   10488 </span><span class="lineCov">       2094 : }</span>
<span class="lineNum">   10489 </span>            : 
<span class="lineNum">   10490 </span><span class="lineCov">       2094 : /* Parse the (optional) middle of a lambda expression.</span>
<span class="lineNum">   10491 </span>            : 
<span class="lineNum">   10492 </span><span class="lineCov">         12 :    lambda-declarator:</span>
<span class="lineNum">   10493 </span><span class="lineCov">         12 :      &lt; template-parameter-list [opt] &gt;</span>
<span class="lineNum">   10494 </span>            :      ( parameter-declaration-clause [opt] )
<span class="lineNum">   10495 </span>            :        attribute-specifier [opt]
<span class="lineNum">   10496 </span>            :        decl-specifier-seq [opt]
<span class="lineNum">   10497 </span><span class="lineCov">       2133 :        exception-specification [opt]</span>
<span class="lineNum">   10498 </span><span class="lineCov">       2133 :        lambda-return-type-clause [opt]</span>
<span class="lineNum">   10499 </span>            : 
<span class="lineNum">   10500 </span><span class="lineCov">         18 :    LAMBDA_EXPR is the current representation of the lambda expression.  */</span>
<a name="10501"><span class="lineNum">   10501 </span><span class="lineCov">         18 : </span></a>
<span class="lineNum">   10502 </span><span class="lineCov">          3 : static bool</span>
<span class="lineNum">   10503 </span>            : cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)
<span class="lineNum">   10504 </span>            : {
<span class="lineNum">   10505 </span><span class="lineCov">         18 :   /* 5.1.1.4 of the standard says:</span>
<span class="lineNum">   10506 </span><span class="lineCov">         18 :        If a lambda-expression does not include a lambda-declarator, it is as if</span>
<span class="lineNum">   10507 </span><span class="lineCov">          3 :        the lambda-declarator were ().</span>
<span class="lineNum">   10508 </span>            :      This means an empty parameter list, no attributes, and no exception
<span class="lineNum">   10509 </span>            :      specification.  */
<span class="lineNum">   10510 </span>            :   tree param_list = void_list_node;
<span class="lineNum">   10511 </span>            :   tree attributes = NULL_TREE;
<span class="lineNum">   10512 </span><span class="lineCov">       2133 :   tree exception_spec = NULL_TREE;</span>
<span class="lineNum">   10513 </span>            :   tree template_param_list = NULL_TREE;
<span class="lineNum">   10514 </span>            :   tree tx_qual = NULL_TREE;
<span class="lineNum">   10515 </span>            :   tree return_type = NULL_TREE;
<span class="lineNum">   10516 </span>            :   cp_decl_specifier_seq lambda_specs;
<span class="lineNum">   10517 </span>            :   clear_decl_specs (&amp;lambda_specs);
<span class="lineNum">   10518 </span>            : 
<span class="lineNum">   10519 </span>            :   /* The template-parameter-list is optional, but must begin with
<span class="lineNum">   10520 </span><span class="lineCov">       2133 :      an opening angle if present.  */</span>
<span class="lineNum">   10521 </span><span class="lineCov">       2133 :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_LESS))</span>
<span class="lineNum">   10522 </span><span class="lineCov">       2133 :     {</span>
<span class="lineNum">   10523 </span>            :       if (cxx_dialect &lt; cxx14)
<span class="lineNum">   10524 </span>            :         pedwarn (parser-&gt;lexer-&gt;next_token-&gt;location, 0,
<span class="lineNum">   10525 </span><span class="lineCov">       4758 :                  &quot;lambda templates are only available with &quot;</span>
<span class="lineNum">   10526 </span>            :                  &quot;-std=c++14 or -std=gnu++14&quot;);
<span class="lineNum">   10527 </span>            :       else if (cxx_dialect &lt; cxx2a)
<span class="lineNum">   10528 </span>            :         pedwarn (parser-&gt;lexer-&gt;next_token-&gt;location, OPT_Wpedantic,
<span class="lineNum">   10529 </span>            :                  &quot;lambda templates are only available with &quot;
<span class="lineNum">   10530 </span>            :                  &quot;-std=c++2a or -std=gnu++2a&quot;);
<span class="lineNum">   10531 </span>            : 
<span class="lineNum">   10532 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   10533 </span>            : 
<span class="lineNum">   10534 </span>            :       template_param_list = cp_parser_template_parameter_list (parser);
<span class="lineNum">   10535 </span>            : 
<span class="lineNum">   10536 </span>            :       cp_parser_skip_to_end_of_template_parameter_list (parser);
<span class="lineNum">   10537 </span>            : 
<span class="lineNum">   10538 </span>            :       /* We just processed one more parameter list.  */
<span class="lineNum">   10539 </span>            :       ++parser-&gt;num_template_parameter_lists;
<span class="lineNum">   10540 </span>            :     }
<span class="lineNum">   10541 </span><span class="lineCov">       4758 : </span>
<span class="lineNum">   10542 </span>            :   /* The parameter-declaration-clause is optional (unless
<span class="lineNum">   10543 </span>            :      template-parameter-list was given), but must begin with an
<span class="lineNum">   10544 </span>            :      opening parenthesis if present.  */
<span class="lineNum">   10545 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_PAREN))
<span class="lineNum">   10546 </span>            :     {
<span class="lineNum">   10547 </span>            :       matching_parens parens;
<span class="lineNum">   10548 </span><span class="lineCov">       4758 :       parens.consume_open (parser);</span>
<span class="lineNum">   10549 </span><span class="lineCov">       4758 : </span>
<span class="lineNum">   10550 </span><span class="lineCov">       4758 :       begin_scope (sk_function_parms, /*entity=*/NULL_TREE);</span>
<span class="lineNum">   10551 </span><span class="lineCov">       4758 : </span>
<span class="lineNum">   10552 </span><span class="lineCov">       4758 :       /* Parse parameters.  */</span>
<span class="lineNum">   10553 </span><span class="lineCov">       4758 :       param_list = cp_parser_parameter_declaration_clause (parser);</span>
<span class="lineNum">   10554 </span><span class="lineCov">       4758 : </span>
<span class="lineNum">   10555 </span><span class="lineCov">       9516 :       /* Default arguments shall not be specified in the</span>
<span class="lineNum">   10556 </span>            :          parameter-declaration-clause of a lambda-declarator.  */
<span class="lineNum">   10557 </span>            :       if (cxx_dialect &lt; cxx14)
<span class="lineNum">   10558 </span>            :         for (tree t = param_list; t; t = TREE_CHAIN (t))
<span class="lineNum">   10559 </span><span class="lineCov">       4758 :           if (TREE_PURPOSE (t) &amp;&amp; DECL_P (TREE_VALUE (t)))</span>
<span class="lineNum">   10560 </span>            :             pedwarn (DECL_SOURCE_LOCATION (TREE_VALUE (t)), OPT_Wpedantic,
<span class="lineNum">   10561 </span><span class="lineCov">         31 :                      &quot;default argument specified for lambda parameter&quot;);</span>
<span class="lineNum">   10562 </span><span class="lineCov">          6 : </span>
<span class="lineNum">   10563 </span>            :       parens.require_close (parser);
<span class="lineNum">   10564 </span>            : 
<span class="lineNum">   10565 </span><span class="lineCov">         25 :       attributes = cp_parser_attributes_opt (parser);</span>
<span class="lineNum">   10566 </span><span class="lineCov">         24 : </span>
<span class="lineNum">   10567 </span>            :       /* In the decl-specifier-seq of the lambda-declarator, each
<span class="lineNum">   10568 </span>            :          decl-specifier shall either be mutable or constexpr.  */
<span class="lineNum">   10569 </span>            :       int declares_class_or_enum;
<span class="lineNum">   10570 </span><span class="lineCov">         31 :       if (cp_lexer_next_token_is_decl_specifier_keyword (parser-&gt;lexer))</span>
<span class="lineNum">   10571 </span>            :         cp_parser_decl_specifier_seq (parser,
<span class="lineNum">   10572 </span><span class="lineCov">         31 :                                       CP_PARSER_FLAGS_ONLY_MUTABLE_OR_CONSTEXPR,</span>
<span class="lineNum">   10573 </span>            :                                       &amp;lambda_specs, &amp;declares_class_or_enum);
<span class="lineNum">   10574 </span><span class="lineCov">         31 :       if (lambda_specs.storage_class == sc_mutable)</span>
<span class="lineNum">   10575 </span>            :         {
<span class="lineNum">   10576 </span>            :           LAMBDA_EXPR_MUTABLE_P (lambda_expr) = 1;
<span class="lineNum">   10577 </span><span class="lineCov">         31 :           if (lambda_specs.conflicting_specifiers_p)</span>
<span class="lineNum">   10578 </span>            :             error_at (lambda_specs.locations[ds_storage_class],
<span class="lineNum">   10579 </span>            :                       &quot;duplicate %&lt;mutable%&gt;&quot;);
<span class="lineNum">   10580 </span>            :         }
<span class="lineNum">   10581 </span>            : 
<span class="lineNum">   10582 </span>            :       tx_qual = cp_parser_tx_qualifier_opt (parser);
<span class="lineNum">   10583 </span><span class="lineCov">       4758 : </span>
<span class="lineNum">   10584 </span>            :       /* Parse optional exception specification.  */
<span class="lineNum">   10585 </span><span class="lineCov">       6730 :       exception_spec = cp_parser_exception_specification_opt (parser);</span>
<span class="lineNum">   10586 </span><span class="lineCov">       3365 : </span>
<span class="lineNum">   10587 </span>            :       /* Parse optional trailing return type.  */
<span class="lineNum">   10588 </span><span class="lineCov">       3365 :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_DEREF))</span>
<span class="lineNum">   10589 </span>            :         {
<span class="lineNum">   10590 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   10591 </span><span class="lineCov">       3365 :           return_type = cp_parser_trailing_type_id (parser);</span>
<span class="lineNum">   10592 </span>            :         }
<span class="lineNum">   10593 </span>            : 
<span class="lineNum">   10594 </span>            :       /* The function parameters must be in scope all the way until after the
<span class="lineNum">   10595 </span><span class="lineCov">       3365 :          trailing-return-type in case of decltype.  */</span>
<span class="lineNum">   10596 </span><span class="lineCov">       1272 :       pop_bindings_and_leave_scope ();</span>
<span class="lineNum">   10597 </span><span class="lineCov">        784 :     }</span>
<span class="lineNum">   10598 </span><span class="lineCov">          2 :   else if (template_param_list != NULL_TREE) // generate diagnostic</span>
<span class="lineNum">   10599 </span>            :     cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);
<span class="lineNum">   10600 </span>            : 
<span class="lineNum">   10601 </span><span class="lineCov">       3365 :   /* Create the function call operator.</span>
<span class="lineNum">   10602 </span>            : 
<span class="lineNum">   10603 </span><span class="lineCov">       3365 :      Messing with declarators like this is no uglier than building up the</span>
<span class="lineNum">   10604 </span>            :      FUNCTION_DECL by hand, and this is less likely to get out of sync with
<span class="lineNum">   10605 </span>            :      other code.  */
<span class="lineNum">   10606 </span>            :   {
<span class="lineNum">   10607 </span><span class="lineCov">       3365 :     cp_decl_specifier_seq return_type_specs;</span>
<span class="lineNum">   10608 </span><span class="lineCov">       3365 :     cp_declarator* declarator;</span>
<span class="lineNum">   10609 </span><span class="lineCov">         70 :     tree fco;</span>
<span class="lineNum">   10610 </span>            :     int quals;
<span class="lineNum">   10611 </span>            :     void *p;
<span class="lineNum">   10612 </span><span class="lineCov">       3365 : </span>
<span class="lineNum">   10613 </span>            :     clear_decl_specs (&amp;return_type_specs);
<span class="lineNum">   10614 </span><span class="lineCov">         56 :     return_type_specs.type = make_auto ();</span>
<span class="lineNum">   10615 </span><span class="lineCov">         56 : </span>
<span class="lineNum">   10616 </span><span class="lineCov">          1 :     if (lambda_specs.locations[ds_constexpr])</span>
<span class="lineNum">   10617 </span>            :       {
<span class="lineNum">   10618 </span>            :         if (cxx_dialect &gt;= cxx17)
<span class="lineNum">   10619 </span>            :           return_type_specs.locations[ds_constexpr]
<span class="lineNum">   10620 </span><span class="lineCov">       3365 :             = lambda_specs.locations[ds_constexpr];</span>
<span class="lineNum">   10621 </span>            :         else
<span class="lineNum">   10622 </span>            :           error_at (lambda_specs.locations[ds_constexpr], &quot;%&lt;constexpr%&gt; &quot;
<span class="lineNum">   10623 </span><span class="lineCov">       3365 :                     &quot;lambda only available with -std=c++17 or -std=gnu++17&quot;);</span>
<span class="lineNum">   10624 </span>            :       }
<span class="lineNum">   10625 </span>            : 
<span class="lineNum">   10626 </span><span class="lineCov">       3365 :     p = obstack_alloc (&amp;declarator_obstack, 0);</span>
<span class="lineNum">   10627 </span>            : 
<span class="lineNum">   10628 </span><span class="lineCov">        457 :     declarator = make_id_declarator (NULL_TREE, call_op_identifier, sfk_none);</span>
<span class="lineNum">   10629 </span><span class="lineCov">        914 : </span>
<span class="lineNum">   10630 </span>            :     quals = (LAMBDA_EXPR_MUTABLE_P (lambda_expr)
<span class="lineNum">   10631 </span>            :              ? TYPE_UNQUALIFIED : TYPE_QUAL_CONST);
<span class="lineNum">   10632 </span>            :     declarator = make_call_declarator (declarator, param_list, quals,
<span class="lineNum">   10633 </span>            :                                        VIRT_SPEC_UNSPECIFIED,
<span class="lineNum">   10634 </span><span class="lineCov">       3365 :                                        REF_QUAL_NONE,</span>
<span class="lineNum">   10635 </span>            :                                        tx_qual,
<span class="lineNum">   10636 </span><span class="lineCov">       1393 :                                        exception_spec,</span>
<span class="lineNum">   10637 </span><span class="lineNoCov">          0 :                                        /*late_return_type=*/NULL_TREE,</span>
<span class="lineNum">   10638 </span>            :                                        /*requires_clause*/NULL_TREE);
<span class="lineNum">   10639 </span>            :     declarator-&gt;id_loc = LAMBDA_EXPR_LOCATION (lambda_expr);
<span class="lineNum">   10640 </span>            :     if (return_type)
<span class="lineNum">   10641 </span>            :       declarator-&gt;u.function.late_return_type = return_type;
<span class="lineNum">   10642 </span>            : 
<span class="lineNum">   10643 </span>            :     fco = grokmethod (&amp;return_type_specs,
<span class="lineNum">   10644 </span><span class="lineCov">       4758 :                       declarator,</span>
<span class="lineNum">   10645 </span><span class="lineCov">       4758 :                       attributes);</span>
<span class="lineNum">   10646 </span><span class="lineCov">       4758 :     if (fco != error_mark_node)</span>
<span class="lineNum">   10647 </span><span class="lineCov">       4758 :       {</span>
<span class="lineNum">   10648 </span><span class="lineCov">       4758 :         DECL_INITIALIZED_IN_CLASS_P (fco) = 1;</span>
<span class="lineNum">   10649 </span><span class="lineCov">       4758 :         DECL_ARTIFICIAL (fco) = 1;</span>
<span class="lineNum">   10650 </span>            :         /* Give the object parameter a different name.  */
<span class="lineNum">   10651 </span><span class="lineCov">       9516 :         DECL_NAME (DECL_ARGUMENTS (fco)) = closure_identifier;</span>
<span class="lineNum">   10652 </span><span class="lineCov">       4758 :       }</span>
<span class="lineNum">   10653 </span>            :     if (template_param_list)
<span class="lineNum">   10654 </span><span class="lineCov">       4758 :       {</span>
<span class="lineNum">   10655 </span>            :         fco = finish_member_template_decl (fco);
<span class="lineNum">   10656 </span><span class="lineCov">         10 :         finish_template_decl (template_param_list);</span>
<span class="lineNum">   10657 </span><span class="lineCov">          9 :         --parser-&gt;num_template_parameter_lists;</span>
<span class="lineNum">   10658 </span><span class="lineCov">          9 :       }</span>
<span class="lineNum">   10659 </span>            :     else if (parser-&gt;fully_implicit_function_template_p)
<span class="lineNum">   10660 </span><span class="lineCov">          1 :       fco = finish_fully_implicit_template (parser, fco);</span>
<span class="lineNum">   10661 </span>            : 
<span class="lineNum">   10662 </span>            :     finish_member_declaration (fco);
<span class="lineNum">   10663 </span>            : 
<span class="lineNum">   10664 </span><span class="lineCov">       4758 :     obstack_free (&amp;declarator_obstack, p);</span>
<span class="lineNum">   10665 </span>            : 
<span class="lineNum">   10666 </span><span class="lineCov">       4758 :     return (fco != error_mark_node);</span>
<span class="lineNum">   10667 </span>            :   }
<span class="lineNum">   10668 </span><span class="lineCov">       4758 : }</span>
<span class="lineNum">   10669 </span><span class="lineCov">       4758 : </span>
<span class="lineNum">   10670 </span><span class="lineCov">       4758 : /* Parse the body of a lambda expression, which is simply</span>
<span class="lineNum">   10671 </span>            : 
<span class="lineNum">   10672 </span>            :    compound-statement
<span class="lineNum">   10673 </span>            : 
<span class="lineNum">   10674 </span>            :    but which requires special handling.
<span class="lineNum">   10675 </span>            :    LAMBDA_EXPR is the current representation of the lambda expression.  */
<a name="10676"><span class="lineNum">   10676 </span>            : </a>
<span class="lineNum">   10677 </span><span class="lineCov">       4758 : static void</span>
<span class="lineNum">   10678 </span><span class="lineCov">       4758 : cp_parser_lambda_body (cp_parser* parser, tree lambda_expr)</span>
<span class="lineNum">   10679 </span><span class="lineCov">        457 : {</span>
<span class="lineNum">   10680 </span>            :   bool nested = (current_function_decl != NULL_TREE);
<span class="lineNum">   10681 </span><span class="lineCov">       4758 :   bool local_variables_forbidden_p = parser-&gt;local_variables_forbidden_p;</span>
<span class="lineNum">   10682 </span>            :   bool in_function_body = parser-&gt;in_function_body;
<span class="lineNum">   10683 </span>            : 
<span class="lineNum">   10684 </span><span class="lineCov">       4758 :   if (nested)</span>
<span class="lineNum">   10685 </span>            :     push_function_context ();
<span class="lineNum">   10686 </span><span class="lineCov">       9510 :   else</span>
<span class="lineNum">   10687 </span><span class="lineCov">       4755 :     /* Still increment function_depth so that we don't GC in the</span>
<span class="lineNum">   10688 </span>            :        middle of an expression.  */
<span class="lineNum">   10689 </span><span class="lineCov">       4755 :     ++function_depth;</span>
<span class="lineNum">   10690 </span>            : 
<span class="lineNum">   10691 </span><span class="lineCov">       4758 :   vec&lt;tree&gt; omp_privatization_save;</span>
<span class="lineNum">   10692 </span>            :   save_omp_privatization_clauses (omp_privatization_save);
<span class="lineNum">   10693 </span><span class="lineCov">         31 :   /* Clear this in case we're in the middle of a default argument.  */</span>
<span class="lineNum">   10694 </span><span class="lineCov">         31 :   parser-&gt;local_variables_forbidden_p = false;</span>
<span class="lineNum">   10695 </span><span class="lineCov">         31 :   parser-&gt;in_function_body = true;</span>
<span class="lineNum">   10696 </span>            : 
<span class="lineNum">   10697 </span><span class="lineCov">       4727 :   {</span>
<span class="lineNum">   10698 </span><span class="lineCov">        215 :     local_specialization_stack s (lss_copy);</span>
<span class="lineNum">   10699 </span>            :     tree fco = lambda_function (lambda_expr);
<span class="lineNum">   10700 </span><span class="lineCov">       4758 :     tree body = start_lambda_function (fco, lambda_expr);</span>
<span class="lineNum">   10701 </span>            :     matching_braces braces;
<span class="lineNum">   10702 </span><span class="lineCov">       4758 : </span>
<span class="lineNum">   10703 </span>            :     if (braces.require_open (parser))
<span class="lineNum">   10704 </span><span class="lineCov">       4758 :       {</span>
<span class="lineNum">   10705 </span>            :         tree compound_stmt = begin_compound_stmt (0);
<span class="lineNum">   10706 </span>            : 
<span class="lineNum">   10707 </span>            :         /* Originally C++11 required us to peek for 'return expr'; and
<span class="lineNum">   10708 </span>            :            process it specially here to deduce the return type.  N3638
<span class="lineNum">   10709 </span>            :            removed the need for that.  */
<span class="lineNum">   10710 </span>            : 
<span class="lineNum">   10711 </span>            :         while (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_LABEL))
<span class="lineNum">   10712 </span>            :           cp_parser_label_declaration (parser);
<span class="lineNum">   10713 </span>            :         cp_parser_statement_seq_opt (parser, NULL_TREE);
<span class="lineNum">   10714 </span>            :         braces.require_close (parser);
<span class="lineNum">   10715 </span>            : 
<span class="lineNum">   10716 </span><span class="lineCov">       4737 :         finish_compound_stmt (compound_stmt);</span>
<span class="lineNum">   10717 </span>            :       }
<span class="lineNum">   10718 </span><span class="lineCov">       4737 : </span>
<span class="lineNum">   10719 </span><span class="lineCov">       4737 :     finish_lambda_function (body);</span>
<span class="lineNum">   10720 </span><span class="lineCov">       4737 :   }</span>
<span class="lineNum">   10721 </span>            : 
<span class="lineNum">   10722 </span><span class="lineCov">       4737 :   restore_omp_privatization_clauses (omp_privatization_save);</span>
<span class="lineNum">   10723 </span><span class="lineCov">       4494 :   parser-&gt;local_variables_forbidden_p = local_variables_forbidden_p;</span>
<span class="lineNum">   10724 </span>            :   parser-&gt;in_function_body = in_function_body;
<span class="lineNum">   10725 </span>            :   if (nested)
<span class="lineNum">   10726 </span>            :     pop_function_context();
<span class="lineNum">   10727 </span><span class="lineCov">        243 :   else</span>
<span class="lineNum">   10728 </span>            :     --function_depth;
<span class="lineNum">   10729 </span><span class="lineCov">       4737 : }</span>
<span class="lineNum">   10730 </span><span class="lineCov">       4737 : </span>
<span class="lineNum">   10731 </span>            : /* Statements [gram.stmt.stmt]  */
<span class="lineNum">   10732 </span><span class="lineCov">       4737 : </span>
<span class="lineNum">   10733 </span><span class="lineCov">       4737 : /* Build and add a DEBUG_BEGIN_STMT statement with location LOC.  */</span>
<a name="10734"><span class="lineNum">   10734 </span>            : </a>
<span class="lineNum">   10735 </span><span class="lineCov">       4737 : static void</span>
<span class="lineNum">   10736 </span><span class="lineCov">       9474 : add_debug_begin_stmt (location_t loc)</span>
<span class="lineNum">   10737 </span><span class="lineCov">       4737 : {</span>
<span class="lineNum">   10738 </span><span class="lineCov">       4737 :   if (!MAY_HAVE_DEBUG_MARKER_STMTS)</span>
<span class="lineNum">   10739 </span><span class="lineCov">       9474 :     return;</span>
<span class="lineNum">   10740 </span>            :   if (DECL_DECLARED_CONCEPT_P (current_function_decl))
<span class="lineNum">   10741 </span><span class="lineCov">       4737 :     /* A concept is never expanded normally.  */</span>
<span class="lineNum">   10742 </span>            :     return;
<span class="lineNum">   10743 </span><span class="lineCov">       4734 : </span>
<span class="lineNum">   10744 </span>            :   tree stmt = build0 (DEBUG_BEGIN_STMT, void_type_node);
<span class="lineNum">   10745 </span>            :   SET_EXPR_LOCATION (stmt, loc);
<span class="lineNum">   10746 </span>            :   add_stmt (stmt);
<span class="lineNum">   10747 </span>            : }
<span class="lineNum">   10748 </span>            : 
<span class="lineNum">   10749 </span><span class="lineCov">       4734 : /* Parse a statement.</span>
<span class="lineNum">   10750 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10751 </span><span class="lineCov">       4734 :    statement:</span>
<span class="lineNum">   10752 </span><span class="lineCov">       4734 :      labeled-statement</span>
<span class="lineNum">   10753 </span>            :      expression-statement
<span class="lineNum">   10754 </span><span class="lineCov">       4734 :      compound-statement</span>
<span class="lineNum">   10755 </span>            :      selection-statement
<span class="lineNum">   10756 </span>            :      iteration-statement
<span class="lineNum">   10757 </span><span class="lineCov">       4737 :      jump-statement</span>
<span class="lineNum">   10758 </span>            :      declaration-statement
<span class="lineNum">   10759 </span>            :      try-block
<span class="lineNum">   10760 </span><span class="lineCov">       4737 : </span>
<span class="lineNum">   10761 </span><span class="lineCov">       4737 :   C++11:</span>
<span class="lineNum">   10762 </span><span class="lineCov">       4737 : </span>
<span class="lineNum">   10763 </span><span class="lineCov">       4737 :   statement:</span>
<span class="lineNum">   10764 </span><span class="lineCov">       4494 :     labeled-statement</span>
<span class="lineNum">   10765 </span>            :     attribute-specifier-seq (opt) expression-statement
<span class="lineNum">   10766 </span><span class="lineCov">        243 :     attribute-specifier-seq (opt) compound-statement</span>
<span class="lineNum">   10767 </span><span class="lineCov">       4737 :     attribute-specifier-seq (opt) selection-statement</span>
<span class="lineNum">   10768 </span>            :     attribute-specifier-seq (opt) iteration-statement
<span class="lineNum">   10769 </span>            :     attribute-specifier-seq (opt) jump-statement
<span class="lineNum">   10770 </span>            :     declaration-statement
<span class="lineNum">   10771 </span>            :     attribute-specifier-seq (opt) try-block
<span class="lineNum">   10772 </span>            : 
<span class="lineNum">   10773 </span>            :   init-statement:
<span class="lineNum">   10774 </span><span class="lineCov">   13955614 :     expression-statement</span>
<span class="lineNum">   10775 </span>            :     simple-declaration
<span class="lineNum">   10776 </span><span class="lineCov">   13955614 : </span>
<span class="lineNum">   10777 </span>            :   TM Extension:
<span class="lineNum">   10778 </span><span class="lineCov">   10076116 : </span>
<span class="lineNum">   10779 </span>            :    statement:
<span class="lineNum">   10780 </span>            :      atomic-statement
<span class="lineNum">   10781 </span>            : 
<span class="lineNum">   10782 </span><span class="lineCov">   10076115 :   IN_COMPOUND is true when the statement is nested inside a</span>
<span class="lineNum">   10783 </span><span class="lineCov">   10076115 :   cp_parser_compound_statement; this matters for certain pragmas.</span>
<span class="lineNum">   10784 </span><span class="lineCov">   10076115 : </span>
<span class="lineNum">   10785 </span>            :   If IF_P is not NULL, *IF_P is set to indicate whether the statement
<span class="lineNum">   10786 </span>            :   is a (possibly labeled) if statement which is not enclosed in braces
<span class="lineNum">   10787 </span>            :   and has an else clause.  This is used to implement -Wparentheses.
<span class="lineNum">   10788 </span>            : 
<span class="lineNum">   10789 </span>            :   CHAIN is a vector of if-else-if conditions.  */
<a name="10790"><span class="lineNum">   10790 </span>            : </a>
<span class="lineNum">   10791 </span>            : static void
<span class="lineNum">   10792 </span>            : cp_parser_statement (cp_parser* parser, tree in_statement_expr,
<span class="lineNum">   10793 </span>            :                      bool in_compound, bool *if_p, vec&lt;tree&gt; *chain,
<span class="lineNum">   10794 </span>            :                      location_t *loc_after_labels)
<span class="lineNum">   10795 </span>            : {
<span class="lineNum">   10796 </span>            :   tree statement, std_attrs = NULL_TREE;
<span class="lineNum">   10797 </span>            :   cp_token *token;
<span class="lineNum">   10798 </span>            :   location_t statement_location, attrs_location;
<span class="lineNum">   10799 </span>            : 
<span class="lineNum">   10800 </span>            :  restart:
<span class="lineNum">   10801 </span>            :   if (if_p != NULL)
<span class="lineNum">   10802 </span>            :     *if_p = false;
<span class="lineNum">   10803 </span>            :   /* There is no statement yet.  */
<span class="lineNum">   10804 </span>            :   statement = NULL_TREE;
<span class="lineNum">   10805 </span>            : 
<span class="lineNum">   10806 </span>            :   saved_token_sentinel saved_tokens (parser-&gt;lexer);
<span class="lineNum">   10807 </span>            :   attrs_location = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">   10808 </span>            :   if (c_dialect_objc ())
<span class="lineNum">   10809 </span>            :     /* In obj-c++, seeing '[[' might be the either the beginning of
<span class="lineNum">   10810 </span>            :        c++11 attributes, or a nested objc-message-expression.  So
<span class="lineNum">   10811 </span>            :        let's parse the c++11 attributes tentatively.  */
<span class="lineNum">   10812 </span>            :     cp_parser_parse_tentatively (parser);
<span class="lineNum">   10813 </span>            :   std_attrs = cp_parser_std_attribute_spec_seq (parser);
<span class="lineNum">   10814 </span>            :   if (c_dialect_objc ())
<span class="lineNum">   10815 </span>            :     {
<span class="lineNum">   10816 </span>            :       if (!cp_parser_parse_definitely (parser))
<span class="lineNum">   10817 </span>            :         std_attrs = NULL_TREE;
<span class="lineNum">   10818 </span>            :     }
<span class="lineNum">   10819 </span>            : 
<span class="lineNum">   10820 </span>            :   /* Peek at the next token.  */
<span class="lineNum">   10821 </span>            :   token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   10822 </span>            :   /* Remember the location of the first token in the statement.  */
<span class="lineNum">   10823 </span>            :   statement_location = token-&gt;location;
<span class="lineNum">   10824 </span>            :   add_debug_begin_stmt (statement_location);
<span class="lineNum">   10825 </span>            :   /* If this is a keyword, then that will often determine what kind of
<span class="lineNum">   10826 </span>            :      statement we have.  */
<span class="lineNum">   10827 </span>            :   if (token-&gt;type == CPP_KEYWORD)
<span class="lineNum">   10828 </span>            :     {
<span class="lineNum">   10829 </span>            :       enum rid keyword = token-&gt;keyword;
<span class="lineNum">   10830 </span><span class="lineCov">   13876414 : </span>
<span class="lineNum">   10831 </span>            :       switch (keyword)
<span class="lineNum">   10832 </span>            :         {
<span class="lineNum">   10833 </span>            :         case RID_CASE:
<span class="lineNum">   10834 </span><span class="lineCov">   13876414 :         case RID_DEFAULT:</span>
<span class="lineNum">   10835 </span><span class="lineCov">   13955614 :           /* Looks like a labeled-statement with a case label.</span>
<span class="lineNum">   10836 </span><span class="lineCov">   13955614 :              Parse the label, and then use tail recursion to parse</span>
<span class="lineNum">   10837 </span>            :              the statement.  */
<span class="lineNum">   10838 </span><span class="lineCov">   27911228 :           cp_parser_label_for_labeled_statement (parser, std_attrs);</span>
<span class="lineNum">   10839 </span><span class="lineCov">   13955614 :           in_compound = false;</span>
<span class="lineNum">   10840 </span><span class="lineCov">    1126241 :           goto restart;</span>
<span class="lineNum">   10841 </span>            : 
<span class="lineNum">   10842 </span><span class="lineCov">   13955614 :         case RID_IF:</span>
<span class="lineNum">   10843 </span>            :         case RID_SWITCH:
<span class="lineNum">   10844 </span><span class="lineCov">   25499790 :           statement = cp_parser_selection_statement (parser, if_p, chain);</span>
<span class="lineNum">   10845 </span><span class="lineCov">   27911228 :           break;</span>
<span class="lineNum">   10846 </span><span class="lineCov">   13955614 : </span>
<span class="lineNum">   10847 </span>            :         case RID_WHILE:
<span class="lineNum">   10848 </span>            :         case RID_DO:
<span class="lineNum">   10849 </span>            :         case RID_FOR:
<span class="lineNum">   10850 </span><span class="lineNoCov">          0 :           statement = cp_parser_iteration_statement (parser, if_p, false, 0);</span>
<span class="lineNum">   10851 </span><span class="lineCov">   13955614 :           break;</span>
<span class="lineNum">   10852 </span><span class="lineCov">   13955614 : </span>
<span class="lineNum">   10853 </span>            :         case RID_BREAK:
<span class="lineNum">   10854 </span><span class="lineNoCov">          0 :         case RID_CONTINUE:</span>
<span class="lineNum">   10855 </span><span class="lineNoCov">          0 :         case RID_RETURN:</span>
<span class="lineNum">   10856 </span>            :         case RID_GOTO:
<span class="lineNum">   10857 </span>            :           statement = cp_parser_jump_statement (parser);
<span class="lineNum">   10858 </span>            :           break;
<span class="lineNum">   10859 </span><span class="lineCov">   27911228 : </span>
<span class="lineNum">   10860 </span>            :           /* Objective-C++ exception-handling constructs.  */
<span class="lineNum">   10861 </span><span class="lineCov">   13955614 :         case RID_AT_TRY:</span>
<span class="lineNum">   10862 </span><span class="lineCov">   13955614 :         case RID_AT_CATCH:</span>
<span class="lineNum">   10863 </span>            :         case RID_AT_FINALLY:
<span class="lineNum">   10864 </span>            :         case RID_AT_SYNCHRONIZED:
<span class="lineNum">   10865 </span><span class="lineCov">   13955614 :         case RID_AT_THROW:</span>
<span class="lineNum">   10866 </span>            :           statement = cp_parser_objc_statement (parser);
<span class="lineNum">   10867 </span><span class="lineCov">    8643397 :           break;</span>
<span class="lineNum">   10868 </span>            : 
<span class="lineNum">   10869 </span><span class="lineCov">    8643397 :         case RID_TRY:</span>
<span class="lineNum">   10870 </span>            :           statement = cp_parser_try_block (parser);
<span class="lineNum">   10871 </span><span class="lineCov">      77839 :           break;</span>
<span class="lineNum">   10872 </span><span class="lineCov">      77839 : </span>
<span class="lineNum">   10873 </span>            :         case RID_NAMESPACE:
<span class="lineNum">   10874 </span>            :           /* This must be a namespace alias definition.  */
<span class="lineNum">   10875 </span>            :           cp_parser_declaration_statement (parser);
<span class="lineNum">   10876 </span><span class="lineCov">      77839 :           return;</span>
<span class="lineNum">   10877 </span><span class="lineCov">      77839 :           </span>
<span class="lineNum">   10878 </span><span class="lineCov">      79200 :         case RID_TRANSACTION_ATOMIC:</span>
<span class="lineNum">   10879 </span>            :         case RID_TRANSACTION_RELAXED:
<span class="lineNum">   10880 </span><span class="lineCov">    1656162 :         case RID_SYNCHRONIZED:</span>
<span class="lineNum">   10881 </span><span class="lineCov">    1656162 :         case RID_ATOMIC_NOEXCEPT:</span>
<span class="lineNum">   10882 </span><span class="lineCov">    1656162 :         case RID_ATOMIC_CANCEL:</span>
<span class="lineNum">   10883 </span><span class="lineCov">    1656162 :           statement = cp_parser_transaction (parser, token);</span>
<span class="lineNum">   10884 </span>            :           break;
<span class="lineNum">   10885 </span><span class="lineCov">     460809 :         case RID_TRANSACTION_CANCEL:</span>
<span class="lineNum">   10886 </span><span class="lineCov">     460809 :           statement = cp_parser_transaction_cancel (parser);</span>
<span class="lineNum">   10887 </span><span class="lineCov">     460809 :           break;</span>
<span class="lineNum">   10888 </span><span class="lineCov">     460809 : </span>
<span class="lineNum">   10889 </span><span class="lineCov">     460809 :         default:</span>
<span class="lineNum">   10890 </span>            :           /* It might be a keyword like `int' that can start a
<span class="lineNum">   10891 </span><span class="lineCov">    4590586 :              declaration-statement.  */</span>
<span class="lineNum">   10892 </span><span class="lineCov">    4590586 :           break;</span>
<span class="lineNum">   10893 </span><span class="lineCov">    4590586 :         }</span>
<span class="lineNum">   10894 </span><span class="lineCov">    4590586 :     }</span>
<span class="lineNum">   10895 </span><span class="lineCov">    4590586 :   else if (token-&gt;type == CPP_NAME)</span>
<span class="lineNum">   10896 </span><span class="lineCov">    4590586 :     {</span>
<span class="lineNum">   10897 </span>            :       /* If the next token is a `:', then we are looking at a
<span class="lineNum">   10898 </span>            :          labeled-statement.  */
<span class="lineNum">   10899 </span><span class="lineNoCov">          0 :       token = cp_lexer_peek_nth_token (parser-&gt;lexer, 2);</span>
<span class="lineNum">   10900 </span><span class="lineNoCov">          0 :       if (token-&gt;type == CPP_COLON)</span>
<span class="lineNum">   10901 </span><span class="lineNoCov">          0 :         {</span>
<span class="lineNum">   10902 </span><span class="lineNoCov">          0 :           /* Looks like a labeled-statement with an ordinary label.</span>
<span class="lineNum">   10903 </span><span class="lineNoCov">          0 :              Parse the label, and then use tail recursion to parse</span>
<span class="lineNum">   10904 </span><span class="lineNoCov">          0 :              the statement.  */</span>
<span class="lineNum">   10905 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   10906 </span>            :           cp_parser_label_for_labeled_statement (parser, std_attrs);
<span class="lineNum">   10907 </span><span class="lineCov">      84398 :           in_compound = false;</span>
<span class="lineNum">   10908 </span><span class="lineCov">      84398 :           goto restart;</span>
<span class="lineNum">   10909 </span><span class="lineCov">      84398 :         }</span>
<span class="lineNum">   10910 </span>            :     }
<span class="lineNum">   10911 </span><span class="lineCov">         42 :   /* Anything that starts with a `{' must be a compound-statement.  */</span>
<span class="lineNum">   10912 </span>            :   else if (token-&gt;type == CPP_OPEN_BRACE)
<span class="lineNum">   10913 </span><span class="lineCov">         42 :     statement = cp_parser_compound_statement (parser, NULL, BCS_NORMAL, false);</span>
<span class="lineNum">   10914 </span><span class="lineCov">    2332219 :   /* CPP_PRAGMA is a #pragma inside a function body, which constitutes</span>
<span class="lineNum">   10915 </span>            :      a statement all its own.  */
<span class="lineNum">   10916 </span><span class="lineCov">        222 :   else if (token-&gt;type == CPP_PRAGMA)</span>
<span class="lineNum">   10917 </span><span class="lineCov">        222 :     {</span>
<span class="lineNum">   10918 </span><span class="lineCov">        222 :       /* Only certain OpenMP pragmas are attached to statements, and thus</span>
<span class="lineNum">   10919 </span><span class="lineCov">        222 :          are considered statements themselves.  All others are not.  In</span>
<span class="lineNum">   10920 </span><span class="lineCov">        222 :          the context of a compound, accept the pragma as a &quot;statement&quot; and</span>
<span class="lineNum">   10921 </span><span class="lineCov">        222 :          return so that we can check for a close brace.  Otherwise we</span>
<span class="lineNum">   10922 </span><span class="lineCov">        222 :          require a real statement and must go back and read one.  */</span>
<span class="lineNum">   10923 </span><span class="lineCov">         12 :       if (in_compound)</span>
<span class="lineNum">   10924 </span><span class="lineCov">         12 :         cp_parser_pragma (parser, pragma_compound, if_p);</span>
<span class="lineNum">   10925 </span><span class="lineCov">         12 :       else if (!cp_parser_pragma (parser, pragma_stmt, if_p))</span>
<span class="lineNum">   10926 </span>            :         goto restart;
<span class="lineNum">   10927 </span>            :       return;
<span class="lineNum">   10928 </span>            :     }
<span class="lineNum">   10929 </span>            :   else if (token-&gt;type == CPP_EOF)
<span class="lineNum">   10930 </span>            :     {
<span class="lineNum">   10931 </span>            :       cp_parser_error (parser, &quot;expected statement&quot;);
<span class="lineNum">   10932 </span>            :       return;
<span class="lineNum">   10933 </span><span class="lineCov">    5312217 :     }</span>
<span class="lineNum">   10934 </span>            : 
<span class="lineNum">   10935 </span>            :   /* Everything else must be a declaration-statement or an
<span class="lineNum">   10936 </span>            :      expression-statement.  Try for the declaration-statement
<span class="lineNum">   10937 </span><span class="lineCov">    4368424 :      first, unless we are looking at a `;', in which case we know that</span>
<span class="lineNum">   10938 </span><span class="lineCov">    4368424 :      we have an expression-statement.  */</span>
<span class="lineNum">   10939 </span>            :   if (!statement)
<span class="lineNum">   10940 </span>            :     {
<span class="lineNum">   10941 </span>            :       if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_SEMICOLON))
<span class="lineNum">   10942 </span>            :         {
<span class="lineNum">   10943 </span>            :           if (std_attrs != NULL_TREE)
<span class="lineNum">   10944 </span><span class="lineCov">       1040 :             {</span>
<span class="lineNum">   10945 </span><span class="lineCov">       1040 :               /*  Attributes should be parsed as part of the the</span>
<span class="lineNum">   10946 </span><span class="lineCov">       1040 :                   declaration, so let's un-parse them.  */</span>
<span class="lineNum">   10947 </span>            :               saved_tokens.rollback();
<span class="lineNum">   10948 </span>            :               std_attrs = NULL_TREE;
<span class="lineNum">   10949 </span>            :             }
<span class="lineNum">   10950 </span><span class="lineCov">     943793 : </span>
<span class="lineNum">   10951 </span><span class="lineCov">      14425 :           cp_parser_parse_tentatively (parser);</span>
<span class="lineNum">   10952 </span>            :           /* Try to parse the declaration-statement.  */
<span class="lineNum">   10953 </span>            :           cp_parser_declaration_statement (parser);
<span class="lineNum">   10954 </span><span class="lineCov">     929368 :           /* If that worked, we're done.  */</span>
<span class="lineNum">   10955 </span>            :           if (cp_parser_parse_definitely (parser))
<span class="lineNum">   10956 </span>            :             return;
<span class="lineNum">   10957 </span>            :         }
<span class="lineNum">   10958 </span>            :       /* All preceding labels have been parsed at this point.  */
<span class="lineNum">   10959 </span>            :       if (loc_after_labels != NULL)
<span class="lineNum">   10960 </span>            :         *loc_after_labels = statement_location;
<span class="lineNum">   10961 </span><span class="lineCov">      20555 : </span>
<span class="lineNum">   10962 </span><span class="lineCov">      18372 :       /* Look for an expression-statement instead.  */</span>
<span class="lineNum">   10963 </span><span class="lineCov">       2183 :       statement = cp_parser_expression_statement (parser, in_statement_expr);</span>
<span class="lineNum">   10964 </span>            : 
<span class="lineNum">   10965 </span><span class="lineCov">      20234 :       /* Handle [[fallthrough]];.  */</span>
<span class="lineNum">   10966 </span>            :       if (attribute_fallthrough_p (std_attrs))
<span class="lineNum">   10967 </span><span class="lineCov">     908813 :         {</span>
<span class="lineNum">   10968 </span>            :           /* The next token after the fallthrough attribute is ';'.  */
<span class="lineNum">   10969 </span><span class="lineCov">          6 :           if (statement == NULL_TREE)</span>
<span class="lineNum">   10970 </span><span class="lineCov">          6 :             {</span>
<span class="lineNum">   10971 </span>            :               /* Turn [[fallthrough]]; into FALLTHROUGH ();.  */
<span class="lineNum">   10972 </span>            :               statement = build_call_expr_internal_loc (statement_location,
<span class="lineNum">   10973 </span>            :                                                         IFN_FALLTHROUGH,
<span class="lineNum">   10974 </span>            :                                                         void_type_node, 0);
<span class="lineNum">   10975 </span>            :               finish_expr_stmt (statement);
<span class="lineNum">   10976 </span>            :             }
<span class="lineNum">   10977 </span><span class="lineCov">   12947325 :           else</span>
<span class="lineNum">   10978 </span>            :             warning_at (statement_location, OPT_Wattributes,
<span class="lineNum">   10979 </span><span class="lineCov">    7049518 :                         &quot;%&lt;fallthrough%&gt; attribute not followed by %&lt;;%&gt;&quot;);</span>
<span class="lineNum">   10980 </span>            :           std_attrs = NULL_TREE;
<span class="lineNum">   10981 </span><span class="lineCov">    6724621 :         }</span>
<span class="lineNum">   10982 </span>            :     }
<span class="lineNum">   10983 </span>            : 
<span class="lineNum">   10984 </span>            :   /* Set the line number for the statement.  */
<span class="lineNum">   10985 </span><span class="lineCov">        746 :   if (statement &amp;&amp; STATEMENT_CODE_P (TREE_CODE (statement)))</span>
<span class="lineNum">   10986 </span><span class="lineCov">        746 :     SET_EXPR_LOCATION (statement, statement_location);</span>
<span class="lineNum">   10987 </span>            : 
<span class="lineNum">   10988 </span>            :   /* Allow &quot;[[fallthrough]];&quot;, but warn otherwise.  */
<span class="lineNum">   10989 </span><span class="lineCov">    6724621 :   if (std_attrs != NULL_TREE)</span>
<span class="lineNum">   10990 </span>            :     warning_at (attrs_location,
<span class="lineNum">   10991 </span><span class="lineCov">    6724621 :                 OPT_Wattributes,</span>
<span class="lineNum">   10992 </span>            :                 &quot;attributes at the beginning of statement are ignored&quot;);
<span class="lineNum">   10993 </span><span class="lineCov">    6724616 : }</span>
<span class="lineNum">   10994 </span>            : 
<span class="lineNum">   10995 </span>            : /* Append ATTR to attribute list ATTRS.  */
<a name="10996"><span class="lineNum">   10996 </span>            : </a>
<span class="lineNum">   10997 </span><span class="lineCov">    4737576 : static tree</span>
<span class="lineNum">   10998 </span><span class="lineCov">    1041515 : attr_chainon (tree attrs, tree attr)</span>
<span class="lineNum">   10999 </span>            : {
<span class="lineNum">   11000 </span>            :   if (attrs == error_mark_node)
<span class="lineNum">   11001 </span><span class="lineCov">    4737576 :     return error_mark_node;</span>
<span class="lineNum">   11002 </span>            :   if (attr == error_mark_node)
<span class="lineNum">   11003 </span>            :     return error_mark_node;
<span class="lineNum">   11004 </span><span class="lineCov">    4737562 :   return chainon (attrs, attr);</span>
<span class="lineNum">   11005 </span>            : }
<span class="lineNum">   11006 </span>            : 
<span class="lineNum">   11007 </span><span class="lineCov">         39 : /* Parse the label for a labeled-statement, i.e.</span>
<span class="lineNum">   11008 </span>            : 
<span class="lineNum">   11009 </span>            :    identifier :
<span class="lineNum">   11010 </span><span class="lineCov">         39 :    case constant-expression :</span>
<span class="lineNum">   11011 </span>            :    default :
<span class="lineNum">   11012 </span>            : 
<span class="lineNum">   11013 </span><span class="lineCov">         39 :    GNU Extension:</span>
<span class="lineNum">   11014 </span>            :    case constant-expression ... constant-expression : statement
<span class="lineNum">   11015 </span>            : 
<span class="lineNum">   11016 </span><span class="lineNoCov">          0 :    When a label is parsed without errors, the label is added to the</span>
<span class="lineNum">   11017 </span>            :    parse tree by the finish_* functions, so this function doesn't
<span class="lineNum">   11018 </span>            :    have to return the label.  */
<a name="11019"><span class="lineNum">   11019 </span>            : </a>
<span class="lineNum">   11020 </span>            : static void
<span class="lineNum">   11021 </span>            : cp_parser_label_for_labeled_statement (cp_parser* parser, tree attributes)
<span class="lineNum">   11022 </span>            : {
<span class="lineNum">   11023 </span><span class="lineCov">   11544176 :   cp_token *token;</span>
<span class="lineNum">   11024 </span><span class="lineCov">    5400149 :   tree label = NULL_TREE;</span>
<span class="lineNum">   11025 </span>            :   bool saved_colon_corrects_to_scope_p = parser-&gt;colon_corrects_to_scope_p;
<span class="lineNum">   11026 </span>            : 
<span class="lineNum">   11027 </span><span class="lineCov">   11544176 :   /* The next token should be an identifier.  */</span>
<span class="lineNum">   11028 </span><span class="lineCov">          6 :   token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   11029 </span>            :   if (token-&gt;type != CPP_NAME
<span class="lineNum">   11030 </span>            :       &amp;&amp; token-&gt;type != CPP_KEYWORD)
<span class="lineNum">   11031 </span>            :     {
<span class="lineNum">   11032 </span>            :       cp_parser_error (parser, &quot;expected labeled-statement&quot;);
<span class="lineNum">   11033 </span>            :       return;
<span class="lineNum">   11034 </span>            :     }
<span class="lineNum">   11035 </span>            : 
<span class="lineNum">   11036 </span><span class="lineNoCov">          0 :   /* Remember whether this case or a user-defined label is allowed to fall</span>
<span class="lineNum">   11037 </span>            :      through to.  */
<span class="lineNum">   11038 </span><span class="lineNoCov">          0 :   bool fallthrough_p = token-&gt;flags &amp; PREV_FALLTHROUGH;</span>
<span class="lineNum">   11039 </span>            : 
<span class="lineNum">   11040 </span><span class="lineCov">   27092587 :   parser-&gt;colon_corrects_to_scope_p = false;</span>
<span class="lineNum">   11041 </span>            :   switch (token-&gt;keyword)
<span class="lineNum">   11042 </span><span class="lineCov">   27092575 :     {</span>
<span class="lineNum">   11043 </span>            :     case RID_CASE:
<span class="lineNum">   11044 </span>            :       {
<span class="lineNum">   11045 </span>            :         tree expr, expr_hi;
<span class="lineNum">   11046 </span>            :         cp_token *ellipsis;
<span class="lineNum">   11047 </span>            : 
<span class="lineNum">   11048 </span>            :         /* Consume the `case' token.  */
<span class="lineNum">   11049 </span>            :         cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   11050 </span>            :         /* Parse the constant-expression.  */
<span class="lineNum">   11051 </span>            :         expr = cp_parser_constant_expression (parser);
<span class="lineNum">   11052 </span>            :         if (check_for_bare_parameter_packs (expr))
<span class="lineNum">   11053 </span>            :           expr = error_mark_node;
<span class="lineNum">   11054 </span>            : 
<span class="lineNum">   11055 </span>            :         ellipsis = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   11056 </span>            :         if (ellipsis-&gt;type == CPP_ELLIPSIS)
<span class="lineNum">   11057 </span>            :           {
<span class="lineNum">   11058 </span>            :             /* Consume the `...' token.  */
<span class="lineNum">   11059 </span><span class="lineCov">      78879 :             cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   11060 </span>            :             expr_hi = cp_parser_constant_expression (parser);
<span class="lineNum">   11061 </span><span class="lineCov">      78879 :             if (check_for_bare_parameter_packs (expr_hi))</span>
<span class="lineNum">   11062 </span><span class="lineCov">      78879 :               expr_hi = error_mark_node;</span>
<span class="lineNum">   11063 </span><span class="lineCov">      78879 : </span>
<span class="lineNum">   11064 </span>            :             /* We don't need to emit warnings here, as the common code
<span class="lineNum">   11065 </span>            :                will do this for us.  */
<span class="lineNum">   11066 </span><span class="lineCov">     157758 :           }</span>
<span class="lineNum">   11067 </span><span class="lineCov">      78879 :         else</span>
<span class="lineNum">   11068 </span><span class="lineCov">      77839 :           expr_hi = NULL_TREE;</span>
<span class="lineNum">   11069 </span>            : 
<span class="lineNum">   11070 </span><span class="lineNoCov">          0 :         if (parser-&gt;in_switch_statement_p)</span>
<span class="lineNum">   11071 </span><span class="lineNoCov">          0 :           {</span>
<span class="lineNum">   11072 </span>            :             tree l = finish_case_label (token-&gt;location, expr, expr_hi);
<span class="lineNum">   11073 </span>            :             if (l &amp;&amp; TREE_CODE (l) == CASE_LABEL_EXPR)
<span class="lineNum">   11074 </span>            :               FALLTHROUGH_LABEL_P (CASE_LABEL (l)) = fallthrough_p;
<span class="lineNum">   11075 </span>            :           }
<span class="lineNum">   11076 </span><span class="lineCov">      78879 :         else</span>
<span class="lineNum">   11077 </span>            :           error_at (token-&gt;location,
<span class="lineNum">   11078 </span><span class="lineCov">      78879 :                     &quot;case label %qE not within a switch statement&quot;,</span>
<span class="lineNum">   11079 </span><span class="lineCov">      78879 :                     expr);</span>
<span class="lineNum">   11080 </span>            :       }
<span class="lineNum">   11081 </span><span class="lineCov">      70684 :       break;</span>
<span class="lineNum">   11082 </span><span class="lineCov">      70684 : </span>
<span class="lineNum">   11083 </span><span class="lineCov">      70684 :     case RID_DEFAULT:</span>
<span class="lineNum">   11084 </span><span class="lineCov">      70684 :       /* Consume the `default' token.  */</span>
<span class="lineNum">   11085 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   11086 </span>            : 
<span class="lineNum">   11087 </span><span class="lineCov">      70684 :       if (parser-&gt;in_switch_statement_p)</span>
<span class="lineNum">   11088 </span>            :         {
<span class="lineNum">   11089 </span><span class="lineCov">      70684 :           tree l = finish_case_label (token-&gt;location, NULL_TREE, NULL_TREE);</span>
<span class="lineNum">   11090 </span><span class="lineCov">      70684 :           if (l &amp;&amp; TREE_CODE (l) == CASE_LABEL_EXPR)</span>
<span class="lineNum">   11091 </span><span class="lineCov">          2 :             FALLTHROUGH_LABEL_P (CASE_LABEL (l)) = fallthrough_p;</span>
<span class="lineNum">   11092 </span>            :         }
<span class="lineNum">   11093 </span><span class="lineCov">     141368 :       else</span>
<span class="lineNum">   11094 </span><span class="lineCov">      70684 :         error_at (token-&gt;location, &quot;case label not within a switch statement&quot;);</span>
<span class="lineNum">   11095 </span>            :       break;
<span class="lineNum">   11096 </span>            : 
<span class="lineNum">   11097 </span><span class="lineCov">         87 :     default:</span>
<span class="lineNum">   11098 </span><span class="lineCov">         87 :       /* Anything else must be an ordinary label.  */</span>
<span class="lineNum">   11099 </span><span class="lineCov">         87 :       label = finish_label_stmt (cp_parser_identifier (parser));</span>
<span class="lineNum">   11100 </span><span class="lineCov">          2 :       if (label &amp;&amp; TREE_CODE (label) == LABEL_DECL)</span>
<span class="lineNum">   11101 </span>            :         FALLTHROUGH_LABEL_P (label) = fallthrough_p;
<span class="lineNum">   11102 </span>            :       break;
<span class="lineNum">   11103 </span>            :     }
<span class="lineNum">   11104 </span>            : 
<span class="lineNum">   11105 </span>            :   /* Require the `:' token.  */
<span class="lineNum">   11106 </span>            :   cp_parser_require (parser, CPP_COLON, RT_COLON);
<span class="lineNum">   11107 </span>            : 
<span class="lineNum">   11108 </span><span class="lineCov">      70684 :   /* An ordinary label may optionally be followed by attributes.</span>
<span class="lineNum">   11109 </span>            :      However, this is only permitted if the attributes are then
<span class="lineNum">   11110 </span><span class="lineCov">      70680 :      followed by a semicolon.  This is because, for backward</span>
<span class="lineNum">   11111 </span><span class="lineCov">      70680 :      compatibility, when parsing</span>
<span class="lineNum">   11112 </span><span class="lineCov">     140868 :        lab: __attribute__ ((unused)) int i;</span>
<span class="lineNum">   11113 </span>            :      we want the attribute to attach to &quot;i&quot;, not &quot;lab&quot;.  */
<span class="lineNum">   11114 </span>            :   if (label != NULL_TREE
<span class="lineNum">   11115 </span><span class="lineCov">          4 :       &amp;&amp; cp_next_tokens_can_be_gnu_attribute_p (parser))</span>
<span class="lineNum">   11116 </span>            :     {
<span class="lineNum">   11117 </span>            :       tree attrs;
<span class="lineNum">   11118 </span>            :       cp_parser_parse_tentatively (parser);
<span class="lineNum">   11119 </span>            :       attrs = cp_parser_gnu_attributes_opt (parser);
<span class="lineNum">   11120 </span>            :       if (attrs == NULL_TREE
<span class="lineNum">   11121 </span><span class="lineCov">       7155 :           || cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_SEMICOLON))</span>
<span class="lineNum">   11122 </span>            :         cp_parser_abort_tentative_parse (parser);
<span class="lineNum">   11123 </span><span class="lineCov">       7155 :       else if (!cp_parser_parse_definitely (parser))</span>
<span class="lineNum">   11124 </span>            :         ;
<span class="lineNum">   11125 </span><span class="lineCov">       7155 :       else</span>
<span class="lineNum">   11126 </span>            :         attributes = attr_chainon (attributes, attrs);
<span class="lineNum">   11127 </span><span class="lineCov">       7155 :     }</span>
<span class="lineNum">   11128 </span><span class="lineCov">       7155 : </span>
<span class="lineNum">   11129 </span><span class="lineCov">      14268 :   if (attributes != NULL_TREE)</span>
<span class="lineNum">   11130 </span>            :     cplus_decl_attributes (&amp;label, attributes, 0);
<span class="lineNum">   11131 </span>            : 
<span class="lineNum">   11132 </span><span class="lineNoCov">          0 :   parser-&gt;colon_corrects_to_scope_p = saved_colon_corrects_to_scope_p;</span>
<span class="lineNum">   11133 </span>            : }
<span class="lineNum">   11134 </span>            : 
<span class="lineNum">   11135 </span><span class="lineCov">       1040 : /* Parse an expression-statement.</span>
<span class="lineNum">   11136 </span>            : 
<span class="lineNum">   11137 </span><span class="lineCov">       1040 :    expression-statement:</span>
<span class="lineNum">   11138 </span><span class="lineCov">       1040 :      expression [opt] ;</span>
<span class="lineNum">   11139 </span><span class="lineCov">       2068 : </span>
<span class="lineNum">   11140 </span>            :    Returns the new EXPR_STMT -- or NULL_TREE if the expression
<span class="lineNum">   11141 </span>            :    statement consists of nothing more than an `;'. IN_STATEMENT_EXPR_P
<span class="lineNum">   11142 </span>            :    indicates whether this expression-statement is part of an
<span class="lineNum">   11143 </span>            :    expression statement.  */
<a name="11144"><span class="lineNum">   11144 </span><span class="lineCov">      78879 : </span></a>
<span class="lineNum">   11145 </span>            : static tree
<span class="lineNum">   11146 </span>            : cp_parser_expression_statement (cp_parser* parser, tree in_statement_expr)
<span class="lineNum">   11147 </span>            : {
<span class="lineNum">   11148 </span>            :   tree statement = NULL_TREE;
<span class="lineNum">   11149 </span>            :   cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   11150 </span>            :   location_t loc = token-&gt;location;
<span class="lineNum">   11151 </span>            : 
<span class="lineNum">   11152 </span><span class="lineCov">      78879 :   /* There might be attribute fallthrough.  */</span>
<span class="lineNum">   11153 </span><span class="lineCov">      78879 :   tree attr = cp_parser_gnu_attributes_opt (parser);</span>
<span class="lineNum">   11154 </span>            : 
<span class="lineNum">   11155 </span><span class="lineCov">         23 :   /* If the next token is a ';', then there is no expression</span>
<span class="lineNum">   11156 </span><span class="lineCov">         23 :      statement.  */</span>
<span class="lineNum">   11157 </span><span class="lineCov">         23 :   if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_SEMICOLON))</span>
<span class="lineNum">   11158 </span><span class="lineCov">         23 :     {</span>
<span class="lineNum">   11159 </span><span class="lineCov">         23 :       statement = cp_parser_expression (parser);</span>
<span class="lineNum">   11160 </span><span class="lineCov">          6 :       if (statement == error_mark_node</span>
<span class="lineNum">   11161 </span><span class="lineCov">         17 :           &amp;&amp; !cp_parser_uncommitted_to_tentative_parse_p (parser))</span>
<span class="lineNum">   11162 </span>            :         {
<span class="lineNum">   11163 </span>            :           cp_parser_skip_to_end_of_block_or_statement (parser);
<span class="lineNum">   11164 </span><span class="lineCov">         17 :           return error_mark_node;</span>
<span class="lineNum">   11165 </span>            :         }
<span class="lineNum">   11166 </span>            :     }
<span class="lineNum">   11167 </span><span class="lineCov">      78879 : </span>
<span class="lineNum">   11168 </span><span class="lineCov">         21 :   /* Handle [[fallthrough]];.  */</span>
<span class="lineNum">   11169 </span>            :   if (attribute_fallthrough_p (attr))
<span class="lineNum">   11170 </span><span class="lineCov">      78879 :     {</span>
<span class="lineNum">   11171 </span>            :       /* The next token after the fallthrough attribute is ';'.  */
<span class="lineNum">   11172 </span>            :       if (statement == NULL_TREE)
<span class="lineNum">   11173 </span>            :         /* Turn [[fallthrough]]; into FALLTHROUGH ();.  */
<span class="lineNum">   11174 </span>            :         statement = build_call_expr_internal_loc (loc, IFN_FALLTHROUGH,
<span class="lineNum">   11175 </span>            :                                                   void_type_node, 0);
<span class="lineNum">   11176 </span>            :       else
<span class="lineNum">   11177 </span>            :         warning_at (loc, OPT_Wattributes,
<span class="lineNum">   11178 </span>            :                     &quot;%&lt;fallthrough%&gt; attribute not followed by %&lt;;%&gt;&quot;);
<span class="lineNum">   11179 </span>            :       attr = NULL_TREE;
<span class="lineNum">   11180 </span>            :     }
<span class="lineNum">   11181 </span>            : 
<span class="lineNum">   11182 </span>            :   /* Allow &quot;[[fallthrough]];&quot;, but warn otherwise.  */
<span class="lineNum">   11183 </span>            :   if (attr != NULL_TREE)
<span class="lineNum">   11184 </span><span class="lineCov">    4834592 :     warning_at (loc, OPT_Wattributes,</span>
<span class="lineNum">   11185 </span>            :                 &quot;attributes at the beginning of statement are ignored&quot;);
<span class="lineNum">   11186 </span><span class="lineCov">    4834592 : </span>
<span class="lineNum">   11187 </span><span class="lineCov">    9669184 :   /* Give a helpful message for &quot;A&lt;T&gt;::type t;&quot; and the like.  */</span>
<span class="lineNum">   11188 </span><span class="lineCov">    4834592 :   if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_SEMICOLON)</span>
<span class="lineNum">   11189 </span>            :       &amp;&amp; !cp_parser_uncommitted_to_tentative_parse_p (parser))
<span class="lineNum">   11190 </span>            :     {
<span class="lineNum">   11191 </span><span class="lineCov">    4834592 :       if (TREE_CODE (statement) == SCOPE_REF)</span>
<span class="lineNum">   11192 </span>            :         error_at (token-&gt;location, &quot;need %&lt;typename%&gt; before %qE because &quot;
<span class="lineNum">   11193 </span>            :                   &quot;%qT is a dependent scope&quot;,
<span class="lineNum">   11194 </span>            :                   statement, TREE_OPERAND (statement, 0));
<span class="lineNum">   11195 </span><span class="lineCov">    4834592 :       else if (is_overloaded_fn (statement)</span>
<span class="lineNum">   11196 </span>            :                &amp;&amp; DECL_CONSTRUCTOR_P (get_first_fn (statement)))
<span class="lineNum">   11197 </span><span class="lineCov">    4438842 :         {</span>
<span class="lineNum">   11198 </span><span class="lineCov">    4438831 :           /* A::A a; */</span>
<span class="lineNum">   11199 </span><span class="lineCov">    4438831 :           tree fn = get_first_fn (statement);</span>
<span class="lineNum">   11200 </span>            :           error_at (token-&gt;location,
<span class="lineNum">   11201 </span><span class="lineCov">       6528 :                     &quot;%&lt;%T::%D%&gt; names the constructor, not the type&quot;,</span>
<span class="lineNum">   11202 </span><span class="lineCov">       6528 :                     DECL_CONTEXT (fn), DECL_NAME (fn));</span>
<span class="lineNum">   11203 </span>            :         }
<span class="lineNum">   11204 </span>            :     }
<span class="lineNum">   11205 </span>            : 
<span class="lineNum">   11206 </span>            :   /* Consume the final `;'.  */
<span class="lineNum">   11207 </span><span class="lineCov">    4828053 :   cp_parser_consume_semicolon_at_end_of_statement (parser);</span>
<span class="lineNum">   11208 </span>            : 
<span class="lineNum">   11209 </span>            :   if (in_statement_expr
<span class="lineNum">   11210 </span><span class="lineCov">        178 :       &amp;&amp; cp_lexer_next_token_is (parser-&gt;lexer, CPP_CLOSE_BRACE))</span>
<span class="lineNum">   11211 </span>            :     /* This is the final expression statement of a statement
<span class="lineNum">   11212 </span><span class="lineCov">        175 :        expression.  */</span>
<span class="lineNum">   11213 </span>            :     statement = finish_stmt_expr_expr (statement, in_statement_expr);
<span class="lineNum">   11214 </span>            :   else if (statement)
<span class="lineNum">   11215 </span><span class="lineCov">          3 :     statement = finish_expr_stmt (statement);</span>
<span class="lineNum">   11216 </span>            : 
<span class="lineNum">   11217 </span>            :   return statement;
<span class="lineNum">   11218 </span>            : }
<span class="lineNum">   11219 </span>            : 
<span class="lineNum">   11220 </span>            : /* Parse a compound-statement.
<span class="lineNum">   11221 </span><span class="lineCov">    4827875 : </span>
<span class="lineNum">   11222 </span><span class="lineCov">         18 :    compound-statement:</span>
<span class="lineNum">   11223 </span>            :      { statement-seq [opt] }
<span class="lineNum">   11224 </span>            : 
<span class="lineNum">   11225 </span>            :    GNU extension:
<span class="lineNum">   11226 </span><span class="lineCov">    9656106 : </span>
<span class="lineNum">   11227 </span><span class="lineCov">    4828053 :    compound-statement:</span>
<span class="lineNum">   11228 </span>            :      { label-declaration-seq [opt] statement-seq [opt] }
<span class="lineNum">   11229 </span><span class="lineCov">         30 : </span>
<span class="lineNum">   11230 </span><span class="lineCov">          9 :    label-declaration-seq:</span>
<span class="lineNum">   11231 </span>            :      label-declaration
<span class="lineNum">   11232 </span><span class="lineCov">          9 :      label-declaration-seq label-declaration</span>
<span class="lineNum">   11233 </span><span class="lineCov">         21 : </span>
<span class="lineNum">   11234 </span><span class="lineCov">         21 :    Returns a tree representing the statement.  */</span>
<a name="11235"><span class="lineNum">   11235 </span>            : </a>
<span class="lineNum">   11236 </span>            : static tree
<span class="lineNum">   11237 </span><span class="lineCov">          3 : cp_parser_compound_statement (cp_parser *parser, tree in_statement_expr,</span>
<span class="lineNum">   11238 </span><span class="lineCov">          9 :                               int bcs_flags, bool function_body)</span>
<span class="lineNum">   11239 </span>            : {
<span class="lineNum">   11240 </span><span class="lineCov">          3 :   tree compound_stmt;</span>
<span class="lineNum">   11241 </span>            :   matching_braces braces;
<span class="lineNum">   11242 </span>            : 
<span class="lineNum">   11243 </span>            :   /* Consume the `{'.  */
<span class="lineNum">   11244 </span>            :   if (!braces.require_open (parser))
<span class="lineNum">   11245 </span><span class="lineCov">    4828053 :     return error_mark_node;</span>
<span class="lineNum">   11246 </span>            :   if (DECL_DECLARED_CONSTEXPR_P (current_function_decl)
<span class="lineNum">   11247 </span><span class="lineCov">    4828053 :       &amp;&amp; !function_body &amp;&amp; cxx_dialect &lt; cxx14)</span>
<span class="lineNum">   11248 </span><span class="lineCov">    4828053 :     pedwarn (input_location, OPT_Wpedantic,</span>
<span class="lineNum">   11249 </span>            :              &quot;compound-statement in %&lt;constexpr%&gt; function&quot;);
<span class="lineNum">   11250 </span>            :   /* Begin the compound-statement.  */
<span class="lineNum">   11251 </span><span class="lineCov">       9130 :   compound_stmt = begin_compound_stmt (bcs_flags);</span>
<span class="lineNum">   11252 </span><span class="lineCov">    4818923 :   /* If the next keyword is `__label__' we have a label declaration.  */</span>
<span class="lineNum">   11253 </span><span class="lineCov">    4423363 :   while (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_LABEL))</span>
<span class="lineNum">   11254 </span>            :     cp_parser_label_declaration (parser);
<span class="lineNum">   11255 </span>            :   /* Parse an (optional) statement-seq.  */
<span class="lineNum">   11256 </span>            :   cp_parser_statement_seq_opt (parser, in_statement_expr);
<span class="lineNum">   11257 </span>            :   /* Finish the compound-statement.  */
<span class="lineNum">   11258 </span>            :   finish_compound_stmt (compound_stmt);
<span class="lineNum">   11259 </span>            :   /* Consume the `}'.  */
<span class="lineNum">   11260 </span>            :   braces.require_close (parser);
<span class="lineNum">   11261 </span>            : 
<span class="lineNum">   11262 </span>            :   return compound_stmt;
<span class="lineNum">   11263 </span>            : }
<span class="lineNum">   11264 </span>            : 
<span class="lineNum">   11265 </span>            : /* Parse an (optional) statement-seq.
<span class="lineNum">   11266 </span>            : 
<span class="lineNum">   11267 </span>            :    statement-seq:
<span class="lineNum">   11268 </span>            :      statement
<span class="lineNum">   11269 </span>            :      statement-seq [opt] statement  */
<a name="11270"><span class="lineNum">   11270 </span>            : </a>
<span class="lineNum">   11271 </span>            : static void
<span class="lineNum">   11272 </span>            : cp_parser_statement_seq_opt (cp_parser* parser, tree in_statement_expr)
<span class="lineNum">   11273 </span>            : {
<span class="lineNum">   11274 </span>            :   /* Scan statements until there aren't any more.  */
<span class="lineNum">   11275 </span><span class="lineCov">    6678112 :   while (true)</span>
<span class="lineNum">   11276 </span>            :     {
<span class="lineNum">   11277 </span>            :       cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   11278 </span><span class="lineCov">    6678112 : </span>
<span class="lineNum">   11279 </span><span class="lineCov">   13356224 :       /* If we are looking at a `}', then we have run out of</span>
<span class="lineNum">   11280 </span>            :          statements; the same is true if we have reached the end
<span class="lineNum">   11281 </span>            :          of file, or have stumbled upon a stray '@end'.  */
<span class="lineNum">   11282 </span><span class="lineCov">    6678112 :       if (token-&gt;type == CPP_CLOSE_BRACE</span>
<span class="lineNum">   11283 </span><span class="lineCov">         26 :           || token-&gt;type == CPP_EOF</span>
<span class="lineNum">   11284 </span><span class="lineCov">   13356172 :           || token-&gt;type == CPP_PRAGMA_EOL</span>
<span class="lineNum">   11285 </span><span class="lineCov">    6678086 :           || (token-&gt;type == CPP_KEYWORD &amp;&amp; token-&gt;keyword == RID_AT_END))</span>
<span class="lineNum">   11286 </span><span class="lineCov">          8 :         break;</span>
<span class="lineNum">   11287 </span>            :       
<span class="lineNum">   11288 </span>            :       /* If we are in a compound statement and find 'else' then
<span class="lineNum">   11289 </span><span class="lineCov">    6678086 :          something went wrong.  */</span>
<span class="lineNum">   11290 </span>            :       else if (token-&gt;type == CPP_KEYWORD &amp;&amp; token-&gt;keyword == RID_ELSE)
<span class="lineNum">   11291 </span><span class="lineCov">    6678131 :         {</span>
<span class="lineNum">   11292 </span><span class="lineCov">         45 :           if (parser-&gt;in_statement &amp; IN_IF_STMT) </span>
<span class="lineNum">   11293 </span>            :             break;
<span class="lineNum">   11294 </span><span class="lineCov">    6678086 :           else</span>
<span class="lineNum">   11295 </span>            :             {
<span class="lineNum">   11296 </span><span class="lineCov">    6678067 :               token = cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   11297 </span>            :               error_at (token-&gt;location, &quot;%&lt;else%&gt; without a previous %&lt;if%&gt;&quot;);
<span class="lineNum">   11298 </span><span class="lineCov">   13356134 :             }</span>
<span class="lineNum">   11299 </span>            :         }
<span class="lineNum">   11300 </span><span class="lineCov">    6678067 : </span>
<span class="lineNum">   11301 </span>            :       /* Parse the statement.  */
<span class="lineNum">   11302 </span>            :       cp_parser_statement (parser, in_statement_expr, true, NULL);
<span class="lineNum">   11303 </span>            :     }
<span class="lineNum">   11304 </span>            : }
<span class="lineNum">   11305 </span>            : 
<span class="lineNum">   11306 </span>            : /* Return true if this is the C++20 version of range-based-for with
<span class="lineNum">   11307 </span>            :    init-statement.  */
<a name="11308"><span class="lineNum">   11308 </span>            : </a>
<span class="lineNum">   11309 </span>            : static bool
<span class="lineNum">   11310 </span><span class="lineCov">    6825917 : cp_parser_range_based_for_with_init_p (cp_parser *parser)</span>
<span class="lineNum">   11311 </span>            : {
<span class="lineNum">   11312 </span>            :   bool r = false;
<span class="lineNum">   11313 </span><span class="lineCov">   19081424 : </span>
<span class="lineNum">   11314 </span>            :   /* Save tokens so that we can put them back.  */
<span class="lineNum">   11315 </span><span class="lineCov">   38162848 :   cp_lexer_save_tokens (parser-&gt;lexer);</span>
<span class="lineNum">   11316 </span>            : 
<span class="lineNum">   11317 </span>            :   /* There has to be an unnested ; followed by an unnested :.  */
<span class="lineNum">   11318 </span>            :   if (cp_parser_skip_to_closing_parenthesis_1 (parser,
<span class="lineNum">   11319 </span>            :                                                /*recovering=*/false,
<span class="lineNum">   11320 </span><span class="lineCov">   38162848 :                                                CPP_SEMICOLON,</span>
<span class="lineNum">   11321 </span><span class="lineCov">   19081424 :                                                /*consume_paren=*/false) != -1)</span>
<span class="lineNum">   11322 </span><span class="lineCov">   12255529 :     goto out;</span>
<span class="lineNum">   11323 </span><span class="lineCov">   12255529 : </span>
<span class="lineNum">   11324 </span>            :   /* We found the semicolon, eat it now.  */
<span class="lineNum">   11325 </span>            :   cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   11326 </span>            : 
<span class="lineNum">   11327 </span>            :   /* Now look for ':' that is not nested in () or {}.  */
<span class="lineNum">   11328 </span><span class="lineCov">   12255529 :   r = (cp_parser_skip_to_closing_parenthesis_1 (parser,</span>
<span class="lineNum">   11329 </span>            :                                                 /*recovering=*/false,
<span class="lineNum">   11330 </span><span class="lineCov">          6 :                                                 CPP_COLON,</span>
<span class="lineNum">   11331 </span>            :                                                 /*consume_paren=*/false) == -1);
<span class="lineNum">   11332 </span>            : 
<span class="lineNum">   11333 </span>            : out:
<span class="lineNum">   11334 </span><span class="lineCov">          3 :   /* Roll back the tokens we skipped.  */</span>
<span class="lineNum">   11335 </span><span class="lineCov">          3 :   cp_lexer_rollback_tokens (parser-&gt;lexer);</span>
<span class="lineNum">   11336 </span>            : 
<span class="lineNum">   11337 </span>            :   return r;
<span class="lineNum">   11338 </span>            : }
<span class="lineNum">   11339 </span>            : 
<span class="lineNum">   11340 </span><span class="lineCov">   12255526 : /* Return true if we're looking at (init; cond), false otherwise.  */</span>
<a name="11341"><span class="lineNum">   11341 </span><span class="lineCov">   12255507 : </span></a>
<span class="lineNum">   11342 </span><span class="lineCov">    6825898 : static bool</span>
<span class="lineNum">   11343 </span>            : cp_parser_init_statement_p (cp_parser *parser)
<span class="lineNum">   11344 </span>            : {
<span class="lineNum">   11345 </span>            :   /* Save tokens so that we can put them back.  */
<span class="lineNum">   11346 </span>            :   cp_lexer_save_tokens (parser-&gt;lexer);
<span class="lineNum">   11347 </span>            : 
<span class="lineNum">   11348 </span><span class="lineCov">     127818 :   /* Look for ';' that is not nested in () or {}.  */</span>
<span class="lineNum">   11349 </span>            :   int ret = cp_parser_skip_to_closing_parenthesis_1 (parser,
<span class="lineNum">   11350 </span><span class="lineCov">     127818 :                                                      /*recovering=*/false,</span>
<span class="lineNum">   11351 </span>            :                                                      CPP_SEMICOLON,
<span class="lineNum">   11352 </span>            :                                                      /*consume_paren=*/false);
<span class="lineNum">   11353 </span><span class="lineCov">     127818 : </span>
<span class="lineNum">   11354 </span>            :   /* Roll back the tokens we skipped.  */
<span class="lineNum">   11355 </span>            :   cp_lexer_rollback_tokens (parser-&gt;lexer);
<span class="lineNum">   11356 </span><span class="lineCov">     127818 : </span>
<span class="lineNum">   11357 </span>            :   return ret == -1;
<span class="lineNum">   11358 </span>            : }
<span class="lineNum">   11359 </span>            : 
<span class="lineNum">   11360 </span>            : /* Parse a selection-statement.
<span class="lineNum">   11361 </span>            : 
<span class="lineNum">   11362 </span>            :    selection-statement:
<span class="lineNum">   11363 </span><span class="lineCov">     125544 :      if ( init-statement [opt] condition ) statement</span>
<span class="lineNum">   11364 </span>            :      if ( init-statement [opt] condition ) statement else statement
<span class="lineNum">   11365 </span>            :      switch ( init-statement [opt] condition ) statement
<span class="lineNum">   11366 </span><span class="lineCov">     125544 : </span>
<span class="lineNum">   11367 </span>            :    Returns the new IF_STMT or SWITCH_STMT.
<span class="lineNum">   11368 </span>            : 
<span class="lineNum">   11369 </span>            :    If IF_P is not NULL, *IF_P is set to indicate whether the statement
<span class="lineNum">   11370 </span>            :    is a (possibly labeled) if statement which is not enclosed in
<span class="lineNum">   11371 </span><span class="lineCov">     127818 :    braces and has an else clause.  This is used to implement</span>
<span class="lineNum">   11372 </span>            :    -Wparentheses.
<span class="lineNum">   11373 </span><span class="lineCov">     127818 : </span>
<span class="lineNum">   11374 </span>            :    CHAIN is a vector of if-else-if conditions.  This is used to implement
<span class="lineNum">   11375 </span><span class="lineCov">     127818 :    -Wduplicated-cond.  */</span>
<a name="11376"><span class="lineNum">   11376 </span>            : </a>
<span class="lineNum">   11377 </span>            : static tree
<span class="lineNum">   11378 </span>            : cp_parser_selection_statement (cp_parser* parser, bool *if_p,
<span class="lineNum">   11379 </span>            :                                vec&lt;tree&gt; *chain)
<span class="lineNum">   11380 </span>            : {
<span class="lineNum">   11381 </span><span class="lineCov">    1656156 :   cp_token *token;</span>
<span class="lineNum">   11382 </span>            :   enum rid keyword;
<span class="lineNum">   11383 </span>            :   token_indent_info guard_tinfo;
<span class="lineNum">   11384 </span><span class="lineCov">    1656156 : </span>
<span class="lineNum">   11385 </span>            :   if (if_p != NULL)
<span class="lineNum">   11386 </span>            :     *if_p = false;
<span class="lineNum">   11387 </span><span class="lineCov">    1656156 : </span>
<span class="lineNum">   11388 </span>            :   /* Peek at the next token.  */
<span class="lineNum">   11389 </span>            :   token = cp_parser_require (parser, CPP_KEYWORD, RT_SELECT);
<span class="lineNum">   11390 </span>            :   guard_tinfo = get_token_indent_info (token);
<span class="lineNum">   11391 </span>            : 
<span class="lineNum">   11392 </span>            :   /* See what kind of keyword it is.  */
<span class="lineNum">   11393 </span><span class="lineCov">    1656156 :   keyword = token-&gt;keyword;</span>
<span class="lineNum">   11394 </span>            :   switch (keyword)
<span class="lineNum">   11395 </span><span class="lineCov">    1656156 :     {</span>
<span class="lineNum">   11396 </span>            :     case RID_IF:
<span class="lineNum">   11397 </span>            :     case RID_SWITCH:
<span class="lineNum">   11398 </span>            :       {
<span class="lineNum">   11399 </span>            :         tree statement;
<span class="lineNum">   11400 </span>            :         tree condition;
<span class="lineNum">   11401 </span>            : 
<span class="lineNum">   11402 </span>            :         bool cx = false;
<span class="lineNum">   11403 </span>            :         if (keyword == RID_IF
<span class="lineNum">   11404 </span>            :             &amp;&amp; cp_lexer_next_token_is_keyword (parser-&gt;lexer,
<span class="lineNum">   11405 </span>            :                                                RID_CONSTEXPR))
<span class="lineNum">   11406 </span>            :           {
<span class="lineNum">   11407 </span>            :             cx = true;
<span class="lineNum">   11408 </span>            :             cp_token *tok = cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   11409 </span>            :             if (cxx_dialect &lt; cxx17 &amp;&amp; !in_system_header_at (tok-&gt;location))
<span class="lineNum">   11410 </span>            :               pedwarn (tok-&gt;location, 0, &quot;%&lt;if constexpr%&gt; only available &quot;
<span class="lineNum">   11411 </span>            :                        &quot;with -std=c++17 or -std=gnu++17&quot;);
<span class="lineNum">   11412 </span>            :           }
<span class="lineNum">   11413 </span>            : 
<span class="lineNum">   11414 </span>            :         /* Look for the `('.  */
<span class="lineNum">   11415 </span>            :         matching_parens parens;
<span class="lineNum">   11416 </span><span class="lineCov">    1656162 :         if (!parens.require_open (parser))</span>
<span class="lineNum">   11417 </span>            :           {
<span class="lineNum">   11418 </span>            :             cp_parser_skip_to_end_of_statement (parser);
<span class="lineNum">   11419 </span><span class="lineCov">    1656162 :             return error_mark_node;</span>
<span class="lineNum">   11420 </span><span class="lineCov">    1656162 :           }</span>
<span class="lineNum">   11421 </span><span class="lineCov">    1656162 : </span>
<span class="lineNum">   11422 </span>            :         /* Begin the selection-statement.  */
<span class="lineNum">   11423 </span><span class="lineCov">    1656162 :         if (keyword == RID_IF)</span>
<span class="lineNum">   11424 </span><span class="lineCov">       7685 :           {</span>
<span class="lineNum">   11425 </span>            :             statement = begin_if_stmt ();
<span class="lineNum">   11426 </span>            :             IF_STMT_CONSTEXPR_P (statement) = cx;
<span class="lineNum">   11427 </span><span class="lineCov">    1656162 :           }</span>
<span class="lineNum">   11428 </span><span class="lineCov">    1656162 :         else</span>
<span class="lineNum">   11429 </span>            :           statement = begin_switch_stmt ();
<span class="lineNum">   11430 </span>            : 
<span class="lineNum">   11431 </span><span class="lineCov">    1656162 :         /* Parse the optional init-statement.  */</span>
<span class="lineNum">   11432 </span><span class="lineCov">    1656162 :         if (cp_parser_init_statement_p (parser))</span>
<span class="lineNum">   11433 </span>            :           {
<span class="lineNum">   11434 </span><span class="lineCov">    1656162 :             tree decl;</span>
<span class="lineNum">   11435 </span><span class="lineCov">    1656162 :             if (cxx_dialect &lt; cxx17)</span>
<span class="lineNum">   11436 </span><span class="lineCov">    1656162 :               pedwarn (cp_lexer_peek_token (parser-&gt;lexer)-&gt;location, 0,</span>
<span class="lineNum">   11437 </span><span class="lineCov">    1656162 :                        &quot;init-statement in selection statements only available &quot;</span>
<span class="lineNum">   11438 </span><span class="lineCov">    1656162 :                        &quot;with -std=c++17 or -std=gnu++17&quot;);</span>
<span class="lineNum">   11439 </span>            :             cp_parser_init_statement (parser, &amp;decl);
<span class="lineNum">   11440 </span><span class="lineCov">    1656162 :           }</span>
<span class="lineNum">   11441 </span><span class="lineCov">    1656162 : </span>
<span class="lineNum">   11442 </span><span class="lineCov">    1656162 :         /* Parse the condition.  */</span>
<span class="lineNum">   11443 </span>            :         condition = cp_parser_condition (parser);
<span class="lineNum">   11444 </span>            :         /* Look for the `)'.  */
<span class="lineNum">   11445 </span><span class="lineCov">       1302 :         if (!parens.require_close (parser))</span>
<span class="lineNum">   11446 </span><span class="lineCov">       1302 :           cp_parser_skip_to_closing_parenthesis (parser, true, false,</span>
<span class="lineNum">   11447 </span><span class="lineCov">       1302 :                                                  /*consume_paren=*/true);</span>
<span class="lineNum">   11448 </span><span class="lineCov">         17 : </span>
<span class="lineNum">   11449 </span>            :         if (keyword == RID_IF)
<span class="lineNum">   11450 </span>            :           {
<span class="lineNum">   11451 </span>            :             bool nested_if;
<span class="lineNum">   11452 </span>            :             unsigned char in_statement;
<span class="lineNum">   11453 </span><span class="lineCov">    3312324 : </span>
<span class="lineNum">   11454 </span><span class="lineCov">    1656162 :             /* Add the condition.  */</span>
<span class="lineNum">   11455 </span>            :             condition = finish_if_stmt_cond (condition, statement);
<span class="lineNum">   11456 </span><span class="lineCov">          6 : </span>
<span class="lineNum">   11457 </span><span class="lineCov">          6 :             if (warn_duplicated_cond)</span>
<span class="lineNum">   11458 </span>            :               warn_duplicated_cond_add_or_warn (token-&gt;location, condition,
<span class="lineNum">   11459 </span>            :                                                 &amp;chain);
<span class="lineNum">   11460 </span>            : 
<span class="lineNum">   11461 </span><span class="lineCov">    1656156 :             /* Parse the then-clause.  */</span>
<span class="lineNum">   11462 </span>            :             in_statement = parser-&gt;in_statement;
<span class="lineNum">   11463 </span><span class="lineCov">    1645281 :             parser-&gt;in_statement |= IN_IF_STMT;</span>
<span class="lineNum">   11464 </span><span class="lineCov">    1645281 : </span>
<span class="lineNum">   11465 </span>            :             /* Outside a template, the non-selected branch of a constexpr
<span class="lineNum">   11466 </span>            :                if is a 'discarded statement', i.e. unevaluated.  */
<span class="lineNum">   11467 </span><span class="lineCov">      10875 :             bool was_discarded = in_discarded_stmt;</span>
<span class="lineNum">   11468 </span>            :             bool discard_then = (cx &amp;&amp; !processing_template_decl
<span class="lineNum">   11469 </span>            :                                  &amp;&amp; integer_zerop (condition));
<span class="lineNum">   11470 </span><span class="lineCov">    1656156 :             if (discard_then)</span>
<span class="lineNum">   11471 </span>            :               {
<span class="lineNum">   11472 </span><span class="lineCov">         33 :                 in_discarded_stmt = true;</span>
<span class="lineNum">   11473 </span><span class="lineCov">         33 :                 ++c_inhibit_evaluation_warnings;</span>
<span class="lineNum">   11474 </span><span class="lineCov">          2 :               }</span>
<span class="lineNum">   11475 </span>            : 
<span class="lineNum">   11476 </span>            :             cp_parser_implicitly_scoped_statement (parser, &amp;nested_if,
<span class="lineNum">   11477 </span><span class="lineCov">         33 :                                                    guard_tinfo);</span>
<span class="lineNum">   11478 </span>            : 
<span class="lineNum">   11479 </span>            :             parser-&gt;in_statement = in_statement;
<span class="lineNum">   11480 </span>            : 
<span class="lineNum">   11481 </span><span class="lineCov">    1656156 :             finish_then_clause (statement);</span>
<span class="lineNum">   11482 </span>            : 
<span class="lineNum">   11483 </span><span class="lineCov">    1656156 :             if (discard_then)</span>
<span class="lineNum">   11484 </span><span class="lineCov">         11 :               {</span>
<span class="lineNum">   11485 </span>            :                 THEN_CLAUSE (statement) = NULL_TREE;
<span class="lineNum">   11486 </span>            :                 in_discarded_stmt = was_discarded;
<span class="lineNum">   11487 </span><span class="lineCov">    1656156 :                 --c_inhibit_evaluation_warnings;</span>
<span class="lineNum">   11488 </span>            :               }
<span class="lineNum">   11489 </span><span class="lineCov">    1645281 : </span>
<span class="lineNum">   11490 </span><span class="lineCov">    1645281 :             /* If the next token is `else', parse the else-clause.  */</span>
<span class="lineNum">   11491 </span>            :             if (cp_lexer_next_token_is_keyword (parser-&gt;lexer,
<span class="lineNum">   11492 </span>            :                                                 RID_ELSE))
<span class="lineNum">   11493 </span><span class="lineCov">    1645281 :               {</span>
<span class="lineNum">   11494 </span>            :                 bool discard_else = (cx &amp;&amp; !processing_template_decl
<span class="lineNum">   11495 </span><span class="lineCov">    1645281 :                                      &amp;&amp; integer_nonzerop (condition));</span>
<span class="lineNum">   11496 </span><span class="lineCov">        186 :                 if (discard_else)</span>
<span class="lineNum">   11497 </span>            :                   {
<span class="lineNum">   11498 </span>            :                     in_discarded_stmt = true;
<span class="lineNum">   11499 </span>            :                     ++c_inhibit_evaluation_warnings;
<span class="lineNum">   11500 </span><span class="lineCov">    1645281 :                   }</span>
<span class="lineNum">   11501 </span><span class="lineCov">    1645281 : </span>
<span class="lineNum">   11502 </span>            :                 guard_tinfo
<span class="lineNum">   11503 </span>            :                   = get_token_indent_info (cp_lexer_peek_token (parser-&gt;lexer));
<span class="lineNum">   11504 </span>            :                 /* Consume the `else' keyword.  */
<span class="lineNum">   11505 </span><span class="lineCov">    1645281 :                 cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   11506 </span><span class="lineCov">       1302 :                 if (warn_duplicated_cond)</span>
<span class="lineNum">   11507 </span><span class="lineCov">    1645310 :                   {</span>
<span class="lineNum">   11508 </span><span class="lineCov">         17 :                     if (cp_lexer_next_token_is_keyword (parser-&gt;lexer,</span>
<span class="lineNum">   11509 </span>            :                                                         RID_IF)
<span class="lineNum">   11510 </span><span class="lineCov">         17 :                         &amp;&amp; chain == NULL)</span>
<span class="lineNum">   11511 </span><span class="lineCov">         17 :                       {</span>
<span class="lineNum">   11512 </span>            :                         /* We've got &quot;if (COND) else if (COND2)&quot;.  Start
<span class="lineNum">   11513 </span>            :                            the condition chain and add COND as the first
<span class="lineNum">   11514 </span><span class="lineCov">    1645281 :                            element.  */</span>
<span class="lineNum">   11515 </span>            :                         chain = new vec&lt;tree&gt; ();
<span class="lineNum">   11516 </span>            :                         if (!CONSTANT_CLASS_P (condition)
<span class="lineNum">   11517 </span><span class="lineCov">    1645281 :                             &amp;&amp; !TREE_SIDE_EFFECTS (condition))</span>
<span class="lineNum">   11518 </span>            :                         {
<span class="lineNum">   11519 </span><span class="lineCov">    1645281 :                           /* Wrap it in a NOP_EXPR so that we can set the</span>
<span class="lineNum">   11520 </span>            :                              location of the condition.  */
<span class="lineNum">   11521 </span><span class="lineCov">    1645281 :                           tree e = build1 (NOP_EXPR, TREE_TYPE (condition),</span>
<span class="lineNum">   11522 </span>            :                                            condition);
<span class="lineNum">   11523 </span><span class="lineCov">         17 :                           SET_EXPR_LOCATION (e, token-&gt;location);</span>
<span class="lineNum">   11524 </span><span class="lineCov">         17 :                           chain-&gt;safe_push (e);</span>
<span class="lineNum">   11525 </span><span class="lineCov">         17 :                         }</span>
<span class="lineNum">   11526 </span>            :                       }
<span class="lineNum">   11527 </span>            :                     else if (!cp_lexer_next_token_is_keyword (parser-&gt;lexer,
<span class="lineNum">   11528 </span>            :                                                               RID_IF))
<span class="lineNum">   11529 </span><span class="lineCov">    1645281 :                       {</span>
<span class="lineNum">   11530 </span>            :                         /* This is if-else without subsequent if.  Zap the
<span class="lineNum">   11531 </span>            :                            condition chain; we would have already warned at
<span class="lineNum">   11532 </span><span class="lineCov">       1156 :                            this point.  */</span>
<span class="lineNum">   11533 </span><span class="lineCov">     409680 :                         delete chain;</span>
<span class="lineNum">   11534 </span><span class="lineCov">          4 :                         chain = NULL;</span>
<span class="lineNum">   11535 </span>            :                       }
<span class="lineNum">   11536 </span><span class="lineCov">          4 :                   }</span>
<span class="lineNum">   11537 </span><span class="lineCov">          4 :                 begin_else_clause (statement);</span>
<span class="lineNum">   11538 </span>            :                 /* Parse the else-clause.  */
<span class="lineNum">   11539 </span>            :                 cp_parser_implicitly_scoped_statement (parser, NULL,
<span class="lineNum">   11540 </span><span class="lineCov">     409667 :                                                        guard_tinfo, chain);</span>
<span class="lineNum">   11541 </span><span class="lineCov">     409667 : </span>
<span class="lineNum">   11542 </span>            :                 finish_else_clause (statement);
<span class="lineNum">   11543 </span><span class="lineCov">     409667 : </span>
<span class="lineNum">   11544 </span><span class="lineCov">     409667 :                 /* If we are currently parsing a then-clause, then</span>
<span class="lineNum">   11545 </span>            :                    IF_P will not be NULL.  We set it to true to
<span class="lineNum">   11546 </span><span class="lineCov">        258 :                    indicate that this if statement has an else clause.</span>
<span class="lineNum">   11547 </span>            :                    This may trigger the Wparentheses warning below
<span class="lineNum">   11548 </span><span class="lineCov">        129 :                    when we get back up to the parent if statement.  */</span>
<span class="lineNum">   11549 </span>            :                 if (if_p != NULL)
<span class="lineNum">   11550 </span>            :                   *if_p = true;
<span class="lineNum">   11551 </span>            : 
<span class="lineNum">   11552 </span>            :                 if (discard_else)
<span class="lineNum">   11553 </span><span class="lineCov">         54 :                   {</span>
<span class="lineNum">   11554 </span><span class="lineCov">         54 :                     ELSE_CLAUSE (statement) = NULL_TREE;</span>
<span class="lineNum">   11555 </span><span class="lineCov">         54 :                     in_discarded_stmt = was_discarded;</span>
<span class="lineNum">   11556 </span>            :                     --c_inhibit_evaluation_warnings;
<span class="lineNum">   11557 </span>            :                   }
<span class="lineNum">   11558 </span>            :               }
<span class="lineNum">   11559 </span><span class="lineCov">         36 :             else</span>
<span class="lineNum">   11560 </span><span class="lineCov">         36 :               {</span>
<span class="lineNum">   11561 </span><span class="lineCov">         36 :                 /* This if statement does not have an else clause.  If</span>
<span class="lineNum">   11562 </span><span class="lineCov">         36 :                    NESTED_IF is true, then the then-clause has an if</span>
<span class="lineNum">   11563 </span>            :                    statement which does have an else clause.  We warn
<span class="lineNum">   11564 </span>            :                    about the potential ambiguity.  */
<span class="lineNum">   11565 </span><span class="lineCov">         75 :                 if (nested_if)</span>
<span class="lineNum">   11566 </span>            :                   warning_at (EXPR_LOCATION (statement), OPT_Wdangling_else,
<span class="lineNum">   11567 </span>            :                               &quot;suggest explicit braces to avoid ambiguous&quot;
<span class="lineNum">   11568 </span>            :                               &quot; %&lt;else%&gt;&quot;);
<span class="lineNum">   11569 </span>            :                 if (warn_duplicated_cond)
<span class="lineNum">   11570 </span>            :                   {
<span class="lineNum">   11571 </span><span class="lineCov">         12 :                     /* We don't need the condition chain anymore.  */</span>
<span class="lineNum">   11572 </span><span class="lineCov">         12 :                     delete chain;</span>
<span class="lineNum">   11573 </span>            :                     chain = NULL;
<span class="lineNum">   11574 </span>            :                   }
<span class="lineNum">   11575 </span><span class="lineCov">     409667 :               }</span>
<span class="lineNum">   11576 </span>            : 
<span class="lineNum">   11577 </span><span class="lineCov">     409667 :             /* Now we're all done with the if-statement.  */</span>
<span class="lineNum">   11578 </span>            :             finish_if_stmt (statement);
<span class="lineNum">   11579 </span>            :           }
<span class="lineNum">   11580 </span><span class="lineCov">     409667 :         else</span>
<span class="lineNum">   11581 </span>            :           {
<span class="lineNum">   11582 </span>            :             bool in_switch_statement_p;
<span class="lineNum">   11583 </span>            :             unsigned char in_statement;
<span class="lineNum">   11584 </span>            : 
<span class="lineNum">   11585 </span>            :             /* Add the condition.  */
<span class="lineNum">   11586 </span>            :             finish_switch_cond (condition, statement);
<span class="lineNum">   11587 </span><span class="lineCov">     409667 : </span>
<span class="lineNum">   11588 </span><span class="lineCov">       4066 :             /* Parse the body of the switch-statement.  */</span>
<span class="lineNum">   11589 </span>            :             in_switch_statement_p = parser-&gt;in_switch_statement_p;
<span class="lineNum">   11590 </span><span class="lineCov">     409667 :             in_statement = parser-&gt;in_statement;</span>
<span class="lineNum">   11591 </span>            :             parser-&gt;in_switch_statement_p = true;
<span class="lineNum">   11592 </span><span class="lineCov">          4 :             parser-&gt;in_statement |= IN_SWITCH_STMT;</span>
<span class="lineNum">   11593 </span><span class="lineCov">          4 :             cp_parser_implicitly_scoped_statement (parser, if_p,</span>
<span class="lineNum">   11594 </span><span class="lineCov">          4 :                                                    guard_tinfo);</span>
<span class="lineNum">   11595 </span>            :             parser-&gt;in_switch_statement_p = in_switch_statement_p;
<span class="lineNum">   11596 </span>            :             parser-&gt;in_statement = in_statement;
<span class="lineNum">   11597 </span>            : 
<span class="lineNum">   11598 </span>            :             /* Now we're all done with the switch-statement.  */
<span class="lineNum">   11599 </span>            :             finish_switch_stmt (statement);
<span class="lineNum">   11600 </span>            :           }
<span class="lineNum">   11601 </span>            : 
<span class="lineNum">   11602 </span>            :         return statement;
<span class="lineNum">   11603 </span><span class="lineCov">    1235614 :       }</span>
<span class="lineNum">   11604 </span><span class="lineCov">        335 :       break;</span>
<span class="lineNum">   11605 </span>            : 
<span class="lineNum">   11606 </span>            :     default:
<span class="lineNum">   11607 </span><span class="lineCov">    1235614 :       cp_parser_error (parser, &quot;expected selection-statement&quot;);</span>
<span class="lineNum">   11608 </span>            :       return error_mark_node;
<span class="lineNum">   11609 </span>            :     }
<span class="lineNum">   11610 </span><span class="lineCov">         57 : }</span>
<span class="lineNum">   11611 </span><span class="lineCov">         57 : </span>
<span class="lineNum">   11612 </span>            : /* Helper function for cp_parser_condition and cp_parser_simple_declaration.
<span class="lineNum">   11613 </span>            :    If we have seen at least one decl-specifier, and the next token
<span class="lineNum">   11614 </span>            :    is not a parenthesis, then we must be looking at a declaration.
<span class="lineNum">   11615 </span>            :    (After &quot;int (&quot; we might be looking at a functional cast.)  */
<a name="11616"><span class="lineNum">   11616 </span><span class="lineCov">    1645281 : </span></a>
<span class="lineNum">   11617 </span>            : static void
<span class="lineNum">   11618 </span>            : cp_parser_maybe_commit_to_declaration (cp_parser* parser,
<span class="lineNum">   11619 </span>            :                                        bool any_specifiers_p)
<span class="lineNum">   11620 </span><span class="lineCov">      10875 : {</span>
<span class="lineNum">   11621 </span><span class="lineCov">      10875 :   if (any_specifiers_p</span>
<span class="lineNum">   11622 </span>            :       &amp;&amp; cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_OPEN_PAREN)
<span class="lineNum">   11623 </span>            :       &amp;&amp; cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_OPEN_BRACE)
<span class="lineNum">   11624 </span><span class="lineCov">      10875 :       &amp;&amp; !cp_parser_error_occurred (parser))</span>
<span class="lineNum">   11625 </span>            :     cp_parser_commit_to_tentative_parse (parser);
<span class="lineNum">   11626 </span>            : }
<span class="lineNum">   11627 </span><span class="lineCov">      10875 : </span>
<span class="lineNum">   11628 </span><span class="lineCov">      10875 : /* Helper function for cp_parser_condition.  Enforces [stmt.stmt]/2:</span>
<span class="lineNum">   11629 </span><span class="lineCov">      10875 :    The declarator shall not specify a function or an array.  Returns</span>
<span class="lineNum">   11630 </span><span class="lineCov">      10875 :    TRUE if the declarator is valid, FALSE otherwise.  */</span>
<a name="11631"><span class="lineNum">   11631 </span><span class="lineCov">      10875 : </span></a>
<span class="lineNum">   11632 </span>            : static bool
<span class="lineNum">   11633 </span><span class="lineCov">      10875 : cp_parser_check_condition_declarator (cp_parser* parser,</span>
<span class="lineNum">   11634 </span><span class="lineCov">      10875 :                                      cp_declarator *declarator,</span>
<span class="lineNum">   11635 </span>            :                                      location_t loc)
<span class="lineNum">   11636 </span>            : {
<span class="lineNum">   11637 </span><span class="lineCov">      10875 :   if (declarator == cp_error_declarator</span>
<span class="lineNum">   11638 </span>            :       || function_declarator_p (declarator)
<span class="lineNum">   11639 </span>            :       || declarator-&gt;kind == cdk_array)
<span class="lineNum">   11640 </span>            :     {
<span class="lineNum">   11641 </span>            :       if (declarator == cp_error_declarator)
<span class="lineNum">   11642 </span><span class="lineNoCov">          0 :         /* Already complained.  */;</span>
<span class="lineNum">   11643 </span>            :       else if (declarator-&gt;kind == cdk_array)
<span class="lineNum">   11644 </span><span class="lineNoCov">          0 :        error_at (loc, &quot;condition declares an array&quot;);</span>
<span class="lineNum">   11645 </span><span class="lineNoCov">          0 :       else</span>
<span class="lineNum">   11646 </span><span class="lineNoCov">          0 :        error_at (loc, &quot;condition declares a function&quot;);</span>
<span class="lineNum">   11647 </span>            :       if (parser-&gt;fully_implicit_function_template_p)
<span class="lineNum">   11648 </span>            :        abort_fully_implicit_template (parser);
<span class="lineNum">   11649 </span>            :       cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,
<span class="lineNum">   11650 </span>            :                                             /*or_comma=*/false,
<span class="lineNum">   11651 </span>            :                                             /*consume_paren=*/false);
<span class="lineNum">   11652 </span>            :       return false;
<span class="lineNum">   11653 </span>            :     }
<span class="lineNum">   11654 </span>            :   else
<span class="lineNum">   11655 </span>            :     return true;
<span class="lineNum">   11656 </span><span class="lineCov">   10305151 : }</span>
<span class="lineNum">   11657 </span>            : 
<span class="lineNum">   11658 </span>            : /* Parse a condition.
<span class="lineNum">   11659 </span><span class="lineCov">   10305151 : </span>
<span class="lineNum">   11660 </span><span class="lineCov">   10301680 :    condition:</span>
<span class="lineNum">   11661 </span><span class="lineCov">    9896744 :      expression</span>
<span class="lineNum">   11662 </span><span class="lineCov">   10305151 :      type-specifier-seq declarator = initializer-clause</span>
<span class="lineNum">   11663 </span><span class="lineCov">    8308769 :      type-specifier-seq declarator braced-init-list</span>
<span class="lineNum">   11664 </span><span class="lineCov">   10305151 : </span>
<span class="lineNum">   11665 </span>            :    GNU Extension:
<span class="lineNum">   11666 </span>            : 
<span class="lineNum">   11667 </span>            :    condition:
<span class="lineNum">   11668 </span>            :      type-specifier-seq declarator asm-specification [opt]
<span class="lineNum">   11669 </span>            :        attributes [opt] = assignment-expression
<span class="lineNum">   11670 </span>            : 
<span class="lineNum">   11671 </span><span class="lineCov">      15410 :    Returns the expression that should be tested.  */</span>
<a name="11672"><span class="lineNum">   11672 </span>            : </a>
<span class="lineNum">   11673 </span>            : static tree
<span class="lineNum">   11674 </span>            : cp_parser_condition (cp_parser* parser)
<span class="lineNum">   11675 </span><span class="lineCov">      15410 : {</span>
<span class="lineNum">   11676 </span><span class="lineCov">      15398 :   cp_decl_specifier_seq type_specifiers;</span>
<span class="lineNum">   11677 </span><span class="lineCov">      30781 :   const char *saved_message;</span>
<span class="lineNum">   11678 </span>            :   int declares_class_or_enum;
<span class="lineNum">   11679 </span><span class="lineCov">         57 : </span>
<span class="lineNum">   11680 </span>            :   /* Try the declaration first.  */
<span class="lineNum">   11681 </span><span class="lineCov">         45 :   cp_parser_parse_tentatively (parser);</span>
<span class="lineNum">   11682 </span><span class="lineCov">         18 :   /* New types are not allowed in the type-specifier-seq for a</span>
<span class="lineNum">   11683 </span>            :      condition.  */
<span class="lineNum">   11684 </span><span class="lineCov">         27 :   saved_message = parser-&gt;type_definition_forbidden_message;</span>
<span class="lineNum">   11685 </span><span class="lineCov">         57 :   parser-&gt;type_definition_forbidden_message</span>
<span class="lineNum">   11686 </span><span class="lineCov">          9 :     = G_(&quot;types may not be defined in conditions&quot;);</span>
<span class="lineNum">   11687 </span><span class="lineCov">        114 :   /* Parse the type-specifier-seq.  */</span>
<span class="lineNum">   11688 </span>            :   cp_parser_decl_specifier_seq (parser,
<span class="lineNum">   11689 </span>            :                                 CP_PARSER_FLAGS_ONLY_TYPE_OR_CONSTEXPR,
<span class="lineNum">   11690 </span><span class="lineCov">         57 :                                 &amp;type_specifiers,</span>
<span class="lineNum">   11691 </span>            :                                 &amp;declares_class_or_enum);
<span class="lineNum">   11692 </span>            :   /* Restore the saved message.  */
<span class="lineNum">   11693 </span>            :   parser-&gt;type_definition_forbidden_message = saved_message;
<span class="lineNum">   11694 </span>            : 
<span class="lineNum">   11695 </span>            :   cp_parser_maybe_commit_to_declaration (parser,
<span class="lineNum">   11696 </span>            :                                          type_specifiers.any_specifiers_p);
<span class="lineNum">   11697 </span>            : 
<span class="lineNum">   11698 </span>            :   /* If all is well, we might be looking at a declaration.  */
<span class="lineNum">   11699 </span>            :   if (!cp_parser_error_occurred (parser))
<span class="lineNum">   11700 </span>            :     {
<span class="lineNum">   11701 </span>            :       tree decl;
<span class="lineNum">   11702 </span>            :       tree asm_specification;
<span class="lineNum">   11703 </span>            :       tree attributes;
<span class="lineNum">   11704 </span>            :       cp_declarator *declarator;
<span class="lineNum">   11705 </span>            :       tree initializer = NULL_TREE;
<span class="lineNum">   11706 </span>            :       location_t loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">   11707 </span>            : 
<span class="lineNum">   11708 </span>            :       /* Parse the declarator.  */
<span class="lineNum">   11709 </span>            :       declarator = cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,
<span class="lineNum">   11710 </span>            :                                          /*ctor_dtor_or_conv_p=*/NULL,
<span class="lineNum">   11711 </span>            :                                          /*parenthesized_p=*/NULL,
<span class="lineNum">   11712 </span><span class="lineCov">    1965017 :                                          /*member_p=*/false,</span>
<span class="lineNum">   11713 </span>            :                                          /*friend_p=*/false);
<span class="lineNum">   11714 </span><span class="lineCov">    1965017 :       /* Parse the attributes.  */</span>
<span class="lineNum">   11715 </span><span class="lineCov">    1965017 :       attributes = cp_parser_attributes_opt (parser);</span>
<span class="lineNum">   11716 </span><span class="lineCov">    1965017 :       /* Parse the asm-specification.  */</span>
<span class="lineNum">   11717 </span>            :       asm_specification = cp_parser_asm_specification_opt (parser);
<span class="lineNum">   11718 </span>            :       /* If the next token is not an `=' or '{', then we might still be
<span class="lineNum">   11719 </span><span class="lineCov">    1965017 :          looking at an expression.  For example:</span>
<span class="lineNum">   11720 </span>            : 
<span class="lineNum">   11721 </span>            :            if (A(a).x)
<span class="lineNum">   11722 </span><span class="lineCov">    1965017 : </span>
<span class="lineNum">   11723 </span><span class="lineCov">    1965017 :          looks like a decl-specifier-seq and a declarator -- but then</span>
<span class="lineNum">   11724 </span><span class="lineCov">    1965017 :          there is no `=', so this is an expression.  */</span>
<span class="lineNum">   11725 </span>            :       if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_EQ)
<span class="lineNum">   11726 </span><span class="lineCov">    1965017 :           &amp;&amp; cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_OPEN_BRACE))</span>
<span class="lineNum">   11727 </span>            :         cp_parser_simulate_error (parser);
<span class="lineNum">   11728 </span>            :         
<span class="lineNum">   11729 </span>            :       /* If we did see an `=' or '{', then we are looking at a declaration
<span class="lineNum">   11730 </span>            :          for sure.  */
<span class="lineNum">   11731 </span><span class="lineCov">    1965017 :       if (cp_parser_parse_definitely (parser))</span>
<span class="lineNum">   11732 </span>            :         {
<span class="lineNum">   11733 </span><span class="lineCov">    3930034 :           tree pushed_scope;</span>
<span class="lineNum">   11734 </span><span class="lineCov">    1965017 :           bool non_constant_p = false;</span>
<span class="lineNum">   11735 </span>            :           int flags = LOOKUP_ONLYCONVERTING;
<span class="lineNum">   11736 </span>            : 
<span class="lineNum">   11737 </span><span class="lineCov">    3930034 :           if (!cp_parser_check_condition_declarator (parser, declarator, loc))</span>
<span class="lineNum">   11738 </span>            :             return error_mark_node;
<span class="lineNum">   11739 </span><span class="lineCov">      24188 : </span>
<span class="lineNum">   11740 </span><span class="lineCov">      24188 :           /* Create the declaration.  */</span>
<span class="lineNum">   11741 </span><span class="lineCov">      24188 :           decl = start_decl (declarator, &amp;type_specifiers,</span>
<span class="lineNum">   11742 </span><span class="lineCov">      24188 :                              /*initialized_p=*/true,</span>
<span class="lineNum">   11743 </span><span class="lineCov">      24188 :                              attributes, /*prefix_attributes=*/NULL_TREE,</span>
<span class="lineNum">   11744 </span><span class="lineCov">      48376 :                              &amp;pushed_scope);</span>
<span class="lineNum">   11745 </span>            : 
<span class="lineNum">   11746 </span>            :           /* Parse the initializer.  */
<span class="lineNum">   11747 </span><span class="lineCov">      24188 :           if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_BRACE))</span>
<span class="lineNum">   11748 </span>            :             {
<span class="lineNum">   11749 </span>            :               initializer = cp_parser_braced_list (parser, &amp;non_constant_p);
<span class="lineNum">   11750 </span>            :               CONSTRUCTOR_IS_DIRECT_INIT (initializer) = 1;
<span class="lineNum">   11751 </span>            :               flags = 0;
<span class="lineNum">   11752 </span>            :             }
<span class="lineNum">   11753 </span><span class="lineCov">      24188 :           else if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_EQ))</span>
<span class="lineNum">   11754 </span>            :             {
<span class="lineNum">   11755 </span><span class="lineCov">      24188 :               /* Consume the `='.  */</span>
<span class="lineNum">   11756 </span>            :               cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   11757 </span>            :               initializer = cp_parser_initializer_clause (parser,
<span class="lineNum">   11758 </span>            :                                                           &amp;non_constant_p);
<span class="lineNum">   11759 </span>            :             }
<span class="lineNum">   11760 </span>            :           else
<span class="lineNum">   11761 </span>            :             {
<span class="lineNum">   11762 </span>            :               cp_parser_error (parser, &quot;expected initializer&quot;);
<span class="lineNum">   11763 </span><span class="lineCov">      48376 :               initializer = error_mark_node;</span>
<span class="lineNum">   11764 </span><span class="lineCov">      24188 :             }</span>
<span class="lineNum">   11765 </span><span class="lineCov">       8823 :           if (BRACE_ENCLOSED_INITIALIZER_P (initializer))</span>
<span class="lineNum">   11766 </span>            :             maybe_warn_cpp0x (CPP0X_INITIALIZER_LISTS);
<span class="lineNum">   11767 </span>            : 
<span class="lineNum">   11768 </span>            :           /* Process the initializer.  */
<span class="lineNum">   11769 </span><span class="lineCov">      24188 :           cp_finish_decl (decl,</span>
<span class="lineNum">   11770 </span>            :                           initializer, !non_constant_p,
<span class="lineNum">   11771 </span><span class="lineCov">      15410 :                           asm_specification,</span>
<span class="lineNum">   11772 </span><span class="lineCov">      15410 :                           flags);</span>
<span class="lineNum">   11773 </span><span class="lineCov">      15410 : </span>
<span class="lineNum">   11774 </span>            :           if (pushed_scope)
<span class="lineNum">   11775 </span><span class="lineCov">      15410 :             pop_scope (pushed_scope);</span>
<span class="lineNum">   11776 </span><span class="lineCov">         57 : </span>
<span class="lineNum">   11777 </span>            :           return convert_from_reference (decl);
<span class="lineNum">   11778 </span>            :         }
<span class="lineNum">   11779 </span><span class="lineCov">      15353 :     }</span>
<span class="lineNum">   11780 </span>            :   /* If we didn't even get past the declarator successfully, we are
<span class="lineNum">   11781 </span>            :      definitely not looking at a declaration.  */
<span class="lineNum">   11782 </span>            :   else
<span class="lineNum">   11783 </span>            :     cp_parser_abort_tentative_parse (parser);
<span class="lineNum">   11784 </span>            : 
<span class="lineNum">   11785 </span><span class="lineCov">      15353 :   /* Otherwise, we are looking at an expression.  */</span>
<span class="lineNum">   11786 </span>            :   return cp_parser_expression (parser);
<span class="lineNum">   11787 </span><span class="lineCov">         18 : }</span>
<span class="lineNum">   11788 </span><span class="lineCov">         18 : </span>
<span class="lineNum">   11789 </span><span class="lineCov">         18 : /* Parses a for-statement or range-for-statement until the closing ')',</span>
<span class="lineNum">   11790 </span>            :    not included. */
<a name="11791"><span class="lineNum">   11791 </span><span class="lineCov">      15335 : </span></a>
<span class="lineNum">   11792 </span>            : static tree
<span class="lineNum">   11793 </span>            : cp_parser_for (cp_parser *parser, bool ivdep, unsigned short unroll)
<span class="lineNum">   11794 </span><span class="lineCov">      15326 : {</span>
<span class="lineNum">   11795 </span><span class="lineCov">      15326 :   tree init, scope, decl;</span>
<span class="lineNum">   11796 </span><span class="lineCov">      15326 :   bool is_range_for;</span>
<span class="lineNum">   11797 </span>            : 
<span class="lineNum">   11798 </span>            :   /* Begin the for-statement.  */
<span class="lineNum">   11799 </span>            :   scope = begin_for_scope (&amp;init);
<span class="lineNum">   11800 </span><span class="lineCov">          9 : </span>
<span class="lineNum">   11801 </span><span class="lineCov">          9 :   /* Parse the initialization.  */</span>
<span class="lineNum">   11802 </span>            :   is_range_for = cp_parser_init_statement (parser, &amp;decl);
<span class="lineNum">   11803 </span><span class="lineCov">      15353 : </span>
<span class="lineNum">   11804 </span><span class="lineCov">         20 :   if (is_range_for)</span>
<span class="lineNum">   11805 </span>            :     return cp_parser_range_for (parser, scope, init, decl, ivdep, unroll);
<span class="lineNum">   11806 </span>            :   else
<span class="lineNum">   11807 </span><span class="lineCov">      30706 :     return cp_parser_c_for (parser, scope, init, ivdep, unroll);</span>
<span class="lineNum">   11808 </span><span class="lineCov">      15353 : }</span>
<a name="11809"><span class="lineNum">   11809 </span>            : </a>
<span class="lineNum">   11810 </span>            : static tree
<span class="lineNum">   11811 </span>            : cp_parser_c_for (cp_parser *parser, tree scope, tree init, bool ivdep,
<span class="lineNum">   11812 </span><span class="lineCov">      15353 :                  unsigned short unroll)</span>
<span class="lineNum">   11813 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   11814 </span>            :   /* Normal for loop */
<span class="lineNum">   11815 </span><span class="lineCov">      15353 :   tree condition = NULL_TREE;</span>
<span class="lineNum">   11816 </span>            :   tree expression = NULL_TREE;
<span class="lineNum">   11817 </span>            :   tree stmt;
<span class="lineNum">   11818 </span>            : 
<span class="lineNum">   11819 </span>            :   stmt = begin_for_stmt (scope, init);
<span class="lineNum">   11820 </span>            :   /* The init-statement has already been parsed in
<span class="lineNum">   11821 </span><span class="lineCov">    1940829 :      cp_parser_init_statement, so no work is needed here.  */</span>
<span class="lineNum">   11822 </span>            :   finish_init_stmt (stmt);
<span class="lineNum">   11823 </span>            : 
<span class="lineNum">   11824 </span><span class="lineCov">    1949607 :   /* If there's a condition, process it.  */</span>
<span class="lineNum">   11825 </span>            :   if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_SEMICOLON))
<span class="lineNum">   11826 </span>            :     condition = cp_parser_condition (parser);
<span class="lineNum">   11827 </span>            :   else if (ivdep)
<span class="lineNum">   11828 </span>            :     {
<span class="lineNum">   11829 </span>            :       cp_parser_error (parser, &quot;missing loop condition in loop with &quot;
<span class="lineNum">   11830 </span>            :                        &quot;%&lt;GCC ivdep%&gt; pragma&quot;);
<span class="lineNum">   11831 </span><span class="lineCov">     198448 :       condition = error_mark_node;</span>
<span class="lineNum">   11832 </span>            :     }
<span class="lineNum">   11833 </span><span class="lineCov">     198448 :   else if (unroll)</span>
<span class="lineNum">   11834 </span><span class="lineCov">     198448 :     {</span>
<span class="lineNum">   11835 </span>            :       cp_parser_error (parser, &quot;missing loop condition in loop with &quot;
<span class="lineNum">   11836 </span>            :                        &quot;%&lt;GCC unroll%&gt; pragma&quot;);
<span class="lineNum">   11837 </span><span class="lineCov">     198448 :       condition = error_mark_node;</span>
<span class="lineNum">   11838 </span>            :     }
<span class="lineNum">   11839 </span>            :   finish_for_cond (condition, stmt, ivdep, unroll);
<span class="lineNum">   11840 </span><span class="lineCov">     198448 :   /* Look for the `;'.  */</span>
<span class="lineNum">   11841 </span>            :   cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);
<span class="lineNum">   11842 </span><span class="lineCov">     198448 : </span>
<span class="lineNum">   11843 </span><span class="lineCov">       2333 :   /* If there's an expression, process it.  */</span>
<span class="lineNum">   11844 </span>            :   if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_CLOSE_PAREN))
<span class="lineNum">   11845 </span><span class="lineCov">     196115 :     expression = cp_parser_expression (parser);</span>
<span class="lineNum">   11846 </span>            :   finish_for_expr (expression, stmt);
<span class="lineNum">   11847 </span>            : 
<span class="lineNum">   11848 </span>            :   return stmt;
<span class="lineNum">   11849 </span><span class="lineCov">     196115 : }</span>
<span class="lineNum">   11850 </span>            : 
<span class="lineNum">   11851 </span>            : /* Tries to parse a range-based for-statement:
<span class="lineNum">   11852 </span>            : 
<span class="lineNum">   11853 </span><span class="lineCov">     196115 :   range-based-for:</span>
<span class="lineNum">   11854 </span><span class="lineCov">     196115 :     decl-specifier-seq declarator : expression</span>
<span class="lineNum">   11855 </span><span class="lineCov">     196115 : </span>
<span class="lineNum">   11856 </span>            :   The decl-specifier-seq declarator and the `:' are already parsed by
<span class="lineNum">   11857 </span><span class="lineCov">     196115 :   cp_parser_init_statement.  If processing_template_decl it returns a</span>
<span class="lineNum">   11858 </span>            :   newly created RANGE_FOR_STMT; if not, it is converted to a
<span class="lineNum">   11859 </span>            :   regular FOR_STMT.  */
<a name="11860"><span class="lineNum">   11860 </span><span class="lineCov">     196115 : </span></a>
<span class="lineNum">   11861 </span>            : static tree
<span class="lineNum">   11862 </span>            : cp_parser_range_for (cp_parser *parser, tree scope, tree init, tree range_decl,
<span class="lineNum">   11863 </span><span class="lineCov">     196115 :                      bool ivdep, unsigned short unroll)</span>
<span class="lineNum">   11864 </span><span class="lineCov">     189950 : {</span>
<span class="lineNum">   11865 </span><span class="lineCov">       6165 :   tree stmt, range_expr;</span>
<span class="lineNum">   11866 </span>            :   auto_vec &lt;cxx_binding *, 16&gt; bindings;
<span class="lineNum">   11867 </span><span class="lineCov">          3 :   auto_vec &lt;tree, 16&gt; names;</span>
<span class="lineNum">   11868 </span>            :   tree decomp_first_name = NULL_TREE;
<span class="lineNum">   11869 </span><span class="lineCov">          3 :   unsigned int decomp_cnt = 0;</span>
<span class="lineNum">   11870 </span>            : 
<span class="lineNum">   11871 </span><span class="lineCov">       6162 :   /* Get the range declaration momentarily out of the way so that</span>
<span class="lineNum">   11872 </span>            :      the range expression doesn't clash with it. */
<span class="lineNum">   11873 </span><span class="lineNoCov">          0 :   if (range_decl != error_mark_node)</span>
<span class="lineNum">   11874 </span>            :     {
<span class="lineNum">   11875 </span><span class="lineNoCov">          0 :       if (DECL_HAS_VALUE_EXPR_P (range_decl))</span>
<span class="lineNum">   11876 </span>            :         {
<span class="lineNum">   11877 </span><span class="lineCov">     196115 :           tree v = DECL_VALUE_EXPR (range_decl);</span>
<span class="lineNum">   11878 </span>            :           /* For decomposition declaration get all of the corresponding
<span class="lineNum">   11879 </span><span class="lineCov">     196115 :              declarations out of the way.  */</span>
<span class="lineNum">   11880 </span>            :           if (TREE_CODE (v) == ARRAY_REF
<span class="lineNum">   11881 </span>            :               &amp;&amp; VAR_P (TREE_OPERAND (v, 0))
<span class="lineNum">   11882 </span><span class="lineCov">     196115 :               &amp;&amp; DECL_DECOMPOSITION_P (TREE_OPERAND (v, 0)))</span>
<span class="lineNum">   11883 </span><span class="lineCov">     186562 :             {</span>
<span class="lineNum">   11884 </span><span class="lineCov">     196115 :               tree d = range_decl;</span>
<span class="lineNum">   11885 </span>            :               range_decl = TREE_OPERAND (v, 0);
<span class="lineNum">   11886 </span><span class="lineCov">     196115 :               decomp_cnt = tree_to_uhwi (TREE_OPERAND (v, 1)) + 1;</span>
<span class="lineNum">   11887 </span>            :               decomp_first_name = d;
<span class="lineNum">   11888 </span>            :               for (unsigned int i = 0; i &lt; decomp_cnt; i++, d = DECL_CHAIN (d))
<span class="lineNum">   11889 </span>            :                 {
<span class="lineNum">   11890 </span>            :                   tree name = DECL_NAME (d);
<span class="lineNum">   11891 </span>            :                   names.safe_push (name);
<span class="lineNum">   11892 </span>            :                   bindings.safe_push (IDENTIFIER_BINDING (name));
<span class="lineNum">   11893 </span>            :                   IDENTIFIER_BINDING (name)
<span class="lineNum">   11894 </span>            :                     = IDENTIFIER_BINDING (name)-&gt;previous;
<span class="lineNum">   11895 </span>            :                 }
<span class="lineNum">   11896 </span>            :             }
<span class="lineNum">   11897 </span>            :         }
<span class="lineNum">   11898 </span>            :       if (names.is_empty ())
<span class="lineNum">   11899 </span>            :         {
<span class="lineNum">   11900 </span><span class="lineCov">       2333 :           tree name = DECL_NAME (range_decl);</span>
<span class="lineNum">   11901 </span>            :           names.safe_push (name);
<span class="lineNum">   11902 </span>            :           bindings.safe_push (IDENTIFIER_BINDING (name));
<span class="lineNum">   11903 </span><span class="lineCov">       2333 :           IDENTIFIER_BINDING (name) = IDENTIFIER_BINDING (name)-&gt;previous;</span>
<span class="lineNum">   11904 </span><span class="lineCov">       2333 :         }</span>
<span class="lineNum">   11905 </span><span class="lineCov">       4666 :     }</span>
<span class="lineNum">   11906 </span><span class="lineCov">       2333 : </span>
<span class="lineNum">   11907 </span><span class="lineCov">       2333 :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_BRACE))</span>
<span class="lineNum">   11908 </span>            :     {
<span class="lineNum">   11909 </span>            :       bool expr_non_constant_p;
<span class="lineNum">   11910 </span>            :       range_expr = cp_parser_braced_list (parser, &amp;expr_non_constant_p);
<span class="lineNum">   11911 </span><span class="lineCov">       2333 :     }</span>
<span class="lineNum">   11912 </span>            :   else
<span class="lineNum">   11913 </span><span class="lineCov">       2323 :     range_expr = cp_parser_expression (parser);</span>
<span class="lineNum">   11914 </span>            : 
<span class="lineNum">   11915 </span><span class="lineCov">         43 :   /* Put the range declaration(s) back into scope. */</span>
<span class="lineNum">   11916 </span>            :   for (unsigned int i = 0; i &lt; names.length (); i++)
<span class="lineNum">   11917 </span>            :     {
<span class="lineNum">   11918 </span><span class="lineCov">         43 :       cxx_binding *binding = bindings[i];</span>
<span class="lineNum">   11919 </span><span class="lineCov">         43 :       binding-&gt;previous = IDENTIFIER_BINDING (names[i]);</span>
<span class="lineNum">   11920 </span><span class="lineCov">         86 :       IDENTIFIER_BINDING (names[i]) = binding;</span>
<span class="lineNum">   11921 </span>            :     }
<span class="lineNum">   11922 </span><span class="lineCov">         43 : </span>
<span class="lineNum">   11923 </span><span class="lineCov">         43 :   /* If in template, STMT is converted to a normal for-statement</span>
<span class="lineNum">   11924 </span><span class="lineCov">         43 :      at instantiation. If not, it is done just ahead. */</span>
<span class="lineNum">   11925 </span><span class="lineCov">         43 :   if (processing_template_decl)</span>
<span class="lineNum">   11926 </span><span class="lineCov">        287 :     {</span>
<span class="lineNum">   11927 </span>            :       if (check_for_bare_parameter_packs (range_expr))
<span class="lineNum">   11928 </span><span class="lineCov">        244 :         range_expr = error_mark_node;</span>
<span class="lineNum">   11929 </span><span class="lineCov">        244 :       stmt = begin_range_for_stmt (scope, init);</span>
<span class="lineNum">   11930 </span><span class="lineCov">        244 :       if (ivdep)</span>
<span class="lineNum">   11931 </span><span class="lineCov">        732 :         RANGE_FOR_IVDEP (stmt) = 1;</span>
<span class="lineNum">   11932 </span><span class="lineCov">        244 :       if (unroll)</span>
<span class="lineNum">   11933 </span>            :         RANGE_FOR_UNROLL (stmt) = build_int_cst (integer_type_node, unroll);
<span class="lineNum">   11934 </span>            :       finish_range_for_decl (stmt, range_decl, range_expr);
<span class="lineNum">   11935 </span>            :       if (!type_dependent_expression_p (range_expr)
<span class="lineNum">   11936 </span><span class="lineCov">       2323 :           /* do_auto_deduction doesn't mess with template init-lists.  */</span>
<span class="lineNum">   11937 </span>            :           &amp;&amp; !BRACE_ENCLOSED_INITIALIZER_P (range_expr))
<span class="lineNum">   11938 </span><span class="lineCov">       2280 :         do_range_for_auto_deduction (range_decl, range_expr);</span>
<span class="lineNum">   11939 </span><span class="lineCov">       2280 :     }</span>
<span class="lineNum">   11940 </span><span class="lineCov">       2280 :   else</span>
<span class="lineNum">   11941 </span><span class="lineCov">       2280 :     {</span>
<span class="lineNum">   11942 </span>            :       stmt = begin_for_stmt (scope, init);
<span class="lineNum">   11943 </span>            :       stmt = cp_convert_range_for (stmt, range_decl, range_expr,
<span class="lineNum">   11944 </span>            :                                    decomp_first_name, decomp_cnt, ivdep,
<span class="lineNum">   11945 </span><span class="lineCov">       2333 :                                    unroll);</span>
<span class="lineNum">   11946 </span>            :     }
<span class="lineNum">   11947 </span><span class="lineCov">         18 :   return stmt;</span>
<span class="lineNum">   11948 </span><span class="lineCov">         18 : }</span>
<span class="lineNum">   11949 </span>            : 
<span class="lineNum">   11950 </span>            : /* Subroutine of cp_convert_range_for: given the initializer expression,
<span class="lineNum">   11951 </span><span class="lineCov">       2315 :    builds up the range temporary.  */</span>
<a name="11952"><span class="lineNum">   11952 </span>            : </a>
<span class="lineNum">   11953 </span>            : static tree
<span class="lineNum">   11954 </span><span class="lineCov">       9714 : build_range_temp (tree range_expr)</span>
<span class="lineNum">   11955 </span>            : {
<span class="lineNum">   11956 </span><span class="lineCov">       2524 :   tree range_type, range_temp;</span>
<span class="lineNum">   11957 </span><span class="lineCov">       2524 : </span>
<span class="lineNum">   11958 </span><span class="lineCov">       5048 :   /* Find out the type deduced by the declaration</span>
<span class="lineNum">   11959 </span>            :      `auto &amp;&amp;__range = range_expr'.  */
<span class="lineNum">   11960 </span>            :   range_type = cp_build_reference_type (make_auto (), true);
<span class="lineNum">   11961 </span>            :   range_type = do_auto_deduction (range_type, range_expr,
<span class="lineNum">   11962 </span>            :                                   type_uses_auto (range_type));
<span class="lineNum">   11963 </span><span class="lineCov">       2333 : </span>
<span class="lineNum">   11964 </span>            :   /* Create the __range variable.  */
<span class="lineNum">   11965 </span><span class="lineCov">       1548 :   range_temp = build_decl (input_location, VAR_DECL, for_range__identifier,</span>
<span class="lineNum">   11966 </span><span class="lineCov">          2 :                            range_type);</span>
<span class="lineNum">   11967 </span><span class="lineCov">       1548 :   TREE_USED (range_temp) = 1;</span>
<span class="lineNum">   11968 </span><span class="lineCov">       1548 :   DECL_ARTIFICIAL (range_temp) = 1;</span>
<span class="lineNum">   11969 </span><span class="lineCov">          1 : </span>
<span class="lineNum">   11970 </span><span class="lineCov">       1548 :   return range_temp;</span>
<span class="lineNum">   11971 </span><span class="lineCov">          2 : }</span>
<span class="lineNum">   11972 </span><span class="lineCov">       1548 : </span>
<span class="lineNum">   11973 </span><span class="lineCov">       1548 : /* Used by cp_parser_range_for in template context: we aren't going to</span>
<span class="lineNum">   11974 </span>            :    do a full conversion yet, but we still need to resolve auto in the
<span class="lineNum">   11975 </span><span class="lineCov">       1548 :    type of the for-range-declaration if present.  This is basically</span>
<span class="lineNum">   11976 </span><span class="lineCov">        364 :    a shortcut version of cp_convert_range_for.  */</span>
<a name="11977"><span class="lineNum">   11977 </span>            : </a>
<span class="lineNum">   11978 </span>            : static void
<span class="lineNum">   11979 </span>            : do_range_for_auto_deduction (tree decl, tree range_expr)
<span class="lineNum">   11980 </span><span class="lineCov">        785 : {</span>
<span class="lineNum">   11981 </span><span class="lineCov">        785 :   tree auto_node = type_uses_auto (TREE_TYPE (decl));</span>
<span class="lineNum">   11982 </span>            :   if (auto_node)
<span class="lineNum">   11983 </span>            :     {
<span class="lineNum">   11984 </span>            :       tree begin_dummy, end_dummy, range_temp, iter_type, iter_decl;
<span class="lineNum">   11985 </span><span class="lineCov">       2333 :       range_temp = convert_from_reference (build_range_temp (range_expr));</span>
<span class="lineNum">   11986 </span>            :       iter_type = (cp_parser_perform_range_for_lookup
<span class="lineNum">   11987 </span>            :                    (range_temp, &amp;begin_dummy, &amp;end_dummy));
<span class="lineNum">   11988 </span>            :       if (iter_type)
<span class="lineNum">   11989 </span>            :         {
<span class="lineNum">   11990 </span>            :           iter_decl = build_decl (input_location, VAR_DECL, NULL_TREE,
<span class="lineNum">   11991 </span>            :                                   iter_type);
<span class="lineNum">   11992 </span><span class="lineCov">       3530 :           iter_decl = build_x_indirect_ref (input_location, iter_decl,</span>
<span class="lineNum">   11993 </span>            :                                             RO_UNARY_STAR,
<span class="lineNum">   11994 </span><span class="lineCov">       3530 :                                             tf_warning_or_error);</span>
<span class="lineNum">   11995 </span>            :           TREE_TYPE (decl) = do_auto_deduction (TREE_TYPE (decl),
<span class="lineNum">   11996 </span>            :                                                 iter_decl, auto_node);
<span class="lineNum">   11997 </span>            :         }
<span class="lineNum">   11998 </span><span class="lineCov">       3530 :     }</span>
<span class="lineNum">   11999 </span><span class="lineCov">       3530 : }</span>
<span class="lineNum">   12000 </span>            : 
<span class="lineNum">   12001 </span>            : /* Converts a range-based for-statement into a normal
<span class="lineNum">   12002 </span>            :    for-statement, as per the definition.
<span class="lineNum">   12003 </span><span class="lineCov">       3530 : </span>
<span class="lineNum">   12004 </span>            :       for (RANGE_DECL : RANGE_EXPR)
<span class="lineNum">   12005 </span><span class="lineCov">       3530 :         BLOCK</span>
<span class="lineNum">   12006 </span><span class="lineCov">       3530 : </span>
<span class="lineNum">   12007 </span>            :    should be equivalent to:
<span class="lineNum">   12008 </span><span class="lineCov">       3530 : </span>
<span class="lineNum">   12009 </span>            :       {
<span class="lineNum">   12010 </span>            :         auto &amp;&amp;__range = RANGE_EXPR;
<span class="lineNum">   12011 </span>            :         for (auto __begin = BEGIN_EXPR, end = END_EXPR;
<span class="lineNum">   12012 </span>            :               __begin != __end;
<span class="lineNum">   12013 </span>            :               ++__begin)
<span class="lineNum">   12014 </span>            :           {
<span class="lineNum">   12015 </span>            :               RANGE_DECL = *__begin;
<span class="lineNum">   12016 </span>            :               BLOCK
<span class="lineNum">   12017 </span><span class="lineCov">        364 :           }</span>
<span class="lineNum">   12018 </span>            :       }
<span class="lineNum">   12019 </span><span class="lineCov">        364 : </span>
<span class="lineNum">   12020 </span><span class="lineCov">        364 :    If RANGE_EXPR is an array:</span>
<span class="lineNum">   12021 </span>            :         BEGIN_EXPR = __range
<span class="lineNum">   12022 </span><span class="lineCov">        349 :         END_EXPR = __range + ARRAY_SIZE(__range)</span>
<span class="lineNum">   12023 </span><span class="lineCov">        349 :    Else if RANGE_EXPR has a member 'begin' or 'end':</span>
<span class="lineNum">   12024 </span><span class="lineCov">        349 :         BEGIN_EXPR = __range.begin()</span>
<span class="lineNum">   12025 </span><span class="lineCov">        349 :         END_EXPR = __range.end()</span>
<span class="lineNum">   12026 </span><span class="lineCov">        349 :    Else:</span>
<span class="lineNum">   12027 </span>            :         BEGIN_EXPR = begin(__range)
<span class="lineNum">   12028 </span><span class="lineCov">        345 :         END_EXPR = end(__range);</span>
<span class="lineNum">   12029 </span>            : 
<span class="lineNum">   12030 </span><span class="lineCov">        345 :    If __range has a member 'begin' but not 'end', or vice versa, we must</span>
<span class="lineNum">   12031 </span>            :    still use the second alternative (it will surely fail, however).
<span class="lineNum">   12032 </span>            :    When calling begin()/end() in the third alternative we must use
<span class="lineNum">   12033 </span><span class="lineCov">        345 :    argument dependent lookup, but always considering 'std' as an associated</span>
<span class="lineNum">   12034 </span>            :    namespace.  */
<a name="12035"><span class="lineNum">   12035 </span>            : </a>
<span class="lineNum">   12036 </span>            : tree
<span class="lineNum">   12037 </span><span class="lineCov">        364 : cp_convert_range_for (tree statement, tree range_decl, tree range_expr,</span>
<span class="lineNum">   12038 </span>            :                       tree decomp_first_name, unsigned int decomp_cnt,
<span class="lineNum">   12039 </span>            :                       bool ivdep, unsigned short unroll)
<span class="lineNum">   12040 </span>            : {
<span class="lineNum">   12041 </span>            :   tree begin, end;
<span class="lineNum">   12042 </span>            :   tree iter_type, begin_expr, end_expr;
<span class="lineNum">   12043 </span>            :   tree condition, expression;
<span class="lineNum">   12044 </span>            : 
<span class="lineNum">   12045 </span>            :   range_expr = mark_lvalue_use (range_expr);
<span class="lineNum">   12046 </span>            : 
<span class="lineNum">   12047 </span>            :   if (range_decl == error_mark_node || range_expr == error_mark_node)
<span class="lineNum">   12048 </span>            :     /* If an error happened previously do nothing or else a lot of
<span class="lineNum">   12049 </span>            :        unhelpful errors would be issued.  */
<span class="lineNum">   12050 </span>            :     begin_expr = end_expr = iter_type = error_mark_node;
<span class="lineNum">   12051 </span>            :   else
<span class="lineNum">   12052 </span>            :     {
<span class="lineNum">   12053 </span>            :       tree range_temp;
<span class="lineNum">   12054 </span>            : 
<span class="lineNum">   12055 </span>            :       if (VAR_P (range_expr)
<span class="lineNum">   12056 </span>            :           &amp;&amp; array_of_runtime_bound_p (TREE_TYPE (range_expr)))
<span class="lineNum">   12057 </span>            :         /* Can't bind a reference to an array of runtime bound.  */
<span class="lineNum">   12058 </span>            :         range_temp = range_expr;
<span class="lineNum">   12059 </span>            :       else
<span class="lineNum">   12060 </span>            :         {
<span class="lineNum">   12061 </span>            :           range_temp = build_range_temp (range_expr);
<span class="lineNum">   12062 </span>            :           pushdecl (range_temp);
<span class="lineNum">   12063 </span>            :           cp_finish_decl (range_temp, range_expr,
<span class="lineNum">   12064 </span>            :                           /*is_constant_init*/false, NULL_TREE,
<span class="lineNum">   12065 </span>            :                           LOOKUP_ONLYCONVERTING);
<span class="lineNum">   12066 </span>            :           range_temp = convert_from_reference (range_temp);
<span class="lineNum">   12067 </span>            :         }
<span class="lineNum">   12068 </span>            :       iter_type = cp_parser_perform_range_for_lookup (range_temp,
<span class="lineNum">   12069 </span>            :                                                       &amp;begin_expr, &amp;end_expr);
<span class="lineNum">   12070 </span>            :     }
<span class="lineNum">   12071 </span>            : 
<span class="lineNum">   12072 </span>            :   /* The new for initialization statement.  */
<span class="lineNum">   12073 </span>            :   begin = build_decl (input_location, VAR_DECL, for_begin__identifier,
<span class="lineNum">   12074 </span>            :                       iter_type);
<span class="lineNum">   12075 </span><span class="lineCov">       3198 :   TREE_USED (begin) = 1;</span>
<span class="lineNum">   12076 </span>            :   DECL_ARTIFICIAL (begin) = 1;
<span class="lineNum">   12077 </span>            :   pushdecl (begin);
<span class="lineNum">   12078 </span>            :   cp_finish_decl (begin, begin_expr,
<span class="lineNum">   12079 </span><span class="lineCov">       3198 :                   /*is_constant_init*/false, NULL_TREE,</span>
<span class="lineNum">   12080 </span><span class="lineCov">       3198 :                   LOOKUP_ONLYCONVERTING);</span>
<span class="lineNum">   12081 </span><span class="lineCov">       3198 : </span>
<span class="lineNum">   12082 </span>            :   if (cxx_dialect &gt;= cxx17)
<span class="lineNum">   12083 </span><span class="lineCov">       3198 :     iter_type = cv_unqualified (TREE_TYPE (end_expr));</span>
<span class="lineNum">   12084 </span>            :   end = build_decl (input_location, VAR_DECL, for_end__identifier, iter_type);
<span class="lineNum">   12085 </span><span class="lineCov">       3198 :   TREE_USED (end) = 1;</span>
<span class="lineNum">   12086 </span>            :   DECL_ARTIFICIAL (end) = 1;
<span class="lineNum">   12087 </span>            :   pushdecl (end);
<span class="lineNum">   12088 </span><span class="lineCov">         14 :   cp_finish_decl (end, end_expr,</span>
<span class="lineNum">   12089 </span>            :                   /*is_constant_init*/false, NULL_TREE,
<span class="lineNum">   12090 </span>            :                   LOOKUP_ONLYCONVERTING);
<span class="lineNum">   12091 </span><span class="lineCov">       3184 : </span>
<span class="lineNum">   12092 </span>            :   finish_init_stmt (statement);
<span class="lineNum">   12093 </span><span class="lineCov">       3184 : </span>
<span class="lineNum">   12094 </span><span class="lineCov">       3184 :   /* The new for condition.  */</span>
<span class="lineNum">   12095 </span>            :   condition = build_x_binary_op (input_location, NE_EXPR,
<span class="lineNum">   12096 </span>            :                                  begin, ERROR_MARK,
<span class="lineNum">   12097 </span>            :                                  end, ERROR_MARK,
<span class="lineNum">   12098 </span>            :                                  NULL, tf_warning_or_error);
<span class="lineNum">   12099 </span><span class="lineCov">       3181 :   finish_for_cond (condition, statement, ivdep, unroll);</span>
<span class="lineNum">   12100 </span><span class="lineCov">       3181 : </span>
<span class="lineNum">   12101 </span><span class="lineCov">       3181 :   /* The new increment expression.  */</span>
<span class="lineNum">   12102 </span>            :   expression = finish_unary_op_expr (input_location,
<span class="lineNum">   12103 </span>            :                                      PREINCREMENT_EXPR, begin,
<span class="lineNum">   12104 </span><span class="lineCov">       3181 :                                      tf_warning_or_error);</span>
<span class="lineNum">   12105 </span>            :   finish_for_expr (expression, statement);
<span class="lineNum">   12106 </span><span class="lineCov">       3184 : </span>
<span class="lineNum">   12107 </span>            :   if (VAR_P (range_decl) &amp;&amp; DECL_DECOMPOSITION_P (range_decl))
<span class="lineNum">   12108 </span>            :     cp_maybe_mangle_decomp (range_decl, decomp_first_name, decomp_cnt);
<span class="lineNum">   12109 </span>            : 
<span class="lineNum">   12110 </span>            :   /* The declaration is initialized with *__begin inside the loop body.  */
<span class="lineNum">   12111 </span><span class="lineCov">       3198 :   cp_finish_decl (range_decl,</span>
<span class="lineNum">   12112 </span>            :                   build_x_indirect_ref (input_location, begin, RO_UNARY_STAR,
<span class="lineNum">   12113 </span><span class="lineCov">       3198 :                                         tf_warning_or_error),</span>
<span class="lineNum">   12114 </span><span class="lineCov">       3198 :                   /*is_constant_init*/false, NULL_TREE,</span>
<span class="lineNum">   12115 </span><span class="lineCov">       3198 :                   LOOKUP_ONLYCONVERTING);</span>
<span class="lineNum">   12116 </span><span class="lineCov">       3198 :   if (VAR_P (range_decl) &amp;&amp; DECL_DECOMPOSITION_P (range_decl))</span>
<span class="lineNum">   12117 </span>            :     cp_finish_decomp (range_decl, decomp_first_name, decomp_cnt);
<span class="lineNum">   12118 </span>            : 
<span class="lineNum">   12119 </span>            :   return statement;
<span class="lineNum">   12120 </span><span class="lineCov">       3198 : }</span>
<span class="lineNum">   12121 </span><span class="lineCov">        676 : </span>
<span class="lineNum">   12122 </span><span class="lineCov">       3198 : /* Solves BEGIN_EXPR and END_EXPR as described in cp_convert_range_for.</span>
<span class="lineNum">   12123 </span><span class="lineCov">       3198 :    We need to solve both at the same time because the method used</span>
<span class="lineNum">   12124 </span><span class="lineCov">       3198 :    depends on the existence of members begin or end.</span>
<span class="lineNum">   12125 </span><span class="lineCov">       3198 :    Returns the type deduced for the iterator expression.  */</span>
<a name="12126"><span class="lineNum">   12126 </span><span class="lineCov">       3198 : </span></a>
<span class="lineNum">   12127 </span>            : static tree
<span class="lineNum">   12128 </span>            : cp_parser_perform_range_for_lookup (tree range, tree *begin, tree *end)
<span class="lineNum">   12129 </span>            : {
<span class="lineNum">   12130 </span><span class="lineCov">       3198 :   if (error_operand_p (range))</span>
<span class="lineNum">   12131 </span>            :     {
<span class="lineNum">   12132 </span>            :       *begin = *end = error_mark_node;
<span class="lineNum">   12133 </span><span class="lineCov">       3198 :       return error_mark_node;</span>
<span class="lineNum">   12134 </span>            :     }
<span class="lineNum">   12135 </span>            : 
<span class="lineNum">   12136 </span>            :   if (!COMPLETE_TYPE_P (complete_type (TREE_TYPE (range))))
<span class="lineNum">   12137 </span><span class="lineCov">       3198 :     {</span>
<span class="lineNum">   12138 </span>            :       error (&quot;range-based %&lt;for%&gt; expression of type %qT &quot;
<span class="lineNum">   12139 </span>            :              &quot;has incomplete type&quot;, TREE_TYPE (range));
<span class="lineNum">   12140 </span><span class="lineCov">       6396 :       *begin = *end = error_mark_node;</span>
<span class="lineNum">   12141 </span>            :       return error_mark_node;
<span class="lineNum">   12142 </span><span class="lineCov">       3198 :     }</span>
<span class="lineNum">   12143 </span><span class="lineCov">       3198 :   if (TREE_CODE (TREE_TYPE (range)) == ARRAY_TYPE)</span>
<span class="lineNum">   12144 </span>            :     {
<span class="lineNum">   12145 </span><span class="lineCov">       3198 :       /* If RANGE is an array, we will use pointer arithmetic.  */</span>
<span class="lineNum">   12146 </span><span class="lineCov">         43 :       *begin = decay_conversion (range, tf_warning_or_error);</span>
<span class="lineNum">   12147 </span>            :       *end = build_binary_op (input_location, PLUS_EXPR,
<span class="lineNum">   12148 </span>            :                               range,
<span class="lineNum">   12149 </span><span class="lineCov">       3198 :                               array_type_nelts_top (TREE_TYPE (range)),</span>
<span class="lineNum">   12150 </span>            :                               false);
<span class="lineNum">   12151 </span>            :       return TREE_TYPE (*begin);
<span class="lineNum">   12152 </span>            :     }
<span class="lineNum">   12153 </span>            :   else
<span class="lineNum">   12154 </span><span class="lineCov">       3198 :     {</span>
<span class="lineNum">   12155 </span><span class="lineCov">         43 :       /* If it is not an array, we must do a bit of magic.  */</span>
<span class="lineNum">   12156 </span>            :       tree id_begin, id_end;
<span class="lineNum">   12157 </span><span class="lineCov">       3198 :       tree member_begin, member_end;</span>
<span class="lineNum">   12158 </span>            : 
<span class="lineNum">   12159 </span>            :       *begin = *end = error_mark_node;
<span class="lineNum">   12160 </span>            : 
<span class="lineNum">   12161 </span>            :       id_begin = get_identifier (&quot;begin&quot;);
<span class="lineNum">   12162 </span>            :       id_end = get_identifier (&quot;end&quot;);
<span class="lineNum">   12163 </span>            :       member_begin = lookup_member (TREE_TYPE (range), id_begin,
<span class="lineNum">   12164 </span>            :                                     /*protect=*/2, /*want_type=*/false,
<span class="lineNum">   12165 </span>            :                                     tf_warning_or_error);
<span class="lineNum">   12166 </span><span class="lineCov">       3533 :       member_end = lookup_member (TREE_TYPE (range), id_end,</span>
<span class="lineNum">   12167 </span>            :                                   /*protect=*/2, /*want_type=*/false,
<span class="lineNum">   12168 </span><span class="lineCov">       3533 :                                   tf_warning_or_error);</span>
<span class="lineNum">   12169 </span>            : 
<span class="lineNum">   12170 </span><span class="lineCov">          3 :       if (member_begin != NULL_TREE &amp;&amp; member_end != NULL_TREE)</span>
<span class="lineNum">   12171 </span><span class="lineCov">          3 :         {</span>
<span class="lineNum">   12172 </span>            :           /* Use the member functions.  */
<span class="lineNum">   12173 </span>            :           *begin = cp_parser_range_for_member_function (range, id_begin);
<span class="lineNum">   12174 </span><span class="lineCov">       3530 :           *end = cp_parser_range_for_member_function (range, id_end);</span>
<span class="lineNum">   12175 </span>            :         }
<span class="lineNum">   12176 </span><span class="lineCov">         16 :       else</span>
<span class="lineNum">   12177 </span><span class="lineCov">          8 :         {</span>
<span class="lineNum">   12178 </span><span class="lineCov">          8 :           /* Use global functions with ADL.  */</span>
<span class="lineNum">   12179 </span><span class="lineCov">          8 :           vec&lt;tree, va_gc&gt; *vec;</span>
<span class="lineNum">   12180 </span>            :           vec = make_tree_vector ();
<span class="lineNum">   12181 </span><span class="lineCov">       3522 : </span>
<span class="lineNum">   12182 </span>            :           vec_safe_push (vec, range);
<span class="lineNum">   12183 </span>            : 
<span class="lineNum">   12184 </span><span class="lineCov">        589 :           member_begin = perform_koenig_lookup (id_begin, vec,</span>
<span class="lineNum">   12185 </span><span class="lineCov">        589 :                                                 tf_warning_or_error);</span>
<span class="lineNum">   12186 </span>            :           *begin = finish_call_expr (member_begin, &amp;vec, false, true,
<span class="lineNum">   12187 </span><span class="lineCov">        589 :                                      tf_warning_or_error);</span>
<span class="lineNum">   12188 </span>            :           member_end = perform_koenig_lookup (id_end, vec,
<span class="lineNum">   12189 </span><span class="lineCov">        589 :                                               tf_warning_or_error);</span>
<span class="lineNum">   12190 </span>            :           *end = finish_call_expr (member_end, &amp;vec, false, true,
<span class="lineNum">   12191 </span>            :                                    tf_warning_or_error);
<span class="lineNum">   12192 </span>            : 
<span class="lineNum">   12193 </span>            :           release_tree_vector (vec);
<span class="lineNum">   12194 </span><span class="lineCov">       2933 :         }</span>
<span class="lineNum">   12195 </span><span class="lineCov">       2933 : </span>
<span class="lineNum">   12196 </span>            :       /* Last common checks.  */
<span class="lineNum">   12197 </span><span class="lineCov">       2933 :       if (*begin == error_mark_node || *end == error_mark_node)</span>
<span class="lineNum">   12198 </span>            :         {
<span class="lineNum">   12199 </span><span class="lineCov">       2933 :           /* If one of the expressions is an error do no more checks.  */</span>
<span class="lineNum">   12200 </span><span class="lineCov">       2933 :           *begin = *end = error_mark_node;</span>
<span class="lineNum">   12201 </span><span class="lineCov">       2933 :           return error_mark_node;</span>
<span class="lineNum">   12202 </span>            :         }
<span class="lineNum">   12203 </span>            :       else if (type_dependent_expression_p (*begin)
<span class="lineNum">   12204 </span><span class="lineCov">       2933 :                || type_dependent_expression_p (*end))</span>
<span class="lineNum">   12205 </span>            :         /* Can happen, when, eg, in a template context, Koenig lookup
<span class="lineNum">   12206 </span>            :            can't resolve begin/end (c++/58503).  */
<span class="lineNum">   12207 </span>            :         return NULL_TREE;
<span class="lineNum">   12208 </span><span class="lineCov">       2933 :       else</span>
<span class="lineNum">   12209 </span>            :         {
<span class="lineNum">   12210 </span>            :           tree iter_type = cv_unqualified (TREE_TYPE (*begin));
<span class="lineNum">   12211 </span><span class="lineCov">       2882 :           /* The unqualified type of the __begin and __end temporaries should</span>
<span class="lineNum">   12212 </span><span class="lineCov">       2882 :              be the same, as required by the multiple auto declaration.  */</span>
<span class="lineNum">   12213 </span>            :           if (!same_type_p (iter_type, cv_unqualified (TREE_TYPE (*end))))
<span class="lineNum">   12214 </span>            :             {
<span class="lineNum">   12215 </span>            :               if (cxx_dialect &gt;= cxx17
<span class="lineNum">   12216 </span>            :                   &amp;&amp; (build_x_binary_op (input_location, NE_EXPR,
<span class="lineNum">   12217 </span><span class="lineCov">         51 :                                          *begin, ERROR_MARK,</span>
<span class="lineNum">   12218 </span><span class="lineCov">         51 :                                          *end, ERROR_MARK,</span>
<span class="lineNum">   12219 </span>            :                                          NULL, tf_none)
<span class="lineNum">   12220 </span><span class="lineCov">         51 :                       != error_mark_node))</span>
<span class="lineNum">   12221 </span>            :                 /* P0184R0 allows __begin and __end to have different types,
<span class="lineNum">   12222 </span><span class="lineCov">        102 :                    but make sure they are comparable so we can give a better</span>
<span class="lineNum">   12223 </span><span class="lineCov">         51 :                    diagnostic.  */;</span>
<span class="lineNum">   12224 </span><span class="lineCov">         51 :               else</span>
<span class="lineNum">   12225 </span>            :                 error (&quot;inconsistent begin/end types in range-based %&lt;for%&gt; &quot;
<span class="lineNum">   12226 </span><span class="lineCov">        102 :                        &quot;statement: %qT and %qT&quot;,</span>
<span class="lineNum">   12227 </span><span class="lineCov">         51 :                        TREE_TYPE (*begin), TREE_TYPE (*end));</span>
<span class="lineNum">   12228 </span><span class="lineCov">         51 :             }</span>
<span class="lineNum">   12229 </span>            :           return iter_type;
<span class="lineNum">   12230 </span>            :         }
<span class="lineNum">   12231 </span><span class="lineCov">         51 :     }</span>
<span class="lineNum">   12232 </span>            : }
<span class="lineNum">   12233 </span>            : 
<span class="lineNum">   12234 </span>            : /* Helper function for cp_parser_perform_range_for_lookup.
<span class="lineNum">   12235 </span><span class="lineCov">       2933 :    Builds a tree for RANGE.IDENTIFIER().  */</span>
<a name="12236"><span class="lineNum">   12236 </span>            : </a>
<span class="lineNum">   12237 </span>            : static tree
<span class="lineNum">   12238 </span><span class="lineCov">         18 : cp_parser_range_for_member_function (tree range, tree identifier)</span>
<span class="lineNum">   12239 </span><span class="lineCov">         18 : {</span>
<span class="lineNum">   12240 </span>            :   tree member, res;
<span class="lineNum">   12241 </span><span class="lineCov">       2915 :   vec&lt;tree, va_gc&gt; *vec;</span>
<span class="lineNum">   12242 </span><span class="lineCov">       2915 : </span>
<span class="lineNum">   12243 </span>            :   member = finish_class_member_access_expr (range, identifier,
<span class="lineNum">   12244 </span>            :                                             false, tf_warning_or_error);
<span class="lineNum">   12245 </span><span class="lineCov">          4 :   if (member == error_mark_node)</span>
<span class="lineNum">   12246 </span>            :     return error_mark_node;
<span class="lineNum">   12247 </span>            : 
<span class="lineNum">   12248 </span><span class="lineCov">       2911 :   vec = make_tree_vector ();</span>
<span class="lineNum">   12249 </span>            :   res = finish_call_expr (member, &amp;vec,
<span class="lineNum">   12250 </span>            :                           /*disallow_virtual=*/false,
<span class="lineNum">   12251 </span><span class="lineCov">       2911 :                           /*koenig_p=*/false,</span>
<span class="lineNum">   12252 </span>            :                           tf_warning_or_error);
<span class="lineNum">   12253 </span><span class="lineCov">          3 :   release_tree_vector (vec);</span>
<span class="lineNum">   12254 </span><span class="lineCov">          3 :   return res;</span>
<span class="lineNum">   12255 </span>            : }
<span class="lineNum">   12256 </span>            : 
<span class="lineNum">   12257 </span>            : /* Parse an iteration-statement.
<span class="lineNum">   12258 </span><span class="lineCov">          1 : </span>
<span class="lineNum">   12259 </span>            :    iteration-statement:
<span class="lineNum">   12260 </span>            :      while ( condition ) statement
<span class="lineNum">   12261 </span>            :      do statement while ( expression ) ;
<span class="lineNum">   12262 </span>            :      for ( init-statement condition [opt] ; expression [opt] )
<span class="lineNum">   12263 </span><span class="lineCov">          6 :        statement</span>
<span class="lineNum">   12264 </span>            : 
<span class="lineNum">   12265 </span><span class="lineCov">          2 :    Returns the new WHILE_STMT, DO_STMT, FOR_STMT or RANGE_FOR_STMT.  */</span>
<a name="12266"><span class="lineNum">   12266 </span>            : </a>
<span class="lineNum">   12267 </span><span class="lineCov">       2911 : static tree</span>
<span class="lineNum">   12268 </span>            : cp_parser_iteration_statement (cp_parser* parser, bool *if_p, bool ivdep,
<span class="lineNum">   12269 </span>            :                                unsigned short unroll)
<span class="lineNum">   12270 </span>            : {
<span class="lineNum">   12271 </span>            :   cp_token *token;
<span class="lineNum">   12272 </span>            :   enum rid keyword;
<span class="lineNum">   12273 </span>            :   tree statement;
<span class="lineNum">   12274 </span>            :   unsigned char in_statement;
<span class="lineNum">   12275 </span>            :   token_indent_info guard_tinfo;
<span class="lineNum">   12276 </span><span class="lineCov">       5764 : </span>
<span class="lineNum">   12277 </span>            :   /* Peek at the next token.  */
<span class="lineNum">   12278 </span><span class="lineCov">       5764 :   token = cp_parser_require (parser, CPP_KEYWORD, RT_ITERATION);</span>
<span class="lineNum">   12279 </span><span class="lineCov">       5764 :   if (!token)</span>
<span class="lineNum">   12280 </span>            :     return error_mark_node;
<span class="lineNum">   12281 </span><span class="lineCov">       5764 : </span>
<span class="lineNum">   12282 </span>            :   guard_tinfo = get_token_indent_info (token);
<span class="lineNum">   12283 </span><span class="lineCov">       5764 : </span>
<span class="lineNum">   12284 </span>            :   /* Remember whether or not we are already within an iteration
<span class="lineNum">   12285 </span>            :      statement.  */
<span class="lineNum">   12286 </span><span class="lineCov">       5758 :   in_statement = parser-&gt;in_statement;</span>
<span class="lineNum">   12287 </span><span class="lineCov">       5758 : </span>
<span class="lineNum">   12288 </span>            :   /* See what kind of keyword it is.  */
<span class="lineNum">   12289 </span>            :   keyword = token-&gt;keyword;
<span class="lineNum">   12290 </span>            :   switch (keyword)
<span class="lineNum">   12291 </span><span class="lineCov">       5758 :     {</span>
<span class="lineNum">   12292 </span><span class="lineCov">       5758 :     case RID_WHILE:</span>
<span class="lineNum">   12293 </span>            :       {
<span class="lineNum">   12294 </span>            :         tree condition;
<span class="lineNum">   12295 </span>            : 
<span class="lineNum">   12296 </span>            :         /* Begin the while-statement.  */
<span class="lineNum">   12297 </span>            :         statement = begin_while_stmt ();
<span class="lineNum">   12298 </span>            :         /* Look for the `('.  */
<span class="lineNum">   12299 </span>            :         matching_parens parens;
<span class="lineNum">   12300 </span>            :         parens.require_open (parser);
<span class="lineNum">   12301 </span>            :         /* Parse the condition.  */
<span class="lineNum">   12302 </span>            :         condition = cp_parser_condition (parser);
<span class="lineNum">   12303 </span>            :         finish_while_stmt_cond (condition, statement, ivdep, unroll);
<span class="lineNum">   12304 </span>            :         /* Look for the `)'.  */
<span class="lineNum">   12305 </span>            :         parens.require_close (parser);
<span class="lineNum">   12306 </span><span class="lineCov">     460930 :         /* Parse the dependent statement.  */</span>
<span class="lineNum">   12307 </span>            :         parser-&gt;in_statement = IN_ITERATION_STMT;
<span class="lineNum">   12308 </span>            :         bool prev = note_iteration_stmt_body_start ();
<span class="lineNum">   12309 </span><span class="lineCov">     460930 :         cp_parser_already_scoped_statement (parser, if_p, guard_tinfo);</span>
<span class="lineNum">   12310 </span><span class="lineCov">     460930 :         note_iteration_stmt_body_end (prev);</span>
<span class="lineNum">   12311 </span><span class="lineCov">     460930 :         parser-&gt;in_statement = in_statement;</span>
<span class="lineNum">   12312 </span><span class="lineCov">     460930 :         /* We're done with the while-statement.  */</span>
<span class="lineNum">   12313 </span><span class="lineCov">     460930 :         finish_while_stmt (statement);</span>
<span class="lineNum">   12314 </span>            :       }
<span class="lineNum">   12315 </span>            :       break;
<span class="lineNum">   12316 </span><span class="lineCov">     460930 : </span>
<span class="lineNum">   12317 </span><span class="lineCov">     460930 :     case RID_DO:</span>
<span class="lineNum">   12318 </span><span class="lineNoCov">          0 :       {</span>
<span class="lineNum">   12319 </span>            :         tree expression;
<span class="lineNum">   12320 </span><span class="lineCov">     460930 : </span>
<span class="lineNum">   12321 </span>            :         /* Begin the do-statement.  */
<span class="lineNum">   12322 </span>            :         statement = begin_do_stmt ();
<span class="lineNum">   12323 </span>            :         /* Parse the body of the do-statement.  */
<span class="lineNum">   12324 </span><span class="lineCov">     460930 :         parser-&gt;in_statement = IN_ITERATION_STMT;</span>
<span class="lineNum">   12325 </span>            :         bool prev = note_iteration_stmt_body_start ();
<span class="lineNum">   12326 </span>            :         cp_parser_implicitly_scoped_statement (parser, NULL, guard_tinfo);
<span class="lineNum">   12327 </span><span class="lineCov">     460930 :         note_iteration_stmt_body_end (prev);</span>
<span class="lineNum">   12328 </span><span class="lineCov">     460930 :         parser-&gt;in_statement = in_statement;</span>
<span class="lineNum">   12329 </span>            :         finish_do_body (statement);
<span class="lineNum">   12330 </span><span class="lineCov">     118376 :         /* Look for the `while' keyword.  */</span>
<span class="lineNum">   12331 </span><span class="lineCov">     118376 :         cp_parser_require_keyword (parser, RID_WHILE, RT_WHILE);</span>
<span class="lineNum">   12332 </span><span class="lineCov">     118376 :         /* Look for the `('.  */</span>
<span class="lineNum">   12333 </span>            :         matching_parens parens;
<span class="lineNum">   12334 </span>            :         parens.require_open (parser);
<span class="lineNum">   12335 </span><span class="lineCov">     118376 :         /* Parse the expression.  */</span>
<span class="lineNum">   12336 </span>            :         expression = cp_parser_expression (parser);
<span class="lineNum">   12337 </span><span class="lineCov">     236752 :         /* We're done with the do-statement.  */</span>
<span class="lineNum">   12338 </span><span class="lineCov">     118376 :         finish_do_stmt (expression, statement, ivdep, unroll);</span>
<span class="lineNum">   12339 </span>            :         /* Look for the `)'.  */
<span class="lineNum">   12340 </span><span class="lineCov">     118376 :         parens.require_close (parser);</span>
<span class="lineNum">   12341 </span><span class="lineCov">     118376 :         /* Look for the `;'.  */</span>
<span class="lineNum">   12342 </span>            :         cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);
<span class="lineNum">   12343 </span><span class="lineCov">     118376 :       }</span>
<span class="lineNum">   12344 </span>            :       break;
<span class="lineNum">   12345 </span><span class="lineCov">     118376 : </span>
<span class="lineNum">   12346 </span><span class="lineCov">     118376 :     case RID_FOR:</span>
<span class="lineNum">   12347 </span><span class="lineCov">     118376 :       {</span>
<span class="lineNum">   12348 </span><span class="lineCov">     118376 :         /* Look for the `('.  */</span>
<span class="lineNum">   12349 </span><span class="lineCov">     118376 :         matching_parens parens;</span>
<span class="lineNum">   12350 </span>            :         parens.require_open (parser);
<span class="lineNum">   12351 </span><span class="lineCov">     118376 : </span>
<span class="lineNum">   12352 </span>            :         statement = cp_parser_for (parser, ivdep, unroll);
<span class="lineNum">   12353 </span><span class="lineCov">     118376 : </span>
<span class="lineNum">   12354 </span>            :         /* Look for the `)'.  */
<span class="lineNum">   12355 </span><span class="lineCov">     144106 :         parens.require_close (parser);</span>
<span class="lineNum">   12356 </span><span class="lineCov">     144106 : </span>
<span class="lineNum">   12357 </span><span class="lineCov">     144106 :         /* Parse the body of the for-statement.  */</span>
<span class="lineNum">   12358 </span>            :         parser-&gt;in_statement = IN_ITERATION_STMT;
<span class="lineNum">   12359 </span>            :         bool prev = note_iteration_stmt_body_start ();
<span class="lineNum">   12360 </span><span class="lineCov">     144106 :         cp_parser_already_scoped_statement (parser, if_p, guard_tinfo);</span>
<span class="lineNum">   12361 </span>            :         note_iteration_stmt_body_end (prev);
<span class="lineNum">   12362 </span><span class="lineCov">     144106 :         parser-&gt;in_statement = in_statement;</span>
<span class="lineNum">   12363 </span><span class="lineCov">     144106 : </span>
<span class="lineNum">   12364 </span><span class="lineCov">     144106 :         /* We're done with the for-statement.  */</span>
<span class="lineNum">   12365 </span><span class="lineCov">     144106 :         finish_for_stmt (statement);</span>
<span class="lineNum">   12366 </span><span class="lineCov">     144106 :       }</span>
<span class="lineNum">   12367 </span><span class="lineCov">     144106 :       break;</span>
<span class="lineNum">   12368 </span>            : 
<span class="lineNum">   12369 </span><span class="lineCov">     144106 :     default:</span>
<span class="lineNum">   12370 </span>            :       cp_parser_error (parser, &quot;expected iteration-statement&quot;);
<span class="lineNum">   12371 </span><span class="lineCov">     288212 :       statement = error_mark_node;</span>
<span class="lineNum">   12372 </span><span class="lineCov">     144106 :       break;</span>
<span class="lineNum">   12373 </span>            :     }
<span class="lineNum">   12374 </span><span class="lineCov">     144106 : </span>
<span class="lineNum">   12375 </span>            :   return statement;
<span class="lineNum">   12376 </span><span class="lineCov">     144106 : }</span>
<span class="lineNum">   12377 </span>            : 
<span class="lineNum">   12378 </span><span class="lineCov">     144106 : /* Parse a init-statement or the declarator of a range-based-for.</span>
<span class="lineNum">   12379 </span>            :    Returns true if a range-based-for declaration is seen.
<span class="lineNum">   12380 </span><span class="lineCov">     144106 : </span>
<span class="lineNum">   12381 </span>            :    init-statement:
<span class="lineNum">   12382 </span><span class="lineCov">     144106 :      expression-statement</span>
<span class="lineNum">   12383 </span>            :      simple-declaration  */
<a name="12384"><span class="lineNum">   12384 </span><span class="lineCov">     198448 : </span></a>
<span class="lineNum">   12385 </span><span class="lineCov">     198448 : static bool</span>
<span class="lineNum">   12386 </span>            : cp_parser_init_statement (cp_parser *parser, tree *decl)
<span class="lineNum">   12387 </span><span class="lineCov">     396896 : {</span>
<span class="lineNum">   12388 </span><span class="lineCov">     198448 :   /* If the next token is a `;', then we have an empty</span>
<span class="lineNum">   12389 </span>            :      expression-statement.  Grammatically, this is also a
<span class="lineNum">   12390 </span><span class="lineCov">     198448 :      simple-declaration, but an invalid one, because it does not</span>
<span class="lineNum">   12391 </span>            :      declare anything.  Therefore, if we did not handle this case
<span class="lineNum">   12392 </span>            :      specially, we would issue an error message about an invalid
<span class="lineNum">   12393 </span><span class="lineCov">     198448 :      declaration.  */</span>
<span class="lineNum">   12394 </span>            :   if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_SEMICOLON))
<span class="lineNum">   12395 </span>            :     {
<span class="lineNum">   12396 </span><span class="lineCov">     198448 :       bool is_range_for = false;</span>
<span class="lineNum">   12397 </span><span class="lineCov">     198448 :       bool saved_colon_corrects_to_scope_p = parser-&gt;colon_corrects_to_scope_p;</span>
<span class="lineNum">   12398 </span><span class="lineCov">     198448 : </span>
<span class="lineNum">   12399 </span><span class="lineCov">     198448 :       /* Try to parse the init-statement.  */</span>
<span class="lineNum">   12400 </span><span class="lineCov">     198448 :       if (cp_parser_range_based_for_with_init_p (parser))</span>
<span class="lineNum">   12401 </span>            :         {
<span class="lineNum">   12402 </span>            :           tree dummy;
<span class="lineNum">   12403 </span><span class="lineCov">     198448 :           cp_parser_parse_tentatively (parser);</span>
<span class="lineNum">   12404 </span>            :           /* Parse the declaration.  */
<span class="lineNum">   12405 </span><span class="lineCov">     198448 :           cp_parser_simple_declaration (parser,</span>
<span class="lineNum">   12406 </span>            :                                         /*function_definition_allowed_p=*/false,
<span class="lineNum">   12407 </span><span class="lineNoCov">          0 :                                         &amp;dummy);</span>
<span class="lineNum">   12408 </span><span class="lineNoCov">          0 :           cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);</span>
<span class="lineNum">   12409 </span><span class="lineNoCov">          0 :           if (!cp_parser_parse_definitely (parser))</span>
<span class="lineNum">   12410 </span><span class="lineNoCov">          0 :             /* That didn't work, try to parse it as an expression-statement.  */</span>
<span class="lineNum">   12411 </span>            :             cp_parser_expression_statement (parser, NULL_TREE);
<span class="lineNum">   12412 </span>            : 
<span class="lineNum">   12413 </span>            :           if (cxx_dialect &lt; cxx2a)
<span class="lineNum">   12414 </span>            :             {
<span class="lineNum">   12415 </span>            :               pedwarn (cp_lexer_peek_token (parser-&gt;lexer)-&gt;location, 0,
<span class="lineNum">   12416 </span>            :                        &quot;range-based %&lt;for%&gt; loops with initializer only &quot;
<span class="lineNum">   12417 </span>            :                        &quot;available with -std=c++2a or -std=gnu++2a&quot;);
<span class="lineNum">   12418 </span>            :               *decl = error_mark_node;
<span class="lineNum">   12419 </span>            :             }
<span class="lineNum">   12420 </span>            :         }
<span class="lineNum">   12421 </span>            : 
<span class="lineNum">   12422 </span>            :       /* A colon is used in range-based for.  */
<span class="lineNum">   12423 </span>            :       parser-&gt;colon_corrects_to_scope_p = false;
<span class="lineNum">   12424 </span><span class="lineCov">     198481 : </span>
<span class="lineNum">   12425 </span>            :       /* We're going to speculatively look for a declaration, falling back
<span class="lineNum">   12426 </span>            :          to an expression, if necessary.  */
<span class="lineNum">   12427 </span>            :       cp_parser_parse_tentatively (parser);
<span class="lineNum">   12428 </span>            :       /* Parse the declaration.  */
<span class="lineNum">   12429 </span>            :       cp_parser_simple_declaration (parser,
<span class="lineNum">   12430 </span>            :                                     /*function_definition_allowed_p=*/false,
<span class="lineNum">   12431 </span>            :                                     decl);
<span class="lineNum">   12432 </span><span class="lineCov">     198481 :       parser-&gt;colon_corrects_to_scope_p = saved_colon_corrects_to_scope_p;</span>
<span class="lineNum">   12433 </span>            :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_COLON))
<span class="lineNum">   12434 </span><span class="lineCov">     127818 :         {</span>
<span class="lineNum">   12435 </span><span class="lineCov">     127818 :           /* It is a range-for, consume the ':'.  */</span>
<span class="lineNum">   12436 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   12437 </span>            :           is_range_for = true;
<span class="lineNum">   12438 </span><span class="lineCov">     127818 :           if (cxx_dialect &lt; cxx11)</span>
<span class="lineNum">   12439 </span>            :             pedwarn (cp_lexer_peek_token (parser-&gt;lexer)-&gt;location, 0,
<span class="lineNum">   12440 </span><span class="lineCov">         61 :                      &quot;range-based %&lt;for%&gt; loops only available with &quot;</span>
<span class="lineNum">   12441 </span><span class="lineCov">         61 :                      &quot;-std=c++11 or -std=gnu++11&quot;);</span>
<span class="lineNum">   12442 </span>            :         }
<span class="lineNum">   12443 </span><span class="lineCov">         61 :       else</span>
<span class="lineNum">   12444 </span>            :         /* The ';' is not consumed yet because we told
<span class="lineNum">   12445 </span>            :            cp_parser_simple_declaration not to.  */
<span class="lineNum">   12446 </span><span class="lineCov">         61 :         cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);</span>
<span class="lineNum">   12447 </span><span class="lineCov">         61 : </span>
<span class="lineNum">   12448 </span>            :       if (cp_parser_parse_definitely (parser))
<span class="lineNum">   12449 </span><span class="lineCov">          9 :         return is_range_for;</span>
<span class="lineNum">   12450 </span>            :       /* If the tentative parse failed, then we shall need to look for an
<span class="lineNum">   12451 </span><span class="lineCov">         61 :          expression-statement.  */</span>
<span class="lineNum">   12452 </span>            :     }
<span class="lineNum">   12453 </span><span class="lineCov">          4 :   /* If we are here, it is an expression-statement.  */</span>
<span class="lineNum">   12454 </span>            :   cp_parser_expression_statement (parser, NULL_TREE);
<span class="lineNum">   12455 </span>            :   return false;
<span class="lineNum">   12456 </span><span class="lineCov">          4 : }</span>
<span class="lineNum">   12457 </span>            : 
<span class="lineNum">   12458 </span>            : /* Parse a jump-statement.
<span class="lineNum">   12459 </span>            : 
<span class="lineNum">   12460 </span>            :    jump-statement:
<span class="lineNum">   12461 </span><span class="lineCov">     127818 :      break ;</span>
<span class="lineNum">   12462 </span>            :      continue ;
<span class="lineNum">   12463 </span>            :      return expression [opt] ;
<span class="lineNum">   12464 </span>            :      return braced-init-list ;
<span class="lineNum">   12465 </span><span class="lineCov">     127818 :      goto identifier ;</span>
<span class="lineNum">   12466 </span>            : 
<span class="lineNum">   12467 </span><span class="lineCov">     127818 :    GNU extension:</span>
<span class="lineNum">   12468 </span>            : 
<span class="lineNum">   12469 </span>            :    jump-statement:
<span class="lineNum">   12470 </span><span class="lineCov">     127818 :      goto * expression ;</span>
<span class="lineNum">   12471 </span><span class="lineCov">     127818 : </span>
<span class="lineNum">   12472 </span>            :    Returns the new BREAK_STMT, CONTINUE_STMT, RETURN_EXPR, or GOTO_EXPR.  */
<a name="12473"><span class="lineNum">   12473 </span>            : </a>
<span class="lineNum">   12474 </span><span class="lineCov">       2333 : static tree</span>
<span class="lineNum">   12475 </span><span class="lineCov">       2333 : cp_parser_jump_statement (cp_parser* parser)</span>
<span class="lineNum">   12476 </span><span class="lineCov">       2333 : {</span>
<span class="lineNum">   12477 </span><span class="lineCov">          2 :   tree statement = error_mark_node;</span>
<span class="lineNum">   12478 </span>            :   cp_token *token;
<span class="lineNum">   12479 </span>            :   enum rid keyword;
<span class="lineNum">   12480 </span>            :   unsigned char in_statement;
<span class="lineNum">   12481 </span>            : 
<span class="lineNum">   12482 </span>            :   /* Peek at the next token.  */
<span class="lineNum">   12483 </span>            :   token = cp_parser_require (parser, CPP_KEYWORD, RT_JUMP);
<span class="lineNum">   12484 </span><span class="lineCov">     125485 :   if (!token)</span>
<span class="lineNum">   12485 </span>            :     return error_mark_node;
<span class="lineNum">   12486 </span><span class="lineCov">     127818 : </span>
<span class="lineNum">   12487 </span>            :   /* See what kind of keyword it is.  */
<span class="lineNum">   12488 </span>            :   keyword = token-&gt;keyword;
<span class="lineNum">   12489 </span>            :   switch (keyword)
<span class="lineNum">   12490 </span>            :     {
<span class="lineNum">   12491 </span>            :     case RID_BREAK:
<span class="lineNum">   12492 </span><span class="lineCov">      97007 :       in_statement = parser-&gt;in_statement &amp; ~IN_IF_STMT;      </span>
<span class="lineNum">   12493 </span><span class="lineCov">      97007 :       switch (in_statement)</span>
<span class="lineNum">   12494 </span>            :         {
<span class="lineNum">   12495 </span>            :         case 0:
<span class="lineNum">   12496 </span>            :           error_at (token-&gt;location, &quot;break statement not within loop or switch&quot;);
<span class="lineNum">   12497 </span>            :           break;
<span class="lineNum">   12498 </span>            :         default:
<span class="lineNum">   12499 </span>            :           gcc_assert ((in_statement &amp; IN_SWITCH_STMT)
<span class="lineNum">   12500 </span>            :                       || in_statement == IN_ITERATION_STMT);
<span class="lineNum">   12501 </span>            :           statement = finish_break_stmt ();
<span class="lineNum">   12502 </span>            :           if (in_statement == IN_ITERATION_STMT)
<span class="lineNum">   12503 </span>            :             break_maybe_infinite_loop ();
<span class="lineNum">   12504 </span>            :           break;
<span class="lineNum">   12505 </span>            :         case IN_OMP_BLOCK:
<span class="lineNum">   12506 </span>            :           error_at (token-&gt;location, &quot;invalid exit from OpenMP structured block&quot;);
<span class="lineNum">   12507 </span>            :           break;
<span class="lineNum">   12508 </span>            :         case IN_OMP_FOR:
<span class="lineNum">   12509 </span>            :           error_at (token-&gt;location, &quot;break statement used with OpenMP for loop&quot;);
<span class="lineNum">   12510 </span>            :           break;
<span class="lineNum">   12511 </span>            :         }
<span class="lineNum">   12512 </span>            :       cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);
<span class="lineNum">   12513 </span><span class="lineCov">    4590586 :       break;</span>
<span class="lineNum">   12514 </span>            : 
<span class="lineNum">   12515 </span><span class="lineCov">    4590586 :     case RID_CONTINUE:</span>
<span class="lineNum">   12516 </span><span class="lineCov">    4590586 :       switch (parser-&gt;in_statement &amp; ~(IN_SWITCH_STMT | IN_IF_STMT))</span>
<span class="lineNum">   12517 </span><span class="lineCov">    4590586 :         {</span>
<span class="lineNum">   12518 </span><span class="lineCov">    4590586 :         case 0:</span>
<span class="lineNum">   12519 </span>            :           error_at (token-&gt;location, &quot;continue statement not within a loop&quot;);
<span class="lineNum">   12520 </span>            :           break;
<span class="lineNum">   12521 </span><span class="lineCov">    4590586 :           /* Fall through.  */</span>
<span class="lineNum">   12522 </span><span class="lineCov">    4590586 :         case IN_ITERATION_STMT:</span>
<span class="lineNum">   12523 </span><span class="lineNoCov">          0 :         case IN_OMP_FOR:</span>
<span class="lineNum">   12524 </span>            :           statement = finish_continue_stmt ();
<span class="lineNum">   12525 </span>            :           break;
<span class="lineNum">   12526 </span><span class="lineCov">    4590586 :         case IN_OMP_BLOCK:</span>
<span class="lineNum">   12527 </span><span class="lineCov">    4590586 :           error_at (token-&gt;location, &quot;invalid exit from OpenMP structured block&quot;);</span>
<span class="lineNum">   12528 </span>            :           break;
<span class="lineNum">   12529 </span><span class="lineCov">      96944 :         default:</span>
<span class="lineNum">   12530 </span><span class="lineCov">      96944 :           gcc_unreachable ();</span>
<span class="lineNum">   12531 </span><span class="lineCov">      96944 :         }</span>
<span class="lineNum">   12532 </span>            :       cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);
<span class="lineNum">   12533 </span><span class="lineCov">          7 :       break;</span>
<span class="lineNum">   12534 </span><span class="lineCov">          7 : </span>
<span class="lineNum">   12535 </span><span class="lineCov">          7 :     case RID_RETURN:</span>
<span class="lineNum">   12536 </span><span class="lineCov">      96913 :       {</span>
<span class="lineNum">   12537 </span><span class="lineCov">      96913 :         tree expr;</span>
<span class="lineNum">   12538 </span>            :         bool expr_non_constant_p;
<span class="lineNum">   12539 </span><span class="lineCov">      96913 : </span>
<span class="lineNum">   12540 </span><span class="lineCov">      96913 :         if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_BRACE))</span>
<span class="lineNum">   12541 </span><span class="lineCov">      55149 :           {</span>
<span class="lineNum">   12542 </span>            :             cp_lexer_set_source_position (parser-&gt;lexer);
<span class="lineNum">   12543 </span><span class="lineCov">          9 :             maybe_warn_cpp0x (CPP0X_INITIALIZER_LISTS);</span>
<span class="lineNum">   12544 </span><span class="lineCov">          9 :             expr = cp_parser_braced_list (parser, &amp;expr_non_constant_p);</span>
<span class="lineNum">   12545 </span><span class="lineCov">          9 :           }</span>
<span class="lineNum">   12546 </span><span class="lineCov">         15 :         else if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_SEMICOLON))</span>
<span class="lineNum">   12547 </span><span class="lineCov">         15 :           expr = cp_parser_expression (parser);</span>
<span class="lineNum">   12548 </span><span class="lineCov">         15 :         else</span>
<span class="lineNum">   12549 </span>            :           /* If the next token is a `;', then there is no
<span class="lineNum">   12550 </span><span class="lineCov">      96944 :              expression.  */</span>
<span class="lineNum">   12551 </span><span class="lineCov">      96944 :           expr = NULL_TREE;</span>
<span class="lineNum">   12552 </span>            :         /* Build the return-statement.  */
<span class="lineNum">   12553 </span><span class="lineCov">       4390 :         if (current_function_auto_return_pattern &amp;&amp; in_discarded_stmt)</span>
<span class="lineNum">   12554 </span><span class="lineCov">       4390 :           /* Don't deduce from a discarded return statement.  */;</span>
<span class="lineNum">   12555 </span>            :         else
<span class="lineNum">   12556 </span><span class="lineCov">          3 :           statement = finish_return_stmt (expr);</span>
<span class="lineNum">   12557 </span><span class="lineCov">          3 :         /* Look for the final `;'.  */</span>
<span class="lineNum">   12558 </span><span class="lineCov">          3 :         cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);</span>
<span class="lineNum">   12559 </span>            :       }
<span class="lineNum">   12560 </span><span class="lineCov">       4375 :       break;</span>
<span class="lineNum">   12561 </span><span class="lineCov">       4375 : </span>
<span class="lineNum">   12562 </span><span class="lineCov">       4375 :     case RID_GOTO:</span>
<span class="lineNum">   12563 </span><span class="lineCov">       4375 :       if (parser-&gt;in_function_body</span>
<span class="lineNum">   12564 </span><span class="lineCov">         12 :           &amp;&amp; DECL_DECLARED_CONSTEXPR_P (current_function_decl))</span>
<span class="lineNum">   12565 </span><span class="lineCov">         12 :         {</span>
<span class="lineNum">   12566 </span><span class="lineCov">         12 :           error (&quot;%&lt;goto%&gt; in %&lt;constexpr%&gt; function&quot;);</span>
<span class="lineNum">   12567 </span><span class="lineNoCov">          0 :           cp_function_chain-&gt;invalid_constexpr = true;</span>
<span class="lineNum">   12568 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">   12569 </span>            : 
<span class="lineNum">   12570 </span><span class="lineCov">       4390 :       /* Create the goto-statement.  */</span>
<span class="lineNum">   12571 </span><span class="lineCov">       4390 :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_MULT))</span>
<span class="lineNum">   12572 </span>            :         {
<span class="lineNum">   12573 </span><span class="lineCov">    4488438 :           /* Issue a warning about this use of a GNU extension.  */</span>
<span class="lineNum">   12574 </span><span class="lineCov">    4488438 :           pedwarn (token-&gt;location, OPT_Wpedantic, &quot;ISO C++ forbids computed gotos&quot;);</span>
<span class="lineNum">   12575 </span><span class="lineCov">    4488438 :           /* Consume the '*' token.  */</span>
<span class="lineNum">   12576 </span><span class="lineCov">    4488438 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   12577 </span>            :           /* Parse the dependent expression.  */
<span class="lineNum">   12578 </span><span class="lineCov">    4488438 :           finish_goto_stmt (cp_parser_expression (parser));</span>
<span class="lineNum">   12579 </span>            :         }
<span class="lineNum">   12580 </span><span class="lineCov">      17608 :       else</span>
<span class="lineNum">   12581 </span><span class="lineCov">       8804 :         finish_goto_stmt (cp_parser_identifier (parser));</span>
<span class="lineNum">   12582 </span><span class="lineCov">       8804 :       /* Look for the final `;'.  */</span>
<span class="lineNum">   12583 </span>            :       cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);
<span class="lineNum">   12584 </span><span class="lineCov">    4479634 :       break;</span>
<span class="lineNum">   12585 </span><span class="lineCov">    4441376 : </span>
<span class="lineNum">   12586 </span>            :     default:
<span class="lineNum">   12587 </span>            :       cp_parser_error (parser, &quot;expected jump-statement&quot;);
<span class="lineNum">   12588 </span>            :       break;
<span class="lineNum">   12589 </span>            :     }
<span class="lineNum">   12590 </span>            : 
<span class="lineNum">   12591 </span><span class="lineCov">    4488438 :   return statement;</span>
<span class="lineNum">   12592 </span>            : }
<span class="lineNum">   12593 </span>            : 
<span class="lineNum">   12594 </span><span class="lineCov">    4488437 : /* Parse a declaration-statement.</span>
<span class="lineNum">   12595 </span>            : 
<span class="lineNum">   12596 </span><span class="lineCov">    4488438 :    declaration-statement:</span>
<span class="lineNum">   12597 </span>            :      block-declaration  */
<a name="12598"><span class="lineNum">   12598 </span><span class="lineCov">    4488438 : </span></a>
<span class="lineNum">   12599 </span>            : static void
<span class="lineNum">   12600 </span><span class="lineCov">        814 : cp_parser_declaration_statement (cp_parser* parser)</span>
<span class="lineNum">   12601 </span><span class="lineCov">        814 : {</span>
<span class="lineNum">   12602 </span><span class="lineCov">       1628 :   void *p;</span>
<span class="lineNum">   12603 </span>            : 
<span class="lineNum">   12604 </span><span class="lineCov">          1 :   /* Get the high-water mark for the DECLARATOR_OBSTACK.  */</span>
<span class="lineNum">   12605 </span><span class="lineCov">          1 :   p = obstack_alloc (&amp;declarator_obstack, 0);</span>
<span class="lineNum">   12606 </span>            : 
<span class="lineNum">   12607 </span>            :  /* Parse the block-declaration.  */
<span class="lineNum">   12608 </span>            :   cp_parser_block_declaration (parser, /*statement_p=*/true);
<span class="lineNum">   12609 </span><span class="lineCov">        814 : </span>
<span class="lineNum">   12610 </span>            :   /* Free any declarators allocated.  */
<span class="lineNum">   12611 </span>            :   obstack_free (&amp;declarator_obstack, p);
<span class="lineNum">   12612 </span><span class="lineCov">         73 : }</span>
<span class="lineNum">   12613 </span>            : 
<span class="lineNum">   12614 </span><span class="lineCov">         73 : /* Some dependent statements (like `if (cond) statement'), are</span>
<span class="lineNum">   12615 </span>            :    implicitly in their own scope.  In other words, if the statement is
<span class="lineNum">   12616 </span><span class="lineCov">         73 :    a single statement (as opposed to a compound-statement), it is</span>
<span class="lineNum">   12617 </span>            :    none-the-less treated as if it were enclosed in braces.  Any
<span class="lineNum">   12618 </span>            :    declarations appearing in the dependent statement are out of scope
<span class="lineNum">   12619 </span><span class="lineCov">        741 :    after control passes that point.  This function parses a statement,</span>
<span class="lineNum">   12620 </span>            :    but ensures that is in its own scope, even if it is not a
<span class="lineNum">   12621 </span><span class="lineCov">        814 :    compound-statement.</span>
<span class="lineNum">   12622 </span><span class="lineCov">        814 : </span>
<span class="lineNum">   12623 </span>            :    If IF_P is not NULL, *IF_P is set to indicate whether the statement
<span class="lineNum">   12624 </span><span class="lineNoCov">          0 :    is a (possibly labeled) if statement which is not enclosed in</span>
<span class="lineNum">   12625 </span><span class="lineNoCov">          0 :    braces and has an else clause.  This is used to implement</span>
<span class="lineNum">   12626 </span><span class="lineNoCov">          0 :    -Wparentheses.</span>
<span class="lineNum">   12627 </span>            : 
<span class="lineNum">   12628 </span>            :    CHAIN is a vector of if-else-if conditions.  This is used to implement
<span class="lineNum">   12629 </span>            :    -Wduplicated-cond.
<span class="lineNum">   12630 </span>            : 
<span class="lineNum">   12631 </span>            :    Returns the new statement.  */
<a name="12632"><span class="lineNum">   12632 </span>            : </a>
<span class="lineNum">   12633 </span>            : static tree
<span class="lineNum">   12634 </span>            : cp_parser_implicitly_scoped_statement (cp_parser* parser, bool *if_p,
<span class="lineNum">   12635 </span>            :                                        const token_indent_info &amp;guard_tinfo,
<span class="lineNum">   12636 </span>            :                                        vec&lt;tree&gt; *chain)
<span class="lineNum">   12637 </span>            : {
<span class="lineNum">   12638 </span><span class="lineCov">    6724678 :   tree statement;</span>
<span class="lineNum">   12639 </span>            :   location_t body_loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">   12640 </span><span class="lineCov">    6724678 :   location_t body_loc_after_labels = UNKNOWN_LOCATION;</span>
<span class="lineNum">   12641 </span>            :   token_indent_info body_tinfo
<span class="lineNum">   12642 </span>            :     = get_token_indent_info (cp_lexer_peek_token (parser-&gt;lexer));
<span class="lineNum">   12643 </span><span class="lineCov">    6724678 : </span>
<span class="lineNum">   12644 </span>            :   if (if_p != NULL)
<span class="lineNum">   12645 </span>            :     *if_p = false;
<span class="lineNum">   12646 </span><span class="lineCov">    6724678 : </span>
<span class="lineNum">   12647 </span>            :   /* Mark if () ; with a special NOP_EXPR.  */
<span class="lineNum">   12648 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_SEMICOLON))
<span class="lineNum">   12649 </span><span class="lineCov">    6724673 :     {</span>
<span class="lineNum">   12650 </span><span class="lineCov">    6724673 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   12651 </span>            :       statement = add_stmt (build_empty_stmt (body_loc));
<span class="lineNum">   12652 </span>            : 
<span class="lineNum">   12653 </span>            :       if (guard_tinfo.keyword == RID_IF
<span class="lineNum">   12654 </span>            :           &amp;&amp; !cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_ELSE))
<span class="lineNum">   12655 </span>            :         warning_at (body_loc, OPT_Wempty_body,
<span class="lineNum">   12656 </span>            :                     &quot;suggest braces around empty body in an %&lt;if%&gt; statement&quot;);
<span class="lineNum">   12657 </span>            :       else if (guard_tinfo.keyword == RID_ELSE)
<span class="lineNum">   12658 </span>            :         warning_at (body_loc, OPT_Wempty_body,
<span class="lineNum">   12659 </span>            :                     &quot;suggest braces around empty body in an %&lt;else%&gt; statement&quot;);
<span class="lineNum">   12660 </span>            :     }
<span class="lineNum">   12661 </span>            :   /* if a compound is opened, we simply parse the statement directly.  */
<span class="lineNum">   12662 </span>            :   else if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_BRACE))
<span class="lineNum">   12663 </span>            :     statement = cp_parser_compound_statement (parser, NULL, BCS_NORMAL, false);
<span class="lineNum">   12664 </span>            :   /* If the token is not a `{', then we must take special action.  */
<span class="lineNum">   12665 </span>            :   else
<span class="lineNum">   12666 </span>            :     {
<span class="lineNum">   12667 </span>            :       /* Create a compound-statement.  */
<span class="lineNum">   12668 </span>            :       statement = begin_compound_stmt (0);
<span class="lineNum">   12669 </span>            :       /* Parse the dependent-statement.  */
<span class="lineNum">   12670 </span>            :       cp_parser_statement (parser, NULL_TREE, false, if_p, chain,
<span class="lineNum">   12671 </span>            :                            &amp;body_loc_after_labels);
<span class="lineNum">   12672 </span><span class="lineCov">    2209929 :       /* Finish the dummy compound-statement.  */</span>
<span class="lineNum">   12673 </span>            :       finish_compound_stmt (statement);
<span class="lineNum">   12674 </span>            :     }
<span class="lineNum">   12675 </span>            : 
<span class="lineNum">   12676 </span><span class="lineCov">    2209929 :   token_indent_info next_tinfo</span>
<span class="lineNum">   12677 </span><span class="lineCov">    4419858 :     = get_token_indent_info (cp_lexer_peek_token (parser-&gt;lexer));</span>
<span class="lineNum">   12678 </span><span class="lineCov">    2209929 :   warn_for_misleading_indentation (guard_tinfo, body_tinfo, next_tinfo);</span>
<span class="lineNum">   12679 </span><span class="lineCov">    2209929 : </span>
<span class="lineNum">   12680 </span><span class="lineCov">    2209929 :   if (body_loc_after_labels != UNKNOWN_LOCATION</span>
<span class="lineNum">   12681 </span>            :       &amp;&amp; next_tinfo.type != CPP_SEMICOLON)
<span class="lineNum">   12682 </span><span class="lineCov">    2209929 :     warn_for_multistatement_macros (body_loc_after_labels, next_tinfo.location,</span>
<span class="lineNum">   12683 </span><span class="lineCov">    1645307 :                                     guard_tinfo.location, guard_tinfo.keyword);</span>
<span class="lineNum">   12684 </span>            : 
<span class="lineNum">   12685 </span>            :   /* Return the statement.  */
<span class="lineNum">   12686 </span><span class="lineCov">    2209929 :   return statement;</span>
<span class="lineNum">   12687 </span>            : }
<span class="lineNum">   12688 </span><span class="lineCov">        855 : </span>
<span class="lineNum">   12689 </span><span class="lineCov">        855 : /* For some dependent statements (like `while (cond) statement'), we</span>
<span class="lineNum">   12690 </span>            :    have already created a scope.  Therefore, even if the dependent
<span class="lineNum">   12691 </span><span class="lineCov">        855 :    statement is a compound-statement, we do not want to create another</span>
<span class="lineNum">   12692 </span><span class="lineCov">        855 :    scope.  */</span>
<a name="12693"><span class="lineNum">   12693 </span><span class="lineCov">        621 : </span></a>
<span class="lineNum">   12694 </span>            : static void
<span class="lineNum">   12695 </span><span class="lineCov">        234 : cp_parser_already_scoped_statement (cp_parser* parser, bool *if_p,</span>
<span class="lineNum">   12696 </span><span class="lineCov">         15 :                                     const token_indent_info &amp;guard_tinfo)</span>
<span class="lineNum">   12697 </span>            : {
<span class="lineNum">   12698 </span>            :   /* If the token is a `{', then we must take special action.  */
<span class="lineNum">   12699 </span>            :   if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_OPEN_BRACE))
<span class="lineNum">   12700 </span><span class="lineCov">    2209074 :     {</span>
<span class="lineNum">   12701 </span><span class="lineCov">     776417 :       token_indent_info body_tinfo</span>
<span class="lineNum">   12702 </span>            :         = get_token_indent_info (cp_lexer_peek_token (parser-&gt;lexer));
<span class="lineNum">   12703 </span>            :       location_t loc_after_labels = UNKNOWN_LOCATION;
<span class="lineNum">   12704 </span>            : 
<span class="lineNum">   12705 </span>            :       cp_parser_statement (parser, NULL_TREE, false, if_p, NULL,
<span class="lineNum">   12706 </span><span class="lineCov">    1432657 :                            &amp;loc_after_labels);</span>
<span class="lineNum">   12707 </span>            :       token_indent_info next_tinfo
<span class="lineNum">   12708 </span><span class="lineCov">    1432657 :         = get_token_indent_info (cp_lexer_peek_token (parser-&gt;lexer));</span>
<span class="lineNum">   12709 </span>            :       warn_for_misleading_indentation (guard_tinfo, body_tinfo, next_tinfo);
<span class="lineNum">   12710 </span>            : 
<span class="lineNum">   12711 </span><span class="lineCov">    1432657 :       if (loc_after_labels != UNKNOWN_LOCATION</span>
<span class="lineNum">   12712 </span>            :           &amp;&amp; next_tinfo.type != CPP_SEMICOLON)
<span class="lineNum">   12713 </span>            :         warn_for_multistatement_macros (loc_after_labels, next_tinfo.location,
<span class="lineNum">   12714 </span><span class="lineCov">    2209929 :                                         guard_tinfo.location,</span>
<span class="lineNum">   12715 </span><span class="lineCov">    2209929 :                                         guard_tinfo.keyword);</span>
<span class="lineNum">   12716 </span><span class="lineCov">    2209929 :     }</span>
<span class="lineNum">   12717 </span>            :   else
<span class="lineNum">   12718 </span><span class="lineCov">    2209929 :     {</span>
<span class="lineNum">   12719 </span><span class="lineCov">     918275 :       /* Avoid calling cp_parser_compound_statement, so that we</span>
<span class="lineNum">   12720 </span><span class="lineCov">    2745120 :          don't create a new scope.  Do everything else by hand.  */</span>
<span class="lineNum">   12721 </span><span class="lineCov">     915040 :       matching_braces braces;</span>
<span class="lineNum">   12722 </span>            :       braces.require_open (parser);
<span class="lineNum">   12723 </span>            :       /* If the next keyword is `__label__' we have a label declaration.  */
<span class="lineNum">   12724 </span><span class="lineCov">    2209929 :       while (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_LABEL))</span>
<span class="lineNum">   12725 </span>            :         cp_parser_label_declaration (parser);
<span class="lineNum">   12726 </span>            :       /* Parse an (optional) statement-seq.  */
<span class="lineNum">   12727 </span>            :       cp_parser_statement_seq_opt (parser, NULL_TREE);
<span class="lineNum">   12728 </span>            :       braces.require_close (parser);
<span class="lineNum">   12729 </span>            :     }
<span class="lineNum">   12730 </span>            : }
<span class="lineNum">   12731 </span>            : 
<span class="lineNum">   12732 </span>            : /* Declarations [gram.dcl.dcl] */
<span class="lineNum">   12733 </span><span class="lineCov">     316824 : </span>
<span class="lineNum">   12734 </span>            : /* Parse an optional declaration-sequence.
<span class="lineNum">   12735 </span>            : 
<span class="lineNum">   12736 </span>            :    declaration-seq:
<span class="lineNum">   12737 </span><span class="lineCov">     316824 :      declaration</span>
<span class="lineNum">   12738 </span>            :      declaration-seq declaration  */
<a name="12739"><span class="lineNum">   12739 </span><span class="lineCov">     173730 : </span></a>
<span class="lineNum">   12740 </span><span class="lineCov">     173730 : static void</span>
<span class="lineNum">   12741 </span><span class="lineCov">     173730 : cp_parser_declaration_seq_opt (cp_parser* parser)</span>
<span class="lineNum">   12742 </span>            : {
<span class="lineNum">   12743 </span><span class="lineCov">     173730 :   while (true)</span>
<span class="lineNum">   12744 </span>            :     {
<span class="lineNum">   12745 </span><span class="lineCov">     173730 :       cp_token *token;</span>
<span class="lineNum">   12746 </span><span class="lineCov">     173730 : </span>
<span class="lineNum">   12747 </span><span class="lineCov">     173730 :       token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   12748 </span>            : 
<span class="lineNum">   12749 </span><span class="lineCov">     173730 :       if (token-&gt;type == CPP_CLOSE_BRACE</span>
<span class="lineNum">   12750 </span><span class="lineCov">     123240 :           || token-&gt;type == CPP_EOF</span>
<span class="lineNum">   12751 </span><span class="lineCov">     369423 :           || token-&gt;type == CPP_PRAGMA_EOL)</span>
<span class="lineNum">   12752 </span><span class="lineCov">     123141 :         break;</span>
<span class="lineNum">   12753 </span><span class="lineCov">     123141 : </span>
<span class="lineNum">   12754 </span>            :       if (token-&gt;type == CPP_SEMICOLON)
<span class="lineNum">   12755 </span>            :         {
<span class="lineNum">   12756 </span>            :           /* A declaration consisting of a single semicolon is
<span class="lineNum">   12757 </span>            :              invalid.  Allow it unless we're being pedantic.  */
<span class="lineNum">   12758 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   12759 </span><span class="lineCov">     286188 :           if (!in_system_header_at (input_location))</span>
<span class="lineNum">   12760 </span><span class="lineCov">     143094 :             pedwarn (input_location, OPT_Wpedantic, &quot;extra %&lt;;%&gt;&quot;);</span>
<span class="lineNum">   12761 </span>            :           continue;
<span class="lineNum">   12762 </span><span class="lineCov">     143100 :         }</span>
<span class="lineNum">   12763 </span><span class="lineCov">          6 : </span>
<span class="lineNum">   12764 </span>            :       /* If we're entering or exiting a region that's implicitly
<span class="lineNum">   12765 </span><span class="lineCov">     143094 :          extern &quot;C&quot;, modify the lang context appropriately.  */</span>
<span class="lineNum">   12766 </span><span class="lineCov">     143094 :       if (!parser-&gt;implicit_extern_c &amp;&amp; token-&gt;implicit_extern_c)</span>
<span class="lineNum">   12767 </span>            :         {
<span class="lineNum">   12768 </span><span class="lineCov">     316824 :           push_lang_context (lang_name_c);</span>
<span class="lineNum">   12769 </span>            :           parser-&gt;implicit_extern_c = true;
<span class="lineNum">   12770 </span>            :         }
<span class="lineNum">   12771 </span>            :       else if (parser-&gt;implicit_extern_c &amp;&amp; !token-&gt;implicit_extern_c)
<span class="lineNum">   12772 </span>            :         {
<span class="lineNum">   12773 </span>            :           pop_lang_context ();
<span class="lineNum">   12774 </span>            :           parser-&gt;implicit_extern_c = false;
<span class="lineNum">   12775 </span>            :         }
<span class="lineNum">   12776 </span>            : 
<span class="lineNum">   12777 </span>            :       if (token-&gt;type == CPP_PRAGMA)
<span class="lineNum">   12778 </span>            :         {
<span class="lineNum">   12779 </span><span class="lineCov">     494397 :           /* A top-level declaration can consist solely of a #pragma.</span>
<span class="lineNum">   12780 </span>            :              A nested declaration cannot, so this is done here and not
<span class="lineNum">   12781 </span><span class="lineCov">   11550552 :              in cp_parser_declaration.  (A #pragma at block scope is</span>
<span class="lineNum">   12782 </span>            :              handled in cp_parser_statement.)  */
<span class="lineNum">   12783 </span><span class="lineCov">   11550552 :           cp_parser_pragma (parser, pragma_external, NULL);</span>
<span class="lineNum">   12784 </span>            :           continue;
<span class="lineNum">   12785 </span><span class="lineCov">   23101104 :         }</span>
<span class="lineNum">   12786 </span>            : 
<span class="lineNum">   12787 </span><span class="lineCov">   23101104 :       /* Parse the declaration itself.  */</span>
<span class="lineNum">   12788 </span><span class="lineCov">   11550552 :       cp_parser_declaration (parser);</span>
<span class="lineNum">   12789 </span><span class="lineCov">   11056196 :     }</span>
<span class="lineNum">   12790 </span>            : }
<span class="lineNum">   12791 </span>            : 
<span class="lineNum">   12792 </span><span class="lineCov">   11056196 : /* Parse a declaration.</span>
<span class="lineNum">   12793 </span>            : 
<span class="lineNum">   12794 </span>            :    declaration:
<span class="lineNum">   12795 </span>            :      block-declaration
<span class="lineNum">   12796 </span><span class="lineCov">      13204 :      function-definition</span>
<span class="lineNum">   12797 </span><span class="lineCov">      13204 :      template-declaration</span>
<span class="lineNum">   12798 </span><span class="lineCov">       1486 :      explicit-instantiation</span>
<span class="lineNum">   12799 </span><span class="lineCov">      13204 :      explicit-specialization</span>
<span class="lineNum">   12800 </span>            :      linkage-specification
<span class="lineNum">   12801 </span>            :      namespace-definition
<span class="lineNum">   12802 </span>            : 
<span class="lineNum">   12803 </span>            :    C++17:
<span class="lineNum">   12804 </span><span class="lineCov">   11042992 :      deduction-guide</span>
<span class="lineNum">   12805 </span>            : 
<span class="lineNum">   12806 </span><span class="lineNoCov">          0 :    GNU extension:</span>
<span class="lineNum">   12807 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   12808 </span>            :    declaration:
<span class="lineNum">   12809 </span><span class="lineCov">   11042992 :       __extension__ declaration */</span>
<a name="12810"><span class="lineNum">   12810 </span>            : </a>
<span class="lineNum">   12811 </span><span class="lineNoCov">          0 : static void</span>
<span class="lineNum">   12812 </span><span class="lineNoCov">          0 : cp_parser_declaration (cp_parser* parser)</span>
<span class="lineNum">   12813 </span>            : {
<span class="lineNum">   12814 </span>            :   cp_token token1;
<span class="lineNum">   12815 </span><span class="lineCov">   11042992 :   cp_token token2;</span>
<span class="lineNum">   12816 </span>            :   int saved_pedantic;
<span class="lineNum">   12817 </span>            :   void *p;
<span class="lineNum">   12818 </span>            :   tree attributes = NULL_TREE;
<span class="lineNum">   12819 </span>            : 
<span class="lineNum">   12820 </span>            :   /* Check for the `__extension__' keyword.  */
<span class="lineNum">   12821 </span><span class="lineCov">      87372 :   if (cp_parser_extension_opt (parser, &amp;saved_pedantic))</span>
<span class="lineNum">   12822 </span><span class="lineCov">      87372 :     {</span>
<span class="lineNum">   12823 </span>            :       /* Parse the qualified declaration.  */
<span class="lineNum">   12824 </span>            :       cp_parser_declaration (parser);
<span class="lineNum">   12825 </span>            :       /* Restore the PEDANTIC flag.  */
<span class="lineNum">   12826 </span><span class="lineCov">   10955620 :       pedantic = saved_pedantic;</span>
<span class="lineNum">   12827 </span>            : 
<span class="lineNum">   12828 </span><span class="lineCov">     494356 :       return;</span>
<span class="lineNum">   12829 </span>            :     }
<span class="lineNum">   12830 </span>            : 
<span class="lineNum">   12831 </span>            :   /* Try to figure out what kind of declaration is present.  */
<span class="lineNum">   12832 </span>            :   token1 = *cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   12833 </span>            : 
<span class="lineNum">   12834 </span>            :   if (token1.type != CPP_EOF)
<span class="lineNum">   12835 </span>            :     token2 = *cp_lexer_peek_nth_token (parser-&gt;lexer, 2);
<span class="lineNum">   12836 </span>            :   else
<span class="lineNum">   12837 </span>            :     {
<span class="lineNum">   12838 </span>            :       token2.type = CPP_EOF;
<span class="lineNum">   12839 </span>            :       token2.keyword = RID_MAX;
<span class="lineNum">   12840 </span>            :     }
<span class="lineNum">   12841 </span>            : 
<span class="lineNum">   12842 </span>            :   /* Get the high-water mark for the DECLARATOR_OBSTACK.  */
<span class="lineNum">   12843 </span>            :   p = obstack_alloc (&amp;declarator_obstack, 0);
<span class="lineNum">   12844 </span>            : 
<span class="lineNum">   12845 </span>            :   /* If the next token is `extern' and the following token is a string
<span class="lineNum">   12846 </span>            :      literal, then we have a linkage specification.  */
<span class="lineNum">   12847 </span>            :   if (token1.keyword == RID_EXTERN
<span class="lineNum">   12848 </span>            :       &amp;&amp; cp_parser_is_pure_string_literal (&amp;token2))
<span class="lineNum">   12849 </span>            :     cp_parser_linkage_specification (parser);
<span class="lineNum">   12850 </span><span class="lineCov">   11064954 :   /* If the next token is `template', then we have either a template</span>
<span class="lineNum">   12851 </span>            :      declaration, an explicit instantiation, or an explicit
<span class="lineNum">   12852 </span><span class="lineCov">   11064954 :      specialization.  */</span>
<span class="lineNum">   12853 </span><span class="lineCov">   11064954 :   else if (token1.keyword == RID_TEMPLATE)</span>
<span class="lineNum">   12854 </span><span class="lineCov">   11064954 :     {</span>
<span class="lineNum">   12855 </span><span class="lineCov">   11064954 :       /* `template &lt;&gt;' indicates a template specialization.  */</span>
<span class="lineNum">   12856 </span><span class="lineCov">   11064954 :       if (token2.type == CPP_LESS</span>
<span class="lineNum">   12857 </span>            :           &amp;&amp; cp_lexer_peek_nth_token (parser-&gt;lexer, 3)-&gt;type == CPP_GREATER)
<span class="lineNum">   12858 </span>            :         cp_parser_explicit_specialization (parser);
<span class="lineNum">   12859 </span><span class="lineCov">   22129908 :       /* `template &lt;' indicates a template declaration.  */</span>
<span class="lineNum">   12860 </span>            :       else if (token2.type == CPP_LESS)
<span class="lineNum">   12861 </span>            :         cp_parser_template_declaration (parser, /*member_p=*/false);
<span class="lineNum">   12862 </span><span class="lineCov">      65971 :       /* Anything else must be an explicit instantiation.  */</span>
<span class="lineNum">   12863 </span>            :       else
<span class="lineNum">   12864 </span><span class="lineCov">      65971 :         cp_parser_explicit_instantiation (parser);</span>
<span class="lineNum">   12865 </span>            :     }
<span class="lineNum">   12866 </span><span class="lineCov">      65971 :   /* If the next token is `export', then we have a template</span>
<span class="lineNum">   12867 </span>            :      declaration.  */
<span class="lineNum">   12868 </span>            :   else if (token1.keyword == RID_EXPORT)
<span class="lineNum">   12869 </span>            :     cp_parser_template_declaration (parser, /*member_p=*/false);
<span class="lineNum">   12870 </span><span class="lineCov">   21997966 :   /* If the next token is `extern', 'static' or 'inline' and the one</span>
<span class="lineNum">   12871 </span>            :      after that is `template', we have a GNU extended explicit
<span class="lineNum">   12872 </span><span class="lineCov">   10998983 :      instantiation directive.  */</span>
<span class="lineNum">   12873 </span><span class="lineCov">   10998983 :   else if (cp_parser_allow_gnu_extensions_p (parser)</span>
<span class="lineNum">   12874 </span>            :            &amp;&amp; (token1.keyword == RID_EXTERN
<span class="lineNum">   12875 </span>            :                || token1.keyword == RID_STATIC
<span class="lineNum">   12876 </span>            :                || token1.keyword == RID_INLINE)
<span class="lineNum">   12877 </span>            :            &amp;&amp; token2.keyword == RID_TEMPLATE)
<span class="lineNum">   12878 </span>            :     cp_parser_explicit_instantiation (parser);
<span class="lineNum">   12879 </span>            :   /* If the next token is `namespace', check for a named or unnamed
<span class="lineNum">   12880 </span>            :      namespace definition.  */
<span class="lineNum">   12881 </span><span class="lineCov">   10998983 :   else if (token1.keyword == RID_NAMESPACE</span>
<span class="lineNum">   12882 </span>            :            &amp;&amp; (/* A named namespace definition.  */
<span class="lineNum">   12883 </span>            :                (token2.type == CPP_NAME
<span class="lineNum">   12884 </span>            :                 &amp;&amp; (cp_lexer_peek_nth_token (parser-&gt;lexer, 3)-&gt;type
<span class="lineNum">   12885 </span><span class="lineCov">   10998983 :                     != CPP_EQ))</span>
<span class="lineNum">   12886 </span><span class="lineCov">   10998983 :                || (token2.type == CPP_OPEN_SQUARE</span>
<span class="lineNum">   12887 </span><span class="lineCov">     140164 :                    &amp;&amp; cp_lexer_peek_nth_token (parser-&gt;lexer, 3)-&gt;type</span>
<span class="lineNum">   12888 </span>            :                    == CPP_OPEN_SQUARE)
<span class="lineNum">   12889 </span>            :                /* An unnamed namespace definition.  */
<span class="lineNum">   12890 </span>            :                || token2.type == CPP_OPEN_BRACE
<span class="lineNum">   12891 </span><span class="lineCov">   10858819 :                || token2.keyword == RID_ATTRIBUTE))</span>
<span class="lineNum">   12892 </span>            :     cp_parser_namespace_definition (parser);
<span class="lineNum">   12893 </span>            :   /* An inline (associated) namespace definition.  */
<span class="lineNum">   12894 </span><span class="lineCov">    3730779 :   else if (token1.keyword == RID_INLINE</span>
<span class="lineNum">   12895 </span><span class="lineCov">    3730779 :            &amp;&amp; token2.keyword == RID_NAMESPACE)</span>
<span class="lineNum">   12896 </span><span class="lineCov">     456282 :     cp_parser_namespace_definition (parser);</span>
<span class="lineNum">   12897 </span>            :   /* Objective-C++ declaration/definition.  */
<span class="lineNum">   12898 </span><span class="lineCov">    3274497 :   else if (c_dialect_objc () &amp;&amp; OBJC_IS_AT_KEYWORD (token1.keyword))</span>
<span class="lineNum">   12899 </span><span class="lineCov">    3270218 :     cp_parser_objc_declaration (parser, NULL_TREE);</span>
<span class="lineNum">   12900 </span>            :   else if (c_dialect_objc ()
<span class="lineNum">   12901 </span>            :            &amp;&amp; token1.keyword == RID_ATTRIBUTE
<span class="lineNum">   12902 </span><span class="lineCov">       4279 :            &amp;&amp; cp_parser_objc_valid_prefix_attributes (parser, &amp;attributes))</span>
<span class="lineNum">   12903 </span>            :     cp_parser_objc_declaration (parser, attributes);
<span class="lineNum">   12904 </span>            :   /* At this point we may have a template declared by a concept
<span class="lineNum">   12905 </span>            :      introduction.  */
<span class="lineNum">   12906 </span><span class="lineCov">    7128040 :   else if (flag_concepts</span>
<span class="lineNum">   12907 </span><span class="lineCov">         18 :            &amp;&amp; cp_parser_template_declaration_after_export (parser,</span>
<span class="lineNum">   12908 </span>            :                                                            /*member_p=*/false))
<span class="lineNum">   12909 </span>            :     /* We did.  */;
<span class="lineNum">   12910 </span>            :   else
<span class="lineNum">   12911 </span><span class="lineCov">   14256044 :     /* Try to parse a block-declaration, or a function-definition.  */</span>
<span class="lineNum">   12912 </span><span class="lineCov">    7128022 :     cp_parser_block_declaration (parser, /*statement_p=*/false);</span>
<span class="lineNum">   12913 </span><span class="lineCov">    3333637 : </span>
<span class="lineNum">   12914 </span><span class="lineCov">    3162643 :   /* Free any declarators allocated.  */</span>
<span class="lineNum">   12915 </span><span class="lineCov">    4280932 :   obstack_free (&amp;declarator_obstack, p);</span>
<span class="lineNum">   12916 </span><span class="lineCov">     146523 : }</span>
<span class="lineNum">   12917 </span>            : 
<span class="lineNum">   12918 </span>            : /* Parse a block-declaration.
<span class="lineNum">   12919 </span><span class="lineCov">    6981499 : </span>
<span class="lineNum">   12920 </span><span class="lineCov">    6981499 :    block-declaration:</span>
<span class="lineNum">   12921 </span>            :      simple-declaration
<span class="lineNum">   12922 </span><span class="lineCov">     323186 :      asm-definition</span>
<span class="lineNum">   12923 </span>            :      namespace-alias-definition
<span class="lineNum">   12924 </span><span class="lineCov">       2283 :      using-declaration</span>
<span class="lineNum">   12925 </span><span class="lineCov">          5 :      using-directive</span>
<span class="lineNum">   12926 </span>            : 
<span class="lineNum">   12927 </span>            :    GNU Extension:
<span class="lineNum">   12928 </span><span class="lineCov">       2278 : </span>
<span class="lineNum">   12929 </span><span class="lineCov">        465 :    block-declaration:</span>
<span class="lineNum">   12930 </span><span class="lineCov">     324545 :      __extension__ block-declaration</span>
<span class="lineNum">   12931 </span>            : 
<span class="lineNum">   12932 </span><span class="lineCov">    6656954 :    C++0x Extension:</span>
<span class="lineNum">   12933 </span><span class="lineCov">     315529 : </span>
<span class="lineNum">   12934 </span><span class="lineCov">      16157 :    block-declaration:</span>
<span class="lineNum">   12935 </span>            :      static_assert-declaration
<span class="lineNum">   12936 </span><span class="lineCov">    6640797 : </span>
<span class="lineNum">   12937 </span><span class="lineNoCov">          0 :    If STATEMENT_P is TRUE, then this block-declaration is occurring as</span>
<span class="lineNum">   12938 </span><span class="lineCov">    6640797 :    part of a declaration-statement.  */</span>
<a name="12939"><span class="lineNum">   12939 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   12940 </span><span class="lineCov">    6640797 : static void</span>
<span class="lineNum">   12941 </span><span class="lineNoCov">          0 : cp_parser_block_declaration (cp_parser *parser,</span>
<span class="lineNum">   12942 </span>            :                              bool      statement_p)
<span class="lineNum">   12943 </span>            : {
<span class="lineNum">   12944 </span><span class="lineCov">    6640797 :   cp_token *token1;</span>
<span class="lineNum">   12945 </span><span class="lineCov">    6640797 :   int saved_pedantic;</span>
<span class="lineNum">   12946 </span>            : 
<span class="lineNum">   12947 </span>            :   /* Check for the `__extension__' keyword.  */
<span class="lineNum">   12948 </span>            :   if (cp_parser_extension_opt (parser, &amp;saved_pedantic))
<span class="lineNum">   12949 </span>            :     {
<span class="lineNum">   12950 </span><span class="lineCov">    6640776 :       /* Parse the qualified declaration.  */</span>
<span class="lineNum">   12951 </span>            :       cp_parser_block_declaration (parser, statement_p);
<span class="lineNum">   12952 </span>            :       /* Restore the PEDANTIC flag.  */
<span class="lineNum">   12953 </span><span class="lineCov">   10998942 :       pedantic = saved_pedantic;</span>
<span class="lineNum">   12954 </span>            : 
<span class="lineNum">   12955 </span>            :       return;
<span class="lineNum">   12956 </span>            :     }
<span class="lineNum">   12957 </span>            : 
<span class="lineNum">   12958 </span>            :   /* Peek at the next token to figure out which kind of declaration is
<span class="lineNum">   12959 </span>            :      present.  */
<span class="lineNum">   12960 </span>            :   token1 = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   12961 </span>            : 
<span class="lineNum">   12962 </span>            :   /* If the next keyword is `asm', we have an asm-definition.  */
<span class="lineNum">   12963 </span>            :   if (token1-&gt;keyword == RID_ASM)
<span class="lineNum">   12964 </span>            :     {
<span class="lineNum">   12965 </span>            :       if (statement_p)
<span class="lineNum">   12966 </span>            :         cp_parser_commit_to_tentative_parse (parser);
<span class="lineNum">   12967 </span>            :       cp_parser_asm_definition (parser);
<span class="lineNum">   12968 </span>            :     }
<span class="lineNum">   12969 </span>            :   /* If the next keyword is `namespace', we have a
<span class="lineNum">   12970 </span>            :      namespace-alias-definition.  */
<span class="lineNum">   12971 </span>            :   else if (token1-&gt;keyword == RID_NAMESPACE)
<span class="lineNum">   12972 </span>            :     cp_parser_namespace_alias_definition (parser);
<span class="lineNum">   12973 </span>            :   /* If the next keyword is `using', we have a
<span class="lineNum">   12974 </span>            :      using-declaration, a using-directive, or an alias-declaration.  */
<span class="lineNum">   12975 </span>            :   else if (token1-&gt;keyword == RID_USING)
<span class="lineNum">   12976 </span>            :     {
<span class="lineNum">   12977 </span>            :       cp_token *token2;
<span class="lineNum">   12978 </span>            : 
<span class="lineNum">   12979 </span><span class="lineCov">   13365488 :       if (statement_p)</span>
<span class="lineNum">   12980 </span>            :         cp_parser_commit_to_tentative_parse (parser);
<span class="lineNum">   12981 </span>            :       /* If the token after `using' is `namespace', then we have a
<span class="lineNum">   12982 </span><span class="lineCov">   13365488 :          using-directive.  */</span>
<span class="lineNum">   12983 </span><span class="lineCov">   13365488 :       token2 = cp_lexer_peek_nth_token (parser-&gt;lexer, 2);</span>
<span class="lineNum">   12984 </span>            :       if (token2-&gt;keyword == RID_NAMESPACE)
<span class="lineNum">   12985 </span>            :         cp_parser_using_directive (parser);
<span class="lineNum">   12986 </span><span class="lineCov">   26730976 :       /* If the second token after 'using' is '=', then we have an</span>
<span class="lineNum">   12987 </span>            :          alias-declaration.  */
<span class="lineNum">   12988 </span>            :       else if (cxx_dialect &gt;= cxx11
<span class="lineNum">   12989 </span><span class="lineCov">         34 :                &amp;&amp; token2-&gt;type == CPP_NAME</span>
<span class="lineNum">   12990 </span>            :                &amp;&amp; ((cp_lexer_peek_nth_token (parser-&gt;lexer, 3)-&gt;type == CPP_EQ)
<span class="lineNum">   12991 </span><span class="lineCov">         34 :                    || (cp_nth_tokens_can_be_attribute_p (parser, 3))))</span>
<span class="lineNum">   12992 </span>            :         cp_parser_alias_declaration (parser);
<span class="lineNum">   12993 </span><span class="lineCov">         34 :       /* Otherwise, it's a using-declaration.  */</span>
<span class="lineNum">   12994 </span>            :       else
<span class="lineNum">   12995 </span>            :         cp_parser_using_declaration (parser,
<span class="lineNum">   12996 </span>            :                                      /*access_declaration_p=*/false);
<span class="lineNum">   12997 </span>            :     }
<span class="lineNum">   12998 </span><span class="lineCov">   26730908 :   /* If the next keyword is `__label__' we have a misplaced label</span>
<span class="lineNum">   12999 </span>            :      declaration.  */
<span class="lineNum">   13000 </span>            :   else if (token1-&gt;keyword == RID_LABEL)
<span class="lineNum">   13001 </span><span class="lineCov">   13365454 :     {</span>
<span class="lineNum">   13002 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   13003 </span><span class="lineCov">      13271 :       error_at (token1-&gt;location, &quot;%&lt;__label__%&gt; not at the beginning of a block&quot;);</span>
<span class="lineNum">   13004 </span><span class="lineCov">      13142 :       cp_parser_skip_to_end_of_statement (parser);</span>
<span class="lineNum">   13005 </span><span class="lineCov">      13271 :       /* If the next token is now a `;', consume it.  */</span>
<span class="lineNum">   13006 </span>            :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_SEMICOLON))
<span class="lineNum">   13007 </span>            :         cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   13008 </span>            :     }
<span class="lineNum">   13009 </span><span class="lineCov">   13352183 :   /* If the next token is `static_assert' we have a static assertion.  */</span>
<span class="lineNum">   13010 </span><span class="lineCov">        505 :   else if (token1-&gt;keyword == RID_STATIC_ASSERT)</span>
<span class="lineNum">   13011 </span>            :     cp_parser_static_assert (parser, /*member_p=*/false);
<span class="lineNum">   13012 </span>            :   /* Anything else must be a simple-declaration.  */
<span class="lineNum">   13013 </span><span class="lineCov">   13351678 :   else</span>
<span class="lineNum">   13014 </span>            :     cp_parser_simple_declaration (parser, !statement_p,
<span class="lineNum">   13015 </span><span class="lineCov">     675110 :                                   /*maybe_range_for_decl*/NULL);</span>
<span class="lineNum">   13016 </span>            : }
<span class="lineNum">   13017 </span><span class="lineCov">     675110 : </span>
<span class="lineNum">   13018 </span><span class="lineCov">      81370 : /* Parse a simple-declaration.</span>
<span class="lineNum">   13019 </span>            : 
<span class="lineNum">   13020 </span>            :    simple-declaration:
<span class="lineNum">   13021 </span><span class="lineCov">     675110 :      decl-specifier-seq [opt] init-declarator-list [opt] ;</span>
<span class="lineNum">   13022 </span><span class="lineCov">     675110 :      decl-specifier-seq ref-qualifier [opt] [ identifier-list ]</span>
<span class="lineNum">   13023 </span><span class="lineCov">      10784 :        brace-or-equal-initializer ;</span>
<span class="lineNum">   13024 </span>            : 
<span class="lineNum">   13025 </span>            :    init-declarator-list:
<span class="lineNum">   13026 </span><span class="lineCov">     664326 :      init-declarator</span>
<span class="lineNum">   13027 </span><span class="lineCov">     622838 :      init-declarator-list , init-declarator</span>
<span class="lineNum">   13028 </span><span class="lineCov">     839057 : </span>
<span class="lineNum">   13029 </span><span class="lineCov">     103863 :    If FUNCTION_DEFINITION_ALLOWED_P is TRUE, then we also recognize a</span>
<span class="lineNum">   13030 </span><span class="lineCov">      70874 :    function-definition as a simple-declaration.</span>
<span class="lineNum">   13031 </span>            : 
<span class="lineNum">   13032 </span>            :    If MAYBE_RANGE_FOR_DECL is not NULL, the pointed tree will be set to the
<span class="lineNum">   13033 </span><span class="lineCov">     593452 :    parsed declaration if it is an uninitialized single declarator not followed</span>
<span class="lineNum">   13034 </span>            :    by a `;', or to error_mark_node otherwise. Either way, the trailing `;',
<span class="lineNum">   13035 </span>            :    if present, will not be consumed.  */
<a name="13036"><span class="lineNum">   13036 </span>            : </a>
<span class="lineNum">   13037 </span>            : static void
<span class="lineNum">   13038 </span><span class="lineCov">   12676568 : cp_parser_simple_declaration (cp_parser* parser,</span>
<span class="lineNum">   13039 </span>            :                               bool function_definition_allowed_p,
<span class="lineNum">   13040 </span><span class="lineCov">         18 :                               tree *maybe_range_for_decl)</span>
<span class="lineNum">   13041 </span><span class="lineCov">         18 : {</span>
<span class="lineNum">   13042 </span><span class="lineCov">         18 :   cp_decl_specifier_seq decl_specifiers;</span>
<span class="lineNum">   13043 </span>            :   int declares_class_or_enum;
<span class="lineNum">   13044 </span><span class="lineCov">         18 :   bool saw_declarator;</span>
<span class="lineNum">   13045 </span><span class="lineCov">         18 :   location_t comma_loc = UNKNOWN_LOCATION;</span>
<span class="lineNum">   13046 </span>            :   location_t init_loc = UNKNOWN_LOCATION;
<span class="lineNum">   13047 </span>            : 
<span class="lineNum">   13048 </span><span class="lineCov">   12676550 :   if (maybe_range_for_decl)</span>
<span class="lineNum">   13049 </span><span class="lineCov">      42624 :     *maybe_range_for_decl = NULL_TREE;</span>
<span class="lineNum">   13050 </span>            : 
<span class="lineNum">   13051 </span>            :   /* Defer access checks until we know what is being declared; the
<span class="lineNum">   13052 </span><span class="lineCov">   12633926 :      checks for names appearing in the decl-specifier-seq should be</span>
<span class="lineNum">   13053 </span>            :      done as if we were in the scope of the thing being declared.  */
<span class="lineNum">   13054 </span>            :   push_deferring_access_checks (dk_deferred);
<span class="lineNum">   13055 </span>            : 
<span class="lineNum">   13056 </span>            :   /* Parse the decl-specifier-seq.  We have to keep track of whether
<span class="lineNum">   13057 </span>            :      or not the decl-specifier-seq declares a named class or
<span class="lineNum">   13058 </span>            :      enumeration type, since that is the only case in which the
<span class="lineNum">   13059 </span>            :      init-declarator-list is allowed to be empty.
<span class="lineNum">   13060 </span>            : 
<span class="lineNum">   13061 </span>            :      [dcl.dcl]
<span class="lineNum">   13062 </span>            : 
<span class="lineNum">   13063 </span>            :      In a simple-declaration, the optional init-declarator-list can be
<span class="lineNum">   13064 </span>            :      omitted only when declaring a class or enumeration, that is when
<span class="lineNum">   13065 </span>            :      the decl-specifier-seq contains either a class-specifier, an
<span class="lineNum">   13066 </span>            :      elaborated-type-specifier, or an enum-specifier.  */
<span class="lineNum">   13067 </span>            :   cp_parser_decl_specifier_seq (parser,
<span class="lineNum">   13068 </span>            :                                 CP_PARSER_FLAGS_OPTIONAL,
<span class="lineNum">   13069 </span>            :                                 &amp;decl_specifiers,
<span class="lineNum">   13070 </span>            :                                 &amp;declares_class_or_enum);
<span class="lineNum">   13071 </span>            :   /* We no longer need to defer access checks.  */
<span class="lineNum">   13072 </span>            :   stop_deferring_access_checks ();
<span class="lineNum">   13073 </span>            : 
<span class="lineNum">   13074 </span>            :   /* In a block scope, a valid declaration must always have a
<span class="lineNum">   13075 </span>            :      decl-specifier-seq.  By not trying to parse declarators, we can
<span class="lineNum">   13076 </span><span class="lineCov">   12761805 :      resolve the declaration/expression ambiguity more quickly.  */</span>
<span class="lineNum">   13077 </span>            :   if (!function_definition_allowed_p
<span class="lineNum">   13078 </span>            :       &amp;&amp; !decl_specifiers.any_specifiers_p)
<span class="lineNum">   13079 </span>            :     {
<span class="lineNum">   13080 </span><span class="lineCov">   12761805 :       cp_parser_error (parser, &quot;expected declaration&quot;);</span>
<span class="lineNum">   13081 </span><span class="lineCov">   12761805 :       goto done;</span>
<span class="lineNum">   13082 </span><span class="lineCov">   12761805 :     }</span>
<span class="lineNum">   13083 </span><span class="lineCov">   12761805 : </span>
<span class="lineNum">   13084 </span><span class="lineCov">   12761805 :   /* If the next two tokens are both identifiers, the code is</span>
<span class="lineNum">   13085 </span>            :      erroneous. The usual cause of this situation is code like:
<span class="lineNum">   13086 </span><span class="lineCov">   12761805 : </span>
<span class="lineNum">   13087 </span><span class="lineCov">     127879 :        T t;</span>
<span class="lineNum">   13088 </span>            : 
<span class="lineNum">   13089 </span>            :      where &quot;T&quot; should name a type -- but does not.  */
<span class="lineNum">   13090 </span>            :   if (!decl_specifiers.any_type_specifiers_p
<span class="lineNum">   13091 </span>            :       &amp;&amp; cp_parser_parse_and_diagnose_invalid_type_name (parser))
<span class="lineNum">   13092 </span><span class="lineCov">   12761805 :     {</span>
<span class="lineNum">   13093 </span>            :       /* If parsing tentatively, we should commit; we really are
<span class="lineNum">   13094 </span>            :          looking at a declaration.  */
<span class="lineNum">   13095 </span>            :       cp_parser_commit_to_tentative_parse (parser);
<span class="lineNum">   13096 </span>            :       /* Give up.  */
<span class="lineNum">   13097 </span>            :       goto done;
<span class="lineNum">   13098 </span>            :     }
<span class="lineNum">   13099 </span>            : 
<span class="lineNum">   13100 </span>            :   cp_parser_maybe_commit_to_declaration (parser,
<span class="lineNum">   13101 </span>            :                                          decl_specifiers.any_specifiers_p);
<span class="lineNum">   13102 </span>            : 
<span class="lineNum">   13103 </span>            :   /* Look for C++17 decomposition declaration.  */
<span class="lineNum">   13104 </span>            :   for (size_t n = 1; ; n++)
<span class="lineNum">   13105 </span><span class="lineCov">   12761805 :     if (cp_lexer_nth_token_is (parser-&gt;lexer, n, CPP_AND)</span>
<span class="lineNum">   13106 </span>            :         || cp_lexer_nth_token_is (parser-&gt;lexer, n, CPP_AND_AND))
<span class="lineNum">   13107 </span>            :       continue;
<span class="lineNum">   13108 </span>            :     else if (cp_lexer_nth_token_is (parser-&gt;lexer, n, CPP_OPEN_SQUARE)
<span class="lineNum">   13109 </span>            :              &amp;&amp; !cp_lexer_nth_token_is (parser-&gt;lexer, n + 1, CPP_OPEN_SQUARE)
<span class="lineNum">   13110 </span><span class="lineCov">   12761796 :              &amp;&amp; decl_specifiers.any_specifiers_p)</span>
<span class="lineNum">   13111 </span>            :       {
<span class="lineNum">   13112 </span>            :         tree decl
<span class="lineNum">   13113 </span>            :           = cp_parser_decomposition_declaration (parser, &amp;decl_specifiers,
<span class="lineNum">   13114 </span>            :                                                  maybe_range_for_decl,
<span class="lineNum">   13115 </span><span class="lineCov">   12761796 :                                                  &amp;init_loc);</span>
<span class="lineNum">   13116 </span><span class="lineCov">    6722935 : </span>
<span class="lineNum">   13117 </span>            :         /* The next token should be either a `,' or a `;'.  */
<span class="lineNum">   13118 </span><span class="lineCov">    4421453 :         cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   13119 </span><span class="lineCov">    4421453 :         /* If it's a `;', we are done.  */</span>
<span class="lineNum">   13120 </span>            :         if (token-&gt;type == CPP_SEMICOLON)
<span class="lineNum">   13121 </span>            :           goto finish;
<span class="lineNum">   13122 </span>            :         else if (maybe_range_for_decl)
<span class="lineNum">   13123 </span>            :           {
<span class="lineNum">   13124 </span>            :             if (*maybe_range_for_decl == NULL_TREE)
<span class="lineNum">   13125 </span>            :               *maybe_range_for_decl = error_mark_node;
<span class="lineNum">   13126 </span>            :             goto finish;
<span class="lineNum">   13127 </span>            :           }
<span class="lineNum">   13128 </span><span class="lineCov">    8340343 :         /* Anything else is an error.  */</span>
<span class="lineNum">   13129 </span><span class="lineCov">    8340343 :         else</span>
<span class="lineNum">   13130 </span>            :           {
<span class="lineNum">   13131 </span>            :             /* If we have already issued an error message we don't need
<span class="lineNum">   13132 </span>            :                to issue another one.  */
<span class="lineNum">   13133 </span><span class="lineCov">        209 :             if ((decl != error_mark_node</span>
<span class="lineNum">   13134 </span>            :                  &amp;&amp; DECL_INITIAL (decl) != error_mark_node)
<span class="lineNum">   13135 </span><span class="lineCov">        209 :                 || cp_parser_uncommitted_to_tentative_parse_p (parser))</span>
<span class="lineNum">   13136 </span>            :               cp_parser_error (parser, &quot;expected %&lt;,%&gt; or %&lt;;%&gt;&quot;);
<span class="lineNum">   13137 </span>            :             /* Skip tokens until we reach the end of the statement.  */
<span class="lineNum">   13138 </span><span class="lineCov">   16680268 :             cp_parser_skip_to_end_of_statement (parser);</span>
<span class="lineNum">   13139 </span><span class="lineCov">    8340134 :             /* If the next token is now a `;', consume it.  */</span>
<span class="lineNum">   13140 </span>            :             if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_SEMICOLON))
<span class="lineNum">   13141 </span>            :               cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   13142 </span><span class="lineCov">    8340134 :             goto done;</span>
<span class="lineNum">   13143 </span><span class="lineCov">    8436402 :           }</span>
<span class="lineNum">   13144 </span><span class="lineCov">    8436402 :       }</span>
<span class="lineNum">   13145 </span><span class="lineCov">      96268 :     else</span>
<span class="lineNum">   13146 </span><span class="lineCov">   16680268 :       break;</span>
<span class="lineNum">   13147 </span><span class="lineCov">        320 : </span>
<span class="lineNum">   13148 </span><span class="lineCov">    8340454 :   tree last_type;</span>
<span class="lineNum">   13149 </span>            :   bool auto_specifier_p;
<span class="lineNum">   13150 </span><span class="lineCov">        320 :   /* NULL_TREE if both variable and function declaration are allowed,</span>
<span class="lineNum">   13151 </span><span class="lineCov">        320 :      error_mark_node if function declaration are not allowed and</span>
<span class="lineNum">   13152 </span>            :      a FUNCTION_DECL that should be diagnosed if it is followed by
<span class="lineNum">   13153 </span><span class="lineCov">        320 :      variable declarations.  */</span>
<span class="lineNum">   13154 </span>            :   tree auto_function_declaration;
<span class="lineNum">   13155 </span>            : 
<span class="lineNum">   13156 </span><span class="lineCov">        640 :   last_type = NULL_TREE;</span>
<span class="lineNum">   13157 </span>            :   auto_specifier_p
<span class="lineNum">   13158 </span><span class="lineCov">        320 :     = decl_specifiers.type &amp;&amp; type_uses_auto (decl_specifiers.type);</span>
<span class="lineNum">   13159 </span>            :   auto_function_declaration = NULL_TREE;
<span class="lineNum">   13160 </span><span class="lineCov">         47 : </span>
<span class="lineNum">   13161 </span>            :   /* Keep going until we hit the `;' at the end of the simple
<span class="lineNum">   13162 </span><span class="lineCov">         45 :      declaration.  */</span>
<span class="lineNum">   13163 </span><span class="lineCov">          2 :   saw_declarator = false;</span>
<span class="lineNum">   13164 </span><span class="lineCov">         45 :   while (cp_lexer_next_token_is_not (parser-&gt;lexer,</span>
<span class="lineNum">   13165 </span>            :                                      CPP_SEMICOLON))
<span class="lineNum">   13166 </span>            :     {
<span class="lineNum">   13167 </span>            :       cp_token *token;
<span class="lineNum">   13168 </span>            :       bool function_definition_p;
<span class="lineNum">   13169 </span>            :       tree decl;
<span class="lineNum">   13170 </span>            :       tree auto_result = NULL_TREE;
<span class="lineNum">   13171 </span><span class="lineCov">          2 : </span>
<span class="lineNum">   13172 </span><span class="lineCov">          2 :       if (saw_declarator)</span>
<span class="lineNum">   13173 </span><span class="lineCov">          2 :         {</span>
<span class="lineNum">   13174 </span><span class="lineCov">          2 :           /* If we are processing next declarator, comma is expected */</span>
<span class="lineNum">   13175 </span>            :           token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   13176 </span><span class="lineCov">          2 :           gcc_assert (token-&gt;type == CPP_COMMA);</span>
<span class="lineNum">   13177 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   13178 </span><span class="lineCov">          2 :           if (maybe_range_for_decl)</span>
<span class="lineNum">   13179 </span><span class="lineCov">          2 :             {</span>
<span class="lineNum">   13180 </span><span class="lineCov">          2 :               *maybe_range_for_decl = error_mark_node;</span>
<span class="lineNum">   13181 </span>            :               if (comma_loc == UNKNOWN_LOCATION)
<span class="lineNum">   13182 </span>            :                 comma_loc = token-&gt;location;
<span class="lineNum">   13183 </span>            :             }
<span class="lineNum">   13184 </span><span class="lineCov">      96268 :         }</span>
<span class="lineNum">   13185 </span>            :       else
<span class="lineNum">   13186 </span><span class="lineCov">    8339814 :         saw_declarator = true;</span>
<span class="lineNum">   13187 </span><span class="lineCov">    8339814 : </span>
<span class="lineNum">   13188 </span>            :       /* Parse the init-declarator.  */
<span class="lineNum">   13189 </span>            :       decl = cp_parser_init_declarator (parser, &amp;decl_specifiers,
<span class="lineNum">   13190 </span>            :                                         /*checks=*/NULL,
<span class="lineNum">   13191 </span>            :                                         function_definition_allowed_p,
<span class="lineNum">   13192 </span><span class="lineCov">    8339814 :                                         /*member_p=*/false,</span>
<span class="lineNum">   13193 </span>            :                                         declares_class_or_enum,
<span class="lineNum">   13194 </span><span class="lineCov">    8339814 :                                         &amp;function_definition_p,</span>
<span class="lineNum">   13195 </span><span class="lineCov">    8339814 :                                         maybe_range_for_decl,</span>
<span class="lineNum">   13196 </span><span class="lineCov">    8339814 :                                         &amp;init_loc,</span>
<span class="lineNum">   13197 </span><span class="lineCov">    8339814 :                                         &amp;auto_result);</span>
<span class="lineNum">   13198 </span>            :       /* If an error occurred while parsing tentatively, exit quickly.
<span class="lineNum">   13199 </span>            :          (That usually happens when in the body of a function; each
<span class="lineNum">   13200 </span>            :          statement is treated as a declaration-statement until proven
<span class="lineNum">   13201 </span><span class="lineCov">    8339814 :          otherwise.)  */</span>
<span class="lineNum">   13202 </span><span class="lineCov">    8413406 :       if (cp_parser_error_occurred (parser))</span>
<span class="lineNum">   13203 </span>            :         goto done;
<span class="lineNum">   13204 </span>            : 
<span class="lineNum">   13205 </span><span class="lineCov">    7890952 :       if (auto_specifier_p &amp;&amp; cxx_dialect &gt;= cxx14)</span>
<span class="lineNum">   13206 </span><span class="lineCov">    7890952 :         {</span>
<span class="lineNum">   13207 </span><span class="lineCov">    7890952 :           /* If the init-declarator-list contains more than one</span>
<span class="lineNum">   13208 </span><span class="lineCov">    7890952 :              init-declarator, they shall all form declarations of</span>
<span class="lineNum">   13209 </span>            :              variables.  */
<span class="lineNum">   13210 </span><span class="lineCov">    7890952 :           if (auto_function_declaration == NULL_TREE)</span>
<span class="lineNum">   13211 </span>            :             auto_function_declaration
<span class="lineNum">   13212 </span>            :               = TREE_CODE (decl) == FUNCTION_DECL ? decl : error_mark_node;
<span class="lineNum">   13213 </span><span class="lineCov">     147184 :           else if (TREE_CODE (decl) == FUNCTION_DECL</span>
<span class="lineNum">   13214 </span><span class="lineCov">      73592 :                    || auto_function_declaration != error_mark_node)</span>
<span class="lineNum">   13215 </span><span class="lineCov">      73592 :             {</span>
<span class="lineNum">   13216 </span><span class="lineCov">      73592 :               error_at (decl_specifiers.locations[ds_type_spec],</span>
<span class="lineNum">   13217 </span>            :                         &quot;non-variable %qD in declaration with more than one &quot;
<span class="lineNum">   13218 </span><span class="lineCov">       1559 :                         &quot;declarator with placeholder type&quot;,</span>
<span class="lineNum">   13219 </span><span class="lineCov">       1559 :                         TREE_CODE (decl) == FUNCTION_DECL</span>
<span class="lineNum">   13220 </span><span class="lineCov">       1559 :                         ? decl : auto_function_declaration);</span>
<span class="lineNum">   13221 </span>            :               auto_function_declaration = error_mark_node;
<span class="lineNum">   13222 </span>            :             }
<span class="lineNum">   13223 </span>            :         }
<span class="lineNum">   13224 </span>            : 
<span class="lineNum">   13225 </span>            :       if (auto_result
<span class="lineNum">   13226 </span>            :           &amp;&amp; (!processing_template_decl || !type_uses_auto (auto_result)))
<span class="lineNum">   13227 </span><span class="lineCov">    7890952 :         {</span>
<span class="lineNum">   13228 </span>            :           if (last_type
<span class="lineNum">   13229 </span>            :               &amp;&amp; last_type != error_mark_node
<span class="lineNum">   13230 </span>            :               &amp;&amp; !same_type_p (auto_result, last_type))
<span class="lineNum">   13231 </span>            :             {
<span class="lineNum">   13232 </span>            :               /* If the list of declarators contains more than one declarator,
<span class="lineNum">   13233 </span>            :                  the type of each declared variable is determined as described
<span class="lineNum">   13234 </span>            :                  above. If the type deduced for the template parameter U is not
<span class="lineNum">   13235 </span>            :                  the same in each deduction, the program is ill-formed.  */
<span class="lineNum">   13236 </span>            :               error_at (decl_specifiers.locations[ds_type_spec],
<span class="lineNum">   13237 </span>            :                         &quot;inconsistent deduction for %qT: %qT and then %qT&quot;,
<span class="lineNum">   13238 </span>            :                         decl_specifiers.type, last_type, auto_result);
<span class="lineNum">   13239 </span>            :               last_type = error_mark_node;
<span class="lineNum">   13240 </span><span class="lineCov">   15764282 :             }</span>
<span class="lineNum">   13241 </span><span class="lineCov">      18176 :           else</span>
<span class="lineNum">   13242 </span>            :             last_type = auto_result;
<span class="lineNum">   13243 </span><span class="lineCov">    7873356 :         }</span>
<span class="lineNum">   13244 </span>            : 
<span class="lineNum">   13245 </span>            :       /* Handle function definitions specially.  */
<span class="lineNum">   13246 </span>            :       if (function_definition_p)
<span class="lineNum">   13247 </span>            :         {
<span class="lineNum">   13248 </span><span class="lineCov">      55834 :           /* If the next token is a `,', then we are probably</span>
<span class="lineNum">   13249 </span><span class="lineCov">      54947 :              processing something like:</span>
<span class="lineNum">   13250 </span><span class="lineCov">      54947 : </span>
<span class="lineNum">   13251 </span><span class="lineCov">        887 :                void f() {}, *p;</span>
<span class="lineNum">   13252 </span><span class="lineCov">        884 : </span>
<span class="lineNum">   13253 </span>            :              which is erroneous.  */
<span class="lineNum">   13254 </span><span class="lineCov">          5 :           if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_COMMA))</span>
<span class="lineNum">   13255 </span>            :             {
<span class="lineNum">   13256 </span>            :               cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   13257 </span>            :               error_at (token-&gt;location,
<span class="lineNum">   13258 </span>            :                         &quot;mixing&quot;
<span class="lineNum">   13259 </span><span class="lineCov">          4 :                         &quot; declarations and function-definitions is forbidden&quot;);</span>
<span class="lineNum">   13260 </span>            :             }
<span class="lineNum">   13261 </span>            :           /* Otherwise, we're done with the list of declarators.  */
<span class="lineNum">   13262 </span>            :           else
<span class="lineNum">   13263 </span><span class="lineCov">    7873356 :             {</span>
<span class="lineNum">   13264 </span><span class="lineCov">    7873356 :               pop_deferring_access_checks ();</span>
<span class="lineNum">   13265 </span>            :               return;
<span class="lineNum">   13266 </span><span class="lineCov">       9516 :             }</span>
<span class="lineNum">   13267 </span><span class="lineCov">         33 :         }</span>
<span class="lineNum">   13268 </span><span class="lineCov">       9549 :       if (maybe_range_for_decl &amp;&amp; *maybe_range_for_decl == NULL_TREE)</span>
<span class="lineNum">   13269 </span>            :         *maybe_range_for_decl = decl;
<span class="lineNum">   13270 </span>            :       /* The next token should be either a `,' or a `;'.  */
<span class="lineNum">   13271 </span>            :       token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   13272 </span>            :       /* If it's a `,', there are more declarators to come.  */
<span class="lineNum">   13273 </span>            :       if (token-&gt;type == CPP_COMMA)
<span class="lineNum">   13274 </span><span class="lineCov">          2 :         /* will be consumed next time around */;</span>
<span class="lineNum">   13275 </span>            :       /* If it's a `;', we are done.  */
<span class="lineNum">   13276 </span>            :       else if (token-&gt;type == CPP_SEMICOLON)
<span class="lineNum">   13277 </span><span class="lineCov">          2 :         break;</span>
<span class="lineNum">   13278 </span>            :       else if (maybe_range_for_decl)
<span class="lineNum">   13279 </span>            :         {
<span class="lineNum">   13280 </span><span class="lineCov">       9514 :           if ((declares_class_or_enum &amp; 2) &amp;&amp; token-&gt;type == CPP_COLON)</span>
<span class="lineNum">   13281 </span>            :             permerror (decl_specifiers.locations[ds_type_spec],
<span class="lineNum">   13282 </span>            :                        &quot;types may not be defined in a for-range-declaration&quot;);
<span class="lineNum">   13283 </span>            :           break;
<span class="lineNum">   13284 </span><span class="lineCov">    7873356 :         }</span>
<span class="lineNum">   13285 </span>            :       /* Anything else is an error.  */
<span class="lineNum">   13286 </span>            :       else
<span class="lineNum">   13287 </span>            :         {
<span class="lineNum">   13288 </span>            :           /* If we have already issued an error message we don't need
<span class="lineNum">   13289 </span>            :              to issue another one.  */
<span class="lineNum">   13290 </span>            :           if ((decl != error_mark_node
<span class="lineNum">   13291 </span>            :                &amp;&amp; DECL_INITIAL (decl) != error_mark_node)
<span class="lineNum">   13292 </span><span class="lineCov">    1329426 :               || cp_parser_uncommitted_to_tentative_parse_p (parser))</span>
<span class="lineNum">   13293 </span>            :             cp_parser_error (parser, &quot;expected %&lt;,%&gt; or %&lt;;%&gt;&quot;);
<span class="lineNum">   13294 </span><span class="lineNoCov">          0 :           /* Skip tokens until we reach the end of the statement.  */</span>
<span class="lineNum">   13295 </span><span class="lineNoCov">          0 :           cp_parser_skip_to_end_of_statement (parser);</span>
<span class="lineNum">   13296 </span>            :           /* If the next token is now a `;', consume it.  */
<span class="lineNum">   13297 </span>            :           if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_SEMICOLON))
<span class="lineNum">   13298 </span>            :             cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   13299 </span>            :           goto done;
<span class="lineNum">   13300 </span>            :         }
<span class="lineNum">   13301 </span>            :       /* After the first time around, a function-definition is not
<span class="lineNum">   13302 </span><span class="lineCov">    1329426 :          allowed -- even if it was OK at first.  For example:</span>
<span class="lineNum">   13303 </span><span class="lineCov">    1329426 : </span>
<span class="lineNum">   13304 </span>            :            int i, f() {}
<span class="lineNum">   13305 </span>            : 
<span class="lineNum">   13306 </span><span class="lineCov">    6543930 :          is not valid.  */</span>
<span class="lineNum">   13307 </span><span class="lineCov">       2439 :       function_definition_allowed_p = false;</span>
<span class="lineNum">   13308 </span>            :     }
<span class="lineNum">   13309 </span><span class="lineCov">   13087860 : </span>
<span class="lineNum">   13310 </span>            :   /* Issue an error message if no declarators are present, and the
<span class="lineNum">   13311 </span><span class="lineCov">    6543930 :      decl-specifier-seq does not itself declare a class or</span>
<span class="lineNum">   13312 </span>            :      enumeration: [dcl.dcl]/3.  */
<span class="lineNum">   13313 </span>            :   if (!saw_declarator)
<span class="lineNum">   13314 </span><span class="lineCov">    6470338 :     {</span>
<span class="lineNum">   13315 </span>            :       if (cp_parser_declares_only_class_p (parser))
<span class="lineNum">   13316 </span><span class="lineCov">       2896 :         {</span>
<span class="lineNum">   13317 </span>            :           if (!declares_class_or_enum
<span class="lineNum">   13318 </span><span class="lineCov">       2290 :               &amp;&amp; decl_specifiers.type</span>
<span class="lineNum">   13319 </span><span class="lineCov">          6 :               &amp;&amp; OVERLOAD_TYPE_P (decl_specifiers.type))</span>
<span class="lineNum">   13320 </span>            :             /* Ensure an error is issued anyway when finish_decltype_type,
<span class="lineNum">   13321 </span>            :                called via cp_parser_decl_specifier_seq, returns a class or
<span class="lineNum">   13322 </span>            :                an enumeration (c++/51786).  */
<span class="lineNum">   13323 </span>            :             decl_specifiers.type = NULL_TREE;
<span class="lineNum">   13324 </span>            :           shadow_tag (&amp;decl_specifiers);
<span class="lineNum">   13325 </span>            :         }
<span class="lineNum">   13326 </span>            :       /* Perform any deferred access checks.  */
<span class="lineNum">   13327 </span>            :       perform_deferred_access_checks (tf_warning_or_error);
<span class="lineNum">   13328 </span><span class="lineCov">        606 :     }</span>
<span class="lineNum">   13329 </span><span class="lineCov">         49 : </span>
<span class="lineNum">   13330 </span><span class="lineCov">        606 :   /* Consume the `;'.  */</span>
<span class="lineNum">   13331 </span><span class="lineCov">         33 :  finish:</span>
<span class="lineNum">   13332 </span>            :   if (!maybe_range_for_decl)
<span class="lineNum">   13333 </span><span class="lineCov">        606 :     cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);</span>
<span class="lineNum">   13334 </span>            :   else if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_COLON))
<span class="lineNum">   13335 </span><span class="lineCov">        606 :     {</span>
<span class="lineNum">   13336 </span><span class="lineCov">        442 :       if (init_loc != UNKNOWN_LOCATION)</span>
<span class="lineNum">   13337 </span><span class="lineCov">        606 :         error_at (init_loc, &quot;initializer in range-based %&lt;for%&gt; loop&quot;);</span>
<span class="lineNum">   13338 </span>            :       if (comma_loc != UNKNOWN_LOCATION)
<span class="lineNum">   13339 </span>            :         error_at (comma_loc,
<span class="lineNum">   13340 </span>            :                   &quot;multiple declarations in range-based %&lt;for%&gt; loop&quot;);
<span class="lineNum">   13341 </span>            :     }
<span class="lineNum">   13342 </span>            : 
<span class="lineNum">   13343 </span>            :  done:
<span class="lineNum">   13344 </span>            :   pop_deferring_access_checks ();
<span class="lineNum">   13345 </span><span class="lineCov">      73592 : }</span>
<span class="lineNum">   13346 </span>            : 
<span class="lineNum">   13347 </span>            : /* Helper of cp_parser_simple_declaration, parse a decomposition declaration.
<span class="lineNum">   13348 </span>            :      decl-specifier-seq ref-qualifier [opt] [ identifier-list ]
<span class="lineNum">   13349 </span>            :        initializer ;  */
<a name="13350"><span class="lineNum">   13350 </span>            : </a>
<span class="lineNum">   13351 </span><span class="lineCov">    6992186 : static tree</span>
<span class="lineNum">   13352 </span>            : cp_parser_decomposition_declaration (cp_parser *parser,
<span class="lineNum">   13353 </span><span class="lineCov">     522454 :                                      cp_decl_specifier_seq *decl_specifiers,</span>
<span class="lineNum">   13354 </span>            :                                      tree *maybe_range_for_decl,
<span class="lineNum">   13355 </span><span class="lineCov">     522454 :                                      location_t *init_loc)</span>
<span class="lineNum">   13356 </span><span class="lineCov">         76 : {</span>
<span class="lineNum">   13357 </span><span class="lineCov">     522525 :   cp_ref_qualifier ref_qual = cp_parser_ref_qualifier_opt (parser);</span>
<span class="lineNum">   13358 </span>            :   location_t loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">   13359 </span>            :   cp_parser_require (parser, CPP_OPEN_SQUARE, RT_OPEN_SQUARE);
<span class="lineNum">   13360 </span>            : 
<span class="lineNum">   13361 </span><span class="lineCov">          4 :   /* Parse the identifier-list.  */</span>
<span class="lineNum">   13362 </span><span class="lineCov">     522454 :   auto_vec&lt;cp_expr, 10&gt; v;</span>
<span class="lineNum">   13363 </span>            :   if (!cp_lexer_next_token_is (parser-&gt;lexer, CPP_CLOSE_SQUARE))
<span class="lineNum">   13364 </span>            :     while (true)
<span class="lineNum">   13365 </span><span class="lineCov">     522454 :       {</span>
<span class="lineNum">   13366 </span>            :         cp_expr e = cp_parser_identifier (parser);
<span class="lineNum">   13367 </span>            :         if (e.get_value () == error_mark_node)
<span class="lineNum">   13368 </span>            :           break;
<span class="lineNum">   13369 </span><span class="lineCov">    6469732 :         v.safe_push (e);</span>
<span class="lineNum">   13370 </span><span class="lineCov">    6992504 :         if (!cp_lexer_next_token_is (parser-&gt;lexer, CPP_COMMA))</span>
<span class="lineNum">   13371 </span><span class="lineCov">    6890978 :           break;</span>
<span class="lineNum">   13372 </span><span class="lineCov">     101526 :         cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   13373 </span>            :       }
<span class="lineNum">   13374 </span><span class="lineCov">       2333 : </span>
<span class="lineNum">   13375 </span><span class="lineCov">          6 :   location_t end_loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;</span>
<span class="lineNum">   13376 </span><span class="lineCov">       2333 :   if (!cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE))</span>
<span class="lineNum">   13377 </span><span class="lineCov">          4 :     {</span>
<span class="lineNum">   13378 </span>            :       end_loc = UNKNOWN_LOCATION;
<span class="lineNum">   13379 </span>            :       cp_parser_skip_to_closing_parenthesis_1 (parser, true, CPP_CLOSE_SQUARE,
<span class="lineNum">   13380 </span>            :                                                false);
<span class="lineNum">   13381 </span><span class="lineCov">      99193 :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_CLOSE_SQUARE))</span>
<span class="lineNum">   13382 </span><span class="lineCov">   11432344 :         cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   13383 </span>            :       else
<span class="lineNum">   13384 </span>            :         {
<span class="lineNum">   13385 </span>            :           cp_parser_skip_to_end_of_statement (parser);
<span class="lineNum">   13386 </span>            :           return error_mark_node;
<span class="lineNum">   13387 </span>            :         }
<span class="lineNum">   13388 </span>            :     }
<span class="lineNum">   13389 </span>            : 
<span class="lineNum">   13390 </span><span class="lineCov">        320 :   if (cxx_dialect &lt; cxx17)</span>
<span class="lineNum">   13391 </span>            :     pedwarn (loc, 0, &quot;structured bindings only available with &quot;
<span class="lineNum">   13392 </span>            :                      &quot;-std=c++17 or -std=gnu++17&quot;);
<span class="lineNum">   13393 </span>            : 
<span class="lineNum">   13394 </span>            :   tree pushed_scope;
<span class="lineNum">   13395 </span><span class="lineCov">        320 :   cp_declarator *declarator = make_declarator (cdk_decomp);</span>
<span class="lineNum">   13396 </span><span class="lineCov">        640 :   loc = end_loc == UNKNOWN_LOCATION ? loc : make_location (loc, loc, end_loc);</span>
<span class="lineNum">   13397 </span><span class="lineCov">        320 :   declarator-&gt;id_loc = loc;</span>
<span class="lineNum">   13398 </span>            :   if (ref_qual != REF_QUAL_NONE)
<span class="lineNum">   13399 </span>            :     declarator = make_reference_declarator (TYPE_UNQUALIFIED, declarator,
<span class="lineNum">   13400 </span><span class="lineCov">        640 :                                             ref_qual == REF_QUAL_RVALUE,</span>
<span class="lineNum">   13401 </span><span class="lineCov">        320 :                                             NULL_TREE);</span>
<span class="lineNum">   13402 </span><span class="lineCov">        860 :   tree decl = start_decl (declarator, decl_specifiers, SD_INITIALIZED,</span>
<span class="lineNum">   13403 </span>            :                           NULL_TREE, decl_specifiers-&gt;attributes,
<span class="lineNum">   13404 </span><span class="lineCov">        860 :                           &amp;pushed_scope);</span>
<span class="lineNum">   13405 </span><span class="lineCov">       1720 :   tree orig_decl = decl;</span>
<span class="lineNum">   13406 </span>            : 
<span class="lineNum">   13407 </span><span class="lineCov">        857 :   unsigned int i;</span>
<span class="lineNum">   13408 </span><span class="lineCov">        857 :   cp_expr e;</span>
<span class="lineNum">   13409 </span>            :   cp_decl_specifier_seq decl_specs;
<span class="lineNum">   13410 </span><span class="lineCov">        541 :   clear_decl_specs (&amp;decl_specs);</span>
<span class="lineNum">   13411 </span><span class="lineCov">        541 :   decl_specs.type = make_auto ();</span>
<span class="lineNum">   13412 </span>            :   tree prev = decl;
<span class="lineNum">   13413 </span><span class="lineCov">        640 :   FOR_EACH_VEC_ELT (v, i, e)</span>
<span class="lineNum">   13414 </span><span class="lineCov">        320 :     {</span>
<span class="lineNum">   13415 </span>            :       if (i == 0)
<span class="lineNum">   13416 </span><span class="lineCov">          5 :         declarator = make_id_declarator (NULL_TREE, e.get_value (), sfk_none);</span>
<span class="lineNum">   13417 </span><span class="lineCov">          5 :       else</span>
<span class="lineNum">   13418 </span>            :         declarator-&gt;u.id.unqualified_name = e.get_value ();
<span class="lineNum">   13419 </span><span class="lineCov">          5 :       declarator-&gt;id_loc = e.get_location ();</span>
<span class="lineNum">   13420 </span><span class="lineNoCov">          0 :       tree elt_pushed_scope;</span>
<span class="lineNum">   13421 </span>            :       tree decl2 = start_decl (declarator, &amp;decl_specs, SD_INITIALIZED,
<span class="lineNum">   13422 </span>            :                                NULL_TREE, NULL_TREE, &amp;elt_pushed_scope);
<span class="lineNum">   13423 </span><span class="lineCov">          5 :       if (decl2 == error_mark_node)</span>
<span class="lineNum">   13424 </span><span class="lineCov">          5 :         decl = error_mark_node;</span>
<span class="lineNum">   13425 </span>            :       else if (decl != error_mark_node &amp;&amp; DECL_CHAIN (decl2) != prev)
<span class="lineNum">   13426 </span>            :         {
<span class="lineNum">   13427 </span>            :           /* Ensure we've diagnosed redeclaration if we aren't creating
<span class="lineNum">   13428 </span><span class="lineCov">        315 :              a new VAR_DECL.  */</span>
<span class="lineNum">   13429 </span><span class="lineCov">        196 :           gcc_assert (errorcount);</span>
<span class="lineNum">   13430 </span>            :           decl = error_mark_node;
<span class="lineNum">   13431 </span>            :         }
<span class="lineNum">   13432 </span><span class="lineCov">        315 :       else</span>
<span class="lineNum">   13433 </span><span class="lineCov">        315 :         prev = decl2;</span>
<span class="lineNum">   13434 </span><span class="lineCov">        315 :       if (elt_pushed_scope)</span>
<span class="lineNum">   13435 </span><span class="lineCov">        315 :         pop_scope (elt_pushed_scope);</span>
<span class="lineNum">   13436 </span><span class="lineCov">        315 :     }</span>
<span class="lineNum">   13437 </span><span class="lineCov">         93 : </span>
<span class="lineNum">   13438 </span>            :   if (v.is_empty ())
<span class="lineNum">   13439 </span>            :     {
<span class="lineNum">   13440 </span><span class="lineCov">        315 :       error_at (loc, &quot;empty structured binding declaration&quot;);</span>
<span class="lineNum">   13441 </span>            :       decl = error_mark_node;
<span class="lineNum">   13442 </span>            :     }
<span class="lineNum">   13443 </span><span class="lineCov">        315 : </span>
<span class="lineNum">   13444 </span>            :   if (maybe_range_for_decl == NULL
<span class="lineNum">   13445 </span><span class="lineCov">        315 :       || cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_COLON))</span>
<span class="lineNum">   13446 </span><span class="lineCov">        315 :     {</span>
<span class="lineNum">   13447 </span><span class="lineCov">        315 :       bool non_constant_p = false, is_direct_init = false;</span>
<span class="lineNum">   13448 </span><span class="lineCov">        630 :       *init_loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;</span>
<span class="lineNum">   13449 </span><span class="lineCov">        315 :       tree initializer = cp_parser_initializer (parser, &amp;is_direct_init,</span>
<span class="lineNum">   13450 </span><span class="lineCov">        315 :                                                 &amp;non_constant_p);</span>
<span class="lineNum">   13451 </span><span class="lineCov">       1170 :       if (initializer == NULL_TREE</span>
<span class="lineNum">   13452 </span>            :           || (TREE_CODE (initializer) == TREE_LIST
<span class="lineNum">   13453 </span><span class="lineCov">        855 :               &amp;&amp; TREE_CHAIN (initializer))</span>
<span class="lineNum">   13454 </span><span class="lineCov">        628 :           || (is_direct_init</span>
<span class="lineNum">   13455 </span>            :               &amp;&amp; BRACE_ENCLOSED_INITIALIZER_P (initializer)
<span class="lineNum">   13456 </span><span class="lineCov">       1082 :               &amp;&amp; CONSTRUCTOR_NELTS (initializer) != 1))</span>
<span class="lineNum">   13457 </span><span class="lineCov">        855 :         {</span>
<span class="lineNum">   13458 </span><span class="lineCov">        855 :           error_at (loc, &quot;invalid initializer for structured binding &quot;</span>
<span class="lineNum">   13459 </span><span class="lineCov">        855 :                     &quot;declaration&quot;);</span>
<span class="lineNum">   13460 </span><span class="lineCov">        855 :           initializer = error_mark_node;</span>
<span class="lineNum">   13461 </span><span class="lineCov">        855 :         }</span>
<span class="lineNum">   13462 </span>            : 
<span class="lineNum">   13463 </span><span class="lineCov">        855 :       if (decl != error_mark_node)</span>
<span class="lineNum">   13464 </span>            :         {
<span class="lineNum">   13465 </span>            :           cp_maybe_mangle_decomp (decl, prev, v.length ());
<span class="lineNum">   13466 </span>            :           cp_finish_decl (decl, initializer, non_constant_p, NULL_TREE,
<span class="lineNum">   13467 </span><span class="lineNoCov">          0 :                           is_direct_init ? LOOKUP_NORMAL : LOOKUP_IMPLICIT);</span>
<span class="lineNum">   13468 </span>            :           cp_finish_decomp (decl, prev, v.length ());
<span class="lineNum">   13469 </span>            :         }
<span class="lineNum">   13470 </span>            :     }
<span class="lineNum">   13471 </span>            :   else if (decl != error_mark_node)
<span class="lineNum">   13472 </span><span class="lineCov">        855 :     {</span>
<span class="lineNum">   13473 </span><span class="lineCov">         50 :       *maybe_range_for_decl = prev;</span>
<span class="lineNum">   13474 </span>            :       /* Ensure DECL_VALUE_EXPR is created for all the decls but
<span class="lineNum">   13475 </span>            :          the underlying DECL.  */
<span class="lineNum">   13476 </span><span class="lineCov">        315 :       cp_finish_decomp (decl, prev, v.length ());</span>
<span class="lineNum">   13477 </span>            :     }
<span class="lineNum">   13478 </span><span class="lineCov">          1 : </span>
<span class="lineNum">   13479 </span><span class="lineCov">          1 :   if (pushed_scope)</span>
<span class="lineNum">   13480 </span>            :     pop_scope (pushed_scope);
<span class="lineNum">   13481 </span>            : 
<span class="lineNum">   13482 </span><span class="lineCov">        315 :   if (decl == error_mark_node &amp;&amp; DECL_P (orig_decl))</span>
<span class="lineNum">   13483 </span><span class="lineCov">        315 :     {</span>
<span class="lineNum">   13484 </span>            :       if (DECL_NAMESPACE_SCOPE_P (orig_decl))
<span class="lineNum">   13485 </span><span class="lineCov">        272 :         SET_DECL_ASSEMBLER_NAME (orig_decl, get_identifier (&quot;&lt;decomp&gt;&quot;));</span>
<span class="lineNum">   13486 </span><span class="lineCov">        544 :     }</span>
<span class="lineNum">   13487 </span><span class="lineCov">        272 : </span>
<span class="lineNum">   13488 </span><span class="lineCov">        272 :   return decl;</span>
<span class="lineNum">   13489 </span><span class="lineCov">        272 : }</span>
<span class="lineNum">   13490 </span><span class="lineCov">        271 : </span>
<span class="lineNum">   13491 </span><span class="lineCov">         10 : /* Parse a decl-specifier-seq.</span>
<span class="lineNum">   13492 </span><span class="lineCov">        541 : </span>
<span class="lineNum">   13493 </span><span class="lineCov">         29 :    decl-specifier-seq:</span>
<span class="lineNum">   13494 </span><span class="lineCov">         42 :      decl-specifier-seq [opt] decl-specifier</span>
<span class="lineNum">   13495 </span>            :      decl-specifier attribute-specifier-seq [opt] (C++11)
<span class="lineNum">   13496 </span><span class="lineCov">          5 : </span>
<span class="lineNum">   13497 </span>            :    decl-specifier:
<span class="lineNum">   13498 </span><span class="lineCov">          5 :      storage-class-specifier</span>
<span class="lineNum">   13499 </span>            :      type-specifier
<span class="lineNum">   13500 </span>            :      function-specifier
<span class="lineNum">   13501 </span><span class="lineCov">        272 :      friend</span>
<span class="lineNum">   13502 </span>            :      typedef
<span class="lineNum">   13503 </span><span class="lineCov">        542 : </span>
<span class="lineNum">   13504 </span><span class="lineCov">        511 :    GNU Extension:</span>
<span class="lineNum">   13505 </span>            : 
<span class="lineNum">   13506 </span><span class="lineCov">        542 :    decl-specifier:</span>
<span class="lineNum">   13507 </span>            :      attributes
<span class="lineNum">   13508 </span>            : 
<span class="lineNum">   13509 </span><span class="lineCov">         43 :    Concepts Extension:</span>
<span class="lineNum">   13510 </span>            : 
<span class="lineNum">   13511 </span><span class="lineCov">         43 :    decl-specifier:</span>
<span class="lineNum">   13512 </span>            :      concept
<span class="lineNum">   13513 </span>            : 
<span class="lineNum">   13514 </span><span class="lineCov">         86 :    Set *DECL_SPECS to a representation of the decl-specifier-seq.</span>
<span class="lineNum">   13515 </span>            : 
<span class="lineNum">   13516 </span>            :    The parser flags FLAGS is used to control type-specifier parsing.
<span class="lineNum">   13517 </span><span class="lineCov">        315 : </span>
<span class="lineNum">   13518 </span><span class="lineCov">         16 :    *DECLARES_CLASS_OR_ENUM is set to the bitwise or of the following</span>
<span class="lineNum">   13519 </span>            :    flags:
<span class="lineNum">   13520 </span><span class="lineCov">        315 : </span>
<span class="lineNum">   13521 </span>            :      1: one of the decl-specifiers is an elaborated-type-specifier
<span class="lineNum">   13522 </span><span class="lineCov">          1 :         (i.e., a type declaration)</span>
<span class="lineNum">   13523 </span><span class="lineNoCov">          0 :      2: one of the decl-specifiers is an enum-specifier or a</span>
<span class="lineNum">   13524 </span>            :         class-specifier (i.e., a type definition)
<span class="lineNum">   13525 </span>            : 
<span class="lineNum">   13526 </span>            :    */
<a name="13527"><span class="lineNum">   13527 </span>            : </a>
<span class="lineNum">   13528 </span>            : static void
<span class="lineNum">   13529 </span>            : cp_parser_decl_specifier_seq (cp_parser* parser,
<span class="lineNum">   13530 </span>            :                               cp_parser_flags flags,
<span class="lineNum">   13531 </span>            :                               cp_decl_specifier_seq *decl_specs,
<span class="lineNum">   13532 </span>            :                               int* declares_class_or_enum)
<span class="lineNum">   13533 </span>            : {
<span class="lineNum">   13534 </span>            :   bool constructor_possible_p = !parser-&gt;in_declarator_p;
<span class="lineNum">   13535 </span>            :   bool found_decl_spec = false;
<span class="lineNum">   13536 </span>            :   cp_token *start_token = NULL;
<span class="lineNum">   13537 </span>            :   cp_decl_spec ds;
<span class="lineNum">   13538 </span>            : 
<span class="lineNum">   13539 </span>            :   /* Clear DECL_SPECS.  */
<span class="lineNum">   13540 </span>            :   clear_decl_specs (decl_specs);
<span class="lineNum">   13541 </span>            : 
<span class="lineNum">   13542 </span>            :   /* Assume no class or enumeration type is declared.  */
<span class="lineNum">   13543 </span>            :   *declares_class_or_enum = 0;
<span class="lineNum">   13544 </span>            : 
<span class="lineNum">   13545 </span>            :   /* Keep reading specifiers until there are no more to read.  */
<span class="lineNum">   13546 </span>            :   while (true)
<span class="lineNum">   13547 </span>            :     {
<span class="lineNum">   13548 </span>            :       bool constructor_p;
<span class="lineNum">   13549 </span>            :       cp_token *token;
<span class="lineNum">   13550 </span>            :       ds = ds_last;
<span class="lineNum">   13551 </span>            : 
<span class="lineNum">   13552 </span>            :       /* Peek at the next token.  */
<span class="lineNum">   13553 </span>            :       token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   13554 </span>            : 
<span class="lineNum">   13555 </span>            :       /* Save the first token of the decl spec list for error
<span class="lineNum">   13556 </span>            :          reporting.  */
<span class="lineNum">   13557 </span>            :       if (!start_token)
<span class="lineNum">   13558 </span>            :         start_token = token;
<span class="lineNum">   13559 </span>            :       /* Handle attributes.  */
<span class="lineNum">   13560 </span>            :       if (cp_next_tokens_can_be_attribute_p (parser))
<span class="lineNum">   13561 </span>            :         {
<span class="lineNum">   13562 </span>            :           /* Parse the attributes.  */
<span class="lineNum">   13563 </span>            :           tree attrs = cp_parser_attributes_opt (parser);
<span class="lineNum">   13564 </span>            : 
<span class="lineNum">   13565 </span>            :           /* In a sequence of declaration specifiers, c++11 attributes
<span class="lineNum">   13566 </span>            :              appertain to the type that precede them. In that case
<span class="lineNum">   13567 </span><span class="lineCov">   43959101 :              [dcl.spec]/1 says:</span>
<span class="lineNum">   13568 </span>            : 
<span class="lineNum">   13569 </span>            :                  The attribute-specifier-seq affects the type only for
<span class="lineNum">   13570 </span>            :                  the declaration it appears in, not other declarations
<span class="lineNum">   13571 </span>            :                  involving the same type.
<span class="lineNum">   13572 </span><span class="lineCov">   43959101 : </span>
<span class="lineNum">   13573 </span><span class="lineCov">   43959101 :              But for now let's force the user to position the</span>
<span class="lineNum">   13574 </span><span class="lineCov">   43959101 :              attribute either at the beginning of the declaration or</span>
<span class="lineNum">   13575 </span><span class="lineCov">   43959101 :              after the declarator-id, which would clearly mean that it</span>
<span class="lineNum">   13576 </span>            :              applies to the declarator.  */
<span class="lineNum">   13577 </span>            :           if (cxx11_attribute_p (attrs))
<span class="lineNum">   13578 </span><span class="lineCov">   87918202 :             {</span>
<span class="lineNum">   13579 </span>            :               if (!found_decl_spec)
<span class="lineNum">   13580 </span>            :                 /* The c++11 attribute is at the beginning of the
<span class="lineNum">   13581 </span><span class="lineCov">   43959101 :                    declaration.  It appertains to the entity being</span>
<span class="lineNum">   13582 </span>            :                    declared.  */;
<span class="lineNum">   13583 </span>            :               else
<span class="lineNum">   13584 </span><span class="lineCov">  102696568 :                 {</span>
<span class="lineNum">   13585 </span>            :                   if (decl_specs-&gt;type &amp;&amp; CLASS_TYPE_P (decl_specs-&gt;type))
<span class="lineNum">   13586 </span><span class="lineCov">  102696568 :                     {</span>
<span class="lineNum">   13587 </span><span class="lineCov">  102696568 :                       /*  This is an attribute following a</span>
<span class="lineNum">   13588 </span><span class="lineCov">  102696568 :                           class-specifier.  */</span>
<span class="lineNum">   13589 </span>            :                       if (decl_specs-&gt;type_definition_p)
<span class="lineNum">   13590 </span>            :                         warn_misplaced_attr_for_class_type (token-&gt;location,
<span class="lineNum">   13591 </span><span class="lineCov">  205393136 :                                                             decl_specs-&gt;type);</span>
<span class="lineNum">   13592 </span>            :                       attrs = NULL_TREE;
<span class="lineNum">   13593 </span>            :                     }
<span class="lineNum">   13594 </span>            :                   else
<span class="lineNum">   13595 </span><span class="lineCov">  102696568 :                     {</span>
<span class="lineNum">   13596 </span>            :                       decl_specs-&gt;std_attributes
<span class="lineNum">   13597 </span>            :                         = attr_chainon (decl_specs-&gt;std_attributes, attrs);
<span class="lineNum">   13598 </span><span class="lineCov">  102696568 :                       if (decl_specs-&gt;locations[ds_std_attribute] == 0)</span>
<span class="lineNum">   13599 </span>            :                         decl_specs-&gt;locations[ds_std_attribute] = token-&gt;location;
<span class="lineNum">   13600 </span>            :                     }
<span class="lineNum">   13601 </span><span class="lineCov">     996813 :                   continue;</span>
<span class="lineNum">   13602 </span>            :                 }
<span class="lineNum">   13603 </span>            :             }
<span class="lineNum">   13604 </span>            : 
<span class="lineNum">   13605 </span>            :           decl_specs-&gt;attributes
<span class="lineNum">   13606 </span>            :             = attr_chainon (decl_specs-&gt;attributes, attrs);
<span class="lineNum">   13607 </span>            :           if (decl_specs-&gt;locations[ds_attribute] == 0)
<span class="lineNum">   13608 </span>            :             decl_specs-&gt;locations[ds_attribute] = token-&gt;location;
<span class="lineNum">   13609 </span>            :           continue;
<span class="lineNum">   13610 </span>            :         }
<span class="lineNum">   13611 </span>            :       /* Assume we will find a decl-specifier keyword.  */
<span class="lineNum">   13612 </span>            :       found_decl_spec = true;
<span class="lineNum">   13613 </span>            :       /* If the next token is an appropriate keyword, we can simply
<span class="lineNum">   13614 </span>            :          add it to the list.  */
<span class="lineNum">   13615 </span><span class="lineCov">     996813 :       switch (token-&gt;keyword)</span>
<span class="lineNum">   13616 </span>            :         {
<span class="lineNum">   13617 </span><span class="lineCov">      14293 :           /* decl-specifier:</span>
<span class="lineNum">   13618 </span>            :                friend
<span class="lineNum">   13619 </span>            :                constexpr */
<span class="lineNum">   13620 </span>            :         case RID_FRIEND:
<span class="lineNum">   13621 </span>            :           if (!at_class_scope_p ())
<span class="lineNum">   13622 </span>            :             {
<span class="lineNum">   13623 </span><span class="lineCov">         16 :               gcc_rich_location richloc (token-&gt;location);</span>
<span class="lineNum">   13624 </span>            :               richloc.add_fixit_remove ();
<span class="lineNum">   13625 </span>            :               error_at (&amp;richloc, &quot;%&lt;friend%&gt; used outside of class&quot;);
<span class="lineNum">   13626 </span>            :               cp_lexer_purge_token (parser-&gt;lexer);
<span class="lineNum">   13627 </span><span class="lineCov">          4 :             }</span>
<span class="lineNum">   13628 </span><span class="lineCov">          4 :           else</span>
<span class="lineNum">   13629 </span>            :             {
<span class="lineNum">   13630 </span>            :               ds = ds_friend;
<span class="lineNum">   13631 </span>            :               /* Consume the token.  */
<span class="lineNum">   13632 </span>            :               cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   13633 </span>            :             }
<span class="lineNum">   13634 </span><span class="lineCov">         12 :           break;</span>
<span class="lineNum">   13635 </span><span class="lineCov">         12 : </span>
<span class="lineNum">   13636 </span><span class="lineCov">         12 :         case RID_CONSTEXPR:</span>
<span class="lineNum">   13637 </span><span class="lineCov">         12 :           ds = ds_constexpr;</span>
<span class="lineNum">   13638 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   13639 </span><span class="lineCov">         16 :           break;</span>
<span class="lineNum">   13640 </span>            : 
<span class="lineNum">   13641 </span>            :         case RID_CONCEPT:
<span class="lineNum">   13642 </span>            :           ds = ds_concept;
<span class="lineNum">   13643 </span><span class="lineCov">     996797 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   13644 </span><span class="lineCov">     996797 :           break;</span>
<span class="lineNum">   13645 </span><span class="lineCov">     996797 : </span>
<span class="lineNum">   13646 </span><span class="lineCov">     928296 :           /* function-specifier:</span>
<span class="lineNum">   13647 </span><span class="lineCov">     996797 :                inline</span>
<span class="lineNum">   13648 </span>            :                virtual
<span class="lineNum">   13649 </span>            :                explicit  */
<span class="lineNum">   13650 </span><span class="lineCov">  101699755 :         case RID_INLINE:</span>
<span class="lineNum">   13651 </span>            :         case RID_VIRTUAL:
<span class="lineNum">   13652 </span>            :         case RID_EXPLICIT:
<span class="lineNum">   13653 </span><span class="lineCov">  101699755 :           cp_parser_function_specifier_opt (parser, decl_specs);</span>
<span class="lineNum">   13654 </span>            :           break;
<span class="lineNum">   13655 </span>            : 
<span class="lineNum">   13656 </span>            :           /* decl-specifier:
<span class="lineNum">   13657 </span>            :                typedef  */
<span class="lineNum">   13658 </span><span class="lineCov">     111274 :         case RID_TYPEDEF:</span>
<span class="lineNum">   13659 </span><span class="lineCov">     111274 :           ds = ds_typedef;</span>
<span class="lineNum">   13660 </span>            :           /* Consume the token.  */
<span class="lineNum">   13661 </span><span class="lineCov">         24 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   13662 </span><span class="lineCov">         12 :           /* A constructor declarator cannot appear in a typedef.  */</span>
<span class="lineNum">   13663 </span><span class="lineCov">         12 :           constructor_possible_p = false;</span>
<span class="lineNum">   13664 </span><span class="lineCov">         12 :           /* The &quot;typedef&quot; keyword can only occur in a declaration; we</span>
<span class="lineNum">   13665 </span>            :              may as well commit at this point.  */
<span class="lineNum">   13666 </span>            :           cp_parser_commit_to_tentative_parse (parser);
<span class="lineNum">   13667 </span>            : 
<span class="lineNum">   13668 </span><span class="lineCov">     111262 :           if (decl_specs-&gt;storage_class != sc_none)</span>
<span class="lineNum">   13669 </span>            :             decl_specs-&gt;conflicting_specifiers_p = true;
<span class="lineNum">   13670 </span><span class="lineCov">     111262 :           break;</span>
<span class="lineNum">   13671 </span>            : 
<span class="lineNum">   13672 </span>            :           /* storage-class-specifier:
<span class="lineNum">   13673 </span>            :                auto
<span class="lineNum">   13674 </span><span class="lineCov">    1576065 :                register</span>
<span class="lineNum">   13675 </span><span class="lineCov">    1576065 :                static</span>
<span class="lineNum">   13676 </span><span class="lineCov">    1576065 :                extern</span>
<span class="lineNum">   13677 </span><span class="lineCov">    1576065 :                mutable</span>
<span class="lineNum">   13678 </span>            : 
<span class="lineNum">   13679 </span><span class="lineCov">        328 :              GNU Extension:</span>
<span class="lineNum">   13680 </span><span class="lineCov">        328 :                thread  */</span>
<span class="lineNum">   13681 </span><span class="lineCov">        328 :         case RID_AUTO:</span>
<span class="lineNum">   13682 </span><span class="lineCov">        328 :           if (cxx_dialect == cxx98) </span>
<span class="lineNum">   13683 </span>            :             {
<span class="lineNum">   13684 </span>            :               /* Consume the token.  */
<span class="lineNum">   13685 </span>            :               cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   13686 </span>            : 
<span class="lineNum">   13687 </span>            :               /* Complain about `auto' as a storage specifier, if
<span class="lineNum">   13688 </span><span class="lineCov">    2562895 :                  we're complaining about C++0x compatibility.  */</span>
<span class="lineNum">   13689 </span><span class="lineCov">    2562895 :               gcc_rich_location richloc (token-&gt;location);</span>
<span class="lineNum">   13690 </span><span class="lineCov">    2562895 :               richloc.add_fixit_remove ();</span>
<span class="lineNum">   13691 </span><span class="lineCov">    2562895 :               warning_at (&amp;richloc, OPT_Wc__11_compat,</span>
<span class="lineNum">   13692 </span><span class="lineCov">    2562895 :                           &quot;%&lt;auto%&gt; changes meaning in C++11; &quot;</span>
<span class="lineNum">   13693 </span>            :                           &quot;please remove it&quot;);
<span class="lineNum">   13694 </span>            : 
<span class="lineNum">   13695 </span>            :               /* Set the storage class anyway.  */
<span class="lineNum">   13696 </span><span class="lineCov">    2375705 :               cp_parser_set_storage_class (parser, decl_specs, RID_AUTO,</span>
<span class="lineNum">   13697 </span><span class="lineCov">    2375705 :                                            token);</span>
<span class="lineNum">   13698 </span>            :             }
<span class="lineNum">   13699 </span><span class="lineCov">    2375705 :           else</span>
<span class="lineNum">   13700 </span>            :             /* C++0x auto type-specifier.  */
<span class="lineNum">   13701 </span><span class="lineCov">    2375705 :             found_decl_spec = false;</span>
<span class="lineNum">   13702 </span>            :           break;
<span class="lineNum">   13703 </span>            : 
<span class="lineNum">   13704 </span><span class="lineCov">    2375705 :         case RID_REGISTER:</span>
<span class="lineNum">   13705 </span>            :         case RID_STATIC:
<span class="lineNum">   13706 </span><span class="lineCov">    2375705 :         case RID_EXTERN:</span>
<span class="lineNum">   13707 </span><span class="lineCov">          6 :         case RID_MUTABLE:</span>
<span class="lineNum">   13708 </span>            :           /* Consume the token.  */
<span class="lineNum">   13709 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   13710 </span>            :           cp_parser_set_storage_class (parser, decl_specs, token-&gt;keyword,
<span class="lineNum">   13711 </span>            :                                        token);
<span class="lineNum">   13712 </span>            :           break;
<span class="lineNum">   13713 </span>            :         case RID_THREAD:
<span class="lineNum">   13714 </span>            :           /* Consume the token.  */
<span class="lineNum">   13715 </span>            :           ds = ds_thread;
<span class="lineNum">   13716 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   13717 </span>            :           break;
<span class="lineNum">   13718 </span>            : 
<span class="lineNum">   13719 </span><span class="lineCov">     148726 :         default:</span>
<span class="lineNum">   13720 </span><span class="lineCov">     148726 :           /* We did not yet find a decl-specifier yet.  */</span>
<span class="lineNum">   13721 </span>            :           found_decl_spec = false;
<span class="lineNum">   13722 </span>            :           break;
<span class="lineNum">   13723 </span><span class="lineCov">         16 :         }</span>
<span class="lineNum">   13724 </span>            : 
<span class="lineNum">   13725 </span>            :       if (found_decl_spec
<span class="lineNum">   13726 </span>            :           &amp;&amp; (flags &amp; CP_PARSER_FLAGS_ONLY_TYPE_OR_CONSTEXPR)
<span class="lineNum">   13727 </span><span class="lineCov">         32 :           &amp;&amp; token-&gt;keyword != RID_CONSTEXPR)</span>
<span class="lineNum">   13728 </span><span class="lineCov">         16 :         error (&quot;decl-specifier invalid in condition&quot;);</span>
<span class="lineNum">   13729 </span><span class="lineCov">         16 : </span>
<span class="lineNum">   13730 </span>            :       if (found_decl_spec
<span class="lineNum">   13731 </span>            :           &amp;&amp; (flags &amp; CP_PARSER_FLAGS_ONLY_MUTABLE_OR_CONSTEXPR)
<span class="lineNum">   13732 </span>            :           &amp;&amp; token-&gt;keyword != RID_MUTABLE
<span class="lineNum">   13733 </span>            :           &amp;&amp; token-&gt;keyword != RID_CONSTEXPR)
<span class="lineNum">   13734 </span><span class="lineCov">         16 :         error_at (token-&gt;location, &quot;%qD invalid in lambda&quot;,</span>
<span class="lineNum">   13735 </span>            :                   ridpointers[token-&gt;keyword]);
<span class="lineNum">   13736 </span>            : 
<span class="lineNum">   13737 </span>            :       if (ds != ds_last)
<span class="lineNum">   13738 </span>            :         set_and_check_decl_spec_loc (decl_specs, ds, token);
<span class="lineNum">   13739 </span>            : 
<span class="lineNum">   13740 </span>            :       /* Constructors are a special case.  The `S' in `S()' is not a
<span class="lineNum">   13741 </span>            :          decl-specifier; it is the beginning of the declarator.  */
<span class="lineNum">   13742 </span><span class="lineCov">    5399030 :       constructor_p</span>
<span class="lineNum">   13743 </span><span class="lineCov">    5399030 :         = (!found_decl_spec</span>
<span class="lineNum">   13744 </span><span class="lineCov">    5399030 :            &amp;&amp; constructor_possible_p</span>
<span class="lineNum">   13745 </span><span class="lineCov">    5399030 :            &amp;&amp; (cp_parser_constructor_declarator_p</span>
<span class="lineNum">   13746 </span>            :                (parser, decl_spec_seq_has_spec_p (decl_specs, ds_friend))));
<span class="lineNum">   13747 </span><span class="lineCov">    5399030 : </span>
<span class="lineNum">   13748 </span><span class="lineCov">    5399030 :       /* If we don't have a DECL_SPEC yet, then we must be looking at</span>
<span class="lineNum">   13749 </span>            :          a type-specifier.  */
<span class="lineNum">   13750 </span><span class="lineCov">    5399030 :       if (!found_decl_spec &amp;&amp; !constructor_p)</span>
<span class="lineNum">   13751 </span><span class="lineCov">        804 :         {</span>
<span class="lineNum">   13752 </span>            :           int decl_spec_declares_class_or_enum;
<span class="lineNum">   13753 </span><span class="lineCov">        804 :           bool is_cv_qualifier;</span>
<span class="lineNum">   13754 </span><span class="lineCov">        804 :           tree type_spec;</span>
<span class="lineNum">   13755 </span><span class="lineCov">        804 : </span>
<span class="lineNum">   13756 </span>            :           type_spec
<span class="lineNum">   13757 </span>            :             = cp_parser_type_specifier (parser, flags,
<span class="lineNum">   13758 </span>            :                                         decl_specs,
<span class="lineNum">   13759 </span>            :                                         /*is_declaration=*/true,
<span class="lineNum">   13760 </span>            :                                         &amp;decl_spec_declares_class_or_enum,
<span class="lineNum">   13761 </span>            :                                         &amp;is_cv_qualifier);
<span class="lineNum">   13762 </span>            :           *declares_class_or_enum |= decl_spec_declares_class_or_enum;
<span class="lineNum">   13763 </span><span class="lineCov">  101699755 : </span>
<span class="lineNum">   13764 </span><span class="lineCov">   12026117 :           /* If this type-specifier referenced a user-defined type</span>
<span class="lineNum">   13765 </span><span class="lineCov">          5 :              (a typedef, class-name, etc.), then we can't allow any</span>
<span class="lineNum">   13766 </span><span class="lineCov">          2 :              more such type-specifiers henceforth.</span>
<span class="lineNum">   13767 </span>            : 
<span class="lineNum">   13768 </span><span class="lineCov">  101699755 :              [dcl.spec]</span>
<span class="lineNum">   13769 </span><span class="lineCov">   12026117 : </span>
<span class="lineNum">   13770 </span><span class="lineCov">         69 :              The longest sequence of decl-specifiers that could</span>
<span class="lineNum">   13771 </span><span class="lineCov">         12 :              possibly be a type name is taken as the</span>
<span class="lineNum">   13772 </span><span class="lineCov">          2 :              decl-specifier-seq of a declaration.  The sequence shall</span>
<span class="lineNum">   13773 </span><span class="lineCov">          1 :              be self-consistent as described below.</span>
<span class="lineNum">   13774 </span>            : 
<span class="lineNum">   13775 </span><span class="lineCov">  101699755 :              [dcl.type]</span>
<span class="lineNum">   13776 </span><span class="lineCov">    4064164 : </span>
<span class="lineNum">   13777 </span>            :              As a general rule, at most one type-specifier is allowed
<span class="lineNum">   13778 </span>            :              in the complete decl-specifier-seq of a declaration.  The
<span class="lineNum">   13779 </span>            :              only exceptions are the following:
<span class="lineNum">   13780 </span><span class="lineCov">  101699755 : </span>
<span class="lineNum">   13781 </span><span class="lineCov">  203399510 :              -- const or volatile can be combined with any other</span>
<span class="lineNum">   13782 </span><span class="lineCov">  101699755 :                 type-specifier.</span>
<span class="lineNum">   13783 </span><span class="lineCov">  126555510 : </span>
<span class="lineNum">   13784 </span><span class="lineCov">   24855755 :              -- signed or unsigned can be combined with char, long,</span>
<span class="lineNum">   13785 </span>            :                 short, or int.
<span class="lineNum">   13786 </span>            : 
<span class="lineNum">   13787 </span>            :              -- ..
<span class="lineNum">   13788 </span><span class="lineCov">  101699755 : </span>
<span class="lineNum">   13789 </span>            :              Example:
<span class="lineNum">   13790 </span><span class="lineCov">   88722943 : </span>
<span class="lineNum">   13791 </span><span class="lineCov">   88722943 :                typedef char* Pc;</span>
<span class="lineNum">   13792 </span><span class="lineCov">   88722943 :                void g (const int Pc);</span>
<span class="lineNum">   13793 </span>            : 
<span class="lineNum">   13794 </span><span class="lineCov">   88722943 :              Here, Pc is *not* part of the decl-specifier seq; it's</span>
<span class="lineNum">   13795 </span><span class="lineCov">   88722943 :              the declarator.  Therefore, once we see a type-specifier</span>
<span class="lineNum">   13796 </span>            :              (other than a cv-qualifier), we forbid any additional
<span class="lineNum">   13797 </span>            :              user-defined types.  We *do* still allow things like `int
<span class="lineNum">   13798 </span>            :              int' to be considered a decl-specifier-seq, and issue the
<span class="lineNum">   13799 </span>            :              error message later.  */
<span class="lineNum">   13800 </span><span class="lineCov">   88722930 :           if (type_spec &amp;&amp; !is_cv_qualifier)</span>
<span class="lineNum">   13801 </span>            :             flags |= CP_PARSER_FLAGS_NO_USER_DEFINED_TYPES;
<span class="lineNum">   13802 </span>            :           /* A constructor declarator cannot follow a type-specifier.  */
<span class="lineNum">   13803 </span>            :           if (type_spec)
<span class="lineNum">   13804 </span>            :             {
<span class="lineNum">   13805 </span>            :               constructor_possible_p = false;
<span class="lineNum">   13806 </span>            :               found_decl_spec = true;
<span class="lineNum">   13807 </span>            :               if (!is_cv_qualifier)
<span class="lineNum">   13808 </span>            :                 decl_specs-&gt;any_type_specifiers_p = true;
<span class="lineNum">   13809 </span>            : 
<span class="lineNum">   13810 </span>            :               if ((flags &amp; CP_PARSER_FLAGS_ONLY_MUTABLE_OR_CONSTEXPR) != 0)
<span class="lineNum">   13811 </span>            :                 error_at (token-&gt;location, &quot;type-specifier invalid in lambda&quot;);
<span class="lineNum">   13812 </span>            :             }
<span class="lineNum">   13813 </span>            :         }
<span class="lineNum">   13814 </span>            : 
<span class="lineNum">   13815 </span>            :       /* If we still do not have a DECL_SPEC, then there are no more
<span class="lineNum">   13816 </span>            :          decl-specifiers.  */
<span class="lineNum">   13817 </span>            :       if (!found_decl_spec)
<span class="lineNum">   13818 </span>            :         break;
<span class="lineNum">   13819 </span>            : 
<span class="lineNum">   13820 </span>            :       decl_specs-&gt;any_specifiers_p = true;
<span class="lineNum">   13821 </span>            :       /* After we see one decl-specifier, further decl-specifiers are
<span class="lineNum">   13822 </span>            :          always optional.  */
<span class="lineNum">   13823 </span>            :       flags |= CP_PARSER_FLAGS_OPTIONAL;
<span class="lineNum">   13824 </span>            :     }
<span class="lineNum">   13825 </span>            : 
<span class="lineNum">   13826 </span>            :   /* Don't allow a friend specifier with a class definition.  */
<span class="lineNum">   13827 </span>            :   if (decl_spec_seq_has_spec_p (decl_specs, ds_friend)
<span class="lineNum">   13828 </span>            :       &amp;&amp; (*declares_class_or_enum &amp; 2))
<span class="lineNum">   13829 </span>            :     error_at (decl_specs-&gt;locations[ds_friend],
<span class="lineNum">   13830 </span>            :               &quot;class definition may not be declared a friend&quot;);
<span class="lineNum">   13831 </span>            : }
<span class="lineNum">   13832 </span>            : 
<span class="lineNum">   13833 </span>            : /* Parse an (optional) storage-class-specifier.
<span class="lineNum">   13834 </span>            : 
<span class="lineNum">   13835 </span>            :    storage-class-specifier:
<span class="lineNum">   13836 </span>            :      auto
<span class="lineNum">   13837 </span>            :      register
<span class="lineNum">   13838 </span><span class="lineCov">   88722930 :      static</span>
<span class="lineNum">   13839 </span><span class="lineCov">   40429215 :      extern</span>
<span class="lineNum">   13840 </span>            :      mutable
<span class="lineNum">   13841 </span><span class="lineCov">   88722930 : </span>
<span class="lineNum">   13842 </span>            :    GNU Extension:
<span class="lineNum">   13843 </span><span class="lineCov">   45714537 : </span>
<span class="lineNum">   13844 </span><span class="lineCov">   45714537 :    storage-class-specifier:</span>
<span class="lineNum">   13845 </span><span class="lineCov">   45714537 :      thread</span>
<span class="lineNum">   13846 </span><span class="lineCov">   40429215 : </span>
<span class="lineNum">   13847 </span>            :    Returns an IDENTIFIER_NODE corresponding to the keyword used.  */
<a name="13848"><span class="lineNum">   13848 </span><span class="lineCov">   45714537 : </span></a>
<span class="lineNum">   13849 </span><span class="lineCov">         12 : static tree</span>
<span class="lineNum">   13850 </span>            : cp_parser_storage_class_specifier_opt (cp_parser* parser)
<span class="lineNum">   13851 </span>            : {
<span class="lineNum">   13852 </span>            :   switch (cp_lexer_peek_token (parser-&gt;lexer)-&gt;keyword)
<span class="lineNum">   13853 </span>            :     {
<span class="lineNum">   13854 </span>            :     case RID_AUTO:
<span class="lineNum">   13855 </span><span class="lineCov">  101699742 :       if (cxx_dialect != cxx98)</span>
<span class="lineNum">   13856 </span>            :         return NULL_TREE;
<span class="lineNum">   13857 </span>            :       /* Fall through for C++98.  */
<span class="lineNum">   13858 </span><span class="lineCov">   57740654 :       gcc_fallthrough ();</span>
<span class="lineNum">   13859 </span>            : 
<span class="lineNum">   13860 </span>            :     case RID_REGISTER:
<span class="lineNum">   13861 </span><span class="lineCov">   57740654 :     case RID_STATIC:</span>
<span class="lineNum">   13862 </span>            :     case RID_EXTERN:
<span class="lineNum">   13863 </span>            :     case RID_MUTABLE:
<span class="lineNum">   13864 </span>            :     case RID_THREAD:
<span class="lineNum">   13865 </span><span class="lineCov">   43959088 :       /* Consume the token.  */</span>
<span class="lineNum">   13866 </span><span class="lineCov">   43959088 :       return cp_lexer_consume_token (parser-&gt;lexer)-&gt;u.value;</span>
<span class="lineNum">   13867 </span><span class="lineCov">          6 : </span>
<span class="lineNum">   13868 </span>            :     default:
<span class="lineNum">   13869 </span><span class="lineCov">   43959088 :       return NULL_TREE;</span>
<span class="lineNum">   13870 </span>            :     }
<span class="lineNum">   13871 </span>            : }
<span class="lineNum">   13872 </span>            : 
<span class="lineNum">   13873 </span>            : /* Parse an (optional) function-specifier.
<span class="lineNum">   13874 </span>            : 
<span class="lineNum">   13875 </span>            :    function-specifier:
<span class="lineNum">   13876 </span>            :      inline
<span class="lineNum">   13877 </span>            :      virtual
<span class="lineNum">   13878 </span>            :      explicit
<span class="lineNum">   13879 </span>            : 
<span class="lineNum">   13880 </span>            :    Returns an IDENTIFIER_NODE corresponding to the keyword used.
<span class="lineNum">   13881 </span>            :    Updates DECL_SPECS, if it is non-NULL.  */
<a name="13882"><span class="lineNum">   13882 </span>            : </a>
<span class="lineNum">   13883 </span>            : static tree
<span class="lineNum">   13884 </span>            : cp_parser_function_specifier_opt (cp_parser* parser,
<span class="lineNum">   13885 </span>            :                                   cp_decl_specifier_seq *decl_specs)
<span class="lineNum">   13886 </span>            : {
<span class="lineNum">   13887 </span>            :   cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   13888 </span><span class="lineCov">     150802 :   switch (token-&gt;keyword)</span>
<span class="lineNum">   13889 </span>            :     {
<span class="lineNum">   13890 </span><span class="lineCov">     150802 :     case RID_INLINE:</span>
<span class="lineNum">   13891 </span>            :       set_and_check_decl_spec_loc (decl_specs, ds_inline, token);
<span class="lineNum">   13892 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">   13893 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   13894 </span>            :     case RID_VIRTUAL:
<span class="lineNum">   13895 </span>            :       /* 14.5.2.3 [temp.mem]
<span class="lineNum">   13896 </span><span class="lineCov">     146499 : </span>
<span class="lineNum">   13897 </span>            :          A member function template shall not be virtual.  */
<span class="lineNum">   13898 </span><span class="lineCov">     146499 :       if (PROCESSING_REAL_TEMPLATE_DECL_P ()</span>
<span class="lineNum">   13899 </span><span class="lineCov">     146499 :           &amp;&amp; current_class_type)</span>
<span class="lineNum">   13900 </span><span class="lineCov">     146499 :         error_at (token-&gt;location, &quot;templates may not be %&lt;virtual%&gt;&quot;);</span>
<span class="lineNum">   13901 </span><span class="lineCov">     146499 :       else</span>
<span class="lineNum">   13902 </span><span class="lineCov">     146499 :         set_and_check_decl_spec_loc (decl_specs, ds_virtual, token);</span>
<span class="lineNum">   13903 </span>            :       break;
<span class="lineNum">   13904 </span><span class="lineCov">     146499 : </span>
<span class="lineNum">   13905 </span>            :     case RID_EXPLICIT:
<span class="lineNum">   13906 </span>            :       set_and_check_decl_spec_loc (decl_specs, ds_explicit, token);
<span class="lineNum">   13907 </span>            :       break;
<span class="lineNum">   13908 </span>            : 
<span class="lineNum">   13909 </span>            :     default:
<span class="lineNum">   13910 </span>            :       return NULL_TREE;
<span class="lineNum">   13911 </span>            :     }
<span class="lineNum">   13912 </span>            : 
<span class="lineNum">   13913 </span>            :   /* Consume the token.  */
<span class="lineNum">   13914 </span>            :   return cp_lexer_consume_token (parser-&gt;lexer)-&gt;u.value;
<span class="lineNum">   13915 </span>            : }
<span class="lineNum">   13916 </span>            : 
<span class="lineNum">   13917 </span>            : /* Parse a linkage-specification.
<span class="lineNum">   13918 </span>            : 
<span class="lineNum">   13919 </span>            :    linkage-specification:
<span class="lineNum">   13920 </span>            :      extern string-literal { declaration-seq [opt] }
<span class="lineNum">   13921 </span>            :      extern string-literal declaration  */
<a name="13922"><span class="lineNum">   13922 </span><span class="lineCov">    2567198 : </span></a>
<span class="lineNum">   13923 </span>            : static void
<span class="lineNum">   13924 </span>            : cp_parser_linkage_specification (cp_parser* parser)
<span class="lineNum">   13925 </span><span class="lineCov">    5134396 : {</span>
<span class="lineNum">   13926 </span><span class="lineCov">    2567198 :   tree linkage;</span>
<span class="lineNum">   13927 </span>            : 
<span class="lineNum">   13928 </span><span class="lineCov">    2038946 :   /* Look for the `extern' keyword.  */</span>
<span class="lineNum">   13929 </span><span class="lineCov">    2038946 :   cp_token *extern_token</span>
<span class="lineNum">   13930 </span><span class="lineCov">    2038946 :     = cp_parser_require_keyword (parser, RID_EXTERN, RT_EXTERN);</span>
<span class="lineNum">   13931 </span>            : 
<span class="lineNum">   13932 </span><span class="lineCov">     265752 :   /* Look for the string-literal.  */</span>
<span class="lineNum">   13933 </span>            :   cp_token *string_token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   13934 </span>            :   linkage = cp_parser_string_literal (parser, false, false);
<span class="lineNum">   13935 </span>            : 
<span class="lineNum">   13936 </span><span class="lineCov">     265752 :   /* Transform the literal into an identifier.  If the literal is a</span>
<span class="lineNum">   13937 </span><span class="lineCov">     265770 :      wide-character string, or contains embedded NULs, then we can't</span>
<span class="lineNum">   13938 </span><span class="lineCov">          9 :      handle it as the user wants.  */</span>
<span class="lineNum">   13939 </span>            :   if (strlen (TREE_STRING_POINTER (linkage))
<span class="lineNum">   13940 </span><span class="lineCov">     265743 :       != (size_t) (TREE_STRING_LENGTH (linkage) - 1))</span>
<span class="lineNum">   13941 </span>            :     {
<span class="lineNum">   13942 </span>            :       cp_parser_error (parser, &quot;invalid linkage-specification&quot;);
<span class="lineNum">   13943 </span><span class="lineCov">     258221 :       /* Assume C++ linkage.  */</span>
<span class="lineNum">   13944 </span><span class="lineCov">     258221 :       linkage = lang_name_cplusplus;</span>
<span class="lineNum">   13945 </span><span class="lineCov">     258221 :     }</span>
<span class="lineNum">   13946 </span>            :   else
<span class="lineNum">   13947 </span>            :     linkage = get_identifier (TREE_STRING_POINTER (linkage));
<span class="lineNum">   13948 </span>            : 
<span class="lineNum">   13949 </span>            :   /* We're now using the new linkage.  */
<span class="lineNum">   13950 </span>            :   push_lang_context (linkage);
<span class="lineNum">   13951 </span>            : 
<span class="lineNum">   13952 </span><span class="lineCov">    2562919 :   /* Preserve the location of the the innermost linkage specification,</span>
<span class="lineNum">   13953 </span>            :      tracking the locations of nested specifications via a local.  */
<span class="lineNum">   13954 </span>            :   location_t saved_location
<span class="lineNum">   13955 </span>            :     = parser-&gt;innermost_linkage_specification_location;
<span class="lineNum">   13956 </span>            :   /* Construct a location ranging from the start of the &quot;extern&quot; to
<span class="lineNum">   13957 </span>            :      the end of the string-literal, with the caret at the start, e.g.:
<span class="lineNum">   13958 </span>            :        extern &quot;C&quot; {
<span class="lineNum">   13959 </span>            :        ^~~~~~~~~~
<span class="lineNum">   13960 </span>            :   */
<span class="lineNum">   13961 </span>            :   parser-&gt;innermost_linkage_specification_location
<span class="lineNum">   13962 </span><span class="lineCov">     140164 :     = make_location (extern_token-&gt;location,</span>
<span class="lineNum">   13963 </span>            :                      extern_token-&gt;location,
<span class="lineNum">   13964 </span><span class="lineCov">     140164 :                      get_finish (string_token-&gt;location));</span>
<span class="lineNum">   13965 </span>            : 
<span class="lineNum">   13966 </span>            :   /* If the next token is a `{', then we're using the first
<span class="lineNum">   13967 </span><span class="lineCov">     140164 :      production.  */</span>
<span class="lineNum">   13968 </span><span class="lineCov">     140164 :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_BRACE))</span>
<span class="lineNum">   13969 </span>            :     {
<span class="lineNum">   13970 </span>            :       cp_ensure_no_omp_declare_simd (parser);
<span class="lineNum">   13971 </span><span class="lineCov">     280328 :       cp_ensure_no_oacc_routine (parser);</span>
<span class="lineNum">   13972 </span><span class="lineCov">     140164 : </span>
<span class="lineNum">   13973 </span>            :       /* Consume the `{' token.  */
<span class="lineNum">   13974 </span>            :       matching_braces braces;
<span class="lineNum">   13975 </span>            :       braces.consume_open (parser)-&gt;location;
<span class="lineNum">   13976 </span>            :       /* Parse the declarations.  */
<span class="lineNum">   13977 </span><span class="lineCov">     140164 :       cp_parser_declaration_seq_opt (parser);</span>
<span class="lineNum">   13978 </span><span class="lineCov">     280328 :       /* Look for the closing `}'.  */</span>
<span class="lineNum">   13979 </span>            :       braces.require_close (parser);
<span class="lineNum">   13980 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   13981 </span>            :   /* Otherwise, there's just one declaration.  */
<span class="lineNum">   13982 </span><span class="lineNoCov">          0 :   else</span>
<span class="lineNum">   13983 </span>            :     {
<span class="lineNum">   13984 </span>            :       bool saved_in_unbraced_linkage_specification_p;
<span class="lineNum">   13985 </span><span class="lineCov">     280328 : </span>
<span class="lineNum">   13986 </span>            :       saved_in_unbraced_linkage_specification_p
<span class="lineNum">   13987 </span>            :         = parser-&gt;in_unbraced_linkage_specification_p;
<span class="lineNum">   13988 </span><span class="lineCov">     140164 :       parser-&gt;in_unbraced_linkage_specification_p = true;</span>
<span class="lineNum">   13989 </span>            :       cp_parser_declaration (parser);
<span class="lineNum">   13990 </span>            :       parser-&gt;in_unbraced_linkage_specification_p
<span class="lineNum">   13991 </span>            :         = saved_in_unbraced_linkage_specification_p;
<span class="lineNum">   13992 </span><span class="lineCov">     140164 :     }</span>
<span class="lineNum">   13993 </span>            : 
<span class="lineNum">   13994 </span>            :   /* We're done with the linkage-specification.  */
<span class="lineNum">   13995 </span>            :   pop_lang_context ();
<span class="lineNum">   13996 </span>            : 
<span class="lineNum">   13997 </span>            :   /* Restore location of parent linkage specification, if any.  */
<span class="lineNum">   13998 </span>            :   parser-&gt;innermost_linkage_specification_location = saved_location;
<span class="lineNum">   13999 </span><span class="lineCov">     140164 : }</span>
<span class="lineNum">   14000 </span><span class="lineCov">     140164 : </span>
<span class="lineNum">   14001 </span>            : /* Parse a static_assert-declaration.
<span class="lineNum">   14002 </span>            : 
<span class="lineNum">   14003 </span>            :    static_assert-declaration:
<span class="lineNum">   14004 </span>            :      static_assert ( constant-expression , string-literal ) ; 
<span class="lineNum">   14005 </span>            :      static_assert ( constant-expression ) ; (C++17)
<span class="lineNum">   14006 </span><span class="lineCov">     140164 : </span>
<span class="lineNum">   14007 </span>            :    If MEMBER_P, this static_assert is a class member.  */
<a name="14008"><span class="lineNum">   14008 </span><span class="lineCov">      97462 : </span></a>
<span class="lineNum">   14009 </span><span class="lineCov">      97462 : static void </span>
<span class="lineNum">   14010 </span>            : cp_parser_static_assert(cp_parser *parser, bool member_p)
<span class="lineNum">   14011 </span>            : {
<span class="lineNum">   14012 </span><span class="lineCov">     194924 :   cp_expr condition;</span>
<span class="lineNum">   14013 </span><span class="lineCov">      97462 :   location_t token_loc;</span>
<span class="lineNum">   14014 </span>            :   tree message;
<span class="lineNum">   14015 </span><span class="lineCov">      97462 :   bool dummy;</span>
<span class="lineNum">   14016 </span>            : 
<span class="lineNum">   14017 </span><span class="lineCov">      97462 :   /* Peek at the `static_assert' token so we can keep track of exactly</span>
<span class="lineNum">   14018 </span>            :      where the static assertion started.  */
<span class="lineNum">   14019 </span>            :   token_loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">   14020 </span>            : 
<span class="lineNum">   14021 </span>            :   /* Look for the `static_assert' keyword.  */
<span class="lineNum">   14022 </span><span class="lineCov">      42702 :   if (!cp_parser_require_keyword (parser, RID_STATIC_ASSERT, </span>
<span class="lineNum">   14023 </span>            :                                   RT_STATIC_ASSERT))
<span class="lineNum">   14024 </span><span class="lineCov">      42702 :     return;</span>
<span class="lineNum">   14025 </span><span class="lineCov">      42702 : </span>
<span class="lineNum">   14026 </span><span class="lineCov">      42702 :   /*  We know we are in a static assertion; commit to any tentative</span>
<span class="lineNum">   14027 </span><span class="lineCov">      42702 :       parse.  */</span>
<span class="lineNum">   14028 </span><span class="lineCov">      42702 :   if (cp_parser_parsing_tentatively (parser))</span>
<span class="lineNum">   14029 </span><span class="lineCov">      42702 :     cp_parser_commit_to_tentative_parse (parser);</span>
<span class="lineNum">   14030 </span>            : 
<span class="lineNum">   14031 </span>            :   /* Parse the `(' starting the static assertion condition.  */
<span class="lineNum">   14032 </span>            :   matching_parens parens;
<span class="lineNum">   14033 </span><span class="lineCov">     140164 :   parens.require_open (parser);</span>
<span class="lineNum">   14034 </span>            : 
<span class="lineNum">   14035 </span>            :   /* Parse the constant-expression.  Allow a non-constant expression
<span class="lineNum">   14036 </span><span class="lineCov">     140164 :      here in order to give better diagnostics in finish_static_assert.  */</span>
<span class="lineNum">   14037 </span><span class="lineCov">     140164 :   condition = </span>
<span class="lineNum">   14038 </span>            :     cp_parser_constant_expression (parser,
<span class="lineNum">   14039 </span>            :                                    /*allow_non_constant_p=*/true,
<span class="lineNum">   14040 </span>            :                                    /*non_constant_p=*/&amp;dummy);
<span class="lineNum">   14041 </span>            : 
<span class="lineNum">   14042 </span>            :   if (cp_lexer_peek_token (parser-&gt;lexer)-&gt;type == CPP_CLOSE_PAREN)
<span class="lineNum">   14043 </span>            :     {
<span class="lineNum">   14044 </span>            :       if (cxx_dialect &lt; cxx17)
<span class="lineNum">   14045 </span>            :         pedwarn (input_location, OPT_Wpedantic,
<span class="lineNum">   14046 </span>            :                  &quot;static_assert without a message &quot;
<span class="lineNum">   14047 </span>            :                  &quot;only available with -std=c++17 or -std=gnu++17&quot;);
<span class="lineNum">   14048 </span><span class="lineCov">      74407 :       /* Eat the ')'  */</span>
<span class="lineNum">   14049 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   14050 </span><span class="lineCov">      74407 :       message = build_string (1, &quot;&quot;);</span>
<span class="lineNum">   14051 </span><span class="lineCov">      74407 :       TREE_TYPE (message) = char_array_type_node;</span>
<span class="lineNum">   14052 </span><span class="lineCov">      74407 :       fix_string_type (message);</span>
<span class="lineNum">   14053 </span><span class="lineCov">      74407 :     }</span>
<span class="lineNum">   14054 </span>            :   else
<span class="lineNum">   14055 </span>            :     {
<span class="lineNum">   14056 </span>            :       /* Parse the separating `,'.  */
<span class="lineNum">   14057 </span><span class="lineCov">     148814 :       cp_parser_require (parser, CPP_COMMA, RT_COMMA);</span>
<span class="lineNum">   14058 </span>            : 
<span class="lineNum">   14059 </span>            :       /* Parse the string-literal message.  */
<span class="lineNum">   14060 </span><span class="lineCov">      74407 :       message = cp_parser_string_literal (parser, </span>
<span class="lineNum">   14061 </span>            :                                           /*translate=*/false,
<span class="lineNum">   14062 </span><span class="lineNoCov">          0 :                                           /*wide_ok=*/true);</span>
<span class="lineNum">   14063 </span>            : 
<span class="lineNum">   14064 </span>            :       /* A `)' completes the static assertion.  */
<span class="lineNum">   14065 </span>            :       if (!parens.require_close (parser))
<span class="lineNum">   14066 </span><span class="lineCov">      74407 :         cp_parser_skip_to_closing_parenthesis (parser, </span>
<span class="lineNum">   14067 </span><span class="lineCov">      66836 :                                                /*recovering=*/true, </span>
<span class="lineNum">   14068 </span>            :                                                /*or_comma=*/false,
<span class="lineNum">   14069 </span>            :                                                /*consume_paren=*/true);
<span class="lineNum">   14070 </span><span class="lineCov">     148814 :     }</span>
<span class="lineNum">   14071 </span><span class="lineCov">      74407 : </span>
<span class="lineNum">   14072 </span>            :   /* A semicolon terminates the declaration.  */
<span class="lineNum">   14073 </span>            :   cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);
<span class="lineNum">   14074 </span>            : 
<span class="lineNum">   14075 </span><span class="lineCov">     148814 :   /* Get the location for the static assertion.  Use that of the</span>
<span class="lineNum">   14076 </span><span class="lineCov">      74407 :      condition if available, otherwise, use that of the &quot;static_assert&quot;</span>
<span class="lineNum">   14077 </span>            :      token.  */
<span class="lineNum">   14078 </span><span class="lineCov">      74407 :   location_t assert_loc = condition.get_location ();</span>
<span class="lineNum">   14079 </span>            :   if (assert_loc == UNKNOWN_LOCATION)
<span class="lineNum">   14080 </span><span class="lineCov">      74407 :     assert_loc = token_loc;</span>
<span class="lineNum">   14081 </span>            : 
<span class="lineNum">   14082 </span><span class="lineCov">       2570 :   /* Complete the static assertion, which may mean either processing </span>
<span class="lineNum">   14083 </span><span class="lineCov">         73 :      the static assert now or saving it for template instantiation.  */</span>
<span class="lineNum">   14084 </span>            :   finish_static_assert (condition, message, assert_loc, member_p);
<span class="lineNum">   14085 </span>            : }
<span class="lineNum">   14086 </span>            : 
<span class="lineNum">   14087 </span><span class="lineCov">       2570 : /* Parse the expression in decltype ( expression ).  */</span>
<a name="14088"><span class="lineNum">   14088 </span><span class="lineCov">       2570 : </span></a>
<span class="lineNum">   14089 </span><span class="lineCov">       2570 : static tree</span>
<span class="lineNum">   14090 </span><span class="lineCov">       2570 : cp_parser_decltype_expr (cp_parser *parser,</span>
<span class="lineNum">   14091 </span>            :                          bool &amp;id_expression_or_member_access_p)
<span class="lineNum">   14092 </span>            : {
<span class="lineNum">   14093 </span>            :   cp_token *id_expr_start_token;
<span class="lineNum">   14094 </span>            :   tree expr;
<span class="lineNum">   14095 </span><span class="lineCov">      71837 : </span>
<span class="lineNum">   14096 </span>            :   /* Since we're going to preserve any side-effects from this parse, set up a
<span class="lineNum">   14097 </span>            :      firewall to protect our callers from cp_parser_commit_to_tentative_parse
<span class="lineNum">   14098 </span><span class="lineCov">     143674 :      in the expression.  */</span>
<span class="lineNum">   14099 </span>            :   tentative_firewall firewall (parser);
<span class="lineNum">   14100 </span><span class="lineCov">      71837 : </span>
<span class="lineNum">   14101 </span>            :   /* First, try parsing an id-expression.  */
<span class="lineNum">   14102 </span>            :   id_expr_start_token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   14103 </span><span class="lineCov">      71837 :   cp_parser_parse_tentatively (parser);</span>
<span class="lineNum">   14104 </span><span class="lineNoCov">          0 :   expr = cp_parser_id_expression (parser,</span>
<span class="lineNum">   14105 </span>            :                                   /*template_keyword_p=*/false,
<span class="lineNum">   14106 </span>            :                                   /*check_dependency_p=*/true,
<span class="lineNum">   14107 </span>            :                                   /*template_p=*/NULL,
<span class="lineNum">   14108 </span>            :                                   /*declarator_p=*/false,
<span class="lineNum">   14109 </span>            :                                   /*optional_p=*/false);
<span class="lineNum">   14110 </span>            : 
<span class="lineNum">   14111 </span><span class="lineCov">      74407 :   if (!cp_parser_error_occurred (parser) &amp;&amp; expr != error_mark_node)</span>
<span class="lineNum">   14112 </span>            :     {
<span class="lineNum">   14113 </span>            :       bool non_integral_constant_expression_p = false;
<span class="lineNum">   14114 </span>            :       tree id_expression = expr;
<span class="lineNum">   14115 </span>            :       cp_id_kind idk;
<span class="lineNum">   14116 </span><span class="lineCov">      74407 :       const char *error_msg;</span>
<span class="lineNum">   14117 </span><span class="lineCov">      74407 : </span>
<span class="lineNum">   14118 </span><span class="lineCov">          4 :       if (identifier_p (expr))</span>
<span class="lineNum">   14119 </span>            :         /* Lookup the name we got back from the id-expression.  */
<span class="lineNum">   14120 </span>            :         expr = cp_parser_lookup_name_simple (parser, expr,
<span class="lineNum">   14121 </span>            :                                              id_expr_start_token-&gt;location);
<span class="lineNum">   14122 </span><span class="lineCov">     148814 : </span>
<span class="lineNum">   14123 </span>            :       if (expr &amp;&amp; TREE_CODE (expr) == TEMPLATE_DECL)
<span class="lineNum">   14124 </span>            :         /* A template without args is not a complete id-expression.  */
<span class="lineNum">   14125 </span>            :         expr = error_mark_node;
<span class="lineNum">   14126 </span>            : 
<span class="lineNum">   14127 </span>            :       if (expr
<span class="lineNum">   14128 </span><span class="lineCov">     184880 :           &amp;&amp; expr != error_mark_node</span>
<span class="lineNum">   14129 </span>            :           &amp;&amp; TREE_CODE (expr) != TYPE_DECL
<span class="lineNum">   14130 </span>            :           &amp;&amp; (TREE_CODE (expr) != BIT_NOT_EXPR
<span class="lineNum">   14131 </span><span class="lineCov">     184880 :               || !TYPE_P (TREE_OPERAND (expr, 0)))</span>
<span class="lineNum">   14132 </span><span class="lineCov">     184880 :           &amp;&amp; cp_lexer_peek_token (parser-&gt;lexer)-&gt;type == CPP_CLOSE_PAREN)</span>
<span class="lineNum">   14133 </span>            :         {
<span class="lineNum">   14134 </span>            :           /* Complete lookup of the id-expression.  */
<span class="lineNum">   14135 </span>            :           expr = (finish_id_expression
<span class="lineNum">   14136 </span>            :                   (id_expression, expr, parser-&gt;scope, &amp;idk,
<span class="lineNum">   14137 </span><span class="lineCov">     184880 :                    /*integral_constant_expression_p=*/false,</span>
<span class="lineNum">   14138 </span>            :                    /*allow_non_integral_constant_expression_p=*/true,
<span class="lineNum">   14139 </span>            :                    &amp;non_integral_constant_expression_p,
<span class="lineNum">   14140 </span><span class="lineCov">     369760 :                    /*template_p=*/false,</span>
<span class="lineNum">   14141 </span><span class="lineCov">     184880 :                    /*done=*/true,</span>
<span class="lineNum">   14142 </span><span class="lineCov">     369760 :                    /*address_p=*/false,</span>
<span class="lineNum">   14143 </span>            :                    /*template_arg_p=*/false,
<span class="lineNum">   14144 </span>            :                    &amp;error_msg,
<span class="lineNum">   14145 </span>            :                    id_expr_start_token-&gt;location));
<span class="lineNum">   14146 </span>            : 
<span class="lineNum">   14147 </span><span class="lineCov">     184880 :           if (expr == error_mark_node)</span>
<span class="lineNum">   14148 </span>            :             /* We found an id-expression, but it was something that we
<span class="lineNum">   14149 </span><span class="lineCov">     164073 :                should not have found. This is an error, not something</span>
<span class="lineNum">   14150 </span>            :                we can recover from, so note that we found an
<span class="lineNum">   14151 </span><span class="lineCov">     164071 :                id-expression and we'll recover as gracefully as</span>
<span class="lineNum">   14152 </span><span class="lineCov">     164071 :                possible.  */</span>
<span class="lineNum">   14153 </span><span class="lineCov">     164071 :             id_expression_or_member_access_p = true;</span>
<span class="lineNum">   14154 </span><span class="lineCov">     164071 :         }</span>
<span class="lineNum">   14155 </span>            : 
<span class="lineNum">   14156 </span><span class="lineCov">     164071 :       if (expr </span>
<span class="lineNum">   14157 </span>            :           &amp;&amp; expr != error_mark_node
<span class="lineNum">   14158 </span><span class="lineCov">     143702 :           &amp;&amp; cp_lexer_peek_token (parser-&gt;lexer)-&gt;type == CPP_CLOSE_PAREN)</span>
<span class="lineNum">   14159 </span>            :         /* We have an id-expression.  */
<span class="lineNum">   14160 </span>            :         id_expression_or_member_access_p = true;
<span class="lineNum">   14161 </span><span class="lineCov">     164071 :     }</span>
<span class="lineNum">   14162 </span>            : 
<span class="lineNum">   14163 </span><span class="lineCov">         95 :   if (!id_expression_or_member_access_p)</span>
<span class="lineNum">   14164 </span>            :     {
<span class="lineNum">   14165 </span><span class="lineCov">     164071 :       /* Abort the id-expression parse.  */</span>
<span class="lineNum">   14166 </span><span class="lineCov">     164071 :       cp_parser_abort_tentative_parse (parser);</span>
<span class="lineNum">   14167 </span><span class="lineCov">     163304 : </span>
<span class="lineNum">   14168 </span><span class="lineCov">     156801 :       /* Parsing tentatively, again.  */</span>
<span class="lineNum">   14169 </span><span class="lineCov">         11 :       cp_parser_parse_tentatively (parser);</span>
<span class="lineNum">   14170 </span><span class="lineCov">     320861 : </span>
<span class="lineNum">   14171 </span>            :       /* Parse a class member access.  */
<span class="lineNum">   14172 </span>            :       expr = cp_parser_postfix_expression (parser, /*address_p=*/false,
<span class="lineNum">   14173 </span><span class="lineCov">       5038 :                                            /*cast_p=*/false, /*decltype*/true,</span>
<span class="lineNum">   14174 </span><span class="lineCov">       2519 :                                            /*member_access_only_p=*/true, NULL);</span>
<span class="lineNum">   14175 </span>            : 
<span class="lineNum">   14176 </span>            :       if (expr 
<span class="lineNum">   14177 </span>            :           &amp;&amp; expr != error_mark_node
<span class="lineNum">   14178 </span>            :           &amp;&amp; cp_lexer_peek_token (parser-&gt;lexer)-&gt;type == CPP_CLOSE_PAREN)
<span class="lineNum">   14179 </span>            :         /* We have an id-expression.  */
<span class="lineNum">   14180 </span>            :         id_expression_or_member_access_p = true;
<span class="lineNum">   14181 </span>            :     }
<span class="lineNum">   14182 </span>            : 
<span class="lineNum">   14183 </span><span class="lineCov">       2519 :   if (id_expression_or_member_access_p)</span>
<span class="lineNum">   14184 </span>            :     /* We have parsed the complete id-expression or member access.  */
<span class="lineNum">   14185 </span><span class="lineCov">       2519 :     cp_parser_parse_definitely (parser);</span>
<span class="lineNum">   14186 </span>            :   else
<span class="lineNum">   14187 </span>            :     {
<span class="lineNum">   14188 </span>            :       /* Abort our attempt to parse an id-expression or member access
<span class="lineNum">   14189 </span>            :          expression.  */
<span class="lineNum">   14190 </span>            :       cp_parser_abort_tentative_parse (parser);
<span class="lineNum">   14191 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   14192 </span>            :       /* Commit to the tentative_firewall so we get syntax errors.  */
<span class="lineNum">   14193 </span>            :       cp_parser_commit_to_tentative_parse (parser);
<span class="lineNum">   14194 </span><span class="lineCov">     164071 : </span>
<span class="lineNum">   14195 </span><span class="lineCov">     164071 :       /* Parse a full expression.  */</span>
<span class="lineNum">   14196 </span><span class="lineCov">     327375 :       expr = cp_parser_expression (parser, /*pidk=*/NULL, /*cast_p=*/false,</span>
<span class="lineNum">   14197 </span>            :                                    /*decltype_p=*/true);
<span class="lineNum">   14198 </span><span class="lineCov">       2542 :     }</span>
<span class="lineNum">   14199 </span>            : 
<span class="lineNum">   14200 </span>            :   return expr;
<span class="lineNum">   14201 </span><span class="lineCov">     184880 : }</span>
<span class="lineNum">   14202 </span>            : 
<span class="lineNum">   14203 </span>            : /* Parse a `decltype' type. Returns the type.
<span class="lineNum">   14204 </span><span class="lineCov">     182338 : </span>
<span class="lineNum">   14205 </span>            :    simple-type-specifier:
<span class="lineNum">   14206 </span>            :      decltype ( expression )
<span class="lineNum">   14207 </span><span class="lineCov">     182338 :    C++14 proposal:</span>
<span class="lineNum">   14208 </span>            :      decltype ( auto )  */
<a name="14209"><span class="lineNum">   14209 </span>            : </a>
<span class="lineNum">   14210 </span><span class="lineCov">     364676 : static tree</span>
<span class="lineNum">   14211 </span>            : cp_parser_decltype (cp_parser *parser)
<span class="lineNum">   14212 </span><span class="lineCov">     182338 : {</span>
<span class="lineNum">   14213 </span>            :   bool id_expression_or_member_access_p = false;
<span class="lineNum">   14214 </span><span class="lineCov">     182338 :   cp_token *start_token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   14215 </span><span class="lineCov">     182338 : </span>
<span class="lineNum">   14216 </span><span class="lineCov">     182389 :   if (start_token-&gt;type == CPP_DECLTYPE)</span>
<span class="lineNum">   14217 </span>            :     {
<span class="lineNum">   14218 </span><span class="lineCov">         51 :       /* Already parsed.  */</span>
<span class="lineNum">   14219 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   14220 </span>            :       return saved_checks_value (start_token-&gt;u.tree_check_value);
<span class="lineNum">   14221 </span><span class="lineCov">     184880 :     }</span>
<span class="lineNum">   14222 </span>            : 
<span class="lineNum">   14223 </span><span class="lineCov">       2593 :   /* Look for the `decltype' token.  */</span>
<span class="lineNum">   14224 </span>            :   if (!cp_parser_require_keyword (parser, RID_DECLTYPE, RT_DECLTYPE))
<span class="lineNum">   14225 </span>            :     return error_mark_node;
<span class="lineNum">   14226 </span>            : 
<span class="lineNum">   14227 </span>            :   /* Parse the opening `('.  */
<span class="lineNum">   14228 </span><span class="lineCov">     182287 :   matching_parens parens;</span>
<span class="lineNum">   14229 </span>            :   if (!parens.require_open (parser))
<span class="lineNum">   14230 </span>            :     return error_mark_node;
<span class="lineNum">   14231 </span><span class="lineCov">     182287 : </span>
<span class="lineNum">   14232 </span>            :   push_deferring_access_checks (dk_deferred);
<span class="lineNum">   14233 </span>            : 
<span class="lineNum">   14234 </span><span class="lineCov">     182287 :   tree expr = NULL_TREE;</span>
<span class="lineNum">   14235 </span><span class="lineCov">     182287 :   </span>
<span class="lineNum">   14236 </span>            :   if (cxx_dialect &gt;= cxx14
<span class="lineNum">   14237 </span>            :       &amp;&amp; cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_AUTO))
<span class="lineNum">   14238 </span><span class="lineCov">     184880 :     /* decltype (auto) */</span>
<span class="lineNum">   14239 </span>            :     cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   14240 </span>            :   else
<span class="lineNum">   14241 </span>            :     {
<span class="lineNum">   14242 </span>            :       /* decltype (expression)  */
<span class="lineNum">   14243 </span>            : 
<span class="lineNum">   14244 </span>            :       /* Types cannot be defined in a `decltype' expression.  Save away the
<span class="lineNum">   14245 </span>            :          old message and set the new one.  */
<span class="lineNum">   14246 </span>            :       const char *saved_message = parser-&gt;type_definition_forbidden_message;
<span class="lineNum">   14247 </span>            :       parser-&gt;type_definition_forbidden_message
<span class="lineNum">   14248 </span>            :         = G_(&quot;types may not be defined in %&lt;decltype%&gt; expressions&quot;);
<span class="lineNum">   14249 </span><span class="lineCov">     190878 : </span>
<span class="lineNum">   14250 </span>            :       /* The restrictions on constant-expressions do not apply inside
<span class="lineNum">   14251 </span><span class="lineCov">     190878 :          decltype expressions.  */</span>
<span class="lineNum">   14252 </span><span class="lineCov">     381756 :       bool saved_integral_constant_expression_p</span>
<span class="lineNum">   14253 </span>            :         = parser-&gt;integral_constant_expression_p;
<span class="lineNum">   14254 </span><span class="lineCov">     190878 :       bool saved_non_integral_constant_expression_p</span>
<span class="lineNum">   14255 </span>            :         = parser-&gt;non_integral_constant_expression_p;
<span class="lineNum">   14256 </span>            :       parser-&gt;integral_constant_expression_p = false;
<span class="lineNum">   14257 </span><span class="lineCov">        293 : </span>
<span class="lineNum">   14258 </span><span class="lineCov">        293 :       /* Within a parenthesized expression, a `&gt;' token is always</span>
<span class="lineNum">   14259 </span>            :          the greater-than operator.  */
<span class="lineNum">   14260 </span>            :       bool saved_greater_than_is_operator_p
<span class="lineNum">   14261 </span>            :         = parser-&gt;greater_than_is_operator_p;
<span class="lineNum">   14262 </span><span class="lineCov">     190585 :       parser-&gt;greater_than_is_operator_p = true;</span>
<span class="lineNum">   14263 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   14264 </span>            :       /* Do not actually evaluate the expression.  */
<span class="lineNum">   14265 </span>            :       ++cp_unevaluated_operand;
<span class="lineNum">   14266 </span><span class="lineCov">     381170 : </span>
<span class="lineNum">   14267 </span><span class="lineCov">     190585 :       /* Do not warn about problems with the expression.  */</span>
<span class="lineNum">   14268 </span><span class="lineCov">         20 :       ++c_inhibit_evaluation_warnings;</span>
<span class="lineNum">   14269 </span>            : 
<span class="lineNum">   14270 </span><span class="lineCov">     190565 :       expr = cp_parser_decltype_expr (parser, id_expression_or_member_access_p);</span>
<span class="lineNum">   14271 </span>            : 
<span class="lineNum">   14272 </span><span class="lineCov">     190565 :       /* Go back to evaluating expressions.  */</span>
<span class="lineNum">   14273 </span>            :       --cp_unevaluated_operand;
<span class="lineNum">   14274 </span><span class="lineCov">     190565 :       --c_inhibit_evaluation_warnings;</span>
<span class="lineNum">   14275 </span><span class="lineCov">     190565 : </span>
<span class="lineNum">   14276 </span>            :       /* The `&gt;' token might be the end of a template-id or
<span class="lineNum">   14277 </span><span class="lineCov">       5685 :          template-parameter-list now.  */</span>
<span class="lineNum">   14278 </span>            :       parser-&gt;greater_than_is_operator_p
<span class="lineNum">   14279 </span>            :         = saved_greater_than_is_operator_p;
<span class="lineNum">   14280 </span>            : 
<span class="lineNum">   14281 </span>            :       /* Restore the old message and the integral constant expression
<span class="lineNum">   14282 </span>            :          flags.  */
<span class="lineNum">   14283 </span>            :       parser-&gt;type_definition_forbidden_message = saved_message;
<span class="lineNum">   14284 </span><span class="lineCov">     184880 :       parser-&gt;integral_constant_expression_p</span>
<span class="lineNum">   14285 </span><span class="lineCov">     184880 :         = saved_integral_constant_expression_p;</span>
<span class="lineNum">   14286 </span><span class="lineCov">     184880 :       parser-&gt;non_integral_constant_expression_p</span>
<span class="lineNum">   14287 </span>            :         = saved_non_integral_constant_expression_p;
<span class="lineNum">   14288 </span>            :     }
<span class="lineNum">   14289 </span>            : 
<span class="lineNum">   14290 </span><span class="lineCov">     184880 :   /* Parse to the closing `)'.  */</span>
<span class="lineNum">   14291 </span>            :   if (!parens.require_close (parser))
<span class="lineNum">   14292 </span><span class="lineCov">     184880 :     {</span>
<span class="lineNum">   14293 </span>            :       cp_parser_skip_to_closing_parenthesis (parser, true, false,
<span class="lineNum">   14294 </span><span class="lineCov">     184880 :                                              /*consume_paren=*/true);</span>
<span class="lineNum">   14295 </span>            :       pop_deferring_access_checks ();
<span class="lineNum">   14296 </span>            :       return error_mark_node;
<span class="lineNum">   14297 </span>            :     }
<span class="lineNum">   14298 </span><span class="lineCov">     184880 : </span>
<span class="lineNum">   14299 </span>            :   if (!expr)
<span class="lineNum">   14300 </span><span class="lineCov">     184880 :     {</span>
<span class="lineNum">   14301 </span>            :       /* Build auto.  */
<span class="lineNum">   14302 </span>            :       expr = make_decltype_auto ();
<span class="lineNum">   14303 </span><span class="lineCov">     184880 :       AUTO_IS_DECLTYPE (expr) = true;</span>
<span class="lineNum">   14304 </span>            :     }
<span class="lineNum">   14305 </span>            :   else
<span class="lineNum">   14306 </span><span class="lineCov">     184880 :     expr = finish_decltype_type (expr, id_expression_or_member_access_p,</span>
<span class="lineNum">   14307 </span>            :                                  tf_warning_or_error);
<span class="lineNum">   14308 </span><span class="lineCov">     184880 : </span>
<span class="lineNum">   14309 </span>            :   /* Replace the decltype with a CPP_DECLTYPE so we don't need to parse
<span class="lineNum">   14310 </span>            :      it again.  */
<span class="lineNum">   14311 </span><span class="lineCov">     184880 :   start_token-&gt;type = CPP_DECLTYPE;</span>
<span class="lineNum">   14312 </span><span class="lineCov">     184880 :   start_token-&gt;u.tree_check_value = ggc_cleared_alloc&lt;struct tree_check&gt; ();</span>
<span class="lineNum">   14313 </span>            :   start_token-&gt;u.tree_check_value-&gt;value = expr;
<span class="lineNum">   14314 </span>            :   start_token-&gt;u.tree_check_value-&gt;checks = get_deferred_access_checks ();
<span class="lineNum">   14315 </span>            :   start_token-&gt;keyword = RID_MAX;
<span class="lineNum">   14316 </span><span class="lineCov">     184880 :   cp_lexer_purge_tokens_after (parser-&gt;lexer, start_token);</span>
<span class="lineNum">   14317 </span><span class="lineCov">     184880 : </span>
<span class="lineNum">   14318 </span>            :   pop_to_parent_deferring_access_checks ();
<span class="lineNum">   14319 </span>            :   
<span class="lineNum">   14320 </span>            :   return expr;
<span class="lineNum">   14321 </span><span class="lineCov">     184880 : }</span>
<span class="lineNum">   14322 </span><span class="lineCov">     184880 : </span>
<span class="lineNum">   14323 </span><span class="lineCov">     184880 : /* Special member functions [gram.special] */</span>
<span class="lineNum">   14324 </span><span class="lineCov">     184880 : </span>
<span class="lineNum">   14325 </span><span class="lineCov">     184880 : /* Parse a conversion-function-id.</span>
<span class="lineNum">   14326 </span>            : 
<span class="lineNum">   14327 </span>            :    conversion-function-id:
<span class="lineNum">   14328 </span>            :      operator conversion-type-id
<span class="lineNum">   14329 </span><span class="lineCov">     190565 : </span>
<span class="lineNum">   14330 </span>            :    Returns an IDENTIFIER_NODE representing the operator.  */
<a name="14331"><span class="lineNum">   14331 </span><span class="lineCov">         22 : </span></a>
<span class="lineNum">   14332 </span>            : static tree
<span class="lineNum">   14333 </span><span class="lineCov">         22 : cp_parser_conversion_function_id (cp_parser* parser)</span>
<span class="lineNum">   14334 </span><span class="lineCov">         22 : {</span>
<span class="lineNum">   14335 </span>            :   tree type;
<span class="lineNum">   14336 </span>            :   tree saved_scope;
<span class="lineNum">   14337 </span><span class="lineCov">     190543 :   tree saved_qualifying_scope;</span>
<span class="lineNum">   14338 </span>            :   tree saved_object_scope;
<span class="lineNum">   14339 </span>            :   tree pushed_scope = NULL_TREE;
<span class="lineNum">   14340 </span><span class="lineCov">       5685 : </span>
<span class="lineNum">   14341 </span><span class="lineCov">       5685 :   /* Look for the `operator' token.  */</span>
<span class="lineNum">   14342 </span>            :   if (!cp_parser_require_keyword (parser, RID_OPERATOR, RT_OPERATOR))
<span class="lineNum">   14343 </span>            :     return error_mark_node;
<span class="lineNum">   14344 </span><span class="lineCov">     184858 :   /* When we parse the conversion-type-id, the current scope will be</span>
<span class="lineNum">   14345 </span>            :      reset.  However, we need that information in able to look up the
<span class="lineNum">   14346 </span>            :      conversion function later, so we save it here.  */
<span class="lineNum">   14347 </span>            :   saved_scope = parser-&gt;scope;
<span class="lineNum">   14348 </span>            :   saved_qualifying_scope = parser-&gt;qualifying_scope;
<span class="lineNum">   14349 </span><span class="lineCov">     190543 :   saved_object_scope = parser-&gt;object_scope;</span>
<span class="lineNum">   14350 </span><span class="lineCov">     190543 :   /* We must enter the scope of the class so that the names of</span>
<span class="lineNum">   14351 </span><span class="lineCov">     190543 :      entities declared within the class are available in the</span>
<span class="lineNum">   14352 </span><span class="lineCov">     190543 :      conversion-type-id.  For example, consider:</span>
<span class="lineNum">   14353 </span><span class="lineCov">     190543 : </span>
<span class="lineNum">   14354 </span><span class="lineCov">     190543 :        struct S {</span>
<span class="lineNum">   14355 </span>            :          typedef int I;
<span class="lineNum">   14356 </span><span class="lineCov">     190543 :          operator I();</span>
<span class="lineNum">   14357 </span>            :        };
<span class="lineNum">   14358 </span><span class="lineCov">     190543 : </span>
<span class="lineNum">   14359 </span>            :        S::operator I() { ... }
<span class="lineNum">   14360 </span>            : 
<span class="lineNum">   14361 </span>            :      In order to see that `I' is a type-name in the definition, we
<span class="lineNum">   14362 </span>            :      must be in the scope of `S'.  */
<span class="lineNum">   14363 </span>            :   if (saved_scope)
<span class="lineNum">   14364 </span>            :     pushed_scope = push_scope (saved_scope);
<span class="lineNum">   14365 </span>            :   /* Parse the conversion-type-id.  */
<span class="lineNum">   14366 </span>            :   type = cp_parser_conversion_type_id (parser);
<span class="lineNum">   14367 </span>            :   /* Leave the scope of the class, if any.  */
<span class="lineNum">   14368 </span>            :   if (pushed_scope)
<span class="lineNum">   14369 </span>            :     pop_scope (pushed_scope);
<span class="lineNum">   14370 </span>            :   /* Restore the saved scope.  */
<span class="lineNum">   14371 </span><span class="lineCov">      55190 :   parser-&gt;scope = saved_scope;</span>
<span class="lineNum">   14372 </span>            :   parser-&gt;qualifying_scope = saved_qualifying_scope;
<span class="lineNum">   14373 </span><span class="lineCov">      55190 :   parser-&gt;object_scope = saved_object_scope;</span>
<span class="lineNum">   14374 </span><span class="lineCov">      55190 :   /* If the TYPE is invalid, indicate failure.  */</span>
<span class="lineNum">   14375 </span><span class="lineCov">      55190 :   if (type == error_mark_node)</span>
<span class="lineNum">   14376 </span><span class="lineCov">      55190 :     return error_mark_node;</span>
<span class="lineNum">   14377 </span><span class="lineCov">      55190 :   return make_conv_op_name (type);</span>
<span class="lineNum">   14378 </span>            : }
<span class="lineNum">   14379 </span>            : 
<span class="lineNum">   14380 </span><span class="lineCov">      55190 : /* Parse a conversion-type-id:</span>
<span class="lineNum">   14381 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   14382 </span>            :    conversion-type-id:
<span class="lineNum">   14383 </span>            :      type-specifier-seq conversion-declarator [opt]
<span class="lineNum">   14384 </span>            : 
<span class="lineNum">   14385 </span><span class="lineCov">      55190 :    Returns the TYPE specified.  */</span>
<a name="14386"><span class="lineNum">   14386 </span><span class="lineCov">      55190 : </span></a>
<span class="lineNum">   14387 </span><span class="lineCov">      55190 : static tree</span>
<span class="lineNum">   14388 </span>            : cp_parser_conversion_type_id (cp_parser* parser)
<span class="lineNum">   14389 </span>            : {
<span class="lineNum">   14390 </span>            :   tree attributes;
<span class="lineNum">   14391 </span>            :   cp_decl_specifier_seq type_specifiers;
<span class="lineNum">   14392 </span>            :   cp_declarator *declarator;
<span class="lineNum">   14393 </span>            :   tree type_specified;
<span class="lineNum">   14394 </span>            :   const char *saved_message;
<span class="lineNum">   14395 </span>            : 
<span class="lineNum">   14396 </span>            :   /* Parse the attributes.  */
<span class="lineNum">   14397 </span>            :   attributes = cp_parser_attributes_opt (parser);
<span class="lineNum">   14398 </span>            : 
<span class="lineNum">   14399 </span>            :   saved_message = parser-&gt;type_definition_forbidden_message;
<span class="lineNum">   14400 </span>            :   parser-&gt;type_definition_forbidden_message
<span class="lineNum">   14401 </span><span class="lineCov">      55190 :     = G_(&quot;types may not be defined in a conversion-type-id&quot;);</span>
<span class="lineNum">   14402 </span><span class="lineCov">       4088 : </span>
<span class="lineNum">   14403 </span>            :   /* Parse the type-specifiers.  */
<span class="lineNum">   14404 </span><span class="lineCov">      55190 :   cp_parser_type_specifier_seq (parser, /*is_declaration=*/false,</span>
<span class="lineNum">   14405 </span>            :                                 /*is_trailing_return=*/false,
<span class="lineNum">   14406 </span><span class="lineCov">      55190 :                                 &amp;type_specifiers);</span>
<span class="lineNum">   14407 </span><span class="lineCov">       4088 : </span>
<span class="lineNum">   14408 </span>            :   parser-&gt;type_definition_forbidden_message = saved_message;
<span class="lineNum">   14409 </span><span class="lineCov">      55190 : </span>
<span class="lineNum">   14410 </span><span class="lineCov">      55190 :   /* If that didn't work, stop.  */</span>
<span class="lineNum">   14411 </span><span class="lineCov">      55190 :   if (type_specifiers.type == error_mark_node)</span>
<span class="lineNum">   14412 </span>            :     return error_mark_node;
<span class="lineNum">   14413 </span><span class="lineCov">      55190 :   /* Parse the conversion-declarator.  */</span>
<span class="lineNum">   14414 </span>            :   declarator = cp_parser_conversion_declarator_opt (parser);
<span class="lineNum">   14415 </span><span class="lineCov">      55156 : </span>
<span class="lineNum">   14416 </span>            :   type_specified =  grokdeclarator (declarator, &amp;type_specifiers, TYPENAME,
<span class="lineNum">   14417 </span>            :                                     /*initialized=*/0, &amp;attributes);
<span class="lineNum">   14418 </span>            :   if (attributes)
<span class="lineNum">   14419 </span>            :     cplus_decl_attributes (&amp;type_specified, attributes, /*flags=*/0);
<span class="lineNum">   14420 </span>            : 
<span class="lineNum">   14421 </span>            :   /* Don't give this error when parsing tentatively.  This happens to
<span class="lineNum">   14422 </span>            :      work because we always parse this definitively once.  */
<span class="lineNum">   14423 </span>            :   if (! cp_parser_uncommitted_to_tentative_parse_p (parser)
<span class="lineNum">   14424 </span>            :       &amp;&amp; type_uses_auto (type_specified))
<span class="lineNum">   14425 </span>            :     {
<span class="lineNum">   14426 </span><span class="lineCov">      55190 :       if (cxx_dialect &lt; cxx14)</span>
<span class="lineNum">   14427 </span>            :         {
<span class="lineNum">   14428 </span><span class="lineCov">      55190 :           error (&quot;invalid use of %&lt;auto%&gt; in conversion operator&quot;);</span>
<span class="lineNum">   14429 </span><span class="lineCov">      55190 :           return error_mark_node;</span>
<span class="lineNum">   14430 </span><span class="lineCov">      55190 :         }</span>
<span class="lineNum">   14431 </span><span class="lineCov">      55190 :       else if (template_parm_scope_p ())</span>
<span class="lineNum">   14432 </span><span class="lineCov">      55190 :         warning (0, &quot;use of %&lt;auto%&gt; in member template &quot;</span>
<span class="lineNum">   14433 </span>            :                  &quot;conversion operator can never be deduced&quot;);
<span class="lineNum">   14434 </span>            :     }
<span class="lineNum">   14435 </span><span class="lineCov">      55190 : </span>
<span class="lineNum">   14436 </span>            :   return type_specified;
<span class="lineNum">   14437 </span><span class="lineCov">      55190 : }</span>
<span class="lineNum">   14438 </span><span class="lineCov">      55190 : </span>
<span class="lineNum">   14439 </span><span class="lineCov">      55190 : /* Parse an (optional) conversion-declarator.</span>
<span class="lineNum">   14440 </span>            : 
<span class="lineNum">   14441 </span>            :    conversion-declarator:
<span class="lineNum">   14442 </span><span class="lineCov">      55190 :      ptr-operator conversion-declarator [opt]</span>
<span class="lineNum">   14443 </span>            : 
<span class="lineNum">   14444 </span>            :    */
<a name="14445"><span class="lineNum">   14445 </span>            : </a>
<span class="lineNum">   14446 </span><span class="lineCov">      55190 : static cp_declarator *</span>
<span class="lineNum">   14447 </span>            : cp_parser_conversion_declarator_opt (cp_parser* parser)
<span class="lineNum">   14448 </span>            : {
<span class="lineNum">   14449 </span><span class="lineCov">      55190 :   enum tree_code code;</span>
<span class="lineNum">   14450 </span>            :   tree class_type, std_attributes = NULL_TREE;
<span class="lineNum">   14451 </span>            :   cp_cv_quals cv_quals;
<span class="lineNum">   14452 </span><span class="lineCov">      55162 : </span>
<span class="lineNum">   14453 </span>            :   /* We don't know if there's a ptr-operator next, or not.  */
<span class="lineNum">   14454 </span><span class="lineCov">      55162 :   cp_parser_parse_tentatively (parser);</span>
<span class="lineNum">   14455 </span>            :   /* Try the ptr-operator.  */
<span class="lineNum">   14456 </span><span class="lineCov">      55162 :   code = cp_parser_ptr_operator (parser, &amp;class_type, &amp;cv_quals,</span>
<span class="lineNum">   14457 </span><span class="lineCov">         12 :                                  &amp;std_attributes);</span>
<span class="lineNum">   14458 </span>            :   /* If it worked, look for more conversion-declarators.  */
<span class="lineNum">   14459 </span>            :   if (cp_parser_parse_definitely (parser))
<span class="lineNum">   14460 </span>            :     {
<span class="lineNum">   14461 </span><span class="lineCov">      84360 :       cp_declarator *declarator;</span>
<span class="lineNum">   14462 </span><span class="lineCov">      29198 : </span>
<span class="lineNum">   14463 </span>            :       /* Parse another optional declarator.  */
<span class="lineNum">   14464 </span><span class="lineCov">         20 :       declarator = cp_parser_conversion_declarator_opt (parser);</span>
<span class="lineNum">   14465 </span>            : 
<span class="lineNum">   14466 </span><span class="lineCov">          6 :       declarator = cp_parser_make_indirect_declarator</span>
<span class="lineNum">   14467 </span><span class="lineCov">          6 :         (code, class_type, cv_quals, declarator, std_attributes);</span>
<span class="lineNum">   14468 </span>            : 
<span class="lineNum">   14469 </span><span class="lineCov">         14 :       return declarator;</span>
<span class="lineNum">   14470 </span><span class="lineCov">          1 :    }</span>
<span class="lineNum">   14471 </span>            : 
<span class="lineNum">   14472 </span>            :   return NULL;
<span class="lineNum">   14473 </span>            : }
<span class="lineNum">   14474 </span><span class="lineCov">      55156 : </span>
<span class="lineNum">   14475 </span>            : /* Parse an (optional) ctor-initializer.
<span class="lineNum">   14476 </span>            : 
<span class="lineNum">   14477 </span>            :    ctor-initializer:
<span class="lineNum">   14478 </span>            :      : mem-initializer-list  */
<a name="14479"><span class="lineNum">   14479 </span>            : </a>
<span class="lineNum">   14480 </span>            : static void
<span class="lineNum">   14481 </span>            : cp_parser_ctor_initializer_opt (cp_parser* parser)
<span class="lineNum">   14482 </span>            : {
<span class="lineNum">   14483 </span>            :   /* If the next token is not a `:', then there is no
<span class="lineNum">   14484 </span>            :      ctor-initializer.  */
<span class="lineNum">   14485 </span><span class="lineCov">      59406 :   if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_COLON))</span>
<span class="lineNum">   14486 </span>            :     {
<span class="lineNum">   14487 </span><span class="lineCov">      59406 :       /* Do default initialization of any bases and members.  */</span>
<span class="lineNum">   14488 </span><span class="lineCov">      59406 :       if (DECL_CONSTRUCTOR_P (current_function_decl))</span>
<span class="lineNum">   14489 </span><span class="lineCov">      59406 :         finish_mem_initializers (NULL_TREE);</span>
<span class="lineNum">   14490 </span>            :       return;
<span class="lineNum">   14491 </span>            :     }
<span class="lineNum">   14492 </span><span class="lineCov">      59406 : </span>
<span class="lineNum">   14493 </span>            :   /* Consume the `:' token.  */
<span class="lineNum">   14494 </span><span class="lineCov">      59406 :   cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   14495 </span>            :   /* And the mem-initializer-list.  */
<span class="lineNum">   14496 </span>            :   cp_parser_mem_initializer_list (parser);
<span class="lineNum">   14497 </span><span class="lineCov">      59406 : }</span>
<span class="lineNum">   14498 </span>            : 
<span class="lineNum">   14499 </span><span class="lineCov">       4244 : /* Parse a mem-initializer-list.</span>
<span class="lineNum">   14500 </span>            : 
<span class="lineNum">   14501 </span>            :    mem-initializer-list:
<span class="lineNum">   14502 </span><span class="lineCov">       4244 :      mem-initializer ... [opt]</span>
<span class="lineNum">   14503 </span>            :      mem-initializer ... [opt] , mem-initializer-list  */
<a name="14504"><span class="lineNum">   14504 </span><span class="lineCov">       4244 : </span></a>
<span class="lineNum">   14505 </span><span class="lineCov">       4244 : static void</span>
<span class="lineNum">   14506 </span>            : cp_parser_mem_initializer_list (cp_parser* parser)
<span class="lineNum">   14507 </span><span class="lineCov">       4244 : {</span>
<span class="lineNum">   14508 </span>            :   tree mem_initializer_list = NULL_TREE;
<span class="lineNum">   14509 </span>            :   tree target_ctor = error_mark_node;
<span class="lineNum">   14510 </span>            :   cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   14511 </span>            : 
<span class="lineNum">   14512 </span>            :   /* Let the semantic analysis code know that we are starting the
<span class="lineNum">   14513 </span>            :      mem-initializer-list.  */
<span class="lineNum">   14514 </span>            :   if (!DECL_CONSTRUCTOR_P (current_function_decl))
<span class="lineNum">   14515 </span>            :     error_at (token-&gt;location,
<span class="lineNum">   14516 </span>            :               &quot;only constructors take member initializers&quot;);
<span class="lineNum">   14517 </span>            : 
<span class="lineNum">   14518 </span>            :   /* Loop through the list.  */
<span class="lineNum">   14519 </span><span class="lineCov">    5666355 :   while (true)</span>
<span class="lineNum">   14520 </span>            :     {
<span class="lineNum">   14521 </span>            :       tree mem_initializer;
<span class="lineNum">   14522 </span>            : 
<span class="lineNum">   14523 </span><span class="lineCov">    5666355 :       token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   14524 </span>            :       /* Parse the mem-initializer.  */
<span class="lineNum">   14525 </span>            :       mem_initializer = cp_parser_mem_initializer (parser);
<span class="lineNum">   14526 </span><span class="lineCov">    5100605 :       /* If the next token is a `...', we're expanding member initializers. */</span>
<span class="lineNum">   14527 </span><span class="lineCov">      93254 :       bool ellipsis = cp_lexer_next_token_is (parser-&gt;lexer, CPP_ELLIPSIS);</span>
<span class="lineNum">   14528 </span><span class="lineCov">    5100605 :       if (ellipsis</span>
<span class="lineNum">   14529 </span>            :           || (mem_initializer != error_mark_node
<span class="lineNum">   14530 </span>            :               &amp;&amp; check_for_bare_parameter_packs (TREE_PURPOSE
<span class="lineNum">   14531 </span>            :                                                  (mem_initializer))))
<span class="lineNum">   14532 </span><span class="lineCov">     565750 :         {</span>
<span class="lineNum">   14533 </span>            :           /* Consume the `...'. */
<span class="lineNum">   14534 </span><span class="lineCov">     565750 :           if (ellipsis)</span>
<span class="lineNum">   14535 </span>            :             cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   14536 </span>            : 
<span class="lineNum">   14537 </span>            :           /* The TREE_PURPOSE must be a _TYPE, because base-specifiers
<span class="lineNum">   14538 </span>            :              can be expanded but members cannot. */
<span class="lineNum">   14539 </span>            :           if (mem_initializer != error_mark_node
<span class="lineNum">   14540 </span>            :               &amp;&amp; !TYPE_P (TREE_PURPOSE (mem_initializer)))
<span class="lineNum">   14541 </span>            :             {
<span class="lineNum">   14542 </span>            :               error_at (token-&gt;location,
<span class="lineNum">   14543 </span>            :                         &quot;cannot expand initializer for member %qD&quot;,
<span class="lineNum">   14544 </span><span class="lineCov">     565750 :                         TREE_PURPOSE (mem_initializer));</span>
<span class="lineNum">   14545 </span>            :               mem_initializer = error_mark_node;
<span class="lineNum">   14546 </span><span class="lineCov">     565750 :             }</span>
<span class="lineNum">   14547 </span><span class="lineCov">     565750 : </span>
<span class="lineNum">   14548 </span><span class="lineCov">    1131500 :           /* Construct the pack expansion type. */</span>
<span class="lineNum">   14549 </span>            :           if (mem_initializer != error_mark_node)
<span class="lineNum">   14550 </span>            :             mem_initializer = make_pack_expansion (mem_initializer);
<span class="lineNum">   14551 </span>            :         }
<span class="lineNum">   14552 </span><span class="lineCov">     565750 :       if (target_ctor != error_mark_node</span>
<span class="lineNum">   14553 </span><span class="lineCov">          9 :           &amp;&amp; mem_initializer != error_mark_node)</span>
<span class="lineNum">   14554 </span>            :         {
<span class="lineNum">   14555 </span>            :           error (&quot;mem-initializer for %qD follows constructor delegation&quot;,
<span class="lineNum">   14556 </span>            :                  TREE_PURPOSE (mem_initializer));
<span class="lineNum">   14557 </span><span class="lineCov">     866135 :           mem_initializer = error_mark_node;</span>
<span class="lineNum">   14558 </span>            :         }
<span class="lineNum">   14559 </span><span class="lineCov">     866135 :       /* Look for a target constructor. */</span>
<span class="lineNum">   14560 </span>            :       if (mem_initializer != error_mark_node
<span class="lineNum">   14561 </span><span class="lineCov">    1732270 :           &amp;&amp; CLASS_TYPE_P (TREE_PURPOSE (mem_initializer))</span>
<span class="lineNum">   14562 </span>            :           &amp;&amp; same_type_p (TREE_PURPOSE (mem_initializer), current_class_type))
<span class="lineNum">   14563 </span><span class="lineCov">     866135 :         {</span>
<span class="lineNum">   14564 </span>            :           maybe_warn_cpp0x (CPP0X_DELEGATING_CTORS);
<span class="lineNum">   14565 </span><span class="lineCov">    1732270 :           if (mem_initializer_list)</span>
<span class="lineNum">   14566 </span><span class="lineCov">     866135 :             {</span>
<span class="lineNum">   14567 </span><span class="lineCov">     866135 :               error (&quot;constructor delegation follows mem-initializer for %qD&quot;,</span>
<span class="lineNum">   14568 </span><span class="lineCov">     866084 :                      TREE_PURPOSE (mem_initializer_list));</span>
<span class="lineNum">   14569 </span>            :               mem_initializer = error_mark_node;
<span class="lineNum">   14570 </span>            :             }
<span class="lineNum">   14571 </span>            :           target_ctor = mem_initializer;
<span class="lineNum">   14572 </span><span class="lineCov">         15 :         }</span>
<span class="lineNum">   14573 </span><span class="lineCov">         13 :       /* Add it to the list, unless it was erroneous.  */</span>
<span class="lineNum">   14574 </span>            :       if (mem_initializer != error_mark_node)
<span class="lineNum">   14575 </span>            :         {
<span class="lineNum">   14576 </span>            :           TREE_CHAIN (mem_initializer) = mem_initializer_list;
<span class="lineNum">   14577 </span><span class="lineCov">         15 :           mem_initializer_list = mem_initializer;</span>
<span class="lineNum">   14578 </span><span class="lineCov">         15 :         }</span>
<span class="lineNum">   14579 </span>            :       /* If the next token is not a `,', we're done.  */
<span class="lineNum">   14580 </span><span class="lineCov">          6 :       if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_COMMA))</span>
<span class="lineNum">   14581 </span>            :         break;
<span class="lineNum">   14582 </span><span class="lineCov">          6 :       /* Consume the `,' token.  */</span>
<span class="lineNum">   14583 </span><span class="lineCov">          3 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   14584 </span>            :     }
<span class="lineNum">   14585 </span>            : 
<span class="lineNum">   14586 </span>            :   /* Perform semantic analysis.  */
<span class="lineNum">   14587 </span><span class="lineCov">         15 :   if (DECL_CONSTRUCTOR_P (current_function_decl))</span>
<span class="lineNum">   14588 </span><span class="lineCov">         12 :     finish_mem_initializers (mem_initializer_list);</span>
<span class="lineNum">   14589 </span>            : }
<span class="lineNum">   14590 </span><span class="lineCov">     866135 : </span>
<span class="lineNum">   14591 </span><span class="lineCov">          4 : /* Parse a mem-initializer.</span>
<span class="lineNum">   14592 </span>            : 
<span class="lineNum">   14593 </span><span class="lineCov">          8 :    mem-initializer:</span>
<span class="lineNum">   14594 </span><span class="lineCov">          4 :      mem-initializer-id ( expression-list [opt] )</span>
<span class="lineNum">   14595 </span><span class="lineCov">          4 :      mem-initializer-id braced-init-list</span>
<span class="lineNum">   14596 </span>            : 
<span class="lineNum">   14597 </span>            :    GNU extension:
<span class="lineNum">   14598 </span><span class="lineCov">     866135 : </span>
<span class="lineNum">   14599 </span><span class="lineCov">     866090 :    mem-initializer:</span>
<span class="lineNum">   14600 </span><span class="lineCov">    1290043 :      ( expression-list [opt] )</span>
<span class="lineNum">   14601 </span>            : 
<span class="lineNum">   14602 </span><span class="lineCov">      28846 :    Returns a TREE_LIST.  The TREE_PURPOSE is the TYPE (for a base</span>
<span class="lineNum">   14603 </span><span class="lineCov">      28846 :    class) or FIELD_DECL (for a non-static data member) to initialize;</span>
<span class="lineNum">   14604 </span>            :    the TREE_VALUE is the expression-list.  An empty initialization
<span class="lineNum">   14605 </span><span class="lineCov">          8 :    list is represented by void_list_node.  */</span>
<a name="14606"><span class="lineNum">   14606 </span><span class="lineCov">          4 : </span></a>
<span class="lineNum">   14607 </span><span class="lineCov">          4 : static tree</span>
<span class="lineNum">   14608 </span>            : cp_parser_mem_initializer (cp_parser* parser)
<span class="lineNum">   14609 </span>            : {
<span class="lineNum">   14610 </span>            :   tree mem_initializer_id;
<span class="lineNum">   14611 </span>            :   tree expression_list;
<span class="lineNum">   14612 </span><span class="lineCov">     866135 :   tree member;</span>
<span class="lineNum">   14613 </span>            :   cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   14614 </span><span class="lineCov">     866086 : </span>
<span class="lineNum">   14615 </span><span class="lineCov">     866086 :   /* Find out what is being initialized.  */</span>
<span class="lineNum">   14616 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_PAREN))
<span class="lineNum">   14617 </span>            :     {
<span class="lineNum">   14618 </span><span class="lineCov">     866135 :       permerror (token-&gt;location,</span>
<span class="lineNum">   14619 </span>            :                  &quot;anachronistic old-style base class initializer&quot;);
<span class="lineNum">   14620 </span>            :       mem_initializer_id = NULL_TREE;
<span class="lineNum">   14621 </span><span class="lineCov">     300385 :     }</span>
<span class="lineNum">   14622 </span><span class="lineCov">     300385 :   else</span>
<span class="lineNum">   14623 </span>            :     {
<span class="lineNum">   14624 </span>            :       mem_initializer_id = cp_parser_mem_initializer_id (parser);
<span class="lineNum">   14625 </span><span class="lineCov">     565750 :       if (mem_initializer_id == error_mark_node)</span>
<span class="lineNum">   14626 </span><span class="lineCov">     565741 :         return mem_initializer_id;</span>
<span class="lineNum">   14627 </span><span class="lineCov">     565750 :     }</span>
<span class="lineNum">   14628 </span>            :   member = expand_member_init (mem_initializer_id);
<span class="lineNum">   14629 </span>            :   if (member &amp;&amp; !DECL_P (member))
<span class="lineNum">   14630 </span>            :     in_base_initializer = 1;
<span class="lineNum">   14631 </span>            : 
<span class="lineNum">   14632 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_BRACE))
<span class="lineNum">   14633 </span>            :     {
<span class="lineNum">   14634 </span>            :       bool expr_non_constant_p;
<span class="lineNum">   14635 </span>            :       cp_lexer_set_source_position (parser-&gt;lexer);
<span class="lineNum">   14636 </span>            :       maybe_warn_cpp0x (CPP0X_INITIALIZER_LISTS);
<span class="lineNum">   14637 </span>            :       expression_list = cp_parser_braced_list (parser, &amp;expr_non_constant_p);
<span class="lineNum">   14638 </span>            :       CONSTRUCTOR_IS_DIRECT_INIT (expression_list) = 1;
<span class="lineNum">   14639 </span>            :       expression_list = build_tree_list (NULL_TREE, expression_list);
<span class="lineNum">   14640 </span>            :     }
<span class="lineNum">   14641 </span>            :   else
<span class="lineNum">   14642 </span>            :     {
<span class="lineNum">   14643 </span>            :       vec&lt;tree, va_gc&gt; *vec;
<span class="lineNum">   14644 </span>            :       vec = cp_parser_parenthesized_expression_list (parser, non_attr,
<span class="lineNum">   14645 </span>            :                                                      /*cast_p=*/false,
<span class="lineNum">   14646 </span><span class="lineCov">     866135 :                                                      /*allow_expansion_p=*/true,</span>
<span class="lineNum">   14647 </span>            :                                                      /*non_constant_p=*/NULL);
<span class="lineNum">   14648 </span><span class="lineCov">     866135 :       if (vec == NULL)</span>
<span class="lineNum">   14649 </span><span class="lineCov">     866135 :         return error_mark_node;</span>
<span class="lineNum">   14650 </span><span class="lineCov">     866135 :       expression_list = build_tree_list_vec (vec);</span>
<span class="lineNum">   14651 </span><span class="lineCov">    1732270 :       release_tree_vector (vec);</span>
<span class="lineNum">   14652 </span>            :     }
<span class="lineNum">   14653 </span>            : 
<span class="lineNum">   14654 </span><span class="lineCov">     866135 :   if (expression_list == error_mark_node)</span>
<span class="lineNum">   14655 </span>            :     return error_mark_node;
<span class="lineNum">   14656 </span><span class="lineCov">          6 :   if (!expression_list)</span>
<span class="lineNum">   14657 </span>            :     expression_list = void_type_node;
<span class="lineNum">   14658 </span><span class="lineCov">          6 : </span>
<span class="lineNum">   14659 </span>            :   in_base_initializer = 0;
<span class="lineNum">   14660 </span>            : 
<span class="lineNum">   14661 </span>            :   return member ? build_tree_list (member, expression_list) : error_mark_node;
<span class="lineNum">   14662 </span><span class="lineCov">     866129 : }</span>
<span class="lineNum">   14663 </span><span class="lineCov">     866129 : </span>
<span class="lineNum">   14664 </span>            : /* Parse a mem-initializer-id.
<span class="lineNum">   14665 </span>            : 
<span class="lineNum">   14666 </span><span class="lineCov">     866124 :    mem-initializer-id:</span>
<span class="lineNum">   14667 </span><span class="lineCov">     866124 :      :: [opt] nested-name-specifier [opt] class-name</span>
<span class="lineNum">   14668 </span><span class="lineCov">     264684 :      decltype-specifier (C++11)</span>
<span class="lineNum">   14669 </span>            :      identifier
<span class="lineNum">   14670 </span><span class="lineCov">     866124 : </span>
<span class="lineNum">   14671 </span>            :    Returns a TYPE indicating the class to be initialized for the first
<span class="lineNum">   14672 </span><span class="lineCov">       7812 :    production (and the second in C++11).  Returns an IDENTIFIER_NODE</span>
<span class="lineNum">   14673 </span><span class="lineCov">      15624 :    indicating the data member to be initialized for the last production.  */</span>
<a name="14674"><span class="lineNum">   14674 </span><span class="lineCov">       7812 : </span></a>
<span class="lineNum">   14675 </span><span class="lineCov">       7812 : static tree</span>
<span class="lineNum">   14676 </span><span class="lineCov">       7812 : cp_parser_mem_initializer_id (cp_parser* parser)</span>
<span class="lineNum">   14677 </span><span class="lineCov">       7812 : {</span>
<span class="lineNum">   14678 </span>            :   bool global_scope_p;
<span class="lineNum">   14679 </span>            :   bool nested_name_specifier_p;
<span class="lineNum">   14680 </span>            :   bool template_p = false;
<span class="lineNum">   14681 </span><span class="lineCov">     858312 :   tree id;</span>
<span class="lineNum">   14682 </span><span class="lineCov">     858312 : </span>
<span class="lineNum">   14683 </span>            :   cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   14684 </span>            : 
<span class="lineNum">   14685 </span>            :   /* `typename' is not allowed in this context ([temp.res]).  */
<span class="lineNum">   14686 </span><span class="lineCov">     858312 :   if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_TYPENAME))</span>
<span class="lineNum">   14687 </span><span class="lineCov">          6 :     {</span>
<span class="lineNum">   14688 </span><span class="lineCov">     858306 :       error_at (token-&gt;location, </span>
<span class="lineNum">   14689 </span><span class="lineCov">     858306 :                 &quot;keyword %&lt;typename%&gt; not allowed in this context (a qualified &quot;</span>
<span class="lineNum">   14690 </span>            :                 &quot;member initializer is implicitly a type)&quot;);
<span class="lineNum">   14691 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   14692 </span><span class="lineCov">     866118 :     }</span>
<span class="lineNum">   14693 </span>            :   /* Look for the optional `::' operator.  */
<span class="lineNum">   14694 </span><span class="lineCov">     866118 :   global_scope_p</span>
<span class="lineNum">   14695 </span><span class="lineCov">      79245 :     = (cp_parser_global_scope_opt (parser,</span>
<span class="lineNum">   14696 </span>            :                                    /*current_scope_valid_p=*/false)
<span class="lineNum">   14697 </span><span class="lineCov">     866118 :        != NULL_TREE);</span>
<span class="lineNum">   14698 </span>            :   /* Look for the optional nested-name-specifier.  The simplest way to
<span class="lineNum">   14699 </span><span class="lineCov">     866118 :      implement:</span>
<span class="lineNum">   14700 </span>            : 
<span class="lineNum">   14701 </span>            :        [temp.res]
<span class="lineNum">   14702 </span>            : 
<span class="lineNum">   14703 </span>            :        The keyword `typename' is not permitted in a base-specifier or
<span class="lineNum">   14704 </span>            :        mem-initializer; in these contexts a qualified name that
<span class="lineNum">   14705 </span>            :        depends on a template-parameter is implicitly assumed to be a
<span class="lineNum">   14706 </span>            :        type name.
<span class="lineNum">   14707 </span>            : 
<span class="lineNum">   14708 </span>            :      is to assume that we have seen the `typename' keyword at this
<span class="lineNum">   14709 </span>            :      point.  */
<span class="lineNum">   14710 </span>            :   nested_name_specifier_p
<span class="lineNum">   14711 </span>            :     = (cp_parser_nested_name_specifier_opt (parser,
<span class="lineNum">   14712 </span>            :                                             /*typename_keyword_p=*/true,
<span class="lineNum">   14713 </span>            :                                             /*check_dependency_p=*/true,
<span class="lineNum">   14714 </span><span class="lineCov">     866129 :                                             /*type_p=*/true,</span>
<span class="lineNum">   14715 </span>            :                                             /*is_declaration=*/true)
<span class="lineNum">   14716 </span><span class="lineCov">     866129 :        != NULL_TREE);</span>
<span class="lineNum">   14717 </span><span class="lineCov">     866129 :   if (nested_name_specifier_p)</span>
<span class="lineNum">   14718 </span><span class="lineCov">     866129 :     template_p = cp_parser_optional_template_keyword (parser);</span>
<span class="lineNum">   14719 </span><span class="lineCov">     866129 :   /* If there is a `::' operator or a nested-name-specifier, then we</span>
<span class="lineNum">   14720 </span>            :      are definitely looking for a class-name.  */
<span class="lineNum">   14721 </span><span class="lineCov">    1732258 :   if (global_scope_p || nested_name_specifier_p)</span>
<span class="lineNum">   14722 </span>            :     return cp_parser_class_name (parser,
<span class="lineNum">   14723 </span>            :                                  /*typename_keyword_p=*/true,
<span class="lineNum">   14724 </span><span class="lineCov">     866129 :                                  /*template_keyword_p=*/template_p,</span>
<span class="lineNum">   14725 </span>            :                                  typename_type,
<span class="lineNum">   14726 </span><span class="lineCov">          3 :                                  /*check_dependency_p=*/true,</span>
<span class="lineNum">   14727 </span>            :                                  /*class_head_p=*/false,
<span class="lineNum">   14728 </span>            :                                  /*is_declaration=*/true);
<span class="lineNum">   14729 </span><span class="lineCov">          3 :   /* Otherwise, we could also be looking for an ordinary identifier.  */</span>
<span class="lineNum">   14730 </span>            :   cp_parser_parse_tentatively (parser);
<span class="lineNum">   14731 </span>            :   if (cp_lexer_next_token_is_decltype (parser-&gt;lexer))
<span class="lineNum">   14732 </span><span class="lineCov">     866129 :     /* Try a decltype-specifier.  */</span>
<span class="lineNum">   14733 </span><span class="lineCov">    1732258 :     id = cp_parser_decltype (parser);</span>
<span class="lineNum">   14734 </span>            :   else
<span class="lineNum">   14735 </span>            :     /* Otherwise, try a class-name.  */
<span class="lineNum">   14736 </span>            :     id = cp_parser_class_name (parser,
<span class="lineNum">   14737 </span>            :                                /*typename_keyword_p=*/true,
<span class="lineNum">   14738 </span>            :                                /*template_keyword_p=*/false,
<span class="lineNum">   14739 </span>            :                                none_type,
<span class="lineNum">   14740 </span>            :                                /*check_dependency_p=*/true,
<span class="lineNum">   14741 </span>            :                                /*class_head_p=*/false,
<span class="lineNum">   14742 </span>            :                                /*is_declaration=*/true);
<span class="lineNum">   14743 </span>            :   /* If we found one, we're done.  */
<span class="lineNum">   14744 </span>            :   if (cp_parser_parse_definitely (parser))
<span class="lineNum">   14745 </span>            :     return id;
<span class="lineNum">   14746 </span>            :   /* Otherwise, look for an ordinary identifier.  */
<span class="lineNum">   14747 </span>            :   return cp_parser_identifier (parser);
<span class="lineNum">   14748 </span><span class="lineCov">     866129 : }</span>
<span class="lineNum">   14749 </span><span class="lineCov">     866129 : </span>
<span class="lineNum">   14750 </span>            : /* Overloading [gram.over] */
<span class="lineNum">   14751 </span>            : 
<span class="lineNum">   14752 </span>            : /* Parse an operator-function-id.
<span class="lineNum">   14753 </span>            : 
<span class="lineNum">   14754 </span>            :    operator-function-id:
<span class="lineNum">   14755 </span><span class="lineCov">     866129 :      operator operator</span>
<span class="lineNum">   14756 </span><span class="lineCov">       6667 : </span>
<span class="lineNum">   14757 </span>            :    Returns an IDENTIFIER_NODE for the operator which is a
<span class="lineNum">   14758 </span>            :    human-readable spelling of the identifier, e.g., `operator +'.  */
<a name="14759"><span class="lineNum">   14759 </span><span class="lineCov">     866129 : </span></a>
<span class="lineNum">   14760 </span><span class="lineCov">       6667 : static cp_expr</span>
<span class="lineNum">   14761 </span>            : cp_parser_operator_function_id (cp_parser* parser)
<span class="lineNum">   14762 </span>            : {
<span class="lineNum">   14763 </span>            :   /* Look for the `operator' keyword.  */
<span class="lineNum">   14764 </span>            :   if (!cp_parser_require_keyword (parser, RID_OPERATOR, RT_OPERATOR))
<span class="lineNum">   14765 </span>            :     return error_mark_node;
<span class="lineNum">   14766 </span><span class="lineCov">       6667 :   /* And then the name of the operator itself.  */</span>
<span class="lineNum">   14767 </span>            :   return cp_parser_operator (parser);
<span class="lineNum">   14768 </span><span class="lineCov">     859462 : }</span>
<span class="lineNum">   14769 </span><span class="lineCov">     859462 : </span>
<span class="lineNum">   14770 </span>            : /* Return an identifier node for a user-defined literal operator.
<span class="lineNum">   14771 </span><span class="lineCov">          4 :    The suffix identifier is chained to the operator name identifier.  */</span>
<a name="14772"><span class="lineNum">   14772 </span>            : </a>
<span class="lineNum">   14773 </span>            : tree
<span class="lineNum">   14774 </span><span class="lineCov">     859458 : cp_literal_operator_id (const char* name)</span>
<span class="lineNum">   14775 </span>            : {
<span class="lineNum">   14776 </span>            :   tree identifier;
<span class="lineNum">   14777 </span>            :   char *buffer = XNEWVEC (char, strlen (UDLIT_OP_ANSI_PREFIX)
<span class="lineNum">   14778 </span>            :                               + strlen (name) + 10);
<span class="lineNum">   14779 </span>            :   sprintf (buffer, UDLIT_OP_ANSI_FORMAT, name);
<span class="lineNum">   14780 </span>            :   identifier = get_identifier (buffer);
<span class="lineNum">   14781 </span>            : 
<span class="lineNum">   14782 </span><span class="lineCov">     859462 :   return identifier;</span>
<span class="lineNum">   14783 </span>            : }
<span class="lineNum">   14784 </span>            : 
<span class="lineNum">   14785 </span><span class="lineCov">     601442 : /* Parse an operator.</span>
<span class="lineNum">   14786 </span>            : 
<span class="lineNum">   14787 </span>            :    operator:
<span class="lineNum">   14788 </span>            :      new delete new[] delete[] + - * / % ^ &amp; | ~ ! = &lt; &gt;
<span class="lineNum">   14789 </span>            :      += -= *= /= %= ^= &amp;= |= &lt;&lt; &gt;&gt; &gt;&gt;= &lt;&lt;= == != &lt;= &gt;= &amp;&amp;
<span class="lineNum">   14790 </span>            :      || ++ -- , -&gt;* -&gt; () []
<span class="lineNum">   14791 </span>            : 
<span class="lineNum">   14792 </span>            :    GNU Extensions:
<span class="lineNum">   14793 </span>            : 
<span class="lineNum">   14794 </span>            :    operator:
<span class="lineNum">   14795 </span>            :      &lt;? &gt;? &lt;?= &gt;?=
<span class="lineNum">   14796 </span>            : 
<span class="lineNum">   14797 </span>            :    Returns an IDENTIFIER_NODE for the operator which is a
<span class="lineNum">   14798 </span>            :    human-readable spelling of the identifier, e.g., `operator +'.  */
<a name="14799"><span class="lineNum">   14799 </span><span class="lineCov">    2969623 : </span></a>
<span class="lineNum">   14800 </span>            : static cp_expr
<span class="lineNum">   14801 </span>            : cp_parser_operator (cp_parser* parser)
<span class="lineNum">   14802 </span><span class="lineCov">    2969623 : {</span>
<span class="lineNum">   14803 </span><span class="lineNoCov">          0 :   tree id = NULL_TREE;</span>
<span class="lineNum">   14804 </span>            :   cp_token *token;
<span class="lineNum">   14805 </span><span class="lineCov">    2969623 :   bool utf8 = false;</span>
<span class="lineNum">   14806 </span>            : 
<span class="lineNum">   14807 </span>            :   /* Peek at the next token.  */
<span class="lineNum">   14808 </span>            :   token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   14809 </span>            : 
<span class="lineNum">   14810 </span>            :   location_t start_loc = token-&gt;location;
<span class="lineNum">   14811 </span>            : 
<span class="lineNum">   14812 </span><span class="lineCov">      58235 :   /* Figure out which operator we have.  */</span>
<span class="lineNum">   14813 </span>            :   enum tree_code op = ERROR_MARK;
<span class="lineNum">   14814 </span><span class="lineCov">      58235 :   bool assop = false;</span>
<span class="lineNum">   14815 </span><span class="lineCov">      58235 :   bool consumed = false;</span>
<span class="lineNum">   14816 </span>            :   switch (token-&gt;type)
<span class="lineNum">   14817 </span><span class="lineCov">      58235 :     {</span>
<span class="lineNum">   14818 </span><span class="lineCov">      58235 :     case CPP_KEYWORD:</span>
<span class="lineNum">   14819 </span>            :       {
<span class="lineNum">   14820 </span><span class="lineCov">      58235 :         /* The keyword should be either `new' or `delete'.  */</span>
<span class="lineNum">   14821 </span>            :         if (token-&gt;keyword == RID_NEW)
<span class="lineNum">   14822 </span>            :           op = NEW_EXPR;
<span class="lineNum">   14823 </span>            :         else if (token-&gt;keyword == RID_DELETE)
<span class="lineNum">   14824 </span>            :           op = DELETE_EXPR;
<span class="lineNum">   14825 </span>            :         else
<span class="lineNum">   14826 </span>            :           break;
<span class="lineNum">   14827 </span>            : 
<span class="lineNum">   14828 </span>            :         /* Consume the `new' or `delete' token.  */
<span class="lineNum">   14829 </span>            :         location_t end_loc = cp_lexer_consume_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">   14830 </span>            : 
<span class="lineNum">   14831 </span>            :         /* Peek at the next token.  */
<span class="lineNum">   14832 </span>            :         token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   14833 </span>            :         /* If it's a `[' token then this is the array variant of the
<span class="lineNum">   14834 </span>            :            operator.  */
<span class="lineNum">   14835 </span>            :         if (token-&gt;type == CPP_OPEN_SQUARE)
<span class="lineNum">   14836 </span>            :           {
<span class="lineNum">   14837 </span>            :             /* Consume the `[' token.  */
<span class="lineNum">   14838 </span>            :             cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   14839 </span><span class="lineCov">    2969623 :             /* Look for the `]' token.  */</span>
<span class="lineNum">   14840 </span>            :             if (cp_token *close_token
<span class="lineNum">   14841 </span><span class="lineCov">    2969623 :                 = cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE))</span>
<span class="lineNum">   14842 </span><span class="lineCov">    2969623 :               end_loc = close_token-&gt;location;</span>
<span class="lineNum">   14843 </span><span class="lineCov">    2969623 :             op = op == NEW_EXPR ? VEC_NEW_EXPR : VEC_DELETE_EXPR;</span>
<span class="lineNum">   14844 </span>            :           }
<span class="lineNum">   14845 </span>            :         start_loc = make_location (start_loc, start_loc, end_loc);
<span class="lineNum">   14846 </span><span class="lineCov">    5939246 :         consumed = true;</span>
<span class="lineNum">   14847 </span>            :         break;
<span class="lineNum">   14848 </span><span class="lineCov">    2969623 :       }</span>
<span class="lineNum">   14849 </span>            : 
<span class="lineNum">   14850 </span>            :     case CPP_PLUS:
<span class="lineNum">   14851 </span><span class="lineCov">    2969623 :       op = PLUS_EXPR;</span>
<span class="lineNum">   14852 </span><span class="lineCov">    2969623 :       break;</span>
<span class="lineNum">   14853 </span><span class="lineCov">    2969623 : </span>
<span class="lineNum">   14854 </span><span class="lineCov">    2969623 :     case CPP_MINUS:</span>
<span class="lineNum">   14855 </span>            :       op = MINUS_EXPR;
<span class="lineNum">   14856 </span><span class="lineCov">     167553 :       break;</span>
<span class="lineNum">   14857 </span><span class="lineCov">     167553 : </span>
<span class="lineNum">   14858 </span>            :     case CPP_MULT:
<span class="lineNum">   14859 </span><span class="lineCov">     167553 :       op = MULT_EXPR;</span>
<span class="lineNum">   14860 </span>            :       break;
<span class="lineNum">   14861 </span><span class="lineCov">     121485 : </span>
<span class="lineNum">   14862 </span>            :     case CPP_DIV:
<span class="lineNum">   14863 </span>            :       op = TRUNC_DIV_EXPR;
<span class="lineNum">   14864 </span>            :       break;
<span class="lineNum">   14865 </span>            : 
<span class="lineNum">   14866 </span>            :     case CPP_MOD:
<span class="lineNum">   14867 </span><span class="lineCov">     102538 :       op = TRUNC_MOD_EXPR;</span>
<span class="lineNum">   14868 </span>            :       break;
<span class="lineNum">   14869 </span>            : 
<span class="lineNum">   14870 </span><span class="lineCov">     205076 :     case CPP_XOR:</span>
<span class="lineNum">   14871 </span>            :       op = BIT_XOR_EXPR;
<span class="lineNum">   14872 </span>            :       break;
<span class="lineNum">   14873 </span><span class="lineCov">     102538 : </span>
<span class="lineNum">   14874 </span>            :     case CPP_AND:
<span class="lineNum">   14875 </span>            :       op = BIT_AND_EXPR;
<span class="lineNum">   14876 </span><span class="lineCov">      35993 :       break;</span>
<span class="lineNum">   14877 </span>            : 
<span class="lineNum">   14878 </span><span class="lineCov">      71986 :     case CPP_OR:</span>
<span class="lineNum">   14879 </span><span class="lineCov">      35993 :       op = BIT_IOR_EXPR;</span>
<span class="lineNum">   14880 </span><span class="lineCov">      35979 :       break;</span>
<span class="lineNum">   14881 </span><span class="lineCov">      35993 : </span>
<span class="lineNum">   14882 </span>            :     case CPP_COMPL:
<span class="lineNum">   14883 </span><span class="lineCov">     102538 :       op = BIT_NOT_EXPR;</span>
<span class="lineNum">   14884 </span><span class="lineCov">     102538 :       break;</span>
<span class="lineNum">   14885 </span><span class="lineCov">     102538 : </span>
<span class="lineNum">   14886 </span>            :     case CPP_NOT:
<span class="lineNum">   14887 </span>            :       op = TRUTH_NOT_EXPR;
<span class="lineNum">   14888 </span><span class="lineCov">     107678 :       break;</span>
<span class="lineNum">   14889 </span><span class="lineCov">     107678 : </span>
<span class="lineNum">   14890 </span><span class="lineCov">     107678 :     case CPP_EQ:</span>
<span class="lineNum">   14891 </span>            :       assop = true;
<span class="lineNum">   14892 </span><span class="lineCov">      63443 :       op = NOP_EXPR;</span>
<span class="lineNum">   14893 </span><span class="lineCov">      63443 :       break;</span>
<span class="lineNum">   14894 </span><span class="lineCov">      63443 : </span>
<span class="lineNum">   14895 </span>            :     case CPP_LESS:
<span class="lineNum">   14896 </span><span class="lineCov">      64216 :       op = LT_EXPR;</span>
<span class="lineNum">   14897 </span><span class="lineCov">      64216 :       break;</span>
<span class="lineNum">   14898 </span><span class="lineCov">      64216 : </span>
<span class="lineNum">   14899 </span>            :     case CPP_GREATER:
<span class="lineNum">   14900 </span><span class="lineCov">       7752 :       op = GT_EXPR;</span>
<span class="lineNum">   14901 </span><span class="lineCov">       7752 :       break;</span>
<span class="lineNum">   14902 </span><span class="lineCov">       7752 : </span>
<span class="lineNum">   14903 </span>            :     case CPP_PLUS_EQ:
<span class="lineNum">   14904 </span><span class="lineCov">       2782 :       assop = true;</span>
<span class="lineNum">   14905 </span><span class="lineCov">       2782 :       op = PLUS_EXPR;</span>
<span class="lineNum">   14906 </span><span class="lineCov">       2782 :       break;</span>
<span class="lineNum">   14907 </span>            : 
<span class="lineNum">   14908 </span><span class="lineCov">       8412 :     case CPP_MINUS_EQ:</span>
<span class="lineNum">   14909 </span><span class="lineCov">       8412 :       assop = true;</span>
<span class="lineNum">   14910 </span><span class="lineCov">       8412 :       op = MINUS_EXPR;</span>
<span class="lineNum">   14911 </span>            :       break;
<span class="lineNum">   14912 </span><span class="lineCov">      10252 : </span>
<span class="lineNum">   14913 </span><span class="lineCov">      10252 :     case CPP_MULT_EQ:</span>
<span class="lineNum">   14914 </span><span class="lineCov">      10252 :       assop = true;</span>
<span class="lineNum">   14915 </span>            :       op = MULT_EXPR;
<span class="lineNum">   14916 </span><span class="lineCov">       9024 :       break;</span>
<span class="lineNum">   14917 </span><span class="lineCov">       9024 : </span>
<span class="lineNum">   14918 </span><span class="lineCov">       9024 :     case CPP_DIV_EQ:</span>
<span class="lineNum">   14919 </span>            :       assop = true;
<span class="lineNum">   14920 </span><span class="lineCov">       8138 :       op = TRUNC_DIV_EXPR;</span>
<span class="lineNum">   14921 </span><span class="lineCov">       8138 :       break;</span>
<span class="lineNum">   14922 </span><span class="lineCov">       8138 : </span>
<span class="lineNum">   14923 </span>            :     case CPP_MOD_EQ:
<span class="lineNum">   14924 </span><span class="lineCov">       2112 :       assop = true;</span>
<span class="lineNum">   14925 </span><span class="lineCov">       2112 :       op = TRUNC_MOD_EXPR;</span>
<span class="lineNum">   14926 </span><span class="lineCov">       2112 :       break;</span>
<span class="lineNum">   14927 </span>            : 
<span class="lineNum">   14928 </span><span class="lineCov">     478414 :     case CPP_XOR_EQ:</span>
<span class="lineNum">   14929 </span><span class="lineCov">     478414 :       assop = true;</span>
<span class="lineNum">   14930 </span><span class="lineCov">     478414 :       op = BIT_XOR_EXPR;</span>
<span class="lineNum">   14931 </span><span class="lineCov">     478414 :       break;</span>
<span class="lineNum">   14932 </span>            : 
<span class="lineNum">   14933 </span><span class="lineCov">     115485 :     case CPP_AND_EQ:</span>
<span class="lineNum">   14934 </span><span class="lineCov">     115485 :       assop = true;</span>
<span class="lineNum">   14935 </span><span class="lineCov">     115485 :       op = BIT_AND_EXPR;</span>
<span class="lineNum">   14936 </span>            :       break;
<span class="lineNum">   14937 </span><span class="lineCov">      93528 : </span>
<span class="lineNum">   14938 </span><span class="lineCov">      93528 :     case CPP_OR_EQ:</span>
<span class="lineNum">   14939 </span><span class="lineCov">      93528 :       assop = true;</span>
<span class="lineNum">   14940 </span>            :       op = BIT_IOR_EXPR;
<span class="lineNum">   14941 </span><span class="lineCov">      59103 :       break;</span>
<span class="lineNum">   14942 </span><span class="lineCov">      59103 : </span>
<span class="lineNum">   14943 </span><span class="lineCov">      59103 :     case CPP_LSHIFT:</span>
<span class="lineNum">   14944 </span><span class="lineCov">      59103 :       op = LSHIFT_EXPR;</span>
<span class="lineNum">   14945 </span>            :       break;
<span class="lineNum">   14946 </span><span class="lineCov">      37762 : </span>
<span class="lineNum">   14947 </span><span class="lineCov">      37762 :     case CPP_RSHIFT:</span>
<span class="lineNum">   14948 </span><span class="lineCov">      37762 :       op = RSHIFT_EXPR;</span>
<span class="lineNum">   14949 </span><span class="lineCov">      37762 :       break;</span>
<span class="lineNum">   14950 </span>            : 
<span class="lineNum">   14951 </span><span class="lineCov">       7480 :     case CPP_LSHIFT_EQ:</span>
<span class="lineNum">   14952 </span><span class="lineCov">       7480 :       assop = true;</span>
<span class="lineNum">   14953 </span><span class="lineCov">       7480 :       op = LSHIFT_EXPR;</span>
<span class="lineNum">   14954 </span><span class="lineCov">       7480 :       break;</span>
<span class="lineNum">   14955 </span>            : 
<span class="lineNum">   14956 </span><span class="lineCov">       8978 :     case CPP_RSHIFT_EQ:</span>
<span class="lineNum">   14957 </span><span class="lineCov">       8978 :       assop = true;</span>
<span class="lineNum">   14958 </span><span class="lineCov">       8978 :       op = RSHIFT_EXPR;</span>
<span class="lineNum">   14959 </span><span class="lineCov">       8978 :       break;</span>
<span class="lineNum">   14960 </span>            : 
<span class="lineNum">   14961 </span><span class="lineCov">       4088 :     case CPP_EQ_EQ:</span>
<span class="lineNum">   14962 </span><span class="lineCov">       4088 :       op = EQ_EXPR;</span>
<span class="lineNum">   14963 </span><span class="lineCov">       4088 :       break;</span>
<span class="lineNum">   14964 </span><span class="lineCov">       4088 : </span>
<span class="lineNum">   14965 </span>            :     case CPP_NOT_EQ:
<span class="lineNum">   14966 </span><span class="lineCov">      11282 :       op = NE_EXPR;</span>
<span class="lineNum">   14967 </span><span class="lineCov">      11282 :       break;</span>
<span class="lineNum">   14968 </span><span class="lineCov">      11282 : </span>
<span class="lineNum">   14969 </span><span class="lineCov">      11282 :     case CPP_LESS_EQ:</span>
<span class="lineNum">   14970 </span>            :       op = LE_EXPR;
<span class="lineNum">   14971 </span><span class="lineCov">      11264 :       break;</span>
<span class="lineNum">   14972 </span><span class="lineCov">      11264 : </span>
<span class="lineNum">   14973 </span><span class="lineCov">      11264 :     case CPP_GREATER_EQ:</span>
<span class="lineNum">   14974 </span><span class="lineCov">      11264 :       op = GE_EXPR;</span>
<span class="lineNum">   14975 </span>            :       break;
<span class="lineNum">   14976 </span><span class="lineCov">      11266 : </span>
<span class="lineNum">   14977 </span><span class="lineCov">      11266 :     case CPP_AND_AND:</span>
<span class="lineNum">   14978 </span><span class="lineCov">      11266 :       op = TRUTH_ANDIF_EXPR;</span>
<span class="lineNum">   14979 </span><span class="lineCov">      11266 :       break;</span>
<span class="lineNum">   14980 </span>            : 
<span class="lineNum">   14981 </span><span class="lineCov">     111159 :     case CPP_OR_OR:</span>
<span class="lineNum">   14982 </span><span class="lineCov">     111159 :       op = TRUTH_ORIF_EXPR;</span>
<span class="lineNum">   14983 </span><span class="lineCov">     111159 :       break;</span>
<span class="lineNum">   14984 </span>            : 
<span class="lineNum">   14985 </span><span class="lineCov">     106294 :     case CPP_PLUS_PLUS:</span>
<span class="lineNum">   14986 </span><span class="lineCov">     106294 :       op = POSTINCREMENT_EXPR;</span>
<span class="lineNum">   14987 </span><span class="lineCov">     106294 :       break;</span>
<span class="lineNum">   14988 </span>            : 
<span class="lineNum">   14989 </span><span class="lineCov">       2534 :     case CPP_MINUS_MINUS:</span>
<span class="lineNum">   14990 </span><span class="lineCov">       2534 :       op = PREDECREMENT_EXPR;</span>
<span class="lineNum">   14991 </span><span class="lineCov">       2534 :       break;</span>
<span class="lineNum">   14992 </span><span class="lineCov">       2534 : </span>
<span class="lineNum">   14993 </span>            :     case CPP_COMMA:
<span class="lineNum">   14994 </span><span class="lineCov">       2518 :       op = COMPOUND_EXPR;</span>
<span class="lineNum">   14995 </span><span class="lineCov">       2518 :       break;</span>
<span class="lineNum">   14996 </span><span class="lineCov">       2518 : </span>
<span class="lineNum">   14997 </span><span class="lineCov">       2518 :     case CPP_DEREF_STAR:</span>
<span class="lineNum">   14998 </span>            :       op = MEMBER_REF;
<span class="lineNum">   14999 </span><span class="lineCov">     190971 :       break;</span>
<span class="lineNum">   15000 </span><span class="lineCov">     190971 : </span>
<span class="lineNum">   15001 </span><span class="lineCov">     190971 :     case CPP_DEREF:</span>
<span class="lineNum">   15002 </span>            :       op = COMPONENT_REF;
<span class="lineNum">   15003 </span><span class="lineCov">     152944 :       break;</span>
<span class="lineNum">   15004 </span><span class="lineCov">     152944 : </span>
<span class="lineNum">   15005 </span><span class="lineCov">     152944 :     case CPP_OPEN_PAREN:</span>
<span class="lineNum">   15006 </span>            :       {
<span class="lineNum">   15007 </span><span class="lineCov">      91514 :         /* Consume the `('.  */</span>
<span class="lineNum">   15008 </span><span class="lineCov">      91514 :         matching_parens parens;</span>
<span class="lineNum">   15009 </span><span class="lineCov">      91514 :         parens.consume_open (parser);</span>
<span class="lineNum">   15010 </span>            :         /* Look for the matching `)'.  */
<span class="lineNum">   15011 </span><span class="lineCov">      95462 :         parens.require_close (parser);</span>
<span class="lineNum">   15012 </span><span class="lineCov">      95462 :         op = CALL_EXPR;</span>
<span class="lineNum">   15013 </span><span class="lineCov">      95462 :         consumed = true;</span>
<span class="lineNum">   15014 </span>            :         break;
<span class="lineNum">   15015 </span><span class="lineCov">        890 :       }</span>
<span class="lineNum">   15016 </span><span class="lineCov">        890 : </span>
<span class="lineNum">   15017 </span><span class="lineCov">        890 :     case CPP_OPEN_SQUARE:</span>
<span class="lineNum">   15018 </span>            :       /* Consume the `['.  */
<span class="lineNum">   15019 </span><span class="lineCov">        880 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   15020 </span><span class="lineCov">        880 :       /* Look for the matching `]'.  */</span>
<span class="lineNum">   15021 </span><span class="lineCov">        880 :       cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);</span>
<span class="lineNum">   15022 </span>            :       op = ARRAY_REF;
<span class="lineNum">   15023 </span><span class="lineCov">     111632 :       consumed = true;</span>
<span class="lineNum">   15024 </span><span class="lineCov">     111632 :       break;</span>
<span class="lineNum">   15025 </span><span class="lineCov">     111632 : </span>
<span class="lineNum">   15026 </span>            :     case CPP_UTF8STRING:
<span class="lineNum">   15027 </span><span class="lineCov">      50992 :     case CPP_UTF8STRING_USERDEF:</span>
<span class="lineNum">   15028 </span><span class="lineCov">      50992 :       utf8 = true;</span>
<span class="lineNum">   15029 </span><span class="lineCov">      50992 :       /* FALLTHRU */</span>
<span class="lineNum">   15030 </span>            :     case CPP_STRING:
<span class="lineNum">   15031 </span><span class="lineCov">       1620 :     case CPP_WSTRING:</span>
<span class="lineNum">   15032 </span><span class="lineCov">       1620 :     case CPP_STRING16:</span>
<span class="lineNum">   15033 </span><span class="lineCov">       1620 :     case CPP_STRING32:</span>
<span class="lineNum">   15034 </span>            :     case CPP_STRING_USERDEF:
<span class="lineNum">   15035 </span><span class="lineCov">         22 :     case CPP_WSTRING_USERDEF:</span>
<span class="lineNum">   15036 </span><span class="lineCov">         22 :     case CPP_STRING16_USERDEF:</span>
<span class="lineNum">   15037 </span><span class="lineCov">         22 :     case CPP_STRING32_USERDEF:</span>
<span class="lineNum">   15038 </span>            :       {
<span class="lineNum">   15039 </span><span class="lineCov">      40338 :         tree str, string_tree;</span>
<span class="lineNum">   15040 </span><span class="lineCov">      40338 :         int sz, len;</span>
<span class="lineNum">   15041 </span><span class="lineCov">      40338 : </span>
<span class="lineNum">   15042 </span>            :         if (cxx_dialect == cxx98)
<span class="lineNum">   15043 </span><span class="lineCov">     551776 :           maybe_warn_cpp0x (CPP0X_USER_DEFINED_LITERALS);</span>
<span class="lineNum">   15044 </span><span class="lineCov">     551776 : </span>
<span class="lineNum">   15045 </span>            :         /* Consume the string.  */
<span class="lineNum">   15046 </span><span class="lineCov">    1103552 :         str = cp_parser_string_literal (parser, /*translate=*/true,</span>
<span class="lineNum">   15047 </span><span class="lineCov">     551776 :                                       /*wide_ok=*/true, /*lookup_udlit=*/false);</span>
<span class="lineNum">   15048 </span>            :         if (str == error_mark_node)
<span class="lineNum">   15049 </span><span class="lineCov">     551776 :           return error_mark_node;</span>
<span class="lineNum">   15050 </span><span class="lineCov">     551776 :         else if (TREE_CODE (str) == USERDEF_LITERAL)</span>
<span class="lineNum">   15051 </span><span class="lineCov">     551776 :           {</span>
<span class="lineNum">   15052 </span><span class="lineCov">     551776 :             string_tree = USERDEF_LITERAL_VALUE (str);</span>
<span class="lineNum">   15053 </span>            :             id = USERDEF_LITERAL_SUFFIX_ID (str);
<span class="lineNum">   15054 </span>            :           }
<span class="lineNum">   15055 </span><span class="lineCov">      72318 :         else</span>
<span class="lineNum">   15056 </span>            :           {
<span class="lineNum">   15057 </span><span class="lineCov">      72318 :             string_tree = str;</span>
<span class="lineNum">   15058 </span>            :             /* Look for the suffix identifier.  */
<span class="lineNum">   15059 </span><span class="lineCov">      72318 :             token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   15060 </span><span class="lineCov">      72318 :             if (token-&gt;type == CPP_NAME)</span>
<span class="lineNum">   15061 </span><span class="lineCov">      72318 :               id = cp_parser_identifier (parser);</span>
<span class="lineNum">   15062 </span><span class="lineCov">      72318 :             else if (token-&gt;type == CPP_KEYWORD)</span>
<span class="lineNum">   15063 </span>            :               {
<span class="lineNum">   15064 </span><span class="lineCov">          4 :                 error (&quot;unexpected keyword;&quot;</span>
<span class="lineNum">   15065 </span><span class="lineCov">          4 :                        &quot; remove space between quotes and suffix identifier&quot;);</span>
<span class="lineNum">   15066 </span><span class="lineCov">          4 :                 return error_mark_node;</span>
<span class="lineNum">   15067 </span>            :               }
<span class="lineNum">   15068 </span><span class="lineCov">      26112 :             else</span>
<span class="lineNum">   15069 </span><span class="lineCov">      26112 :               {</span>
<span class="lineNum">   15070 </span><span class="lineCov">      26112 :                 error (&quot;expected suffix identifier&quot;);</span>
<span class="lineNum">   15071 </span><span class="lineCov">      26112 :                 return error_mark_node;</span>
<span class="lineNum">   15072 </span><span class="lineCov">      26112 :               }</span>
<span class="lineNum">   15073 </span><span class="lineCov">      26112 :           }</span>
<span class="lineNum">   15074 </span><span class="lineCov">      26112 :         sz = TREE_INT_CST_LOW (TYPE_SIZE_UNIT</span>
<span class="lineNum">   15075 </span><span class="lineCov">      26112 :                                (TREE_TYPE (TREE_TYPE (string_tree))));</span>
<span class="lineNum">   15076 </span><span class="lineCov">      26112 :         len = TREE_STRING_LENGTH (string_tree) / sz - 1;</span>
<span class="lineNum">   15077 </span><span class="lineCov">      26112 :         if (len != 0)</span>
<span class="lineNum">   15078 </span><span class="lineCov">      26112 :           {</span>
<span class="lineNum">   15079 </span>            :             error (&quot;expected empty string after %&lt;operator%&gt; keyword&quot;);
<span class="lineNum">   15080 </span><span class="lineCov">      26112 :             return error_mark_node;</span>
<span class="lineNum">   15081 </span><span class="lineCov">          4 :           }</span>
<span class="lineNum">   15082 </span>            :         if (utf8 || TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (string_tree)))
<span class="lineNum">   15083 </span>            :             != char_type_node)
<span class="lineNum">   15084 </span><span class="lineCov">      52224 :           {</span>
<span class="lineNum">   15085 </span><span class="lineCov">      26112 :             error (&quot;invalid encoding prefix in literal operator&quot;);</span>
<span class="lineNum">   15086 </span><span class="lineCov">      26112 :             return error_mark_node;</span>
<span class="lineNum">   15087 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">   15088 </span><span class="lineCov">      26112 :         if (id != error_mark_node)</span>
<span class="lineNum">   15089 </span>            :           {
<span class="lineNum">   15090 </span><span class="lineCov">      25153 :             const char *name = IDENTIFIER_POINTER (id);</span>
<span class="lineNum">   15091 </span><span class="lineCov">      50306 :             id = cp_literal_operator_id (name);</span>
<span class="lineNum">   15092 </span>            :           }
<span class="lineNum">   15093 </span>            :         return id;
<span class="lineNum">   15094 </span>            :       }
<span class="lineNum">   15095 </span><span class="lineCov">        959 : </span>
<span class="lineNum">   15096 </span>            :     default:
<span class="lineNum">   15097 </span><span class="lineCov">       1918 :       /* Anything else is an error.  */</span>
<span class="lineNum">   15098 </span><span class="lineCov">        959 :       break;</span>
<span class="lineNum">   15099 </span><span class="lineCov">        951 :     }</span>
<span class="lineNum">   15100 </span><span class="lineCov">          8 : </span>
<span class="lineNum">   15101 </span>            :   /* If we have selected an identifier, we need to consume the
<span class="lineNum">   15102 </span><span class="lineCov">          2 :      operator token.  */</span>
<span class="lineNum">   15103 </span>            :   if (op != ERROR_MARK)
<span class="lineNum">   15104 </span><span class="lineCov">          2 :     {</span>
<span class="lineNum">   15105 </span>            :       id = ovl_op_identifier (assop, op);
<span class="lineNum">   15106 </span>            :       if (!consumed)
<span class="lineNum">   15107 </span>            :         cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   15108 </span><span class="lineCov">          6 :     }</span>
<span class="lineNum">   15109 </span><span class="lineCov">          6 :   /* Otherwise, no valid operator name was present.  */</span>
<span class="lineNum">   15110 </span>            :   else
<span class="lineNum">   15111 </span>            :     {
<span class="lineNum">   15112 </span><span class="lineCov">      26104 :       cp_parser_error (parser, &quot;expected operator&quot;);</span>
<span class="lineNum">   15113 </span>            :       id = error_mark_node;
<span class="lineNum">   15114 </span><span class="lineCov">      26104 :     }</span>
<span class="lineNum">   15115 </span><span class="lineCov">      26104 : </span>
<span class="lineNum">   15116 </span>            :   return cp_expr (id, start_loc);
<span class="lineNum">   15117 </span><span class="lineCov">         11 : }</span>
<span class="lineNum">   15118 </span><span class="lineCov">         11 : </span>
<span class="lineNum">   15119 </span>            : /* Parse a template-declaration.
<span class="lineNum">   15120 </span><span class="lineCov">      26093 : </span>
<span class="lineNum">   15121 </span><span class="lineCov">      26090 :    template-declaration:</span>
<span class="lineNum">   15122 </span>            :      export [opt] template &lt; template-parameter-list &gt; declaration
<span class="lineNum">   15123 </span><span class="lineCov">         16 : </span>
<span class="lineNum">   15124 </span><span class="lineCov">         16 :    If MEMBER_P is TRUE, this template-declaration occurs within a</span>
<span class="lineNum">   15125 </span>            :    class-specifier.
<span class="lineNum">   15126 </span><span class="lineCov">      26077 : </span>
<span class="lineNum">   15127 </span>            :    The grammar rule given by the standard isn't correct.  What
<span class="lineNum">   15128 </span><span class="lineCov">      26077 :    is really meant is:</span>
<span class="lineNum">   15129 </span><span class="lineCov">      26077 : </span>
<span class="lineNum">   15130 </span>            :    template-declaration:
<span class="lineNum">   15131 </span><span class="lineCov">      26077 :      export [opt] template-parameter-list-seq</span>
<span class="lineNum">   15132 </span>            :        decl-specifier-seq [opt] init-declarator [opt] ;
<span class="lineNum">   15133 </span>            :      export [opt] template-parameter-list-seq
<span class="lineNum">   15134 </span>            :        function-definition
<span class="lineNum">   15135 </span>            : 
<span class="lineNum">   15136 </span>            :    template-parameter-list-seq:
<span class="lineNum">   15137 </span>            :      template-parameter-list-seq [opt]
<span class="lineNum">   15138 </span>            :      template &lt; template-parameter-list &gt;
<span class="lineNum">   15139 </span>            : 
<span class="lineNum">   15140 </span>            :    Concept Extensions:
<span class="lineNum">   15141 </span><span class="lineCov">    2943511 : </span>
<span class="lineNum">   15142 </span>            :    template-parameter-list-seq:
<span class="lineNum">   15143 </span><span class="lineCov">    2808861 :      template &lt; template-parameter-list &gt; requires-clause [opt]</span>
<span class="lineNum">   15144 </span><span class="lineCov">    2808861 : </span>
<span class="lineNum">   15145 </span><span class="lineCov">    2082229 :    requires-clause:</span>
<span class="lineNum">   15146 </span>            :      requires logical-or-expression  */
<a name="15147"><span class="lineNum">   15147 </span>            : </a>
<span class="lineNum">   15148 </span>            : static void
<span class="lineNum">   15149 </span>            : cp_parser_template_declaration (cp_parser* parser, bool member_p)
<span class="lineNum">   15150 </span><span class="lineCov">     134650 : {</span>
<span class="lineNum">   15151 </span><span class="lineCov">     134650 :   /* Check for `export'.  */</span>
<span class="lineNum">   15152 </span>            :   if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_EXPORT))
<span class="lineNum">   15153 </span>            :     {
<span class="lineNum">   15154 </span><span class="lineCov">    2943511 :       /* Consume the `export' token.  */</span>
<span class="lineNum">   15155 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   15156 </span>            :       /* Warn that we do not support `export'.  */
<span class="lineNum">   15157 </span>            :       warning (0, &quot;keyword %&lt;export%&gt; not implemented, and will be ignored&quot;);
<span class="lineNum">   15158 </span>            :     }
<span class="lineNum">   15159 </span>            : 
<span class="lineNum">   15160 </span>            :   cp_parser_template_declaration_after_export (parser, member_p);
<span class="lineNum">   15161 </span>            : }
<span class="lineNum">   15162 </span>            : 
<span class="lineNum">   15163 </span>            : /* Parse a template-parameter-list.
<span class="lineNum">   15164 </span>            : 
<span class="lineNum">   15165 </span>            :    template-parameter-list:
<span class="lineNum">   15166 </span>            :      template-parameter
<span class="lineNum">   15167 </span>            :      template-parameter-list , template-parameter
<span class="lineNum">   15168 </span>            : 
<span class="lineNum">   15169 </span>            :    Returns a TREE_LIST.  Each node represents a template parameter.
<span class="lineNum">   15170 </span>            :    The nodes are connected via their TREE_CHAINs.  */
<a name="15171"><span class="lineNum">   15171 </span>            : </a>
<span class="lineNum">   15172 </span>            : static tree
<span class="lineNum">   15173 </span>            : cp_parser_template_parameter_list (cp_parser* parser)
<span class="lineNum">   15174 </span>            : {
<span class="lineNum">   15175 </span>            :   tree parameter_list = NULL_TREE;
<span class="lineNum">   15176 </span>            : 
<span class="lineNum">   15177 </span>            :   begin_template_parm_list ();
<span class="lineNum">   15178 </span>            : 
<span class="lineNum">   15179 </span>            :   /* The loop below parses the template parms.  We first need to know
<span class="lineNum">   15180 </span>            :      the total number of template parms to be able to compute proper
<span class="lineNum">   15181 </span>            :      canonical types of each dependent type. So after the loop, when
<span class="lineNum">   15182 </span>            :      we know the total number of template parms,
<span class="lineNum">   15183 </span>            :      end_template_parm_list computes the proper canonical types and
<span class="lineNum">   15184 </span>            :      fixes up the dependent types accordingly.  */
<span class="lineNum">   15185 </span>            :   while (true)
<span class="lineNum">   15186 </span>            :     {
<span class="lineNum">   15187 </span><span class="lineCov">    4149427 :       tree parameter;</span>
<span class="lineNum">   15188 </span>            :       bool is_non_type;
<span class="lineNum">   15189 </span>            :       bool is_parameter_pack;
<span class="lineNum">   15190 </span><span class="lineCov">    4149427 :       location_t parm_loc;</span>
<span class="lineNum">   15191 </span>            : 
<span class="lineNum">   15192 </span>            :       /* Parse the template-parameter.  */
<span class="lineNum">   15193 </span><span class="lineCov">         18 :       parm_loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;</span>
<span class="lineNum">   15194 </span>            :       parameter = cp_parser_template_parameter (parser, 
<span class="lineNum">   15195 </span><span class="lineCov">         18 :                                                 &amp;is_non_type,</span>
<span class="lineNum">   15196 </span>            :                                                 &amp;is_parameter_pack);
<span class="lineNum">   15197 </span>            :       /* Add it to the list.  */
<span class="lineNum">   15198 </span><span class="lineCov">    4149427 :       if (parameter != error_mark_node)</span>
<span class="lineNum">   15199 </span><span class="lineCov">    4149423 :         parameter_list = process_template_parm (parameter_list,</span>
<span class="lineNum">   15200 </span>            :                                                 parm_loc,
<span class="lineNum">   15201 </span>            :                                                 parameter,
<span class="lineNum">   15202 </span>            :                                                 is_non_type,
<span class="lineNum">   15203 </span>            :                                                 is_parameter_pack);
<span class="lineNum">   15204 </span>            :       else
<span class="lineNum">   15205 </span>            :        {
<span class="lineNum">   15206 </span>            :          tree err_parm = build_tree_list (parameter, parameter);
<span class="lineNum">   15207 </span>            :          parameter_list = chainon (parameter_list, err_parm);
<span class="lineNum">   15208 </span>            :        }
<span class="lineNum">   15209 </span>            : 
<span class="lineNum">   15210 </span>            :       /* If the next token is not a `,', we're done.  */
<span class="lineNum">   15211 </span><span class="lineCov">    4231242 :       if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_COMMA))</span>
<span class="lineNum">   15212 </span>            :         break;
<span class="lineNum">   15213 </span><span class="lineCov">    4231242 :       /* Otherwise, consume the `,' token.  */</span>
<span class="lineNum">   15214 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   15215 </span><span class="lineCov">    4231242 :     }</span>
<span class="lineNum">   15216 </span>            : 
<span class="lineNum">   15217 </span>            :   return end_template_parm_list (parameter_list);
<span class="lineNum">   15218 </span>            : }
<span class="lineNum">   15219 </span>            : 
<span class="lineNum">   15220 </span>            : /* Parse a introduction-list.
<span class="lineNum">   15221 </span>            : 
<span class="lineNum">   15222 </span>            :    introduction-list:
<span class="lineNum">   15223 </span><span class="lineCov">    7793899 :      introduced-parameter</span>
<span class="lineNum">   15224 </span>            :      introduction-list , introduced-parameter
<span class="lineNum">   15225 </span><span class="lineCov">    7793899 : </span>
<span class="lineNum">   15226 </span><span class="lineCov">    7793899 :    introduced-parameter:</span>
<span class="lineNum">   15227 </span><span class="lineCov">    7793899 :      ...[opt] identifier</span>
<span class="lineNum">   15228 </span><span class="lineCov">    7793899 : </span>
<span class="lineNum">   15229 </span>            :    Returns a TREE_VEC of WILDCARD_DECLs.  If the parameter is a pack
<span class="lineNum">   15230 </span>            :    then the introduced parm will have WILDCARD_PACK_P set.  In addition, the
<span class="lineNum">   15231 </span><span class="lineCov">   15587798 :    WILDCARD_DECL will also have DECL_NAME set and token location in</span>
<span class="lineNum">   15232 </span><span class="lineCov">    7793899 :    DECL_SOURCE_LOCATION.  */</span>
<a name="15233"><span class="lineNum">   15233 </span>            : </a>
<span class="lineNum">   15234 </span>            : static tree
<span class="lineNum">   15235 </span>            : cp_parser_introduction_list (cp_parser *parser)
<span class="lineNum">   15236 </span><span class="lineCov">    7793899 : {</span>
<span class="lineNum">   15237 </span><span class="lineCov">    7793815 :   vec&lt;tree, va_gc&gt; *introduction_vec = make_tree_vector ();</span>
<span class="lineNum">   15238 </span>            : 
<span class="lineNum">   15239 </span>            :   while (true)
<span class="lineNum">   15240 </span>            :     {
<span class="lineNum">   15241 </span>            :       bool is_pack = cp_lexer_next_token_is (parser-&gt;lexer, CPP_ELLIPSIS);
<span class="lineNum">   15242 </span>            :       if (is_pack)
<span class="lineNum">   15243 </span>            :         cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   15244 </span><span class="lineCov">         84 : </span>
<span class="lineNum">   15245 </span><span class="lineCov">         84 :       tree identifier = cp_parser_identifier (parser);</span>
<span class="lineNum">   15246 </span>            :       if (identifier == error_mark_node)
<span class="lineNum">   15247 </span>            :         break;
<span class="lineNum">   15248 </span>            : 
<span class="lineNum">   15249 </span><span class="lineCov">    7793899 :       /* Build placeholder. */</span>
<span class="lineNum">   15250 </span>            :       tree parm = build_nt (WILDCARD_DECL);
<span class="lineNum">   15251 </span>            :       DECL_SOURCE_LOCATION (parm)
<span class="lineNum">   15252 </span><span class="lineCov">    3562657 :         = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;</span>
<span class="lineNum">   15253 </span><span class="lineCov">    3562657 :       DECL_NAME (parm) = identifier;</span>
<span class="lineNum">   15254 </span>            :       WILDCARD_PACK_P (parm) = is_pack;
<span class="lineNum">   15255 </span><span class="lineCov">    4231242 :       vec_safe_push (introduction_vec, parm);</span>
<span class="lineNum">   15256 </span>            : 
<span class="lineNum">   15257 </span>            :       /* If the next token is not a `,', we're done.  */
<span class="lineNum">   15258 </span>            :       if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_COMMA))
<span class="lineNum">   15259 </span>            :         break;
<span class="lineNum">   15260 </span>            :       /* Otherwise, consume the `,' token.  */
<span class="lineNum">   15261 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   15262 </span>            :     }
<span class="lineNum">   15263 </span>            : 
<span class="lineNum">   15264 </span>            :   /* Convert the vec into a TREE_VEC.  */
<span class="lineNum">   15265 </span>            :   tree introduction_list = make_tree_vec (introduction_vec-&gt;length ());
<span class="lineNum">   15266 </span>            :   unsigned int n;
<span class="lineNum">   15267 </span>            :   tree parm;
<span class="lineNum">   15268 </span>            :   FOR_EACH_VEC_ELT (*introduction_vec, n, parm)
<span class="lineNum">   15269 </span>            :     TREE_VEC_ELT (introduction_list, n) = parm;
<span class="lineNum">   15270 </span>            : 
<span class="lineNum">   15271 </span>            :   release_tree_vector (introduction_vec);
<span class="lineNum">   15272 </span>            :   return introduction_list;
<span class="lineNum">   15273 </span><span class="lineCov">         25 : }</span>
<span class="lineNum">   15274 </span>            : 
<span class="lineNum">   15275 </span><span class="lineCov">         25 : /* Given a declarator, get the declarator-id part, or NULL_TREE if this</span>
<span class="lineNum">   15276 </span>            :    is an abstract declarator. */
<span class="lineNum">   15277 </span><span class="lineCov">         30 : </span>
<span class="lineNum">   15278 </span>            : static inline cp_declarator*
<span class="lineNum">   15279 </span><span class="lineCov">         60 : get_id_declarator (cp_declarator *declarator)</span>
<span class="lineNum">   15280 </span><span class="lineCov">         30 : {</span>
<span class="lineNum">   15281 </span><span class="lineCov">          5 :   cp_declarator *d = declarator;</span>
<span class="lineNum">   15282 </span>            :   while (d &amp;&amp; d-&gt;kind != cdk_id)
<span class="lineNum">   15283 </span><span class="lineCov">         30 :     d = d-&gt;declarator;</span>
<span class="lineNum">   15284 </span><span class="lineCov">         30 :   return d;</span>
<span class="lineNum">   15285 </span>            : }
<span class="lineNum">   15286 </span>            : 
<span class="lineNum">   15287 </span>            : /* Get the unqualified-id from the DECLARATOR or NULL_TREE if this
<span class="lineNum">   15288 </span><span class="lineCov">         29 :    is an abstract declarator. */</span>
<span class="lineNum">   15289 </span><span class="lineCov">         87 : </span>
<span class="lineNum">   15290 </span><span class="lineCov">         29 : static inline tree</span>
<span class="lineNum">   15291 </span><span class="lineCov">         29 : get_unqualified_id (cp_declarator *declarator)</span>
<span class="lineNum">   15292 </span><span class="lineCov">         29 : {</span>
<span class="lineNum">   15293 </span><span class="lineCov">         29 :   declarator = get_id_declarator (declarator);</span>
<span class="lineNum">   15294 </span>            :   if (declarator)
<span class="lineNum">   15295 </span>            :     return declarator-&gt;u.id.unqualified_name;
<span class="lineNum">   15296 </span><span class="lineCov">         29 :   else</span>
<span class="lineNum">   15297 </span>            :     return NULL_TREE;
<span class="lineNum">   15298 </span>            : }
<span class="lineNum">   15299 </span><span class="lineCov">          5 : </span>
<span class="lineNum">   15300 </span><span class="lineCov">          5 : /* Returns true if DECL represents a constrained-parameter.  */</span>
<a name="15301"><span class="lineNum">   15301 </span>            : </a>
<span class="lineNum">   15302 </span>            : static inline bool
<span class="lineNum">   15303 </span><span class="lineCov">         25 : is_constrained_parameter (tree decl)</span>
<span class="lineNum">   15304 </span><span class="lineCov">         25 : {</span>
<span class="lineNum">   15305 </span><span class="lineCov">         25 :   return (decl</span>
<span class="lineNum">   15306 </span><span class="lineCov">         54 :           &amp;&amp; TREE_CODE (decl) == TYPE_DECL</span>
<span class="lineNum">   15307 </span><span class="lineCov">         29 :           &amp;&amp; CONSTRAINED_PARM_CONCEPT (decl)</span>
<span class="lineNum">   15308 </span>            :           &amp;&amp; DECL_P (CONSTRAINED_PARM_CONCEPT (decl)));
<span class="lineNum">   15309 </span><span class="lineCov">         25 : }</span>
<span class="lineNum">   15310 </span><span class="lineCov">         25 : </span>
<span class="lineNum">   15311 </span>            : /* Returns true if PARM declares a constrained-parameter. */
<a name="15312"><span class="lineNum">   15312 </span>            : </a>
<span class="lineNum">   15313 </span>            : static inline bool
<span class="lineNum">   15314 </span>            : is_constrained_parameter (cp_parameter_declarator *parm)
<span class="lineNum">   15315 </span>            : {
<span class="lineNum">   15316 </span>            :   return is_constrained_parameter (parm-&gt;decl_specifiers.type);
<span class="lineNum">   15317 </span>            : }
<span class="lineNum">   15318 </span>            : 
<span class="lineNum">   15319 </span><span class="lineCov">        193 : /* Check that the type parameter is only a declarator-id, and that its</span>
<span class="lineNum">   15320 </span><span class="lineCov">      28088 :    type is not cv-qualified. */</span>
<a name="15321"><span class="lineNum">   15321 </span><span class="lineCov">      13951 : </span></a>
<span class="lineNum">   15322 </span><span class="lineCov">      14137 : bool</span>
<span class="lineNum">   15323 </span>            : cp_parser_check_constrained_type_parm (cp_parser *parser,
<span class="lineNum">   15324 </span>            :                                        cp_parameter_declarator *parm)
<span class="lineNum">   15325 </span>            : {
<span class="lineNum">   15326 </span>            :   if (!parm-&gt;declarator)
<span class="lineNum">   15327 </span>            :     return true;
<span class="lineNum">   15328 </span>            : 
<span class="lineNum">   15329 </span>            :   if (parm-&gt;declarator-&gt;kind != cdk_id)
<span class="lineNum">   15330 </span>            :     {
<span class="lineNum">   15331 </span><span class="lineCov">        386 :       cp_parser_error (parser, &quot;invalid constrained type parameter&quot;);</span>
<span class="lineNum">   15332 </span><span class="lineCov">        193 :       return false;</span>
<span class="lineNum">   15333 </span><span class="lineCov">        173 :     }</span>
<span class="lineNum">   15334 </span>            : 
<span class="lineNum">   15335 </span>            :   /* Don't allow cv-qualified type parameters.  */
<span class="lineNum">   15336 </span>            :   if (decl_spec_seq_has_spec_p (&amp;parm-&gt;decl_specifiers, ds_const)
<span class="lineNum">   15337 </span>            :       || decl_spec_seq_has_spec_p (&amp;parm-&gt;decl_specifiers, ds_volatile))
<span class="lineNum">   15338 </span>            :     {
<span class="lineNum">   15339 </span>            :       cp_parser_error (parser, &quot;cv-qualified type parameter&quot;);
<span class="lineNum">   15340 </span>            :       return false;
<span class="lineNum">   15341 </span><span class="lineCov">   76651837 :     }</span>
<span class="lineNum">   15342 </span>            : 
<span class="lineNum">   15343 </span><span class="lineCov">   76651837 :   return true;</span>
<span class="lineNum">   15344 </span><span class="lineCov">   76607445 : }</span>
<span class="lineNum">   15345 </span><span class="lineCov">     730884 : </span>
<span class="lineNum">   15346 </span><span class="lineCov">   76653973 : /* Finish parsing/processing a template type parameter and checking</span>
<span class="lineNum">   15347 </span>            :    various restrictions. */
<a name="15348"><span class="lineNum">   15348 </span>            : </a>
<span class="lineNum">   15349 </span>            : static inline tree
<span class="lineNum">   15350 </span>            : cp_parser_constrained_type_template_parm (cp_parser *parser,
<span class="lineNum">   15351 </span>            :                                           tree id,
<span class="lineNum">   15352 </span><span class="lineNoCov">          0 :                                           cp_parameter_declarator* parmdecl)</span>
<span class="lineNum">   15353 </span>            : {
<span class="lineNum">   15354 </span><span class="lineNoCov">          0 :   if (cp_parser_check_constrained_type_parm (parser, parmdecl))</span>
<span class="lineNum">   15355 </span>            :     return finish_template_type_parm (class_type_node, id);
<span class="lineNum">   15356 </span>            :   else
<span class="lineNum">   15357 </span>            :     return error_mark_node;
<span class="lineNum">   15358 </span>            : }
<a name="15359"><span class="lineNum">   15359 </span>            : </a>
<span class="lineNum">   15360 </span>            : static tree
<span class="lineNum">   15361 </span><span class="lineCov">        178 : finish_constrained_template_template_parm (tree proto, tree id)</span>
<span class="lineNum">   15362 </span>            : {
<span class="lineNum">   15363 </span>            :   /* FIXME: This should probably be copied, and we may need to adjust
<span class="lineNum">   15364 </span><span class="lineCov">        178 :      the template parameter depths.  */</span>
<span class="lineNum">   15365 </span>            :   tree saved_parms = current_template_parms;
<span class="lineNum">   15366 </span>            :   begin_template_parm_list ();
<span class="lineNum">   15367 </span><span class="lineCov">        164 :   current_template_parms = DECL_TEMPLATE_PARMS (proto);</span>
<span class="lineNum">   15368 </span>            :   end_template_parm_list ();
<span class="lineNum">   15369 </span><span class="lineCov">          6 : </span>
<span class="lineNum">   15370 </span><span class="lineCov">          6 :   tree parm = finish_template_template_parm (class_type_node, id);</span>
<span class="lineNum">   15371 </span>            :   current_template_parms = saved_parms;
<span class="lineNum">   15372 </span>            : 
<span class="lineNum">   15373 </span>            :   return parm;
<span class="lineNum">   15374 </span><span class="lineCov">        158 : }</span>
<span class="lineNum">   15375 </span><span class="lineCov">        158 : </span>
<span class="lineNum">   15376 </span>            : /* Finish parsing/processing a template template parameter by borrowing
<span class="lineNum">   15377 </span><span class="lineCov">          2 :    the template parameter list from the prototype parameter.  */</span>
<a name="15378"><span class="lineNum">   15378 </span><span class="lineCov">          2 : </span></a>
<span class="lineNum">   15379 </span>            : static tree
<span class="lineNum">   15380 </span>            : cp_parser_constrained_template_template_parm (cp_parser *parser,
<span class="lineNum">   15381 </span>            :                                               tree proto,
<span class="lineNum">   15382 </span>            :                                               tree id,
<span class="lineNum">   15383 </span>            :                                               cp_parameter_declarator *parmdecl)
<span class="lineNum">   15384 </span>            : {
<span class="lineNum">   15385 </span>            :   if (!cp_parser_check_constrained_type_parm (parser, parmdecl))
<span class="lineNum">   15386 </span>            :     return error_mark_node;
<span class="lineNum">   15387 </span>            :   return finish_constrained_template_template_parm (proto, id);
<span class="lineNum">   15388 </span><span class="lineCov">        168 : }</span>
<span class="lineNum">   15389 </span>            : 
<span class="lineNum">   15390 </span>            : /* Create a new non-type template parameter from the given PARM
<span class="lineNum">   15391 </span>            :    declarator.  */
<a name="15392"><span class="lineNum">   15392 </span><span class="lineCov">        168 : </span></a>
<span class="lineNum">   15393 </span><span class="lineCov">        160 : static tree</span>
<span class="lineNum">   15394 </span>            : constrained_non_type_template_parm (bool *is_non_type,
<span class="lineNum">   15395 </span><span class="lineCov">          8 :                                     cp_parameter_declarator *parm)</span>
<span class="lineNum">   15396 </span>            : {
<span class="lineNum">   15397 </span>            :   *is_non_type = true;
<span class="lineNum">   15398 </span>            :   cp_declarator *decl = parm-&gt;declarator;
<span class="lineNum">   15399 </span><span class="lineCov">         11 :   cp_decl_specifier_seq *specs = &amp;parm-&gt;decl_specifiers;</span>
<span class="lineNum">   15400 </span>            :   specs-&gt;type = TREE_TYPE (DECL_INITIAL (specs-&gt;type));
<span class="lineNum">   15401 </span>            :   return grokdeclarator (decl, specs, TPARM, 0, NULL);
<span class="lineNum">   15402 </span>            : }
<span class="lineNum">   15403 </span><span class="lineCov">         11 : </span>
<span class="lineNum">   15404 </span><span class="lineCov">         11 : /* Build a constrained template parameter based on the PARMDECL</span>
<span class="lineNum">   15405 </span><span class="lineCov">         11 :    declarator. The type of PARMDECL is the constrained type, which</span>
<span class="lineNum">   15406 </span><span class="lineCov">         11 :    refers to the prototype template parameter that ultimately</span>
<span class="lineNum">   15407 </span>            :    specifies the type of the declared parameter. */
<a name="15408"><span class="lineNum">   15408 </span><span class="lineCov">         11 : </span></a>
<span class="lineNum">   15409 </span><span class="lineCov">         11 : static tree</span>
<span class="lineNum">   15410 </span>            : finish_constrained_parameter (cp_parser *parser,
<span class="lineNum">   15411 </span><span class="lineCov">         11 :                               cp_parameter_declarator *parmdecl,</span>
<span class="lineNum">   15412 </span>            :                               bool *is_non_type,
<span class="lineNum">   15413 </span>            :                               bool *is_parameter_pack)
<span class="lineNum">   15414 </span>            : {
<span class="lineNum">   15415 </span>            :   tree decl = parmdecl-&gt;decl_specifiers.type;
<span class="lineNum">   15416 </span>            :   tree id = get_unqualified_id (parmdecl-&gt;declarator);
<span class="lineNum">   15417 </span>            :   tree def = parmdecl-&gt;default_argument;
<span class="lineNum">   15418 </span><span class="lineCov">         10 :   tree proto = DECL_INITIAL (decl);</span>
<span class="lineNum">   15419 </span>            : 
<span class="lineNum">   15420 </span>            :   /* A template parameter constrained by a variadic concept shall also
<span class="lineNum">   15421 </span>            :      be declared as a template parameter pack.  */
<span class="lineNum">   15422 </span>            :   bool is_variadic = template_parameter_pack_p (proto);
<span class="lineNum">   15423 </span><span class="lineCov">         10 :   if (is_variadic &amp;&amp; !*is_parameter_pack)</span>
<span class="lineNum">   15424 </span><span class="lineNoCov">          0 :     cp_parser_error (parser, &quot;variadic constraint introduced without %&lt;...%&gt;&quot;);</span>
<span class="lineNum">   15425 </span><span class="lineCov">         10 : </span>
<span class="lineNum">   15426 </span>            :   /* Build the parameter. Return an error if the declarator was invalid. */
<span class="lineNum">   15427 </span>            :   tree parm;
<span class="lineNum">   15428 </span>            :   if (TREE_CODE (proto) == TYPE_DECL)
<span class="lineNum">   15429 </span>            :     parm = cp_parser_constrained_type_template_parm (parser, id, parmdecl);
<span class="lineNum">   15430 </span>            :   else if (TREE_CODE (proto) == TEMPLATE_DECL)
<span class="lineNum">   15431 </span>            :     parm = cp_parser_constrained_template_template_parm (parser, proto, id,
<span class="lineNum">   15432 </span><span class="lineCov">         15 :                                                          parmdecl);</span>
<span class="lineNum">   15433 </span>            :   else
<span class="lineNum">   15434 </span>            :     parm = constrained_non_type_template_parm (is_non_type, parmdecl);
<span class="lineNum">   15435 </span><span class="lineCov">         15 :   if (parm == error_mark_node)</span>
<span class="lineNum">   15436 </span><span class="lineCov">         15 :     return error_mark_node;</span>
<span class="lineNum">   15437 </span><span class="lineCov">         15 : </span>
<span class="lineNum">   15438 </span><span class="lineCov">         15 :   /* Finish the parameter decl and create a node attaching the</span>
<span class="lineNum">   15439 </span><span class="lineCov">         15 :      default argument and constraint.  */</span>
<span class="lineNum">   15440 </span>            :   parm = build_tree_list (def, parm);
<span class="lineNum">   15441 </span>            :   TEMPLATE_PARM_CONSTRAINTS (parm) = decl;
<span class="lineNum">   15442 </span>            : 
<span class="lineNum">   15443 </span>            :   return parm;
<span class="lineNum">   15444 </span>            : }
<span class="lineNum">   15445 </span>            : 
<span class="lineNum">   15446 </span>            : /* Returns true if the parsed type actually represents the declaration
<span class="lineNum">   15447 </span>            :    of a type template-parameter.  */
<a name="15448"><span class="lineNum">   15448 </span><span class="lineCov">        193 : </span></a>
<span class="lineNum">   15449 </span>            : static inline bool
<span class="lineNum">   15450 </span>            : declares_constrained_type_template_parameter (tree type)
<span class="lineNum">   15451 </span>            : {
<span class="lineNum">   15452 </span>            :   return (is_constrained_parameter (type)
<span class="lineNum">   15453 </span><span class="lineCov">        193 :           &amp;&amp; TREE_CODE (TREE_TYPE (type)) == TEMPLATE_TYPE_PARM);</span>
<span class="lineNum">   15454 </span><span class="lineCov">        193 : }</span>
<span class="lineNum">   15455 </span><span class="lineCov">        193 : </span>
<span class="lineNum">   15456 </span><span class="lineCov">        193 : </span>
<span class="lineNum">   15457 </span>            : /* Returns true if the parsed type actually represents the declaration of
<span class="lineNum">   15458 </span>            :    a template template-parameter.  */
<a name="15459"><span class="lineNum">   15459 </span>            : </a>
<span class="lineNum">   15460 </span><span class="lineCov">        193 : static bool</span>
<span class="lineNum">   15461 </span><span class="lineCov">        193 : declares_constrained_template_template_parameter (tree type)</span>
<span class="lineNum">   15462 </span><span class="lineCov">          2 : {</span>
<span class="lineNum">   15463 </span>            :   return (is_constrained_parameter (type)
<span class="lineNum">   15464 </span>            :           &amp;&amp; TREE_CODE (TREE_TYPE (type)) == TEMPLATE_TEMPLATE_PARM);
<span class="lineNum">   15465 </span><span class="lineCov">        193 : }</span>
<span class="lineNum">   15466 </span><span class="lineCov">        193 : </span>
<span class="lineNum">   15467 </span><span class="lineCov">        168 : /* Parse a default argument for a type template-parameter.</span>
<span class="lineNum">   15468 </span><span class="lineCov">         25 :    Note that diagnostics are handled in cp_parser_template_parameter.  */</span>
<a name="15469"><span class="lineNum">   15469 </span><span class="lineCov">         10 : </span></a>
<span class="lineNum">   15470 </span>            : static tree
<span class="lineNum">   15471 </span>            : cp_parser_default_type_template_argument (cp_parser *parser)
<span class="lineNum">   15472 </span><span class="lineCov">         15 : {</span>
<span class="lineNum">   15473 </span><span class="lineCov">        193 :   gcc_assert (cp_lexer_next_token_is (parser-&gt;lexer, CPP_EQ));</span>
<span class="lineNum">   15474 </span>            : 
<span class="lineNum">   15475 </span>            :   /* Consume the `=' token.  */
<span class="lineNum">   15476 </span>            :   cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   15477 </span>            : 
<span class="lineNum">   15478 </span><span class="lineCov">        185 :   cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   15479 </span><span class="lineCov">        185 : </span>
<span class="lineNum">   15480 </span>            :   /* Parse the default-argument.  */
<span class="lineNum">   15481 </span><span class="lineCov">        185 :   push_deferring_access_checks (dk_no_deferred);</span>
<span class="lineNum">   15482 </span>            :   tree default_argument = cp_parser_type_id (parser);
<span class="lineNum">   15483 </span>            :   pop_deferring_access_checks ();
<span class="lineNum">   15484 </span>            : 
<span class="lineNum">   15485 </span>            :   if (flag_concepts &amp;&amp; type_uses_auto (default_argument))
<span class="lineNum">   15486 </span>            :     {
<span class="lineNum">   15487 </span>            :       error_at (token-&gt;location,
<span class="lineNum">   15488 </span><span class="lineCov">     250195 :                 &quot;invalid use of %&lt;auto%&gt; in default template argument&quot;);</span>
<span class="lineNum">   15489 </span>            :       return error_mark_node;
<span class="lineNum">   15490 </span><span class="lineCov">     250195 :     }</span>
<span class="lineNum">   15491 </span><span class="lineCov">     250195 : </span>
<span class="lineNum">   15492 </span>            :   return default_argument;
<span class="lineNum">   15493 </span>            : }
<span class="lineNum">   15494 </span>            : 
<span class="lineNum">   15495 </span>            : /* Parse a default argument for a template template-parameter.  */
<a name="15496"><span class="lineNum">   15496 </span>            : </a>
<span class="lineNum">   15497 </span>            : static tree
<span class="lineNum">   15498 </span>            : cp_parser_default_template_template_argument (cp_parser *parser)
<span class="lineNum">   15499 </span><span class="lineCov">     250190 : {</span>
<span class="lineNum">   15500 </span>            :   gcc_assert (cp_lexer_next_token_is (parser-&gt;lexer, CPP_EQ));
<span class="lineNum">   15501 </span><span class="lineCov">     250190 : </span>
<span class="lineNum">   15502 </span><span class="lineCov">     250190 :   bool is_template;</span>
<span class="lineNum">   15503 </span>            : 
<span class="lineNum">   15504 </span>            :   /* Consume the `='.  */
<span class="lineNum">   15505 </span>            :   cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   15506 </span>            :   /* Parse the id-expression.  */
<span class="lineNum">   15507 </span>            :   push_deferring_access_checks (dk_no_deferred);
<span class="lineNum">   15508 </span>            :   /* save token before parsing the id-expression, for error
<span class="lineNum">   15509 </span><span class="lineCov">     319387 :      reporting */</span>
<span class="lineNum">   15510 </span>            :   const cp_token* token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   15511 </span><span class="lineCov">     319387 :   tree default_argument</span>
<span class="lineNum">   15512 </span>            :     = cp_parser_id_expression (parser,
<span class="lineNum">   15513 </span>            :                                /*template_keyword_p=*/false,
<span class="lineNum">   15514 </span><span class="lineCov">     319387 :                                /*check_dependency_p=*/true,</span>
<span class="lineNum">   15515 </span>            :                                /*template_p=*/&amp;is_template,
<span class="lineNum">   15516 </span><span class="lineCov">     638774 :                                /*declarator_p=*/false,</span>
<span class="lineNum">   15517 </span>            :                                /*optional_p=*/false);
<span class="lineNum">   15518 </span>            :   if (TREE_CODE (default_argument) == TYPE_DECL)
<span class="lineNum">   15519 </span><span class="lineCov">     319387 :     /* If the id-expression was a template-id that refers to</span>
<span class="lineNum">   15520 </span><span class="lineCov">     638774 :        a template-class, we already have the declaration here,</span>
<span class="lineNum">   15521 </span><span class="lineCov">     319387 :        so no further lookup is needed.  */</span>
<span class="lineNum">   15522 </span>            :     ;
<span class="lineNum">   15523 </span><span class="lineCov">     319387 :   else</span>
<span class="lineNum">   15524 </span>            :     /* Look up the name.  */
<span class="lineNum">   15525 </span><span class="lineNoCov">          0 :     default_argument</span>
<span class="lineNum">   15526 </span>            :       = cp_parser_lookup_name (parser, default_argument,
<span class="lineNum">   15527 </span><span class="lineNoCov">          0 :                                none_type,</span>
<span class="lineNum">   15528 </span>            :                                /*is_template=*/is_template,
<span class="lineNum">   15529 </span>            :                                /*is_namespace=*/false,
<span class="lineNum">   15530 </span>            :                                /*check_dependency=*/true,
<span class="lineNum">   15531 </span>            :                                /*ambiguous_decls=*/NULL,
<span class="lineNum">   15532 </span>            :                                token-&gt;location);
<span class="lineNum">   15533 </span>            :   /* See if the default argument is valid.  */
<span class="lineNum">   15534 </span>            :   default_argument = check_template_template_default_arg (default_argument);
<span class="lineNum">   15535 </span>            :   pop_deferring_access_checks ();
<span class="lineNum">   15536 </span><span class="lineCov">        795 :   return default_argument;</span>
<span class="lineNum">   15537 </span>            : }
<span class="lineNum">   15538 </span><span class="lineCov">        795 : </span>
<span class="lineNum">   15539 </span>            : /* Parse a template-parameter.
<span class="lineNum">   15540 </span><span class="lineCov">        795 : </span>
<span class="lineNum">   15541 </span>            :    template-parameter:
<span class="lineNum">   15542 </span>            :      type-parameter
<span class="lineNum">   15543 </span><span class="lineCov">        795 :      parameter-declaration</span>
<span class="lineNum">   15544 </span>            : 
<span class="lineNum">   15545 </span><span class="lineCov">        795 :    If all goes well, returns a TREE_LIST.  The TREE_VALUE represents</span>
<span class="lineNum">   15546 </span>            :    the parameter.  The TREE_PURPOSE is the default value, if any.
<span class="lineNum">   15547 </span>            :    Returns ERROR_MARK_NODE on failure.  *IS_NON_TYPE is set to true
<span class="lineNum">   15548 </span><span class="lineCov">       1590 :    iff this parameter is a non-type parameter.  *IS_PARAMETER_PACK is</span>
<span class="lineNum">   15549 </span><span class="lineCov">        795 :    set to true iff this parameter is a parameter pack. */</span>
<a name="15550"><span class="lineNum">   15550 </span><span class="lineCov">        795 : </span></a>
<span class="lineNum">   15551 </span>            : static tree
<span class="lineNum">   15552 </span>            : cp_parser_template_parameter (cp_parser* parser, bool *is_non_type,
<span class="lineNum">   15553 </span>            :                               bool *is_parameter_pack)
<span class="lineNum">   15554 </span>            : {
<span class="lineNum">   15555 </span><span class="lineCov">        795 :   cp_token *token;</span>
<span class="lineNum">   15556 </span><span class="lineCov">        795 :   cp_parameter_declarator *parameter_declarator;</span>
<span class="lineNum">   15557 </span>            :   tree parm;
<span class="lineNum">   15558 </span>            : 
<span class="lineNum">   15559 </span>            :   /* Assume it is a type parameter or a template parameter.  */
<span class="lineNum">   15560 </span>            :   *is_non_type = false;
<span class="lineNum">   15561 </span>            :   /* Assume it not a parameter pack. */
<span class="lineNum">   15562 </span>            :   *is_parameter_pack = false;
<span class="lineNum">   15563 </span><span class="lineCov">        792 :   /* Peek at the next token.  */</span>
<span class="lineNum">   15564 </span><span class="lineCov">        792 :   token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   15565 </span>            :   /* If it is `template', we have a type-parameter.  */
<span class="lineNum">   15566 </span>            :   if (token-&gt;keyword == RID_TEMPLATE)
<span class="lineNum">   15567 </span>            :     return cp_parser_type_parameter (parser, is_parameter_pack);
<span class="lineNum">   15568 </span>            :   /* If it is `class' or `typename' we do not know yet whether it is a
<span class="lineNum">   15569 </span>            :      type parameter or a non-type parameter.  Consider:
<span class="lineNum">   15570 </span><span class="lineCov">        792 : </span>
<span class="lineNum">   15571 </span>            :        template &lt;typename T, typename T::X X&gt; ...
<span class="lineNum">   15572 </span><span class="lineCov">        795 : </span>
<span class="lineNum">   15573 </span><span class="lineCov">        795 :      or:</span>
<span class="lineNum">   15574 </span><span class="lineCov">        795 : </span>
<span class="lineNum">   15575 </span>            :        template &lt;class C, class D*&gt; ...
<span class="lineNum">   15576 </span>            : 
<span class="lineNum">   15577 </span>            :      Here, the first parameter is a type parameter, and the second is
<span class="lineNum">   15578 </span>            :      a non-type parameter.  We can tell by looking at the token after
<span class="lineNum">   15579 </span>            :      the identifier -- if it is a `,', `=', or `&gt;' then we have a type
<span class="lineNum">   15580 </span>            :      parameter.  */
<span class="lineNum">   15581 </span>            :   if (token-&gt;keyword == RID_TYPENAME || token-&gt;keyword == RID_CLASS)
<span class="lineNum">   15582 </span>            :     {
<span class="lineNum">   15583 </span>            :       /* Peek at the token after `class' or `typename'.  */
<span class="lineNum">   15584 </span>            :       token = cp_lexer_peek_nth_token (parser-&gt;lexer, 2);
<span class="lineNum">   15585 </span>            :       /* If it's an ellipsis, we have a template type parameter
<span class="lineNum">   15586 </span>            :          pack. */
<span class="lineNum">   15587 </span>            :       if (token-&gt;type == CPP_ELLIPSIS)
<span class="lineNum">   15588 </span>            :         return cp_parser_type_parameter (parser, is_parameter_pack);
<span class="lineNum">   15589 </span>            :       /* If it's an identifier, skip it.  */
<span class="lineNum">   15590 </span><span class="lineCov">    7793899 :       if (token-&gt;type == CPP_NAME)</span>
<span class="lineNum">   15591 </span>            :         token = cp_lexer_peek_nth_token (parser-&gt;lexer, 3);
<span class="lineNum">   15592 </span>            :       /* Now, see if the token looks like the end of a template
<span class="lineNum">   15593 </span><span class="lineCov">    7793899 :          parameter.  */</span>
<span class="lineNum">   15594 </span><span class="lineCov">    7793899 :       if (token-&gt;type == CPP_COMMA</span>
<span class="lineNum">   15595 </span><span class="lineCov">    7793899 :           || token-&gt;type == CPP_EQ</span>
<span class="lineNum">   15596 </span>            :           || token-&gt;type == CPP_GREATER)
<span class="lineNum">   15597 </span>            :         return cp_parser_type_parameter (parser, is_parameter_pack);
<span class="lineNum">   15598 </span><span class="lineCov">    7793899 :     }</span>
<span class="lineNum">   15599 </span>            : 
<span class="lineNum">   15600 </span><span class="lineCov">    7793899 :   /* Otherwise, it is a non-type parameter or a constrained parameter.</span>
<span class="lineNum">   15601 </span>            : 
<span class="lineNum">   15602 </span><span class="lineCov">   15587798 :      [temp.param]</span>
<span class="lineNum">   15603 </span>            : 
<span class="lineNum">   15604 </span><span class="lineCov">    7793899 :      When parsing a default template-argument for a non-type</span>
<span class="lineNum">   15605 </span><span class="lineCov">      36630 :      template-parameter, the first non-nested `&gt;' is taken as the end</span>
<span class="lineNum">   15606 </span>            :      of the template parameter-list rather than a greater-than
<span class="lineNum">   15607 </span>            :      operator.  */
<span class="lineNum">   15608 </span>            :   parameter_declarator
<span class="lineNum">   15609 </span>            :      = cp_parser_parameter_declaration (parser, /*template_parm_p=*/true,
<span class="lineNum">   15610 </span>            :                                         /*parenthesized_p=*/NULL);
<span class="lineNum">   15611 </span>            : 
<span class="lineNum">   15612 </span>            :   if (!parameter_declarator)
<span class="lineNum">   15613 </span>            :     return error_mark_node;
<span class="lineNum">   15614 </span>            : 
<span class="lineNum">   15615 </span>            :   /* If the parameter declaration is marked as a parameter pack, set
<span class="lineNum">   15616 </span>            :    *IS_PARAMETER_PACK to notify the caller.  */
<span class="lineNum">   15617 </span>            :   if (parameter_declarator-&gt;template_parameter_pack_p)
<span class="lineNum">   15618 </span>            :     *is_parameter_pack = true;
<span class="lineNum">   15619 </span><span class="lineCov">    7757269 : </span>
<span class="lineNum">   15620 </span>            :   if (parameter_declarator-&gt;default_argument)
<span class="lineNum">   15621 </span>            :     {
<span class="lineNum">   15622 </span><span class="lineCov">    7086008 :       /* Can happen in some cases of erroneous input (c++/34892).  */</span>
<span class="lineNum">   15623 </span>            :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_ELLIPSIS))
<span class="lineNum">   15624 </span>            :         /* Consume the `...' for better error recovery.  */
<span class="lineNum">   15625 </span><span class="lineCov">    7086008 :         cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   15626 </span><span class="lineCov">     437893 :     }</span>
<span class="lineNum">   15627 </span>            : 
<span class="lineNum">   15628 </span><span class="lineCov">    6648115 :   // The parameter may have been constrained.</span>
<span class="lineNum">   15629 </span><span class="lineCov">    6335528 :   if (is_constrained_parameter (parameter_declarator))</span>
<span class="lineNum">   15630 </span>            :     return finish_constrained_parameter (parser,
<span class="lineNum">   15631 </span>            :                                          parameter_declarator,
<span class="lineNum">   15632 </span><span class="lineCov">   13296230 :                                          is_non_type,</span>
<span class="lineNum">   15633 </span><span class="lineCov">    6648115 :                                          is_parameter_pack);</span>
<span class="lineNum">   15634 </span><span class="lineCov">    3254402 : </span>
<span class="lineNum">   15635 </span><span class="lineCov">    6583723 :   // Now we're sure that the parameter is a non-type parameter.</span>
<span class="lineNum">   15636 </span>            :   *is_non_type = true;
<span class="lineNum">   15637 </span>            : 
<span class="lineNum">   15638 </span>            :   parm = grokdeclarator (parameter_declarator-&gt;declarator,
<span class="lineNum">   15639 </span>            :                          &amp;parameter_declarator-&gt;decl_specifiers,
<span class="lineNum">   15640 </span>            :                          TPARM, /*initialized=*/0,
<span class="lineNum">   15641 </span>            :                          /*attrlist=*/NULL);
<span class="lineNum">   15642 </span>            :   if (parm == error_mark_node)
<span class="lineNum">   15643 </span>            :     return error_mark_node;
<span class="lineNum">   15644 </span>            : 
<span class="lineNum">   15645 </span>            :   return build_tree_list (parameter_declarator-&gt;default_argument, parm);
<span class="lineNum">   15646 </span><span class="lineCov">     735653 : }</span>
<span class="lineNum">   15647 </span><span class="lineCov">     735653 : </span>
<span class="lineNum">   15648 </span>            : /* Parse a type-parameter.
<span class="lineNum">   15649 </span>            : 
<span class="lineNum">   15650 </span><span class="lineCov">     735653 :    type-parameter:</span>
<span class="lineNum">   15651 </span><span class="lineNoCov">          0 :      class identifier [opt]</span>
<span class="lineNum">   15652 </span>            :      class identifier [opt] = type-id
<span class="lineNum">   15653 </span>            :      typename identifier [opt]
<span class="lineNum">   15654 </span>            :      typename identifier [opt] = type-id
<span class="lineNum">   15655 </span><span class="lineCov">     735653 :      template &lt; template-parameter-list &gt; class identifier [opt]</span>
<span class="lineNum">   15656 </span><span class="lineCov">      26773 :      template &lt; template-parameter-list &gt; class identifier [opt]</span>
<span class="lineNum">   15657 </span>            :        = id-expression
<span class="lineNum">   15658 </span><span class="lineCov">     735653 : </span>
<span class="lineNum">   15659 </span>            :    GNU Extension (variadic templates):
<span class="lineNum">   15660 </span>            : 
<span class="lineNum">   15661 </span><span class="lineCov">     184463 :    type-parameter:</span>
<span class="lineNum">   15662 </span>            :      class ... identifier [opt]
<span class="lineNum">   15663 </span><span class="lineCov">          3 :      typename ... identifier [opt]</span>
<span class="lineNum">   15664 </span>            : 
<span class="lineNum">   15665 </span>            :    Returns a TREE_LIST.  The TREE_VALUE is itself a TREE_LIST.  The
<span class="lineNum">   15666 </span>            :    TREE_PURPOSE is the default-argument, if any.  The TREE_VALUE is
<span class="lineNum">   15667 </span><span class="lineCov">     735653 :    the declaration of the parameter.</span>
<span class="lineNum">   15668 </span><span class="lineCov">        193 : </span>
<span class="lineNum">   15669 </span>            :    Sets *IS_PARAMETER_PACK if this is a template parameter pack. */
<a name="15670"><span class="lineNum">   15670 </span>            : </a>
<span class="lineNum">   15671 </span><span class="lineCov">        193 : static tree</span>
<span class="lineNum">   15672 </span>            : cp_parser_type_parameter (cp_parser* parser, bool *is_parameter_pack)
<span class="lineNum">   15673 </span>            : {
<span class="lineNum">   15674 </span><span class="lineCov">     735460 :   cp_token *token;</span>
<span class="lineNum">   15675 </span>            :   tree parameter;
<span class="lineNum">   15676 </span><span class="lineCov">     735460 : </span>
<span class="lineNum">   15677 </span>            :   /* Look for a keyword to tell us what kind of parameter this is.  */
<span class="lineNum">   15678 </span>            :   token = cp_parser_require (parser, CPP_KEYWORD, RT_CLASS_TYPENAME_TEMPLATE);
<span class="lineNum">   15679 </span>            :   if (!token)
<span class="lineNum">   15680 </span><span class="lineCov">     735460 :     return error_mark_node;</span>
<span class="lineNum">   15681 </span>            : 
<span class="lineNum">   15682 </span>            :   switch (token-&gt;keyword)
<span class="lineNum">   15683 </span><span class="lineCov">     735384 :     {</span>
<span class="lineNum">   15684 </span>            :     case RID_CLASS:
<span class="lineNum">   15685 </span>            :     case RID_TYPENAME:
<span class="lineNum">   15686 </span>            :       {
<span class="lineNum">   15687 </span>            :         tree identifier;
<span class="lineNum">   15688 </span>            :         tree default_argument;
<span class="lineNum">   15689 </span>            : 
<span class="lineNum">   15690 </span>            :         /* If the next token is an ellipsis, we have a template
<span class="lineNum">   15691 </span>            :            argument pack. */
<span class="lineNum">   15692 </span>            :         if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_ELLIPSIS))
<span class="lineNum">   15693 </span>            :           {
<span class="lineNum">   15694 </span>            :             /* Consume the `...' token. */
<span class="lineNum">   15695 </span>            :             cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   15696 </span>            :             maybe_warn_variadic_templates ();
<span class="lineNum">   15697 </span>            : 
<span class="lineNum">   15698 </span>            :             *is_parameter_pack = true;
<span class="lineNum">   15699 </span>            :           }
<span class="lineNum">   15700 </span>            : 
<span class="lineNum">   15701 </span>            :         /* If the next token is an identifier, then it names the
<span class="lineNum">   15702 </span>            :            parameter.  */
<span class="lineNum">   15703 </span>            :         if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))
<span class="lineNum">   15704 </span>            :           identifier = cp_parser_identifier (parser);
<span class="lineNum">   15705 </span>            :         else
<span class="lineNum">   15706 </span>            :           identifier = NULL_TREE;
<span class="lineNum">   15707 </span>            : 
<span class="lineNum">   15708 </span>            :         /* Create the parameter.  */
<span class="lineNum">   15709 </span>            :         parameter = finish_template_type_parm (class_type_node, identifier);
<span class="lineNum">   15710 </span><span class="lineCov">    7058246 : </span>
<span class="lineNum">   15711 </span>            :         /* If the next token is an `=', we have a default argument.  */
<span class="lineNum">   15712 </span><span class="lineCov">    7058246 :         if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_EQ))</span>
<span class="lineNum">   15713 </span><span class="lineCov">    7058246 :           {</span>
<span class="lineNum">   15714 </span>            :             default_argument
<span class="lineNum">   15715 </span>            :               = cp_parser_default_type_template_argument (parser);
<span class="lineNum">   15716 </span><span class="lineCov">    7058246 : </span>
<span class="lineNum">   15717 </span><span class="lineCov">    7058246 :             /* Template parameter packs cannot have default</span>
<span class="lineNum">   15718 </span><span class="lineNoCov">          0 :                arguments. */</span>
<span class="lineNum">   15719 </span>            :             if (*is_parameter_pack)
<span class="lineNum">   15720 </span><span class="lineCov">    7058246 :               {</span>
<span class="lineNum">   15721 </span>            :                 if (identifier)
<span class="lineNum">   15722 </span><span class="lineCov">    7021616 :                   error_at (token-&gt;location,</span>
<span class="lineNum">   15723 </span><span class="lineCov">    7021616 :                             &quot;template parameter pack %qD cannot have a &quot;</span>
<span class="lineNum">   15724 </span><span class="lineCov">    7021616 :                             &quot;default argument&quot;, identifier);</span>
<span class="lineNum">   15725 </span><span class="lineCov">    7021616 :                 else</span>
<span class="lineNum">   15726 </span><span class="lineCov">    7021616 :                   error_at (token-&gt;location,</span>
<span class="lineNum">   15727 </span>            :                             &quot;template parameter packs cannot have &quot;
<span class="lineNum">   15728 </span>            :                             &quot;default arguments&quot;);
<span class="lineNum">   15729 </span>            :                 default_argument = NULL_TREE;
<span class="lineNum">   15730 </span><span class="lineCov">    7021616 :               }</span>
<span class="lineNum">   15731 </span>            :             else if (check_for_bare_parameter_packs (default_argument))
<span class="lineNum">   15732 </span>            :               default_argument = error_mark_node;
<span class="lineNum">   15733 </span><span class="lineCov">     437893 :           }</span>
<span class="lineNum">   15734 </span><span class="lineCov">     437893 :         else</span>
<span class="lineNum">   15735 </span>            :           default_argument = NULL_TREE;
<span class="lineNum">   15736 </span><span class="lineCov">     437893 : </span>
<span class="lineNum">   15737 </span>            :         /* Create the combined representation of the parameter and the
<span class="lineNum">   15738 </span>            :            default argument.  */
<span class="lineNum">   15739 </span>            :         parameter = build_tree_list (default_argument, parameter);
<span class="lineNum">   15740 </span>            :       }
<span class="lineNum">   15741 </span><span class="lineCov">    7021616 :       break;</span>
<span class="lineNum">   15742 </span><span class="lineCov">    6670887 : </span>
<span class="lineNum">   15743 </span>            :     case RID_TEMPLATE:
<span class="lineNum">   15744 </span>            :       {
<span class="lineNum">   15745 </span>            :         tree identifier;
<span class="lineNum">   15746 </span>            :         tree default_argument;
<span class="lineNum">   15747 </span><span class="lineCov">    7021616 : </span>
<span class="lineNum">   15748 </span>            :         /* Look for the `&lt;'.  */
<span class="lineNum">   15749 </span>            :         cp_parser_require (parser, CPP_LESS, RT_LESS);
<span class="lineNum">   15750 </span><span class="lineCov">    7021616 :         /* Parse the template-parameter-list.  */</span>
<span class="lineNum">   15751 </span>            :         cp_parser_template_parameter_list (parser);
<span class="lineNum">   15752 </span><span class="lineCov">     319382 :         /* Look for the `&gt;'.  */</span>
<span class="lineNum">   15753 </span><span class="lineCov">     319382 :         cp_parser_require (parser, CPP_GREATER, RT_GREATER);</span>
<span class="lineNum">   15754 </span>            : 
<span class="lineNum">   15755 </span>            :         // If template requirements are present, parse them.
<span class="lineNum">   15756 </span>            :         if (flag_concepts)
<span class="lineNum">   15757 </span><span class="lineCov">     319382 :           {</span>
<span class="lineNum">   15758 </span>            :             tree reqs = get_shorthand_constraints (current_template_parms);
<span class="lineNum">   15759 </span><span class="lineCov">          6 :             if (tree r = cp_parser_requires_clause_opt (parser))</span>
<span class="lineNum">   15760 </span><span class="lineCov">          4 :               reqs = conjoin_constraints (reqs, normalize_expression (r));</span>
<span class="lineNum">   15761 </span>            :             TEMPLATE_PARMS_CONSTRAINTS (current_template_parms) = reqs;
<span class="lineNum">   15762 </span>            :           }
<span class="lineNum">   15763 </span>            : 
<span class="lineNum">   15764 </span><span class="lineCov">          2 :         /* Look for the `class' or 'typename' keywords.  */</span>
<span class="lineNum">   15765 </span>            :         cp_parser_type_parameter_key (parser);
<span class="lineNum">   15766 </span>            :         /* If the next token is an ellipsis, we have a template
<span class="lineNum">   15767 </span>            :            argument pack. */
<span class="lineNum">   15768 </span>            :         if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_ELLIPSIS))
<span class="lineNum">   15769 </span><span class="lineCov">     319376 :           {</span>
<span class="lineNum">   15770 </span><span class="lineCov">          6 :             /* Consume the `...' token. */</span>
<span class="lineNum">   15771 </span>            :             cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   15772 </span>            :             maybe_warn_variadic_templates ();
<span class="lineNum">   15773 </span>            : 
<span class="lineNum">   15774 </span>            :             *is_parameter_pack = true;
<span class="lineNum">   15775 </span>            :           }
<span class="lineNum">   15776 </span>            :         /* If the next token is an `=', then there is a
<span class="lineNum">   15777 </span><span class="lineCov">    7021616 :            default-argument.  If the next token is a `&gt;', we are at</span>
<span class="lineNum">   15778 </span>            :            the end of the parameter-list.  If the next token is a `,',
<span class="lineNum">   15779 </span><span class="lineCov">    7021616 :            then we are at the end of this parameter.  */</span>
<span class="lineNum">   15780 </span>            :         if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_EQ)
<span class="lineNum">   15781 </span><span class="lineCov">      36630 :             &amp;&amp; cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_GREATER)</span>
<span class="lineNum">   15782 </span><span class="lineCov">      36630 :             &amp;&amp; cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_COMMA))</span>
<span class="lineNum">   15783 </span><span class="lineCov">      36630 :           {</span>
<span class="lineNum">   15784 </span><span class="lineCov">      36630 :             identifier = cp_parser_identifier (parser);</span>
<span class="lineNum">   15785 </span>            :             /* Treat invalid names as if the parameter were nameless.  */
<span class="lineNum">   15786 </span>            :             if (identifier == error_mark_node)
<span class="lineNum">   15787 </span><span class="lineCov">      36630 :               identifier = NULL_TREE;</span>
<span class="lineNum">   15788 </span>            :           }
<span class="lineNum">   15789 </span><span class="lineCov">      36630 :         else</span>
<span class="lineNum">   15790 </span>            :           identifier = NULL_TREE;
<span class="lineNum">   15791 </span><span class="lineCov">      36630 : </span>
<span class="lineNum">   15792 </span>            :         /* Create the template parameter.  */
<span class="lineNum">   15793 </span>            :         parameter = finish_template_template_parm (class_type_node,
<span class="lineNum">   15794 </span><span class="lineCov">      36630 :                                                    identifier);</span>
<span class="lineNum">   15795 </span>            : 
<span class="lineNum">   15796 </span><span class="lineCov">         64 :         /* If the next token is an `=', then there is a</span>
<span class="lineNum">   15797 </span><span class="lineCov">         64 :            default-argument.  */</span>
<span class="lineNum">   15798 </span><span class="lineCov">          3 :         if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_EQ))</span>
<span class="lineNum">   15799 </span><span class="lineCov">         64 :           {</span>
<span class="lineNum">   15800 </span>            :             default_argument
<span class="lineNum">   15801 </span>            :               = cp_parser_default_template_template_argument (parser);
<span class="lineNum">   15802 </span>            : 
<span class="lineNum">   15803 </span><span class="lineCov">      36630 :             /* Template parameter packs cannot have default</span>
<span class="lineNum">   15804 </span>            :                arguments. */
<span class="lineNum">   15805 </span>            :             if (*is_parameter_pack)
<span class="lineNum">   15806 </span><span class="lineCov">      36630 :               {</span>
<span class="lineNum">   15807 </span>            :                 if (identifier)
<span class="lineNum">   15808 </span>            :                   error_at (token-&gt;location,
<span class="lineNum">   15809 </span><span class="lineCov">         60 :                             &quot;template parameter pack %qD cannot &quot;</span>
<span class="lineNum">   15810 </span><span class="lineCov">         60 :                             &quot;have a default argument&quot;,</span>
<span class="lineNum">   15811 </span>            :                             identifier);
<span class="lineNum">   15812 </span><span class="lineCov">         60 :                 else</span>
<span class="lineNum">   15813 </span>            :                   error_at (token-&gt;location, &quot;template parameter packs cannot &quot;
<span class="lineNum">   15814 </span>            :                             &quot;have default arguments&quot;);
<span class="lineNum">   15815 </span>            :                 default_argument = NULL_TREE;
<span class="lineNum">   15816 </span>            :               }
<span class="lineNum">   15817 </span>            :           }
<span class="lineNum">   15818 </span><span class="lineCov">      73260 :         else</span>
<span class="lineNum">   15819 </span><span class="lineCov">      36605 :           default_argument = NULL_TREE;</span>
<span class="lineNum">   15820 </span><span class="lineCov">      73123 : </span>
<span class="lineNum">   15821 </span>            :         /* Create the combined representation of the parameter and the
<span class="lineNum">   15822 </span><span class="lineCov">      36469 :            default argument.  */</span>
<span class="lineNum">   15823 </span>            :         parameter = build_tree_list (default_argument, parameter);
<span class="lineNum">   15824 </span><span class="lineCov">      36469 :       }</span>
<span class="lineNum">   15825 </span><span class="lineCov">          6 :       break;</span>
<span class="lineNum">   15826 </span>            : 
<span class="lineNum">   15827 </span>            :     default:
<span class="lineNum">   15828 </span>            :       gcc_unreachable ();
<span class="lineNum">   15829 </span>            :       break;
<span class="lineNum">   15830 </span>            :     }
<span class="lineNum">   15831 </span><span class="lineCov">      36630 : </span>
<span class="lineNum">   15832 </span>            :   return parameter;
<span class="lineNum">   15833 </span>            : }
<span class="lineNum">   15834 </span>            : 
<span class="lineNum">   15835 </span>            : /* Parse a template-id.
<span class="lineNum">   15836 </span><span class="lineCov">      36630 : </span>
<span class="lineNum">   15837 </span>            :    template-id:
<span class="lineNum">   15838 </span><span class="lineCov">        790 :      template-name &lt; template-argument-list [opt] &gt;</span>
<span class="lineNum">   15839 </span><span class="lineCov">        790 : </span>
<span class="lineNum">   15840 </span>            :    If TEMPLATE_KEYWORD_P is TRUE, then we have just seen the
<span class="lineNum">   15841 </span>            :    `template' keyword.  In this case, a TEMPLATE_ID_EXPR will be
<span class="lineNum">   15842 </span>            :    returned.  Otherwise, if the template-name names a function, or set
<span class="lineNum">   15843 </span><span class="lineCov">        790 :    of functions, returns a TEMPLATE_ID_EXPR.  If the template-name</span>
<span class="lineNum">   15844 </span>            :    names a class, returns a TYPE_DECL for the specialization.
<span class="lineNum">   15845 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   15846 </span><span class="lineNoCov">          0 :    If CHECK_DEPENDENCY_P is FALSE, names are looked up in</span>
<span class="lineNum">   15847 </span>            :    uninstantiated templates.  */
<a name="15848"><span class="lineNum">   15848 </span>            : </a>
<span class="lineNum">   15849 </span>            : static tree
<span class="lineNum">   15850 </span>            : cp_parser_template_id (cp_parser *parser,
<span class="lineNum">   15851 </span><span class="lineNoCov">          0 :                        bool template_keyword_p,</span>
<span class="lineNum">   15852 </span>            :                        bool check_dependency_p,
<span class="lineNum">   15853 </span>            :                        enum tag_types tag_type,
<span class="lineNum">   15854 </span>            :                        bool is_declaration)
<span class="lineNum">   15855 </span>            : {
<span class="lineNum">   15856 </span>            :   tree templ;
<span class="lineNum">   15857 </span>            :   tree arguments;
<span class="lineNum">   15858 </span>            :   tree template_id;
<span class="lineNum">   15859 </span>            :   cp_token_position start_of_id = 0;
<span class="lineNum">   15860 </span>            :   cp_token *next_token = NULL, *next_token_2 = NULL;
<span class="lineNum">   15861 </span><span class="lineCov">      36630 :   bool is_identifier;</span>
<span class="lineNum">   15862 </span>            : 
<span class="lineNum">   15863 </span><span class="lineCov">      36630 :   /* If the next token corresponds to a template-id, there is no need</span>
<span class="lineNum">   15864 </span>            :      to reparse it.  */
<span class="lineNum">   15865 </span><span class="lineNoCov">          0 :   cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   15866 </span><span class="lineNoCov">          0 :   if (token-&gt;type == CPP_TEMPLATE_ID)</span>
<span class="lineNum">   15867 </span>            :     {
<span class="lineNum">   15868 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   15869 </span>            :       return saved_checks_value (token-&gt;u.tree_check_value);
<span class="lineNum">   15870 </span>            :     }
<span class="lineNum">   15871 </span>            : 
<span class="lineNum">   15872 </span>            :   /* Avoid performing name lookup if there is no possibility of
<span class="lineNum">   15873 </span>            :      finding a template-id.  */
<span class="lineNum">   15874 </span>            :   if ((token-&gt;type != CPP_NAME &amp;&amp; token-&gt;keyword != RID_OPERATOR)
<span class="lineNum">   15875 </span>            :       || (token-&gt;type == CPP_NAME
<span class="lineNum">   15876 </span>            :           &amp;&amp; !cp_parser_nth_token_starts_template_argument_list_p
<span class="lineNum">   15877 </span>            :                (parser, 2)))
<span class="lineNum">   15878 </span>            :     {
<span class="lineNum">   15879 </span>            :       cp_parser_error (parser, &quot;expected template-id&quot;);
<span class="lineNum">   15880 </span>            :       return error_mark_node;
<span class="lineNum">   15881 </span>            :     }
<span class="lineNum">   15882 </span>            : 
<span class="lineNum">   15883 </span>            :   /* Remember where the template-id starts.  */
<span class="lineNum">   15884 </span>            :   if (cp_parser_uncommitted_to_tentative_parse_p (parser))
<span class="lineNum">   15885 </span>            :     start_of_id = cp_lexer_token_position (parser-&gt;lexer, false);
<span class="lineNum">   15886 </span>            : 
<span class="lineNum">   15887 </span>            :   push_deferring_access_checks (dk_deferred);
<span class="lineNum">   15888 </span><span class="lineCov">  169418763 : </span>
<span class="lineNum">   15889 </span>            :   /* Parse the template-name.  */
<span class="lineNum">   15890 </span>            :   is_identifier = false;
<span class="lineNum">   15891 </span>            :   templ = cp_parser_template_name (parser, template_keyword_p,
<span class="lineNum">   15892 </span>            :                                    check_dependency_p,
<span class="lineNum">   15893 </span>            :                                    is_declaration,
<span class="lineNum">   15894 </span><span class="lineCov">  169418763 :                                    tag_type,</span>
<span class="lineNum">   15895 </span><span class="lineCov">  169418763 :                                    &amp;is_identifier);</span>
<span class="lineNum">   15896 </span><span class="lineCov">  169418763 :   if (templ == error_mark_node || is_identifier)</span>
<span class="lineNum">   15897 </span><span class="lineCov">  169418763 :     {</span>
<span class="lineNum">   15898 </span><span class="lineCov">  169418763 :       pop_deferring_access_checks ();</span>
<span class="lineNum">   15899 </span><span class="lineCov">  169418763 :       return templ;</span>
<span class="lineNum">   15900 </span>            :     }
<span class="lineNum">   15901 </span>            : 
<span class="lineNum">   15902 </span>            :   /* Since we're going to preserve any side-effects from this parse, set up a
<span class="lineNum">   15903 </span><span class="lineCov">  338837526 :      firewall to protect our callers from cp_parser_commit_to_tentative_parse</span>
<span class="lineNum">   15904 </span><span class="lineCov">  169418763 :      in the template arguments.  */</span>
<span class="lineNum">   15905 </span>            :   tentative_firewall firewall (parser);
<span class="lineNum">   15906 </span><span class="lineCov">   11392290 : </span>
<span class="lineNum">   15907 </span><span class="lineCov">   11392290 :   /* If we find the sequence `[:' after a template-name, it's probably</span>
<span class="lineNum">   15908 </span>            :      a digraph-typo for `&lt; ::'. Substitute the tokens and check if we can
<span class="lineNum">   15909 </span>            :      parse correctly the argument list.  */
<span class="lineNum">   15910 </span>            :   if (((next_token = cp_lexer_peek_token (parser-&gt;lexer))-&gt;type
<span class="lineNum">   15911 </span>            :        == CPP_OPEN_SQUARE)
<span class="lineNum">   15912 </span><span class="lineCov">   33484649 :       &amp;&amp; next_token-&gt;flags &amp; DIGRAPH</span>
<span class="lineNum">   15913 </span><span class="lineCov">  159551452 :       &amp;&amp; ((next_token_2 = cp_lexer_peek_nth_token (parser-&gt;lexer, 2))-&gt;type</span>
<span class="lineNum">   15914 </span><span class="lineCov">  124541824 :           == CPP_COLON)</span>
<span class="lineNum">   15915 </span><span class="lineCov">  124541824 :       &amp;&amp; !(next_token_2-&gt;flags &amp; PREV_WHITE))</span>
<span class="lineNum">   15916 </span>            :     {
<span class="lineNum">   15917 </span><span class="lineCov">  145892467 :       cp_parser_parse_tentatively (parser);</span>
<span class="lineNum">   15918 </span><span class="lineCov">  145892467 :       /* Change `:' into `::'.  */</span>
<span class="lineNum">   15919 </span>            :       next_token_2-&gt;type = CPP_SCOPE;
<span class="lineNum">   15920 </span>            :       /* Consume the first token (CPP_OPEN_SQUARE - which we pretend it is
<span class="lineNum">   15921 </span>            :          CPP_LESS.  */
<span class="lineNum">   15922 </span><span class="lineCov">   24267984 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   15923 </span><span class="lineCov">   12133978 : </span>
<span class="lineNum">   15924 </span>            :       /* Parse the arguments.  */
<span class="lineNum">   15925 </span><span class="lineCov">   12134006 :       arguments = cp_parser_enclosed_template_argument_list (parser);</span>
<span class="lineNum">   15926 </span>            :       if (!cp_parser_parse_definitely (parser))
<span class="lineNum">   15927 </span>            :         {
<span class="lineNum">   15928 </span><span class="lineCov">   12134006 :           /* If we couldn't parse an argument list, then we revert our changes</span>
<span class="lineNum">   15929 </span><span class="lineCov">   12134006 :              and return simply an error. Maybe this is not a template-id</span>
<span class="lineNum">   15930 </span>            :              after all.  */
<span class="lineNum">   15931 </span>            :           next_token_2-&gt;type = CPP_COLON;
<span class="lineNum">   15932 </span>            :           cp_parser_error (parser, &quot;expected %&lt;&lt;%&gt;&quot;);
<span class="lineNum">   15933 </span>            :           pop_deferring_access_checks ();
<span class="lineNum">   15934 </span><span class="lineCov">   12134006 :           return error_mark_node;</span>
<span class="lineNum">   15935 </span>            :         }
<span class="lineNum">   15936 </span><span class="lineCov">    3293098 :       /* Otherwise, emit an error about the invalid digraph, but continue</span>
<span class="lineNum">   15937 </span><span class="lineCov">    3293098 :          parsing because we got our argument list.  */</span>
<span class="lineNum">   15938 </span>            :       if (permerror (next_token-&gt;location,
<span class="lineNum">   15939 </span>            :                      &quot;%&lt;&lt;::%&gt; cannot begin a template-argument list&quot;))
<span class="lineNum">   15940 </span>            :         {
<span class="lineNum">   15941 </span>            :           static bool hint = false;
<span class="lineNum">   15942 </span>            :           inform (next_token-&gt;location,
<span class="lineNum">   15943 </span><span class="lineCov">   17681816 :                   &quot;%&lt;&lt;:%&gt; is an alternate spelling for %&lt;[%&gt;.&quot;</span>
<span class="lineNum">   15944 </span>            :                   &quot; Insert whitespace between %&lt;&lt;%&gt; and %&lt;::%&gt;&quot;);
<span class="lineNum">   15945 </span>            :           if (!hint &amp;&amp; !flag_permissive)
<span class="lineNum">   15946 </span>            :             {
<span class="lineNum">   15947 </span>            :               inform (next_token-&gt;location, &quot;(if you use %&lt;-fpermissive%&gt; &quot;
<span class="lineNum">   15948 </span><span class="lineCov">   17681816 :                       &quot;or %&lt;-std=c++11%&gt;, or %&lt;-std=gnu++11%&gt; G++ will &quot;</span>
<span class="lineNum">   15949 </span>            :                       &quot;accept your code)&quot;);
<span class="lineNum">   15950 </span><span class="lineCov">          1 :               hint = true;</span>
<span class="lineNum">   15951 </span><span class="lineCov">          1 :             }</span>
<span class="lineNum">   15952 </span>            :         }
<span class="lineNum">   15953 </span><span class="lineCov">    8840909 :     }</span>
<span class="lineNum">   15954 </span>            :   else
<span class="lineNum">   15955 </span><span class="lineCov">          1 :     {</span>
<span class="lineNum">   15956 </span>            :       /* Look for the `&lt;' that starts the template-argument-list.  */
<span class="lineNum">   15957 </span><span class="lineCov">          1 :       if (!cp_parser_require (parser, CPP_LESS, RT_LESS))</span>
<span class="lineNum">   15958 </span>            :         {
<span class="lineNum">   15959 </span>            :           pop_deferring_access_checks ();
<span class="lineNum">   15960 </span><span class="lineCov">          1 :           return error_mark_node;</span>
<span class="lineNum">   15961 </span>            :         }
<span class="lineNum">   15962 </span>            :       /* Parse the arguments.  */
<span class="lineNum">   15963 </span><span class="lineCov">          1 :       arguments = cp_parser_enclosed_template_argument_list (parser);</span>
<span class="lineNum">   15964 </span><span class="lineCov">          1 :     }</span>
<span class="lineNum">   15965 </span>            : 
<span class="lineNum">   15966 </span>            :   /* Set the location to be of the form:
<span class="lineNum">   15967 </span>            :      template-name &lt; template-argument-list [opt] &gt;
<span class="lineNum">   15968 </span>            :      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<span class="lineNum">   15969 </span><span class="lineNoCov">          0 :      with caret == start at the start of the template-name,</span>
<span class="lineNum">   15970 </span><span class="lineNoCov">          0 :      ranging until the closing '&gt;'.  */</span>
<span class="lineNum">   15971 </span><span class="lineNoCov">          0 :   location_t finish_loc</span>
<span class="lineNum">   15972 </span><span class="lineNoCov">          0 :     = get_finish (cp_lexer_previous_token (parser-&gt;lexer)-&gt;location);</span>
<span class="lineNum">   15973 </span>            :   location_t combined_loc
<span class="lineNum">   15974 </span>            :     = make_location (token-&gt;location, token-&gt;location, finish_loc);
<span class="lineNum">   15975 </span>            : 
<span class="lineNum">   15976 </span><span class="lineCov">          1 :   /* Check for concepts autos where they don't belong.  We could</span>
<span class="lineNum">   15977 </span>            :      identify types in some cases of idnetifier TEMPL, looking ahead
<span class="lineNum">   15978 </span>            :      for a CPP_SCOPE, but that would buy us nothing: we accept auto in
<span class="lineNum">   15979 </span><span class="lineCov">          1 :      types.  We reject them in functions, but if what we have is an</span>
<span class="lineNum">   15980 </span><span class="lineCov">          1 :      identifier, even with none_type we can't conclude it's NOT a</span>
<span class="lineNum">   15981 </span>            :      type, we have to wait for template substitution.  */
<span class="lineNum">   15982 </span>            :   if (flag_concepts &amp;&amp; check_auto_in_tmpl_args (templ, arguments))
<span class="lineNum">   15983 </span><span class="lineCov">          1 :     template_id = error_mark_node;</span>
<span class="lineNum">   15984 </span>            :   /* Build a representation of the specialization.  */
<span class="lineNum">   15985 </span><span class="lineNoCov">          0 :   else if (identifier_p (templ))</span>
<span class="lineNum">   15986 </span>            :     template_id = build_min_nt_loc (combined_loc,
<span class="lineNum">   15987 </span>            :                                     TEMPLATE_ID_EXPR,
<span class="lineNum">   15988 </span><span class="lineNoCov">          0 :                                     templ, arguments);</span>
<span class="lineNum">   15989 </span>            :   else if (DECL_TYPE_TEMPLATE_P (templ)
<span class="lineNum">   15990 </span>            :            || DECL_TEMPLATE_TEMPLATE_PARM_P (templ))
<span class="lineNum">   15991 </span>            :     {
<span class="lineNum">   15992 </span>            :       /* In &quot;template &lt;typename T&gt; ... A&lt;T&gt;::&quot;, A&lt;T&gt; is the abstract A
<span class="lineNum">   15993 </span>            :          template (rather than some instantiation thereof) only if
<span class="lineNum">   15994 </span>            :          is not nested within some other construct.  For example, in
<span class="lineNum">   15995 </span><span class="lineCov">    8840907 :          &quot;template &lt;typename T&gt; void f(T) { A&lt;T&gt;::&quot;, A&lt;T&gt; is just an</span>
<span class="lineNum">   15996 </span>            :          instantiation of A.  */
<span class="lineNum">   15997 </span><span class="lineCov">     467717 :       bool entering_scope</span>
<span class="lineNum">   15998 </span><span class="lineCov">     467717 :         = (template_parm_scope_p ()</span>
<span class="lineNum">   15999 </span>            :            &amp;&amp; cp_lexer_next_token_is (parser-&gt;lexer, CPP_SCOPE));
<span class="lineNum">   16000 </span>            :       template_id
<span class="lineNum">   16001 </span><span class="lineCov">    8373190 :         = finish_template_type (templ, arguments, entering_scope);</span>
<span class="lineNum">   16002 </span>            :     }
<span class="lineNum">   16003 </span>            :   /* A template-like identifier may be a partial concept id. */
<span class="lineNum">   16004 </span>            :   else if (flag_concepts
<span class="lineNum">   16005 </span>            :            &amp;&amp; (template_id = (cp_parser_maybe_partial_concept_id
<span class="lineNum">   16006 </span>            :                               (parser, templ, arguments))))
<span class="lineNum">   16007 </span>            :     return template_id;
<span class="lineNum">   16008 </span>            :   else if (variable_template_p (templ))
<span class="lineNum">   16009 </span><span class="lineCov">    8373191 :     {</span>
<span class="lineNum">   16010 </span><span class="lineCov">    8373191 :       template_id = lookup_template_variable (templ, arguments);</span>
<span class="lineNum">   16011 </span><span class="lineCov">    8373191 :       if (TREE_CODE (template_id) == TEMPLATE_ID_EXPR)</span>
<span class="lineNum">   16012 </span><span class="lineCov">    8373191 :         SET_EXPR_LOCATION (template_id, combined_loc);</span>
<span class="lineNum">   16013 </span>            :     }
<span class="lineNum">   16014 </span>            :   else
<span class="lineNum">   16015 </span>            :     {
<span class="lineNum">   16016 </span>            :       /* If it's not a class-template or a template-template, it should be
<span class="lineNum">   16017 </span>            :          a function-template.  */
<span class="lineNum">   16018 </span>            :       gcc_assert ((DECL_FUNCTION_TEMPLATE_P (templ)
<span class="lineNum">   16019 </span>            :                    || TREE_CODE (templ) == OVERLOAD
<span class="lineNum">   16020 </span><span class="lineCov">    8373191 :                    || BASELINK_P (templ)));</span>
<span class="lineNum">   16021 </span><span class="lineCov">          2 : </span>
<span class="lineNum">   16022 </span>            :       template_id = lookup_template_function (templ, arguments);
<span class="lineNum">   16023 </span><span class="lineCov">    8373189 :       if (TREE_CODE (template_id) == TEMPLATE_ID_EXPR)</span>
<span class="lineNum">   16024 </span><span class="lineCov">     175344 :         SET_EXPR_LOCATION (template_id, combined_loc);</span>
<span class="lineNum">   16025 </span>            :     }
<span class="lineNum">   16026 </span>            : 
<span class="lineNum">   16027 </span><span class="lineCov">   14916318 :   /* If parsing tentatively, replace the sequence of tokens that makes</span>
<span class="lineNum">   16028 </span><span class="lineCov">    8211568 :      up the template-id with a CPP_TEMPLATE_ID token.  That way,</span>
<span class="lineNum">   16029 </span>            :      should we re-parse the token stream, we will not have to repeat
<span class="lineNum">   16030 </span>            :      the effort required to do the parse, nor will we issue duplicate
<span class="lineNum">   16031 </span>            :      error messages about problems during instantiation of the
<span class="lineNum">   16032 </span>            :      template.  */
<span class="lineNum">   16033 </span>            :   if (start_of_id
<span class="lineNum">   16034 </span>            :       /* Don't do this if we had a parse error in a declarator; re-parsing
<span class="lineNum">   16035 </span><span class="lineCov">    7444436 :          might succeed if a name changes meaning (60361).  */</span>
<span class="lineNum">   16036 </span><span class="lineCov">    7444436 :       &amp;&amp; !(cp_parser_error_occurred (parser)</span>
<span class="lineNum">   16037 </span><span class="lineCov">    7444436 :            &amp;&amp; cp_parser_parsing_tentatively (parser)</span>
<span class="lineNum">   16038 </span><span class="lineCov">    7444436 :            &amp;&amp; parser-&gt;in_declarator_p))</span>
<span class="lineNum">   16039 </span><span class="lineCov">    7444436 :     {</span>
<span class="lineNum">   16040 </span>            :       /* Reset the contents of the START_OF_ID token.  */
<span class="lineNum">   16041 </span>            :       token-&gt;type = CPP_TEMPLATE_ID;
<span class="lineNum">   16042 </span><span class="lineCov">     753409 :       token-&gt;location = combined_loc;</span>
<span class="lineNum">   16043 </span><span class="lineCov">     753409 : </span>
<span class="lineNum">   16044 </span><span class="lineCov">       1561 :       /* Retrieve any deferred checks.  Do not pop this access checks yet</span>
<span class="lineNum">   16045 </span>            :          so the memory will not be reclaimed during token replacing below.  */
<span class="lineNum">   16046 </span><span class="lineCov">     753334 :       token-&gt;u.tree_check_value = ggc_cleared_alloc&lt;struct tree_check&gt; ();</span>
<span class="lineNum">   16047 </span>            :       token-&gt;u.tree_check_value-&gt;value = template_id;
<span class="lineNum">   16048 </span><span class="lineCov">      13693 :       token-&gt;u.tree_check_value-&gt;checks = get_deferred_access_checks ();</span>
<span class="lineNum">   16049 </span><span class="lineCov">      13693 :       token-&gt;keyword = RID_MAX;</span>
<span class="lineNum">   16050 </span><span class="lineCov">      13693 : </span>
<span class="lineNum">   16051 </span>            :       /* Purge all subsequent tokens.  */
<span class="lineNum">   16052 </span>            :       cp_lexer_purge_tokens_after (parser-&gt;lexer, start_of_id);
<span class="lineNum">   16053 </span>            : 
<span class="lineNum">   16054 </span>            :       /* ??? Can we actually assume that, if template_id ==
<span class="lineNum">   16055 </span>            :          error_mark_node, we will have issued a diagnostic to the
<span class="lineNum">   16056 </span><span class="lineCov">     739641 :          user, as opposed to simply marking the tentative parse as</span>
<span class="lineNum">   16057 </span>            :          failed?  */
<span class="lineNum">   16058 </span>            :       if (cp_parser_error_occurred (parser) &amp;&amp; template_id != error_mark_node)
<span class="lineNum">   16059 </span>            :         error_at (token-&gt;location, &quot;parse error in template argument list&quot;);
<span class="lineNum">   16060 </span><span class="lineCov">     739641 :     }</span>
<span class="lineNum">   16061 </span><span class="lineCov">     739641 : </span>
<span class="lineNum">   16062 </span><span class="lineCov">     729785 :   pop_to_parent_deferring_access_checks ();</span>
<span class="lineNum">   16063 </span>            :   return template_id;
<span class="lineNum">   16064 </span>            : }
<span class="lineNum">   16065 </span>            : 
<span class="lineNum">   16066 </span>            : /* Parse a template-name.
<span class="lineNum">   16067 </span>            : 
<span class="lineNum">   16068 </span>            :    template-name:
<span class="lineNum">   16069 </span>            :      identifier
<span class="lineNum">   16070 </span>            : 
<span class="lineNum">   16071 </span><span class="lineCov">    8373116 :    The standard should actually say:</span>
<span class="lineNum">   16072 </span>            : 
<span class="lineNum">   16073 </span>            :    template-name:
<span class="lineNum">   16074 </span><span class="lineCov">    8373116 :      identifier</span>
<span class="lineNum">   16075 </span><span class="lineCov">        108 :      operator-function-id</span>
<span class="lineNum">   16076 </span><span class="lineCov">        108 : </span>
<span class="lineNum">   16077 </span>            :    A defect report has been filed about this issue.
<span class="lineNum">   16078 </span>            : 
<span class="lineNum">   16079 </span><span class="lineCov">    8373080 :    A conversion-function-id cannot be a template name because they cannot</span>
<span class="lineNum">   16080 </span><span class="lineCov">    8373080 :    be part of a template-id. In fact, looking at this code:</span>
<span class="lineNum">   16081 </span>            : 
<span class="lineNum">   16082 </span>            :    a.operator K&lt;int&gt;()
<span class="lineNum">   16083 </span>            : 
<span class="lineNum">   16084 </span><span class="lineCov">    8373080 :    the conversion-function-id is &quot;operator K&lt;int&gt;&quot;, and K&lt;int&gt; is a type-id.</span>
<span class="lineNum">   16085 </span><span class="lineCov">    8373080 :    It is impossible to call a templated conversion-function-id with an</span>
<span class="lineNum">   16086 </span><span class="lineCov">    8373080 :    explicit argument list, since the only allowed template parameter is</span>
<span class="lineNum">   16087 </span><span class="lineCov">    8373080 :    the type to which it is converting.</span>
<span class="lineNum">   16088 </span>            : 
<span class="lineNum">   16089 </span>            :    If TEMPLATE_KEYWORD_P is true, then we have just seen the
<span class="lineNum">   16090 </span><span class="lineCov">    8373080 :    `template' keyword, in a construction like:</span>
<span class="lineNum">   16091 </span>            : 
<span class="lineNum">   16092 </span>            :      T::template f&lt;3&gt;()
<span class="lineNum">   16093 </span>            : 
<span class="lineNum">   16094 </span>            :    In that case `f' is taken to be a template-name, even though there
<span class="lineNum">   16095 </span>            :    is no way of knowing for sure.
<span class="lineNum">   16096 </span><span class="lineCov">         84 : </span>
<span class="lineNum">   16097 </span><span class="lineCov">         19 :    Returns the TEMPLATE_DECL for the template, or an OVERLOAD if the</span>
<span class="lineNum">   16098 </span>            :    name refers to a set of overloaded functions, at least one of which
<span class="lineNum">   16099 </span>            :    is a template, or an IDENTIFIER_NODE with the name of the template,
<span class="lineNum">   16100 </span><span class="lineCov">    8373116 :    if TEMPLATE_KEYWORD_P is true.  If CHECK_DEPENDENCY_P is FALSE,</span>
<span class="lineNum">   16101 </span><span class="lineCov">    8373116 :    names are looked up inside uninstantiated templates.  */</span>
<a name="16102"><span class="lineNum">   16102 </span>            : </a>
<span class="lineNum">   16103 </span>            : static tree
<span class="lineNum">   16104 </span>            : cp_parser_template_name (cp_parser* parser,
<span class="lineNum">   16105 </span>            :                          bool template_keyword_p,
<span class="lineNum">   16106 </span>            :                          bool check_dependency_p,
<span class="lineNum">   16107 </span>            :                          bool is_declaration,
<span class="lineNum">   16108 </span>            :                          enum tag_types tag_type,
<span class="lineNum">   16109 </span>            :                          bool *is_identifier)
<span class="lineNum">   16110 </span>            : {
<span class="lineNum">   16111 </span>            :   tree identifier;
<span class="lineNum">   16112 </span>            :   tree decl;
<span class="lineNum">   16113 </span>            :   cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   16114 </span>            : 
<span class="lineNum">   16115 </span>            :   /* If the next token is `operator', then we have either an
<span class="lineNum">   16116 </span>            :      operator-function-id or a conversion-function-id.  */
<span class="lineNum">   16117 </span>            :   if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_OPERATOR))
<span class="lineNum">   16118 </span>            :     {
<span class="lineNum">   16119 </span>            :       /* We don't know whether we're looking at an
<span class="lineNum">   16120 </span>            :          operator-function-id or a conversion-function-id.  */
<span class="lineNum">   16121 </span>            :       cp_parser_parse_tentatively (parser);
<span class="lineNum">   16122 </span>            :       /* Try an operator-function-id.  */
<span class="lineNum">   16123 </span>            :       identifier = cp_parser_operator_function_id (parser);
<span class="lineNum">   16124 </span>            :       /* If that didn't work, try a conversion-function-id.  */
<span class="lineNum">   16125 </span>            :       if (!cp_parser_parse_definitely (parser))
<span class="lineNum">   16126 </span>            :         {
<span class="lineNum">   16127 </span>            :           cp_parser_error (parser, &quot;expected template-name&quot;);
<span class="lineNum">   16128 </span>            :           return error_mark_node;
<span class="lineNum">   16129 </span>            :         }
<span class="lineNum">   16130 </span>            :     }
<span class="lineNum">   16131 </span>            :   /* Look for the identifier.  */
<span class="lineNum">   16132 </span>            :   else
<span class="lineNum">   16133 </span>            :     identifier = cp_parser_identifier (parser);
<span class="lineNum">   16134 </span>            : 
<span class="lineNum">   16135 </span>            :   /* If we didn't find an identifier, we don't have a template-id.  */
<span class="lineNum">   16136 </span>            :   if (identifier == error_mark_node)
<span class="lineNum">   16137 </span>            :     return error_mark_node;
<span class="lineNum">   16138 </span>            : 
<span class="lineNum">   16139 </span>            :   /* If the name immediately followed the `template' keyword, then it
<span class="lineNum">   16140 </span>            :      is a template-name.  However, if the next token is not `&lt;', then
<span class="lineNum">   16141 </span>            :      we do not treat it as a template-name, since it is not being used
<span class="lineNum">   16142 </span><span class="lineCov">   12469178 :      as part of a template-id.  This enables us to handle constructs</span>
<span class="lineNum">   16143 </span>            :      like:
<span class="lineNum">   16144 </span>            : 
<span class="lineNum">   16145 </span>            :        template &lt;typename T&gt; struct S { S(); };
<span class="lineNum">   16146 </span>            :        template &lt;typename T&gt; S&lt;T&gt;::S();
<span class="lineNum">   16147 </span>            : 
<span class="lineNum">   16148 </span>            :      correctly.  We would treat `S' as a template -- if it were `S&lt;T&gt;'
<span class="lineNum">   16149 </span><span class="lineCov">   12469178 :      -- but we do not if there is no `&lt;'.  */</span>
<span class="lineNum">   16150 </span><span class="lineCov">   12469178 : </span>
<span class="lineNum">   16151 </span><span class="lineCov">   24938356 :   if (processing_template_decl</span>
<span class="lineNum">   16152 </span>            :       &amp;&amp; cp_parser_nth_token_starts_template_argument_list_p (parser, 1))
<span class="lineNum">   16153 </span>            :     {
<span class="lineNum">   16154 </span>            :       /* In a declaration, in a dependent context, we pretend that the
<span class="lineNum">   16155 </span><span class="lineCov">   12469178 :          &quot;template&quot; keyword was present in order to improve error</span>
<span class="lineNum">   16156 </span>            :          recovery.  For example, given:
<span class="lineNum">   16157 </span>            : 
<span class="lineNum">   16158 </span>            :            template &lt;typename T&gt; void f(T::X&lt;int&gt;);
<span class="lineNum">   16159 </span><span class="lineCov">    1524979 : </span>
<span class="lineNum">   16160 </span>            :          we want to treat &quot;X&lt;int&gt;&quot; as a template-id.  */
<span class="lineNum">   16161 </span><span class="lineCov">    1524979 :       if (is_declaration</span>
<span class="lineNum">   16162 </span>            :           &amp;&amp; !template_keyword_p
<span class="lineNum">   16163 </span><span class="lineCov">    1524979 :           &amp;&amp; parser-&gt;scope &amp;&amp; TYPE_P (parser-&gt;scope)</span>
<span class="lineNum">   16164 </span>            :           &amp;&amp; check_dependency_p
<span class="lineNum">   16165 </span><span class="lineCov">      79480 :           &amp;&amp; dependent_scope_p (parser-&gt;scope)</span>
<span class="lineNum">   16166 </span><span class="lineCov">      79480 :           /* Do not do this for dtors (or ctors), since they never</span>
<span class="lineNum">   16167 </span>            :              need the template keyword before their name.  */
<span class="lineNum">   16168 </span>            :           &amp;&amp; !constructor_name_p (identifier, parser-&gt;scope))
<span class="lineNum">   16169 </span>            :         {
<span class="lineNum">   16170 </span>            :           cp_token_position start = 0;
<span class="lineNum">   16171 </span><span class="lineCov">   10944199 : </span>
<span class="lineNum">   16172 </span>            :           /* Explain what went wrong.  */
<span class="lineNum">   16173 </span>            :           error_at (token-&gt;location, &quot;non-template %qD used as template&quot;,
<span class="lineNum">   16174 </span><span class="lineCov">   12389698 :                     identifier);</span>
<span class="lineNum">   16175 </span>            :           inform (token-&gt;location, &quot;use %&lt;%T::template %D%&gt; to indicate that it is a template&quot;,
<span class="lineNum">   16176 </span>            :                   parser-&gt;scope, identifier);
<span class="lineNum">   16177 </span>            :           /* If parsing tentatively, find the location of the &quot;&lt;&quot; token.  */
<span class="lineNum">   16178 </span>            :           if (cp_parser_simulate_error (parser))
<span class="lineNum">   16179 </span>            :             start = cp_lexer_token_position (parser-&gt;lexer, true);
<span class="lineNum">   16180 </span>            :           /* Parse the template arguments so that we can issue error
<span class="lineNum">   16181 </span>            :              messages about them.  */
<span class="lineNum">   16182 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   16183 </span>            :           cp_parser_enclosed_template_argument_list (parser);
<span class="lineNum">   16184 </span>            :           /* Skip tokens until we find a good place from which to
<span class="lineNum">   16185 </span>            :              continue parsing.  */
<span class="lineNum">   16186 </span>            :           cp_parser_skip_to_closing_parenthesis (parser,
<span class="lineNum">   16187 </span>            :                                                  /*recovering=*/true,
<span class="lineNum">   16188 </span>            :                                                  /*or_comma=*/true,
<span class="lineNum">   16189 </span><span class="lineCov">   12389662 :                                                  /*consume_paren=*/false);</span>
<span class="lineNum">   16190 </span><span class="lineCov">   12389662 :           /* If parsing tentatively, permanently remove the</span>
<span class="lineNum">   16191 </span>            :              template argument list.  That will prevent duplicate
<span class="lineNum">   16192 </span>            :              error messages from being issued about the missing
<span class="lineNum">   16193 </span>            :              &quot;template&quot; keyword.  */
<span class="lineNum">   16194 </span>            :           if (start)
<span class="lineNum">   16195 </span>            :             cp_lexer_purge_tokens_after (parser-&gt;lexer, start);
<span class="lineNum">   16196 </span>            :           if (is_identifier)
<span class="lineNum">   16197 </span>            :             *is_identifier = true;
<span class="lineNum">   16198 </span>            :           parser-&gt;context-&gt;object_type = NULL_TREE;
<span class="lineNum">   16199 </span><span class="lineCov">    9039368 :           return identifier;</span>
<span class="lineNum">   16200 </span><span class="lineCov">    9039368 :         }</span>
<span class="lineNum">   16201 </span><span class="lineCov">    1232609 : </span>
<span class="lineNum">   16202 </span><span class="lineCov">       3566 :       /* If the &quot;template&quot; keyword is present, then there is generally</span>
<span class="lineNum">   16203 </span><span class="lineCov">       3500 :          no point in doing name-lookup, so we just return IDENTIFIER.</span>
<span class="lineNum">   16204 </span>            :          But, if the qualifying scope is non-dependent then we can
<span class="lineNum">   16205 </span>            :          (and must) do name-lookup normally.  */
<span class="lineNum">   16206 </span><span class="lineCov">    9039389 :       if (template_keyword_p)</span>
<span class="lineNum">   16207 </span>            :         {
<span class="lineNum">   16208 </span><span class="lineCov">         21 :           tree scope = (parser-&gt;scope ? parser-&gt;scope</span>
<span class="lineNum">   16209 </span>            :                         : parser-&gt;context-&gt;object_type);
<span class="lineNum">   16210 </span>            :           if (scope &amp;&amp; TYPE_P (scope)
<span class="lineNum">   16211 </span><span class="lineCov">         21 :               &amp;&amp; (!CLASS_TYPE_P (scope)</span>
<span class="lineNum">   16212 </span>            :                   || (check_dependency_p &amp;&amp; dependent_type_p (scope))))
<span class="lineNum">   16213 </span><span class="lineCov">         21 :             {</span>
<span class="lineNum">   16214 </span>            :               /* We're optimizing away the call to cp_parser_lookup_name, but
<span class="lineNum">   16215 </span>            :                  we still need to do this.  */
<span class="lineNum">   16216 </span><span class="lineCov">         42 :               parser-&gt;context-&gt;object_type = NULL_TREE;</span>
<span class="lineNum">   16217 </span><span class="lineCov">         21 :               return identifier;</span>
<span class="lineNum">   16218 </span>            :             }
<span class="lineNum">   16219 </span>            :         }
<span class="lineNum">   16220 </span><span class="lineCov">         21 :     }</span>
<span class="lineNum">   16221 </span><span class="lineCov">         21 : </span>
<span class="lineNum">   16222 </span>            :   /* Look up the name.  */
<span class="lineNum">   16223 </span>            :   decl = cp_parser_lookup_name (parser, identifier,
<span class="lineNum">   16224 </span><span class="lineCov">         21 :                                 tag_type,</span>
<span class="lineNum">   16225 </span>            :                                 /*is_template=*/true,
<span class="lineNum">   16226 </span>            :                                 /*is_namespace=*/false,
<span class="lineNum">   16227 </span>            :                                 check_dependency_p,
<span class="lineNum">   16228 </span>            :                                 /*ambiguous_decls=*/NULL,
<span class="lineNum">   16229 </span>            :                                 token-&gt;location);
<span class="lineNum">   16230 </span>            : 
<span class="lineNum">   16231 </span>            :   decl = strip_using_decl (decl);
<span class="lineNum">   16232 </span><span class="lineCov">         21 : </span>
<span class="lineNum">   16233 </span><span class="lineCov">         21 :   /* If DECL is a template, then the name was a template-name.  */</span>
<span class="lineNum">   16234 </span><span class="lineCov">         21 :   if (TREE_CODE (decl) == TEMPLATE_DECL)</span>
<span class="lineNum">   16235 </span><span class="lineCov">         21 :     {</span>
<span class="lineNum">   16236 </span><span class="lineCov">         21 :       if (TREE_DEPRECATED (decl)</span>
<span class="lineNum">   16237 </span><span class="lineCov">         21 :           &amp;&amp; deprecated_state != DEPRECATED_SUPPRESS)</span>
<span class="lineNum">   16238 </span>            :         warn_deprecated_use (decl, NULL_TREE);
<span class="lineNum">   16239 </span>            :     }
<span class="lineNum">   16240 </span>            :   else
<span class="lineNum">   16241 </span>            :     {
<span class="lineNum">   16242 </span>            :       /* The standard does not explicitly indicate whether a name that
<span class="lineNum">   16243 </span>            :          names a set of overloaded declarations, some of which are
<span class="lineNum">   16244 </span><span class="lineCov">    9039347 :          templates, is a template-name.  However, such a name should</span>
<span class="lineNum">   16245 </span>            :          be a template-name; otherwise, there is no way to form a
<span class="lineNum">   16246 </span><span class="lineCov">     144888 :          template-id for the overloaded templates.  */</span>
<span class="lineNum">   16247 </span><span class="lineCov">        834 :       bool found = false;</span>
<span class="lineNum">   16248 </span><span class="lineCov">     144885 : </span>
<span class="lineNum">   16249 </span><span class="lineCov">     289755 :       for (lkp_iterator iter (MAYBE_BASELINK_FUNCTIONS (decl));</span>
<span class="lineNum">   16250 </span><span class="lineCov">     125789 :            !found &amp;&amp; iter; ++iter)</span>
<span class="lineNum">   16251 </span>            :         if (TREE_CODE (*iter) == TEMPLATE_DECL)
<span class="lineNum">   16252 </span>            :           found = true;
<span class="lineNum">   16253 </span>            : 
<span class="lineNum">   16254 </span><span class="lineCov">     143162 :       if (!found)</span>
<span class="lineNum">   16255 </span><span class="lineCov">     143162 :         {</span>
<span class="lineNum">   16256 </span>            :           /* The name does not name a template.  */
<span class="lineNum">   16257 </span>            :           cp_parser_error (parser, &quot;expected template-name&quot;);
<span class="lineNum">   16258 </span>            :           return error_mark_node;
<span class="lineNum">   16259 </span>            :         }
<span class="lineNum">   16260 </span>            :     }
<span class="lineNum">   16261 </span><span class="lineCov">   24492958 : </span>
<span class="lineNum">   16262 </span>            :   /* If DECL is dependent, and refers to a function, then just return
<span class="lineNum">   16263 </span>            :      its name; we will look it up again during template instantiation.  */
<span class="lineNum">   16264 </span>            :   if (DECL_FUNCTION_TEMPLATE_P (decl) || !DECL_P (decl))
<span class="lineNum">   16265 </span>            :     {
<span class="lineNum">   16266 </span>            :       tree scope = ovl_scope (decl);
<span class="lineNum">   16267 </span><span class="lineCov">   12246479 :       if (TYPE_P (scope) &amp;&amp; dependent_type_p (scope))</span>
<span class="lineNum">   16268 </span>            :         return identifier;
<span class="lineNum">   16269 </span><span class="lineCov">   12246479 :     }</span>
<span class="lineNum">   16270 </span>            : 
<span class="lineNum">   16271 </span>            :   return decl;
<span class="lineNum">   16272 </span><span class="lineCov">   12246479 : }</span>
<span class="lineNum">   16273 </span>            : 
<span class="lineNum">   16274 </span><span class="lineCov">   14929758 : /* Parse a template-argument-list.</span>
<span class="lineNum">   16275 </span><span class="lineCov">    7464879 : </span>
<span class="lineNum">   16276 </span><span class="lineCov">       8874 :    template-argument-list:</span>
<span class="lineNum">   16277 </span>            :      template-argument ... [opt]
<span class="lineNum">   16278 </span>            :      template-argument-list , template-argument ... [opt]
<span class="lineNum">   16279 </span>            : 
<span class="lineNum">   16280 </span>            :    Returns a TREE_VEC containing the arguments.  */
<a name="16281"><span class="lineNum">   16281 </span>            : </a>
<span class="lineNum">   16282 </span>            : static tree
<span class="lineNum">   16283 </span>            : cp_parser_template_argument_list (cp_parser* parser)
<span class="lineNum">   16284 </span>            : {
<span class="lineNum">   16285 </span><span class="lineCov">    4781600 :   tree fixed_args[10];</span>
<span class="lineNum">   16286 </span>            :   unsigned n_args = 0;
<span class="lineNum">   16287 </span><span class="lineCov">   10729367 :   unsigned alloced = 10;</span>
<span class="lineNum">   16288 </span><span class="lineCov">   16677134 :   tree *arg_ary = fixed_args;</span>
<span class="lineNum">   16289 </span><span class="lineCov">    5947767 :   tree vec;</span>
<span class="lineNum">   16290 </span><span class="lineCov">    1239714 :   bool saved_in_template_argument_list_p;</span>
<span class="lineNum">   16291 </span>            :   bool saved_ice_p;
<span class="lineNum">   16292 </span><span class="lineCov">    4781600 :   bool saved_non_ice_p;</span>
<span class="lineNum">   16293 </span>            : 
<span class="lineNum">   16294 </span>            :   saved_in_template_argument_list_p = parser-&gt;in_template_argument_list_p;
<span class="lineNum">   16295 </span><span class="lineCov">    3541886 :   parser-&gt;in_template_argument_list_p = true;</span>
<span class="lineNum">   16296 </span><span class="lineCov">    3541886 :   /* Even if the template-id appears in an integral</span>
<span class="lineNum">   16297 </span>            :      constant-expression, the contents of the argument list do
<span class="lineNum">   16298 </span>            :      not.  */
<span class="lineNum">   16299 </span>            :   saved_ice_p = parser-&gt;integral_constant_expression_p;
<span class="lineNum">   16300 </span>            :   parser-&gt;integral_constant_expression_p = false;
<span class="lineNum">   16301 </span>            :   saved_non_ice_p = parser-&gt;non_integral_constant_expression_p;
<span class="lineNum">   16302 </span><span class="lineCov">    8704593 :   parser-&gt;non_integral_constant_expression_p = false;</span>
<span class="lineNum">   16303 </span>            : 
<span class="lineNum">   16304 </span><span class="lineCov">    1239714 :   /* Parse the arguments.  */</span>
<span class="lineNum">   16305 </span><span class="lineCov">    1239714 :   do</span>
<span class="lineNum">   16306 </span><span class="lineCov">      63805 :     {</span>
<span class="lineNum">   16307 </span>            :       tree argument;
<span class="lineNum">   16308 </span>            : 
<span class="lineNum">   16309 </span>            :       if (n_args)
<span class="lineNum">   16310 </span>            :         /* Consume the comma.  */
<span class="lineNum">   16311 </span>            :         cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   16312 </span>            : 
<span class="lineNum">   16313 </span>            :       /* Parse the template-argument.  */
<span class="lineNum">   16314 </span>            :       argument = cp_parser_template_argument (parser);
<span class="lineNum">   16315 </span>            : 
<span class="lineNum">   16316 </span>            :       /* If the next token is an ellipsis, we're expanding a template
<span class="lineNum">   16317 </span>            :          argument pack. */
<span class="lineNum">   16318 </span>            :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_ELLIPSIS))
<span class="lineNum">   16319 </span>            :         {
<span class="lineNum">   16320 </span>            :           if (argument == error_mark_node)
<span class="lineNum">   16321 </span><span class="lineCov">    8351532 :             {</span>
<span class="lineNum">   16322 </span>            :               cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   16323 </span><span class="lineCov">    8351532 :               error_at (token-&gt;location,</span>
<span class="lineNum">   16324 </span><span class="lineCov">    8351532 :                         &quot;expected parameter pack before %&lt;...%&gt;&quot;);</span>
<span class="lineNum">   16325 </span><span class="lineCov">    8351532 :             }</span>
<span class="lineNum">   16326 </span><span class="lineCov">    8351532 :           /* Consume the `...' token. */</span>
<span class="lineNum">   16327 </span><span class="lineCov">    8351532 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   16328 </span><span class="lineCov">    8351532 : </span>
<span class="lineNum">   16329 </span><span class="lineCov">    8351532 :           /* Make the argument into a TYPE_PACK_EXPANSION or</span>
<span class="lineNum">   16330 </span><span class="lineCov">    8351532 :              EXPR_PACK_EXPANSION. */</span>
<span class="lineNum">   16331 </span>            :           argument = make_pack_expansion (argument);
<span class="lineNum">   16332 </span><span class="lineCov">    8351532 :         }</span>
<span class="lineNum">   16333 </span><span class="lineCov">    8351532 : </span>
<span class="lineNum">   16334 </span>            :       if (n_args == alloced)
<span class="lineNum">   16335 </span>            :         {
<span class="lineNum">   16336 </span>            :           alloced *= 2;
<span class="lineNum">   16337 </span><span class="lineCov">    8351532 : </span>
<span class="lineNum">   16338 </span><span class="lineCov">    8351532 :           if (arg_ary == fixed_args)</span>
<span class="lineNum">   16339 </span><span class="lineCov">    8351532 :             {</span>
<span class="lineNum">   16340 </span><span class="lineCov">    8351532 :               arg_ary = XNEWVEC (tree, alloced);</span>
<span class="lineNum">   16341 </span>            :               memcpy (arg_ary, fixed_args, sizeof (tree) * n_args);
<span class="lineNum">   16342 </span>            :             }
<span class="lineNum">   16343 </span><span class="lineCov">   13948970 :           else</span>
<span class="lineNum">   16344 </span>            :             arg_ary = XRESIZEVEC (tree, arg_ary, alloced);
<span class="lineNum">   16345 </span><span class="lineCov">   13948970 :         }</span>
<span class="lineNum">   16346 </span>            :       arg_ary[n_args++] = argument;
<span class="lineNum">   16347 </span><span class="lineCov">   13948970 :     }</span>
<span class="lineNum">   16348 </span>            :   while (cp_lexer_next_token_is (parser-&gt;lexer, CPP_COMMA));
<span class="lineNum">   16349 </span><span class="lineCov">    5597438 : </span>
<span class="lineNum">   16350 </span>            :   vec = make_tree_vec (n_args);
<span class="lineNum">   16351 </span>            : 
<span class="lineNum">   16352 </span><span class="lineCov">   13948970 :   while (n_args--)</span>
<span class="lineNum">   16353 </span>            :     TREE_VEC_ELT (vec, n_args) = arg_ary[n_args];
<span class="lineNum">   16354 </span>            : 
<span class="lineNum">   16355 </span>            :   if (arg_ary != fixed_args)
<span class="lineNum">   16356 </span><span class="lineCov">   13948970 :     free (arg_ary);</span>
<span class="lineNum">   16357 </span>            :   parser-&gt;non_integral_constant_expression_p = saved_non_ice_p;
<span class="lineNum">   16358 </span><span class="lineCov">     424873 :   parser-&gt;integral_constant_expression_p = saved_ice_p;</span>
<span class="lineNum">   16359 </span>            :   parser-&gt;in_template_argument_list_p = saved_in_template_argument_list_p;
<span class="lineNum">   16360 </span><span class="lineCov">         12 :   if (CHECKING_P)</span>
<span class="lineNum">   16361 </span><span class="lineCov">          6 :     SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (vec, TREE_VEC_LENGTH (vec));</span>
<span class="lineNum">   16362 </span>            :   return vec;
<span class="lineNum">   16363 </span>            : }
<span class="lineNum">   16364 </span>            : 
<span class="lineNum">   16365 </span><span class="lineCov">     424873 : /* Parse a template-argument.</span>
<span class="lineNum">   16366 </span>            : 
<span class="lineNum">   16367 </span>            :    template-argument:
<span class="lineNum">   16368 </span>            :      assignment-expression
<span class="lineNum">   16369 </span><span class="lineCov">     424873 :      type-id</span>
<span class="lineNum">   16370 </span>            :      id-expression
<span class="lineNum">   16371 </span>            : 
<span class="lineNum">   16372 </span><span class="lineCov">   13948970 :    The representation is that of an assignment-expression, type-id, or</span>
<span class="lineNum">   16373 </span>            :    id-expression -- except that the qualified id-expression is
<span class="lineNum">   16374 </span><span class="lineCov">      39306 :    evaluated, so that the value returned is either a DECL or an</span>
<span class="lineNum">   16375 </span>            :    OVERLOAD.
<span class="lineNum">   16376 </span><span class="lineCov">      39306 : </span>
<span class="lineNum">   16377 </span>            :    Although the standard says &quot;assignment-expression&quot;, it forbids
<span class="lineNum">   16378 </span><span class="lineCov">      39292 :    throw-expressions or assignments in the template argument.</span>
<span class="lineNum">   16379 </span><span class="lineCov">      39292 :    Therefore, we use &quot;conditional-expression&quot; instead.  */</span>
<a name="16380"><span class="lineNum">   16380 </span>            : </a>
<span class="lineNum">   16381 </span>            : static tree
<span class="lineNum">   16382 </span><span class="lineCov">         14 : cp_parser_template_argument (cp_parser* parser)</span>
<span class="lineNum">   16383 </span>            : {
<span class="lineNum">   16384 </span><span class="lineCov">   13948970 :   tree argument;</span>
<span class="lineNum">   16385 </span>            :   bool template_p;
<span class="lineNum">   16386 </span><span class="lineCov">   13948970 :   bool address_p;</span>
<span class="lineNum">   16387 </span>            :   bool maybe_type_id = false;
<span class="lineNum">   16388 </span><span class="lineCov">    8351532 :   cp_token *token = NULL, *argument_start_token = NULL;</span>
<span class="lineNum">   16389 </span>            :   location_t loc = 0;
<span class="lineNum">   16390 </span><span class="lineCov">   22300502 :   cp_id_kind idk;</span>
<span class="lineNum">   16391 </span><span class="lineCov">   13948970 : </span>
<span class="lineNum">   16392 </span>            :   /* There's really no way to know what we're looking at, so we just
<span class="lineNum">   16393 </span><span class="lineCov">    8351532 :      try each alternative in order.</span>
<span class="lineNum">   16394 </span><span class="lineCov">      39292 : </span>
<span class="lineNum">   16395 </span><span class="lineCov">    8351532 :        [temp.arg]</span>
<span class="lineNum">   16396 </span><span class="lineCov">    8351532 : </span>
<span class="lineNum">   16397 </span><span class="lineCov">    8351532 :        In a template-argument, an ambiguity between a type-id and an</span>
<span class="lineNum">   16398 </span><span class="lineCov">    8351532 :        expression is resolved to a type-id, regardless of the form of</span>
<span class="lineNum">   16399 </span><span class="lineCov">    8351532 :        the corresponding template-parameter.</span>
<span class="lineNum">   16400 </span><span class="lineCov">    8351532 : </span>
<span class="lineNum">   16401 </span>            :      Therefore, we try a type-id first.  */
<span class="lineNum">   16402 </span>            :   cp_parser_parse_tentatively (parser);
<span class="lineNum">   16403 </span>            :   argument = cp_parser_template_type_arg (parser);
<span class="lineNum">   16404 </span>            :   /* If there was no error parsing the type-id but the next token is a
<span class="lineNum">   16405 </span>            :      '&gt;&gt;', our behavior depends on which dialect of C++ we're
<span class="lineNum">   16406 </span>            :      parsing. In C++98, we probably found a typo for '&gt; &gt;'. But there
<span class="lineNum">   16407 </span>            :      are type-id which are also valid expressions. For instance:
<span class="lineNum">   16408 </span>            : 
<span class="lineNum">   16409 </span>            :      struct X { int operator &gt;&gt; (int); };
<span class="lineNum">   16410 </span>            :      template &lt;int V&gt; struct Foo {};
<span class="lineNum">   16411 </span>            :      Foo&lt;X () &gt;&gt; 5&gt; r;
<span class="lineNum">   16412 </span>            : 
<span class="lineNum">   16413 </span>            :      Here 'X()' is a valid type-id of a function type, but the user just
<span class="lineNum">   16414 </span>            :      wanted to write the expression &quot;X() &gt;&gt; 5&quot;. Thus, we remember that we
<span class="lineNum">   16415 </span>            :      found a valid type-id, but we still try to parse the argument as an
<span class="lineNum">   16416 </span>            :      expression to see what happens. 
<span class="lineNum">   16417 </span>            : 
<span class="lineNum">   16418 </span>            :      In C++0x, the '&gt;&gt;' will be considered two separate '&gt;'
<span class="lineNum">   16419 </span>            :      tokens.  */
<span class="lineNum">   16420 </span><span class="lineCov">   13948970 :   if (!cp_parser_error_occurred (parser)</span>
<span class="lineNum">   16421 </span>            :       &amp;&amp; cxx_dialect == cxx98
<span class="lineNum">   16422 </span><span class="lineCov">   13948970 :       &amp;&amp; cp_lexer_next_token_is (parser-&gt;lexer, CPP_RSHIFT))</span>
<span class="lineNum">   16423 </span><span class="lineCov">   13948970 :     {</span>
<span class="lineNum">   16424 </span><span class="lineCov">   13948970 :       maybe_type_id = true;</span>
<span class="lineNum">   16425 </span><span class="lineCov">   13948970 :       cp_parser_abort_tentative_parse (parser);</span>
<span class="lineNum">   16426 </span><span class="lineCov">   13948970 :     }</span>
<span class="lineNum">   16427 </span><span class="lineCov">   13948970 :   else</span>
<span class="lineNum">   16428 </span><span class="lineCov">   13948970 :     {</span>
<span class="lineNum">   16429 </span>            :       /* If the next token isn't a `,' or a `&gt;', then this argument wasn't
<span class="lineNum">   16430 </span>            :       really finished. This means that the argument is not a valid
<span class="lineNum">   16431 </span>            :       type-id.  */
<span class="lineNum">   16432 </span>            :       if (!cp_parser_next_token_ends_template_argument_p (parser))
<span class="lineNum">   16433 </span>            :         cp_parser_error (parser, &quot;expected template-argument&quot;);
<span class="lineNum">   16434 </span>            :       /* If that worked, we're done.  */
<span class="lineNum">   16435 </span>            :       if (cp_parser_parse_definitely (parser))
<span class="lineNum">   16436 </span>            :         return argument;
<span class="lineNum">   16437 </span>            :     }
<span class="lineNum">   16438 </span>            :   /* We're still not sure what the argument will be.  */
<span class="lineNum">   16439 </span>            :   cp_parser_parse_tentatively (parser);
<span class="lineNum">   16440 </span><span class="lineCov">   13948970 :   /* Try a template.  */</span>
<span class="lineNum">   16441 </span><span class="lineCov">   13948970 :   argument_start_token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   16442 </span>            :   argument = cp_parser_id_expression (parser,
<span class="lineNum">   16443 </span>            :                                       /*template_keyword_p=*/false,
<span class="lineNum">   16444 </span>            :                                       /*check_dependency_p=*/true,
<span class="lineNum">   16445 </span>            :                                       &amp;template_p,
<span class="lineNum">   16446 </span>            :                                       /*declarator_p=*/false,
<span class="lineNum">   16447 </span>            :                                       /*optional_p=*/false);
<span class="lineNum">   16448 </span>            :   /* If the next token isn't a `,' or a `&gt;', then this argument wasn't
<span class="lineNum">   16449 </span>            :      really finished.  */
<span class="lineNum">   16450 </span>            :   if (!cp_parser_next_token_ends_template_argument_p (parser))
<span class="lineNum">   16451 </span>            :     cp_parser_error (parser, &quot;expected template-argument&quot;);
<span class="lineNum">   16452 </span>            :   if (!cp_parser_error_occurred (parser))
<span class="lineNum">   16453 </span>            :     {
<span class="lineNum">   16454 </span>            :       /* Figure out what is being referred to.  If the id-expression
<span class="lineNum">   16455 </span>            :          was for a class template specialization, then we will have a
<span class="lineNum">   16456 </span>            :          TYPE_DECL at this point.  There is no need to do name lookup
<span class="lineNum">   16457 </span>            :          at this point in that case.  */
<span class="lineNum">   16458 </span><span class="lineCov">   26042280 :       if (TREE_CODE (argument) != TYPE_DECL)</span>
<span class="lineNum">   16459 </span><span class="lineCov">   12093310 :         argument = cp_parser_lookup_name (parser, argument,</span>
<span class="lineNum">   16460 </span><span class="lineCov">     509763 :                                           none_type,</span>
<span class="lineNum">   16461 </span>            :                                           /*is_template=*/template_p,
<span class="lineNum">   16462 </span><span class="lineCov">          7 :                                           /*is_namespace=*/false,</span>
<span class="lineNum">   16463 </span><span class="lineCov">          7 :                                           /*check_dependency=*/true,</span>
<span class="lineNum">   16464 </span>            :                                           /*ambiguous_decls=*/NULL,
<span class="lineNum">   16465 </span>            :                                           argument_start_token-&gt;location);
<span class="lineNum">   16466 </span>            :       /* Handle a constrained-type-specifier for a non-type template
<span class="lineNum">   16467 </span>            :          parameter.  */
<span class="lineNum">   16468 </span>            :       if (tree decl = cp_parser_maybe_concept_name (parser, argument))
<span class="lineNum">   16469 </span>            :         argument = decl;
<span class="lineNum">   16470 </span><span class="lineCov">   15789870 :       else if (TREE_CODE (argument) != TEMPLATE_DECL</span>
<span class="lineNum">   16471 </span><span class="lineCov">    1840907 :                &amp;&amp; TREE_CODE (argument) != UNBOUND_CLASS_TEMPLATE)</span>
<span class="lineNum">   16472 </span>            :         cp_parser_error (parser, &quot;expected template-name&quot;);
<span class="lineNum">   16473 </span><span class="lineCov">   13948963 :     }</span>
<span class="lineNum">   16474 </span>            :   if (cp_parser_parse_definitely (parser))
<span class="lineNum">   16475 </span>            :     {
<span class="lineNum">   16476 </span>            :       if (TREE_DEPRECATED (argument))
<span class="lineNum">   16477 </span><span class="lineCov">    1858359 :         warn_deprecated_use (argument, NULL_TREE);</span>
<span class="lineNum">   16478 </span>            :       return argument;
<span class="lineNum">   16479 </span><span class="lineCov">    3716718 :     }</span>
<span class="lineNum">   16480 </span><span class="lineCov">    3716718 :   /* It must be a non-type argument.  In C++17 any constant-expression is</span>
<span class="lineNum">   16481 </span>            :      allowed.  */
<span class="lineNum">   16482 </span>            :   if (cxx_dialect &gt; cxx14)
<span class="lineNum">   16483 </span>            :     goto general_expr;
<span class="lineNum">   16484 </span>            : 
<span class="lineNum">   16485 </span><span class="lineCov">    1858359 :   /* Otherwise, the permitted cases are given in [temp.arg.nontype]:</span>
<span class="lineNum">   16486 </span>            : 
<span class="lineNum">   16487 </span>            :      -- an integral constant-expression of integral or enumeration
<span class="lineNum">   16488 </span><span class="lineCov">    2726075 :         type; or</span>
<span class="lineNum">   16489 </span><span class="lineCov">     867716 : </span>
<span class="lineNum">   16490 </span><span class="lineCov">    2848994 :      -- the name of a non-type template-parameter; or</span>
<span class="lineNum">   16491 </span>            : 
<span class="lineNum">   16492 </span>            :      -- the name of an object or function with external linkage...
<span class="lineNum">   16493 </span>            : 
<span class="lineNum">   16494 </span>            :      -- the address of an object or function with external linkage...
<span class="lineNum">   16495 </span>            : 
<span class="lineNum">   16496 </span><span class="lineCov">     990635 :      -- a pointer to member...  */</span>
<span class="lineNum">   16497 </span><span class="lineCov">     990635 :   /* Look for a non-type template parameter.  */</span>
<span class="lineNum">   16498 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))
<span class="lineNum">   16499 </span>            :     {
<span class="lineNum">   16500 </span>            :       cp_parser_parse_tentatively (parser);
<span class="lineNum">   16501 </span>            :       argument = cp_parser_primary_expression (parser,
<span class="lineNum">   16502 </span>            :                                                /*address_p=*/false,
<span class="lineNum">   16503 </span><span class="lineCov">     990635 :                                                /*cast_p=*/false,</span>
<span class="lineNum">   16504 </span>            :                                                /*template_arg_p=*/true,
<span class="lineNum">   16505 </span>            :                                                &amp;idk);
<span class="lineNum">   16506 </span><span class="lineCov">     990635 :       if (TREE_CODE (argument) != TEMPLATE_PARM_INDEX</span>
<span class="lineNum">   16507 </span>            :           || !cp_parser_next_token_ends_template_argument_p (parser))
<span class="lineNum">   16508 </span><span class="lineCov">     990634 :         cp_parser_simulate_error (parser);</span>
<span class="lineNum">   16509 </span><span class="lineCov">     892457 :       if (cp_parser_parse_definitely (parser))</span>
<span class="lineNum">   16510 </span><span class="lineCov">     892391 :         return argument;</span>
<span class="lineNum">   16511 </span>            :     }
<span class="lineNum">   16512 </span><span class="lineCov">    1858359 : </span>
<span class="lineNum">   16513 </span>            :   /* If the next token is &quot;&amp;&quot;, the argument must be the address of an
<span class="lineNum">   16514 </span><span class="lineCov">      98244 :      object or function with external linkage.  */</span>
<span class="lineNum">   16515 </span><span class="lineCov">          3 :   address_p = cp_lexer_next_token_is (parser-&gt;lexer, CPP_AND);</span>
<span class="lineNum">   16516 </span><span class="lineCov">      98244 :   if (address_p)</span>
<span class="lineNum">   16517 </span>            :     {
<span class="lineNum">   16518 </span>            :       loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">   16519 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   16520 </span><span class="lineCov">    1760115 :     }</span>
<span class="lineNum">   16521 </span>            :   /* See if we might have an id-expression.  */
<span class="lineNum">   16522 </span>            :   token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   16523 </span>            :   if (token-&gt;type == CPP_NAME
<span class="lineNum">   16524 </span>            :       || token-&gt;keyword == RID_OPERATOR
<span class="lineNum">   16525 </span>            :       || token-&gt;type == CPP_SCOPE
<span class="lineNum">   16526 </span>            :       || token-&gt;type == CPP_TEMPLATE_ID
<span class="lineNum">   16527 </span>            :       || token-&gt;type == CPP_NESTED_NAME_SPECIFIER)
<span class="lineNum">   16528 </span>            :     {
<span class="lineNum">   16529 </span>            :       cp_parser_parse_tentatively (parser);
<span class="lineNum">   16530 </span>            :       argument = cp_parser_primary_expression (parser,
<span class="lineNum">   16531 </span>            :                                                address_p,
<span class="lineNum">   16532 </span>            :                                                /*cast_p=*/false,
<span class="lineNum">   16533 </span>            :                                                /*template_arg_p=*/true,
<span class="lineNum">   16534 </span>            :                                                &amp;idk);
<span class="lineNum">   16535 </span>            :       if (cp_parser_error_occurred (parser)
<span class="lineNum">   16536 </span><span class="lineCov">    1325473 :           || !cp_parser_next_token_ends_template_argument_p (parser))</span>
<span class="lineNum">   16537 </span>            :         cp_parser_abort_tentative_parse (parser);
<span class="lineNum">   16538 </span><span class="lineCov">     540272 :       else</span>
<span class="lineNum">   16539 </span><span class="lineCov">    1080544 :         {</span>
<span class="lineNum">   16540 </span>            :           tree probe;
<span class="lineNum">   16541 </span>            : 
<span class="lineNum">   16542 </span>            :           if (INDIRECT_REF_P (argument))
<span class="lineNum">   16543 </span><span class="lineCov">     540272 :             {</span>
<span class="lineNum">   16544 </span><span class="lineCov">     540272 :               /* Strip the dereference temporarily.  */</span>
<span class="lineNum">   16545 </span><span class="lineCov">     540272 :               gcc_assert (REFERENCE_REF_P (argument));</span>
<span class="lineNum">   16546 </span><span class="lineCov">      49040 :               argument = TREE_OPERAND (argument, 0);</span>
<span class="lineNum">   16547 </span><span class="lineCov">     540272 :             }</span>
<span class="lineNum">   16548 </span>            : 
<span class="lineNum">   16549 </span>            :           /* If we're in a template, we represent a qualified-id referring
<span class="lineNum">   16550 </span>            :              to a static data member as a SCOPE_REF even if the scope isn't
<span class="lineNum">   16551 </span>            :              dependent so that we can check access control later.  */
<span class="lineNum">   16552 </span>            :           probe = argument;
<span class="lineNum">   16553 </span><span class="lineCov">    1668482 :           if (TREE_CODE (probe) == SCOPE_REF)</span>
<span class="lineNum">   16554 </span><span class="lineCov">     834241 :             probe = TREE_OPERAND (probe, 1);</span>
<span class="lineNum">   16555 </span>            :           if (VAR_P (probe))
<span class="lineNum">   16556 </span><span class="lineCov">       1306 :             {</span>
<span class="lineNum">   16557 </span><span class="lineCov">        653 :               /* A variable without external linkage might still be a</span>
<span class="lineNum">   16558 </span>            :                  valid constant-expression, so no error is issued here
<span class="lineNum">   16559 </span>            :                  if the external-linkage check fails.  */
<span class="lineNum">   16560 </span><span class="lineCov">    1668482 :               if (!address_p &amp;&amp; !DECL_EXTERNAL_LINKAGE_P (probe))</span>
<span class="lineNum">   16561 </span><span class="lineCov">     834241 :                 cp_parser_simulate_error (parser);</span>
<span class="lineNum">   16562 </span><span class="lineCov">     784551 :             }</span>
<span class="lineNum">   16563 </span><span class="lineCov">     784551 :           else if (is_overloaded_fn (argument))</span>
<span class="lineNum">   16564 </span><span class="lineCov">     784503 :             /* All overloaded functions are allowed; if the external</span>
<span class="lineNum">   16565 </span><span class="lineCov">     778773 :                linkage test does not pass, an error will be issued</span>
<span class="lineNum">   16566 </span>            :                later.  */
<span class="lineNum">   16567 </span><span class="lineCov">     258723 :             ;</span>
<span class="lineNum">   16568 </span><span class="lineCov">     517446 :           else if (address_p</span>
<span class="lineNum">   16569 </span>            :                    &amp;&amp; (TREE_CODE (argument) == OFFSET_REF
<span class="lineNum">   16570 </span>            :                        || TREE_CODE (argument) == SCOPE_REF))
<span class="lineNum">   16571 </span>            :             /* A pointer-to-member.  */
<span class="lineNum">   16572 </span><span class="lineCov">     258723 :             ;</span>
<span class="lineNum">   16573 </span><span class="lineCov">     515602 :           else if (TREE_CODE (argument) == TEMPLATE_PARM_INDEX)</span>
<span class="lineNum">   16574 </span><span class="lineCov">     256879 :             ;</span>
<span class="lineNum">   16575 </span><span class="lineCov">      73468 :           else</span>
<span class="lineNum">   16576 </span>            :             cp_parser_simulate_error (parser);
<span class="lineNum">   16577 </span>            : 
<span class="lineNum">   16578 </span><span class="lineCov">     185255 :           if (cp_parser_parse_definitely (parser))</span>
<span class="lineNum">   16579 </span>            :             {
<span class="lineNum">   16580 </span><span class="lineCov">     185255 :               if (address_p)</span>
<span class="lineNum">   16581 </span>            :                 argument = build_x_unary_op (loc, ADDR_EXPR, argument,
<span class="lineNum">   16582 </span>            :                                              tf_warning_or_error);
<span class="lineNum">   16583 </span><span class="lineCov">         34 :               else</span>
<span class="lineNum">   16584 </span><span class="lineCov">         34 :                 argument = convert_from_reference (argument);</span>
<span class="lineNum">   16585 </span>            :               return argument;
<span class="lineNum">   16586 </span>            :             }
<span class="lineNum">   16587 </span>            :         }
<span class="lineNum">   16588 </span>            :     }
<span class="lineNum">   16589 </span>            :   /* If the argument started with &quot;&amp;&quot;, there are no other valid
<span class="lineNum">   16590 </span><span class="lineCov">     185255 :      alternatives at this point.  */</span>
<span class="lineNum">   16591 </span><span class="lineCov">     185255 :   if (address_p)</span>
<span class="lineNum">   16592 </span><span class="lineCov">     155810 :     {</span>
<span class="lineNum">   16593 </span><span class="lineCov">     185255 :       cp_parser_error (parser, &quot;invalid non-type template argument&quot;);</span>
<span class="lineNum">   16594 </span>            :       return error_mark_node;
<span class="lineNum">   16595 </span>            :     }
<span class="lineNum">   16596 </span>            : 
<span class="lineNum">   16597 </span>            :  general_expr:
<span class="lineNum">   16598 </span><span class="lineCov">      20184 :   /* If the argument wasn't successfully parsed as a type-id followed</span>
<span class="lineNum">   16599 </span><span class="lineCov">       7701 :      by '&gt;&gt;', the argument can only be a constant expression now.</span>
<span class="lineNum">   16600 </span>            :      Otherwise, we try parsing the constant-expression tentatively,
<span class="lineNum">   16601 </span><span class="lineCov">     165071 :      because the argument could really be a type-id.  */</span>
<span class="lineNum">   16602 </span>            :   if (maybe_type_id)
<span class="lineNum">   16603 </span>            :     cp_parser_parse_tentatively (parser);
<span class="lineNum">   16604 </span>            : 
<span class="lineNum">   16605 </span>            :   if (cxx_dialect &lt;= cxx14)
<span class="lineNum">   16606 </span><span class="lineCov">     164557 :     argument = cp_parser_constant_expression (parser);</span>
<span class="lineNum">   16607 </span><span class="lineCov">        219 :   else</span>
<span class="lineNum">   16608 </span><span class="lineCov">         93 :     {</span>
<span class="lineNum">   16609 </span>            :       /* With C++17 generalized non-type template arguments we need to handle
<span class="lineNum">   16610 </span>            :          lvalue constant expressions, too.  */
<span class="lineNum">   16611 </span><span class="lineCov">     164341 :       argument = cp_parser_assignment_expression (parser);</span>
<span class="lineNum">   16612 </span>            :       require_potential_constant_expression (argument);
<span class="lineNum">   16613 </span>            :     }
<span class="lineNum">   16614 </span><span class="lineCov">     164307 : </span>
<span class="lineNum">   16615 </span>            :   if (!maybe_type_id)
<span class="lineNum">   16616 </span><span class="lineCov">     185255 :     return argument;</span>
<span class="lineNum">   16617 </span>            :   if (!cp_parser_next_token_ends_template_argument_p (parser))
<span class="lineNum">   16618 </span><span class="lineCov">      13247 :     cp_parser_error (parser, &quot;expected template-argument&quot;);</span>
<span class="lineNum">   16619 </span><span class="lineCov">        636 :   if (cp_parser_parse_definitely (parser))</span>
<span class="lineNum">   16620 </span>            :     return argument;
<span class="lineNum">   16621 </span>            :   /* We did our best to parse the argument as a non type-id, but that
<span class="lineNum">   16622 </span><span class="lineCov">      12611 :      was the only alternative that matched (albeit with a '&gt;' after</span>
<span class="lineNum">   16623 </span><span class="lineCov">      13247 :      it). We can assume it's just a typo from the user, and a</span>
<span class="lineNum">   16624 </span>            :      diagnostic will then be issued.  */
<span class="lineNum">   16625 </span>            :   return cp_parser_template_type_arg (parser);
<span class="lineNum">   16626 </span>            : }
<span class="lineNum">   16627 </span>            : 
<span class="lineNum">   16628 </span>            : /* Parse an explicit-instantiation.
<span class="lineNum">   16629 </span><span class="lineCov">     820994 : </span>
<span class="lineNum">   16630 </span>            :    explicit-instantiation:
<span class="lineNum">   16631 </span><span class="lineCov">         17 :      template declaration</span>
<span class="lineNum">   16632 </span><span class="lineCov">         17 : </span>
<span class="lineNum">   16633 </span>            :    Although the standard says `declaration', what it really means is:
<span class="lineNum">   16634 </span>            : 
<span class="lineNum">   16635 </span><span class="lineCov">     820977 :    explicit-instantiation:</span>
<span class="lineNum">   16636 </span>            :      template decl-specifier-seq [opt] declarator [opt] ;
<span class="lineNum">   16637 </span>            : 
<span class="lineNum">   16638 </span>            :    Things like `template int S&lt;int&gt;::i = 5, int S&lt;double&gt;::j;' are not
<span class="lineNum">   16639 </span>            :    supposed to be allowed.  A defect report has been filed about this
<span class="lineNum">   16640 </span><span class="lineCov">    1255619 :    issue.</span>
<span class="lineNum">   16641 </span><span class="lineCov">          7 : </span>
<span class="lineNum">   16642 </span>            :    GNU Extension:
<span class="lineNum">   16643 </span><span class="lineCov">    1255619 : </span>
<span class="lineNum">   16644 </span><span class="lineCov">     820977 :    explicit-instantiation:</span>
<span class="lineNum">   16645 </span>            :      storage-class-specifier template
<span class="lineNum">   16646 </span>            :        decl-specifier-seq [opt] declarator [opt] ;
<span class="lineNum">   16647 </span>            :      function-specifier template
<span class="lineNum">   16648 </span>            :        decl-specifier-seq [opt] declarator [opt] ;  */
<a name="16649"><span class="lineNum">   16649 </span><span class="lineCov">     434642 : </span></a>
<span class="lineNum">   16650 </span><span class="lineCov">     434642 : static void</span>
<span class="lineNum">   16651 </span>            : cp_parser_explicit_instantiation (cp_parser* parser)
<span class="lineNum">   16652 </span>            : {
<span class="lineNum">   16653 </span><span class="lineCov">    1255619 :   int declares_class_or_enum;</span>
<span class="lineNum">   16654 </span>            :   cp_decl_specifier_seq decl_specifiers;
<span class="lineNum">   16655 </span><span class="lineCov">         12 :   tree extension_specifier = NULL_TREE;</span>
<span class="lineNum">   16656 </span><span class="lineCov">          5 : </span>
<span class="lineNum">   16657 </span><span class="lineCov">          7 :   timevar_push (TV_TEMPLATE_INST);</span>
<span class="lineNum">   16658 </span>            : 
<span class="lineNum">   16659 </span>            :   /* Look for an (optional) storage-class-specifier or
<span class="lineNum">   16660 </span>            :      function-specifier.  */
<span class="lineNum">   16661 </span>            :   if (cp_parser_allow_gnu_extensions_p (parser))
<span class="lineNum">   16662 </span>            :     {
<span class="lineNum">   16663 </span><span class="lineCov">          5 :       extension_specifier</span>
<span class="lineNum">   16664 </span>            :         = cp_parser_storage_class_specifier_opt (parser);
<span class="lineNum">   16665 </span>            :       if (!extension_specifier)
<span class="lineNum">   16666 </span>            :         extension_specifier
<span class="lineNum">   16667 </span>            :           = cp_parser_function_specifier_opt (parser,
<span class="lineNum">   16668 </span>            :                                               /*decl_specs=*/NULL);
<span class="lineNum">   16669 </span>            :     }
<span class="lineNum">   16670 </span>            : 
<span class="lineNum">   16671 </span>            :   /* Look for the `template' keyword.  */
<span class="lineNum">   16672 </span>            :   cp_parser_require_keyword (parser, RID_TEMPLATE, RT_TEMPLATE);
<span class="lineNum">   16673 </span>            :   /* Let the front end know that we are processing an explicit
<span class="lineNum">   16674 </span>            :      instantiation.  */
<span class="lineNum">   16675 </span>            :   begin_explicit_instantiation ();
<span class="lineNum">   16676 </span>            :   /* [temp.explicit] says that we are supposed to ignore access
<span class="lineNum">   16677 </span>            :      control while processing explicit instantiation directives.  */
<span class="lineNum">   16678 </span>            :   push_deferring_access_checks (dk_no_check);
<span class="lineNum">   16679 </span>            :   /* Parse a decl-specifier-seq.  */
<span class="lineNum">   16680 </span>            :   cp_parser_decl_specifier_seq (parser,
<span class="lineNum">   16681 </span>            :                                 CP_PARSER_FLAGS_OPTIONAL,
<span class="lineNum">   16682 </span>            :                                 &amp;decl_specifiers,
<span class="lineNum">   16683 </span>            :                                 &amp;declares_class_or_enum);
<span class="lineNum">   16684 </span>            :   /* If there was exactly one decl-specifier, and it declared a class,
<span class="lineNum">   16685 </span>            :      and there's no declarator, then we have an explicit type
<span class="lineNum">   16686 </span>            :      instantiation.  */
<span class="lineNum">   16687 </span>            :   if (declares_class_or_enum &amp;&amp; cp_parser_declares_only_class_p (parser))
<span class="lineNum">   16688 </span>            :     {
<span class="lineNum">   16689 </span><span class="lineCov">     150802 :       tree type;</span>
<span class="lineNum">   16690 </span>            : 
<span class="lineNum">   16691 </span><span class="lineCov">     150802 :       type = check_tag_decl (&amp;decl_specifiers,</span>
<span class="lineNum">   16692 </span><span class="lineCov">     150802 :                              /*explicit_type_instantiation_p=*/true);</span>
<span class="lineNum">   16693 </span><span class="lineCov">     150802 :       /* Turn access control back on for names used during</span>
<span class="lineNum">   16694 </span>            :          template instantiation.  */
<span class="lineNum">   16695 </span><span class="lineCov">     150802 :       pop_deferring_access_checks ();</span>
<span class="lineNum">   16696 </span>            :       if (type)
<span class="lineNum">   16697 </span>            :         do_type_instantiation (type, extension_specifier,
<span class="lineNum">   16698 </span>            :                                /*complain=*/tf_error);
<span class="lineNum">   16699 </span><span class="lineCov">     301604 :     }</span>
<span class="lineNum">   16700 </span>            :   else
<span class="lineNum">   16701 </span><span class="lineCov">     150802 :     {</span>
<span class="lineNum">   16702 </span><span class="lineCov">     150802 :       cp_declarator *declarator;</span>
<span class="lineNum">   16703 </span><span class="lineCov">     150802 :       tree decl;</span>
<span class="lineNum">   16704 </span><span class="lineCov">       4303 : </span>
<span class="lineNum">   16705 </span><span class="lineCov">       4303 :       /* Parse the declarator.  */</span>
<span class="lineNum">   16706 </span>            :       declarator
<span class="lineNum">   16707 </span>            :         = cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,
<span class="lineNum">   16708 </span>            :                                 /*ctor_dtor_or_conv_p=*/NULL,
<span class="lineNum">   16709 </span>            :                                 /*parenthesized_p=*/NULL,
<span class="lineNum">   16710 </span><span class="lineCov">     150802 :                                 /*member_p=*/false,</span>
<span class="lineNum">   16711 </span>            :                                 /*friend_p=*/false);
<span class="lineNum">   16712 </span>            :       if (declares_class_or_enum &amp; 2)
<span class="lineNum">   16713 </span><span class="lineCov">     150802 :         cp_parser_check_for_definition_in_return_type (declarator,</span>
<span class="lineNum">   16714 </span>            :                                                        decl_specifiers.type,
<span class="lineNum">   16715 </span>            :                                                        decl_specifiers.locations[ds_type_spec]);
<span class="lineNum">   16716 </span><span class="lineCov">     150802 :       if (declarator != cp_error_declarator)</span>
<span class="lineNum">   16717 </span>            :         {
<span class="lineNum">   16718 </span><span class="lineCov">     150802 :           if (decl_spec_seq_has_spec_p (&amp;decl_specifiers, ds_inline))</span>
<span class="lineNum">   16719 </span>            :             permerror (decl_specifiers.locations[ds_inline],
<span class="lineNum">   16720 </span>            :                        &quot;explicit instantiation shall not use&quot;
<span class="lineNum">   16721 </span>            :                        &quot; %&lt;inline%&gt; specifier&quot;);
<span class="lineNum">   16722 </span>            :           if (decl_spec_seq_has_spec_p (&amp;decl_specifiers, ds_constexpr))
<span class="lineNum">   16723 </span>            :             permerror (decl_specifiers.locations[ds_constexpr],
<span class="lineNum">   16724 </span>            :                        &quot;explicit instantiation shall not use&quot;
<span class="lineNum">   16725 </span><span class="lineCov">     150802 :                        &quot; %&lt;constexpr%&gt; specifier&quot;);</span>
<span class="lineNum">   16726 </span>            : 
<span class="lineNum">   16727 </span><span class="lineCov">      44597 :           decl = grokdeclarator (declarator, &amp;decl_specifiers,</span>
<span class="lineNum">   16728 </span>            :                                  NORMAL, 0, &amp;decl_specifiers.attributes);
<span class="lineNum">   16729 </span><span class="lineCov">      44597 :           /* Turn access control back on for names used during</span>
<span class="lineNum">   16730 </span>            :              template instantiation.  */
<span class="lineNum">   16731 </span>            :           pop_deferring_access_checks ();
<span class="lineNum">   16732 </span>            :           /* Do the explicit instantiation.  */
<span class="lineNum">   16733 </span><span class="lineCov">      44597 :           do_decl_instantiation (decl, extension_specifier);</span>
<span class="lineNum">   16734 </span><span class="lineCov">      44597 :         }</span>
<span class="lineNum">   16735 </span><span class="lineCov">      44574 :       else</span>
<span class="lineNum">   16736 </span>            :         {
<span class="lineNum">   16737 </span>            :           pop_deferring_access_checks ();
<span class="lineNum">   16738 </span>            :           /* Skip the body of the explicit instantiation.  */
<span class="lineNum">   16739 </span>            :           cp_parser_skip_to_end_of_statement (parser);
<span class="lineNum">   16740 </span><span class="lineCov">     106205 :         }</span>
<span class="lineNum">   16741 </span><span class="lineCov">     106205 :     }</span>
<span class="lineNum">   16742 </span>            :   /* We're done with the instantiation.  */
<span class="lineNum">   16743 </span>            :   end_explicit_instantiation ();
<span class="lineNum">   16744 </span><span class="lineCov">     106205 : </span>
<span class="lineNum">   16745 </span><span class="lineCov">     106205 :   cp_parser_consume_semicolon_at_end_of_statement (parser);</span>
<span class="lineNum">   16746 </span>            : 
<span class="lineNum">   16747 </span>            :   timevar_pop (TV_TEMPLATE_INST);
<span class="lineNum">   16748 </span>            : }
<span class="lineNum">   16749 </span>            : 
<span class="lineNum">   16750 </span><span class="lineCov">     106205 : /* Parse an explicit-specialization.</span>
<span class="lineNum">   16751 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   16752 </span>            :    explicit-specialization:
<span class="lineNum">   16753 </span>            :      template &lt; &gt; declaration
<span class="lineNum">   16754 </span><span class="lineCov">     106205 : </span>
<span class="lineNum">   16755 </span>            :    Although the standard says `declaration', what it really means is:
<span class="lineNum">   16756 </span><span class="lineCov">     106184 : </span>
<span class="lineNum">   16757 </span><span class="lineCov">          2 :    explicit-specialization:</span>
<span class="lineNum">   16758 </span>            :      template &lt;&gt; decl-specifier [opt] init-declarator [opt] ;
<span class="lineNum">   16759 </span>            :      template &lt;&gt; function-definition
<span class="lineNum">   16760 </span><span class="lineCov">     106184 :      template &lt;&gt; explicit-specialization</span>
<span class="lineNum">   16761 </span><span class="lineCov">          2 :      template &lt;&gt; template-declaration  */</span>
<a name="16762"><span class="lineNum">   16762 </span>            : </a>
<span class="lineNum">   16763 </span>            : static void
<span class="lineNum">   16764 </span>            : cp_parser_explicit_specialization (cp_parser* parser)
<span class="lineNum">   16765 </span><span class="lineCov">     106184 : {</span>
<span class="lineNum">   16766 </span>            :   bool need_lang_pop;
<span class="lineNum">   16767 </span>            :   cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   16768 </span>            : 
<span class="lineNum">   16769 </span><span class="lineCov">     106184 :   /* Look for the `template' keyword.  */</span>
<span class="lineNum">   16770 </span>            :   cp_parser_require_keyword (parser, RID_TEMPLATE, RT_TEMPLATE);
<span class="lineNum">   16771 </span><span class="lineCov">     106184 :   /* Look for the `&lt;'.  */</span>
<span class="lineNum">   16772 </span>            :   cp_parser_require (parser, CPP_LESS, RT_LESS);
<span class="lineNum">   16773 </span>            :   /* Look for the `&gt;'.  */
<span class="lineNum">   16774 </span>            :   cp_parser_require (parser, CPP_GREATER, RT_GREATER);
<span class="lineNum">   16775 </span><span class="lineCov">         21 :   /* We have processed another parameter list.  */</span>
<span class="lineNum">   16776 </span>            :   ++parser-&gt;num_template_parameter_lists;
<span class="lineNum">   16777 </span><span class="lineCov">         21 :   /* [temp]</span>
<span class="lineNum">   16778 </span>            : 
<span class="lineNum">   16779 </span>            :      A template ... explicit specialization ... shall not have C
<span class="lineNum">   16780 </span>            :      linkage.  */
<span class="lineNum">   16781 </span><span class="lineCov">     150799 :   if (current_lang_name == lang_name_c)</span>
<span class="lineNum">   16782 </span>            :     {
<span class="lineNum">   16783 </span><span class="lineCov">     150799 :       error_at (token-&gt;location, &quot;template specialization with C linkage&quot;);</span>
<span class="lineNum">   16784 </span>            :       maybe_show_extern_c_location ();
<span class="lineNum">   16785 </span><span class="lineCov">     150799 :       /* Give it C++ linkage to avoid confusing other parts of the</span>
<span class="lineNum">   16786 </span><span class="lineCov">     150799 :          front end.  */</span>
<span class="lineNum">   16787 </span>            :       push_lang_context (lang_name_cplusplus);
<span class="lineNum">   16788 </span>            :       need_lang_pop = true;
<span class="lineNum">   16789 </span>            :     }
<span class="lineNum">   16790 </span>            :   else
<span class="lineNum">   16791 </span>            :     need_lang_pop = false;
<span class="lineNum">   16792 </span>            :   /* Let the front end know that we are beginning a specialization.  */
<span class="lineNum">   16793 </span>            :   if (!begin_specialization ())
<span class="lineNum">   16794 </span>            :     {
<span class="lineNum">   16795 </span>            :       end_specialization ();
<span class="lineNum">   16796 </span>            :       return;
<span class="lineNum">   16797 </span>            :     }
<span class="lineNum">   16798 </span>            : 
<span class="lineNum">   16799 </span>            :   /* If the next keyword is `template', we need to figure out whether
<span class="lineNum">   16800 </span>            :      or not we're looking a template-declaration.  */
<span class="lineNum">   16801 </span>            :   if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_TEMPLATE))
<span class="lineNum">   16802 </span><span class="lineCov">     456439 :     {</span>
<span class="lineNum">   16803 </span>            :       if (cp_lexer_peek_nth_token (parser-&gt;lexer, 2)-&gt;type == CPP_LESS
<span class="lineNum">   16804 </span><span class="lineCov">     456439 :           &amp;&amp; cp_lexer_peek_nth_token (parser-&gt;lexer, 3)-&gt;type != CPP_GREATER)</span>
<span class="lineNum">   16805 </span><span class="lineCov">     912878 :         cp_parser_template_declaration_after_export (parser,</span>
<span class="lineNum">   16806 </span>            :                                                      /*member_p=*/false);
<span class="lineNum">   16807 </span>            :       else
<span class="lineNum">   16808 </span><span class="lineCov">     456439 :         cp_parser_explicit_specialization (parser);</span>
<span class="lineNum">   16809 </span>            :     }
<span class="lineNum">   16810 </span><span class="lineCov">     456439 :   else</span>
<span class="lineNum">   16811 </span>            :     /* Parse the dependent declaration.  */
<span class="lineNum">   16812 </span><span class="lineCov">     456439 :     cp_parser_single_declaration (parser,</span>
<span class="lineNum">   16813 </span>            :                                   /*checks=*/NULL,
<span class="lineNum">   16814 </span><span class="lineCov">     456439 :                                   /*member_p=*/false,</span>
<span class="lineNum">   16815 </span>            :                                   /*explicit_specialization_p=*/true,
<span class="lineNum">   16816 </span>            :                                   /*friend_p=*/NULL);
<span class="lineNum">   16817 </span>            :   /* We're done with the specialization.  */
<span class="lineNum">   16818 </span>            :   end_specialization ();
<span class="lineNum">   16819 </span><span class="lineCov">     456439 :   /* For the erroneous case of a template with C linkage, we pushed an</span>
<span class="lineNum">   16820 </span>            :      implicit C++ linkage scope; exit that scope now.  */
<span class="lineNum">   16821 </span><span class="lineCov">          3 :   if (need_lang_pop)</span>
<span class="lineNum">   16822 </span><span class="lineCov">          3 :     pop_lang_context ();</span>
<span class="lineNum">   16823 </span>            :   /* We're done with this parameter list.  */
<span class="lineNum">   16824 </span>            :   --parser-&gt;num_template_parameter_lists;
<span class="lineNum">   16825 </span><span class="lineCov">          3 : }</span>
<span class="lineNum">   16826 </span><span class="lineCov">          3 : </span>
<span class="lineNum">   16827 </span>            : /* Parse a type-specifier.
<span class="lineNum">   16828 </span>            : 
<span class="lineNum">   16829 </span>            :    type-specifier:
<span class="lineNum">   16830 </span>            :      simple-type-specifier
<span class="lineNum">   16831 </span><span class="lineCov">     456439 :      class-specifier</span>
<span class="lineNum">   16832 </span>            :      enum-specifier
<span class="lineNum">   16833 </span><span class="lineCov">         24 :      elaborated-type-specifier</span>
<span class="lineNum">   16834 </span><span class="lineCov">         24 :      cv-qualifier</span>
<span class="lineNum">   16835 </span>            : 
<span class="lineNum">   16836 </span>            :    GNU Extension:
<span class="lineNum">   16837 </span>            : 
<span class="lineNum">   16838 </span>            :    type-specifier:
<span class="lineNum">   16839 </span><span class="lineCov">     456415 :      __complex__</span>
<span class="lineNum">   16840 </span>            : 
<span class="lineNum">   16841 </span><span class="lineCov">        869 :    Returns a representation of the type-specifier.  For a</span>
<span class="lineNum">   16842 </span><span class="lineCov">        869 :    class-specifier, enum-specifier, or elaborated-type-specifier, a</span>
<span class="lineNum">   16843 </span><span class="lineCov">        736 :    TREE_TYPE is returned; otherwise, a TYPE_DECL is returned.</span>
<span class="lineNum">   16844 </span>            : 
<span class="lineNum">   16845 </span>            :    The parser flags FLAGS is used to control type-specifier parsing.
<span class="lineNum">   16846 </span><span class="lineCov">        133 : </span>
<span class="lineNum">   16847 </span>            :    If IS_DECLARATION is TRUE, then this type-specifier is appearing
<span class="lineNum">   16848 </span>            :    in a decl-specifier-seq.
<span class="lineNum">   16849 </span>            : 
<span class="lineNum">   16850 </span><span class="lineCov">     455546 :    If DECLARES_CLASS_OR_ENUM is non-NULL, and the type-specifier is a</span>
<span class="lineNum">   16851 </span>            :    class-specifier, enum-specifier, or elaborated-type-specifier, then
<span class="lineNum">   16852 </span>            :    *DECLARES_CLASS_OR_ENUM is set to a nonzero value.  The value is 1
<span class="lineNum">   16853 </span>            :    if a type is declared; 2 if it is defined.  Otherwise, it is set to
<span class="lineNum">   16854 </span>            :    zero.
<span class="lineNum">   16855 </span>            : 
<span class="lineNum">   16856 </span><span class="lineCov">     456415 :    If IS_CV_QUALIFIER is non-NULL, and the type-specifier is a</span>
<span class="lineNum">   16857 </span>            :    cv-qualifier, then IS_CV_QUALIFIER is set to TRUE.  Otherwise, it
<span class="lineNum">   16858 </span>            :    is set to FALSE.  */
<a name="16859"><span class="lineNum">   16859 </span><span class="lineCov">     456415 : </span></a>
<span class="lineNum">   16860 </span><span class="lineCov">          3 : static tree</span>
<span class="lineNum">   16861 </span>            : cp_parser_type_specifier (cp_parser* parser,
<span class="lineNum">   16862 </span><span class="lineCov">     456415 :                           cp_parser_flags flags,</span>
<span class="lineNum">   16863 </span>            :                           cp_decl_specifier_seq *decl_specs,
<span class="lineNum">   16864 </span>            :                           bool is_declaration,
<span class="lineNum">   16865 </span>            :                           int* declares_class_or_enum,
<span class="lineNum">   16866 </span>            :                           bool* is_cv_qualifier)
<span class="lineNum">   16867 </span>            : {
<span class="lineNum">   16868 </span>            :   tree type_spec = NULL_TREE;
<span class="lineNum">   16869 </span>            :   cp_token *token;
<span class="lineNum">   16870 </span>            :   enum rid keyword;
<span class="lineNum">   16871 </span>            :   cp_decl_spec ds = ds_last;
<span class="lineNum">   16872 </span>            : 
<span class="lineNum">   16873 </span>            :   /* Assume this type-specifier does not declare a new type.  */
<span class="lineNum">   16874 </span>            :   if (declares_class_or_enum)
<span class="lineNum">   16875 </span>            :     *declares_class_or_enum = 0;
<span class="lineNum">   16876 </span>            :   /* And that it does not specify a cv-qualifier.  */
<span class="lineNum">   16877 </span>            :   if (is_cv_qualifier)
<span class="lineNum">   16878 </span>            :     *is_cv_qualifier = false;
<span class="lineNum">   16879 </span>            :   /* Peek at the next token.  */
<span class="lineNum">   16880 </span>            :   token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   16881 </span>            : 
<span class="lineNum">   16882 </span>            :   /* If we're looking at a keyword, we can use that to guide the
<span class="lineNum">   16883 </span>            :      production we choose.  */
<span class="lineNum">   16884 </span>            :   keyword = token-&gt;keyword;
<span class="lineNum">   16885 </span>            :   switch (keyword)
<span class="lineNum">   16886 </span>            :     {
<span class="lineNum">   16887 </span>            :     case RID_ENUM:
<span class="lineNum">   16888 </span>            :       if ((flags &amp; CP_PARSER_FLAGS_NO_TYPE_DEFINITIONS))
<span class="lineNum">   16889 </span>            :         goto elaborated_type_specifier;
<span class="lineNum">   16890 </span>            : 
<span class="lineNum">   16891 </span>            :       /* Look for the enum-specifier.  */
<span class="lineNum">   16892 </span>            :       type_spec = cp_parser_enum_specifier (parser);
<span class="lineNum">   16893 </span>            :       /* If that worked, we're done.  */
<span class="lineNum">   16894 </span>            :       if (type_spec)
<span class="lineNum">   16895 </span>            :         {
<span class="lineNum">   16896 </span>            :           if (declares_class_or_enum)
<span class="lineNum">   16897 </span>            :             *declares_class_or_enum = 2;
<span class="lineNum">   16898 </span>            :           if (decl_specs)
<span class="lineNum">   16899 </span><span class="lineCov">  126421921 :             cp_parser_set_decl_spec_type (decl_specs,</span>
<span class="lineNum">   16900 </span>            :                                           type_spec,
<span class="lineNum">   16901 </span>            :                                           token,
<span class="lineNum">   16902 </span>            :                                           /*type_definition_p=*/true);
<span class="lineNum">   16903 </span>            :           return type_spec;
<span class="lineNum">   16904 </span>            :         }
<span class="lineNum">   16905 </span>            :       else
<span class="lineNum">   16906 </span><span class="lineCov">  126421921 :         goto elaborated_type_specifier;</span>
<span class="lineNum">   16907 </span><span class="lineCov">  126421921 : </span>
<span class="lineNum">   16908 </span><span class="lineCov">  126421921 :       /* Any of these indicate either a class-specifier, or an</span>
<span class="lineNum">   16909 </span><span class="lineCov">  126421921 :          elaborated-type-specifier.  */</span>
<span class="lineNum">   16910 </span>            :     case RID_CLASS:
<span class="lineNum">   16911 </span>            :     case RID_STRUCT:
<span class="lineNum">   16912 </span><span class="lineCov">  126421921 :     case RID_UNION:</span>
<span class="lineNum">   16913 </span><span class="lineCov">   88722943 :       if ((flags &amp; CP_PARSER_FLAGS_NO_TYPE_DEFINITIONS))</span>
<span class="lineNum">   16914 </span>            :         goto elaborated_type_specifier;
<span class="lineNum">   16915 </span><span class="lineCov">  126421921 : </span>
<span class="lineNum">   16916 </span><span class="lineCov">  125716879 :       /* Parse tentatively so that we can back up if we don't find a</span>
<span class="lineNum">   16917 </span>            :          class-specifier.  */
<span class="lineNum">   16918 </span><span class="lineCov">  252843842 :       cp_parser_parse_tentatively (parser);</span>
<span class="lineNum">   16919 </span>            :       /* Look for the class-specifier.  */
<span class="lineNum">   16920 </span>            :       type_spec = cp_parser_class_specifier (parser);
<span class="lineNum">   16921 </span>            :       invoke_plugin_callbacks (PLUGIN_FINISH_TYPE, type_spec);
<span class="lineNum">   16922 </span><span class="lineCov">  126421921 :       /* If that worked, we're done.  */</span>
<span class="lineNum">   16923 </span><span class="lineCov">  126421921 :       if (cp_parser_parse_definitely (parser))</span>
<span class="lineNum">   16924 </span>            :         {
<span class="lineNum">   16925 </span><span class="lineCov">     184080 :           if (declares_class_or_enum)</span>
<span class="lineNum">   16926 </span><span class="lineCov">     184080 :             *declares_class_or_enum = 2;</span>
<span class="lineNum">   16927 </span>            :           if (decl_specs)
<span class="lineNum">   16928 </span>            :             cp_parser_set_decl_spec_type (decl_specs,
<span class="lineNum">   16929 </span>            :                                           type_spec,
<span class="lineNum">   16930 </span><span class="lineCov">     184078 :                                           token,</span>
<span class="lineNum">   16931 </span>            :                                           /*type_definition_p=*/true);
<span class="lineNum">   16932 </span><span class="lineCov">     184078 :           return type_spec;</span>
<span class="lineNum">   16933 </span>            :         }
<span class="lineNum">   16934 </span><span class="lineCov">     169969 : </span>
<span class="lineNum">   16935 </span><span class="lineCov">     169956 :       /* Fall through.  */</span>
<span class="lineNum">   16936 </span><span class="lineCov">     169969 :     elaborated_type_specifier:</span>
<span class="lineNum">   16937 </span><span class="lineCov">     169969 :       /* We're declaring (not defining) a class or enum.  */</span>
<span class="lineNum">   16938 </span>            :       if (declares_class_or_enum)
<span class="lineNum">   16939 </span>            :         *declares_class_or_enum = 1;
<span class="lineNum">   16940 </span>            : 
<span class="lineNum">   16941 </span><span class="lineCov">     169969 :       /* Fall through.  */</span>
<span class="lineNum">   16942 </span>            :     case RID_TYPENAME:
<span class="lineNum">   16943 </span>            :       /* Look for an elaborated-type-specifier.  */
<span class="lineNum">   16944 </span>            :       type_spec
<span class="lineNum">   16945 </span>            :         = (cp_parser_elaborated_type_specifier
<span class="lineNum">   16946 </span>            :            (parser,
<span class="lineNum">   16947 </span>            :             decl_spec_seq_has_spec_p (decl_specs, ds_friend),
<span class="lineNum">   16948 </span><span class="lineCov">    3284485 :             is_declaration));</span>
<span class="lineNum">   16949 </span><span class="lineCov">    3284485 :       if (decl_specs)</span>
<span class="lineNum">   16950 </span><span class="lineCov">    3284485 :         cp_parser_set_decl_spec_type (decl_specs,</span>
<span class="lineNum">   16951 </span><span class="lineCov">    3284485 :                                       type_spec,</span>
<span class="lineNum">   16952 </span>            :                                       token,
<span class="lineNum">   16953 </span>            :                                       /*type_definition_p=*/false);
<span class="lineNum">   16954 </span>            :       return type_spec;
<span class="lineNum">   16955 </span>            : 
<span class="lineNum">   16956 </span><span class="lineCov">    3284481 :     case RID_CONST:</span>
<span class="lineNum">   16957 </span>            :       ds = ds_const;
<span class="lineNum">   16958 </span><span class="lineCov">    3284481 :       if (is_cv_qualifier)</span>
<span class="lineNum">   16959 </span><span class="lineCov">    3284471 :         *is_cv_qualifier = true;</span>
<span class="lineNum">   16960 </span>            :       break;
<span class="lineNum">   16961 </span><span class="lineCov">    3284471 : </span>
<span class="lineNum">   16962 </span>            :     case RID_VOLATILE:
<span class="lineNum">   16963 </span><span class="lineCov">    2408984 :       ds = ds_volatile;</span>
<span class="lineNum">   16964 </span><span class="lineCov">    2408877 :       if (is_cv_qualifier)</span>
<span class="lineNum">   16965 </span><span class="lineCov">    2408984 :         *is_cv_qualifier = true;</span>
<span class="lineNum">   16966 </span><span class="lineCov">    2408984 :       break;</span>
<span class="lineNum">   16967 </span>            : 
<span class="lineNum">   16968 </span>            :     case RID_RESTRICT:
<span class="lineNum">   16969 </span>            :       ds = ds_restrict;
<span class="lineNum">   16970 </span><span class="lineCov">    2408984 :       if (is_cv_qualifier)</span>
<span class="lineNum">   16971 </span>            :         *is_cv_qualifier = true;
<span class="lineNum">   16972 </span>            :       break;
<span class="lineNum">   16973 </span>            : 
<span class="lineNum">   16974 </span><span class="lineCov">     875487 :     case RID_COMPLEX:</span>
<span class="lineNum">   16975 </span>            :       /* The `__complex__' keyword is a GNU extension.  */
<span class="lineNum">   16976 </span><span class="lineCov">     889602 :       ds = ds_complex;</span>
<span class="lineNum">   16977 </span><span class="lineCov">     881546 :       break;</span>
<span class="lineNum">   16978 </span>            : 
<span class="lineNum">   16979 </span>            :     default:
<span class="lineNum">   16980 </span><span class="lineCov">    2330572 :       break;</span>
<span class="lineNum">   16981 </span>            :     }
<span class="lineNum">   16982 </span><span class="lineCov">    2330572 : </span>
<span class="lineNum">   16983 </span>            :   /* Handle simple keywords.  */
<span class="lineNum">   16984 </span><span class="lineCov">    2330572 :   if (ds != ds_last)</span>
<span class="lineNum">   16985 </span><span class="lineCov">    2330572 :     {</span>
<span class="lineNum">   16986 </span>            :       if (decl_specs)
<span class="lineNum">   16987 </span><span class="lineCov">    2330572 :         {</span>
<span class="lineNum">   16988 </span><span class="lineCov">    2330572 :           set_and_check_decl_spec_loc (decl_specs, ds, token);</span>
<span class="lineNum">   16989 </span>            :           decl_specs-&gt;any_specifiers_p = true;
<span class="lineNum">   16990 </span>            :         }
<span class="lineNum">   16991 </span>            :       return cp_lexer_consume_token (parser-&gt;lexer)-&gt;u.value;
<span class="lineNum">   16992 </span>            :     }
<span class="lineNum">   16993 </span>            : 
<span class="lineNum">   16994 </span><span class="lineCov">    5802511 :   /* If we do not already have a type-specifier, assume we are looking</span>
<span class="lineNum">   16995 </span><span class="lineCov">    5802511 :      at a simple-type-specifier.  */</span>
<span class="lineNum">   16996 </span><span class="lineCov">    5802511 :   type_spec = cp_parser_simple_type_specifier (parser,</span>
<span class="lineNum">   16997 </span><span class="lineCov">    5495230 :                                                decl_specs,</span>
<span class="lineNum">   16998 </span>            :                                                flags);
<span class="lineNum">   16999 </span>            : 
<span class="lineNum">   17000 </span><span class="lineCov">     115404 :   /* If we didn't find a type-specifier, and a type-specifier was not</span>
<span class="lineNum">   17001 </span><span class="lineCov">     115404 :      optional in this context, issue an error message.  */</span>
<span class="lineNum">   17002 </span><span class="lineCov">     115404 :   if (!type_spec &amp;&amp; !(flags &amp; CP_PARSER_FLAGS_OPTIONAL))</span>
<span class="lineNum">   17003 </span><span class="lineCov">     115394 :     {</span>
<span class="lineNum">   17004 </span>            :       cp_parser_error (parser, &quot;expected type specifier&quot;);
<span class="lineNum">   17005 </span>            :       return error_mark_node;
<span class="lineNum">   17006 </span><span class="lineCov">         18 :     }</span>
<span class="lineNum">   17007 </span><span class="lineCov">         18 : </span>
<span class="lineNum">   17008 </span><span class="lineCov">         18 :   return type_spec;</span>
<span class="lineNum">   17009 </span><span class="lineCov">         18 : }</span>
<span class="lineNum">   17010 </span>            : 
<span class="lineNum">   17011 </span>            : /* Parse a simple-type-specifier.
<span class="lineNum">   17012 </span>            : 
<span class="lineNum">   17013 </span>            :    simple-type-specifier:
<span class="lineNum">   17014 </span>            :      :: [opt] nested-name-specifier [opt] type-name
<span class="lineNum">   17015 </span>            :      :: [opt] nested-name-specifier template template-id
<span class="lineNum">   17016 </span>            :      char
<span class="lineNum">   17017 </span>            :      wchar_t
<span class="lineNum">   17018 </span>            :      bool
<span class="lineNum">   17019 </span>            :      short
<span class="lineNum">   17020 </span>            :      int
<span class="lineNum">   17021 </span>            :      long
<span class="lineNum">   17022 </span><span class="lineCov">    5610642 :      signed</span>
<span class="lineNum">   17023 </span>            :      unsigned
<span class="lineNum">   17024 </span><span class="lineCov">    5957184 :      float</span>
<span class="lineNum">   17025 </span>            :      double
<span class="lineNum">   17026 </span><span class="lineCov">    5649890 :      void</span>
<span class="lineNum">   17027 </span><span class="lineCov">    5649890 : </span>
<span class="lineNum">   17028 </span>            :    C++11 Extension:
<span class="lineNum">   17029 </span><span class="lineCov">    5957184 : </span>
<span class="lineNum">   17030 </span>            :    simple-type-specifier:
<span class="lineNum">   17031 </span>            :      auto
<span class="lineNum">   17032 </span>            :      decltype ( expression )   
<span class="lineNum">   17033 </span>            :      char16_t
<span class="lineNum">   17034 </span><span class="lineCov">  115555202 :      char32_t</span>
<span class="lineNum">   17035 </span>            :      __underlying_type ( type-id )
<span class="lineNum">   17036 </span>            : 
<span class="lineNum">   17037 </span>            :    C++17 extension:
<span class="lineNum">   17038 </span>            : 
<span class="lineNum">   17039 </span>            :      nested-name-specifier(opt) template-name
<span class="lineNum">   17040 </span><span class="lineCov">  115555199 : </span>
<span class="lineNum">   17041 </span>            :    GNU Extension:
<span class="lineNum">   17042 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   17043 </span><span class="lineNoCov">          0 :    simple-type-specifier:</span>
<span class="lineNum">   17044 </span>            :      __int128
<span class="lineNum">   17045 </span>            :      __typeof__ unary-expression
<span class="lineNum">   17046 </span>            :      __typeof__ ( type-id )
<span class="lineNum">   17047 </span>            :      __typeof__ ( type-id ) { initializer-list , [opt] }
<span class="lineNum">   17048 </span>            : 
<span class="lineNum">   17049 </span>            :    Concepts Extension:
<span class="lineNum">   17050 </span>            : 
<span class="lineNum">   17051 </span>            :    simple-type-specifier:
<span class="lineNum">   17052 </span>            :      constrained-type-specifier
<span class="lineNum">   17053 </span>            : 
<span class="lineNum">   17054 </span>            :    Returns the indicated TYPE_DECL.  If DECL_SPECS is not NULL, it is
<span class="lineNum">   17055 </span>            :    appropriately updated.  */
<a name="17056"><span class="lineNum">   17056 </span>            : </a>
<span class="lineNum">   17057 </span>            : static tree
<span class="lineNum">   17058 </span>            : cp_parser_simple_type_specifier (cp_parser* parser,
<span class="lineNum">   17059 </span>            :                                  cp_decl_specifier_seq *decl_specs,
<span class="lineNum">   17060 </span>            :                                  cp_parser_flags flags)
<span class="lineNum">   17061 </span>            : {
<span class="lineNum">   17062 </span>            :   tree type = NULL_TREE;
<span class="lineNum">   17063 </span>            :   cp_token *token;
<span class="lineNum">   17064 </span>            :   int idx;
<span class="lineNum">   17065 </span>            : 
<span class="lineNum">   17066 </span>            :   /* Peek at the next token.  */
<span class="lineNum">   17067 </span>            :   token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   17068 </span>            : 
<span class="lineNum">   17069 </span>            :   /* If we're looking at a keyword, things are easy.  */
<span class="lineNum">   17070 </span>            :   switch (token-&gt;keyword)
<span class="lineNum">   17071 </span>            :     {
<span class="lineNum">   17072 </span>            :     case RID_CHAR:
<span class="lineNum">   17073 </span>            :       if (decl_specs)
<span class="lineNum">   17074 </span>            :         decl_specs-&gt;explicit_char_p = true;
<span class="lineNum">   17075 </span>            :       type = char_type_node;
<span class="lineNum">   17076 </span>            :       break;
<span class="lineNum">   17077 </span>            :     case RID_CHAR16:
<span class="lineNum">   17078 </span>            :       type = char16_type_node;
<span class="lineNum">   17079 </span>            :       break;
<span class="lineNum">   17080 </span>            :     case RID_CHAR32:
<span class="lineNum">   17081 </span>            :       type = char32_type_node;
<span class="lineNum">   17082 </span>            :       break;
<span class="lineNum">   17083 </span>            :     case RID_WCHAR:
<span class="lineNum">   17084 </span>            :       type = wchar_type_node;
<span class="lineNum">   17085 </span>            :       break;
<span class="lineNum">   17086 </span>            :     case RID_BOOL:
<span class="lineNum">   17087 </span>            :       type = boolean_type_node;
<span class="lineNum">   17088 </span>            :       break;
<span class="lineNum">   17089 </span>            :     case RID_SHORT:
<span class="lineNum">   17090 </span>            :       set_and_check_decl_spec_loc (decl_specs, ds_short, token);
<span class="lineNum">   17091 </span>            :       type = short_integer_type_node;
<span class="lineNum">   17092 </span>            :       break;
<span class="lineNum">   17093 </span>            :     case RID_INT:
<span class="lineNum">   17094 </span>            :       if (decl_specs)
<span class="lineNum">   17095 </span>            :         decl_specs-&gt;explicit_int_p = true;
<span class="lineNum">   17096 </span><span class="lineCov">  161101987 :       type = integer_type_node;</span>
<span class="lineNum">   17097 </span>            :       break;
<span class="lineNum">   17098 </span>            :     case RID_INT_N_0:
<span class="lineNum">   17099 </span>            :     case RID_INT_N_1:
<span class="lineNum">   17100 </span><span class="lineCov">  161101987 :     case RID_INT_N_2:</span>
<span class="lineNum">   17101 </span><span class="lineCov">  161101987 :     case RID_INT_N_3:</span>
<span class="lineNum">   17102 </span><span class="lineCov">  161101987 :       idx = token-&gt;keyword - RID_INT_N_0;</span>
<span class="lineNum">   17103 </span>            :       if (! int_n_enabled_p [idx])
<span class="lineNum">   17104 </span>            :         break;
<span class="lineNum">   17105 </span><span class="lineCov">  322203974 :       if (decl_specs)</span>
<span class="lineNum">   17106 </span>            :         {
<span class="lineNum">   17107 </span>            :           decl_specs-&gt;explicit_intN_p = true;
<span class="lineNum">   17108 </span><span class="lineCov">  161101987 :           decl_specs-&gt;int_n_idx = idx;</span>
<span class="lineNum">   17109 </span>            :         }
<span class="lineNum">   17110 </span><span class="lineCov">    2338679 :       type = int_n_trees [idx].signed_type;</span>
<span class="lineNum">   17111 </span><span class="lineCov">    2338679 :       break;</span>
<span class="lineNum">   17112 </span><span class="lineCov">    2334150 :     case RID_LONG:</span>
<span class="lineNum">   17113 </span><span class="lineCov">    2338679 :       if (decl_specs)</span>
<span class="lineNum">   17114 </span><span class="lineCov">    2338679 :         set_and_check_decl_spec_loc (decl_specs, ds_long, token);</span>
<span class="lineNum">   17115 </span><span class="lineCov">      76328 :       type = long_integer_type_node;</span>
<span class="lineNum">   17116 </span><span class="lineCov">      76328 :       break;</span>
<span class="lineNum">   17117 </span><span class="lineCov">      76328 :     case RID_SIGNED:</span>
<span class="lineNum">   17118 </span><span class="lineCov">      76420 :       set_and_check_decl_spec_loc (decl_specs, ds_signed, token);</span>
<span class="lineNum">   17119 </span><span class="lineCov">      76420 :       type = integer_type_node;</span>
<span class="lineNum">   17120 </span><span class="lineCov">      76420 :       break;</span>
<span class="lineNum">   17121 </span><span class="lineCov">     574222 :     case RID_UNSIGNED:</span>
<span class="lineNum">   17122 </span><span class="lineCov">     574222 :       set_and_check_decl_spec_loc (decl_specs, ds_unsigned, token);</span>
<span class="lineNum">   17123 </span><span class="lineCov">     574222 :       type = unsigned_type_node;</span>
<span class="lineNum">   17124 </span><span class="lineCov">    2049118 :       break;</span>
<span class="lineNum">   17125 </span><span class="lineCov">    2049118 :     case RID_FLOAT:</span>
<span class="lineNum">   17126 </span><span class="lineCov">    2049118 :       type = float_type_node;</span>
<span class="lineNum">   17127 </span><span class="lineCov">     247778 :       break;</span>
<span class="lineNum">   17128 </span><span class="lineCov">     247778 :     case RID_DOUBLE:</span>
<span class="lineNum">   17129 </span><span class="lineCov">     247778 :       type = double_type_node;</span>
<span class="lineNum">   17130 </span><span class="lineCov">     247778 :       break;</span>
<span class="lineNum">   17131 </span><span class="lineCov">    4944986 :     case RID_VOID:</span>
<span class="lineNum">   17132 </span><span class="lineCov">    4944986 :       type = void_type_node;</span>
<span class="lineNum">   17133 </span><span class="lineCov">    4926955 :       break;</span>
<span class="lineNum">   17134 </span><span class="lineCov">    4944986 : </span>
<span class="lineNum">   17135 </span><span class="lineCov">    4944986 :     case RID_AUTO:</span>
<span class="lineNum">   17136 </span><span class="lineCov">     109099 :       maybe_warn_cpp0x (CPP0X_AUTO);</span>
<span class="lineNum">   17137 </span><span class="lineCov">     109099 :       if (parser-&gt;auto_is_implicit_function_template_parm_p)</span>
<span class="lineNum">   17138 </span><span class="lineCov">     109099 :         {</span>
<span class="lineNum">   17139 </span><span class="lineCov">     109099 :           /* The 'auto' might be the placeholder return type for a function decl</span>
<span class="lineNum">   17140 </span><span class="lineCov">     109099 :              with trailing return type.  */</span>
<span class="lineNum">   17141 </span><span class="lineCov">     109099 :           bool have_trailing_return_fn_decl = false;</span>
<span class="lineNum">   17142 </span>            : 
<span class="lineNum">   17143 </span><span class="lineCov">     109095 :           cp_parser_parse_tentatively (parser);</span>
<span class="lineNum">   17144 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   17145 </span><span class="lineCov">     109095 :           while (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_EQ)</span>
<span class="lineNum">   17146 </span><span class="lineCov">     109095 :                  &amp;&amp; cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_COMMA)</span>
<span class="lineNum">   17147 </span>            :                  &amp;&amp; cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_CLOSE_PAREN)
<span class="lineNum">   17148 </span><span class="lineCov">     109095 :                  &amp;&amp; cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_EOF))</span>
<span class="lineNum">   17149 </span><span class="lineCov">     109095 :             {</span>
<span class="lineNum">   17150 </span><span class="lineCov">    1611160 :               if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_PAREN))</span>
<span class="lineNum">   17151 </span><span class="lineCov">    1611160 :                 {</span>
<span class="lineNum">   17152 </span><span class="lineCov">    1611141 :                   cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   17153 </span><span class="lineCov">    1611160 :                   cp_parser_skip_to_closing_parenthesis (parser,</span>
<span class="lineNum">   17154 </span><span class="lineCov">    1611160 :                                                          /*recovering*/false,</span>
<span class="lineNum">   17155 </span><span class="lineCov">     186743 :                                                          /*or_comma*/false,</span>
<span class="lineNum">   17156 </span><span class="lineCov">     186743 :                                                          /*consume_paren*/true);</span>
<span class="lineNum">   17157 </span><span class="lineCov">     186743 :                   continue;</span>
<span class="lineNum">   17158 </span><span class="lineCov">     186743 :                 }</span>
<span class="lineNum">   17159 </span><span class="lineCov">    1363080 : </span>
<span class="lineNum">   17160 </span><span class="lineCov">    1363080 :               if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_DEREF))</span>
<span class="lineNum">   17161 </span><span class="lineCov">    1363080 :                 {</span>
<span class="lineNum">   17162 </span><span class="lineCov">    1363080 :                   have_trailing_return_fn_decl = true;</span>
<span class="lineNum">   17163 </span><span class="lineCov">     344699 :                   break;</span>
<span class="lineNum">   17164 </span><span class="lineCov">     344699 :                 }</span>
<span class="lineNum">   17165 </span><span class="lineCov">     344699 : </span>
<span class="lineNum">   17166 </span><span class="lineCov">     687483 :               cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   17167 </span><span class="lineCov">     687483 :             }</span>
<span class="lineNum">   17168 </span><span class="lineCov">     687483 :           cp_parser_abort_tentative_parse (parser);</span>
<span class="lineNum">   17169 </span><span class="lineCov">    2160529 : </span>
<span class="lineNum">   17170 </span><span class="lineCov">    2160529 :           if (have_trailing_return_fn_decl)</span>
<span class="lineNum">   17171 </span><span class="lineCov">    2160529 :             {</span>
<span class="lineNum">   17172 </span>            :               type = make_auto ();
<span class="lineNum">   17173 </span><span class="lineCov">     148962 :               break;</span>
<span class="lineNum">   17174 </span><span class="lineCov">     148962 :             }</span>
<span class="lineNum">   17175 </span><span class="lineCov">     148962 : </span>
<span class="lineNum">   17176 </span>            :           if (cxx_dialect &gt;= cxx14)
<span class="lineNum">   17177 </span>            :             {
<span class="lineNum">   17178 </span>            :               type = synthesize_implicit_template_parm (parser, NULL_TREE);
<span class="lineNum">   17179 </span><span class="lineCov">        359 :               type = TREE_TYPE (type);</span>
<span class="lineNum">   17180 </span>            :             }
<span class="lineNum">   17181 </span><span class="lineCov">        359 :           else</span>
<span class="lineNum">   17182 </span><span class="lineCov">        359 :             type = error_mark_node;</span>
<span class="lineNum">   17183 </span><span class="lineCov">       1548 : </span>
<span class="lineNum">   17184 </span><span class="lineCov">        773 :           if (current_class_type &amp;&amp; LAMBDA_TYPE_P (current_class_type))</span>
<span class="lineNum">   17185 </span><span class="lineCov">        734 :             {</span>
<span class="lineNum">   17186 </span><span class="lineCov">       1211 :               if (cxx_dialect &lt; cxx14)</span>
<span class="lineNum">   17187 </span>            :                 error_at (token-&gt;location,
<span class="lineNum">   17188 </span><span class="lineCov">        437 :                          &quot;use of %&lt;auto%&gt; in lambda parameter declaration &quot;</span>
<span class="lineNum">   17189 </span>            :                          &quot;only available with &quot;
<span class="lineNum">   17190 </span><span class="lineCov">         44 :                          &quot;-std=c++14 or -std=gnu++14&quot;);</span>
<span class="lineNum">   17191 </span><span class="lineCov">         88 :             }</span>
<span class="lineNum">   17192 </span>            :           else if (cxx_dialect &lt; cxx14)
<span class="lineNum">   17193 </span>            :             error_at (token-&gt;location,
<span class="lineNum">   17194 </span>            :                      &quot;use of %&lt;auto%&gt; in parameter declaration &quot;
<span class="lineNum">   17195 </span><span class="lineCov">         44 :                      &quot;only available with &quot;</span>
<span class="lineNum">   17196 </span>            :                      &quot;-std=c++14 or -std=gnu++14&quot;);
<span class="lineNum">   17197 </span>            :           else if (!flag_concepts)
<span class="lineNum">   17198 </span><span class="lineCov">        393 :             pedwarn (token-&gt;location, 0,</span>
<span class="lineNum">   17199 </span>            :                      &quot;use of %&lt;auto%&gt; in parameter declaration &quot;
<span class="lineNum">   17200 </span>            :                      &quot;only available with -fconcepts&quot;);
<span class="lineNum">   17201 </span>            :         }
<span class="lineNum">   17202 </span>            :       else
<span class="lineNum">   17203 </span>            :         type = make_auto ();
<span class="lineNum">   17204 </span><span class="lineCov">        371 :       break;</span>
<span class="lineNum">   17205 </span>            : 
<span class="lineNum">   17206 </span><span class="lineCov">        359 :     case RID_DECLTYPE:</span>
<span class="lineNum">   17207 </span>            :       /* Since DR 743, decltype can either be a simple-type-specifier by
<span class="lineNum">   17208 </span><span class="lineCov">        359 :          itself or begin a nested-name-specifier.  Parsing it will replace</span>
<span class="lineNum">   17209 </span>            :          it with a CPP_DECLTYPE, so just rewind and let the CPP_DECLTYPE
<span class="lineNum">   17210 </span><span class="lineCov">         22 :          handling below decide what to do.  */</span>
<span class="lineNum">   17211 </span><span class="lineCov">         22 :       cp_parser_decltype (parser);</span>
<span class="lineNum">   17212 </span>            :       cp_lexer_set_token_position (parser-&gt;lexer, token);
<span class="lineNum">   17213 </span>            :       break;
<span class="lineNum">   17214 </span><span class="lineCov">        337 : </span>
<span class="lineNum">   17215 </span>            :     case RID_TYPEOF:
<span class="lineNum">   17216 </span><span class="lineCov">        333 :       /* Consume the `typeof' token.  */</span>
<span class="lineNum">   17217 </span><span class="lineCov">        333 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   17218 </span>            :       /* Parse the operand to `typeof'.  */
<span class="lineNum">   17219 </span>            :       type = cp_parser_sizeof_operand (parser, RID_TYPEOF);
<span class="lineNum">   17220 </span><span class="lineCov">          4 :       /* If it is not already a TYPE, take its type.  */</span>
<span class="lineNum">   17221 </span>            :       if (!TYPE_P (type))
<span class="lineNum">   17222 </span><span class="lineCov">        337 :         type = finish_typeof (type);</span>
<span class="lineNum">   17223 </span>            : 
<span class="lineNum">   17224 </span><span class="lineCov">        258 :       if (decl_specs)</span>
<span class="lineNum">   17225 </span><span class="lineCov">          1 :         cp_parser_set_decl_spec_type (decl_specs, type,</span>
<span class="lineNum">   17226 </span>            :                                       token,
<span class="lineNum">   17227 </span>            :                                       /*type_definition_p=*/false);
<span class="lineNum">   17228 </span>            : 
<span class="lineNum">   17229 </span>            :       return type;
<span class="lineNum">   17230 </span><span class="lineCov">         79 : </span>
<span class="lineNum">   17231 </span><span class="lineCov">          3 :     case RID_UNDERLYING_TYPE:</span>
<span class="lineNum">   17232 </span>            :       type = cp_parser_trait_expr (parser, RID_UNDERLYING_TYPE);
<span class="lineNum">   17233 </span>            :       if (decl_specs)
<span class="lineNum">   17234 </span>            :         cp_parser_set_decl_spec_type (decl_specs, type,
<span class="lineNum">   17235 </span><span class="lineCov">         76 :                                       token,</span>
<span class="lineNum">   17236 </span><span class="lineCov">          7 :                                       /*type_definition_p=*/false);</span>
<span class="lineNum">   17237 </span>            : 
<span class="lineNum">   17238 </span>            :       return type;
<span class="lineNum">   17239 </span>            : 
<span class="lineNum">   17240 </span>            :     case RID_BASES:
<span class="lineNum">   17241 </span><span class="lineCov">     148603 :     case RID_DIRECT_BASES:</span>
<span class="lineNum">   17242 </span>            :       type = cp_parser_trait_expr (parser, token-&gt;keyword);
<span class="lineNum">   17243 </span>            :       if (decl_specs)
<span class="lineNum">   17244 </span><span class="lineCov">     190248 :        cp_parser_set_decl_spec_type (decl_specs, type,</span>
<span class="lineNum">   17245 </span>            :                                      token,
<span class="lineNum">   17246 </span>            :                                      /*type_definition_p=*/false);
<span class="lineNum">   17247 </span>            :       return type;
<span class="lineNum">   17248 </span>            :     default:
<span class="lineNum">   17249 </span><span class="lineCov">     190248 :       break;</span>
<span class="lineNum">   17250 </span><span class="lineCov">     190248 :     }</span>
<span class="lineNum">   17251 </span>            : 
<span class="lineNum">   17252 </span>            :   /* If token is an already-parsed decltype not followed by ::,
<span class="lineNum">   17253 </span><span class="lineCov">      82596 :      it's a simple-type-specifier.  */</span>
<span class="lineNum">   17254 </span>            :   if (token-&gt;type == CPP_DECLTYPE
<span class="lineNum">   17255 </span><span class="lineCov">      82596 :       &amp;&amp; cp_lexer_peek_nth_token (parser-&gt;lexer, 2)-&gt;type != CPP_SCOPE)</span>
<span class="lineNum">   17256 </span>            :     {
<span class="lineNum">   17257 </span><span class="lineCov">      82596 :       type = saved_checks_value (token-&gt;u.tree_check_value);</span>
<span class="lineNum">   17258 </span>            :       if (decl_specs)
<span class="lineNum">   17259 </span><span class="lineCov">      82596 :         {</span>
<span class="lineNum">   17260 </span><span class="lineCov">      82589 :           cp_parser_set_decl_spec_type (decl_specs, type,</span>
<span class="lineNum">   17261 </span>            :                                         token,
<span class="lineNum">   17262 </span><span class="lineCov">      82596 :                                         /*type_definition_p=*/false);</span>
<span class="lineNum">   17263 </span><span class="lineCov">      82587 :           /* Remember that we are handling a decltype in order to</span>
<span class="lineNum">   17264 </span>            :              implement the resolution of DR 1510 when the argument
<span class="lineNum">   17265 </span>            :              isn't instantiation dependent.  */
<span class="lineNum">   17266 </span>            :           decl_specs-&gt;decltype_p = true;
<span class="lineNum">   17267 </span>            :         }
<span class="lineNum">   17268 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   17269 </span><span class="lineCov">       2422 :       return type;</span>
<span class="lineNum">   17270 </span><span class="lineCov">       2422 :     }</span>
<span class="lineNum">   17271 </span><span class="lineCov">       2422 : </span>
<span class="lineNum">   17272 </span><span class="lineCov">       2422 :   /* If the type-specifier was for a built-in type, we're done.  */</span>
<span class="lineNum">   17273 </span>            :   if (type)
<span class="lineNum">   17274 </span>            :     {
<span class="lineNum">   17275 </span>            :       /* Record the type.  */
<span class="lineNum">   17276 </span>            :       if (decl_specs
<span class="lineNum">   17277 </span>            :           &amp;&amp; (token-&gt;keyword != RID_SIGNED
<span class="lineNum">   17278 </span><span class="lineCov">         24 :               &amp;&amp; token-&gt;keyword != RID_UNSIGNED</span>
<span class="lineNum">   17279 </span><span class="lineCov">         24 :               &amp;&amp; token-&gt;keyword != RID_SHORT</span>
<span class="lineNum">   17280 </span><span class="lineCov">         24 :               &amp;&amp; token-&gt;keyword != RID_LONG))</span>
<span class="lineNum">   17281 </span><span class="lineCov">         24 :         cp_parser_set_decl_spec_type (decl_specs,</span>
<span class="lineNum">   17282 </span><span class="lineCov">         24 :                                       type,</span>
<span class="lineNum">   17283 </span>            :                                       token,
<span class="lineNum">   17284 </span>            :                                       /*type_definition_p=*/false);
<span class="lineNum">   17285 </span>            :       if (decl_specs)
<span class="lineNum">   17286 </span>            :         decl_specs-&gt;any_specifiers_p = true;
<span class="lineNum">   17287 </span>            : 
<span class="lineNum">   17288 </span>            :       /* Consume the token.  */
<span class="lineNum">   17289 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   17290 </span>            : 
<span class="lineNum">   17291 </span>            :       if (type == error_mark_node)
<span class="lineNum">   17292 </span><span class="lineCov">  161016945 :         return error_mark_node;</span>
<span class="lineNum">   17293 </span><span class="lineCov">  161016945 : </span>
<span class="lineNum">   17294 </span>            :       /* There is no valid C++ program where a non-template type is
<span class="lineNum">   17295 </span><span class="lineCov">     190248 :          followed by a &quot;&lt;&quot;.  That usually indicates that the user thought</span>
<span class="lineNum">   17296 </span><span class="lineCov">     190248 :          that the type was a template.  */</span>
<span class="lineNum">   17297 </span>            :       cp_parser_check_for_invalid_template_id (parser, type, none_type,
<span class="lineNum">   17298 </span><span class="lineCov">     190240 :                                                token-&gt;location);</span>
<span class="lineNum">   17299 </span>            : 
<span class="lineNum">   17300 </span>            :       return TYPE_NAME (type);
<span class="lineNum">   17301 </span>            :     }
<span class="lineNum">   17302 </span>            : 
<span class="lineNum">   17303 </span>            :   /* The type-specifier must be a user-defined type.  */
<span class="lineNum">   17304 </span><span class="lineCov">     190240 :   if (!(flags &amp; CP_PARSER_FLAGS_NO_USER_DEFINED_TYPES))</span>
<span class="lineNum">   17305 </span>            :     {
<span class="lineNum">   17306 </span><span class="lineCov">     190248 :       bool qualified_p;</span>
<span class="lineNum">   17307 </span><span class="lineCov">     190248 :       bool global_p;</span>
<span class="lineNum">   17308 </span>            : 
<span class="lineNum">   17309 </span>            :       /* Don't gobble tokens or issue error messages if this is an
<span class="lineNum">   17310 </span>            :          optional type-specifier.  */
<span class="lineNum">   17311 </span><span class="lineCov">  160826697 :       if ((flags &amp; CP_PARSER_FLAGS_OPTIONAL) || cxx_dialect &gt;= cxx17)</span>
<span class="lineNum">   17312 </span>            :         cp_parser_parse_tentatively (parser);
<span class="lineNum">   17313 </span>            : 
<span class="lineNum">   17314 </span><span class="lineCov">   16919282 :       token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   17315 </span><span class="lineCov">   16825842 : </span>
<span class="lineNum">   17316 </span><span class="lineCov">   16639102 :       /* Look for the optional `::' operator.  */</span>
<span class="lineNum">   17317 </span><span class="lineCov">   15276056 :       global_p</span>
<span class="lineNum">   17318 </span><span class="lineCov">   15033418 :         = (cp_parser_global_scope_opt (parser,</span>
<span class="lineNum">   17319 </span><span class="lineCov">   13422277 :                                        /*current_scope_valid_p=*/false)</span>
<span class="lineNum">   17320 </span>            :            != NULL_TREE);
<span class="lineNum">   17321 </span>            :       /* Look for the nested-name specifier.  */
<span class="lineNum">   17322 </span>            :       qualified_p
<span class="lineNum">   17323 </span><span class="lineCov">   16919282 :         = (cp_parser_nested_name_specifier_opt (parser,</span>
<span class="lineNum">   17324 </span><span class="lineCov">   16825842 :                                                 /*typename_keyword_p=*/false,</span>
<span class="lineNum">   17325 </span>            :                                                 /*check_dependency_p=*/true,
<span class="lineNum">   17326 </span>            :                                                 /*type_p=*/false,
<span class="lineNum">   17327 </span><span class="lineCov">   16919282 :                                                 /*is_declaration=*/false)</span>
<span class="lineNum">   17328 </span>            :            != NULL_TREE);
<span class="lineNum">   17329 </span><span class="lineCov">   16919282 :       /* If we have seen a nested-name-specifier, and the next token</span>
<span class="lineNum">   17330 </span>            :          is `template', then we are using the template-id production.  */
<span class="lineNum">   17331 </span>            :       if (parser-&gt;scope
<span class="lineNum">   17332 </span>            :           &amp;&amp; cp_parser_optional_template_keyword (parser))
<span class="lineNum">   17333 </span>            :         {
<span class="lineNum">   17334 </span>            :           /* Look for the template-id.  */
<span class="lineNum">   17335 </span><span class="lineCov">   16919278 :           type = cp_parser_template_id (parser,</span>
<span class="lineNum">   17336 </span>            :                                         /*template_keyword_p=*/true,
<span class="lineNum">   17337 </span>            :                                         /*check_dependency_p=*/true,
<span class="lineNum">   17338 </span><span class="lineCov">   16919278 :                                         none_type,</span>
<span class="lineNum">   17339 </span>            :                                         /*is_declaration=*/false);
<span class="lineNum">   17340 </span>            :           /* If the template-id did not name a type, we are out of
<span class="lineNum">   17341 </span>            :              luck.  */
<span class="lineNum">   17342 </span><span class="lineCov">  143907415 :           if (TREE_CODE (type) != TYPE_DECL)</span>
<span class="lineNum">   17343 </span>            :             {
<span class="lineNum">   17344 </span><span class="lineCov">  105477429 :               cp_parser_error (parser, &quot;expected template-id for type&quot;);</span>
<span class="lineNum">   17345 </span><span class="lineCov">  105477429 :               type = NULL_TREE;</span>
<span class="lineNum">   17346 </span>            :             }
<span class="lineNum">   17347 </span>            :         }
<span class="lineNum">   17348 </span>            :       /* Otherwise, look for a type-name.  */
<span class="lineNum">   17349 </span><span class="lineCov">  105477429 :       else</span>
<span class="lineNum">   17350 </span><span class="lineCov">   59271649 :         type = cp_parser_type_name (parser);</span>
<span class="lineNum">   17351 </span>            :       /* Keep track of all name-lookups performed in class scopes.  */
<span class="lineNum">   17352 </span><span class="lineCov">  210954858 :       if (type</span>
<span class="lineNum">   17353 </span>            :           &amp;&amp; !global_p
<span class="lineNum">   17354 </span>            :           &amp;&amp; !qualified_p
<span class="lineNum">   17355 </span><span class="lineCov">  105477429 :           &amp;&amp; TREE_CODE (type) == TYPE_DECL</span>
<span class="lineNum">   17356 </span><span class="lineCov">  210954858 :           &amp;&amp; identifier_p (DECL_NAME (type)))</span>
<span class="lineNum">   17357 </span>            :         maybe_note_name_used_in_class (DECL_NAME (type), type);
<span class="lineNum">   17358 </span>            :       /* If it didn't work out, we don't have a TYPE.  */
<span class="lineNum">   17359 </span>            :       if (((flags &amp; CP_PARSER_FLAGS_OPTIONAL) || cxx_dialect &gt;= cxx17)
<span class="lineNum">   17360 </span><span class="lineCov">  105477429 :           &amp;&amp; !cp_parser_parse_definitely (parser))</span>
<span class="lineNum">   17361 </span><span class="lineCov">  105477429 :         type = NULL_TREE;</span>
<span class="lineNum">   17362 </span>            :       if (!type &amp;&amp; cxx_dialect &gt;= cxx17)
<span class="lineNum">   17363 </span>            :         {
<span class="lineNum">   17364 </span>            :           if (flags &amp; CP_PARSER_FLAGS_OPTIONAL)
<span class="lineNum">   17365 </span>            :             cp_parser_parse_tentatively (parser);
<span class="lineNum">   17366 </span>            : 
<span class="lineNum">   17367 </span>            :           cp_parser_global_scope_opt (parser,
<span class="lineNum">   17368 </span>            :                                       /*current_scope_valid_p=*/false);
<span class="lineNum">   17369 </span><span class="lineCov">  105477426 :           cp_parser_nested_name_specifier_opt (parser,</span>
<span class="lineNum">   17370 </span><span class="lineCov">  105477426 :                                                /*typename_keyword_p=*/false,</span>
<span class="lineNum">   17371 </span>            :                                                /*check_dependency_p=*/true,
<span class="lineNum">   17372 </span>            :                                                /*type_p=*/false,
<span class="lineNum">   17373 </span><span class="lineCov">     166725 :                                                /*is_declaration=*/false);</span>
<span class="lineNum">   17374 </span>            :           tree name = cp_parser_identifier (parser);
<span class="lineNum">   17375 </span>            :           if (name &amp;&amp; TREE_CODE (name) == IDENTIFIER_NODE
<span class="lineNum">   17376 </span>            :               &amp;&amp; parser-&gt;scope != error_mark_node)
<span class="lineNum">   17377 </span>            :             {
<span class="lineNum">   17378 </span>            :               tree tmpl = cp_parser_lookup_name (parser, name,
<span class="lineNum">   17379 </span>            :                                                  none_type,
<span class="lineNum">   17380 </span><span class="lineCov">     166725 :                                                  /*is_template=*/false,</span>
<span class="lineNum">   17381 </span>            :                                                  /*is_namespace=*/false,
<span class="lineNum">   17382 </span><span class="lineCov">     166721 :                                                  /*check_dependency=*/true,</span>
<span class="lineNum">   17383 </span><span class="lineCov">     166721 :                                                  /*ambiguous_decls=*/NULL,</span>
<span class="lineNum">   17384 </span>            :                                                  token-&gt;location);
<span class="lineNum">   17385 </span>            :               if (tmpl &amp;&amp; tmpl != error_mark_node
<span class="lineNum">   17386 </span>            :                   &amp;&amp; (DECL_CLASS_TEMPLATE_P (tmpl)
<span class="lineNum">   17387 </span>            :                       || DECL_TEMPLATE_TEMPLATE_PARM_P (tmpl)))
<span class="lineNum">   17388 </span><span class="lineCov">  210621402 :                 type = make_template_placeholder (tmpl);</span>
<span class="lineNum">   17389 </span>            :               else
<span class="lineNum">   17390 </span><span class="lineCov">     166721 :                 {</span>
<span class="lineNum">   17391 </span><span class="lineCov">  105310705 :                   type = error_mark_node;</span>
<span class="lineNum">   17392 </span><span class="lineCov">  105310705 :                   if (!cp_parser_simulate_error (parser))</span>
<span class="lineNum">   17393 </span><span class="lineCov">   99594212 :                     cp_parser_name_lookup_error (parser, name, tmpl,</span>
<span class="lineNum">   17394 </span><span class="lineCov">  139099930 :                                                  NLE_TYPE, token-&gt;location);</span>
<span class="lineNum">   17395 </span><span class="lineCov">   67578450 :                 }</span>
<span class="lineNum">   17396 </span>            :             }
<span class="lineNum">   17397 </span><span class="lineCov">   57189086 :           else</span>
<span class="lineNum">   17398 </span><span class="lineCov">  116460732 :             type = error_mark_node;</span>
<span class="lineNum">   17399 </span>            : 
<span class="lineNum">   17400 </span><span class="lineCov">  105477426 :           if ((flags &amp; CP_PARSER_FLAGS_OPTIONAL)</span>
<span class="lineNum">   17401 </span>            :               &amp;&amp; !cp_parser_parse_definitely (parser))
<span class="lineNum">   17402 </span><span class="lineCov">   14148539 :             type = NULL_TREE;</span>
<span class="lineNum">   17403 </span><span class="lineCov">    5304868 :         }</span>
<span class="lineNum">   17404 </span>            :       if (type &amp;&amp; decl_specs)
<span class="lineNum">   17405 </span><span class="lineCov">   14148539 :         cp_parser_set_decl_spec_type (decl_specs, type,</span>
<span class="lineNum">   17406 </span>            :                                       token,
<span class="lineNum">   17407 </span><span class="lineCov">   14148539 :                                       /*type_definition_p=*/false);</span>
<span class="lineNum">   17408 </span>            :     }
<span class="lineNum">   17409 </span>            : 
<span class="lineNum">   17410 </span>            :   /* If we didn't get a type-name, issue an error message.  */
<span class="lineNum">   17411 </span>            :   if (!type &amp;&amp; !(flags &amp; CP_PARSER_FLAGS_OPTIONAL))
<span class="lineNum">   17412 </span><span class="lineCov">   14148539 :     {</span>
<span class="lineNum">   17413 </span><span class="lineCov">   14148539 :       cp_parser_error (parser, &quot;expected type-name&quot;);</span>
<span class="lineNum">   17414 </span><span class="lineCov">    6743223 :       return error_mark_node;</span>
<span class="lineNum">   17415 </span>            :     }
<span class="lineNum">   17416 </span><span class="lineCov">   13486446 : </span>
<span class="lineNum">   17417 </span>            :   if (type &amp;&amp; type != error_mark_node)
<span class="lineNum">   17418 </span>            :     {
<span class="lineNum">   17419 </span>            :       /* See if TYPE is an Objective-C type, and if so, parse and
<span class="lineNum">   17420 </span>            :          accept any protocol references following it.  Do this before
<span class="lineNum">   17421 </span>            :          the cp_parser_check_for_invalid_template_id() call, because
<span class="lineNum">   17422 </span><span class="lineCov">    6743223 :          Objective-C types can be followed by '&lt;...&gt;' which would</span>
<span class="lineNum">   17423 </span><span class="lineCov">    6743223 :          enclose protocol names rather than template arguments, and so</span>
<span class="lineNum">   17424 </span><span class="lineCov">   13483999 :          everything is fine.  */</span>
<span class="lineNum">   17425 </span><span class="lineCov">    6727097 :       if (c_dialect_objc () &amp;&amp; !parser-&gt;scope</span>
<span class="lineNum">   17426 </span><span class="lineCov">      17953 :           &amp;&amp; (objc_is_id (type) || objc_is_class_name (type)))</span>
<span class="lineNum">   17427 </span>            :         {
<span class="lineNum">   17428 </span>            :           tree protos = cp_parser_objc_protocol_refs_opt (parser);
<span class="lineNum">   17429 </span><span class="lineCov">    6725270 :           tree qual_type = objc_get_protocol_qualified_type (type, protos);</span>
<span class="lineNum">   17430 </span><span class="lineCov">    6725267 : </span>
<span class="lineNum">   17431 </span><span class="lineCov">          3 :           /* Clobber the &quot;unqualified&quot; type previously entered into</span>
<span class="lineNum">   17432 </span>            :              DECL_SPECS with the new, improved protocol-qualified version.  */
<span class="lineNum">   17433 </span>            :           if (decl_specs)
<span class="lineNum">   17434 </span>            :             decl_specs-&gt;type = qual_type;
<span class="lineNum">   17435 </span>            : 
<span class="lineNum">   17436 </span><span class="lineCov">    7405316 :           return qual_type;</span>
<span class="lineNum">   17437 </span>            :         }
<span class="lineNum">   17438 </span><span class="lineCov">   14148539 : </span>
<span class="lineNum">   17439 </span><span class="lineCov">   14148539 :       /* There is no valid C++ program where a non-template type is</span>
<span class="lineNum">   17440 </span>            :          followed by a &quot;&lt;&quot;.  That usually indicates that the user
<span class="lineNum">   17441 </span>            :          thought that the type was a template.  */
<span class="lineNum">   17442 </span><span class="lineCov">  100190268 :       cp_parser_check_for_invalid_template_id (parser, type,</span>
<span class="lineNum">   17443 </span><span class="lineCov">   35644834 :                                                none_type,</span>
<span class="lineNum">   17444 </span>            :                                                token-&gt;location);
<span class="lineNum">   17445 </span>            :     }
<span class="lineNum">   17446 </span>            : 
<span class="lineNum">   17447 </span>            :   return type;
<span class="lineNum">   17448 </span>            : }
<span class="lineNum">   17449 </span><span class="lineCov">  143907412 : </span>
<span class="lineNum">   17450 </span>            : /* Parse a type-name.
<span class="lineNum">   17451 </span><span class="lineCov">      76196 : </span>
<span class="lineNum">   17452 </span><span class="lineCov">      76196 :    type-name:</span>
<span class="lineNum">   17453 </span>            :      class-name
<span class="lineNum">   17454 </span>            :      enum-name
<span class="lineNum">   17455 </span><span class="lineCov">  143831216 :      typedef-name</span>
<span class="lineNum">   17456 </span>            :      simple-template-id [in c++0x]
<span class="lineNum">   17457 </span>            : 
<span class="lineNum">   17458 </span>            :    enum-name:
<span class="lineNum">   17459 </span>            :      identifier
<span class="lineNum">   17460 </span>            : 
<span class="lineNum">   17461 </span>            :    typedef-name:
<span class="lineNum">   17462 </span>            :      identifier
<span class="lineNum">   17463 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   17464 </span><span class="lineCov">   34973446 :   Concepts:</span>
<span class="lineNum">   17465 </span>            : 
<span class="lineNum">   17466 </span><span class="lineNoCov">          0 :    type-name:</span>
<span class="lineNum">   17467 </span><span class="lineNoCov">          0 :      concept-name</span>
<span class="lineNum">   17468 </span>            :      partial-concept-id
<span class="lineNum">   17469 </span>            : 
<span class="lineNum">   17470 </span>            :    concept-name:
<span class="lineNum">   17471 </span><span class="lineNoCov">          0 :      identifier</span>
<span class="lineNum">   17472 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   17473 </span>            :    Returns a TYPE_DECL for the type.  */
<a name="17474"><span class="lineNum">   17474 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   17475 </span>            : static tree
<span class="lineNum">   17476 </span>            : cp_parser_type_name (cp_parser* parser)
<span class="lineNum">   17477 </span>            : {
<span class="lineNum">   17478 </span>            :   return cp_parser_type_name (parser, /*typename_keyword_p=*/false);
<span class="lineNum">   17479 </span>            : }
<span class="lineNum">   17480 </span><span class="lineCov">   34973446 : </span>
<a name="17481"><span class="lineNum">   17481 </span>            : /* See above. */</a>
<span class="lineNum">   17482 </span>            : static tree
<span class="lineNum">   17483 </span>            : cp_parser_type_name (cp_parser* parser, bool typename_keyword_p)
<span class="lineNum">   17484 </span>            : {
<span class="lineNum">   17485 </span>            :   tree type_decl;
<span class="lineNum">   17486 </span>            : 
<span class="lineNum">   17487 </span>            :   /* We can't know yet whether it is a class-name or not.  */
<span class="lineNum">   17488 </span>            :   cp_parser_parse_tentatively (parser);
<span class="lineNum">   17489 </span>            :   /* Try a class-name.  */
<span class="lineNum">   17490 </span>            :   type_decl = cp_parser_class_name (parser,
<span class="lineNum">   17491 </span>            :                                     typename_keyword_p,
<span class="lineNum">   17492 </span>            :                                     /*template_keyword_p=*/false,
<span class="lineNum">   17493 </span>            :                                     none_type,
<span class="lineNum">   17494 </span>            :                                     /*check_dependency_p=*/true,
<span class="lineNum">   17495 </span>            :                                     /*class_head_p=*/false,
<span class="lineNum">   17496 </span>            :                                     /*is_declaration=*/false);
<span class="lineNum">   17497 </span>            :   /* If it's not a class-name, keep looking.  */
<span class="lineNum">   17498 </span>            :   if (!cp_parser_parse_definitely (parser))
<span class="lineNum">   17499 </span>            :     {
<span class="lineNum">   17500 </span>            :       if (cxx_dialect &lt; cxx11)
<span class="lineNum">   17501 </span>            :         /* It must be a typedef-name or an enum-name.  */
<span class="lineNum">   17502 </span>            :         return cp_parser_nonclass_name (parser);
<span class="lineNum">   17503 </span>            : 
<span class="lineNum">   17504 </span>            :       cp_parser_parse_tentatively (parser);
<span class="lineNum">   17505 </span>            :       /* It is either a simple-template-id representing an
<span class="lineNum">   17506 </span>            :          instantiation of an alias template...  */
<span class="lineNum">   17507 </span>            :       type_decl = cp_parser_template_id (parser,
<span class="lineNum">   17508 </span>            :                                          /*template_keyword_p=*/false,
<span class="lineNum">   17509 </span>            :                                          /*check_dependency_p=*/true,
<span class="lineNum">   17510 </span>            :                                          none_type,
<span class="lineNum">   17511 </span>            :                                          /*is_declaration=*/false);
<span class="lineNum">   17512 </span>            :       /* Note that this must be an instantiation of an alias template
<span class="lineNum">   17513 </span>            :          because [temp.names]/6 says:
<span class="lineNum">   17514 </span><span class="lineNoCov">          0 :          </span>
<span class="lineNum">   17515 </span>            :              A template-id that names an alias template specialization
<span class="lineNum">   17516 </span><span class="lineCov">  105310701 :              is a type-name.</span>
<span class="lineNum">   17517 </span>            : 
<span class="lineNum">   17518 </span>            :          Whereas [temp.names]/7 says:
<span class="lineNum">   17519 </span>            :          
<span class="lineNum">   17520 </span>            :              A simple-template-id that names a class template
<span class="lineNum">   17521 </span><span class="lineCov">  105310720 :              specialization is a class-name.</span>
<span class="lineNum">   17522 </span>            : 
<span class="lineNum">   17523 </span><span class="lineCov">  105310720 :          With concepts, this could also be a partial-concept-id that</span>
<span class="lineNum">   17524 </span>            :          declares a non-type template parameter. */
<span class="lineNum">   17525 </span>            :       if (type_decl != NULL_TREE
<span class="lineNum">   17526 </span><span class="lineCov">  105310720 :           &amp;&amp; TREE_CODE (type_decl) == TYPE_DECL</span>
<span class="lineNum">   17527 </span>            :           &amp;&amp; TYPE_DECL_ALIAS_P (type_decl))
<span class="lineNum">   17528 </span><span class="lineCov">  105310720 :         gcc_assert (DECL_TEMPLATE_INSTANTIATION (type_decl));</span>
<span class="lineNum">   17529 </span>            :       else if (is_constrained_parameter (type_decl))
<span class="lineNum">   17530 </span>            :         /* Don't do anything. */ ;
<span class="lineNum">   17531 </span>            :       else
<span class="lineNum">   17532 </span>            :         cp_parser_simulate_error (parser);
<span class="lineNum">   17533 </span>            : 
<span class="lineNum">   17534 </span>            :       if (!cp_parser_parse_definitely (parser))
<span class="lineNum">   17535 </span>            :         /* ... Or a typedef-name or an enum-name.  */
<span class="lineNum">   17536 </span><span class="lineCov">  105310720 :         return cp_parser_nonclass_name (parser);</span>
<span class="lineNum">   17537 </span>            :     }
<span class="lineNum">   17538 </span><span class="lineCov">   80672574 : </span>
<span class="lineNum">   17539 </span>            :   return type_decl;
<span class="lineNum">   17540 </span><span class="lineCov">    5216579 : }</span>
<span class="lineNum">   17541 </span>            : 
<span class="lineNum">   17542 </span><span class="lineCov">   75455995 : /*  Check if DECL and ARGS can form a constrained-type-specifier.</span>
<span class="lineNum">   17543 </span>            :     If ARGS is non-null, we try to form a concept check of the
<span class="lineNum">   17544 </span>            :     form DECL&lt;?, ARGS&gt; where ? is a wildcard that matches any
<span class="lineNum">   17545 </span><span class="lineCov">   75455995 :     kind of template argument. If ARGS is NULL, then we try to</span>
<span class="lineNum">   17546 </span>            :     form a concept check of the form DECL&lt;?&gt;. */
<a name="17547"><span class="lineNum">   17547 </span>            : </a>
<span class="lineNum">   17548 </span>            : static tree
<span class="lineNum">   17549 </span>            : cp_parser_maybe_constrained_type_specifier (cp_parser *parser,
<span class="lineNum">   17550 </span>            :                                             tree decl, tree args)
<span class="lineNum">   17551 </span>            : {
<span class="lineNum">   17552 </span>            :   gcc_assert (args ? TREE_CODE (args) == TREE_VEC : true);
<span class="lineNum">   17553 </span>            : 
<span class="lineNum">   17554 </span>            :   /* If we a constrained-type-specifier cannot be deduced. */
<span class="lineNum">   17555 </span>            :   if (parser-&gt;prevent_constrained_type_specifiers)
<span class="lineNum">   17556 </span>            :     return NULL_TREE;
<span class="lineNum">   17557 </span>            : 
<span class="lineNum">   17558 </span>            :   /* A constrained type specifier can only be found in an
<span class="lineNum">   17559 </span>            :      overload set or as a reference to a template declaration.
<span class="lineNum">   17560 </span>            : 
<span class="lineNum">   17561 </span>            :      FIXME: This might be masking a bug.  It's possible that
<span class="lineNum">   17562 </span>            :      that the deduction below is causing template specializations
<span class="lineNum">   17563 </span><span class="lineCov">   75455995 :      to be formed with the wildcard as an argument.  */</span>
<span class="lineNum">   17564 </span><span class="lineCov">   75455995 :   if (TREE_CODE (decl) != OVERLOAD &amp;&amp; TREE_CODE (decl) != TEMPLATE_DECL)</span>
<span class="lineNum">   17565 </span><span class="lineCov">   75536391 :     return NULL_TREE;</span>
<span class="lineNum">   17566 </span><span class="lineCov">      80392 : </span>
<span class="lineNum">   17567 </span><span class="lineCov">   75415799 :   /* Try to build a call expression that evaluates the</span>
<span class="lineNum">   17568 </span>            :      concept. This can fail if the overload set refers
<span class="lineNum">   17569 </span>            :      only to non-templates. */
<span class="lineNum">   17570 </span><span class="lineCov">   75415797 :   tree placeholder = build_nt (WILDCARD_DECL);</span>
<span class="lineNum">   17571 </span>            :   tree check = build_concept_check (decl, placeholder, args);
<span class="lineNum">   17572 </span><span class="lineCov">   75455995 :   if (check == error_mark_node)</span>
<span class="lineNum">   17573 </span>            :     return NULL_TREE;
<span class="lineNum">   17574 </span><span class="lineCov">   75415797 : </span>
<span class="lineNum">   17575 </span>            :   /* Deduce the checked constraint and the prototype parameter.
<span class="lineNum">   17576 </span>            : 
<span class="lineNum">   17577 </span>            :      FIXME: In certain cases, failure to deduce should be a
<span class="lineNum">   17578 </span>            :      diagnosable error.  */
<span class="lineNum">   17579 </span>            :   tree conc;
<span class="lineNum">   17580 </span>            :   tree proto;
<span class="lineNum">   17581 </span>            :   if (!deduce_constrained_parameter (check, conc, proto))
<span class="lineNum">   17582 </span>            :     return NULL_TREE;
<span class="lineNum">   17583 </span>            : 
<span class="lineNum">   17584 </span>            :   /* In template parameter scope, this results in a constrained
<span class="lineNum">   17585 </span>            :      parameter. Return a descriptor of that parm. */
<span class="lineNum">   17586 </span>            :   if (processing_template_parmlist)
<span class="lineNum">   17587 </span><span class="lineCov">       3928 :     return build_constrained_parameter (conc, proto, args);</span>
<span class="lineNum">   17588 </span>            : 
<span class="lineNum">   17589 </span>            :   /* In a parameter-declaration-clause, constrained-type
<span class="lineNum">   17590 </span><span class="lineCov">       3928 :      specifiers result in invented template parameters.  */</span>
<span class="lineNum">   17591 </span>            :   if (parser-&gt;auto_is_implicit_function_template_parm_p)
<span class="lineNum">   17592 </span>            :     {
<span class="lineNum">   17593 </span><span class="lineCov">       3928 :       tree x = build_constrained_parameter (conc, proto, args);</span>
<span class="lineNum">   17594 </span>            :       return synthesize_implicit_template_parm (parser, x);
<span class="lineNum">   17595 </span>            :     }
<span class="lineNum">   17596 </span>            :   else
<span class="lineNum">   17597 </span>            :     {
<span class="lineNum">   17598 </span>            :      /* Otherwise, we're in a context where the constrained
<span class="lineNum">   17599 </span>            :         type name is deduced and the constraint applies
<span class="lineNum">   17600 </span>            :         after deduction. */
<span class="lineNum">   17601 </span>            :       return make_constrained_auto (conc, args);
<span class="lineNum">   17602 </span><span class="lineCov">       1077 :     }</span>
<span class="lineNum">   17603 </span>            : 
<span class="lineNum">   17604 </span>            :   return NULL_TREE;
<span class="lineNum">   17605 </span>            : }
<span class="lineNum">   17606 </span>            : 
<span class="lineNum">   17607 </span>            : /* If DECL refers to a concept, return a TYPE_DECL representing
<span class="lineNum">   17608 </span><span class="lineCov">       1065 :    the result of using the constrained type specifier in the</span>
<span class="lineNum">   17609 </span><span class="lineCov">       1065 :    current context.  DECL refers to a concept if</span>
<span class="lineNum">   17610 </span><span class="lineCov">       1065 : </span>
<span class="lineNum">   17611 </span>            :   - it is an overload set containing a function concept taking a single
<span class="lineNum">   17612 </span>            :     type argument, or
<span class="lineNum">   17613 </span>            : 
<span class="lineNum">   17614 </span>            :   - it is a variable concept taking a single type argument.  */
<a name="17615"><span class="lineNum">   17615 </span>            : </a>
<span class="lineNum">   17616 </span>            : static tree
<span class="lineNum">   17617 </span><span class="lineCov">       1065 : cp_parser_maybe_concept_name (cp_parser* parser, tree decl)</span>
<span class="lineNum">   17618 </span><span class="lineCov">       1065 : {</span>
<span class="lineNum">   17619 </span><span class="lineCov">       1065 :   if (flag_concepts</span>
<span class="lineNum">   17620 </span>            :       &amp;&amp; (TREE_CODE (decl) == OVERLOAD
<span class="lineNum">   17621 </span>            :           || BASELINK_P (decl)
<span class="lineNum">   17622 </span>            :           || variable_concept_p (decl)))
<span class="lineNum">   17623 </span>            :     return cp_parser_maybe_constrained_type_specifier (parser, decl, NULL_TREE);
<span class="lineNum">   17624 </span><span class="lineCov">        332 :   else</span>
<span class="lineNum">   17625 </span><span class="lineCov">        216 :     return NULL_TREE;</span>
<span class="lineNum">   17626 </span>            : }
<span class="lineNum">   17627 </span>            : 
<span class="lineNum">   17628 </span>            : /* Check if DECL and ARGS form a partial-concept-id.  If so,
<span class="lineNum">   17629 </span><span class="lineCov">        116 :    assign ID to the resulting constrained placeholder.</span>
<span class="lineNum">   17630 </span>            : 
<span class="lineNum">   17631 </span><span class="lineCov">         65 :    Returns true if the partial-concept-id designates a placeholder</span>
<span class="lineNum">   17632 </span><span class="lineCov">         65 :    and false otherwise. Note that *id is set to NULL_TREE in</span>
<span class="lineNum">   17633 </span>            :    this case. */
<a name="17634"><span class="lineNum">   17634 </span>            : </a>
<span class="lineNum">   17635 </span>            : static tree
<span class="lineNum">   17636 </span>            : cp_parser_maybe_partial_concept_id (cp_parser *parser, tree decl, tree args)
<span class="lineNum">   17637 </span>            : {
<span class="lineNum">   17638 </span>            :   return cp_parser_maybe_constrained_type_specifier (parser, decl, args);
<span class="lineNum">   17639 </span><span class="lineCov">         51 : }</span>
<span class="lineNum">   17640 </span>            : 
<span class="lineNum">   17641 </span>            : /* Parse a non-class type-name, that is, either an enum-name, a typedef-name,
<span class="lineNum">   17642 </span>            :    or a concept-name.
<span class="lineNum">   17643 </span>            : 
<span class="lineNum">   17644 </span>            :    enum-name:
<span class="lineNum">   17645 </span>            :      identifier
<span class="lineNum">   17646 </span>            : 
<span class="lineNum">   17647 </span>            :    typedef-name:
<span class="lineNum">   17648 </span>            :      identifier
<span class="lineNum">   17649 </span>            : 
<span class="lineNum">   17650 </span>            :    concept-name:
<span class="lineNum">   17651 </span>            :      identifier
<span class="lineNum">   17652 </span>            : 
<span class="lineNum">   17653 </span>            :    Returns a TYPE_DECL for the type.  */
<a name="17654"><span class="lineNum">   17654 </span>            : </a>
<span class="lineNum">   17655 </span><span class="lineCov">   46720170 : static tree</span>
<span class="lineNum">   17656 </span>            : cp_parser_nonclass_name (cp_parser* parser)
<span class="lineNum">   17657 </span><span class="lineCov">   46720170 : {</span>
<span class="lineNum">   17658 </span><span class="lineCov">   46720170 :   tree type_decl;</span>
<span class="lineNum">   17659 </span><span class="lineCov">      27287 :   tree identifier;</span>
<span class="lineNum">   17660 </span><span class="lineCov">      25010 : </span>
<span class="lineNum">   17661 </span><span class="lineCov">       2367 :   cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   17662 </span>            :   identifier = cp_parser_identifier (parser);
<span class="lineNum">   17663 </span>            :   if (identifier == error_mark_node)
<span class="lineNum">   17664 </span>            :     return error_mark_node;
<span class="lineNum">   17665 </span>            : 
<span class="lineNum">   17666 </span>            :   /* Look up the type-name.  */
<span class="lineNum">   17667 </span>            :   type_decl = cp_parser_lookup_name_simple (parser, identifier, token-&gt;location);
<span class="lineNum">   17668 </span>            : 
<span class="lineNum">   17669 </span>            :   type_decl = strip_using_decl (type_decl);
<span class="lineNum">   17670 </span>            :   
<span class="lineNum">   17671 </span>            :   /* If we found an overload set, then it may refer to a concept-name. */
<span class="lineNum">   17672 </span>            :   if (tree decl = cp_parser_maybe_concept_name (parser, type_decl))
<span class="lineNum">   17673 </span>            :     type_decl = decl;
<span class="lineNum">   17674 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   17675 </span>            :   if (TREE_CODE (type_decl) != TYPE_DECL
<span class="lineNum">   17676 </span><span class="lineCov">       1561 :       &amp;&amp; (objc_is_id (identifier) || objc_is_class_name (identifier)))</span>
<span class="lineNum">   17677 </span>            :     {
<span class="lineNum">   17678 </span>            :       /* See if this is an Objective-C type.  */
<span class="lineNum">   17679 </span>            :       tree protos = cp_parser_objc_protocol_refs_opt (parser);
<span class="lineNum">   17680 </span>            :       tree type = objc_get_protocol_qualified_type (identifier, protos);
<span class="lineNum">   17681 </span>            :       if (type)
<span class="lineNum">   17682 </span>            :         type_decl = TYPE_NAME (type);
<span class="lineNum">   17683 </span>            :     }
<span class="lineNum">   17684 </span>            : 
<span class="lineNum">   17685 </span>            :   /* Issue an error if we did not find a type-name.  */
<span class="lineNum">   17686 </span>            :   if (TREE_CODE (type_decl) != TYPE_DECL
<span class="lineNum">   17687 </span>            :       /* In Objective-C, we have the complication that class names are
<span class="lineNum">   17688 </span>            :          normally type names and start declarations (eg, the
<span class="lineNum">   17689 </span>            :          &quot;NSObject&quot; in &quot;NSObject *object;&quot;), but can be used in an
<span class="lineNum">   17690 </span>            :          Objective-C 2.0 dot-syntax (as in &quot;NSObject.version&quot;) which
<span class="lineNum">   17691 </span>            :          is an expression.  So, a classname followed by a dot is not a
<span class="lineNum">   17692 </span>            :          valid type-name.  */
<span class="lineNum">   17693 </span>            :       || (objc_is_class_name (TREE_TYPE (type_decl))
<span class="lineNum">   17694 </span><span class="lineCov">   80653116 :           &amp;&amp; cp_lexer_peek_token (parser-&gt;lexer)-&gt;type == CPP_DOT))</span>
<span class="lineNum">   17695 </span>            :     {
<span class="lineNum">   17696 </span><span class="lineCov">   80653116 :       if (!cp_parser_simulate_error (parser))</span>
<span class="lineNum">   17697 </span><span class="lineCov">   80653116 :         cp_parser_name_lookup_error (parser, identifier, type_decl,</span>
<span class="lineNum">   17698 </span>            :                                      NLE_TYPE, token-&gt;location);
<span class="lineNum">   17699 </span><span class="lineCov">  161306232 :       return error_mark_node;</span>
<span class="lineNum">   17700 </span><span class="lineCov">   80653116 :     }</span>
<span class="lineNum">   17701 </span><span class="lineCov">   80653116 :   /* Remember that the name was used in the definition of the</span>
<span class="lineNum">   17702 </span>            :      current class so that we can check later to see if the
<span class="lineNum">   17703 </span>            :      meaning would have been different after the class was
<span class="lineNum">   17704 </span>            :      entirely defined.  */
<span class="lineNum">   17705 </span><span class="lineCov">   91459070 :   else if (type_decl != error_mark_node</span>
<span class="lineNum">   17706 </span>            :            &amp;&amp; !parser-&gt;scope)
<span class="lineNum">   17707 </span><span class="lineCov">   91459070 :     maybe_note_name_used_in_class (identifier, type_decl);</span>
<span class="lineNum">   17708 </span>            :   
<span class="lineNum">   17709 </span>            :   return type_decl;
<span class="lineNum">   17710 </span><span class="lineCov">   45729535 : }</span>
<span class="lineNum">   17711 </span><span class="lineCov">        256 : </span>
<span class="lineNum">   17712 </span>            : /* Parse an elaborated-type-specifier.  Note that the grammar given
<span class="lineNum">   17713 </span><span class="lineCov">   45729535 :    here incorporates the resolution to DR68.</span>
<span class="lineNum">   17714 </span><span class="lineCov">   45729535 : </span>
<span class="lineNum">   17715 </span>            :    elaborated-type-specifier:
<span class="lineNum">   17716 </span>            :      class-key :: [opt] nested-name-specifier [opt] identifier
<span class="lineNum">   17717 </span><span class="lineNoCov">          0 :      class-key :: [opt] nested-name-specifier [opt] template [opt] template-id</span>
<span class="lineNum">   17718 </span><span class="lineNoCov">          0 :      enum-key :: [opt] nested-name-specifier [opt] identifier</span>
<span class="lineNum">   17719 </span><span class="lineNoCov">          0 :      typename :: [opt] nested-name-specifier identifier</span>
<span class="lineNum">   17720 </span><span class="lineNoCov">          0 :      typename :: [opt] nested-name-specifier template [opt]</span>
<span class="lineNum">   17721 </span>            :        template-id
<span class="lineNum">   17722 </span>            : 
<span class="lineNum">   17723 </span>            :    GNU extension:
<span class="lineNum">   17724 </span><span class="lineCov">   45729535 : </span>
<span class="lineNum">   17725 </span>            :    elaborated-type-specifier:
<span class="lineNum">   17726 </span>            :      class-key attributes :: [opt] nested-name-specifier [opt] identifier
<span class="lineNum">   17727 </span>            :      class-key attributes :: [opt] nested-name-specifier [opt]
<span class="lineNum">   17728 </span>            :                template [opt] template-id
<span class="lineNum">   17729 </span>            :      enum attributes :: [opt] nested-name-specifier [opt] identifier
<span class="lineNum">   17730 </span>            : 
<span class="lineNum">   17731 </span><span class="lineCov">   45729535 :    If IS_FRIEND is TRUE, then this elaborated-type-specifier is being</span>
<span class="lineNum">   17732 </span><span class="lineNoCov">          0 :    declared `friend'.  If IS_DECLARATION is TRUE, then this</span>
<span class="lineNum">   17733 </span>            :    elaborated-type-specifier appears in a decl-specifiers-seq, i.e.,
<span class="lineNum">   17734 </span><span class="lineCov">   35431637 :    something is being declared.</span>
<span class="lineNum">   17735 </span><span class="lineCov">         90 : </span>
<span class="lineNum">   17736 </span>            :    Returns the TYPE specified.  */
<a name="17737"><span class="lineNum">   17737 </span><span class="lineCov">   35431727 : </span></a>
<span class="lineNum">   17738 </span>            : static tree
<span class="lineNum">   17739 </span>            : cp_parser_elaborated_type_specifier (cp_parser* parser,
<span class="lineNum">   17740 </span>            :                                      bool is_friend,
<span class="lineNum">   17741 </span>            :                                      bool is_declaration)
<span class="lineNum">   17742 </span>            : {
<span class="lineNum">   17743 </span><span class="lineCov">   10297808 :   enum tag_types tag_type;</span>
<span class="lineNum">   17744 </span><span class="lineCov">   10297808 :   tree identifier;</span>
<span class="lineNum">   17745 </span><span class="lineCov">    9749318 :   tree type = NULL_TREE;</span>
<span class="lineNum">   17746 </span>            :   tree attributes = NULL_TREE;
<span class="lineNum">   17747 </span>            :   tree globalscope;
<span class="lineNum">   17748 </span>            :   cp_token *token = NULL;
<span class="lineNum">   17749 </span>            : 
<span class="lineNum">   17750 </span>            :   /* See if we're looking at the `enum' keyword.  */
<span class="lineNum">   17751 </span>            :   if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_ENUM))
<span class="lineNum">   17752 </span>            :     {
<span class="lineNum">   17753 </span>            :       /* Consume the `enum' token.  */
<span class="lineNum">   17754 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   17755 </span>            :       /* Remember that it's an enumeration type.  */
<span class="lineNum">   17756 </span>            :       tag_type = enum_type;
<span class="lineNum">   17757 </span>            :       /* Issue a warning if the `struct' or `class' key (for C++0x scoped
<span class="lineNum">   17758 </span>            :          enums) is used here.  */
<span class="lineNum">   17759 </span>            :       cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   17760 </span>            :       if (cp_parser_is_keyword (token, RID_CLASS)
<span class="lineNum">   17761 </span>            :           || cp_parser_is_keyword (token, RID_STRUCT))
<span class="lineNum">   17762 </span>            :         {
<span class="lineNum">   17763 </span>            :           gcc_rich_location richloc (token-&gt;location);
<span class="lineNum">   17764 </span>            :           richloc.add_range (input_location);
<span class="lineNum">   17765 </span>            :           richloc.add_fixit_remove ();
<span class="lineNum">   17766 </span>            :           pedwarn (&amp;richloc, 0, &quot;elaborated-type-specifier for &quot;
<span class="lineNum">   17767 </span>            :                    &quot;a scoped enum must not use the %qD keyword&quot;,
<span class="lineNum">   17768 </span>            :                    token-&gt;u.value);
<span class="lineNum">   17769 </span>            :           /* Consume the `struct' or `class' and parse it anyway.  */
<span class="lineNum">   17770 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   17771 </span>            :         }
<span class="lineNum">   17772 </span>            :       /* Parse the attributes.  */
<span class="lineNum">   17773 </span>            :       attributes = cp_parser_attributes_opt (parser);
<span class="lineNum">   17774 </span>            :     }
<span class="lineNum">   17775 </span>            :   /* Or, it might be `typename'.  */
<span class="lineNum">   17776 </span>            :   else if (cp_lexer_next_token_is_keyword (parser-&gt;lexer,
<span class="lineNum">   17777 </span><span class="lineCov">    2344354 :                                            RID_TYPENAME))</span>
<span class="lineNum">   17778 </span>            :     {
<span class="lineNum">   17779 </span>            :       /* Consume the `typename' token.  */
<span class="lineNum">   17780 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   17781 </span><span class="lineCov">    2344354 :       /* Remember that it's a `typename' type.  */</span>
<span class="lineNum">   17782 </span><span class="lineCov">    2344354 :       tag_type = typename_type;</span>
<span class="lineNum">   17783 </span><span class="lineCov">    2344354 :     }</span>
<span class="lineNum">   17784 </span><span class="lineCov">    2344354 :   /* Otherwise it must be a class-key.  */</span>
<span class="lineNum">   17785 </span><span class="lineCov">    2344354 :   else</span>
<span class="lineNum">   17786 </span><span class="lineCov">    2344354 :     {</span>
<span class="lineNum">   17787 </span>            :       tag_type = cp_parser_class_key (parser);
<span class="lineNum">   17788 </span>            :       if (tag_type == none_type)
<span class="lineNum">   17789 </span><span class="lineCov">    2344354 :         return error_mark_node;</span>
<span class="lineNum">   17790 </span>            :       /* Parse the attributes.  */
<span class="lineNum">   17791 </span>            :       attributes = cp_parser_attributes_opt (parser);
<span class="lineNum">   17792 </span><span class="lineCov">      14107 :     }</span>
<span class="lineNum">   17793 </span>            : 
<span class="lineNum">   17794 </span><span class="lineCov">      14107 :   /* Look for the `::' operator.  */</span>
<span class="lineNum">   17795 </span>            :   globalscope =  cp_parser_global_scope_opt (parser,
<span class="lineNum">   17796 </span>            :                                              /*current_scope_valid_p=*/false);
<span class="lineNum">   17797 </span><span class="lineCov">      28214 :   /* Look for the nested-name-specifier.  */</span>
<span class="lineNum">   17798 </span><span class="lineCov">      28214 :   tree nested_name_specifier;</span>
<span class="lineNum">   17799 </span><span class="lineCov">      14107 :   if (tag_type == typename_type &amp;&amp; !globalscope)</span>
<span class="lineNum">   17800 </span>            :     {
<span class="lineNum">   17801 </span><span class="lineCov">         12 :       nested_name_specifier</span>
<span class="lineNum">   17802 </span><span class="lineCov">          6 :         = cp_parser_nested_name_specifier (parser,</span>
<span class="lineNum">   17803 </span><span class="lineCov">          6 :                                            /*typename_keyword_p=*/true,</span>
<span class="lineNum">   17804 </span><span class="lineCov">          6 :                                            /*check_dependency_p=*/true,</span>
<span class="lineNum">   17805 </span>            :                                            /*type_p=*/true,
<span class="lineNum">   17806 </span>            :                                            is_declaration);
<span class="lineNum">   17807 </span>            :       if (!nested_name_specifier)
<span class="lineNum">   17808 </span><span class="lineCov">          6 :         return error_mark_node;</span>
<span class="lineNum">   17809 </span>            :     }
<span class="lineNum">   17810 </span>            :   else
<span class="lineNum">   17811 </span><span class="lineCov">      14107 :     /* Even though `typename' is not present, the proposed resolution</span>
<span class="lineNum">   17812 </span>            :        to Core Issue 180 says that in `class A&lt;T&gt;::B', `B' should be
<span class="lineNum">   17813 </span>            :        considered a type-name, even if `A&lt;T&gt;' is dependent.  */
<span class="lineNum">   17814 </span><span class="lineCov">    2330247 :     nested_name_specifier</span>
<span class="lineNum">   17815 </span>            :       = cp_parser_nested_name_specifier_opt (parser,
<span class="lineNum">   17816 </span>            :                                              /*typename_keyword_p=*/true,
<span class="lineNum">   17817 </span>            :                                              /*check_dependency_p=*/true,
<span class="lineNum">   17818 </span><span class="lineCov">    1454752 :                                              /*type_p=*/true,</span>
<span class="lineNum">   17819 </span>            :                                              is_declaration);
<span class="lineNum">   17820 </span><span class="lineCov">    1454752 :  /* For everything but enumeration types, consider a template-id.</span>
<span class="lineNum">   17821 </span>            :     For an enumeration type, consider only a plain identifier.  */
<span class="lineNum">   17822 </span>            :   if (tag_type != enum_type)
<span class="lineNum">   17823 </span>            :     {
<span class="lineNum">   17824 </span>            :       bool template_p = false;
<span class="lineNum">   17825 </span><span class="lineCov">     875495 :       tree decl;</span>
<span class="lineNum">   17826 </span><span class="lineCov">     875495 : </span>
<span class="lineNum">   17827 </span><span class="lineCov">          4 :       /* Allow the `template' keyword.  */</span>
<span class="lineNum">   17828 </span>            :       template_p = cp_parser_optional_template_keyword (parser);
<span class="lineNum">   17829 </span><span class="lineCov">     875491 :       /* If we didn't see `template', we don't know if there's a</span>
<span class="lineNum">   17830 </span>            :          template-id or not.  */
<span class="lineNum">   17831 </span>            :       if (!template_p)
<span class="lineNum">   17832 </span>            :         cp_parser_parse_tentatively (parser);
<span class="lineNum">   17833 </span><span class="lineCov">    4688700 :       /* Parse the template-id.  */</span>
<span class="lineNum">   17834 </span>            :       token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   17835 </span>            :       decl = cp_parser_template_id (parser, template_p,
<span class="lineNum">   17836 </span><span class="lineCov">    2344350 :                                     /*check_dependency_p=*/true,</span>
<span class="lineNum">   17837 </span><span class="lineCov">    2344350 :                                     tag_type,</span>
<span class="lineNum">   17838 </span>            :                                     is_declaration);
<span class="lineNum">   17839 </span><span class="lineCov">    1454733 :       /* If we didn't find a template-id, look for an ordinary</span>
<span class="lineNum">   17840 </span><span class="lineCov">    1454733 :          identifier.  */</span>
<span class="lineNum">   17841 </span>            :       if (!template_p &amp;&amp; !cp_parser_parse_definitely (parser))
<span class="lineNum">   17842 </span>            :         ;
<span class="lineNum">   17843 </span>            :       /* We can get here when cp_parser_template_id, called by
<span class="lineNum">   17844 </span>            :          cp_parser_class_name with tag_type == none_type, succeeds
<span class="lineNum">   17845 </span><span class="lineCov">    1454733 :          and caches a BASELINK.  Then, when called again here,</span>
<span class="lineNum">   17846 </span><span class="lineCov">         66 :          instead of failing and returning an error_mark_node</span>
<span class="lineNum">   17847 </span>            :          returns it (see template/typename17.C in C++11).
<span class="lineNum">   17848 </span>            :          ??? Could we diagnose this earlier?  */
<span class="lineNum">   17849 </span>            :       else if (tag_type == typename_type &amp;&amp; BASELINK_P (decl))
<span class="lineNum">   17850 </span>            :         {
<span class="lineNum">   17851 </span>            :           cp_parser_diagnose_invalid_type_name (parser, decl, token-&gt;location);
<span class="lineNum">   17852 </span><span class="lineCov">     889617 :           type = error_mark_node;</span>
<span class="lineNum">   17853 </span><span class="lineCov">     889617 :         }</span>
<span class="lineNum">   17854 </span>            :       /* If DECL is a TEMPLATE_ID_EXPR, and the `typename' keyword is
<span class="lineNum">   17855 </span>            :          in effect, then we must assume that, upon instantiation, the
<span class="lineNum">   17856 </span>            :          template will correspond to a class.  */
<span class="lineNum">   17857 </span>            :       else if (TREE_CODE (decl) == TEMPLATE_ID_EXPR
<span class="lineNum">   17858 </span>            :                &amp;&amp; tag_type == typename_type)
<span class="lineNum">   17859 </span>            :         type = make_typename_type (parser-&gt;scope, decl,
<span class="lineNum">   17860 </span><span class="lineCov">    2344284 :                                    typename_type,</span>
<span class="lineNum">   17861 </span>            :                                    /*complain=*/tf_error);
<span class="lineNum">   17862 </span><span class="lineCov">    2330177 :       /* If the `typename' keyword is in effect and DECL is not a type</span>
<span class="lineNum">   17863 </span><span class="lineCov">    2330177 :          decl, then type is non existent.   */</span>
<span class="lineNum">   17864 </span>            :       else if (tag_type == typename_type &amp;&amp; TREE_CODE (decl) != TYPE_DECL)
<span class="lineNum">   17865 </span>            :         ; 
<span class="lineNum">   17866 </span><span class="lineCov">    2330177 :       else if (TREE_CODE (decl) == TYPE_DECL)</span>
<span class="lineNum">   17867 </span>            :         {
<span class="lineNum">   17868 </span>            :           type = check_elaborated_type_specifier (tag_type, decl,
<span class="lineNum">   17869 </span><span class="lineCov">    2330177 :                                                   /*allow_template_p=*/true);</span>
<span class="lineNum">   17870 </span><span class="lineCov">    2317631 : </span>
<span class="lineNum">   17871 </span>            :           /* If the next token is a semicolon, this must be a specialization,
<span class="lineNum">   17872 </span><span class="lineCov">    4660354 :              instantiation, or friend declaration.  Check the scope while we</span>
<span class="lineNum">   17873 </span><span class="lineCov">    2330177 :              still know whether or not we had a nested-name-specifier.  */</span>
<span class="lineNum">   17874 </span>            :           if (type != error_mark_node
<span class="lineNum">   17875 </span>            :               &amp;&amp; !nested_name_specifier &amp;&amp; !is_friend
<span class="lineNum">   17876 </span>            :               &amp;&amp; cp_lexer_next_token_is (parser-&gt;lexer, CPP_SEMICOLON))
<span class="lineNum">   17877 </span>            :             check_unqualified_spec_or_inst (type, token-&gt;location);
<span class="lineNum">   17878 </span>            :         }
<span class="lineNum">   17879 </span><span class="lineCov">    2330177 :       else if (decl == error_mark_node)</span>
<span class="lineNum">   17880 </span>            :         type = error_mark_node; 
<span class="lineNum">   17881 </span>            :     }
<span class="lineNum">   17882 </span>            : 
<span class="lineNum">   17883 </span>            :   if (!type)
<span class="lineNum">   17884 </span>            :     {
<span class="lineNum">   17885 </span>            :       token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   17886 </span>            :       identifier = cp_parser_identifier (parser);
<span class="lineNum">   17887 </span><span class="lineCov">     105935 : </span>
<span class="lineNum">   17888 </span>            :       if (identifier == error_mark_node)
<span class="lineNum">   17889 </span><span class="lineNoCov">          0 :         {</span>
<span class="lineNum">   17890 </span><span class="lineNoCov">          0 :           parser-&gt;scope = NULL_TREE;</span>
<span class="lineNum">   17891 </span>            :           return error_mark_node;
<span class="lineNum">   17892 </span>            :         }
<span class="lineNum">   17893 </span>            : 
<span class="lineNum">   17894 </span>            :       /* For a `typename', we needn't call xref_tag.  */
<span class="lineNum">   17895 </span><span class="lineCov">     105935 :       if (tag_type == typename_type</span>
<span class="lineNum">   17896 </span><span class="lineCov">      12529 :           &amp;&amp; TREE_CODE (parser-&gt;scope) != NAMESPACE_DECL)</span>
<span class="lineNum">   17897 </span><span class="lineCov">      12529 :         return cp_parser_make_typename_type (parser, identifier,</span>
<span class="lineNum">   17898 </span>            :                                              token-&gt;location);
<span class="lineNum">   17899 </span>            : 
<span class="lineNum">   17900 </span>            :       /* Template parameter lists apply only if we are not within a
<span class="lineNum">   17901 </span>            :          function parameter list.  */
<span class="lineNum">   17902 </span><span class="lineCov">      93406 :       bool template_parm_lists_apply</span>
<span class="lineNum">   17903 </span>            :           = parser-&gt;num_template_parameter_lists;
<span class="lineNum">   17904 </span><span class="lineCov">      93400 :       if (template_parm_lists_apply)</span>
<span class="lineNum">   17905 </span>            :         for (cp_binding_level *s = current_binding_level;
<span class="lineNum">   17906 </span><span class="lineCov">      93381 :              s &amp;&amp; s-&gt;kind != sk_template_parms;</span>
<span class="lineNum">   17907 </span>            :              s = s-&gt;level_chain)
<span class="lineNum">   17908 </span>            :           if (s-&gt;kind == sk_function_parms)
<span class="lineNum">   17909 </span>            :             template_parm_lists_apply = false;
<span class="lineNum">   17910 </span>            : 
<span class="lineNum">   17911 </span>            :       /* Look up a qualified name in the usual way.  */
<span class="lineNum">   17912 </span><span class="lineCov">      93381 :       if (parser-&gt;scope)</span>
<span class="lineNum">   17913 </span><span class="lineCov">      93367 :         {</span>
<span class="lineNum">   17914 </span><span class="lineCov">     162724 :           tree decl;</span>
<span class="lineNum">   17915 </span><span class="lineCov">      69282 :           tree ambiguous_decls;</span>
<span class="lineNum">   17916 </span>            : 
<span class="lineNum">   17917 </span><span class="lineCov">         19 :           decl = cp_parser_lookup_name (parser, identifier,</span>
<span class="lineNum">   17918 </span><span class="lineCov">         19 :                                         tag_type,</span>
<span class="lineNum">   17919 </span>            :                                         /*is_template=*/false,
<span class="lineNum">   17920 </span>            :                                         /*is_namespace=*/false,
<span class="lineNum">   17921 </span><span class="lineCov">    2344284 :                                         /*check_dependency=*/true,</span>
<span class="lineNum">   17922 </span>            :                                         &amp;ambiguous_decls,
<span class="lineNum">   17923 </span><span class="lineCov">    4476710 :                                         token-&gt;location);</span>
<span class="lineNum">   17924 </span><span class="lineCov">    2238355 : </span>
<span class="lineNum">   17925 </span>            :           /* If the lookup was ambiguous, an error will already have been
<span class="lineNum">   17926 </span><span class="lineCov">    2238355 :              issued.  */</span>
<span class="lineNum">   17927 </span>            :           if (ambiguous_decls)
<span class="lineNum">   17928 </span><span class="lineCov">         38 :             return error_mark_node;</span>
<span class="lineNum">   17929 </span><span class="lineCov">         38 : </span>
<span class="lineNum">   17930 </span>            :           /* If we are parsing friend declaration, DECL may be a
<span class="lineNum">   17931 </span>            :              TEMPLATE_DECL tree node here.  However, we need to check
<span class="lineNum">   17932 </span>            :              whether this TEMPLATE_DECL results in valid code.  Consider
<span class="lineNum">   17933 </span><span class="lineCov">    2238317 :              the following example:</span>
<span class="lineNum">   17934 </span><span class="lineCov">    1439069 : </span>
<span class="lineNum">   17935 </span><span class="lineCov">    1439033 :                namespace N {</span>
<span class="lineNum">   17936 </span><span class="lineCov">    1439033 :                  template &lt;class T&gt; class C {};</span>
<span class="lineNum">   17937 </span>            :                }
<span class="lineNum">   17938 </span>            :                class X {
<span class="lineNum">   17939 </span>            :                  template &lt;class T&gt; friend class N::C; // #1, valid code
<span class="lineNum">   17940 </span><span class="lineCov">    1598568 :                };</span>
<span class="lineNum">   17941 </span><span class="lineCov">     799284 :                template &lt;class T&gt; class Y {</span>
<span class="lineNum">   17942 </span><span class="lineCov">     799284 :                  friend class N::C;                    // #2, invalid code</span>
<span class="lineNum">   17943 </span><span class="lineCov">     268027 :                };</span>
<span class="lineNum">   17944 </span><span class="lineCov">     268060 : </span>
<span class="lineNum">   17945 </span><span class="lineCov">         33 :              For both case #1 and #2, we arrive at a TEMPLATE_DECL after</span>
<span class="lineNum">   17946 </span><span class="lineCov">         33 :              name lookup of `N::C'.  We see that friend declaration must</span>
<span class="lineNum">   17947 </span><span class="lineCov">         18 :              be template for the code to be valid.  Note that</span>
<span class="lineNum">   17948 </span>            :              processing_template_decl does not work here since it is
<span class="lineNum">   17949 </span>            :              always 1 for the above two cases.  */
<span class="lineNum">   17950 </span><span class="lineCov">     799284 : </span>
<span class="lineNum">   17951 </span>            :           decl = (cp_parser_maybe_treat_template_as_class
<span class="lineNum">   17952 </span><span class="lineCov">       6868 :                   (decl, /*tag_name_p=*/is_friend</span>
<span class="lineNum">   17953 </span><span class="lineCov">       6868 :                          &amp;&amp; template_parm_lists_apply));</span>
<span class="lineNum">   17954 </span>            : 
<span class="lineNum">   17955 </span><span class="lineCov">      13736 :           if (TREE_CODE (decl) != TYPE_DECL)</span>
<span class="lineNum">   17956 </span>            :             {
<span class="lineNum">   17957 </span>            :               cp_parser_diagnose_invalid_type_name (parser,
<span class="lineNum">   17958 </span>            :                                                     identifier,
<span class="lineNum">   17959 </span>            :                                                     token-&gt;location);
<span class="lineNum">   17960 </span>            :               return error_mark_node;
<span class="lineNum">   17961 </span><span class="lineCov">       6868 :             }</span>
<span class="lineNum">   17962 </span>            : 
<span class="lineNum">   17963 </span>            :           if (TREE_CODE (TREE_TYPE (decl)) != TYPENAME_TYPE)
<span class="lineNum">   17964 </span>            :             {
<span class="lineNum">   17965 </span><span class="lineCov">       6868 :               bool allow_template = (template_parm_lists_apply</span>
<span class="lineNum">   17966 </span><span class="lineCov">         83 :                                      || DECL_SELF_REFERENCE_P (decl));</span>
<span class="lineNum">   17967 </span>            :               type = check_elaborated_type_specifier (tag_type, decl,
<span class="lineNum">   17968 </span>            :                                                       allow_template);
<span class="lineNum">   17969 </span>            : 
<span class="lineNum">   17970 </span>            :               if (type == error_mark_node)
<span class="lineNum">   17971 </span>            :                 return error_mark_node;
<span class="lineNum">   17972 </span>            :             }
<span class="lineNum">   17973 </span>            : 
<span class="lineNum">   17974 </span>            :           /* Forward declarations of nested types, such as
<span class="lineNum">   17975 </span>            : 
<span class="lineNum">   17976 </span>            :                class C1::C2;
<span class="lineNum">   17977 </span>            :                class C1::C2::C3;
<span class="lineNum">   17978 </span>            : 
<span class="lineNum">   17979 </span>            :              are invalid unless all components preceding the final '::'
<span class="lineNum">   17980 </span>            :              are complete.  If all enclosing types are complete, these
<span class="lineNum">   17981 </span>            :              declarations become merely pointless.
<span class="lineNum">   17982 </span>            : 
<span class="lineNum">   17983 </span>            :              Invalid forward declarations of nested types are errors
<span class="lineNum">   17984 </span>            :              caught elsewhere in parsing.  Those that are pointless arrive
<span class="lineNum">   17985 </span>            :              here.  */
<span class="lineNum">   17986 </span>            : 
<span class="lineNum">   17987 </span>            :           if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_SEMICOLON)
<span class="lineNum">   17988 </span>            :               &amp;&amp; !is_friend &amp;&amp; !processing_explicit_instantiation)
<span class="lineNum">   17989 </span><span class="lineCov">      13730 :             warning (0, &quot;declaration %qD does not declare anything&quot;, decl);</span>
<span class="lineNum">   17990 </span><span class="lineCov">       6865 : </span>
<span class="lineNum">   17991 </span><span class="lineCov">       6865 :           type = TREE_TYPE (decl);</span>
<span class="lineNum">   17992 </span>            :         }
<span class="lineNum">   17993 </span><span class="lineCov">       6865 :       else</span>
<span class="lineNum">   17994 </span>            :         {
<span class="lineNum">   17995 </span><span class="lineCov">         57 :           /* An elaborated-type-specifier sometimes introduces a new type and</span>
<span class="lineNum">   17996 </span>            :              sometimes names an existing type.  Normally, the rule is that it
<span class="lineNum">   17997 </span>            :              introduces a new type only if there is not an existing type of
<span class="lineNum">   17998 </span><span class="lineCov">         57 :              the same name already in scope.  For example, given:</span>
<span class="lineNum">   17999 </span>            : 
<span class="lineNum">   18000 </span>            :                struct S {};
<span class="lineNum">   18001 </span><span class="lineCov">       6808 :                void f() { struct S s; }</span>
<span class="lineNum">   18002 </span>            : 
<span class="lineNum">   18003 </span><span class="lineCov">       6721 :              the `struct S' in the body of `f' is the same `struct S' as in</span>
<span class="lineNum">   18004 </span><span class="lineCov">       6721 :              the global scope; the existing definition is used.  However, if</span>
<span class="lineNum">   18005 </span><span class="lineCov">       6721 :              there were no global declaration, this would introduce a new</span>
<span class="lineNum">   18006 </span>            :              local class named `S'.
<span class="lineNum">   18007 </span>            : 
<span class="lineNum">   18008 </span><span class="lineCov">       6721 :              An exception to this rule applies to the following code:</span>
<span class="lineNum">   18009 </span>            : 
<span class="lineNum">   18010 </span>            :                namespace N { struct S; }
<span class="lineNum">   18011 </span>            : 
<span class="lineNum">   18012 </span>            :              Here, the elaborated-type-specifier names a new type
<span class="lineNum">   18013 </span>            :              unconditionally; even if there is already an `S' in the
<span class="lineNum">   18014 </span>            :              containing scope this declaration names a new type.
<span class="lineNum">   18015 </span>            :              This exception only applies if the elaborated-type-specifier
<span class="lineNum">   18016 </span>            :              forms the complete declaration:
<span class="lineNum">   18017 </span>            : 
<span class="lineNum">   18018 </span>            :                [class.name]
<span class="lineNum">   18019 </span>            : 
<span class="lineNum">   18020 </span>            :                A declaration consisting solely of `class-key identifier ;' is
<span class="lineNum">   18021 </span>            :                either a redeclaration of the name in the current scope or a
<span class="lineNum">   18022 </span>            :                forward declaration of the identifier as a class name.  It
<span class="lineNum">   18023 </span>            :                introduces the name into the current scope.
<span class="lineNum">   18024 </span>            : 
<span class="lineNum">   18025 </span><span class="lineCov">      13570 :              We are in this situation precisely when the next token is a `;'.</span>
<span class="lineNum">   18026 </span><span class="lineCov">       6785 : </span>
<span class="lineNum">   18027 </span><span class="lineCov">         21 :              An exception to the exception is that a `friend' declaration does</span>
<span class="lineNum">   18028 </span>            :              *not* name a new type; i.e., given:
<span class="lineNum">   18029 </span><span class="lineCov">       6785 : </span>
<span class="lineNum">   18030 </span>            :                struct S { friend struct T; };
<span class="lineNum">   18031 </span>            : 
<span class="lineNum">   18032 </span>            :              `T' is not a new type in the scope of `S'.
<span class="lineNum">   18033 </span>            : 
<span class="lineNum">   18034 </span>            :              Also, `new struct S' or `sizeof (struct S)' never results in the
<span class="lineNum">   18035 </span>            :              definition of a new type; a new type can only be declared in a
<span class="lineNum">   18036 </span>            :              declaration context.  */
<span class="lineNum">   18037 </span>            : 
<span class="lineNum">   18038 </span>            :           tag_scope ts;
<span class="lineNum">   18039 </span>            :           bool template_p;
<span class="lineNum">   18040 </span>            : 
<span class="lineNum">   18041 </span>            :           if (is_friend)
<span class="lineNum">   18042 </span>            :             /* Friends have special name lookup rules.  */
<span class="lineNum">   18043 </span>            :             ts = ts_within_enclosing_non_class;
<span class="lineNum">   18044 </span>            :           else if (is_declaration
<span class="lineNum">   18045 </span>            :                    &amp;&amp; cp_lexer_next_token_is (parser-&gt;lexer,
<span class="lineNum">   18046 </span>            :                                               CPP_SEMICOLON))
<span class="lineNum">   18047 </span>            :             /* This is a `class-key identifier ;' */
<span class="lineNum">   18048 </span>            :             ts = ts_current;
<span class="lineNum">   18049 </span>            :           else
<span class="lineNum">   18050 </span>            :             ts = ts_global;
<span class="lineNum">   18051 </span>            : 
<span class="lineNum">   18052 </span>            :           template_p =
<span class="lineNum">   18053 </span>            :             (template_parm_lists_apply
<span class="lineNum">   18054 </span>            :              &amp;&amp; (cp_parser_next_token_starts_class_definition_p (parser)
<span class="lineNum">   18055 </span>            :                  || cp_lexer_next_token_is (parser-&gt;lexer, CPP_SEMICOLON)));
<span class="lineNum">   18056 </span>            :           /* An unqualified name was used to reference this type, so
<span class="lineNum">   18057 </span>            :              there were no qualifying templates.  */
<span class="lineNum">   18058 </span>            :           if (template_parm_lists_apply
<span class="lineNum">   18059 </span>            :               &amp;&amp; !cp_parser_check_template_parameters (parser,
<span class="lineNum">   18060 </span>            :                                                        /*num_templates=*/0,
<span class="lineNum">   18061 </span>            :                                                        /*template_id*/false,
<span class="lineNum">   18062 </span>            :                                                        token-&gt;location,
<span class="lineNum">   18063 </span>            :                                                        /*declarator=*/NULL))
<span class="lineNum">   18064 </span>            :             return error_mark_node;
<span class="lineNum">   18065 </span>            :           type = xref_tag (tag_type, identifier, ts, template_p);
<span class="lineNum">   18066 </span>            :         }
<span class="lineNum">   18067 </span>            :     }
<span class="lineNum">   18068 </span>            : 
<span class="lineNum">   18069 </span>            :   if (type == error_mark_node)
<span class="lineNum">   18070 </span>            :     return error_mark_node;
<span class="lineNum">   18071 </span>            : 
<span class="lineNum">   18072 </span>            :   /* Allow attributes on forward declarations of classes.  */
<span class="lineNum">   18073 </span>            :   if (attributes)
<span class="lineNum">   18074 </span>            :     {
<span class="lineNum">   18075 </span>            :       if (TREE_CODE (type) == TYPENAME_TYPE)
<span class="lineNum">   18076 </span><span class="lineCov">     792416 :         warning (OPT_Wattributes,</span>
<span class="lineNum">   18077 </span><span class="lineCov">     792416 :                  &quot;attributes ignored on uninstantiated type&quot;);</span>
<span class="lineNum">   18078 </span>            :       else if (tag_type != enum_type &amp;&amp; CLASSTYPE_TEMPLATE_INSTANTIATION (type)
<span class="lineNum">   18079 </span><span class="lineCov">     792416 :                &amp;&amp; ! processing_explicit_instantiation)</span>
<span class="lineNum">   18080 </span>            :         warning (OPT_Wattributes,
<span class="lineNum">   18081 </span>            :                  &quot;attributes ignored on template instantiation&quot;);
<span class="lineNum">   18082 </span><span class="lineCov">     769012 :       else if (is_declaration &amp;&amp; cp_parser_declares_only_class_p (parser))</span>
<span class="lineNum">   18083 </span><span class="lineCov">     769012 :         cplus_decl_attributes (&amp;type, attributes, (int) ATTR_FLAG_TYPE_IN_PLACE);</span>
<span class="lineNum">   18084 </span>            :       else
<span class="lineNum">   18085 </span>            :         warning (OPT_Wattributes,
<span class="lineNum">   18086 </span>            :                  &quot;attributes ignored on elaborated-type-specifier that is not a forward declaration&quot;);
<span class="lineNum">   18087 </span>            :     }
<span class="lineNum">   18088 </span>            : 
<span class="lineNum">   18089 </span>            :   if (tag_type != enum_type)
<span class="lineNum">   18090 </span><span class="lineCov">    1584832 :     {</span>
<span class="lineNum">   18091 </span>            :       /* Indicate whether this class was declared as a `class' or as a
<span class="lineNum">   18092 </span><span class="lineCov">     792416 :          `struct'.  */</span>
<span class="lineNum">   18093 </span><span class="lineCov">     266033 :       if (CLASS_TYPE_P (type))</span>
<span class="lineNum">   18094 </span>            :         CLASSTYPE_DECLARED_CLASS (type) = (tag_type == class_type);
<span class="lineNum">   18095 </span>            :       cp_parser_check_class_key (tag_type, type);
<span class="lineNum">   18096 </span><span class="lineCov">     792416 :     }</span>
<span class="lineNum">   18097 </span><span class="lineCov">     792416 : </span>
<span class="lineNum">   18098 </span>            :   /* A &quot;&lt;&quot; cannot follow an elaborated type specifier.  If that
<span class="lineNum">   18099 </span>            :      happens, the user was probably trying to form a template-id.  */
<span class="lineNum">   18100 </span>            :   cp_parser_check_for_invalid_template_id (parser, type, tag_type,
<span class="lineNum">   18101 </span>            :                                            token-&gt;location);
<span class="lineNum">   18102 </span><span class="lineCov">          6 : </span>
<span class="lineNum">   18103 </span><span class="lineCov">     792410 :   return type;</span>
<span class="lineNum">   18104 </span>            : }
<span class="lineNum">   18105 </span>            : 
<span class="lineNum">   18106 </span>            : /* Parse an enum-specifier.
<span class="lineNum">   18107 </span><span class="lineCov">     905124 : </span>
<span class="lineNum">   18108 </span>            :    enum-specifier:
<span class="lineNum">   18109 </span>            :      enum-head { enumerator-list [opt] }
<span class="lineNum">   18110 </span>            :      enum-head { enumerator-list , } [C++0x]
<span class="lineNum">   18111 </span><span class="lineCov">     904973 : </span>
<span class="lineNum">   18112 </span>            :    enum-head:
<span class="lineNum">   18113 </span><span class="lineCov">         65 :      enum-key identifier [opt] enum-base [opt]</span>
<span class="lineNum">   18114 </span><span class="lineCov">          5 :      enum-key nested-name-specifier identifier enum-base [opt]</span>
<span class="lineNum">   18115 </span>            : 
<span class="lineNum">   18116 </span><span class="lineCov">         55 :    enum-key:</span>
<span class="lineNum">   18117 </span><span class="lineCov">         80 :      enum</span>
<span class="lineNum">   18118 </span><span class="lineCov">          5 :      enum class   [C++0x]</span>
<span class="lineNum">   18119 </span>            :      enum struct  [C++0x]
<span class="lineNum">   18120 </span><span class="lineCov">         55 : </span>
<span class="lineNum">   18121 </span><span class="lineCov">         44 :    enum-base:   [C++0x]</span>
<span class="lineNum">   18122 </span>            :      : type-specifier-seq
<span class="lineNum">   18123 </span><span class="lineCov">         11 : </span>
<span class="lineNum">   18124 </span>            :    opaque-enum-specifier:
<span class="lineNum">   18125 </span>            :      enum-key identifier enum-base [opt] ;
<span class="lineNum">   18126 </span>            : 
<span class="lineNum">   18127 </span><span class="lineCov">     904973 :    GNU Extensions:</span>
<span class="lineNum">   18128 </span>            :      enum-key attributes[opt] identifier [opt] enum-base [opt] 
<span class="lineNum">   18129 </span>            :        { enumerator-list [opt] }attributes[opt]
<span class="lineNum">   18130 </span>            :      enum-key attributes[opt] identifier [opt] enum-base [opt]
<span class="lineNum">   18131 </span><span class="lineCov">     890890 :        { enumerator-list, }attributes[opt] [C++0x]</span>
<span class="lineNum">   18132 </span><span class="lineCov">    1756312 : </span>
<span class="lineNum">   18133 </span><span class="lineCov">     890890 :    Returns an ENUM_TYPE representing the enumeration, or NULL_TREE</span>
<span class="lineNum">   18134 </span>            :    if the token stream isn't an enum-specifier after all.  */
<a name="18135"><span class="lineNum">   18135 </span>            : </a>
<span class="lineNum">   18136 </span>            : static tree
<span class="lineNum">   18137 </span>            : cp_parser_enum_specifier (cp_parser* parser)
<span class="lineNum">   18138 </span><span class="lineCov">     904973 : {</span>
<span class="lineNum">   18139 </span>            :   tree identifier;
<span class="lineNum">   18140 </span>            :   tree type = NULL_TREE;
<span class="lineNum">   18141 </span><span class="lineCov">     904973 :   tree prev_scope;</span>
<span class="lineNum">   18142 </span>            :   tree nested_name_specifier = NULL_TREE;
<span class="lineNum">   18143 </span>            :   tree attributes;
<span class="lineNum">   18144 </span>            :   bool scoped_enum_p = false;
<span class="lineNum">   18145 </span>            :   bool has_underlying_type = false;
<span class="lineNum">   18146 </span>            :   bool nested_being_defined = false;
<span class="lineNum">   18147 </span>            :   bool new_value_list = false;
<span class="lineNum">   18148 </span>            :   bool is_new_type = false;
<span class="lineNum">   18149 </span>            :   bool is_unnamed = false;
<span class="lineNum">   18150 </span>            :   tree underlying_type = NULL_TREE;
<span class="lineNum">   18151 </span>            :   cp_token *type_start_token = NULL;
<span class="lineNum">   18152 </span>            :   bool saved_colon_corrects_to_scope_p = parser-&gt;colon_corrects_to_scope_p;
<span class="lineNum">   18153 </span>            : 
<span class="lineNum">   18154 </span>            :   parser-&gt;colon_corrects_to_scope_p = false;
<span class="lineNum">   18155 </span>            : 
<span class="lineNum">   18156 </span>            :   /* Parse tentatively so that we can back up if we don't find a
<span class="lineNum">   18157 </span>            :      enum-specifier.  */
<span class="lineNum">   18158 </span>            :   cp_parser_parse_tentatively (parser);
<span class="lineNum">   18159 </span>            : 
<span class="lineNum">   18160 </span>            :   /* Caller guarantees that the current token is 'enum', an identifier
<span class="lineNum">   18161 </span>            :      possibly follows, and the token after that is an opening brace.
<span class="lineNum">   18162 </span>            :      If we don't have an identifier, fabricate an anonymous name for
<span class="lineNum">   18163 </span>            :      the enumeration being defined.  */
<span class="lineNum">   18164 </span>            :   cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   18165 </span>            : 
<span class="lineNum">   18166 </span>            :   /* Parse the &quot;class&quot; or &quot;struct&quot;, which indicates a scoped
<span class="lineNum">   18167 </span>            :      enumeration type in C++0x.  */
<span class="lineNum">   18168 </span>            :   if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_CLASS)
<span class="lineNum">   18169 </span>            :       || cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_STRUCT))
<span class="lineNum">   18170 </span>            :     {
<span class="lineNum">   18171 </span>            :       if (cxx_dialect &lt; cxx11)
<span class="lineNum">   18172 </span>            :         maybe_warn_cpp0x (CPP0X_SCOPED_ENUMS);
<span class="lineNum">   18173 </span>            : 
<span class="lineNum">   18174 </span>            :       /* Consume the `struct' or `class' token.  */
<span class="lineNum">   18175 </span><span class="lineCov">     184078 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   18176 </span>            : 
<span class="lineNum">   18177 </span><span class="lineCov">     184078 :       scoped_enum_p = true;</span>
<span class="lineNum">   18178 </span><span class="lineCov">     184078 :     }</span>
<span class="lineNum">   18179 </span><span class="lineCov">     184078 : </span>
<span class="lineNum">   18180 </span><span class="lineCov">     184078 :   attributes = cp_parser_attributes_opt (parser);</span>
<span class="lineNum">   18181 </span><span class="lineCov">     184078 : </span>
<span class="lineNum">   18182 </span><span class="lineCov">     184078 :   /* Clear the qualification.  */</span>
<span class="lineNum">   18183 </span><span class="lineCov">     184078 :   parser-&gt;scope = NULL_TREE;</span>
<span class="lineNum">   18184 </span><span class="lineCov">     184078 :   parser-&gt;qualifying_scope = NULL_TREE;</span>
<span class="lineNum">   18185 </span><span class="lineCov">     184078 :   parser-&gt;object_scope = NULL_TREE;</span>
<span class="lineNum">   18186 </span><span class="lineCov">     184078 : </span>
<span class="lineNum">   18187 </span><span class="lineCov">     184078 :   /* Figure out in what scope the declaration is being placed.  */</span>
<span class="lineNum">   18188 </span><span class="lineCov">     184078 :   prev_scope = current_scope ();</span>
<span class="lineNum">   18189 </span><span class="lineCov">     184078 : </span>
<span class="lineNum">   18190 </span><span class="lineCov">     184078 :   type_start_token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   18191 </span>            : 
<span class="lineNum">   18192 </span><span class="lineCov">     184078 :   push_deferring_access_checks (dk_no_check);</span>
<span class="lineNum">   18193 </span>            :   nested_name_specifier
<span class="lineNum">   18194 </span>            :       = cp_parser_nested_name_specifier_opt (parser,
<span class="lineNum">   18195 </span>            :                                              /*typename_keyword_p=*/true,
<span class="lineNum">   18196 </span><span class="lineCov">     184078 :                                              /*check_dependency_p=*/false,</span>
<span class="lineNum">   18197 </span>            :                                              /*type_p=*/false,
<span class="lineNum">   18198 </span>            :                                              /*is_declaration=*/false);
<span class="lineNum">   18199 </span>            : 
<span class="lineNum">   18200 </span>            :   if (nested_name_specifier)
<span class="lineNum">   18201 </span>            :     {
<span class="lineNum">   18202 </span><span class="lineCov">     184078 :       tree name;</span>
<span class="lineNum">   18203 </span>            : 
<span class="lineNum">   18204 </span>            :       identifier = cp_parser_identifier (parser);
<span class="lineNum">   18205 </span>            :       name =  cp_parser_lookup_name (parser, identifier,
<span class="lineNum">   18206 </span><span class="lineCov">     368156 :                                      enum_type,</span>
<span class="lineNum">   18207 </span><span class="lineCov">     184078 :                                      /*is_template=*/false,</span>
<span class="lineNum">   18208 </span>            :                                      /*is_namespace=*/false,
<span class="lineNum">   18209 </span><span class="lineCov">       7336 :                                      /*check_dependency=*/true,</span>
<span class="lineNum">   18210 </span><span class="lineCov">          2 :                                      /*ambiguous_decls=*/NULL,</span>
<span class="lineNum">   18211 </span>            :                                      input_location);
<span class="lineNum">   18212 </span>            :       if (name &amp;&amp; name != error_mark_node)
<span class="lineNum">   18213 </span><span class="lineCov">       7336 :         {</span>
<span class="lineNum">   18214 </span>            :           type = TREE_TYPE (name);
<span class="lineNum">   18215 </span><span class="lineCov">       7336 :           if (TREE_CODE (type) == TYPENAME_TYPE)</span>
<span class="lineNum">   18216 </span>            :             {
<span class="lineNum">   18217 </span>            :               /* Are template enums allowed in ISO? */
<span class="lineNum">   18218 </span><span class="lineCov">     184078 :               if (template_parm_scope_p ())</span>
<span class="lineNum">   18219 </span>            :                 pedwarn (type_start_token-&gt;location, OPT_Wpedantic,
<span class="lineNum">   18220 </span>            :                          &quot;%qD is an enumeration template&quot;, name);
<span class="lineNum">   18221 </span><span class="lineCov">     184078 :               /* ignore a typename reference, for it will be solved by name</span>
<span class="lineNum">   18222 </span><span class="lineCov">     184078 :                  in start_enum.  */</span>
<span class="lineNum">   18223 </span><span class="lineCov">     184078 :               type = NULL_TREE;</span>
<span class="lineNum">   18224 </span>            :             }
<span class="lineNum">   18225 </span>            :         }
<span class="lineNum">   18226 </span><span class="lineCov">     184078 :       else if (nested_name_specifier == error_mark_node)</span>
<span class="lineNum">   18227 </span>            :         /* We already issued an error.  */;
<span class="lineNum">   18228 </span><span class="lineCov">     368156 :       else</span>
<span class="lineNum">   18229 </span>            :         {
<span class="lineNum">   18230 </span><span class="lineCov">     184078 :           error_at (type_start_token-&gt;location,</span>
<span class="lineNum">   18231 </span><span class="lineCov">     184078 :                     &quot;%qD does not name an enumeration in %qT&quot;,</span>
<span class="lineNum">   18232 </span><span class="lineCov">     184078 :                     identifier, nested_name_specifier);</span>
<span class="lineNum">   18233 </span>            :           nested_name_specifier = error_mark_node;
<span class="lineNum">   18234 </span>            :         }
<span class="lineNum">   18235 </span>            :     }
<span class="lineNum">   18236 </span>            :   else
<span class="lineNum">   18237 </span>            :     {
<span class="lineNum">   18238 </span><span class="lineCov">     184078 :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))</span>
<span class="lineNum">   18239 </span>            :         identifier = cp_parser_identifier (parser);
<span class="lineNum">   18240 </span><span class="lineCov">        220 :       else</span>
<span class="lineNum">   18241 </span>            :         {
<span class="lineNum">   18242 </span><span class="lineCov">        220 :           identifier = make_anon_name ();</span>
<span class="lineNum">   18243 </span><span class="lineCov">        440 :           is_unnamed = true;</span>
<span class="lineNum">   18244 </span>            :           if (scoped_enum_p)
<span class="lineNum">   18245 </span>            :             error_at (type_start_token-&gt;location,
<span class="lineNum">   18246 </span>            :                       &quot;unnamed scoped enum is not allowed&quot;);
<span class="lineNum">   18247 </span>            :         }
<span class="lineNum">   18248 </span>            :     }
<span class="lineNum">   18249 </span><span class="lineCov">        220 :   pop_deferring_access_checks ();</span>
<span class="lineNum">   18250 </span><span class="lineCov">        220 : </span>
<span class="lineNum">   18251 </span>            :   /* Check for the `:' that denotes a specified underlying type in C++0x.
<span class="lineNum">   18252 </span><span class="lineCov">        212 :      Note that a ':' could also indicate a bitfield width, however.  */</span>
<span class="lineNum">   18253 </span><span class="lineCov">        212 :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_COLON))</span>
<span class="lineNum">   18254 </span>            :     {
<span class="lineNum">   18255 </span>            :       cp_decl_specifier_seq type_specifiers;
<span class="lineNum">   18256 </span><span class="lineCov">         50 : </span>
<span class="lineNum">   18257 </span><span class="lineCov">         12 :       /* Consume the `:'.  */</span>
<span class="lineNum">   18258 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   18259 </span>            : 
<span class="lineNum">   18260 </span>            :       /* Parse the type-specifier-seq.  */
<span class="lineNum">   18261 </span><span class="lineCov">         50 :       cp_parser_type_specifier_seq (parser, /*is_declaration=*/false,</span>
<span class="lineNum">   18262 </span>            :                                     /*is_trailing_return=*/false,
<span class="lineNum">   18263 </span>            :                                     &amp;type_specifiers);
<span class="lineNum">   18264 </span><span class="lineCov">          8 : </span>
<span class="lineNum">   18265 </span>            :       /* At this point this is surely not elaborated type specifier.  */
<span class="lineNum">   18266 </span>            :       if (!cp_parser_parse_definitely (parser))
<span class="lineNum">   18267 </span>            :         return NULL_TREE;
<span class="lineNum">   18268 </span><span class="lineCov">          6 : </span>
<span class="lineNum">   18269 </span>            :       if (cxx_dialect &lt; cxx11)
<span class="lineNum">   18270 </span>            :         maybe_warn_cpp0x (CPP0X_SCOPED_ENUMS);
<span class="lineNum">   18271 </span><span class="lineCov">          6 : </span>
<span class="lineNum">   18272 </span>            :       has_underlying_type = true;
<span class="lineNum">   18273 </span>            : 
<span class="lineNum">   18274 </span>            :       /* If that didn't work, stop.  */
<span class="lineNum">   18275 </span>            :       if (type_specifiers.type != error_mark_node)
<span class="lineNum">   18276 </span><span class="lineCov">     183858 :         {</span>
<span class="lineNum">   18277 </span><span class="lineCov">      46107 :           underlying_type = grokdeclarator (NULL, &amp;type_specifiers, TYPENAME,</span>
<span class="lineNum">   18278 </span>            :                                             /*initialized=*/0, NULL);
<span class="lineNum">   18279 </span>            :           if (underlying_type == error_mark_node
<span class="lineNum">   18280 </span><span class="lineCov">     137751 :               || check_for_bare_parameter_packs (underlying_type))</span>
<span class="lineNum">   18281 </span><span class="lineCov">     137751 :             underlying_type = NULL_TREE;</span>
<span class="lineNum">   18282 </span><span class="lineCov">     137751 :         }</span>
<span class="lineNum">   18283 </span><span class="lineCov">          4 :     }</span>
<span class="lineNum">   18284 </span>            : 
<span class="lineNum">   18285 </span>            :   /* Look for the `{' but don't consume it yet.  */
<span class="lineNum">   18286 </span>            :   if (!cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_BRACE))
<span class="lineNum">   18287 </span><span class="lineCov">     184078 :     {</span>
<span class="lineNum">   18288 </span>            :       if (cxx_dialect &lt; cxx11 || (!scoped_enum_p &amp;&amp; !underlying_type))
<span class="lineNum">   18289 </span>            :         {
<span class="lineNum">   18290 </span>            :           cp_parser_error (parser, &quot;expected %&lt;{%&gt;&quot;);
<span class="lineNum">   18291 </span><span class="lineCov">     184078 :           if (has_underlying_type)</span>
<span class="lineNum">   18292 </span>            :             {
<span class="lineNum">   18293 </span><span class="lineCov">       4613 :               type = NULL_TREE;</span>
<span class="lineNum">   18294 </span>            :               goto out;
<span class="lineNum">   18295 </span>            :             }
<span class="lineNum">   18296 </span><span class="lineCov">       4613 :         }</span>
<span class="lineNum">   18297 </span>            :       /* An opaque-enum-specifier must have a ';' here.  */
<span class="lineNum">   18298 </span>            :       if ((scoped_enum_p || underlying_type)
<span class="lineNum">   18299 </span><span class="lineCov">       4613 :           &amp;&amp; cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_SEMICOLON))</span>
<span class="lineNum">   18300 </span>            :         {
<span class="lineNum">   18301 </span>            :           cp_parser_error (parser, &quot;expected %&lt;;%&gt; or %&lt;{%&gt;&quot;);
<span class="lineNum">   18302 </span>            :           if (has_underlying_type)
<span class="lineNum">   18303 </span>            :             {
<span class="lineNum">   18304 </span><span class="lineCov">       4613 :               type = NULL_TREE;</span>
<span class="lineNum">   18305 </span><span class="lineCov">          7 :               goto out;</span>
<span class="lineNum">   18306 </span>            :             }
<span class="lineNum">   18307 </span><span class="lineCov">       4606 :         }</span>
<span class="lineNum">   18308 </span><span class="lineCov">          2 :     }</span>
<span class="lineNum">   18309 </span>            : 
<span class="lineNum">   18310 </span><span class="lineCov">       4606 :   if (!has_underlying_type &amp;&amp; !cp_parser_parse_definitely (parser))</span>
<span class="lineNum">   18311 </span>            :     return NULL_TREE;
<span class="lineNum">   18312 </span>            : 
<span class="lineNum">   18313 </span><span class="lineCov">       4606 :   if (nested_name_specifier)</span>
<span class="lineNum">   18314 </span>            :     {
<span class="lineNum">   18315 </span><span class="lineCov">       4606 :       if (CLASS_TYPE_P (nested_name_specifier))</span>
<span class="lineNum">   18316 </span>            :         {
<span class="lineNum">   18317 </span><span class="lineCov">       4606 :           nested_being_defined = TYPE_BEING_DEFINED (nested_name_specifier);</span>
<span class="lineNum">   18318 </span><span class="lineCov">       4606 :           TYPE_BEING_DEFINED (nested_name_specifier) = 1;</span>
<span class="lineNum">   18319 </span>            :           push_scope (nested_name_specifier);
<span class="lineNum">   18320 </span>            :         }
<span class="lineNum">   18321 </span>            :       else if (TREE_CODE (nested_name_specifier) == NAMESPACE_DECL)
<span class="lineNum">   18322 </span>            :         {
<span class="lineNum">   18323 </span>            :           push_nested_namespace (nested_name_specifier);
<span class="lineNum">   18324 </span><span class="lineCov">     184071 :         }</span>
<span class="lineNum">   18325 </span>            :     }
<span class="lineNum">   18326 </span><span class="lineCov">      16252 : </span>
<span class="lineNum">   18327 </span>            :   /* Issue an error message if type-definitions are forbidden here.  */
<span class="lineNum">   18328 </span><span class="lineCov">      14092 :   if (!cp_parser_check_type_definition (parser))</span>
<span class="lineNum">   18329 </span><span class="lineCov">      14092 :     type = error_mark_node;</span>
<span class="lineNum">   18330 </span>            :   else
<span class="lineNum">   18331 </span><span class="lineNoCov">          0 :     /* Create the new type.  We do this before consuming the opening</span>
<span class="lineNum">   18332 </span><span class="lineNoCov">          0 :        brace so the enum will be recorded as being on the line of its</span>
<span class="lineNum">   18333 </span>            :        tag (or the 'enum' keyword, if there is no tag).  */
<span class="lineNum">   18334 </span>            :     type = start_enum (identifier, type, underlying_type,
<span class="lineNum">   18335 </span>            :                        attributes, scoped_enum_p, &amp;is_new_type);
<span class="lineNum">   18336 </span><span class="lineCov">      16252 : </span>
<span class="lineNum">   18337 </span><span class="lineCov">      16252 :   /* If the next token is not '{' it is an opaque-enum-specifier or an</span>
<span class="lineNum">   18338 </span>            :      elaborated-type-specifier.  */
<span class="lineNum">   18339 </span><span class="lineCov">         10 :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_BRACE))</span>
<span class="lineNum">   18340 </span><span class="lineCov">         10 :     {</span>
<span class="lineNum">   18341 </span>            :       timevar_push (TV_PARSE_ENUM);
<span class="lineNum">   18342 </span><span class="lineCov">          4 :       if (nested_name_specifier</span>
<span class="lineNum">   18343 </span><span class="lineCov">          4 :           &amp;&amp; nested_name_specifier != error_mark_node)</span>
<span class="lineNum">   18344 </span>            :         {
<span class="lineNum">   18345 </span>            :           /* The following catches invalid code such as:
<span class="lineNum">   18346 </span>            :              enum class S&lt;int&gt;::E { A, B, C }; */
<span class="lineNum">   18347 </span>            :           if (!processing_specialization
<span class="lineNum">   18348 </span><span class="lineCov">     184067 :               &amp;&amp; CLASS_TYPE_P (nested_name_specifier)</span>
<span class="lineNum">   18349 </span>            :               &amp;&amp; CLASSTYPE_USE_TEMPLATE (nested_name_specifier))
<span class="lineNum">   18350 </span>            :             error_at (type_start_token-&gt;location, &quot;cannot add an enumerator &quot;
<span class="lineNum">   18351 </span><span class="lineCov">     169969 :                       &quot;list to a template instantiation&quot;);</span>
<span class="lineNum">   18352 </span>            : 
<span class="lineNum">   18353 </span><span class="lineCov">        150 :           if (TREE_CODE (nested_name_specifier) == TYPENAME_TYPE)</span>
<span class="lineNum">   18354 </span>            :             {
<span class="lineNum">   18355 </span><span class="lineCov">        109 :               error_at (type_start_token-&gt;location,</span>
<span class="lineNum">   18356 </span><span class="lineCov">        109 :                         &quot;%&lt;%T::%E%&gt; has not been declared&quot;,</span>
<span class="lineNum">   18357 </span><span class="lineCov">        109 :                         TYPE_CONTEXT (nested_name_specifier),</span>
<span class="lineNum">   18358 </span>            :                         nested_name_specifier);
<span class="lineNum">   18359 </span><span class="lineCov">         41 :               type = error_mark_node;</span>
<span class="lineNum">   18360 </span>            :             }
<span class="lineNum">   18361 </span><span class="lineCov">         27 :           else if (TREE_CODE (nested_name_specifier) != NAMESPACE_DECL</span>
<span class="lineNum">   18362 </span>            :                    &amp;&amp; !CLASS_TYPE_P (nested_name_specifier))
<span class="lineNum">   18363 </span>            :             {
<span class="lineNum">   18364 </span>            :               error_at (type_start_token-&gt;location, &quot;nested name specifier &quot;
<span class="lineNum">   18365 </span>            :                         &quot;%qT for enum declaration does not name a class &quot;
<span class="lineNum">   18366 </span><span class="lineCov">     169969 :                         &quot;or namespace&quot;, nested_name_specifier);</span>
<span class="lineNum">   18367 </span><span class="lineCov">         11 :               type = error_mark_node;</span>
<span class="lineNum">   18368 </span>            :             }
<span class="lineNum">   18369 </span>            :           /* If that scope does not contain the scope in which the
<span class="lineNum">   18370 </span>            :              class was originally declared, the program is invalid.  */
<span class="lineNum">   18371 </span>            :           else if (prev_scope &amp;&amp; !is_ancestor (prev_scope,
<span class="lineNum">   18372 </span><span class="lineCov">     169958 :                                                nested_name_specifier))</span>
<span class="lineNum">   18373 </span>            :             {
<span class="lineNum">   18374 </span>            :               if (at_namespace_scope_p ())
<span class="lineNum">   18375 </span>            :                 error_at (type_start_token-&gt;location,
<span class="lineNum">   18376 </span>            :                           &quot;declaration of %qD in namespace %qD which does not &quot;
<span class="lineNum">   18377 </span><span class="lineCov">     169969 :                           &quot;enclose %qD&quot;,</span>
<span class="lineNum">   18378 </span>            :                           type, prev_scope, nested_name_specifier);
<span class="lineNum">   18379 </span><span class="lineCov">     167819 :               else</span>
<span class="lineNum">   18380 </span><span class="lineCov">     167819 :                 error_at (type_start_token-&gt;location,</span>
<span class="lineNum">   18381 </span><span class="lineCov">        146 :                           &quot;declaration of %qD in %qD which does not &quot;</span>
<span class="lineNum">   18382 </span>            :                           &quot;enclose %qD&quot;,
<span class="lineNum">   18383 </span>            :                           type, prev_scope, nested_name_specifier);
<span class="lineNum">   18384 </span>            :               type = error_mark_node;
<span class="lineNum">   18385 </span><span class="lineCov">        138 :             }</span>
<span class="lineNum">   18386 </span><span class="lineCov">        132 :           /* If that scope is the scope where the declaration is being placed</span>
<span class="lineNum">   18387 </span><span class="lineCov">        340 :              the program is invalid.  */</span>
<span class="lineNum">   18388 </span><span class="lineNoCov">          0 :           else if (CLASS_TYPE_P (nested_name_specifier)</span>
<span class="lineNum">   18389 </span>            :                    &amp;&amp; CLASS_TYPE_P (prev_scope)
<span class="lineNum">   18390 </span>            :                    &amp;&amp; same_type_p (nested_name_specifier, prev_scope))
<span class="lineNum">   18391 </span><span class="lineCov">        138 :             {</span>
<span class="lineNum">   18392 </span>            :               permerror (type_start_token-&gt;location,
<span class="lineNum">   18393 </span><span class="lineCov">          6 :                          &quot;extra qualification not allowed&quot;);</span>
<span class="lineNum">   18394 </span>            :               nested_name_specifier = NULL_TREE;
<span class="lineNum">   18395 </span><span class="lineCov">          3 :             }</span>
<span class="lineNum">   18396 </span>            :         }
<span class="lineNum">   18397 </span><span class="lineCov">          3 : </span>
<span class="lineNum">   18398 </span>            :       if (scoped_enum_p)
<span class="lineNum">   18399 </span><span class="lineCov">        135 :         begin_scope (sk_scoped_enum, type);</span>
<span class="lineNum">   18400 </span><span class="lineCov">        135 : </span>
<span class="lineNum">   18401 </span>            :       /* Consume the opening brace.  */
<span class="lineNum">   18402 </span><span class="lineCov">          3 :       matching_braces braces;</span>
<span class="lineNum">   18403 </span>            :       braces.consume_open (parser);
<span class="lineNum">   18404 </span>            : 
<span class="lineNum">   18405 </span><span class="lineCov">          3 :       if (type == error_mark_node)</span>
<span class="lineNum">   18406 </span>            :         ; /* Nothing to add */
<span class="lineNum">   18407 </span>            :       else if (OPAQUE_ENUM_P (type)
<span class="lineNum">   18408 </span>            :                || (cxx_dialect &gt; cxx98 &amp;&amp; processing_specialization))
<span class="lineNum">   18409 </span><span class="lineCov">        132 :         {</span>
<span class="lineNum">   18410 </span>            :           new_value_list = true;
<span class="lineNum">   18411 </span>            :           SET_OPAQUE_ENUM_P (type, false);
<span class="lineNum">   18412 </span><span class="lineCov">          8 :           DECL_SOURCE_LOCATION (TYPE_NAME (type)) = type_start_token-&gt;location;</span>
<span class="lineNum">   18413 </span><span class="lineCov">          4 :         }</span>
<span class="lineNum">   18414 </span>            :       else
<span class="lineNum">   18415 </span>            :         {
<span class="lineNum">   18416 </span>            :           error_at (type_start_token-&gt;location,
<span class="lineNum">   18417 </span>            :                     &quot;multiple definition of %q#T&quot;, type);
<span class="lineNum">   18418 </span><span class="lineCov">          4 :           inform (DECL_SOURCE_LOCATION (TYPE_MAIN_DECL (type)),</span>
<span class="lineNum">   18419 </span>            :                   &quot;previous definition here&quot;);
<span class="lineNum">   18420 </span>            :           type = error_mark_node;
<span class="lineNum">   18421 </span>            :         }
<span class="lineNum">   18422 </span><span class="lineCov">          8 : </span>
<span class="lineNum">   18423 </span>            :       if (type == error_mark_node)
<span class="lineNum">   18424 </span>            :         cp_parser_skip_to_end_of_block_or_statement (parser);
<span class="lineNum">   18425 </span>            :       /* If the next token is not '}', then there are some enumerators.  */
<span class="lineNum">   18426 </span><span class="lineCov">        103 :       else if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_CLOSE_BRACE))</span>
<span class="lineNum">   18427 </span><span class="lineCov">        103 :         {</span>
<span class="lineNum">   18428 </span><span class="lineCov">        154 :           if (is_unnamed &amp;&amp; !scoped_enum_p)</span>
<span class="lineNum">   18429 </span>            :             pedwarn (type_start_token-&gt;location, OPT_Wpedantic,
<span class="lineNum">   18430 </span><span class="lineCov">         20 :                      &quot;ISO C++ forbids empty unnamed enum&quot;);</span>
<span class="lineNum">   18431 </span>            :         }
<span class="lineNum">   18432 </span><span class="lineCov">         20 :       else</span>
<span class="lineNum">   18433 </span>            :         cp_parser_enumerator_list (parser, type);
<span class="lineNum">   18434 </span>            : 
<span class="lineNum">   18435 </span>            :       /* Consume the final '}'.  */
<span class="lineNum">   18436 </span><span class="lineCov">     167819 :       braces.require_close (parser);</span>
<span class="lineNum">   18437 </span><span class="lineCov">       5986 : </span>
<span class="lineNum">   18438 </span>            :       if (scoped_enum_p)
<span class="lineNum">   18439 </span>            :         finish_scope ();
<span class="lineNum">   18440 </span><span class="lineCov">     335638 :       timevar_pop (TV_PARSE_ENUM);</span>
<span class="lineNum">   18441 </span><span class="lineCov">     167819 :     }</span>
<span class="lineNum">   18442 </span>            :   else
<span class="lineNum">   18443 </span><span class="lineCov">     167819 :     {</span>
<span class="lineNum">   18444 </span>            :       /* If a ';' follows, then it is an opaque-enum-specifier
<span class="lineNum">   18445 </span><span class="lineCov">     335566 :         and additional restrictions apply.  */</span>
<span class="lineNum">   18446 </span><span class="lineCov">     167796 :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_SEMICOLON))</span>
<span class="lineNum">   18447 </span>            :         {
<span class="lineNum">   18448 </span><span class="lineCov">     167776 :           if (is_unnamed)</span>
<span class="lineNum">   18449 </span><span class="lineCov">     167776 :             error_at (type_start_token-&gt;location,</span>
<span class="lineNum">   18450 </span><span class="lineCov">     167776 :                       &quot;opaque-enum-specifier without name&quot;);</span>
<span class="lineNum">   18451 </span>            :           else if (nested_name_specifier)
<span class="lineNum">   18452 </span>            :             error_at (type_start_token-&gt;location,
<span class="lineNum">   18453 </span>            :                       &quot;opaque-enum-specifier must use a simple identifier&quot;);
<span class="lineNum">   18454 </span><span class="lineCov">          7 :         }</span>
<span class="lineNum">   18455 </span>            :     }
<span class="lineNum">   18456 </span><span class="lineCov">          7 : </span>
<span class="lineNum">   18457 </span>            :   /* Look for trailing attributes to apply to this enumeration, and
<span class="lineNum">   18458 </span><span class="lineCov">          7 :      apply them if appropriate.  */</span>
<span class="lineNum">   18459 </span>            :   if (cp_parser_allow_gnu_extensions_p (parser))
<span class="lineNum">   18460 </span>            :     {
<span class="lineNum">   18461 </span><span class="lineCov">     167819 :       tree trailing_attr = cp_parser_gnu_attributes_opt (parser);</span>
<span class="lineNum">   18462 </span><span class="lineCov">         43 :       cplus_decl_attributes (&amp;type,</span>
<span class="lineNum">   18463 </span>            :                              trailing_attr,
<span class="lineNum">   18464 </span><span class="lineCov">     167776 :                              (int) ATTR_FLAG_TYPE_IN_PLACE);</span>
<span class="lineNum">   18465 </span>            :     }
<span class="lineNum">   18466 </span><span class="lineCov">       1043 : </span>
<span class="lineNum">   18467 </span><span class="lineCov">         42 :   /* Finish up the enumeration.  */</span>
<span class="lineNum">   18468 </span>            :   if (type != error_mark_node)
<span class="lineNum">   18469 </span>            :     {
<span class="lineNum">   18470 </span>            :       if (new_value_list)
<span class="lineNum">   18471 </span><span class="lineCov">     166733 :         finish_enum_value_list (type);</span>
<span class="lineNum">   18472 </span>            :       if (is_new_type)
<span class="lineNum">   18473 </span>            :         finish_enum (type);
<span class="lineNum">   18474 </span><span class="lineCov">     167819 :     }</span>
<span class="lineNum">   18475 </span>            : 
<span class="lineNum">   18476 </span><span class="lineCov">     167819 :   if (nested_name_specifier)</span>
<span class="lineNum">   18477 </span><span class="lineCov">       5986 :     {</span>
<span class="lineNum">   18478 </span><span class="lineCov">     167819 :       if (CLASS_TYPE_P (nested_name_specifier))</span>
<span class="lineNum">   18479 </span>            :         {
<span class="lineNum">   18480 </span>            :           TYPE_BEING_DEFINED (nested_name_specifier) = nested_being_defined;
<span class="lineNum">   18481 </span>            :           pop_scope (nested_name_specifier);
<span class="lineNum">   18482 </span>            :         }
<span class="lineNum">   18483 </span>            :       else if (TREE_CODE (nested_name_specifier) == NAMESPACE_DECL)
<span class="lineNum">   18484 </span><span class="lineCov">       2150 :         {</span>
<span class="lineNum">   18485 </span>            :           pop_nested_namespace (nested_name_specifier);
<span class="lineNum">   18486 </span><span class="lineCov">       2150 :         }</span>
<span class="lineNum">   18487 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   18488 </span>            :  out:
<span class="lineNum">   18489 </span><span class="lineCov">       2150 :   parser-&gt;colon_corrects_to_scope_p = saved_colon_corrects_to_scope_p;</span>
<span class="lineNum">   18490 </span><span class="lineCov">          4 :   return type;</span>
<span class="lineNum">   18491 </span>            : }
<span class="lineNum">   18492 </span>            : 
<span class="lineNum">   18493 </span>            : /* Parse an enumerator-list.  The enumerators all have the indicated
<span class="lineNum">   18494 </span>            :    TYPE.
<span class="lineNum">   18495 </span>            : 
<span class="lineNum">   18496 </span>            :    enumerator-list:
<span class="lineNum">   18497 </span><span class="lineCov">     339938 :      enumerator-definition</span>
<span class="lineNum">   18498 </span>            :      enumerator-list , enumerator-definition  */
<a name="18499"><span class="lineNum">   18499 </span><span class="lineCov">     169969 : </span></a>
<span class="lineNum">   18500 </span><span class="lineCov">     169969 : static void</span>
<span class="lineNum">   18501 </span>            : cp_parser_enumerator_list (cp_parser* parser, tree type)
<span class="lineNum">   18502 </span>            : {
<span class="lineNum">   18503 </span>            :   while (true)
<span class="lineNum">   18504 </span>            :     {
<span class="lineNum">   18505 </span>            :       /* Parse an enumerator-definition.  */
<span class="lineNum">   18506 </span><span class="lineCov">     169969 :       cp_parser_enumerator_definition (parser, type);</span>
<span class="lineNum">   18507 </span>            : 
<span class="lineNum">   18508 </span><span class="lineCov">     169926 :       /* If the next token is not a ',', we've reached the end of</span>
<span class="lineNum">   18509 </span><span class="lineCov">     167776 :          the list.  */</span>
<span class="lineNum">   18510 </span><span class="lineCov">     169926 :       if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_COMMA))</span>
<span class="lineNum">   18511 </span><span class="lineCov">     169112 :         break;</span>
<span class="lineNum">   18512 </span>            :       /* Otherwise, consume the `,' and keep going.  */
<span class="lineNum">   18513 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   18514 </span><span class="lineCov">     169969 :       /* If the next token is a `}', there is a trailing comma.  */</span>
<span class="lineNum">   18515 </span>            :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_CLOSE_BRACE))
<span class="lineNum">   18516 </span><span class="lineCov">        130 :         {</span>
<span class="lineNum">   18517 </span>            :           if (cxx_dialect &lt; cxx11 &amp;&amp; !in_system_header_at (input_location))
<span class="lineNum">   18518 </span><span class="lineCov">         89 :             pedwarn (input_location, OPT_Wpedantic,</span>
<span class="lineNum">   18519 </span><span class="lineCov">         89 :                      &quot;comma at end of enumerator list&quot;);</span>
<span class="lineNum">   18520 </span>            :           break;
<span class="lineNum">   18521 </span><span class="lineCov">         41 :         }</span>
<span class="lineNum">   18522 </span>            :     }
<span class="lineNum">   18523 </span><span class="lineCov">         27 : }</span>
<span class="lineNum">   18524 </span>            : 
<span class="lineNum">   18525 </span>            : /* Parse an enumerator-definition.  The enumerator has the indicated
<span class="lineNum">   18526 </span><span class="lineCov">     169839 :    TYPE.</span>
<span class="lineNum">   18527 </span><span class="lineCov">     169973 : </span>
<span class="lineNum">   18528 </span><span class="lineCov">     169973 :    enumerator-definition:</span>
<span class="lineNum">   18529 </span>            :      enumerator
<span class="lineNum">   18530 </span>            :      enumerator = constant-expression
<span class="lineNum">   18531 </span>            : 
<span class="lineNum">   18532 </span>            :    enumerator:
<span class="lineNum">   18533 </span>            :      identifier
<span class="lineNum">   18534 </span>            : 
<span class="lineNum">   18535 </span>            :    GNU Extensions:
<span class="lineNum">   18536 </span>            : 
<span class="lineNum">   18537 </span>            :    enumerator-definition:
<span class="lineNum">   18538 </span>            :      enumerator attributes [opt]
<span class="lineNum">   18539 </span><span class="lineCov">     166733 :      enumerator attributes [opt] = constant-expression  */</span>
<a name="18540"><span class="lineNum">   18540 </span>            : </a>
<span class="lineNum">   18541 </span><span class="lineCov">    1968277 : static void</span>
<span class="lineNum">   18542 </span>            : cp_parser_enumerator_definition (cp_parser* parser, tree type)
<span class="lineNum">   18543 </span>            : {
<span class="lineNum">   18544 </span><span class="lineCov">    1968277 :   tree identifier;</span>
<span class="lineNum">   18545 </span>            :   tree value;
<span class="lineNum">   18546 </span>            :   location_t loc;
<span class="lineNum">   18547 </span>            : 
<span class="lineNum">   18548 </span><span class="lineCov">    1968277 :   /* Save the input location because we are interested in the location</span>
<span class="lineNum">   18549 </span>            :      of the identifier and not the location of the explicit value.  */
<span class="lineNum">   18550 </span>            :   loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">   18551 </span><span class="lineCov">    1803923 : </span>
<span class="lineNum">   18552 </span>            :   /* Look for the identifier.  */
<span class="lineNum">   18553 </span><span class="lineCov">    1803923 :   identifier = cp_parser_identifier (parser);</span>
<span class="lineNum">   18554 </span>            :   if (identifier == error_mark_node)
<span class="lineNum">   18555 </span><span class="lineCov">       2379 :     return;</span>
<span class="lineNum">   18556 </span><span class="lineCov">         17 : </span>
<span class="lineNum">   18557 </span>            :   /* Parse any specified attributes.  */
<span class="lineNum">   18558 </span>            :   tree attrs = cp_parser_attributes_opt (parser);
<span class="lineNum">   18559 </span>            : 
<span class="lineNum">   18560 </span>            :   /* If the next token is an '=', then there is an explicit value.  */
<span class="lineNum">   18561 </span><span class="lineCov">     166733 :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_EQ))</span>
<span class="lineNum">   18562 </span>            :     {
<span class="lineNum">   18563 </span>            :       /* Consume the `=' token.  */
<span class="lineNum">   18564 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   18565 </span>            :       /* Parse the value.  */
<span class="lineNum">   18566 </span>            :       value = cp_parser_constant_expression (parser);
<span class="lineNum">   18567 </span>            :     }
<span class="lineNum">   18568 </span>            :   else
<span class="lineNum">   18569 </span>            :     value = NULL_TREE;
<span class="lineNum">   18570 </span>            : 
<span class="lineNum">   18571 </span>            :   /* If we are processing a template, make sure the initializer of the
<span class="lineNum">   18572 </span>            :      enumerator doesn't contain any bare template parameter pack.  */
<span class="lineNum">   18573 </span>            :   if (check_for_bare_parameter_packs (value))
<span class="lineNum">   18574 </span>            :     value = error_mark_node;
<span class="lineNum">   18575 </span>            : 
<span class="lineNum">   18576 </span>            :   /* Create the enumerator.  */
<span class="lineNum">   18577 </span>            :   build_enumerator (identifier, value, type, attrs, loc);
<span class="lineNum">   18578 </span>            : }
<span class="lineNum">   18579 </span>            : 
<span class="lineNum">   18580 </span><span class="lineCov">    1968277 : /* Parse a namespace-name.</span>
<span class="lineNum">   18581 </span>            : 
<span class="lineNum">   18582 </span><span class="lineCov">    1968277 :    namespace-name:</span>
<span class="lineNum">   18583 </span><span class="lineCov">    1968277 :      original-namespace-name</span>
<span class="lineNum">   18584 </span><span class="lineCov">    1968277 :      namespace-alias</span>
<span class="lineNum">   18585 </span>            : 
<span class="lineNum">   18586 </span>            :    Returns the NAMESPACE_DECL for the namespace.  */
<a name="18587"><span class="lineNum">   18587 </span>            : </a>
<span class="lineNum">   18588 </span><span class="lineCov">    3936554 : static tree</span>
<span class="lineNum">   18589 </span>            : cp_parser_namespace_name (cp_parser* parser)
<span class="lineNum">   18590 </span>            : {
<span class="lineNum">   18591 </span><span class="lineCov">    1968277 :   tree identifier;</span>
<span class="lineNum">   18592 </span><span class="lineCov">    1968277 :   tree namespace_decl;</span>
<span class="lineNum">   18593 </span>            : 
<span class="lineNum">   18594 </span>            :   cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   18595 </span>            : 
<span class="lineNum">   18596 </span><span class="lineCov">    1968274 :   /* Get the name of the namespace.  */</span>
<span class="lineNum">   18597 </span>            :   identifier = cp_parser_identifier (parser);
<span class="lineNum">   18598 </span>            :   if (identifier == error_mark_node)
<span class="lineNum">   18599 </span><span class="lineCov">    1968274 :     return error_mark_node;</span>
<span class="lineNum">   18600 </span>            : 
<span class="lineNum">   18601 </span>            :   /* Look up the identifier in the currently active scope.  Look only
<span class="lineNum">   18602 </span><span class="lineCov">     380980 :      for namespaces, due to:</span>
<span class="lineNum">   18603 </span>            : 
<span class="lineNum">   18604 </span><span class="lineCov">     380980 :        [basic.lookup.udir]</span>
<span class="lineNum">   18605 </span>            : 
<span class="lineNum">   18606 </span>            :        When looking up a namespace-name in a using-directive or alias
<span class="lineNum">   18607 </span>            :        definition, only namespace names are considered.
<span class="lineNum">   18608 </span>            : 
<span class="lineNum">   18609 </span>            :      And:
<span class="lineNum">   18610 </span>            : 
<span class="lineNum">   18611 </span><span class="lineCov">    1968274 :        [basic.lookup.qual]</span>
<span class="lineNum">   18612 </span><span class="lineCov">          2 : </span>
<span class="lineNum">   18613 </span>            :        During the lookup of a name preceding the :: scope resolution
<span class="lineNum">   18614 </span>            :        operator, object, function, and enumerator names are ignored.
<span class="lineNum">   18615 </span><span class="lineCov">    1968274 : </span>
<span class="lineNum">   18616 </span>            :      (Note that cp_parser_qualifying_entity only calls this
<span class="lineNum">   18617 </span>            :      function if the token after the name is the scope resolution
<span class="lineNum">   18618 </span>            :      operator.)  */
<span class="lineNum">   18619 </span>            :   namespace_decl = cp_parser_lookup_name (parser, identifier,
<span class="lineNum">   18620 </span>            :                                           none_type,
<span class="lineNum">   18621 </span>            :                                           /*is_template=*/false,
<span class="lineNum">   18622 </span>            :                                           /*is_namespace=*/true,
<span class="lineNum">   18623 </span>            :                                           /*check_dependency=*/true,
<span class="lineNum">   18624 </span>            :                                           /*ambiguous_decls=*/NULL,
<span class="lineNum">   18625 </span>            :                                           token-&gt;location);
<span class="lineNum">   18626 </span>            :   /* If it's not a namespace, issue an error.  */
<span class="lineNum">   18627 </span><span class="lineCov">    3306257 :   if (namespace_decl == error_mark_node</span>
<span class="lineNum">   18628 </span>            :       || TREE_CODE (namespace_decl) != NAMESPACE_DECL)
<span class="lineNum">   18629 </span><span class="lineCov">    3306257 :     {</span>
<span class="lineNum">   18630 </span><span class="lineCov">    3306257 :       if (!cp_parser_uncommitted_to_tentative_parse_p (parser))</span>
<span class="lineNum">   18631 </span>            :         {
<span class="lineNum">   18632 </span><span class="lineCov">    6612514 :           auto_diagnostic_group d;</span>
<span class="lineNum">   18633 </span>            :           error_at (token-&gt;location, &quot;%qD is not a namespace-name&quot;, identifier);
<span class="lineNum">   18634 </span>            :           if (namespace_decl == error_mark_node
<span class="lineNum">   18635 </span><span class="lineCov">    3306257 :               &amp;&amp; parser-&gt;scope &amp;&amp; TREE_CODE (parser-&gt;scope) == NAMESPACE_DECL)</span>
<span class="lineNum">   18636 </span><span class="lineCov">    3306257 :             suggest_alternative_in_explicit_scope (token-&gt;location, identifier,</span>
<span class="lineNum">   18637 </span>            :                                                    parser-&gt;scope);
<span class="lineNum">   18638 </span>            :         }
<span class="lineNum">   18639 </span>            :       cp_parser_error (parser, &quot;expected namespace-name&quot;);
<span class="lineNum">   18640 </span>            :       namespace_decl = error_mark_node;
<span class="lineNum">   18641 </span>            :     }
<span class="lineNum">   18642 </span>            : 
<span class="lineNum">   18643 </span>            :   return namespace_decl;
<span class="lineNum">   18644 </span>            : }
<span class="lineNum">   18645 </span>            : 
<span class="lineNum">   18646 </span>            : /* Parse a namespace-definition.
<span class="lineNum">   18647 </span>            : 
<span class="lineNum">   18648 </span>            :    namespace-definition:
<span class="lineNum">   18649 </span>            :      named-namespace-definition
<span class="lineNum">   18650 </span>            :      unnamed-namespace-definition
<span class="lineNum">   18651 </span>            : 
<span class="lineNum">   18652 </span>            :    named-namespace-definition:
<span class="lineNum">   18653 </span>            :      original-namespace-definition
<span class="lineNum">   18654 </span>            :      extension-namespace-definition
<span class="lineNum">   18655 </span>            : 
<span class="lineNum">   18656 </span>            :    original-namespace-definition:
<span class="lineNum">   18657 </span><span class="lineCov">    6612514 :      namespace identifier { namespace-body }</span>
<span class="lineNum">   18658 </span>            : 
<span class="lineNum">   18659 </span>            :    extension-namespace-definition:
<span class="lineNum">   18660 </span>            :      namespace original-namespace-name { namespace-body }
<span class="lineNum">   18661 </span>            : 
<span class="lineNum">   18662 </span>            :    unnamed-namespace-definition:
<span class="lineNum">   18663 </span><span class="lineCov">    3306257 :      namespace { namespace-body } */</span>
<a name="18664"><span class="lineNum">   18664 </span>            : </a>
<span class="lineNum">   18665 </span><span class="lineCov">    3306257 : static void</span>
<span class="lineNum">   18666 </span><span class="lineCov">    3306043 : cp_parser_namespace_definition (cp_parser* parser)</span>
<span class="lineNum">   18667 </span>            : {
<span class="lineNum">   18668 </span><span class="lineCov">        264 :   tree identifier;</span>
<span class="lineNum">   18669 </span>            :   int nested_definition_count = 0;
<span class="lineNum">   18670 </span><span class="lineCov">         46 : </span>
<span class="lineNum">   18671 </span><span class="lineCov">         23 :   cp_ensure_no_omp_declare_simd (parser);</span>
<span class="lineNum">   18672 </span><span class="lineCov">         23 :   cp_ensure_no_oacc_routine (parser);</span>
<span class="lineNum">   18673 </span><span class="lineCov">         20 : </span>
<span class="lineNum">   18674 </span><span class="lineCov">          8 :   bool is_inline = cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_INLINE);</span>
<span class="lineNum">   18675 </span>            : 
<span class="lineNum">   18676 </span>            :   if (is_inline)
<span class="lineNum">   18677 </span><span class="lineCov">        241 :     {</span>
<span class="lineNum">   18678 </span><span class="lineCov">        241 :       maybe_warn_cpp0x (CPP0X_INLINE_NAMESPACES);</span>
<span class="lineNum">   18679 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   18680 </span>            :     }
<span class="lineNum">   18681 </span>            : 
<span class="lineNum">   18682 </span>            :   /* Look for the `namespace' keyword.  */
<span class="lineNum">   18683 </span>            :   cp_token* token
<span class="lineNum">   18684 </span>            :     = cp_parser_require_keyword (parser, RID_NAMESPACE, RT_NAMESPACE);
<span class="lineNum">   18685 </span>            : 
<span class="lineNum">   18686 </span>            :   /* Parse any specified attributes before the identifier.  */
<span class="lineNum">   18687 </span>            :   tree attribs = cp_parser_attributes_opt (parser);
<span class="lineNum">   18688 </span>            : 
<span class="lineNum">   18689 </span>            :   for (;;)
<span class="lineNum">   18690 </span>            :     {
<span class="lineNum">   18691 </span>            :       identifier = NULL_TREE;
<span class="lineNum">   18692 </span>            :       
<span class="lineNum">   18693 </span>            :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))
<span class="lineNum">   18694 </span>            :         {
<span class="lineNum">   18695 </span>            :           identifier = cp_parser_identifier (parser);
<span class="lineNum">   18696 </span>            : 
<span class="lineNum">   18697 </span>            :           if (cp_next_tokens_can_be_std_attribute_p (parser))
<span class="lineNum">   18698 </span>            :             pedwarn (input_location, OPT_Wpedantic,
<span class="lineNum">   18699 </span>            :                      &quot;standard attributes on namespaces must precede &quot;
<span class="lineNum">   18700 </span>            :                      &quot;the namespace name&quot;);
<span class="lineNum">   18701 </span>            : 
<span class="lineNum">   18702 </span>            :           /* Parse any attributes specified after the identifier.  */
<span class="lineNum">   18703 </span>            :           attribs = attr_chainon (attribs, cp_parser_attributes_opt (parser));
<span class="lineNum">   18704 </span><span class="lineCov">     340702 :         }</span>
<span class="lineNum">   18705 </span>            : 
<span class="lineNum">   18706 </span><span class="lineCov">     340702 :       if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_SCOPE))</span>
<span class="lineNum">   18707 </span><span class="lineCov">     340702 :         break;</span>
<span class="lineNum">   18708 </span>            :   
<span class="lineNum">   18709 </span><span class="lineCov">     340702 :       if (!nested_definition_count &amp;&amp; cxx_dialect &lt; cxx17)</span>
<span class="lineNum">   18710 </span><span class="lineCov">     340702 :         pedwarn (input_location, OPT_Wpedantic,</span>
<span class="lineNum">   18711 </span>            :                  &quot;nested namespace definitions only available with &quot;
<span class="lineNum">   18712 </span><span class="lineCov">     681404 :                  &quot;-std=c++17 or -std=gnu++17&quot;);</span>
<span class="lineNum">   18713 </span>            : 
<span class="lineNum">   18714 </span><span class="lineCov">     340702 :       /* Nested namespace names can create new namespaces (unlike</span>
<span class="lineNum">   18715 </span>            :          other qualified-ids).  */
<span class="lineNum">   18716 </span><span class="lineCov">      16157 :       if (int count = identifier ? push_namespace (identifier) : 0)</span>
<span class="lineNum">   18717 </span><span class="lineCov">      16157 :         nested_definition_count += count;</span>
<span class="lineNum">   18718 </span>            :       else
<span class="lineNum">   18719 </span>            :         cp_parser_error (parser, &quot;nested namespace name required&quot;);
<span class="lineNum">   18720 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   18721 </span><span class="lineCov">     340702 :     }</span>
<span class="lineNum">   18722 </span><span class="lineCov">     340702 : </span>
<span class="lineNum">   18723 </span>            :   if (nested_definition_count &amp;&amp; !identifier)
<span class="lineNum">   18724 </span>            :     cp_parser_error (parser, &quot;namespace name required&quot;);
<span class="lineNum">   18725 </span><span class="lineCov">     340702 :   </span>
<span class="lineNum">   18726 </span>            :   if (nested_definition_count &amp;&amp; attribs)
<span class="lineNum">   18727 </span><span class="lineCov">     340732 :     error_at (token-&gt;location,</span>
<span class="lineNum">   18728 </span>            :               &quot;a nested namespace definition cannot have attributes&quot;);
<span class="lineNum">   18729 </span><span class="lineCov">     340732 :   if (nested_definition_count &amp;&amp; is_inline)</span>
<span class="lineNum">   18730 </span>            :     error_at (token-&gt;location,
<span class="lineNum">   18731 </span><span class="lineCov">     340732 :               &quot;a nested namespace definition cannot be inline&quot;);</span>
<span class="lineNum">   18732 </span>            : 
<span class="lineNum">   18733 </span><span class="lineCov">     338910 :   /* Start the namespace.  */</span>
<span class="lineNum">   18734 </span>            :   nested_definition_count += push_namespace (identifier, is_inline);
<span class="lineNum">   18735 </span><span class="lineCov">     338910 : </span>
<span class="lineNum">   18736 </span><span class="lineCov">          3 :   bool has_visibility = handle_namespace_attrs (current_namespace, attribs);</span>
<span class="lineNum">   18737 </span>            : 
<span class="lineNum">   18738 </span>            :   warning  (OPT_Wnamespaces, &quot;namespace %qD entered&quot;, current_namespace);
<span class="lineNum">   18739 </span>            : 
<span class="lineNum">   18740 </span>            :   /* Look for the `{' to validate starting the namespace.  */
<span class="lineNum">   18741 </span><span class="lineCov">     338910 :   matching_braces braces;</span>
<span class="lineNum">   18742 </span>            :   if (braces.require_open (parser))
<span class="lineNum">   18743 </span>            :     {
<span class="lineNum">   18744 </span><span class="lineCov">     340732 :       /* Parse the body of the namespace.  */</span>
<span class="lineNum">   18745 </span>            :       cp_parser_namespace_body (parser);
<span class="lineNum">   18746 </span>            : 
<span class="lineNum">   18747 </span><span class="lineCov">         30 :       /* Look for the final `}'.  */</span>
<span class="lineNum">   18748 </span><span class="lineCov">          5 :       braces.require_close (parser);</span>
<span class="lineNum">   18749 </span>            :     }
<span class="lineNum">   18750 </span>            : 
<span class="lineNum">   18751 </span>            :   if (has_visibility)
<span class="lineNum">   18752 </span>            :     pop_visibility (1);
<span class="lineNum">   18753 </span>            : 
<span class="lineNum">   18754 </span><span class="lineCov">         30 :   /* Pop the nested namespace definitions.  */</span>
<span class="lineNum">   18755 </span><span class="lineCov">         30 :   while (nested_definition_count--)</span>
<span class="lineNum">   18756 </span>            :     pop_namespace ();
<span class="lineNum">   18757 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   18758 </span><span class="lineCov">         30 : </span>
<span class="lineNum">   18759 </span><span class="lineCov">         30 : /* Parse a namespace-body.</span>
<span class="lineNum">   18760 </span>            : 
<span class="lineNum">   18761 </span><span class="lineCov">     340702 :    namespace-body:</span>
<span class="lineNum">   18762 </span><span class="lineCov">          1 :      declaration-seq [opt]  */</span>
<a name="18763"><span class="lineNum">   18763 </span>            : </a>
<span class="lineNum">   18764 </span><span class="lineCov">     340702 : static void</span>
<span class="lineNum">   18765 </span><span class="lineCov">          4 : cp_parser_namespace_body (cp_parser* parser)</span>
<span class="lineNum">   18766 </span>            : {
<span class="lineNum">   18767 </span><span class="lineCov">     340702 :   cp_parser_declaration_seq_opt (parser);</span>
<span class="lineNum">   18768 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">   18769 </span>            : 
<span class="lineNum">   18770 </span>            : /* Parse a namespace-alias-definition.
<span class="lineNum">   18771 </span>            : 
<span class="lineNum">   18772 </span><span class="lineCov">     340702 :    namespace-alias-definition:</span>
<span class="lineNum">   18773 </span>            :      namespace identifier = qualified-namespace-specifier ;  */
<a name="18774"><span class="lineNum">   18774 </span><span class="lineCov">     340702 : </span></a>
<span class="lineNum">   18775 </span>            : static void
<span class="lineNum">   18776 </span><span class="lineCov">     340702 : cp_parser_namespace_alias_definition (cp_parser* parser)</span>
<span class="lineNum">   18777 </span>            : {
<span class="lineNum">   18778 </span>            :   tree identifier;
<span class="lineNum">   18779 </span><span class="lineCov">     681404 :   tree namespace_specifier;</span>
<span class="lineNum">   18780 </span><span class="lineCov">     340702 : </span>
<span class="lineNum">   18781 </span>            :   cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   18782 </span>            : 
<span class="lineNum">   18783 </span><span class="lineCov">     681384 :   /* Look for the `namespace' keyword.  */</span>
<span class="lineNum">   18784 </span>            :   cp_parser_require_keyword (parser, RID_NAMESPACE, RT_NAMESPACE);
<span class="lineNum">   18785 </span>            :   /* Look for the identifier.  */
<span class="lineNum">   18786 </span><span class="lineCov">     340690 :   identifier = cp_parser_identifier (parser);</span>
<span class="lineNum">   18787 </span>            :   if (identifier == error_mark_node)
<span class="lineNum">   18788 </span>            :     return;
<span class="lineNum">   18789 </span><span class="lineCov">     340698 :   /* Look for the `=' token.  */</span>
<span class="lineNum">   18790 </span><span class="lineCov">     153732 :   if (!cp_parser_uncommitted_to_tentative_parse_p (parser)</span>
<span class="lineNum">   18791 </span>            :       &amp;&amp; cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_BRACE)) 
<span class="lineNum">   18792 </span>            :     {
<span class="lineNum">   18793 </span><span class="lineCov">     681425 :       error_at (token-&gt;location, &quot;%&lt;namespace%&gt; definition is not allowed here&quot;);</span>
<span class="lineNum">   18794 </span><span class="lineCov">     340727 :       /* Skip the definition.  */</span>
<span class="lineNum">   18795 </span><span class="lineCov">     340698 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   18796 </span>            :       if (cp_parser_skip_to_closing_brace (parser))
<span class="lineNum">   18797 </span>            :         cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   18798 </span>            :       return;
<span class="lineNum">   18799 </span>            :     }
<span class="lineNum">   18800 </span>            :   cp_parser_require (parser, CPP_EQ, RT_EQ);
<span class="lineNum">   18801 </span>            :   /* Look for the qualified-namespace-specifier.  */
<span class="lineNum">   18802 </span>            :   namespace_specifier
<span class="lineNum">   18803 </span><span class="lineNoCov">          0 :     = cp_parser_qualified_namespace_specifier (parser);</span>
<span class="lineNum">   18804 </span>            :   /* Look for the `;' token.  */
<span class="lineNum">   18805 </span><span class="lineCov">     340694 :   cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);</span>
<span class="lineNum">   18806 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   18807 </span>            :   /* Register the alias in the symbol table.  */
<span class="lineNum">   18808 </span>            :   do_namespace_alias (identifier, namespace_specifier);
<span class="lineNum">   18809 </span>            : }
<span class="lineNum">   18810 </span>            : 
<span class="lineNum">   18811 </span>            : /* Parse a qualified-namespace-specifier.
<span class="lineNum">   18812 </span>            : 
<span class="lineNum">   18813 </span>            :    qualified-namespace-specifier:
<span class="lineNum">   18814 </span><span class="lineCov">        505 :      :: [opt] nested-name-specifier [opt] namespace-name</span>
<span class="lineNum">   18815 </span>            : 
<span class="lineNum">   18816 </span><span class="lineCov">        505 :    Returns a NAMESPACE_DECL corresponding to the specified</span>
<span class="lineNum">   18817 </span><span class="lineCov">        505 :    namespace.  */</span>
<a name="18818"><span class="lineNum">   18818 </span>            : </a>
<span class="lineNum">   18819 </span><span class="lineCov">       1010 : static tree</span>
<span class="lineNum">   18820 </span>            : cp_parser_qualified_namespace_specifier (cp_parser* parser)
<span class="lineNum">   18821 </span>            : {
<span class="lineNum">   18822 </span><span class="lineCov">        505 :   /* Look for the optional `::'.  */</span>
<span class="lineNum">   18823 </span>            :   cp_parser_global_scope_opt (parser,
<span class="lineNum">   18824 </span><span class="lineCov">        505 :                               /*current_scope_valid_p=*/false);</span>
<span class="lineNum">   18825 </span><span class="lineCov">        505 : </span>
<span class="lineNum">   18826 </span>            :   /* Look for the optional nested-name-specifier.  */
<span class="lineNum">   18827 </span>            :   cp_parser_nested_name_specifier_opt (parser,
<span class="lineNum">   18828 </span><span class="lineCov">       1006 :                                        /*typename_keyword_p=*/false,</span>
<span class="lineNum">   18829 </span><span class="lineCov">        503 :                                        /*check_dependency_p=*/true,</span>
<span class="lineNum">   18830 </span>            :                                        /*type_p=*/false,
<span class="lineNum">   18831 </span><span class="lineCov">          6 :                                        /*is_declaration=*/true);</span>
<span class="lineNum">   18832 </span>            : 
<span class="lineNum">   18833 </span><span class="lineCov">          6 :   return cp_parser_namespace_name (parser);</span>
<span class="lineNum">   18834 </span><span class="lineCov">          6 : }</span>
<span class="lineNum">   18835 </span><span class="lineCov">          3 : </span>
<span class="lineNum">   18836 </span><span class="lineCov">          6 : /* Parse a using-declaration, or, if ACCESS_DECLARATION_P is true, an</span>
<span class="lineNum">   18837 </span>            :    access declaration.
<span class="lineNum">   18838 </span><span class="lineCov">        497 : </span>
<span class="lineNum">   18839 </span>            :    using-declaration:
<span class="lineNum">   18840 </span><span class="lineCov">        497 :      using typename [opt] :: [opt] nested-name-specifier unqualified-id ;</span>
<span class="lineNum">   18841 </span><span class="lineCov">        497 :      using :: unqualified-id ;  </span>
<span class="lineNum">   18842 </span>            : 
<span class="lineNum">   18843 </span><span class="lineCov">        497 :    access-declaration:</span>
<span class="lineNum">   18844 </span>            :      qualified-id ;  
<span class="lineNum">   18845 </span>            : 
<span class="lineNum">   18846 </span><span class="lineCov">        497 :    */</span>
<a name="18847"><span class="lineNum">   18847 </span>            : </a>
<span class="lineNum">   18848 </span>            : static bool
<span class="lineNum">   18849 </span>            : cp_parser_using_declaration (cp_parser* parser, 
<span class="lineNum">   18850 </span>            :                              bool access_declaration_p)
<span class="lineNum">   18851 </span>            : {
<span class="lineNum">   18852 </span>            :   cp_token *token;
<span class="lineNum">   18853 </span>            :   bool typename_p = false;
<span class="lineNum">   18854 </span>            :   bool global_scope_p;
<span class="lineNum">   18855 </span>            :   tree decl;
<span class="lineNum">   18856 </span>            :   tree identifier;
<span class="lineNum">   18857 </span>            :   tree qscope;
<span class="lineNum">   18858 </span><span class="lineCov">        497 :   int oldcount = errorcount;</span>
<span class="lineNum">   18859 </span>            :   cp_token *diag_token = NULL;
<span class="lineNum">   18860 </span>            : 
<span class="lineNum">   18861 </span><span class="lineCov">        497 :   if (access_declaration_p)</span>
<span class="lineNum">   18862 </span>            :     {
<span class="lineNum">   18863 </span>            :       diag_token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   18864 </span>            :       cp_parser_parse_tentatively (parser);
<span class="lineNum">   18865 </span><span class="lineCov">        497 :     }</span>
<span class="lineNum">   18866 </span>            :   else
<span class="lineNum">   18867 </span>            :     {
<span class="lineNum">   18868 </span>            :       /* Look for the `using' keyword.  */
<span class="lineNum">   18869 </span>            :       cp_parser_require_keyword (parser, RID_USING, RT_USING);
<span class="lineNum">   18870 </span>            :       
<span class="lineNum">   18871 </span><span class="lineCov">        497 :  again:</span>
<span class="lineNum">   18872 </span>            :       /* Peek at the next token.  */
<span class="lineNum">   18873 </span>            :       token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   18874 </span>            :       /* See if it's `typename'.  */
<span class="lineNum">   18875 </span>            :       if (token-&gt;keyword == RID_TYPENAME)
<span class="lineNum">   18876 </span>            :         {
<span class="lineNum">   18877 </span>            :           /* Remember that we've seen it.  */
<span class="lineNum">   18878 </span>            :           typename_p = true;
<span class="lineNum">   18879 </span>            :           /* Consume the `typename' token.  */
<span class="lineNum">   18880 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   18881 </span>            :         }
<span class="lineNum">   18882 </span>            :     }
<span class="lineNum">   18883 </span>            : 
<span class="lineNum">   18884 </span>            :   /* Look for the optional global scope qualification.  */
<span class="lineNum">   18885 </span>            :   global_scope_p
<span class="lineNum">   18886 </span>            :     = (cp_parser_global_scope_opt (parser,
<span class="lineNum">   18887 </span><span class="lineCov">    7794355 :                                    /*current_scope_valid_p=*/false)</span>
<span class="lineNum">   18888 </span>            :        != NULL_TREE);
<span class="lineNum">   18889 </span>            : 
<span class="lineNum">   18890 </span><span class="lineCov">    7794355 :   /* If we saw `typename', or didn't see `::', then there must be a</span>
<span class="lineNum">   18891 </span><span class="lineCov">    7794355 :      nested-name-specifier present.  */</span>
<span class="lineNum">   18892 </span><span class="lineCov">    7794355 :   if (typename_p || !global_scope_p)</span>
<span class="lineNum">   18893 </span><span class="lineCov">    7794355 :     {</span>
<span class="lineNum">   18894 </span><span class="lineCov">    7794355 :       qscope = cp_parser_nested_name_specifier (parser, typename_p,</span>
<span class="lineNum">   18895 </span><span class="lineCov">    7794355 :                                                 /*check_dependency_p=*/true,</span>
<span class="lineNum">   18896 </span><span class="lineCov">    7794355 :                                                 /*type_p=*/false,</span>
<span class="lineNum">   18897 </span><span class="lineCov">    7794355 :                                                 /*is_declaration=*/true);</span>
<span class="lineNum">   18898 </span>            :       if (!qscope &amp;&amp; !cp_parser_uncommitted_to_tentative_parse_p (parser))
<span class="lineNum">   18899 </span><span class="lineCov">    7794355 :         {</span>
<span class="lineNum">   18900 </span>            :           cp_parser_skip_to_end_of_block_or_statement (parser);
<span class="lineNum">   18901 </span><span class="lineCov">   14344206 :           return false;</span>
<span class="lineNum">   18902 </span><span class="lineCov">    7172103 :         }</span>
<span class="lineNum">   18903 </span>            :     }
<span class="lineNum">   18904 </span>            :   /* Otherwise, we could be in either of the two productions.  In that
<span class="lineNum">   18905 </span>            :      case, treat the nested-name-specifier as optional.  */
<span class="lineNum">   18906 </span>            :   else
<span class="lineNum">   18907 </span><span class="lineCov">     622252 :     qscope = cp_parser_nested_name_specifier_opt (parser,</span>
<span class="lineNum">   18908 </span>            :                                                   /*typename_keyword_p=*/false,
<span class="lineNum">   18909 </span><span class="lineCov">     622258 :                                                   /*check_dependency_p=*/true,</span>
<span class="lineNum">   18910 </span>            :                                                   /*type_p=*/false,
<span class="lineNum">   18911 </span><span class="lineCov">    1244516 :                                                   /*is_declaration=*/true);</span>
<span class="lineNum">   18912 </span>            :   if (!qscope)
<span class="lineNum">   18913 </span><span class="lineCov">     622258 :     qscope = global_namespace;</span>
<span class="lineNum">   18914 </span>            :   else if (UNSCOPED_ENUM_P (qscope))
<span class="lineNum">   18915 </span>            :     qscope = CP_TYPE_CONTEXT (qscope);
<span class="lineNum">   18916 </span><span class="lineCov">        130 : </span>
<span class="lineNum">   18917 </span>            :   if (access_declaration_p &amp;&amp; cp_parser_error_occurred (parser))
<span class="lineNum">   18918 </span><span class="lineCov">        130 :     /* Something has already gone wrong; there's no need to parse</span>
<span class="lineNum">   18919 </span>            :        further.  Since an error has occurred, the return value of
<span class="lineNum">   18920 </span>            :        cp_parser_parse_definitely will be false, as required.  */
<span class="lineNum">   18921 </span>            :     return cp_parser_parse_definitely (parser);
<span class="lineNum">   18922 </span>            : 
<span class="lineNum">   18923 </span><span class="lineCov">    7794361 :   token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   18924 </span><span class="lineCov">   15588722 :   /* Parse the unqualified-id.  */</span>
<span class="lineNum">   18925 </span>            :   identifier = cp_parser_unqualified_id (parser,
<span class="lineNum">   18926 </span>            :                                          /*template_keyword_p=*/false,
<span class="lineNum">   18927 </span>            :                                          /*check_dependency_p=*/true,
<span class="lineNum">   18928 </span>            :                                          /*declarator_p=*/true,
<span class="lineNum">   18929 </span>            :                                          /*optional_p=*/false);
<span class="lineNum">   18930 </span><span class="lineCov">    7794361 : </span>
<span class="lineNum">   18931 </span>            :   if (access_declaration_p)
<span class="lineNum">   18932 </span><span class="lineCov">    7310707 :     {</span>
<span class="lineNum">   18933 </span>            :       if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_SEMICOLON))
<span class="lineNum">   18934 </span>            :         cp_parser_simulate_error (parser);
<span class="lineNum">   18935 </span>            :       if (!cp_parser_parse_definitely (parser))
<span class="lineNum">   18936 </span><span class="lineCov">    7310707 :         return false;</span>
<span class="lineNum">   18937 </span>            :     }
<span class="lineNum">   18938 </span><span class="lineCov">         54 :   else if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_ELLIPSIS))</span>
<span class="lineNum">   18939 </span><span class="lineCov">         54 :     {</span>
<span class="lineNum">   18940 </span>            :       cp_token *ell = cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   18941 </span>            :       if (cxx_dialect &lt; cxx17
<span class="lineNum">   18942 </span>            :           &amp;&amp; !in_system_header_at (ell-&gt;location))
<span class="lineNum">   18943 </span>            :         pedwarn (ell-&gt;location, 0,
<span class="lineNum">   18944 </span>            :                  &quot;pack expansion in using-declaration only available &quot;
<span class="lineNum">   18945 </span><span class="lineCov">     483654 :                  &quot;with -std=c++17 or -std=gnu++17&quot;);</span>
<span class="lineNum">   18946 </span>            :       qscope = make_pack_expansion (qscope);
<span class="lineNum">   18947 </span>            :     }
<span class="lineNum">   18948 </span>            : 
<span class="lineNum">   18949 </span>            :   /* The function we call to handle a using-declaration is different
<span class="lineNum">   18950 </span><span class="lineCov">    7794307 :      depending on what scope we are in.  */</span>
<span class="lineNum">   18951 </span><span class="lineCov">    7589342 :   if (qscope == error_mark_node || identifier == error_mark_node)</span>
<span class="lineNum">   18952 </span><span class="lineCov">     204965 :     ;</span>
<span class="lineNum">   18953 </span><span class="lineCov">          8 :   else if (!identifier_p (identifier)</span>
<span class="lineNum">   18954 </span>            :            &amp;&amp; TREE_CODE (identifier) != BIT_NOT_EXPR)
<span class="lineNum">   18955 </span><span class="lineCov">    7794307 :     /* [namespace.udecl]</span>
<span class="lineNum">   18956 </span>            : 
<span class="lineNum">   18957 </span>            :        A using declaration shall not name a template-id.  */
<span class="lineNum">   18958 </span>            :     error_at (token-&gt;location,
<span class="lineNum">   18959 </span><span class="lineCov">    7143585 :               &quot;a template-id may not appear in a using-declaration&quot;);</span>
<span class="lineNum">   18960 </span>            :   else
<span class="lineNum">   18961 </span><span class="lineCov">    1301444 :     {</span>
<span class="lineNum">   18962 </span>            :       if (at_class_scope_p ())
<span class="lineNum">   18963 </span><span class="lineCov">    1301444 :         {</span>
<span class="lineNum">   18964 </span>            :           /* Create the USING_DECL.  */
<span class="lineNum">   18965 </span>            :           decl = do_class_using_decl (qscope, identifier);
<span class="lineNum">   18966 </span>            : 
<span class="lineNum">   18967 </span><span class="lineCov">     650722 :           if (decl &amp;&amp; typename_p)</span>
<span class="lineNum">   18968 </span>            :             USING_DECL_TYPENAME_P (decl) = 1;
<span class="lineNum">   18969 </span><span class="lineCov">     650722 : </span>
<span class="lineNum">   18970 </span>            :           if (check_for_bare_parameter_packs (decl))
<span class="lineNum">   18971 </span><span class="lineCov">      28518 :             {</span>
<span class="lineNum">   18972 </span><span class="lineCov">      28388 :               cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);</span>
<span class="lineNum">   18973 </span><span class="lineCov">      28518 :               return false;</span>
<span class="lineNum">   18974 </span>            :             }
<span class="lineNum">   18975 </span>            :           else
<span class="lineNum">   18976 </span><span class="lineCov">     622204 :             /* Add it to the list of members in this class.  */</span>
<span class="lineNum">   18977 </span>            :             finish_member_declaration (decl);
<span class="lineNum">   18978 </span><span class="lineCov">          3 :         }</span>
<span class="lineNum">   18979 </span><span class="lineCov">          3 :       else</span>
<span class="lineNum">   18980 </span><span class="lineCov">          3 :         {</span>
<span class="lineNum">   18981 </span><span class="lineCov">          2 :           decl = cp_parser_lookup_name_simple (parser,</span>
<span class="lineNum">   18982 </span>            :                                                identifier,
<span class="lineNum">   18983 </span>            :                                                token-&gt;location);
<span class="lineNum">   18984 </span><span class="lineCov">          3 :           if (decl == error_mark_node)</span>
<span class="lineNum">   18985 </span>            :             cp_parser_name_lookup_error (parser, identifier,
<span class="lineNum">   18986 </span>            :                                          decl, NLE_NULL,
<span class="lineNum">   18987 </span>            :                                          token-&gt;location);
<span class="lineNum">   18988 </span>            :           else if (check_for_bare_parameter_packs (decl))
<span class="lineNum">   18989 </span><span class="lineCov">     622334 :             {</span>
<span class="lineNum">   18990 </span>            :               cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);
<span class="lineNum">   18991 </span><span class="lineCov">     622325 :               return false;</span>
<span class="lineNum">   18992 </span><span class="lineCov">         12 :             }</span>
<span class="lineNum">   18993 </span>            :           else if (!at_namespace_scope_p ())
<span class="lineNum">   18994 </span>            :             finish_local_using_decl (decl, qscope, identifier);
<span class="lineNum">   18995 </span>            :           else
<span class="lineNum">   18996 </span><span class="lineCov">         12 :             finish_namespace_using_decl (decl, qscope, identifier);</span>
<span class="lineNum">   18997 </span>            :         }
<span class="lineNum">   18998 </span>            :     }
<span class="lineNum">   18999 </span>            : 
<span class="lineNum">   19000 </span><span class="lineCov">     622313 :   if (!access_declaration_p</span>
<span class="lineNum">   19001 </span>            :       &amp;&amp; cp_lexer_next_token_is (parser-&gt;lexer, CPP_COMMA))
<span class="lineNum">   19002 </span>            :     {
<span class="lineNum">   19003 </span><span class="lineCov">      28923 :       cp_token *comma = cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   19004 </span>            :       if (cxx_dialect &lt; cxx17)
<span class="lineNum">   19005 </span><span class="lineCov">      28923 :         pedwarn (comma-&gt;location, 0,</span>
<span class="lineNum">   19006 </span><span class="lineCov">        124 :                  &quot;comma-separated list in using-declaration only available &quot;</span>
<span class="lineNum">   19007 </span>            :                  &quot;with -std=c++17 or -std=gnu++17&quot;);
<span class="lineNum">   19008 </span><span class="lineCov">      28923 :       goto again;</span>
<span class="lineNum">   19009 </span>            :     }
<span class="lineNum">   19010 </span><span class="lineCov">          2 : </span>
<span class="lineNum">   19011 </span><span class="lineCov">          2 :   /* Look for the final `;'.  */</span>
<span class="lineNum">   19012 </span>            :   cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);
<span class="lineNum">   19013 </span>            : 
<span class="lineNum">   19014 </span>            :   if (access_declaration_p &amp;&amp; errorcount == oldcount)
<span class="lineNum">   19015 </span><span class="lineCov">      28921 :     warning_at (diag_token-&gt;location, OPT_Wdeprecated,</span>
<span class="lineNum">   19016 </span>            :                 &quot;access declarations are deprecated &quot;
<span class="lineNum">   19017 </span>            :                 &quot;in favour of using-declarations; &quot;
<span class="lineNum">   19018 </span>            :                 &quot;suggestion: add the %&lt;using%&gt; keyword&quot;);
<span class="lineNum">   19019 </span><span class="lineCov">    1186780 : </span>
<span class="lineNum">   19020 </span>            :   return true;
<span class="lineNum">   19021 </span>            : }
<span class="lineNum">   19022 </span><span class="lineCov">     593390 : </span>
<span class="lineNum">   19023 </span><span class="lineCov">         46 : /* Parse an alias-declaration.</span>
<span class="lineNum">   19024 </span>            : 
<span class="lineNum">   19025 </span>            :    alias-declaration:
<span class="lineNum">   19026 </span><span class="lineCov">     593344 :      using identifier attribute-specifier-seq [opt] = type-id  */</span>
<a name="19027"><span class="lineNum">   19027 </span>            : </a>
<span class="lineNum">   19028 </span><span class="lineNoCov">          0 : static tree</span>
<span class="lineNum">   19029 </span><span class="lineNoCov">          0 : cp_parser_alias_declaration (cp_parser* parser)</span>
<span class="lineNum">   19030 </span>            : {
<span class="lineNum">   19031 </span><span class="lineCov">     593344 :   tree id, type, decl, pushed_scope = NULL_TREE, attributes;</span>
<span class="lineNum">   19032 </span><span class="lineCov">      12931 :   location_t id_location;</span>
<span class="lineNum">   19033 </span>            :   cp_declarator *declarator;
<span class="lineNum">   19034 </span><span class="lineCov">     580413 :   cp_decl_specifier_seq decl_specs;</span>
<span class="lineNum">   19035 </span>            :   bool member_p;
<span class="lineNum">   19036 </span>            :   const char *saved_message = NULL;
<span class="lineNum">   19037 </span>            : 
<span class="lineNum">   19038 </span><span class="lineCov">     622332 :   /* Look for the `using' keyword.  */</span>
<span class="lineNum">   19039 </span><span class="lineCov">     622332 :   cp_token *using_token</span>
<span class="lineNum">   19040 </span>            :     = cp_parser_require_keyword (parser, RID_USING, RT_USING);
<span class="lineNum">   19041 </span><span class="lineCov">          6 :   if (using_token == NULL)</span>
<span class="lineNum">   19042 </span><span class="lineCov">          6 :     return error_mark_node;</span>
<span class="lineNum">   19043 </span><span class="lineCov">          6 : </span>
<span class="lineNum">   19044 </span>            :   id_location = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">   19045 </span>            :   id = cp_parser_identifier (parser);
<span class="lineNum">   19046 </span><span class="lineCov">          6 :   if (id == error_mark_node)</span>
<span class="lineNum">   19047 </span>            :     return error_mark_node;
<span class="lineNum">   19048 </span>            : 
<span class="lineNum">   19049 </span>            :   cp_token *attrs_token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   19050 </span><span class="lineCov">     622326 :   attributes = cp_parser_attributes_opt (parser);</span>
<span class="lineNum">   19051 </span>            :   if (attributes == error_mark_node)
<span class="lineNum">   19052 </span><span class="lineCov">     622326 :     return error_mark_node;</span>
<span class="lineNum">   19053 </span><span class="lineCov">        121 : </span>
<span class="lineNum">   19054 </span>            :   cp_parser_require (parser, CPP_EQ, RT_EQ);
<span class="lineNum">   19055 </span>            : 
<span class="lineNum">   19056 </span>            :   if (cp_parser_error_occurred (parser))
<span class="lineNum">   19057 </span>            :     return error_mark_node;
<span class="lineNum">   19058 </span>            : 
<span class="lineNum">   19059 </span>            :   cp_parser_commit_to_tentative_parse (parser);
<span class="lineNum">   19060 </span>            : 
<span class="lineNum">   19061 </span>            :   /* Now we are going to parse the type-id of the declaration.  */
<span class="lineNum">   19062 </span>            : 
<span class="lineNum">   19063 </span>            :   /*
<span class="lineNum">   19064 </span>            :     [dcl.type]/3 says:
<span class="lineNum">   19065 </span>            : 
<span class="lineNum">   19066 </span>            :         &quot;A type-specifier-seq shall not define a class or enumeration
<span class="lineNum">   19067 </span><span class="lineCov">     450100 :          unless it appears in the type-id of an alias-declaration (7.1.3) that</span>
<span class="lineNum">   19068 </span>            :          is not the declaration of a template-declaration.&quot;
<span class="lineNum">   19069 </span><span class="lineCov">     450100 : </span>
<span class="lineNum">   19070 </span><span class="lineCov">     450100 :     In other words, if we currently are in an alias template, the</span>
<span class="lineNum">   19071 </span><span class="lineCov">     450100 :     type-id should not define a type.</span>
<span class="lineNum">   19072 </span><span class="lineCov">     450100 : </span>
<span class="lineNum">   19073 </span><span class="lineCov">     450100 :     So let's set parser-&gt;type_definition_forbidden_message in that</span>
<span class="lineNum">   19074 </span><span class="lineCov">     450100 :     case; cp_parser_check_type_definition (called by</span>
<span class="lineNum">   19075 </span>            :     cp_parser_class_specifier) will then emit an error if a type is
<span class="lineNum">   19076 </span>            :     defined in the type-id.  */
<span class="lineNum">   19077 </span><span class="lineCov">     450100 :   if (parser-&gt;num_template_parameter_lists)</span>
<span class="lineNum">   19078 </span><span class="lineCov">     450100 :     {</span>
<span class="lineNum">   19079 </span><span class="lineCov">     450100 :       saved_message = parser-&gt;type_definition_forbidden_message;</span>
<span class="lineNum">   19080 </span><span class="lineNoCov">          0 :       parser-&gt;type_definition_forbidden_message =</span>
<span class="lineNum">   19081 </span>            :         G_(&quot;types may not be defined in alias template declarations&quot;);
<span class="lineNum">   19082 </span><span class="lineCov">     900200 :     }</span>
<span class="lineNum">   19083 </span><span class="lineCov">     450100 : </span>
<span class="lineNum">   19084 </span><span class="lineCov">     450100 :   type = cp_parser_type_id (parser);</span>
<span class="lineNum">   19085 </span>            : 
<span class="lineNum">   19086 </span>            :   /* Restore the error message if need be.  */
<span class="lineNum">   19087 </span><span class="lineCov">     899942 :   if (parser-&gt;num_template_parameter_lists)</span>
<span class="lineNum">   19088 </span><span class="lineCov">     449971 :     parser-&gt;type_definition_forbidden_message = saved_message;</span>
<span class="lineNum">   19089 </span><span class="lineCov">     449971 : </span>
<span class="lineNum">   19090 </span>            :   if (type == error_mark_node
<span class="lineNum">   19091 </span>            :       || !cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON))
<span class="lineNum">   19092 </span><span class="lineCov">     449971 :     {</span>
<span class="lineNum">   19093 </span>            :       cp_parser_skip_to_end_of_block_or_statement (parser);
<span class="lineNum">   19094 </span><span class="lineCov">     899942 :       return error_mark_node;</span>
<span class="lineNum">   19095 </span><span class="lineCov">      27451 :     }</span>
<span class="lineNum">   19096 </span>            : 
<span class="lineNum">   19097 </span><span class="lineCov">     422520 :   /* A typedef-name can also be introduced by an alias-declaration. The</span>
<span class="lineNum">   19098 </span>            :      identifier following the using keyword becomes a typedef-name. It has
<span class="lineNum">   19099 </span>            :      the same semantics as if it were introduced by the typedef
<span class="lineNum">   19100 </span>            :      specifier. In particular, it does not define a new type and it shall
<span class="lineNum">   19101 </span>            :      not appear in the type-id.  */
<span class="lineNum">   19102 </span>            : 
<span class="lineNum">   19103 </span>            :   clear_decl_specs (&amp;decl_specs);
<span class="lineNum">   19104 </span>            :   decl_specs.type = type;
<span class="lineNum">   19105 </span>            :   if (attributes != NULL_TREE)
<span class="lineNum">   19106 </span>            :     {
<span class="lineNum">   19107 </span>            :       decl_specs.attributes = attributes;
<span class="lineNum">   19108 </span>            :       set_and_check_decl_spec_loc (&amp;decl_specs,
<span class="lineNum">   19109 </span>            :                                    ds_attribute,
<span class="lineNum">   19110 </span>            :                                    attrs_token);
<span class="lineNum">   19111 </span>            :     }
<span class="lineNum">   19112 </span>            :   set_and_check_decl_spec_loc (&amp;decl_specs,
<span class="lineNum">   19113 </span>            :                                ds_typedef,
<span class="lineNum">   19114 </span>            :                                using_token);
<span class="lineNum">   19115 </span><span class="lineCov">     422520 :   set_and_check_decl_spec_loc (&amp;decl_specs,</span>
<span class="lineNum">   19116 </span>            :                                ds_alias,
<span class="lineNum">   19117 </span><span class="lineCov">     162278 :                                using_token);</span>
<span class="lineNum">   19118 </span><span class="lineCov">     162278 : </span>
<span class="lineNum">   19119 </span>            :   if (parser-&gt;num_template_parameter_lists
<span class="lineNum">   19120 </span>            :       &amp;&amp; !cp_parser_check_template_parameters (parser,
<span class="lineNum">   19121 </span>            :                                                /*num_templates=*/0,
<span class="lineNum">   19122 </span><span class="lineCov">     845040 :                                                /*template_id*/false,</span>
<span class="lineNum">   19123 </span>            :                                                id_location,
<span class="lineNum">   19124 </span>            :                                                /*declarator=*/NULL))
<span class="lineNum">   19125 </span><span class="lineCov">     422520 :     return error_mark_node;</span>
<span class="lineNum">   19126 </span><span class="lineCov">     162278 : </span>
<span class="lineNum">   19127 </span>            :   declarator = make_id_declarator (NULL_TREE, id, sfk_none);
<span class="lineNum">   19128 </span><span class="lineCov">     422520 :   declarator-&gt;id_loc = id_location;</span>
<span class="lineNum">   19129 </span><span class="lineCov">     422520 : </span>
<span class="lineNum">   19130 </span>            :   member_p = at_class_scope_p ();
<span class="lineNum">   19131 </span><span class="lineCov">         23 :   if (member_p)</span>
<span class="lineNum">   19132 </span><span class="lineCov">         23 :     decl = grokfield (declarator, &amp;decl_specs, NULL_TREE, false,</span>
<span class="lineNum">   19133 </span>            :                       NULL_TREE, attributes);
<span class="lineNum">   19134 </span>            :   else
<span class="lineNum">   19135 </span>            :     decl = start_decl (declarator, &amp;decl_specs, 0,
<span class="lineNum">   19136 </span>            :                        attributes, NULL_TREE, &amp;pushed_scope);
<span class="lineNum">   19137 </span>            :   if (decl == error_mark_node)
<span class="lineNum">   19138 </span>            :     return decl;
<span class="lineNum">   19139 </span>            : 
<span class="lineNum">   19140 </span>            :   // Attach constraints to the alias declaration.
<span class="lineNum">   19141 </span><span class="lineCov">     844994 :   if (flag_concepts &amp;&amp; current_template_parms)</span>
<span class="lineNum">   19142 </span><span class="lineCov">     422497 :     {</span>
<span class="lineNum">   19143 </span><span class="lineCov">     422497 :       tree reqs = TEMPLATE_PARMS_CONSTRAINTS (current_template_parms);</span>
<span class="lineNum">   19144 </span>            :       tree constr = build_constraints (reqs, NULL_TREE);
<span class="lineNum">   19145 </span><span class="lineCov">        436 :       set_constraints (decl, constr);</span>
<span class="lineNum">   19146 </span><span class="lineCov">        436 :     }</span>
<span class="lineNum">   19147 </span>            : 
<span class="lineNum">   19148 </span>            :   cp_finish_decl (decl, NULL_TREE, 0, NULL_TREE, 0);
<span class="lineNum">   19149 </span>            : 
<span class="lineNum">   19150 </span><span class="lineCov">     422497 :   if (pushed_scope)</span>
<span class="lineNum">   19151 </span>            :     pop_scope (pushed_scope);
<span class="lineNum">   19152 </span>            : 
<span class="lineNum">   19153 </span><span class="lineCov">     422497 :   /* If decl is a template, return its TEMPLATE_DECL so that it gets</span>
<span class="lineNum">   19154 </span>            :      added into the symbol table; otherwise, return the TYPE_DECL.  */
<span class="lineNum">   19155 </span>            :   if (DECL_LANG_SPECIFIC (decl)
<span class="lineNum">   19156 </span>            :       &amp;&amp; DECL_TEMPLATE_INFO (decl)
<span class="lineNum">   19157 </span><span class="lineCov">     422497 :       &amp;&amp; PRIMARY_TEMPLATE_P (DECL_TI_TEMPLATE (decl)))</span>
<span class="lineNum">   19158 </span><span class="lineCov">     422497 :     {</span>
<span class="lineNum">   19159 </span>            :       decl = DECL_TI_TEMPLATE (decl);
<span class="lineNum">   19160 </span>            :       if (member_p)
<span class="lineNum">   19161 </span>            :         check_member_template (decl);
<span class="lineNum">   19162 </span>            :     }
<span class="lineNum">   19163 </span><span class="lineCov">          4 : </span>
<span class="lineNum">   19164 </span>            :   return decl;
<span class="lineNum">   19165 </span><span class="lineCov">     422493 : }</span>
<span class="lineNum">   19166 </span><span class="lineCov">     422493 : </span>
<span class="lineNum">   19167 </span>            : /* Parse a using-directive.
<span class="lineNum">   19168 </span><span class="lineCov">     422493 : </span>
<span class="lineNum">   19169 </span><span class="lineCov">     422493 :    using-directive:</span>
<span class="lineNum">   19170 </span><span class="lineCov">     248510 :      using namespace :: [opt] nested-name-specifier [opt]</span>
<span class="lineNum">   19171 </span>            :        namespace-name ;  */
<a name="19172"><span class="lineNum">   19172 </span>            : </a>
<span class="lineNum">   19173 </span><span class="lineCov">     173983 : static void</span>
<span class="lineNum">   19174 </span>            : cp_parser_using_directive (cp_parser* parser)
<span class="lineNum">   19175 </span><span class="lineCov">     422493 : {</span>
<span class="lineNum">   19176 </span>            :   tree namespace_decl;
<span class="lineNum">   19177 </span>            :   tree attribs;
<span class="lineNum">   19178 </span>            : 
<span class="lineNum">   19179 </span><span class="lineCov">     422485 :   /* Look for the `using' keyword.  */</span>
<span class="lineNum">   19180 </span>            :   cp_parser_require_keyword (parser, RID_USING, RT_USING);
<span class="lineNum">   19181 </span><span class="lineCov">        779 :   /* And the `namespace' keyword.  */</span>
<span class="lineNum">   19182 </span><span class="lineCov">        779 :   cp_parser_require_keyword (parser, RID_NAMESPACE, RT_NAMESPACE);</span>
<span class="lineNum">   19183 </span><span class="lineCov">        779 :   /* Look for the optional `::' operator.  */</span>
<span class="lineNum">   19184 </span>            :   cp_parser_global_scope_opt (parser, /*current_scope_valid_p=*/false);
<span class="lineNum">   19185 </span>            :   /* And the optional nested-name-specifier.  */
<span class="lineNum">   19186 </span><span class="lineCov">     422485 :   cp_parser_nested_name_specifier_opt (parser,</span>
<span class="lineNum">   19187 </span>            :                                        /*typename_keyword_p=*/false,
<span class="lineNum">   19188 </span><span class="lineCov">     422485 :                                        /*check_dependency_p=*/true,</span>
<span class="lineNum">   19189 </span><span class="lineCov">     107462 :                                        /*type_p=*/false,</span>
<span class="lineNum">   19190 </span>            :                                        /*is_declaration=*/true);
<span class="lineNum">   19191 </span>            :   /* Get the namespace being used.  */
<span class="lineNum">   19192 </span>            :   namespace_decl = cp_parser_namespace_name (parser);
<span class="lineNum">   19193 </span><span class="lineCov">     422485 :   /* And any specified attributes.  */</span>
<span class="lineNum">   19194 </span><span class="lineCov">     351628 :   attribs = cp_parser_attributes_opt (parser);</span>
<span class="lineNum">   19195 </span><span class="lineCov">     756316 : </span>
<span class="lineNum">   19196 </span>            :   /* Update the symbol table.  */
<span class="lineNum">   19197 </span><span class="lineCov">     162262 :   if (namespace_bindings_p ())</span>
<span class="lineNum">   19198 </span><span class="lineCov">     162262 :     finish_namespace_using_directive (namespace_decl, attribs);</span>
<span class="lineNum">   19199 </span><span class="lineCov">      59144 :   else</span>
<span class="lineNum">   19200 </span>            :     finish_local_using_directive (namespace_decl, attribs);
<span class="lineNum">   19201 </span>            : 
<span class="lineNum">   19202 </span>            :   /* Look for the final `;'.  */
<span class="lineNum">   19203 </span>            :   cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);
<span class="lineNum">   19204 </span>            : }
<span class="lineNum">   19205 </span>            : 
<span class="lineNum">   19206 </span>            : /* Parse an asm-definition.
<span class="lineNum">   19207 </span>            : 
<span class="lineNum">   19208 </span>            :    asm-definition:
<span class="lineNum">   19209 </span>            :      asm ( string-literal ) ;
<span class="lineNum">   19210 </span>            : 
<span class="lineNum">   19211 </span>            :    GNU Extension:
<span class="lineNum">   19212 </span><span class="lineCov">      10784 : </span>
<span class="lineNum">   19213 </span>            :    asm-definition:
<span class="lineNum">   19214 </span><span class="lineCov">      10784 :      asm volatile [opt] ( string-literal ) ;</span>
<span class="lineNum">   19215 </span><span class="lineCov">      10784 :      asm volatile [opt] ( string-literal : asm-operand-list [opt] ) ;</span>
<span class="lineNum">   19216 </span>            :      asm volatile [opt] ( string-literal : asm-operand-list [opt]
<span class="lineNum">   19217 </span>            :                           : asm-operand-list [opt] ) ;
<span class="lineNum">   19218 </span><span class="lineCov">      10784 :      asm volatile [opt] ( string-literal : asm-operand-list [opt]</span>
<span class="lineNum">   19219 </span>            :                           : asm-operand-list [opt]
<span class="lineNum">   19220 </span><span class="lineCov">      10784 :                           : asm-clobber-list [opt] ) ;</span>
<span class="lineNum">   19221 </span>            :      asm volatile [opt] goto ( string-literal : : asm-operand-list [opt]
<span class="lineNum">   19222 </span><span class="lineCov">      10784 :                                : asm-clobber-list [opt]</span>
<span class="lineNum">   19223 </span>            :                                : asm-goto-list ) ;  */
<a name="19224"><span class="lineNum">   19224 </span><span class="lineCov">      10784 : </span></a>
<span class="lineNum">   19225 </span>            : static void
<span class="lineNum">   19226 </span>            : cp_parser_asm_definition (cp_parser* parser)
<span class="lineNum">   19227 </span>            : {
<span class="lineNum">   19228 </span>            :   tree string;
<span class="lineNum">   19229 </span>            :   tree outputs = NULL_TREE;
<span class="lineNum">   19230 </span><span class="lineCov">      10784 :   tree inputs = NULL_TREE;</span>
<span class="lineNum">   19231 </span>            :   tree clobbers = NULL_TREE;
<span class="lineNum">   19232 </span><span class="lineCov">      10784 :   tree labels = NULL_TREE;</span>
<span class="lineNum">   19233 </span>            :   tree asm_stmt;
<span class="lineNum">   19234 </span>            :   bool volatile_p = false;
<span class="lineNum">   19235 </span><span class="lineCov">      10784 :   bool extended_p = false;</span>
<span class="lineNum">   19236 </span><span class="lineCov">       8074 :   bool invalid_inputs_p = false;</span>
<span class="lineNum">   19237 </span>            :   bool invalid_outputs_p = false;
<span class="lineNum">   19238 </span><span class="lineCov">       2710 :   bool goto_p = false;</span>
<span class="lineNum">   19239 </span>            :   required_token missing = RT_NONE;
<span class="lineNum">   19240 </span>            : 
<span class="lineNum">   19241 </span><span class="lineCov">      10784 :   /* Look for the `asm' keyword.  */</span>
<span class="lineNum">   19242 </span><span class="lineCov">      10784 :   cp_parser_require_keyword (parser, RID_ASM, RT_ASM);</span>
<span class="lineNum">   19243 </span>            : 
<span class="lineNum">   19244 </span>            :   if (parser-&gt;in_function_body
<span class="lineNum">   19245 </span>            :       &amp;&amp; DECL_DECLARED_CONSTEXPR_P (current_function_decl))
<span class="lineNum">   19246 </span>            :     {
<span class="lineNum">   19247 </span>            :       error (&quot;%&lt;asm%&gt; in %&lt;constexpr%&gt; function&quot;);
<span class="lineNum">   19248 </span>            :       cp_function_chain-&gt;invalid_constexpr = true;
<span class="lineNum">   19249 </span>            :     }
<span class="lineNum">   19250 </span>            : 
<span class="lineNum">   19251 </span>            :   /* See if the next token is `volatile'.  */
<span class="lineNum">   19252 </span>            :   if (cp_parser_allow_gnu_extensions_p (parser)
<span class="lineNum">   19253 </span>            :       &amp;&amp; cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_VOLATILE))
<span class="lineNum">   19254 </span>            :     {
<span class="lineNum">   19255 </span>            :       /* Remember that we saw the `volatile' keyword.  */
<span class="lineNum">   19256 </span>            :       volatile_p = true;
<span class="lineNum">   19257 </span>            :       /* Consume the token.  */
<span class="lineNum">   19258 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   19259 </span>            :     }
<span class="lineNum">   19260 </span>            :   if (cp_parser_allow_gnu_extensions_p (parser)
<span class="lineNum">   19261 </span>            :       &amp;&amp; parser-&gt;in_function_body
<span class="lineNum">   19262 </span>            :       &amp;&amp; cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_GOTO))
<span class="lineNum">   19263 </span>            :     {
<span class="lineNum">   19264 </span><span class="lineCov">      13271 :       /* Remember that we saw the `goto' keyword.  */</span>
<span class="lineNum">   19265 </span>            :       goto_p = true;
<span class="lineNum">   19266 </span><span class="lineCov">      13271 :       /* Consume the token.  */</span>
<span class="lineNum">   19267 </span><span class="lineCov">      13271 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   19268 </span><span class="lineCov">      13271 :     }</span>
<span class="lineNum">   19269 </span><span class="lineCov">      13271 :   /* Look for the opening `('.  */</span>
<span class="lineNum">   19270 </span><span class="lineCov">      13271 :   if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))</span>
<span class="lineNum">   19271 </span><span class="lineCov">      13271 :     return;</span>
<span class="lineNum">   19272 </span><span class="lineCov">      13271 :   /* Look for the string.  */</span>
<span class="lineNum">   19273 </span><span class="lineCov">      13271 :   string = cp_parser_string_literal (parser, false, false);</span>
<span class="lineNum">   19274 </span><span class="lineCov">      13271 :   if (string == error_mark_node)</span>
<span class="lineNum">   19275 </span><span class="lineCov">      13271 :     {</span>
<span class="lineNum">   19276 </span><span class="lineCov">      13271 :       cp_parser_skip_to_closing_parenthesis (parser, true, false,</span>
<span class="lineNum">   19277 </span><span class="lineCov">      13271 :                                              /*consume_paren=*/true);</span>
<span class="lineNum">   19278 </span>            :       return;
<span class="lineNum">   19279 </span>            :     }
<span class="lineNum">   19280 </span><span class="lineCov">      13271 : </span>
<span class="lineNum">   19281 </span>            :   /* If we're allowing GNU extensions, check for the extended assembly
<span class="lineNum">   19282 </span><span class="lineCov">      13271 :      syntax.  Unfortunately, the `:' tokens need not be separated by</span>
<span class="lineNum">   19283 </span><span class="lineCov">      26413 :      a space in C, and so, for compatibility, we tolerate that here</span>
<span class="lineNum">   19284 </span>            :      too.  Doing that means that we have to treat the `::' operator as
<span class="lineNum">   19285 </span><span class="lineCov">          1 :      two `:' tokens.  */</span>
<span class="lineNum">   19286 </span><span class="lineCov">          1 :   if (cp_parser_allow_gnu_extensions_p (parser)</span>
<span class="lineNum">   19287 </span>            :       &amp;&amp; parser-&gt;in_function_body
<span class="lineNum">   19288 </span>            :       &amp;&amp; (cp_lexer_next_token_is (parser-&gt;lexer, CPP_COLON)
<span class="lineNum">   19289 </span>            :           || cp_lexer_next_token_is (parser-&gt;lexer, CPP_SCOPE)))
<span class="lineNum">   19290 </span><span class="lineCov">      26542 :     {</span>
<span class="lineNum">   19291 </span><span class="lineCov">      13271 :       bool inputs_p = false;</span>
<span class="lineNum">   19292 </span>            :       bool clobbers_p = false;
<span class="lineNum">   19293 </span>            :       bool labels_p = false;
<span class="lineNum">   19294 </span><span class="lineCov">      10632 : </span>
<span class="lineNum">   19295 </span>            :       /* The extended syntax was used.  */
<span class="lineNum">   19296 </span><span class="lineCov">      10632 :       extended_p = true;</span>
<span class="lineNum">   19297 </span>            : 
<span class="lineNum">   19298 </span><span class="lineCov">      26542 :       /* Look for outputs.  */</span>
<span class="lineNum">   19299 </span><span class="lineCov">      13271 :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_COLON))</span>
<span class="lineNum">   19300 </span><span class="lineCov">      13142 :         {</span>
<span class="lineNum">   19301 </span>            :           /* Consume the `:'.  */
<span class="lineNum">   19302 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   19303 </span><span class="lineCov">         58 :           /* Parse the output-operands.  */</span>
<span class="lineNum">   19304 </span>            :           if (cp_lexer_next_token_is_not (parser-&gt;lexer,
<span class="lineNum">   19305 </span><span class="lineCov">         58 :                                           CPP_COLON)</span>
<span class="lineNum">   19306 </span>            :               &amp;&amp; cp_lexer_next_token_is_not (parser-&gt;lexer,
<span class="lineNum">   19307 </span>            :                                              CPP_SCOPE)
<span class="lineNum">   19308 </span><span class="lineCov">      13271 :               &amp;&amp; cp_lexer_next_token_is_not (parser-&gt;lexer,</span>
<span class="lineNum">   19309 </span>            :                                              CPP_CLOSE_PAREN)
<span class="lineNum">   19310 </span>            :               &amp;&amp; !goto_p)
<span class="lineNum">   19311 </span><span class="lineCov">      13271 :             {</span>
<span class="lineNum">   19312 </span><span class="lineCov">      13271 :               outputs = cp_parser_asm_operand_list (parser);</span>
<span class="lineNum">   19313 </span>            :               if (outputs == error_mark_node)
<span class="lineNum">   19314 </span><span class="lineCov">         66 :                 invalid_outputs_p = true;</span>
<span class="lineNum">   19315 </span>            :             }
<span class="lineNum">   19316 </span><span class="lineCov">         33 :         }</span>
<span class="lineNum">   19317 </span>            :       /* If the next token is `::', there are no outputs, and the
<span class="lineNum">   19318 </span>            :          next token is the beginning of the inputs.  */
<span class="lineNum">   19319 </span>            :       else if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_SCOPE))
<span class="lineNum">   19320 </span>            :         /* The inputs are coming next.  */
<span class="lineNum">   19321 </span>            :         inputs_p = true;
<span class="lineNum">   19322 </span>            : 
<span class="lineNum">   19323 </span>            :       /* Look for inputs.  */
<span class="lineNum">   19324 </span><span class="lineCov">      26476 :       if (inputs_p</span>
<span class="lineNum">   19325 </span><span class="lineCov">      13238 :           || cp_lexer_next_token_is (parser-&gt;lexer, CPP_COLON))</span>
<span class="lineNum">   19326 </span><span class="lineCov">      13109 :         {</span>
<span class="lineNum">   19327 </span><span class="lineCov">       4713 :           /* Consume the `:' or `::'.  */</span>
<span class="lineNum">   19328 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   19329 </span><span class="lineCov">      12608 :           /* Parse the output-operands.  */</span>
<span class="lineNum">   19330 </span><span class="lineCov">      12608 :           if (cp_lexer_next_token_is_not (parser-&gt;lexer,</span>
<span class="lineNum">   19331 </span><span class="lineCov">      12608 :                                           CPP_COLON)</span>
<span class="lineNum">   19332 </span>            :               &amp;&amp; cp_lexer_next_token_is_not (parser-&gt;lexer,
<span class="lineNum">   19333 </span>            :                                              CPP_SCOPE)
<span class="lineNum">   19334 </span><span class="lineCov">      12608 :               &amp;&amp; cp_lexer_next_token_is_not (parser-&gt;lexer,</span>
<span class="lineNum">   19335 </span>            :                                              CPP_CLOSE_PAREN))
<span class="lineNum">   19336 </span>            :             {
<span class="lineNum">   19337 </span><span class="lineCov">      12608 :               inputs = cp_parser_asm_operand_list (parser);</span>
<span class="lineNum">   19338 </span>            :               if (inputs == error_mark_node)
<span class="lineNum">   19339 </span>            :                 invalid_inputs_p = true;
<span class="lineNum">   19340 </span><span class="lineCov">       8396 :             }</span>
<span class="lineNum">   19341 </span>            :         }
<span class="lineNum">   19342 </span><span class="lineCov">      16792 :       else if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_SCOPE))</span>
<span class="lineNum">   19343 </span>            :         /* The clobbers are coming next.  */
<span class="lineNum">   19344 </span><span class="lineCov">       6791 :         clobbers_p = true;</span>
<span class="lineNum">   19345 </span>            : 
<span class="lineNum">   19346 </span><span class="lineCov">       6785 :       /* Look for clobbers.  */</span>
<span class="lineNum">   19347 </span>            :       if (clobbers_p
<span class="lineNum">   19348 </span><span class="lineCov">      15172 :           || cp_lexer_next_token_is (parser-&gt;lexer, CPP_COLON))</span>
<span class="lineNum">   19349 </span>            :         {
<span class="lineNum">   19350 </span><span class="lineCov">       6770 :           clobbers_p = true;</span>
<span class="lineNum">   19351 </span><span class="lineCov">       6770 :           /* Consume the `:' or `::'.  */</span>
<span class="lineNum">   19352 </span><span class="lineCov">          6 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   19353 </span>            :           /* Parse the clobbers.  */
<span class="lineNum">   19354 </span>            :           if (cp_lexer_next_token_is_not (parser-&gt;lexer,
<span class="lineNum">   19355 </span>            :                                           CPP_COLON)
<span class="lineNum">   19356 </span>            :               &amp;&amp; cp_lexer_next_token_is_not (parser-&gt;lexer,
<span class="lineNum">   19357 </span><span class="lineCov">       4212 :                                              CPP_CLOSE_PAREN))</span>
<span class="lineNum">   19358 </span>            :             clobbers = cp_parser_asm_clobber_list (parser);
<span class="lineNum">   19359 </span><span class="lineCov">       4212 :         }</span>
<span class="lineNum">   19360 </span>            :       else if (goto_p
<span class="lineNum">   19361 </span>            :                &amp;&amp; cp_lexer_next_token_is (parser-&gt;lexer, CPP_SCOPE))
<span class="lineNum">   19362 </span><span class="lineCov">      12608 :         /* The labels are coming next.  */</span>
<span class="lineNum">   19363 </span><span class="lineCov">      12608 :         labels_p = true;</span>
<span class="lineNum">   19364 </span>            : 
<span class="lineNum">   19365 </span>            :       /* Look for labels.  */
<span class="lineNum">   19366 </span><span class="lineCov">       9902 :       if (labels_p</span>
<span class="lineNum">   19367 </span>            :           || (goto_p &amp;&amp; cp_lexer_next_token_is (parser-&gt;lexer, CPP_COLON)))
<span class="lineNum">   19368 </span><span class="lineCov">      19804 :         {</span>
<span class="lineNum">   19369 </span>            :           labels_p = true;
<span class="lineNum">   19370 </span><span class="lineCov">       5466 :           /* Consume the `:' or `::'.  */</span>
<span class="lineNum">   19371 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   19372 </span><span class="lineCov">      15368 :           /* Parse the labels.  */</span>
<span class="lineNum">   19373 </span>            :           labels = cp_parser_asm_label_list (parser);
<span class="lineNum">   19374 </span>            :         }
<span class="lineNum">   19375 </span><span class="lineCov">       5448 : </span>
<span class="lineNum">   19376 </span><span class="lineCov">       5448 :       if (goto_p &amp;&amp; !labels_p)</span>
<span class="lineNum">   19377 </span><span class="lineCov">          3 :         missing = clobbers_p ? RT_COLON : RT_COLON_SCOPE;</span>
<span class="lineNum">   19378 </span>            :     }
<span class="lineNum">   19379 </span>            :   else if (goto_p)
<span class="lineNum">   19380 </span><span class="lineCov">       2706 :     missing = RT_COLON_SCOPE;</span>
<span class="lineNum">   19381 </span>            : 
<span class="lineNum">   19382 </span><span class="lineCov">         12 :   /* Look for the closing `)'.  */</span>
<span class="lineNum">   19383 </span>            :   if (!cp_parser_require (parser, missing ? CPP_COLON : CPP_CLOSE_PAREN,
<span class="lineNum">   19384 </span>            :                           missing ? missing : RT_CLOSE_PAREN))
<span class="lineNum">   19385 </span><span class="lineCov">      12608 :     cp_parser_skip_to_closing_parenthesis (parser, true, false,</span>
<span class="lineNum">   19386 </span><span class="lineCov">      12608 :                                            /*consume_paren=*/true);</span>
<span class="lineNum">   19387 </span>            :   cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);
<span class="lineNum">   19388 </span><span class="lineCov">       8111 : </span>
<span class="lineNum">   19389 </span>            :   if (!invalid_inputs_p &amp;&amp; !invalid_outputs_p)
<span class="lineNum">   19390 </span><span class="lineCov">       8111 :     {</span>
<span class="lineNum">   19391 </span>            :       /* Create the ASM_EXPR.  */
<span class="lineNum">   19392 </span><span class="lineCov">      16222 :       if (parser-&gt;in_function_body)</span>
<span class="lineNum">   19393 </span>            :         {
<span class="lineNum">   19394 </span><span class="lineCov">       8111 :           asm_stmt = finish_asm_stmt (volatile_p, string, outputs,</span>
<span class="lineNum">   19395 </span>            :                                       inputs, clobbers, labels);
<span class="lineNum">   19396 </span><span class="lineCov">       8036 :           /* If the extended syntax was not used, mark the ASM_EXPR.  */</span>
<span class="lineNum">   19397 </span>            :           if (!extended_p)
<span class="lineNum">   19398 </span><span class="lineCov">       4497 :             {</span>
<span class="lineNum">   19399 </span><span class="lineCov">       4497 :               tree temp = asm_stmt;</span>
<span class="lineNum">   19400 </span>            :               if (TREE_CODE (temp) == CLEANUP_POINT_EXPR)
<span class="lineNum">   19401 </span>            :                 temp = TREE_OPERAND (temp, 0);
<span class="lineNum">   19402 </span>            : 
<span class="lineNum">   19403 </span>            :               ASM_INPUT_P (temp) = 1;
<span class="lineNum">   19404 </span><span class="lineCov">      12608 :             }</span>
<span class="lineNum">   19405 </span><span class="lineCov">      12608 :         }</span>
<span class="lineNum">   19406 </span>            :       else
<span class="lineNum">   19407 </span><span class="lineCov">         34 :         symtab-&gt;finalize_toplevel_asm (string);</span>
<span class="lineNum">   19408 </span>            :     }
<span class="lineNum">   19409 </span><span class="lineCov">         34 : }</span>
<span class="lineNum">   19410 </span>            : 
<span class="lineNum">   19411 </span><span class="lineCov">         34 : /* Given the type TYPE of a declaration with declarator DECLARATOR, return the</span>
<span class="lineNum">   19412 </span>            :    type that comes from the decl-specifier-seq.  */
<a name="19413"><span class="lineNum">   19413 </span>            : </a>
<span class="lineNum">   19414 </span><span class="lineCov">      12608 : static tree</span>
<span class="lineNum">   19415 </span><span class="lineCov">         21 : strip_declarator_types (tree type, cp_declarator *declarator)</span>
<span class="lineNum">   19416 </span>            : {
<span class="lineNum">   19417 </span><span class="lineCov">        630 :   for (cp_declarator *d = declarator; d;)</span>
<span class="lineNum">   19418 </span><span class="lineCov">          3 :     switch (d-&gt;kind)</span>
<span class="lineNum">   19419 </span>            :       {
<span class="lineNum">   19420 </span>            :       case cdk_id:
<span class="lineNum">   19421 </span><span class="lineCov">      26476 :       case cdk_decomp:</span>
<span class="lineNum">   19422 </span>            :       case cdk_error:
<span class="lineNum">   19423 </span><span class="lineCov">         36 :         d = NULL;</span>
<span class="lineNum">   19424 </span>            :         break;
<span class="lineNum">   19425 </span><span class="lineCov">      13238 : </span>
<span class="lineNum">   19426 </span>            :       default:
<span class="lineNum">   19427 </span><span class="lineCov">      13238 :         if (TYPE_PTRMEMFUNC_P (type))</span>
<span class="lineNum">   19428 </span>            :           type = TYPE_PTRMEMFUNC_FN_TYPE (type);
<span class="lineNum">   19429 </span>            :         type = TREE_TYPE (type);
<span class="lineNum">   19430 </span><span class="lineCov">      13229 :         d = d-&gt;declarator;</span>
<span class="lineNum">   19431 </span>            :         break;
<span class="lineNum">   19432 </span><span class="lineCov">      13100 :       }</span>
<span class="lineNum">   19433 </span>            : 
<span class="lineNum">   19434 </span>            :   return type;
<span class="lineNum">   19435 </span><span class="lineCov">      13100 : }</span>
<span class="lineNum">   19436 </span>            : 
<span class="lineNum">   19437 </span><span class="lineCov">        501 : /* Declarators [gram.dcl.decl] */</span>
<span class="lineNum">   19438 </span><span class="lineCov">        501 : </span>
<span class="lineNum">   19439 </span><span class="lineCov">        483 : /* Parse an init-declarator.</span>
<span class="lineNum">   19440 </span>            : 
<span class="lineNum">   19441 </span><span class="lineCov">        501 :    init-declarator:</span>
<span class="lineNum">   19442 </span>            :      declarator initializer [opt]
<span class="lineNum">   19443 </span>            : 
<span class="lineNum">   19444 </span>            :    GNU Extension:
<span class="lineNum">   19445 </span><span class="lineCov">        129 : </span>
<span class="lineNum">   19446 </span>            :    init-declarator:
<span class="lineNum">   19447 </span>            :      declarator asm-specification [opt] attributes [opt] initializer [opt]
<span class="lineNum">   19448 </span>            : 
<span class="lineNum">   19449 </span>            :    function-definition:
<span class="lineNum">   19450 </span>            :      decl-specifier-seq [opt] declarator ctor-initializer [opt]
<span class="lineNum">   19451 </span>            :        function-body
<span class="lineNum">   19452 </span>            :      decl-specifier-seq [opt] declarator function-try-block
<span class="lineNum">   19453 </span><span class="lineCov">      61781 : </span>
<span class="lineNum">   19454 </span>            :    GNU Extension:
<span class="lineNum">   19455 </span><span class="lineCov">      67042 : </span>
<span class="lineNum">   19456 </span><span class="lineCov">      67042 :    function-definition:</span>
<span class="lineNum">   19457 </span>            :      __extension__ function-definition
<span class="lineNum">   19458 </span>            : 
<span class="lineNum">   19459 </span>            :    TM Extension:
<span class="lineNum">   19460 </span>            : 
<span class="lineNum">   19461 </span>            :    function-definition:
<span class="lineNum">   19462 </span>            :      decl-specifier-seq [opt] declarator function-transaction-block
<span class="lineNum">   19463 </span>            : 
<span class="lineNum">   19464 </span><span class="lineCov">       5261 :    The DECL_SPECIFIERS apply to this declarator.  Returns a</span>
<span class="lineNum">   19465 </span><span class="lineCov">       5261 :    representation of the entity declared.  If MEMBER_P is TRUE, then</span>
<span class="lineNum">   19466 </span><span class="lineCov">          2 :    this declarator appears in a class scope.  The new DECL created by</span>
<span class="lineNum">   19467 </span><span class="lineCov">       5261 :    this declarator is returned.</span>
<span class="lineNum">   19468 </span><span class="lineCov">       5261 : </span>
<span class="lineNum">   19469 </span><span class="lineCov">       5261 :    The CHECKS are access checks that should be performed once we know</span>
<span class="lineNum">   19470 </span>            :    what entity is being declared (and, therefore, what classes have
<span class="lineNum">   19471 </span>            :    befriended it).
<span class="lineNum">   19472 </span><span class="lineCov">      61781 : </span>
<span class="lineNum">   19473 </span>            :    If FUNCTION_DEFINITION_ALLOWED_P then we handle the declarator and
<span class="lineNum">   19474 </span>            :    for a function-definition here as well.  If the declarator is a
<span class="lineNum">   19475 </span>            :    declarator for a function-definition, *FUNCTION_DEFINITION_P will
<span class="lineNum">   19476 </span>            :    be TRUE upon return.  By that point, the function-definition will
<span class="lineNum">   19477 </span>            :    have been completely parsed.
<span class="lineNum">   19478 </span>            : 
<span class="lineNum">   19479 </span>            :    FUNCTION_DEFINITION_P may be NULL if FUNCTION_DEFINITION_ALLOWED_P
<span class="lineNum">   19480 </span>            :    is FALSE.
<span class="lineNum">   19481 </span>            : 
<span class="lineNum">   19482 </span>            :    If MAYBE_RANGE_FOR_DECL is not NULL, the pointed tree will be set to the
<span class="lineNum">   19483 </span>            :    parsed declaration if it is an uninitialized single declarator not followed
<span class="lineNum">   19484 </span>            :    by a `;', or to error_mark_node otherwise. Either way, the trailing `;',
<span class="lineNum">   19485 </span>            :    if present, will not be consumed.  If returned, this declarator will be
<span class="lineNum">   19486 </span>            :    created with SD_INITIALIZED but will not call cp_finish_decl.
<span class="lineNum">   19487 </span>            : 
<span class="lineNum">   19488 </span>            :    If INIT_LOC is not NULL, and *INIT_LOC is equal to UNKNOWN_LOCATION,
<span class="lineNum">   19489 </span>            :    and there is an initializer, the pointed location_t is set to the
<span class="lineNum">   19490 </span>            :    location of the '=' or `(', or '{' in C++11 token introducing the
<span class="lineNum">   19491 </span>            :    initializer.  */
<a name="19492"><span class="lineNum">   19492 </span>            : </a>
<span class="lineNum">   19493 </span>            : static tree
<span class="lineNum">   19494 </span>            : cp_parser_init_declarator (cp_parser* parser,
<span class="lineNum">   19495 </span>            :                            cp_decl_specifier_seq *decl_specifiers,
<span class="lineNum">   19496 </span>            :                            vec&lt;deferred_access_check, va_gc&gt; *checks,
<span class="lineNum">   19497 </span>            :                            bool function_definition_allowed_p,
<span class="lineNum">   19498 </span>            :                            bool member_p,
<span class="lineNum">   19499 </span>            :                            int declares_class_or_enum,
<span class="lineNum">   19500 </span>            :                            bool* function_definition_p,
<span class="lineNum">   19501 </span>            :                            tree* maybe_range_for_decl,
<span class="lineNum">   19502 </span>            :                            location_t* init_loc,
<span class="lineNum">   19503 </span>            :                            tree* auto_result)
<span class="lineNum">   19504 </span>            : {
<span class="lineNum">   19505 </span>            :   cp_token *token = NULL, *asm_spec_start_token = NULL,
<span class="lineNum">   19506 </span>            :            *attributes_start_token = NULL;
<span class="lineNum">   19507 </span>            :   cp_declarator *declarator;
<span class="lineNum">   19508 </span>            :   tree prefix_attributes;
<span class="lineNum">   19509 </span>            :   tree attributes = NULL;
<span class="lineNum">   19510 </span>            :   tree asm_specification;
<span class="lineNum">   19511 </span>            :   tree initializer;
<span class="lineNum">   19512 </span>            :   tree decl = NULL_TREE;
<span class="lineNum">   19513 </span>            :   tree scope;
<span class="lineNum">   19514 </span>            :   int is_initialized;
<span class="lineNum">   19515 </span>            :   /* Only valid if IS_INITIALIZED is true.  In that case, CPP_EQ if
<span class="lineNum">   19516 </span>            :      initialized with &quot;= ..&quot;, CPP_OPEN_PAREN if initialized with
<span class="lineNum">   19517 </span>            :      &quot;(...)&quot;.  */
<span class="lineNum">   19518 </span>            :   enum cpp_ttype initialization_kind;
<span class="lineNum">   19519 </span>            :   bool is_direct_init = false;
<span class="lineNum">   19520 </span>            :   bool is_non_constant_init;
<span class="lineNum">   19521 </span>            :   int ctor_dtor_or_conv_p;
<span class="lineNum">   19522 </span>            :   bool friend_p = cp_parser_friend_p (decl_specifiers);
<span class="lineNum">   19523 </span>            :   tree pushed_scope = NULL_TREE;
<span class="lineNum">   19524 </span>            :   bool range_for_decl_p = false;
<span class="lineNum">   19525 </span>            :   bool saved_default_arg_ok_p = parser-&gt;default_arg_ok_p;
<span class="lineNum">   19526 </span>            :   location_t tmp_init_loc = UNKNOWN_LOCATION;
<span class="lineNum">   19527 </span>            : 
<span class="lineNum">   19528 </span>            :   /* Gather the attributes that were provided with the
<span class="lineNum">   19529 </span>            :      decl-specifiers.  */
<span class="lineNum">   19530 </span>            :   prefix_attributes = decl_specifiers-&gt;attributes;
<span class="lineNum">   19531 </span>            : 
<span class="lineNum">   19532 </span><span class="lineCov">   10170317 :   /* Assume that this is not the declarator for a function</span>
<span class="lineNum">   19533 </span>            :      definition.  */
<span class="lineNum">   19534 </span>            :   if (function_definition_p)
<span class="lineNum">   19535 </span>            :     *function_definition_p = false;
<span class="lineNum">   19536 </span>            : 
<span class="lineNum">   19537 </span>            :   /* Default arguments are only permitted for function parameters.  */
<span class="lineNum">   19538 </span>            :   if (decl_spec_seq_has_spec_p (decl_specifiers, ds_typedef))
<span class="lineNum">   19539 </span>            :     parser-&gt;default_arg_ok_p = false;
<span class="lineNum">   19540 </span>            : 
<span class="lineNum">   19541 </span>            :   /* Defer access checks while parsing the declarator; we cannot know
<span class="lineNum">   19542 </span>            :      what names are accessible until we know what is being
<span class="lineNum">   19543 </span><span class="lineCov">   10170317 :      declared.  */</span>
<span class="lineNum">   19544 </span><span class="lineCov">   10170317 :   resume_deferring_access_checks ();</span>
<span class="lineNum">   19545 </span><span class="lineCov">   10170317 : </span>
<span class="lineNum">   19546 </span><span class="lineCov">   10170317 :   token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   19547 </span><span class="lineCov">   10170317 : </span>
<span class="lineNum">   19548 </span><span class="lineCov">   10170317 :   /* Parse the declarator.  */</span>
<span class="lineNum">   19549 </span><span class="lineCov">   10170317 :   declarator</span>
<span class="lineNum">   19550 </span><span class="lineCov">   10170317 :     = cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,</span>
<span class="lineNum">   19551 </span><span class="lineCov">   10170317 :                             &amp;ctor_dtor_or_conv_p,</span>
<span class="lineNum">   19552 </span><span class="lineCov">   10170317 :                             /*parenthesized_p=*/NULL,</span>
<span class="lineNum">   19553 </span>            :                             member_p, friend_p);
<span class="lineNum">   19554 </span>            :   /* Gather up the deferred checks.  */
<span class="lineNum">   19555 </span>            :   stop_deferring_access_checks ();
<span class="lineNum">   19556 </span><span class="lineCov">   10170317 : </span>
<span class="lineNum">   19557 </span><span class="lineCov">   10170317 :   parser-&gt;default_arg_ok_p = saved_default_arg_ok_p;</span>
<span class="lineNum">   19558 </span><span class="lineCov">   10170317 : </span>
<span class="lineNum">   19559 </span><span class="lineCov">   10170317 :   /* If the DECLARATOR was erroneous, there's no need to go</span>
<span class="lineNum">   19560 </span><span class="lineCov">   20340634 :      further.  */</span>
<span class="lineNum">   19561 </span><span class="lineCov">   10170317 :   if (declarator == cp_error_declarator)</span>
<span class="lineNum">   19562 </span><span class="lineCov">   10170317 :     return error_mark_node;</span>
<span class="lineNum">   19563 </span><span class="lineCov">   10170317 : </span>
<span class="lineNum">   19564 </span><span class="lineCov">   10170317 :   /* Check that the number of template-parameter-lists is OK.  */</span>
<span class="lineNum">   19565 </span>            :   if (!cp_parser_check_declarator_template_parameters (parser, declarator,
<span class="lineNum">   19566 </span>            :                                                        token-&gt;location))
<span class="lineNum">   19567 </span>            :     return error_mark_node;
<span class="lineNum">   19568 </span><span class="lineCov">   10170317 : </span>
<span class="lineNum">   19569 </span>            :   if (declares_class_or_enum &amp; 2)
<span class="lineNum">   19570 </span>            :     cp_parser_check_for_definition_in_return_type (declarator,
<span class="lineNum">   19571 </span>            :                                                    decl_specifiers-&gt;type,
<span class="lineNum">   19572 </span><span class="lineCov">   10170317 :                                                    decl_specifiers-&gt;locations[ds_type_spec]);</span>
<span class="lineNum">   19573 </span><span class="lineCov">   10170317 : </span>
<span class="lineNum">   19574 </span>            :   /* Figure out what scope the entity declared by the DECLARATOR is
<span class="lineNum">   19575 </span>            :      located in.  `grokdeclarator' sometimes changes the scope, so
<span class="lineNum">   19576 </span><span class="lineCov">   10170317 :      we compute it now.  */</span>
<span class="lineNum">   19577 </span><span class="lineCov">    1074867 :   scope = get_scope_of_declarator (declarator);</span>
<span class="lineNum">   19578 </span>            : 
<span class="lineNum">   19579 </span>            :   /* Perform any lookups in the declared type which were thought to be
<span class="lineNum">   19580 </span>            :      dependent, but are not in the scope of the declarator.  */
<span class="lineNum">   19581 </span>            :   decl_specifiers-&gt;type
<span class="lineNum">   19582 </span><span class="lineCov">   10170317 :     = maybe_update_decl_type (decl_specifiers-&gt;type, scope);</span>
<span class="lineNum">   19583 </span>            : 
<span class="lineNum">   19584 </span><span class="lineCov">   20340634 :   /* If we're allowing GNU extensions, look for an</span>
<span class="lineNum">   19585 </span>            :      asm-specification.  */
<span class="lineNum">   19586 </span>            :   if (cp_parser_allow_gnu_extensions_p (parser))
<span class="lineNum">   19587 </span><span class="lineCov">   10170317 :     {</span>
<span class="lineNum">   19588 </span><span class="lineCov">   10170317 :       /* Look for an asm-specification.  */</span>
<span class="lineNum">   19589 </span>            :       asm_spec_start_token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   19590 </span>            :       asm_specification = cp_parser_asm_specification_opt (parser);
<span class="lineNum">   19591 </span>            :     }
<span class="lineNum">   19592 </span>            :   else
<span class="lineNum">   19593 </span><span class="lineCov">   10170317 :     asm_specification = NULL_TREE;</span>
<span class="lineNum">   19594 </span>            : 
<span class="lineNum">   19595 </span><span class="lineCov">   10170317 :   /* Look for attributes.  */</span>
<span class="lineNum">   19596 </span>            :   attributes_start_token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   19597 </span>            :   attributes = cp_parser_attributes_opt (parser);
<span class="lineNum">   19598 </span>            : 
<span class="lineNum">   19599 </span><span class="lineCov">   10170317 :   /* Peek at the next token.  */</span>
<span class="lineNum">   19600 </span><span class="lineCov">      15351 :   token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   19601 </span>            : 
<span class="lineNum">   19602 </span>            :   bool bogus_implicit_tmpl = false;
<span class="lineNum">   19603 </span><span class="lineCov">   10154966 : </span>
<span class="lineNum">   19604 </span>            :   if (function_declarator_p (declarator))
<span class="lineNum">   19605 </span><span class="lineCov">         27 :     {</span>
<span class="lineNum">   19606 </span>            :       /* Handle C++17 deduction guides.  */
<span class="lineNum">   19607 </span><span class="lineCov">   10154939 :       if (!decl_specifiers-&gt;type</span>
<span class="lineNum">   19608 </span><span class="lineCov">      73000 :           &amp;&amp; ctor_dtor_or_conv_p &lt;= 0</span>
<span class="lineNum">   19609 </span>            :           &amp;&amp; cxx_dialect &gt;= cxx17)
<span class="lineNum">   19610 </span>            :         {
<span class="lineNum">   19611 </span>            :           cp_declarator *id = get_id_declarator (declarator);
<span class="lineNum">   19612 </span>            :           tree name = id-&gt;u.id.unqualified_name;
<span class="lineNum">   19613 </span>            :           parser-&gt;scope = id-&gt;u.id.qualifying_scope;
<span class="lineNum">   19614 </span>            :           tree tmpl = cp_parser_lookup_name_simple (parser, name, id-&gt;id_loc);
<span class="lineNum">   19615 </span><span class="lineCov">   10154939 :           if (tmpl</span>
<span class="lineNum">   19616 </span>            :               &amp;&amp; (DECL_CLASS_TEMPLATE_P (tmpl)
<span class="lineNum">   19617 </span>            :                   || DECL_TEMPLATE_TEMPLATE_PARM_P (tmpl)))
<span class="lineNum">   19618 </span>            :             {
<span class="lineNum">   19619 </span><span class="lineCov">   10154939 :               id-&gt;u.id.unqualified_name = dguide_name (tmpl);</span>
<span class="lineNum">   19620 </span><span class="lineCov">   10154939 :               id-&gt;u.id.sfk = sfk_deduction_guide;</span>
<span class="lineNum">   19621 </span>            :               ctor_dtor_or_conv_p = 1;
<span class="lineNum">   19622 </span>            :             }
<span class="lineNum">   19623 </span>            :         }
<span class="lineNum">   19624 </span><span class="lineCov">   20309878 : </span>
<span class="lineNum">   19625 </span>            :       /* Check to see if the token indicates the start of a
<span class="lineNum">   19626 </span>            :          function-definition.  */
<span class="lineNum">   19627 </span><span class="lineCov">   20309878 :       if (cp_parser_token_starts_function_definition_p (token))</span>
<span class="lineNum">   19628 </span><span class="lineCov">   10154939 :         {</span>
<span class="lineNum">   19629 </span>            :           if (!function_definition_allowed_p)
<span class="lineNum">   19630 </span>            :             {
<span class="lineNum">   19631 </span>            :               /* If a function-definition should not appear here, issue an
<span class="lineNum">   19632 </span>            :                  error message.  */
<span class="lineNum">   19633 </span>            :               cp_parser_error (parser,
<span class="lineNum">   19634 </span><span class="lineCov">   20309878 :                                &quot;a function-definition is not allowed here&quot;);</span>
<span class="lineNum">   19635 </span><span class="lineCov">   10154939 :               return error_mark_node;</span>
<span class="lineNum">   19636 </span>            :             }
<span class="lineNum">   19637 </span>            : 
<span class="lineNum">   19638 </span><span class="lineCov">   20309878 :           location_t func_brace_location</span>
<span class="lineNum">   19639 </span>            :             = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">   19640 </span><span class="lineCov">   10154939 : </span>
<span class="lineNum">   19641 </span>            :           /* Neither attributes nor an asm-specification are allowed
<span class="lineNum">   19642 </span><span class="lineCov">   10154939 :              on a function-definition.  */</span>
<span class="lineNum">   19643 </span>            :           if (asm_specification)
<span class="lineNum">   19644 </span>            :             error_at (asm_spec_start_token-&gt;location,
<span class="lineNum">   19645 </span><span class="lineCov">    6497918 :                       &quot;an asm-specification is not allowed &quot;</span>
<span class="lineNum">   19646 </span><span class="lineCov">     289275 :                       &quot;on a function-definition&quot;);</span>
<span class="lineNum">   19647 </span><span class="lineCov">      59021 :           if (attributes)</span>
<span class="lineNum">   19648 </span>            :             error_at (attributes_start_token-&gt;location,
<span class="lineNum">   19649 </span><span class="lineCov">      13944 :                       &quot;attributes are not allowed &quot;</span>
<span class="lineNum">   19650 </span><span class="lineCov">      13944 :                       &quot;on a function-definition&quot;);</span>
<span class="lineNum">   19651 </span><span class="lineCov">      13944 :           /* This is a function-definition.  */</span>
<span class="lineNum">   19652 </span><span class="lineCov">      27888 :           *function_definition_p = true;</span>
<span class="lineNum">   19653 </span><span class="lineCov">      13944 : </span>
<span class="lineNum">   19654 </span><span class="lineCov">      13944 :           /* Parse the function definition.  */</span>
<span class="lineNum">   19655 </span><span class="lineCov">       7342 :           if (member_p)</span>
<span class="lineNum">   19656 </span>            :             decl = cp_parser_save_member_function_body (parser,
<span class="lineNum">   19657 </span><span class="lineCov">       6603 :                                                         decl_specifiers,</span>
<span class="lineNum">   19658 </span><span class="lineCov">       6603 :                                                         declarator,</span>
<span class="lineNum">   19659 </span><span class="lineCov">       6603 :                                                         prefix_attributes);</span>
<span class="lineNum">   19660 </span>            :           else
<span class="lineNum">   19661 </span>            :             decl =
<span class="lineNum">   19662 </span>            :               (cp_parser_function_definition_from_specifiers_and_declarator
<span class="lineNum">   19663 </span>            :                (parser, decl_specifiers, prefix_attributes, declarator));
<span class="lineNum">   19664 </span>            : 
<span class="lineNum">   19665 </span><span class="lineCov">    6497918 :           if (decl != error_mark_node &amp;&amp; DECL_STRUCT_FUNCTION (decl))</span>
<span class="lineNum">   19666 </span>            :             {
<span class="lineNum">   19667 </span><span class="lineCov">    3161583 :               /* This is where the prologue starts...  */</span>
<span class="lineNum">   19668 </span>            :               DECL_STRUCT_FUNCTION (decl)-&gt;function_start_locus
<span class="lineNum">   19669 </span>            :                 = func_brace_location;
<span class="lineNum">   19670 </span>            :             }
<span class="lineNum">   19671 </span><span class="lineCov">          4 : </span>
<span class="lineNum">   19672 </span>            :           return decl;
<span class="lineNum">   19673 </span><span class="lineCov">          4 :         }</span>
<span class="lineNum">   19674 </span>            :     }
<span class="lineNum">   19675 </span>            :   else if (parser-&gt;fully_implicit_function_template_p)
<span class="lineNum">   19676 </span><span class="lineCov">    3161579 :     {</span>
<span class="lineNum">   19677 </span><span class="lineCov">    6323158 :       /* A non-template declaration involving a function parameter list</span>
<span class="lineNum">   19678 </span>            :          containing an implicit template parameter will be made into a
<span class="lineNum">   19679 </span>            :          template.  If the resulting declaration is not going to be an
<span class="lineNum">   19680 </span>            :          actual function then finish the template scope here to prevent it.
<span class="lineNum">   19681 </span><span class="lineCov">    3161579 :          An error message will be issued once we have a decl to talk about.</span>
<span class="lineNum">   19682 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   19683 </span>            :          FIXME probably we should do type deduction rather than create an
<span class="lineNum">   19684 </span>            :          implicit template, but the standard currently doesn't allow it. */
<span class="lineNum">   19685 </span><span class="lineCov">    3161579 :       bogus_implicit_tmpl = true;</span>
<span class="lineNum">   19686 </span><span class="lineNoCov">          0 :       finish_fully_implicit_template (parser, NULL_TREE);</span>
<span class="lineNum">   19687 </span>            :     }
<span class="lineNum">   19688 </span>            : 
<span class="lineNum">   19689 </span>            :   /* [dcl.dcl]
<span class="lineNum">   19690 </span><span class="lineCov">    3161579 : </span>
<span class="lineNum">   19691 </span>            :      Only in function declarations for constructors, destructors, type
<span class="lineNum">   19692 </span>            :      conversions, and deduction guides can the decl-specifier-seq be omitted.
<span class="lineNum">   19693 </span><span class="lineCov">    3161579 : </span>
<span class="lineNum">   19694 </span><span class="lineCov">     553263 :      We explicitly postpone this check past the point where we handle</span>
<span class="lineNum">   19695 </span>            :      function-definitions because we tolerate function-definitions
<span class="lineNum">   19696 </span>            :      that are missing their return types in some modes.  */
<span class="lineNum">   19697 </span>            :   if (!decl_specifiers-&gt;any_specifiers_p &amp;&amp; ctor_dtor_or_conv_p &lt;= 0)
<span class="lineNum">   19698 </span>            :     {
<span class="lineNum">   19699 </span><span class="lineCov">    5216632 :       cp_parser_error (parser,</span>
<span class="lineNum">   19700 </span>            :                        &quot;expected constructor, destructor, or type conversion&quot;);
<span class="lineNum">   19701 </span><span class="lineCov">    2608316 :       return error_mark_node;</span>
<span class="lineNum">   19702 </span>            :     }
<span class="lineNum">   19703 </span><span class="lineCov">    3161560 : </span>
<span class="lineNum">   19704 </span>            :   /* An `=' or an `(', or an '{' in C++0x, indicates an initializer.  */
<span class="lineNum">   19705 </span>            :   if (token-&gt;type == CPP_EQ
<span class="lineNum">   19706 </span><span class="lineCov">    2608090 :       || token-&gt;type == CPP_OPEN_PAREN</span>
<span class="lineNum">   19707 </span><span class="lineCov">    2608090 :       || token-&gt;type == CPP_OPEN_BRACE)</span>
<span class="lineNum">   19708 </span>            :     {
<span class="lineNum">   19709 </span>            :       is_initialized = SD_INITIALIZED;
<span class="lineNum">   19710 </span><span class="lineCov">    3161560 :       initialization_kind = token-&gt;type;</span>
<span class="lineNum">   19711 </span>            :       if (maybe_range_for_decl)
<span class="lineNum">   19712 </span>            :         *maybe_range_for_decl = error_mark_node;
<span class="lineNum">   19713 </span><span class="lineCov">    3657021 :       tmp_init_loc = token-&gt;location;</span>
<span class="lineNum">   19714 </span>            :       if (init_loc &amp;&amp; *init_loc == UNKNOWN_LOCATION)
<span class="lineNum">   19715 </span>            :         *init_loc = tmp_init_loc;
<span class="lineNum">   19716 </span>            : 
<span class="lineNum">   19717 </span>            :       if (token-&gt;type == CPP_EQ
<span class="lineNum">   19718 </span>            :           &amp;&amp; function_declarator_p (declarator))
<span class="lineNum">   19719 </span>            :         {
<span class="lineNum">   19720 </span>            :           cp_token *t2 = cp_lexer_peek_nth_token (parser-&gt;lexer, 2);
<span class="lineNum">   19721 </span>            :           if (t2-&gt;keyword == RID_DEFAULT)
<span class="lineNum">   19722 </span>            :             is_initialized = SD_DEFAULTED;
<span class="lineNum">   19723 </span><span class="lineCov">          2 :           else if (t2-&gt;keyword == RID_DELETE)</span>
<span class="lineNum">   19724 </span><span class="lineCov">          2 :             is_initialized = SD_DELETED;</span>
<span class="lineNum">   19725 </span>            :         }
<span class="lineNum">   19726 </span>            :     }
<span class="lineNum">   19727 </span>            :   else
<span class="lineNum">   19728 </span>            :     {
<span class="lineNum">   19729 </span>            :       /* If the init-declarator isn't initialized and isn't followed by a
<span class="lineNum">   19730 </span>            :          `,' or `;', it's not a valid init-declarator.  */
<span class="lineNum">   19731 </span>            :       if (token-&gt;type != CPP_COMMA
<span class="lineNum">   19732 </span>            :           &amp;&amp; token-&gt;type != CPP_SEMICOLON)
<span class="lineNum">   19733 </span>            :         {
<span class="lineNum">   19734 </span>            :           if (maybe_range_for_decl &amp;&amp; *maybe_range_for_decl != error_mark_node)
<span class="lineNum">   19735 </span><span class="lineCov">    6993356 :             range_for_decl_p = true;</span>
<span class="lineNum">   19736 </span>            :           else
<span class="lineNum">   19737 </span><span class="lineCov">         18 :             {</span>
<span class="lineNum">   19738 </span>            :               if (!maybe_range_for_decl)
<span class="lineNum">   19739 </span><span class="lineCov">         18 :                 cp_parser_error (parser, &quot;expected initializer&quot;);</span>
<span class="lineNum">   19740 </span>            :               return error_mark_node;
<span class="lineNum">   19741 </span>            :             }
<span class="lineNum">   19742 </span>            :         }
<span class="lineNum">   19743 </span><span class="lineCov">    6993338 :       is_initialized = SD_UNINITIALIZED;</span>
<span class="lineNum">   19744 </span><span class="lineCov">    5226024 :       initialization_kind = CPP_EOF;</span>
<span class="lineNum">   19745 </span><span class="lineCov">    5098322 :     }</span>
<span class="lineNum">   19746 </span>            : 
<span class="lineNum">   19747 </span><span class="lineCov">    1908118 :   /* Because start_decl has side-effects, we should only call it if we</span>
<span class="lineNum">   19748 </span><span class="lineCov">    1908118 :      know we're going ahead.  By this point, we know that we cannot</span>
<span class="lineNum">   19749 </span><span class="lineCov">    1908118 :      possibly be looking at any other construct.  */</span>
<span class="lineNum">   19750 </span><span class="lineCov">     100565 :   cp_parser_commit_to_tentative_parse (parser);</span>
<span class="lineNum">   19751 </span><span class="lineCov">    1908118 : </span>
<span class="lineNum">   19752 </span><span class="lineCov">    1908118 :   /* Enter the newly declared entry in the symbol table.  If we're</span>
<span class="lineNum">   19753 </span><span class="lineCov">    1822310 :      processing a declaration in a class-specifier, we wait until</span>
<span class="lineNum">   19754 </span>            :      after processing the initializer.  */
<span class="lineNum">   19755 </span><span class="lineCov">    1908118 :   if (!member_p)</span>
<span class="lineNum">   19756 </span><span class="lineCov">    1908118 :     {</span>
<span class="lineNum">   19757 </span>            :       if (parser-&gt;in_unbraced_linkage_specification_p)
<span class="lineNum">   19758 </span><span class="lineCov">      16528 :         decl_specifiers-&gt;storage_class = sc_extern;</span>
<span class="lineNum">   19759 </span><span class="lineCov">      16528 :       decl = start_decl (declarator, decl_specifiers,</span>
<span class="lineNum">   19760 </span>            :                          range_for_decl_p? SD_INITIALIZED : is_initialized,
<span class="lineNum">   19761 </span><span class="lineCov">      14999 :                          attributes, prefix_attributes, &amp;pushed_scope);</span>
<span class="lineNum">   19762 </span><span class="lineCov">      14981 :       cp_finalize_omp_declare_simd (parser, decl);</span>
<span class="lineNum">   19763 </span>            :       cp_finalize_oacc_routine (parser, decl, false);
<span class="lineNum">   19764 </span>            :       /* Adjust location of decl if declarator-&gt;id_loc is more appropriate:
<span class="lineNum">   19765 </span>            :          set, and decl wasn't merged with another decl, in which case its
<span class="lineNum">   19766 </span>            :          location would be different from input_location, and more accurate.  */
<span class="lineNum">   19767 </span>            :       if (DECL_P (decl)
<span class="lineNum">   19768 </span>            :           &amp;&amp; declarator-&gt;id_loc != UNKNOWN_LOCATION
<span class="lineNum">   19769 </span><span class="lineCov">    5085220 :           &amp;&amp; DECL_SOURCE_LOCATION (decl) == input_location)</span>
<span class="lineNum">   19770 </span><span class="lineCov">    5020333 :         DECL_SOURCE_LOCATION (decl) = declarator-&gt;id_loc;</span>
<span class="lineNum">   19771 </span>            :     }
<span class="lineNum">   19772 </span><span class="lineCov">       5145 :   else if (scope)</span>
<span class="lineNum">   19773 </span>            :     /* Enter the SCOPE.  That way unqualified names appearing in the
<span class="lineNum">   19774 </span>            :        initializer will be looked up in SCOPE.  */
<span class="lineNum">   19775 </span>            :     pushed_scope = push_scope (scope);
<span class="lineNum">   19776 </span><span class="lineCov">       2865 : </span>
<span class="lineNum">   19777 </span><span class="lineCov">       2861 :   /* Perform deferred access control checks, now that we know in which</span>
<span class="lineNum">   19778 </span><span class="lineCov">       2865 :      SCOPE the declared entity resides.  */</span>
<span class="lineNum">   19779 </span>            :   if (!member_p &amp;&amp; decl)
<span class="lineNum">   19780 </span>            :     {
<span class="lineNum">   19781 </span>            :       tree saved_current_function_decl = NULL_TREE;
<span class="lineNum">   19782 </span>            : 
<span class="lineNum">   19783 </span>            :       /* If the entity being declared is a function, pretend that we
<span class="lineNum">   19784 </span>            :          are in its scope.  If it is a `friend', it may have access to
<span class="lineNum">   19785 </span>            :          things that would not otherwise be accessible.  */
<span class="lineNum">   19786 </span>            :       if (TREE_CODE (decl) == FUNCTION_DECL)
<span class="lineNum">   19787 </span>            :         {
<span class="lineNum">   19788 </span><span class="lineCov">    6990473 :           saved_current_function_decl = current_function_decl;</span>
<span class="lineNum">   19789 </span>            :           current_function_decl = decl;
<span class="lineNum">   19790 </span>            :         }
<span class="lineNum">   19791 </span>            : 
<span class="lineNum">   19792 </span>            :       /* Perform access checks for template parameters.  */
<span class="lineNum">   19793 </span><span class="lineCov">    6990473 :       cp_parser_perform_template_parameter_access_checks (checks);</span>
<span class="lineNum">   19794 </span>            : 
<span class="lineNum">   19795 </span><span class="lineCov">    6817311 :       /* Perform the access control checks for the declarator and the</span>
<span class="lineNum">   19796 </span><span class="lineCov">      39228 :          decl-specifiers.  */</span>
<span class="lineNum">   19797 </span><span class="lineCov">   13632342 :       perform_deferred_access_checks (tf_warning_or_error);</span>
<span class="lineNum">   19798 </span>            : 
<span class="lineNum">   19799 </span>            :       /* Restore the saved value.  */
<span class="lineNum">   19800 </span><span class="lineCov">    6817308 :       if (TREE_CODE (decl) == FUNCTION_DECL)</span>
<span class="lineNum">   19801 </span><span class="lineCov">    6817308 :         current_function_decl = saved_current_function_decl;</span>
<span class="lineNum">   19802 </span>            :     }
<span class="lineNum">   19803 </span>            : 
<span class="lineNum">   19804 </span>            :   /* Parse the initializer.  */
<span class="lineNum">   19805 </span><span class="lineCov">    6817308 :   initializer = NULL_TREE;</span>
<span class="lineNum">   19806 </span><span class="lineCov">    6815286 :   is_direct_init = false;</span>
<span class="lineNum">   19807 </span><span class="lineCov">   13628816 :   is_non_constant_init = true;</span>
<span class="lineNum">   19808 </span><span class="lineCov">    7133672 :   if (is_initialized)</span>
<span class="lineNum">   19809 </span>            :     {
<span class="lineNum">   19810 </span><span class="lineCov">     173162 :       if (function_declarator_p (declarator))</span>
<span class="lineNum">   19811 </span>            :         {
<span class="lineNum">   19812 </span>            :            if (initialization_kind == CPP_EQ)
<span class="lineNum">   19813 </span><span class="lineCov">       2202 :              initializer = cp_parser_pure_specifier (parser);</span>
<span class="lineNum">   19814 </span>            :            else
<span class="lineNum">   19815 </span>            :              {
<span class="lineNum">   19816 </span>            :                /* If the declaration was erroneous, we don't really
<span class="lineNum">   19817 </span><span class="lineCov">    6990470 :                   know what the user intended, so just silently</span>
<span class="lineNum">   19818 </span>            :                   consume the initializer.  */
<span class="lineNum">   19819 </span><span class="lineCov">    6817308 :                if (decl != error_mark_node)</span>
<span class="lineNum">   19820 </span>            :                  error_at (tmp_init_loc, &quot;initializer provided for function&quot;);
<span class="lineNum">   19821 </span>            :                cp_parser_skip_to_closing_parenthesis (parser,
<span class="lineNum">   19822 </span>            :                                                       /*recovering=*/true,
<span class="lineNum">   19823 </span>            :                                                       /*or_comma=*/false,
<span class="lineNum">   19824 </span><span class="lineCov">    6817308 :                                                       /*consume_paren=*/true);</span>
<span class="lineNum">   19825 </span>            :              }
<span class="lineNum">   19826 </span><span class="lineCov">    3205676 :         }</span>
<span class="lineNum">   19827 </span><span class="lineCov">    3205676 :       else</span>
<span class="lineNum">   19828 </span>            :         {
<span class="lineNum">   19829 </span>            :           /* We want to record the extra mangling scope for in-class
<span class="lineNum">   19830 </span>            :              initializers of class members and initializers of static data
<span class="lineNum">   19831 </span><span class="lineCov">   13634616 :              member templates.  The former involves deferring</span>
<span class="lineNum">   19832 </span>            :              parsing of the initializer until end of class as with default
<span class="lineNum">   19833 </span>            :              arguments.  So right here we only handle the latter.  */
<span class="lineNum">   19834 </span>            :           if (!member_p &amp;&amp; processing_template_decl &amp;&amp; decl != error_mark_node)
<span class="lineNum">   19835 </span><span class="lineCov">    6817308 :             start_lambda_scope (decl);</span>
<span class="lineNum">   19836 </span>            :           initializer = cp_parser_initializer (parser,
<span class="lineNum">   19837 </span>            :                                                &amp;is_direct_init,
<span class="lineNum">   19838 </span><span class="lineCov">    6817308 :                                                &amp;is_non_constant_init);</span>
<span class="lineNum">   19839 </span><span class="lineCov">    3205676 :           if (!member_p &amp;&amp; processing_template_decl &amp;&amp; decl != error_mark_node)</span>
<span class="lineNum">   19840 </span>            :             finish_lambda_scope ();
<span class="lineNum">   19841 </span>            :           if (initializer == error_mark_node)
<span class="lineNum">   19842 </span>            :             cp_parser_skip_to_end_of_statement (parser);
<span class="lineNum">   19843 </span><span class="lineCov">    6990470 :         }</span>
<span class="lineNum">   19844 </span><span class="lineCov">    6990470 :     }</span>
<span class="lineNum">   19845 </span><span class="lineCov">    6990470 : </span>
<span class="lineNum">   19846 </span><span class="lineCov">    6990470 :   /* The old parser allows attributes to appear after a parenthesized</span>
<span class="lineNum">   19847 </span>            :      initializer.  Mark Mitchell proposed removing this functionality
<span class="lineNum">   19848 </span><span class="lineCov">    1908118 :      on the GCC mailing lists on 2002-08-13.  This parser accepts the</span>
<span class="lineNum">   19849 </span>            :      attributes -- but ignores them.  Made a permerror in GCC 8.  */
<span class="lineNum">   19850 </span><span class="lineCov">      16534 :   if (cp_parser_allow_gnu_extensions_p (parser)</span>
<span class="lineNum">   19851 </span><span class="lineCov">      16528 :       &amp;&amp; initialization_kind == CPP_OPEN_PAREN</span>
<span class="lineNum">   19852 </span>            :       &amp;&amp; cp_parser_attributes_opt (parser)
<span class="lineNum">   19853 </span>            :       &amp;&amp; permerror (input_location,
<span class="lineNum">   19854 </span>            :                     &quot;attributes after parenthesized initializer ignored&quot;))
<span class="lineNum">   19855 </span>            :     {
<span class="lineNum">   19856 </span>            :       static bool hint;
<span class="lineNum">   19857 </span><span class="lineCov">          6 :       if (flag_permissive &amp;&amp; !hint)</span>
<span class="lineNum">   19858 </span><span class="lineCov">          6 :         {</span>
<span class="lineNum">   19859 </span><span class="lineCov">          6 :           hint = true;</span>
<span class="lineNum">   19860 </span>            :           inform (input_location,
<span class="lineNum">   19861 </span>            :                   &quot;this flexibility is deprecated and will be removed&quot;);
<span class="lineNum">   19862 </span>            :         }
<span class="lineNum">   19863 </span>            :     }
<span class="lineNum">   19864 </span>            : 
<span class="lineNum">   19865 </span>            :   /* And now complain about a non-function implicit template.  */
<span class="lineNum">   19866 </span>            :   if (bogus_implicit_tmpl &amp;&amp; decl != error_mark_node)
<span class="lineNum">   19867 </span>            :     error_at (DECL_SOURCE_LOCATION (decl),
<span class="lineNum">   19868 </span>            :               &quot;non-function %qD declared as implicit template&quot;, decl);
<span class="lineNum">   19869 </span>            : 
<span class="lineNum">   19870 </span>            :   /* For an in-class declaration, use `grokfield' to create the
<span class="lineNum">   19871 </span>            :      declaration.  */
<span class="lineNum">   19872 </span><span class="lineCov">    1891584 :   if (member_p)</span>
<span class="lineNum">   19873 </span><span class="lineCov">    1511310 :     {</span>
<span class="lineNum">   19874 </span><span class="lineCov">    1891584 :       if (pushed_scope)</span>
<span class="lineNum">   19875 </span>            :         {
<span class="lineNum">   19876 </span>            :           pop_scope (pushed_scope);
<span class="lineNum">   19877 </span><span class="lineCov">    1891580 :           pushed_scope = NULL_TREE;</span>
<span class="lineNum">   19878 </span><span class="lineCov">    1511310 :         }</span>
<span class="lineNum">   19879 </span><span class="lineCov">    1891580 :       decl = grokfield (declarator, decl_specifiers,</span>
<span class="lineNum">   19880 </span><span class="lineCov">        874 :                         initializer, !is_non_constant_init,</span>
<span class="lineNum">   19881 </span>            :                         /*asmspec=*/NULL_TREE,
<span class="lineNum">   19882 </span>            :                         attr_chainon (attributes, prefix_attributes));
<span class="lineNum">   19883 </span>            :       if (decl &amp;&amp; TREE_CODE (decl) == FUNCTION_DECL)
<span class="lineNum">   19884 </span>            :         cp_parser_save_default_args (parser, decl);
<span class="lineNum">   19885 </span>            :       cp_finalize_omp_declare_simd (parser, decl);
<span class="lineNum">   19886 </span>            :       cp_finalize_oacc_routine (parser, decl, false);
<span class="lineNum">   19887 </span>            :     }
<span class="lineNum">   19888 </span><span class="lineCov">   13980932 : </span>
<span class="lineNum">   19889 </span><span class="lineCov">    6990466 :   /* Finish processing the declaration.  But, skip member</span>
<span class="lineNum">   19890 </span><span class="lineCov">     127702 :      declarations.  */</span>
<span class="lineNum">   19891 </span><span class="lineCov">          3 :   if (!member_p &amp;&amp; decl &amp;&amp; decl != error_mark_node &amp;&amp; !range_for_decl_p)</span>
<span class="lineNum">   19892 </span>            :     {
<span class="lineNum">   19893 </span>            :       cp_finish_decl (decl,
<span class="lineNum">   19894 </span><span class="lineCov">          3 :                       initializer, !is_non_constant_init,</span>
<span class="lineNum">   19895 </span><span class="lineCov">          3 :                       asm_specification,</span>
<span class="lineNum">   19896 </span>            :                       /* If the initializer is in parentheses, then this is
<span class="lineNum">   19897 </span><span class="lineCov">          3 :                          a direct-initialization, which means that an</span>
<span class="lineNum">   19898 </span><span class="lineCov">          3 :                          `explicit' constructor is OK.  Otherwise, an</span>
<span class="lineNum">   19899 </span>            :                          `explicit' constructor cannot be used.  */
<span class="lineNum">   19900 </span>            :                       ((is_direct_init || !is_initialized)
<span class="lineNum">   19901 </span>            :                        ? LOOKUP_NORMAL : LOOKUP_IMPLICIT));
<span class="lineNum">   19902 </span>            :     }
<span class="lineNum">   19903 </span>            :   else if ((cxx_dialect != cxx98) &amp;&amp; friend_p
<span class="lineNum">   19904 </span><span class="lineCov">    6990466 :            &amp;&amp; decl &amp;&amp; TREE_CODE (decl) == FUNCTION_DECL)</span>
<span class="lineNum">   19905 </span><span class="lineNoCov">          0 :     /* Core issue #226 (C++0x only): A default template-argument</span>
<span class="lineNum">   19906 </span>            :        shall not be specified in a friend class template
<span class="lineNum">   19907 </span>            :        declaration. */
<span class="lineNum">   19908 </span>            :     check_default_tmpl_args (decl, current_template_parms, /*is_primary=*/true, 
<span class="lineNum">   19909 </span>            :                              /*is_partial=*/false, /*is_friend_decl=*/1);
<span class="lineNum">   19910 </span><span class="lineCov">    6990466 : </span>
<span class="lineNum">   19911 </span>            :   if (!friend_p &amp;&amp; pushed_scope)
<span class="lineNum">   19912 </span><span class="lineCov">     173162 :     pop_scope (pushed_scope);</span>
<span class="lineNum">   19913 </span>            : 
<span class="lineNum">   19914 </span><span class="lineCov">       2199 :   if (function_declarator_p (declarator)</span>
<span class="lineNum">   19915 </span><span class="lineCov">       2199 :       &amp;&amp; parser-&gt;fully_implicit_function_template_p)</span>
<span class="lineNum">   19916 </span>            :     {
<span class="lineNum">   19917 </span><span class="lineCov">     173162 :       if (member_p)</span>
<span class="lineNum">   19918 </span><span class="lineCov">     173162 :         decl = finish_fully_implicit_template (parser, decl);</span>
<span class="lineNum">   19919 </span>            :       else
<span class="lineNum">   19920 </span>            :         finish_fully_implicit_template (parser, /*member_decl_opt=*/0);
<span class="lineNum">   19921 </span><span class="lineCov">     173162 :     }</span>
<span class="lineNum">   19922 </span><span class="lineCov">     172788 : </span>
<span class="lineNum">   19923 </span><span class="lineCov">     173162 :   if (auto_result &amp;&amp; is_initialized &amp;&amp; decl_specifiers-&gt;type</span>
<span class="lineNum">   19924 </span><span class="lineCov">     173162 :       &amp;&amp; type_uses_auto (decl_specifiers-&gt;type))</span>
<span class="lineNum">   19925 </span>            :     *auto_result = strip_declarator_types (TREE_TYPE (decl), declarator);
<span class="lineNum">   19926 </span>            : 
<span class="lineNum">   19927 </span>            :   return decl;
<span class="lineNum">   19928 </span>            : }
<span class="lineNum">   19929 </span><span class="lineCov">    6990466 : </span>
<span class="lineNum">   19930 </span>            : /* Parse a declarator.
<span class="lineNum">   19931 </span><span class="lineCov">    6813002 : </span>
<span class="lineNum">   19932 </span><span class="lineCov">    6813002 :    declarator:</span>
<span class="lineNum">   19933 </span>            :      direct-declarator
<span class="lineNum">   19934 </span>            :      ptr-operator declarator
<span class="lineNum">   19935 </span>            : 
<span class="lineNum">   19936 </span>            :    abstract-declarator:
<span class="lineNum">   19937 </span>            :      ptr-operator abstract-declarator [opt]
<span class="lineNum">   19938 </span><span class="lineCov">    6672261 :      direct-abstract-declarator</span>
<span class="lineNum">   19939 </span>            : 
<span class="lineNum">   19940 </span>            :    GNU Extensions:
<span class="lineNum">   19941 </span><span class="lineCov">     177464 : </span>
<span class="lineNum">   19942 </span><span class="lineCov">      27836 :    declarator:</span>
<span class="lineNum">   19943 </span>            :      attributes [opt] direct-declarator
<span class="lineNum">   19944 </span>            :      attributes [opt] ptr-operator declarator
<span class="lineNum">   19945 </span>            : 
<span class="lineNum">   19946 </span><span class="lineCov">      27786 :    abstract-declarator:</span>
<span class="lineNum">   19947 </span>            :      attributes [opt] ptr-operator abstract-declarator [opt]
<span class="lineNum">   19948 </span>            :      attributes [opt] direct-abstract-declarator
<span class="lineNum">   19949 </span><span class="lineCov">    6990466 : </span>
<span class="lineNum">   19950 </span><span class="lineCov">     854845 :    If CTOR_DTOR_OR_CONV_P is not NULL, *CTOR_DTOR_OR_CONV_P is used to</span>
<span class="lineNum">   19951 </span>            :    detect constructors, destructors, deduction guides, or conversion operators.
<span class="lineNum">   19952 </span><span class="lineCov">    6990466 :    It is set to -1 if the declarator is a name, and +1 if it is a</span>
<span class="lineNum">   19953 </span><span class="lineCov">    6990466 :    function. Otherwise it is set to zero. Usually you just want to</span>
<span class="lineNum">   19954 </span>            :    test for &gt;0, but internally the negative value is used.
<span class="lineNum">   19955 </span><span class="lineCov">         15 : </span>
<span class="lineNum">   19956 </span><span class="lineNoCov">          0 :    (The reason for CTOR_DTOR_OR_CONV_P is that a declaration must have</span>
<span class="lineNum">   19957 </span>            :    a decl-specifier-seq unless it declares a constructor, destructor,
<span class="lineNum">   19958 </span><span class="lineCov">         15 :    or conversion.  It might seem that we could check this condition in</span>
<span class="lineNum">   19959 </span>            :    semantic analysis, rather than parsing, but that makes it difficult
<span class="lineNum">   19960 </span>            :    to handle something like `f()'.  We want to notice that there are
<span class="lineNum">   19961 </span><span class="lineCov">    1830486 :    no decl-specifiers, and therefore realize that this is an</span>
<span class="lineNum">   19962 </span><span class="lineCov">    8792815 :    expression, not a declaration.)</span>
<span class="lineNum">   19963 </span><span class="lineCov">      61781 : </span>
<span class="lineNum">   19964 </span>            :    If PARENTHESIZED_P is non-NULL, *PARENTHESIZED_P is set to true iff
<span class="lineNum">   19965 </span>            :    the declarator is a direct-declarator of the form &quot;(...)&quot;.
<span class="lineNum">   19966 </span>            : 
<span class="lineNum">   19967 </span>            :    MEMBER_P is true iff this declarator is a member-declarator.
<span class="lineNum">   19968 </span>            : 
<span class="lineNum">   19969 </span>            :    FRIEND_P is true iff this declarator is a friend.  */
<a name="19970"><span class="lineNum">   19970 </span>            : </a>
<span class="lineNum">   19971 </span>            : static cp_declarator *
<span class="lineNum">   19972 </span>            : cp_parser_declarator (cp_parser* parser,
<span class="lineNum">   19973 </span>            :                       cp_parser_declarator_kind dcl_kind,
<span class="lineNum">   19974 </span>            :                       int* ctor_dtor_or_conv_p,
<span class="lineNum">   19975 </span>            :                       bool* parenthesized_p,
<span class="lineNum">   19976 </span>            :                       bool member_p, bool friend_p)
<span class="lineNum">   19977 </span>            : {
<span class="lineNum">   19978 </span>            :   cp_declarator *declarator;
<span class="lineNum">   19979 </span>            :   enum tree_code code;
<span class="lineNum">   19980 </span>            :   cp_cv_quals cv_quals;
<span class="lineNum">   19981 </span>            :   tree class_type;
<span class="lineNum">   19982 </span>            :   tree gnu_attributes = NULL_TREE, std_attributes = NULL_TREE;
<span class="lineNum">   19983 </span>            : 
<span class="lineNum">   19984 </span>            :   /* Assume this is not a constructor, destructor, or type-conversion
<span class="lineNum">   19985 </span>            :      operator.  */
<span class="lineNum">   19986 </span>            :   if (ctor_dtor_or_conv_p)
<span class="lineNum">   19987 </span>            :     *ctor_dtor_or_conv_p = 0;
<span class="lineNum">   19988 </span>            : 
<span class="lineNum">   19989 </span>            :   if (cp_parser_allow_gnu_extensions_p (parser))
<span class="lineNum">   19990 </span>            :     gnu_attributes = cp_parser_gnu_attributes_opt (parser);
<span class="lineNum">   19991 </span>            : 
<span class="lineNum">   19992 </span>            :   /* Check for the ptr-operator production.  */
<span class="lineNum">   19993 </span>            :   cp_parser_parse_tentatively (parser);
<span class="lineNum">   19994 </span>            :   /* Parse the ptr-operator.  */
<span class="lineNum">   19995 </span>            :   code = cp_parser_ptr_operator (parser,
<span class="lineNum">   19996 </span>            :                                  &amp;class_type,
<span class="lineNum">   19997 </span>            :                                  &amp;cv_quals,
<span class="lineNum">   19998 </span>            :                                  &amp;std_attributes);
<span class="lineNum">   19999 </span>            : 
<span class="lineNum">   20000 </span>            :   /* If that worked, then we have a ptr-operator.  */
<span class="lineNum">   20001 </span>            :   if (cp_parser_parse_definitely (parser))
<span class="lineNum">   20002 </span>            :     {
<span class="lineNum">   20003 </span>            :       /* If a ptr-operator was found, then this declarator was not
<span class="lineNum">   20004 </span>            :          parenthesized.  */
<span class="lineNum">   20005 </span>            :       if (parenthesized_p)
<span class="lineNum">   20006 </span>            :         *parenthesized_p = true;
<span class="lineNum">   20007 </span>            :       /* The dependent declarator is optional if we are parsing an
<span class="lineNum">   20008 </span>            :          abstract-declarator.  */
<span class="lineNum">   20009 </span>            :       if (dcl_kind != CP_PARSER_DECLARATOR_NAMED)
<span class="lineNum">   20010 </span><span class="lineCov">   60823582 :         cp_parser_parse_tentatively (parser);</span>
<span class="lineNum">   20011 </span>            : 
<span class="lineNum">   20012 </span>            :       /* Parse the dependent declarator.  */
<span class="lineNum">   20013 </span>            :       declarator = cp_parser_declarator (parser, dcl_kind,
<span class="lineNum">   20014 </span>            :                                          /*ctor_dtor_or_conv_p=*/NULL,
<span class="lineNum">   20015 </span>            :                                          /*parenthesized_p=*/NULL,
<span class="lineNum">   20016 </span><span class="lineCov">   60823582 :                                          /*member_p=*/false,</span>
<span class="lineNum">   20017 </span><span class="lineCov">   60823582 :                                          friend_p);</span>
<span class="lineNum">   20018 </span><span class="lineCov">   60823582 : </span>
<span class="lineNum">   20019 </span><span class="lineCov">   60823582 :       /* If we are parsing an abstract-declarator, we must handle the</span>
<span class="lineNum">   20020 </span><span class="lineCov">   60823582 :          case where the dependent declarator is absent.  */</span>
<span class="lineNum">   20021 </span>            :       if (dcl_kind != CP_PARSER_DECLARATOR_NAMED
<span class="lineNum">   20022 </span>            :           &amp;&amp; !cp_parser_parse_definitely (parser))
<span class="lineNum">   20023 </span>            :         declarator = NULL;
<span class="lineNum">   20024 </span><span class="lineCov">   60823582 : </span>
<span class="lineNum">   20025 </span><span class="lineCov">   17203752 :       declarator = cp_parser_make_indirect_declarator</span>
<span class="lineNum">   20026 </span>            :         (code, class_type, cv_quals, declarator, std_attributes);
<span class="lineNum">   20027 </span><span class="lineCov">  121647164 :     }</span>
<span class="lineNum">   20028 </span><span class="lineCov">   60823582 :   /* Everything else is a direct-declarator.  */</span>
<span class="lineNum">   20029 </span>            :   else
<span class="lineNum">   20030 </span>            :     {
<span class="lineNum">   20031 </span><span class="lineCov">   60823582 :       if (parenthesized_p)</span>
<span class="lineNum">   20032 </span>            :         *parenthesized_p = cp_lexer_next_token_is (parser-&gt;lexer,
<span class="lineNum">   20033 </span><span class="lineCov">   60823582 :                                                    CPP_OPEN_PAREN);</span>
<span class="lineNum">   20034 </span>            :       declarator = cp_parser_direct_declarator (parser, dcl_kind,
<span class="lineNum">   20035 </span>            :                                                 ctor_dtor_or_conv_p,
<span class="lineNum">   20036 </span>            :                                                 member_p, friend_p);
<span class="lineNum">   20037 </span>            :     }
<span class="lineNum">   20038 </span>            : 
<span class="lineNum">   20039 </span><span class="lineCov">   60823582 :   if (gnu_attributes &amp;&amp; declarator &amp;&amp; declarator != cp_error_declarator)</span>
<span class="lineNum">   20040 </span>            :     declarator-&gt;attributes = gnu_attributes;
<span class="lineNum">   20041 </span>            :   return declarator;
<span class="lineNum">   20042 </span>            : }
<span class="lineNum">   20043 </span><span class="lineCov">   10701826 : </span>
<span class="lineNum">   20044 </span><span class="lineCov">    7379601 : /* Parse a direct-declarator or direct-abstract-declarator.</span>
<span class="lineNum">   20045 </span>            : 
<span class="lineNum">   20046 </span>            :    direct-declarator:
<span class="lineNum">   20047 </span><span class="lineCov">   10701826 :      declarator-id</span>
<span class="lineNum">   20048 </span><span class="lineCov">    8547392 :      direct-declarator ( parameter-declaration-clause )</span>
<span class="lineNum">   20049 </span>            :        cv-qualifier-seq [opt]
<span class="lineNum">   20050 </span>            :        ref-qualifier [opt]
<span class="lineNum">   20051 </span><span class="lineCov">   10701826 :        exception-specification [opt]</span>
<span class="lineNum">   20052 </span>            :      direct-declarator [ constant-expression [opt] ]
<span class="lineNum">   20053 </span>            :      ( declarator )
<span class="lineNum">   20054 </span>            : 
<span class="lineNum">   20055 </span>            :    direct-abstract-declarator:
<span class="lineNum">   20056 </span>            :      direct-abstract-declarator [opt]
<span class="lineNum">   20057 </span>            :        ( parameter-declaration-clause )
<span class="lineNum">   20058 </span>            :        cv-qualifier-seq [opt]
<span class="lineNum">   20059 </span><span class="lineCov">   10701826 :        ref-qualifier [opt]</span>
<span class="lineNum">   20060 </span><span class="lineCov">   10701826 :        exception-specification [opt]</span>
<span class="lineNum">   20061 </span>            :      direct-abstract-declarator [opt] [ constant-expression [opt] ]
<span class="lineNum">   20062 </span>            :      ( abstract-declarator )
<span class="lineNum">   20063 </span><span class="lineCov">   10701826 : </span>
<span class="lineNum">   20064 </span><span class="lineCov">   10701826 :    Returns a representation of the declarator.  DCL_KIND is</span>
<span class="lineNum">   20065 </span>            :    CP_PARSER_DECLARATOR_ABSTRACT, if we are parsing a
<span class="lineNum">   20066 </span>            :    direct-abstract-declarator.  It is CP_PARSER_DECLARATOR_NAMED, if
<span class="lineNum">   20067 </span>            :    we are parsing a direct-declarator.  It is
<span class="lineNum">   20068 </span>            :    CP_PARSER_DECLARATOR_EITHER, if we can accept either - in the case
<span class="lineNum">   20069 </span><span class="lineCov">   50121756 :    of ambiguity we prefer an abstract declarator, as per</span>
<span class="lineNum">   20070 </span><span class="lineCov">    8077543 :    [dcl.ambig.res].  CTOR_DTOR_OR_CONV_P, MEMBER_P, and FRIEND_P are</span>
<span class="lineNum">   20071 </span>            :    as for cp_parser_declarator.  */
<a name="20072"><span class="lineNum">   20072 </span><span class="lineCov">   50121756 : </span></a>
<span class="lineNum">   20073 </span>            : static cp_declarator *
<span class="lineNum">   20074 </span>            : cp_parser_direct_declarator (cp_parser* parser,
<span class="lineNum">   20075 </span>            :                              cp_parser_declarator_kind dcl_kind,
<span class="lineNum">   20076 </span>            :                              int* ctor_dtor_or_conv_p,
<span class="lineNum">   20077 </span><span class="lineCov">   60823582 :                              bool member_p, bool friend_p)</span>
<span class="lineNum">   20078 </span><span class="lineCov">        623 : {</span>
<span class="lineNum">   20079 </span><span class="lineCov">   60823582 :   cp_token *token;</span>
<span class="lineNum">   20080 </span>            :   cp_declarator *declarator = NULL;
<span class="lineNum">   20081 </span>            :   tree scope = NULL_TREE;
<span class="lineNum">   20082 </span>            :   bool saved_default_arg_ok_p = parser-&gt;default_arg_ok_p;
<span class="lineNum">   20083 </span>            :   bool saved_in_declarator_p = parser-&gt;in_declarator_p;
<span class="lineNum">   20084 </span>            :   bool first = true;
<span class="lineNum">   20085 </span>            :   tree pushed_scope = NULL_TREE;
<span class="lineNum">   20086 </span>            :   cp_token *open_paren = NULL, *close_paren = NULL;
<span class="lineNum">   20087 </span>            : 
<span class="lineNum">   20088 </span>            :   while (true)
<span class="lineNum">   20089 </span>            :     {
<span class="lineNum">   20090 </span>            :       /* Peek at the next token.  */
<span class="lineNum">   20091 </span>            :       token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   20092 </span>            :       if (token-&gt;type == CPP_OPEN_PAREN)
<span class="lineNum">   20093 </span>            :         {
<span class="lineNum">   20094 </span>            :           /* This is either a parameter-declaration-clause, or a
<span class="lineNum">   20095 </span>            :              parenthesized declarator. When we know we are parsing a
<span class="lineNum">   20096 </span>            :              named declarator, it must be a parenthesized declarator
<span class="lineNum">   20097 </span>            :              if FIRST is true. For instance, `(int)' is a
<span class="lineNum">   20098 </span>            :              parameter-declaration-clause, with an omitted
<span class="lineNum">   20099 </span>            :              direct-abstract-declarator. But `((*))', is a
<span class="lineNum">   20100 </span>            :              parenthesized abstract declarator. Finally, when T is a
<span class="lineNum">   20101 </span>            :              template parameter `(T)' is a
<span class="lineNum">   20102 </span>            :              parameter-declaration-clause, and not a parenthesized
<span class="lineNum">   20103 </span>            :              named declarator.
<span class="lineNum">   20104 </span>            : 
<span class="lineNum">   20105 </span>            :              We first try and parse a parameter-declaration-clause,
<span class="lineNum">   20106 </span>            :              and then try a nested declarator (if FIRST is true).
<span class="lineNum">   20107 </span>            : 
<span class="lineNum">   20108 </span>            :              It is not an error for it not to be a
<span class="lineNum">   20109 </span>            :              parameter-declaration-clause, even when FIRST is
<span class="lineNum">   20110 </span>            :              false. Consider,
<span class="lineNum">   20111 </span>            : 
<span class="lineNum">   20112 </span><span class="lineCov">   50121756 :                int i (int);</span>
<span class="lineNum">   20113 </span>            :                int i (3);
<span class="lineNum">   20114 </span>            : 
<span class="lineNum">   20115 </span>            :              The first is the declaration of a function while the
<span class="lineNum">   20116 </span>            :              second is the definition of a variable, including its
<span class="lineNum">   20117 </span><span class="lineCov">   50121756 :              initializer.</span>
<span class="lineNum">   20118 </span><span class="lineCov">   50121756 : </span>
<span class="lineNum">   20119 </span><span class="lineCov">   50121756 :              Having seen only the parenthesis, we cannot know which of</span>
<span class="lineNum">   20120 </span><span class="lineCov">   50121756 :              these two alternatives should be selected.  Even more</span>
<span class="lineNum">   20121 </span><span class="lineCov">   50121756 :              complex are examples like:</span>
<span class="lineNum">   20122 </span><span class="lineCov">   50121756 : </span>
<span class="lineNum">   20123 </span><span class="lineCov">   50121756 :                int i (int (a));</span>
<span class="lineNum">   20124 </span><span class="lineCov">   50121756 :                int i (int (3));</span>
<span class="lineNum">   20125 </span>            : 
<span class="lineNum">   20126 </span><span class="lineCov">   93206851 :              The former is a function-declaration; the latter is a</span>
<span class="lineNum">   20127 </span>            :              variable initialization.
<span class="lineNum">   20128 </span>            : 
<span class="lineNum">   20129 </span><span class="lineCov">  186413702 :              Thus again, we try a parameter-declaration-clause, and if</span>
<span class="lineNum">   20130 </span><span class="lineCov">   93206851 :              that fails, we back out and return.  */</span>
<span class="lineNum">   20131 </span>            : 
<span class="lineNum">   20132 </span>            :           if (!first || dcl_kind != CP_PARSER_DECLARATOR_NAMED)
<span class="lineNum">   20133 </span>            :             {
<span class="lineNum">   20134 </span>            :               tree params;
<span class="lineNum">   20135 </span>            :               bool is_declarator = false;
<span class="lineNum">   20136 </span>            : 
<span class="lineNum">   20137 </span>            :               open_paren = NULL;
<span class="lineNum">   20138 </span>            : 
<span class="lineNum">   20139 </span>            :               /* In a member-declarator, the only valid interpretation
<span class="lineNum">   20140 </span>            :                  of a parenthesis is the start of a
<span class="lineNum">   20141 </span>            :                  parameter-declaration-clause.  (It is invalid to
<span class="lineNum">   20142 </span>            :                  initialize a static data member with a parenthesized
<span class="lineNum">   20143 </span>            :                  initializer; only the &quot;=&quot; form of initialization is
<span class="lineNum">   20144 </span>            :                  permitted.)  */
<span class="lineNum">   20145 </span>            :               if (!member_p)
<span class="lineNum">   20146 </span>            :                 cp_parser_parse_tentatively (parser);
<span class="lineNum">   20147 </span>            : 
<span class="lineNum">   20148 </span>            :               /* Consume the `('.  */
<span class="lineNum">   20149 </span>            :               matching_parens parens;
<span class="lineNum">   20150 </span>            :               parens.consume_open (parser);
<span class="lineNum">   20151 </span>            :               if (first)
<span class="lineNum">   20152 </span>            :                 {
<span class="lineNum">   20153 </span>            :                   /* If this is going to be an abstract declarator, we're
<span class="lineNum">   20154 </span>            :                      in a declarator and we can't have default args.  */
<span class="lineNum">   20155 </span>            :                   parser-&gt;default_arg_ok_p = false;
<span class="lineNum">   20156 </span>            :                   parser-&gt;in_declarator_p = true;
<span class="lineNum">   20157 </span>            :                 }
<span class="lineNum">   20158 </span>            : 
<span class="lineNum">   20159 </span>            :               begin_scope (sk_function_parms, NULL_TREE);
<span class="lineNum">   20160 </span>            : 
<span class="lineNum">   20161 </span>            :               /* Parse the parameter-declaration-clause.  */
<span class="lineNum">   20162 </span>            :               params = cp_parser_parameter_declaration_clause (parser);
<span class="lineNum">   20163 </span>            : 
<span class="lineNum">   20164 </span>            :               /* Consume the `)'.  */
<span class="lineNum">   20165 </span>            :               parens.require_close (parser);
<span class="lineNum">   20166 </span>            : 
<span class="lineNum">   20167 </span>            :               /* If all went well, parse the cv-qualifier-seq,
<span class="lineNum">   20168 </span>            :                  ref-qualifier and the exception-specification.  */
<span class="lineNum">   20169 </span>            :               if (member_p || cp_parser_parse_definitely (parser))
<span class="lineNum">   20170 </span><span class="lineCov">   10774487 :                 {</span>
<span class="lineNum">   20171 </span>            :                   cp_cv_quals cv_quals;
<span class="lineNum">   20172 </span><span class="lineCov">   10684151 :                   cp_virt_specifiers virt_specifiers;</span>
<span class="lineNum">   20173 </span><span class="lineCov">   10684151 :                   cp_ref_qualifier ref_qual;</span>
<span class="lineNum">   20174 </span>            :                   tree exception_specification;
<span class="lineNum">   20175 </span><span class="lineCov">   10684151 :                   tree late_return;</span>
<span class="lineNum">   20176 </span>            :                   tree attrs;
<span class="lineNum">   20177 </span>            :                   bool memfn = (member_p || (pushed_scope
<span class="lineNum">   20178 </span>            :                                              &amp;&amp; CLASS_TYPE_P (pushed_scope)));
<span class="lineNum">   20179 </span>            : 
<span class="lineNum">   20180 </span>            :                   is_declarator = true;
<span class="lineNum">   20181 </span>            : 
<span class="lineNum">   20182 </span>            :                   if (ctor_dtor_or_conv_p)
<span class="lineNum">   20183 </span><span class="lineCov">   10684151 :                     *ctor_dtor_or_conv_p = *ctor_dtor_or_conv_p &lt; 0;</span>
<span class="lineNum">   20184 </span><span class="lineCov">    7114635 :                   first = false;</span>
<span class="lineNum">   20185 </span>            : 
<span class="lineNum">   20186 </span>            :                   /* Parse the cv-qualifier-seq.  */
<span class="lineNum">   20187 </span><span class="lineCov">   21368302 :                   cv_quals = cp_parser_cv_qualifier_seq_opt (parser);</span>
<span class="lineNum">   20188 </span><span class="lineCov">   10684151 :                   /* Parse the ref-qualifier. */</span>
<span class="lineNum">   20189 </span><span class="lineCov">   10684151 :                   ref_qual = cp_parser_ref_qualifier_opt (parser);</span>
<span class="lineNum">   20190 </span>            :                   /* Parse the tx-qualifier.  */
<span class="lineNum">   20191 </span>            :                   tree tx_qual = cp_parser_tx_qualifier_opt (parser);
<span class="lineNum">   20192 </span>            :                   /* And the exception-specification.  */
<span class="lineNum">   20193 </span><span class="lineCov">     257209 :                   exception_specification</span>
<span class="lineNum">   20194 </span><span class="lineCov">     257209 :                     = cp_parser_exception_specification_opt (parser);</span>
<span class="lineNum">   20195 </span>            : 
<span class="lineNum">   20196 </span>            :                   attrs = cp_parser_std_attribute_spec_seq (parser);
<span class="lineNum">   20197 </span><span class="lineCov">   10684151 : </span>
<span class="lineNum">   20198 </span>            :                   /* In here, we handle cases where attribute is used after
<span class="lineNum">   20199 </span>            :                      the function declaration.  For example:
<span class="lineNum">   20200 </span><span class="lineCov">   10684151 :                      void func (int x) __attribute__((vector(..)));  */</span>
<span class="lineNum">   20201 </span>            :                   tree gnu_attrs = NULL_TREE;
<span class="lineNum">   20202 </span>            :                   tree requires_clause = NULL_TREE;
<span class="lineNum">   20203 </span><span class="lineCov">   10684151 :                   late_return = (cp_parser_late_return_type_opt</span>
<span class="lineNum">   20204 </span>            :                                  (parser, declarator, requires_clause,
<span class="lineNum">   20205 </span>            :                                   memfn ? cv_quals : -1));
<span class="lineNum">   20206 </span>            : 
<span class="lineNum">   20207 </span><span class="lineCov">   10684151 :                   /* Parse the virt-specifier-seq.  */</span>
<span class="lineNum">   20208 </span>            :                   virt_specifiers = cp_parser_virt_specifier_seq_opt (parser);
<span class="lineNum">   20209 </span><span class="lineCov">   10406532 : </span>
<span class="lineNum">   20210 </span><span class="lineCov">   10406532 :                   /* Create the function-declarator.  */</span>
<span class="lineNum">   20211 </span><span class="lineCov">   10406532 :                   declarator = make_call_declarator (declarator,</span>
<span class="lineNum">   20212 </span><span class="lineCov">   10406532 :                                                      params,</span>
<span class="lineNum">   20213 </span><span class="lineCov">   10406532 :                                                      cv_quals,</span>
<span class="lineNum">   20214 </span><span class="lineCov">   10406532 :                                                      virt_specifiers,</span>
<span class="lineNum">   20215 </span><span class="lineCov">   10406532 :                                                      ref_qual,</span>
<span class="lineNum">   20216 </span><span class="lineCov">     411296 :                                                      tx_qual,</span>
<span class="lineNum">   20217 </span>            :                                                      exception_specification,
<span class="lineNum">   20218 </span><span class="lineCov">   10406532 :                                                      late_return,</span>
<span class="lineNum">   20219 </span>            :                                                      requires_clause);
<span class="lineNum">   20220 </span><span class="lineCov">   10406532 :                   declarator-&gt;std_attributes = attrs;</span>
<span class="lineNum">   20221 </span><span class="lineCov">    8804005 :                   declarator-&gt;attributes = gnu_attrs;</span>
<span class="lineNum">   20222 </span><span class="lineCov">   10406532 :                   /* Any subsequent parameter lists are to do with</span>
<span class="lineNum">   20223 </span>            :                      return type, so are not those of the declared
<span class="lineNum">   20224 </span>            :                      function.  */
<span class="lineNum">   20225 </span><span class="lineCov">   10406532 :                   parser-&gt;default_arg_ok_p = false;</span>
<span class="lineNum">   20226 </span>            :                 }
<span class="lineNum">   20227 </span><span class="lineCov">   10406532 : </span>
<span class="lineNum">   20228 </span>            :               /* Remove the function parms from scope.  */
<span class="lineNum">   20229 </span><span class="lineCov">   10406532 :               pop_bindings_and_leave_scope ();</span>
<span class="lineNum">   20230 </span>            : 
<span class="lineNum">   20231 </span><span class="lineCov">   10406532 :               if (is_declarator)</span>
<span class="lineNum">   20232 </span><span class="lineCov">   10406532 :                 /* Repeat the main loop.  */</span>
<span class="lineNum">   20233 </span>            :                 continue;
<span class="lineNum">   20234 </span><span class="lineCov">   10406532 :             }</span>
<span class="lineNum">   20235 </span>            : 
<span class="lineNum">   20236 </span>            :           /* If this is the first, we can try a parenthesized
<span class="lineNum">   20237 </span>            :              declarator.  */
<span class="lineNum">   20238 </span>            :           if (first)
<span class="lineNum">   20239 </span><span class="lineCov">   10406532 :             {</span>
<span class="lineNum">   20240 </span><span class="lineCov">   10406532 :               bool saved_in_type_id_in_expr_p;</span>
<span class="lineNum">   20241 </span><span class="lineCov">   10406532 : </span>
<span class="lineNum">   20242 </span><span class="lineCov">   16833501 :               parser-&gt;default_arg_ok_p = saved_default_arg_ok_p;</span>
<span class="lineNum">   20243 </span>            :               parser-&gt;in_declarator_p = saved_in_declarator_p;
<span class="lineNum">   20244 </span>            : 
<span class="lineNum">   20245 </span>            :               open_paren = token;
<span class="lineNum">   20246 </span><span class="lineCov">   10406532 :               /* Consume the `('.  */</span>
<span class="lineNum">   20247 </span>            :               matching_parens parens;
<span class="lineNum">   20248 </span>            :               parens.consume_open (parser);
<span class="lineNum">   20249 </span><span class="lineCov">   10406532 :               /* Parse the nested declarator.  */</span>
<span class="lineNum">   20250 </span>            :               saved_in_type_id_in_expr_p = parser-&gt;in_type_id_in_expr_p;
<span class="lineNum">   20251 </span>            :               parser-&gt;in_type_id_in_expr_p = true;
<span class="lineNum">   20252 </span>            :               declarator
<span class="lineNum">   20253 </span>            :                 = cp_parser_declarator (parser, dcl_kind, ctor_dtor_or_conv_p,
<span class="lineNum">   20254 </span>            :                                         /*parenthesized_p=*/NULL,
<span class="lineNum">   20255 </span>            :                                         member_p, friend_p);
<span class="lineNum">   20256 </span>            :               parser-&gt;in_type_id_in_expr_p = saved_in_type_id_in_expr_p;
<span class="lineNum">   20257 </span>            :               first = false;
<span class="lineNum">   20258 </span><span class="lineCov">   10406532 :               /* Expect a `)'.  */</span>
<span class="lineNum">   20259 </span><span class="lineCov">   10406532 :               close_paren = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   20260 </span>            :               if (!parens.require_close (parser))
<span class="lineNum">   20261 </span>            :                 declarator = cp_error_declarator;
<span class="lineNum">   20262 </span>            :               if (declarator == cp_error_declarator)
<span class="lineNum">   20263 </span><span class="lineCov">   10406532 :                 break;</span>
<span class="lineNum">   20264 </span>            : 
<span class="lineNum">   20265 </span>            :               goto handle_declarator;
<span class="lineNum">   20266 </span>            :             }
<span class="lineNum">   20267 </span><span class="lineCov">   10684151 :           /* Otherwise, we must be done.  */</span>
<span class="lineNum">   20268 </span>            :           else
<span class="lineNum">   20269 </span><span class="lineCov">   10684151 :             break;</span>
<span class="lineNum">   20270 </span>            :         }
<span class="lineNum">   20271 </span><span class="lineCov">   10406532 :       else if ((!first || dcl_kind != CP_PARSER_DECLARATOR_NAMED)</span>
<span class="lineNum">   20272 </span>            :                &amp;&amp; token-&gt;type == CPP_OPEN_SQUARE
<span class="lineNum">   20273 </span>            :                &amp;&amp; !cp_next_tokens_can_be_attribute_p (parser))
<span class="lineNum">   20274 </span>            :         {
<span class="lineNum">   20275 </span>            :           /* Parse an array-declarator.  */
<span class="lineNum">   20276 </span><span class="lineCov">     367955 :           tree bounds, attrs;</span>
<span class="lineNum">   20277 </span>            : 
<span class="lineNum">   20278 </span><span class="lineCov">     238855 :           if (ctor_dtor_or_conv_p)</span>
<span class="lineNum">   20279 </span>            :             *ctor_dtor_or_conv_p = 0;
<span class="lineNum">   20280 </span><span class="lineCov">     238855 : </span>
<span class="lineNum">   20281 </span><span class="lineCov">     238855 :           open_paren = NULL;</span>
<span class="lineNum">   20282 </span>            :           first = false;
<span class="lineNum">   20283 </span><span class="lineCov">     238855 :           parser-&gt;default_arg_ok_p = false;</span>
<span class="lineNum">   20284 </span>            :           parser-&gt;in_declarator_p = true;
<span class="lineNum">   20285 </span><span class="lineCov">     477710 :           /* Consume the `['.  */</span>
<span class="lineNum">   20286 </span><span class="lineCov">     238855 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   20287 </span>            :           /* Peek at the next token.  */
<span class="lineNum">   20288 </span><span class="lineCov">     238855 :           token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   20289 </span><span class="lineCov">     238855 :           /* If the next token is `]', then there is no</span>
<span class="lineNum">   20290 </span><span class="lineCov">     238855 :              constant-expression.  */</span>
<span class="lineNum">   20291 </span><span class="lineCov">     238855 :           if (token-&gt;type != CPP_CLOSE_SQUARE)</span>
<span class="lineNum">   20292 </span>            :             {
<span class="lineNum">   20293 </span>            :               bool non_constant_p;
<span class="lineNum">   20294 </span><span class="lineCov">     238855 :               bounds</span>
<span class="lineNum">   20295 </span><span class="lineCov">     238855 :                 = cp_parser_constant_expression (parser,</span>
<span class="lineNum">   20296 </span>            :                                                  /*allow_non_constant=*/true,
<span class="lineNum">   20297 </span><span class="lineCov">     477710 :                                                  &amp;non_constant_p);</span>
<span class="lineNum">   20298 </span><span class="lineCov">     238855 :               if (!non_constant_p)</span>
<span class="lineNum">   20299 </span><span class="lineCov">      23917 :                 /* OK */;</span>
<span class="lineNum">   20300 </span><span class="lineCov">     238855 :               else if (error_operand_p (bounds))</span>
<span class="lineNum">   20301 </span>            :                 /* Already gave an error.  */;
<span class="lineNum">   20302 </span>            :               else if (!parser-&gt;in_function_body
<span class="lineNum">   20303 </span><span class="lineCov">     205476 :                        || current_binding_level-&gt;kind == sk_function_parms)</span>
<span class="lineNum">   20304 </span>            :                 {
<span class="lineNum">   20305 </span>            :                   /* Normally, the array bound must be an integral constant
<span class="lineNum">   20306 </span>            :                      expression.  However, as an extension, we allow VLAs
<span class="lineNum">   20307 </span>            :                      in function scopes as long as they aren't part of a
<span class="lineNum">   20308 </span>            :                      parameter declaration.  */
<span class="lineNum">   20309 </span><span class="lineCov">   82432364 :                   cp_parser_error (parser,</span>
<span class="lineNum">   20310 </span><span class="lineCov">   65175085 :                                    &quot;array bound is not an integer constant&quot;);</span>
<span class="lineNum">   20311 </span><span class="lineCov">   82831866 :                   bounds = error_mark_node;</span>
<span class="lineNum">   20312 </span>            :                 }
<span class="lineNum">   20313 </span>            :               else if (processing_template_decl
<span class="lineNum">   20314 </span><span class="lineCov">     399502 :                        &amp;&amp; !type_dependent_expression_p (bounds))</span>
<span class="lineNum">   20315 </span>            :                 {
<span class="lineNum">   20316 </span><span class="lineCov">     399502 :                   /* Remember this wasn't a constant-expression.  */</span>
<span class="lineNum">   20317 </span><span class="lineCov">     199385 :                   bounds = build_nop (TREE_TYPE (bounds), bounds);</span>
<span class="lineNum">   20318 </span>            :                   TREE_SIDE_EFFECTS (bounds) = 1;
<span class="lineNum">   20319 </span><span class="lineCov">     399502 :                 }</span>
<span class="lineNum">   20320 </span><span class="lineCov">     399502 :             }</span>
<span class="lineNum">   20321 </span><span class="lineCov">     399502 :           else</span>
<span class="lineNum">   20322 </span><span class="lineCov">     399502 :             bounds = NULL_TREE;</span>
<span class="lineNum">   20323 </span>            :           /* Look for the closing `]'.  */
<span class="lineNum">   20324 </span><span class="lineCov">     399502 :           if (!cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE))</span>
<span class="lineNum">   20325 </span>            :             {
<span class="lineNum">   20326 </span><span class="lineCov">     799004 :               declarator = cp_error_declarator;</span>
<span class="lineNum">   20327 </span>            :               break;
<span class="lineNum">   20328 </span>            :             }
<span class="lineNum">   20329 </span><span class="lineCov">     399502 : </span>
<span class="lineNum">   20330 </span>            :           attrs = cp_parser_std_attribute_spec_seq (parser);
<span class="lineNum">   20331 </span><span class="lineCov">     271694 :           declarator = make_array_declarator (declarator, bounds);</span>
<span class="lineNum">   20332 </span><span class="lineCov">     271694 :           declarator-&gt;std_attributes = attrs;</span>
<span class="lineNum">   20333 </span><span class="lineCov">     271694 :         }</span>
<span class="lineNum">   20334 </span>            :       else if (first &amp;&amp; dcl_kind != CP_PARSER_DECLARATOR_ABSTRACT)
<span class="lineNum">   20335 </span><span class="lineCov">     271694 :         {</span>
<span class="lineNum">   20336 </span><span class="lineCov">     271694 :           {</span>
<span class="lineNum">   20337 </span>            :             tree qualifying_scope;
<span class="lineNum">   20338 </span><span class="lineCov">        654 :             tree unqualified_name;</span>
<span class="lineNum">   20339 </span>            :             tree attrs;
<span class="lineNum">   20340 </span><span class="lineCov">        618 :             special_function_kind sfk;</span>
<span class="lineNum">   20341 </span><span class="lineCov">        598 :             bool abstract_ok;</span>
<span class="lineNum">   20342 </span>            :             bool pack_expansion_p = false;
<span class="lineNum">   20343 </span>            :             cp_token *declarator_id_start_token;
<span class="lineNum">   20344 </span>            : 
<span class="lineNum">   20345 </span>            :             /* Parse a declarator-id */
<span class="lineNum">   20346 </span>            :             abstract_ok = (dcl_kind == CP_PARSER_DECLARATOR_EITHER);
<span class="lineNum">   20347 </span><span class="lineCov">         26 :             if (abstract_ok)</span>
<span class="lineNum">   20348 </span>            :               {
<span class="lineNum">   20349 </span><span class="lineCov">         26 :                 cp_parser_parse_tentatively (parser);</span>
<span class="lineNum">   20350 </span>            : 
<span class="lineNum">   20351 </span><span class="lineCov">        592 :                 /* If we see an ellipsis, we should be looking at a</span>
<span class="lineNum">   20352 </span><span class="lineCov">        592 :                    parameter pack. */</span>
<span class="lineNum">   20353 </span>            :                 if (token-&gt;type == CPP_ELLIPSIS)
<span class="lineNum">   20354 </span>            :                   {
<span class="lineNum">   20355 </span><span class="lineCov">         15 :                     /* Consume the `...' */</span>
<span class="lineNum">   20356 </span><span class="lineCov">         15 :                     cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   20357 </span>            : 
<span class="lineNum">   20358 </span>            :                     pack_expansion_p = true;
<span class="lineNum">   20359 </span>            :                   }
<span class="lineNum">   20360 </span>            :               }
<span class="lineNum">   20361 </span>            : 
<span class="lineNum">   20362 </span><span class="lineCov">     399502 :             declarator_id_start_token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   20363 </span>            :             unqualified_name
<span class="lineNum">   20364 </span><span class="lineCov">          9 :               = cp_parser_declarator_id (parser, /*optional_p=*/abstract_ok);</span>
<span class="lineNum">   20365 </span><span class="lineCov">          9 :             qualifying_scope = parser-&gt;scope;</span>
<span class="lineNum">   20366 </span>            :             if (abstract_ok)
<span class="lineNum">   20367 </span>            :               {
<span class="lineNum">   20368 </span><span class="lineCov">     399493 :                 bool okay = false;</span>
<span class="lineNum">   20369 </span><span class="lineCov">     399493 : </span>
<span class="lineNum">   20370 </span><span class="lineCov">     399493 :                 if (!unqualified_name &amp;&amp; pack_expansion_p)</span>
<span class="lineNum">   20371 </span>            :                   {
<span class="lineNum">   20372 </span><span class="lineCov">   82032862 :                     /* Check whether an error occurred. */</span>
<span class="lineNum">   20373 </span>            :                     okay = !cp_parser_error_occurred (parser);
<span class="lineNum">   20374 </span><span class="lineCov">   33302278 : </span>
<span class="lineNum">   20375 </span><span class="lineCov">   33302278 :                     /* We already consumed the ellipsis to mark a</span>
<span class="lineNum">   20376 </span><span class="lineCov">   33302278 :                        parameter pack, but we have no way to report it,</span>
<span class="lineNum">   20377 </span><span class="lineCov">   33302278 :                        so abort the tentative parse. We will be exiting</span>
<span class="lineNum">   20378 </span><span class="lineCov">   33302278 :                        immediately anyway. */</span>
<span class="lineNum">   20379 </span><span class="lineCov">   33302278 :                     cp_parser_abort_tentative_parse (parser);</span>
<span class="lineNum">   20380 </span><span class="lineCov">   33302278 :                   }</span>
<span class="lineNum">   20381 </span><span class="lineCov">   33302278 :                 else</span>
<span class="lineNum">   20382 </span>            :                   okay = cp_parser_parse_definitely (parser);
<span class="lineNum">   20383 </span>            : 
<span class="lineNum">   20384 </span><span class="lineCov">   33302278 :                 if (!okay)</span>
<span class="lineNum">   20385 </span><span class="lineCov">   33302278 :                   unqualified_name = error_mark_node;</span>
<span class="lineNum">   20386 </span>            :                 else if (unqualified_name
<span class="lineNum">   20387 </span><span class="lineCov">   16044999 :                          &amp;&amp; (qualifying_scope</span>
<span class="lineNum">   20388 </span>            :                              || (!identifier_p (unqualified_name))))
<span class="lineNum">   20389 </span>            :                   {
<span class="lineNum">   20390 </span>            :                     cp_parser_error (parser, &quot;expected unqualified-id&quot;);
<span class="lineNum">   20391 </span><span class="lineCov">   16044999 :                     unqualified_name = error_mark_node;</span>
<span class="lineNum">   20392 </span>            :                   }
<span class="lineNum">   20393 </span>            :               }
<span class="lineNum">   20394 </span><span class="lineCov">     229001 : </span>
<span class="lineNum">   20395 </span>            :             if (!unqualified_name)
<span class="lineNum">   20396 </span><span class="lineCov">     229001 :               return NULL;</span>
<span class="lineNum">   20397 </span>            :             if (unqualified_name == error_mark_node)
<span class="lineNum">   20398 </span>            :               {
<span class="lineNum">   20399 </span>            :                 declarator = cp_error_declarator;
<span class="lineNum">   20400 </span><span class="lineCov">   66604556 :                 pack_expansion_p = false;</span>
<span class="lineNum">   20401 </span><span class="lineCov">   33302278 :                 declarator-&gt;parameter_pack_p = false;</span>
<span class="lineNum">   20402 </span><span class="lineCov">   33302278 :                 break;</span>
<span class="lineNum">   20403 </span><span class="lineCov">   33302278 :               }</span>
<span class="lineNum">   20404 </span><span class="lineCov">   33302278 : </span>
<span class="lineNum">   20405 </span>            :             attrs = cp_parser_std_attribute_spec_seq (parser);
<span class="lineNum">   20406 </span><span class="lineCov">   16044999 : </span>
<span class="lineNum">   20407 </span>            :             if (qualifying_scope &amp;&amp; at_namespace_scope_p ()
<span class="lineNum">   20408 </span><span class="lineCov">   16044999 :                 &amp;&amp; TREE_CODE (qualifying_scope) == TYPENAME_TYPE)</span>
<span class="lineNum">   20409 </span>            :               {
<span class="lineNum">   20410 </span>            :                 /* In the declaration of a member of a template class
<span class="lineNum">   20411 </span><span class="lineCov">     247042 :                    outside of the class itself, the SCOPE will sometimes</span>
<span class="lineNum">   20412 </span>            :                    be a TYPENAME_TYPE.  For example, given:
<span class="lineNum">   20413 </span>            : 
<span class="lineNum">   20414 </span>            :                    template &lt;typename T&gt;
<span class="lineNum">   20415 </span>            :                    int S&lt;T&gt;::R::i = 3;
<span class="lineNum">   20416 </span>            : 
<span class="lineNum">   20417 </span><span class="lineCov">     123521 :                    the SCOPE will be a TYPENAME_TYPE for `S&lt;T&gt;::R'.  In</span>
<span class="lineNum">   20418 </span>            :                    this context, we must resolve S&lt;T&gt;::R to an ordinary
<span class="lineNum">   20419 </span>            :                    type, rather than a typename type.
<span class="lineNum">   20420 </span><span class="lineCov">   15921478 : </span>
<span class="lineNum">   20421 </span>            :                    The reason we normally avoid resolving TYPENAME_TYPEs
<span class="lineNum">   20422 </span><span class="lineCov">   16044999 :                    is that a specialization of `S' might render</span>
<span class="lineNum">   20423 </span><span class="lineCov">          1 :                    `S&lt;T&gt;::R' not a type.  However, if `S' is</span>
<span class="lineNum">   20424 </span><span class="lineCov">   16044998 :                    specialized, then this `i' will not be used, so there</span>
<span class="lineNum">   20425 </span><span class="lineCov">   16044998 :                    is no harm in resolving the types here.  */</span>
<span class="lineNum">   20426 </span><span class="lineCov">   14834459 :                 tree type;</span>
<span class="lineNum">   20427 </span>            : 
<span class="lineNum">   20428 </span><span class="lineCov">          7 :                 /* Resolve the TYPENAME_TYPE.  */</span>
<span class="lineNum">   20429 </span><span class="lineCov">          7 :                 type = resolve_typename_type (qualifying_scope,</span>
<span class="lineNum">   20430 </span>            :                                               /*only_current_p=*/false);
<span class="lineNum">   20431 </span>            :                 /* If that failed, the declarator is invalid.  */
<span class="lineNum">   20432 </span>            :                 if (TREE_CODE (type) == TYPENAME_TYPE)
<span class="lineNum">   20433 </span><span class="lineCov">   33302278 :                   {</span>
<span class="lineNum">   20434 </span>            :                     if (typedef_variant_p (type))
<span class="lineNum">   20435 </span><span class="lineCov">   32091745 :                       error_at (declarator_id_start_token-&gt;location,</span>
<span class="lineNum">   20436 </span>            :                                 &quot;cannot define member of dependent typedef &quot;
<span class="lineNum">   20437 </span><span class="lineCov">      13983 :                                 &quot;%qT&quot;, type);</span>
<span class="lineNum">   20438 </span><span class="lineCov">      13983 :                     else</span>
<span class="lineNum">   20439 </span><span class="lineCov">      13983 :                       error_at (declarator_id_start_token-&gt;location,</span>
<span class="lineNum">   20440 </span><span class="lineCov">      13983 :                                 &quot;%&lt;%T::%E%&gt; is not a type&quot;,</span>
<span class="lineNum">   20441 </span>            :                                 TYPE_CONTEXT (qualifying_scope),
<span class="lineNum">   20442 </span>            :                                 TYPE_IDENTIFIER (qualifying_scope));
<span class="lineNum">   20443 </span><span class="lineCov">   32077762 :                   }</span>
<span class="lineNum">   20444 </span>            :                 qualifying_scope = type;
<span class="lineNum">   20445 </span><span class="lineCov">     478473 :               }</span>
<span class="lineNum">   20446 </span><span class="lineCov">   32545799 : </span>
<span class="lineNum">   20447 </span>            :             sfk = sfk_none;
<span class="lineNum">   20448 </span>            : 
<span class="lineNum">   20449 </span>            :             if (unqualified_name)
<span class="lineNum">   20450 </span>            :               {
<span class="lineNum">   20451 </span>            :                 tree class_type;
<span class="lineNum">   20452 </span>            : 
<span class="lineNum">   20453 </span>            :                 if (qualifying_scope
<span class="lineNum">   20454 </span>            :                     &amp;&amp; CLASS_TYPE_P (qualifying_scope))
<span class="lineNum">   20455 </span>            :                   class_type = qualifying_scope;
<span class="lineNum">   20456 </span>            :                 else
<span class="lineNum">   20457 </span>            :                   class_type = current_class_type;
<span class="lineNum">   20458 </span>            : 
<span class="lineNum">   20459 </span>            :                 if (TREE_CODE (unqualified_name) == TYPE_DECL)
<span class="lineNum">   20460 </span>            :                   {
<span class="lineNum">   20461 </span>            :                     tree name_type = TREE_TYPE (unqualified_name);
<span class="lineNum">   20462 </span>            : 
<span class="lineNum">   20463 </span>            :                     if (!class_type || !same_type_p (name_type, class_type))
<span class="lineNum">   20464 </span><span class="lineCov">         18 :                       {</span>
<span class="lineNum">   20465 </span>            :                         /* We do not attempt to print the declarator
<span class="lineNum">   20466 </span>            :                            here because we do not have enough
<span class="lineNum">   20467 </span><span class="lineCov">         18 :                            information about its original syntactic</span>
<span class="lineNum">   20468 </span>            :                            form.  */
<span class="lineNum">   20469 </span>            :                         cp_parser_error (parser, &quot;invalid declarator&quot;);
<span class="lineNum">   20470 </span><span class="lineCov">         18 :                         declarator = cp_error_declarator;</span>
<span class="lineNum">   20471 </span>            :                         break;
<span class="lineNum">   20472 </span><span class="lineCov">         18 :                       }</span>
<span class="lineNum">   20473 </span><span class="lineCov">          6 :                     else if (qualifying_scope</span>
<span class="lineNum">   20474 </span>            :                              &amp;&amp; CLASSTYPE_USE_TEMPLATE (name_type))
<span class="lineNum">   20475 </span>            :                       {
<span class="lineNum">   20476 </span>            :                         error_at (declarator_id_start_token-&gt;location,
<span class="lineNum">   20477 </span><span class="lineCov">         48 :                                   &quot;invalid use of constructor as a template&quot;);</span>
<span class="lineNum">   20478 </span>            :                         inform (declarator_id_start_token-&gt;location,
<span class="lineNum">   20479 </span><span class="lineCov">         24 :                                 &quot;use %&lt;%T::%D%&gt; instead of %&lt;%T::%D%&gt; to &quot;</span>
<span class="lineNum">   20480 </span><span class="lineCov">         12 :                                 &quot;name the constructor in a qualified name&quot;,</span>
<span class="lineNum">   20481 </span>            :                                 class_type,
<span class="lineNum">   20482 </span>            :                                 DECL_NAME (TYPE_TI_TEMPLATE (class_type)),
<span class="lineNum">   20483 </span>            :                                 class_type, name_type);
<span class="lineNum">   20484 </span>            :                         declarator = cp_error_declarator;
<span class="lineNum">   20485 </span><span class="lineCov">   32077762 :                         break;</span>
<span class="lineNum">   20486 </span>            :                       }
<span class="lineNum">   20487 </span><span class="lineCov">   32077762 :                     unqualified_name = constructor_name (class_type);</span>
<span class="lineNum">   20488 </span>            :                   }
<span class="lineNum">   20489 </span><span class="lineCov">   32077762 : </span>
<span class="lineNum">   20490 </span>            :                 if (class_type)
<span class="lineNum">   20491 </span><span class="lineCov">   32077762 :                   {</span>
<span class="lineNum">   20492 </span><span class="lineCov">   32077762 :                     if (TREE_CODE (unqualified_name) == BIT_NOT_EXPR)</span>
<span class="lineNum">   20493 </span>            :                       sfk = sfk_destructor;
<span class="lineNum">   20494 </span>            :                     else if (identifier_p (unqualified_name)
<span class="lineNum">   20495 </span><span class="lineCov">   31610726 :                              &amp;&amp; IDENTIFIER_CONV_OP_P (unqualified_name))</span>
<span class="lineNum">   20496 </span>            :                       sfk = sfk_conversion;
<span class="lineNum">   20497 </span><span class="lineCov">   32077762 :                     else if (/* There's no way to declare a constructor</span>
<span class="lineNum">   20498 </span>            :                                 for an unnamed type, even if the type
<span class="lineNum">   20499 </span><span class="lineCov">        279 :                                 got a name for linkage purposes.  */</span>
<span class="lineNum">   20500 </span>            :                              !TYPE_WAS_UNNAMED (class_type)
<span class="lineNum">   20501 </span><span class="lineCov">        279 :                              /* Handle correctly (c++/19200):</span>
<span class="lineNum">   20502 </span>            : 
<span class="lineNum">   20503 </span>            :                                 struct S {
<span class="lineNum">   20504 </span>            :                                   struct T{};
<span class="lineNum">   20505 </span>            :                                   friend void S(T);
<span class="lineNum">   20506 </span>            :                                 };
<span class="lineNum">   20507 </span><span class="lineCov">         96 : </span>
<span class="lineNum">   20508 </span><span class="lineCov">         96 :                                 and also:</span>
<span class="lineNum">   20509 </span><span class="lineCov">         96 : </span>
<span class="lineNum">   20510 </span>            :                                 namespace N {
<span class="lineNum">   20511 </span><span class="lineCov">        183 :                                   void S();</span>
<span class="lineNum">   20512 </span><span class="lineCov">        183 :                                 }</span>
<span class="lineNum">   20513 </span>            : 
<span class="lineNum">   20514 </span><span class="lineNoCov">          0 :                                 struct S {</span>
<span class="lineNum">   20515 </span>            :                                   friend void N::S();
<span class="lineNum">   20516 </span><span class="lineNoCov">          0 :                                 };  */</span>
<span class="lineNum">   20517 </span>            :                              &amp;&amp; (!friend_p || class_type == qualifying_scope)
<span class="lineNum">   20518 </span>            :                              &amp;&amp; constructor_name_p (unqualified_name,
<span class="lineNum">   20519 </span>            :                                                     class_type))
<span class="lineNum">   20520 </span><span class="lineNoCov">          0 :                       sfk = sfk_constructor;</span>
<span class="lineNum">   20521 </span>            :                     else if (is_overloaded_fn (unqualified_name)
<span class="lineNum">   20522 </span><span class="lineNoCov">          0 :                              &amp;&amp; DECL_CONSTRUCTOR_P (get_first_fn</span>
<span class="lineNum">   20523 </span><span class="lineNoCov">          0 :                                                     (unqualified_name)))</span>
<span class="lineNum">   20524 </span>            :                       sfk = sfk_constructor;
<span class="lineNum">   20525 </span><span class="lineCov">        183 : </span>
<span class="lineNum">   20526 </span>            :                     if (ctor_dtor_or_conv_p &amp;&amp; sfk != sfk_none)
<span class="lineNum">   20527 </span>            :                       *ctor_dtor_or_conv_p = -1;
<span class="lineNum">   20528 </span><span class="lineCov">   32077666 :                   }</span>
<span class="lineNum">   20529 </span>            :               }
<span class="lineNum">   20530 </span><span class="lineCov">   13953065 :             declarator = make_id_declarator (qualifying_scope,</span>
<span class="lineNum">   20531 </span>            :                                              unqualified_name,
<span class="lineNum">   20532 </span><span class="lineCov">   13783387 :                                              sfk);</span>
<span class="lineNum">   20533 </span><span class="lineCov">   96473405 :             declarator-&gt;std_attributes = attrs;</span>
<span class="lineNum">   20534 </span>            :             declarator-&gt;id_loc = token-&gt;location;
<span class="lineNum">   20535 </span><span class="lineCov">   13757671 :             declarator-&gt;parameter_pack_p = pack_expansion_p;</span>
<span class="lineNum">   20536 </span>            : 
<span class="lineNum">   20537 </span>            :             if (pack_expansion_p)
<span class="lineNum">   20538 </span><span class="lineCov">   13757671 :               maybe_warn_variadic_templates ();</span>
<span class="lineNum">   20539 </span>            :           }
<span class="lineNum">   20540 </span>            : 
<span class="lineNum">   20541 </span>            :         handle_declarator:;
<span class="lineNum">   20542 </span>            :           scope = get_scope_of_declarator (declarator);
<span class="lineNum">   20543 </span>            :           if (scope)
<span class="lineNum">   20544 </span>            :             {
<span class="lineNum">   20545 </span>            :               /* Any names that appear after the declarator-id for a
<span class="lineNum">   20546 </span>            :                  member are looked up in the containing scope.  */
<span class="lineNum">   20547 </span>            :               if (at_function_scope_p ())
<span class="lineNum">   20548 </span>            :                 {
<span class="lineNum">   20549 </span>            :                   /* But declarations with qualified-ids can't appear in a
<span class="lineNum">   20550 </span>            :                      function.  */
<span class="lineNum">   20551 </span>            :                   cp_parser_error (parser, &quot;qualified-id in declaration&quot;);
<span class="lineNum">   20552 </span>            :                   declarator = cp_error_declarator;
<span class="lineNum">   20553 </span>            :                   break;
<span class="lineNum">   20554 </span>            :                 }
<span class="lineNum">   20555 </span><span class="lineCov">   13757665 :               pushed_scope = push_scope (scope);</span>
<span class="lineNum">   20556 </span><span class="lineCov">   27448746 :             }</span>
<span class="lineNum">   20557 </span>            :           parser-&gt;in_declarator_p = true;
<span class="lineNum">   20558 </span>            :           if ((ctor_dtor_or_conv_p &amp;&amp; *ctor_dtor_or_conv_p)
<span class="lineNum">   20559 </span><span class="lineCov">   12813486 :               || (declarator &amp;&amp; declarator-&gt;kind == cdk_id))</span>
<span class="lineNum">   20560 </span><span class="lineCov">   12813486 :             /* Default args are only allowed on function</span>
<span class="lineNum">   20561 </span>            :                declarations.  */
<span class="lineNum">   20562 </span>            :             parser-&gt;default_arg_ok_p = saved_default_arg_ok_p;
<span class="lineNum">   20563 </span>            :           else
<span class="lineNum">   20564 </span><span class="lineCov">   13953065 :             parser-&gt;default_arg_ok_p = false;</span>
<span class="lineNum">   20565 </span><span class="lineCov">    1139493 : </span>
<span class="lineNum">   20566 </span>            :           first = false;
<span class="lineNum">   20567 </span>            :         }
<span class="lineNum">   20568 </span><span class="lineCov">   32077666 :       /* We're done.  */</span>
<span class="lineNum">   20569 </span>            :       else
<span class="lineNum">   20570 </span>            :         break;
<span class="lineNum">   20571 </span><span class="lineCov">   32077666 :     }</span>
<span class="lineNum">   20572 </span><span class="lineCov">   32077666 : </span>
<span class="lineNum">   20573 </span><span class="lineCov">   32077666 :   /* For an abstract declarator, we might wind up with nothing at this</span>
<span class="lineNum">   20574 </span>            :      point.  That's an error; the declarator is not optional.  */
<span class="lineNum">   20575 </span><span class="lineCov">   32077666 :   if (!declarator)</span>
<span class="lineNum">   20576 </span><span class="lineCov">     105480 :     cp_parser_error (parser, &quot;expected declarator&quot;);</span>
<span class="lineNum">   20577 </span>            :   else if (open_paren)
<span class="lineNum">   20578 </span>            :     {
<span class="lineNum">   20579 </span><span class="lineCov">   32283142 :       /* Record overly parenthesized declarator so we can give a</span>
<span class="lineNum">   20580 </span><span class="lineCov">   32283142 :          diagnostic about confusing decl/expr disambiguation.  */</span>
<span class="lineNum">   20581 </span><span class="lineCov">   32283142 :       if (declarator-&gt;kind == cdk_array)</span>
<span class="lineNum">   20582 </span>            :         {
<span class="lineNum">   20583 </span>            :           /* If the open and close parens are on different lines, this
<span class="lineNum">   20584 </span>            :              is probably a formatting thing, so ignore.  */
<span class="lineNum">   20585 </span><span class="lineCov">     478534 :           expanded_location open = expand_location (open_paren-&gt;location);</span>
<span class="lineNum">   20586 </span>            :           expanded_location close = expand_location (close_paren-&gt;location);
<span class="lineNum">   20587 </span>            :           if (open.line != close.line || open.file != close.file)
<span class="lineNum">   20588 </span>            :             open_paren = NULL;
<span class="lineNum">   20589 </span><span class="lineCov">       4072 :         }</span>
<span class="lineNum">   20590 </span><span class="lineCov">       4072 :       if (open_paren)</span>
<span class="lineNum">   20591 </span><span class="lineCov">       4072 :         declarator-&gt;parenthesized = open_paren-&gt;location;</span>
<span class="lineNum">   20592 </span>            :     }
<span class="lineNum">   20593 </span><span class="lineCov">     474462 : </span>
<span class="lineNum">   20594 </span>            :   /* If we entered a scope, we must exit it now.  */
<span class="lineNum">   20595 </span><span class="lineCov">   32279070 :   if (pushed_scope)</span>
<span class="lineNum">   20596 </span><span class="lineCov">   32279070 :     pop_scope (pushed_scope);</span>
<span class="lineNum">   20597 </span><span class="lineCov">   31139577 : </span>
<span class="lineNum">   20598 </span>            :   parser-&gt;default_arg_ok_p = saved_default_arg_ok_p;
<span class="lineNum">   20599 </span>            :   parser-&gt;in_declarator_p = saved_in_declarator_p;
<span class="lineNum">   20600 </span><span class="lineCov">   32077065 : </span>
<span class="lineNum">   20601 </span>            :   return declarator;
<span class="lineNum">   20602 </span><span class="lineCov">     202005 : }</span>
<span class="lineNum">   20603 </span>            : 
<span class="lineNum">   20604 </span>            : /* Parse a ptr-operator.
<span class="lineNum">   20605 </span>            : 
<span class="lineNum">   20606 </span>            :    ptr-operator:
<span class="lineNum">   20607 </span>            :      * attribute-specifier-seq [opt] cv-qualifier-seq [opt] (C++11)
<span class="lineNum">   20608 </span>            :      * cv-qualifier-seq [opt]
<span class="lineNum">   20609 </span>            :      &amp;
<span class="lineNum">   20610 </span>            :      :: [opt] nested-name-specifier * cv-qualifier-seq [opt]
<span class="lineNum">   20611 </span>            :      nested-name-specifier * attribute-specifier-seq [opt] cv-qualifier-seq [opt] (C++11)
<span class="lineNum">   20612 </span>            : 
<span class="lineNum">   20613 </span><span class="lineCov">   48911223 :    GNU Extension:</span>
<span class="lineNum">   20614 </span><span class="lineCov">   16431118 : </span>
<span class="lineNum">   20615 </span><span class="lineCov">   32480105 :    ptr-operator:</span>
<span class="lineNum">   20616 </span>            :      &amp; cv-qualifier-seq [opt]
<span class="lineNum">   20617 </span>            : 
<span class="lineNum">   20618 </span>            :    Returns INDIRECT_REF if a pointer, or pointer-to-member, was used.
<span class="lineNum">   20619 </span><span class="lineCov">      36961 :    Returns ADDR_EXPR if a reference was used, or NON_LVALUE_EXPR for</span>
<span class="lineNum">   20620 </span>            :    an rvalue reference. In the case of a pointer-to-member, *TYPE is
<span class="lineNum">   20621 </span>            :    filled in with the TYPE containing the member.  *CV_QUALS is
<span class="lineNum">   20622 </span>            :    filled in with the cv-qualifier-seq, or TYPE_UNQUALIFIED, if there
<span class="lineNum">   20623 </span><span class="lineCov">         24 :    are no cv-qualifiers.  Returns ERROR_MARK if an error occurred.</span>
<span class="lineNum">   20624 </span><span class="lineCov">         24 :    Note that the tree codes returned by this function have nothing</span>
<span class="lineNum">   20625 </span><span class="lineCov">         24 :    to do with the types of trees that will be eventually be created</span>
<span class="lineNum">   20626 </span><span class="lineCov">          6 :    to represent the pointer or reference type being parsed. They are</span>
<a name="20627"><span class="lineNum">   20627 </span>            :    just constants with suggestive names. */</a>
<span class="lineNum">   20628 </span><span class="lineCov">          6 : static enum tree_code</span>
<span class="lineNum">   20629 </span><span class="lineCov">      36955 : cp_parser_ptr_operator (cp_parser* parser,</span>
<span class="lineNum">   20630 </span>            :                         tree* type,
<span class="lineNum">   20631 </span>            :                         cp_cv_quals *cv_quals,
<span class="lineNum">   20632 </span>            :                         tree *attributes)
<span class="lineNum">   20633 </span><span class="lineCov">   48911223 : {</span>
<span class="lineNum">   20634 </span><span class="lineCov">     474408 :   enum tree_code code = ERROR_MARK;</span>
<span class="lineNum">   20635 </span>            :   cp_token *token;
<span class="lineNum">   20636 </span><span class="lineCov">   48911223 :   tree attrs = NULL_TREE;</span>
<span class="lineNum">   20637 </span><span class="lineCov">   48911223 : </span>
<span class="lineNum">   20638 </span>            :   /* Assume that it's not a pointer-to-member.  */
<span class="lineNum">   20639 </span><span class="lineCov">   48911223 :   *type = NULL_TREE;</span>
<span class="lineNum">   20640 </span>            :   /* And that there are no cv-qualifiers.  */
<span class="lineNum">   20641 </span>            :   *cv_quals = TYPE_UNQUALIFIED;
<span class="lineNum">   20642 </span>            : 
<span class="lineNum">   20643 </span>            :   /* Peek at the next token.  */
<span class="lineNum">   20644 </span>            :   token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   20645 </span>            : 
<span class="lineNum">   20646 </span>            :   /* If it's a `*', `&amp;' or `&amp;&amp;' we have a pointer or reference.  */
<span class="lineNum">   20647 </span>            :   if (token-&gt;type == CPP_MULT)
<span class="lineNum">   20648 </span>            :     code = INDIRECT_REF;
<span class="lineNum">   20649 </span>            :   else if (token-&gt;type == CPP_AND)
<span class="lineNum">   20650 </span>            :     code = ADDR_EXPR;
<span class="lineNum">   20651 </span>            :   else if ((cxx_dialect != cxx98) &amp;&amp;
<span class="lineNum">   20652 </span>            :            token-&gt;type == CPP_AND_AND) /* C++0x only */
<span class="lineNum">   20653 </span>            :     code = NON_LVALUE_EXPR;
<span class="lineNum">   20654 </span>            : 
<span class="lineNum">   20655 </span>            :   if (code != ERROR_MARK)
<span class="lineNum">   20656 </span>            :     {
<span class="lineNum">   20657 </span>            :       /* Consume the `*', `&amp;' or `&amp;&amp;'.  */
<span class="lineNum">   20658 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   20659 </span>            : 
<span class="lineNum">   20660 </span>            :       /* A `*' can be followed by a cv-qualifier-seq, and so can a
<span class="lineNum">   20661 </span>            :          `&amp;', if we are allowing GNU extensions.  (The only qualifier
<span class="lineNum">   20662 </span>            :          that can legally appear after `&amp;' is `restrict', but that is
<span class="lineNum">   20663 </span>            :          enforced during semantic analysis.  */
<span class="lineNum">   20664 </span>            :       if (code == INDIRECT_REF
<span class="lineNum">   20665 </span>            :           || cp_parser_allow_gnu_extensions_p (parser))
<span class="lineNum">   20666 </span>            :         *cv_quals = cp_parser_cv_qualifier_seq_opt (parser);
<span class="lineNum">   20667 </span><span class="lineCov">   60929398 : </span>
<span class="lineNum">   20668 </span>            :       attrs = cp_parser_std_attribute_spec_seq (parser);
<span class="lineNum">   20669 </span>            :       if (attributes != NULL)
<span class="lineNum">   20670 </span>            :         *attributes = attrs;
<span class="lineNum">   20671 </span>            :     }
<span class="lineNum">   20672 </span><span class="lineCov">   60929398 :   else</span>
<span class="lineNum">   20673 </span><span class="lineCov">   60929398 :     {</span>
<span class="lineNum">   20674 </span><span class="lineCov">   60929398 :       /* Try the pointer-to-member case.  */</span>
<span class="lineNum">   20675 </span>            :       cp_parser_parse_tentatively (parser);
<span class="lineNum">   20676 </span>            :       /* Look for the optional `::' operator.  */
<span class="lineNum">   20677 </span><span class="lineCov">   60929398 :       cp_parser_global_scope_opt (parser,</span>
<span class="lineNum">   20678 </span>            :                                   /*current_scope_valid_p=*/false);
<span class="lineNum">   20679 </span><span class="lineCov">   60929398 :       /* Look for the nested-name specifier.  */</span>
<span class="lineNum">   20680 </span>            :       token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   20681 </span>            :       cp_parser_nested_name_specifier (parser,
<span class="lineNum">   20682 </span><span class="lineCov">  121858796 :                                        /*typename_keyword_p=*/false,</span>
<span class="lineNum">   20683 </span>            :                                        /*check_dependency_p=*/true,
<span class="lineNum">   20684 </span>            :                                        /*type_p=*/false,
<span class="lineNum">   20685 </span><span class="lineCov">   60929398 :                                        /*is_declaration=*/false);</span>
<span class="lineNum">   20686 </span>            :       /* If we found it, and the next token is a `*', then we are
<span class="lineNum">   20687 </span><span class="lineCov">   55007858 :          indeed looking at a pointer-to-member operator.  */</span>
<span class="lineNum">   20688 </span>            :       if (!cp_parser_error_occurred (parser)
<span class="lineNum">   20689 </span><span class="lineCov">   50879307 :           &amp;&amp; cp_parser_require (parser, CPP_MULT, RT_MULT))</span>
<span class="lineNum">   20690 </span>            :         {
<span class="lineNum">   20691 </span>            :           /* Indicate that the `*' operator was used.  */
<span class="lineNum">   20692 </span>            :           code = INDIRECT_REF;
<span class="lineNum">   20693 </span>            : 
<span class="lineNum">   20694 </span>            :           if (TREE_CODE (parser-&gt;scope) == NAMESPACE_DECL)
<span class="lineNum">   20695 </span>            :             error_at (token-&gt;location, &quot;%qD is a namespace&quot;, parser-&gt;scope);
<span class="lineNum">   20696 </span><span class="lineCov">   10604410 :           else if (TREE_CODE (parser-&gt;scope) == ENUMERAL_TYPE)</span>
<span class="lineNum">   20697 </span>            :             error_at (token-&gt;location, &quot;cannot form pointer to member of &quot;
<span class="lineNum">   20698 </span>            :                       &quot;non-class %q#T&quot;, parser-&gt;scope);
<span class="lineNum">   20699 </span>            :           else
<span class="lineNum">   20700 </span>            :             {
<span class="lineNum">   20701 </span>            :               /* The type of which the member is a member is given by the
<span class="lineNum">   20702 </span><span class="lineCov">   10604410 :                  current SCOPE.  */</span>
<span class="lineNum">   20703 </span><span class="lineCov">   10604410 :               *type = parser-&gt;scope;</span>
<span class="lineNum">   20704 </span><span class="lineCov">   10604410 :               /* The next name will not be qualified.  */</span>
<span class="lineNum">   20705 </span>            :               parser-&gt;scope = NULL_TREE;
<span class="lineNum">   20706 </span><span class="lineCov">   10604410 :               parser-&gt;qualifying_scope = NULL_TREE;</span>
<span class="lineNum">   20707 </span><span class="lineCov">   10604410 :               parser-&gt;object_scope = NULL_TREE;</span>
<span class="lineNum">   20708 </span><span class="lineCov">   10604410 :               /* Look for optional c++11 attributes.  */</span>
<span class="lineNum">   20709 </span>            :               attrs = cp_parser_std_attribute_spec_seq (parser);
<span class="lineNum">   20710 </span>            :               if (attributes != NULL)
<span class="lineNum">   20711 </span>            :                 *attributes = attrs;
<span class="lineNum">   20712 </span>            :               /* Look for the optional cv-qualifier-seq.  */
<span class="lineNum">   20713 </span><span class="lineCov">   50324988 :               *cv_quals = cp_parser_cv_qualifier_seq_opt (parser);</span>
<span class="lineNum">   20714 </span>            :             }
<span class="lineNum">   20715 </span><span class="lineCov">   50324988 :         }</span>
<span class="lineNum">   20716 </span>            :       /* If that didn't work we don't have a ptr-operator.  */
<span class="lineNum">   20717 </span>            :       if (!cp_parser_parse_definitely (parser))
<span class="lineNum">   20718 </span><span class="lineCov">  100649976 :         cp_parser_error (parser, &quot;expected ptr-operator&quot;);</span>
<span class="lineNum">   20719 </span><span class="lineCov">   50324988 :     }</span>
<span class="lineNum">   20720 </span>            : 
<span class="lineNum">   20721 </span>            :   return code;
<span class="lineNum">   20722 </span>            : }
<span class="lineNum">   20723 </span>            : 
<span class="lineNum">   20724 </span>            : /* Parse an (optional) cv-qualifier-seq.
<span class="lineNum">   20725 </span>            : 
<span class="lineNum">   20726 </span><span class="lineCov">   50905280 :    cv-qualifier-seq:</span>
<span class="lineNum">   20727 </span><span class="lineCov">     580292 :      cv-qualifier cv-qualifier-seq [opt]</span>
<span class="lineNum">   20728 </span>            : 
<span class="lineNum">   20729 </span>            :    cv-qualifier:
<span class="lineNum">   20730 </span><span class="lineCov">     101729 :      const</span>
<span class="lineNum">   20731 </span>            :      volatile
<span class="lineNum">   20732 </span><span class="lineCov">     101729 : </span>
<span class="lineNum">   20733 </span><span class="lineCov">          6 :    GNU Extension:</span>
<span class="lineNum">   20734 </span><span class="lineCov">     101723 : </span>
<span class="lineNum">   20735 </span><span class="lineCov">          2 :    cv-qualifier:</span>
<span class="lineNum">   20736 </span>            :      __restrict__
<span class="lineNum">   20737 </span>            : 
<span class="lineNum">   20738 </span>            :    Returns a bitmask representing the cv-qualifiers.  */
<a name="20739"><span class="lineNum">   20739 </span>            : </a>
<span class="lineNum">   20740 </span>            : static cp_cv_quals
<span class="lineNum">   20741 </span><span class="lineCov">     101721 : cp_parser_cv_qualifier_seq_opt (cp_parser* parser)</span>
<span class="lineNum">   20742 </span>            : {
<span class="lineNum">   20743 </span><span class="lineCov">     101721 :   cp_cv_quals cv_quals = TYPE_UNQUALIFIED;</span>
<span class="lineNum">   20744 </span><span class="lineCov">     101721 : </span>
<span class="lineNum">   20745 </span><span class="lineCov">     101721 :   while (true)</span>
<span class="lineNum">   20746 </span>            :     {
<span class="lineNum">   20747 </span><span class="lineCov">     101721 :       cp_token *token;</span>
<span class="lineNum">   20748 </span><span class="lineCov">     101721 :       cp_cv_quals cv_qualifier;</span>
<span class="lineNum">   20749 </span><span class="lineCov">     101721 : </span>
<span class="lineNum">   20750 </span>            :       /* Peek at the next token.  */
<span class="lineNum">   20751 </span><span class="lineCov">     101721 :       token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   20752 </span>            :       /* See if it's a cv-qualifier.  */
<span class="lineNum">   20753 </span>            :       switch (token-&gt;keyword)
<span class="lineNum">   20754 </span>            :         {
<span class="lineNum">   20755 </span><span class="lineCov">   50324988 :         case RID_CONST:</span>
<span class="lineNum">   20756 </span><span class="lineCov">   50223259 :           cv_qualifier = TYPE_QUAL_CONST;</span>
<span class="lineNum">   20757 </span>            :           break;
<span class="lineNum">   20758 </span>            : 
<span class="lineNum">   20759 </span><span class="lineCov">   60929398 :         case RID_VOLATILE:</span>
<span class="lineNum">   20760 </span>            :           cv_qualifier = TYPE_QUAL_VOLATILE;
<span class="lineNum">   20761 </span>            :           break;
<span class="lineNum">   20762 </span>            : 
<span class="lineNum">   20763 </span>            :         case RID_RESTRICT:
<span class="lineNum">   20764 </span>            :           cv_qualifier = TYPE_QUAL_RESTRICT;
<span class="lineNum">   20765 </span>            :           break;
<span class="lineNum">   20766 </span>            : 
<span class="lineNum">   20767 </span>            :         default:
<span class="lineNum">   20768 </span>            :           cv_qualifier = TYPE_UNQUALIFIED;
<span class="lineNum">   20769 </span>            :           break;
<span class="lineNum">   20770 </span>            :         }
<span class="lineNum">   20771 </span>            : 
<span class="lineNum">   20772 </span>            :       if (!cv_qualifier)
<span class="lineNum">   20773 </span>            :         break;
<span class="lineNum">   20774 </span>            : 
<span class="lineNum">   20775 </span>            :       if (cv_quals &amp; cv_qualifier)
<span class="lineNum">   20776 </span>            :         {
<span class="lineNum">   20777 </span>            :           gcc_rich_location richloc (token-&gt;location);
<span class="lineNum">   20778 </span>            :           richloc.add_fixit_remove ();
<span class="lineNum">   20779 </span><span class="lineCov">   21112663 :           error_at (&amp;richloc, &quot;duplicate cv-qualifier&quot;);</span>
<span class="lineNum">   20780 </span>            :           cp_lexer_purge_token (parser-&gt;lexer);
<span class="lineNum">   20781 </span><span class="lineCov">   21112663 :         }</span>
<span class="lineNum">   20782 </span>            :       else
<span class="lineNum">   20783 </span><span class="lineCov">   23506583 :         {</span>
<span class="lineNum">   20784 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   20785 </span><span class="lineCov">   23506583 :           cv_quals |= cv_qualifier;</span>
<span class="lineNum">   20786 </span><span class="lineCov">   23506583 :         }</span>
<span class="lineNum">   20787 </span>            :     }
<span class="lineNum">   20788 </span>            : 
<span class="lineNum">   20789 </span><span class="lineCov">   47013166 :   return cv_quals;</span>
<span class="lineNum">   20790 </span>            : }
<span class="lineNum">   20791 </span><span class="lineCov">   23506583 : </span>
<span class="lineNum">   20792 </span>            : /* Parse an (optional) ref-qualifier
<span class="lineNum">   20793 </span>            : 
<span class="lineNum">   20794 </span>            :    ref-qualifier:
<span class="lineNum">   20795 </span>            :      &amp;
<span class="lineNum">   20796 </span>            :      &amp;&amp;
<span class="lineNum">   20797 </span><span class="lineCov">      82710 : </span>
<span class="lineNum">   20798 </span><span class="lineCov">      82710 :    Returns cp_ref_qualifier representing ref-qualifier. */</span>
<a name="20799"><span class="lineNum">   20799 </span><span class="lineCov">      82710 : </span></a>
<span class="lineNum">   20800 </span>            : static cp_ref_qualifier
<span class="lineNum">   20801 </span><span class="lineCov">    1000307 : cp_parser_ref_qualifier_opt (cp_parser* parser)</span>
<span class="lineNum">   20802 </span><span class="lineCov">    1000307 : {</span>
<span class="lineNum">   20803 </span><span class="lineCov">    1000307 :   cp_ref_qualifier ref_qual = REF_QUAL_NONE;</span>
<span class="lineNum">   20804 </span>            : 
<span class="lineNum">   20805 </span><span class="lineCov">   21112663 :   /* Don't try to parse bitwise '&amp;' as a ref-qualifier (c++/57532).  */</span>
<span class="lineNum">   20806 </span><span class="lineCov">   21112663 :   if (cxx_dialect &lt; cxx11 &amp;&amp; cp_parser_parsing_tentatively (parser))</span>
<span class="lineNum">   20807 </span><span class="lineCov">   21112663 :     return ref_qual;</span>
<span class="lineNum">   20808 </span>            : 
<span class="lineNum">   20809 </span>            :   while (true)
<span class="lineNum">   20810 </span><span class="lineCov">    1083017 :     {</span>
<span class="lineNum">   20811 </span>            :       cp_ref_qualifier curr_ref_qual = REF_QUAL_NONE;
<span class="lineNum">   20812 </span>            :       cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   20813 </span><span class="lineCov">    2393920 : </span>
<span class="lineNum">   20814 </span>            :       switch (token-&gt;type)
<span class="lineNum">   20815 </span><span class="lineCov">          6 :         {</span>
<span class="lineNum">   20816 </span><span class="lineCov">          3 :         case CPP_AND:</span>
<span class="lineNum">   20817 </span><span class="lineCov">          3 :           curr_ref_qual = REF_QUAL_LVALUE;</span>
<span class="lineNum">   20818 </span><span class="lineCov">          3 :           break;</span>
<span class="lineNum">   20819 </span>            : 
<span class="lineNum">   20820 </span>            :         case CPP_AND_AND:
<span class="lineNum">   20821 </span>            :           curr_ref_qual = REF_QUAL_RVALUE;
<span class="lineNum">   20822 </span><span class="lineCov">    2393917 :           break;</span>
<span class="lineNum">   20823 </span><span class="lineCov">    2393917 : </span>
<span class="lineNum">   20824 </span>            :         default:
<span class="lineNum">   20825 </span>            :           curr_ref_qual = REF_QUAL_NONE;
<span class="lineNum">   20826 </span>            :           break;
<span class="lineNum">   20827 </span><span class="lineCov">   21112663 :         }</span>
<span class="lineNum">   20828 </span>            : 
<span class="lineNum">   20829 </span>            :       if (!curr_ref_qual)
<span class="lineNum">   20830 </span>            :         break;
<span class="lineNum">   20831 </span>            :       else if (ref_qual)
<span class="lineNum">   20832 </span>            :         {
<span class="lineNum">   20833 </span>            :           error_at (token-&gt;location, &quot;multiple ref-qualifiers&quot;);
<span class="lineNum">   20834 </span>            :           cp_lexer_purge_token (parser-&gt;lexer);
<span class="lineNum">   20835 </span>            :         }
<span class="lineNum">   20836 </span>            :       else
<span class="lineNum">   20837 </span>            :         {
<span class="lineNum">   20838 </span>            :           ref_qual = curr_ref_qual;
<span class="lineNum">   20839 </span><span class="lineCov">   10406852 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   20840 </span>            :         }
<span class="lineNum">   20841 </span><span class="lineCov">   10406852 :     }</span>
<span class="lineNum">   20842 </span>            : 
<span class="lineNum">   20843 </span>            :   return ref_qual;
<span class="lineNum">   20844 </span><span class="lineCov">   10406852 : }</span>
<span class="lineNum">   20845 </span>            : 
<span class="lineNum">   20846 </span>            : /* Parse an optional tx-qualifier.
<span class="lineNum">   20847 </span><span class="lineCov">   10202080 : </span>
<span class="lineNum">   20848 </span>            :    tx-qualifier:
<span class="lineNum">   20849 </span><span class="lineCov">   10202080 :      transaction_safe</span>
<span class="lineNum">   20850 </span><span class="lineCov">   20404160 :      transaction_safe_dynamic  */</span>
<a name="20851"><span class="lineNum">   20851 </span>            : </a>
<span class="lineNum">   20852 </span><span class="lineCov">   10202080 : static tree</span>
<span class="lineNum">   20853 </span>            : cp_parser_tx_qualifier_opt (cp_parser *parser)
<span class="lineNum">   20854 </span>            : {
<span class="lineNum">   20855 </span>            :   cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   20856 </span>            :   if (token-&gt;type == CPP_NAME)
<span class="lineNum">   20857 </span>            :     {
<span class="lineNum">   20858 </span>            :       tree name = token-&gt;u.value;
<span class="lineNum">   20859 </span>            :       const char *p = IDENTIFIER_POINTER (name);
<span class="lineNum">   20860 </span>            :       const int len = strlen (&quot;transaction_safe&quot;);
<span class="lineNum">   20861 </span>            :       if (!strncmp (p, &quot;transaction_safe&quot;, len))
<span class="lineNum">   20862 </span>            :         {
<span class="lineNum">   20863 </span>            :           p += len;
<span class="lineNum">   20864 </span>            :           if (*p == '\0'
<span class="lineNum">   20865 </span>            :               || !strcmp (p, &quot;_dynamic&quot;))
<span class="lineNum">   20866 </span>            :             {
<span class="lineNum">   20867 </span><span class="lineCov">      26475 :               cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   20868 </span>            :               if (!flag_tm)
<span class="lineNum">   20869 </span><span class="lineCov">      52678 :                 {</span>
<span class="lineNum">   20870 </span>            :                   error (&quot;%qE requires %&lt;-fgnu-tm%&gt;&quot;, name);
<span class="lineNum">   20871 </span><span class="lineCov">          5 :                   return NULL_TREE;</span>
<span class="lineNum">   20872 </span><span class="lineCov">          5 :                 }</span>
<span class="lineNum">   20873 </span>            :               else
<span class="lineNum">   20874 </span>            :                 return name;
<span class="lineNum">   20875 </span>            :             }
<span class="lineNum">   20876 </span><span class="lineCov">      52673 :         }</span>
<span class="lineNum">   20877 </span><span class="lineCov">      52673 :     }</span>
<span class="lineNum">   20878 </span>            :   return NULL_TREE;
<span class="lineNum">   20879 </span>            : }
<span class="lineNum">   20880 </span>            : 
<span class="lineNum">   20881 </span>            : /* Parse an (optional) virt-specifier-seq.
<span class="lineNum">   20882 </span>            : 
<span class="lineNum">   20883 </span>            :    virt-specifier-seq:
<span class="lineNum">   20884 </span>            :      virt-specifier virt-specifier-seq [opt]
<span class="lineNum">   20885 </span>            : 
<span class="lineNum">   20886 </span>            :    virt-specifier:
<span class="lineNum">   20887 </span>            :      override
<span class="lineNum">   20888 </span>            :      final
<span class="lineNum">   20889 </span>            : 
<span class="lineNum">   20890 </span>            :    Returns a bitmask representing the virt-specifiers.  */
<a name="20891"><span class="lineNum">   20891 </span><span class="lineCov">   10409897 : </span></a>
<span class="lineNum">   20892 </span>            : static cp_virt_specifiers
<span class="lineNum">   20893 </span><span class="lineCov">   20819794 : cp_parser_virt_specifier_seq_opt (cp_parser* parser)</span>
<span class="lineNum">   20894 </span><span class="lineCov">   10409897 : {</span>
<span class="lineNum">   20895 </span>            :   cp_virt_specifiers virt_specifiers = VIRT_SPEC_UNSPECIFIED;
<span class="lineNum">   20896 </span><span class="lineCov">       1282 : </span>
<span class="lineNum">   20897 </span><span class="lineCov">       1282 :   while (true)</span>
<span class="lineNum">   20898 </span><span class="lineCov">       1282 :     {</span>
<span class="lineNum">   20899 </span><span class="lineCov">       1282 :       cp_token *token;</span>
<span class="lineNum">   20900 </span>            :       cp_virt_specifiers virt_specifier;
<span class="lineNum">   20901 </span><span class="lineCov">        133 : </span>
<span class="lineNum">   20902 </span><span class="lineCov">        133 :       /* Peek at the next token.  */</span>
<span class="lineNum">   20903 </span><span class="lineCov">         31 :       token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   20904 </span>            :       /* See if it's a virt-specifier-qualifier.  */
<span class="lineNum">   20905 </span><span class="lineCov">        133 :       if (token-&gt;type != CPP_NAME)</span>
<span class="lineNum">   20906 </span><span class="lineCov">        133 :         break;</span>
<span class="lineNum">   20907 </span>            :       if (id_equal (token-&gt;u.value, &quot;override&quot;))
<span class="lineNum">   20908 </span><span class="lineNoCov">          0 :         {</span>
<span class="lineNum">   20909 </span><span class="lineNoCov">          0 :           maybe_warn_cpp0x (CPP0X_OVERRIDE_CONTROLS);</span>
<span class="lineNum">   20910 </span>            :           virt_specifier = VIRT_SPEC_OVERRIDE;
<span class="lineNum">   20911 </span>            :         }
<span class="lineNum">   20912 </span>            :       else if (id_equal (token-&gt;u.value, &quot;final&quot;))
<span class="lineNum">   20913 </span>            :         {
<span class="lineNum">   20914 </span>            :           maybe_warn_cpp0x (CPP0X_OVERRIDE_CONTROLS);
<span class="lineNum">   20915 </span>            :           virt_specifier = VIRT_SPEC_FINAL;
<span class="lineNum">   20916 </span>            :         }
<span class="lineNum">   20917 </span>            :       else if (id_equal (token-&gt;u.value, &quot;__final&quot;))
<span class="lineNum">   20918 </span>            :         {
<span class="lineNum">   20919 </span>            :           virt_specifier = VIRT_SPEC_FINAL;
<span class="lineNum">   20920 </span>            :         }
<span class="lineNum">   20921 </span>            :       else
<span class="lineNum">   20922 </span>            :         break;
<span class="lineNum">   20923 </span>            : 
<span class="lineNum">   20924 </span>            :       if (virt_specifiers &amp; virt_specifier)
<span class="lineNum">   20925 </span>            :         {
<span class="lineNum">   20926 </span>            :           gcc_rich_location richloc (token-&gt;location);
<span class="lineNum">   20927 </span>            :           richloc.add_fixit_remove ();
<span class="lineNum">   20928 </span>            :           error_at (&amp;richloc, &quot;duplicate virt-specifier&quot;);
<span class="lineNum">   20929 </span>            :           cp_lexer_purge_token (parser-&gt;lexer);
<span class="lineNum">   20930 </span>            :         }
<span class="lineNum">   20931 </span><span class="lineCov">   13691013 :       else</span>
<span class="lineNum">   20932 </span>            :         {
<span class="lineNum">   20933 </span><span class="lineCov">   13691013 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   20934 </span>            :           virt_specifiers |= virt_specifier;
<span class="lineNum">   20935 </span><span class="lineCov">   13695101 :         }</span>
<span class="lineNum">   20936 </span>            :     }
<span class="lineNum">   20937 </span><span class="lineCov">   13695101 :   return virt_specifiers;</span>
<span class="lineNum">   20938 </span><span class="lineCov">   13695101 : }</span>
<span class="lineNum">   20939 </span>            : 
<span class="lineNum">   20940 </span>            : /* Used by handling of trailing-return-types and NSDMI, in which 'this'
<span class="lineNum">   20941 </span><span class="lineCov">   27390202 :    is in scope even though it isn't real.  */</span>
<a name="20942"><span class="lineNum">   20942 </span>            : </a>
<span class="lineNum">   20943 </span><span class="lineCov">   13695101 : void</span>
<span class="lineNum">   20944 </span>            : inject_this_parameter (tree ctype, cp_cv_quals quals)
<span class="lineNum">   20945 </span><span class="lineCov">     115948 : {</span>
<span class="lineNum">   20946 </span>            :   tree this_parm;
<span class="lineNum">   20947 </span><span class="lineCov">       1377 : </span>
<span class="lineNum">   20948 </span><span class="lineCov">       1377 :   if (current_class_ptr)</span>
<span class="lineNum">   20949 </span>            :     {
<span class="lineNum">   20950 </span><span class="lineCov">     114571 :       /* We don't clear this between NSDMIs.  Is it already what we want?  */</span>
<span class="lineNum">   20951 </span>            :       tree type = TREE_TYPE (TREE_TYPE (current_class_ptr));
<span class="lineNum">   20952 </span><span class="lineCov">       2710 :       if (DECL_P (current_class_ptr)</span>
<span class="lineNum">   20953 </span><span class="lineCov">       2710 :           &amp;&amp; DECL_CONTEXT (current_class_ptr) == NULL_TREE</span>
<span class="lineNum">   20954 </span>            :           &amp;&amp; same_type_ignoring_top_level_qualifiers_p (ctype, type)
<span class="lineNum">   20955 </span><span class="lineCov">     111861 :           &amp;&amp; cp_type_quals (type) == quals)</span>
<span class="lineNum">   20956 </span>            :         return;
<span class="lineNum">   20957 </span>            :     }
<span class="lineNum">   20958 </span>            : 
<span class="lineNum">   20959 </span>            :   this_parm = build_this_parm (NULL_TREE, ctype, quals);
<span class="lineNum">   20960 </span>            :   /* Clear this first to avoid shortcut in cp_build_indirect_ref.  */
<span class="lineNum">   20961 </span>            :   current_class_ptr = NULL_TREE;
<span class="lineNum">   20962 </span><span class="lineCov">       4088 :   current_class_ref</span>
<span class="lineNum">   20963 </span>            :     = cp_build_fold_indirect_ref (this_parm);
<span class="lineNum">   20964 </span><span class="lineCov">         16 :   current_class_ptr = this_parm;</span>
<span class="lineNum">   20965 </span><span class="lineCov">          8 : }</span>
<span class="lineNum">   20966 </span><span class="lineCov">          8 : </span>
<span class="lineNum">   20967 </span><span class="lineCov">          8 : /* Return true iff our current scope is a non-static data member</span>
<span class="lineNum">   20968 </span>            :    initializer.  */
<a name="20969"><span class="lineNum">   20969 </span>            : </a>
<span class="lineNum">   20970 </span>            : bool
<span class="lineNum">   20971 </span><span class="lineCov">       4080 : parsing_nsdmi (void)</span>
<span class="lineNum">   20972 </span><span class="lineCov">       4080 : {</span>
<span class="lineNum">   20973 </span>            :   /* We recognize NSDMI context by the context-less 'this' pointer set up
<span class="lineNum">   20974 </span>            :      by the function above.  */
<span class="lineNum">   20975 </span><span class="lineCov">   13691013 :   if (current_class_ptr</span>
<span class="lineNum">   20976 </span>            :       &amp;&amp; TREE_CODE (current_class_ptr) == PARM_DECL
<span class="lineNum">   20977 </span>            :       &amp;&amp; DECL_CONTEXT (current_class_ptr) == NULL_TREE)
<span class="lineNum">   20978 </span>            :     return true;
<span class="lineNum">   20979 </span>            :   return false;
<span class="lineNum">   20980 </span>            : }
<span class="lineNum">   20981 </span>            : 
<span class="lineNum">   20982 </span><span class="lineCov">      75443 : /* Parse a late-specified return type, if any.  This is not a separate</span>
<span class="lineNum">   20983 </span>            :    non-terminal, but part of a function declarator, which looks like
<span class="lineNum">   20984 </span><span class="lineCov">      75443 : </span>
<span class="lineNum">   20985 </span>            :    -&gt; trailing-type-specifier-seq abstract-declarator(opt)
<span class="lineNum">   20986 </span><span class="lineCov">      75443 : </span>
<span class="lineNum">   20987 </span>            :    Returns the type indicated by the type-id.
<span class="lineNum">   20988 </span>            : 
<span class="lineNum">   20989 </span><span class="lineCov">       3794 :    In addition to this, parse any queued up #pragma omp declare simd</span>
<span class="lineNum">   20990 </span><span class="lineCov">       3794 :    clauses, and #pragma acc routine clauses.</span>
<span class="lineNum">   20991 </span><span class="lineCov">       3794 : </span>
<span class="lineNum">   20992 </span><span class="lineCov">       2677 :    QUALS is either a bitmask of cv_qualifiers or -1 for a non-member</span>
<span class="lineNum">   20993 </span><span class="lineCov">       6464 :    function.  */</span>
<a name="20994"><span class="lineNum">   20994 </span>            : </a>
<span class="lineNum">   20995 </span>            : static tree
<span class="lineNum">   20996 </span>            : cp_parser_late_return_type_opt (cp_parser* parser, cp_declarator *declarator,
<span class="lineNum">   20997 </span><span class="lineCov">      72773 :                                 tree&amp; requires_clause, cp_cv_quals quals)</span>
<span class="lineNum">   20998 </span>            : {
<span class="lineNum">   20999 </span><span class="lineCov">      72773 :   cp_token *token;</span>
<span class="lineNum">   21000 </span><span class="lineCov">      72773 :   tree type = NULL_TREE;</span>
<span class="lineNum">   21001 </span><span class="lineCov">      72773 :   bool declare_simd_p = (parser-&gt;omp_declare_simd</span>
<span class="lineNum">   21002 </span><span class="lineCov">      72773 :                          &amp;&amp; declarator</span>
<span class="lineNum">   21003 </span>            :                          &amp;&amp; declarator-&gt;kind == cdk_id);
<span class="lineNum">   21004 </span>            : 
<span class="lineNum">   21005 </span>            :   bool oacc_routine_p = (parser-&gt;oacc_routine
<span class="lineNum">   21006 </span>            :                          &amp;&amp; declarator
<span class="lineNum">   21007 </span>            :                          &amp;&amp; declarator-&gt;kind == cdk_id);
<span class="lineNum">   21008 </span>            : 
<span class="lineNum">   21009 </span><span class="lineCov">  115523556 :   /* Peek at the next token.  */</span>
<span class="lineNum">   21010 </span>            :   token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   21011 </span>            :   /* A late-specified return type is indicated by an initial '-&gt;'. */
<span class="lineNum">   21012 </span>            :   if (token-&gt;type != CPP_DEREF
<span class="lineNum">   21013 </span><span class="lineCov">  115523556 :       &amp;&amp; token-&gt;keyword != RID_REQUIRES</span>
<span class="lineNum">   21014 </span><span class="lineCov">   52200315 :       &amp;&amp; !(token-&gt;type == CPP_NAME</span>
<span class="lineNum">   21015 </span><span class="lineCov">  167723871 :            &amp;&amp; token-&gt;u.value == ridpointers[RID_REQUIRES])</span>
<span class="lineNum">   21016 </span><span class="lineCov">      35837 :       &amp;&amp; !(declare_simd_p || oacc_routine_p))</span>
<span class="lineNum">   21017 </span>            :     return NULL_TREE;
<span class="lineNum">   21018 </span>            : 
<span class="lineNum">   21019 </span>            :   tree save_ccp = current_class_ptr;
<span class="lineNum">   21020 </span>            :   tree save_ccr = current_class_ref;
<span class="lineNum">   21021 </span>            :   if (quals &gt;= 0)
<span class="lineNum">   21022 </span>            :     {
<span class="lineNum">   21023 </span>            :       /* DR 1207: 'this' is in scope in the trailing return type.  */
<span class="lineNum">   21024 </span>            :       inject_this_parameter (current_class_type, quals);
<span class="lineNum">   21025 </span>            :     }
<span class="lineNum">   21026 </span>            : 
<span class="lineNum">   21027 </span>            :   if (token-&gt;type == CPP_DEREF)
<span class="lineNum">   21028 </span>            :     {
<span class="lineNum">   21029 </span>            :       /* Consume the -&gt;.  */
<span class="lineNum">   21030 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   21031 </span>            : 
<span class="lineNum">   21032 </span>            :       type = cp_parser_trailing_type_id (parser);
<span class="lineNum">   21033 </span>            :     }
<span class="lineNum">   21034 </span><span class="lineCov">   10406532 : </span>
<span class="lineNum">   21035 </span>            :   /* Function declarations may be followed by a trailing
<span class="lineNum">   21036 </span>            :      requires-clause.  */
<span class="lineNum">   21037 </span><span class="lineCov">   10406532 :   requires_clause = cp_parser_requires_clause_opt (parser);</span>
<span class="lineNum">   21038 </span><span class="lineCov">   10406532 : </span>
<span class="lineNum">   21039 </span><span class="lineCov">   20813064 :   if (declare_simd_p)</span>
<span class="lineNum">   21040 </span><span class="lineCov">        509 :     declarator-&gt;attributes</span>
<span class="lineNum">   21041 </span><span class="lineCov">   10407041 :       = cp_parser_late_parsing_omp_declare_simd (parser,</span>
<span class="lineNum">   21042 </span>            :                                                  declarator-&gt;attributes);
<span class="lineNum">   21043 </span><span class="lineCov">   20813064 :   if (oacc_routine_p)</span>
<span class="lineNum">   21044 </span><span class="lineCov">        245 :     declarator-&gt;attributes</span>
<span class="lineNum">   21045 </span><span class="lineCov">   10406777 :       = cp_parser_late_parsing_oacc_routine (parser,</span>
<span class="lineNum">   21046 </span>            :                                              declarator-&gt;attributes);
<span class="lineNum">   21047 </span>            : 
<span class="lineNum">   21048 </span><span class="lineCov">   20813064 :   if (quals &gt;= 0)</span>
<span class="lineNum">   21049 </span>            :     {
<span class="lineNum">   21050 </span><span class="lineCov">   10406532 :       current_class_ptr = save_ccp;</span>
<span class="lineNum">   21051 </span><span class="lineCov">   10319935 :       current_class_ref = save_ccr;</span>
<span class="lineNum">   21052 </span><span class="lineCov">   10319868 :     }</span>
<span class="lineNum">   21053 </span><span class="lineCov">       1538 : </span>
<span class="lineNum">   21054 </span><span class="lineCov">   10319868 :   return type;</span>
<span class="lineNum">   21055 </span>            : }
<span class="lineNum">   21056 </span>            : 
<span class="lineNum">   21057 </span><span class="lineCov">      87416 : /* Parse a declarator-id.</span>
<span class="lineNum">   21058 </span><span class="lineCov">      87416 : </span>
<span class="lineNum">   21059 </span><span class="lineCov">      87416 :    declarator-id:</span>
<span class="lineNum">   21060 </span>            :      id-expression
<span class="lineNum">   21061 </span>            :      :: [opt] nested-name-specifier [opt] type-name
<span class="lineNum">   21062 </span><span class="lineCov">      39044 : </span>
<span class="lineNum">   21063 </span>            :    In the `id-expression' case, the value returned is as for
<span class="lineNum">   21064 </span>            :    cp_parser_id_expression if the id-expression was an unqualified-id.
<span class="lineNum">   21065 </span><span class="lineCov">      87416 :    If the id-expression was a qualified-id, then a SCOPE_REF is</span>
<span class="lineNum">   21066 </span>            :    returned.  The first operand is the scope (either a NAMESPACE_DECL
<span class="lineNum">   21067 </span>            :    or TREE_TYPE), but the second is still just a representation of an
<span class="lineNum">   21068 </span><span class="lineCov">      86597 :    unqualified-id.  */</span>
<a name="21069"><span class="lineNum">   21069 </span>            : </a>
<span class="lineNum">   21070 </span><span class="lineCov">      86597 : static tree</span>
<span class="lineNum">   21071 </span>            : cp_parser_declarator_id (cp_parser* parser, bool optional_p)
<span class="lineNum">   21072 </span>            : {
<span class="lineNum">   21073 </span>            :   tree id;
<span class="lineNum">   21074 </span>            :   /* The expression must be an id-expression.  Assume that qualified
<span class="lineNum">   21075 </span><span class="lineCov">      87416 :      names are the names of types so that:</span>
<span class="lineNum">   21076 </span>            : 
<span class="lineNum">   21077 </span><span class="lineCov">      87416 :        template &lt;class T&gt;</span>
<span class="lineNum">   21078 </span><span class="lineCov">        509 :        int S&lt;T&gt;::R::i = 3;</span>
<span class="lineNum">   21079 </span><span class="lineCov">        509 : </span>
<span class="lineNum">   21080 </span>            :      will work; we must treat `S&lt;T&gt;::R' as the name of a type.
<span class="lineNum">   21081 </span><span class="lineCov">      87416 :      Similarly, assume that qualified names are templates, where</span>
<span class="lineNum">   21082 </span><span class="lineCov">        245 :      required, so that:</span>
<span class="lineNum">   21083 </span><span class="lineCov">        245 : </span>
<span class="lineNum">   21084 </span>            :        template &lt;class T&gt;
<span class="lineNum">   21085 </span>            :        int S&lt;T&gt;::R&lt;T&gt;::i = 3;
<span class="lineNum">   21086 </span><span class="lineCov">      87416 : </span>
<span class="lineNum">   21087 </span>            :      will work, too.  */
<span class="lineNum">   21088 </span><span class="lineCov">      39044 :   id = cp_parser_id_expression (parser,</span>
<span class="lineNum">   21089 </span><span class="lineCov">      39044 :                                 /*template_keyword_p=*/false,</span>
<span class="lineNum">   21090 </span>            :                                 /*check_dependency_p=*/false,
<span class="lineNum">   21091 </span>            :                                 /*template_p=*/NULL,
<span class="lineNum">   21092 </span>            :                                 /*declarator_p=*/true,
<span class="lineNum">   21093 </span>            :                                 optional_p);
<span class="lineNum">   21094 </span>            :   if (id &amp;&amp; BASELINK_P (id))
<span class="lineNum">   21095 </span>            :     id = BASELINK_FUNCTIONS (id);
<span class="lineNum">   21096 </span>            :   return id;
<span class="lineNum">   21097 </span>            : }
<span class="lineNum">   21098 </span>            : 
<span class="lineNum">   21099 </span>            : /* Parse a type-id.
<span class="lineNum">   21100 </span>            : 
<span class="lineNum">   21101 </span>            :    type-id:
<span class="lineNum">   21102 </span>            :      type-specifier-seq abstract-declarator [opt]
<span class="lineNum">   21103 </span>            : 
<span class="lineNum">   21104 </span>            :    Returns the TYPE specified.  */
<a name="21105"><span class="lineNum">   21105 </span>            : </a>
<span class="lineNum">   21106 </span>            : static tree
<span class="lineNum">   21107 </span>            : cp_parser_type_id_1 (cp_parser* parser, bool is_template_arg,
<span class="lineNum">   21108 </span>            :                      bool is_trailing_return)
<span class="lineNum">   21109 </span><span class="lineCov">   33302278 : {</span>
<span class="lineNum">   21110 </span>            :   cp_decl_specifier_seq type_specifier_seq;
<span class="lineNum">   21111 </span><span class="lineCov">   33302278 :   cp_declarator *abstract_declarator;</span>
<span class="lineNum">   21112 </span>            : 
<span class="lineNum">   21113 </span>            :   /* Parse the type-specifier-seq.  */
<span class="lineNum">   21114 </span>            :   cp_parser_type_specifier_seq (parser, /*is_declaration=*/false,
<span class="lineNum">   21115 </span>            :                                 is_trailing_return,
<span class="lineNum">   21116 </span>            :                                 &amp;type_specifier_seq);
<span class="lineNum">   21117 </span>            :   if (is_template_arg &amp;&amp; type_specifier_seq.type
<span class="lineNum">   21118 </span>            :       &amp;&amp; TREE_CODE (type_specifier_seq.type) == TEMPLATE_TYPE_PARM
<span class="lineNum">   21119 </span>            :       &amp;&amp; CLASS_PLACEHOLDER_TEMPLATE (type_specifier_seq.type))
<span class="lineNum">   21120 </span>            :     /* A bare template name as a template argument is a template template
<span class="lineNum">   21121 </span>            :        argument, not a placeholder, so fail parsing it as a type argument.  */
<span class="lineNum">   21122 </span>            :     {
<span class="lineNum">   21123 </span>            :       gcc_assert (cp_parser_uncommitted_to_tentative_parse_p (parser));
<span class="lineNum">   21124 </span>            :       cp_parser_simulate_error (parser);
<span class="lineNum">   21125 </span>            :       return error_mark_node;
<span class="lineNum">   21126 </span><span class="lineCov">   66604556 :     }</span>
<span class="lineNum">   21127 </span>            :   if (type_specifier_seq.type == error_mark_node)
<span class="lineNum">   21128 </span>            :     return error_mark_node;
<span class="lineNum">   21129 </span>            : 
<span class="lineNum">   21130 </span>            :   /* There might or might not be an abstract declarator.  */
<span class="lineNum">   21131 </span><span class="lineCov">   33302278 :   cp_parser_parse_tentatively (parser);</span>
<span class="lineNum">   21132 </span><span class="lineCov">   33302278 :   /* Look for the declarator.  */</span>
<span class="lineNum">   21133 </span><span class="lineCov">        400 :   abstract_declarator</span>
<span class="lineNum">   21134 </span><span class="lineCov">   33302278 :     = cp_parser_declarator (parser, CP_PARSER_DECLARATOR_ABSTRACT, NULL,</span>
<span class="lineNum">   21135 </span>            :                             /*parenthesized_p=*/NULL,
<span class="lineNum">   21136 </span>            :                             /*member_p=*/false,
<span class="lineNum">   21137 </span>            :                             /*friend_p=*/false);
<span class="lineNum">   21138 </span>            :   /* Check to see if there really was a declarator.  */
<span class="lineNum">   21139 </span>            :   if (!cp_parser_parse_definitely (parser))
<span class="lineNum">   21140 </span>            :     abstract_declarator = NULL;
<span class="lineNum">   21141 </span>            : 
<span class="lineNum">   21142 </span>            :   if (type_specifier_seq.type
<span class="lineNum">   21143 </span>            :       /* The concepts TS allows 'auto' as a type-id.  */
<span class="lineNum">   21144 </span>            :       &amp;&amp; (!flag_concepts || parser-&gt;in_type_id_in_expr_p)
<span class="lineNum">   21145 </span><span class="lineCov">   19250086 :       /* None of the valid uses of 'auto' in C++14 involve the type-id</span>
<span class="lineNum">   21146 </span>            :          nonterminal, but it is valid in a trailing-return-type.  */
<span class="lineNum">   21147 </span>            :       &amp;&amp; !(cxx_dialect &gt;= cxx14 &amp;&amp; is_trailing_return))
<span class="lineNum">   21148 </span><span class="lineCov">   19250086 :     if (tree auto_node = type_uses_auto (type_specifier_seq.type))</span>
<span class="lineNum">   21149 </span><span class="lineCov">   19250086 :       {</span>
<span class="lineNum">   21150 </span>            :         /* A type-id with type 'auto' is only ok if the abstract declarator
<span class="lineNum">   21151 </span>            :            is a function declarator with a late-specified return type.
<span class="lineNum">   21152 </span><span class="lineCov">   19250086 : </span>
<span class="lineNum">   21153 </span>            :            A type-id with 'auto' is also valid in a trailing-return-type
<span class="lineNum">   21154 </span>            :            in a compound-requirement. */
<span class="lineNum">   21155 </span><span class="lineCov">   13948975 :         if (abstract_declarator</span>
<span class="lineNum">   21156 </span><span class="lineCov">   13819025 :             &amp;&amp; abstract_declarator-&gt;kind == cdk_function</span>
<span class="lineNum">   21157 </span><span class="lineCov">   19285064 :             &amp;&amp; abstract_declarator-&gt;u.function.late_return_type)</span>
<span class="lineNum">   21158 </span>            :           /* OK */;
<span class="lineNum">   21159 </span>            :         else if (parser-&gt;in_result_type_constraint_p)
<span class="lineNum">   21160 </span>            :           /* OK */;
<span class="lineNum">   21161 </span><span class="lineNoCov">          0 :         else</span>
<span class="lineNum">   21162 </span><span class="lineCov">      34858 :           {</span>
<span class="lineNum">   21163 </span><span class="lineCov">      17429 :             location_t loc = type_specifier_seq.locations[ds_type_spec];</span>
<span class="lineNum">   21164 </span>            :             if (tree tmpl = CLASS_PLACEHOLDER_TEMPLATE (auto_node))
<span class="lineNum">   21165 </span><span class="lineCov">   19232657 :               {</span>
<span class="lineNum">   21166 </span>            :                 error_at (loc, &quot;missing template arguments after %qT&quot;,
<span class="lineNum">   21167 </span>            :                           auto_node);
<span class="lineNum">   21168 </span>            :                 inform (DECL_SOURCE_LOCATION (tmpl), &quot;%qD declared here&quot;,
<span class="lineNum">   21169 </span><span class="lineCov">   16580327 :                         tmpl);</span>
<span class="lineNum">   21170 </span>            :               }
<span class="lineNum">   21171 </span><span class="lineCov">   16580327 :             else</span>
<span class="lineNum">   21172 </span><span class="lineCov">   16580327 :               error_at (loc, &quot;invalid use of %qT&quot;, auto_node);</span>
<span class="lineNum">   21173 </span>            :             return error_mark_node;
<span class="lineNum">   21174 </span>            :           }
<span class="lineNum">   21175 </span>            :       }
<span class="lineNum">   21176 </span>            :   
<span class="lineNum">   21177 </span><span class="lineCov">   16580327 :   return groktypename (&amp;type_specifier_seq, abstract_declarator,</span>
<span class="lineNum">   21178 </span><span class="lineCov">   15642008 :                        is_template_arg);</span>
<span class="lineNum">   21179 </span>            : }
<a name="21180"><span class="lineNum">   21180 </span><span class="lineCov">   16580327 : </span></a>
<span class="lineNum">   21181 </span>            : static tree
<span class="lineNum">   21182 </span><span class="lineCov">   16301977 : cp_parser_type_id (cp_parser *parser)</span>
<span class="lineNum">   21183 </span>            : {
<span class="lineNum">   21184 </span>            :   return cp_parser_type_id_1 (parser, false, false);
<span class="lineNum">   21185 </span><span class="lineCov">   16284430 : }</span>
<a name="21186"><span class="lineNum">   21186 </span><span class="lineCov">   16204995 : </span></a>
<span class="lineNum">   21187 </span>            : static tree
<span class="lineNum">   21188 </span>            : cp_parser_template_type_arg (cp_parser *parser)
<span class="lineNum">   21189 </span>            : {
<span class="lineNum">   21190 </span>            :   tree r;
<span class="lineNum">   21191 </span>            :   const char *saved_message = parser-&gt;type_definition_forbidden_message;
<span class="lineNum">   21192 </span>            :   parser-&gt;type_definition_forbidden_message
<span class="lineNum">   21193 </span><span class="lineCov">         93 :     = G_(&quot;types may not be defined in template arguments&quot;);</span>
<span class="lineNum">   21194 </span><span class="lineCov">         48 :   r = cp_parser_type_id_1 (parser, true, false);</span>
<span class="lineNum">   21195 </span><span class="lineCov">         14 :   parser-&gt;type_definition_forbidden_message = saved_message;</span>
<span class="lineNum">   21196 </span>            :   if (cxx_dialect &gt;= cxx14 &amp;&amp; !flag_concepts &amp;&amp; type_uses_auto (r))
<span class="lineNum">   21197 </span><span class="lineCov">         84 :     {</span>
<span class="lineNum">   21198 </span>            :       error (&quot;invalid use of %&lt;auto%&gt; in template argument&quot;);
<span class="lineNum">   21199 </span>            :       r = error_mark_node;
<span class="lineNum">   21200 </span>            :     }
<span class="lineNum">   21201 </span><span class="lineCov">         84 :   return r;</span>
<span class="lineNum">   21202 </span><span class="lineCov">         84 : }</span>
<a name="21203"><span class="lineNum">   21203 </span>            : </a>
<span class="lineNum">   21204 </span><span class="lineNoCov">          0 : static tree</span>
<span class="lineNum">   21205 </span>            : cp_parser_trailing_type_id (cp_parser *parser)
<span class="lineNum">   21206 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   21207 </span>            :   return cp_parser_type_id_1 (parser, false, true);
<span class="lineNum">   21208 </span>            : }
<span class="lineNum">   21209 </span>            : 
<span class="lineNum">   21210 </span><span class="lineCov">         84 : /* Parse a type-specifier-seq.</span>
<span class="lineNum">   21211 </span><span class="lineCov">         84 : </span>
<span class="lineNum">   21212 </span>            :    type-specifier-seq:
<span class="lineNum">   21213 </span>            :      type-specifier type-specifier-seq [opt]
<span class="lineNum">   21214 </span>            : 
<span class="lineNum">   21215 </span><span class="lineCov">   16580243 :    GNU extension:</span>
<span class="lineNum">   21216 </span><span class="lineCov">   16580243 : </span>
<span class="lineNum">   21217 </span>            :    type-specifier-seq:
<span class="lineNum">   21218 </span>            :      attributes type-specifier-seq [opt]
<span class="lineNum">   21219 </span>            : 
<span class="lineNum">   21220 </span><span class="lineCov">    3446840 :    If IS_DECLARATION is true, we are at the start of a &quot;condition&quot; or</span>
<span class="lineNum">   21221 </span>            :    exception-declaration, so we might be followed by a declarator-id.
<span class="lineNum">   21222 </span><span class="lineCov">    4771471 : </span>
<span class="lineNum">   21223 </span>            :    If IS_TRAILING_RETURN is true, we are in a trailing-return-type,
<span class="lineNum">   21224 </span>            :    i.e. we've just seen &quot;-&gt;&quot;.
<span class="lineNum">   21225 </span>            : 
<span class="lineNum">   21226 </span><span class="lineCov">   13948975 :    Sets *TYPE_SPECIFIER_SEQ to represent the sequence.  */</span>
<a name="21227"><span class="lineNum">   21227 </span>            : </a>
<span class="lineNum">   21228 </span><span class="lineCov">   13948975 : static void</span>
<span class="lineNum">   21229 </span><span class="lineCov">   13948975 : cp_parser_type_specifier_seq (cp_parser* parser,</span>
<span class="lineNum">   21230 </span><span class="lineCov">   13948975 :                               bool is_declaration,</span>
<span class="lineNum">   21231 </span><span class="lineCov">   13948975 :                               bool is_trailing_return,</span>
<span class="lineNum">   21232 </span><span class="lineCov">   13948975 :                               cp_decl_specifier_seq *type_specifier_seq)</span>
<span class="lineNum">   21233 </span><span class="lineCov">   13948975 : {</span>
<span class="lineNum">   21234 </span><span class="lineCov">   13948975 :   bool seen_type_specifier = false;</span>
<span class="lineNum">   21235 </span>            :   cp_parser_flags flags = CP_PARSER_FLAGS_OPTIONAL;
<span class="lineNum">   21236 </span><span class="lineNoCov">          0 :   cp_token *start_token = NULL;</span>
<span class="lineNum">   21237 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   21238 </span>            :   /* Clear the TYPE_SPECIFIER_SEQ.  */
<span class="lineNum">   21239 </span><span class="lineCov">   13948975 :   clear_decl_specs (type_specifier_seq);</span>
<span class="lineNum">   21240 </span>            : 
<span class="lineNum">   21241 </span>            :   /* In the context of a trailing return type, enum E { } is an
<span class="lineNum">   21242 </span>            :      elaborated-type-specifier followed by a function-body, not an
<span class="lineNum">   21243 </span><span class="lineCov">      86597 :      enum-specifier.  */</span>
<span class="lineNum">   21244 </span>            :   if (is_trailing_return)
<span class="lineNum">   21245 </span><span class="lineCov">      87054 :     flags |= CP_PARSER_FLAGS_NO_TYPE_DEFINITIONS;</span>
<span class="lineNum">   21246 </span>            : 
<span class="lineNum">   21247 </span>            :   /* Parse the type-specifiers and attributes.  */
<span class="lineNum">   21248 </span>            :   while (true)
<span class="lineNum">   21249 </span>            :     {
<span class="lineNum">   21250 </span>            :       tree type_specifier;
<span class="lineNum">   21251 </span>            :       bool is_cv_qualifier;
<span class="lineNum">   21252 </span>            : 
<span class="lineNum">   21253 </span>            :       /* Check for attributes first.  */
<span class="lineNum">   21254 </span>            :       if (cp_next_tokens_can_be_attribute_p (parser))
<span class="lineNum">   21255 </span>            :         {
<span class="lineNum">   21256 </span>            :           type_specifier_seq-&gt;attributes
<span class="lineNum">   21257 </span>            :             = attr_chainon (type_specifier_seq-&gt;attributes,
<span class="lineNum">   21258 </span>            :                             cp_parser_attributes_opt (parser));
<span class="lineNum">   21259 </span>            :           continue;
<span class="lineNum">   21260 </span>            :         }
<span class="lineNum">   21261 </span>            : 
<span class="lineNum">   21262 </span>            :       /* record the token of the beginning of the type specifier seq,
<span class="lineNum">   21263 </span>            :          for error reporting purposes*/
<span class="lineNum">   21264 </span>            :      if (!start_token)
<span class="lineNum">   21265 </span>            :        start_token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   21266 </span>            : 
<span class="lineNum">   21267 </span><span class="lineCov">   19403108 :       /* Look for the type-specifier.  */</span>
<span class="lineNum">   21268 </span>            :       type_specifier = cp_parser_type_specifier (parser,
<span class="lineNum">   21269 </span>            :                                                  flags,
<span class="lineNum">   21270 </span>            :                                                  type_specifier_seq,
<span class="lineNum">   21271 </span>            :                                                  /*is_declaration=*/false,
<span class="lineNum">   21272 </span><span class="lineCov">   19403108 :                                                  NULL,</span>
<span class="lineNum">   21273 </span><span class="lineCov">   19403108 :                                                  &amp;is_cv_qualifier);</span>
<span class="lineNum">   21274 </span><span class="lineCov">   19403108 :       if (!type_specifier)</span>
<span class="lineNum">   21275 </span>            :         {
<span class="lineNum">   21276 </span>            :           /* If the first type-specifier could not be found, this is not a
<span class="lineNum">   21277 </span><span class="lineCov">   38806216 :              type-specifier-seq at all.  */</span>
<span class="lineNum">   21278 </span>            :           if (!seen_type_specifier)
<span class="lineNum">   21279 </span>            :             {
<span class="lineNum">   21280 </span>            :               /* Set in_declarator_p to avoid skipping to the semicolon.  */
<span class="lineNum">   21281 </span>            :               int in_decl = parser-&gt;in_declarator_p;
<span class="lineNum">   21282 </span><span class="lineCov">   19403108 :               parser-&gt;in_declarator_p = true;</span>
<span class="lineNum">   21283 </span><span class="lineCov">      87077 : </span>
<span class="lineNum">   21284 </span>            :               if (cp_parser_uncommitted_to_tentative_parse_p (parser)
<span class="lineNum">   21285 </span>            :                   || !cp_parser_parse_and_diagnose_invalid_type_name (parser))
<span class="lineNum">   21286 </span><span class="lineCov">   36994421 :                 cp_parser_error (parser, &quot;expected type-specifier&quot;);</span>
<span class="lineNum">   21287 </span>            : 
<span class="lineNum">   21288 </span><span class="lineCov">   36994421 :               parser-&gt;in_declarator_p = in_decl;</span>
<span class="lineNum">   21289 </span><span class="lineCov">   36994421 : </span>
<span class="lineNum">   21290 </span>            :               type_specifier_seq-&gt;type = error_mark_node;
<span class="lineNum">   21291 </span>            :               return;
<span class="lineNum">   21292 </span><span class="lineCov">   36994421 :             }</span>
<span class="lineNum">   21293 </span>            :           /* If subsequent type-specifiers could not be found, the
<span class="lineNum">   21294 </span><span class="lineCov">        485 :              type-specifier-seq is complete.  */</span>
<span class="lineNum">   21295 </span><span class="lineCov">        485 :           break;</span>
<span class="lineNum">   21296 </span>            :         }
<span class="lineNum">   21297 </span><span class="lineCov">        485 : </span>
<span class="lineNum">   21298 </span>            :       seen_type_specifier = true;
<span class="lineNum">   21299 </span>            :       /* The standard says that a condition can be:
<span class="lineNum">   21300 </span>            : 
<span class="lineNum">   21301 </span>            :             type-specifier-seq declarator = assignment-expression
<span class="lineNum">   21302 </span><span class="lineCov">   36993936 : </span>
<span class="lineNum">   21303 </span>            :          However, given:
<span class="lineNum">   21304 </span>            : 
<span class="lineNum">   21305 </span>            :            struct S {};
<span class="lineNum">   21306 </span><span class="lineCov">   36993936 :            if (int S = ...)</span>
<span class="lineNum">   21307 </span>            : 
<span class="lineNum">   21308 </span>            :          we should treat the &quot;S&quot; as a declarator, not as a
<span class="lineNum">   21309 </span>            :          type-specifier.  The standard doesn't say that explicitly for
<span class="lineNum">   21310 </span>            :          type-specifier-seq, but it does say that for
<span class="lineNum">   21311 </span>            :          decl-specifier-seq in an ordinary declaration.  Perhaps it
<span class="lineNum">   21312 </span><span class="lineCov">   36993936 :          would be clearer just to allow a decl-specifier-seq here, and</span>
<span class="lineNum">   21313 </span>            :          then add a semantic restriction that if any decl-specifiers
<span class="lineNum">   21314 </span>            :          that are not type-specifiers appear, the program is invalid.  */
<span class="lineNum">   21315 </span>            :       if (is_declaration &amp;&amp; !is_cv_qualifier)
<span class="lineNum">   21316 </span><span class="lineCov">   19403108 :         flags |= CP_PARSER_FLAGS_NO_USER_DEFINED_TYPES;</span>
<span class="lineNum">   21317 </span>            :     }
<span class="lineNum">   21318 </span>            : }
<span class="lineNum">   21319 </span><span class="lineCov">    2659514 : </span>
<span class="lineNum">   21320 </span><span class="lineCov">    2659514 : /* Return whether the function currently being declared has an associated</span>
<span class="lineNum">   21321 </span>            :    template parameter list.  */
<a name="21322"><span class="lineNum">   21322 </span><span class="lineCov">    2659607 : </span></a>
<span class="lineNum">   21323 </span><span class="lineCov">         93 : static bool</span>
<span class="lineNum">   21324 </span><span class="lineCov">    2659451 : function_being_declared_is_template_p (cp_parser* parser)</span>
<span class="lineNum">   21325 </span>            : {
<span class="lineNum">   21326 </span><span class="lineCov">    2659514 :   if (!current_template_parms || processing_template_parmlist)</span>
<span class="lineNum">   21327 </span>            :     return false;
<span class="lineNum">   21328 </span><span class="lineCov">    2659514 : </span>
<span class="lineNum">   21329 </span><span class="lineCov">    2659514 :   if (parser-&gt;implicit_template_scope)</span>
<span class="lineNum">   21330 </span>            :     return true;
<span class="lineNum">   21331 </span>            : 
<span class="lineNum">   21332 </span>            :   if (at_class_scope_p ()
<span class="lineNum">   21333 </span><span class="lineCov">   16743594 :       &amp;&amp; TYPE_BEING_DEFINED (current_class_type))</span>
<span class="lineNum">   21334 </span>            :     return parser-&gt;num_template_parameter_lists != 0;
<span class="lineNum">   21335 </span>            : 
<span class="lineNum">   21336 </span><span class="lineCov">   17590828 :   return ((int) parser-&gt;num_template_parameter_lists &gt; template_class_depth</span>
<span class="lineNum">   21337 </span>            :           (current_class_type));
<span class="lineNum">   21338 </span>            : }
<span class="lineNum">   21339 </span>            : 
<span class="lineNum">   21340 </span>            : /* Parse a parameter-declaration-clause.
<span class="lineNum">   21341 </span>            : 
<span class="lineNum">   21342 </span>            :    parameter-declaration-clause:
<span class="lineNum">   21343 </span>            :      parameter-declaration-list [opt] ... [opt]
<span class="lineNum">   21344 </span>            :      parameter-declaration-list , ...
<span class="lineNum">   21345 </span>            : 
<span class="lineNum">   21346 </span>            :    Returns a representation for the parameter declarations.  A return
<span class="lineNum">   21347 </span>            :    value of NULL indicates a parameter-declaration-clause consisting
<span class="lineNum">   21348 </span>            :    only of an ellipsis.  */
<a name="21349"><span class="lineNum">   21349 </span>            : </a>
<span class="lineNum">   21350 </span>            : static tree
<span class="lineNum">   21351 </span>            : cp_parser_parameter_declaration_clause (cp_parser* parser)
<span class="lineNum">   21352 </span>            : {
<span class="lineNum">   21353 </span><span class="lineCov">   17590828 :   tree parameters;</span>
<span class="lineNum">   21354 </span><span class="lineCov">      39933 :   cp_token *token;</span>
<span class="lineNum">   21355 </span>            :   bool ellipsis_p;
<span class="lineNum">   21356 </span>            : 
<span class="lineNum">   21357 </span>            :   temp_override&lt;bool&gt; cleanup
<span class="lineNum">   21358 </span>            :     (parser-&gt;auto_is_implicit_function_template_parm_p);
<span class="lineNum">   21359 </span>            : 
<span class="lineNum">   21360 </span>            :   if (!processing_specialization
<span class="lineNum">   21361 </span>            :       &amp;&amp; !processing_template_parmlist
<span class="lineNum">   21362 </span><span class="lineCov">   17466020 :       &amp;&amp; !processing_explicit_instantiation</span>
<span class="lineNum">   21363 </span>            :       /* default_arg_ok_p tracks whether this is a parameter-clause for an
<span class="lineNum">   21364 </span><span class="lineCov">   17466020 :          actual function or a random abstract declarator.  */</span>
<span class="lineNum">   21365 </span>            :       &amp;&amp; parser-&gt;default_arg_ok_p)
<span class="lineNum">   21366 </span>            :     if (!current_function_decl
<span class="lineNum">   21367 </span><span class="lineCov">    7093086 :         || (current_class_type &amp;&amp; LAMBDA_TYPE_P (current_class_type)))</span>
<span class="lineNum">   21368 </span>            :       parser-&gt;auto_is_implicit_function_template_parm_p = true;
<span class="lineNum">   21369 </span>            : 
<span class="lineNum">   21370 </span><span class="lineCov">    7093033 :   /* Peek at the next token.  */</span>
<span class="lineNum">   21371 </span><span class="lineCov">    7093033 :   token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   21372 </span><span class="lineCov">    3874162 :   /* Check for trivial parameter-declaration-clauses.  */</span>
<span class="lineNum">   21373 </span>            :   if (token-&gt;type == CPP_ELLIPSIS)
<span class="lineNum">   21374 </span><span class="lineCov">    3218871 :     {</span>
<span class="lineNum">   21375 </span><span class="lineCov">    3218871 :       /* Consume the `...' token.  */</span>
<span class="lineNum">   21376 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   21377 </span>            :       return NULL_TREE;
<span class="lineNum">   21378 </span>            :     }
<span class="lineNum">   21379 </span>            :   else if (token-&gt;type == CPP_CLOSE_PAREN)
<span class="lineNum">   21380 </span>            :     /* There are no parameters.  */
<span class="lineNum">   21381 </span>            :     return void_list_node;
<span class="lineNum">   21382 </span>            :   /* Check for `(void)', too, which is a special case.  */
<span class="lineNum">   21383 </span>            :   else if (token-&gt;keyword == RID_VOID
<span class="lineNum">   21384 </span>            :            &amp;&amp; (cp_lexer_peek_nth_token (parser-&gt;lexer, 2)-&gt;type
<span class="lineNum">   21385 </span>            :                == CPP_CLOSE_PAREN))
<span class="lineNum">   21386 </span>            :     {
<span class="lineNum">   21387 </span>            :       /* Consume the `void' token.  */
<span class="lineNum">   21388 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   21389 </span><span class="lineCov">   10687567 :       /* There are no parameters.  */</span>
<span class="lineNum">   21390 </span>            :       return void_list_node;
<span class="lineNum">   21391 </span><span class="lineCov">   10687567 :     }</span>
<span class="lineNum">   21392 </span><span class="lineCov">   10687567 : </span>
<span class="lineNum">   21393 </span><span class="lineCov">   10687567 :   /* Parse the parameter-declaration-list.  */</span>
<span class="lineNum">   21394 </span>            :   parameters = cp_parser_parameter_declaration_list (parser);
<span class="lineNum">   21395 </span><span class="lineCov">   10687567 :   /* If a parse error occurred while parsing the</span>
<span class="lineNum">   21396 </span><span class="lineCov">   10687567 :      parameter-declaration-list, then the entire</span>
<span class="lineNum">   21397 </span>            :      parameter-declaration-clause is erroneous.  */
<span class="lineNum">   21398 </span><span class="lineCov">   10687567 :   if (parameters == error_mark_node)</span>
<span class="lineNum">   21399 </span><span class="lineCov">   10636999 :     return NULL_TREE;</span>
<span class="lineNum">   21400 </span><span class="lineCov">   10633854 : </span>
<span class="lineNum">   21401 </span>            :   /* Peek at the next token.  */
<span class="lineNum">   21402 </span>            :   token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   21403 </span><span class="lineCov">   10527721 :   /* If it's a `,', the clause should terminate with an ellipsis.  */</span>
<span class="lineNum">   21404 </span><span class="lineCov">   10092596 :   if (token-&gt;type == CPP_COMMA)</span>
<span class="lineNum">   21405 </span><span class="lineCov">   10092596 :     {</span>
<span class="lineNum">   21406 </span><span class="lineCov">    9953267 :       /* Consume the `,'.  */</span>
<span class="lineNum">   21407 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   21408 </span>            :       /* Expect an ellipsis.  */
<span class="lineNum">   21409 </span><span class="lineCov">   21375134 :       ellipsis_p</span>
<span class="lineNum">   21410 </span>            :         = (cp_parser_require (parser, CPP_ELLIPSIS, RT_ELLIPSIS) != NULL);
<span class="lineNum">   21411 </span><span class="lineCov">   10687567 :     }</span>
<span class="lineNum">   21412 </span>            :   /* It might also be `...' if the optional trailing `,' was
<span class="lineNum">   21413 </span>            :      omitted.  */
<span class="lineNum">   21414 </span><span class="lineCov">      43903 :   else if (token-&gt;type == CPP_ELLIPSIS)</span>
<span class="lineNum">   21415 </span><span class="lineCov">      43903 :     {</span>
<span class="lineNum">   21416 </span>            :       /* Consume the `...' token.  */
<span class="lineNum">   21417 </span><span class="lineCov">   10643664 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   21418 </span>            :       /* And remember that we saw it.  */
<span class="lineNum">   21419 </span><span class="lineCov">    1669209 :       ellipsis_p = true;</span>
<span class="lineNum">   21420 </span>            :     }
<span class="lineNum">   21421 </span><span class="lineCov">    8974455 :   else</span>
<span class="lineNum">   21422 </span><span class="lineCov">    8974455 :     ellipsis_p = false;</span>
<span class="lineNum">   21423 </span>            : 
<span class="lineNum">   21424 </span>            :   /* Finish the parameter list.  */
<span class="lineNum">   21425 </span>            :   if (!ellipsis_p)
<span class="lineNum">   21426 </span><span class="lineCov">     265623 :     parameters = chainon (parameters, void_list_node);</span>
<span class="lineNum">   21427 </span>            : 
<span class="lineNum">   21428 </span><span class="lineCov">     265623 :   return parameters;</span>
<span class="lineNum">   21429 </span>            : }
<span class="lineNum">   21430 </span>            : 
<span class="lineNum">   21431 </span>            : /* Parse a parameter-declaration-list.
<span class="lineNum">   21432 </span><span class="lineCov">    8708832 : </span>
<span class="lineNum">   21433 </span>            :    parameter-declaration-list:
<span class="lineNum">   21434 </span>            :      parameter-declaration
<span class="lineNum">   21435 </span>            :      parameter-declaration-list , parameter-declaration
<span class="lineNum">   21436 </span><span class="lineCov">    8708832 : </span>
<span class="lineNum">   21437 </span>            :    Returns a representation of the parameter-declaration-list, as for
<span class="lineNum">   21438 </span>            :    cp_parser_parameter_declaration_clause.  However, the
<span class="lineNum">   21439 </span>            :    `void_list_node' is never appended to the list.  */
<a name="21440"><span class="lineNum">   21440 </span><span class="lineCov">   16862350 : </span></a>
<span class="lineNum">   21441 </span>            : static tree
<span class="lineNum">   21442 </span><span class="lineCov">    8431175 : cp_parser_parameter_declaration_list (cp_parser* parser)</span>
<span class="lineNum">   21443 </span>            : {
<span class="lineNum">   21444 </span>            :   tree parameters = NULL_TREE;
<span class="lineNum">   21445 </span><span class="lineCov">      78218 :   tree *tail = &amp;parameters;</span>
<span class="lineNum">   21446 </span>            :   bool saved_in_unbraced_linkage_specification_p;
<span class="lineNum">   21447 </span><span class="lineCov">      78218 :   int index = 0;</span>
<span class="lineNum">   21448 </span><span class="lineCov">      78218 : </span>
<span class="lineNum">   21449 </span>            :   /* The special considerations that apply to a function within an
<span class="lineNum">   21450 </span>            :      unbraced linkage specifications do not apply to the parameters
<span class="lineNum">   21451 </span>            :      to the function.  */
<span class="lineNum">   21452 </span><span class="lineCov">    8352957 :   saved_in_unbraced_linkage_specification_p</span>
<span class="lineNum">   21453 </span>            :     = parser-&gt;in_unbraced_linkage_specification_p;
<span class="lineNum">   21454 </span>            :   parser-&gt;in_unbraced_linkage_specification_p = false;
<span class="lineNum">   21455 </span><span class="lineCov">      44874 : </span>
<span class="lineNum">   21456 </span>            :   /* Look for more parameters.  */
<span class="lineNum">   21457 </span><span class="lineCov">      44874 :   while (true)</span>
<span class="lineNum">   21458 </span>            :     {
<span class="lineNum">   21459 </span>            :       cp_parameter_declarator *parameter;
<span class="lineNum">   21460 </span>            :       tree decl = error_mark_node;
<span class="lineNum">   21461 </span>            :       bool parenthesized_p = false;
<span class="lineNum">   21462 </span>            : 
<span class="lineNum">   21463 </span><span class="lineCov">     123092 :       /* Parse the parameter.  */</span>
<span class="lineNum">   21464 </span><span class="lineCov">    8308083 :       parameter</span>
<span class="lineNum">   21465 </span>            :         = cp_parser_parameter_declaration (parser,
<span class="lineNum">   21466 </span>            :                                            /*template_parm_p=*/false,
<span class="lineNum">   21467 </span>            :                                            &amp;parenthesized_p);
<span class="lineNum">   21468 </span>            : 
<span class="lineNum">   21469 </span>            :       /* We don't know yet if the enclosing context is deprecated, so wait
<span class="lineNum">   21470 </span>            :          and warn in grokparms if appropriate.  */
<span class="lineNum">   21471 </span>            :       deprecated_state = DEPRECATED_SUPPRESS;
<span class="lineNum">   21472 </span>            : 
<span class="lineNum">   21473 </span>            :       if (parameter)
<span class="lineNum">   21474 </span>            :         {
<span class="lineNum">   21475 </span>            :           decl = grokdeclarator (parameter-&gt;declarator,
<span class="lineNum">   21476 </span>            :                                  &amp;parameter-&gt;decl_specifiers,
<span class="lineNum">   21477 </span>            :                                  PARM,
<span class="lineNum">   21478 </span>            :                                  parameter-&gt;default_argument != NULL_TREE,
<span class="lineNum">   21479 </span>            :                                  &amp;parameter-&gt;decl_specifiers.attributes);
<span class="lineNum">   21480 </span><span class="lineCov">    8708842 :           if (decl != error_mark_node &amp;&amp; parameter-&gt;loc != UNKNOWN_LOCATION)</span>
<span class="lineNum">   21481 </span>            :             DECL_SOURCE_LOCATION (decl) = parameter-&gt;loc;
<span class="lineNum">   21482 </span><span class="lineCov">    8708842 :         }</span>
<span class="lineNum">   21483 </span><span class="lineCov">    8708842 : </span>
<span class="lineNum">   21484 </span><span class="lineCov">    8708842 :       deprecated_state = DEPRECATED_NORMAL;</span>
<span class="lineNum">   21485 </span><span class="lineCov">    8708842 : </span>
<span class="lineNum">   21486 </span>            :       /* If a parse error occurred parsing the parameter declaration,
<span class="lineNum">   21487 </span>            :          then the entire parameter-declaration-list is erroneous.  */
<span class="lineNum">   21488 </span>            :       if (decl == error_mark_node)
<span class="lineNum">   21489 </span>            :         {
<span class="lineNum">   21490 </span><span class="lineCov">    8708842 :           parameters = error_mark_node;</span>
<span class="lineNum">   21491 </span><span class="lineCov">    8708842 :           break;</span>
<span class="lineNum">   21492 </span><span class="lineCov">    8708842 :         }</span>
<span class="lineNum">   21493 </span>            : 
<span class="lineNum">   21494 </span>            :       if (parameter-&gt;decl_specifiers.attributes)
<span class="lineNum">   21495 </span><span class="lineCov">   16730348 :         cplus_decl_attributes (&amp;decl,</span>
<span class="lineNum">   21496 </span>            :                                parameter-&gt;decl_specifiers.attributes,
<span class="lineNum">   21497 </span><span class="lineCov">   16730348 :                                0);</span>
<span class="lineNum">   21498 </span><span class="lineCov">   16730348 :       if (DECL_NAME (decl))</span>
<span class="lineNum">   21499 </span><span class="lineCov">   16730348 :         decl = pushdecl (decl);</span>
<span class="lineNum">   21500 </span>            : 
<span class="lineNum">   21501 </span>            :       if (decl != error_mark_node)
<span class="lineNum">   21502 </span><span class="lineCov">   16730348 :         {</span>
<span class="lineNum">   21503 </span><span class="lineCov">   16730348 :           retrofit_lang_decl (decl);</span>
<span class="lineNum">   21504 </span>            :           DECL_PARM_INDEX (decl) = ++index;
<span class="lineNum">   21505 </span>            :           DECL_PARM_LEVEL (decl) = function_parm_depth ();
<span class="lineNum">   21506 </span>            :         }
<span class="lineNum">   21507 </span>            : 
<span class="lineNum">   21508 </span>            :       /* Add the new parameter to the list.  */
<span class="lineNum">   21509 </span><span class="lineCov">   16730348 :       *tail = build_tree_list (parameter-&gt;default_argument, decl);</span>
<span class="lineNum">   21510 </span>            :       tail = &amp;TREE_CHAIN (*tail);
<span class="lineNum">   21511 </span><span class="lineCov">   16730348 : </span>
<span class="lineNum">   21512 </span>            :       /* Peek at the next token.  */
<span class="lineNum">   21513 </span><span class="lineCov">   49361214 :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_CLOSE_PAREN)</span>
<span class="lineNum">   21514 </span>            :           || cp_lexer_next_token_is (parser-&gt;lexer, CPP_ELLIPSIS)
<span class="lineNum">   21515 </span>            :           /* These are for Objective-C++ */
<span class="lineNum">   21516 </span><span class="lineCov">   16453738 :           || cp_lexer_next_token_is (parser-&gt;lexer, CPP_SEMICOLON)</span>
<span class="lineNum">   21517 </span>            :           || cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_BRACE))
<span class="lineNum">   21518 </span><span class="lineCov">   16453738 :         /* The parameter-declaration-list is complete.  */</span>
<span class="lineNum">   21519 </span><span class="lineCov">   16452688 :         break;</span>
<span class="lineNum">   21520 </span>            :       else if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_COMMA))
<span class="lineNum">   21521 </span>            :         {
<span class="lineNum">   21522 </span><span class="lineCov">   16730348 :           cp_token *token;</span>
<span class="lineNum">   21523 </span>            : 
<span class="lineNum">   21524 </span>            :           /* Peek at the next token.  */
<span class="lineNum">   21525 </span>            :           token = cp_lexer_peek_nth_token (parser-&gt;lexer, 2);
<span class="lineNum">   21526 </span><span class="lineCov">   16730348 :           /* If it's an ellipsis, then the list is complete.  */</span>
<span class="lineNum">   21527 </span>            :           if (token-&gt;type == CPP_ELLIPSIS)
<span class="lineNum">   21528 </span><span class="lineCov">     277657 :             break;</span>
<span class="lineNum">   21529 </span><span class="lineCov">     277657 :           /* Otherwise, there must be more parameters.  Consume the</span>
<span class="lineNum">   21530 </span>            :              `,'.  */
<span class="lineNum">   21531 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   21532 </span><span class="lineCov">   16452691 :           /* When parsing something like:</span>
<span class="lineNum">   21533 </span><span class="lineCov">       8923 : </span>
<span class="lineNum">   21534 </span>            :                 int i(float f, double d)
<span class="lineNum">   21535 </span>            : 
<span class="lineNum">   21536 </span><span class="lineCov">   16452691 :              we can tell after seeing the declaration for &quot;f&quot; that we</span>
<span class="lineNum">   21537 </span><span class="lineCov">   14283019 :              are not looking at an initialization of a variable &quot;i&quot;,</span>
<span class="lineNum">   21538 </span>            :              but rather at the declaration of a function &quot;i&quot;.
<span class="lineNum">   21539 </span><span class="lineCov">   16452691 : </span>
<span class="lineNum">   21540 </span>            :              Due to the fact that the parsing of template arguments
<span class="lineNum">   21541 </span><span class="lineCov">   16452638 :              (as specified to a template-id) requires backtracking we</span>
<span class="lineNum">   21542 </span><span class="lineCov">   16452638 :              cannot use this technique when inside a template argument</span>
<span class="lineNum">   21543 </span><span class="lineCov">   16452638 :              list.  */</span>
<span class="lineNum">   21544 </span>            :           if (!parser-&gt;in_template_argument_list_p
<span class="lineNum">   21545 </span>            :               &amp;&amp; !parser-&gt;in_type_id_in_expr_p
<span class="lineNum">   21546 </span>            :               &amp;&amp; cp_parser_uncommitted_to_tentative_parse_p (parser)
<span class="lineNum">   21547 </span><span class="lineCov">   16452691 :               /* However, a parameter-declaration of the form</span>
<span class="lineNum">   21548 </span><span class="lineCov">   16452691 :                  &quot;float(f)&quot; (which is a valid declaration of a</span>
<span class="lineNum">   21549 </span>            :                  parameter &quot;f&quot;) can also be interpreted as an
<span class="lineNum">   21550 </span>            :                  expression (the conversion of &quot;f&quot; to &quot;float&quot;).  */
<span class="lineNum">   21551 </span><span class="lineCov">   32905382 :               &amp;&amp; !parenthesized_p)</span>
<span class="lineNum">   21552 </span><span class="lineCov">    8144694 :             cp_parser_commit_to_tentative_parse (parser);</span>
<span class="lineNum">   21553 </span>            :         }
<span class="lineNum">   21554 </span><span class="lineCov">    8099820 :       else</span>
<span class="lineNum">   21555 </span><span class="lineCov">   24552490 :         {</span>
<span class="lineNum">   21556 </span>            :           cp_parser_error (parser, &quot;expected %&lt;,%&gt; or %&lt;...%&gt;&quot;);
<span class="lineNum">   21557 </span>            :           if (!cp_parser_uncommitted_to_tentative_parse_p (parser))
<span class="lineNum">   21558 </span><span class="lineCov">    8099775 :             cp_parser_skip_to_closing_parenthesis (parser,</span>
<span class="lineNum">   21559 </span>            :                                                    /*recovering=*/true,
<span class="lineNum">   21560 </span><span class="lineCov">    8099724 :                                                    /*or_comma=*/false,</span>
<span class="lineNum">   21561 </span>            :                                                    /*consume_paren=*/false);
<span class="lineNum">   21562 </span>            :           break;
<span class="lineNum">   21563 </span><span class="lineCov">    8099724 :         }</span>
<span class="lineNum">   21564 </span>            :     }
<span class="lineNum">   21565 </span><span class="lineCov">    8099724 : </span>
<span class="lineNum">   21566 </span>            :   parser-&gt;in_unbraced_linkage_specification_p
<span class="lineNum">   21567 </span>            :     = saved_in_unbraced_linkage_specification_p;
<span class="lineNum">   21568 </span>            : 
<span class="lineNum">   21569 </span><span class="lineCov">    8021506 :   /* Reset implicit_template_scope if we are about to leave the function</span>
<span class="lineNum">   21570 </span>            :      parameter list that introduced it.  Note that for out-of-line member
<span class="lineNum">   21571 </span>            :      definitions, there will be one or more class scopes before we get to
<span class="lineNum">   21572 </span>            :      the template parameter scope.  */
<span class="lineNum">   21573 </span>            : 
<span class="lineNum">   21574 </span>            :   if (cp_binding_level *its = parser-&gt;implicit_template_scope)
<span class="lineNum">   21575 </span>            :     if (cp_binding_level *maybe_its = current_binding_level-&gt;level_chain)
<span class="lineNum">   21576 </span>            :       {
<span class="lineNum">   21577 </span>            :         while (maybe_its-&gt;kind == sk_class)
<span class="lineNum">   21578 </span>            :           maybe_its = maybe_its-&gt;level_chain;
<span class="lineNum">   21579 </span>            :         if (maybe_its == its)
<span class="lineNum">   21580 </span>            :           {
<span class="lineNum">   21581 </span>            :             parser-&gt;implicit_template_parms = 0;
<span class="lineNum">   21582 </span><span class="lineCov">    8021506 :             parser-&gt;implicit_template_scope = 0;</span>
<span class="lineNum">   21583 </span><span class="lineCov">    8014559 :           }</span>
<span class="lineNum">   21584 </span><span class="lineCov">    8170981 :       }</span>
<span class="lineNum">   21585 </span>            : 
<span class="lineNum">   21586 </span>            :   return parameters;
<span class="lineNum">   21587 </span>            : }
<span class="lineNum">   21588 </span>            : 
<span class="lineNum">   21589 </span><span class="lineCov">    8177973 : /* Parse a parameter declaration.</span>
<span class="lineNum">   21590 </span><span class="lineCov">     147695 : </span>
<span class="lineNum">   21591 </span>            :    parameter-declaration:
<span class="lineNum">   21592 </span>            :      decl-specifier-seq ... [opt] declarator
<span class="lineNum">   21593 </span>            :      decl-specifier-seq declarator = assignment-expression
<span class="lineNum">   21594 </span><span class="lineCov">         51 :      decl-specifier-seq ... [opt] abstract-declarator [opt]</span>
<span class="lineNum">   21595 </span><span class="lineCov">         84 :      decl-specifier-seq abstract-declarator [opt] = assignment-expression</span>
<span class="lineNum">   21596 </span><span class="lineCov">         33 : </span>
<span class="lineNum">   21597 </span>            :    If TEMPLATE_PARM_P is TRUE, then this parameter-declaration
<span class="lineNum">   21598 </span>            :    declares a template parameter.  (In that case, a non-nested `&gt;'
<span class="lineNum">   21599 </span>            :    token encountered during the parsing of the assignment-expression
<span class="lineNum">   21600 </span>            :    is not interpreted as a greater-than operator.)
<span class="lineNum">   21601 </span>            : 
<span class="lineNum">   21602 </span><span class="lineCov">    8021506 :    Returns a representation of the parameter, or NULL if an error</span>
<span class="lineNum">   21603 </span>            :    occurs.  If PARENTHESIZED_P is non-NULL, *PARENTHESIZED_P is set to
<span class="lineNum">   21604 </span><span class="lineCov">    8708842 :    true iff the declarator is of the form &quot;(p)&quot;.  */</span>
<a name="21605"><span class="lineNum">   21605 </span><span class="lineCov">    8708842 : </span></a>
<span class="lineNum">   21606 </span>            : static cp_parameter_declarator *
<span class="lineNum">   21607 </span>            : cp_parser_parameter_declaration (cp_parser *parser,
<span class="lineNum">   21608 </span>            :                                  bool template_parm_p,
<span class="lineNum">   21609 </span>            :                                  bool *parenthesized_p)
<span class="lineNum">   21610 </span>            : {
<span class="lineNum">   21611 </span>            :   int declares_class_or_enum;
<span class="lineNum">   21612 </span><span class="lineCov">    8708842 :   cp_decl_specifier_seq decl_specifiers;</span>
<span class="lineNum">   21613 </span><span class="lineCov">        359 :   cp_declarator *declarator;</span>
<span class="lineNum">   21614 </span>            :   tree default_argument;
<span class="lineNum">   21615 </span><span class="lineCov">        383 :   cp_token *token = NULL, *declarator_token_start = NULL;</span>
<span class="lineNum">   21616 </span><span class="lineCov">         24 :   const char *saved_message;</span>
<span class="lineNum">   21617 </span><span class="lineCov">        359 :   bool template_parameter_pack_p = false;</span>
<span class="lineNum">   21618 </span>            : 
<span class="lineNum">   21619 </span><span class="lineCov">        347 :   /* In a template parameter, `&gt;' is not an operator.</span>
<span class="lineNum">   21620 </span><span class="lineCov">        347 : </span>
<span class="lineNum">   21621 </span>            :      [temp.param]
<span class="lineNum">   21622 </span>            : 
<span class="lineNum">   21623 </span>            :      When parsing a default template-argument for a non-type
<span class="lineNum">   21624 </span><span class="lineCov">    8708842 :      template-parameter, the first non-nested `&gt;' is taken as the end</span>
<span class="lineNum">   21625 </span>            :      of the template parameter-list rather than a greater-than
<span class="lineNum">   21626 </span>            :      operator.  */
<span class="lineNum">   21627 </span>            : 
<span class="lineNum">   21628 </span>            :   /* Type definitions may not appear in parameter types.  */
<span class="lineNum">   21629 </span>            :   saved_message = parser-&gt;type_definition_forbidden_message;
<span class="lineNum">   21630 </span>            :   parser-&gt;type_definition_forbidden_message
<span class="lineNum">   21631 </span>            :     = G_(&quot;types may not be defined in parameter types&quot;);
<span class="lineNum">   21632 </span>            : 
<span class="lineNum">   21633 </span>            :   int template_parm_idx = (function_being_declared_is_template_p (parser) ?
<span class="lineNum">   21634 </span>            :                            TREE_VEC_LENGTH (INNERMOST_TEMPLATE_PARMS
<span class="lineNum">   21635 </span>            :                                             (current_template_parms)) : 0);
<span class="lineNum">   21636 </span>            : 
<span class="lineNum">   21637 </span>            :   /* Parse the declaration-specifiers.  */
<span class="lineNum">   21638 </span>            :   cp_token *decl_spec_token_start = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   21639 </span>            :   cp_parser_decl_specifier_seq (parser,
<span class="lineNum">   21640 </span>            :                                 CP_PARSER_FLAGS_NONE,
<span class="lineNum">   21641 </span>            :                                 &amp;decl_specifiers,
<span class="lineNum">   21642 </span>            :                                 &amp;declares_class_or_enum);
<span class="lineNum">   21643 </span>            : 
<span class="lineNum">   21644 </span>            :   /* Complain about missing 'typename' or other invalid type names.  */
<span class="lineNum">   21645 </span><span class="lineCov">   17466001 :   if (!decl_specifiers.any_type_specifiers_p</span>
<span class="lineNum">   21646 </span>            :       &amp;&amp; cp_parser_parse_and_diagnose_invalid_type_name (parser))
<span class="lineNum">   21647 </span>            :     decl_specifiers.type = error_mark_node;
<span class="lineNum">   21648 </span>            : 
<span class="lineNum">   21649 </span><span class="lineCov">   17466001 :   /* If an error occurred, there's no reason to attempt to parse the</span>
<span class="lineNum">   21650 </span><span class="lineCov">   17466001 :      rest of the declaration.  */</span>
<span class="lineNum">   21651 </span><span class="lineCov">   17466001 :   if (cp_parser_error_occurred (parser))</span>
<span class="lineNum">   21652 </span><span class="lineCov">   17466001 :     {</span>
<span class="lineNum">   21653 </span><span class="lineCov">   17466001 :       parser-&gt;type_definition_forbidden_message = saved_message;</span>
<span class="lineNum">   21654 </span><span class="lineCov">   17466001 :       return NULL;</span>
<span class="lineNum">   21655 </span><span class="lineCov">   17466001 :     }</span>
<span class="lineNum">   21656 </span>            : 
<span class="lineNum">   21657 </span>            :   /* Peek at the next token.  */
<span class="lineNum">   21658 </span>            :   token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   21659 </span>            : 
<span class="lineNum">   21660 </span>            :   /* If the next token is a `)', `,', `=', `&gt;', or `...', then there
<span class="lineNum">   21661 </span>            :      is no declarator. However, when variadic templates are enabled,
<span class="lineNum">   21662 </span>            :      there may be a declarator following `...'.  */
<span class="lineNum">   21663 </span>            :   if (token-&gt;type == CPP_CLOSE_PAREN
<span class="lineNum">   21664 </span>            :       || token-&gt;type == CPP_COMMA
<span class="lineNum">   21665 </span>            :       || token-&gt;type == CPP_EQ
<span class="lineNum">   21666 </span>            :       || token-&gt;type == CPP_GREATER)
<span class="lineNum">   21667 </span><span class="lineCov">   17466001 :     {</span>
<span class="lineNum">   21668 </span><span class="lineCov">   17466001 :       declarator = NULL;</span>
<span class="lineNum">   21669 </span><span class="lineCov">   17466001 :       if (parenthesized_p)</span>
<span class="lineNum">   21670 </span>            :         *parenthesized_p = false;
<span class="lineNum">   21671 </span><span class="lineCov">   17466001 :     }</span>
<span class="lineNum">   21672 </span><span class="lineCov">    3898103 :   /* Otherwise, there should be a declarator.  */</span>
<span class="lineNum">   21673 </span><span class="lineCov">   17466001 :   else</span>
<span class="lineNum">   21674 </span>            :     {
<span class="lineNum">   21675 </span>            :       bool saved_default_arg_ok_p = parser-&gt;default_arg_ok_p;
<span class="lineNum">   21676 </span><span class="lineCov">   34932002 :       parser-&gt;default_arg_ok_p = false;</span>
<span class="lineNum">   21677 </span><span class="lineCov">   17466001 : </span>
<span class="lineNum">   21678 </span>            :       /* After seeing a decl-specifier-seq, if the next token is not a
<span class="lineNum">   21679 </span>            :          &quot;(&quot;, there is no possibility that the code is a valid
<span class="lineNum">   21680 </span>            :          expression.  Therefore, if parsing tentatively, we commit at
<span class="lineNum">   21681 </span>            :          this point.  */
<span class="lineNum">   21682 </span>            :       if (!parser-&gt;in_template_argument_list_p
<span class="lineNum">   21683 </span><span class="lineCov">   17466001 :           /* In an expression context, having seen:</span>
<span class="lineNum">   21684 </span><span class="lineCov">   17466001 : </span>
<span class="lineNum">   21685 </span><span class="lineCov">         21 :                (int((char ...</span>
<span class="lineNum">   21686 </span>            : 
<span class="lineNum">   21687 </span>            :              we cannot be sure whether we are looking at a
<span class="lineNum">   21688 </span>            :              function-type (taking a &quot;char&quot; as a parameter) or a cast
<span class="lineNum">   21689 </span><span class="lineCov">   34932002 :              of some object of type &quot;char&quot; to &quot;int&quot;.  */</span>
<span class="lineNum">   21690 </span>            :           &amp;&amp; !parser-&gt;in_type_id_in_expr_p
<span class="lineNum">   21691 </span><span class="lineCov">     276610 :           &amp;&amp; cp_parser_uncommitted_to_tentative_parse_p (parser)</span>
<span class="lineNum">   21692 </span><span class="lineCov">     276610 :           &amp;&amp; cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_OPEN_BRACE)</span>
<span class="lineNum">   21693 </span>            :           &amp;&amp; cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_OPEN_PAREN))
<span class="lineNum">   21694 </span>            :         cp_parser_commit_to_tentative_parse (parser);
<span class="lineNum">   21695 </span>            :       /* Parse the declarator.  */
<span class="lineNum">   21696 </span><span class="lineCov">   34378782 :       declarator_token_start = token;</span>
<span class="lineNum">   21697 </span>            :       declarator = cp_parser_declarator (parser,
<span class="lineNum">   21698 </span>            :                                          CP_PARSER_DECLARATOR_EITHER,
<span class="lineNum">   21699 </span>            :                                          /*ctor_dtor_or_conv_p=*/NULL,
<span class="lineNum">   21700 </span>            :                                          parenthesized_p,
<span class="lineNum">   21701 </span><span class="lineCov">   17189391 :                                          /*member_p=*/false,</span>
<span class="lineNum">   21702 </span><span class="lineCov">   16543784 :                                          /*friend_p=*/false);</span>
<span class="lineNum">   21703 </span><span class="lineCov">   16173657 :       parser-&gt;default_arg_ok_p = saved_default_arg_ok_p;</span>
<span class="lineNum">   21704 </span><span class="lineCov">   16022153 :       /* After the declarator, allow more attributes.  */</span>
<span class="lineNum">   21705 </span>            :       decl_specifiers.attributes
<span class="lineNum">   21706 </span><span class="lineCov">    1180441 :         = attr_chainon (decl_specifiers.attributes,</span>
<span class="lineNum">   21707 </span><span class="lineCov">    1180441 :                         cp_parser_attributes_opt (parser));</span>
<span class="lineNum">   21708 </span><span class="lineCov">     996594 : </span>
<span class="lineNum">   21709 </span>            :       /* If the declarator is a template parameter pack, remember that and
<span class="lineNum">   21710 </span>            :          clear the flag in the declarator itself so we don't get errors
<span class="lineNum">   21711 </span>            :          from grokdeclarator.  */
<span class="lineNum">   21712 </span>            :       if (template_parm_p &amp;&amp; declarator &amp;&amp; declarator-&gt;parameter_pack_p)
<span class="lineNum">   21713 </span><span class="lineCov">   16008950 :         {</span>
<span class="lineNum">   21714 </span><span class="lineCov">   16008950 :           declarator-&gt;parameter_pack_p = false;</span>
<span class="lineNum">   21715 </span>            :           template_parameter_pack_p = true;
<span class="lineNum">   21716 </span>            :         }
<span class="lineNum">   21717 </span>            :     }
<span class="lineNum">   21718 </span>            : 
<span class="lineNum">   21719 </span>            :   /* If the next token is an ellipsis, and we have not seen a declarator
<span class="lineNum">   21720 </span><span class="lineCov">   16008950 :      name, and if either the type of the declarator contains parameter</span>
<span class="lineNum">   21721 </span>            :      packs but it is not a TYPE_PACK_EXPANSION or is null (this happens
<span class="lineNum">   21722 </span>            :      for, eg, abbreviated integral type names), then we actually have a
<span class="lineNum">   21723 </span>            :      parameter pack expansion expression. Otherwise, leave the ellipsis
<span class="lineNum">   21724 </span>            :      for a C-style variadic function. */
<span class="lineNum">   21725 </span>            :   token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   21726 </span>            : 
<span class="lineNum">   21727 </span>            :   /* If a function parameter pack was specified and an implicit template
<span class="lineNum">   21728 </span><span class="lineCov">   15895219 :      parameter was introduced during cp_parser_parameter_declaration,</span>
<span class="lineNum">   21729 </span><span class="lineCov">   21612432 :      change any implicit parameters introduced into packs.  */</span>
<span class="lineNum">   21730 </span><span class="lineCov">    5717327 :   if (parser-&gt;implicit_template_parms</span>
<span class="lineNum">   21731 </span><span class="lineCov">   21726253 :       &amp;&amp; ((token-&gt;type == CPP_ELLIPSIS</span>
<span class="lineNum">   21732 </span><span class="lineCov">    5658564 :            &amp;&amp; declarator_can_be_parameter_pack (declarator))</span>
<span class="lineNum">   21733 </span>            :           || (declarator &amp;&amp; declarator-&gt;parameter_pack_p)))
<span class="lineNum">   21734 </span><span class="lineCov">   16008950 :     {</span>
<span class="lineNum">   21735 </span><span class="lineCov">   16008950 :       int latest_template_parm_idx = TREE_VEC_LENGTH</span>
<span class="lineNum">   21736 </span>            :         (INNERMOST_TEMPLATE_PARMS (current_template_parms));
<span class="lineNum">   21737 </span>            : 
<span class="lineNum">   21738 </span>            :       if (latest_template_parm_idx != template_parm_idx)
<span class="lineNum">   21739 </span>            :         decl_specifiers.type = convert_generic_types_to_packs
<span class="lineNum">   21740 </span>            :           (decl_specifiers.type,
<span class="lineNum">   21741 </span><span class="lineCov">   16008950 :            template_parm_idx, latest_template_parm_idx);</span>
<span class="lineNum">   21742 </span>            :     }
<span class="lineNum">   21743 </span><span class="lineCov">   16008950 : </span>
<span class="lineNum">   21744 </span><span class="lineCov">   16008950 :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_ELLIPSIS))</span>
<span class="lineNum">   21745 </span>            :     {
<span class="lineNum">   21746 </span>            :       tree type = decl_specifiers.type;
<span class="lineNum">   21747 </span>            : 
<span class="lineNum">   21748 </span>            :       if (type &amp;&amp; DECL_P (type))
<span class="lineNum">   21749 </span>            :         type = TREE_TYPE (type);
<span class="lineNum">   21750 </span><span class="lineCov">   16008950 : </span>
<span class="lineNum">   21751 </span>            :       if (((type
<span class="lineNum">   21752 </span><span class="lineCov">      24674 :             &amp;&amp; TREE_CODE (type) != TYPE_PACK_EXPANSION</span>
<span class="lineNum">   21753 </span><span class="lineCov">      24674 :             &amp;&amp; (template_parm_p || uses_parameter_packs (type)))</span>
<span class="lineNum">   21754 </span>            :            || (!type &amp;&amp; template_parm_p))
<span class="lineNum">   21755 </span>            :           &amp;&amp; declarator_can_be_parameter_pack (declarator))
<span class="lineNum">   21756 </span>            :         {
<span class="lineNum">   21757 </span>            :           /* Consume the `...'. */
<span class="lineNum">   21758 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   21759 </span>            :           maybe_warn_variadic_templates ();
<span class="lineNum">   21760 </span>            :           
<span class="lineNum">   21761 </span>            :           /* Build a pack expansion type */
<span class="lineNum">   21762 </span>            :           if (template_parm_p)
<span class="lineNum">   21763 </span><span class="lineCov">   34378782 :             template_parameter_pack_p = true;</span>
<span class="lineNum">   21764 </span>            :           else if (declarator)
<span class="lineNum">   21765 </span>            :             declarator-&gt;parameter_pack_p = true;
<span class="lineNum">   21766 </span>            :           else
<span class="lineNum">   21767 </span>            :             decl_specifiers.type = make_pack_expansion (type);
<span class="lineNum">   21768 </span><span class="lineCov">   17189391 :         }</span>
<span class="lineNum">   21769 </span><span class="lineCov">   17189391 :     }</span>
<span class="lineNum">   21770 </span><span class="lineCov">          6 : </span>
<span class="lineNum">   21771 </span><span class="lineCov">        385 :   /* The restriction on defining new types applies only to the type</span>
<span class="lineNum">   21772 </span>            :      of the parameter, not to the default argument.  */
<span class="lineNum">   21773 </span><span class="lineCov">         45 :   parser-&gt;type_definition_forbidden_message = saved_message;</span>
<span class="lineNum">   21774 </span>            : 
<span class="lineNum">   21775 </span>            :   /* If the next token is `=', then process a default argument.  */
<span class="lineNum">   21776 </span><span class="lineCov">         45 :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_EQ))</span>
<span class="lineNum">   21777 </span><span class="lineCov">         44 :     {</span>
<span class="lineNum">   21778 </span><span class="lineCov">         44 :       tree type = decl_specifiers.type;</span>
<span class="lineNum">   21779 </span>            :       token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   21780 </span>            :       /* If we are defining a class, then the tokens that make up the
<span class="lineNum">   21781 </span>            :          default argument must be saved and processed later.  */
<span class="lineNum">   21782 </span><span class="lineCov">   17189391 :       if (!template_parm_p &amp;&amp; at_class_scope_p ()</span>
<span class="lineNum">   21783 </span>            :           &amp;&amp; TYPE_BEING_DEFINED (current_class_type)
<span class="lineNum">   21784 </span><span class="lineCov">     123530 :           &amp;&amp; !LAMBDA_TYPE_P (current_class_type))</span>
<span class="lineNum">   21785 </span>            :         default_argument = cp_parser_cache_defarg (parser, /*nsdmi=*/false);
<span class="lineNum">   21786 </span><span class="lineCov">     123530 : </span>
<span class="lineNum">   21787 </span><span class="lineCov">     120934 :       // A constrained-type-specifier may declare a type template-parameter.</span>
<span class="lineNum">   21788 </span>            :       else if (declares_constrained_type_template_parameter (type))
<span class="lineNum">   21789 </span><span class="lineCov">     123530 :         default_argument</span>
<span class="lineNum">   21790 </span><span class="lineCov">     123522 :           = cp_parser_default_type_template_argument (parser);</span>
<span class="lineNum">   21791 </span><span class="lineCov">     123522 : </span>
<span class="lineNum">   21792 </span><span class="lineCov">         68 :       // A constrained-type-specifier may declare a template-template-parameter.</span>
<span class="lineNum">   21793 </span><span class="lineCov">     247000 :       else if (declares_constrained_template_template_parameter (type))</span>
<span class="lineNum">   21794 </span>            :         default_argument
<span class="lineNum">   21795 </span>            :           = cp_parser_default_template_template_argument (parser);
<span class="lineNum">   21796 </span><span class="lineCov">     123470 : </span>
<span class="lineNum">   21797 </span><span class="lineCov">     123470 :       /* Outside of a class definition, we can just parse the</span>
<span class="lineNum">   21798 </span>            :          assignment-expression.  */
<span class="lineNum">   21799 </span>            :       else
<span class="lineNum">   21800 </span><span class="lineCov">     123470 :         default_argument</span>
<span class="lineNum">   21801 </span>            :           = cp_parser_default_argument (parser, template_parm_p);
<span class="lineNum">   21802 </span><span class="lineCov">     121371 : </span>
<span class="lineNum">   21803 </span><span class="lineCov">       2932 :       if (!parser-&gt;default_arg_ok_p)</span>
<span class="lineNum">   21804 </span>            :         {
<span class="lineNum">   21805 </span><span class="lineCov">     118439 :           permerror (token-&gt;location,</span>
<span class="lineNum">   21806 </span>            :                      &quot;default arguments are only &quot;
<span class="lineNum">   21807 </span>            :                      &quot;permitted for function parameters&quot;);
<span class="lineNum">   21808 </span>            :         }
<span class="lineNum">   21809 </span>            :       else if ((declarator &amp;&amp; declarator-&gt;parameter_pack_p)
<span class="lineNum">   21810 </span>            :                || template_parameter_pack_p
<span class="lineNum">   21811 </span><span class="lineCov">   17189391 :                || (decl_specifiers.type</span>
<span class="lineNum">   21812 </span>            :                    &amp;&amp; PACK_EXPANSION_P (decl_specifiers.type)))
<span class="lineNum">   21813 </span>            :         {
<span class="lineNum">   21814 </span><span class="lineCov">   17189391 :           /* Find the name of the parameter pack.  */     </span>
<span class="lineNum">   21815 </span>            :           cp_declarator *id_declarator = declarator;
<span class="lineNum">   21816 </span><span class="lineCov">     498468 :           while (id_declarator &amp;&amp; id_declarator-&gt;kind != cdk_id)</span>
<span class="lineNum">   21817 </span><span class="lineCov">     996936 :             id_declarator = id_declarator-&gt;declarator;</span>
<span class="lineNum">   21818 </span>            :           
<span class="lineNum">   21819 </span>            :           if (id_declarator &amp;&amp; id_declarator-&gt;kind == cdk_id)
<span class="lineNum">   21820 </span><span class="lineCov">     313995 :             error_at (declarator_token_start-&gt;location,</span>
<span class="lineNum">   21821 </span><span class="lineCov">     248389 :                       template_parm_p</span>
<span class="lineNum">   21822 </span><span class="lineCov">     746756 :                       ? G_(&quot;template parameter pack %qD &quot;</span>
<span class="lineNum">   21823 </span><span class="lineCov">     248273 :                            &quot;cannot have a default argument&quot;)</span>
<span class="lineNum">   21824 </span>            :                       : G_(&quot;parameter pack %qD cannot have &quot;
<span class="lineNum">   21825 </span>            :                            &quot;a default argument&quot;),
<span class="lineNum">   21826 </span><span class="lineCov">     250195 :                       id_declarator-&gt;u.id.unqualified_name);</span>
<span class="lineNum">   21827 </span><span class="lineCov">          5 :           else</span>
<span class="lineNum">   21828 </span><span class="lineCov">          5 :             error_at (declarator_token_start-&gt;location,</span>
<span class="lineNum">   21829 </span>            :                       template_parm_p
<span class="lineNum">   21830 </span>            :                       ? G_(&quot;template parameter pack cannot have &quot;
<span class="lineNum">   21831 </span><span class="lineCov">     250190 :                            &quot;a default argument&quot;)</span>
<span class="lineNum">   21832 </span><span class="lineCov">          5 :                       : G_(&quot;parameter pack cannot have a &quot;</span>
<span class="lineNum">   21833 </span><span class="lineCov">          5 :                            &quot;default argument&quot;));</span>
<span class="lineNum">   21834 </span>            : 
<span class="lineNum">   21835 </span>            :           default_argument = NULL_TREE;
<span class="lineNum">   21836 </span>            :         }
<span class="lineNum">   21837 </span>            :     }
<span class="lineNum">   21838 </span><span class="lineCov">     250185 :   else</span>
<span class="lineNum">   21839 </span><span class="lineCov">     250185 :     default_argument = NULL_TREE;</span>
<span class="lineNum">   21840 </span>            : 
<span class="lineNum">   21841 </span><span class="lineCov">     498468 :   /* Generate a location for the parameter, ranging from the start of the</span>
<span class="lineNum">   21842 </span>            :      initial token to the end of the final token (using input_location for
<span class="lineNum">   21843 </span><span class="lineCov">          6 :      the latter, set up by cp_lexer_set_source_position_from_token when</span>
<span class="lineNum">   21844 </span>            :      consuming tokens).
<span class="lineNum">   21845 </span>            : 
<span class="lineNum">   21846 </span>            :      If we have a identifier, then use it for the caret location, e.g.
<span class="lineNum">   21847 </span><span class="lineCov">     498462 : </span>
<span class="lineNum">   21848 </span><span class="lineCov">     498460 :        extern int callee (int one, int (*two)(int, int), float three);</span>
<span class="lineNum">   21849 </span><span class="lineCov">     498450 :                                    ~~~~~~^~~~~~~~~~~~~~</span>
<span class="lineNum">   21850 </span><span class="lineCov">     492732 : </span>
<span class="lineNum">   21851 </span>            :      otherwise, reuse the start location for the caret location e.g.:
<span class="lineNum">   21852 </span>            : 
<span class="lineNum">   21853 </span>            :        extern int callee (int one, int (*)(int, int), float three);
<span class="lineNum">   21854 </span><span class="lineCov">         18 :                                    ^~~~~~~~~~~~~~~~~</span>
<span class="lineNum">   21855 </span><span class="lineCov">          4 : </span>
<span class="lineNum">   21856 </span>            :   */
<span class="lineNum">   21857 </span><span class="lineCov">         14 :   location_t caret_loc = (declarator &amp;&amp; declarator-&gt;id_loc != UNKNOWN_LOCATION</span>
<span class="lineNum">   21858 </span><span class="lineCov">          9 :                           ? declarator-&gt;id_loc</span>
<span class="lineNum">   21859 </span>            :                           : decl_spec_token_start-&gt;location);
<span class="lineNum">   21860 </span>            :   location_t param_loc = make_location (caret_loc,
<span class="lineNum">   21861 </span>            :                                         decl_spec_token_start-&gt;location,
<span class="lineNum">   21862 </span>            :                                         input_location);
<span class="lineNum">   21863 </span>            : 
<span class="lineNum">   21864 </span>            :   return make_parameter_declarator (&amp;decl_specifiers,
<span class="lineNum">   21865 </span>            :                                     declarator,
<span class="lineNum">   21866 </span><span class="lineCov">          9 :                                     default_argument,</span>
<span class="lineNum">   21867 </span>            :                                     param_loc,
<span class="lineNum">   21868 </span>            :                                     template_parameter_pack_p);
<span class="lineNum">   21869 </span>            : }
<span class="lineNum">   21870 </span>            : 
<span class="lineNum">   21871 </span>            : /* Parse a default argument and return it.
<span class="lineNum">   21872 </span>            : 
<span class="lineNum">   21873 </span>            :    TEMPLATE_PARM_P is true if this is a default argument for a
<a name="21874"><span class="lineNum">   21874 </span>            :    non-type template parameter.  */</a>
<span class="lineNum">   21875 </span>            : static tree
<span class="lineNum">   21876 </span>            : cp_parser_default_argument (cp_parser *parser, bool template_parm_p)
<span class="lineNum">   21877 </span>            : {
<span class="lineNum">   21878 </span>            :   tree default_argument = NULL_TREE;
<span class="lineNum">   21879 </span>            :   bool saved_greater_than_is_operator_p;
<span class="lineNum">   21880 </span>            :   bool saved_local_variables_forbidden_p;
<span class="lineNum">   21881 </span>            :   bool non_constant_p, is_direct_init;
<span class="lineNum">   21882 </span>            : 
<span class="lineNum">   21883 </span>            :   /* Make sure that PARSER-&gt;GREATER_THAN_IS_OPERATOR_P is
<span class="lineNum">   21884 </span>            :      set correctly.  */
<span class="lineNum">   21885 </span>            :   saved_greater_than_is_operator_p = parser-&gt;greater_than_is_operator_p;
<span class="lineNum">   21886 </span>            :   parser-&gt;greater_than_is_operator_p = !template_parm_p;
<span class="lineNum">   21887 </span>            :   /* Local variable names (and the `this' keyword) may not
<span class="lineNum">   21888 </span>            :      appear in a default argument.  */
<span class="lineNum">   21889 </span>            :   saved_local_variables_forbidden_p = parser-&gt;local_variables_forbidden_p;
<span class="lineNum">   21890 </span>            :   parser-&gt;local_variables_forbidden_p = true;
<span class="lineNum">   21891 </span>            :   /* Parse the assignment-expression.  */
<span class="lineNum">   21892 </span>            :   if (template_parm_p)
<span class="lineNum">   21893 </span>            :     push_deferring_access_checks (dk_no_deferred);
<span class="lineNum">   21894 </span>            :   tree saved_class_ptr = NULL_TREE;
<span class="lineNum">   21895 </span><span class="lineCov">   15888326 :   tree saved_class_ref = NULL_TREE;</span>
<span class="lineNum">   21896 </span><span class="lineCov">   18275586 :   /* The &quot;this&quot; pointer is not valid in a default argument.  */</span>
<span class="lineNum">   21897 </span>            :   if (cfun)
<span class="lineNum">   21898 </span><span class="lineCov">   17189391 :     {</span>
<span class="lineNum">   21899 </span>            :       saved_class_ptr = current_class_ptr;
<span class="lineNum">   21900 </span>            :       cp_function_chain-&gt;x_current_class_ptr = NULL_TREE;
<span class="lineNum">   21901 </span>            :       saved_class_ref = current_class_ref;
<span class="lineNum">   21902 </span><span class="lineCov">   17189391 :       cp_function_chain-&gt;x_current_class_ref = NULL_TREE;</span>
<span class="lineNum">   21903 </span>            :     }
<span class="lineNum">   21904 </span>            :   default_argument
<span class="lineNum">   21905 </span>            :     = cp_parser_initializer (parser, &amp;is_direct_init, &amp;non_constant_p);
<span class="lineNum">   21906 </span><span class="lineCov">   17189391 :   /* Restore the &quot;this&quot; pointer.  */</span>
<span class="lineNum">   21907 </span>            :   if (cfun)
<span class="lineNum">   21908 </span>            :     {
<span class="lineNum">   21909 </span>            :       cp_function_chain-&gt;x_current_class_ptr = saved_class_ptr;
<span class="lineNum">   21910 </span>            :       cp_function_chain-&gt;x_current_class_ref = saved_class_ref;
<span class="lineNum">   21911 </span>            :     }
<span class="lineNum">   21912 </span>            :   if (BRACE_ENCLOSED_INITIALIZER_P (default_argument))
<span class="lineNum">   21913 </span>            :     maybe_warn_cpp0x (CPP0X_INITIALIZER_LISTS);
<span class="lineNum">   21914 </span><span class="lineCov">     250185 :   if (template_parm_p)</span>
<span class="lineNum">   21915 </span>            :     pop_deferring_access_checks ();
<span class="lineNum">   21916 </span><span class="lineCov">     250185 :   parser-&gt;greater_than_is_operator_p = saved_greater_than_is_operator_p;</span>
<span class="lineNum">   21917 </span><span class="lineCov">     250185 :   parser-&gt;local_variables_forbidden_p = saved_local_variables_forbidden_p;</span>
<span class="lineNum">   21918 </span><span class="lineCov">     250185 : </span>
<span class="lineNum">   21919 </span><span class="lineCov">     250185 :   return default_argument;</span>
<span class="lineNum">   21920 </span>            : }
<span class="lineNum">   21921 </span>            : 
<span class="lineNum">   21922 </span>            : /* Parse a function-body.
<span class="lineNum">   21923 </span><span class="lineCov">     250185 : </span>
<span class="lineNum">   21924 </span><span class="lineCov">     250185 :    function-body:</span>
<span class="lineNum">   21925 </span>            :      compound_statement  */
<a name="21926"><span class="lineNum">   21926 </span>            : </a>
<span class="lineNum">   21927 </span><span class="lineCov">     250185 : static void</span>
<span class="lineNum">   21928 </span><span class="lineCov">     250185 : cp_parser_function_body (cp_parser *parser, bool in_function_try_block)</span>
<span class="lineNum">   21929 </span>            : {
<span class="lineNum">   21930 </span><span class="lineCov">     250185 :   cp_parser_compound_statement (parser, NULL, (in_function_try_block</span>
<span class="lineNum">   21931 </span><span class="lineCov">     184463 :                                                ? BCS_TRY_BLOCK : BCS_NORMAL),</span>
<span class="lineNum">   21932 </span><span class="lineCov">     250185 :                                 true);</span>
<span class="lineNum">   21933 </span><span class="lineCov">     250185 : }</span>
<span class="lineNum">   21934 </span>            : 
<span class="lineNum">   21935 </span><span class="lineCov">     250185 : /* Parse a ctor-initializer-opt followed by a function-body.  Return</span>
<span class="lineNum">   21936 </span>            :    true if a ctor-initializer was present.  When IN_FUNCTION_TRY_BLOCK
<span class="lineNum">   21937 </span><span class="lineCov">         26 :    is true we are parsing a function-try-block.  */</span>
<a name="21938"><span class="lineNum">   21938 </span><span class="lineCov">         26 : </span></a>
<span class="lineNum">   21939 </span><span class="lineCov">         26 : static void</span>
<span class="lineNum">   21940 </span><span class="lineCov">         26 : cp_parser_ctor_initializer_opt_and_function_body (cp_parser *parser,</span>
<span class="lineNum">   21941 </span>            :                                                   bool in_function_try_block)
<span class="lineNum">   21942 </span><span class="lineCov">     250185 : {</span>
<span class="lineNum">   21943 </span><span class="lineCov">     250185 :   tree body, list;</span>
<span class="lineNum">   21944 </span>            :   const bool check_body_p =
<span class="lineNum">   21945 </span><span class="lineCov">     250185 :      DECL_CONSTRUCTOR_P (current_function_decl)</span>
<span class="lineNum">   21946 </span>            :      &amp;&amp; DECL_DECLARED_CONSTEXPR_P (current_function_decl);
<span class="lineNum">   21947 </span><span class="lineCov">         26 :   tree last = NULL;</span>
<span class="lineNum">   21948 </span><span class="lineCov">         26 : </span>
<span class="lineNum">   21949 </span>            :   /* Begin the function body.  */
<span class="lineNum">   21950 </span><span class="lineCov">     250185 :   body = begin_function_body ();</span>
<span class="lineNum">   21951 </span><span class="lineCov">        409 :   /* Parse the optional ctor-initializer.  */</span>
<span class="lineNum">   21952 </span><span class="lineCov">     250185 :   cp_parser_ctor_initializer_opt (parser);</span>
<span class="lineNum">   21953 </span><span class="lineCov">     184463 : </span>
<span class="lineNum">   21954 </span><span class="lineCov">     250185 :   /* If we're parsing a constexpr constructor definition, we need</span>
<span class="lineNum">   21955 </span><span class="lineCov">     250185 :      to check that the constructor body is indeed empty.  However,</span>
<span class="lineNum">   21956 </span>            :      before we get to cp_parser_function_body lot of junk has been
<span class="lineNum">   21957 </span><span class="lineCov">     250185 :      generated, so we can't just check that we have an empty block.</span>
<span class="lineNum">   21958 </span>            :      Rather we take a snapshot of the outermost block, and check whether
<span class="lineNum">   21959 </span>            :      cp_parser_function_body changed its state.  */
<span class="lineNum">   21960 </span>            :   if (check_body_p)
<span class="lineNum">   21961 </span>            :     {
<span class="lineNum">   21962 </span>            :       list = cur_stmt_list;
<span class="lineNum">   21963 </span>            :       if (STATEMENT_LIST_TAIL (list))
<span class="lineNum">   21964 </span>            :         last = STATEMENT_LIST_TAIL (list)-&gt;stmt;
<span class="lineNum">   21965 </span>            :     }
<span class="lineNum">   21966 </span><span class="lineNoCov">          0 :   /* Parse the function-body.  */</span>
<span class="lineNum">   21967 </span>            :   cp_parser_function_body (parser, in_function_try_block);
<span class="lineNum">   21968 </span><span class="lineCov">    5666355 :   if (check_body_p)</span>
<span class="lineNum">   21969 </span>            :     check_constexpr_ctor_body (last, list, /*complain=*/true);
<span class="lineNum">   21970 </span>            :   /* Finish the function body.  */
<span class="lineNum">   21971 </span><span class="lineNoCov">          0 :   finish_function_body (body);</span>
<span class="lineNum">   21972 </span>            : }
<span class="lineNum">   21973 </span>            : 
<span class="lineNum">   21974 </span>            : /* Parse an initializer.
<span class="lineNum">   21975 </span>            : 
<span class="lineNum">   21976 </span>            :    initializer:
<span class="lineNum">   21977 </span>            :      = initializer-clause
<span class="lineNum">   21978 </span><span class="lineCov">    5666355 :      ( expression-list )</span>
<span class="lineNum">   21979 </span>            : 
<span class="lineNum">   21980 </span>            :    Returns an expression representing the initializer.  If no
<span class="lineNum">   21981 </span><span class="lineCov">    5666355 :    initializer is present, NULL_TREE is returned.</span>
<span class="lineNum">   21982 </span><span class="lineCov">    5666355 : </span>
<span class="lineNum">   21983 </span><span class="lineCov">    5666355 :    *IS_DIRECT_INIT is set to FALSE if the `= initializer-clause'</span>
<span class="lineNum">   21984 </span><span class="lineCov">    5666355 :    production is used, and TRUE otherwise.  *IS_DIRECT_INIT is</span>
<span class="lineNum">   21985 </span><span class="lineCov">    5666355 :    set to TRUE if there is no initializer present.  If there is an</span>
<span class="lineNum">   21986 </span>            :    initializer, and it is not a constant-expression, *NON_CONSTANT_P
<span class="lineNum">   21987 </span>            :    is set to true; otherwise it is set to false.  */
<a name="21988"><span class="lineNum">   21988 </span><span class="lineCov">    5666355 : </span></a>
<span class="lineNum">   21989 </span>            : static tree
<span class="lineNum">   21990 </span><span class="lineCov">    5666355 : cp_parser_initializer (cp_parser* parser, bool* is_direct_init,</span>
<span class="lineNum">   21991 </span>            :                        bool* non_constant_p, bool subexpression_p)
<span class="lineNum">   21992 </span>            : {
<span class="lineNum">   21993 </span>            :   cp_token *token;
<span class="lineNum">   21994 </span>            :   tree init;
<span class="lineNum">   21995 </span>            : 
<span class="lineNum">   21996 </span>            :   /* Peek at the next token.  */
<span class="lineNum">   21997 </span>            :   token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   21998 </span><span class="lineCov">    5666355 : </span>
<span class="lineNum">   21999 </span>            :   /* Let our caller know whether or not this initializer was
<span class="lineNum">   22000 </span><span class="lineCov">     104650 :      parenthesized.  */</span>
<span class="lineNum">   22001 </span><span class="lineCov">     104650 :   *is_direct_init = (token-&gt;type != CPP_EQ);</span>
<span class="lineNum">   22002 </span><span class="lineCov">     207946 :   /* Assume that the initializer is constant.  */</span>
<span class="lineNum">   22003 </span>            :   *non_constant_p = false;
<span class="lineNum">   22004 </span>            : 
<span class="lineNum">   22005 </span><span class="lineCov">    5666355 :   if (token-&gt;type == CPP_EQ)</span>
<span class="lineNum">   22006 </span><span class="lineCov">    5666336 :     {</span>
<span class="lineNum">   22007 </span><span class="lineCov">     104650 :       /* Consume the `='.  */</span>
<span class="lineNum">   22008 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   22009 </span><span class="lineCov">    5666336 :       /* Parse the initializer-clause.  */</span>
<span class="lineNum">   22010 </span><span class="lineCov">    5666336 :       init = cp_parser_initializer_clause (parser, non_constant_p);</span>
<span class="lineNum">   22011 </span>            :     }
<span class="lineNum">   22012 </span>            :   else if (token-&gt;type == CPP_OPEN_PAREN)
<span class="lineNum">   22013 </span>            :     {
<span class="lineNum">   22014 </span>            :       vec&lt;tree, va_gc&gt; *vec;
<span class="lineNum">   22015 </span>            :       vec = cp_parser_parenthesized_expression_list (parser, non_attr,
<span class="lineNum">   22016 </span>            :                                                      /*cast_p=*/false,
<span class="lineNum">   22017 </span>            :                                                      /*allow_expansion_p=*/true,
<span class="lineNum">   22018 </span>            :                                                      non_constant_p);
<span class="lineNum">   22019 </span>            :       if (vec == NULL)
<span class="lineNum">   22020 </span>            :         return error_mark_node;
<span class="lineNum">   22021 </span>            :       init = build_tree_list_vec (vec);
<span class="lineNum">   22022 </span>            :       release_tree_vector (vec);
<span class="lineNum">   22023 </span>            :     }
<span class="lineNum">   22024 </span>            :   else if (token-&gt;type == CPP_OPEN_BRACE)
<span class="lineNum">   22025 </span>            :     {
<span class="lineNum">   22026 </span>            :       cp_lexer_set_source_position (parser-&gt;lexer);
<span class="lineNum">   22027 </span>            :       maybe_warn_cpp0x (CPP0X_INITIALIZER_LISTS);
<span class="lineNum">   22028 </span><span class="lineCov">    2399041 :       init = cp_parser_braced_list (parser, non_constant_p);</span>
<span class="lineNum">   22029 </span>            :       CONSTRUCTOR_IS_DIRECT_INIT (init) = 1;
<span class="lineNum">   22030 </span>            :     }
<span class="lineNum">   22031 </span><span class="lineCov">    2399041 :   else</span>
<span class="lineNum">   22032 </span><span class="lineCov">    2399041 :     {</span>
<span class="lineNum">   22033 </span>            :       /* Anything else is an error.  */
<span class="lineNum">   22034 </span>            :       cp_parser_error (parser, &quot;expected initializer&quot;);
<span class="lineNum">   22035 </span><span class="lineCov">    4798082 :       init = error_mark_node;</span>
<span class="lineNum">   22036 </span>            :     }
<span class="lineNum">   22037 </span>            : 
<span class="lineNum">   22038 </span>            :   if (!subexpression_p &amp;&amp; check_for_bare_parameter_packs (init))
<span class="lineNum">   22039 </span><span class="lineCov">    2399041 :     init = error_mark_node;</span>
<span class="lineNum">   22040 </span>            : 
<span class="lineNum">   22041 </span><span class="lineCov">    2399041 :   return init;</span>
<span class="lineNum">   22042 </span>            : }
<span class="lineNum">   22043 </span><span class="lineCov">    2399041 : </span>
<span class="lineNum">   22044 </span>            : /* Parse an initializer-clause.
<span class="lineNum">   22045 </span>            : 
<span class="lineNum">   22046 </span><span class="lineCov">    2257829 :    initializer-clause:</span>
<span class="lineNum">   22047 </span>            :      assignment-expression
<span class="lineNum">   22048 </span><span class="lineCov">    2257829 :      braced-init-list</span>
<span class="lineNum">   22049 </span>            : 
<span class="lineNum">   22050 </span><span class="lineCov">     141212 :    Returns an expression representing the initializer.</span>
<span class="lineNum">   22051 </span>            : 
<span class="lineNum">   22052 </span><span class="lineCov">     127776 :    If the `assignment-expression' production is used the value</span>
<span class="lineNum">   22053 </span><span class="lineCov">     127776 :    returned is simply a representation for the expression.</span>
<span class="lineNum">   22054 </span>            : 
<span class="lineNum">   22055 </span>            :    Otherwise, calls cp_parser_braced_list.  */
<a name="22056"><span class="lineNum">   22056 </span>            : </a>
<span class="lineNum">   22057 </span><span class="lineCov">     127776 : static cp_expr</span>
<span class="lineNum">   22058 </span><span class="lineCov">         13 : cp_parser_initializer_clause (cp_parser* parser, bool* non_constant_p)</span>
<span class="lineNum">   22059 </span><span class="lineCov">     127763 : {</span>
<span class="lineNum">   22060 </span><span class="lineCov">     127763 :   cp_expr initializer;</span>
<span class="lineNum">   22061 </span>            : 
<span class="lineNum">   22062 </span><span class="lineCov">      13436 :   /* Assume the expression is constant.  */</span>
<span class="lineNum">   22063 </span>            :   *non_constant_p = false;
<span class="lineNum">   22064 </span><span class="lineCov">      26872 : </span>
<span class="lineNum">   22065 </span><span class="lineCov">      13436 :   /* If it is not a `{', then we are looking at an</span>
<span class="lineNum">   22066 </span><span class="lineCov">      13436 :      assignment-expression.  */</span>
<span class="lineNum">   22067 </span><span class="lineCov">      13436 :   if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_OPEN_BRACE))</span>
<span class="lineNum">   22068 </span>            :     {
<span class="lineNum">   22069 </span>            :       initializer
<span class="lineNum">   22070 </span>            :         = cp_parser_constant_expression (parser,
<span class="lineNum">   22071 </span>            :                                         /*allow_non_constant_p=*/true,
<span class="lineNum">   22072 </span><span class="lineNoCov">          0 :                                         non_constant_p);</span>
<span class="lineNum">   22073 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   22074 </span>            :   else
<span class="lineNum">   22075 </span>            :     initializer = cp_parser_braced_list (parser, non_constant_p);
<span class="lineNum">   22076 </span><span class="lineCov">    2399024 : </span>
<span class="lineNum">   22077 </span><span class="lineCov">         10 :   return initializer;</span>
<span class="lineNum">   22078 </span>            : }
<span class="lineNum">   22079 </span>            : 
<span class="lineNum">   22080 </span>            : /* Parse a brace-enclosed initializer list.
<span class="lineNum">   22081 </span>            : 
<span class="lineNum">   22082 </span>            :    braced-init-list:
<span class="lineNum">   22083 </span>            :      { initializer-list , [opt] }
<span class="lineNum">   22084 </span>            :      { designated-initializer-list , [opt] }
<span class="lineNum">   22085 </span>            :      { }
<span class="lineNum">   22086 </span>            : 
<span class="lineNum">   22087 </span>            :    Returns a CONSTRUCTOR.  The CONSTRUCTOR_ELTS will be
<span class="lineNum">   22088 </span>            :    the elements of the initializer-list (or NULL, if the last
<span class="lineNum">   22089 </span>            :    production is used).  The TREE_TYPE for the CONSTRUCTOR will be
<span class="lineNum">   22090 </span>            :    NULL_TREE.  There is no way to detect whether or not the optional
<span class="lineNum">   22091 </span>            :    trailing `,' was provided.  NON_CONSTANT_P is as for
<span class="lineNum">   22092 </span>            :    cp_parser_initializer.  */     
<a name="22093"><span class="lineNum">   22093 </span>            : </a>
<span class="lineNum">   22094 </span>            : static cp_expr
<span class="lineNum">   22095 </span>            : cp_parser_braced_list (cp_parser* parser, bool* non_constant_p)
<span class="lineNum">   22096 </span><span class="lineCov">    5257268 : {</span>
<span class="lineNum">   22097 </span>            :   tree initializer;
<span class="lineNum">   22098 </span><span class="lineCov">    5257268 :   location_t start_loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;</span>
<span class="lineNum">   22099 </span>            : 
<span class="lineNum">   22100 </span>            :   /* Consume the `{' token.  */
<span class="lineNum">   22101 </span><span class="lineCov">    5257268 :   matching_braces braces;</span>
<span class="lineNum">   22102 </span>            :   braces.require_open (parser);
<span class="lineNum">   22103 </span>            :   /* Create a CONSTRUCTOR to represent the braced-initializer.  */
<span class="lineNum">   22104 </span>            :   initializer = make_node (CONSTRUCTOR);
<span class="lineNum">   22105 </span><span class="lineCov">    5257268 :   /* If it's not a `}', then there is a non-trivial initializer.  */</span>
<span class="lineNum">   22106 </span>            :   if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_CLOSE_BRACE))
<span class="lineNum">   22107 </span><span class="lineCov">    5183341 :     {</span>
<span class="lineNum">   22108 </span><span class="lineCov">    5183337 :       /* Parse the initializer list.  */</span>
<span class="lineNum">   22109 </span>            :       CONSTRUCTOR_ELTS (initializer)
<span class="lineNum">   22110 </span><span class="lineCov">    5183341 :         = cp_parser_initializer_list (parser, non_constant_p);</span>
<span class="lineNum">   22111 </span>            :       /* A trailing `,' token is allowed.  */
<span class="lineNum">   22112 </span>            :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_COMMA))
<span class="lineNum">   22113 </span><span class="lineCov">      73927 :         cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   22114 </span>            :     }
<span class="lineNum">   22115 </span><span class="lineCov">    5257264 :   else</span>
<span class="lineNum">   22116 </span>            :     *non_constant_p = false;
<span class="lineNum">   22117 </span>            :   /* Now, there should be a trailing `}'.  */
<span class="lineNum">   22118 </span>            :   location_t finish_loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">   22119 </span>            :   braces.require_close (parser);
<span class="lineNum">   22120 </span>            :   TREE_TYPE (initializer) = init_list_type_node;
<span class="lineNum">   22121 </span>            : 
<span class="lineNum">   22122 </span>            :   cp_expr result (initializer);
<span class="lineNum">   22123 </span>            :   /* Build a location of the form:
<span class="lineNum">   22124 </span>            :        { ... }
<span class="lineNum">   22125 </span>            :        ^~~~~~~
<span class="lineNum">   22126 </span>            :      with caret==start at the open brace, finish at the close brace.  */
<span class="lineNum">   22127 </span>            :   location_t combined_loc = make_location (start_loc, start_loc, finish_loc);
<span class="lineNum">   22128 </span>            :   result.set_location (combined_loc);
<span class="lineNum">   22129 </span>            :   return result;
<span class="lineNum">   22130 </span>            : }
<span class="lineNum">   22131 </span>            : 
<span class="lineNum">   22132 </span>            : /* Consume tokens up to, and including, the next non-nested closing `]'.
<span class="lineNum">   22133 </span><span class="lineCov">     182741 :    Returns true iff we found a closing `]'.  */</span>
<a name="22134"><span class="lineNum">   22134 </span>            : </a>
<span class="lineNum">   22135 </span><span class="lineCov">     182741 : static bool</span>
<span class="lineNum">   22136 </span><span class="lineCov">     365482 : cp_parser_skip_to_closing_square_bracket (cp_parser *parser)</span>
<span class="lineNum">   22137 </span>            : {
<span class="lineNum">   22138 </span>            :   unsigned square_depth = 0;
<span class="lineNum">   22139 </span><span class="lineCov">     365482 : </span>
<span class="lineNum">   22140 </span><span class="lineCov">     182741 :   while (true)</span>
<span class="lineNum">   22141 </span>            :     {
<span class="lineNum">   22142 </span><span class="lineCov">     182741 :       cp_token * token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   22143 </span>            : 
<span class="lineNum">   22144 </span><span class="lineCov">     182741 :       switch (token-&gt;type)</span>
<span class="lineNum">   22145 </span>            :         {
<span class="lineNum">   22146 </span>            :         case CPP_EOF:
<span class="lineNum">   22147 </span><span class="lineCov">     133439 :         case CPP_PRAGMA_EOL:</span>
<span class="lineNum">   22148 </span><span class="lineCov">     133439 :           /* If we've run out of tokens, then there is no closing `]'.  */</span>
<span class="lineNum">   22149 </span>            :           return false;
<span class="lineNum">   22150 </span><span class="lineCov">     133439 : </span>
<span class="lineNum">   22151 </span><span class="lineCov">       3481 :         case CPP_OPEN_SQUARE:</span>
<span class="lineNum">   22152 </span>            :           ++square_depth;
<span class="lineNum">   22153 </span>            :           break;
<span class="lineNum">   22154 </span><span class="lineCov">      49302 : </span>
<span class="lineNum">   22155 </span>            :         case CPP_CLOSE_SQUARE:
<span class="lineNum">   22156 </span><span class="lineCov">     365482 :           if (!square_depth--)</span>
<span class="lineNum">   22157 </span><span class="lineCov">     182741 :             {</span>
<span class="lineNum">   22158 </span><span class="lineCov">     182741 :               cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   22159 </span>            :               return true;
<span class="lineNum">   22160 </span><span class="lineCov">     182741 :             }</span>
<span class="lineNum">   22161 </span>            :           break;
<span class="lineNum">   22162 </span>            : 
<span class="lineNum">   22163 </span>            :         default:
<span class="lineNum">   22164 </span>            :           break;
<span class="lineNum">   22165 </span><span class="lineCov">     182741 :         }</span>
<span class="lineNum">   22166 </span><span class="lineCov">     182741 : </span>
<span class="lineNum">   22167 </span><span class="lineCov">     182741 :       /* Consume the token.  */</span>
<span class="lineNum">   22168 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   22169 </span>            :     }
<span class="lineNum">   22170 </span>            : }
<span class="lineNum">   22171 </span>            : 
<span class="lineNum">   22172 </span>            : /* Return true if we are looking at an array-designator, false otherwise.  */
<a name="22173"><span class="lineNum">   22173 </span>            : </a>
<span class="lineNum">   22174 </span><span class="lineCov">        201 : static bool</span>
<span class="lineNum">   22175 </span>            : cp_parser_array_designator_p (cp_parser *parser)
<span class="lineNum">   22176 </span><span class="lineCov">        201 : {</span>
<span class="lineNum">   22177 </span>            :   /* Consume the `['.  */
<span class="lineNum">   22178 </span><span class="lineCov">        416 :   cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   22179 </span>            : 
<span class="lineNum">   22180 </span><span class="lineCov">        832 :   cp_lexer_save_tokens (parser-&gt;lexer);</span>
<span class="lineNum">   22181 </span>            : 
<span class="lineNum">   22182 </span><span class="lineCov">        416 :   /* Skip tokens until the next token is a closing square bracket.</span>
<span class="lineNum">   22183 </span>            :      If we find the closing `]', and the next token is a `=', then
<span class="lineNum">   22184 </span>            :      we are looking at an array designator.  */
<span class="lineNum">   22185 </span>            :   bool array_designator_p
<span class="lineNum">   22186 </span>            :     = (cp_parser_skip_to_closing_square_bracket (parser)
<span class="lineNum">   22187 </span>            :        &amp;&amp; cp_lexer_next_token_is (parser-&gt;lexer, CPP_EQ));
<span class="lineNum">   22188 </span>            :   
<span class="lineNum">   22189 </span><span class="lineNoCov">          0 :   /* Roll back the tokens we skipped.  */</span>
<span class="lineNum">   22190 </span><span class="lineNoCov">          0 :   cp_lexer_rollback_tokens (parser-&gt;lexer);</span>
<span class="lineNum">   22191 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   22192 </span>            :   return array_designator_p;
<span class="lineNum">   22193 </span><span class="lineCov">        201 : }</span>
<span class="lineNum">   22194 </span><span class="lineCov">        201 : </span>
<span class="lineNum">   22195 </span>            : /* Parse an initializer-list.
<span class="lineNum">   22196 </span><span class="lineCov">        201 : </span>
<span class="lineNum">   22197 </span><span class="lineCov">        201 :    initializer-list:</span>
<span class="lineNum">   22198 </span>            :      initializer-clause ... [opt]
<span class="lineNum">   22199 </span>            :      initializer-list , initializer-clause ... [opt]
<span class="lineNum">   22200 </span>            : 
<span class="lineNum">   22201 </span>            :    C++2A Extension:
<span class="lineNum">   22202 </span>            : 
<span class="lineNum">   22203 </span>            :    designated-initializer-list:
<span class="lineNum">   22204 </span>            :      designated-initializer-clause
<span class="lineNum">   22205 </span>            :      designated-initializer-list , designated-initializer-clause
<span class="lineNum">   22206 </span><span class="lineCov">        215 : </span>
<span class="lineNum">   22207 </span><span class="lineCov">        215 :    designated-initializer-clause:</span>
<span class="lineNum">   22208 </span>            :      designator brace-or-equal-initializer
<span class="lineNum">   22209 </span>            : 
<span class="lineNum">   22210 </span>            :    designator:
<span class="lineNum">   22211 </span>            :      . identifier
<span class="lineNum">   22212 </span>            : 
<span class="lineNum">   22213 </span><span class="lineCov">        201 :    GNU Extension:</span>
<span class="lineNum">   22214 </span>            : 
<span class="lineNum">   22215 </span>            :    initializer-list:
<span class="lineNum">   22216 </span><span class="lineCov">        201 :      designation initializer-clause ...[opt]</span>
<span class="lineNum">   22217 </span>            :      initializer-list , designation initializer-clause ...[opt]
<span class="lineNum">   22218 </span><span class="lineCov">        201 : </span>
<span class="lineNum">   22219 </span>            :    designation:
<span class="lineNum">   22220 </span>            :      . identifier =
<span class="lineNum">   22221 </span>            :      identifier :
<span class="lineNum">   22222 </span>            :      [ constant-expression ] =
<span class="lineNum">   22223 </span><span class="lineCov">        201 : </span>
<span class="lineNum">   22224 </span><span class="lineCov">        201 :    Returns a vec of constructor_elt.  The VALUE of each elt is an expression</span>
<span class="lineNum">   22225 </span><span class="lineCov">        201 :    for the initializer.  If the INDEX of the elt is non-NULL, it is the</span>
<span class="lineNum">   22226 </span>            :    IDENTIFIER_NODE naming the field to initialize.  NON_CONSTANT_P is
<span class="lineNum">   22227 </span>            :    as for cp_parser_initializer.  */
<a name="22228"><span class="lineNum">   22228 </span><span class="lineCov">        201 : </span></a>
<span class="lineNum">   22229 </span>            : static vec&lt;constructor_elt, va_gc&gt; *
<span class="lineNum">   22230 </span><span class="lineCov">        201 : cp_parser_initializer_list (cp_parser* parser, bool* non_constant_p)</span>
<span class="lineNum">   22231 </span>            : {
<span class="lineNum">   22232 </span>            :   vec&lt;constructor_elt, va_gc&gt; *v = NULL;
<span class="lineNum">   22233 </span>            :   bool first_p = true;
<span class="lineNum">   22234 </span>            :   tree first_designator = NULL_TREE;
<span class="lineNum">   22235 </span>            : 
<span class="lineNum">   22236 </span>            :   /* Assume all of the expressions are constant.  */
<span class="lineNum">   22237 </span>            :   *non_constant_p = false;
<span class="lineNum">   22238 </span>            : 
<span class="lineNum">   22239 </span>            :   /* Parse the rest of the list.  */
<span class="lineNum">   22240 </span>            :   while (true)
<span class="lineNum">   22241 </span>            :     {
<span class="lineNum">   22242 </span>            :       cp_token *token;
<span class="lineNum">   22243 </span>            :       tree designator;
<span class="lineNum">   22244 </span>            :       tree initializer;
<span class="lineNum">   22245 </span>            :       bool clause_non_constant_p;
<span class="lineNum">   22246 </span>            :       location_t loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">   22247 </span>            : 
<span class="lineNum">   22248 </span>            :       /* Handle the C++2A syntax, '. id ='.  */
<span class="lineNum">   22249 </span>            :       if ((cxx_dialect &gt;= cxx2a
<span class="lineNum">   22250 </span>            :            || cp_parser_allow_gnu_extensions_p (parser))
<span class="lineNum">   22251 </span>            :           &amp;&amp; cp_lexer_next_token_is (parser-&gt;lexer, CPP_DOT)
<span class="lineNum">   22252 </span>            :           &amp;&amp; cp_lexer_peek_nth_token (parser-&gt;lexer, 2)-&gt;type == CPP_NAME
<span class="lineNum">   22253 </span>            :           &amp;&amp; (cp_lexer_peek_nth_token (parser-&gt;lexer, 3)-&gt;type == CPP_EQ
<span class="lineNum">   22254 </span>            :               || (cp_lexer_peek_nth_token (parser-&gt;lexer, 3)-&gt;type
<span class="lineNum">   22255 </span>            :                   == CPP_OPEN_BRACE)))
<span class="lineNum">   22256 </span>            :         {
<span class="lineNum">   22257 </span>            :           if (cxx_dialect &lt; cxx2a)
<span class="lineNum">   22258 </span>            :             pedwarn (loc, OPT_Wpedantic,
<span class="lineNum">   22259 </span>            :                      &quot;C++ designated initializers only available with &quot;
<span class="lineNum">   22260 </span>            :                      &quot;-std=c++2a or -std=gnu++2a&quot;);
<span class="lineNum">   22261 </span>            :           /* Consume the `.'.  */
<span class="lineNum">   22262 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   22263 </span>            :           /* Consume the identifier.  */
<span class="lineNum">   22264 </span>            :           designator = cp_lexer_consume_token (parser-&gt;lexer)-&gt;u.value;
<span class="lineNum">   22265 </span>            :           if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_EQ))
<span class="lineNum">   22266 </span>            :             /* Consume the `='.  */
<span class="lineNum">   22267 </span>            :             cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   22268 </span><span class="lineCov">     133439 :         }</span>
<span class="lineNum">   22269 </span>            :       /* Also, if the next token is an identifier and the following one is a
<span class="lineNum">   22270 </span><span class="lineCov">     133439 :          colon, we are looking at the GNU designated-initializer</span>
<span class="lineNum">   22271 </span><span class="lineCov">     133439 :          syntax.  */</span>
<span class="lineNum">   22272 </span><span class="lineCov">     133439 :       else if (cp_parser_allow_gnu_extensions_p (parser)</span>
<span class="lineNum">   22273 </span>            :                &amp;&amp; cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME)
<span class="lineNum">   22274 </span>            :                &amp;&amp; (cp_lexer_peek_nth_token (parser-&gt;lexer, 2)-&gt;type
<span class="lineNum">   22275 </span><span class="lineCov">     133439 :                    == CPP_COLON))</span>
<span class="lineNum">   22276 </span>            :         {
<span class="lineNum">   22277 </span>            :           /* Warn the user that they are using an extension.  */
<span class="lineNum">   22278 </span><span class="lineCov">     551823 :           pedwarn (loc, OPT_Wpedantic,</span>
<span class="lineNum">   22279 </span>            :                    &quot;ISO C++ does not allow GNU designated initializers&quot;);
<span class="lineNum">   22280 </span><span class="lineCov">     551823 :           /* Consume the identifier.  */</span>
<span class="lineNum">   22281 </span><span class="lineCov">     551823 :           designator = cp_lexer_consume_token (parser-&gt;lexer)-&gt;u.value;</span>
<span class="lineNum">   22282 </span><span class="lineCov">     551823 :           /* Consume the `:'.  */</span>
<span class="lineNum">   22283 </span><span class="lineCov">     551823 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   22284 </span><span class="lineCov">    1103646 :         }</span>
<span class="lineNum">   22285 </span>            :       /* Also handle C99 array designators, '[ const ] ='.  */
<span class="lineNum">   22286 </span>            :       else if (cp_parser_allow_gnu_extensions_p (parser)
<span class="lineNum">   22287 </span><span class="lineCov">     551823 :                &amp;&amp; !c_dialect_objc ()</span>
<span class="lineNum">   22288 </span><span class="lineCov">    1089124 :                &amp;&amp; cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_SQUARE))</span>
<span class="lineNum">   22289 </span><span class="lineCov">     551823 :         {</span>
<span class="lineNum">   22290 </span><span class="lineCov">        199 :           /* In C++11, [ could start a lambda-introducer.  */</span>
<span class="lineNum">   22291 </span><span class="lineCov">     552022 :           bool non_const = false;</span>
<span class="lineNum">   22292 </span><span class="lineCov">          3 : </span>
<span class="lineNum">   22293 </span>            :           cp_parser_parse_tentatively (parser);
<span class="lineNum">   22294 </span>            : 
<span class="lineNum">   22295 </span><span class="lineCov">        199 :           if (!cp_parser_array_designator_p (parser))</span>
<span class="lineNum">   22296 </span><span class="lineCov">        195 :             {</span>
<span class="lineNum">   22297 </span>            :               cp_parser_simulate_error (parser);
<span class="lineNum">   22298 </span>            :               designator = NULL_TREE;
<span class="lineNum">   22299 </span>            :             }
<span class="lineNum">   22300 </span><span class="lineCov">        199 :           else</span>
<span class="lineNum">   22301 </span>            :             {
<span class="lineNum">   22302 </span><span class="lineCov">        199 :               designator = cp_parser_constant_expression (parser, true,</span>
<span class="lineNum">   22303 </span><span class="lineCov">        199 :                                                           &amp;non_const);</span>
<span class="lineNum">   22304 </span>            :               cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);
<span class="lineNum">   22305 </span><span class="lineCov">        196 :               cp_parser_require (parser, CPP_EQ, RT_EQ);</span>
<span class="lineNum">   22306 </span>            :             }
<span class="lineNum">   22307 </span>            : 
<span class="lineNum">   22308 </span>            :           if (!cp_parser_parse_definitely (parser))
<span class="lineNum">   22309 </span>            :             designator = NULL_TREE;
<span class="lineNum">   22310 </span><span class="lineCov">    1103248 :           else if (non_const</span>
<span class="lineNum">   22311 </span><span class="lineCov">     551624 :                    &amp;&amp; (!require_potential_rvalue_constant_expression</span>
<span class="lineNum">   22312 </span><span class="lineCov">     139748 :                        (designator)))</span>
<span class="lineNum">   22313 </span>            :             designator = NULL_TREE;
<span class="lineNum">   22314 </span>            :           if (designator)
<span class="lineNum">   22315 </span>            :             /* Warn the user that they are using an extension.  */
<span class="lineNum">   22316 </span><span class="lineCov">         98 :             pedwarn (loc, OPT_Wpedantic,</span>
<span class="lineNum">   22317 </span>            :                      &quot;ISO C++ does not allow C99 designated initializers&quot;);
<span class="lineNum">   22318 </span>            :         }
<span class="lineNum">   22319 </span><span class="lineCov">         98 :       else</span>
<span class="lineNum">   22320 </span>            :         designator = NULL_TREE;
<span class="lineNum">   22321 </span><span class="lineCov">         98 : </span>
<span class="lineNum">   22322 </span>            :       if (first_p)
<span class="lineNum">   22323 </span>            :         {
<span class="lineNum">   22324 </span><span class="lineCov">    1103052 :           first_designator = designator;</span>
<span class="lineNum">   22325 </span><span class="lineCov">     551526 :           first_p = false;</span>
<span class="lineNum">   22326 </span><span class="lineCov">     551526 :         }</span>
<span class="lineNum">   22327 </span>            :       else if (cxx_dialect &gt;= cxx2a
<span class="lineNum">   22328 </span>            :                &amp;&amp; first_designator != error_mark_node
<span class="lineNum">   22329 </span><span class="lineCov">        201 :                &amp;&amp; (!first_designator != !designator))</span>
<span class="lineNum">   22330 </span>            :         {
<span class="lineNum">   22331 </span><span class="lineCov">        201 :           error_at (loc, &quot;either all initializer clauses should be designated &quot;</span>
<span class="lineNum">   22332 </span>            :                          &quot;or none of them should be&quot;);
<span class="lineNum">   22333 </span><span class="lineCov">        201 :           first_designator = error_mark_node;</span>
<span class="lineNum">   22334 </span>            :         }
<span class="lineNum">   22335 </span><span class="lineCov">        135 :       else if (cxx_dialect &lt; cxx2a &amp;&amp; !first_designator)</span>
<span class="lineNum">   22336 </span>            :         first_designator = designator;
<span class="lineNum">   22337 </span>            : 
<span class="lineNum">   22338 </span>            :       /* Parse the initializer.  */
<span class="lineNum">   22339 </span>            :       initializer = cp_parser_initializer_clause (parser,
<span class="lineNum">   22340 </span><span class="lineCov">        132 :                                                   &amp;clause_non_constant_p);</span>
<span class="lineNum">   22341 </span><span class="lineCov">         66 :       /* If any clause is non-constant, so is the entire initializer.  */</span>
<span class="lineNum">   22342 </span><span class="lineCov">         66 :       if (clause_non_constant_p)</span>
<span class="lineNum">   22343 </span><span class="lineCov">         66 :         *non_constant_p = true;</span>
<span class="lineNum">   22344 </span>            : 
<span class="lineNum">   22345 </span>            :       /* If we have an ellipsis, this is an initializer pack
<span class="lineNum">   22346 </span><span class="lineCov">        201 :          expansion.  */</span>
<span class="lineNum">   22347 </span>            :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_ELLIPSIS))
<span class="lineNum">   22348 </span><span class="lineCov">         66 :         {</span>
<span class="lineNum">   22349 </span><span class="lineCov">         70 :           location_t loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;</span>
<span class="lineNum">   22350 </span><span class="lineCov">          4 : </span>
<span class="lineNum">   22351 </span>            :           /* Consume the `...'.  */
<span class="lineNum">   22352 </span><span class="lineCov">         62 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   22353 </span>            : 
<span class="lineNum">   22354 </span><span class="lineCov">         62 :           if (designator &amp;&amp; cxx_dialect &gt;= cxx2a)</span>
<span class="lineNum">   22355 </span>            :             error_at (loc,
<span class="lineNum">   22356 </span>            :                       &quot;%&lt;...%&gt; not allowed in designated initializer list&quot;);
<span class="lineNum">   22357 </span>            : 
<span class="lineNum">   22358 </span>            :           /* Turn the initializer into an initializer expansion.  */
<span class="lineNum">   22359 </span>            :           initializer = make_pack_expansion (initializer);
<span class="lineNum">   22360 </span><span class="lineCov">     551823 :         }</span>
<span class="lineNum">   22361 </span>            : 
<span class="lineNum">   22362 </span>            :       /* Add it to the vector.  */
<span class="lineNum">   22363 </span>            :       CONSTRUCTOR_APPEND_ELT (v, designator, initializer);
<span class="lineNum">   22364 </span>            : 
<span class="lineNum">   22365 </span><span class="lineCov">     418384 :       /* If the next token is not a comma, we have reached the end of</span>
<span class="lineNum">   22366 </span><span class="lineCov">       4620 :          the list.  */</span>
<span class="lineNum">   22367 </span><span class="lineCov">       4620 :       if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_COMMA))</span>
<span class="lineNum">   22368 </span>            :         break;
<span class="lineNum">   22369 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   22370 </span>            :       /* Peek at the next token.  */
<span class="lineNum">   22371 </span><span class="lineNoCov">          0 :       token = cp_lexer_peek_nth_token (parser-&gt;lexer, 2);</span>
<span class="lineNum">   22372 </span>            :       /* If the next token is a `}', then we're still done.  An
<span class="lineNum">   22373 </span><span class="lineCov">     418384 :          initializer-clause can have a trailing `,' after the</span>
<span class="lineNum">   22374 </span><span class="lineCov">     413668 :          initializer-list and before the closing `}'.  */</span>
<span class="lineNum">   22375 </span>            :       if (token-&gt;type == CPP_CLOSE_BRACE)
<span class="lineNum">   22376 </span>            :         break;
<span class="lineNum">   22377 </span><span class="lineCov">    1103646 : </span>
<span class="lineNum">   22378 </span><span class="lineCov">     551823 :       /* Consume the `,' token.  */</span>
<span class="lineNum">   22379 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   22380 </span><span class="lineCov">     551823 :     }</span>
<span class="lineNum">   22381 </span><span class="lineCov">      12230 : </span>
<span class="lineNum">   22382 </span>            :   /* The same identifier shall not appear in multiple designators
<span class="lineNum">   22383 </span>            :      of a designated-initializer-list.  */
<span class="lineNum">   22384 </span>            :   if (first_designator)
<span class="lineNum">   22385 </span><span class="lineCov">     551823 :     {</span>
<span class="lineNum">   22386 </span>            :       unsigned int i;
<span class="lineNum">   22387 </span><span class="lineCov">       2212 :       tree designator, val;</span>
<span class="lineNum">   22388 </span>            :       FOR_EACH_CONSTRUCTOR_ELT (v, i, designator, val)
<span class="lineNum">   22389 </span>            :         if (designator &amp;&amp; TREE_CODE (designator) == IDENTIFIER_NODE)
<span class="lineNum">   22390 </span><span class="lineCov">       1106 :           {</span>
<span class="lineNum">   22391 </span>            :             if (IDENTIFIER_MARKED (designator))
<span class="lineNum">   22392 </span><span class="lineCov">       1106 :               {</span>
<span class="lineNum">   22393 </span><span class="lineNoCov">          0 :                 error_at (cp_expr_loc_or_loc (val, input_location),</span>
<span class="lineNum">   22394 </span>            :                           &quot;%&lt;.%s%&gt; designator used multiple times in &quot;
<span class="lineNum">   22395 </span>            :                           &quot;the same initializer list&quot;,
<span class="lineNum">   22396 </span>            :                           IDENTIFIER_POINTER (designator));
<span class="lineNum">   22397 </span><span class="lineCov">       1106 :                 (*v)[i].index = error_mark_node;</span>
<span class="lineNum">   22398 </span>            :               }
<span class="lineNum">   22399 </span>            :             else
<span class="lineNum">   22400 </span>            :               IDENTIFIER_MARKED (designator) = 1;
<span class="lineNum">   22401 </span><span class="lineCov">     551823 :           }</span>
<span class="lineNum">   22402 </span>            :       FOR_EACH_CONSTRUCTOR_ELT (v, i, designator, val)
<span class="lineNum">   22403 </span>            :         if (designator &amp;&amp; TREE_CODE (designator) == IDENTIFIER_NODE)
<span class="lineNum">   22404 </span>            :           IDENTIFIER_MARKED (designator) = 0;
<span class="lineNum">   22405 </span><span class="lineCov">     551823 :     }</span>
<span class="lineNum">   22406 </span>            : 
<span class="lineNum">   22407 </span>            :   return v;
<span class="lineNum">   22408 </span>            : }
<span class="lineNum">   22409 </span><span class="lineCov">     421865 : </span>
<span class="lineNum">   22410 </span>            : /* Classes [gram.class] */
<span class="lineNum">   22411 </span>            : 
<span class="lineNum">   22412 </span>            : /* Parse a class-name.
<span class="lineNum">   22413 </span><span class="lineCov">     421865 : </span>
<span class="lineNum">   22414 </span>            :    class-name:
<span class="lineNum">   22415 </span>            :      identifier
<span class="lineNum">   22416 </span>            :      template-id
<span class="lineNum">   22417 </span><span class="lineCov">     418384 : </span>
<span class="lineNum">   22418 </span><span class="lineCov">     418384 :    TYPENAME_KEYWORD_P is true iff the `typename' keyword has been used</span>
<span class="lineNum">   22419 </span>            :    to indicate that names looked up in dependent types should be
<span class="lineNum">   22420 </span>            :    assumed to be types.  TEMPLATE_KEYWORD_P is true iff the `template'
<span class="lineNum">   22421 </span>            :    keyword has been used to indicate that the name that appears next
<span class="lineNum">   22422 </span><span class="lineCov">     133439 :    is a template.  TAG_TYPE indicates the explicit tag given before</span>
<span class="lineNum">   22423 </span>            :    the type name, if any.  If CHECK_DEPENDENCY_P is FALSE, names are
<span class="lineNum">   22424 </span>            :    looked up in dependent scopes.  If CLASS_HEAD_P is TRUE, this class
<span class="lineNum">   22425 </span>            :    is the class being defined in a class-head.  If ENUM_OK is TRUE,
<span class="lineNum">   22426 </span><span class="lineCov">       1336 :    enum-names are also accepted.</span>
<span class="lineNum">   22427 </span><span class="lineCov">        389 : </span>
<span class="lineNum">   22428 </span>            :    Returns the TYPE_DECL representing the class.  */
<a name="22429"><span class="lineNum">   22429 </span><span class="lineCov">        891 : </span></a>
<span class="lineNum">   22430 </span>            : static tree
<span class="lineNum">   22431 </span><span class="lineCov">          5 : cp_parser_class_name (cp_parser *parser,</span>
<span class="lineNum">   22432 </span>            :                       bool typename_keyword_p,
<span class="lineNum">   22433 </span>            :                       bool template_keyword_p,
<span class="lineNum">   22434 </span><span class="lineCov">         10 :                       enum tag_types tag_type,</span>
<span class="lineNum">   22435 </span><span class="lineCov">          5 :                       bool check_dependency_p,</span>
<span class="lineNum">   22436 </span>            :                       bool class_head_p,
<span class="lineNum">   22437 </span>            :                       bool is_declaration,
<span class="lineNum">   22438 </span><span class="lineCov">        876 :                       bool enum_ok)</span>
<span class="lineNum">   22439 </span>            : {
<span class="lineNum">   22440 </span><span class="lineCov">       1336 :   tree decl;</span>
<span class="lineNum">   22441 </span><span class="lineCov">        389 :   tree scope;</span>
<span class="lineNum">   22442 </span><span class="lineCov">        876 :   bool typename_p;</span>
<span class="lineNum">   22443 </span>            :   cp_token *token;
<span class="lineNum">   22444 </span>            :   tree identifier = NULL_TREE;
<span class="lineNum">   22445 </span><span class="lineCov">     133439 : </span>
<span class="lineNum">   22446 </span>            :   /* All class-names start with an identifier.  */
<span class="lineNum">   22447 </span>            :   token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   22448 </span>            :   if (token-&gt;type != CPP_NAME &amp;&amp; token-&gt;type != CPP_TEMPLATE_ID)
<span class="lineNum">   22449 </span>            :     {
<span class="lineNum">   22450 </span>            :       cp_parser_error (parser, &quot;expected class-name&quot;);
<span class="lineNum">   22451 </span>            :       return error_mark_node;
<span class="lineNum">   22452 </span>            :     }
<span class="lineNum">   22453 </span>            : 
<span class="lineNum">   22454 </span>            :   /* PARSER-&gt;SCOPE can be cleared when parsing the template-arguments
<span class="lineNum">   22455 </span>            :      to a template-id, so we save it here.  */
<span class="lineNum">   22456 </span>            :   scope = parser-&gt;scope;
<span class="lineNum">   22457 </span>            :   if (scope == error_mark_node)
<span class="lineNum">   22458 </span>            :     return error_mark_node;
<span class="lineNum">   22459 </span>            : 
<span class="lineNum">   22460 </span>            :   /* Any name names a type if we're following the `typename' keyword
<span class="lineNum">   22461 </span>            :      in a qualified name where the enclosing scope is type-dependent.  */
<span class="lineNum">   22462 </span>            :   typename_p = (typename_keyword_p &amp;&amp; scope &amp;&amp; TYPE_P (scope)
<span class="lineNum">   22463 </span>            :                 &amp;&amp; dependent_type_p (scope));
<span class="lineNum">   22464 </span>            :   /* Handle the common case (an identifier, but not a template-id)
<span class="lineNum">   22465 </span>            :      efficiently.  */
<span class="lineNum">   22466 </span>            :   if (token-&gt;type == CPP_NAME
<span class="lineNum">   22467 </span>            :       &amp;&amp; !cp_parser_nth_token_starts_template_argument_list_p (parser, 2))
<span class="lineNum">   22468 </span>            :     {
<span class="lineNum">   22469 </span><span class="lineCov">  128735105 :       cp_token *identifier_token;</span>
<span class="lineNum">   22470 </span>            :       bool ambiguous_p;
<span class="lineNum">   22471 </span>            : 
<span class="lineNum">   22472 </span>            :       /* Look for the identifier.  */
<span class="lineNum">   22473 </span>            :       identifier_token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   22474 </span>            :       ambiguous_p = identifier_token-&gt;error_reported;
<span class="lineNum">   22475 </span>            :       identifier = cp_parser_identifier (parser);
<span class="lineNum">   22476 </span>            :       /* If the next token isn't an identifier, we are certainly not
<span class="lineNum">   22477 </span>            :          looking at a class-name.  */
<span class="lineNum">   22478 </span><span class="lineCov">  128735105 :       if (identifier == error_mark_node)</span>
<span class="lineNum">   22479 </span><span class="lineCov">  128735105 :         decl = error_mark_node;</span>
<span class="lineNum">   22480 </span><span class="lineCov">  128735105 :       /* If we know this is a type-name, there's no need to look it</span>
<span class="lineNum">   22481 </span><span class="lineCov">  128735105 :          up.  */</span>
<span class="lineNum">   22482 </span><span class="lineCov">  128735105 :       else if (typename_p)</span>
<span class="lineNum">   22483 </span>            :         decl = identifier;
<span class="lineNum">   22484 </span>            :       else
<span class="lineNum">   22485 </span><span class="lineCov">  257470210 :         {</span>
<span class="lineNum">   22486 </span><span class="lineCov">  128735105 :           tree ambiguous_decls;</span>
<span class="lineNum">   22487 </span>            :           /* If we already know that this lookup is ambiguous, then
<span class="lineNum">   22488 </span><span class="lineCov">   33989225 :              we've already issued an error message; there's no reason</span>
<span class="lineNum">   22489 </span><span class="lineCov">   33989225 :              to check again.  */</span>
<span class="lineNum">   22490 </span>            :           if (ambiguous_p)
<span class="lineNum">   22491 </span>            :             {
<span class="lineNum">   22492 </span>            :               cp_parser_simulate_error (parser);
<span class="lineNum">   22493 </span>            :               return error_mark_node;
<span class="lineNum">   22494 </span><span class="lineCov">   94745880 :             }</span>
<span class="lineNum">   22495 </span><span class="lineCov">   94745880 :           /* If the next token is a `::', then the name must be a type</span>
<span class="lineNum">   22496 </span>            :              name.
<span class="lineNum">   22497 </span>            : 
<span class="lineNum">   22498 </span>            :              [basic.lookup.qual]
<span class="lineNum">   22499 </span>            : 
<span class="lineNum">   22500 </span><span class="lineCov">    3537442 :              During the lookup for a name preceding the :: scope</span>
<span class="lineNum">   22501 </span><span class="lineCov">   94933933 :              resolution operator, object, function, and enumerator</span>
<span class="lineNum">   22502 </span>            :              names are ignored.  */
<span class="lineNum">   22503 </span>            :           if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_SCOPE))
<span class="lineNum">   22504 </span><span class="lineCov">   94745846 :             tag_type = scope_type;</span>
<span class="lineNum">   22505 </span><span class="lineCov">   94745846 :           /* Look up the name.  */</span>
<span class="lineNum">   22506 </span>            :           decl = cp_parser_lookup_name (parser, identifier,
<span class="lineNum">   22507 </span><span class="lineCov">   77122126 :                                         tag_type,</span>
<span class="lineNum">   22508 </span><span class="lineCov">   77122126 :                                         /*is_template=*/false,</span>
<span class="lineNum">   22509 </span>            :                                         /*is_namespace=*/false,
<span class="lineNum">   22510 </span>            :                                         check_dependency_p,
<span class="lineNum">   22511 </span><span class="lineCov">  154244252 :                                         &amp;ambiguous_decls,</span>
<span class="lineNum">   22512 </span><span class="lineCov">   77122126 :                                         identifier_token-&gt;location);</span>
<span class="lineNum">   22513 </span><span class="lineCov">   77122126 :           if (ambiguous_decls)</span>
<span class="lineNum">   22514 </span>            :             {
<span class="lineNum">   22515 </span>            :               if (cp_parser_parsing_tentatively (parser))
<span class="lineNum">   22516 </span><span class="lineCov">   77122126 :                 cp_parser_simulate_error (parser);</span>
<span class="lineNum">   22517 </span>            :               return error_mark_node;
<span class="lineNum">   22518 </span>            :             }
<span class="lineNum">   22519 </span>            :         }
<span class="lineNum">   22520 </span><span class="lineCov">   77122126 :     }</span>
<span class="lineNum">   22521 </span>            :   else
<span class="lineNum">   22522 </span>            :     {
<span class="lineNum">   22523 </span>            :       /* Try a template-id.  */
<span class="lineNum">   22524 </span><span class="lineCov">   76984592 :       decl = cp_parser_template_id (parser, template_keyword_p,</span>
<span class="lineNum">   22525 </span>            :                                     check_dependency_p,
<span class="lineNum">   22526 </span>            :                                     tag_type,
<span class="lineNum">   22527 </span>            :                                     is_declaration);
<span class="lineNum">   22528 </span><span class="lineCov">   76984592 :       if (decl == error_mark_node)</span>
<span class="lineNum">   22529 </span>            :         return error_mark_node;
<span class="lineNum">   22530 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   22531 </span><span class="lineCov">         81 : </span>
<span class="lineNum">   22532 </span>            :   decl = cp_parser_maybe_treat_template_as_class (decl, class_head_p);
<span class="lineNum">   22533 </span>            : 
<span class="lineNum">   22534 </span>            :   /* If this is a typename, create a TYPENAME_TYPE.  */
<span class="lineNum">   22535 </span>            :   if (typename_p &amp;&amp; decl != error_mark_node)
<span class="lineNum">   22536 </span>            :     {
<span class="lineNum">   22537 </span>            :       decl = make_typename_type (scope, decl, typename_type,
<span class="lineNum">   22538 </span>            :                                  /*complain=*/tf_error);
<span class="lineNum">   22539 </span>            :       if (decl != error_mark_node)
<span class="lineNum">   22540 </span>            :         decl = TYPE_NAME (decl);
<span class="lineNum">   22541 </span><span class="lineCov">   76984592 :     }</span>
<span class="lineNum">   22542 </span><span class="lineCov">    5454377 : </span>
<span class="lineNum">   22543 </span>            :   decl = strip_using_decl (decl);
<span class="lineNum">   22544 </span><span class="lineCov">  153969184 : </span>
<span class="lineNum">   22545 </span>            :   /* Check to see that it is really the name of a class.  */
<span class="lineNum">   22546 </span>            :   if (TREE_CODE (decl) == TEMPLATE_ID_EXPR
<span class="lineNum">   22547 </span>            :       &amp;&amp; identifier_p (TREE_OPERAND (decl, 0))
<span class="lineNum">   22548 </span>            :       &amp;&amp; cp_lexer_next_token_is (parser-&gt;lexer, CPP_SCOPE))
<span class="lineNum">   22549 </span>            :     /* Situations like this:
<span class="lineNum">   22550 </span><span class="lineCov">   76984592 : </span>
<span class="lineNum">   22551 </span><span class="lineCov">   76984592 :          template &lt;typename T&gt; struct A {</span>
<span class="lineNum">   22552 </span>            :            typename T::template X&lt;int&gt;::I i;
<span class="lineNum">   22553 </span><span class="lineCov">         81 :          };</span>
<span class="lineNum">   22554 </span><span class="lineCov">         81 : </span>
<span class="lineNum">   22555 </span><span class="lineCov">         81 :        are problematic.  Is `T::template X&lt;int&gt;' a class-name?  The</span>
<span class="lineNum">   22556 </span>            :        standard does not seem to be definitive, but there is no other
<span class="lineNum">   22557 </span>            :        valid interpretation of the following `::'.  Therefore, those
<span class="lineNum">   22558 </span>            :        names are considered class-names.  */
<span class="lineNum">   22559 </span>            :     {
<span class="lineNum">   22560 </span>            :       decl = make_typename_type (scope, decl, tag_type, tf_error);
<span class="lineNum">   22561 </span>            :       if (decl != error_mark_node)
<span class="lineNum">   22562 </span><span class="lineCov">   17623720 :         decl = TYPE_NAME (decl);</span>
<span class="lineNum">   22563 </span>            :     }
<span class="lineNum">   22564 </span>            :   else if (TREE_CODE (decl) != TYPE_DECL
<span class="lineNum">   22565 </span>            :            || TREE_TYPE (decl) == error_mark_node
<span class="lineNum">   22566 </span><span class="lineCov">   17623720 :            || !(MAYBE_CLASS_TYPE_P (TREE_TYPE (decl))</span>
<span class="lineNum">   22567 </span>            :                 || (enum_ok &amp;&amp; TREE_CODE (TREE_TYPE (decl)) == ENUMERAL_TYPE))
<span class="lineNum">   22568 </span>            :            /* In Objective-C 2.0, a classname followed by '.' starts a
<span class="lineNum">   22569 </span>            :               dot-syntax expression, and it's not a type-name.  */
<span class="lineNum">   22570 </span><span class="lineCov">   93311389 :            || (c_dialect_objc ()</span>
<span class="lineNum">   22571 </span>            :                &amp;&amp; cp_lexer_peek_token (parser-&gt;lexer)-&gt;type == CPP_DOT 
<span class="lineNum">   22572 </span>            :                &amp;&amp; objc_is_class_name (decl)))
<span class="lineNum">   22573 </span><span class="lineCov">   93311389 :     decl = error_mark_node;</span>
<span class="lineNum">   22574 </span>            : 
<span class="lineNum">   22575 </span><span class="lineCov">     168985 :   if (decl == error_mark_node)</span>
<span class="lineNum">   22576 </span>            :     cp_parser_error (parser, &quot;expected class-name&quot;);
<span class="lineNum">   22577 </span><span class="lineCov">     168985 :   else if (identifier &amp;&amp; !parser-&gt;scope)</span>
<span class="lineNum">   22578 </span><span class="lineCov">     168985 :     maybe_note_name_used_in_class (identifier, decl);</span>
<span class="lineNum">   22579 </span>            : 
<span class="lineNum">   22580 </span>            :   return decl;
<span class="lineNum">   22581 </span><span class="lineCov">   93311389 : }</span>
<span class="lineNum">   22582 </span>            : 
<span class="lineNum">   22583 </span>            : /* Parse a class-specifier.
<span class="lineNum">   22584 </span><span class="lineCov">   93311389 : </span>
<span class="lineNum">   22585 </span><span class="lineCov">    3664020 :    class-specifier:</span>
<span class="lineNum">   22586 </span><span class="lineCov">   93911909 :      class-head { member-specification [opt] }</span>
<span class="lineNum">   22587 </span>            : 
<span class="lineNum">   22588 </span>            :    Returns the TREE_TYPE representing the class.  */
<a name="22589"><span class="lineNum">   22589 </span>            : </a>
<span class="lineNum">   22590 </span>            : static tree
<span class="lineNum">   22591 </span>            : cp_parser_class_specifier_1 (cp_parser* parser)
<span class="lineNum">   22592 </span>            : {
<span class="lineNum">   22593 </span>            :   tree type;
<span class="lineNum">   22594 </span>            :   tree attributes = NULL_TREE;
<span class="lineNum">   22595 </span>            :   bool nested_name_specifier_p;
<span class="lineNum">   22596 </span>            :   unsigned saved_num_template_parameter_lists;
<span class="lineNum">   22597 </span>            :   bool saved_in_function_body;
<span class="lineNum">   22598 </span><span class="lineCov">         46 :   unsigned char in_statement;</span>
<span class="lineNum">   22599 </span><span class="lineCov">         46 :   bool in_switch_statement_p;</span>
<span class="lineNum">   22600 </span><span class="lineCov">         31 :   bool saved_in_unbraced_linkage_specification_p;</span>
<span class="lineNum">   22601 </span>            :   tree old_scope = NULL_TREE;
<span class="lineNum">   22602 </span><span class="lineCov">   93311343 :   tree scope = NULL_TREE;</span>
<span class="lineNum">   22603 </span><span class="lineCov">   50791123 :   cp_token *closing_brace;</span>
<span class="lineNum">   22604 </span><span class="lineCov">  101582132 : </span>
<span class="lineNum">   22605 </span><span class="lineCov">     125400 :   push_deferring_access_checks (dk_no_deferred);</span>
<span class="lineNum">   22606 </span>            : 
<span class="lineNum">   22607 </span>            :   /* Parse the class-head.  */
<span class="lineNum">   22608 </span><span class="lineCov">  132741907 :   type = cp_parser_class_head (parser,</span>
<span class="lineNum">   22609 </span><span class="lineNoCov">          0 :                                &amp;nested_name_specifier_p);</span>
<span class="lineNum">   22610 </span><span class="lineNoCov">          0 :   /* If the class-head was a semantic disaster, skip the entire body</span>
<span class="lineNum">   22611 </span><span class="lineCov">   53880779 :      of the class.  */</span>
<span class="lineNum">   22612 </span>            :   if (!type)
<span class="lineNum">   22613 </span><span class="lineCov">   93311389 :     {</span>
<span class="lineNum">   22614 </span><span class="lineCov">   53880794 :       cp_parser_skip_to_end_of_block_or_statement (parser);</span>
<span class="lineNum">   22615 </span><span class="lineCov">   39430595 :       pop_deferring_access_checks ();</span>
<span class="lineNum">   22616 </span><span class="lineCov">   26446323 :       return error_mark_node;</span>
<span class="lineNum">   22617 </span>            :     }
<span class="lineNum">   22618 </span>            : 
<span class="lineNum">   22619 </span>            :   /* Look for the `{'.  */
<span class="lineNum">   22620 </span>            :   matching_braces braces;
<span class="lineNum">   22621 </span>            :   if (!braces.require_open (parser))
<span class="lineNum">   22622 </span>            :     {
<span class="lineNum">   22623 </span>            :       pop_deferring_access_checks ();
<span class="lineNum">   22624 </span>            :       return error_mark_node;
<span class="lineNum">   22625 </span>            :     }
<span class="lineNum">   22626 </span>            : 
<span class="lineNum">   22627 </span>            :   cp_ensure_no_omp_declare_simd (parser);
<span class="lineNum">   22628 </span>            :   cp_ensure_no_oacc_routine (parser);
<span class="lineNum">   22629 </span><span class="lineCov">    3284481 : </span>
<span class="lineNum">   22630 </span>            :   /* Issue an error message if type-definitions are forbidden here.  */
<span class="lineNum">   22631 </span><span class="lineCov">    3284481 :   cp_parser_check_type_definition (parser);</span>
<span class="lineNum">   22632 </span><span class="lineCov">    3284481 :   /* Remember that we are defining one more class.  */</span>
<span class="lineNum">   22633 </span><span class="lineCov">    3284481 :   ++parser-&gt;num_classes_being_defined;</span>
<span class="lineNum">   22634 </span><span class="lineCov">    3284481 :   /* Inside the class, surrounding template-parameter-lists do not</span>
<span class="lineNum">   22635 </span><span class="lineCov">    3284481 :      apply.  */</span>
<span class="lineNum">   22636 </span><span class="lineCov">    3284481 :   saved_num_template_parameter_lists</span>
<span class="lineNum">   22637 </span><span class="lineCov">    3284481 :     = parser-&gt;num_template_parameter_lists;</span>
<span class="lineNum">   22638 </span><span class="lineCov">    3284481 :   parser-&gt;num_template_parameter_lists = 0;</span>
<span class="lineNum">   22639 </span><span class="lineCov">    3284481 :   /* We are not in a function body.  */</span>
<span class="lineNum">   22640 </span><span class="lineCov">    3284481 :   saved_in_function_body = parser-&gt;in_function_body;</span>
<span class="lineNum">   22641 </span><span class="lineCov">    3284481 :   parser-&gt;in_function_body = false;</span>
<span class="lineNum">   22642 </span>            :   /* Or in a loop.  */
<span class="lineNum">   22643 </span><span class="lineCov">    3284481 :   in_statement = parser-&gt;in_statement;</span>
<span class="lineNum">   22644 </span>            :   parser-&gt;in_statement = 0;
<span class="lineNum">   22645 </span>            :   /* Or in a switch.  */
<span class="lineNum">   22646 </span><span class="lineCov">    3284481 :   in_switch_statement_p = parser-&gt;in_switch_statement_p;</span>
<span class="lineNum">   22647 </span>            :   parser-&gt;in_switch_statement_p = false;
<span class="lineNum">   22648 </span>            :   /* We are not immediately inside an extern &quot;lang&quot; block.  */
<span class="lineNum">   22649 </span>            :   saved_in_unbraced_linkage_specification_p
<span class="lineNum">   22650 </span><span class="lineCov">    3284481 :     = parser-&gt;in_unbraced_linkage_specification_p;</span>
<span class="lineNum">   22651 </span>            :   parser-&gt;in_unbraced_linkage_specification_p = false;
<span class="lineNum">   22652 </span><span class="lineCov">        312 : </span>
<span class="lineNum">   22653 </span><span class="lineCov">        312 :   // Associate constraints with the type.</span>
<span class="lineNum">   22654 </span><span class="lineCov">        312 :   if (flag_concepts)</span>
<span class="lineNum">   22655 </span>            :     type = associate_classtype_constraints (type);
<span class="lineNum">   22656 </span>            : 
<span class="lineNum">   22657 </span>            :   /* Start the class.  */
<span class="lineNum">   22658 </span><span class="lineCov">    6568338 :   if (nested_name_specifier_p)</span>
<span class="lineNum">   22659 </span><span class="lineCov">    3284169 :     {</span>
<span class="lineNum">   22660 </span>            :       scope = CP_DECL_CONTEXT (TYPE_MAIN_DECL (type));
<span class="lineNum">   22661 </span><span class="lineCov">     875521 :       old_scope = push_inner_scope (scope);</span>
<span class="lineNum">   22662 </span><span class="lineCov">     875521 :     }</span>
<span class="lineNum">   22663 </span>            :   type = begin_class_definition (type);
<span class="lineNum">   22664 </span>            : 
<span class="lineNum">   22665 </span><span class="lineCov">    2408648 :   if (type == error_mark_node)</span>
<span class="lineNum">   22666 </span><span class="lineCov">    2408648 :     /* If the type is erroneous, skip the entire body of the class.  */</span>
<span class="lineNum">   22667 </span>            :     cp_parser_skip_to_closing_brace (parser);
<span class="lineNum">   22668 </span>            :   else
<span class="lineNum">   22669 </span><span class="lineCov">    2408648 :     /* Parse the member-specification.  */</span>
<span class="lineNum">   22670 </span>            :     cp_parser_member_specification_opt (parser);
<span class="lineNum">   22671 </span><span class="lineCov">    2408648 : </span>
<span class="lineNum">   22672 </span>            :   /* Look for the trailing `}'.  */
<span class="lineNum">   22673 </span>            :   closing_brace = braces.require_close (parser);
<span class="lineNum">   22674 </span><span class="lineCov">    2408648 :   /* Look for trailing attributes to apply to this class.  */</span>
<span class="lineNum">   22675 </span><span class="lineCov">    2408648 :   if (cp_parser_allow_gnu_extensions_p (parser))</span>
<span class="lineNum">   22676 </span><span class="lineCov">    2408648 :     attributes = cp_parser_gnu_attributes_opt (parser);</span>
<span class="lineNum">   22677 </span>            :   if (type != error_mark_node)
<span class="lineNum">   22678 </span><span class="lineCov">    2408648 :     type = finish_struct (type, attributes);</span>
<span class="lineNum">   22679 </span><span class="lineCov">    2408648 :   if (nested_name_specifier_p)</span>
<span class="lineNum">   22680 </span>            :     pop_inner_scope (old_scope, scope);
<span class="lineNum">   22681 </span><span class="lineCov">    2408648 : </span>
<span class="lineNum">   22682 </span><span class="lineCov">    2408648 :   /* We've finished a type definition.  Check for the common syntax</span>
<span class="lineNum">   22683 </span>            :      error of forgetting a semicolon after the definition.  We need to
<span class="lineNum">   22684 </span><span class="lineCov">    2408648 :      be careful, as we can't just check for not-a-semicolon and be done</span>
<span class="lineNum">   22685 </span><span class="lineCov">    2408648 :      with it; the user might have typed:</span>
<span class="lineNum">   22686 </span>            : 
<span class="lineNum">   22687 </span><span class="lineCov">    2408648 :      class X { } c = ...;</span>
<span class="lineNum">   22688 </span><span class="lineCov">    2408648 :      class X { } *p = ...;</span>
<span class="lineNum">   22689 </span><span class="lineCov">    2408648 : </span>
<span class="lineNum">   22690 </span>            :      and so forth.  Instead, enumerate all the possible tokens that
<span class="lineNum">   22691 </span>            :      might follow this production; if we don't see one of them, then
<span class="lineNum">   22692 </span><span class="lineCov">    2408648 :      complain and silently insert the semicolon.  */</span>
<span class="lineNum">   22693 </span><span class="lineCov">       4409 :   {</span>
<span class="lineNum">   22694 </span>            :     cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   22695 </span>            :     bool want_semicolon = true;
<span class="lineNum">   22696 </span><span class="lineCov">    2408648 : </span>
<span class="lineNum">   22697 </span>            :     if (cp_next_tokens_can_be_std_attribute_p (parser))
<span class="lineNum">   22698 </span><span class="lineCov">       7967 :       /* Don't try to parse c++11 attributes here.  As per the</span>
<span class="lineNum">   22699 </span><span class="lineCov">       7967 :          grammar, that should be a task for</span>
<span class="lineNum">   22700 </span>            :          cp_parser_decl_specifier_seq.  */
<span class="lineNum">   22701 </span><span class="lineCov">    2408648 :       want_semicolon = false;</span>
<span class="lineNum">   22702 </span>            : 
<span class="lineNum">   22703 </span><span class="lineCov">    2408648 :     switch (token-&gt;type)</span>
<span class="lineNum">   22704 </span>            :       {
<span class="lineNum">   22705 </span><span class="lineCov">         40 :       case CPP_NAME:</span>
<span class="lineNum">   22706 </span>            :       case CPP_SEMICOLON:
<span class="lineNum">   22707 </span>            :       case CPP_MULT:
<span class="lineNum">   22708 </span><span class="lineCov">    2408608 :       case CPP_AND:</span>
<span class="lineNum">   22709 </span>            :       case CPP_OPEN_PAREN:
<span class="lineNum">   22710 </span>            :       case CPP_CLOSE_PAREN:
<span class="lineNum">   22711 </span><span class="lineCov">    2408642 :       case CPP_COMMA:</span>
<span class="lineNum">   22712 </span>            :         want_semicolon = false;
<span class="lineNum">   22713 </span><span class="lineCov">    4817284 :         break;</span>
<span class="lineNum">   22714 </span><span class="lineCov">    2408642 : </span>
<span class="lineNum">   22715 </span><span class="lineCov">    2408642 :         /* While it's legal for type qualifiers and storage class</span>
<span class="lineNum">   22716 </span><span class="lineCov">    2408602 :            specifiers to follow type definitions in the grammar, only</span>
<span class="lineNum">   22717 </span><span class="lineCov">    2408638 :            compiler testsuites contain code like that.  Assume that if</span>
<span class="lineNum">   22718 </span><span class="lineCov">       7967 :            we see such code, then what we're really seeing is a case</span>
<span class="lineNum">   22719 </span>            :            like:
<span class="lineNum">   22720 </span>            : 
<span class="lineNum">   22721 </span>            :            class X { }
<span class="lineNum">   22722 </span>            :            const &lt;type&gt; var = ...;
<span class="lineNum">   22723 </span>            : 
<span class="lineNum">   22724 </span>            :            or
<span class="lineNum">   22725 </span>            : 
<span class="lineNum">   22726 </span>            :            class Y { }
<span class="lineNum">   22727 </span>            :            static &lt;type&gt; func (...) ...
<span class="lineNum">   22728 </span>            : 
<span class="lineNum">   22729 </span>            :            i.e. the qualifier or specifier applies to the next
<span class="lineNum">   22730 </span>            :            declaration.  To do so, however, we need to look ahead one
<span class="lineNum">   22731 </span><span class="lineCov">    2408638 :            more token to see if *that* token is a type specifier.</span>
<span class="lineNum">   22732 </span><span class="lineCov">    4817276 : </span>
<span class="lineNum">   22733 </span><span class="lineCov">    2408638 :            This code could be improved to handle:</span>
<span class="lineNum">   22734 </span>            : 
<span class="lineNum">   22735 </span><span class="lineCov">    2408638 :            class Z { }</span>
<span class="lineNum">   22736 </span>            :            static const &lt;type&gt; var = ...;  */
<span class="lineNum">   22737 </span>            :       case CPP_KEYWORD:
<span class="lineNum">   22738 </span>            :         if (keyword_is_decl_specifier (token-&gt;keyword))
<span class="lineNum">   22739 </span><span class="lineCov">          8 :           {</span>
<span class="lineNum">   22740 </span>            :             cp_token *lookahead = cp_lexer_peek_nth_token (parser-&gt;lexer, 2);
<span class="lineNum">   22741 </span><span class="lineCov">    2408638 : </span>
<span class="lineNum">   22742 </span>            :             /* Handling user-defined types here would be nice, but very
<span class="lineNum">   22743 </span><span class="lineCov">    2406950 :                tricky.  */</span>
<span class="lineNum">   22744 </span><span class="lineCov">    2406950 :             want_semicolon</span>
<span class="lineNum">   22745 </span><span class="lineCov">    2406950 :               = (lookahead-&gt;type == CPP_KEYWORD</span>
<span class="lineNum">   22746 </span><span class="lineCov">    2406950 :                  &amp;&amp; keyword_begins_type_specifier (lookahead-&gt;keyword));</span>
<span class="lineNum">   22747 </span><span class="lineCov">    2406950 :           }</span>
<span class="lineNum">   22748 </span><span class="lineCov">    2406950 :         break;</span>
<span class="lineNum">   22749 </span><span class="lineCov">    2406950 :       default:</span>
<span class="lineNum">   22750 </span><span class="lineCov">    2406950 :         break;</span>
<span class="lineNum">   22751 </span><span class="lineCov">    2406950 :       }</span>
<span class="lineNum">   22752 </span>            : 
<span class="lineNum">   22753 </span>            :     /* If we don't have a type, then something is very wrong and we
<span class="lineNum">   22754 </span>            :        shouldn't try to do anything clever.  Likewise for not seeing the
<span class="lineNum">   22755 </span>            :        closing brace.  */
<span class="lineNum">   22756 </span>            :     if (closing_brace &amp;&amp; TYPE_P (type) &amp;&amp; want_semicolon)
<span class="lineNum">   22757 </span>            :       {
<span class="lineNum">   22758 </span>            :         /* Locate the closing brace.  */
<span class="lineNum">   22759 </span>            :         cp_token_position prev
<span class="lineNum">   22760 </span>            :           = cp_lexer_previous_token_position (parser-&gt;lexer);
<span class="lineNum">   22761 </span>            :         cp_token *prev_token = cp_lexer_token_at (parser-&gt;lexer, prev);
<span class="lineNum">   22762 </span>            :         location_t loc = prev_token-&gt;location;
<span class="lineNum">   22763 </span>            : 
<span class="lineNum">   22764 </span>            :         /* We want to suggest insertion of a ';' immediately *after* the
<span class="lineNum">   22765 </span>            :            closing brace, so, if we can, offset the location by 1 column.  */
<span class="lineNum">   22766 </span>            :         location_t next_loc = loc;
<span class="lineNum">   22767 </span>            :         if (!linemap_location_from_macro_expansion_p (line_table, loc))
<span class="lineNum">   22768 </span>            :           next_loc = linemap_position_for_loc_and_offset (line_table, loc, 1);
<span class="lineNum">   22769 </span>            : 
<span class="lineNum">   22770 </span>            :         rich_location richloc (line_table, next_loc);
<span class="lineNum">   22771 </span>            : 
<span class="lineNum">   22772 </span>            :         /* If we successfully offset the location, suggest the fix-it.  */
<span class="lineNum">   22773 </span>            :         if (next_loc != loc)
<span class="lineNum">   22774 </span>            :           richloc.add_fixit_insert_before (next_loc, &quot;;&quot;);
<span class="lineNum">   22775 </span><span class="lineCov">       1576 : </span>
<span class="lineNum">   22776 </span><span class="lineCov">       1576 :         if (CLASSTYPE_DECLARED_CLASS (type))</span>
<span class="lineNum">   22777 </span>            :           error_at (&amp;richloc,
<span class="lineNum">   22778 </span><span class="lineCov">       1550 :                     &quot;expected %&lt;;%&gt; after class definition&quot;);</span>
<span class="lineNum">   22779 </span>            :         else if (TREE_CODE (type) == RECORD_TYPE)
<span class="lineNum">   22780 </span>            :           error_at (&amp;richloc,
<span class="lineNum">   22781 </span>            :                     &quot;expected %&lt;;%&gt; after struct definition&quot;);
<span class="lineNum">   22782 </span><span class="lineCov">       1550 :         else if (TREE_CODE (type) == UNION_TYPE)</span>
<span class="lineNum">   22783 </span><span class="lineCov">       1550 :           error_at (&amp;richloc,</span>
<span class="lineNum">   22784 </span><span class="lineCov">       1550 :                     &quot;expected %&lt;;%&gt; after union definition&quot;);</span>
<span class="lineNum">   22785 </span>            :         else
<span class="lineNum">   22786 </span>            :           gcc_unreachable ();
<span class="lineNum">   22787 </span>            : 
<span class="lineNum">   22788 </span>            :         /* Unget one token and smash it to look as though we encountered
<span class="lineNum">   22789 </span>            :            a semicolon in the input stream.  */
<span class="lineNum">   22790 </span>            :         cp_lexer_set_token_position (parser-&gt;lexer, prev);
<span class="lineNum">   22791 </span>            :         token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   22792 </span>            :         token-&gt;type = CPP_SEMICOLON;
<span class="lineNum">   22793 </span>            :         token-&gt;keyword = RID_MAX;
<span class="lineNum">   22794 </span><span class="lineCov">    2408638 :       }</span>
<span class="lineNum">   22795 </span>            :   }
<span class="lineNum">   22796 </span>            : 
<span class="lineNum">   22797 </span><span class="lineCov">         98 :   /* If this class is not itself within the scope of another class,</span>
<span class="lineNum">   22798 </span><span class="lineCov">         98 :      then we need to parse the bodies of all of the queued function</span>
<span class="lineNum">   22799 </span><span class="lineCov">        196 :      definitions.  Note that the queued functions defined in a class</span>
<span class="lineNum">   22800 </span><span class="lineCov">         98 :      are not always processed immediately following the</span>
<span class="lineNum">   22801 </span>            :      class-specifier for that class.  Consider:
<span class="lineNum">   22802 </span>            : 
<span class="lineNum">   22803 </span>            :        struct A {
<span class="lineNum">   22804 </span><span class="lineCov">         98 :          struct B { void f() { sizeof (A); } };</span>
<span class="lineNum">   22805 </span><span class="lineCov">         98 :        };</span>
<span class="lineNum">   22806 </span><span class="lineCov">         98 : </span>
<span class="lineNum">   22807 </span>            :      If `f' were processed before the processing of `A' were
<span class="lineNum">   22808 </span><span class="lineCov">         98 :      completed, there would be no way to compute the size of `A'.</span>
<span class="lineNum">   22809 </span>            :      Note that the nesting we are interested in here is lexical --
<span class="lineNum">   22810 </span>            :      not the semantic nesting given by TYPE_CONTEXT.  In particular,
<span class="lineNum">   22811 </span><span class="lineCov">         98 :      for:</span>
<span class="lineNum">   22812 </span><span class="lineCov">         95 : </span>
<span class="lineNum">   22813 </span>            :        struct A { struct B; };
<span class="lineNum">   22814 </span><span class="lineCov">         98 :        struct A::B { void f() { } };</span>
<span class="lineNum">   22815 </span><span class="lineCov">         37 : </span>
<span class="lineNum">   22816 </span>            :      there is no need to delay the parsing of `A::B::f'.  */
<span class="lineNum">   22817 </span><span class="lineCov">         61 :   if (--parser-&gt;num_classes_being_defined == 0)</span>
<span class="lineNum">   22818 </span><span class="lineCov">         59 :     {</span>
<span class="lineNum">   22819 </span>            :       tree decl;
<span class="lineNum">   22820 </span><span class="lineCov">          2 :       tree class_type = NULL_TREE;</span>
<span class="lineNum">   22821 </span><span class="lineCov">          2 :       tree pushed_scope = NULL_TREE;</span>
<span class="lineNum">   22822 </span>            :       unsigned ix;
<span class="lineNum">   22823 </span>            :       cp_default_arg_entry *e;
<span class="lineNum">   22824 </span><span class="lineNoCov">          0 :       tree save_ccp, save_ccr;</span>
<span class="lineNum">   22825 </span>            : 
<span class="lineNum">   22826 </span>            :       if (any_erroneous_template_args_p (type))
<span class="lineNum">   22827 </span>            :         {
<span class="lineNum">   22828 </span><span class="lineCov">        196 :           /* Skip default arguments, NSDMIs, etc, in order to improve</span>
<span class="lineNum">   22829 </span><span class="lineCov">        196 :              error recovery (c++/71169, c++/71832).  */</span>
<span class="lineNum">   22830 </span><span class="lineCov">         98 :           vec_safe_truncate (unparsed_funs_with_default_args, 0);</span>
<span class="lineNum">   22831 </span><span class="lineCov">         98 :           vec_safe_truncate (unparsed_nsdmis, 0);</span>
<span class="lineNum">   22832 </span>            :           vec_safe_truncate (unparsed_classes, 0);
<span class="lineNum">   22833 </span>            :           vec_safe_truncate (unparsed_funs_with_definitions, 0);
<span class="lineNum">   22834 </span>            :         }
<span class="lineNum">   22835 </span>            : 
<span class="lineNum">   22836 </span>            :       /* In a first pass, parse default arguments to the functions.
<span class="lineNum">   22837 </span>            :          Then, in a second pass, parse the bodies of the functions.
<span class="lineNum">   22838 </span>            :          This two-phased approach handles cases like:
<span class="lineNum">   22839 </span>            : 
<span class="lineNum">   22840 </span>            :             struct S {
<span class="lineNum">   22841 </span>            :               void f() { g(); }
<span class="lineNum">   22842 </span>            :               void g(int i = 3);
<span class="lineNum">   22843 </span>            :             };
<span class="lineNum">   22844 </span>            : 
<span class="lineNum">   22845 </span>            :          */
<span class="lineNum">   22846 </span>            :       FOR_EACH_VEC_SAFE_ELT (unparsed_funs_with_default_args, ix, e)
<span class="lineNum">   22847 </span>            :         {
<span class="lineNum">   22848 </span>            :           decl = e-&gt;decl;
<span class="lineNum">   22849 </span>            :           /* If there are default arguments that have not yet been processed,
<span class="lineNum">   22850 </span>            :              take care of them now.  */
<span class="lineNum">   22851 </span>            :           if (class_type != e-&gt;class_type)
<span class="lineNum">   22852 </span>            :             {
<span class="lineNum">   22853 </span>            :               if (pushed_scope)
<span class="lineNum">   22854 </span>            :                 pop_scope (pushed_scope);
<span class="lineNum">   22855 </span><span class="lineCov">    2408638 :               class_type = e-&gt;class_type;</span>
<span class="lineNum">   22856 </span>            :               pushed_scope = push_scope (class_type);
<span class="lineNum">   22857 </span><span class="lineCov">    2256799 :             }</span>
<span class="lineNum">   22858 </span><span class="lineCov">    2256799 :           /* Make sure that any template parameters are in scope.  */</span>
<span class="lineNum">   22859 </span><span class="lineCov">    2256799 :           maybe_begin_member_template_processing (decl);</span>
<span class="lineNum">   22860 </span><span class="lineCov">    2256799 :           /* Parse the default argument expressions.  */</span>
<span class="lineNum">   22861 </span><span class="lineCov">    2256799 :           cp_parser_late_parsing_default_args (parser, decl);</span>
<span class="lineNum">   22862 </span><span class="lineCov">    2256799 :           /* Remove any template parameters from the symbol table.  */</span>
<span class="lineNum">   22863 </span>            :           maybe_end_member_template_processing ();
<span class="lineNum">   22864 </span><span class="lineCov">    2256799 :         }</span>
<span class="lineNum">   22865 </span>            :       vec_safe_truncate (unparsed_funs_with_default_args, 0);
<span class="lineNum">   22866 </span>            :       /* Now parse any NSDMIs.  */
<span class="lineNum">   22867 </span>            :       save_ccp = current_class_ptr;
<span class="lineNum">   22868 </span><span class="lineCov">        118 :       save_ccr = current_class_ref;</span>
<span class="lineNum">   22869 </span><span class="lineCov">        236 :       FOR_EACH_VEC_SAFE_ELT (unparsed_nsdmis, ix, decl)</span>
<span class="lineNum">   22870 </span><span class="lineCov">        236 :         {</span>
<span class="lineNum">   22871 </span><span class="lineCov">        236 :           if (class_type != DECL_CONTEXT (decl))</span>
<span class="lineNum">   22872 </span>            :             {
<span class="lineNum">   22873 </span>            :               if (pushed_scope)
<span class="lineNum">   22874 </span>            :                 pop_scope (pushed_scope);
<span class="lineNum">   22875 </span>            :               class_type = DECL_CONTEXT (decl);
<span class="lineNum">   22876 </span>            :               pushed_scope = push_scope (class_type);
<span class="lineNum">   22877 </span>            :             }
<span class="lineNum">   22878 </span>            :           inject_this_parameter (class_type, TYPE_UNQUALIFIED);
<span class="lineNum">   22879 </span>            :           cp_parser_late_parsing_nsdmi (parser, decl);
<span class="lineNum">   22880 </span>            :         }
<span class="lineNum">   22881 </span>            :       vec_safe_truncate (unparsed_nsdmis, 0);
<span class="lineNum">   22882 </span>            :       current_class_ptr = save_ccp;
<span class="lineNum">   22883 </span>            :       current_class_ref = save_ccr;
<span class="lineNum">   22884 </span><span class="lineCov">    2467742 :       if (pushed_scope)</span>
<span class="lineNum">   22885 </span>            :         pop_scope (pushed_scope);
<span class="lineNum">   22886 </span><span class="lineCov">     210943 : </span>
<span class="lineNum">   22887 </span>            :       /* Now do some post-NSDMI bookkeeping.  */
<span class="lineNum">   22888 </span>            :       FOR_EACH_VEC_SAFE_ELT (unparsed_classes, ix, class_type)
<span class="lineNum">   22889 </span><span class="lineCov">     210943 :         after_nsdmi_defaulted_late_checks (class_type);</span>
<span class="lineNum">   22890 </span>            :       vec_safe_truncate (unparsed_classes, 0);
<span class="lineNum">   22891 </span><span class="lineCov">      74482 :       after_nsdmi_defaulted_late_checks (type);</span>
<span class="lineNum">   22892 </span><span class="lineCov">       4859 : </span>
<span class="lineNum">   22893 </span><span class="lineCov">      74482 :       /* Now parse the body of the functions.  */</span>
<span class="lineNum">   22894 </span><span class="lineCov">      74482 :       if (flag_openmp)</span>
<span class="lineNum">   22895 </span>            :         {
<span class="lineNum">   22896 </span>            :           /* OpenMP UDRs need to be parsed before all other functions.  */
<span class="lineNum">   22897 </span><span class="lineCov">     210943 :           FOR_EACH_VEC_SAFE_ELT (unparsed_funs_with_definitions, ix, decl)</span>
<span class="lineNum">   22898 </span>            :             if (DECL_OMP_DECLARE_REDUCTION_P (decl))
<span class="lineNum">   22899 </span><span class="lineCov">     210943 :               cp_parser_late_parsing_for_member (parser, decl);</span>
<span class="lineNum">   22900 </span>            :           FOR_EACH_VEC_SAFE_ELT (unparsed_funs_with_definitions, ix, decl)
<span class="lineNum">   22901 </span><span class="lineCov">     210943 :             if (!DECL_OMP_DECLARE_REDUCTION_P (decl))</span>
<span class="lineNum">   22902 </span>            :               cp_parser_late_parsing_for_member (parser, decl);
<span class="lineNum">   22903 </span><span class="lineCov">    4513598 :         }</span>
<span class="lineNum">   22904 </span>            :       else
<span class="lineNum">   22905 </span><span class="lineCov">    2256799 :         FOR_EACH_VEC_SAFE_ELT (unparsed_funs_with_definitions, ix, decl)</span>
<span class="lineNum">   22906 </span><span class="lineCov">    2256799 :           cp_parser_late_parsing_for_member (parser, decl);</span>
<span class="lineNum">   22907 </span><span class="lineCov">    2265069 :       vec_safe_truncate (unparsed_funs_with_definitions, 0);</span>
<span class="lineNum">   22908 </span>            :     }
<span class="lineNum">   22909 </span><span class="lineCov">       8270 :   else</span>
<span class="lineNum">   22910 </span>            :     vec_safe_push (unparsed_classes, type);
<span class="lineNum">   22911 </span><span class="lineCov">       4456 : </span>
<span class="lineNum">   22912 </span><span class="lineCov">         12 :   /* Put back any saved access checks.  */</span>
<span class="lineNum">   22913 </span><span class="lineCov">       4456 :   pop_deferring_access_checks ();</span>
<span class="lineNum">   22914 </span><span class="lineCov">       4456 : </span>
<span class="lineNum">   22915 </span>            :   /* Restore saved state.  */
<span class="lineNum">   22916 </span><span class="lineCov">       8270 :   parser-&gt;in_switch_statement_p = in_switch_statement_p;</span>
<span class="lineNum">   22917 </span><span class="lineCov">       8270 :   parser-&gt;in_statement = in_statement;</span>
<span class="lineNum">   22918 </span>            :   parser-&gt;in_function_body = saved_in_function_body;
<span class="lineNum">   22919 </span><span class="lineCov">    4513598 :   parser-&gt;num_template_parameter_lists</span>
<span class="lineNum">   22920 </span><span class="lineCov">    2256799 :     = saved_num_template_parameter_lists;</span>
<span class="lineNum">   22921 </span><span class="lineCov">    2256799 :   parser-&gt;in_unbraced_linkage_specification_p</span>
<span class="lineNum">   22922 </span><span class="lineCov">    2256799 :     = saved_in_unbraced_linkage_specification_p;</span>
<span class="lineNum">   22923 </span><span class="lineCov">      74067 : </span>
<span class="lineNum">   22924 </span>            :   return type;
<span class="lineNum">   22925 </span>            : }
<a name="22926"><span class="lineNum">   22926 </span><span class="lineCov">    2408633 : </span></a>
<span class="lineNum">   22927 </span><span class="lineCov">     151834 : static tree</span>
<span class="lineNum">   22928 </span><span class="lineCov">    4513598 : cp_parser_class_specifier (cp_parser* parser)</span>
<span class="lineNum">   22929 </span><span class="lineCov">    2256799 : {</span>
<span class="lineNum">   22930 </span>            :   tree ret;
<span class="lineNum">   22931 </span>            :   timevar_push (TV_PARSE_STRUCT);
<span class="lineNum">   22932 </span><span class="lineCov">    2256799 :   ret = cp_parser_class_specifier_1 (parser);</span>
<span class="lineNum">   22933 </span>            :   timevar_pop (TV_PARSE_STRUCT);
<span class="lineNum">   22934 </span>            :   return ret;
<span class="lineNum">   22935 </span><span class="lineCov">      16740 : }</span>
<span class="lineNum">   22936 </span><span class="lineCov">       9333 : </span>
<span class="lineNum">   22937 </span><span class="lineCov">        169 : /* Parse a class-head.</span>
<span class="lineNum">   22938 </span><span class="lineCov">      16740 : </span>
<span class="lineNum">   22939 </span><span class="lineCov">       9333 :    class-head:</span>
<span class="lineNum">   22940 </span><span class="lineCov">       9164 :      class-key identifier [opt] base-clause [opt]</span>
<span class="lineNum">   22941 </span>            :      class-key nested-name-specifier identifier class-virt-specifier [opt] base-clause [opt]
<span class="lineNum">   22942 </span>            :      class-key nested-name-specifier [opt] template-id
<span class="lineNum">   22943 </span><span class="lineCov">    6024553 :        base-clause [opt]</span>
<span class="lineNum">   22944 </span><span class="lineCov">    3775161 : </span>
<span class="lineNum">   22945 </span><span class="lineCov">    2256799 :    class-virt-specifier:</span>
<span class="lineNum">   22946 </span>            :      final
<span class="lineNum">   22947 </span>            : 
<span class="lineNum">   22948 </span><span class="lineCov">     151839 :    GNU Extensions:</span>
<span class="lineNum">   22949 </span>            :      class-key attributes identifier [opt] base-clause [opt]
<span class="lineNum">   22950 </span>            :      class-key attributes nested-name-specifier identifier base-clause [opt]
<span class="lineNum">   22951 </span><span class="lineCov">    2408638 :      class-key attributes nested-name-specifier [opt] template-id</span>
<span class="lineNum">   22952 </span>            :        base-clause [opt]
<span class="lineNum">   22953 </span>            : 
<span class="lineNum">   22954 </span><span class="lineCov">    2408638 :    Upon return BASES is initialized to the list of base classes (or</span>
<span class="lineNum">   22955 </span><span class="lineCov">    2408638 :    NULL, if there are none) in the same form returned by</span>
<span class="lineNum">   22956 </span><span class="lineCov">    2408638 :    cp_parser_base_clause.</span>
<span class="lineNum">   22957 </span><span class="lineCov">    2408638 : </span>
<span class="lineNum">   22958 </span><span class="lineCov">    2408638 :    Returns the TYPE of the indicated class.  Sets</span>
<span class="lineNum">   22959 </span><span class="lineCov">    2408638 :    *NESTED_NAME_SPECIFIER_P to TRUE iff one of the productions</span>
<span class="lineNum">   22960 </span><span class="lineCov">    2408638 :    involving a nested-name-specifier was used, and FALSE otherwise.</span>
<span class="lineNum">   22961 </span>            : 
<span class="lineNum">   22962 </span><span class="lineCov">    2408638 :    Returns error_mark_node if this is not a class-head.</span>
<span class="lineNum">   22963 </span>            : 
<span class="lineNum">   22964 </span>            :    Returns NULL_TREE if the class-head is syntactically valid, but
<span class="lineNum">   22965 </span>            :    semantically invalid in a way that means we should skip the entire
<span class="lineNum">   22966 </span><span class="lineCov">    3284481 :    body of the class.  */</span>
<a name="22967"><span class="lineNum">   22967 </span>            : </a>
<span class="lineNum">   22968 </span><span class="lineCov">    3284481 : static tree</span>
<span class="lineNum">   22969 </span><span class="lineCov">    3284481 : cp_parser_class_head (cp_parser* parser,</span>
<span class="lineNum">   22970 </span><span class="lineCov">    3284481 :                       bool* nested_name_specifier_p)</span>
<span class="lineNum">   22971 </span><span class="lineCov">    3284471 : {</span>
<span class="lineNum">   22972 </span><span class="lineCov">    3284471 :   tree nested_name_specifier;</span>
<span class="lineNum">   22973 </span>            :   enum tag_types class_key;
<span class="lineNum">   22974 </span>            :   tree id = NULL_TREE;
<span class="lineNum">   22975 </span>            :   tree type = NULL_TREE;
<span class="lineNum">   22976 </span>            :   tree attributes;
<span class="lineNum">   22977 </span>            :   tree bases;
<span class="lineNum">   22978 </span>            :   cp_virt_specifiers virt_specifiers = VIRT_SPEC_UNSPECIFIED;
<span class="lineNum">   22979 </span>            :   bool template_id_p = false;
<span class="lineNum">   22980 </span>            :   bool qualified_p = false;
<span class="lineNum">   22981 </span>            :   bool invalid_nested_name_p = false;
<span class="lineNum">   22982 </span>            :   bool invalid_explicit_specialization_p = false;
<span class="lineNum">   22983 </span>            :   bool saved_colon_corrects_to_scope_p = parser-&gt;colon_corrects_to_scope_p;
<span class="lineNum">   22984 </span>            :   tree pushed_scope = NULL_TREE;
<span class="lineNum">   22985 </span>            :   unsigned num_templates;
<span class="lineNum">   22986 </span>            :   cp_token *type_start_token = NULL, *nested_name_specifier_token_start = NULL;
<span class="lineNum">   22987 </span>            :   /* Assume no nested-name-specifier will be present.  */
<span class="lineNum">   22988 </span>            :   *nested_name_specifier_p = false;
<span class="lineNum">   22989 </span>            :   /* Assume no template parameter lists will be used in defining the
<span class="lineNum">   22990 </span>            :      type.  */
<span class="lineNum">   22991 </span>            :   num_templates = 0;
<span class="lineNum">   22992 </span>            :   parser-&gt;colon_corrects_to_scope_p = false;
<span class="lineNum">   22993 </span>            : 
<span class="lineNum">   22994 </span>            :   /* Look for the class-key.  */
<span class="lineNum">   22995 </span>            :   class_key = cp_parser_class_key (parser);
<span class="lineNum">   22996 </span>            :   if (class_key == none_type)
<span class="lineNum">   22997 </span>            :     return error_mark_node;
<span class="lineNum">   22998 </span>            : 
<span class="lineNum">   22999 </span>            :   location_t class_head_start_location = input_location;
<span class="lineNum">   23000 </span>            : 
<span class="lineNum">   23001 </span>            :   /* Parse the attributes.  */
<span class="lineNum">   23002 </span>            :   attributes = cp_parser_attributes_opt (parser);
<span class="lineNum">   23003 </span>            : 
<span class="lineNum">   23004 </span>            :   /* If the next token is `::', that is invalid -- but sometimes
<span class="lineNum">   23005 </span>            :      people do try to write:
<span class="lineNum">   23006 </span>            : 
<span class="lineNum">   23007 </span><span class="lineCov">    3284481 :        struct ::S {};</span>
<span class="lineNum">   23008 </span>            : 
<span class="lineNum">   23009 </span>            :      Handle this gracefully by accepting the extra qualifier, and then
<span class="lineNum">   23010 </span><span class="lineCov">    3284481 :      issuing an error about it later if this really is a</span>
<span class="lineNum">   23011 </span><span class="lineCov">    3284481 :      class-head.  If it turns out just to be an elaborated type</span>
<span class="lineNum">   23012 </span><span class="lineCov">    3284481 :      specifier, remain silent.  */</span>
<span class="lineNum">   23013 </span><span class="lineCov">    3284481 :   if (cp_parser_global_scope_opt (parser, /*current_scope_valid_p=*/false))</span>
<span class="lineNum">   23014 </span><span class="lineCov">    3284481 :     qualified_p = true;</span>
<span class="lineNum">   23015 </span><span class="lineCov">    3284481 : </span>
<span class="lineNum">   23016 </span><span class="lineCov">    3284481 :   push_deferring_access_checks (dk_no_check);</span>
<span class="lineNum">   23017 </span><span class="lineCov">    3284481 : </span>
<span class="lineNum">   23018 </span><span class="lineCov">    3284481 :   /* Determine the name of the class.  Begin by looking for an</span>
<span class="lineNum">   23019 </span><span class="lineCov">    3284481 :      optional nested-name-specifier.  */</span>
<span class="lineNum">   23020 </span><span class="lineCov">    3284481 :   nested_name_specifier_token_start = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   23021 </span><span class="lineCov">    3284481 :   nested_name_specifier</span>
<span class="lineNum">   23022 </span><span class="lineCov">    3284481 :     = cp_parser_nested_name_specifier_opt (parser,</span>
<span class="lineNum">   23023 </span><span class="lineCov">    3284481 :                                            /*typename_keyword_p=*/false,</span>
<span class="lineNum">   23024 </span><span class="lineCov">    3284481 :                                            /*check_dependency_p=*/false,</span>
<span class="lineNum">   23025 </span>            :                                            /*type_p=*/true,
<span class="lineNum">   23026 </span><span class="lineCov">    3284481 :                                            /*is_declaration=*/false);</span>
<span class="lineNum">   23027 </span>            :   /* If there was a nested-name-specifier, then there *must* be an
<span class="lineNum">   23028 </span>            :      identifier.  */
<span class="lineNum">   23029 </span><span class="lineCov">    3284481 : </span>
<span class="lineNum">   23030 </span><span class="lineCov">    3284481 :   cp_token *bad_template_keyword = NULL;</span>
<span class="lineNum">   23031 </span>            : 
<span class="lineNum">   23032 </span>            :   if (nested_name_specifier)
<span class="lineNum">   23033 </span><span class="lineCov">    3284481 :     {</span>
<span class="lineNum">   23034 </span><span class="lineCov">    3284481 :       type_start_token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   23035 </span><span class="lineNoCov">          0 :       /* Although the grammar says `identifier', it really means</span>
<span class="lineNum">   23036 </span>            :          `class-name' or `template-name'.  You are only allowed to
<span class="lineNum">   23037 </span><span class="lineCov">    3284481 :          define a class that has already been declared with this</span>
<span class="lineNum">   23038 </span>            :          syntax.
<span class="lineNum">   23039 </span>            : 
<span class="lineNum">   23040 </span><span class="lineCov">    3284481 :          The proposed resolution for Core Issue 180 says that wherever</span>
<span class="lineNum">   23041 </span>            :          you see `class T::X' you should treat `X' as a type-name.
<span class="lineNum">   23042 </span>            : 
<span class="lineNum">   23043 </span>            :          It is OK to define an inaccessible class; for example:
<span class="lineNum">   23044 </span>            : 
<span class="lineNum">   23045 </span>            :            class A { class B; };
<span class="lineNum">   23046 </span>            :            class A::B {};
<span class="lineNum">   23047 </span>            : 
<span class="lineNum">   23048 </span>            :          We do not know if we will see a class-name, or a
<span class="lineNum">   23049 </span>            :          template-name.  We look for a class-name first, in case the
<span class="lineNum">   23050 </span>            :          class-name is a template-id; if we looked for the
<span class="lineNum">   23051 </span><span class="lineCov">    6568962 :          template-name first we would stop after the template-name.  */</span>
<span class="lineNum">   23052 </span><span class="lineCov">        403 :       cp_parser_parse_tentatively (parser);</span>
<span class="lineNum">   23053 </span>            :       if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_TEMPLATE))
<span class="lineNum">   23054 </span><span class="lineCov">    3284481 :         bad_template_keyword = cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   23055 </span>            :       type = cp_parser_class_name (parser,
<span class="lineNum">   23056 </span>            :                                    /*typename_keyword_p=*/false,
<span class="lineNum">   23057 </span>            :                                    /*template_keyword_p=*/false,
<span class="lineNum">   23058 </span><span class="lineCov">    6568962 :                                    class_type,</span>
<span class="lineNum">   23059 </span><span class="lineCov">    3284481 :                                    /*check_dependency_p=*/false,</span>
<span class="lineNum">   23060 </span><span class="lineCov">    3284481 :                                    /*class_head_p=*/true,</span>
<span class="lineNum">   23061 </span>            :                                    /*is_declaration=*/false);
<span class="lineNum">   23062 </span>            :       /* If that didn't work, ignore the nested-name-specifier.  */
<span class="lineNum">   23063 </span>            :       if (!cp_parser_parse_definitely (parser))
<span class="lineNum">   23064 </span>            :         {
<span class="lineNum">   23065 </span>            :           invalid_nested_name_p = true;
<span class="lineNum">   23066 </span>            :           type_start_token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   23067 </span>            :           id = cp_parser_identifier (parser);
<span class="lineNum">   23068 </span><span class="lineCov">    3284481 :           if (id == error_mark_node)</span>
<span class="lineNum">   23069 </span>            :             id = NULL_TREE;
<span class="lineNum">   23070 </span><span class="lineCov">    3284481 :         }</span>
<span class="lineNum">   23071 </span>            :       /* If we could not find a corresponding TYPE, treat this
<span class="lineNum">   23072 </span><span class="lineCov">      41092 :          declaration like an unqualified declaration.  */</span>
<span class="lineNum">   23073 </span>            :       if (type == error_mark_node)
<span class="lineNum">   23074 </span>            :         nested_name_specifier = NULL_TREE;
<span class="lineNum">   23075 </span>            :       /* Otherwise, count the number of templates used in TYPE and its
<span class="lineNum">   23076 </span>            :          containing scopes.  */
<span class="lineNum">   23077 </span>            :       else
<span class="lineNum">   23078 </span>            :         num_templates = num_template_headers_for_class (TREE_TYPE (type));
<span class="lineNum">   23079 </span>            :     }
<span class="lineNum">   23080 </span>            :   /* Otherwise, the identifier is optional.  */
<span class="lineNum">   23081 </span>            :   else
<span class="lineNum">   23082 </span>            :     {
<span class="lineNum">   23083 </span>            :       /* We don't know whether what comes next is a template-id,
<span class="lineNum">   23084 </span>            :          an identifier, or nothing at all.  */
<span class="lineNum">   23085 </span>            :       cp_parser_parse_tentatively (parser);
<span class="lineNum">   23086 </span>            :       /* Check for a template-id.  */
<span class="lineNum">   23087 </span>            :       type_start_token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   23088 </span>            :       id = cp_parser_template_id (parser,
<span class="lineNum">   23089 </span>            :                                   /*template_keyword_p=*/false,
<span class="lineNum">   23090 </span><span class="lineCov">      20546 :                                   /*check_dependency_p=*/true,</span>
<span class="lineNum">   23091 </span><span class="lineCov">      20546 :                                   class_key,</span>
<span class="lineNum">   23092 </span><span class="lineCov">          3 :                                   /*is_declaration=*/true);</span>
<span class="lineNum">   23093 </span><span class="lineCov">      20546 :       /* If that didn't work, it could still be an identifier.  */</span>
<span class="lineNum">   23094 </span>            :       if (!cp_parser_parse_definitely (parser))
<span class="lineNum">   23095 </span>            :         {
<span class="lineNum">   23096 </span>            :           if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))
<span class="lineNum">   23097 </span>            :             {
<span class="lineNum">   23098 </span>            :               type_start_token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   23099 </span>            :               id = cp_parser_identifier (parser);
<span class="lineNum">   23100 </span>            :             }
<span class="lineNum">   23101 </span><span class="lineCov">      20546 :           else</span>
<span class="lineNum">   23102 </span>            :             id = NULL_TREE;
<span class="lineNum">   23103 </span><span class="lineCov">         50 :         }</span>
<span class="lineNum">   23104 </span><span class="lineCov">        100 :       else</span>
<span class="lineNum">   23105 </span><span class="lineCov">         50 :         {</span>
<span class="lineNum">   23106 </span><span class="lineCov">         50 :           template_id_p = true;</span>
<span class="lineNum">   23107 </span><span class="lineNoCov">          0 :           ++num_templates;</span>
<span class="lineNum">   23108 </span>            :         }
<span class="lineNum">   23109 </span>            :     }
<span class="lineNum">   23110 </span>            : 
<span class="lineNum">   23111 </span><span class="lineCov">      20546 :   pop_deferring_access_checks ();</span>
<span class="lineNum">   23112 </span>            : 
<span class="lineNum">   23113 </span>            :   if (id)
<span class="lineNum">   23114 </span>            :     {
<span class="lineNum">   23115 </span>            :       cp_parser_check_for_invalid_template_id (parser, id,
<span class="lineNum">   23116 </span><span class="lineCov">      20493 :                                                class_key,</span>
<span class="lineNum">   23117 </span>            :                                                type_start_token-&gt;location);
<span class="lineNum">   23118 </span>            :     }
<span class="lineNum">   23119 </span>            :   virt_specifiers = cp_parser_virt_specifier_seq_opt (parser);
<span class="lineNum">   23120 </span>            : 
<span class="lineNum">   23121 </span>            :   /* If it's not a `:' or a `{' then we can't really be looking at a
<span class="lineNum">   23122 </span>            :      class-head, since a class-head only appears as part of a
<span class="lineNum">   23123 </span><span class="lineCov">    3263935 :      class-specifier.  We have to detect this situation before calling</span>
<span class="lineNum">   23124 </span>            :      xref_tag, since that has irreversible side-effects.  */
<span class="lineNum">   23125 </span><span class="lineCov">    6527870 :   if (!cp_parser_next_token_starts_class_definition_p (parser))</span>
<span class="lineNum">   23126 </span><span class="lineCov">    3263935 :     {</span>
<span class="lineNum">   23127 </span>            :       cp_parser_error (parser, &quot;expected %&lt;{%&gt; or %&lt;:%&gt;&quot;);
<span class="lineNum">   23128 </span>            :       type = error_mark_node;
<span class="lineNum">   23129 </span>            :       goto out;
<span class="lineNum">   23130 </span>            :     }
<span class="lineNum">   23131 </span>            : 
<span class="lineNum">   23132 </span><span class="lineCov">    3263935 :   /* At this point, we're going ahead with the class-specifier, even</span>
<span class="lineNum">   23133 </span>            :      if some other problem occurs.  */
<span class="lineNum">   23134 </span><span class="lineCov">    2201956 :   cp_parser_commit_to_tentative_parse (parser);</span>
<span class="lineNum">   23135 </span>            :   if (virt_specifiers &amp; VIRT_SPEC_OVERRIDE)
<span class="lineNum">   23136 </span><span class="lineCov">    4205070 :     {</span>
<span class="lineNum">   23137 </span><span class="lineCov">    2102535 :       cp_parser_error (parser,</span>
<span class="lineNum">   23138 </span>            :                        &quot;cannot specify %&lt;override%&gt; for a class&quot;);
<span class="lineNum">   23139 </span>            :       type = error_mark_node;
<span class="lineNum">   23140 </span>            :       goto out;
<span class="lineNum">   23141 </span>            :     }
<span class="lineNum">   23142 </span>            :   /* Issue the error about the overly-qualified name now.  */
<span class="lineNum">   23143 </span>            :   if (qualified_p)
<span class="lineNum">   23144 </span>            :     {
<span class="lineNum">   23145 </span>            :       cp_parser_error (parser,
<span class="lineNum">   23146 </span>            :                        &quot;global qualification of class name is invalid&quot;);
<span class="lineNum">   23147 </span>            :       type = error_mark_node;
<span class="lineNum">   23148 </span>            :       goto out;
<span class="lineNum">   23149 </span><span class="lineCov">    3284481 :     }</span>
<span class="lineNum">   23150 </span>            :   else if (invalid_nested_name_p)
<span class="lineNum">   23151 </span><span class="lineCov">    3284481 :     {</span>
<span class="lineNum">   23152 </span>            :       cp_parser_error (parser,
<span class="lineNum">   23153 </span><span class="lineCov">    3164564 :                        &quot;qualified name does not name a class&quot;);</span>
<span class="lineNum">   23154 </span>            :       type = error_mark_node;
<span class="lineNum">   23155 </span>            :       goto out;
<span class="lineNum">   23156 </span>            :     }
<span class="lineNum">   23157 </span><span class="lineCov">    3284481 :   else if (nested_name_specifier)</span>
<span class="lineNum">   23158 </span>            :     {
<span class="lineNum">   23159 </span>            :       tree scope;
<span class="lineNum">   23160 </span>            : 
<span class="lineNum">   23161 </span>            :       if (bad_template_keyword)
<span class="lineNum">   23162 </span>            :         /* [temp.names]: in a qualified-id formed by a class-head-name, the
<span class="lineNum">   23163 </span><span class="lineCov">    4159968 :            keyword template shall not appear at the top level.  */</span>
<span class="lineNum">   23164 </span>            :         pedwarn (bad_template_keyword-&gt;location, OPT_Wpedantic,
<span class="lineNum">   23165 </span><span class="lineCov">     875487 :                  &quot;keyword %&lt;template%&gt; not allowed in class-head-name&quot;);</span>
<span class="lineNum">   23166 </span><span class="lineCov">     875487 : </span>
<span class="lineNum">   23167 </span><span class="lineCov">     875487 :       /* Reject typedef-names in class heads.  */</span>
<span class="lineNum">   23168 </span>            :       if (!DECL_IMPLICIT_TYPEDEF_P (type))
<span class="lineNum">   23169 </span>            :         {
<span class="lineNum">   23170 </span>            :           error_at (type_start_token-&gt;location,
<span class="lineNum">   23171 </span>            :                     &quot;invalid class name in declaration of %qD&quot;,
<span class="lineNum">   23172 </span><span class="lineCov">    2408994 :                     type);</span>
<span class="lineNum">   23173 </span><span class="lineCov">    2408994 :           type = NULL_TREE;</span>
<span class="lineNum">   23174 </span>            :           goto done;
<span class="lineNum">   23175 </span><span class="lineCov">          4 :         }</span>
<span class="lineNum">   23176 </span>            : 
<span class="lineNum">   23177 </span><span class="lineCov">          4 :       /* Figure out in what scope the declaration is being placed.  */</span>
<span class="lineNum">   23178 </span><span class="lineCov">          4 :       scope = current_scope ();</span>
<span class="lineNum">   23179 </span>            :       /* If that scope does not contain the scope in which the
<span class="lineNum">   23180 </span>            :          class was originally declared, the program is invalid.  */
<span class="lineNum">   23181 </span><span class="lineCov">    2408990 :       if (scope &amp;&amp; !is_ancestor (scope, nested_name_specifier))</span>
<span class="lineNum">   23182 </span>            :         {
<span class="lineNum">   23183 </span><span class="lineCov">         12 :           if (at_namespace_scope_p ())</span>
<span class="lineNum">   23184 </span>            :             error_at (type_start_token-&gt;location,
<span class="lineNum">   23185 </span><span class="lineCov">         12 :                       &quot;declaration of %qD in namespace %qD which does not &quot;</span>
<span class="lineNum">   23186 </span><span class="lineCov">         12 :                       &quot;enclose %qD&quot;,</span>
<span class="lineNum">   23187 </span>            :                       type, scope, nested_name_specifier);
<span class="lineNum">   23188 </span><span class="lineCov">    2408978 :           else</span>
<span class="lineNum">   23189 </span>            :             error_at (type_start_token-&gt;location,
<span class="lineNum">   23190 </span><span class="lineCov">         18 :                       &quot;declaration of %qD in %qD which does not enclose %qD&quot;,</span>
<span class="lineNum">   23191 </span>            :                       type, scope, nested_name_specifier);
<span class="lineNum">   23192 </span><span class="lineCov">         18 :           type = NULL_TREE;</span>
<span class="lineNum">   23193 </span><span class="lineCov">         18 :           goto done;</span>
<span class="lineNum">   23194 </span>            :         }
<span class="lineNum">   23195 </span><span class="lineCov">    2408960 :       /* [dcl.meaning]</span>
<span class="lineNum">   23196 </span>            : 
<span class="lineNum">   23197 </span><span class="lineCov">       8044 :          A declarator-id shall not be qualified except for the</span>
<span class="lineNum">   23198 </span>            :          definition of a ... nested class outside of its class
<span class="lineNum">   23199 </span><span class="lineCov">       8044 :          ... [or] the definition or explicit instantiation of a</span>
<span class="lineNum">   23200 </span>            :          class member of a namespace outside of its namespace.  */
<span class="lineNum">   23201 </span>            :       if (scope == nested_name_specifier)
<span class="lineNum">   23202 </span><span class="lineCov">          3 :         {</span>
<span class="lineNum">   23203 </span>            :           permerror (nested_name_specifier_token_start-&gt;location,
<span class="lineNum">   23204 </span>            :                      &quot;extra qualification not allowed&quot;);
<span class="lineNum">   23205 </span>            :           nested_name_specifier = NULL_TREE;
<span class="lineNum">   23206 </span><span class="lineCov">       8044 :           num_templates = 0;</span>
<span class="lineNum">   23207 </span>            :         }
<span class="lineNum">   23208 </span><span class="lineCov">         15 :     }</span>
<span class="lineNum">   23209 </span>            :   /* An explicit-specialization must be preceded by &quot;template &lt;&gt;&quot;.  If
<span class="lineNum">   23210 </span>            :      it is not, try to recover gracefully.  */
<span class="lineNum">   23211 </span><span class="lineCov">         15 :   if (at_namespace_scope_p ()</span>
<span class="lineNum">   23212 </span><span class="lineCov">         15 :       &amp;&amp; parser-&gt;num_template_parameter_lists == 0</span>
<span class="lineNum">   23213 </span>            :       &amp;&amp; !processing_template_parmlist
<span class="lineNum">   23214 </span>            :       &amp;&amp; template_id_p)
<span class="lineNum">   23215 </span>            :     {
<span class="lineNum">   23216 </span><span class="lineCov">       8029 :       /* Build a location of this form:</span>
<span class="lineNum">   23217 </span>            :            struct typename &lt;ARGS&gt;
<span class="lineNum">   23218 </span>            :            ^~~~~~~~~~~~~~~~~~~~~~
<span class="lineNum">   23219 </span><span class="lineCov">       8029 :          with caret==start at the start token, and</span>
<span class="lineNum">   23220 </span>            :          finishing at the end of the type.  */
<span class="lineNum">   23221 </span><span class="lineCov">         18 :       location_t reported_loc</span>
<span class="lineNum">   23222 </span><span class="lineCov">          9 :         = make_location (class_head_start_location,</span>
<span class="lineNum">   23223 </span>            :                          class_head_start_location,
<span class="lineNum">   23224 </span>            :                          get_finish (type_start_token-&gt;location));
<span class="lineNum">   23225 </span>            :       rich_location richloc (line_table, reported_loc);
<span class="lineNum">   23226 </span>            :       richloc.add_fixit_insert_before (class_head_start_location,
<span class="lineNum">   23227 </span><span class="lineCov">          9 :                                        &quot;template &lt;&gt; &quot;);</span>
<span class="lineNum">   23228 </span>            :       error_at (&amp;richloc,
<span class="lineNum">   23229 </span>            :                 &quot;an explicit specialization must be preceded by&quot;
<span class="lineNum">   23230 </span><span class="lineCov">         18 :                 &quot; %&lt;template &lt;&gt;%&gt;&quot;);</span>
<span class="lineNum">   23231 </span><span class="lineCov">         18 :       invalid_explicit_specialization_p = true;</span>
<span class="lineNum">   23232 </span>            :       /* Take the same action that would have been taken by
<span class="lineNum">   23233 </span>            :          cp_parser_explicit_specialization.  */
<span class="lineNum">   23234 </span>            :       ++parser-&gt;num_template_parameter_lists;
<span class="lineNum">   23235 </span>            :       begin_specialization ();
<span class="lineNum">   23236 </span>            :     }
<span class="lineNum">   23237 </span>            :   /* There must be no &quot;return&quot; statements between this point and the
<span class="lineNum">   23238 </span>            :      end of this function; set &quot;type &quot;to the correct return value and
<span class="lineNum">   23239 </span><span class="lineCov">       8011 :      use &quot;goto done;&quot; to return.  */</span>
<span class="lineNum">   23240 </span>            :   /* Make sure that the right number of template parameters were
<span class="lineNum">   23241 </span><span class="lineCov">          6 :      present.  */</span>
<span class="lineNum">   23242 </span>            :   if (!cp_parser_check_template_parameters (parser, num_templates,
<span class="lineNum">   23243 </span><span class="lineCov">          6 :                                             template_id_p,</span>
<span class="lineNum">   23244 </span><span class="lineCov">          6 :                                             type_start_token-&gt;location,</span>
<span class="lineNum">   23245 </span>            :                                             /*declarator=*/NULL))
<span class="lineNum">   23246 </span>            :     {
<span class="lineNum">   23247 </span>            :       /* If something went wrong, there is no point in even trying to
<span class="lineNum">   23248 </span>            :          process the class-definition.  */
<span class="lineNum">   23249 </span><span class="lineCov">    2408927 :       type = NULL_TREE;</span>
<span class="lineNum">   23250 </span><span class="lineCov">    2248689 :       goto done;</span>
<span class="lineNum">   23251 </span><span class="lineCov">     456753 :     }</span>
<span class="lineNum">   23252 </span><span class="lineCov">    2865662 : </span>
<span class="lineNum">   23253 </span>            :   /* Look up the type.  */
<span class="lineNum">   23254 </span>            :   if (template_id_p)
<span class="lineNum">   23255 </span>            :     {
<span class="lineNum">   23256 </span>            :       if (TREE_CODE (id) == TEMPLATE_ID_EXPR
<span class="lineNum">   23257 </span>            :           &amp;&amp; (DECL_FUNCTION_TEMPLATE_P (TREE_OPERAND (id, 0))
<span class="lineNum">   23258 </span>            :               || TREE_CODE (TREE_OPERAND (id, 0)) == OVERLOAD))
<span class="lineNum">   23259 </span><span class="lineCov">          6 :         {</span>
<span class="lineNum">   23260 </span><span class="lineCov">          6 :           error_at (type_start_token-&gt;location,</span>
<span class="lineNum">   23261 </span>            :                     &quot;function template %qD redeclared as a class template&quot;, id);
<span class="lineNum">   23262 </span>            :           type = error_mark_node;
<span class="lineNum">   23263 </span><span class="lineCov">         12 :         }</span>
<span class="lineNum">   23264 </span><span class="lineCov">          6 :       else</span>
<span class="lineNum">   23265 </span>            :         {
<span class="lineNum">   23266 </span><span class="lineCov">          6 :           type = TREE_TYPE (id);</span>
<span class="lineNum">   23267 </span>            :           type = maybe_process_partial_specialization (type);
<span class="lineNum">   23268 </span>            : 
<span class="lineNum">   23269 </span><span class="lineCov">          6 :           /* Check the scope while we still know whether or not we had a</span>
<span class="lineNum">   23270 </span>            :              nested-name-specifier.  */
<span class="lineNum">   23271 </span>            :           if (type != error_mark_node)
<span class="lineNum">   23272 </span><span class="lineCov">          6 :             check_unqualified_spec_or_inst (type, type_start_token-&gt;location);</span>
<span class="lineNum">   23273 </span><span class="lineCov">          6 :         }</span>
<span class="lineNum">   23274 </span>            :       if (nested_name_specifier)
<span class="lineNum">   23275 </span>            :         pushed_scope = push_scope (nested_name_specifier);
<span class="lineNum">   23276 </span>            :     }
<span class="lineNum">   23277 </span>            :   else if (nested_name_specifier)
<span class="lineNum">   23278 </span>            :     {
<span class="lineNum">   23279 </span>            :       tree class_type;
<span class="lineNum">   23280 </span><span class="lineCov">    2408927 : </span>
<span class="lineNum">   23281 </span>            :       /* Given:
<span class="lineNum">   23282 </span>            : 
<span class="lineNum">   23283 </span>            :             template &lt;typename T&gt; struct S { struct T };
<span class="lineNum">   23284 </span>            :             template &lt;typename T&gt; struct S&lt;T&gt;::T { };
<span class="lineNum">   23285 </span>            : 
<span class="lineNum">   23286 </span>            :          we will get a TYPENAME_TYPE when processing the definition of
<span class="lineNum">   23287 </span><span class="lineCov">         35 :          `S::T'.  We need to resolve it to the actual type before we</span>
<span class="lineNum">   23288 </span><span class="lineCov">         35 :          try to define it.  */</span>
<span class="lineNum">   23289 </span>            :       if (TREE_CODE (TREE_TYPE (type)) == TYPENAME_TYPE)
<span class="lineNum">   23290 </span>            :         {
<span class="lineNum">   23291 </span>            :           class_type = resolve_typename_type (TREE_TYPE (type),
<span class="lineNum">   23292 </span><span class="lineCov">    2408892 :                                               /*only_current_p=*/false);</span>
<span class="lineNum">   23293 </span>            :           if (TREE_CODE (class_type) != TYPENAME_TYPE)
<span class="lineNum">   23294 </span><span class="lineCov">     977425 :             type = TYPE_NAME (class_type);</span>
<span class="lineNum">   23295 </span><span class="lineCov">     977425 :           else</span>
<span class="lineNum">   23296 </span><span class="lineNoCov">          0 :             {</span>
<span class="lineNum">   23297 </span>            :               cp_parser_error (parser, &quot;could not resolve typename type&quot;);
<span class="lineNum">   23298 </span><span class="lineNoCov">          0 :               type = error_mark_node;</span>
<span class="lineNum">   23299 </span>            :             }
<span class="lineNum">   23300 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">   23301 </span>            : 
<span class="lineNum">   23302 </span>            :       if (maybe_process_partial_specialization (TREE_TYPE (type))
<span class="lineNum">   23303 </span>            :           == error_mark_node)
<span class="lineNum">   23304 </span><span class="lineCov">     977425 :         {</span>
<span class="lineNum">   23305 </span><span class="lineCov">     977425 :           type = NULL_TREE;</span>
<span class="lineNum">   23306 </span>            :           goto done;
<span class="lineNum">   23307 </span>            :         }
<span class="lineNum">   23308 </span>            : 
<span class="lineNum">   23309 </span><span class="lineCov">     977425 :       class_type = current_class_type;</span>
<span class="lineNum">   23310 </span><span class="lineCov">     977318 :       /* Enter the scope indicated by the nested-name-specifier.  */</span>
<span class="lineNum">   23311 </span>            :       pushed_scope = push_scope (nested_name_specifier);
<span class="lineNum">   23312 </span><span class="lineCov">     977425 :       /* Get the canonical version of this type.  */</span>
<span class="lineNum">   23313 </span><span class="lineNoCov">          0 :       type = TYPE_MAIN_DECL (TREE_TYPE (type));</span>
<span class="lineNum">   23314 </span>            :       /* Call push_template_decl if it seems like we should be defining a
<span class="lineNum">   23315 </span><span class="lineCov">    1431467 :          template either from the template headers or the type we're</span>
<span class="lineNum">   23316 </span>            :          defining, so that we diagnose both extra and missing headers.  */
<span class="lineNum">   23317 </span><span class="lineCov">       7993 :       if ((PROCESSING_REAL_TEMPLATE_DECL_P ()</span>
<span class="lineNum">   23318 </span>            :            || CLASSTYPE_TEMPLATE_INFO (TREE_TYPE (type)))
<span class="lineNum">   23319 </span>            :           &amp;&amp; !CLASSTYPE_TEMPLATE_SPECIALIZATION (TREE_TYPE (type)))
<span class="lineNum">   23320 </span>            :         {
<span class="lineNum">   23321 </span>            :           type = push_template_decl (type);
<span class="lineNum">   23322 </span>            :           if (type == error_mark_node)
<span class="lineNum">   23323 </span>            :             {
<span class="lineNum">   23324 </span>            :               type = NULL_TREE;
<span class="lineNum">   23325 </span>            :               goto done;
<span class="lineNum">   23326 </span>            :             }
<span class="lineNum">   23327 </span><span class="lineCov">       7993 :         }</span>
<span class="lineNum">   23328 </span>            : 
<span class="lineNum">   23329 </span><span class="lineNoCov">          0 :       type = TREE_TYPE (type);</span>
<span class="lineNum">   23330 </span>            :       *nested_name_specifier_p = true;
<span class="lineNum">   23331 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   23332 </span><span class="lineNoCov">          0 :   else      /* The name is not a nested name.  */</span>
<span class="lineNum">   23333 </span>            :     {
<span class="lineNum">   23334 </span>            :       /* If the class was unnamed, create a dummy name.  */
<span class="lineNum">   23335 </span><span class="lineNoCov">          0 :       if (!id)</span>
<span class="lineNum">   23336 </span><span class="lineNoCov">          0 :         id = make_anon_name ();</span>
<span class="lineNum">   23337 </span>            :       tag_scope tag_scope = (parser-&gt;in_type_id_in_expr_p
<span class="lineNum">   23338 </span>            :                              ? ts_within_enclosing_non_class
<span class="lineNum">   23339 </span>            :                              : ts_current);
<span class="lineNum">   23340 </span><span class="lineCov">       7993 :       type = xref_tag (class_key, id, tag_scope,</span>
<span class="lineNum">   23341 </span><span class="lineCov">       7993 :                        parser-&gt;num_template_parameter_lists);</span>
<span class="lineNum">   23342 </span>            :     }
<span class="lineNum">   23343 </span><span class="lineCov">          5 : </span>
<span class="lineNum">   23344 </span><span class="lineCov">         20 :   /* Indicate whether this class was declared as a `class' or as a</span>
<span class="lineNum">   23345 </span>            :      `struct'.  */
<span class="lineNum">   23346 </span>            :   if (TREE_CODE (type) == RECORD_TYPE)
<span class="lineNum">   23347 </span><span class="lineCov">       7988 :     CLASSTYPE_DECLARED_CLASS (type) = (class_key == class_type);</span>
<span class="lineNum">   23348 </span>            :   cp_parser_check_class_key (class_key, type);
<span class="lineNum">   23349 </span><span class="lineCov">       7988 : </span>
<span class="lineNum">   23350 </span>            :   /* If this type was already complete, and we see another definition,
<span class="lineNum">   23351 </span><span class="lineCov">       7988 :      that's an error.  */</span>
<span class="lineNum">   23352 </span>            :   if (type != error_mark_node &amp;&amp; COMPLETE_TYPE_P (type))
<span class="lineNum">   23353 </span>            :     {
<span class="lineNum">   23354 </span>            :       error_at (type_start_token-&gt;location, &quot;redefinition of %q#T&quot;,
<span class="lineNum">   23355 </span><span class="lineCov">       7985 :                 type);</span>
<span class="lineNum">   23356 </span><span class="lineCov">       5279 :       inform (location_of (type), &quot;previous definition of %q#T&quot;,</span>
<span class="lineNum">   23357 </span><span class="lineCov">      12649 :               type);</span>
<span class="lineNum">   23358 </span>            :       type = NULL_TREE;
<span class="lineNum">   23359 </span><span class="lineCov">       3827 :       goto done;</span>
<span class="lineNum">   23360 </span><span class="lineCov">       3827 :     }</span>
<span class="lineNum">   23361 </span>            :   else if (type == error_mark_node)
<span class="lineNum">   23362 </span><span class="lineCov">         15 :     type = NULL_TREE;</span>
<span class="lineNum">   23363 </span><span class="lineCov">         15 : </span>
<span class="lineNum">   23364 </span>            :   if (type)
<span class="lineNum">   23365 </span>            :     {
<span class="lineNum">   23366 </span>            :       /* Apply attributes now, before any use of the class as a template
<span class="lineNum">   23367 </span><span class="lineCov">       7973 :          argument in its base list.  */</span>
<span class="lineNum">   23368 </span><span class="lineCov">       7973 :       cplus_decl_attributes (&amp;type, attributes, (int)ATTR_FLAG_TYPE_IN_PLACE);</span>
<span class="lineNum">   23369 </span>            :       fixup_attribute_variants (type);
<span class="lineNum">   23370 </span>            :     }
<span class="lineNum">   23371 </span>            : 
<span class="lineNum">   23372 </span>            :   /* We will have entered the scope containing the class; the names of
<span class="lineNum">   23373 </span><span class="lineCov">    1423474 :      base classes should be looked up in that context.  For example:</span>
<span class="lineNum">   23374 </span><span class="lineCov">      99408 : </span>
<span class="lineNum">   23375 </span><span class="lineCov">    2846948 :        struct A { struct B {}; struct C; };</span>
<span class="lineNum">   23376 </span><span class="lineCov">    1423474 :        struct A::C : B {};</span>
<span class="lineNum">   23377 </span>            : 
<span class="lineNum">   23378 </span><span class="lineCov">    1423474 :      is valid.  */</span>
<span class="lineNum">   23379 </span><span class="lineCov">    1423474 : </span>
<span class="lineNum">   23380 </span>            :   /* Get the list of base-classes, if there is one.  */
<span class="lineNum">   23381 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_COLON))
<span class="lineNum">   23382 </span>            :     {
<span class="lineNum">   23383 </span>            :       /* PR59482: enter the class scope so that base-specifiers are looked
<span class="lineNum">   23384 </span><span class="lineCov">    2408872 :          up correctly.  */</span>
<span class="lineNum">   23385 </span><span class="lineCov">    2349500 :       if (type)</span>
<span class="lineNum">   23386 </span><span class="lineCov">    2408872 :         pushclass (type);</span>
<span class="lineNum">   23387 </span>            :       bases = cp_parser_base_clause (parser);
<span class="lineNum">   23388 </span>            :       /* PR59482: get out of the previously pushed class scope so that the
<span class="lineNum">   23389 </span>            :          subsequent pops pop the right thing.  */
<span class="lineNum">   23390 </span><span class="lineCov">    2408872 :       if (type)</span>
<span class="lineNum">   23391 </span>            :         popclass ();
<span class="lineNum">   23392 </span><span class="lineCov">         54 :     }</span>
<span class="lineNum">   23393 </span>            :   else
<span class="lineNum">   23394 </span><span class="lineCov">         54 :     bases = NULL_TREE;</span>
<span class="lineNum">   23395 </span>            : 
<span class="lineNum">   23396 </span><span class="lineCov">         54 :   /* If we're really defining a class, process the base classes.</span>
<span class="lineNum">   23397 </span><span class="lineCov">         54 :      If they're invalid, fail.  */</span>
<span class="lineNum">   23398 </span>            :   if (type &amp;&amp; cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_BRACE))
<span class="lineNum">   23399 </span><span class="lineCov">    2408818 :     xref_basetypes (type, bases);</span>
<span class="lineNum">   23400 </span><span class="lineCov">        170 : </span>
<span class="lineNum">   23401 </span>            :  done:
<span class="lineNum">   23402 </span><span class="lineCov">    2408818 :   /* Leave the scope given by the nested-name-specifier.  We will</span>
<span class="lineNum">   23403 </span>            :      enter the class scope itself while processing the members.  */
<span class="lineNum">   23404 </span>            :   if (pushed_scope)
<span class="lineNum">   23405 </span>            :     pop_scope (pushed_scope);
<span class="lineNum">   23406 </span><span class="lineCov">    2408648 : </span>
<span class="lineNum">   23407 </span><span class="lineCov">    2408648 :   if (invalid_explicit_specialization_p)</span>
<span class="lineNum">   23408 </span>            :     {
<span class="lineNum">   23409 </span>            :       end_specialization ();
<span class="lineNum">   23410 </span>            :       --parser-&gt;num_template_parameter_lists;
<span class="lineNum">   23411 </span>            :     }
<span class="lineNum">   23412 </span>            : 
<span class="lineNum">   23413 </span>            :   if (type)
<span class="lineNum">   23414 </span>            :     DECL_SOURCE_LOCATION (TYPE_NAME (type)) = type_start_token-&gt;location;
<span class="lineNum">   23415 </span>            :   if (type &amp;&amp; (virt_specifiers &amp; VIRT_SPEC_FINAL))
<span class="lineNum">   23416 </span>            :     CLASSTYPE_FINAL (type) = 1;
<span class="lineNum">   23417 </span>            :  out:
<span class="lineNum">   23418 </span>            :   parser-&gt;colon_corrects_to_scope_p = saved_colon_corrects_to_scope_p;
<span class="lineNum">   23419 </span><span class="lineCov">    2408818 :   return type;</span>
<span class="lineNum">   23420 </span>            : }
<span class="lineNum">   23421 </span>            : 
<span class="lineNum">   23422 </span>            : /* Parse a class-key.
<span class="lineNum">   23423 </span><span class="lineCov">    1134842 : </span>
<span class="lineNum">   23424 </span><span class="lineCov">    1134833 :    class-key:</span>
<span class="lineNum">   23425 </span><span class="lineCov">    1134842 :      class</span>
<span class="lineNum">   23426 </span>            :      struct
<span class="lineNum">   23427 </span>            :      union
<span class="lineNum">   23428 </span><span class="lineCov">    1134842 : </span>
<span class="lineNum">   23429 </span><span class="lineCov">    1134833 :    Returns the kind of class-key specified, or none_type to indicate</span>
<span class="lineNum">   23430 </span>            :    error.  */
<a name="23431"><span class="lineNum">   23431 </span>            : </a>
<span class="lineNum">   23432 </span>            : static enum tag_types
<span class="lineNum">   23433 </span>            : cp_parser_class_key (cp_parser* parser)
<span class="lineNum">   23434 </span>            : {
<span class="lineNum">   23435 </span>            :   cp_token *token;
<span class="lineNum">   23436 </span><span class="lineCov">    2408818 :   enum tag_types tag_type;</span>
<span class="lineNum">   23437 </span><span class="lineCov">    2408614 : </span>
<span class="lineNum">   23438 </span>            :   /* Look for the class-key.  */
<span class="lineNum">   23439 </span><span class="lineCov">    2408960 :   token = cp_parser_require (parser, CPP_KEYWORD, RT_CLASS_KEY);</span>
<span class="lineNum">   23440 </span>            :   if (!token)
<span class="lineNum">   23441 </span>            :     return none_type;
<span class="lineNum">   23442 </span><span class="lineCov">    2408960 : </span>
<span class="lineNum">   23443 </span><span class="lineCov">       7988 :   /* Check to see if the TOKEN is a class-key.  */</span>
<span class="lineNum">   23444 </span>            :   tag_type = cp_parser_token_is_class_key (token);
<span class="lineNum">   23445 </span><span class="lineCov">    2408960 :   if (!tag_type)</span>
<span class="lineNum">   23446 </span>            :     cp_parser_error (parser, &quot;expected class-key&quot;);
<span class="lineNum">   23447 </span><span class="lineCov">          6 :   return tag_type;</span>
<span class="lineNum">   23448 </span><span class="lineCov">          6 : }</span>
<span class="lineNum">   23449 </span>            : 
<span class="lineNum">   23450 </span>            : /* Parse a type-parameter-key.
<span class="lineNum">   23451 </span><span class="lineCov">    2408960 : </span>
<span class="lineNum">   23452 </span><span class="lineCov">    2408648 :    type-parameter-key:</span>
<span class="lineNum">   23453 </span><span class="lineCov">    2408960 :      class</span>
<span class="lineNum">   23454 </span><span class="lineCov">       2528 :      typename</span>
<span class="lineNum">   23455 </span><span class="lineCov">    2406432 :  */</span>
<a name="23456"><span class="lineNum">   23456 </span><span class="lineCov">    3284481 : </span></a>
<span class="lineNum">   23457 </span><span class="lineCov">    3284481 : static void</span>
<span class="lineNum">   23458 </span>            : cp_parser_type_parameter_key (cp_parser* parser)
<span class="lineNum">   23459 </span>            : {
<span class="lineNum">   23460 </span>            :   /* Look for the type-parameter-key.  */
<span class="lineNum">   23461 </span>            :   enum tag_types tag_type = none_type;
<span class="lineNum">   23462 </span>            :   cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   23463 </span>            :   if ((tag_type = cp_parser_token_is_type_parameter_key (token)) != none_type)
<span class="lineNum">   23464 </span>            :     {
<span class="lineNum">   23465 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   23466 </span>            :       if (pedantic &amp;&amp; tag_type == typename_type &amp;&amp; cxx_dialect &lt; cxx17)
<span class="lineNum">   23467 </span>            :         /* typename is not allowed in a template template parameter
<span class="lineNum">   23468 </span>            :            by the standard until C++17.  */
<span class="lineNum">   23469 </span>            :         pedwarn (token-&gt;location, OPT_Wpedantic, 
<span class="lineNum">   23470 </span>            :                  &quot;ISO C++ forbids typename key in template template parameter;&quot;
<span class="lineNum">   23471 </span><span class="lineCov">    4159976 :                  &quot; use -std=c++17 or -std=gnu++17&quot;);</span>
<span class="lineNum">   23472 </span>            :     }
<span class="lineNum">   23473 </span><span class="lineCov">    4159976 :   else</span>
<span class="lineNum">   23474 </span><span class="lineCov">    4159976 :     cp_parser_error (parser, &quot;expected %&lt;class%&gt; or %&lt;typename%&gt;&quot;);</span>
<span class="lineNum">   23475 </span>            : 
<span class="lineNum">   23476 </span>            :   return;
<span class="lineNum">   23477 </span><span class="lineCov">    4159976 : }</span>
<span class="lineNum">   23478 </span><span class="lineCov">    4159976 : </span>
<span class="lineNum">   23479 </span>            : /* Parse an (optional) member-specification.
<span class="lineNum">   23480 </span>            : 
<span class="lineNum">   23481 </span>            :    member-specification:
<span class="lineNum">   23482 </span><span class="lineCov">    7563164 :      member-declaration member-specification [opt]</span>
<span class="lineNum">   23483 </span><span class="lineCov">    3403192 :      access-specifier : member-specification [opt]  */</span>
<a name="23484"><span class="lineNum">   23484 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   23485 </span>            : static void
<span class="lineNum">   23486 </span>            : cp_parser_member_specification_opt (cp_parser* parser)
<span class="lineNum">   23487 </span>            : {
<span class="lineNum">   23488 </span>            :   while (true)
<span class="lineNum">   23489 </span>            :     {
<span class="lineNum">   23490 </span>            :       cp_token *token;
<span class="lineNum">   23491 </span>            :       enum rid keyword;
<span class="lineNum">   23492 </span>            : 
<span class="lineNum">   23493 </span>            :       /* Peek at the next token.  */
<span class="lineNum">   23494 </span>            :       token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   23495 </span>            :       /* If it's a `}', or EOF then we've seen all the members.  */
<span class="lineNum">   23496 </span><span class="lineCov">      36630 :       if (token-&gt;type == CPP_CLOSE_BRACE</span>
<span class="lineNum">   23497 </span>            :           || token-&gt;type == CPP_EOF
<span class="lineNum">   23498 </span>            :           || token-&gt;type == CPP_PRAGMA_EOL)
<span class="lineNum">   23499 </span><span class="lineCov">      36630 :         break;</span>
<span class="lineNum">   23500 </span><span class="lineCov">      73260 : </span>
<span class="lineNum">   23501 </span><span class="lineCov">      36615 :       /* See if this token is a keyword.  */</span>
<span class="lineNum">   23502 </span>            :       keyword = token-&gt;keyword;
<span class="lineNum">   23503 </span><span class="lineCov">      36624 :       switch (keyword)</span>
<span class="lineNum">   23504 </span><span class="lineCov">      36624 :         {</span>
<span class="lineNum">   23505 </span>            :         case RID_PUBLIC:
<span class="lineNum">   23506 </span>            :         case RID_PROTECTED:
<span class="lineNum">   23507 </span><span class="lineCov">          3 :         case RID_PRIVATE:</span>
<span class="lineNum">   23508 </span>            :           /* Consume the access-specifier.  */
<span class="lineNum">   23509 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   23510 </span>            :           /* Remember which access-specifier is active.  */
<span class="lineNum">   23511 </span>            :           current_access_specifier = token-&gt;u.value;
<span class="lineNum">   23512 </span><span class="lineCov">          6 :           /* Look for the `:'.  */</span>
<span class="lineNum">   23513 </span>            :           cp_parser_require (parser, CPP_COLON, RT_COLON);
<span class="lineNum">   23514 </span><span class="lineCov">      36630 :           break;</span>
<span class="lineNum">   23515 </span>            : 
<span class="lineNum">   23516 </span>            :         default:
<span class="lineNum">   23517 </span>            :           /* Accept #pragmas at class scope.  */
<span class="lineNum">   23518 </span>            :           if (token-&gt;type == CPP_PRAGMA)
<span class="lineNum">   23519 </span>            :             {
<span class="lineNum">   23520 </span>            :               cp_parser_pragma (parser, pragma_member, NULL);
<span class="lineNum">   23521 </span>            :               break;
<span class="lineNum">   23522 </span>            :             }
<span class="lineNum">   23523 </span>            : 
<span class="lineNum">   23524 </span><span class="lineCov">    2408608 :           /* Otherwise, the next construction must be a</span>
<span class="lineNum">   23525 </span>            :              member-declaration.  */
<span class="lineNum">   23526 </span><span class="lineCov">   11355709 :           cp_parser_member_declaration (parser);</span>
<span class="lineNum">   23527 </span>            :         }
<span class="lineNum">   23528 </span><span class="lineCov">   11355709 :     }</span>
<span class="lineNum">   23529 </span><span class="lineCov">   11355709 : }</span>
<span class="lineNum">   23530 </span>            : 
<span class="lineNum">   23531 </span>            : /* Parse a member-declaration.
<span class="lineNum">   23532 </span><span class="lineCov">   22711418 : </span>
<span class="lineNum">   23533 </span>            :    member-declaration:
<span class="lineNum">   23534 </span><span class="lineCov">   22711418 :      decl-specifier-seq [opt] member-declarator-list [opt] ;</span>
<span class="lineNum">   23535 </span><span class="lineCov">   11355709 :      function-definition ; [opt]</span>
<span class="lineNum">   23536 </span><span class="lineCov">    8947107 :      :: [opt] nested-name-specifier template [opt] unqualified-id ;</span>
<span class="lineNum">   23537 </span>            :      using-declaration
<span class="lineNum">   23538 </span>            :      template-declaration
<span class="lineNum">   23539 </span>            :      alias-declaration
<span class="lineNum">   23540 </span><span class="lineCov">    8947107 : </span>
<span class="lineNum">   23541 </span><span class="lineCov">    8947107 :    member-declarator-list:</span>
<span class="lineNum">   23542 </span>            :      member-declarator
<span class="lineNum">   23543 </span><span class="lineCov">     634392 :      member-declarator-list , member-declarator</span>
<span class="lineNum">   23544 </span><span class="lineCov">     634392 : </span>
<span class="lineNum">   23545 </span><span class="lineCov">     634392 :    member-declarator:</span>
<span class="lineNum">   23546 </span>            :      declarator pure-specifier [opt]
<span class="lineNum">   23547 </span><span class="lineCov">     634392 :      declarator constant-initializer [opt]</span>
<span class="lineNum">   23548 </span>            :      identifier [opt] : constant-expression
<span class="lineNum">   23549 </span><span class="lineCov">     634392 : </span>
<span class="lineNum">   23550 </span>            :    GNU Extensions:
<span class="lineNum">   23551 </span><span class="lineCov">     634392 : </span>
<span class="lineNum">   23552 </span><span class="lineCov">     634392 :    member-declaration:</span>
<span class="lineNum">   23553 </span>            :      __extension__ member-declaration
<span class="lineNum">   23554 </span><span class="lineCov">    8312715 : </span>
<span class="lineNum">   23555 </span>            :    member-declarator:
<span class="lineNum">   23556 </span><span class="lineCov">    8312715 :      declarator attributes [opt] pure-specifier [opt]</span>
<span class="lineNum">   23557 </span>            :      declarator attributes [opt] constant-initializer [opt]
<span class="lineNum">   23558 </span><span class="lineCov">      11575 :      identifier [opt] attributes [opt] : constant-expression  </span>
<span class="lineNum">   23559 </span><span class="lineCov">      11575 : </span>
<span class="lineNum">   23560 </span>            :    C++0x Extensions:
<span class="lineNum">   23561 </span>            : 
<span class="lineNum">   23562 </span>            :    member-declaration:
<span class="lineNum">   23563 </span>            :      static_assert-declaration  */
<a name="23564"><span class="lineNum">   23564 </span><span class="lineCov">    8301140 : </span></a>
<span class="lineNum">   23565 </span>            : static void
<span class="lineNum">   23566 </span>            : cp_parser_member_declaration (cp_parser* parser)
<span class="lineNum">   23567 </span><span class="lineCov">    2408602 : {</span>
<span class="lineNum">   23568 </span>            :   cp_decl_specifier_seq decl_specifiers;
<span class="lineNum">   23569 </span>            :   tree prefix_attributes;
<span class="lineNum">   23570 </span>            :   tree decl;
<span class="lineNum">   23571 </span>            :   int declares_class_or_enum;
<span class="lineNum">   23572 </span>            :   bool friend_p;
<span class="lineNum">   23573 </span>            :   cp_token *token = NULL;
<span class="lineNum">   23574 </span>            :   cp_token *decl_spec_token_start = NULL;
<span class="lineNum">   23575 </span>            :   cp_token *initializer_token_start = NULL;
<span class="lineNum">   23576 </span>            :   int saved_pedantic;
<span class="lineNum">   23577 </span>            :   bool saved_colon_corrects_to_scope_p = parser-&gt;colon_corrects_to_scope_p;
<span class="lineNum">   23578 </span>            : 
<span class="lineNum">   23579 </span>            :   /* Check for the `__extension__' keyword.  */
<span class="lineNum">   23580 </span>            :   if (cp_parser_extension_opt (parser, &amp;saved_pedantic))
<span class="lineNum">   23581 </span>            :     {
<span class="lineNum">   23582 </span>            :       /* Recurse.  */
<span class="lineNum">   23583 </span>            :       cp_parser_member_declaration (parser);
<span class="lineNum">   23584 </span>            :       /* Restore the old value of the PEDANTIC flag.  */
<span class="lineNum">   23585 </span>            :       pedantic = saved_pedantic;
<span class="lineNum">   23586 </span>            : 
<span class="lineNum">   23587 </span>            :       return;
<span class="lineNum">   23588 </span>            :     }
<span class="lineNum">   23589 </span>            : 
<span class="lineNum">   23590 </span>            :   /* Check for a template-declaration.  */
<span class="lineNum">   23591 </span>            :   if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_TEMPLATE))
<span class="lineNum">   23592 </span>            :     {
<span class="lineNum">   23593 </span>            :       /* An explicit specialization here is an error condition, and we
<span class="lineNum">   23594 </span>            :          expect the specialization handler to detect and report this.  */
<span class="lineNum">   23595 </span>            :       if (cp_lexer_peek_nth_token (parser-&gt;lexer, 2)-&gt;type == CPP_LESS
<span class="lineNum">   23596 </span>            :           &amp;&amp; cp_lexer_peek_nth_token (parser-&gt;lexer, 3)-&gt;type == CPP_GREATER)
<span class="lineNum">   23597 </span>            :         cp_parser_explicit_specialization (parser);
<span class="lineNum">   23598 </span>            :       else
<span class="lineNum">   23599 </span>            :         cp_parser_template_declaration (parser, /*member_p=*/true);
<span class="lineNum">   23600 </span>            : 
<span class="lineNum">   23601 </span>            :       return;
<span class="lineNum">   23602 </span>            :     }
<span class="lineNum">   23603 </span>            :   /* Check for a template introduction.  */
<span class="lineNum">   23604 </span><span class="lineCov">    8320755 :   else if (cp_parser_template_declaration_after_export (parser, true))</span>
<span class="lineNum">   23605 </span>            :     return;
<span class="lineNum">   23606 </span><span class="lineCov">    8320755 : </span>
<span class="lineNum">   23607 </span><span class="lineCov">    8320755 :   /* Check for a using-declaration.  */</span>
<span class="lineNum">   23608 </span><span class="lineCov">    8320755 :   if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_USING))</span>
<span class="lineNum">   23609 </span><span class="lineCov">    8320755 :     {</span>
<span class="lineNum">   23610 </span><span class="lineCov">    8320755 :       if (cxx_dialect &lt; cxx11)</span>
<span class="lineNum">   23611 </span><span class="lineCov">    8320755 :         {</span>
<span class="lineNum">   23612 </span><span class="lineCov">    8320755 :           /* Parse the using-declaration.  */</span>
<span class="lineNum">   23613 </span><span class="lineCov">    8320755 :           cp_parser_using_declaration (parser,</span>
<span class="lineNum">   23614 </span><span class="lineCov">    8320755 :                                        /*access_declaration_p=*/false);</span>
<span class="lineNum">   23615 </span><span class="lineCov">    8320755 :           return;</span>
<span class="lineNum">   23616 </span>            :         }
<span class="lineNum">   23617 </span>            :       else
<span class="lineNum">   23618 </span><span class="lineCov">   16641510 :         {</span>
<span class="lineNum">   23619 </span>            :           tree decl;
<span class="lineNum">   23620 </span>            :           bool alias_decl_expected;
<span class="lineNum">   23621 </span><span class="lineCov">      19483 :           cp_parser_parse_tentatively (parser);</span>
<span class="lineNum">   23622 </span>            :           decl = cp_parser_alias_declaration (parser);
<span class="lineNum">   23623 </span><span class="lineCov">      19483 :           /* Note that if we actually see the '=' token after the</span>
<span class="lineNum">   23624 </span>            :              identifier, cp_parser_alias_declaration commits the
<span class="lineNum">   23625 </span><span class="lineCov">    1148652 :              tentative parse.  In that case, we really expect an</span>
<span class="lineNum">   23626 </span>            :              alias-declaration.  Otherwise, we expect a using
<span class="lineNum">   23627 </span>            :              declaration.  */
<span class="lineNum">   23628 </span>            :           alias_decl_expected =
<span class="lineNum">   23629 </span><span class="lineCov">    8301272 :             !cp_parser_uncommitted_to_tentative_parse_p (parser);</span>
<span class="lineNum">   23630 </span>            :           cp_parser_parse_definitely (parser);
<span class="lineNum">   23631 </span>            : 
<span class="lineNum">   23632 </span>            :           if (alias_decl_expected)
<span class="lineNum">   23633 </span><span class="lineCov">     879215 :             finish_member_declaration (decl);</span>
<span class="lineNum">   23634 </span><span class="lineCov">     879215 :           else</span>
<span class="lineNum">   23635 </span><span class="lineCov">         24 :             cp_parser_using_declaration (parser,</span>
<span class="lineNum">   23636 </span>            :                                          /*access_declaration_p=*/false);
<span class="lineNum">   23637 </span><span class="lineCov">     879191 :           return;</span>
<span class="lineNum">   23638 </span>            :         }
<span class="lineNum">   23639 </span><span class="lineCov">     879215 :     }</span>
<span class="lineNum">   23640 </span>            : 
<span class="lineNum">   23641 </span>            :   /* Check for @defs.  */
<span class="lineNum">   23642 </span><span class="lineCov">    7422057 :   if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_AT_DEFS))</span>
<span class="lineNum">   23643 </span>            :     {
<span class="lineNum">   23644 </span>            :       tree ivar, member;
<span class="lineNum">   23645 </span>            :       tree ivar_chains = cp_parser_objc_defs_expression (parser);
<span class="lineNum">   23646 </span><span class="lineCov">    7422054 :       ivar = ivar_chains;</span>
<span class="lineNum">   23647 </span>            :       while (ivar)
<span class="lineNum">   23648 </span><span class="lineCov">     218168 :         {</span>
<span class="lineNum">   23649 </span>            :           member = ivar;
<span class="lineNum">   23650 </span>            :           ivar = TREE_CHAIN (member);
<span class="lineNum">   23651 </span><span class="lineCov">       1230 :           TREE_CHAIN (member) = NULL_TREE;</span>
<span class="lineNum">   23652 </span>            :           finish_member_declaration (member);
<span class="lineNum">   23653 </span><span class="lineCov">       1230 :         }</span>
<span class="lineNum">   23654 </span>            :       return;
<span class="lineNum">   23655 </span>            :     }
<span class="lineNum">   23656 </span>            : 
<span class="lineNum">   23657 </span><span class="lineCov">     216938 :   /* If the next token is `static_assert' we have a static assertion.  */</span>
<span class="lineNum">   23658 </span><span class="lineCov">     216938 :   if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_STATIC_ASSERT))</span>
<span class="lineNum">   23659 </span><span class="lineCov">     216938 :     {</span>
<span class="lineNum">   23660 </span><span class="lineCov">     216938 :       cp_parser_static_assert (parser, /*member_p=*/true);</span>
<span class="lineNum">   23661 </span>            :       return;
<span class="lineNum">   23662 </span>            :     }
<span class="lineNum">   23663 </span>            : 
<span class="lineNum">   23664 </span>            :   parser-&gt;colon_corrects_to_scope_p = false;
<span class="lineNum">   23665 </span>            : 
<span class="lineNum">   23666 </span><span class="lineCov">     433876 :   if (cp_parser_using_declaration (parser, /*access_declaration=*/true))</span>
<span class="lineNum">   23667 </span><span class="lineCov">     433876 :       goto out;</span>
<span class="lineNum">   23668 </span><span class="lineCov">     216938 : </span>
<span class="lineNum">   23669 </span>            :   /* Parse the decl-specifier-seq.  */
<span class="lineNum">   23670 </span><span class="lineCov">     216938 :   decl_spec_token_start = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   23671 </span><span class="lineCov">     189368 :   cp_parser_decl_specifier_seq (parser,</span>
<span class="lineNum">   23672 </span>            :                                 CP_PARSER_FLAGS_OPTIONAL,
<span class="lineNum">   23673 </span><span class="lineCov">      27570 :                                 &amp;decl_specifiers,</span>
<span class="lineNum">   23674 </span>            :                                 &amp;declares_class_or_enum);
<span class="lineNum">   23675 </span><span class="lineCov">     216938 :   /* Check for an invalid type-name.  */</span>
<span class="lineNum">   23676 </span>            :   if (!decl_specifiers.any_type_specifiers_p
<span class="lineNum">   23677 </span>            :       &amp;&amp; cp_parser_parse_and_diagnose_invalid_type_name (parser))
<span class="lineNum">   23678 </span>            :     goto out;
<span class="lineNum">   23679 </span>            :   /* If there is no declarator, then the decl-specifier-seq should
<span class="lineNum">   23680 </span><span class="lineCov">    7203886 :      specify a type.  */</span>
<span class="lineNum">   23681 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_SEMICOLON))
<span class="lineNum">   23682 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   23683 </span><span class="lineNoCov">          0 :       /* If there was no decl-specifier-seq, and the next token is a</span>
<span class="lineNum">   23684 </span><span class="lineNoCov">          0 :          `;', then we have something like:</span>
<span class="lineNum">   23685 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   23686 </span>            :            struct S { ; };
<span class="lineNum">   23687 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   23688 </span><span class="lineNoCov">          0 :          [class.mem]</span>
<span class="lineNum">   23689 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   23690 </span><span class="lineNoCov">          0 :          Each member-declaration shall declare at least one member</span>
<span class="lineNum">   23691 </span>            :          name of the class.  */
<span class="lineNum">   23692 </span>            :       if (!decl_specifiers.any_specifiers_p)
<span class="lineNum">   23693 </span>            :         {
<span class="lineNum">   23694 </span>            :           cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   23695 </span>            :           if (!in_system_header_at (token-&gt;location))
<span class="lineNum">   23696 </span><span class="lineCov">    7203886 :             {</span>
<span class="lineNum">   23697 </span>            :               gcc_rich_location richloc (token-&gt;location);
<span class="lineNum">   23698 </span><span class="lineCov">      31783 :               richloc.add_fixit_remove ();</span>
<span class="lineNum">   23699 </span><span class="lineCov">      31783 :               pedwarn (&amp;richloc, OPT_Wpedantic, &quot;extra %&lt;;%&gt;&quot;);</span>
<span class="lineNum">   23700 </span>            :             }
<span class="lineNum">   23701 </span>            :         }
<span class="lineNum">   23702 </span><span class="lineCov">    7172103 :       else</span>
<span class="lineNum">   23703 </span>            :         {
<span class="lineNum">   23704 </span><span class="lineCov">    7172103 :           tree type;</span>
<span class="lineNum">   23705 </span>            : 
<span class="lineNum">   23706 </span>            :           /* See if this declaration is a friend.  */
<span class="lineNum">   23707 </span>            :           friend_p = cp_parser_friend_p (&amp;decl_specifiers);
<span class="lineNum">   23708 </span><span class="lineCov">   14343946 :           /* If there were decl-specifiers, check to see if there was</span>
<span class="lineNum">   23709 </span><span class="lineCov">    7171973 :              a class-declaration.  */</span>
<span class="lineNum">   23710 </span>            :           type = check_tag_decl (&amp;decl_specifiers,
<span class="lineNum">   23711 </span>            :                                  /*explicit_type_instantiation_p=*/false);
<span class="lineNum">   23712 </span>            :           /* Nested classes have already been added to the class, but
<span class="lineNum">   23713 </span>            :              a `friend' needs to be explicitly registered.  */
<span class="lineNum">   23714 </span><span class="lineCov">    7171973 :           if (friend_p)</span>
<span class="lineNum">   23715 </span><span class="lineCov">    7171973 :             {</span>
<span class="lineNum">   23716 </span>            :               /* If the `friend' keyword was present, the friend must
<span class="lineNum">   23717 </span>            :                  be introduced with a class-key.  */
<span class="lineNum">   23718 </span>            :                if (!declares_class_or_enum &amp;&amp; cxx_dialect &lt; cxx11)
<span class="lineNum">   23719 </span><span class="lineCov">    7171814 :                  pedwarn (decl_spec_token_start-&gt;location, OPT_Wpedantic,</span>
<span class="lineNum">   23720 </span>            :                           &quot;in C++03 a class-key must be used &quot;
<span class="lineNum">   23721 </span>            :                           &quot;when declaring a friend&quot;);
<span class="lineNum">   23722 </span>            :                /* In this case:
<span class="lineNum">   23723 </span>            : 
<span class="lineNum">   23724 </span>            :                     template &lt;typename T&gt; struct A {
<span class="lineNum">   23725 </span>            :                       friend struct A&lt;T&gt;::B;
<span class="lineNum">   23726 </span>            :                     };
<span class="lineNum">   23727 </span>            : 
<span class="lineNum">   23728 </span>            :                   A&lt;T&gt;::B will be represented by a TYPENAME_TYPE, and
<span class="lineNum">   23729 </span>            :                   therefore not recognized by check_tag_decl.  */
<span class="lineNum">   23730 </span><span class="lineCov">     188982 :                if (!type)</span>
<span class="lineNum">   23731 </span>            :                  {
<span class="lineNum">   23732 </span><span class="lineCov">         50 :                    type = decl_specifiers.type;</span>
<span class="lineNum">   23733 </span><span class="lineCov">         25 :                    if (type &amp;&amp; TREE_CODE (type) == TYPE_DECL)</span>
<span class="lineNum">   23734 </span>            :                      type = TREE_TYPE (type);
<span class="lineNum">   23735 </span><span class="lineCov">         50 :                  }</span>
<span class="lineNum">   23736 </span><span class="lineCov">         25 :                if (!type || !TYPE_P (type))</span>
<span class="lineNum">   23737 </span><span class="lineCov">         25 :                  error_at (decl_spec_token_start-&gt;location,</span>
<span class="lineNum">   23738 </span>            :                            &quot;friend declaration does not name a class or &quot;
<span class="lineNum">   23739 </span>            :                            &quot;function&quot;);
<span class="lineNum">   23740 </span>            :                else
<span class="lineNum">   23741 </span>            :                  make_friend_class (current_class_type, type,
<span class="lineNum">   23742 </span><span class="lineCov">     188957 :                                     /*complain=*/true);</span>
<span class="lineNum">   23743 </span>            :             }
<span class="lineNum">   23744 </span>            :           /* If there is no TYPE, an error message will already have
<span class="lineNum">   23745 </span><span class="lineCov">     377914 :              been issued.  */</span>
<span class="lineNum">   23746 </span>            :           else if (!type || type == error_mark_node)
<span class="lineNum">   23747 </span>            :             ;
<span class="lineNum">   23748 </span><span class="lineCov">     188957 :           /* An anonymous aggregate has to be handled specially; such</span>
<span class="lineNum">   23749 </span>            :              a declaration really declares a data member (with a
<span class="lineNum">   23750 </span>            :              particular type), as opposed to a nested class.  */
<span class="lineNum">   23751 </span>            :           else if (ANON_AGGR_TYPE_P (type))
<span class="lineNum">   23752 </span><span class="lineCov">     188957 :             {</span>
<span class="lineNum">   23753 </span>            :               /* C++11 9.5/6.  */
<span class="lineNum">   23754 </span>            :               if (decl_specifiers.storage_class != sc_none)
<span class="lineNum">   23755 </span>            :                 error_at (decl_spec_token_start-&gt;location,
<span class="lineNum">   23756 </span><span class="lineCov">      30758 :                           &quot;a storage class on an anonymous aggregate &quot;</span>
<span class="lineNum">   23757 </span><span class="lineCov">          6 :                           &quot;in class scope is not allowed&quot;);</span>
<span class="lineNum">   23758 </span>            : 
<span class="lineNum">   23759 </span>            :               /* Remove constructors and such from TYPE, now that we
<span class="lineNum">   23760 </span>            :                  know it is an anonymous aggregate.  */
<span class="lineNum">   23761 </span>            :               fixup_anonymous_aggr (type);
<span class="lineNum">   23762 </span>            :               /* And make the corresponding data member.  */
<span class="lineNum">   23763 </span>            :               decl = build_decl (decl_spec_token_start-&gt;location,
<span class="lineNum">   23764 </span>            :                                  FIELD_DECL, NULL_TREE, type);
<span class="lineNum">   23765 </span>            :               /* Add it to the class.  */
<span class="lineNum">   23766 </span>            :               finish_member_declaration (decl);
<span class="lineNum">   23767 </span>            :             }
<span class="lineNum">   23768 </span><span class="lineCov">      30758 :           else</span>
<span class="lineNum">   23769 </span>            :             cp_parser_check_access_in_redeclaration
<span class="lineNum">   23770 </span><span class="lineCov">        567 :                                               (TYPE_NAME (type),</span>
<span class="lineNum">   23771 </span><span class="lineCov">        567 :                                                decl_spec_token_start-&gt;location);</span>
<span class="lineNum">   23772 </span><span class="lineCov">        530 :         }</span>
<span class="lineNum">   23773 </span>            :     }
<span class="lineNum">   23774 </span><span class="lineCov">      30758 :   else</span>
<span class="lineNum">   23775 </span><span class="lineCov">         26 :     {</span>
<span class="lineNum">   23776 </span>            :       bool assume_semicolon = false;
<span class="lineNum">   23777 </span>            : 
<span class="lineNum">   23778 </span>            :       /* Clear attributes from the decl_specifiers but keep them
<span class="lineNum">   23779 </span><span class="lineCov">      30732 :          around as prefix attributes that apply them to the entity</span>
<span class="lineNum">   23780 </span>            :          being declared.  */
<span class="lineNum">   23781 </span>            :       prefix_attributes = decl_specifiers.attributes;
<span class="lineNum">   23782 </span>            :       decl_specifiers.attributes = NULL_TREE;
<span class="lineNum">   23783 </span>            : 
<span class="lineNum">   23784 </span><span class="lineCov">     158199 :       /* See if these declarations will be friends.  */</span>
<span class="lineNum">   23785 </span>            :       friend_p = cp_parser_friend_p (&amp;decl_specifiers);
<span class="lineNum">   23786 </span>            : 
<span class="lineNum">   23787 </span>            :       /* Keep going until we hit the `;' at the end of the
<span class="lineNum">   23788 </span>            :          declaration.  */
<span class="lineNum">   23789 </span><span class="lineCov">     158105 :       while (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_SEMICOLON))</span>
<span class="lineNum">   23790 </span>            :         {
<span class="lineNum">   23791 </span>            :           tree attributes = NULL_TREE;
<span class="lineNum">   23792 </span><span class="lineCov">      12706 :           tree first_attribute;</span>
<span class="lineNum">   23793 </span><span class="lineCov">         13 :           tree initializer;</span>
<span class="lineNum">   23794 </span>            :           bool named_bitfld = false;
<span class="lineNum">   23795 </span>            : 
<span class="lineNum">   23796 </span>            :           /* Peek at the next token.  */
<span class="lineNum">   23797 </span>            :           token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   23798 </span>            : 
<span class="lineNum">   23799 </span><span class="lineCov">      12706 :           /* The following code wants to know early if it is a bit-field</span>
<span class="lineNum">   23800 </span>            :              or some other declaration.  Attributes can appear before
<span class="lineNum">   23801 </span><span class="lineCov">      12706 :              the `:' token.  Skip over them without consuming any tokens</span>
<span class="lineNum">   23802 </span>            :              to peek if they are followed by `:'.  */
<span class="lineNum">   23803 </span>            :           if (cp_next_tokens_can_be_attribute_p (parser)
<span class="lineNum">   23804 </span><span class="lineCov">      12706 :               || (token-&gt;type == CPP_NAME</span>
<span class="lineNum">   23805 </span>            :                   &amp;&amp; cp_nth_tokens_can_be_attribute_p (parser, 2)
<span class="lineNum">   23806 </span>            :                   &amp;&amp; (named_bitfld = true)))
<span class="lineNum">   23807 </span><span class="lineCov">     145399 :             {</span>
<span class="lineNum">   23808 </span><span class="lineCov">     145399 :               size_t n</span>
<span class="lineNum">   23809 </span>            :                 = cp_parser_skip_attributes_opt (parser, 1 + named_bitfld);
<span class="lineNum">   23810 </span>            :               token = cp_lexer_peek_nth_token (parser-&gt;lexer, n);
<span class="lineNum">   23811 </span>            :             }
<span class="lineNum">   23812 </span>            : 
<span class="lineNum">   23813 </span>            :           /* Check for a bitfield declaration.  */
<span class="lineNum">   23814 </span><span class="lineCov">    6982832 :           if (token-&gt;type == CPP_COLON</span>
<span class="lineNum">   23815 </span>            :               || (token-&gt;type == CPP_NAME
<span class="lineNum">   23816 </span>            :                   &amp;&amp; token == cp_lexer_peek_token (parser-&gt;lexer)
<span class="lineNum">   23817 </span>            :                   &amp;&amp; cp_lexer_nth_token_is (parser-&gt;lexer, 2, CPP_COLON)
<span class="lineNum">   23818 </span>            :                   &amp;&amp; (named_bitfld = true)))
<span class="lineNum">   23819 </span><span class="lineCov">    6982832 :             {</span>
<span class="lineNum">   23820 </span><span class="lineCov">    6982832 :               tree identifier;</span>
<span class="lineNum">   23821 </span>            :               tree width;
<span class="lineNum">   23822 </span>            :               tree late_attributes = NULL_TREE;
<span class="lineNum">   23823 </span><span class="lineCov">   13965664 : </span>
<span class="lineNum">   23824 </span>            :               if (named_bitfld)
<span class="lineNum">   23825 </span>            :                 identifier = cp_parser_identifier (parser);
<span class="lineNum">   23826 </span>            :               else
<span class="lineNum">   23827 </span><span class="lineCov">   11467993 :                 identifier = NULL_TREE;</span>
<span class="lineNum">   23828 </span>            : 
<span class="lineNum">   23829 </span><span class="lineCov">    6990469 :               /* Look for attributes that apply to the bitfield.  */</span>
<span class="lineNum">   23830 </span><span class="lineCov">    6990469 :               attributes = cp_parser_attributes_opt (parser);</span>
<span class="lineNum">   23831 </span><span class="lineCov">    6990469 : </span>
<span class="lineNum">   23832 </span><span class="lineCov">    6990469 :               /* Consume the `:' token.  */</span>
<span class="lineNum">   23833 </span>            :               cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   23834 </span>            : 
<span class="lineNum">   23835 </span><span class="lineCov">   13980938 :               /* Get the width of the bitfield.  */</span>
<span class="lineNum">   23836 </span>            :               width = cp_parser_constant_expression (parser, false, NULL,
<span class="lineNum">   23837 </span>            :                                                      cxx_dialect &gt;= cxx11);
<span class="lineNum">   23838 </span>            : 
<span class="lineNum">   23839 </span>            :               /* In C++2A and as extension for C++11 and above we allow
<span class="lineNum">   23840 </span>            :                  default member initializers for bit-fields.  */
<span class="lineNum">   23841 </span><span class="lineCov">    6990469 :               initializer = NULL_TREE;</span>
<span class="lineNum">   23842 </span><span class="lineCov">    6990469 :               if (cxx_dialect &gt;= cxx11</span>
<span class="lineNum">   23843 </span><span class="lineCov">    5415761 :                   &amp;&amp; (cp_lexer_next_token_is (parser-&gt;lexer, CPP_EQ)</span>
<span class="lineNum">   23844 </span>            :                       || cp_lexer_next_token_is (parser-&gt;lexer,
<span class="lineNum">   23845 </span>            :                                                  CPP_OPEN_BRACE)))
<span class="lineNum">   23846 </span><span class="lineCov">       7475 :                 {</span>
<span class="lineNum">   23847 </span><span class="lineCov">       7475 :                   location_t loc</span>
<span class="lineNum">   23848 </span><span class="lineCov">       7475 :                     = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;</span>
<span class="lineNum">   23849 </span>            :                   if (cxx_dialect &lt; cxx2a
<span class="lineNum">   23850 </span>            :                       &amp;&amp; !in_system_header_at (loc)
<span class="lineNum">   23851 </span>            :                       &amp;&amp; identifier != NULL_TREE)
<span class="lineNum">   23852 </span><span class="lineCov">    6990469 :                     pedwarn (loc, 0,</span>
<span class="lineNum">   23853 </span><span class="lineCov">    6990469 :                              &quot;default member initializers for bit-fields &quot;</span>
<span class="lineNum">   23854 </span><span class="lineCov">    5408286 :                              &quot;only available with -std=c++2a or &quot;</span>
<span class="lineNum">   23855 </span><span class="lineCov">    5408286 :                              &quot;-std=gnu++2a&quot;);</span>
<span class="lineNum">   23856 </span>            : 
<span class="lineNum">   23857 </span>            :                   initializer = cp_parser_save_nsdmi (parser);
<span class="lineNum">   23858 </span><span class="lineCov">      36604 :                   if (identifier == NULL_TREE)</span>
<span class="lineNum">   23859 </span><span class="lineCov">      36604 :                     {</span>
<span class="lineNum">   23860 </span><span class="lineCov">      36604 :                       error_at (loc, &quot;default member initializer for &quot;</span>
<span class="lineNum">   23861 </span>            :                                      &quot;unnamed bit-field&quot;);
<span class="lineNum">   23862 </span><span class="lineCov">      36604 :                       initializer = NULL_TREE;</span>
<span class="lineNum">   23863 </span><span class="lineCov">      12934 :                     }</span>
<span class="lineNum">   23864 </span>            :                 }
<span class="lineNum">   23865 </span>            :               else
<span class="lineNum">   23866 </span>            :                 { 
<span class="lineNum">   23867 </span>            :                   /* Look for attributes that apply to the bitfield after
<span class="lineNum">   23868 </span><span class="lineCov">      36604 :                      the `:' token and width.  This is where GCC used to</span>
<span class="lineNum">   23869 </span>            :                      parse attributes in the past, pedwarn if there is
<span class="lineNum">   23870 </span>            :                      a std attribute.  */
<span class="lineNum">   23871 </span><span class="lineCov">      36604 :                   if (cp_next_tokens_can_be_std_attribute_p (parser))</span>
<span class="lineNum">   23872 </span>            :                     pedwarn (input_location, OPT_Wpedantic,
<span class="lineNum">   23873 </span>            :                              &quot;ISO C++ allows bit-field attributes only &quot;
<span class="lineNum">   23874 </span><span class="lineCov">      73208 :                              &quot;before the %&lt;:%&gt; token&quot;);</span>
<span class="lineNum">   23875 </span><span class="lineCov">      36604 : </span>
<span class="lineNum">   23876 </span>            :                   late_attributes = cp_parser_attributes_opt (parser);
<span class="lineNum">   23877 </span>            :                 }
<span class="lineNum">   23878 </span>            : 
<span class="lineNum">   23879 </span><span class="lineCov">      36604 :               attributes = attr_chainon (attributes, late_attributes);</span>
<span class="lineNum">   23880 </span><span class="lineCov">      36604 : </span>
<span class="lineNum">   23881 </span><span class="lineCov">      36604 :               /* Remember which attributes are prefix attributes and</span>
<span class="lineNum">   23882 </span><span class="lineCov">      33583 :                  which are not.  */</span>
<span class="lineNum">   23883 </span>            :               first_attribute = attributes;
<span class="lineNum">   23884 </span>            :               /* Combine the attributes.  */
<span class="lineNum">   23885 </span><span class="lineCov">         56 :               attributes = attr_chainon (prefix_attributes, attributes);</span>
<span class="lineNum">   23886 </span><span class="lineCov">        112 : </span>
<span class="lineNum">   23887 </span><span class="lineCov">         56 :               /* Create the bitfield declaration.  */</span>
<span class="lineNum">   23888 </span><span class="lineCov">         56 :               decl = grokbitfield (identifier</span>
<span class="lineNum">   23889 </span><span class="lineCov">        112 :                                    ? make_id_declarator (NULL_TREE,</span>
<span class="lineNum">   23890 </span><span class="lineCov">         44 :                                                          identifier,</span>
<span class="lineNum">   23891 </span>            :                                                          sfk_none)
<span class="lineNum">   23892 </span>            :                                    : NULL,
<span class="lineNum">   23893 </span>            :                                    &amp;decl_specifiers,
<span class="lineNum">   23894 </span>            :                                    width, initializer,
<span class="lineNum">   23895 </span><span class="lineCov">        112 :                                    attributes);</span>
<span class="lineNum">   23896 </span><span class="lineCov">         56 :             }</span>
<span class="lineNum">   23897 </span>            :           else
<span class="lineNum">   23898 </span><span class="lineCov">         12 :             {</span>
<span class="lineNum">   23899 </span>            :               cp_declarator *declarator;
<span class="lineNum">   23900 </span><span class="lineCov">         12 :               tree asm_specification;</span>
<span class="lineNum">   23901 </span>            :               int ctor_dtor_or_conv_p;
<span class="lineNum">   23902 </span>            : 
<span class="lineNum">   23903 </span>            :               /* Parse the declarator.  */
<span class="lineNum">   23904 </span>            :               declarator
<span class="lineNum">   23905 </span>            :                 = cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,
<span class="lineNum">   23906 </span>            :                                         &amp;ctor_dtor_or_conv_p,
<span class="lineNum">   23907 </span>            :                                         /*parenthesized_p=*/NULL,
<span class="lineNum">   23908 </span>            :                                         /*member_p=*/true,
<span class="lineNum">   23909 </span><span class="lineCov">      36548 :                                         friend_p);</span>
<span class="lineNum">   23910 </span><span class="lineCov">          4 : </span>
<span class="lineNum">   23911 </span>            :               /* If something went wrong parsing the declarator, make sure
<span class="lineNum">   23912 </span>            :                  that we at least consume some tokens.  */
<span class="lineNum">   23913 </span>            :               if (declarator == cp_error_declarator)
<span class="lineNum">   23914 </span><span class="lineCov">      36548 :                 {</span>
<span class="lineNum">   23915 </span>            :                   /* Skip to the end of the statement.  */
<span class="lineNum">   23916 </span>            :                   cp_parser_skip_to_end_of_statement (parser);
<span class="lineNum">   23917 </span><span class="lineCov">      36604 :                   /* If the next token is not a semicolon, that is</span>
<span class="lineNum">   23918 </span>            :                      probably because we just skipped over the body of
<span class="lineNum">   23919 </span>            :                      a function.  So, we consume a semicolon if
<span class="lineNum">   23920 </span>            :                      present, but do not issue an error message if it
<span class="lineNum">   23921 </span><span class="lineCov">      36604 :                      is not present.  */</span>
<span class="lineNum">   23922 </span>            :                   if (cp_lexer_next_token_is (parser-&gt;lexer,
<span class="lineNum">   23923 </span><span class="lineCov">      36604 :                                               CPP_SEMICOLON))</span>
<span class="lineNum">   23924 </span>            :                     cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   23925 </span>            :                   goto out;
<span class="lineNum">   23926 </span><span class="lineCov">      49538 :                 }</span>
<span class="lineNum">   23927 </span><span class="lineCov">      12934 : </span>
<span class="lineNum">   23928 </span>            :               if (declares_class_or_enum &amp; 2)
<span class="lineNum">   23929 </span>            :                 cp_parser_check_for_definition_in_return_type
<span class="lineNum">   23930 </span>            :                                             (declarator, decl_specifiers.type,
<span class="lineNum">   23931 </span>            :                                              decl_specifiers.locations[ds_type_spec]);
<span class="lineNum">   23932 </span>            : 
<span class="lineNum">   23933 </span>            :               /* Look for an asm-specification.  */
<span class="lineNum">   23934 </span>            :               asm_specification = cp_parser_asm_specification_opt (parser);
<span class="lineNum">   23935 </span>            :               /* Look for attributes that apply to the declaration.  */
<span class="lineNum">   23936 </span>            :               attributes = cp_parser_attributes_opt (parser);
<span class="lineNum">   23937 </span><span class="lineCov">    6953865 :               /* Remember which attributes are prefix attributes and</span>
<span class="lineNum">   23938 </span><span class="lineCov">    6953865 :                  which are not.  */</span>
<span class="lineNum">   23939 </span><span class="lineCov">    6953865 :               first_attribute = attributes;</span>
<span class="lineNum">   23940 </span>            :               /* Combine the attributes.  */
<span class="lineNum">   23941 </span>            :               attributes = attr_chainon (prefix_attributes, attributes);
<span class="lineNum">   23942 </span><span class="lineCov">    6953865 : </span>
<span class="lineNum">   23943 </span><span class="lineCov">    6953865 :               /* If it's an `=', then we have a constant-initializer or a</span>
<span class="lineNum">   23944 </span>            :                  pure-specifier.  It is not correct to parse the
<span class="lineNum">   23945 </span>            :                  initializer before registering the member declaration
<span class="lineNum">   23946 </span>            :                  since the member declaration should be in scope while
<span class="lineNum">   23947 </span>            :                  its initializer is processed.  However, the rest of the
<span class="lineNum">   23948 </span>            :                  front end does not yet provide an interface that allows
<span class="lineNum">   23949 </span>            :                  us to handle this correctly.  */
<span class="lineNum">   23950 </span>            :               if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_EQ))
<span class="lineNum">   23951 </span><span class="lineCov">    6953865 :                 {</span>
<span class="lineNum">   23952 </span>            :                   /* In [class.mem]:
<span class="lineNum">   23953 </span>            : 
<span class="lineNum">   23954 </span><span class="lineCov">        158 :                      A pure-specifier shall be used only in the declaration of</span>
<span class="lineNum">   23955 </span>            :                      a virtual function.
<span class="lineNum">   23956 </span>            : 
<span class="lineNum">   23957 </span>            :                      A member-declarator can contain a constant-initializer
<span class="lineNum">   23958 </span>            :                      only if it declares a static member of integral or
<span class="lineNum">   23959 </span>            :                      enumeration type.
<span class="lineNum">   23960 </span><span class="lineCov">        158 : </span>
<span class="lineNum">   23961 </span>            :                      Therefore, if the DECLARATOR is for a function, we look
<span class="lineNum">   23962 </span><span class="lineCov">        111 :                      for a pure-specifier; otherwise, we look for a</span>
<span class="lineNum">   23963 </span><span class="lineCov">    2505205 :                      constant-initializer.  When we call `grokfield', it will</span>
<span class="lineNum">   23964 </span>            :                      perform more stringent semantics checks.  */
<span class="lineNum">   23965 </span>            :                   initializer_token_start = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   23966 </span><span class="lineCov">    6953707 :                   if (function_declarator_p (declarator)</span>
<span class="lineNum">   23967 </span><span class="lineCov">      28049 :                       || (decl_specifiers.type</span>
<span class="lineNum">   23968 </span><span class="lineCov">      28049 :                           &amp;&amp; TREE_CODE (decl_specifiers.type) == TYPE_DECL</span>
<span class="lineNum">   23969 </span>            :                           &amp;&amp; declarator-&gt;kind == cdk_id
<span class="lineNum">   23970 </span>            :                           &amp;&amp; (TREE_CODE (TREE_TYPE (decl_specifiers.type))
<span class="lineNum">   23971 </span>            :                               == FUNCTION_TYPE)))
<span class="lineNum">   23972 </span><span class="lineCov">    6953707 :                     initializer = cp_parser_pure_specifier (parser);</span>
<span class="lineNum">   23973 </span>            :                   else if (decl_specifiers.storage_class != sc_static)
<span class="lineNum">   23974 </span><span class="lineCov">    6953707 :                     initializer = cp_parser_save_nsdmi (parser);</span>
<span class="lineNum">   23975 </span>            :                   else if (cxx_dialect &gt;= cxx11)
<span class="lineNum">   23976 </span>            :                     {
<span class="lineNum">   23977 </span><span class="lineCov">    6953707 :                       bool nonconst;</span>
<span class="lineNum">   23978 </span>            :                       /* Don't require a constant rvalue in C++11, since we
<span class="lineNum">   23979 </span><span class="lineCov">    6953707 :                          might want a reference constant.  We'll enforce</span>
<span class="lineNum">   23980 </span>            :                          constancy later.  */
<span class="lineNum">   23981 </span>            :                       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   23982 </span>            :                       /* Parse the initializer.  */
<span class="lineNum">   23983 </span>            :                       initializer = cp_parser_initializer_clause (parser,
<span class="lineNum">   23984 </span>            :                                                                   &amp;nonconst);
<span class="lineNum">   23985 </span>            :                     }
<span class="lineNum">   23986 </span>            :                   else
<span class="lineNum">   23987 </span>            :                     /* Parse the initializer.  */
<span class="lineNum">   23988 </span><span class="lineCov">    6953707 :                     initializer = cp_parser_constant_initializer (parser);</span>
<span class="lineNum">   23989 </span>            :                 }
<span class="lineNum">   23990 </span>            :               else if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_BRACE)
<span class="lineNum">   23991 </span>            :                        &amp;&amp; !function_declarator_p (declarator))
<span class="lineNum">   23992 </span>            :                 {
<span class="lineNum">   23993 </span>            :                   bool x;
<span class="lineNum">   23994 </span>            :                   if (decl_specifiers.storage_class != sc_static)
<span class="lineNum">   23995 </span>            :                     initializer = cp_parser_save_nsdmi (parser);
<span class="lineNum">   23996 </span>            :                   else
<span class="lineNum">   23997 </span>            :                     initializer = cp_parser_initializer (parser, &amp;x, &amp;x);
<span class="lineNum">   23998 </span>            :                 }
<span class="lineNum">   23999 </span>            :               /* Otherwise, there is no initializer.  */
<span class="lineNum">   24000 </span>            :               else
<span class="lineNum">   24001 </span>            :                 initializer = NULL_TREE;
<span class="lineNum">   24002 </span>            : 
<span class="lineNum">   24003 </span><span class="lineCov">    1954162 :               /* See if we are probably looking at a function</span>
<span class="lineNum">   24004 </span><span class="lineCov">     977081 :                  definition.  We are certainly not looking at a</span>
<span class="lineNum">   24005 </span><span class="lineCov">     977081 :                  member-declarator.  Calling `grokfield' has</span>
<span class="lineNum">   24006 </span><span class="lineCov">     696334 :                  side-effects, so we must not do it unless we are sure</span>
<span class="lineNum">   24007 </span><span class="lineCov">     178578 :                  that we are looking at a member-declarator.  */</span>
<span class="lineNum">   24008 </span><span class="lineCov">     178016 :               if (cp_parser_token_starts_function_definition_p</span>
<span class="lineNum">   24009 </span>            :                   (cp_lexer_peek_token (parser-&gt;lexer)))
<span class="lineNum">   24010 </span><span class="lineCov">     280603 :                 {</span>
<span class="lineNum">   24011 </span><span class="lineCov">     696478 :                   /* The grammar does not allow a pure-specifier to be</span>
<span class="lineNum">   24012 </span><span class="lineCov">      15978 :                      used when a member function is defined.  (It is</span>
<span class="lineNum">   24013 </span><span class="lineCov">     688489 :                      possible that this fact is an oversight in the</span>
<span class="lineNum">   24014 </span>            :                      standard, since a pure function may be defined
<span class="lineNum">   24015 </span><span class="lineCov">     672432 :                      outside of the class-specifier.  */</span>
<span class="lineNum">   24016 </span>            :                   if (initializer &amp;&amp; initializer_token_start)
<span class="lineNum">   24017 </span>            :                     error_at (initializer_token_start-&gt;location,
<span class="lineNum">   24018 </span>            :                               &quot;pure-specifier on function-definition&quot;);
<span class="lineNum">   24019 </span><span class="lineCov">     672432 :                   decl = cp_parser_save_member_function_body (parser,</span>
<span class="lineNum">   24020 </span>            :                                                               &amp;decl_specifiers,
<span class="lineNum">   24021 </span><span class="lineCov">    1344864 :                                                               declarator,</span>
<span class="lineNum">   24022 </span><span class="lineCov">     672432 :                                                               attributes);</span>
<span class="lineNum">   24023 </span>            :                   if (parser-&gt;fully_implicit_function_template_p)
<span class="lineNum">   24024 </span>            :                     decl = finish_fully_implicit_template (parser, decl);
<span class="lineNum">   24025 </span>            :                   /* If the member was not a friend, declare it here.  */
<span class="lineNum">   24026 </span><span class="lineCov">      16057 :                   if (!friend_p)</span>
<span class="lineNum">   24027 </span>            :                     finish_member_declaration (decl);
<span class="lineNum">   24028 </span><span class="lineCov">   11953252 :                   /* Peek at the next token.  */</span>
<span class="lineNum">   24029 </span><span class="lineCov">    5976626 :                   token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   24030 </span>            :                   /* If the next token is a semicolon, consume it.  */
<span class="lineNum">   24031 </span><span class="lineCov">        297 :                   if (token-&gt;type == CPP_SEMICOLON)</span>
<span class="lineNum">   24032 </span><span class="lineCov">        297 :                     {</span>
<span class="lineNum">   24033 </span><span class="lineCov">        530 :                       location_t semicolon_loc</span>
<span class="lineNum">   24034 </span>            :                         = cp_lexer_consume_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">   24035 </span><span class="lineCov">         32 :                       gcc_rich_location richloc (semicolon_loc);</span>
<span class="lineNum">   24036 </span>            :                       richloc.add_fixit_remove ();
<span class="lineNum">   24037 </span>            :                       warning_at (&amp;richloc, OPT_Wextra_semi,
<span class="lineNum">   24038 </span>            :                                   &quot;extra %&lt;;%&gt; after in-class &quot;
<span class="lineNum">   24039 </span>            :                                   &quot;function definition&quot;);
<span class="lineNum">   24040 </span>            :                     }
<span class="lineNum">   24041 </span>            :                   goto out;
<span class="lineNum">   24042 </span>            :                 }
<span class="lineNum">   24043 </span>            :               else
<span class="lineNum">   24044 </span>            :                 if (declarator-&gt;kind == cdk_function)
<span class="lineNum">   24045 </span>            :                   declarator-&gt;id_loc = token-&gt;location;
<span class="lineNum">   24046 </span><span class="lineCov">    6953707 :               /* Create the declaration.  */</span>
<span class="lineNum">   24047 </span><span class="lineCov">   18356074 :               decl = grokfield (declarator, &amp;decl_specifiers,</span>
<span class="lineNum">   24048 </span>            :                                 initializer, /*init_const_expr_p=*/true,
<span class="lineNum">   24049 </span>            :                                 asm_specification, attributes);
<span class="lineNum">   24050 </span>            :               if (parser-&gt;fully_implicit_function_template_p)
<span class="lineNum">   24051 </span>            :                 {
<span class="lineNum">   24052 </span>            :                   if (friend_p)
<span class="lineNum">   24053 </span>            :                     finish_fully_implicit_template (parser, 0);
<span class="lineNum">   24054 </span><span class="lineCov">    2505047 :                   else</span>
<span class="lineNum">   24055 </span><span class="lineCov">          3 :                     decl = finish_fully_implicit_template (parser, decl);</span>
<span class="lineNum">   24056 </span>            :                 }
<span class="lineNum">   24057 </span><span class="lineCov">    2505047 :             }</span>
<span class="lineNum">   24058 </span>            : 
<span class="lineNum">   24059 </span>            :           cp_finalize_omp_declare_simd (parser, decl);
<span class="lineNum">   24060 </span>            :           cp_finalize_oacc_routine (parser, decl, false);
<span class="lineNum">   24061 </span><span class="lineCov">    2505047 : </span>
<span class="lineNum">   24062 </span><span class="lineCov">         15 :           /* Reset PREFIX_ATTRIBUTES.  */</span>
<span class="lineNum">   24063 </span>            :           if (attributes != error_mark_node)
<span class="lineNum">   24064 </span><span class="lineCov">    2505047 :             {</span>
<span class="lineNum">   24065 </span><span class="lineCov">    2480549 :               while (attributes &amp;&amp; TREE_CHAIN (attributes) != first_attribute)</span>
<span class="lineNum">   24066 </span>            :                 attributes = TREE_CHAIN (attributes);
<span class="lineNum">   24067 </span><span class="lineCov">    5010094 :               if (attributes)</span>
<span class="lineNum">   24068 </span>            :                 TREE_CHAIN (attributes) = NULL_TREE;
<span class="lineNum">   24069 </span><span class="lineCov">    2505047 :             }</span>
<span class="lineNum">   24070 </span>            : 
<span class="lineNum">   24071 </span><span class="lineCov">       3709 :           /* If there is any qualification still in effect, clear it</span>
<span class="lineNum">   24072 </span><span class="lineCov">       3709 :              now; we will be starting fresh with the next declarator.  */</span>
<span class="lineNum">   24073 </span><span class="lineCov">       7418 :           parser-&gt;scope = NULL_TREE;</span>
<span class="lineNum">   24074 </span><span class="lineCov">       3709 :           parser-&gt;qualifying_scope = NULL_TREE;</span>
<span class="lineNum">   24075 </span><span class="lineCov">       3709 :           parser-&gt;object_scope = NULL_TREE;</span>
<span class="lineNum">   24076 </span>            :           /* If it's a `,', then there are more declarators.  */
<span class="lineNum">   24077 </span>            :           if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_COMMA))
<span class="lineNum">   24078 </span>            :             {
<span class="lineNum">   24079 </span><span class="lineCov">    2505047 :               cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   24080 </span>            :               if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_SEMICOLON))
<span class="lineNum">   24081 </span>            :                 {
<span class="lineNum">   24082 </span><span class="lineCov">    4448660 :                   cp_token *token = cp_lexer_previous_token (parser-&gt;lexer);</span>
<span class="lineNum">   24083 </span><span class="lineCov">     822744 :                   gcc_rich_location richloc (token-&gt;location);</span>
<span class="lineNum">   24084 </span>            :                   richloc.add_fixit_remove ();
<span class="lineNum">   24085 </span><span class="lineCov">    4448660 :                   error_at (&amp;richloc, &quot;stray %&lt;,%&gt; at end of &quot;</span>
<span class="lineNum">   24086 </span>            :                             &quot;member declaration&quot;);
<span class="lineNum">   24087 </span>            :                 }
<span class="lineNum">   24088 </span><span class="lineCov">    4448654 :             }</span>
<span class="lineNum">   24089 </span>            :           /* If the next token isn't a `;', then we have a parse error.  */
<span class="lineNum">   24090 </span><span class="lineCov">         19 :           else if (cp_lexer_next_token_is_not (parser-&gt;lexer,</span>
<span class="lineNum">   24091 </span><span class="lineCov">          2 :                                                CPP_SEMICOLON))</span>
<span class="lineNum">   24092 </span>            :             {
<span class="lineNum">   24093 </span><span class="lineCov">         17 :               /* The next token might be a ways away from where the</span>
<span class="lineNum">   24094 </span>            :                  actual semicolon is missing.  Find the previous token
<span class="lineNum">   24095 </span>            :                  and use that for our error position.  */
<span class="lineNum">   24096 </span>            :               cp_token *token = cp_lexer_previous_token (parser-&gt;lexer);
<span class="lineNum">   24097 </span><span class="lineCov">    4485258 :               gcc_rich_location richloc (token-&gt;location);</span>
<span class="lineNum">   24098 </span><span class="lineCov">    4485258 :               richloc.add_fixit_insert_after (&quot;;&quot;);</span>
<span class="lineNum">   24099 </span>            :               error_at (&amp;richloc, &quot;expected %&lt;;%&gt; at end of &quot;
<span class="lineNum">   24100 </span>            :                         &quot;member declaration&quot;);
<span class="lineNum">   24101 </span><span class="lineCov">    4485258 : </span>
<span class="lineNum">   24102 </span>            :               /* Assume that the user meant to provide a semicolon.  If
<span class="lineNum">   24103 </span><span class="lineCov">    4500073 :                  we were to cp_parser_skip_to_end_of_statement, we might</span>
<span class="lineNum">   24104 </span>            :                  skip to a semicolon inside a member function definition
<span class="lineNum">   24105 </span><span class="lineCov">    4485256 :                  and issue nonsensical error messages.  */</span>
<span class="lineNum">   24106 </span><span class="lineCov">      15192 :               assume_semicolon = true;</span>
<span class="lineNum">   24107 </span>            :             }
<span class="lineNum">   24108 </span>            : 
<span class="lineNum">   24109 </span>            :           if (decl)
<span class="lineNum">   24110 </span>            :             {
<span class="lineNum">   24111 </span><span class="lineCov">    4485258 :               /* Add DECL to the list of members.  */</span>
<span class="lineNum">   24112 </span><span class="lineCov">    4485258 :               if (!friend_p</span>
<span class="lineNum">   24113 </span><span class="lineCov">    4485258 :                   /* Explicitly include, eg, NSDMIs, for better error</span>
<span class="lineNum">   24114 </span>            :                      recovery (c++/58650).  */
<span class="lineNum">   24115 </span><span class="lineCov">    4485258 :                   || !DECL_DECLARES_FUNCTION_P (decl))</span>
<span class="lineNum">   24116 </span>            :                 finish_member_declaration (decl);
<span class="lineNum">   24117 </span><span class="lineCov">       7643 : </span>
<span class="lineNum">   24118 </span><span class="lineCov">       7643 :               if (TREE_CODE (decl) == FUNCTION_DECL)</span>
<span class="lineNum">   24119 </span>            :                 cp_parser_save_default_args (parser, decl);
<span class="lineNum">   24120 </span><span class="lineCov">          6 :               else if (TREE_CODE (decl) == FIELD_DECL</span>
<span class="lineNum">   24121 </span><span class="lineCov">         12 :                        &amp;&amp; DECL_INITIAL (decl))</span>
<span class="lineNum">   24122 </span><span class="lineCov">          6 :                 /* Add DECL to the queue of NSDMI to be parsed later.  */</span>
<span class="lineNum">   24123 </span><span class="lineCov">          6 :                 vec_safe_push (unparsed_nsdmis, decl);</span>
<span class="lineNum">   24124 </span>            :             }
<span class="lineNum">   24125 </span>            : 
<span class="lineNum">   24126 </span>            :           if (assume_semicolon)
<span class="lineNum">   24127 </span>            :             goto out;
<span class="lineNum">   24128 </span><span class="lineCov">    4477615 :         }</span>
<span class="lineNum">   24129 </span>            :     }
<span class="lineNum">   24130 </span>            : 
<span class="lineNum">   24131 </span>            :   cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);
<span class="lineNum">   24132 </span>            :  out:
<span class="lineNum">   24133 </span>            :   parser-&gt;colon_corrects_to_scope_p = saved_colon_corrects_to_scope_p;
<span class="lineNum">   24134 </span><span class="lineCov">         97 : }</span>
<span class="lineNum">   24135 </span><span class="lineCov">        194 : </span>
<span class="lineNum">   24136 </span><span class="lineCov">         97 : /* Parse a pure-specifier.</span>
<span class="lineNum">   24137 </span><span class="lineCov">         97 : </span>
<span class="lineNum">   24138 </span>            :    pure-specifier:
<span class="lineNum">   24139 </span>            :      = 0
<span class="lineNum">   24140 </span>            : 
<span class="lineNum">   24141 </span>            :    Returns INTEGER_ZERO_NODE if a pure specifier is found.
<span class="lineNum">   24142 </span>            :    Otherwise, ERROR_MARK_NODE is returned.  */
<a name="24143"><span class="lineNum">   24143 </span>            : </a>
<span class="lineNum">   24144 </span><span class="lineCov">         97 : static tree</span>
<span class="lineNum">   24145 </span>            : cp_parser_pure_specifier (cp_parser* parser)
<span class="lineNum">   24146 </span>            : {
<span class="lineNum">   24147 </span><span class="lineCov">    4485258 :   cp_token *token;</span>
<span class="lineNum">   24148 </span>            : 
<span class="lineNum">   24149 </span>            :   /* Look for the `=' token.  */
<span class="lineNum">   24150 </span><span class="lineCov">    4485249 :   if (!cp_parser_require (parser, CPP_EQ, RT_EQ))</span>
<span class="lineNum">   24151 </span>            :     return error_mark_node;
<span class="lineNum">   24152 </span>            :   /* Look for the `0' token.  */
<span class="lineNum">   24153 </span><span class="lineCov">    4485249 :   token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   24154 </span><span class="lineCov">    4476832 : </span>
<span class="lineNum">   24155 </span>            :   if (token-&gt;type == CPP_EOF
<span class="lineNum">   24156 </span><span class="lineCov">    4485249 :       || token-&gt;type == CPP_PRAGMA_EOL)</span>
<span class="lineNum">   24157 </span><span class="lineCov">    1016114 :     return error_mark_node;</span>
<span class="lineNum">   24158 </span><span class="lineCov">    3469135 : </span>
<span class="lineNum">   24159 </span><span class="lineCov">    3469135 :   cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   24160 </span>            : 
<span class="lineNum">   24161 </span><span class="lineCov">       8270 :   /* Accept = default or = delete in c++0x mode.  */</span>
<span class="lineNum">   24162 </span>            :   if (token-&gt;keyword == RID_DEFAULT
<span class="lineNum">   24163 </span>            :       || token-&gt;keyword == RID_DELETE)
<span class="lineNum">   24164 </span><span class="lineCov">    4485258 :     {</span>
<span class="lineNum">   24165 </span>            :       maybe_warn_cpp0x (CPP0X_DEFAULTED_DELETED);
<span class="lineNum">   24166 </span>            :       return token-&gt;u.value;
<span class="lineNum">   24167 </span>            :     }
<span class="lineNum">   24168 </span>            : 
<span class="lineNum">   24169 </span><span class="lineCov">    4666506 :   /* c_lex_with_flags marks a single digit '0' with PURE_ZERO.  */</span>
<span class="lineNum">   24170 </span><span class="lineCov">    7172097 :   if (token-&gt;type != CPP_NUMBER || !(token-&gt;flags &amp; PURE_ZERO))</span>
<span class="lineNum">   24171 </span><span class="lineCov">    7172097 :     {</span>
<span class="lineNum">   24172 </span>            :       cp_parser_error (parser,
<span class="lineNum">   24173 </span>            :                        &quot;invalid pure specifier (only %&lt;= 0%&gt; is allowed)&quot;);
<span class="lineNum">   24174 </span>            :       cp_parser_skip_to_end_of_statement (parser);
<span class="lineNum">   24175 </span>            :       return error_mark_node;
<span class="lineNum">   24176 </span>            :     }
<span class="lineNum">   24177 </span>            :   if (PROCESSING_REAL_TEMPLATE_DECL_P ())
<span class="lineNum">   24178 </span>            :     {
<span class="lineNum">   24179 </span>            :       error_at (token-&gt;location, &quot;templates may not be %&lt;virtual%&gt;&quot;);
<span class="lineNum">   24180 </span>            :       return error_mark_node;
<span class="lineNum">   24181 </span>            :     }
<span class="lineNum">   24182 </span>            : 
<span class="lineNum">   24183 </span><span class="lineCov">     297131 :   return integer_zero_node;</span>
<span class="lineNum">   24184 </span>            : }
<span class="lineNum">   24185 </span><span class="lineCov">     297131 : </span>
<span class="lineNum">   24186 </span>            : /* Parse a constant-initializer.
<span class="lineNum">   24187 </span>            : 
<span class="lineNum">   24188 </span><span class="lineCov">     297131 :    constant-initializer:</span>
<span class="lineNum">   24189 </span><span class="lineNoCov">          0 :      = constant-expression</span>
<span class="lineNum">   24190 </span>            : 
<span class="lineNum">   24191 </span><span class="lineCov">     594262 :    Returns a representation of the constant-expression.  */</span>
<a name="24192"><span class="lineNum">   24192 </span>            : </a>
<span class="lineNum">   24193 </span><span class="lineCov">     297131 : static tree</span>
<span class="lineNum">   24194 </span><span class="lineCov">     297128 : cp_parser_constant_initializer (cp_parser* parser)</span>
<span class="lineNum">   24195 </span><span class="lineCov">          3 : {</span>
<span class="lineNum">   24196 </span>            :   /* Look for the `=' token.  */
<span class="lineNum">   24197 </span><span class="lineCov">     297128 :   if (!cp_parser_require (parser, CPP_EQ, RT_EQ))</span>
<span class="lineNum">   24198 </span>            :     return error_mark_node;
<span class="lineNum">   24199 </span>            : 
<span class="lineNum">   24200 </span><span class="lineCov">     297128 :   /* It is invalid to write:</span>
<span class="lineNum">   24201 </span><span class="lineCov">     123993 : </span>
<span class="lineNum">   24202 </span>            :        struct S { static const int i = { 7 }; };
<span class="lineNum">   24203 </span><span class="lineCov">     266108 : </span>
<span class="lineNum">   24204 </span><span class="lineCov">     266108 :      */</span>
<span class="lineNum">   24205 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_BRACE))
<span class="lineNum">   24206 </span>            :     {
<span class="lineNum">   24207 </span>            :       cp_parser_error (parser,
<span class="lineNum">   24208 </span><span class="lineCov">      31020 :                        &quot;a brace-enclosed initializer is not allowed here&quot;);</span>
<span class="lineNum">   24209 </span>            :       /* Consume the opening brace.  */
<span class="lineNum">   24210 </span><span class="lineCov">         35 :       matching_braces braces;</span>
<span class="lineNum">   24211 </span>            :       braces.consume_open (parser);
<span class="lineNum">   24212 </span><span class="lineCov">         35 :       /* Skip the initializer.  */</span>
<span class="lineNum">   24213 </span><span class="lineCov">         35 :       cp_parser_skip_to_closing_brace (parser);</span>
<span class="lineNum">   24214 </span>            :       /* Look for the trailing `}'.  */
<span class="lineNum">   24215 </span><span class="lineCov">      30985 :       braces.require_close (parser);</span>
<span class="lineNum">   24216 </span>            : 
<span class="lineNum">   24217 </span><span class="lineCov">          3 :       return error_mark_node;</span>
<span class="lineNum">   24218 </span><span class="lineCov">          3 :     }</span>
<span class="lineNum">   24219 </span>            : 
<span class="lineNum">   24220 </span>            :   return cp_parser_constant_expression (parser);
<span class="lineNum">   24221 </span><span class="lineCov">      30982 : }</span>
<span class="lineNum">   24222 </span>            : 
<span class="lineNum">   24223 </span>            : /* Derived classes [gram.class.derived] */
<span class="lineNum">   24224 </span>            : 
<span class="lineNum">   24225 </span>            : /* Parse a base-clause.
<span class="lineNum">   24226 </span>            : 
<span class="lineNum">   24227 </span>            :    base-clause:
<span class="lineNum">   24228 </span>            :      : base-specifier-list
<span class="lineNum">   24229 </span>            : 
<span class="lineNum">   24230 </span>            :    base-specifier-list:
<span class="lineNum">   24231 </span>            :      base-specifier ... [opt]
<span class="lineNum">   24232 </span><span class="lineCov">      16057 :      base-specifier-list , base-specifier ... [opt]</span>
<span class="lineNum">   24233 </span>            : 
<span class="lineNum">   24234 </span>            :    Returns a TREE_LIST representing the base-classes, in the order in
<span class="lineNum">   24235 </span><span class="lineCov">      16057 :    which they were declared.  The representation of each node is as</span>
<span class="lineNum">   24236 </span><span class="lineNoCov">          0 :    described by cp_parser_base_specifier.</span>
<span class="lineNum">   24237 </span>            : 
<span class="lineNum">   24238 </span>            :    In the case that no bases are specified, this function will return
<span class="lineNum">   24239 </span>            :    NULL_TREE, not ERROR_MARK_NODE.  */
<a name="24240"><span class="lineNum">   24240 </span>            : </a>
<span class="lineNum">   24241 </span>            : static tree
<span class="lineNum">   24242 </span>            : cp_parser_base_clause (cp_parser* parser)
<span class="lineNum">   24243 </span><span class="lineCov">      16057 : {</span>
<span class="lineNum">   24244 </span>            :   tree bases = NULL_TREE;
<span class="lineNum">   24245 </span><span class="lineCov">          1 : </span>
<span class="lineNum">   24246 </span>            :   /* Look for the `:' that begins the list.  */
<span class="lineNum">   24247 </span>            :   cp_parser_require (parser, CPP_COLON, RT_COLON);
<span class="lineNum">   24248 </span><span class="lineCov">          2 : </span>
<span class="lineNum">   24249 </span><span class="lineCov">          1 :   /* Scan the base-specifier-list.  */</span>
<span class="lineNum">   24250 </span>            :   while (true)
<span class="lineNum">   24251 </span><span class="lineCov">          1 :     {</span>
<span class="lineNum">   24252 </span>            :       cp_token *token;
<span class="lineNum">   24253 </span><span class="lineCov">          1 :       tree base;</span>
<span class="lineNum">   24254 </span>            :       bool pack_expansion_p = false;
<span class="lineNum">   24255 </span><span class="lineCov">          1 : </span>
<span class="lineNum">   24256 </span>            :       /* Look for the base-specifier.  */
<span class="lineNum">   24257 </span>            :       base = cp_parser_base_specifier (parser);
<span class="lineNum">   24258 </span><span class="lineCov">      16056 :       /* Look for the (optional) ellipsis. */</span>
<span class="lineNum">   24259 </span>            :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_ELLIPSIS))
<span class="lineNum">   24260 </span>            :         {
<span class="lineNum">   24261 </span>            :           /* Consume the `...'. */
<span class="lineNum">   24262 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   24263 </span>            : 
<span class="lineNum">   24264 </span>            :           pack_expansion_p = true;
<span class="lineNum">   24265 </span>            :         }
<span class="lineNum">   24266 </span>            : 
<span class="lineNum">   24267 </span>            :       /* Add BASE to the front of the list.  */
<span class="lineNum">   24268 </span>            :       if (base &amp;&amp; base != error_mark_node)
<span class="lineNum">   24269 </span>            :         {
<span class="lineNum">   24270 </span>            :           if (pack_expansion_p)
<span class="lineNum">   24271 </span>            :             /* Make this a pack expansion type. */
<span class="lineNum">   24272 </span>            :             TREE_VALUE (base) = make_pack_expansion (TREE_VALUE (base));
<span class="lineNum">   24273 </span>            : 
<span class="lineNum">   24274 </span>            :           if (!check_for_bare_parameter_packs (TREE_VALUE (base)))
<span class="lineNum">   24275 </span>            :             {
<span class="lineNum">   24276 </span>            :               TREE_CHAIN (base) = bases;
<span class="lineNum">   24277 </span>            :               bases = base;
<span class="lineNum">   24278 </span>            :             }
<span class="lineNum">   24279 </span>            :         }
<span class="lineNum">   24280 </span><span class="lineCov">    1134842 :       /* Peek at the next token.  */</span>
<span class="lineNum">   24281 </span>            :       token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   24282 </span><span class="lineCov">    1134842 :       /* If it's not a comma, then the list is complete.  */</span>
<span class="lineNum">   24283 </span>            :       if (token-&gt;type != CPP_COMMA)
<span class="lineNum">   24284 </span>            :         break;
<span class="lineNum">   24285 </span><span class="lineCov">    1134842 :       /* Consume the `,'.  */</span>
<span class="lineNum">   24286 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   24287 </span>            :     }
<span class="lineNum">   24288 </span><span class="lineCov">    1157545 : </span>
<span class="lineNum">   24289 </span>            :   /* PARSER-&gt;SCOPE may still be non-NULL at this point, if the last
<span class="lineNum">   24290 </span><span class="lineCov">    1157545 :      base class had a qualified name.  However, the next name that</span>
<span class="lineNum">   24291 </span><span class="lineCov">    1157545 :      appears is certainly not qualified.  */</span>
<span class="lineNum">   24292 </span><span class="lineCov">    1157545 :   parser-&gt;scope = NULL_TREE;</span>
<span class="lineNum">   24293 </span>            :   parser-&gt;qualifying_scope = NULL_TREE;
<span class="lineNum">   24294 </span>            :   parser-&gt;object_scope = NULL_TREE;
<span class="lineNum">   24295 </span><span class="lineCov">    1157545 : </span>
<span class="lineNum">   24296 </span>            :   return nreverse (bases);
<span class="lineNum">   24297 </span><span class="lineCov">    1157545 : }</span>
<span class="lineNum">   24298 </span>            : 
<span class="lineNum">   24299 </span>            : /* Parse a base-specifier.
<span class="lineNum">   24300 </span><span class="lineCov">         41 : </span>
<span class="lineNum">   24301 </span>            :    base-specifier:
<span class="lineNum">   24302 </span><span class="lineCov">         41 :      :: [opt] nested-name-specifier [opt] class-name</span>
<span class="lineNum">   24303 </span>            :      virtual access-specifier [opt] :: [opt] nested-name-specifier
<span class="lineNum">   24304 </span>            :        [opt] class-name
<span class="lineNum">   24305 </span>            :      access-specifier virtual [opt] :: [opt] nested-name-specifier
<span class="lineNum">   24306 </span><span class="lineCov">    1157545 :        [opt] class-name</span>
<span class="lineNum">   24307 </span>            : 
<span class="lineNum">   24308 </span><span class="lineCov">    1157485 :    Returns a TREE_LIST.  The TREE_PURPOSE will be one of</span>
<span class="lineNum">   24309 </span>            :    ACCESS_{DEFAULT,PUBLIC,PROTECTED,PRIVATE}_[VIRTUAL]_NODE to
<span class="lineNum">   24310 </span><span class="lineCov">         41 :    indicate the specifiers provided.  The TREE_VALUE will be a TYPE</span>
<span class="lineNum">   24311 </span>            :    (or the ERROR_MARK_NODE) indicating the type that was specified.  */
<a name="24312"><span class="lineNum">   24312 </span><span class="lineCov">    1157485 : </span></a>
<span class="lineNum">   24313 </span>            : static tree
<span class="lineNum">   24314 </span><span class="lineCov">    1157479 : cp_parser_base_specifier (cp_parser* parser)</span>
<span class="lineNum">   24315 </span><span class="lineCov">    1157479 : {</span>
<span class="lineNum">   24316 </span>            :   cp_token *token;
<span class="lineNum">   24317 </span>            :   bool done = false;
<span class="lineNum">   24318 </span>            :   bool virtual_p = false;
<span class="lineNum">   24319 </span><span class="lineCov">    2315090 :   bool duplicate_virtual_error_issued_p = false;</span>
<span class="lineNum">   24320 </span>            :   bool duplicate_access_error_issued_p = false;
<span class="lineNum">   24321 </span><span class="lineCov">    1157545 :   bool class_scope_p, template_p;</span>
<span class="lineNum">   24322 </span>            :   tree access = access_default_node;
<span class="lineNum">   24323 </span>            :   tree type;
<span class="lineNum">   24324 </span><span class="lineCov">      22703 : </span>
<span class="lineNum">   24325 </span><span class="lineCov">      22703 :   /* Process the optional `virtual' and `access-specifier'.  */</span>
<span class="lineNum">   24326 </span>            :   while (!done)
<span class="lineNum">   24327 </span>            :     {
<span class="lineNum">   24328 </span>            :       /* Peek at the next token.  */
<span class="lineNum">   24329 </span>            :       token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   24330 </span><span class="lineCov">    1134842 :       /* Process `virtual'.  */</span>
<span class="lineNum">   24331 </span><span class="lineCov">    1134842 :       switch (token-&gt;keyword)</span>
<span class="lineNum">   24332 </span><span class="lineCov">    1134842 :         {</span>
<span class="lineNum">   24333 </span>            :         case RID_VIRTUAL:
<span class="lineNum">   24334 </span><span class="lineCov">    1134842 :           /* If `virtual' appears more than once, issue an error.  */</span>
<span class="lineNum">   24335 </span>            :           if (virtual_p &amp;&amp; !duplicate_virtual_error_issued_p)
<span class="lineNum">   24336 </span>            :             {
<span class="lineNum">   24337 </span>            :               cp_parser_error (parser,
<span class="lineNum">   24338 </span>            :                                &quot;%&lt;virtual%&gt; specified more than once in base-specifier&quot;);
<span class="lineNum">   24339 </span>            :               duplicate_virtual_error_issued_p = true;
<span class="lineNum">   24340 </span>            :             }
<span class="lineNum">   24341 </span>            : 
<span class="lineNum">   24342 </span>            :           virtual_p = true;
<span class="lineNum">   24343 </span>            : 
<span class="lineNum">   24344 </span>            :           /* Consume the `virtual' token.  */
<span class="lineNum">   24345 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   24346 </span>            : 
<span class="lineNum">   24347 </span>            :           break;
<span class="lineNum">   24348 </span>            : 
<span class="lineNum">   24349 </span>            :         case RID_PUBLIC:
<span class="lineNum">   24350 </span>            :         case RID_PROTECTED:
<span class="lineNum">   24351 </span>            :         case RID_PRIVATE:
<span class="lineNum">   24352 </span><span class="lineCov">    1157545 :           /* If more than one access specifier appears, issue an</span>
<span class="lineNum">   24353 </span>            :              error.  */
<span class="lineNum">   24354 </span><span class="lineCov">    1157545 :           if (access != access_default_node</span>
<span class="lineNum">   24355 </span><span class="lineCov">    1157545 :               &amp;&amp; !duplicate_access_error_issued_p)</span>
<span class="lineNum">   24356 </span><span class="lineCov">    1157545 :             {</span>
<span class="lineNum">   24357 </span><span class="lineCov">    1157545 :               cp_parser_error (parser,</span>
<span class="lineNum">   24358 </span><span class="lineCov">    1157545 :                                &quot;more than one access specifier in base-specifier&quot;);</span>
<span class="lineNum">   24359 </span><span class="lineCov">    1157545 :               duplicate_access_error_issued_p = true;</span>
<span class="lineNum">   24360 </span><span class="lineCov">    1157545 :             }</span>
<span class="lineNum">   24361 </span><span class="lineCov">    3272285 : </span>
<span class="lineNum">   24362 </span>            :           access = ridpointers[(int) token-&gt;keyword];
<span class="lineNum">   24363 </span>            : 
<span class="lineNum">   24364 </span><span class="lineCov">    3272285 :           /* Consume the access-specifier.  */</span>
<span class="lineNum">   24365 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   24366 </span>            : 
<span class="lineNum">   24367 </span><span class="lineCov">    4229480 :           break;</span>
<span class="lineNum">   24368 </span>            : 
<span class="lineNum">   24369 </span><span class="lineCov">    2114740 :         default:</span>
<span class="lineNum">   24370 </span>            :           done = true;
<span class="lineNum">   24371 </span><span class="lineCov">       5336 :           break;</span>
<span class="lineNum">   24372 </span>            :         }
<span class="lineNum">   24373 </span><span class="lineCov">       5336 :     }</span>
<span class="lineNum">   24374 </span>            :   /* It is not uncommon to see programs mechanically, erroneously, use
<span class="lineNum">   24375 </span><span class="lineNoCov">          0 :      the 'typename' keyword to denote (dependent) qualified types</span>
<span class="lineNum">   24376 </span>            :      as base classes.  */
<span class="lineNum">   24377 </span><span class="lineNoCov">          0 :   if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_TYPENAME))</span>
<span class="lineNum">   24378 </span>            :     {
<span class="lineNum">   24379 </span>            :       token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   24380 </span><span class="lineCov">       5336 :       if (!processing_template_decl)</span>
<span class="lineNum">   24381 </span>            :         error_at (token-&gt;location,
<span class="lineNum">   24382 </span>            :                   &quot;keyword %&lt;typename%&gt; not allowed outside of templates&quot;);
<span class="lineNum">   24383 </span><span class="lineCov">       5336 :       else</span>
<span class="lineNum">   24384 </span>            :         error_at (token-&gt;location,
<span class="lineNum">   24385 </span><span class="lineCov">       5336 :                   &quot;keyword %&lt;typename%&gt; not allowed in this context &quot;</span>
<span class="lineNum">   24386 </span>            :                   &quot;(the base class is implicitly a type)&quot;);
<span class="lineNum">   24387 </span><span class="lineCov">     951859 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   24388 </span><span class="lineCov">     951859 :     }</span>
<span class="lineNum">   24389 </span><span class="lineCov">     951859 : </span>
<span class="lineNum">   24390 </span>            :   /* Look for the optional `::' operator.  */
<span class="lineNum">   24391 </span>            :   cp_parser_global_scope_opt (parser, /*current_scope_valid_p=*/false);
<span class="lineNum">   24392 </span><span class="lineCov">     951859 :   /* Look for the nested-name-specifier.  The simplest way to</span>
<span class="lineNum">   24393 </span><span class="lineNoCov">          0 :      implement:</span>
<span class="lineNum">   24394 </span>            : 
<span class="lineNum">   24395 </span><span class="lineNoCov">          0 :        [temp.res]</span>
<span class="lineNum">   24396 </span>            : 
<span class="lineNum">   24397 </span><span class="lineNoCov">          0 :        The keyword `typename' is not permitted in a base-specifier or</span>
<span class="lineNum">   24398 </span>            :        mem-initializer; in these contexts a qualified name that
<span class="lineNum">   24399 </span>            :        depends on a template-parameter is implicitly assumed to be a
<span class="lineNum">   24400 </span><span class="lineCov">     951859 :        type name.</span>
<span class="lineNum">   24401 </span>            : 
<span class="lineNum">   24402 </span>            :      is to pretend that we have seen the `typename' keyword at this
<span class="lineNum">   24403 </span><span class="lineCov">     951859 :      point.  */</span>
<span class="lineNum">   24404 </span>            :   cp_parser_nested_name_specifier_opt (parser,
<span class="lineNum">   24405 </span><span class="lineCov">     951859 :                                        /*typename_keyword_p=*/true,</span>
<span class="lineNum">   24406 </span>            :                                        /*check_dependency_p=*/true,
<span class="lineNum">   24407 </span>            :                                        /*type_p=*/true,
<span class="lineNum">   24408 </span>            :                                        /*is_declaration=*/true);
<span class="lineNum">   24409 </span>            :   /* If the base class is given by a qualified name, assume that names
<span class="lineNum">   24410 </span>            :      we see are type names or templates, as appropriate.  */
<span class="lineNum">   24411 </span>            :   class_scope_p = (parser-&gt;scope &amp;&amp; TYPE_P (parser-&gt;scope));
<span class="lineNum">   24412 </span>            :   template_p = class_scope_p &amp;&amp; cp_parser_optional_template_keyword (parser);
<span class="lineNum">   24413 </span>            : 
<span class="lineNum">   24414 </span>            :   if (!parser-&gt;scope
<span class="lineNum">   24415 </span><span class="lineCov">    1157545 :       &amp;&amp; cp_lexer_next_token_is_decltype (parser-&gt;lexer))</span>
<span class="lineNum">   24416 </span>            :     /* DR 950 allows decltype as a base-specifier.  */
<span class="lineNum">   24417 </span><span class="lineCov">         18 :     type = cp_parser_decltype (parser);</span>
<span class="lineNum">   24418 </span><span class="lineCov">          9 :   else</span>
<span class="lineNum">   24419 </span><span class="lineCov">          3 :     {</span>
<span class="lineNum">   24420 </span>            :       /* Otherwise, look for the class-name.  */
<span class="lineNum">   24421 </span>            :       type = cp_parser_class_name (parser,
<span class="lineNum">   24422 </span><span class="lineCov">          6 :                                    class_scope_p,</span>
<span class="lineNum">   24423 </span>            :                                    template_p,
<span class="lineNum">   24424 </span>            :                                    typename_type,
<span class="lineNum">   24425 </span><span class="lineCov">          9 :                                    /*check_dependency_p=*/true,</span>
<span class="lineNum">   24426 </span>            :                                    /*class_head_p=*/false,
<span class="lineNum">   24427 </span>            :                                    /*is_declaration=*/true);
<span class="lineNum">   24428 </span>            :       type = TREE_TYPE (type);
<span class="lineNum">   24429 </span><span class="lineCov">    1157545 :     }</span>
<span class="lineNum">   24430 </span>            : 
<span class="lineNum">   24431 </span>            :   if (type == error_mark_node)
<span class="lineNum">   24432 </span>            :     return error_mark_node;
<span class="lineNum">   24433 </span>            : 
<span class="lineNum">   24434 </span>            :   return finish_base_specifier (type, access, virtual_p);
<span class="lineNum">   24435 </span>            : }
<span class="lineNum">   24436 </span>            : 
<span class="lineNum">   24437 </span>            : /* Exception handling [gram.exception] */
<span class="lineNum">   24438 </span>            : 
<span class="lineNum">   24439 </span>            : /* Parse an (optional) noexcept-specification.
<span class="lineNum">   24440 </span>            : 
<span class="lineNum">   24441 </span>            :    noexcept-specification:
<span class="lineNum">   24442 </span><span class="lineCov">    1157545 :      noexcept ( constant-expression ) [opt]</span>
<span class="lineNum">   24443 </span>            : 
<span class="lineNum">   24444 </span>            :    If no noexcept-specification is present, returns NULL_TREE.
<span class="lineNum">   24445 </span>            :    Otherwise, if REQUIRE_CONSTEXPR is false, then either parse and return any
<span class="lineNum">   24446 </span>            :    expression if parentheses follow noexcept, or return BOOLEAN_TRUE_NODE if
<span class="lineNum">   24447 </span>            :    there are no parentheses.  CONSUMED_EXPR will be set accordingly.
<span class="lineNum">   24448 </span>            :    Otherwise, returns a noexcept specification unless RETURN_COND is true,
<span class="lineNum">   24449 </span><span class="lineCov">    1157545 :    in which case a boolean condition is returned instead.  */</span>
<a name="24450"><span class="lineNum">   24450 </span><span class="lineCov">     136472 : </span></a>
<span class="lineNum">   24451 </span>            : static tree
<span class="lineNum">   24452 </span><span class="lineCov">    1157545 : cp_parser_noexcept_specification_opt (cp_parser* parser,</span>
<span class="lineNum">   24453 </span><span class="lineCov">    1157545 :                                       bool require_constexpr,</span>
<span class="lineNum">   24454 </span>            :                                       bool* consumed_expr,
<span class="lineNum">   24455 </span><span class="lineCov">        214 :                                       bool return_cond)</span>
<span class="lineNum">   24456 </span>            : {
<span class="lineNum">   24457 </span>            :   cp_token *token;
<span class="lineNum">   24458 </span>            :   const char *saved_message;
<span class="lineNum">   24459 </span><span class="lineCov">    1157331 : </span>
<span class="lineNum">   24460 </span>            :   /* Peek at the next token.  */
<span class="lineNum">   24461 </span>            :   token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   24462 </span>            : 
<span class="lineNum">   24463 </span>            :   /* Is it a noexcept-specification?  */
<span class="lineNum">   24464 </span>            :   if (cp_parser_is_keyword (token, RID_NOEXCEPT))
<span class="lineNum">   24465 </span>            :     {
<span class="lineNum">   24466 </span><span class="lineCov">    1157331 :       tree expr;</span>
<span class="lineNum">   24467 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   24468 </span>            : 
<span class="lineNum">   24469 </span><span class="lineCov">    1157545 :       if (cp_lexer_peek_token (parser-&gt;lexer)-&gt;type == CPP_OPEN_PAREN)</span>
<span class="lineNum">   24470 </span>            :         {
<span class="lineNum">   24471 </span>            :           matching_parens parens;
<span class="lineNum">   24472 </span><span class="lineCov">    1157487 :           parens.consume_open (parser);</span>
<span class="lineNum">   24473 </span>            : 
<span class="lineNum">   24474 </span>            :           if (require_constexpr)
<span class="lineNum">   24475 </span>            :             {
<span class="lineNum">   24476 </span>            :               /* Types may not be defined in an exception-specification.  */
<span class="lineNum">   24477 </span>            :               saved_message = parser-&gt;type_definition_forbidden_message;
<span class="lineNum">   24478 </span>            :               parser-&gt;type_definition_forbidden_message
<span class="lineNum">   24479 </span>            :               = G_(&quot;types may not be defined in an exception-specification&quot;);
<span class="lineNum">   24480 </span>            : 
<span class="lineNum">   24481 </span>            :               expr = cp_parser_constant_expression (parser);
<span class="lineNum">   24482 </span>            : 
<span class="lineNum">   24483 </span>            :               /* Restore the saved message.  */
<span class="lineNum">   24484 </span>            :               parser-&gt;type_definition_forbidden_message = saved_message;
<span class="lineNum">   24485 </span>            :             }
<span class="lineNum">   24486 </span>            :           else
<span class="lineNum">   24487 </span>            :             {
<span class="lineNum">   24488 </span>            :               expr = cp_parser_expression (parser);
<span class="lineNum">   24489 </span>            :               *consumed_expr = true;
<span class="lineNum">   24490 </span><span class="lineCov">   10410178 :             }</span>
<span class="lineNum">   24491 </span>            : 
<span class="lineNum">   24492 </span>            :           parens.require_close (parser);
<span class="lineNum">   24493 </span>            :         }
<span class="lineNum">   24494 </span>            :       else
<span class="lineNum">   24495 </span><span class="lineCov">   10410178 :         {</span>
<span class="lineNum">   24496 </span><span class="lineCov">   10410178 :           expr = boolean_true_node;</span>
<span class="lineNum">   24497 </span>            :           if (!require_constexpr)
<span class="lineNum">   24498 </span>            :             *consumed_expr = false;
<span class="lineNum">   24499 </span><span class="lineCov">   20820356 :         }</span>
<span class="lineNum">   24500 </span>            : 
<span class="lineNum">   24501 </span>            :       /* We cannot build a noexcept-spec right away because this will check
<span class="lineNum">   24502 </span><span class="lineCov">   10410178 :          that expr is a constexpr.  */</span>
<span class="lineNum">   24503 </span>            :       if (!return_cond)
<span class="lineNum">   24504 </span><span class="lineCov">    1451636 :         return build_noexcept_spec (expr, tf_warning_or_error);</span>
<span class="lineNum">   24505 </span><span class="lineCov">    1451636 :       else</span>
<span class="lineNum">   24506 </span>            :         return expr;
<span class="lineNum">   24507 </span><span class="lineCov">    1451636 :     }</span>
<span class="lineNum">   24508 </span>            :   else
<span class="lineNum">   24509 </span><span class="lineCov">     218718 :     return NULL_TREE;</span>
<span class="lineNum">   24510 </span><span class="lineCov">     109359 : }</span>
<span class="lineNum">   24511 </span>            : 
<span class="lineNum">   24512 </span><span class="lineCov">     109359 : /* Parse an (optional) exception-specification.</span>
<span class="lineNum">   24513 </span>            : 
<span class="lineNum">   24514 </span>            :    exception-specification:
<span class="lineNum">   24515 </span><span class="lineCov">     109321 :      throw ( type-id-list [opt] )</span>
<span class="lineNum">   24516 </span><span class="lineCov">     109321 : </span>
<span class="lineNum">   24517 </span><span class="lineCov">     109321 :    Returns a TREE_LIST representing the exception-specification.  The</span>
<span class="lineNum">   24518 </span>            :    TREE_VALUE of each node is a type.  */
<a name="24519"><span class="lineNum">   24519 </span><span class="lineCov">     109321 : </span></a>
<span class="lineNum">   24520 </span>            : static tree
<span class="lineNum">   24521 </span>            : cp_parser_exception_specification_opt (cp_parser* parser)
<span class="lineNum">   24522 </span><span class="lineCov">     109321 : {</span>
<span class="lineNum">   24523 </span>            :   cp_token *token;
<span class="lineNum">   24524 </span>            :   tree type_id_list;
<span class="lineNum">   24525 </span>            :   const char *saved_message;
<span class="lineNum">   24526 </span><span class="lineCov">         38 : </span>
<span class="lineNum">   24527 </span><span class="lineCov">         38 :   /* Peek at the next token.  */</span>
<span class="lineNum">   24528 </span>            :   token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   24529 </span>            : 
<span class="lineNum">   24530 </span><span class="lineCov">     109359 :   /* Is it a noexcept-specification?  */</span>
<span class="lineNum">   24531 </span>            :   type_id_list = cp_parser_noexcept_specification_opt (parser, true, NULL,
<span class="lineNum">   24532 </span>            :                                                        false);
<span class="lineNum">   24533 </span>            :   if (type_id_list != NULL_TREE)
<span class="lineNum">   24534 </span><span class="lineCov">    1342277 :     return type_id_list;</span>
<span class="lineNum">   24535 </span><span class="lineCov">    1342277 : </span>
<span class="lineNum">   24536 </span><span class="lineNoCov">          0 :   /* If it's not `throw', then there's no exception-specification.  */</span>
<span class="lineNum">   24537 </span>            :   if (!cp_parser_is_keyword (token, RID_THROW))
<span class="lineNum">   24538 </span>            :     return NULL_TREE;
<span class="lineNum">   24539 </span>            : 
<span class="lineNum">   24540 </span>            :   location_t loc = token-&gt;location;
<span class="lineNum">   24541 </span><span class="lineCov">    1451636 : </span>
<span class="lineNum">   24542 </span><span class="lineCov">    1451574 :   /* Consume the `throw'.  */</span>
<span class="lineNum">   24543 </span>            :   cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   24544 </span>            : 
<span class="lineNum">   24545 </span>            :   /* Look for the `('.  */
<span class="lineNum">   24546 </span>            :   matching_parens parens;
<span class="lineNum">   24547 </span>            :   parens.require_open (parser);
<span class="lineNum">   24548 </span>            : 
<span class="lineNum">   24549 </span>            :   /* Peek at the next token.  */
<span class="lineNum">   24550 </span>            :   token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   24551 </span>            :   /* If it's not a `)', then there is a type-id-list.  */
<span class="lineNum">   24552 </span>            :   if (token-&gt;type != CPP_CLOSE_PAREN)
<span class="lineNum">   24553 </span>            :     {
<span class="lineNum">   24554 </span>            :       /* Types may not be defined in an exception-specification.  */
<span class="lineNum">   24555 </span>            :       saved_message = parser-&gt;type_definition_forbidden_message;
<span class="lineNum">   24556 </span>            :       parser-&gt;type_definition_forbidden_message
<span class="lineNum">   24557 </span>            :         = G_(&quot;types may not be defined in an exception-specification&quot;);
<span class="lineNum">   24558 </span>            :       /* Parse the type-id-list.  */
<span class="lineNum">   24559 </span><span class="lineCov">   10409897 :       type_id_list = cp_parser_type_id_list (parser);</span>
<span class="lineNum">   24560 </span>            :       /* Restore the saved message.  */
<span class="lineNum">   24561 </span><span class="lineCov">   10409897 :       parser-&gt;type_definition_forbidden_message = saved_message;</span>
<span class="lineNum">   24562 </span><span class="lineCov">   10409897 : </span>
<span class="lineNum">   24563 </span><span class="lineCov">   10409897 :       if (cxx_dialect &gt;= cxx17)</span>
<span class="lineNum">   24564 </span>            :         {
<span class="lineNum">   24565 </span>            :           error_at (loc, &quot;ISO C++17 does not allow dynamic exception &quot;
<span class="lineNum">   24566 </span><span class="lineCov">   20819794 :                          &quot;specifications&quot;);</span>
<span class="lineNum">   24567 </span>            :           type_id_list = NULL_TREE;
<span class="lineNum">   24568 </span>            :         }
<span class="lineNum">   24569 </span><span class="lineCov">   10409897 :       else if (cxx_dialect &gt;= cxx11 &amp;&amp; !in_system_header_at (loc))</span>
<span class="lineNum">   24570 </span>            :         warning_at (loc, OPT_Wdeprecated,
<span class="lineNum">   24571 </span><span class="lineCov">   10409897 :                     &quot;dynamic exception specifications are deprecated in &quot;</span>
<span class="lineNum">   24572 </span>            :                     &quot;C++11&quot;);
<span class="lineNum">   24573 </span>            :     }
<span class="lineNum">   24574 </span>            :   /* In C++17, throw() is equivalent to noexcept (true).  throw()
<span class="lineNum">   24575 </span><span class="lineCov">    8958323 :      is deprecated in C++11 and above as well, but is still widely used,</span>
<span class="lineNum">   24576 </span>            :      so don't warn about it yet.  */
<span class="lineNum">   24577 </span>            :   else if (cxx_dialect &gt;= cxx17)
<span class="lineNum">   24578 </span><span class="lineCov">    2465727 :     type_id_list = noexcept_true_spec;</span>
<span class="lineNum">   24579 </span>            :   else
<span class="lineNum">   24580 </span>            :     type_id_list = empty_except_spec;
<span class="lineNum">   24581 </span><span class="lineCov">    2465727 : </span>
<span class="lineNum">   24582 </span>            :   /* Look for the `)'.  */
<span class="lineNum">   24583 </span>            :   parens.require_close (parser);
<span class="lineNum">   24584 </span><span class="lineCov">    4931454 : </span>
<span class="lineNum">   24585 </span><span class="lineCov">    2465727 :   return type_id_list;</span>
<span class="lineNum">   24586 </span>            : }
<span class="lineNum">   24587 </span>            : 
<span class="lineNum">   24588 </span><span class="lineCov">    4931454 : /* Parse an (optional) type-id-list.</span>
<span class="lineNum">   24589 </span>            : 
<span class="lineNum">   24590 </span><span class="lineCov">    2465727 :    type-id-list:</span>
<span class="lineNum">   24591 </span>            :      type-id ... [opt]
<span class="lineNum">   24592 </span>            :      type-id-list , type-id ... [opt]
<span class="lineNum">   24593 </span><span class="lineCov">       1356 : </span>
<span class="lineNum">   24594 </span><span class="lineCov">       1356 :    Returns a TREE_LIST.  The TREE_VALUE of each node is a TYPE,</span>
<span class="lineNum">   24595 </span><span class="lineCov">       1356 :    in the order that the types were presented.  */</span>
<a name="24596"><span class="lineNum">   24596 </span>            : </a>
<span class="lineNum">   24597 </span><span class="lineCov">       1356 : static tree</span>
<span class="lineNum">   24598 </span>            : cp_parser_type_id_list (cp_parser* parser)
<span class="lineNum">   24599 </span><span class="lineCov">       1356 : {</span>
<span class="lineNum">   24600 </span>            :   tree types = NULL_TREE;
<span class="lineNum">   24601 </span><span class="lineCov">       1356 : </span>
<span class="lineNum">   24602 </span>            :   while (true)
<span class="lineNum">   24603 </span><span class="lineCov">          1 :     {</span>
<span class="lineNum">   24604 </span>            :       cp_token *token;
<span class="lineNum">   24605 </span><span class="lineCov">          1 :       tree type;</span>
<span class="lineNum">   24606 </span>            : 
<span class="lineNum">   24607 </span><span class="lineCov">       1355 :       token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   24608 </span><span class="lineCov">        517 : </span>
<span class="lineNum">   24609 </span>            :       /* Get the next type-id.  */
<span class="lineNum">   24610 </span>            :       type = cp_parser_type_id (parser);
<span class="lineNum">   24611 </span>            :       /* Check for invalid 'auto'.  */
<span class="lineNum">   24612 </span>            :       if (flag_concepts &amp;&amp; type_uses_auto (type))
<span class="lineNum">   24613 </span>            :         {
<span class="lineNum">   24614 </span>            :           error_at (token-&gt;location,
<span class="lineNum">   24615 </span><span class="lineCov">    2464371 :                     &quot;invalid use of %&lt;auto%&gt; in exception-specification&quot;);</span>
<span class="lineNum">   24616 </span><span class="lineCov">     317786 :           type = error_mark_node;</span>
<span class="lineNum">   24617 </span>            :         }
<span class="lineNum">   24618 </span><span class="lineCov">    2146585 :       /* Parse the optional ellipsis. */</span>
<span class="lineNum">   24619 </span>            :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_ELLIPSIS))
<span class="lineNum">   24620 </span>            :         {
<span class="lineNum">   24621 </span><span class="lineCov">    4931454 :           /* Consume the `...'. */</span>
<span class="lineNum">   24622 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   24623 </span><span class="lineCov">    2465727 : </span>
<span class="lineNum">   24624 </span>            :           /* Turn the type into a pack expansion expression. */
<span class="lineNum">   24625 </span>            :           type = make_pack_expansion (type);
<span class="lineNum">   24626 </span>            :         }
<span class="lineNum">   24627 </span>            :       /* Add it to the list.  */
<span class="lineNum">   24628 </span>            :       types = add_exception_specifier (types, type, /*complain=*/1);
<span class="lineNum">   24629 </span>            :       /* Peek at the next token.  */
<span class="lineNum">   24630 </span>            :       token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   24631 </span>            :       /* If it is not a `,', we are done.  */
<span class="lineNum">   24632 </span>            :       if (token-&gt;type != CPP_COMMA)
<span class="lineNum">   24633 </span>            :         break;
<span class="lineNum">   24634 </span>            :       /* Consume the `,'.  */
<span class="lineNum">   24635 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   24636 </span><span class="lineCov">       1356 :     }</span>
<span class="lineNum">   24637 </span>            : 
<span class="lineNum">   24638 </span><span class="lineCov">       1356 :   return nreverse (types);</span>
<span class="lineNum">   24639 </span>            : }
<span class="lineNum">   24640 </span><span class="lineCov">       1521 : </span>
<span class="lineNum">   24641 </span>            : /* Parse a try-block.
<span class="lineNum">   24642 </span><span class="lineCov">       1521 : </span>
<span class="lineNum">   24643 </span><span class="lineCov">       1521 :    try-block:</span>
<span class="lineNum">   24644 </span>            :      try compound-statement handler-seq  */
<a name="24645"><span class="lineNum">   24645 </span><span class="lineCov">       3042 : </span></a>
<span class="lineNum">   24646 </span>            : static tree
<span class="lineNum">   24647 </span>            : cp_parser_try_block (cp_parser* parser)
<span class="lineNum">   24648 </span><span class="lineCov">       1521 : {</span>
<span class="lineNum">   24649 </span>            :   tree try_block;
<span class="lineNum">   24650 </span><span class="lineCov">       1521 : </span>
<span class="lineNum">   24651 </span>            :   cp_parser_require_keyword (parser, RID_TRY, RT_TRY);
<span class="lineNum">   24652 </span><span class="lineNoCov">          0 :   if (parser-&gt;in_function_body</span>
<span class="lineNum">   24653 </span>            :       &amp;&amp; DECL_DECLARED_CONSTEXPR_P (current_function_decl))
<span class="lineNum">   24654 </span><span class="lineNoCov">          0 :     error (&quot;%&lt;try%&gt; in %&lt;constexpr%&gt; function&quot;);</span>
<span class="lineNum">   24655 </span>            : 
<span class="lineNum">   24656 </span>            :   try_block = begin_try_block ();
<span class="lineNum">   24657 </span><span class="lineCov">       1521 :   cp_parser_compound_statement (parser, NULL, BCS_TRY_BLOCK, false);</span>
<span class="lineNum">   24658 </span>            :   finish_try_block (try_block);
<span class="lineNum">   24659 </span>            :   cp_parser_handler_seq (parser);
<span class="lineNum">   24660 </span><span class="lineCov">          4 :   finish_handler_sequence (try_block);</span>
<span class="lineNum">   24661 </span>            : 
<span class="lineNum">   24662 </span>            :   return try_block;
<span class="lineNum">   24663 </span><span class="lineCov">          4 : }</span>
<span class="lineNum">   24664 </span>            : 
<span class="lineNum">   24665 </span>            : /* Parse a function-try-block.
<span class="lineNum">   24666 </span><span class="lineCov">       1521 : </span>
<span class="lineNum">   24667 </span>            :    function-try-block:
<span class="lineNum">   24668 </span><span class="lineCov">       3042 :      try ctor-initializer [opt] function-body handler-seq  */</span>
<a name="24669"><span class="lineNum">   24669 </span>            : </a>
<span class="lineNum">   24670 </span><span class="lineCov">       1521 : static void</span>
<span class="lineNum">   24671 </span>            : cp_parser_function_try_block (cp_parser* parser)
<span class="lineNum">   24672 </span>            : {
<span class="lineNum">   24673 </span><span class="lineCov">        165 :   tree compound_stmt;</span>
<span class="lineNum">   24674 </span><span class="lineCov">        165 :   tree try_block;</span>
<span class="lineNum">   24675 </span>            : 
<span class="lineNum">   24676 </span><span class="lineCov">       1356 :   /* Look for the `try' keyword.  */</span>
<span class="lineNum">   24677 </span>            :   if (!cp_parser_require_keyword (parser, RID_TRY, RT_TRY))
<span class="lineNum">   24678 </span>            :     return;
<span class="lineNum">   24679 </span>            :   /* Let the rest of the front end know where we are.  */
<span class="lineNum">   24680 </span>            :   try_block = begin_function_try_block (&amp;compound_stmt);
<span class="lineNum">   24681 </span>            :   /* Parse the function-body.  */
<span class="lineNum">   24682 </span>            :   cp_parser_ctor_initializer_opt_and_function_body
<span class="lineNum">   24683 </span>            :     (parser, /*in_function_try_block=*/true);
<span class="lineNum">   24684 </span>            :   /* We're done with the `try' part.  */
<span class="lineNum">   24685 </span><span class="lineCov">      84398 :   finish_function_try_block (try_block);</span>
<span class="lineNum">   24686 </span>            :   /* Parse the handlers.  */
<span class="lineNum">   24687 </span><span class="lineCov">      84398 :   cp_parser_handler_seq (parser);</span>
<span class="lineNum">   24688 </span>            :   /* We're done with the handlers.  */
<span class="lineNum">   24689 </span><span class="lineCov">      84398 :   finish_function_handler_sequence (try_block, compound_stmt);</span>
<span class="lineNum">   24690 </span><span class="lineCov">      84398 : }</span>
<span class="lineNum">   24691 </span><span class="lineCov">     168796 : </span>
<span class="lineNum">   24692 </span><span class="lineNoCov">          0 : /* Parse a handler-seq.</span>
<span class="lineNum">   24693 </span>            : 
<span class="lineNum">   24694 </span><span class="lineCov">      84398 :    handler-seq:</span>
<span class="lineNum">   24695 </span><span class="lineCov">      84398 :      handler handler-seq [opt]  */</span>
<a name="24696"><span class="lineNum">   24696 </span><span class="lineCov">      84398 : </span></a>
<span class="lineNum">   24697 </span><span class="lineCov">      84398 : static void</span>
<span class="lineNum">   24698 </span><span class="lineCov">      84398 : cp_parser_handler_seq (cp_parser* parser)</span>
<span class="lineNum">   24699 </span>            : {
<span class="lineNum">   24700 </span><span class="lineCov">      84398 :   while (true)</span>
<span class="lineNum">   24701 </span>            :     {
<span class="lineNum">   24702 </span>            :       cp_token *token;
<span class="lineNum">   24703 </span>            : 
<span class="lineNum">   24704 </span>            :       /* Parse the handler.  */
<span class="lineNum">   24705 </span>            :       cp_parser_handler (parser);
<span class="lineNum">   24706 </span>            :       /* Peek at the next token.  */
<span class="lineNum">   24707 </span>            :       token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   24708 </span>            :       /* If it's not `catch' then there are no more handlers.  */
<span class="lineNum">   24709 </span><span class="lineCov">         99 :       if (!cp_parser_is_keyword (token, RID_CATCH))</span>
<span class="lineNum">   24710 </span>            :         break;
<span class="lineNum">   24711 </span><span class="lineCov">         99 :     }</span>
<span class="lineNum">   24712 </span><span class="lineCov">         99 : }</span>
<span class="lineNum">   24713 </span>            : 
<span class="lineNum">   24714 </span>            : /* Parse a handler.
<span class="lineNum">   24715 </span><span class="lineCov">         99 : </span>
<span class="lineNum">   24716 </span><span class="lineNoCov">          0 :    handler:</span>
<span class="lineNum">   24717 </span>            :      catch ( exception-declaration ) compound-statement  */
<a name="24718"><span class="lineNum">   24718 </span><span class="lineCov">         99 : </span></a>
<span class="lineNum">   24719 </span>            : static void
<span class="lineNum">   24720 </span><span class="lineCov">         99 : cp_parser_handler (cp_parser* parser)</span>
<span class="lineNum">   24721 </span><span class="lineCov">         99 : {</span>
<span class="lineNum">   24722 </span>            :   tree handler;
<span class="lineNum">   24723 </span><span class="lineCov">         99 :   tree declaration;</span>
<span class="lineNum">   24724 </span>            : 
<span class="lineNum">   24725 </span><span class="lineCov">         99 :   cp_parser_require_keyword (parser, RID_CATCH, RT_CATCH);</span>
<span class="lineNum">   24726 </span>            :   handler = begin_handler ();
<span class="lineNum">   24727 </span><span class="lineCov">         99 :   matching_parens parens;</span>
<span class="lineNum">   24728 </span>            :   parens.require_open (parser);
<span class="lineNum">   24729 </span>            :   declaration = cp_parser_exception_declaration (parser);
<span class="lineNum">   24730 </span>            :   finish_handler_parms (declaration, handler);
<span class="lineNum">   24731 </span>            :   parens.require_close (parser);
<span class="lineNum">   24732 </span>            :   cp_parser_compound_statement (parser, NULL, BCS_NORMAL, false);
<span class="lineNum">   24733 </span>            :   finish_handler (handler);
<span class="lineNum">   24734 </span>            : }
<span class="lineNum">   24735 </span>            : 
<span class="lineNum">   24736 </span><span class="lineNoCov">          0 : /* Parse an exception-declaration.</span>
<span class="lineNum">   24737 </span>            : 
<span class="lineNum">   24738 </span><span class="lineCov">     118063 :    exception-declaration:</span>
<span class="lineNum">   24739 </span>            :      type-specifier-seq declarator
<span class="lineNum">   24740 </span><span class="lineCov">     118063 :      type-specifier-seq abstract-declarator</span>
<span class="lineNum">   24741 </span>            :      type-specifier-seq
<span class="lineNum">   24742 </span>            :      ...
<span class="lineNum">   24743 </span><span class="lineCov">     118063 : </span>
<span class="lineNum">   24744 </span>            :    Returns a VAR_DECL for the declaration, or NULL_TREE if the
<span class="lineNum">   24745 </span><span class="lineCov">     236126 :    ellipsis variant is used.  */</span>
<a name="24746"><span class="lineNum">   24746 </span>            : </a>
<span class="lineNum">   24747 </span><span class="lineCov">     118063 : static tree</span>
<span class="lineNum">   24748 </span>            : cp_parser_exception_declaration (cp_parser* parser)
<span class="lineNum">   24749 </span>            : {
<span class="lineNum">   24750 </span><span class="lineNoCov">          0 :   cp_decl_specifier_seq type_specifiers;</span>
<span class="lineNum">   24751 </span>            :   cp_declarator *declarator;
<span class="lineNum">   24752 </span>            :   const char *saved_message;
<span class="lineNum">   24753 </span>            : 
<span class="lineNum">   24754 </span>            :   /* If it's an ellipsis, it's easy to handle.  */
<span class="lineNum">   24755 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_ELLIPSIS))
<span class="lineNum">   24756 </span>            :     {
<span class="lineNum">   24757 </span>            :       /* Consume the `...' token.  */
<span class="lineNum">   24758 </span><span class="lineCov">     118063 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   24759 </span>            :       return NULL_TREE;
<span class="lineNum">   24760 </span><span class="lineCov">     118063 :     }</span>
<span class="lineNum">   24761 </span><span class="lineCov">     118063 : </span>
<span class="lineNum">   24762 </span>            :   /* Types may not be defined in exception-declarations.  */
<span class="lineNum">   24763 </span><span class="lineCov">     118063 :   saved_message = parser-&gt;type_definition_forbidden_message;</span>
<span class="lineNum">   24764 </span><span class="lineCov">     118063 :   parser-&gt;type_definition_forbidden_message</span>
<span class="lineNum">   24765 </span><span class="lineCov">     236126 :     = G_(&quot;types may not be defined in exception-declarations&quot;);</span>
<span class="lineNum">   24766 </span><span class="lineCov">     118063 : </span>
<span class="lineNum">   24767 </span><span class="lineCov">     118063 :   /* Parse the type-specifier-seq.  */</span>
<span class="lineNum">   24768 </span><span class="lineCov">     118063 :   cp_parser_type_specifier_seq (parser, /*is_declaration=*/true,</span>
<span class="lineNum">   24769 </span><span class="lineCov">     118063 :                                 /*is_trailing_return=*/false,</span>
<span class="lineNum">   24770 </span><span class="lineCov">     118063 :                                 &amp;type_specifiers);</span>
<span class="lineNum">   24771 </span><span class="lineCov">     118063 :   /* If it's a `)', then there is no declarator.  */</span>
<span class="lineNum">   24772 </span><span class="lineCov">     118063 :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_CLOSE_PAREN))</span>
<span class="lineNum">   24773 </span>            :     declarator = NULL;
<span class="lineNum">   24774 </span>            :   else
<span class="lineNum">   24775 </span>            :     declarator = cp_parser_declarator (parser, CP_PARSER_DECLARATOR_EITHER,
<span class="lineNum">   24776 </span>            :                                        /*ctor_dtor_or_conv_p=*/NULL,
<span class="lineNum">   24777 </span>            :                                        /*parenthesized_p=*/NULL,
<span class="lineNum">   24778 </span>            :                                        /*member_p=*/false,
<span class="lineNum">   24779 </span>            :                                        /*friend_p=*/false);
<span class="lineNum">   24780 </span>            : 
<span class="lineNum">   24781 </span>            :   /* Restore the saved message.  */
<span class="lineNum">   24782 </span>            :   parser-&gt;type_definition_forbidden_message = saved_message;
<span class="lineNum">   24783 </span>            : 
<span class="lineNum">   24784 </span>            :   if (!type_specifiers.any_specifiers_p)
<span class="lineNum">   24785 </span>            :     return error_mark_node;
<span class="lineNum">   24786 </span><span class="lineCov">     118063 : </span>
<span class="lineNum">   24787 </span>            :   return grokdeclarator (declarator, &amp;type_specifiers, CATCHPARM, 1, NULL);
<span class="lineNum">   24788 </span><span class="lineCov">     118063 : }</span>
<span class="lineNum">   24789 </span><span class="lineCov">     118063 : </span>
<span class="lineNum">   24790 </span><span class="lineCov">     118063 : /* Parse a throw-expression.</span>
<span class="lineNum">   24791 </span>            : 
<span class="lineNum">   24792 </span>            :    throw-expression:
<span class="lineNum">   24793 </span><span class="lineCov">     118063 :      throw assignment-expression [opt]</span>
<span class="lineNum">   24794 </span>            : 
<span class="lineNum">   24795 </span>            :    Returns a THROW_EXPR representing the throw-expression.  */
<a name="24796"><span class="lineNum">   24796 </span><span class="lineCov">      81079 : </span></a>
<span class="lineNum">   24797 </span><span class="lineCov">      81079 : static tree</span>
<span class="lineNum">   24798 </span>            : cp_parser_throw_expression (cp_parser* parser)
<span class="lineNum">   24799 </span>            : {
<span class="lineNum">   24800 </span>            :   tree expression;
<span class="lineNum">   24801 </span><span class="lineCov">      36984 :   cp_token* token;</span>
<span class="lineNum">   24802 </span><span class="lineCov">      36984 : </span>
<span class="lineNum">   24803 </span><span class="lineCov">      36984 :   cp_parser_require_keyword (parser, RID_THROW, RT_THROW);</span>
<span class="lineNum">   24804 </span>            :   token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   24805 </span>            :   /* Figure out whether or not there is an assignment-expression
<span class="lineNum">   24806 </span><span class="lineCov">      36984 :      following the &quot;throw&quot; keyword.  */</span>
<span class="lineNum">   24807 </span>            :   if (token-&gt;type == CPP_COMMA
<span class="lineNum">   24808 </span>            :       || token-&gt;type == CPP_SEMICOLON
<span class="lineNum">   24809 </span>            :       || token-&gt;type == CPP_CLOSE_PAREN
<span class="lineNum">   24810 </span><span class="lineCov">      36984 :       || token-&gt;type == CPP_CLOSE_SQUARE</span>
<span class="lineNum">   24811 </span>            :       || token-&gt;type == CPP_CLOSE_BRACE
<span class="lineNum">   24812 </span>            :       || token-&gt;type == CPP_COLON)
<span class="lineNum">   24813 </span><span class="lineCov">      36345 :     expression = NULL_TREE;</span>
<span class="lineNum">   24814 </span>            :   else
<span class="lineNum">   24815 </span>            :     expression = cp_parser_assignment_expression (parser);
<span class="lineNum">   24816 </span>            : 
<span class="lineNum">   24817 </span>            :   return build_throw (expression);
<span class="lineNum">   24818 </span>            : }
<span class="lineNum">   24819 </span>            : 
<span class="lineNum">   24820 </span><span class="lineCov">      36984 : /* GNU Extensions */</span>
<span class="lineNum">   24821 </span>            : 
<span class="lineNum">   24822 </span><span class="lineCov">      36984 : /* Parse an (optional) asm-specification.</span>
<span class="lineNum">   24823 </span><span class="lineCov">         27 : </span>
<span class="lineNum">   24824 </span>            :    asm-specification:
<span class="lineNum">   24825 </span><span class="lineCov">      36957 :      asm ( string-literal )</span>
<span class="lineNum">   24826 </span>            : 
<span class="lineNum">   24827 </span>            :    If the asm-specification is present, returns a STRING_CST
<span class="lineNum">   24828 </span>            :    corresponding to the string-literal.  Otherwise, returns
<span class="lineNum">   24829 </span>            :    NULL_TREE.  */
<a name="24830"><span class="lineNum">   24830 </span>            : </a>
<span class="lineNum">   24831 </span>            : static tree
<span class="lineNum">   24832 </span>            : cp_parser_asm_specification_opt (cp_parser* parser)
<span class="lineNum">   24833 </span>            : {
<span class="lineNum">   24834 </span>            :   cp_token *token;
<span class="lineNum">   24835 </span>            :   tree asm_specification;
<span class="lineNum">   24836 </span><span class="lineCov">      88856 : </span>
<span class="lineNum">   24837 </span>            :   /* Peek at the next token.  */
<span class="lineNum">   24838 </span><span class="lineCov">      88856 :   token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   24839 </span><span class="lineCov">      88856 :   /* If the next token isn't the `asm' keyword, then there's no</span>
<span class="lineNum">   24840 </span>            :      asm-specification.  */
<span class="lineNum">   24841 </span><span class="lineCov">      88856 :   if (!cp_parser_is_keyword (token, RID_ASM))</span>
<span class="lineNum">   24842 </span><span class="lineCov">     177712 :     return NULL_TREE;</span>
<span class="lineNum">   24843 </span>            : 
<span class="lineNum">   24844 </span>            :   /* Consume the `asm' token.  */
<span class="lineNum">   24845 </span><span class="lineCov">     177712 :   cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   24846 </span><span class="lineCov">      88856 :   /* Look for the `('.  */</span>
<span class="lineNum">   24847 </span><span class="lineCov">      16537 :   matching_parens parens;</span>
<span class="lineNum">   24848 </span><span class="lineCov">      16532 :   parens.require_open (parser);</span>
<span class="lineNum">   24849 </span><span class="lineCov">      16532 : </span>
<span class="lineNum">   24850 </span><span class="lineCov">      16532 :   /* Look for the string-literal.  */</span>
<span class="lineNum">   24851 </span>            :   asm_specification = cp_parser_string_literal (parser, false, false);
<span class="lineNum">   24852 </span>            : 
<span class="lineNum">   24853 </span><span class="lineCov">      16532 :   /* Look for the `)'.  */</span>
<span class="lineNum">   24854 </span>            :   parens.require_close (parser);
<span class="lineNum">   24855 </span><span class="lineCov">      88856 : </span>
<span class="lineNum">   24856 </span>            :   return asm_specification;
<span class="lineNum">   24857 </span>            : }
<span class="lineNum">   24858 </span>            : 
<span class="lineNum">   24859 </span>            : /* Parse an asm-operand-list.
<span class="lineNum">   24860 </span>            : 
<span class="lineNum">   24861 </span>            :    asm-operand-list:
<span class="lineNum">   24862 </span>            :      asm-operand
<span class="lineNum">   24863 </span>            :      asm-operand-list , asm-operand
<span class="lineNum">   24864 </span>            : 
<span class="lineNum">   24865 </span>            :    asm-operand:
<span class="lineNum">   24866 </span>            :      string-literal ( expression )
<span class="lineNum">   24867 </span>            :      [ string-literal ] string-literal ( expression )
<span class="lineNum">   24868 </span>            : 
<span class="lineNum">   24869 </span>            :    Returns a TREE_LIST representing the operands.  The TREE_VALUE of
<span class="lineNum">   24870 </span><span class="lineCov">   17135528 :    each node is the expression.  The TREE_PURPOSE is itself a</span>
<span class="lineNum">   24871 </span>            :    TREE_LIST whose TREE_PURPOSE is a STRING_CST for the bracketed
<span class="lineNum">   24872 </span><span class="lineCov">   17135528 :    string-literal (or NULL_TREE if not present) and whose TREE_VALUE</span>
<span class="lineNum">   24873 </span><span class="lineCov">   17135528 :    is a STRING_CST for the string literal before the parenthesis. Returns</span>
<span class="lineNum">   24874 </span>            :    ERROR_MARK_NODE if any of the operands are invalid.  */
<a name="24875"><span class="lineNum">   24875 </span>            : </a>
<span class="lineNum">   24876 </span><span class="lineCov">   34271056 : static tree</span>
<span class="lineNum">   24877 </span>            : cp_parser_asm_operand_list (cp_parser* parser)
<span class="lineNum">   24878 </span>            : {
<span class="lineNum">   24879 </span><span class="lineCov">   17135528 :   tree asm_operands = NULL_TREE;</span>
<span class="lineNum">   24880 </span>            :   bool invalid_operands = false;
<span class="lineNum">   24881 </span>            : 
<span class="lineNum">   24882 </span>            :   while (true)
<span class="lineNum">   24883 </span><span class="lineCov">      41208 :     {</span>
<span class="lineNum">   24884 </span>            :       tree string_literal;
<span class="lineNum">   24885 </span><span class="lineCov">      82416 :       tree expression;</span>
<span class="lineNum">   24886 </span><span class="lineCov">      41208 :       tree name;</span>
<span class="lineNum">   24887 </span>            : 
<span class="lineNum">   24888 </span>            :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_SQUARE))
<span class="lineNum">   24889 </span><span class="lineCov">      41208 :         {</span>
<span class="lineNum">   24890 </span>            :           /* Consume the `[' token.  */
<span class="lineNum">   24891 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   24892 </span><span class="lineCov">      82416 :           /* Read the operand name.  */</span>
<span class="lineNum">   24893 </span>            :           name = cp_parser_identifier (parser);
<span class="lineNum">   24894 </span><span class="lineCov">      41208 :           if (name != error_mark_node)</span>
<span class="lineNum">   24895 </span>            :             name = build_string (IDENTIFIER_LENGTH (name),
<span class="lineNum">   24896 </span>            :                                  IDENTIFIER_POINTER (name));
<span class="lineNum">   24897 </span>            :           /* Look for the closing `]'.  */
<span class="lineNum">   24898 </span>            :           cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);
<span class="lineNum">   24899 </span>            :         }
<span class="lineNum">   24900 </span>            :       else
<span class="lineNum">   24901 </span>            :         name = NULL_TREE;
<span class="lineNum">   24902 </span>            :       /* Look for the string-literal.  */
<span class="lineNum">   24903 </span>            :       string_literal = cp_parser_string_literal (parser, false, false);
<span class="lineNum">   24904 </span>            : 
<span class="lineNum">   24905 </span>            :       /* Look for the `('.  */
<span class="lineNum">   24906 </span>            :       matching_parens parens;
<span class="lineNum">   24907 </span>            :       parens.require_open (parser);
<span class="lineNum">   24908 </span>            :       /* Parse the expression.  */
<span class="lineNum">   24909 </span>            :       expression = cp_parser_expression (parser);
<span class="lineNum">   24910 </span>            :       /* Look for the `)'.  */
<span class="lineNum">   24911 </span>            :       parens.require_close (parser);
<span class="lineNum">   24912 </span>            : 
<span class="lineNum">   24913 </span>            :       if (name == error_mark_node 
<span class="lineNum">   24914 </span>            :           || string_literal == error_mark_node 
<span class="lineNum">   24915 </span><span class="lineCov">      12218 :           || expression == error_mark_node)</span>
<span class="lineNum">   24916 </span>            :         invalid_operands = true;
<span class="lineNum">   24917 </span><span class="lineCov">      12218 : </span>
<span class="lineNum">   24918 </span><span class="lineCov">      12218 :       /* Add this operand to the list.  */</span>
<span class="lineNum">   24919 </span>            :       asm_operands = tree_cons (build_tree_list (name, string_literal),
<span class="lineNum">   24920 </span><span class="lineCov">      23722 :                                 expression,</span>
<span class="lineNum">   24921 </span>            :                                 asm_operands);
<span class="lineNum">   24922 </span><span class="lineCov">      23722 :       /* If the next token is not a `,', there are no more</span>
<span class="lineNum">   24923 </span><span class="lineCov">      23722 :          operands.  */</span>
<span class="lineNum">   24924 </span><span class="lineCov">      23722 :       if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_COMMA))</span>
<span class="lineNum">   24925 </span>            :         break;
<span class="lineNum">   24926 </span><span class="lineCov">      23722 :       /* Consume the `,'.  */</span>
<span class="lineNum">   24927 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   24928 </span>            :     }
<span class="lineNum">   24929 </span><span class="lineCov">         50 : </span>
<span class="lineNum">   24930 </span>            :   return invalid_operands ? error_mark_node : nreverse (asm_operands);
<span class="lineNum">   24931 </span><span class="lineCov">         50 : }</span>
<span class="lineNum">   24932 </span><span class="lineCov">         50 : </span>
<span class="lineNum">   24933 </span><span class="lineCov">         47 : /* Parse an asm-clobber-list.</span>
<span class="lineNum">   24934 </span><span class="lineCov">         47 : </span>
<span class="lineNum">   24935 </span>            :    asm-clobber-list:
<span class="lineNum">   24936 </span><span class="lineCov">         50 :      string-literal</span>
<span class="lineNum">   24937 </span>            :      asm-clobber-list , string-literal
<span class="lineNum">   24938 </span>            : 
<span class="lineNum">   24939 </span>            :    Returns a TREE_LIST, indicating the clobbers in the order that they
<span class="lineNum">   24940 </span>            :    appeared.  The TREE_VALUE of each node is a STRING_CST.  */
<a name="24941"><span class="lineNum">   24941 </span><span class="lineCov">      23722 : </span></a>
<span class="lineNum">   24942 </span>            : static tree
<span class="lineNum">   24943 </span>            : cp_parser_asm_clobber_list (cp_parser* parser)
<span class="lineNum">   24944 </span><span class="lineCov">      47444 : {</span>
<span class="lineNum">   24945 </span><span class="lineCov">      23722 :   tree clobbers = NULL_TREE;</span>
<span class="lineNum">   24946 </span>            : 
<span class="lineNum">   24947 </span><span class="lineCov">      23722 :   while (true)</span>
<span class="lineNum">   24948 </span>            :     {
<span class="lineNum">   24949 </span><span class="lineCov">      23722 :       tree string_literal;</span>
<span class="lineNum">   24950 </span>            : 
<span class="lineNum">   24951 </span><span class="lineCov">      23722 :       /* Look for the string literal.  */</span>
<span class="lineNum">   24952 </span><span class="lineCov">      23719 :       string_literal = cp_parser_string_literal (parser, false, false);</span>
<span class="lineNum">   24953 </span><span class="lineCov">      23713 :       /* Add it to the list.  */</span>
<span class="lineNum">   24954 </span><span class="lineCov">          9 :       clobbers = tree_cons (NULL_TREE, string_literal, clobbers);</span>
<span class="lineNum">   24955 </span>            :       /* If the next token is not a `,', then the list is
<span class="lineNum">   24956 </span>            :          complete.  */
<span class="lineNum">   24957 </span><span class="lineCov">      23722 :       if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_COMMA))</span>
<span class="lineNum">   24958 </span>            :         break;
<span class="lineNum">   24959 </span>            :       /* Consume the `,' token.  */
<span class="lineNum">   24960 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   24961 </span>            :     }
<span class="lineNum">   24962 </span><span class="lineCov">      23722 : </span>
<span class="lineNum">   24963 </span>            :   return clobbers;
<span class="lineNum">   24964 </span>            : }
<span class="lineNum">   24965 </span><span class="lineCov">      11504 : </span>
<span class="lineNum">   24966 </span><span class="lineCov">      11504 : /* Parse an asm-label-list.</span>
<span class="lineNum">   24967 </span>            : 
<span class="lineNum">   24968 </span><span class="lineCov">      12218 :    asm-label-list:</span>
<span class="lineNum">   24969 </span>            :      identifier
<span class="lineNum">   24970 </span>            :      asm-label-list , identifier
<span class="lineNum">   24971 </span>            : 
<span class="lineNum">   24972 </span>            :    Returns a TREE_LIST, indicating the labels in the order that they
<span class="lineNum">   24973 </span>            :    appeared.  The TREE_VALUE of each node is a label.  */
<a name="24974"><span class="lineNum">   24974 </span>            : </a>
<span class="lineNum">   24975 </span>            : static tree
<span class="lineNum">   24976 </span>            : cp_parser_asm_label_list (cp_parser* parser)
<span class="lineNum">   24977 </span>            : {
<span class="lineNum">   24978 </span>            :   tree labels = NULL_TREE;
<span class="lineNum">   24979 </span>            : 
<span class="lineNum">   24980 </span>            :   while (true)
<span class="lineNum">   24981 </span><span class="lineCov">       8036 :     {</span>
<span class="lineNum">   24982 </span>            :       tree identifier, label, name;
<span class="lineNum">   24983 </span><span class="lineCov">       8036 : </span>
<span class="lineNum">   24984 </span>            :       /* Look for the identifier.  */
<span class="lineNum">   24985 </span><span class="lineCov">      19132 :       identifier = cp_parser_identifier (parser);</span>
<span class="lineNum">   24986 </span>            :       if (!error_operand_p (identifier))
<span class="lineNum">   24987 </span><span class="lineCov">      19132 :         {</span>
<span class="lineNum">   24988 </span>            :           label = lookup_label (identifier);
<span class="lineNum">   24989 </span>            :           if (TREE_CODE (label) == LABEL_DECL)
<span class="lineNum">   24990 </span><span class="lineCov">      19132 :             {</span>
<span class="lineNum">   24991 </span>            :               TREE_USED (label) = 1;
<span class="lineNum">   24992 </span><span class="lineCov">      19132 :               check_goto (label);</span>
<span class="lineNum">   24993 </span>            :               name = build_string (IDENTIFIER_LENGTH (identifier),
<span class="lineNum">   24994 </span>            :                                    IDENTIFIER_POINTER (identifier));
<span class="lineNum">   24995 </span><span class="lineCov">      19132 :               labels = tree_cons (name, label, labels);</span>
<span class="lineNum">   24996 </span>            :             }
<span class="lineNum">   24997 </span>            :         }
<span class="lineNum">   24998 </span><span class="lineCov">      11096 :       /* If the next token is not a `,', then the list is</span>
<span class="lineNum">   24999 </span><span class="lineCov">      11096 :          complete.  */</span>
<span class="lineNum">   25000 </span>            :       if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_COMMA))
<span class="lineNum">   25001 </span><span class="lineCov">       8036 :         break;</span>
<span class="lineNum">   25002 </span>            :       /* Consume the `,' token.  */
<span class="lineNum">   25003 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   25004 </span>            :     }
<span class="lineNum">   25005 </span>            : 
<span class="lineNum">   25006 </span>            :   return nreverse (labels);
<span class="lineNum">   25007 </span>            : }
<span class="lineNum">   25008 </span>            : 
<span class="lineNum">   25009 </span>            : /* Return TRUE iff the next tokens in the stream are possibly the
<span class="lineNum">   25010 </span>            :    beginning of a GNU extension attribute. */
<a name="25011"><span class="lineNum">   25011 </span>            : </a>
<span class="lineNum">   25012 </span>            : static bool
<span class="lineNum">   25013 </span>            : cp_next_tokens_can_be_gnu_attribute_p (cp_parser *parser)
<span class="lineNum">   25014 </span><span class="lineCov">         34 : {</span>
<span class="lineNum">   25015 </span>            :   return cp_nth_tokens_can_be_gnu_attribute_p (parser, 1);
<span class="lineNum">   25016 </span><span class="lineCov">         34 : }</span>
<span class="lineNum">   25017 </span>            : 
<span class="lineNum">   25018 </span><span class="lineCov">         59 : /* Return TRUE iff the next tokens in the stream are possibly the</span>
<span class="lineNum">   25019 </span>            :    beginning of a standard C++-11 attribute specifier.  */
<a name="25020"><span class="lineNum">   25020 </span><span class="lineCov">         59 : </span></a>
<span class="lineNum">   25021 </span>            : static bool
<span class="lineNum">   25022 </span>            : cp_next_tokens_can_be_std_attribute_p (cp_parser *parser)
<span class="lineNum">   25023 </span><span class="lineCov">         59 : {</span>
<span class="lineNum">   25024 </span><span class="lineCov">         59 :   return cp_nth_tokens_can_be_std_attribute_p (parser, 1);</span>
<span class="lineNum">   25025 </span>            : }
<span class="lineNum">   25026 </span><span class="lineCov">         56 : </span>
<span class="lineNum">   25027 </span><span class="lineCov">         56 : /* Return TRUE iff the next Nth tokens in the stream are possibly the</span>
<span class="lineNum">   25028 </span>            :    beginning of a standard C++-11 attribute specifier.  */
<a name="25029"><span class="lineNum">   25029 </span><span class="lineCov">         56 : </span></a>
<span class="lineNum">   25030 </span><span class="lineCov">         56 : static bool</span>
<span class="lineNum">   25031 </span><span class="lineCov">         56 : cp_nth_tokens_can_be_std_attribute_p (cp_parser *parser, size_t n)</span>
<span class="lineNum">   25032 </span><span class="lineCov">         56 : {</span>
<span class="lineNum">   25033 </span><span class="lineCov">         56 :   cp_token *token = cp_lexer_peek_nth_token (parser-&gt;lexer, n);</span>
<span class="lineNum">   25034 </span>            : 
<span class="lineNum">   25035 </span>            :   return (cxx_dialect &gt;= cxx11
<span class="lineNum">   25036 </span>            :           &amp;&amp; ((token-&gt;type == CPP_KEYWORD &amp;&amp; token-&gt;keyword == RID_ALIGNAS)
<span class="lineNum">   25037 </span>            :               || (token-&gt;type == CPP_OPEN_SQUARE
<span class="lineNum">   25038 </span><span class="lineCov">         59 :                   &amp;&amp; (token = cp_lexer_peek_nth_token (parser-&gt;lexer, n + 1))</span>
<span class="lineNum">   25039 </span>            :                   &amp;&amp; token-&gt;type == CPP_OPEN_SQUARE)));
<span class="lineNum">   25040 </span>            : }
<span class="lineNum">   25041 </span><span class="lineCov">         25 : </span>
<span class="lineNum">   25042 </span><span class="lineCov">         25 : /* Return TRUE iff the next Nth tokens in the stream are possibly the</span>
<span class="lineNum">   25043 </span>            :    beginning of a GNU extension attribute.  */
<a name="25044"><span class="lineNum">   25044 </span><span class="lineCov">         34 : </span></a>
<span class="lineNum">   25045 </span>            : static bool
<span class="lineNum">   25046 </span>            : cp_nth_tokens_can_be_gnu_attribute_p (cp_parser *parser, size_t n)
<span class="lineNum">   25047 </span>            : {
<span class="lineNum">   25048 </span>            :   cp_token *token = cp_lexer_peek_nth_token (parser-&gt;lexer, n);
<span class="lineNum">   25049 </span>            : 
<span class="lineNum">   25050 </span>            :   return token-&gt;type == CPP_KEYWORD &amp;&amp; token-&gt;keyword == RID_ATTRIBUTE;
<span class="lineNum">   25051 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   25052 </span>            : 
<span class="lineNum">   25053 </span><span class="lineCov">  377899982 : /* Return true iff the next tokens can be the beginning of either a</span>
<span class="lineNum">   25054 </span>            :    GNU attribute list, or a standard C++11 attribute sequence.  */
<a name="25055"><span class="lineNum">   25055 </span>            : </a>
<span class="lineNum">   25056 </span>            : static bool
<span class="lineNum">   25057 </span>            : cp_next_tokens_can_be_attribute_p (cp_parser *parser)
<span class="lineNum">   25058 </span>            : {
<span class="lineNum">   25059 </span>            :   return (cp_next_tokens_can_be_gnu_attribute_p (parser)
<span class="lineNum">   25060 </span><span class="lineNoCov">          0 :           || cp_next_tokens_can_be_std_attribute_p (parser));</span>
<span class="lineNum">   25061 </span>            : }
<span class="lineNum">   25062 </span><span class="lineCov">    3417253 : </span>
<span class="lineNum">   25063 </span>            : /* Return true iff the next Nth tokens can be the beginning of either
<span class="lineNum">   25064 </span>            :    a GNU attribute list, or a standard C++11 attribute sequence.  */
<a name="25065"><span class="lineNum">   25065 </span>            : </a>
<span class="lineNum">   25066 </span>            : static bool
<span class="lineNum">   25067 </span>            : cp_nth_tokens_can_be_attribute_p (cp_parser *parser, size_t n)
<span class="lineNum">   25068 </span>            : {
<span class="lineNum">   25069 </span><span class="lineCov">  155028386 :   return (cp_nth_tokens_can_be_gnu_attribute_p (parser, n)</span>
<span class="lineNum">   25070 </span>            :           || cp_nth_tokens_can_be_std_attribute_p (parser, n));
<span class="lineNum">   25071 </span><span class="lineCov">  155028386 : }</span>
<span class="lineNum">   25072 </span>            : 
<span class="lineNum">   25073 </span><span class="lineCov">  155028386 : /* Parse either a standard C++-11 attribute-specifier-seq, or a series</span>
<span class="lineNum">   25074 </span><span class="lineCov">  155028386 :    of GNU attributes, or return NULL.  */</span>
<a name="25075"><span class="lineNum">   25075 </span><span class="lineCov">  145692438 : </span></a>
<span class="lineNum">   25076 </span><span class="lineCov">    1174765 : static tree</span>
<span class="lineNum">   25077 </span><span class="lineCov">    1174765 : cp_parser_attributes_opt (cp_parser *parser)</span>
<span class="lineNum">   25078 </span>            : {
<span class="lineNum">   25079 </span>            :   if (cp_next_tokens_can_be_gnu_attribute_p (parser))
<span class="lineNum">   25080 </span>            :     return cp_parser_gnu_attributes_opt (parser);
<span class="lineNum">   25081 </span>            :   return cp_parser_std_attribute_spec_seq (parser);
<span class="lineNum">   25082 </span>            : }
<span class="lineNum">   25083 </span>            : 
<span class="lineNum">   25084 </span><span class="lineNoCov">          0 : /* Parse an (optional) series of attributes.</span>
<span class="lineNum">   25085 </span>            : 
<span class="lineNum">   25086 </span><span class="lineCov">       1040 :    attributes:</span>
<span class="lineNum">   25087 </span>            :      attributes attribute
<span class="lineNum">   25088 </span><span class="lineCov">       1040 : </span>
<span class="lineNum">   25089 </span>            :    attribute:
<span class="lineNum">   25090 </span>            :      __attribute__ (( attribute-list [opt] ))
<span class="lineNum">   25091 </span>            : 
<span class="lineNum">   25092 </span>            :    The return value is as for cp_parser_gnu_attribute_list.  */
<a name="25093"><span class="lineNum">   25093 </span>            : </a>
<span class="lineNum">   25094 </span>            : static tree
<span class="lineNum">   25095 </span><span class="lineCov">  147080960 : cp_parser_gnu_attributes_opt (cp_parser* parser)</span>
<span class="lineNum">   25096 </span>            : {
<span class="lineNum">   25097 </span><span class="lineCov">  147080960 :   tree attributes = NULL_TREE;</span>
<span class="lineNum">   25098 </span><span class="lineCov">  147080960 : </span>
<span class="lineNum">   25099 </span>            :   temp_override&lt;bool&gt; cleanup
<span class="lineNum">   25100 </span>            :     (parser-&gt;auto_is_implicit_function_template_parm_p, false);
<span class="lineNum">   25101 </span>            : 
<span class="lineNum">   25102 </span>            :   while (true)
<span class="lineNum">   25103 </span>            :     {
<span class="lineNum">   25104 </span>            :       cp_token *token;
<span class="lineNum">   25105 </span><span class="lineCov">    5519624 :       tree attribute_list;</span>
<span class="lineNum">   25106 </span>            :       bool ok = true;
<span class="lineNum">   25107 </span><span class="lineCov">    5519624 : </span>
<span class="lineNum">   25108 </span><span class="lineCov">    5519624 :       /* Peek at the next token.  */</span>
<span class="lineNum">   25109 </span>            :       token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   25110 </span>            :       /* If it's not `__attribute__', then we're done.  */
<span class="lineNum">   25111 </span>            :       if (token-&gt;keyword != RID_ATTRIBUTE)
<span class="lineNum">   25112 </span>            :         break;
<span class="lineNum">   25113 </span>            : 
<span class="lineNum">   25114 </span>            :       /* Consume the `__attribute__' keyword.  */
<span class="lineNum">   25115 </span><span class="lineCov">   41867987 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   25116 </span>            :       /* Look for the two `(' tokens.  */
<span class="lineNum">   25117 </span><span class="lineCov">   41867987 :       matching_parens outer_parens;</span>
<span class="lineNum">   25118 </span><span class="lineCov">    2468823 :       outer_parens.require_open (parser);</span>
<span class="lineNum">   25119 </span><span class="lineCov">   39399164 :       matching_parens inner_parens;</span>
<span class="lineNum">   25120 </span>            :       inner_parens.require_open (parser);
<span class="lineNum">   25121 </span>            : 
<span class="lineNum">   25122 </span>            :       /* Peek at the next token.  */
<span class="lineNum">   25123 </span>            :       token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   25124 </span>            :       if (token-&gt;type != CPP_CLOSE_PAREN)
<span class="lineNum">   25125 </span>            :         /* Parse the attribute-list.  */
<span class="lineNum">   25126 </span>            :         attribute_list = cp_parser_gnu_attribute_list (parser);
<span class="lineNum">   25127 </span>            :       else
<span class="lineNum">   25128 </span>            :         /* If the next token is a `)', then there is no attribute
<span class="lineNum">   25129 </span>            :            list.  */
<span class="lineNum">   25130 </span>            :         attribute_list = NULL;
<span class="lineNum">   25131 </span>            : 
<span class="lineNum">   25132 </span>            :       /* Look for the two `)' tokens.  */
<span class="lineNum">   25133 </span><span class="lineCov">   70705631 :       if (!inner_parens.require_close (parser))</span>
<span class="lineNum">   25134 </span>            :         ok = false;
<span class="lineNum">   25135 </span><span class="lineCov">   70705631 :       if (!outer_parens.require_close (parser))</span>
<span class="lineNum">   25136 </span>            :         ok = false;
<span class="lineNum">   25137 </span><span class="lineCov">   70705631 :       if (!ok)</span>
<span class="lineNum">   25138 </span><span class="lineCov">   70705631 :         cp_parser_skip_to_end_of_statement (parser);</span>
<span class="lineNum">   25139 </span>            : 
<span class="lineNum">   25140 </span><span class="lineCov">   73252974 :       /* Add these new attributes to the list.  */</span>
<span class="lineNum">   25141 </span>            :       attributes = attr_chainon (attributes, attribute_list);
<span class="lineNum">   25142 </span><span class="lineCov">   73252974 :     }</span>
<span class="lineNum">   25143 </span><span class="lineCov">   73252974 : </span>
<span class="lineNum">   25144 </span><span class="lineCov">   73252974 :   return attributes;</span>
<span class="lineNum">   25145 </span>            : }
<span class="lineNum">   25146 </span>            : 
<span class="lineNum">   25147 </span><span class="lineCov">  146505948 : /* Parse a GNU attribute-list.</span>
<span class="lineNum">   25148 </span>            : 
<span class="lineNum">   25149 </span><span class="lineCov">   73252974 :    attribute-list:</span>
<span class="lineNum">   25150 </span>            :      attribute
<span class="lineNum">   25151 </span>            :      attribute-list , attribute
<span class="lineNum">   25152 </span>            : 
<span class="lineNum">   25153 </span><span class="lineCov">    2547343 :    attribute:</span>
<span class="lineNum">   25154 </span>            :      identifier
<span class="lineNum">   25155 </span><span class="lineCov">    5094686 :      identifier ( identifier )</span>
<span class="lineNum">   25156 </span><span class="lineCov">    2547343 :      identifier ( identifier , expression-list )</span>
<span class="lineNum">   25157 </span><span class="lineCov">    5094686 :      identifier ( expression-list )</span>
<span class="lineNum">   25158 </span><span class="lineCov">    2547343 : </span>
<span class="lineNum">   25159 </span>            :    Returns a TREE_LIST, or NULL_TREE on error.  Each node corresponds
<span class="lineNum">   25160 </span>            :    to an attribute.  The TREE_PURPOSE of each node is the identifier
<span class="lineNum">   25161 </span><span class="lineCov">    5094686 :    indicating which attribute is in use.  The TREE_VALUE represents</span>
<span class="lineNum">   25162 </span><span class="lineCov">    2547343 :    the arguments, if any.  */</span>
<a name="25163"><span class="lineNum">   25163 </span>            : </a>
<span class="lineNum">   25164 </span><span class="lineCov">    2547340 : static tree</span>
<span class="lineNum">   25165 </span>            : cp_parser_gnu_attribute_list (cp_parser* parser)
<span class="lineNum">   25166 </span>            : {
<span class="lineNum">   25167 </span>            :   tree attribute_list = NULL_TREE;
<span class="lineNum">   25168 </span>            :   bool save_translate_strings_p = parser-&gt;translate_strings_p;
<span class="lineNum">   25169 </span>            : 
<span class="lineNum">   25170 </span>            :   parser-&gt;translate_strings_p = false;
<span class="lineNum">   25171 </span><span class="lineCov">    2547343 :   while (true)</span>
<span class="lineNum">   25172 </span><span class="lineCov">         34 :     {</span>
<span class="lineNum">   25173 </span><span class="lineCov">    2547343 :       cp_token *token;</span>
<span class="lineNum">   25174 </span>            :       tree identifier;
<span class="lineNum">   25175 </span><span class="lineCov">    2547297 :       tree attribute;</span>
<span class="lineNum">   25176 </span><span class="lineCov">         46 : </span>
<span class="lineNum">   25177 </span>            :       /* Look for the identifier.  We also allow keywords here; for
<span class="lineNum">   25178 </span>            :          example `__attribute__ ((const))' is legal.  */
<span class="lineNum">   25179 </span><span class="lineCov">    2547343 :       token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   25180 </span>            :       if (token-&gt;type == CPP_NAME
<span class="lineNum">   25181 </span>            :           || token-&gt;type == CPP_KEYWORD)
<span class="lineNum">   25182 </span><span class="lineCov">  141411262 :         {</span>
<span class="lineNum">   25183 </span>            :           tree arguments = NULL_TREE;
<span class="lineNum">   25184 </span>            : 
<span class="lineNum">   25185 </span>            :           /* Consume the token, but save it since we need it for the
<span class="lineNum">   25186 </span>            :              SIMD enabled function parsing.  */
<span class="lineNum">   25187 </span>            :           cp_token *id_token = cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   25188 </span>            : 
<span class="lineNum">   25189 </span>            :           /* Save away the identifier that indicates which attribute
<span class="lineNum">   25190 </span>            :              this is.  */
<span class="lineNum">   25191 </span>            :           identifier = (token-&gt;type == CPP_KEYWORD) 
<span class="lineNum">   25192 </span>            :             /* For keywords, use the canonical spelling, not the
<span class="lineNum">   25193 </span>            :                parsed identifier.  */
<span class="lineNum">   25194 </span>            :             ? ridpointers[(int) token-&gt;keyword]
<span class="lineNum">   25195 </span>            :             : id_token-&gt;u.value;
<span class="lineNum">   25196 </span>            : 
<span class="lineNum">   25197 </span>            :           identifier = canonicalize_attr_name (identifier);
<span class="lineNum">   25198 </span>            :           attribute = build_tree_list (identifier, NULL_TREE);
<span class="lineNum">   25199 </span>            : 
<span class="lineNum">   25200 </span>            :           /* Peek at the next token.  */
<span class="lineNum">   25201 </span>            :           token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   25202 </span>            :           /* If it's an `(', then parse the attribute arguments.  */
<span class="lineNum">   25203 </span><span class="lineCov">    2547340 :           if (token-&gt;type == CPP_OPEN_PAREN)</span>
<span class="lineNum">   25204 </span>            :             {
<span class="lineNum">   25205 </span><span class="lineCov">    2547340 :               vec&lt;tree, va_gc&gt; *vec;</span>
<span class="lineNum">   25206 </span><span class="lineCov">    2547340 :               int attr_flag = (attribute_takes_identifier_p (identifier)</span>
<span class="lineNum">   25207 </span>            :                                ? id_attr : normal_attr);
<span class="lineNum">   25208 </span><span class="lineCov">    2547340 :               vec = cp_parser_parenthesized_expression_list </span>
<span class="lineNum">   25209 </span><span class="lineCov">    3946993 :                     (parser, attr_flag, /*cast_p=*/false, </span>
<span class="lineNum">   25210 </span>            :                     /*allow_expansion_p=*/false, 
<span class="lineNum">   25211 </span><span class="lineCov">    3946993 :                     /*non_constant_p=*/NULL);</span>
<span class="lineNum">   25212 </span><span class="lineCov">    3946993 :               if (vec == NULL)</span>
<span class="lineNum">   25213 </span><span class="lineCov">    3946993 :                 arguments = error_mark_node;</span>
<span class="lineNum">   25214 </span>            :               else
<span class="lineNum">   25215 </span>            :                 {
<span class="lineNum">   25216 </span>            :                   arguments = build_tree_list_vec (vec);
<span class="lineNum">   25217 </span><span class="lineCov">    7893986 :                   release_tree_vector (vec);</span>
<span class="lineNum">   25218 </span><span class="lineCov">    3946993 :                 }</span>
<span class="lineNum">   25219 </span><span class="lineCov">     149489 :               /* Save the arguments away.  */</span>
<span class="lineNum">   25220 </span>            :               TREE_VALUE (attribute) = arguments;
<span class="lineNum">   25221 </span><span class="lineCov">    3946987 :             }</span>
<span class="lineNum">   25222 </span>            : 
<span class="lineNum">   25223 </span>            :           if (arguments != error_mark_node)
<span class="lineNum">   25224 </span>            :             {
<span class="lineNum">   25225 </span><span class="lineCov">    3946987 :               /* Add this attribute to the list.  */</span>
<span class="lineNum">   25226 </span>            :               TREE_CHAIN (attribute) = attribute_list;
<span class="lineNum">   25227 </span>            :               attribute_list = attribute;
<span class="lineNum">   25228 </span>            :             }
<span class="lineNum">   25229 </span><span class="lineCov">    7893974 : </span>
<span class="lineNum">   25230 </span>            :           token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   25231 </span>            :         }
<span class="lineNum">   25232 </span><span class="lineCov">    3946987 :       /* Now, look for more attributes.  If the next token isn't a</span>
<span class="lineNum">   25233 </span>            :          `,', we're done.  */
<span class="lineNum">   25234 </span>            :       if (token-&gt;type != CPP_COMMA)
<span class="lineNum">   25235 </span><span class="lineCov">    3946987 :         break;</span>
<span class="lineNum">   25236 </span><span class="lineCov">    3946987 : </span>
<span class="lineNum">   25237 </span>            :       /* Consume the comma and keep going.  */
<span class="lineNum">   25238 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   25239 </span><span class="lineCov">    7893974 :     }</span>
<span class="lineNum">   25240 </span>            :   parser-&gt;translate_strings_p = save_translate_strings_p;
<span class="lineNum">   25241 </span><span class="lineCov">    3946987 : </span>
<span class="lineNum">   25242 </span>            :   /* We built up the list in reverse order.  */
<span class="lineNum">   25243 </span><span class="lineCov">    1218372 :   return nreverse (attribute_list);</span>
<span class="lineNum">   25244 </span><span class="lineCov">    1218372 : }</span>
<span class="lineNum">   25245 </span><span class="lineCov">    1218372 : </span>
<span class="lineNum">   25246 </span><span class="lineCov">    1218372 : /*  Parse a standard C++11 attribute.</span>
<span class="lineNum">   25247 </span><span class="lineCov">    1218372 : </span>
<span class="lineNum">   25248 </span>            :     The returned representation is a TREE_LIST which TREE_PURPOSE is
<span class="lineNum">   25249 </span>            :     the scoped name of the attribute, and the TREE_VALUE is its
<span class="lineNum">   25250 </span><span class="lineCov">    1218372 :     arguments list.</span>
<span class="lineNum">   25251 </span><span class="lineCov">         28 : </span>
<span class="lineNum">   25252 </span>            :     Note that the scoped name of the attribute is itself a TREE_LIST
<span class="lineNum">   25253 </span>            :     which TREE_PURPOSE is the namespace of the attribute, and
<span class="lineNum">   25254 </span><span class="lineCov">    1218344 :     TREE_VALUE its name.  This is unlike a GNU attribute -- as parsed</span>
<span class="lineNum">   25255 </span><span class="lineCov">    1218344 :     by cp_parser_gnu_attribute_list -- that doesn't have any namespace</span>
<span class="lineNum">   25256 </span>            :     and which TREE_PURPOSE is directly the attribute name.
<span class="lineNum">   25257 </span>            : 
<span class="lineNum">   25258 </span><span class="lineCov">    1218372 :     Clients of the attribute code should use get_attribute_namespace</span>
<span class="lineNum">   25259 </span>            :     and get_attribute_name to get the actual namespace and name of
<span class="lineNum">   25260 </span>            :     attributes, regardless of their being GNU or C++11 attributes.
<span class="lineNum">   25261 </span><span class="lineCov">    3946987 : </span>
<span class="lineNum">   25262 </span>            :     attribute:
<span class="lineNum">   25263 </span>            :       attribute-token attribute-argument-clause [opt]
<span class="lineNum">   25264 </span><span class="lineCov">    3946959 : </span>
<span class="lineNum">   25265 </span><span class="lineCov">    3946959 :     attribute-token:</span>
<span class="lineNum">   25266 </span>            :       identifier
<span class="lineNum">   25267 </span>            :       attribute-scoped-token
<span class="lineNum">   25268 </span><span class="lineCov">    3946987 : </span>
<span class="lineNum">   25269 </span>            :     attribute-scoped-token:
<span class="lineNum">   25270 </span>            :       attribute-namespace :: identifier
<span class="lineNum">   25271 </span>            : 
<span class="lineNum">   25272 </span><span class="lineCov">    3946993 :     attribute-namespace:</span>
<span class="lineNum">   25273 </span>            :       identifier
<span class="lineNum">   25274 </span>            : 
<span class="lineNum">   25275 </span>            :     attribute-argument-clause:
<span class="lineNum">   25276 </span><span class="lineCov">    1399653 :       ( balanced-token-seq )</span>
<span class="lineNum">   25277 </span><span class="lineCov">    1399653 : </span>
<span class="lineNum">   25278 </span><span class="lineCov">    2547340 :     balanced-token-seq:</span>
<span class="lineNum">   25279 </span>            :       balanced-token [opt]
<span class="lineNum">   25280 </span>            :       balanced-token-seq balanced-token
<span class="lineNum">   25281 </span><span class="lineCov">    2547340 : </span>
<span class="lineNum">   25282 </span>            :     balanced-token:
<span class="lineNum">   25283 </span>            :       ( balanced-token-seq )
<span class="lineNum">   25284 </span>            :       [ balanced-token-seq ]
<span class="lineNum">   25285 </span>            :       { balanced-token-seq }.  */
<a name="25286"><span class="lineNum">   25286 </span>            : </a>
<span class="lineNum">   25287 </span>            : static tree
<span class="lineNum">   25288 </span>            : cp_parser_std_attribute (cp_parser *parser, tree attr_ns)
<span class="lineNum">   25289 </span>            : {
<span class="lineNum">   25290 </span>            :   tree attribute, attr_id = NULL_TREE, arguments;
<span class="lineNum">   25291 </span>            :   cp_token *token;
<span class="lineNum">   25292 </span>            : 
<span class="lineNum">   25293 </span>            :   temp_override&lt;bool&gt; cleanup
<span class="lineNum">   25294 </span>            :     (parser-&gt;auto_is_implicit_function_template_parm_p, false);
<span class="lineNum">   25295 </span>            : 
<span class="lineNum">   25296 </span>            :   /* First, parse name of the attribute, a.k.a attribute-token.  */
<span class="lineNum">   25297 </span>            : 
<span class="lineNum">   25298 </span>            :   token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   25299 </span>            :   if (token-&gt;type == CPP_NAME)
<span class="lineNum">   25300 </span>            :     attr_id = token-&gt;u.value;
<span class="lineNum">   25301 </span>            :   else if (token-&gt;type == CPP_KEYWORD)
<span class="lineNum">   25302 </span>            :     attr_id = ridpointers[(int) token-&gt;keyword];
<span class="lineNum">   25303 </span>            :   else if (token-&gt;flags &amp; NAMED_OP)
<span class="lineNum">   25304 </span>            :     attr_id = get_identifier (cpp_type2name (token-&gt;type, token-&gt;flags));
<span class="lineNum">   25305 </span>            : 
<span class="lineNum">   25306 </span>            :   if (attr_id == NULL_TREE)
<span class="lineNum">   25307 </span>            :     return NULL_TREE;
<span class="lineNum">   25308 </span>            : 
<span class="lineNum">   25309 </span>            :   cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   25310 </span>            : 
<span class="lineNum">   25311 </span>            :   token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   25312 </span>            :   if (token-&gt;type == CPP_SCOPE)
<span class="lineNum">   25313 </span>            :     {
<span class="lineNum">   25314 </span>            :       /* We are seeing a scoped attribute token.  */
<span class="lineNum">   25315 </span>            : 
<span class="lineNum">   25316 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   25317 </span>            :       if (attr_ns)
<span class="lineNum">   25318 </span>            :         error_at (token-&gt;location, &quot;attribute using prefix used together &quot;
<span class="lineNum">   25319 </span>            :                                    &quot;with scoped attribute token&quot;);
<span class="lineNum">   25320 </span>            :       attr_ns = attr_id;
<span class="lineNum">   25321 </span>            : 
<span class="lineNum">   25322 </span>            :       token = cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   25323 </span>            :       if (token-&gt;type == CPP_NAME)
<span class="lineNum">   25324 </span>            :         attr_id = token-&gt;u.value;
<span class="lineNum">   25325 </span>            :       else if (token-&gt;type == CPP_KEYWORD)
<span class="lineNum">   25326 </span><span class="lineCov">      14418 :         attr_id = ridpointers[(int) token-&gt;keyword];</span>
<span class="lineNum">   25327 </span>            :       else if (token-&gt;flags &amp; NAMED_OP)
<span class="lineNum">   25328 </span><span class="lineCov">      14418 :         attr_id = get_identifier (cpp_type2name (token-&gt;type, token-&gt;flags));</span>
<span class="lineNum">   25329 </span><span class="lineCov">      14418 :       else</span>
<span class="lineNum">   25330 </span>            :         {
<span class="lineNum">   25331 </span><span class="lineCov">      14418 :           error_at (token-&gt;location,</span>
<span class="lineNum">   25332 </span><span class="lineCov">      14418 :                     &quot;expected an identifier for the attribute name&quot;);</span>
<span class="lineNum">   25333 </span>            :           return error_mark_node;
<span class="lineNum">   25334 </span>            :         }
<span class="lineNum">   25335 </span>            : 
<span class="lineNum">   25336 </span><span class="lineCov">      28836 :       attr_id = canonicalize_attr_name (attr_id);</span>
<span class="lineNum">   25337 </span><span class="lineCov">      14418 :       attribute = build_tree_list (build_tree_list (attr_ns, attr_id),</span>
<span class="lineNum">   25338 </span><span class="lineCov">      14376 :                                    NULL_TREE);</span>
<span class="lineNum">   25339 </span><span class="lineCov">         42 :       token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   25340 </span><span class="lineCov">         10 :     }</span>
<span class="lineNum">   25341 </span><span class="lineCov">         32 :   else if (attr_ns)</span>
<span class="lineNum">   25342 </span><span class="lineCov">         20 :     attribute = build_tree_list (build_tree_list (attr_ns, attr_id),</span>
<span class="lineNum">   25343 </span>            :                                  NULL_TREE);
<span class="lineNum">   25344 </span><span class="lineCov">      14406 :   else</span>
<span class="lineNum">   25345 </span><span class="lineCov">         12 :     {</span>
<span class="lineNum">   25346 </span>            :       attr_id = canonicalize_attr_name (attr_id);
<span class="lineNum">   25347 </span><span class="lineCov">      14406 :       attribute = build_tree_list (build_tree_list (NULL_TREE, attr_id),</span>
<span class="lineNum">   25348 </span>            :                                    NULL_TREE);
<span class="lineNum">   25349 </span><span class="lineCov">      28812 :       /* C++11 noreturn attribute is equivalent to GNU's.  */</span>
<span class="lineNum">   25350 </span><span class="lineCov">      14406 :       if (is_attribute_p (&quot;noreturn&quot;, attr_id))</span>
<span class="lineNum">   25351 </span>            :         TREE_PURPOSE (TREE_PURPOSE (attribute)) = gnu_identifier;
<span class="lineNum">   25352 </span>            :       /* C++14 deprecated attribute is equivalent to GNU's.  */
<span class="lineNum">   25353 </span>            :       else if (is_attribute_p (&quot;deprecated&quot;, attr_id))
<span class="lineNum">   25354 </span><span class="lineCov">        586 :         TREE_PURPOSE (TREE_PURPOSE (attribute)) = gnu_identifier;</span>
<span class="lineNum">   25355 </span><span class="lineCov">        586 :       /* C++17 fallthrough attribute is equivalent to GNU's.  */</span>
<span class="lineNum">   25356 </span><span class="lineCov">          4 :       else if (is_attribute_p (&quot;fallthrough&quot;, attr_id))</span>
<span class="lineNum">   25357 </span>            :         TREE_PURPOSE (TREE_PURPOSE (attribute)) = gnu_identifier;
<span class="lineNum">   25358 </span><span class="lineCov">        586 :       /* Transactional Memory TS optimize_for_synchronized attribute is</span>
<span class="lineNum">   25359 </span>            :          equivalent to GNU transaction_callable.  */
<span class="lineNum">   25360 </span><span class="lineCov">        586 :       else if (is_attribute_p (&quot;optimize_for_synchronized&quot;, attr_id))</span>
<span class="lineNum">   25361 </span><span class="lineCov">        586 :         TREE_PURPOSE (attribute)</span>
<span class="lineNum">   25362 </span><span class="lineCov">        570 :           = get_identifier (&quot;transaction_callable&quot;);</span>
<span class="lineNum">   25363 </span><span class="lineCov">         16 :       /* Transactional Memory attributes are GNU attributes.  */</span>
<span class="lineNum">   25364 </span><span class="lineCov">         10 :       else if (tm_attr_to_mask (attr_id))</span>
<span class="lineNum">   25365 </span><span class="lineCov">          6 :         TREE_PURPOSE (attribute) = attr_id;</span>
<span class="lineNum">   25366 </span><span class="lineCov">          6 :     }</span>
<span class="lineNum">   25367 </span>            : 
<span class="lineNum">   25368 </span>            :   /* Now parse the optional argument clause of the attribute.  */
<span class="lineNum">   25369 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   25370 </span>            :   if (token-&gt;type != CPP_OPEN_PAREN)
<span class="lineNum">   25371 </span><span class="lineNoCov">          0 :     return attribute;</span>
<span class="lineNum">   25372 </span>            : 
<span class="lineNum">   25373 </span>            :   {
<span class="lineNum">   25374 </span><span class="lineCov">        586 :     vec&lt;tree, va_gc&gt; *vec;</span>
<span class="lineNum">   25375 </span><span class="lineCov">        586 :     int attr_flag = normal_attr;</span>
<span class="lineNum">   25376 </span>            : 
<span class="lineNum">   25377 </span><span class="lineCov">        586 :     if (attr_ns == gnu_identifier</span>
<span class="lineNum">   25378 </span>            :         &amp;&amp; attribute_takes_identifier_p (attr_id))
<span class="lineNum">   25379 </span><span class="lineCov">      13820 :       /* A GNU attribute that takes an identifier in parameter.  */</span>
<span class="lineNum">   25380 </span><span class="lineCov">         18 :       attr_flag = id_attr;</span>
<span class="lineNum">   25381 </span>            : 
<span class="lineNum">   25382 </span>            :     vec = cp_parser_parenthesized_expression_list
<span class="lineNum">   25383 </span>            :       (parser, attr_flag, /*cast_p=*/false,
<span class="lineNum">   25384 </span><span class="lineCov">      13802 :        /*allow_expansion_p=*/true,</span>
<span class="lineNum">   25385 </span><span class="lineCov">      13802 :        /*non_constant_p=*/NULL);</span>
<span class="lineNum">   25386 </span>            :     if (vec == NULL)
<span class="lineNum">   25387 </span>            :       arguments = error_mark_node;
<span class="lineNum">   25388 </span><span class="lineCov">      13802 :     else</span>
<span class="lineNum">   25389 </span><span class="lineCov">       7821 :       {</span>
<span class="lineNum">   25390 </span>            :         arguments = build_tree_list_vec (vec);
<span class="lineNum">   25391 </span><span class="lineCov">       5981 :         release_tree_vector (vec);</span>
<span class="lineNum">   25392 </span><span class="lineCov">       3153 :       }</span>
<span class="lineNum">   25393 </span>            : 
<span class="lineNum">   25394 </span><span class="lineCov">       2828 :     if (arguments == error_mark_node)</span>
<span class="lineNum">   25395 </span><span class="lineCov">         11 :       attribute = error_mark_node;</span>
<span class="lineNum">   25396 </span>            :     else
<span class="lineNum">   25397 </span>            :       TREE_VALUE (attribute) = arguments;
<span class="lineNum">   25398 </span><span class="lineCov">       2817 :   }</span>
<span class="lineNum">   25399 </span><span class="lineCov">          2 : </span>
<span class="lineNum">   25400 </span><span class="lineCov">          2 :   return attribute;</span>
<span class="lineNum">   25401 </span>            : }
<span class="lineNum">   25402 </span><span class="lineCov">       2815 : </span>
<span class="lineNum">   25403 </span><span class="lineNoCov">          0 : /* Check that the attribute ATTRIBUTE appears at most once in the</span>
<span class="lineNum">   25404 </span>            :    attribute-list ATTRIBUTES.  This is enforced for noreturn (7.6.3)
<span class="lineNum">   25405 </span>            :    and deprecated (7.6.5).  Note that carries_dependency (7.6.4)
<span class="lineNum">   25406 </span>            :    isn't implemented yet in GCC.  */
<a name="25407"><span class="lineNum">   25407 </span>            : </a>
<span class="lineNum">   25408 </span><span class="lineCov">      14406 : static void</span>
<span class="lineNum">   25409 </span>            : cp_parser_check_std_attribute (tree attributes, tree attribute)
<span class="lineNum">   25410 </span>            : {
<span class="lineNum">   25411 </span><span class="lineCov">       1415 :   if (attributes)</span>
<span class="lineNum">   25412 </span><span class="lineCov">       1415 :     {</span>
<span class="lineNum">   25413 </span><span class="lineCov">       1415 :       tree name = get_attribute_name (attribute);</span>
<span class="lineNum">   25414 </span>            :       if (is_attribute_p (&quot;noreturn&quot;, name)
<span class="lineNum">   25415 </span><span class="lineCov">       1415 :           &amp;&amp; lookup_attribute (&quot;noreturn&quot;, attributes))</span>
<span class="lineNum">   25416 </span><span class="lineCov">       1415 :         error (&quot;attribute %&lt;noreturn%&gt; can appear at most once &quot;</span>
<span class="lineNum">   25417 </span>            :                &quot;in an attribute-list&quot;);
<span class="lineNum">   25418 </span>            :       else if (is_attribute_p (&quot;deprecated&quot;, name)
<span class="lineNum">   25419 </span>            :                &amp;&amp; lookup_attribute (&quot;deprecated&quot;, attributes))
<span class="lineNum">   25420 </span><span class="lineCov">       1415 :         error (&quot;attribute %&lt;deprecated%&gt; can appear at most once &quot;</span>
<span class="lineNum">   25421 </span><span class="lineCov">       1415 :                &quot;in an attribute-list&quot;);</span>
<span class="lineNum">   25422 </span>            :     }
<span class="lineNum">   25423 </span>            : }
<span class="lineNum">   25424 </span><span class="lineCov">       1415 : </span>
<span class="lineNum">   25425 </span><span class="lineCov">         18 : /* Parse a list of standard C++-11 attributes.</span>
<span class="lineNum">   25426 </span>            : 
<span class="lineNum">   25427 </span>            :    attribute-list:
<span class="lineNum">   25428 </span><span class="lineCov">       1397 :      attribute [opt]</span>
<span class="lineNum">   25429 </span><span class="lineCov">       1397 :      attribute-list , attribute[opt]</span>
<span class="lineNum">   25430 </span>            :      attribute ...
<span class="lineNum">   25431 </span>            :      attribute-list , attribute ...
<span class="lineNum">   25432 </span><span class="lineCov">       1415 : */</span>
<a name="25433"><span class="lineNum">   25433 </span>            : </a>
<span class="lineNum">   25434 </span>            : static tree
<span class="lineNum">   25435 </span><span class="lineCov">       1397 : cp_parser_std_attribute_list (cp_parser *parser, tree attr_ns)</span>
<span class="lineNum">   25436 </span>            : {
<span class="lineNum">   25437 </span>            :   tree attributes = NULL_TREE, attribute = NULL_TREE;
<span class="lineNum">   25438 </span>            :   cp_token *token = NULL;
<span class="lineNum">   25439 </span>            : 
<span class="lineNum">   25440 </span>            :   while (true)
<span class="lineNum">   25441 </span>            :     {
<span class="lineNum">   25442 </span>            :       attribute = cp_parser_std_attribute (parser, attr_ns);
<span class="lineNum">   25443 </span>            :       if (attribute == error_mark_node)
<span class="lineNum">   25444 </span>            :         break;
<span class="lineNum">   25445 </span>            :       if (attribute != NULL_TREE)
<span class="lineNum">   25446 </span>            :         {
<span class="lineNum">   25447 </span><span class="lineCov">      14388 :           cp_parser_check_std_attribute (attributes, attribute);</span>
<span class="lineNum">   25448 </span>            :           TREE_CHAIN (attribute) = attributes;
<span class="lineNum">   25449 </span><span class="lineCov">      14388 :           attributes = attribute;</span>
<span class="lineNum">   25450 </span>            :         }
<span class="lineNum">   25451 </span><span class="lineCov">         41 :       token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   25452 </span><span class="lineCov">         41 :       if (token-&gt;type == CPP_ELLIPSIS)</span>
<span class="lineNum">   25453 </span><span class="lineCov">         41 :         {</span>
<span class="lineNum">   25454 </span><span class="lineCov">          2 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   25455 </span>            :           if (attribute == NULL_TREE)
<span class="lineNum">   25456 </span><span class="lineCov">         39 :             error_at (token-&gt;location,</span>
<span class="lineNum">   25457 </span><span class="lineCov">         39 :                       &quot;expected attribute before %&lt;...%&gt;&quot;);</span>
<span class="lineNum">   25458 </span><span class="lineCov">          1 :           else</span>
<span class="lineNum">   25459 </span>            :             {
<span class="lineNum">   25460 </span>            :               tree pack = make_pack_expansion (TREE_VALUE (attribute));
<span class="lineNum">   25461 </span><span class="lineCov">      14388 :               if (pack == error_mark_node)</span>
<span class="lineNum">   25462 </span>            :                 return error_mark_node;
<span class="lineNum">   25463 </span>            :               TREE_VALUE (attribute) = pack;
<span class="lineNum">   25464 </span>            :             }
<span class="lineNum">   25465 </span>            :           token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   25466 </span>            :         }
<span class="lineNum">   25467 </span>            :       if (token-&gt;type != CPP_COMMA)
<span class="lineNum">   25468 </span>            :         break;
<span class="lineNum">   25469 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   25470 </span>            :     }
<span class="lineNum">   25471 </span>            :   attributes = nreverse (attributes);
<span class="lineNum">   25472 </span>            :   return attributes;
<span class="lineNum">   25473 </span><span class="lineCov">      14371 : }</span>
<span class="lineNum">   25474 </span>            : 
<span class="lineNum">   25475 </span><span class="lineCov">      14371 : /* Parse a standard C++-11 attribute specifier.</span>
<span class="lineNum">   25476 </span><span class="lineCov">      14371 : </span>
<span class="lineNum">   25477 </span>            :    attribute-specifier:
<span class="lineNum">   25478 </span><span class="lineCov">      14418 :      [ [ attribute-using-prefix [opt] attribute-list ] ]</span>
<span class="lineNum">   25479 </span>            :      alignment-specifier
<span class="lineNum">   25480 </span><span class="lineCov">      14418 : </span>
<span class="lineNum">   25481 </span><span class="lineCov">      14418 :    attribute-using-prefix:</span>
<span class="lineNum">   25482 </span>            :      using attribute-namespace :
<span class="lineNum">   25483 </span><span class="lineCov">      14400 : </span>
<span class="lineNum">   25484 </span>            :    alignment-specifier:
<span class="lineNum">   25485 </span><span class="lineCov">      14388 :      alignas ( type-id ... [opt] )</span>
<span class="lineNum">   25486 </span><span class="lineCov">      14388 :      alignas ( alignment-expression ... [opt] ).  */</span>
<a name="25487"><span class="lineNum">   25487 </span><span class="lineCov">      14388 : </span></a>
<span class="lineNum">   25488 </span>            : static tree
<span class="lineNum">   25489 </span><span class="lineCov">      28800 : cp_parser_std_attribute_spec (cp_parser *parser)</span>
<span class="lineNum">   25490 </span><span class="lineCov">      14400 : {</span>
<span class="lineNum">   25491 </span>            :   tree attributes = NULL_TREE;
<span class="lineNum">   25492 </span><span class="lineCov">         10 :   cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   25493 </span><span class="lineCov">         10 : </span>
<span class="lineNum">   25494 </span><span class="lineCov">          4 :   if (token-&gt;type == CPP_OPEN_SQUARE</span>
<span class="lineNum">   25495 </span>            :       &amp;&amp; cp_lexer_peek_nth_token (parser-&gt;lexer, 2)-&gt;type == CPP_OPEN_SQUARE)
<span class="lineNum">   25496 </span>            :     {
<span class="lineNum">   25497 </span>            :       tree attr_ns = NULL_TREE;
<span class="lineNum">   25498 </span><span class="lineCov">          6 : </span>
<span class="lineNum">   25499 </span><span class="lineCov">          6 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   25500 </span><span class="lineCov">          2 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   25501 </span><span class="lineCov">          4 : </span>
<span class="lineNum">   25502 </span>            :       if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_USING))
<span class="lineNum">   25503 </span><span class="lineCov">          8 :         {</span>
<span class="lineNum">   25504 </span>            :           token = cp_lexer_peek_nth_token (parser-&gt;lexer, 2);
<span class="lineNum">   25505 </span><span class="lineCov">      14398 :           if (token-&gt;type == CPP_NAME)</span>
<span class="lineNum">   25506 </span>            :             attr_ns = token-&gt;u.value;
<span class="lineNum">   25507 </span><span class="lineCov">         47 :           else if (token-&gt;type == CPP_KEYWORD)</span>
<span class="lineNum">   25508 </span><span class="lineCov">         47 :             attr_ns = ridpointers[(int) token-&gt;keyword];</span>
<span class="lineNum">   25509 </span><span class="lineCov">      14369 :           else if (token-&gt;flags &amp; NAMED_OP)</span>
<span class="lineNum">   25510 </span><span class="lineCov">      14369 :             attr_ns = get_identifier (cpp_type2name (token-&gt;type,</span>
<span class="lineNum">   25511 </span>            :                                                      token-&gt;flags));
<span class="lineNum">   25512 </span>            :           if (attr_ns
<span class="lineNum">   25513 </span>            :               &amp;&amp; cp_lexer_nth_token_is (parser-&gt;lexer, 3, CPP_COLON))
<span class="lineNum">   25514 </span>            :             {
<span class="lineNum">   25515 </span>            :               if (cxx_dialect &lt; cxx17
<span class="lineNum">   25516 </span>            :                   &amp;&amp; !in_system_header_at (input_location))
<span class="lineNum">   25517 </span>            :                 pedwarn (input_location, 0,
<span class="lineNum">   25518 </span>            :                          &quot;attribute using prefix only available &quot;
<span class="lineNum">   25519 </span>            :                          &quot;with -std=c++17 or -std=gnu++17&quot;);
<span class="lineNum">   25520 </span>            : 
<span class="lineNum">   25521 </span>            :               cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   25522 </span>            :               cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   25523 </span>            :               cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   25524 </span>            :             }
<span class="lineNum">   25525 </span>            :           else
<span class="lineNum">   25526 </span>            :             attr_ns = NULL_TREE;
<span class="lineNum">   25527 </span><span class="lineCov">  106961716 :         }</span>
<span class="lineNum">   25528 </span>            : 
<span class="lineNum">   25529 </span><span class="lineCov">  106961716 :       attributes = cp_parser_std_attribute_list (parser, attr_ns);</span>
<span class="lineNum">   25530 </span><span class="lineCov">  213923432 : </span>
<span class="lineNum">   25531 </span>            :       if (!cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE)
<span class="lineNum">   25532 </span><span class="lineCov">  106961716 :           || !cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE))</span>
<span class="lineNum">   25533 </span><span class="lineCov">  106961716 :         cp_parser_skip_to_end_of_statement (parser);</span>
<span class="lineNum">   25534 </span>            :       else
<span class="lineNum">   25535 </span><span class="lineCov">      14371 :         /* Warn about parsing c++11 attribute in non-c++1 mode, only</span>
<span class="lineNum">   25536 </span>            :            when we are sure that we have actually parsed them.  */
<span class="lineNum">   25537 </span><span class="lineCov">      14371 :         maybe_warn_cpp0x (CPP0X_ATTRIBUTES);</span>
<span class="lineNum">   25538 </span><span class="lineCov">      14371 :     }</span>
<span class="lineNum">   25539 </span>            :   else
<span class="lineNum">   25540 </span><span class="lineCov">      14371 :     {</span>
<span class="lineNum">   25541 </span>            :       tree alignas_expr;
<span class="lineNum">   25542 </span><span class="lineCov">         16 : </span>
<span class="lineNum">   25543 </span><span class="lineCov">         16 :       /* Look for an alignment-specifier.  */</span>
<span class="lineNum">   25544 </span><span class="lineCov">         10 : </span>
<span class="lineNum">   25545 </span><span class="lineCov">          6 :       token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   25546 </span><span class="lineCov">          2 : </span>
<span class="lineNum">   25547 </span><span class="lineCov">          4 :       if (token-&gt;type != CPP_KEYWORD</span>
<span class="lineNum">   25548 </span><span class="lineCov">          2 :           || token-&gt;keyword != RID_ALIGNAS)</span>
<span class="lineNum">   25549 </span>            :         return NULL_TREE;
<span class="lineNum">   25550 </span><span class="lineCov">         14 : </span>
<span class="lineNum">   25551 </span><span class="lineCov">         14 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   25552 </span>            :       maybe_warn_cpp0x (CPP0X_ATTRIBUTES);
<span class="lineNum">   25553 </span><span class="lineCov">         14 : </span>
<span class="lineNum">   25554 </span><span class="lineCov">         14 :       matching_parens parens;</span>
<span class="lineNum">   25555 </span><span class="lineCov">         14 :       if (!parens.require_open (parser))</span>
<span class="lineNum">   25556 </span>            :         return error_mark_node;
<span class="lineNum">   25557 </span>            : 
<span class="lineNum">   25558 </span>            :       cp_parser_parse_tentatively (parser);
<span class="lineNum">   25559 </span><span class="lineCov">         14 :       alignas_expr = cp_parser_type_id (parser);</span>
<span class="lineNum">   25560 </span><span class="lineCov">         14 : </span>
<span class="lineNum">   25561 </span><span class="lineCov">         14 :       if (!cp_parser_parse_definitely (parser))</span>
<span class="lineNum">   25562 </span>            :         {
<span class="lineNum">   25563 </span>            :           alignas_expr = cp_parser_assignment_expression (parser);
<span class="lineNum">   25564 </span>            :           if (alignas_expr == error_mark_node)
<span class="lineNum">   25565 </span>            :             cp_parser_skip_to_end_of_statement (parser);
<span class="lineNum">   25566 </span>            :           if (alignas_expr == NULL_TREE
<span class="lineNum">   25567 </span><span class="lineCov">      14371 :               || alignas_expr == error_mark_node)</span>
<span class="lineNum">   25568 </span>            :             return alignas_expr;
<span class="lineNum">   25569 </span><span class="lineCov">      14371 :         }</span>
<span class="lineNum">   25570 </span><span class="lineCov">      14371 : </span>
<span class="lineNum">   25571 </span><span class="lineCov">         22 :       alignas_expr = cxx_alignas_expr (alignas_expr);</span>
<span class="lineNum">   25572 </span>            :       alignas_expr = build_tree_list (NULL_TREE, alignas_expr);
<span class="lineNum">   25573 </span>            : 
<span class="lineNum">   25574 </span>            :       /* Handle alignas (pack...).  */
<span class="lineNum">   25575 </span><span class="lineCov">      14349 :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_ELLIPSIS))</span>
<span class="lineNum">   25576 </span>            :         {
<span class="lineNum">   25577 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   25578 </span>            :           alignas_expr = make_pack_expansion (alignas_expr);
<span class="lineNum">   25579 </span><span class="lineCov">  106947345 :         }</span>
<span class="lineNum">   25580 </span>            : 
<span class="lineNum">   25581 </span>            :       /* Something went wrong, so don't build the attribute.  */
<span class="lineNum">   25582 </span>            :       if (alignas_expr == error_mark_node)
<span class="lineNum">   25583 </span><span class="lineCov">  213894690 :         return error_mark_node;</span>
<span class="lineNum">   25584 </span>            : 
<span class="lineNum">   25585 </span><span class="lineCov">  213894690 :       if (!parens.require_close (parser))</span>
<span class="lineNum">   25586 </span><span class="lineCov">  106947345 :         return error_mark_node;</span>
<span class="lineNum">   25587 </span>            : 
<span class="lineNum">   25588 </span>            :       /* Build the C++-11 representation of an 'aligned'
<span class="lineNum">   25589 </span><span class="lineCov">       2699 :          attribute.  */</span>
<span class="lineNum">   25590 </span><span class="lineCov">       2699 :       attributes</span>
<span class="lineNum">   25591 </span>            :         = build_tree_list (build_tree_list (gnu_identifier,
<span class="lineNum">   25592 </span><span class="lineCov">       5398 :                                             aligned_identifier), alignas_expr);</span>
<span class="lineNum">   25593 </span><span class="lineCov">       2699 :     }</span>
<span class="lineNum">   25594 </span><span class="lineCov">          4 : </span>
<span class="lineNum">   25595 </span>            :   return attributes;
<span class="lineNum">   25596 </span><span class="lineCov">       2695 : }</span>
<span class="lineNum">   25597 </span><span class="lineCov">       2695 : </span>
<span class="lineNum">   25598 </span>            : /* Parse a standard C++-11 attribute-specifier-seq.
<span class="lineNum">   25599 </span><span class="lineCov">       2695 : </span>
<span class="lineNum">   25600 </span>            :    attribute-specifier-seq:
<span class="lineNum">   25601 </span><span class="lineCov">       1231 :      attribute-specifier-seq [opt] attribute-specifier</span>
<span class="lineNum">   25602 </span><span class="lineCov">       1231 :  */</span>
<a name="25603"><span class="lineNum">   25603 </span><span class="lineCov">         14 : </span></a>
<span class="lineNum">   25604 </span><span class="lineCov">       1231 : static tree</span>
<span class="lineNum">   25605 </span><span class="lineCov">       1231 : cp_parser_std_attribute_spec_seq (cp_parser *parser)</span>
<span class="lineNum">   25606 </span>            : {
<span class="lineNum">   25607 </span>            :   tree attr_specs = NULL_TREE;
<span class="lineNum">   25608 </span>            :   tree attr_last = NULL_TREE;
<span class="lineNum">   25609 </span><span class="lineCov">       2681 : </span>
<span class="lineNum">   25610 </span><span class="lineCov">       2681 :   while (true)</span>
<span class="lineNum">   25611 </span>            :     {
<span class="lineNum">   25612 </span>            :       tree attr_spec = cp_parser_std_attribute_spec (parser);
<span class="lineNum">   25613 </span><span class="lineCov">       2681 :       if (attr_spec == NULL_TREE)</span>
<span class="lineNum">   25614 </span>            :         break;
<span class="lineNum">   25615 </span><span class="lineCov">         12 :       if (attr_spec == error_mark_node)</span>
<span class="lineNum">   25616 </span><span class="lineCov">         12 :         return error_mark_node;</span>
<span class="lineNum">   25617 </span>            : 
<span class="lineNum">   25618 </span>            :       if (attr_last)
<span class="lineNum">   25619 </span>            :         TREE_CHAIN (attr_last) = attr_spec;
<span class="lineNum">   25620 </span><span class="lineCov">       2681 :       else</span>
<span class="lineNum">   25621 </span>            :         attr_specs = attr_last = attr_spec;
<span class="lineNum">   25622 </span>            :       attr_last = tree_last (attr_last);
<span class="lineNum">   25623 </span><span class="lineCov">       2679 :     }</span>
<span class="lineNum">   25624 </span><span class="lineCov">          4 : </span>
<span class="lineNum">   25625 </span>            :   return attr_specs;
<span class="lineNum">   25626 </span>            : }
<span class="lineNum">   25627 </span>            : 
<span class="lineNum">   25628 </span><span class="lineCov">       2675 : /* Skip a balanced-token starting at Nth token (with 1 as the next token),</span>
<span class="lineNum">   25629 </span><span class="lineCov">       2675 :    return index of the first token after balanced-token, or N on failure.  */</span>
<a name="25630"><span class="lineNum">   25630 </span>            : </a>
<span class="lineNum">   25631 </span>            : static size_t
<span class="lineNum">   25632 </span>            : cp_parser_skip_balanced_tokens (cp_parser *parser, size_t n)
<span class="lineNum">   25633 </span>            : {
<span class="lineNum">   25634 </span>            :   size_t orig_n = n;
<span class="lineNum">   25635 </span>            :   int nparens = 0, nbraces = 0, nsquares = 0;
<span class="lineNum">   25636 </span>            :   do
<span class="lineNum">   25637 </span>            :     switch (cp_lexer_peek_nth_token (parser-&gt;lexer, n++)-&gt;type)
<span class="lineNum">   25638 </span>            :       {
<span class="lineNum">   25639 </span>            :       case CPP_EOF:
<span class="lineNum">   25640 </span>            :       case CPP_PRAGMA_EOL:
<span class="lineNum">   25641 </span>            :         /* Ran out of tokens.  */
<span class="lineNum">   25642 </span>            :         return orig_n;
<span class="lineNum">   25643 </span><span class="lineCov">  106944696 :       case CPP_OPEN_PAREN:</span>
<span class="lineNum">   25644 </span>            :         ++nparens;
<span class="lineNum">   25645 </span><span class="lineCov">  106944696 :         break;</span>
<span class="lineNum">   25646 </span><span class="lineCov">  106944696 :       case CPP_OPEN_BRACE:</span>
<span class="lineNum">   25647 </span>            :         ++nbraces;
<span class="lineNum">   25648 </span><span class="lineCov">  106961716 :         break;</span>
<span class="lineNum">   25649 </span>            :       case CPP_OPEN_SQUARE:
<span class="lineNum">   25650 </span><span class="lineCov">  106961716 :         ++nsquares;</span>
<span class="lineNum">   25651 </span><span class="lineCov">  106961716 :         break;</span>
<span class="lineNum">   25652 </span>            :       case CPP_CLOSE_PAREN:
<span class="lineNum">   25653 </span><span class="lineCov">      17046 :         --nparens;</span>
<span class="lineNum">   25654 </span><span class="lineCov">         26 :         break;</span>
<span class="lineNum">   25655 </span>            :       case CPP_CLOSE_BRACE:
<span class="lineNum">   25656 </span><span class="lineCov">      17020 :         --nbraces;</span>
<span class="lineNum">   25657 </span><span class="lineCov">          6 :         break;</span>
<span class="lineNum">   25658 </span>            :       case CPP_CLOSE_SQUARE:
<span class="lineNum">   25659 </span>            :         --nsquares;
<span class="lineNum">   25660 </span><span class="lineCov">      17020 :         break;</span>
<span class="lineNum">   25661 </span><span class="lineCov">      17020 :       default:</span>
<span class="lineNum">   25662 </span>            :         break;
<span class="lineNum">   25663 </span>            :       }
<span class="lineNum">   25664 </span>            :   while (nparens || nbraces || nsquares);
<span class="lineNum">   25665 </span>            :   return n;
<span class="lineNum">   25666 </span>            : }
<span class="lineNum">   25667 </span>            : 
<span class="lineNum">   25668 </span>            : /* Skip GNU attribute tokens starting at Nth token (with 1 as the next token),
<span class="lineNum">   25669 </span>            :    return index of the first token after the GNU attribute tokens, or N on
<span class="lineNum">   25670 </span><span class="lineCov">       7477 :    failure.  */</span>
<a name="25671"><span class="lineNum">   25671 </span>            : </a>
<span class="lineNum">   25672 </span><span class="lineCov">       7477 : static size_t</span>
<span class="lineNum">   25673 </span><span class="lineCov">       7477 : cp_parser_skip_gnu_attributes_opt (cp_parser *parser, size_t n)</span>
<span class="lineNum">   25674 </span><span class="lineCov">      61873 : {</span>
<span class="lineNum">   25675 </span><span class="lineCov">      61873 :   while (true)</span>
<span class="lineNum">   25676 </span>            :     {
<span class="lineNum">   25677 </span>            :       if (!cp_lexer_nth_token_is_keyword (parser-&gt;lexer, n, RID_ATTRIBUTE)
<span class="lineNum">   25678 </span>            :           || !cp_lexer_nth_token_is (parser-&gt;lexer, n + 1, CPP_OPEN_PAREN)
<span class="lineNum">   25679 </span>            :           || !cp_lexer_nth_token_is (parser-&gt;lexer, n + 2, CPP_OPEN_PAREN))
<span class="lineNum">   25680 </span>            :         break;
<span class="lineNum">   25681 </span><span class="lineCov">      17858 : </span>
<span class="lineNum">   25682 </span><span class="lineCov">      17858 :       size_t n2 = cp_parser_skip_balanced_tokens (parser, n + 2);</span>
<span class="lineNum">   25683 </span><span class="lineCov">      17858 :       if (n2 == n + 2)</span>
<span class="lineNum">   25684 </span><span class="lineCov">          8 :         break;</span>
<span class="lineNum">   25685 </span><span class="lineCov">          8 :       if (!cp_lexer_nth_token_is (parser-&gt;lexer, n2, CPP_CLOSE_PAREN))</span>
<span class="lineNum">   25686 </span><span class="lineCov">          8 :         break;</span>
<span class="lineNum">   25687 </span><span class="lineCov">       1001 :       n = n2 + 1;</span>
<span class="lineNum">   25688 </span><span class="lineCov">       1001 :     }</span>
<span class="lineNum">   25689 </span><span class="lineCov">       1001 :   return n;</span>
<span class="lineNum">   25690 </span><span class="lineCov">      17858 : }</span>
<span class="lineNum">   25691 </span><span class="lineCov">      17858 : </span>
<span class="lineNum">   25692 </span><span class="lineCov">      17858 : /* Skip standard C++11 attribute tokens starting at Nth token (with 1 as the</span>
<span class="lineNum">   25693 </span><span class="lineCov">          8 :    next token), return index of the first token after the standard C++11</span>
<span class="lineNum">   25694 </span><span class="lineCov">          8 :    attribute tokens, or N on failure.  */</span>
<a name="25695"><span class="lineNum">   25695 </span><span class="lineCov">          8 : </span></a>
<span class="lineNum">   25696 </span><span class="lineCov">       1001 : static size_t</span>
<span class="lineNum">   25697 </span><span class="lineCov">       1001 : cp_parser_skip_std_attribute_spec_seq (cp_parser *parser, size_t n)</span>
<span class="lineNum">   25698 </span><span class="lineCov">       1001 : {</span>
<span class="lineNum">   25699 </span>            :   while (true)
<span class="lineNum">   25700 </span>            :     {
<span class="lineNum">   25701 </span>            :       if (cp_lexer_nth_token_is (parser-&gt;lexer, n, CPP_OPEN_SQUARE)
<span class="lineNum">   25702 </span><span class="lineCov">      61873 :           &amp;&amp; cp_lexer_nth_token_is (parser-&gt;lexer, n + 1, CPP_OPEN_SQUARE))</span>
<span class="lineNum">   25703 </span>            :         {
<span class="lineNum">   25704 </span>            :           size_t n2 = cp_parser_skip_balanced_tokens (parser, n + 1);
<span class="lineNum">   25705 </span>            :           if (n2 == n + 1)
<span class="lineNum">   25706 </span>            :             break;
<span class="lineNum">   25707 </span>            :           if (!cp_lexer_nth_token_is (parser-&gt;lexer, n2, CPP_CLOSE_SQUARE))
<span class="lineNum">   25708 </span>            :             break;
<span class="lineNum">   25709 </span>            :           n = n2 + 1;
<span class="lineNum">   25710 </span>            :         }
<span class="lineNum">   25711 </span><span class="lineCov">       6470 :       else if (cp_lexer_nth_token_is_keyword (parser-&gt;lexer, n, RID_ALIGNAS)</span>
<span class="lineNum">   25712 </span>            :                &amp;&amp; cp_lexer_nth_token_is (parser-&gt;lexer, n + 1, CPP_OPEN_PAREN))
<span class="lineNum">   25713 </span><span class="lineCov">      12940 :         {</span>
<span class="lineNum">   25714 </span>            :           size_t n2 = cp_parser_skip_balanced_tokens (parser, n + 1);
<span class="lineNum">   25715 </span><span class="lineCov">      12940 :           if (n2 == n + 1)</span>
<span class="lineNum">   25716 </span><span class="lineCov">       6470 :             break;</span>
<span class="lineNum">   25717 </span><span class="lineCov">      19410 :           n = n2;</span>
<span class="lineNum">   25718 </span>            :         }
<span class="lineNum">   25719 </span>            :       else
<span class="lineNum">   25720 </span><span class="lineCov">       6470 :         break;</span>
<span class="lineNum">   25721 </span><span class="lineCov">       6470 :     }</span>
<span class="lineNum">   25722 </span>            :   return n;
<span class="lineNum">   25723 </span><span class="lineCov">       6470 : }</span>
<span class="lineNum">   25724 </span>            : 
<span class="lineNum">   25725 </span><span class="lineCov">       6470 : /* Skip standard C++11 or GNU attribute tokens starting at Nth token (with 1</span>
<span class="lineNum">   25726 </span><span class="lineCov">       6470 :    as the next token), return index of the first token after the attribute</span>
<span class="lineNum">   25727 </span><span class="lineCov">       6470 :    tokens, or N on failure.  */</span>
<a name="25728"><span class="lineNum">   25728 </span>            : </a>
<span class="lineNum">   25729 </span>            : static size_t
<span class="lineNum">   25730 </span>            : cp_parser_skip_attributes_opt (cp_parser *parser, size_t n)
<span class="lineNum">   25731 </span>            : {
<span class="lineNum">   25732 </span>            :   if (cp_nth_tokens_can_be_gnu_attribute_p (parser, n))
<span class="lineNum">   25733 </span>            :     return cp_parser_skip_gnu_attributes_opt (parser, n);
<span class="lineNum">   25734 </span>            :   return cp_parser_skip_std_attribute_spec_seq (parser, n);
<span class="lineNum">   25735 </span><span class="lineCov">       1005 : }</span>
<span class="lineNum">   25736 </span>            : 
<span class="lineNum">   25737 </span><span class="lineCov">       2012 : /* Parse an optional `__extension__' keyword.  Returns TRUE if it is</span>
<span class="lineNum">   25738 </span>            :    present, and FALSE otherwise.  *SAVED_PEDANTIC is set to the
<span class="lineNum">   25739 </span><span class="lineCov">       2012 :    current value of the PEDANTIC flag, regardless of whether or not</span>
<span class="lineNum">   25740 </span><span class="lineCov">       2012 :    the `__extension__' keyword is present.  The caller is responsible</span>
<span class="lineNum">   25741 </span>            :    for restoring the value of the PEDANTIC flag.  */
<a name="25742"><span class="lineNum">   25742 </span><span class="lineCov">        993 : </span></a>
<span class="lineNum">   25743 </span><span class="lineCov">        993 : static bool</span>
<span class="lineNum">   25744 </span>            : cp_parser_extension_opt (cp_parser* parser, int* saved_pedantic)
<span class="lineNum">   25745 </span><span class="lineCov">        993 : {</span>
<span class="lineNum">   25746 </span>            :   /* Save the old value of the PEDANTIC flag.  */
<span class="lineNum">   25747 </span><span class="lineCov">        993 :   *saved_pedantic = pedantic;</span>
<span class="lineNum">   25748 </span>            : 
<span class="lineNum">   25749 </span><span class="lineCov">       2038 :   if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_EXTENSION))</span>
<span class="lineNum">   25750 </span><span class="lineCov">       1019 :     {</span>
<span class="lineNum">   25751 </span>            :       /* Consume the `__extension__' token.  */
<span class="lineNum">   25752 </span><span class="lineCov">         14 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   25753 </span><span class="lineCov">         14 :       /* We're not being pedantic while the `__extension__' keyword is</span>
<span class="lineNum">   25754 </span>            :          in effect.  */
<span class="lineNum">   25755 </span>            :       pedantic = 0;
<span class="lineNum">   25756 </span>            : 
<span class="lineNum">   25757 </span>            :       return true;
<span class="lineNum">   25758 </span>            :     }
<span class="lineNum">   25759 </span>            : 
<span class="lineNum">   25760 </span><span class="lineCov">       1005 :   return false;</span>
<span class="lineNum">   25761 </span>            : }
<span class="lineNum">   25762 </span>            : 
<span class="lineNum">   25763 </span>            : /* Parse a label declaration.
<span class="lineNum">   25764 </span>            : 
<span class="lineNum">   25765 </span>            :    label-declaration:
<span class="lineNum">   25766 </span>            :      __label__ label-declarator-seq ;
<span class="lineNum">   25767 </span>            : 
<span class="lineNum">   25768 </span><span class="lineCov">       7475 :    label-declarator-seq:</span>
<span class="lineNum">   25769 </span>            :      identifier , label-declarator-seq
<span class="lineNum">   25770 </span><span class="lineCov">       7475 :      identifier  */</span>
<a name="25771"><span class="lineNum">   25771 </span><span class="lineCov">       6470 : </span></a>
<span class="lineNum">   25772 </span><span class="lineCov">       1005 : static void</span>
<span class="lineNum">   25773 </span>            : cp_parser_label_declaration (cp_parser* parser)
<span class="lineNum">   25774 </span>            : {
<span class="lineNum">   25775 </span>            :   /* Look for the `__label__' keyword.  */
<span class="lineNum">   25776 </span>            :   cp_parser_require_keyword (parser, RID_LABEL, RT_LABEL);
<span class="lineNum">   25777 </span>            : 
<span class="lineNum">   25778 </span>            :   while (true)
<span class="lineNum">   25779 </span>            :     {
<span class="lineNum">   25780 </span>            :       tree identifier;
<span class="lineNum">   25781 </span>            : 
<span class="lineNum">   25782 </span><span class="lineNoCov">          0 :       /* Look for an identifier.  */</span>
<span class="lineNum">   25783 </span>            :       identifier = cp_parser_identifier (parser);
<span class="lineNum">   25784 </span>            :       /* If we failed, stop.  */
<span class="lineNum">   25785 </span><span class="lineCov">   32767051 :       if (identifier == error_mark_node)</span>
<span class="lineNum">   25786 </span>            :         break;
<span class="lineNum">   25787 </span><span class="lineCov">   32767051 :       /* Declare it as a label.  */</span>
<span class="lineNum">   25788 </span>            :       finish_label_decl (identifier);
<span class="lineNum">   25789 </span>            :       /* If the next token is a `;', stop.  */
<span class="lineNum">   25790 </span><span class="lineCov">     101342 :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_SEMICOLON))</span>
<span class="lineNum">   25791 </span>            :         break;
<span class="lineNum">   25792 </span>            :       /* Look for the `,' separating the label declarations.  */
<span class="lineNum">   25793 </span><span class="lineCov">     101342 :       cp_parser_require (parser, CPP_COMMA, RT_COMMA);</span>
<span class="lineNum">   25794 </span>            :     }
<span class="lineNum">   25795 </span><span class="lineCov">     101342 : </span>
<span class="lineNum">   25796 </span>            :   /* Look for the final `;'.  */
<span class="lineNum">   25797 </span>            :   cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);
<span class="lineNum">   25798 </span>            : }
<span class="lineNum">   25799 </span>            : 
<span class="lineNum">   25800 </span>            : // -------------------------------------------------------------------------- //
<span class="lineNum">   25801 </span>            : // Requires Clause
<span class="lineNum">   25802 </span>            : 
<span class="lineNum">   25803 </span>            : // Parse a requires clause.
<span class="lineNum">   25804 </span>            : //
<span class="lineNum">   25805 </span>            : //    requires-clause:
<span class="lineNum">   25806 </span>            : //      'requires' logical-or-expression
<span class="lineNum">   25807 </span>            : //
<span class="lineNum">   25808 </span>            : // The required logical-or-expression must be a constant expression. Note
<span class="lineNum">   25809 </span>            : // that we don't check that the expression is constepxr here. We defer until
<a name="25810"><span class="lineNum">   25810 </span>            : // we analyze constraints and then, we only check atomic constraints.</a>
<span class="lineNum">   25811 </span><span class="lineCov">         51 : static tree</span>
<span class="lineNum">   25812 </span>            : cp_parser_requires_clause (cp_parser *parser)
<span class="lineNum">   25813 </span>            : {
<span class="lineNum">   25814 </span><span class="lineCov">         51 :   // Parse the requires clause so that it is not automatically folded.</span>
<span class="lineNum">   25815 </span>            :   ++processing_template_decl;
<span class="lineNum">   25816 </span><span class="lineCov">         60 :   tree expr = cp_parser_binary_expression (parser, false, false,</span>
<span class="lineNum">   25817 </span>            :                                            PREC_NOT_OPERATOR, NULL);
<span class="lineNum">   25818 </span><span class="lineCov">         60 :   if (check_for_bare_parameter_packs (expr))</span>
<span class="lineNum">   25819 </span>            :     expr = error_mark_node;
<span class="lineNum">   25820 </span>            :   --processing_template_decl;
<span class="lineNum">   25821 </span><span class="lineCov">         60 :   return expr;</span>
<span class="lineNum">   25822 </span>            : }
<span class="lineNum">   25823 </span><span class="lineCov">         60 : </span>
<a name="25824"><span class="lineNum">   25824 </span>            : // Optionally parse a requires clause:</a>
<span class="lineNum">   25825 </span>            : static tree
<span class="lineNum">   25826 </span><span class="lineCov">         60 : cp_parser_requires_clause_opt (cp_parser *parser)</span>
<span class="lineNum">   25827 </span>            : {
<span class="lineNum">   25828 </span><span class="lineCov">         60 :   cp_token *tok = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   25829 </span>            :   if (tok-&gt;keyword != RID_REQUIRES)
<span class="lineNum">   25830 </span>            :     {
<span class="lineNum">   25831 </span><span class="lineCov">          9 :       if (!flag_concepts &amp;&amp; tok-&gt;type == CPP_NAME</span>
<span class="lineNum">   25832 </span><span class="lineCov">          9 :           &amp;&amp; tok-&gt;u.value == ridpointers[RID_REQUIRES])</span>
<span class="lineNum">   25833 </span>            :         {
<span class="lineNum">   25834 </span>            :           error_at (cp_lexer_peek_token (parser-&gt;lexer)-&gt;location,
<span class="lineNum">   25835 </span><span class="lineCov">         51 :                     &quot;%&lt;requires%&gt; only available with -fconcepts&quot;);</span>
<span class="lineNum">   25836 </span><span class="lineCov">         51 :           /* Parse and discard the requires-clause.  */</span>
<span class="lineNum">   25837 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   25838 </span>            :           cp_parser_requires_clause (parser);
<span class="lineNum">   25839 </span>            :         }
<span class="lineNum">   25840 </span>            :       return NULL_TREE;
<span class="lineNum">   25841 </span>            :     }
<span class="lineNum">   25842 </span>            :   cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   25843 </span>            :   return cp_parser_requires_clause (parser);
<span class="lineNum">   25844 </span>            : }
<span class="lineNum">   25845 </span>            : 
<span class="lineNum">   25846 </span>            : 
<span class="lineNum">   25847 </span>            : /*---------------------------------------------------------------------------
<span class="lineNum">   25848 </span>            :                            Requires expressions
<span class="lineNum">   25849 </span>            : ---------------------------------------------------------------------------*/
<span class="lineNum">   25850 </span><span class="lineCov">        140 : </span>
<span class="lineNum">   25851 </span>            : /* Parse a requires expression
<span class="lineNum">   25852 </span>            : 
<span class="lineNum">   25853 </span><span class="lineCov">        140 :    requirement-expression:</span>
<a name="25854"><span class="lineNum">   25854 </span><span class="lineCov">        140 :        'requires' requirement-parameter-list [opt] requirement-body */</span></a>
<span class="lineNum">   25855 </span><span class="lineCov">        140 : static tree</span>
<span class="lineNum">   25856 </span><span class="lineCov">        140 : cp_parser_requires_expression (cp_parser *parser)</span>
<span class="lineNum">   25857 </span><span class="lineCov">          1 : {</span>
<span class="lineNum">   25858 </span><span class="lineCov">        140 :   gcc_assert (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_REQUIRES));</span>
<span class="lineNum">   25859 </span><span class="lineCov">        140 :   location_t loc = cp_lexer_consume_token (parser-&gt;lexer)-&gt;location;</span>
<span class="lineNum">   25860 </span>            : 
<span class="lineNum">   25861 </span>            :   /* A requires-expression shall appear only within a concept
<span class="lineNum">   25862 </span>            :      definition or a requires-clause.
<span class="lineNum">   25863 </span>            : 
<span class="lineNum">   25864 </span><span class="lineCov">      95078 :      TODO: Implement this diagnostic correctly. */</span>
<span class="lineNum">   25865 </span>            :   if (!processing_template_decl)
<span class="lineNum">   25866 </span><span class="lineCov">     190156 :     {</span>
<span class="lineNum">   25867 </span><span class="lineCov">      95078 :       error_at (loc, &quot;a requires expression cannot appear outside a template&quot;);</span>
<span class="lineNum">   25868 </span>            :       cp_parser_skip_to_end_of_statement (parser);
<span class="lineNum">   25869 </span><span class="lineCov">      94943 :       return error_mark_node;</span>
<span class="lineNum">   25870 </span><span class="lineCov">         13 :     }</span>
<span class="lineNum">   25871 </span>            : 
<span class="lineNum">   25872 </span><span class="lineNoCov">          0 :   tree parms, reqs;</span>
<span class="lineNum">   25873 </span>            :   {
<span class="lineNum">   25874 </span>            :     /* Local parameters are delared as variables within the scope
<span class="lineNum">   25875 </span><span class="lineNoCov">          0 :        of the expression.  They are not visible past the end of</span>
<span class="lineNum">   25876 </span><span class="lineNoCov">          0 :        the expression.  Expressions within the requires-expression</span>
<span class="lineNum">   25877 </span>            :        are unevaluated.  */
<a name="25878"><span class="lineNum">   25878 </span><span class="lineCov">      94943 :     struct scope_sentinel</span></a>
<span class="lineNum">   25879 </span>            :     {
<span class="lineNum">   25880 </span><span class="lineCov">        135 :       scope_sentinel ()</span>
<span class="lineNum">   25881 </span><span class="lineCov">        135 :       {</span>
<span class="lineNum">   25882 </span>            :         ++cp_unevaluated_operand;
<span class="lineNum">   25883 </span>            :         begin_scope (sk_block, NULL_TREE);
<a name="25884"><span class="lineNum">   25884 </span>            :       }</a>
<span class="lineNum">   25885 </span>            : 
<span class="lineNum">   25886 </span>            :       ~scope_sentinel ()
<span class="lineNum">   25887 </span>            :       {
<span class="lineNum">   25888 </span>            :         pop_bindings_and_leave_scope ();
<span class="lineNum">   25889 </span>            :         --cp_unevaluated_operand;
<span class="lineNum">   25890 </span>            :       }
<span class="lineNum">   25891 </span>            :     } s;
<span class="lineNum">   25892 </span>            : 
<span class="lineNum">   25893 </span>            :     /* Parse the optional parameter list. */
<span class="lineNum">   25894 </span><span class="lineCov">         72 :     if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_PAREN))</span>
<span class="lineNum">   25895 </span>            :       {
<span class="lineNum">   25896 </span><span class="lineCov">         72 :         parms = cp_parser_requirement_parameter_list (parser);</span>
<span class="lineNum">   25897 </span><span class="lineCov">         72 :         if (parms == error_mark_node)</span>
<span class="lineNum">   25898 </span>            :           return error_mark_node;
<span class="lineNum">   25899 </span>            :       }
<span class="lineNum">   25900 </span>            :     else
<span class="lineNum">   25901 </span>            :       parms = NULL_TREE;
<span class="lineNum">   25902 </span>            : 
<span class="lineNum">   25903 </span><span class="lineCov">         72 :     /* Parse the requirement body. */</span>
<span class="lineNum">   25904 </span>            :     reqs = cp_parser_requirement_body (parser);
<span class="lineNum">   25905 </span><span class="lineNoCov">          0 :     if (reqs == error_mark_node)</span>
<span class="lineNum">   25906 </span><span class="lineNoCov">          0 :       return error_mark_node;</span>
<span class="lineNum">   25907 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">   25908 </span>            : 
<span class="lineNum">   25909 </span>            :   /* This needs to happen after pop_bindings_and_leave_scope, as it reverses
<span class="lineNum">   25910 </span><span class="lineCov">         72 :      the parm chain.  */</span>
<span class="lineNum">   25911 </span><span class="lineCov">         72 :   grokparms (parms, &amp;parms);</span>
<span class="lineNum">   25912 </span>            :   return finish_requires_expr (parms, reqs);
<span class="lineNum">   25913 </span>            : }
<span class="lineNum">   25914 </span>            : 
<span class="lineNum">   25915 </span>            : /* Parse a parameterized requirement.
<span class="lineNum">   25916 </span><span class="lineCov">         72 : </span>
<span class="lineNum">   25917 </span>            :    requirement-parameter-list:
<a name="25918"><span class="lineNum">   25918 </span><span class="lineNoCov">          0 :        '(' parameter-declaration-clause ')' */</span></a>
<span class="lineNum">   25919 </span>            : static tree
<span class="lineNum">   25920 </span><span class="lineCov">         72 : cp_parser_requirement_parameter_list (cp_parser *parser)</span>
<span class="lineNum">   25921 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   25922 </span><span class="lineNoCov">          0 :   matching_parens parens;</span>
<span class="lineNum">   25923 </span>            :   if (!parens.require_open (parser))
<span class="lineNum">   25924 </span><span class="lineNoCov">          0 :     return error_mark_node;</span>
<span class="lineNum">   25925 </span>            : 
<span class="lineNum">   25926 </span><span class="lineNoCov">          0 :   tree parms = cp_parser_parameter_declaration_clause (parser);</span>
<span class="lineNum">   25927 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   25928 </span><span class="lineNoCov">          0 :   if (!parens.require_close (parser))</span>
<span class="lineNum">   25929 </span><span class="lineCov">        144 :     return error_mark_node;</span>
<span class="lineNum">   25930 </span>            : 
<span class="lineNum">   25931 </span>            :   return parms;
<span class="lineNum">   25932 </span><span class="lineCov">         72 : }</span>
<span class="lineNum">   25933 </span>            : 
<span class="lineNum">   25934 </span><span class="lineCov">         51 : /* Parse the body of a requirement.</span>
<span class="lineNum">   25935 </span><span class="lineCov">         51 : </span>
<span class="lineNum">   25936 </span><span class="lineNoCov">          0 :    requirement-body:</span>
<a name="25937"><span class="lineNum">   25937 </span>            :        '{' requirement-list '}' */</a>
<span class="lineNum">   25938 </span>            : static tree
<span class="lineNum">   25939 </span><span class="lineCov">         21 : cp_parser_requirement_body (cp_parser *parser)</span>
<span class="lineNum">   25940 </span>            : {
<span class="lineNum">   25941 </span>            :   matching_braces braces;
<span class="lineNum">   25942 </span><span class="lineCov">         72 :   if (!braces.require_open (parser))</span>
<span class="lineNum">   25943 </span><span class="lineCov">         72 :     return error_mark_node;</span>
<span class="lineNum">   25944 </span>            : 
<span class="lineNum">   25945 </span>            :   tree reqs = cp_parser_requirement_list (parser);
<span class="lineNum">   25946 </span>            : 
<span class="lineNum">   25947 </span>            :   if (!braces.require_close (parser))
<span class="lineNum">   25948 </span>            :     return error_mark_node;
<span class="lineNum">   25949 </span><span class="lineCov">         72 : </span>
<span class="lineNum">   25950 </span><span class="lineCov">         72 :   return reqs;</span>
<span class="lineNum">   25951 </span>            : }
<span class="lineNum">   25952 </span>            : 
<span class="lineNum">   25953 </span>            : /* Parse a list of requirements.
<span class="lineNum">   25954 </span>            : 
<span class="lineNum">   25955 </span>            :    requirement-list:
<span class="lineNum">   25956 </span>            :        requirement
<a name="25957"><span class="lineNum">   25957 </span>            :        requirement-list ';' requirement[opt] */</a>
<span class="lineNum">   25958 </span><span class="lineCov">         51 : static tree</span>
<span class="lineNum">   25959 </span>            : cp_parser_requirement_list (cp_parser *parser)
<span class="lineNum">   25960 </span><span class="lineCov">        102 : {</span>
<span class="lineNum">   25961 </span><span class="lineCov">         51 :   tree result = NULL_TREE;</span>
<span class="lineNum">   25962 </span><span class="lineNoCov">          0 :   while (true)</span>
<span class="lineNum">   25963 </span>            :     {
<span class="lineNum">   25964 </span><span class="lineCov">         51 :       tree req = cp_parser_requirement (parser);</span>
<span class="lineNum">   25965 </span>            :       if (req == error_mark_node)
<span class="lineNum">   25966 </span><span class="lineCov">         51 :         return error_mark_node;</span>
<span class="lineNum">   25967 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   25968 </span>            :       result = tree_cons (NULL_TREE, req, result);
<span class="lineNum">   25969 </span>            : 
<span class="lineNum">   25970 </span>            :       /* If we see a semi-colon, consume it. */
<span class="lineNum">   25971 </span>            :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_SEMICOLON))
<span class="lineNum">   25972 </span>            :         cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   25973 </span>            : 
<span class="lineNum">   25974 </span>            :       /* Stop processing at the end of the list. */
<span class="lineNum">   25975 </span>            :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_CLOSE_BRACE))
<span class="lineNum">   25976 </span>            :         break;
<span class="lineNum">   25977 </span><span class="lineCov">         72 :     }</span>
<span class="lineNum">   25978 </span>            : 
<span class="lineNum">   25979 </span><span class="lineCov">        144 :   /* Reverse the order of requirements so they are analyzed in</span>
<span class="lineNum">   25980 </span><span class="lineCov">         72 :      declaration order. */</span>
<span class="lineNum">   25981 </span><span class="lineNoCov">          0 :   return nreverse (result);</span>
<span class="lineNum">   25982 </span>            : }
<span class="lineNum">   25983 </span><span class="lineCov">         72 : </span>
<span class="lineNum">   25984 </span>            : /* Parse a syntactic requirement or type requirement.
<span class="lineNum">   25985 </span><span class="lineCov">         72 : </span>
<span class="lineNum">   25986 </span><span class="lineNoCov">          0 :      requirement:</span>
<span class="lineNum">   25987 </span>            :        simple-requirement
<span class="lineNum">   25988 </span>            :        compound-requirement
<span class="lineNum">   25989 </span>            :        type-requirement
<a name="25990"><span class="lineNum">   25990 </span>            :        nested-requirement */</a>
<span class="lineNum">   25991 </span>            : static tree
<span class="lineNum">   25992 </span>            : cp_parser_requirement (cp_parser *parser)
<span class="lineNum">   25993 </span>            : {
<span class="lineNum">   25994 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_BRACE))
<span class="lineNum">   25995 </span>            :     return cp_parser_compound_requirement (parser);
<span class="lineNum">   25996 </span>            :   else if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_TYPENAME))
<span class="lineNum">   25997 </span><span class="lineCov">         72 :     return cp_parser_type_requirement (parser);</span>
<span class="lineNum">   25998 </span>            :   else if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_REQUIRES))
<span class="lineNum">   25999 </span><span class="lineCov">         72 :     return cp_parser_nested_requirement (parser);</span>
<span class="lineNum">   26000 </span><span class="lineCov">         77 :   else</span>
<span class="lineNum">   26001 </span>            :     return cp_parser_simple_requirement (parser);
<span class="lineNum">   26002 </span><span class="lineCov">         77 : }</span>
<span class="lineNum">   26003 </span><span class="lineCov">         77 : </span>
<span class="lineNum">   26004 </span><span class="lineNoCov">          0 : /* Parse a simple requirement.</span>
<span class="lineNum">   26005 </span>            : 
<span class="lineNum">   26006 </span><span class="lineCov">         77 :      simple-requirement:</span>
<a name="26007"><span class="lineNum">   26007 </span>            :        expression ';' */</a>
<span class="lineNum">   26008 </span>            : static tree
<span class="lineNum">   26009 </span><span class="lineCov">         77 : cp_parser_simple_requirement (cp_parser *parser)</span>
<span class="lineNum">   26010 </span><span class="lineCov">         25 : {</span>
<span class="lineNum">   26011 </span>            :   tree expr = cp_parser_expression (parser, NULL, false, false);
<span class="lineNum">   26012 </span>            :   if (!expr || expr == error_mark_node)
<span class="lineNum">   26013 </span><span class="lineCov">         77 :     return error_mark_node;</span>
<span class="lineNum">   26014 </span>            : 
<span class="lineNum">   26015 </span>            :   if (!cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON))
<span class="lineNum">   26016 </span>            :     return error_mark_node;
<span class="lineNum">   26017 </span>            : 
<span class="lineNum">   26018 </span>            :   return finish_simple_requirement (expr);
<span class="lineNum">   26019 </span><span class="lineCov">         72 : }</span>
<span class="lineNum">   26020 </span>            : 
<span class="lineNum">   26021 </span>            : /* Parse a type requirement
<span class="lineNum">   26022 </span>            : 
<span class="lineNum">   26023 </span>            :      type-requirement
<span class="lineNum">   26024 </span>            :          nested-name-specifier [opt] required-type-name ';'
<span class="lineNum">   26025 </span>            : 
<span class="lineNum">   26026 </span>            :      required-type-name:
<span class="lineNum">   26027 </span>            :          type-name
<a name="26028"><span class="lineNum">   26028 </span>            :          'template' [opt] simple-template-id  */</a>
<span class="lineNum">   26029 </span>            : static tree
<span class="lineNum">   26030 </span><span class="lineCov">         77 : cp_parser_type_requirement (cp_parser *parser)</span>
<span class="lineNum">   26031 </span>            : {
<span class="lineNum">   26032 </span><span class="lineCov">         77 :   cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   26033 </span><span class="lineCov">         26 : </span>
<span class="lineNum">   26034 </span><span class="lineCov">         51 :   // Save the scope before parsing name specifiers.</span>
<span class="lineNum">   26035 </span><span class="lineCov">         20 :   tree saved_scope = parser-&gt;scope;</span>
<span class="lineNum">   26036 </span><span class="lineCov">         31 :   tree saved_object_scope = parser-&gt;object_scope;</span>
<span class="lineNum">   26037 </span><span class="lineCov">          5 :   tree saved_qualifying_scope = parser-&gt;qualifying_scope;</span>
<span class="lineNum">   26038 </span>            :   cp_parser_global_scope_opt (parser, /*current_scope_valid_p=*/true);
<span class="lineNum">   26039 </span><span class="lineCov">         26 :   cp_parser_nested_name_specifier_opt (parser,</span>
<span class="lineNum">   26040 </span>            :                                        /*typename_keyword_p=*/true,
<span class="lineNum">   26041 </span>            :                                        /*check_dependency_p=*/false,
<span class="lineNum">   26042 </span>            :                                        /*type_p=*/true,
<span class="lineNum">   26043 </span>            :                                        /*is_declaration=*/false);
<span class="lineNum">   26044 </span>            : 
<span class="lineNum">   26045 </span>            :   tree type;
<span class="lineNum">   26046 </span>            :   if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_TEMPLATE))
<span class="lineNum">   26047 </span><span class="lineCov">         26 :     {</span>
<span class="lineNum">   26048 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   26049 </span><span class="lineCov">         26 :       type = cp_parser_template_id (parser,</span>
<span class="lineNum">   26050 </span><span class="lineCov">         26 :                                     /*template_keyword_p=*/true,</span>
<span class="lineNum">   26051 </span><span class="lineNoCov">          0 :                                     /*check_dependency=*/false,</span>
<span class="lineNum">   26052 </span>            :                                     /*tag_type=*/none_type,
<span class="lineNum">   26053 </span><span class="lineCov">         26 :                                     /*is_declaration=*/false);</span>
<span class="lineNum">   26054 </span><span class="lineNoCov">          0 :       type = make_typename_type (parser-&gt;scope, type, typename_type,</span>
<span class="lineNum">   26055 </span>            :                                  /*complain=*/tf_error);
<span class="lineNum">   26056 </span><span class="lineCov">         26 :     }</span>
<span class="lineNum">   26057 </span>            :   else
<span class="lineNum">   26058 </span>            :    type = cp_parser_type_name (parser, /*typename_keyword_p=*/true);
<span class="lineNum">   26059 </span>            : 
<span class="lineNum">   26060 </span>            :   if (TREE_CODE (type) == TYPE_DECL)
<span class="lineNum">   26061 </span>            :     type = TREE_TYPE (type);
<span class="lineNum">   26062 </span>            : 
<span class="lineNum">   26063 </span>            :   parser-&gt;scope = saved_scope;
<span class="lineNum">   26064 </span>            :   parser-&gt;object_scope = saved_object_scope;
<span class="lineNum">   26065 </span>            :   parser-&gt;qualifying_scope = saved_qualifying_scope;
<span class="lineNum">   26066 </span>            : 
<span class="lineNum">   26067 </span>            :   if (type == error_mark_node)
<span class="lineNum">   26068 </span><span class="lineCov">         20 :     cp_parser_skip_to_end_of_statement (parser);</span>
<span class="lineNum">   26069 </span>            : 
<span class="lineNum">   26070 </span><span class="lineCov">         20 :   if (!cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON))</span>
<span class="lineNum">   26071 </span>            :     return error_mark_node;
<span class="lineNum">   26072 </span>            :   if (type == error_mark_node)
<span class="lineNum">   26073 </span><span class="lineCov">         20 :     return error_mark_node;</span>
<span class="lineNum">   26074 </span><span class="lineCov">         20 : </span>
<span class="lineNum">   26075 </span><span class="lineCov">         20 :   return finish_type_requirement (type);</span>
<span class="lineNum">   26076 </span><span class="lineCov">         20 : }</span>
<span class="lineNum">   26077 </span><span class="lineCov">         20 : </span>
<span class="lineNum">   26078 </span>            : /* Parse a compound requirement
<span class="lineNum">   26079 </span>            : 
<span class="lineNum">   26080 </span>            :      compound-requirement:
<a name="26081"><span class="lineNum">   26081 </span>            :          '{' expression '}' 'noexcept' [opt] trailing-return-type [opt] ';' */</a>
<span class="lineNum">   26082 </span>            : static tree
<span class="lineNum">   26083 </span><span class="lineCov">         20 : cp_parser_compound_requirement (cp_parser *parser)</span>
<span class="lineNum">   26084 </span><span class="lineCov">         20 : {</span>
<span class="lineNum">   26085 </span>            :   /* Parse an expression enclosed in '{ }'s. */
<span class="lineNum">   26086 </span><span class="lineCov">          1 :   matching_braces braces;</span>
<span class="lineNum">   26087 </span><span class="lineCov">          1 :   if (!braces.require_open (parser))</span>
<span class="lineNum">   26088 </span>            :     return error_mark_node;
<span class="lineNum">   26089 </span>            : 
<span class="lineNum">   26090 </span>            :   tree expr = cp_parser_expression (parser, NULL, false, false);
<span class="lineNum">   26091 </span>            :   if (!expr || expr == error_mark_node)
<span class="lineNum">   26092 </span><span class="lineCov">          1 :     return error_mark_node;</span>
<span class="lineNum">   26093 </span>            : 
<span class="lineNum">   26094 </span>            :   if (!braces.require_close (parser))
<span class="lineNum">   26095 </span>            :     return error_mark_node;
<span class="lineNum">   26096 </span><span class="lineCov">         19 : </span>
<span class="lineNum">   26097 </span>            :   /* Parse the optional noexcept. */
<span class="lineNum">   26098 </span><span class="lineCov">         20 :   bool noexcept_p = false;</span>
<span class="lineNum">   26099 </span><span class="lineCov">         19 :   if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_NOEXCEPT))</span>
<span class="lineNum">   26100 </span>            :     {
<span class="lineNum">   26101 </span><span class="lineCov">         20 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   26102 </span><span class="lineCov">         20 :       noexcept_p = true;</span>
<span class="lineNum">   26103 </span><span class="lineCov">         20 :     }</span>
<span class="lineNum">   26104 </span>            : 
<span class="lineNum">   26105 </span><span class="lineCov">         20 :   /* Parse the optional trailing return type. */</span>
<span class="lineNum">   26106 </span><span class="lineNoCov">          0 :   tree type = NULL_TREE;</span>
<span class="lineNum">   26107 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_DEREF))
<span class="lineNum">   26108 </span><span class="lineCov">         20 :     {</span>
<span class="lineNum">   26109 </span><span class="lineNoCov">          0 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   26110 </span><span class="lineCov">         20 :       bool saved_result_type_constraint_p = parser-&gt;in_result_type_constraint_p;</span>
<span class="lineNum">   26111 </span>            :       parser-&gt;in_result_type_constraint_p = true;
<span class="lineNum">   26112 </span>            :       type = cp_parser_trailing_type_id (parser);
<span class="lineNum">   26113 </span><span class="lineCov">         20 :       parser-&gt;in_result_type_constraint_p = saved_result_type_constraint_p;</span>
<span class="lineNum">   26114 </span>            :       if (type == error_mark_node)
<span class="lineNum">   26115 </span>            :         return error_mark_node;
<span class="lineNum">   26116 </span>            :     }
<span class="lineNum">   26117 </span>            : 
<span class="lineNum">   26118 </span>            :   return finish_compound_requirement (expr, type, noexcept_p);
<span class="lineNum">   26119 </span>            : }
<span class="lineNum">   26120 </span>            : 
<span class="lineNum">   26121 </span><span class="lineCov">         26 : /* Parse a nested requirement. This is the same as a requires clause.</span>
<span class="lineNum">   26122 </span>            : 
<span class="lineNum">   26123 </span>            :    nested-requirement:
<a name="26124"><span class="lineNum">   26124 </span><span class="lineCov">         52 :      requires-clause */</span></a>
<span class="lineNum">   26125 </span><span class="lineCov">         26 : static tree</span>
<span class="lineNum">   26126 </span><span class="lineNoCov">          0 : cp_parser_nested_requirement (cp_parser *parser)</span>
<span class="lineNum">   26127 </span>            : {
<span class="lineNum">   26128 </span><span class="lineCov">         26 :   cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   26129 </span><span class="lineCov">         26 :   tree req = cp_parser_requires_clause (parser);</span>
<span class="lineNum">   26130 </span><span class="lineNoCov">          0 :   if (req == error_mark_node)</span>
<span class="lineNum">   26131 </span>            :     return error_mark_node;
<span class="lineNum">   26132 </span><span class="lineCov">         26 :   return finish_nested_requirement (req);</span>
<span class="lineNum">   26133 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   26134 </span>            : 
<span class="lineNum">   26135 </span>            : /* Support Functions */
<span class="lineNum">   26136 </span><span class="lineCov">         26 : </span>
<span class="lineNum">   26137 </span><span class="lineCov">         26 : /* Return the appropriate prefer_type argument for lookup_name_real based on</span>
<span class="lineNum">   26138 </span>            :    tag_type and template_mem_access.  */
<span class="lineNum">   26139 </span><span class="lineCov">          1 : </span>
<span class="lineNum">   26140 </span><span class="lineCov">          1 : static inline int</span>
<span class="lineNum">   26141 </span>            : prefer_type_arg (tag_types tag_type, bool template_mem_access = false)
<span class="lineNum">   26142 </span>            : {
<span class="lineNum">   26143 </span>            :   /* DR 141: When looking in the current enclosing context for a template-name
<span class="lineNum">   26144 </span><span class="lineCov">         26 :      after -&gt; or ., only consider class templates.  */</span>
<span class="lineNum">   26145 </span><span class="lineCov">         26 :   if (template_mem_access)</span>
<span class="lineNum">   26146 </span>            :     return 2;
<span class="lineNum">   26147 </span><span class="lineCov">         23 :   switch (tag_type)</span>
<span class="lineNum">   26148 </span><span class="lineCov">         23 :     {</span>
<span class="lineNum">   26149 </span><span class="lineCov">         23 :     case none_type:  return 0;  // No preference.</span>
<span class="lineNum">   26150 </span><span class="lineCov">         23 :     case scope_type: return 1;  // Type or namespace.</span>
<span class="lineNum">   26151 </span><span class="lineCov">         23 :     default:         return 2;  // Type only.</span>
<span class="lineNum">   26152 </span><span class="lineCov">         23 :     }</span>
<span class="lineNum">   26153 </span>            : }
<span class="lineNum">   26154 </span>            : 
<span class="lineNum">   26155 </span>            : /* Looks up NAME in the current scope, as given by PARSER-&gt;SCOPE.
<span class="lineNum">   26156 </span><span class="lineCov">         26 :    NAME should have one of the representations used for an</span>
<span class="lineNum">   26157 </span>            :    id-expression.  If NAME is the ERROR_MARK_NODE, the ERROR_MARK_NODE
<span class="lineNum">   26158 </span>            :    is returned.  If PARSER-&gt;SCOPE is a dependent type, then a
<span class="lineNum">   26159 </span>            :    SCOPE_REF is returned.
<span class="lineNum">   26160 </span>            : 
<span class="lineNum">   26161 </span>            :    If NAME is a TEMPLATE_ID_EXPR, then it will be immediately
<span class="lineNum">   26162 </span>            :    returned; the name was already resolved when the TEMPLATE_ID_EXPR
<span class="lineNum">   26163 </span>            :    was formed.  Abstractly, such entities should not be passed to this
<span class="lineNum">   26164 </span><span class="lineCov">          5 :    function, because they do not need to be looked up, but it is</span>
<span class="lineNum">   26165 </span>            :    simpler to check for this special case here, rather than at the
<span class="lineNum">   26166 </span><span class="lineCov">          5 :    call-sites.</span>
<span class="lineNum">   26167 </span><span class="lineCov">          5 : </span>
<span class="lineNum">   26168 </span><span class="lineCov">          5 :    In cases not explicitly covered above, this function returns a</span>
<span class="lineNum">   26169 </span>            :    DECL, OVERLOAD, or baselink representing the result of the lookup.
<span class="lineNum">   26170 </span><span class="lineCov">          5 :    If there was no entity with the indicated NAME, the ERROR_MARK_NODE</span>
<span class="lineNum">   26171 </span>            :    is returned.
<span class="lineNum">   26172 </span>            : 
<span class="lineNum">   26173 </span>            :    If TAG_TYPE is not NONE_TYPE, it indicates an explicit type keyword
<span class="lineNum">   26174 </span>            :    (e.g., &quot;struct&quot;) that was used.  In that case bindings that do not
<span class="lineNum">   26175 </span>            :    refer to types are ignored.
<span class="lineNum">   26176 </span>            : 
<span class="lineNum">   26177 </span>            :    If IS_TEMPLATE is TRUE, bindings that do not refer to templates are
<span class="lineNum">   26178 </span>            :    ignored.
<span class="lineNum">   26179 </span>            : 
<span class="lineNum">   26180 </span>            :    If IS_NAMESPACE is TRUE, bindings that do not refer to namespaces
<span class="lineNum">   26181 </span>            :    are ignored.
<span class="lineNum">   26182 </span>            : 
<span class="lineNum">   26183 </span><span class="lineCov">  170734556 :    If CHECK_DEPENDENCY is TRUE, names are not looked up in dependent</span>
<span class="lineNum">   26184 </span>            :    types.
<span class="lineNum">   26185 </span><span class="lineCov">      43260 : </span>
<span class="lineNum">   26186 </span>            :    If AMBIGUOUS_DECLS is non-NULL, *AMBIGUOUS_DECLS is set to a
<span class="lineNum">   26187 </span>            :    TREE_LIST of candidates if name-lookup results in an ambiguity, and
<span class="lineNum">   26188 </span><span class="lineCov">    5434556 :    NULL_TREE otherwise.  */</span>
<a name="26189"><span class="lineNum">   26189 </span><span class="lineCov">    3546505 : </span></a>
<span class="lineNum">   26190 </span>            : static cp_expr
<span class="lineNum">   26191 </span>            : cp_parser_lookup_name (cp_parser *parser, tree name,
<span class="lineNum">   26192 </span>            :                        enum tag_types tag_type,
<span class="lineNum">   26193 </span>            :                        bool is_template,
<span class="lineNum">   26194 </span>            :                        bool is_namespace,
<span class="lineNum">   26195 </span>            :                        bool check_dependency,
<span class="lineNum">   26196 </span>            :                        tree *ambiguous_decls,
<span class="lineNum">   26197 </span>            :                        location_t name_location)
<span class="lineNum">   26198 </span>            : {
<span class="lineNum">   26199 </span>            :   tree decl;
<span class="lineNum">   26200 </span>            :   tree object_type = parser-&gt;context-&gt;object_type;
<span class="lineNum">   26201 </span>            : 
<span class="lineNum">   26202 </span>            :   /* Assume that the lookup will be unambiguous.  */
<span class="lineNum">   26203 </span>            :   if (ambiguous_decls)
<span class="lineNum">   26204 </span>            :     *ambiguous_decls = NULL_TREE;
<span class="lineNum">   26205 </span>            : 
<span class="lineNum">   26206 </span>            :   /* Now that we have looked up the name, the OBJECT_TYPE (if any) is
<span class="lineNum">   26207 </span>            :      no longer valid.  Note that if we are parsing tentatively, and
<span class="lineNum">   26208 </span>            :      the parse fails, OBJECT_TYPE will be automatically restored.  */
<span class="lineNum">   26209 </span>            :   parser-&gt;context-&gt;object_type = NULL_TREE;
<span class="lineNum">   26210 </span>            : 
<span class="lineNum">   26211 </span>            :   if (name == error_mark_node)
<span class="lineNum">   26212 </span>            :     return error_mark_node;
<span class="lineNum">   26213 </span>            : 
<span class="lineNum">   26214 </span>            :   /* A template-id has already been resolved; there is no lookup to
<span class="lineNum">   26215 </span>            :      do.  */
<span class="lineNum">   26216 </span>            :   if (TREE_CODE (name) == TEMPLATE_ID_EXPR)
<span class="lineNum">   26217 </span>            :     return name;
<span class="lineNum">   26218 </span>            :   if (BASELINK_P (name))
<span class="lineNum">   26219 </span>            :     {
<span class="lineNum">   26220 </span>            :       gcc_assert (TREE_CODE (BASELINK_FUNCTIONS (name))
<span class="lineNum">   26221 </span>            :                   == TEMPLATE_ID_EXPR);
<span class="lineNum">   26222 </span>            :       return name;
<span class="lineNum">   26223 </span>            :     }
<span class="lineNum">   26224 </span>            : 
<span class="lineNum">   26225 </span>            :   /* A BIT_NOT_EXPR is used to represent a destructor.  By this point,
<span class="lineNum">   26226 </span>            :      it should already have been checked to make sure that the name
<span class="lineNum">   26227 </span>            :      used matches the type being destroyed.  */
<span class="lineNum">   26228 </span>            :   if (TREE_CODE (name) == BIT_NOT_EXPR)
<span class="lineNum">   26229 </span><span class="lineCov">  176529115 :     {</span>
<span class="lineNum">   26230 </span>            :       tree type;
<span class="lineNum">   26231 </span>            : 
<span class="lineNum">   26232 </span>            :       /* Figure out to which type this destructor applies.  */
<span class="lineNum">   26233 </span>            :       if (parser-&gt;scope)
<span class="lineNum">   26234 </span>            :         type = parser-&gt;scope;
<span class="lineNum">   26235 </span>            :       else if (object_type)
<span class="lineNum">   26236 </span>            :         type = object_type;
<span class="lineNum">   26237 </span><span class="lineCov">  176529115 :       else</span>
<span class="lineNum">   26238 </span><span class="lineCov">  176529115 :         type = current_class_type;</span>
<span class="lineNum">   26239 </span>            :       /* If that's not a class type, there is no destructor.  */
<span class="lineNum">   26240 </span>            :       if (!type || !CLASS_TYPE_P (type))
<span class="lineNum">   26241 </span><span class="lineCov">  176529115 :         return error_mark_node;</span>
<span class="lineNum">   26242 </span><span class="lineCov">  106770948 : </span>
<span class="lineNum">   26243 </span>            :       if (CLASSTYPE_LAZY_DESTRUCTOR (type))
<span class="lineNum">   26244 </span>            :         lazily_declare_fn (sfk_destructor, type);
<span class="lineNum">   26245 </span>            : 
<span class="lineNum">   26246 </span>            :       if (tree dtor = CLASSTYPE_DESTRUCTOR (type))
<span class="lineNum">   26247 </span><span class="lineCov">  176529115 :         return dtor;</span>
<span class="lineNum">   26248 </span>            : 
<span class="lineNum">   26249 </span><span class="lineCov">  176529115 :       return error_mark_node;</span>
<span class="lineNum">   26250 </span><span class="lineCov">      16781 :     }</span>
<span class="lineNum">   26251 </span>            : 
<span class="lineNum">   26252 </span>            :   /* By this point, the NAME should be an ordinary identifier.  If
<span class="lineNum">   26253 </span>            :      the id-expression was a qualified name, the qualifying scope is
<span class="lineNum">   26254 </span><span class="lineCov">  176512334 :      stored in PARSER-&gt;SCOPE at this point.  */</span>
<span class="lineNum">   26255 </span><span class="lineCov">       4301 :   gcc_assert (identifier_p (name));</span>
<span class="lineNum">   26256 </span><span class="lineCov">  176508033 : </span>
<span class="lineNum">   26257 </span>            :   /* Perform the lookup.  */
<span class="lineNum">   26258 </span><span class="lineCov">       2476 :   if (parser-&gt;scope)</span>
<span class="lineNum">   26259 </span>            :     {
<span class="lineNum">   26260 </span><span class="lineCov">       1238 :       bool dependent_p;</span>
<span class="lineNum">   26261 </span>            : 
<span class="lineNum">   26262 </span>            :       if (parser-&gt;scope == error_mark_node)
<span class="lineNum">   26263 </span>            :         return error_mark_node;
<span class="lineNum">   26264 </span>            : 
<span class="lineNum">   26265 </span>            :       /* If the SCOPE is dependent, the lookup must be deferred until
<span class="lineNum">   26266 </span><span class="lineCov">  176506795 :          the template is instantiated -- unless we are explicitly</span>
<span class="lineNum">   26267 </span>            :          looking up names in uninstantiated templates.  Even then, we
<span class="lineNum">   26268 </span><span class="lineCov">         41 :          cannot look up the name if the scope is not a class type; it</span>
<span class="lineNum">   26269 </span>            :          might, for example, be a template type parameter.  */
<span class="lineNum">   26270 </span>            :       dependent_p = (TYPE_P (parser-&gt;scope)
<span class="lineNum">   26271 </span><span class="lineCov">         41 :                      &amp;&amp; dependent_scope_p (parser-&gt;scope));</span>
<span class="lineNum">   26272 </span>            :       if ((check_dependency || !CLASS_TYPE_P (parser-&gt;scope))
<span class="lineNum">   26273 </span><span class="lineCov">          3 :           &amp;&amp; dependent_p)</span>
<span class="lineNum">   26274 </span>            :         /* Defer lookup.  */
<span class="lineNum">   26275 </span>            :         decl = error_mark_node;
<span class="lineNum">   26276 </span><span class="lineCov">          3 :       else</span>
<span class="lineNum">   26277 </span>            :         {
<span class="lineNum">   26278 </span><span class="lineCov">         41 :           tree pushed_scope = NULL_TREE;</span>
<span class="lineNum">   26279 </span><span class="lineCov">         12 : </span>
<span class="lineNum">   26280 </span>            :           /* If PARSER-&gt;SCOPE is a dependent type, then it must be a
<span class="lineNum">   26281 </span><span class="lineCov">         58 :              class type, and we must not be checking dependencies;</span>
<span class="lineNum">   26282 </span><span class="lineCov">          8 :              otherwise, we would have processed this lookup above.  So</span>
<span class="lineNum">   26283 </span>            :              that PARSER-&gt;SCOPE is not considered a dependent base by
<span class="lineNum">   26284 </span><span class="lineCov">         29 :              lookup_member, we must enter the scope here.  */</span>
<span class="lineNum">   26285 </span><span class="lineCov">         23 :           if (dependent_p)</span>
<span class="lineNum">   26286 </span>            :             pushed_scope = push_scope (parser-&gt;scope);
<span class="lineNum">   26287 </span><span class="lineCov">          6 : </span>
<span class="lineNum">   26288 </span>            :           /* If the PARSER-&gt;SCOPE is a template specialization, it
<span class="lineNum">   26289 </span>            :              may be instantiated during name lookup.  In that case,
<span class="lineNum">   26290 </span>            :              errors may be issued.  Even if we rollback the current
<span class="lineNum">   26291 </span>            :              tentative parse, those errors are valid.  */
<span class="lineNum">   26292 </span>            :           decl = lookup_qualified_name (parser-&gt;scope, name,
<span class="lineNum">   26293 </span><span class="lineCov">  176506754 :                                         prefer_type_arg (tag_type),</span>
<span class="lineNum">   26294 </span>            :                                         /*complain=*/true);
<span class="lineNum">   26295 </span>            : 
<span class="lineNum">   26296 </span><span class="lineCov">  176506754 :           /* 3.4.3.1: In a lookup in which the constructor is an acceptable</span>
<span class="lineNum">   26297 </span>            :              lookup result and the nested-name-specifier nominates a class C:
<span class="lineNum">   26298 </span><span class="lineCov">   15743225 :                * if the name specified after the nested-name-specifier, when</span>
<span class="lineNum">   26299 </span>            :                looked up in C, is the injected-class-name of C (Clause 9), or
<span class="lineNum">   26300 </span><span class="lineCov">   15743225 :                * if the name specified after the nested-name-specifier is the</span>
<span class="lineNum">   26301 </span><span class="lineCov">         91 :                same as the identifier or the simple-template-id's template-</span>
<span class="lineNum">   26302 </span>            :                name in the last component of the nested-name-specifier,
<span class="lineNum">   26303 </span>            :              the name is instead considered to name the constructor of
<span class="lineNum">   26304 </span>            :              class C. [ Note: for example, the constructor is not an
<span class="lineNum">   26305 </span>            :              acceptable lookup result in an elaborated-type-specifier so
<span class="lineNum">   26306 </span>            :              the constructor would not be used in place of the
<span class="lineNum">   26307 </span>            :              injected-class-name. --end note ] Such a constructor name
<span class="lineNum">   26308 </span><span class="lineCov">   31486268 :              shall be used only in the declarator-id of a declaration that</span>
<span class="lineNum">   26309 </span><span class="lineCov">   15743134 :              names a constructor or in a using-declaration.  */</span>
<span class="lineNum">   26310 </span><span class="lineCov">     207064 :           if (tag_type == none_type</span>
<span class="lineNum">   26311 </span><span class="lineCov">   15937782 :               &amp;&amp; DECL_SELF_REFERENCE_P (decl)</span>
<span class="lineNum">   26312 </span>            :               &amp;&amp; same_type_p (DECL_CONTEXT (decl), parser-&gt;scope))
<span class="lineNum">   26313 </span><span class="lineCov">    5778515 :             decl = lookup_qualified_name (parser-&gt;scope, ctor_identifier,</span>
<span class="lineNum">   26314 </span>            :                                           prefer_type_arg (tag_type),
<span class="lineNum">   26315 </span>            :                                           /*complain=*/true);
<span class="lineNum">   26316 </span><span class="lineCov">    9964619 : </span>
<span class="lineNum">   26317 </span>            :           /* If we have a single function from a using decl, pull it out.  */
<span class="lineNum">   26318 </span>            :           if (TREE_CODE (decl) == OVERLOAD
<span class="lineNum">   26319 </span>            :               &amp;&amp; !really_overloaded_fn (decl))
<span class="lineNum">   26320 </span>            :             decl = OVL_FUNCTION (decl);
<span class="lineNum">   26321 </span>            : 
<span class="lineNum">   26322 </span>            :           if (pushed_scope)
<span class="lineNum">   26323 </span><span class="lineCov">    9964619 :             pop_scope (pushed_scope);</span>
<span class="lineNum">   26324 </span><span class="lineCov">       3734 :         }</span>
<span class="lineNum">   26325 </span>            : 
<span class="lineNum">   26326 </span>            :       /* If the scope is a dependent type and either we deferred lookup or
<span class="lineNum">   26327 </span>            :          we did lookup but didn't find the name, rememeber the name.  */
<span class="lineNum">   26328 </span>            :       if (decl == error_mark_node &amp;&amp; TYPE_P (parser-&gt;scope)
<span class="lineNum">   26329 </span>            :           &amp;&amp; dependent_type_p (parser-&gt;scope))
<span class="lineNum">   26330 </span><span class="lineCov">   10398597 :         {</span>
<span class="lineNum">   26331 </span>            :           if (tag_type)
<span class="lineNum">   26332 </span>            :             {
<span class="lineNum">   26333 </span>            :               tree type;
<span class="lineNum">   26334 </span>            : 
<span class="lineNum">   26335 </span>            :               /* The resolution to Core Issue 180 says that `struct
<span class="lineNum">   26336 </span>            :                  A::B' should be considered a type-name, even if `A'
<span class="lineNum">   26337 </span>            :                  is dependent.  */
<span class="lineNum">   26338 </span>            :               type = make_typename_type (parser-&gt;scope, name, tag_type,
<span class="lineNum">   26339 </span>            :                                          /*complain=*/tf_error);
<span class="lineNum">   26340 </span>            :               if (type != error_mark_node)
<span class="lineNum">   26341 </span>            :                 decl = TYPE_NAME (type);
<span class="lineNum">   26342 </span>            :             }
<span class="lineNum">   26343 </span>            :           else if (is_template
<span class="lineNum">   26344 </span>            :                    &amp;&amp; (cp_parser_next_token_ends_template_argument_p (parser)
<span class="lineNum">   26345 </span>            :                        || cp_lexer_next_token_is (parser-&gt;lexer,
<span class="lineNum">   26346 </span>            :                                                   CPP_CLOSE_PAREN)))
<span class="lineNum">   26347 </span>            :             decl = make_unbound_class_template (parser-&gt;scope,
<span class="lineNum">   26348 </span><span class="lineCov">    9964619 :                                                 name, NULL_TREE,</span>
<span class="lineNum">   26349 </span><span class="lineCov">    9530641 :                                                 /*complain=*/tf_error);</span>
<span class="lineNum">   26350 </span><span class="lineCov">    9964920 :           else</span>
<span class="lineNum">   26351 </span><span class="lineCov">        286 :             decl = build_qualified_name (/*type=*/NULL_TREE,</span>
<span class="lineNum">   26352 </span>            :                                          parser-&gt;scope, name,
<span class="lineNum">   26353 </span>            :                                          is_template);
<span class="lineNum">   26354 </span>            :         }
<span class="lineNum">   26355 </span>            :       parser-&gt;qualifying_scope = parser-&gt;scope;
<span class="lineNum">   26356 </span><span class="lineCov">    9964619 :       parser-&gt;object_scope = NULL_TREE;</span>
<span class="lineNum">   26357 </span><span class="lineCov">    4427467 :     }</span>
<span class="lineNum">   26358 </span><span class="lineCov">     839622 :   else if (object_type)</span>
<span class="lineNum">   26359 </span>            :     {
<span class="lineNum">   26360 </span><span class="lineCov">    9964619 :       /* Look up the name in the scope of the OBJECT_TYPE, unless the</span>
<span class="lineNum">   26361 </span><span class="lineCov">       3734 :          OBJECT_TYPE is not a class.  */</span>
<span class="lineNum">   26362 </span>            :       if (CLASS_TYPE_P (object_type))
<span class="lineNum">   26363 </span>            :         /* If the OBJECT_TYPE is a template specialization, it may
<span class="lineNum">   26364 </span>            :            be instantiated during name lookup.  In that case, errors
<span class="lineNum">   26365 </span>            :            may be issued.  Even if we rollback the current tentative
<span class="lineNum">   26366 </span><span class="lineCov">    5783155 :            parse, those errors are valid.  */</span>
<span class="lineNum">   26367 </span><span class="lineCov">   21525321 :         decl = lookup_member (object_type,</span>
<span class="lineNum">   26368 </span>            :                               name,
<span class="lineNum">   26369 </span><span class="lineCov">    5781565 :                               /*protect=*/0,</span>
<span class="lineNum">   26370 </span>            :                               prefer_type_arg (tag_type),
<span class="lineNum">   26371 </span><span class="lineCov">      20085 :                               tf_warning_or_error);</span>
<span class="lineNum">   26372 </span>            :       else
<span class="lineNum">   26373 </span>            :         decl = NULL_TREE;
<span class="lineNum">   26374 </span>            : 
<span class="lineNum">   26375 </span>            :       if (!decl)
<span class="lineNum">   26376 </span><span class="lineCov">      20085 :         /* Look it up in the enclosing context.  DR 141: When looking for a</span>
<span class="lineNum">   26377 </span>            :            template-name after -&gt; or ., only consider class templates.  */
<span class="lineNum">   26378 </span><span class="lineCov">      20085 :         decl = lookup_name_real (name, prefer_type_arg (tag_type, is_template),</span>
<span class="lineNum">   26379 </span><span class="lineCov">      20083 :                                  /*nonclass=*/0,</span>
<span class="lineNum">   26380 </span>            :                                  /*block_p=*/true, is_namespace, 0);
<span class="lineNum">   26381 </span><span class="lineCov">    5761480 :       if (object_type == unknown_type_node)</span>
<span class="lineNum">   26382 </span><span class="lineCov">    5761480 :         /* The object is type-dependent, so we can't look anything up; we used</span>
<span class="lineNum">   26383 </span><span class="lineCov">      73158 :            this to get the DR 141 behavior.  */</span>
<span class="lineNum">   26384 </span>            :         object_type = NULL_TREE;
<span class="lineNum">   26385 </span><span class="lineCov">        239 :       parser-&gt;object_scope = object_type;</span>
<span class="lineNum">   26386 </span>            :       parser-&gt;qualifying_scope = NULL_TREE;
<span class="lineNum">   26387 </span>            :     }
<span class="lineNum">   26388 </span>            :   else
<span class="lineNum">   26389 </span><span class="lineCov">    5761241 :     {</span>
<span class="lineNum">   26390 </span>            :       decl = lookup_name_real (name, prefer_type_arg (tag_type),
<span class="lineNum">   26391 </span>            :                                /*nonclass=*/0,
<span class="lineNum">   26392 </span>            :                                /*block_p=*/true, is_namespace, 0);
<span class="lineNum">   26393 </span><span class="lineCov">   15743134 :       parser-&gt;qualifying_scope = NULL_TREE;</span>
<span class="lineNum">   26394 </span><span class="lineCov">   15743134 :       parser-&gt;object_scope = NULL_TREE;</span>
<span class="lineNum">   26395 </span>            :     }
<span class="lineNum">   26396 </span><span class="lineCov">  160763529 : </span>
<span class="lineNum">   26397 </span>            :   /* If the lookup failed, let our caller know.  */
<span class="lineNum">   26398 </span>            :   if (!decl || decl == error_mark_node)
<span class="lineNum">   26399 </span>            :     return error_mark_node;
<span class="lineNum">   26400 </span><span class="lineCov">     114118 : </span>
<span class="lineNum">   26401 </span>            :   /* Pull out the template from an injected-class-name (or multiple).  */
<span class="lineNum">   26402 </span>            :   if (is_template)
<span class="lineNum">   26403 </span>            :     decl = maybe_get_template_decl_from_type_decl (decl);
<span class="lineNum">   26404 </span>            : 
<span class="lineNum">   26405 </span><span class="lineCov">      74793 :   /* If it's a TREE_LIST, the result of the lookup was ambiguous.  */</span>
<span class="lineNum">   26406 </span>            :   if (TREE_CODE (decl) == TREE_LIST)
<span class="lineNum">   26407 </span>            :     {
<span class="lineNum">   26408 </span><span class="lineCov">      27363 :       if (ambiguous_decls)</span>
<span class="lineNum">   26409 </span>            :         *ambiguous_decls = decl;
<span class="lineNum">   26410 </span>            :       /* The error message we have to print is too complicated for
<span class="lineNum">   26411 </span>            :          cp_parser_error, so we incorporate its actions directly.  */
<span class="lineNum">   26412 </span>            :       if (!cp_parser_simulate_error (parser))
<span class="lineNum">   26413 </span><span class="lineCov">      24931 :         {</span>
<span class="lineNum">   26414 </span>            :           error_at (name_location, &quot;reference to %qD is ambiguous&quot;,
<span class="lineNum">   26415 </span>            :                     name);
<span class="lineNum">   26416 </span><span class="lineCov">     138569 :           print_candidates (decl);</span>
<span class="lineNum">   26417 </span>            :         }
<span class="lineNum">   26418 </span>            :       return error_mark_node;
<span class="lineNum">   26419 </span><span class="lineCov">     114118 :     }</span>
<span class="lineNum">   26420 </span>            : 
<span class="lineNum">   26421 </span>            :   gcc_assert (DECL_P (decl)
<span class="lineNum">   26422 </span><span class="lineCov">      89009 :               || TREE_CODE (decl) == OVERLOAD</span>
<span class="lineNum">   26423 </span><span class="lineCov">     114118 :               || TREE_CODE (decl) == SCOPE_REF</span>
<span class="lineNum">   26424 </span><span class="lineCov">     114118 :               || TREE_CODE (decl) == UNBOUND_CLASS_TEMPLATE</span>
<span class="lineNum">   26425 </span>            :               || BASELINK_P (decl));
<span class="lineNum">   26426 </span>            : 
<span class="lineNum">   26427 </span>            :   /* If we have resolved the name of a member declaration, check to
<span class="lineNum">   26428 </span><span class="lineCov">  169171351 :      see if the declaration is accessible.  When the name resolves to</span>
<span class="lineNum">   26429 </span>            :      set of overloaded functions, accessibility is checked when
<span class="lineNum">   26430 </span>            :      overload resolution is done.
<span class="lineNum">   26431 </span><span class="lineCov">  160649411 : </span>
<span class="lineNum">   26432 </span><span class="lineCov">  160649411 :      During an explicit instantiation, access is not checked at all,</span>
<span class="lineNum">   26433 </span>            :      as per [temp.explicit].  */
<span class="lineNum">   26434 </span>            :   if (DECL_P (decl))
<span class="lineNum">   26435 </span>            :     check_accessibility_of_qualified_id (decl, object_type, parser-&gt;scope);
<span class="lineNum">   26436 </span><span class="lineCov">  176506663 : </span>
<span class="lineNum">   26437 </span><span class="lineCov">     610155 :   maybe_record_typedef_use (decl);</span>
<span class="lineNum">   26438 </span>            : 
<span class="lineNum">   26439 </span>            :   return cp_expr (decl, name_location);
<span class="lineNum">   26440 </span><span class="lineCov">  175896508 : }</span>
<span class="lineNum">   26441 </span><span class="lineCov">   11680383 : </span>
<span class="lineNum">   26442 </span>            : /* Like cp_parser_lookup_name, but for use in the typical case where
<span class="lineNum">   26443 </span>            :    CHECK_ACCESS is TRUE, IS_TYPE is FALSE, IS_TEMPLATE is FALSE,
<span class="lineNum">   26444 </span><span class="lineCov">  175896508 :    IS_NAMESPACE is FALSE, and CHECK_DEPENDENCY is TRUE.  */</span>
<a name="26445"><span class="lineNum">   26445 </span>            : </a>
<span class="lineNum">   26446 </span><span class="lineCov">        626 : static tree</span>
<span class="lineNum">   26447 </span><span class="lineCov">        132 : cp_parser_lookup_name_simple (cp_parser* parser, tree name, location_t location)</span>
<span class="lineNum">   26448 </span>            : {
<span class="lineNum">   26449 </span>            :   return cp_parser_lookup_name (parser, name,
<span class="lineNum">   26450 </span><span class="lineCov">        572 :                                 none_type,</span>
<span class="lineNum">   26451 </span>            :                                 /*is_template=*/false,
<span class="lineNum">   26452 </span><span class="lineCov">         54 :                                 /*is_namespace=*/false,</span>
<span class="lineNum">   26453 </span>            :                                 /*check_dependency=*/true,
<span class="lineNum">   26454 </span><span class="lineCov">         54 :                                 /*ambiguous_decls=*/NULL,</span>
<span class="lineNum">   26455 </span>            :                                 location);
<span class="lineNum">   26456 </span><span class="lineCov">        626 : }</span>
<span class="lineNum">   26457 </span>            : 
<span class="lineNum">   26458 </span>            : /* If DECL is a TEMPLATE_DECL that can be treated like a TYPE_DECL in
<span class="lineNum">   26459 </span><span class="lineCov">  175895882 :    the current context, return the TYPE_DECL.  If TAG_NAME_P is</span>
<span class="lineNum">   26460 </span>            :    true, the DECL indicates the class being defined in a class-head,
<span class="lineNum">   26461 </span>            :    or declared in an elaborated-type-specifier.
<span class="lineNum">   26462 </span>            : 
<span class="lineNum">   26463 </span>            :    Otherwise, return DECL.  */
<a name="26464"><span class="lineNum">   26464 </span>            : </a>
<span class="lineNum">   26465 </span>            : static tree
<span class="lineNum">   26466 </span>            : cp_parser_maybe_treat_template_as_class (tree decl, bool tag_name_p)
<span class="lineNum">   26467 </span>            : {
<span class="lineNum">   26468 </span>            :   /* If the TEMPLATE_DECL is being declared as part of a class-head,
<span class="lineNum">   26469 </span>            :      the translation from TEMPLATE_DECL to TYPE_DECL occurs:
<span class="lineNum">   26470 </span>            : 
<span class="lineNum">   26471 </span>            :        struct A {
<span class="lineNum">   26472 </span><span class="lineCov">  175895882 :          template &lt;typename T&gt; struct B;</span>
<span class="lineNum">   26473 </span><span class="lineCov">  161424232 :        };</span>
<span class="lineNum">   26474 </span>            : 
<span class="lineNum">   26475 </span><span class="lineCov">  175895882 :        template &lt;typename T&gt; struct A::B {};</span>
<span class="lineNum">   26476 </span>            : 
<span class="lineNum">   26477 </span><span class="lineCov">  175895882 :      Similarly, in an elaborated-type-specifier:</span>
<span class="lineNum">   26478 </span>            : 
<span class="lineNum">   26479 </span>            :        namespace N { struct X{}; }
<span class="lineNum">   26480 </span>            : 
<span class="lineNum">   26481 </span>            :        struct A {
<span class="lineNum">   26482 </span>            :          template &lt;typename T&gt; friend struct N::X;
<span class="lineNum">   26483 </span>            :        };
<span class="lineNum">   26484 </span>            : 
<span class="lineNum">   26485 </span><span class="lineNoCov">          0 :      However, if the DECL refers to a class type, and we are in</span>
<span class="lineNum">   26486 </span>            :      the scope of the class, then the name lookup automatically
<span class="lineNum">   26487 </span><span class="lineCov">   46410834 :      finds the TYPE_DECL created by build_self_reference rather</span>
<span class="lineNum">   26488 </span>            :      than a TEMPLATE_DECL.  For example, in:
<span class="lineNum">   26489 </span>            : 
<span class="lineNum">   26490 </span>            :        template &lt;class T&gt; struct S {
<span class="lineNum">   26491 </span>            :          S s;
<span class="lineNum">   26492 </span>            :        };
<span class="lineNum">   26493 </span><span class="lineCov">   46470561 : </span>
<span class="lineNum">   26494 </span>            :      there is no need to handle such case.  */
<span class="lineNum">   26495 </span>            : 
<span class="lineNum">   26496 </span>            :   if (DECL_CLASS_TEMPLATE_P (decl) &amp;&amp; tag_name_p)
<span class="lineNum">   26497 </span>            :     return DECL_TEMPLATE_RESULT (decl);
<span class="lineNum">   26498 </span>            : 
<span class="lineNum">   26499 </span>            :   return decl;
<span class="lineNum">   26500 </span>            : }
<span class="lineNum">   26501 </span>            : 
<span class="lineNum">   26502 </span>            : /* If too many, or too few, template-parameter lists apply to the
<span class="lineNum">   26503 </span>            :    declarator, issue an error message.  Returns TRUE if all went well,
<span class="lineNum">   26504 </span><span class="lineCov">   93318254 :    and FALSE otherwise.  */</span>
<a name="26505"><span class="lineNum">   26505 </span>            : </a>
<span class="lineNum">   26506 </span>            : static bool
<span class="lineNum">   26507 </span>            : cp_parser_check_declarator_template_parameters (cp_parser* parser,
<span class="lineNum">   26508 </span>            :                                                 cp_declarator *declarator,
<span class="lineNum">   26509 </span>            :                                                 location_t declarator_location)
<span class="lineNum">   26510 </span>            : {
<span class="lineNum">   26511 </span>            :   switch (declarator-&gt;kind)
<span class="lineNum">   26512 </span>            :     {
<span class="lineNum">   26513 </span>            :     case cdk_id:
<span class="lineNum">   26514 </span>            :       {
<span class="lineNum">   26515 </span>            :         unsigned num_templates = 0;
<span class="lineNum">   26516 </span>            :         tree scope = declarator-&gt;u.id.qualifying_scope;
<span class="lineNum">   26517 </span>            :         bool template_id_p = false;
<span class="lineNum">   26518 </span>            : 
<span class="lineNum">   26519 </span>            :         if (scope)
<span class="lineNum">   26520 </span>            :           num_templates = num_template_headers_for_class (scope);
<span class="lineNum">   26521 </span>            :         else if (TREE_CODE (declarator-&gt;u.id.unqualified_name)
<span class="lineNum">   26522 </span>            :                  == TEMPLATE_ID_EXPR)
<span class="lineNum">   26523 </span>            :           {
<span class="lineNum">   26524 </span>            :             /* If the DECLARATOR has the form `X&lt;y&gt;' then it uses one
<span class="lineNum">   26525 </span>            :                additional level of template parameters.  */
<span class="lineNum">   26526 </span>            :             ++num_templates;
<span class="lineNum">   26527 </span>            :             template_id_p = true;
<span class="lineNum">   26528 </span>            :           }
<span class="lineNum">   26529 </span>            : 
<span class="lineNum">   26530 </span>            :         return cp_parser_check_template_parameters 
<span class="lineNum">   26531 </span>            :           (parser, num_templates, template_id_p, declarator_location,
<span class="lineNum">   26532 </span>            :            declarator);
<span class="lineNum">   26533 </span>            :       }
<span class="lineNum">   26534 </span><span class="lineCov">   93318254 : </span>
<span class="lineNum">   26535 </span>            :     case cdk_function:
<span class="lineNum">   26536 </span>            :     case cdk_array:
<span class="lineNum">   26537 </span>            :     case cdk_pointer:
<span class="lineNum">   26538 </span>            :     case cdk_reference:
<span class="lineNum">   26539 </span>            :     case cdk_ptrmem:
<span class="lineNum">   26540 </span>            :       return (cp_parser_check_declarator_template_parameters
<span class="lineNum">   26541 </span>            :               (parser, declarator-&gt;declarator, declarator_location));
<span class="lineNum">   26542 </span>            : 
<span class="lineNum">   26543 </span>            :     case cdk_decomp:
<span class="lineNum">   26544 </span>            :     case cdk_error:
<span class="lineNum">   26545 </span><span class="lineCov">   10154966 :       return true;</span>
<span class="lineNum">   26546 </span>            : 
<span class="lineNum">   26547 </span>            :     default:
<span class="lineNum">   26548 </span>            :       gcc_unreachable ();
<span class="lineNum">   26549 </span><span class="lineCov">   17764384 :     }</span>
<span class="lineNum">   26550 </span>            :   return false;
<span class="lineNum">   26551 </span><span class="lineCov">   10154966 : }</span>
<span class="lineNum">   26552 </span><span class="lineCov">   10154966 : </span>
<span class="lineNum">   26553 </span><span class="lineCov">   10154966 : /* NUM_TEMPLATES were used in the current declaration.  If that is</span>
<span class="lineNum">   26554 </span><span class="lineCov">   10154966 :    invalid, return FALSE and issue an error messages.  Otherwise,</span>
<span class="lineNum">   26555 </span><span class="lineCov">   10154966 :    return TRUE.  If DECLARATOR is non-NULL, then we are checking a</span>
<span class="lineNum">   26556 </span>            :    declarator and we can print more accurate diagnostics.  */
<a name="26557"><span class="lineNum">   26557 </span><span class="lineCov">   10154966 : </span></a>
<span class="lineNum">   26558 </span><span class="lineCov">     440793 : static bool</span>
<span class="lineNum">   26559 </span><span class="lineCov">    9714173 : cp_parser_check_template_parameters (cp_parser* parser,</span>
<span class="lineNum">   26560 </span>            :                                      unsigned num_templates,
<span class="lineNum">   26561 </span>            :                                      bool template_id_p,
<span class="lineNum">   26562 </span>            :                                      location_t location,
<span class="lineNum">   26563 </span>            :                                      cp_declarator *declarator)
<span class="lineNum">   26564 </span><span class="lineCov">        467 : {</span>
<span class="lineNum">   26565 </span><span class="lineCov">        467 :   /* If there are the same number of template classes and parameter</span>
<span class="lineNum">   26566 </span>            :      lists, that's OK.  */
<span class="lineNum">   26567 </span>            :   if (parser-&gt;num_template_parameter_lists == num_templates)
<span class="lineNum">   26568 </span><span class="lineCov">   10154966 :     return true;</span>
<span class="lineNum">   26569 </span><span class="lineCov">   10154966 :   /* If there are more, but only one more, and the name ends in an identifier,</span>
<span class="lineNum">   26570 </span><span class="lineCov">   10154966 :      then we are declaring a primary template.  That's OK too.  */</span>
<span class="lineNum">   26571 </span>            :   if (!template_id_p
<span class="lineNum">   26572 </span>            :       &amp;&amp; parser-&gt;num_template_parameter_lists == num_templates + 1)
<span class="lineNum">   26573 </span><span class="lineCov">    7609418 :     return true;</span>
<span class="lineNum">   26574 </span><span class="lineCov">    7609418 :   /* If there are more template classes than parameter lists, we have</span>
<span class="lineNum">   26575 </span><span class="lineCov">    7609418 :      something like:</span>
<span class="lineNum">   26576 </span><span class="lineCov">    7609418 : </span>
<span class="lineNum">   26577 </span><span class="lineCov">    7609418 :        template &lt;class T&gt; void S&lt;T&gt;::R&lt;T&gt;::f ();  */</span>
<span class="lineNum">   26578 </span><span class="lineCov">    7609418 :   if (parser-&gt;num_template_parameter_lists &lt; num_templates)</span>
<span class="lineNum">   26579 </span><span class="lineCov">    7609418 :     {</span>
<span class="lineNum">   26580 </span>            :       if (declarator &amp;&amp; !current_function_decl)
<span class="lineNum">   26581 </span>            :         error_at (location, &quot;specializing member %&lt;%T::%E%&gt; &quot;
<span class="lineNum">   26582 </span>            :                   &quot;requires %&lt;template&lt;&gt;%&gt; syntax&quot;, 
<span class="lineNum">   26583 </span>            :                   declarator-&gt;u.id.qualifying_scope,
<span class="lineNum">   26584 </span>            :                   declarator-&gt;u.id.unqualified_name);
<span class="lineNum">   26585 </span><span class="lineNoCov">          0 :       else if (declarator)</span>
<span class="lineNum">   26586 </span><span class="lineNoCov">          0 :         error_at (location, &quot;invalid declaration of %&lt;%T::%E%&gt;&quot;,</span>
<span class="lineNum">   26587 </span>            :                   declarator-&gt;u.id.qualifying_scope,
<span class="lineNum">   26588 </span>            :                   declarator-&gt;u.id.unqualified_name);
<span class="lineNum">   26589 </span>            :       else 
<span class="lineNum">   26590 </span>            :         error_at (location, &quot;too few template-parameter-lists&quot;);
<span class="lineNum">   26591 </span>            :       return false;
<span class="lineNum">   26592 </span>            :     }
<span class="lineNum">   26593 </span>            :   /* Otherwise, there are too many template parameter lists.  We have
<span class="lineNum">   26594 </span>            :      something like:
<span class="lineNum">   26595 </span>            : 
<span class="lineNum">   26596 </span>            :      template &lt;class T&gt; template &lt;class U&gt; void S::f();  */
<span class="lineNum">   26597 </span><span class="lineCov">   12992196 :   error_at (location, &quot;too many template-parameter-lists&quot;);</span>
<span class="lineNum">   26598 </span>            :   return false;
<span class="lineNum">   26599 </span>            : }
<span class="lineNum">   26600 </span>            : 
<span class="lineNum">   26601 </span>            : /* Parse an optional `::' token indicating that the following name is
<span class="lineNum">   26602 </span>            :    from the global namespace.  If so, PARSER-&gt;SCOPE is set to the
<span class="lineNum">   26603 </span>            :    GLOBAL_NAMESPACE. Otherwise, PARSER-&gt;SCOPE is set to NULL_TREE,
<span class="lineNum">   26604 </span>            :    unless CURRENT_SCOPE_VALID_P is TRUE, in which case it is left alone.
<span class="lineNum">   26605 </span><span class="lineCov">   12992196 :    Returns the new value of PARSER-&gt;SCOPE, if the `::' token is</span>
<span class="lineNum">   26606 </span>            :    present, and NULL_TREE otherwise.  */
<a name="26607"><span class="lineNum">   26607 </span>            : </a>
<span class="lineNum">   26608 </span>            : static tree
<span class="lineNum">   26609 </span><span class="lineCov">    3235195 : cp_parser_global_scope_opt (cp_parser* parser, bool current_scope_valid_p)</span>
<span class="lineNum">   26610 </span><span class="lineCov">    3235175 : {</span>
<span class="lineNum">   26611 </span>            :   cp_token *token;
<span class="lineNum">   26612 </span>            : 
<span class="lineNum">   26613 </span>            :   /* Peek at the next token.  */
<span class="lineNum">   26614 </span>            :   token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   26615 </span>            :   /* If we're looking at a `::' token then we're starting from the
<span class="lineNum">   26616 </span><span class="lineCov">         72 :      global namespace, not our current location.  */</span>
<span class="lineNum">   26617 </span>            :   if (token-&gt;type == CPP_SCOPE)
<span class="lineNum">   26618 </span><span class="lineCov">         33 :     {</span>
<span class="lineNum">   26619 </span><span class="lineCov">         15 :       /* Consume the `::' token.  */</span>
<span class="lineNum">   26620 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   26621 </span>            :       /* Set the SCOPE so that we know where to start the lookup.  */
<span class="lineNum">   26622 </span>            :       parser-&gt;scope = global_namespace;
<span class="lineNum">   26623 </span><span class="lineCov">         18 :       parser-&gt;qualifying_scope = global_namespace;</span>
<span class="lineNum">   26624 </span><span class="lineNoCov">          0 :       parser-&gt;object_scope = NULL_TREE;</span>
<span class="lineNum">   26625 </span>            : 
<span class="lineNum">   26626 </span>            :       return parser-&gt;scope;
<span class="lineNum">   26627 </span>            :     }
<span class="lineNum">   26628 </span><span class="lineCov">         18 :   else if (!current_scope_valid_p)</span>
<span class="lineNum">   26629 </span><span class="lineCov">         33 :     {</span>
<span class="lineNum">   26630 </span>            :       parser-&gt;scope = NULL_TREE;
<span class="lineNum">   26631 </span>            :       parser-&gt;qualifying_scope = NULL_TREE;
<span class="lineNum">   26632 </span>            :       parser-&gt;object_scope = NULL_TREE;
<span class="lineNum">   26633 </span>            :     }
<span class="lineNum">   26634 </span>            : 
<span class="lineNum">   26635 </span><span class="lineCov">         39 :   return NULL_TREE;</span>
<span class="lineNum">   26636 </span><span class="lineCov">         39 : }</span>
<span class="lineNum">   26637 </span>            : 
<span class="lineNum">   26638 </span>            : /* Returns TRUE if the upcoming token sequence is the start of a
<span class="lineNum">   26639 </span>            :    constructor declarator or C++17 deduction guide.  If FRIEND_P is true, the
<span class="lineNum">   26640 </span>            :    declarator is preceded by the `friend' specifier.  */
<a name="26641"><span class="lineNum">   26641 </span>            : </a>
<span class="lineNum">   26642 </span>            : static bool
<span class="lineNum">   26643 </span>            : cp_parser_constructor_declarator_p (cp_parser *parser, bool friend_p)
<span class="lineNum">   26644 </span>            : {
<span class="lineNum">   26645 </span>            :   bool constructor_p;
<span class="lineNum">   26646 </span>            :   bool outside_class_specifier_p;
<span class="lineNum">   26647 </span><span class="lineCov">   73637794 :   tree nested_name_specifier;</span>
<span class="lineNum">   26648 </span>            :   cp_token *next_token;
<span class="lineNum">   26649 </span><span class="lineCov">  265719338 : </span>
<span class="lineNum">   26650 </span>            :   /* The common case is that this is not a constructor declarator, so
<span class="lineNum">   26651 </span>            :      try to avoid doing lots of work if at all possible.  It's not
<span class="lineNum">   26652 </span><span class="lineCov">  531438676 :      valid declare a constructor at function scope.  */</span>
<span class="lineNum">   26653 </span>            :   if (parser-&gt;in_function_body)
<span class="lineNum">   26654 </span>            :     return false;
<span class="lineNum">   26655 </span><span class="lineCov">  265719338 :   /* And only certain tokens can begin a constructor declarator.  */</span>
<span class="lineNum">   26656 </span>            :   next_token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   26657 </span>            :   if (next_token-&gt;type != CPP_NAME
<span class="lineNum">   26658 </span><span class="lineCov">     587477 :       &amp;&amp; next_token-&gt;type != CPP_SCOPE</span>
<span class="lineNum">   26659 </span>            :       &amp;&amp; next_token-&gt;type != CPP_NESTED_NAME_SPECIFIER
<span class="lineNum">   26660 </span><span class="lineCov">     587477 :       &amp;&amp; next_token-&gt;type != CPP_TEMPLATE_ID)</span>
<span class="lineNum">   26661 </span><span class="lineCov">     587477 :     return false;</span>
<span class="lineNum">   26662 </span><span class="lineCov">     587477 : </span>
<span class="lineNum">   26663 </span>            :   /* Parse tentatively; we are going to roll back all of the tokens
<span class="lineNum">   26664 </span><span class="lineCov">     587477 :      consumed here.  */</span>
<span class="lineNum">   26665 </span>            :   cp_parser_parse_tentatively (parser);
<span class="lineNum">   26666 </span><span class="lineCov">   73627571 :   /* Assume that we are looking at a constructor declarator.  */</span>
<span class="lineNum">   26667 </span>            :   constructor_p = true;
<span class="lineNum">   26668 </span><span class="lineCov">  262920948 : </span>
<span class="lineNum">   26669 </span><span class="lineCov">  262920948 :   /* Look for the optional `::' operator.  */</span>
<span class="lineNum">   26670 </span><span class="lineCov">  262920948 :   cp_parser_global_scope_opt (parser,</span>
<span class="lineNum">   26671 </span>            :                               /*current_scope_valid_p=*/false);
<span class="lineNum">   26672 </span>            :   /* Look for the nested-name-specifier.  */
<span class="lineNum">   26673 </span>            :   nested_name_specifier
<span class="lineNum">   26674 </span>            :     = (cp_parser_nested_name_specifier_opt (parser,
<span class="lineNum">   26675 </span>            :                                             /*typename_keyword_p=*/false,
<span class="lineNum">   26676 </span>            :                                             /*check_dependency_p=*/false,
<span class="lineNum">   26677 </span>            :                                             /*type_p=*/false,
<span class="lineNum">   26678 </span>            :                                             /*is_declaration=*/false));
<span class="lineNum">   26679 </span>            : 
<span class="lineNum">   26680 </span>            :   outside_class_specifier_p = (!at_class_scope_p ()
<span class="lineNum">   26681 </span><span class="lineCov">   24855755 :                                || !TYPE_BEING_DEFINED (current_class_type)</span>
<span class="lineNum">   26682 </span>            :                                || friend_p);
<span class="lineNum">   26683 </span><span class="lineCov">   24855755 : </span>
<span class="lineNum">   26684 </span><span class="lineCov">   24855755 :   /* Outside of a class-specifier, there must be a</span>
<span class="lineNum">   26685 </span><span class="lineCov">   24855755 :      nested-name-specifier.  Except in C++17 mode, where we</span>
<span class="lineNum">   26686 </span><span class="lineCov">   24855755 :      might be declaring a guiding declaration.  */</span>
<span class="lineNum">   26687 </span>            :   if (!nested_name_specifier &amp;&amp; outside_class_specifier_p
<span class="lineNum">   26688 </span>            :       &amp;&amp; cxx_dialect &lt; cxx17)
<span class="lineNum">   26689 </span>            :     constructor_p = false;
<span class="lineNum">   26690 </span>            :   else if (nested_name_specifier == error_mark_node)
<span class="lineNum">   26691 </span><span class="lineCov">   24855755 :     constructor_p = false;</span>
<span class="lineNum">   26692 </span>            : 
<span class="lineNum">   26693 </span>            :   /* If we have a class scope, this is easy; DR 147 says that S::S always
<span class="lineNum">   26694 </span><span class="lineCov">   32884846 :      names the constructor, and no other qualified name could.  */</span>
<span class="lineNum">   26695 </span><span class="lineCov">   16442423 :   if (constructor_p &amp;&amp; nested_name_specifier</span>
<span class="lineNum">   26696 </span><span class="lineCov">   10741955 :       &amp;&amp; CLASS_TYPE_P (nested_name_specifier))</span>
<span class="lineNum">   26697 </span><span class="lineCov">   10741909 :     {</span>
<span class="lineNum">   26698 </span><span class="lineCov">   10713544 :       tree id = cp_parser_unqualified_id (parser,</span>
<span class="lineNum">   26699 </span>            :                                           /*template_keyword_p=*/false,
<span class="lineNum">   26700 </span>            :                                           /*check_dependency_p=*/false,
<span class="lineNum">   26701 </span>            :                                           /*declarator_p=*/true,
<span class="lineNum">   26702 </span>            :                                           /*optional_p=*/false);
<span class="lineNum">   26703 </span><span class="lineCov">    5766130 :       if (is_overloaded_fn (id))</span>
<span class="lineNum">   26704 </span>            :         id = DECL_NAME (get_first_fn (id));
<span class="lineNum">   26705 </span><span class="lineCov">    5766130 :       if (!constructor_name_p (id, nested_name_specifier))</span>
<span class="lineNum">   26706 </span>            :         constructor_p = false;
<span class="lineNum">   26707 </span>            :     }
<span class="lineNum">   26708 </span><span class="lineCov">    5766130 :   /* If we still think that this might be a constructor-declarator,</span>
<span class="lineNum">   26709 </span>            :      look for a class-name.  */
<span class="lineNum">   26710 </span>            :   else if (constructor_p)
<span class="lineNum">   26711 </span><span class="lineCov">    5766130 :     {</span>
<span class="lineNum">   26712 </span><span class="lineCov">    5766130 :       /* If we have:</span>
<span class="lineNum">   26713 </span>            : 
<span class="lineNum">   26714 </span>            :            template &lt;typename T&gt; struct S {
<span class="lineNum">   26715 </span>            :              S();
<span class="lineNum">   26716 </span>            :            };
<span class="lineNum">   26717 </span>            : 
<span class="lineNum">   26718 </span><span class="lineCov">    5766130 :          we must recognize that the nested `S' names a class.  */</span>
<span class="lineNum">   26719 </span><span class="lineCov">    3362080 :       if (cxx_dialect &gt;= cxx17)</span>
<span class="lineNum">   26720 </span><span class="lineCov">    9128210 :         cp_parser_parse_tentatively (parser);</span>
<span class="lineNum">   26721 </span>            : 
<span class="lineNum">   26722 </span>            :       tree type_decl;
<span class="lineNum">   26723 </span>            :       type_decl = cp_parser_class_name (parser,
<span class="lineNum">   26724 </span>            :                                         /*typename_keyword_p=*/false,
<span class="lineNum">   26725 </span><span class="lineCov">    5766130 :                                         /*template_keyword_p=*/false,</span>
<span class="lineNum">   26726 </span><span class="lineCov">    2258706 :                                         none_type,</span>
<span class="lineNum">   26727 </span>            :                                         /*check_dependency_p=*/false,
<span class="lineNum">   26728 </span><span class="lineCov">    3837561 :                                         /*class_head_p=*/false,</span>
<span class="lineNum">   26729 </span>            :                                         /*is_declaration=*/false);
<span class="lineNum">   26730 </span>            : 
<span class="lineNum">   26731 </span>            :       if (cxx_dialect &gt;= cxx17
<span class="lineNum">   26732 </span>            :           &amp;&amp; !cp_parser_parse_definitely (parser))
<span class="lineNum">   26733 </span><span class="lineCov">    3837555 :         {</span>
<span class="lineNum">   26734 </span><span class="lineCov">     233034 :           type_decl = NULL_TREE;</span>
<span class="lineNum">   26735 </span>            :           tree tmpl = cp_parser_template_name (parser,
<span class="lineNum">   26736 </span><span class="lineCov">     132098 :                                                /*template_keyword*/false,</span>
<span class="lineNum">   26737 </span>            :                                                /*check_dependency_p*/false,
<span class="lineNum">   26738 </span>            :                                                /*is_declaration*/false,
<span class="lineNum">   26739 </span>            :                                                none_type,
<span class="lineNum">   26740 </span><span class="lineCov">      66049 :                                                /*is_identifier*/NULL);</span>
<span class="lineNum">   26741 </span><span class="lineCov">      66049 :           if (DECL_CLASS_TEMPLATE_P (tmpl)</span>
<span class="lineNum">   26742 </span><span class="lineCov">         14 :               || DECL_TEMPLATE_TEMPLATE_PARM_P (tmpl))</span>
<span class="lineNum">   26743 </span><span class="lineCov">      66049 :             /* It's a deduction guide, return true.  */;</span>
<span class="lineNum">   26744 </span><span class="lineCov">      37004 :           else</span>
<span class="lineNum">   26745 </span>            :             cp_parser_simulate_error (parser);
<span class="lineNum">   26746 </span>            :         }
<span class="lineNum">   26747 </span>            : 
<span class="lineNum">   26748 </span><span class="lineCov">    5700081 :       /* If there was no class-name, then this is not a constructor.</span>
<span class="lineNum">   26749 </span>            :          Otherwise, if we are in a class-specifier and we aren't
<span class="lineNum">   26750 </span>            :          handling a friend declaration, check that its type matches
<span class="lineNum">   26751 </span>            :          current_class_type (c++/38313).  Note: error_mark_node
<span class="lineNum">   26752 </span>            :          is left alone for error recovery purposes.  */
<span class="lineNum">   26753 </span>            :       constructor_p = (!cp_parser_error_occurred (parser)
<span class="lineNum">   26754 </span>            :                        &amp;&amp; (outside_class_specifier_p
<span class="lineNum">   26755 </span>            :                            || type_decl == NULL_TREE
<span class="lineNum">   26756 </span>            :                            || type_decl == error_mark_node
<span class="lineNum">   26757 </span><span class="lineCov">    3771506 :                            || same_type_p (current_class_type,</span>
<span class="lineNum">   26758 </span><span class="lineCov">    1165465 :                                            TREE_TYPE (type_decl))));</span>
<span class="lineNum">   26759 </span>            : 
<span class="lineNum">   26760 </span><span class="lineCov">    3771506 :       /* If we're still considering a constructor, we have to see a `(',</span>
<span class="lineNum">   26761 </span><span class="lineCov">    3771506 :          to begin the parameter-declaration-clause, followed by either a</span>
<span class="lineNum">   26762 </span>            :          `)', an `...', or a decl-specifier.  We need to check for a
<span class="lineNum">   26763 </span>            :          type-specifier to avoid being fooled into thinking that:
<span class="lineNum">   26764 </span>            : 
<span class="lineNum">   26765 </span>            :            S (f) (int);
<span class="lineNum">   26766 </span>            : 
<span class="lineNum">   26767 </span>            :          is a constructor.  (It is actually a function named `f' that
<span class="lineNum">   26768 </span>            :          takes one parameter (of type `int') and returns a value of type
<span class="lineNum">   26769 </span><span class="lineCov">    3771506 :          `S'.  */</span>
<span class="lineNum">   26770 </span><span class="lineCov">    3771506 :       if (constructor_p</span>
<span class="lineNum">   26771 </span>            :           &amp;&amp; !cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))
<span class="lineNum">   26772 </span><span class="lineCov">     335172 :         constructor_p = false;</span>
<span class="lineNum">   26773 </span><span class="lineCov">     335172 : </span>
<span class="lineNum">   26774 </span>            :       if (constructor_p
<span class="lineNum">   26775 </span>            :           &amp;&amp; cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_CLOSE_PAREN)
<span class="lineNum">   26776 </span>            :           &amp;&amp; cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_ELLIPSIS)
<span class="lineNum">   26777 </span>            :           /* A parameter declaration begins with a decl-specifier,
<span class="lineNum">   26778 </span><span class="lineCov">     335172 :              which is either the &quot;attribute&quot; keyword, a storage class</span>
<span class="lineNum">   26779 </span><span class="lineCov">      13440 :              specifier, or (usually) a type-specifier.  */</span>
<span class="lineNum">   26780 </span><span class="lineCov">     335235 :           &amp;&amp; !cp_lexer_next_token_is_decl_specifier_keyword (parser-&gt;lexer))</span>
<span class="lineNum">   26781 </span>            :         {
<span class="lineNum">   26782 </span>            :           tree type;
<span class="lineNum">   26783 </span><span class="lineCov">     328514 :           tree pushed_scope = NULL_TREE;</span>
<span class="lineNum">   26784 </span>            :           unsigned saved_num_template_parameter_lists;
<span class="lineNum">   26785 </span>            : 
<span class="lineNum">   26786 </span>            :           /* Names appearing in the type-specifier should be looked up
<span class="lineNum">   26787 </span>            :              in the scope of the class.  */
<span class="lineNum">   26788 </span>            :           if (current_class_type)
<span class="lineNum">   26789 </span>            :             type = NULL_TREE;
<span class="lineNum">   26790 </span>            :           else if (type_decl)
<span class="lineNum">   26791 </span><span class="lineCov">    8159706 :             {</span>
<span class="lineNum">   26792 </span><span class="lineCov">    2768311 :               type = TREE_TYPE (type_decl);</span>
<span class="lineNum">   26793 </span><span class="lineCov">    2531313 :               if (TREE_CODE (type) == TYPENAME_TYPE)</span>
<span class="lineNum">   26794 </span><span class="lineCov">    2531313 :                 {</span>
<span class="lineNum">   26795 </span><span class="lineCov">    2531244 :                   type = resolve_typename_type (type,</span>
<span class="lineNum">   26796 </span>            :                                                 /*only_current_p=*/false);
<span class="lineNum">   26797 </span>            :                   if (TREE_CODE (type) == TYPENAME_TYPE)
<span class="lineNum">   26798 </span>            :                     {
<span class="lineNum">   26799 </span>            :                       cp_parser_abort_tentative_parse (parser);
<span class="lineNum">   26800 </span>            :                       return false;
<span class="lineNum">   26801 </span>            :                     }
<span class="lineNum">   26802 </span>            :                 }
<span class="lineNum">   26803 </span>            :               pushed_scope = push_scope (type);
<span class="lineNum">   26804 </span>            :             }
<span class="lineNum">   26805 </span>            : 
<span class="lineNum">   26806 </span>            :           /* Inside the constructor parameter list, surrounding
<span class="lineNum">   26807 </span>            :              template-parameter-lists do not apply.  */
<span class="lineNum">   26808 </span><span class="lineCov">    1619889 :           saved_num_template_parameter_lists</span>
<span class="lineNum">   26809 </span><span class="lineCov">    1619889 :             = parser-&gt;num_template_parameter_lists;</span>
<span class="lineNum">   26810 </span>            :           parser-&gt;num_template_parameter_lists = 0;
<span class="lineNum">   26811 </span>            : 
<span class="lineNum">   26812 </span><span class="lineCov">    3073305 :           /* Look for the type-specifier.  */</span>
<span class="lineNum">   26813 </span><span class="lineCov">     921688 :           cp_parser_type_specifier (parser,</span>
<span class="lineNum">   26814 </span><span class="lineCov">     739973 :                                     CP_PARSER_FLAGS_NONE,</span>
<span class="lineNum">   26815 </span>            :                                     /*decl_specs=*/NULL,
<span class="lineNum">   26816 </span>            :                                     /*is_declarator=*/true,
<span class="lineNum">   26817 </span>            :                                     /*declares_class_or_enum=*/NULL,
<span class="lineNum">   26818 </span><span class="lineCov">    3811926 :                                     /*is_cv_qualifier=*/NULL);</span>
<span class="lineNum">   26819 </span>            : 
<span class="lineNum">   26820 </span><span class="lineCov">     705042 :           parser-&gt;num_template_parameter_lists</span>
<span class="lineNum">   26821 </span><span class="lineCov">     705042 :             = saved_num_template_parameter_lists;</span>
<span class="lineNum">   26822 </span><span class="lineCov">     705042 : </span>
<span class="lineNum">   26823 </span>            :           /* Leave the scope of the class.  */
<span class="lineNum">   26824 </span>            :           if (pushed_scope)
<span class="lineNum">   26825 </span>            :             pop_scope (pushed_scope);
<span class="lineNum">   26826 </span><span class="lineCov">     705042 : </span>
<span class="lineNum">   26827 </span>            :           constructor_p = !cp_parser_error_occurred (parser);
<span class="lineNum">   26828 </span><span class="lineCov">       6626 :         }</span>
<span class="lineNum">   26829 </span>            :     }
<span class="lineNum">   26830 </span><span class="lineCov">         26 : </span>
<span class="lineNum">   26831 </span><span class="lineCov">         26 :   /* We did not really want to consume any tokens.  */</span>
<span class="lineNum">   26832 </span>            :   cp_parser_abort_tentative_parse (parser);
<span class="lineNum">   26833 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   26834 </span>            :   return constructor_p;
<span class="lineNum">   26835 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   26836 </span>            : 
<span class="lineNum">   26837 </span><span class="lineNoCov">          0 : /* Parse the definition of the function given by the DECL_SPECIFIERS,</span>
<span class="lineNum">   26838 </span><span class="lineNoCov">          0 :    ATTRIBUTES, and DECLARATOR.  The access checks have been deferred;</span>
<span class="lineNum">   26839 </span>            :    they must be performed once we are in the scope of the function.
<span class="lineNum">   26840 </span>            : 
<span class="lineNum">   26841 </span><span class="lineCov">         26 :    Returns the function defined.  */</span>
<a name="26842"><span class="lineNum">   26842 </span>            : </a>
<span class="lineNum">   26843 </span>            : static tree
<span class="lineNum">   26844 </span>            : cp_parser_function_definition_from_specifiers_and_declarator
<span class="lineNum">   26845 </span>            :   (cp_parser* parser,
<span class="lineNum">   26846 </span><span class="lineCov">     705042 :    cp_decl_specifier_seq *decl_specifiers,</span>
<span class="lineNum">   26847 </span><span class="lineCov">     705042 :    tree attributes,</span>
<span class="lineNum">   26848 </span><span class="lineCov">     705042 :    const cp_declarator *declarator)</span>
<span class="lineNum">   26849 </span>            : {
<span class="lineNum">   26850 </span>            :   tree fn;
<span class="lineNum">   26851 </span><span class="lineCov">     705042 :   bool success_p;</span>
<span class="lineNum">   26852 </span>            : 
<span class="lineNum">   26853 </span>            :   /* Begin the function-definition.  */
<span class="lineNum">   26854 </span>            :   success_p = start_function (decl_specifiers, declarator, attributes);
<span class="lineNum">   26855 </span>            : 
<span class="lineNum">   26856 </span>            :   /* The things we're about to see are not directly qualified by any
<span class="lineNum">   26857 </span>            :      template headers we've seen thus far.  */
<span class="lineNum">   26858 </span><span class="lineCov">     705042 :   reset_specialization ();</span>
<span class="lineNum">   26859 </span><span class="lineCov">     705042 : </span>
<span class="lineNum">   26860 </span>            :   /* If there were names looked up in the decl-specifier-seq that we
<span class="lineNum">   26861 </span>            :      did not check, check them now.  We must wait until we are in the
<span class="lineNum">   26862 </span><span class="lineCov">     705042 :      scope of the function to perform the checks, since the function</span>
<span class="lineNum">   26863 </span><span class="lineCov">         26 :      might be a friend.  */</span>
<span class="lineNum">   26864 </span>            :   perform_deferred_access_checks (tf_warning_or_error);
<span class="lineNum">   26865 </span><span class="lineCov">     705042 : </span>
<span class="lineNum">   26866 </span>            :   if (success_p)
<span class="lineNum">   26867 </span>            :     {
<span class="lineNum">   26868 </span>            :       cp_finalize_omp_declare_simd (parser, current_function_decl);
<span class="lineNum">   26869 </span>            :       parser-&gt;omp_declare_simd = NULL;
<span class="lineNum">   26870 </span><span class="lineCov">    5766130 :       cp_finalize_oacc_routine (parser, current_function_decl, true);</span>
<span class="lineNum">   26871 </span>            :       parser-&gt;oacc_routine = NULL;
<span class="lineNum">   26872 </span><span class="lineCov">    5766130 :     }</span>
<span class="lineNum">   26873 </span>            : 
<span class="lineNum">   26874 </span>            :   if (!success_p)
<span class="lineNum">   26875 </span>            :     {
<span class="lineNum">   26876 </span>            :       /* Skip the entire function.  */
<span class="lineNum">   26877 </span>            :       cp_parser_skip_to_end_of_block_or_statement (parser);
<span class="lineNum">   26878 </span>            :       fn = error_mark_node;
<span class="lineNum">   26879 </span>            :     }
<span class="lineNum">   26880 </span>            :   else if (DECL_INITIAL (current_function_decl) != error_mark_node)
<span class="lineNum">   26881 </span>            :     {
<span class="lineNum">   26882 </span><span class="lineCov">    2608316 :       /* Seen already, skip it.  An error message has already been output.  */</span>
<span class="lineNum">   26883 </span>            :       cp_parser_skip_to_end_of_block_or_statement (parser);
<span class="lineNum">   26884 </span>            :       fn = current_function_decl;
<span class="lineNum">   26885 </span>            :       current_function_decl = NULL_TREE;
<span class="lineNum">   26886 </span>            :       /* If this is a function from a class, pop the nested class.  */
<span class="lineNum">   26887 </span>            :       if (current_class_name)
<span class="lineNum">   26888 </span><span class="lineCov">    2608316 :         pop_nested_class ();</span>
<span class="lineNum">   26889 </span><span class="lineCov">    2608316 :     }</span>
<span class="lineNum">   26890 </span>            :   else
<span class="lineNum">   26891 </span>            :     {
<span class="lineNum">   26892 </span><span class="lineCov">    2608316 :       timevar_id_t tv;</span>
<span class="lineNum">   26893 </span>            :       if (DECL_DECLARED_INLINE_P (current_function_decl))
<span class="lineNum">   26894 </span>            :         tv = TV_PARSE_INLINE;
<span class="lineNum">   26895 </span>            :       else
<span class="lineNum">   26896 </span><span class="lineCov">    2608316 :         tv = TV_PARSE_FUNC;</span>
<span class="lineNum">   26897 </span>            :       timevar_push (tv);
<span class="lineNum">   26898 </span>            :       fn = cp_parser_function_definition_after_declarator (parser,
<span class="lineNum">   26899 </span>            :                                                          /*inline_p=*/false);
<span class="lineNum">   26900 </span>            :       timevar_pop (tv);
<span class="lineNum">   26901 </span>            :     }
<span class="lineNum">   26902 </span><span class="lineCov">    2608316 : </span>
<span class="lineNum">   26903 </span>            :   return fn;
<span class="lineNum">   26904 </span><span class="lineCov">    2608316 : }</span>
<span class="lineNum">   26905 </span>            : 
<span class="lineNum">   26906 </span><span class="lineCov">    2608109 : /* Parse the part of a function-definition that follows the</span>
<span class="lineNum">   26907 </span><span class="lineCov">    2608109 :    declarator.  INLINE_P is TRUE iff this function is an inline</span>
<span class="lineNum">   26908 </span><span class="lineCov">    2608109 :    function defined within a class-specifier.</span>
<span class="lineNum">   26909 </span><span class="lineCov">    2608109 : </span>
<span class="lineNum">   26910 </span>            :    Returns the function defined.  */
<a name="26911"><span class="lineNum">   26911 </span>            : </a>
<span class="lineNum">   26912 </span><span class="lineCov">    2608316 : static tree</span>
<span class="lineNum">   26913 </span>            : cp_parser_function_definition_after_declarator (cp_parser* parser,
<span class="lineNum">   26914 </span>            :                                                 bool inline_p)
<span class="lineNum">   26915 </span><span class="lineCov">        207 : {</span>
<span class="lineNum">   26916 </span><span class="lineCov">        207 :   tree fn;</span>
<span class="lineNum">   26917 </span>            :   bool saved_in_unbraced_linkage_specification_p;
<span class="lineNum">   26918 </span><span class="lineCov">    2608109 :   bool saved_in_function_body;</span>
<span class="lineNum">   26919 </span>            :   unsigned saved_num_template_parameter_lists;
<span class="lineNum">   26920 </span>            :   cp_token *token;
<span class="lineNum">   26921 </span><span class="lineNoCov">          0 :   bool fully_implicit_function_template_p</span>
<span class="lineNum">   26922 </span><span class="lineNoCov">          0 :     = parser-&gt;fully_implicit_function_template_p;</span>
<span class="lineNum">   26923 </span><span class="lineNoCov">          0 :   parser-&gt;fully_implicit_function_template_p = false;</span>
<span class="lineNum">   26924 </span>            :   tree implicit_template_parms
<span class="lineNum">   26925 </span><span class="lineNoCov">          0 :     = parser-&gt;implicit_template_parms;</span>
<span class="lineNum">   26926 </span><span class="lineNoCov">          0 :   parser-&gt;implicit_template_parms = 0;</span>
<span class="lineNum">   26927 </span>            :   cp_binding_level* implicit_template_scope
<span class="lineNum">   26928 </span>            :     = parser-&gt;implicit_template_scope;
<span class="lineNum">   26929 </span>            :   parser-&gt;implicit_template_scope = 0;
<span class="lineNum">   26930 </span><span class="lineCov">    2608109 : </span>
<span class="lineNum">   26931 </span><span class="lineCov">    2608109 :   saved_in_function_body = parser-&gt;in_function_body;</span>
<span class="lineNum">   26932 </span>            :   parser-&gt;in_function_body = true;
<span class="lineNum">   26933 </span>            :   /* If the next token is `return', then the code may be trying to
<span class="lineNum">   26934 </span><span class="lineCov">     547345 :      make use of the &quot;named return value&quot; extension that G++ used to</span>
<span class="lineNum">   26935 </span><span class="lineCov">    2608109 :      support.  */</span>
<span class="lineNum">   26936 </span><span class="lineCov">    2608109 :   token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   26937 </span>            :   if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_RETURN))
<span class="lineNum">   26938 </span><span class="lineCov">    2608090 :     {</span>
<span class="lineNum">   26939 </span>            :       /* Consume the `return' keyword.  */
<span class="lineNum">   26940 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   26941 </span><span class="lineCov">    2608297 :       /* Look for the identifier that indicates what value is to be</span>
<span class="lineNum">   26942 </span>            :          returned.  */
<span class="lineNum">   26943 </span>            :       cp_parser_identifier (parser);
<span class="lineNum">   26944 </span>            :       /* Issue an error message.  */
<span class="lineNum">   26945 </span>            :       error_at (token-&gt;location,
<span class="lineNum">   26946 </span>            :                 &quot;named return values are no longer supported&quot;);
<span class="lineNum">   26947 </span>            :       /* Skip tokens until we reach the start of the function body.  */
<span class="lineNum">   26948 </span>            :       while (true)
<span class="lineNum">   26949 </span>            :         {
<span class="lineNum">   26950 </span>            :           cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   26951 </span><span class="lineCov">    5666355 :           if (token-&gt;type == CPP_OPEN_BRACE</span>
<span class="lineNum">   26952 </span>            :               || token-&gt;type == CPP_EOF
<span class="lineNum">   26953 </span>            :               || token-&gt;type == CPP_PRAGMA_EOL)
<span class="lineNum">   26954 </span><span class="lineCov">    5666355 :             break;</span>
<span class="lineNum">   26955 </span><span class="lineCov">    5666355 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   26956 </span><span class="lineCov">    5666355 :         }</span>
<span class="lineNum">   26957 </span><span class="lineCov">    5666355 :     }</span>
<span class="lineNum">   26958 </span><span class="lineCov">    5666355 :   /* The `extern' in `extern &quot;C&quot; void f () { ... }' does not apply to</span>
<span class="lineNum">   26959 </span><span class="lineCov">    5666355 :      anything declared inside `f'.  */</span>
<span class="lineNum">   26960 </span>            :   saved_in_unbraced_linkage_specification_p
<span class="lineNum">   26961 </span><span class="lineCov">    5666355 :     = parser-&gt;in_unbraced_linkage_specification_p;</span>
<span class="lineNum">   26962 </span><span class="lineCov">    5666355 :   parser-&gt;in_unbraced_linkage_specification_p = false;</span>
<span class="lineNum">   26963 </span>            :   /* Inside the function, surrounding template-parameter-lists do not
<span class="lineNum">   26964 </span><span class="lineCov">    5666355 :      apply.  */</span>
<span class="lineNum">   26965 </span><span class="lineCov">    5666355 :   saved_num_template_parameter_lists</span>
<span class="lineNum">   26966 </span>            :     = parser-&gt;num_template_parameter_lists;
<span class="lineNum">   26967 </span><span class="lineCov">    5666355 :   parser-&gt;num_template_parameter_lists = 0;</span>
<span class="lineNum">   26968 </span>            : 
<span class="lineNum">   26969 </span><span class="lineCov">    5666355 :   /* If the next token is `try', `__transaction_atomic', or</span>
<span class="lineNum">   26970 </span><span class="lineCov">    5666355 :      `__transaction_relaxed`, then we are looking at either function-try-block</span>
<span class="lineNum">   26971 </span>            :      or function-transaction-block.  Note that all of these include the
<span class="lineNum">   26972 </span>            :      function-body.  */
<span class="lineNum">   26973 </span>            :   if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_TRANSACTION_ATOMIC))
<span class="lineNum">   26974 </span><span class="lineCov">   11332710 :     cp_parser_function_transaction (parser, RID_TRANSACTION_ATOMIC);</span>
<span class="lineNum">   26975 </span><span class="lineCov">    5666355 :   else if (cp_lexer_next_token_is_keyword (parser-&gt;lexer,</span>
<span class="lineNum">   26976 </span>            :       RID_TRANSACTION_RELAXED))
<span class="lineNum">   26977 </span>            :     cp_parser_function_transaction (parser, RID_TRANSACTION_RELAXED);
<span class="lineNum">   26978 </span><span class="lineCov">        216 :   else if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_TRY))</span>
<span class="lineNum">   26979 </span>            :     cp_parser_function_try_block (parser);
<span class="lineNum">   26980 </span>            :   else
<span class="lineNum">   26981 </span><span class="lineCov">        216 :     cp_parser_ctor_initializer_opt_and_function_body</span>
<span class="lineNum">   26982 </span>            :       (parser, /*in_function_try_block=*/false);
<span class="lineNum">   26983 </span><span class="lineCov">        216 : </span>
<span class="lineNum">   26984 </span>            :   /* Finish the function.  */
<span class="lineNum">   26985 </span>            :   fn = finish_function (inline_p);
<span class="lineNum">   26986 </span><span class="lineCov">        825 :   /* Generate code for it, if necessary.  */</span>
<span class="lineNum">   26987 </span>            :   expand_or_defer_fn (fn);
<span class="lineNum">   26988 </span><span class="lineCov">       1650 :   /* Restore the saved values.  */</span>
<span class="lineNum">   26989 </span><span class="lineCov">       1650 :   parser-&gt;in_unbraced_linkage_specification_p</span>
<span class="lineNum">   26990 </span><span class="lineCov">        825 :     = saved_in_unbraced_linkage_specification_p;</span>
<span class="lineNum">   26991 </span><span class="lineCov">        609 :   parser-&gt;num_template_parameter_lists</span>
<span class="lineNum">   26992 </span>            :     = saved_num_template_parameter_lists;
<span class="lineNum">   26993 </span><span class="lineCov">        609 :   parser-&gt;in_function_body = saved_in_function_body;</span>
<span class="lineNum">   26994 </span><span class="lineCov">        609 : </span>
<span class="lineNum">   26995 </span>            :   parser-&gt;fully_implicit_function_template_p
<span class="lineNum">   26996 </span>            :     = fully_implicit_function_template_p;
<span class="lineNum">   26997 </span>            :   parser-&gt;implicit_template_parms
<span class="lineNum">   26998 </span><span class="lineCov">    5666355 :     = implicit_template_parms;</span>
<span class="lineNum">   26999 </span><span class="lineCov">    5666355 :   parser-&gt;implicit_template_scope</span>
<span class="lineNum">   27000 </span><span class="lineCov">    5666355 :     = implicit_template_scope;</span>
<span class="lineNum">   27001 </span>            : 
<span class="lineNum">   27002 </span>            :   if (parser-&gt;fully_implicit_function_template_p)
<span class="lineNum">   27003 </span><span class="lineCov">    5666355 :     finish_fully_implicit_template (parser, /*member_decl_opt=*/0);</span>
<span class="lineNum">   27004 </span><span class="lineCov">    5666355 : </span>
<span class="lineNum">   27005 </span><span class="lineCov">    5666355 :   return fn;</span>
<span class="lineNum">   27006 </span>            : }
<span class="lineNum">   27007 </span>            : 
<span class="lineNum">   27008 </span>            : /* Parse a template-declaration body (following argument list).  */
<a name="27009"><span class="lineNum">   27009 </span>            : </a>
<span class="lineNum">   27010 </span>            : static void
<span class="lineNum">   27011 </span><span class="lineCov">    5666355 : cp_parser_template_declaration_after_parameters (cp_parser* parser,</span>
<span class="lineNum">   27012 </span><span class="lineCov">         17 :                                                  tree parameter_list,</span>
<span class="lineNum">   27013 </span><span class="lineCov">    5666338 :                                                  bool member_p)</span>
<span class="lineNum">   27014 </span>            : {
<span class="lineNum">   27015 </span><span class="lineNoCov">          0 :   tree decl = NULL_TREE;</span>
<span class="lineNum">   27016 </span><span class="lineCov">    5666338 :   bool friend_p = false;</span>
<span class="lineNum">   27017 </span><span class="lineCov">         91 : </span>
<span class="lineNum">   27018 </span>            :   /* We just processed one more parameter list.  */
<span class="lineNum">   27019 </span><span class="lineCov">    5666247 :   ++parser-&gt;num_template_parameter_lists;</span>
<span class="lineNum">   27020 </span><span class="lineCov">    5666247 : </span>
<span class="lineNum">   27021 </span>            :   /* Get the deferred access checks from the parameter list.  These
<span class="lineNum">   27022 </span>            :      will be checked once we know what is being declared, as for a
<span class="lineNum">   27023 </span><span class="lineCov">    5666336 :      member template the checks must be performed in the scope of the</span>
<span class="lineNum">   27024 </span>            :      class containing the member.  */
<span class="lineNum">   27025 </span><span class="lineCov">    5666336 :   vec&lt;deferred_access_check, va_gc&gt; *checks = get_deferred_access_checks ();</span>
<span class="lineNum">   27026 </span>            : 
<span class="lineNum">   27027 </span><span class="lineCov">    5666336 :   /* Tentatively parse for a new template parameter list, which can either be</span>
<span class="lineNum">   27028 </span><span class="lineCov">    5666336 :      the template keyword or a template introduction.  */</span>
<span class="lineNum">   27029 </span><span class="lineCov">    5666336 :   if (cp_parser_template_declaration_after_export (parser, member_p))</span>
<span class="lineNum">   27030 </span><span class="lineCov">    5666336 :     /* OK */;</span>
<span class="lineNum">   27031 </span><span class="lineCov">    5666336 :   else if (cxx_dialect &gt;= cxx11</span>
<span class="lineNum">   27032 </span>            :            &amp;&amp; cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_USING))
<span class="lineNum">   27033 </span><span class="lineCov">    5666336 :     decl = cp_parser_alias_declaration (parser);</span>
<span class="lineNum">   27034 </span><span class="lineCov">    5666336 :   else</span>
<span class="lineNum">   27035 </span><span class="lineCov">    5666336 :     {</span>
<span class="lineNum">   27036 </span><span class="lineCov">    5666336 :       /* There are no access checks when parsing a template, as we do not</span>
<span class="lineNum">   27037 </span><span class="lineCov">    5666336 :          know if a specialization will be a friend.  */</span>
<span class="lineNum">   27038 </span><span class="lineCov">    5666336 :       push_deferring_access_checks (dk_no_check);</span>
<span class="lineNum">   27039 </span>            :       cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   27040 </span><span class="lineCov">    5666336 :       decl = cp_parser_single_declaration (parser,</span>
<span class="lineNum">   27041 </span><span class="lineCov">         53 :                                            checks,</span>
<span class="lineNum">   27042 </span>            :                                            member_p,
<span class="lineNum">   27043 </span><span class="lineCov">    5666336 :                                            /*explicit_specialization_p=*/false,</span>
<span class="lineNum">   27044 </span>            :                                            &amp;friend_p);
<span class="lineNum">   27045 </span>            :       pop_deferring_access_checks ();
<span class="lineNum">   27046 </span>            : 
<span class="lineNum">   27047 </span>            :       /* If this is a member template declaration, let the front
<span class="lineNum">   27048 </span>            :          end know.  */
<span class="lineNum">   27049 </span><span class="lineCov">    4194606 :       if (member_p &amp;&amp; !friend_p &amp;&amp; decl)</span>
<span class="lineNum">   27050 </span>            :         {
<span class="lineNum">   27051 </span>            :           if (TREE_CODE (decl) == TYPE_DECL)
<span class="lineNum">   27052 </span>            :             cp_parser_check_access_in_redeclaration (decl, token-&gt;location);
<span class="lineNum">   27053 </span><span class="lineCov">    4194606 : </span>
<span class="lineNum">   27054 </span><span class="lineCov">    4194606 :           decl = finish_member_template_decl (decl);</span>
<span class="lineNum">   27055 </span>            :         }
<span class="lineNum">   27056 </span>            :       else if (friend_p &amp;&amp; decl
<span class="lineNum">   27057 </span><span class="lineCov">    4194606 :                &amp;&amp; DECL_DECLARES_TYPE_P (decl))</span>
<span class="lineNum">   27058 </span>            :         make_friend_class (current_class_type, TREE_TYPE (decl),
<span class="lineNum">   27059 </span>            :                            /*complain=*/true);
<span class="lineNum">   27060 </span>            :     }
<span class="lineNum">   27061 </span>            :   /* We are done with the current parameter list.  */
<span class="lineNum">   27062 </span>            :   --parser-&gt;num_template_parameter_lists;
<span class="lineNum">   27063 </span><span class="lineCov">    4194606 : </span>
<span class="lineNum">   27064 </span>            :   pop_deferring_access_checks ();
<span class="lineNum">   27065 </span>            : 
<span class="lineNum">   27066 </span>            :   /* Finish up.  */
<span class="lineNum">   27067 </span><span class="lineCov">    4194606 :   finish_template_decl (parameter_list);</span>
<span class="lineNum">   27068 </span>            : 
<span class="lineNum">   27069 </span><span class="lineCov">    4150175 :   /* Check the template arguments for a literal operator template.  */</span>
<span class="lineNum">   27070 </span><span class="lineCov">    4150175 :   if (decl</span>
<span class="lineNum">   27071 </span><span class="lineCov">     162288 :       &amp;&amp; DECL_DECLARES_FUNCTION_P (decl)</span>
<span class="lineNum">   27072 </span>            :       &amp;&amp; UDLIT_OPER_P (DECL_NAME (decl)))
<span class="lineNum">   27073 </span>            :     {
<span class="lineNum">   27074 </span>            :       bool ok = true;
<span class="lineNum">   27075 </span>            :       if (parameter_list == NULL_TREE)
<span class="lineNum">   27076 </span><span class="lineCov">    3987887 :         ok = false;</span>
<span class="lineNum">   27077 </span><span class="lineCov">    7975774 :       else</span>
<span class="lineNum">   27078 </span><span class="lineCov">    3987887 :         {</span>
<span class="lineNum">   27079 </span>            :           int num_parms = TREE_VEC_LENGTH (parameter_list);
<span class="lineNum">   27080 </span>            :           if (num_parms == 1)
<span class="lineNum">   27081 </span>            :             {
<span class="lineNum">   27082 </span>            :               tree parm_list = TREE_VEC_ELT (parameter_list, 0);
<span class="lineNum">   27083 </span><span class="lineCov">    3987883 :               tree parm = INNERMOST_TEMPLATE_PARMS (parm_list);</span>
<span class="lineNum">   27084 </span>            :               if (TREE_TYPE (parm) != char_type_node
<span class="lineNum">   27085 </span>            :                   || !TEMPLATE_PARM_PARAMETER_PACK (DECL_INITIAL (parm)))
<span class="lineNum">   27086 </span>            :                 ok = false;
<span class="lineNum">   27087 </span><span class="lineCov">    3987883 :             }</span>
<span class="lineNum">   27088 </span>            :           else if (num_parms == 2 &amp;&amp; cxx_dialect &gt;= cxx14)
<span class="lineNum">   27089 </span><span class="lineCov">     772542 :             {</span>
<span class="lineNum">   27090 </span><span class="lineCov">      79893 :               tree parm_type = TREE_VEC_ELT (parameter_list, 0);</span>
<span class="lineNum">   27091 </span>            :               tree type = INNERMOST_TEMPLATE_PARMS (parm_type);
<span class="lineNum">   27092 </span><span class="lineCov">     772542 :               tree parm_list = TREE_VEC_ELT (parameter_list, 1);</span>
<span class="lineNum">   27093 </span>            :               tree parm = INNERMOST_TEMPLATE_PARMS (parm_list);
<span class="lineNum">   27094 </span><span class="lineCov">      47503 :               if (parm == error_mark_node</span>
<span class="lineNum">   27095 </span><span class="lineCov">    3262844 :                   || TREE_TYPE (parm) != TREE_TYPE (type)</span>
<span class="lineNum">   27096 </span><span class="lineCov">      13653 :                   || !TEMPLATE_PARM_PARAMETER_PACK (DECL_INITIAL (parm)))</span>
<span class="lineNum">   27097 </span>            :                 ok = false;
<span class="lineNum">   27098 </span>            :             }
<span class="lineNum">   27099 </span>            :           else
<span class="lineNum">   27100 </span><span class="lineCov">    4194602 :             ok = false;</span>
<span class="lineNum">   27101 </span>            :         }
<span class="lineNum">   27102 </span><span class="lineCov">    4194602 :       if (!ok)</span>
<span class="lineNum">   27103 </span>            :         {
<span class="lineNum">   27104 </span>            :           if (cxx_dialect &gt;= cxx14)
<span class="lineNum">   27105 </span><span class="lineCov">    4194602 :             error (&quot;literal operator template %qD has invalid parameter list.&quot;</span>
<span class="lineNum">   27106 </span>            :                    &quot;  Expected non-type template argument pack &lt;char...&gt;&quot;
<span class="lineNum">   27107 </span>            :                    &quot; or &lt;typename CharT, CharT...&gt;&quot;,
<span class="lineNum">   27108 </span><span class="lineCov">    4194602 :                    decl);</span>
<span class="lineNum">   27109 </span><span class="lineCov">    4118971 :           else</span>
<span class="lineNum">   27110 </span><span class="lineCov">    6307321 :             error (&quot;literal operator template %qD has invalid parameter list.&quot;</span>
<span class="lineNum">   27111 </span>            :                    &quot;  Expected non-type template argument pack &lt;char...&gt;&quot;,
<span class="lineNum">   27112 </span><span class="lineCov">       2625 :                    decl);</span>
<span class="lineNum">   27113 </span><span class="lineCov">       2625 :         }</span>
<span class="lineNum">   27114 </span>            :     }
<span class="lineNum">   27115 </span>            : 
<span class="lineNum">   27116 </span>            :   /* Register member declarations.  */
<span class="lineNum">   27117 </span><span class="lineCov">       2625 :   if (member_p &amp;&amp; !friend_p &amp;&amp; decl &amp;&amp; !DECL_CLASS_TEMPLATE_P (decl))</span>
<span class="lineNum">   27118 </span><span class="lineCov">       2625 :     finish_member_declaration (decl);</span>
<span class="lineNum">   27119 </span>            :   /* If DECL is a function template, we must return to parse it later.
<span class="lineNum">   27120 </span><span class="lineCov">       2612 :      (Even though there is no definition, there might be default</span>
<span class="lineNum">   27121 </span><span class="lineCov">       2612 :      arguments that need handling.)  */</span>
<span class="lineNum">   27122 </span><span class="lineCov">       2612 :   if (member_p &amp;&amp; decl</span>
<span class="lineNum">   27123 </span><span class="lineCov">       2612 :       &amp;&amp; DECL_DECLARES_FUNCTION_P (decl))</span>
<span class="lineNum">   27124 </span>            :     vec_safe_push (unparsed_funs_with_definitions, decl);
<span class="lineNum">   27125 </span>            : }
<span class="lineNum">   27126 </span><span class="lineCov">         13 : </span>
<span class="lineNum">   27127 </span>            : /* Parse a template introduction header for a template-declaration.  Returns
<span class="lineNum">   27128 </span><span class="lineCov">         11 :    false if tentative parse fails.  */</span>
<a name="27129"><span class="lineNum">   27129 </span><span class="lineCov">         11 : </span></a>
<span class="lineNum">   27130 </span><span class="lineCov">         11 : static bool</span>
<span class="lineNum">   27131 </span><span class="lineCov">         11 : cp_parser_template_introduction (cp_parser* parser, bool member_p)</span>
<span class="lineNum">   27132 </span><span class="lineCov">         11 : {</span>
<span class="lineNum">   27133 </span><span class="lineCov">         10 :   cp_parser_parse_tentatively (parser);</span>
<span class="lineNum">   27134 </span><span class="lineCov">         21 : </span>
<span class="lineNum">   27135 </span>            :   tree saved_scope = parser-&gt;scope;
<span class="lineNum">   27136 </span>            :   tree saved_object_scope = parser-&gt;object_scope;
<span class="lineNum">   27137 </span>            :   tree saved_qualifying_scope = parser-&gt;qualifying_scope;
<span class="lineNum">   27138 </span>            : 
<span class="lineNum">   27139 </span>            :   /* Look for the optional `::' operator.  */
<span class="lineNum">   27140 </span>            :   cp_parser_global_scope_opt (parser,
<span class="lineNum">   27141 </span>            :                               /*current_scope_valid_p=*/false);
<span class="lineNum">   27142 </span><span class="lineCov">         11 :   /* Look for the nested-name-specifier.  */</span>
<span class="lineNum">   27143 </span><span class="lineCov">          5 :   cp_parser_nested_name_specifier_opt (parser,</span>
<span class="lineNum">   27144 </span>            :                                        /*typename_keyword_p=*/false,
<span class="lineNum">   27145 </span>            :                                        /*check_dependency_p=*/true,
<span class="lineNum">   27146 </span>            :                                        /*type_p=*/false,
<span class="lineNum">   27147 </span>            :                                        /*is_declaration=*/false);
<span class="lineNum">   27148 </span><span class="lineCov">          6 : </span>
<span class="lineNum">   27149 </span>            :   cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   27150 </span>            :   tree concept_name = cp_parser_identifier (parser);
<span class="lineNum">   27151 </span>            : 
<span class="lineNum">   27152 </span>            :   /* Look up the concept for which we will be matching
<span class="lineNum">   27153 </span>            :      template parameters.  */
<span class="lineNum">   27154 </span>            :   tree tmpl_decl = cp_parser_lookup_name_simple (parser, concept_name,
<span class="lineNum">   27155 </span><span class="lineCov">    4194602 :                                                  token-&gt;location);</span>
<span class="lineNum">   27156 </span><span class="lineCov">     751795 :   parser-&gt;scope = saved_scope;</span>
<span class="lineNum">   27157 </span>            :   parser-&gt;object_scope = saved_object_scope;
<span class="lineNum">   27158 </span>            :   parser-&gt;qualifying_scope = saved_qualifying_scope;
<span class="lineNum">   27159 </span>            : 
<span class="lineNum">   27160 </span><span class="lineCov">     879253 :   if (concept_name == error_mark_node)</span>
<span class="lineNum">   27161 </span><span class="lineCov">    5042593 :     cp_parser_simulate_error (parser);</span>
<span class="lineNum">   27162 </span><span class="lineCov">     726090 : </span>
<span class="lineNum">   27163 </span><span class="lineCov">    4194602 :   /* Look for opening brace for introduction.  */</span>
<span class="lineNum">   27164 </span>            :   matching_braces braces;
<span class="lineNum">   27165 </span>            :   braces.require_open (parser);
<span class="lineNum">   27166 </span>            : 
<span class="lineNum">   27167 </span>            :   if (!cp_parser_parse_definitely (parser))
<span class="lineNum">   27168 </span>            :     return false;
<span class="lineNum">   27169 </span><span class="lineCov">      18398 : </span>
<span class="lineNum">   27170 </span>            :   push_deferring_access_checks (dk_deferred);
<span class="lineNum">   27171 </span><span class="lineCov">      18398 : </span>
<span class="lineNum">   27172 </span>            :   /* Build vector of placeholder parameters and grab
<span class="lineNum">   27173 </span><span class="lineCov">      18398 :      matching identifiers.  */</span>
<span class="lineNum">   27174 </span><span class="lineCov">      18398 :   tree introduction_list = cp_parser_introduction_list (parser);</span>
<span class="lineNum">   27175 </span><span class="lineCov">      18398 : </span>
<span class="lineNum">   27176 </span>            :   /* Look for closing brace for introduction.  */
<span class="lineNum">   27177 </span>            :   if (!braces.require_close (parser))
<span class="lineNum">   27178 </span><span class="lineCov">      18398 :     return true;</span>
<span class="lineNum">   27179 </span>            : 
<span class="lineNum">   27180 </span>            :   /* The introduction-list shall not be empty.  */
<span class="lineNum">   27181 </span><span class="lineCov">      18398 :   int nargs = TREE_VEC_LENGTH (introduction_list);</span>
<span class="lineNum">   27182 </span>            :   if (nargs == 0)
<span class="lineNum">   27183 </span>            :     {
<span class="lineNum">   27184 </span>            :       /* In cp_parser_introduction_list we have already issued an error.  */
<span class="lineNum">   27185 </span>            :       return true;
<span class="lineNum">   27186 </span>            :     }
<span class="lineNum">   27187 </span><span class="lineCov">      36796 : </span>
<span class="lineNum">   27188 </span><span class="lineCov">      18398 :   if (tmpl_decl == error_mark_node)</span>
<span class="lineNum">   27189 </span>            :     {
<span class="lineNum">   27190 </span>            :       cp_parser_name_lookup_error (parser, concept_name, tmpl_decl, NLE_NULL,
<span class="lineNum">   27191 </span>            :                                    token-&gt;location);
<span class="lineNum">   27192 </span><span class="lineCov">      18398 :       return true;</span>
<span class="lineNum">   27193 </span>            :     }
<span class="lineNum">   27194 </span><span class="lineCov">      18398 : </span>
<span class="lineNum">   27195 </span><span class="lineCov">      18398 :   /* Build and associate the constraint.  */</span>
<span class="lineNum">   27196 </span><span class="lineCov">      18398 :   tree parms = finish_template_introduction (tmpl_decl, introduction_list);</span>
<span class="lineNum">   27197 </span>            :   if (parms &amp;&amp; parms != error_mark_node)
<span class="lineNum">   27198 </span><span class="lineCov">      18398 :     {</span>
<span class="lineNum">   27199 </span><span class="lineCov">      16779 :       cp_parser_template_declaration_after_parameters (parser, parms,</span>
<span class="lineNum">   27200 </span>            :                                                        member_p);
<span class="lineNum">   27201 </span>            :       return true;
<span class="lineNum">   27202 </span><span class="lineCov">      36796 :     }</span>
<span class="lineNum">   27203 </span><span class="lineCov">      18398 : </span>
<span class="lineNum">   27204 </span>            :   error_at (token-&gt;location, &quot;no matching concept for template-introduction&quot;);
<span class="lineNum">   27205 </span><span class="lineCov">      18398 :   return true;</span>
<span class="lineNum">   27206 </span>            : }
<span class="lineNum">   27207 </span>            : 
<span class="lineNum">   27208 </span><span class="lineCov">         25 : /* Parse a normal template-declaration following the template keyword.  */</span>
<a name="27209"><span class="lineNum">   27209 </span>            : </a>
<span class="lineNum">   27210 </span>            : static void
<span class="lineNum">   27211 </span>            : cp_parser_explicit_template_declaration (cp_parser* parser, bool member_p)
<span class="lineNum">   27212 </span><span class="lineCov">         25 : {</span>
<span class="lineNum">   27213 </span>            :   tree parameter_list;
<span class="lineNum">   27214 </span>            :   bool need_lang_pop;
<span class="lineNum">   27215 </span><span class="lineCov">         25 :   location_t location = input_location;</span>
<span class="lineNum">   27216 </span>            : 
<span class="lineNum">   27217 </span>            :   /* Look for the `&lt;' token.  */
<span class="lineNum">   27218 </span>            :   if (!cp_parser_require (parser, CPP_LESS, RT_LESS))
<span class="lineNum">   27219 </span><span class="lineCov">         25 :     return;</span>
<span class="lineNum">   27220 </span><span class="lineCov">         25 :   if (at_class_scope_p () &amp;&amp; current_function_decl)</span>
<span class="lineNum">   27221 </span>            :     {
<span class="lineNum">   27222 </span>            :       /* 14.5.2.2 [temp.mem]
<span class="lineNum">   27223 </span>            : 
<span class="lineNum">   27224 </span>            :          A local class shall not have member templates.  */
<span class="lineNum">   27225 </span>            :       error_at (location,
<span class="lineNum">   27226 </span><span class="lineCov">         24 :                 &quot;invalid declaration of member template in local class&quot;);</span>
<span class="lineNum">   27227 </span>            :       cp_parser_skip_to_end_of_block_or_statement (parser);
<span class="lineNum">   27228 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">   27229 </span>            :     }
<span class="lineNum">   27230 </span><span class="lineNoCov">          0 :   /* [temp]</span>
<span class="lineNum">   27231 </span>            : 
<span class="lineNum">   27232 </span>            :      A template ... shall not have C linkage.  */
<span class="lineNum">   27233 </span>            :   if (current_lang_name == lang_name_c)
<span class="lineNum">   27234 </span><span class="lineCov">         24 :     {</span>
<span class="lineNum">   27235 </span><span class="lineCov">         24 :       error_at (location, &quot;template with C linkage&quot;);</span>
<span class="lineNum">   27236 </span>            :       maybe_show_extern_c_location ();
<span class="lineNum">   27237 </span><span class="lineCov">         19 :       /* Give it C++ linkage to avoid confusing other parts of the</span>
<span class="lineNum">   27238 </span>            :          front end.  */
<span class="lineNum">   27239 </span><span class="lineCov">         19 :       push_lang_context (lang_name_cplusplus);</span>
<span class="lineNum">   27240 </span>            :       need_lang_pop = true;
<span class="lineNum">   27241 </span>            :     }
<span class="lineNum">   27242 </span><span class="lineCov">          5 :   else</span>
<span class="lineNum">   27243 </span><span class="lineCov">          5 :     need_lang_pop = false;</span>
<span class="lineNum">   27244 </span>            : 
<span class="lineNum">   27245 </span>            :   /* We cannot perform access checks on the template parameter
<span class="lineNum">   27246 </span>            :      declarations until we know what is being declared, just as we
<span class="lineNum">   27247 </span>            :      cannot check the decl-specifier list.  */
<span class="lineNum">   27248 </span>            :   push_deferring_access_checks (dk_deferred);
<span class="lineNum">   27249 </span><span class="lineCov">    4194593 : </span>
<span class="lineNum">   27250 </span>            :   /* If the next token is `&gt;', then we have an invalid
<span class="lineNum">   27251 </span><span class="lineCov">    4194593 :      specialization.  Rather than complain about an invalid template</span>
<span class="lineNum">   27252 </span><span class="lineCov">    4194593 :      parameter, issue an error message here.  */</span>
<span class="lineNum">   27253 </span><span class="lineCov">    4194593 :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_GREATER))</span>
<span class="lineNum">   27254 </span>            :     {
<span class="lineNum">   27255 </span>            :       cp_parser_error (parser, &quot;invalid explicit specialization&quot;);
<span class="lineNum">   27256 </span><span class="lineCov">    4194593 :       begin_specialization ();</span>
<span class="lineNum">   27257 </span>            :       parameter_list = NULL_TREE;
<span class="lineNum">   27258 </span><span class="lineCov">    4194590 :     }</span>
<span class="lineNum">   27259 </span>            :   else
<span class="lineNum">   27260 </span>            :     {
<span class="lineNum">   27261 </span>            :       /* Parse the template parameters.  */
<span class="lineNum">   27262 </span>            :       parameter_list = cp_parser_template_parameter_list (parser);
<span class="lineNum">   27263 </span><span class="lineCov">          3 :     }</span>
<span class="lineNum">   27264 </span>            : 
<span class="lineNum">   27265 </span><span class="lineCov">          3 :   /* Look for the `&gt;'.  */</span>
<span class="lineNum">   27266 </span><span class="lineCov">          3 :   cp_parser_skip_to_end_of_template_parameter_list (parser);</span>
<span class="lineNum">   27267 </span>            : 
<span class="lineNum">   27268 </span>            :   /* Manage template requirements */
<span class="lineNum">   27269 </span>            :   if (flag_concepts)
<span class="lineNum">   27270 </span>            :   {
<span class="lineNum">   27271 </span><span class="lineCov">    4194587 :     tree reqs = get_shorthand_constraints (current_template_parms);</span>
<span class="lineNum">   27272 </span>            :     if (tree r = cp_parser_requires_clause_opt (parser))
<span class="lineNum">   27273 </span><span class="lineCov">         18 :       reqs = conjoin_constraints (reqs, normalize_expression (r));</span>
<span class="lineNum">   27274 </span><span class="lineCov">         18 :     TEMPLATE_PARMS_CONSTRAINTS (current_template_parms) = reqs;</span>
<span class="lineNum">   27275 </span>            :   }
<span class="lineNum">   27276 </span>            : 
<span class="lineNum">   27277 </span><span class="lineCov">         18 :   cp_parser_template_declaration_after_parameters (parser, parameter_list,</span>
<span class="lineNum">   27278 </span><span class="lineCov">         18 :                                                    member_p);</span>
<span class="lineNum">   27279 </span>            : 
<span class="lineNum">   27280 </span>            :   /* For the erroneous case of a template with C linkage, we pushed an
<span class="lineNum">   27281 </span>            :      implicit C++ linkage scope; exit that scope now.  */
<span class="lineNum">   27282 </span>            :   if (need_lang_pop)
<span class="lineNum">   27283 </span>            :     pop_lang_context ();
<span class="lineNum">   27284 </span>            : }
<span class="lineNum">   27285 </span>            : 
<span class="lineNum">   27286 </span><span class="lineCov">    4194587 : /* Parse a template-declaration, assuming that the `export' (and</span>
<span class="lineNum">   27287 </span>            :    `extern') keywords, if present, has already been scanned.  MEMBER_P
<span class="lineNum">   27288 </span>            :    is as for cp_parser_template_declaration.  */
<a name="27289"><span class="lineNum">   27289 </span>            : </a>
<span class="lineNum">   27290 </span>            : static bool
<span class="lineNum">   27291 </span><span class="lineCov">    4194587 : cp_parser_template_declaration_after_export (cp_parser* parser, bool member_p)</span>
<span class="lineNum">   27292 </span>            : {
<span class="lineNum">   27293 </span><span class="lineCov">          6 :   if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_TEMPLATE))</span>
<span class="lineNum">   27294 </span><span class="lineCov">          6 :     {</span>
<span class="lineNum">   27295 </span><span class="lineCov">          6 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   27296 </span>            :       cp_parser_explicit_template_declaration (parser, member_p);
<span class="lineNum">   27297 </span>            :       return true;
<span class="lineNum">   27298 </span>            :     }
<span class="lineNum">   27299 </span>            :   else if (flag_concepts)
<span class="lineNum">   27300 </span><span class="lineCov">    4194581 :     return cp_parser_template_introduction (parser, member_p);</span>
<span class="lineNum">   27301 </span>            : 
<span class="lineNum">   27302 </span>            :   return false;
<span class="lineNum">   27303 </span>            : }
<span class="lineNum">   27304 </span><span class="lineCov">    4194587 : </span>
<span class="lineNum">   27305 </span>            : /* Perform the deferred access checks from a template-parameter-list.
<span class="lineNum">   27306 </span>            :    CHECKS is a TREE_LIST of access checks, as returned by
<span class="lineNum">   27307 </span><span class="lineCov">    4194587 :    get_deferred_access_checks.  */</span>
<a name="27308"><span class="lineNum">   27308 </span>            : </a>
<span class="lineNum">   27309 </span><span class="lineCov">       7598 : static void</span>
<span class="lineNum">   27310 </span><span class="lineCov">       7598 : cp_parser_perform_template_parameter_access_checks (vec&lt;deferred_access_check, va_gc&gt; *checks)</span>
<span class="lineNum">   27311 </span><span class="lineCov">         61 : {</span>
<span class="lineNum">   27312 </span><span class="lineCov">       7598 :   ++processing_template_parmlist;</span>
<span class="lineNum">   27313 </span>            :   perform_access_checks (checks, tf_warning_or_error);
<span class="lineNum">   27314 </span>            :   --processing_template_parmlist;
<span class="lineNum">   27315 </span><span class="lineCov">    4194587 : }</span>
<span class="lineNum">   27316 </span>            : 
<span class="lineNum">   27317 </span>            : /* Parse a `decl-specifier-seq [opt] init-declarator [opt] ;' or
<span class="lineNum">   27318 </span>            :    `function-definition' sequence that follows a template header.
<span class="lineNum">   27319 </span>            :    If MEMBER_P is true, this declaration appears in a class scope.
<span class="lineNum">   27320 </span><span class="lineCov">    4194583 : </span>
<span class="lineNum">   27321 </span><span class="lineCov">         18 :    Returns the DECL for the declared entity.  If FRIEND_P is non-NULL,</span>
<span class="lineNum">   27322 </span>            :    *FRIEND_P is set to TRUE iff the declaration is a friend.  */
<a name="27323"><span class="lineNum">   27323 </span>            : </a>
<span class="lineNum">   27324 </span>            : static tree
<span class="lineNum">   27325 </span>            : cp_parser_single_declaration (cp_parser* parser,
<span class="lineNum">   27326 </span>            :                               vec&lt;deferred_access_check, va_gc&gt; *checks,
<span class="lineNum">   27327 </span>            :                               bool member_p,
<span class="lineNum">   27328 </span>            :                               bool explicit_specialization_p,
<span class="lineNum">   27329 </span><span class="lineCov">   15770723 :                               bool* friend_p)</span>
<span class="lineNum">   27330 </span>            : {
<span class="lineNum">   27331 </span><span class="lineCov">   15770723 :   int declares_class_or_enum;</span>
<span class="lineNum">   27332 </span>            :   tree decl = NULL_TREE;
<span class="lineNum">   27333 </span><span class="lineCov">    4194593 :   cp_decl_specifier_seq decl_specifiers;</span>
<span class="lineNum">   27334 </span><span class="lineCov">    4194593 :   bool function_definition_p = false;</span>
<span class="lineNum">   27335 </span><span class="lineCov">    4194593 :   cp_token *decl_spec_token_start;</span>
<span class="lineNum">   27336 </span>            : 
<span class="lineNum">   27337 </span><span class="lineCov">   11576130 :   /* This function is only used when processing a template</span>
<span class="lineNum">   27338 </span><span class="lineCov">      18398 :      declaration.  */</span>
<span class="lineNum">   27339 </span>            :   gcc_assert (innermost_scope_kind () == sk_template_parms
<span class="lineNum">   27340 </span>            :               || innermost_scope_kind () == sk_template_spec);
<span class="lineNum">   27341 </span>            : 
<span class="lineNum">   27342 </span>            :   /* Defer access checks until we know what is being declared.  */
<span class="lineNum">   27343 </span>            :   push_deferring_access_checks (dk_deferred);
<span class="lineNum">   27344 </span>            : 
<span class="lineNum">   27345 </span>            :   /* Try the `decl-specifier-seq [opt] init-declarator [opt]'
<span class="lineNum">   27346 </span>            :      alternative.  */
<span class="lineNum">   27347 </span>            :   decl_spec_token_start = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   27348 </span><span class="lineNoCov">          0 :   cp_parser_decl_specifier_seq (parser,</span>
<span class="lineNum">   27349 </span>            :                                 CP_PARSER_FLAGS_OPTIONAL,
<span class="lineNum">   27350 </span><span class="lineCov">    8981346 :                                 &amp;decl_specifiers,</span>
<span class="lineNum">   27351 </span><span class="lineCov">    6817308 :                                 &amp;declares_class_or_enum);</span>
<span class="lineNum">   27352 </span><span class="lineCov">    6817308 :   if (friend_p)</span>
<span class="lineNum">   27353 </span><span class="lineNoCov">          0 :     *friend_p = cp_parser_friend_p (&amp;decl_specifiers);</span>
<span class="lineNum">   27354 </span>            : 
<span class="lineNum">   27355 </span>            :   /* There are no template typedefs.  */
<span class="lineNum">   27356 </span>            :   if (decl_spec_seq_has_spec_p (&amp;decl_specifiers, ds_typedef))
<span class="lineNum">   27357 </span>            :     {
<span class="lineNum">   27358 </span>            :       error_at (decl_spec_token_start-&gt;location,
<span class="lineNum">   27359 </span>            :                 &quot;template declaration of %&lt;typedef%&gt;&quot;);
<span class="lineNum">   27360 </span>            :       decl = error_mark_node;
<span class="lineNum">   27361 </span>            :     }
<span class="lineNum">   27362 </span>            : 
<span class="lineNum">   27363 </span><span class="lineCov">    4443433 :   /* Gather up the access checks that occurred the</span>
<span class="lineNum">   27364 </span>            :      decl-specifier-seq.  */
<span class="lineNum">   27365 </span>            :   stop_deferring_access_checks ();
<span class="lineNum">   27366 </span>            : 
<span class="lineNum">   27367 </span>            :   /* Check for the declaration of a template class.  */
<span class="lineNum">   27368 </span>            :   if (declares_class_or_enum)
<span class="lineNum">   27369 </span><span class="lineCov">    4443433 :     {</span>
<span class="lineNum">   27370 </span><span class="lineCov">    4443433 :       if (cp_parser_declares_only_class_p (parser)</span>
<span class="lineNum">   27371 </span><span class="lineCov">    4443433 :           || (declares_class_or_enum &amp; 2))</span>
<span class="lineNum">   27372 </span><span class="lineCov">    4443433 :         {</span>
<span class="lineNum">   27373 </span><span class="lineCov">    4443433 :           // If this is a declaration, but not a definition, associate</span>
<span class="lineNum">   27374 </span>            :           // any constraints with the type declaration. Constraints
<span class="lineNum">   27375 </span>            :           // are associated with definitions in cp_parser_class_specifier.
<span class="lineNum">   27376 </span>            :           if (declares_class_or_enum == 1)
<span class="lineNum">   27377 </span><span class="lineCov">    4443433 :             associate_classtype_constraints (decl_specifiers.type);</span>
<span class="lineNum">   27378 </span>            : 
<span class="lineNum">   27379 </span>            :           decl = shadow_tag (&amp;decl_specifiers);
<span class="lineNum">   27380 </span>            : 
<span class="lineNum">   27381 </span><span class="lineCov">    4443433 :           /* In this case:</span>
<span class="lineNum">   27382 </span>            : 
<span class="lineNum">   27383 </span>            :                struct C {
<span class="lineNum">   27384 </span>            :                  friend template &lt;typename T&gt; struct A&lt;T&gt;::B;
<span class="lineNum">   27385 </span><span class="lineCov">    8886866 :                };</span>
<span class="lineNum">   27386 </span><span class="lineCov">    4443433 : </span>
<span class="lineNum">   27387 </span>            :              A&lt;T&gt;::B will be represented by a TYPENAME_TYPE, and
<span class="lineNum">   27388 </span>            :              therefore not recognized by shadow_tag.  */
<span class="lineNum">   27389 </span>            :           if (friend_p &amp;&amp; *friend_p
<span class="lineNum">   27390 </span><span class="lineCov">    4443429 :               &amp;&amp; !decl</span>
<span class="lineNum">   27391 </span><span class="lineCov">    3987883 :               &amp;&amp; decl_specifiers.type</span>
<span class="lineNum">   27392 </span>            :               &amp;&amp; TYPE_P (decl_specifiers.type))
<span class="lineNum">   27393 </span>            :             decl = decl_specifiers.type;
<span class="lineNum">   27394 </span><span class="lineCov">    4443429 : </span>
<span class="lineNum">   27395 </span>            :           if (decl &amp;&amp; decl != error_mark_node)
<span class="lineNum">   27396 </span><span class="lineCov">          3 :             decl = TYPE_NAME (decl);</span>
<span class="lineNum">   27397 </span>            :           else
<span class="lineNum">   27398 </span><span class="lineCov">          3 :             decl = error_mark_node;</span>
<span class="lineNum">   27399 </span>            : 
<span class="lineNum">   27400 </span>            :           /* Perform access checks for template parameters.  */
<span class="lineNum">   27401 </span>            :           cp_parser_perform_template_parameter_access_checks (checks);
<span class="lineNum">   27402 </span>            : 
<span class="lineNum">   27403 </span><span class="lineCov">    4443429 :           /* Give a helpful diagnostic for</span>
<span class="lineNum">   27404 </span>            :                template &lt;class T&gt; struct A { } a;
<span class="lineNum">   27405 </span>            :              if we aren't already recovering from an error.  */
<span class="lineNum">   27406 </span><span class="lineCov">    4443429 :           if (!cp_parser_declares_only_class_p (parser)</span>
<span class="lineNum">   27407 </span>            :               &amp;&amp; !seen_error ())
<span class="lineNum">   27408 </span><span class="lineCov">    2164129 :             {</span>
<span class="lineNum">   27409 </span><span class="lineCov">         57 :               error_at (cp_lexer_peek_token (parser-&gt;lexer)-&gt;location,</span>
<span class="lineNum">   27410 </span>            :                         &quot;a class template declaration must not declare &quot;
<span class="lineNum">   27411 </span>            :                         &quot;anything else&quot;);
<span class="lineNum">   27412 </span>            :               cp_parser_skip_to_end_of_block_or_statement (parser);
<span class="lineNum">   27413 </span>            :               goto out;
<span class="lineNum">   27414 </span><span class="lineCov">    2164038 :             }</span>
<span class="lineNum">   27415 </span><span class="lineCov">     297787 :         }</span>
<span class="lineNum">   27416 </span>            :     }
<span class="lineNum">   27417 </span><span class="lineCov">    2164038 : </span>
<span class="lineNum">   27418 </span>            :   /* Complain about missing 'typename' or other invalid type names.  */
<span class="lineNum">   27419 </span>            :   if (!decl_specifiers.any_type_specifiers_p
<span class="lineNum">   27420 </span>            :       &amp;&amp; cp_parser_parse_and_diagnose_invalid_type_name (parser))
<span class="lineNum">   27421 </span>            :     {
<span class="lineNum">   27422 </span>            :       /* cp_parser_parse_and_diagnose_invalid_type_name calls
<span class="lineNum">   27423 </span>            :          cp_parser_skip_to_end_of_block_or_statement, so don't try to parse
<span class="lineNum">   27424 </span>            :          the rest of this declaration.  */
<span class="lineNum">   27425 </span>            :       decl = error_mark_node;
<span class="lineNum">   27426 </span>            :       goto out;
<span class="lineNum">   27427 </span><span class="lineCov">    2164038 :     }</span>
<span class="lineNum">   27428 </span><span class="lineCov">      13665 : </span>
<span class="lineNum">   27429 </span><span class="lineCov">         67 :   /* If it's not a template class, try for a template function.  If</span>
<span class="lineNum">   27430 </span><span class="lineCov">         67 :      the next token is a `;', then this declaration does not declare</span>
<span class="lineNum">   27431 </span><span class="lineCov">         55 :      anything.  But, if there were errors in the decl-specifiers, then</span>
<span class="lineNum">   27432 </span>            :      the error might well have come from an attempted class-specifier.
<span class="lineNum">   27433 </span><span class="lineCov">    2164038 :      In that case, there's no need to warn about a missing declarator.  */</span>
<span class="lineNum">   27434 </span><span class="lineCov">    2162832 :   if (!decl</span>
<span class="lineNum">   27435 </span>            :       &amp;&amp; (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_SEMICOLON)
<span class="lineNum">   27436 </span><span class="lineCov">       1206 :           || decl_specifiers.type != error_mark_node))</span>
<span class="lineNum">   27437 </span>            :     {
<span class="lineNum">   27438 </span>            :       decl = cp_parser_init_declarator (parser,
<span class="lineNum">   27439 </span><span class="lineCov">    2164038 :                                         &amp;decl_specifiers,</span>
<span class="lineNum">   27440 </span>            :                                         checks,
<span class="lineNum">   27441 </span>            :                                         /*function_definition_allowed_p=*/true,
<span class="lineNum">   27442 </span>            :                                         member_p,
<span class="lineNum">   27443 </span>            :                                         declares_class_or_enum,
<span class="lineNum">   27444 </span><span class="lineCov">    2164061 :                                         &amp;function_definition_p,</span>
<span class="lineNum">   27445 </span><span class="lineCov">         23 :                                         NULL, NULL, NULL);</span>
<span class="lineNum">   27446 </span>            : 
<span class="lineNum">   27447 </span><span class="lineCov">          1 :     /* 7.1.1-1 [dcl.stc]</span>
<span class="lineNum">   27448 </span>            : 
<span class="lineNum">   27449 </span>            :        A storage-class-specifier shall not be specified in an explicit
<span class="lineNum">   27450 </span><span class="lineCov">          1 :        specialization...  */</span>
<span class="lineNum">   27451 </span><span class="lineCov">          1 :     if (decl</span>
<span class="lineNum">   27452 </span>            :         &amp;&amp; explicit_specialization_p
<span class="lineNum">   27453 </span>            :         &amp;&amp; decl_specifiers.storage_class != sc_none)
<span class="lineNum">   27454 </span>            :       {
<span class="lineNum">   27455 </span>            :         error_at (decl_spec_token_start-&gt;location,
<span class="lineNum">   27456 </span>            :                   &quot;explicit template specialization cannot have a storage class&quot;);
<span class="lineNum">   27457 </span><span class="lineCov">    4443428 :         decl = error_mark_node;</span>
<span class="lineNum">   27458 </span><span class="lineCov">    4443428 :       }</span>
<span class="lineNum">   27459 </span>            : 
<span class="lineNum">   27460 </span>            :     if (decl &amp;&amp; VAR_P (decl))
<span class="lineNum">   27461 </span>            :       check_template_variable (decl);
<span class="lineNum">   27462 </span>            :     }
<span class="lineNum">   27463 </span><span class="lineCov">         26 : </span>
<span class="lineNum">   27464 </span><span class="lineCov">         26 :   /* Look for a trailing `;' after the declaration.  */</span>
<span class="lineNum">   27465 </span>            :   if (!function_definition_p
<span class="lineNum">   27466 </span>            :       &amp;&amp; (decl == error_mark_node
<span class="lineNum">   27467 </span>            :           || !cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON)))
<span class="lineNum">   27468 </span>            :     cp_parser_skip_to_end_of_block_or_statement (parser);
<span class="lineNum">   27469 </span>            : 
<span class="lineNum">   27470 </span>            :  out:
<span class="lineNum">   27471 </span>            :   pop_deferring_access_checks ();
<span class="lineNum">   27472 </span><span class="lineCov">    4443402 : </span>
<span class="lineNum">   27473 </span><span class="lineCov">    4443402 :   /* Clear any current qualification; whatever comes next is the start</span>
<span class="lineNum">   27474 </span><span class="lineCov">         33 :      of something new.  */</span>
<span class="lineNum">   27475 </span>            :   parser-&gt;scope = NULL_TREE;
<span class="lineNum">   27476 </span><span class="lineCov">    2279365 :   parser-&gt;qualifying_scope = NULL_TREE;</span>
<span class="lineNum">   27477 </span>            :   parser-&gt;object_scope = NULL_TREE;
<span class="lineNum">   27478 </span>            : 
<span class="lineNum">   27479 </span>            :   return decl;
<span class="lineNum">   27480 </span>            : }
<span class="lineNum">   27481 </span>            : 
<span class="lineNum">   27482 </span>            : /* Parse a cast-expression that is not the operand of a unary &quot;&amp;&quot;.  */
<a name="27483"><span class="lineNum">   27483 </span>            : </a>
<span class="lineNum">   27484 </span>            : static cp_expr
<span class="lineNum">   27485 </span>            : cp_parser_simple_cast_expression (cp_parser *parser)
<span class="lineNum">   27486 </span>            : {
<span class="lineNum">   27487 </span>            :   return cp_parser_cast_expression (parser, /*address_p=*/false,
<span class="lineNum">   27488 </span>            :                                     /*cast_p=*/false, /*decltype*/false, NULL);
<span class="lineNum">   27489 </span><span class="lineCov">    2279365 : }</span>
<span class="lineNum">   27490 </span><span class="lineCov">    2279365 : </span>
<span class="lineNum">   27491 </span><span class="lineCov">      51405 : /* Parse a functional cast to TYPE.  Returns an expression</span>
<span class="lineNum">   27492 </span>            :    representing the cast.  */
<a name="27493"><span class="lineNum">   27493 </span><span class="lineCov">          6 : </span></a>
<span class="lineNum">   27494 </span>            : static cp_expr
<span class="lineNum">   27495 </span><span class="lineCov">          6 : cp_parser_functional_cast (cp_parser* parser, tree type)</span>
<span class="lineNum">   27496 </span>            : {
<span class="lineNum">   27497 </span>            :   vec&lt;tree, va_gc&gt; *vec;
<span class="lineNum">   27498 </span><span class="lineCov">    2279365 :   tree expression_list;</span>
<span class="lineNum">   27499 </span><span class="lineCov">     115765 :   cp_expr cast;</span>
<span class="lineNum">   27500 </span>            :   bool nonconst_p;
<span class="lineNum">   27501 </span>            : 
<span class="lineNum">   27502 </span>            :   location_t start_loc = input_location;
<span class="lineNum">   27503 </span><span class="lineCov">    4443402 : </span>
<span class="lineNum">   27504 </span><span class="lineCov">    4443402 :   if (!type)</span>
<span class="lineNum">   27505 </span><span class="lineCov">    2609769 :     type = error_mark_node;</span>
<span class="lineNum">   27506 </span><span class="lineCov">       1526 : </span>
<span class="lineNum">   27507 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_BRACE))
<span class="lineNum">   27508 </span><span class="lineCov">    4443429 :     {</span>
<span class="lineNum">   27509 </span><span class="lineCov">    4443429 :       cp_lexer_set_source_position (parser-&gt;lexer);</span>
<span class="lineNum">   27510 </span>            :       maybe_warn_cpp0x (CPP0X_INITIALIZER_LISTS);
<span class="lineNum">   27511 </span>            :       expression_list = cp_parser_braced_list (parser, &amp;nonconst_p);
<span class="lineNum">   27512 </span>            :       CONSTRUCTOR_IS_DIRECT_INIT (expression_list) = 1;
<span class="lineNum">   27513 </span><span class="lineCov">    4443429 :       if (TREE_CODE (type) == TYPE_DECL)</span>
<span class="lineNum">   27514 </span><span class="lineCov">    4443429 :         type = TREE_TYPE (type);</span>
<span class="lineNum">   27515 </span><span class="lineCov">    4443429 : </span>
<span class="lineNum">   27516 </span>            :       cast = finish_compound_literal (type, expression_list,
<span class="lineNum">   27517 </span><span class="lineCov">    4443429 :                                       tf_warning_or_error, fcl_functional);</span>
<span class="lineNum">   27518 </span>            :       /* Create a location of the form:
<span class="lineNum">   27519 </span>            :             type_name{i, f}
<span class="lineNum">   27520 </span>            :             ^~~~~~~~~~~~~~~
<span class="lineNum">   27521 </span>            :          with caret == start at the start of the type name,
<span class="lineNum">   27522 </span>            :          finishing at the closing brace.  */
<span class="lineNum">   27523 </span><span class="lineNoCov">          0 :       location_t finish_loc</span>
<span class="lineNum">   27524 </span>            :         = get_finish (cp_lexer_previous_token (parser-&gt;lexer)-&gt;location);
<span class="lineNum">   27525 </span><span class="lineCov">    6678513 :       location_t combined_loc = make_location (start_loc, start_loc,</span>
<span class="lineNum">   27526 </span><span class="lineCov">    6677968 :                                                finish_loc);</span>
<span class="lineNum">   27527 </span>            :       cast.set_location (combined_loc);
<span class="lineNum">   27528 </span>            :       return cast;
<span class="lineNum">   27529 </span>            :    }
<span class="lineNum">   27530 </span>            : 
<span class="lineNum">   27531 </span>            : 
<span class="lineNum">   27532 </span>            :   vec = cp_parser_parenthesized_expression_list (parser, non_attr,
<span class="lineNum">   27533 </span><span class="lineCov">    1256128 :                                                  /*cast_p=*/true,</span>
<span class="lineNum">   27534 </span>            :                                                  /*allow_expansion_p=*/true,
<span class="lineNum">   27535 </span><span class="lineCov">    1256128 :                                                  /*non_constant_p=*/NULL);</span>
<span class="lineNum">   27536 </span><span class="lineCov">    1256128 :   if (vec == NULL)</span>
<span class="lineNum">   27537 </span><span class="lineCov">    1256128 :     expression_list = error_mark_node;</span>
<span class="lineNum">   27538 </span><span class="lineCov">    1256128 :   else</span>
<span class="lineNum">   27539 </span>            :     {
<span class="lineNum">   27540 </span><span class="lineCov">    1256128 :       expression_list = build_tree_list_vec (vec);</span>
<span class="lineNum">   27541 </span>            :       release_tree_vector (vec);
<span class="lineNum">   27542 </span><span class="lineCov">    1256128 :     }</span>
<span class="lineNum">   27543 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   27544 </span>            :   cast = build_functional_cast (type, expression_list,
<span class="lineNum">   27545 </span><span class="lineCov">    1256128 :                                 tf_warning_or_error);</span>
<span class="lineNum">   27546 </span>            :   /* [expr.const]/1: In an integral constant expression &quot;only type
<span class="lineNum">   27547 </span><span class="lineCov">     110864 :      conversions to integral or enumeration type can be used&quot;.  */</span>
<span class="lineNum">   27548 </span><span class="lineCov">      55432 :   if (TREE_CODE (type) == TYPE_DECL)</span>
<span class="lineNum">   27549 </span><span class="lineCov">      55432 :     type = TREE_TYPE (type);</span>
<span class="lineNum">   27550 </span><span class="lineCov">      55432 :   if (cast != error_mark_node</span>
<span class="lineNum">   27551 </span><span class="lineCov">      55432 :       &amp;&amp; !cast_valid_in_integral_constant_expression_p (type)</span>
<span class="lineNum">   27552 </span><span class="lineCov">      52062 :       &amp;&amp; cp_parser_non_integral_constant_expression (parser,</span>
<span class="lineNum">   27553 </span>            :                                                      NIC_CONSTRUCTOR))
<span class="lineNum">   27554 </span><span class="lineCov">      55432 :     return error_mark_node;</span>
<span class="lineNum">   27555 </span>            : 
<span class="lineNum">   27556 </span>            :   /* Create a location of the form:
<span class="lineNum">   27557 </span>            :        float(i)
<span class="lineNum">   27558 </span>            :        ^~~~~~~~
<span class="lineNum">   27559 </span>            :      with caret == start at the start of the type name,
<span class="lineNum">   27560 </span>            :      finishing at the closing paren.  */
<span class="lineNum">   27561 </span><span class="lineCov">      55432 :   location_t finish_loc</span>
<span class="lineNum">   27562 </span><span class="lineCov">      55432 :     = get_finish (cp_lexer_previous_token (parser-&gt;lexer)-&gt;location);</span>
<span class="lineNum">   27563 </span><span class="lineCov">      55432 :   location_t combined_loc = make_location (start_loc, start_loc, finish_loc);</span>
<span class="lineNum">   27564 </span>            :   cast.set_location (combined_loc);
<span class="lineNum">   27565 </span><span class="lineCov">      55432 :   return cast;</span>
<span class="lineNum">   27566 </span><span class="lineCov">      55432 : }</span>
<span class="lineNum">   27567 </span>            : 
<span class="lineNum">   27568 </span>            : /* Save the tokens that make up the body of a member function defined
<span class="lineNum">   27569 </span>            :    in a class-specifier.  The DECL_SPECIFIERS and DECLARATOR have
<span class="lineNum">   27570 </span><span class="lineCov">    1200696 :    already been parsed.  The ATTRIBUTES are any GNU &quot;__attribute__&quot;</span>
<span class="lineNum">   27571 </span>            :    specifiers applied to the declaration.  Returns the FUNCTION_DECL
<span class="lineNum">   27572 </span>            :    for the member function.  */
<a name="27573"><span class="lineNum">   27573 </span>            : </a>
<span class="lineNum">   27574 </span><span class="lineCov">    1200696 : static tree</span>
<span class="lineNum">   27575 </span><span class="lineCov">        239 : cp_parser_save_member_function_body (cp_parser* parser,</span>
<span class="lineNum">   27576 </span>            :                                      cp_decl_specifier_seq *decl_specifiers,
<span class="lineNum">   27577 </span>            :                                      cp_declarator *declarator,
<span class="lineNum">   27578 </span><span class="lineCov">    1200457 :                                      tree attributes)</span>
<span class="lineNum">   27579 </span><span class="lineCov">    1200457 : {</span>
<span class="lineNum">   27580 </span>            :   cp_token *first;
<span class="lineNum">   27581 </span>            :   cp_token *last;
<span class="lineNum">   27582 </span><span class="lineCov">    1200696 :   tree fn;</span>
<span class="lineNum">   27583 </span>            :   bool function_try_block = false;
<span class="lineNum">   27584 </span>            : 
<span class="lineNum">   27585 </span>            :   /* Create the FUNCTION_DECL.  */
<span class="lineNum">   27586 </span><span class="lineCov">    1200696 :   fn = grokmethod (decl_specifiers, declarator, attributes);</span>
<span class="lineNum">   27587 </span><span class="lineCov">    1189997 :   cp_finalize_omp_declare_simd (parser, fn);</span>
<span class="lineNum">   27588 </span><span class="lineCov">    1200696 :   cp_finalize_oacc_routine (parser, fn, true);</span>
<span class="lineNum">   27589 </span><span class="lineCov">    1200335 :   /* If something went badly wrong, bail out now.  */</span>
<span class="lineNum">   27590 </span><span class="lineCov">    1207463 :   if (fn == error_mark_node)</span>
<span class="lineNum">   27591 </span>            :     {
<span class="lineNum">   27592 </span><span class="lineCov">          1 :       /* If there's a function-body, skip it.  */</span>
<span class="lineNum">   27593 </span>            :       if (cp_parser_token_starts_function_definition_p
<span class="lineNum">   27594 </span>            :           (cp_lexer_peek_token (parser-&gt;lexer)))
<span class="lineNum">   27595 </span>            :         cp_parser_skip_to_end_of_block_or_statement (parser);
<span class="lineNum">   27596 </span>            :       return error_mark_node;
<span class="lineNum">   27597 </span>            :     }
<span class="lineNum">   27598 </span>            : 
<span class="lineNum">   27599 </span><span class="lineCov">    1200695 :   /* Remember it, if there default args to post process.  */</span>
<span class="lineNum">   27600 </span><span class="lineCov">    1200695 :   cp_parser_save_default_args (parser, fn);</span>
<span class="lineNum">   27601 </span><span class="lineCov">    1200695 : </span>
<span class="lineNum">   27602 </span><span class="lineCov">    1200695 :   /* Save away the tokens that make up the body of the</span>
<span class="lineNum">   27603 </span><span class="lineCov">    1200695 :      function.  */</span>
<span class="lineNum">   27604 </span>            :   first = parser-&gt;lexer-&gt;next_token;
<span class="lineNum">   27605 </span>            : 
<span class="lineNum">   27606 </span>            :   if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_TRANSACTION_RELAXED))
<span class="lineNum">   27607 </span>            :     cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   27608 </span>            :   else if (cp_lexer_next_token_is_keyword (parser-&gt;lexer,
<span class="lineNum">   27609 </span>            :                                            RID_TRANSACTION_ATOMIC))
<span class="lineNum">   27610 </span>            :     {
<span class="lineNum">   27611 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   27612 </span>            :       /* Match cp_parser_txn_attribute_opt [[ identifier ]].  */
<span class="lineNum">   27613 </span><span class="lineCov">    3058310 :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_SQUARE)</span>
<span class="lineNum">   27614 </span>            :           &amp;&amp; cp_lexer_nth_token_is (parser-&gt;lexer, 2, CPP_OPEN_SQUARE)
<span class="lineNum">   27615 </span>            :           &amp;&amp; (cp_lexer_nth_token_is (parser-&gt;lexer, 3, CPP_NAME)
<span class="lineNum">   27616 </span>            :               || cp_lexer_nth_token_is (parser-&gt;lexer, 3, CPP_KEYWORD))
<span class="lineNum">   27617 </span>            :           &amp;&amp; cp_lexer_nth_token_is (parser-&gt;lexer, 4, CPP_CLOSE_SQUARE)
<span class="lineNum">   27618 </span><span class="lineCov">    3058310 :           &amp;&amp; cp_lexer_nth_token_is (parser-&gt;lexer, 5, CPP_CLOSE_SQUARE))</span>
<span class="lineNum">   27619 </span><span class="lineCov">    3058310 :         {</span>
<span class="lineNum">   27620 </span><span class="lineCov">    3058310 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   27621 </span><span class="lineCov">    3058310 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   27622 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   27623 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   27624 </span><span class="lineCov">    3058310 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   27625 </span><span class="lineCov">    3058310 :         }</span>
<span class="lineNum">   27626 </span><span class="lineCov">    3058310 :       else</span>
<span class="lineNum">   27627 </span>            :         while (cp_next_tokens_can_be_gnu_attribute_p (parser)
<span class="lineNum">   27628 </span><span class="lineCov">    3058310 :                &amp;&amp; cp_lexer_nth_token_is (parser-&gt;lexer, 2, CPP_OPEN_PAREN))</span>
<span class="lineNum">   27629 </span>            :           {
<span class="lineNum">   27630 </span>            :             cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   27631 </span><span class="lineCov">         51 :             if (cp_parser_cache_group (parser, CPP_CLOSE_PAREN, /*depth=*/0))</span>
<span class="lineNum">   27632 </span><span class="lineCov">        102 :               break;</span>
<span class="lineNum">   27633 </span><span class="lineCov">         51 :           }</span>
<span class="lineNum">   27634 </span><span class="lineCov">         51 :     }</span>
<span class="lineNum">   27635 </span>            : 
<span class="lineNum">   27636 </span>            :   /* Handle function try blocks.  */
<span class="lineNum">   27637 </span>            :   if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_TRY))
<span class="lineNum">   27638 </span><span class="lineCov">    3058259 :     {</span>
<span class="lineNum">   27639 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   27640 </span>            :       function_try_block = true;
<span class="lineNum">   27641 </span>            :     }
<span class="lineNum">   27642 </span><span class="lineCov">    3058259 :   /* We can have braced-init-list mem-initializers before the fn body.  */</span>
<span class="lineNum">   27643 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_COLON))
<span class="lineNum">   27644 </span><span class="lineCov">    3058259 :     {</span>
<span class="lineNum">   27645 </span><span class="lineNoCov">          0 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   27646 </span><span class="lineCov">    3058259 :       while (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_OPEN_BRACE))</span>
<span class="lineNum">   27647 </span>            :         {
<span class="lineNum">   27648 </span>            :           /* cache_group will stop after an un-nested { } pair, too.  */
<span class="lineNum">   27649 </span><span class="lineCov">          4 :           if (cp_parser_cache_group (parser, CPP_CLOSE_PAREN, /*depth=*/0))</span>
<span class="lineNum">   27650 </span>            :             break;
<span class="lineNum">   27651 </span><span class="lineCov">          8 : </span>
<span class="lineNum">   27652 </span><span class="lineCov">          2 :           /* variadic mem-inits have ... after the ')'.  */</span>
<span class="lineNum">   27653 </span><span class="lineCov">          2 :           if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_ELLIPSIS))</span>
<span class="lineNum">   27654 </span><span class="lineNoCov">          0 :             cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   27655 </span><span class="lineCov">          2 :         }</span>
<span class="lineNum">   27656 </span><span class="lineCov">          6 :     }</span>
<span class="lineNum">   27657 </span>            :   cp_parser_cache_group (parser, CPP_CLOSE_BRACE, /*depth=*/0);
<span class="lineNum">   27658 </span><span class="lineCov">          2 :   /* Handle function try blocks.  */</span>
<span class="lineNum">   27659 </span><span class="lineCov">          2 :   if (function_try_block)</span>
<span class="lineNum">   27660 </span><span class="lineCov">          2 :     while (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_CATCH))</span>
<span class="lineNum">   27661 </span><span class="lineCov">          2 :       cp_parser_cache_group (parser, CPP_CLOSE_BRACE, /*depth=*/0);</span>
<span class="lineNum">   27662 </span><span class="lineCov">          2 :   last = parser-&gt;lexer-&gt;next_token;</span>
<span class="lineNum">   27663 </span>            : 
<span class="lineNum">   27664 </span>            :   /* Save away the inline definition; we will process it when the
<span class="lineNum">   27665 </span><span class="lineCov">          4 :      class is complete.  */</span>
<span class="lineNum">   27666 </span><span class="lineCov">          4 :   DECL_PENDING_INLINE_INFO (fn) = cp_token_cache_new (first, last);</span>
<span class="lineNum">   27667 </span>            :   DECL_PENDING_INLINE_P (fn) = 1;
<span class="lineNum">   27668 </span><span class="lineCov">          2 : </span>
<span class="lineNum">   27669 </span><span class="lineCov">          2 :   /* We need to know that this was defined in the class, so that</span>
<span class="lineNum">   27670 </span>            :      friend templates are handled correctly.  */
<span class="lineNum">   27671 </span>            :   DECL_INITIALIZED_IN_CLASS_P (fn) = 1;
<span class="lineNum">   27672 </span>            : 
<span class="lineNum">   27673 </span>            :   /* Add FN to the queue of functions to be parsed later.  */
<span class="lineNum">   27674 </span>            :   vec_safe_push (unparsed_funs_with_definitions, fn);
<span class="lineNum">   27675 </span><span class="lineCov">    3058259 : </span>
<span class="lineNum">   27676 </span>            :   return fn;
<span class="lineNum">   27677 </span><span class="lineCov">         47 : }</span>
<span class="lineNum">   27678 </span><span class="lineCov">         47 : </span>
<span class="lineNum">   27679 </span>            : /* Save the tokens that make up the in-class initializer for a non-static
<span class="lineNum">   27680 </span>            :    data member.  Returns a DEFAULT_ARG.  */
<a name="27681"><span class="lineNum">   27681 </span><span class="lineCov">    3058259 : </span></a>
<span class="lineNum">   27682 </span>            : static tree
<span class="lineNum">   27683 </span><span class="lineCov">     541212 : cp_parser_save_nsdmi (cp_parser* parser)</span>
<span class="lineNum">   27684 </span><span class="lineCov">    1335890 : {</span>
<span class="lineNum">   27685 </span>            :   return cp_parser_cache_defarg (parser, /*nsdmi=*/true);
<span class="lineNum">   27686 </span>            : }
<span class="lineNum">   27687 </span><span class="lineCov">     794686 : </span>
<span class="lineNum">   27688 </span>            : /* Parse a template-argument-list, as well as the trailing &quot;&gt;&quot; (but
<span class="lineNum">   27689 </span>            :    not the opening &quot;&lt;&quot;).  See cp_parser_template_argument_list for the
<span class="lineNum">   27690 </span>            :    return value.  */
<a name="27691"><span class="lineNum">   27691 </span><span class="lineCov">     794678 : </span></a>
<span class="lineNum">   27692 </span><span class="lineCov">         13 : static tree</span>
<span class="lineNum">   27693 </span>            : cp_parser_enclosed_template_argument_list (cp_parser* parser)
<span class="lineNum">   27694 </span>            : {
<span class="lineNum">   27695 </span><span class="lineCov">    3058259 :   tree arguments;</span>
<span class="lineNum">   27696 </span>            :   tree saved_scope;
<span class="lineNum">   27697 </span><span class="lineCov">    3058259 :   tree saved_qualifying_scope;</span>
<span class="lineNum">   27698 </span><span class="lineCov">        104 :   tree saved_object_scope;</span>
<span class="lineNum">   27699 </span><span class="lineCov">         57 :   bool saved_greater_than_is_operator_p;</span>
<span class="lineNum">   27700 </span><span class="lineCov">    3058259 :   int saved_unevaluated_operand;</span>
<span class="lineNum">   27701 </span>            :   int saved_inhibit_evaluation_warnings;
<span class="lineNum">   27702 </span>            : 
<span class="lineNum">   27703 </span>            :   /* [temp.names]
<span class="lineNum">   27704 </span><span class="lineCov">    3058259 : </span>
<span class="lineNum">   27705 </span><span class="lineCov">    3058259 :      When parsing a template-id, the first non-nested `&gt;' is taken as</span>
<span class="lineNum">   27706 </span>            :      the end of the template-argument-list rather than a greater-than
<span class="lineNum">   27707 </span>            :      operator.  */
<span class="lineNum">   27708 </span>            :   saved_greater_than_is_operator_p
<span class="lineNum">   27709 </span><span class="lineCov">    6116518 :     = parser-&gt;greater_than_is_operator_p;</span>
<span class="lineNum">   27710 </span>            :   parser-&gt;greater_than_is_operator_p = false;
<span class="lineNum">   27711 </span>            :   /* Parsing the argument list may modify SCOPE, so we save it
<span class="lineNum">   27712 </span><span class="lineCov">    3058259 :      here.  */</span>
<span class="lineNum">   27713 </span>            :   saved_scope = parser-&gt;scope;
<span class="lineNum">   27714 </span><span class="lineCov">    3058259 :   saved_qualifying_scope = parser-&gt;qualifying_scope;</span>
<span class="lineNum">   27715 </span>            :   saved_object_scope = parser-&gt;object_scope;
<span class="lineNum">   27716 </span>            :   /* We need to evaluate the template arguments, even though this
<span class="lineNum">   27717 </span>            :      template-id may be nested within a &quot;sizeof&quot;.  */
<span class="lineNum">   27718 </span>            :   saved_unevaluated_operand = cp_unevaluated_operand;
<span class="lineNum">   27719 </span>            :   cp_unevaluated_operand = 0;
<span class="lineNum">   27720 </span>            :   saved_inhibit_evaluation_warnings = c_inhibit_evaluation_warnings;
<span class="lineNum">   27721 </span><span class="lineNoCov">          0 :   c_inhibit_evaluation_warnings = 0;</span>
<span class="lineNum">   27722 </span>            :   /* Parse the template-argument-list itself.  */
<span class="lineNum">   27723 </span><span class="lineCov">       8310 :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_GREATER)</span>
<span class="lineNum">   27724 </span>            :       || cp_lexer_next_token_is (parser-&gt;lexer, CPP_RSHIFT))
<span class="lineNum">   27725 </span>            :     arguments = NULL_TREE;
<span class="lineNum">   27726 </span>            :   else
<span class="lineNum">   27727 </span>            :     arguments = cp_parser_template_argument_list (parser);
<span class="lineNum">   27728 </span>            :   /* Look for the `&gt;' that ends the template-argument-list. If we find
<span class="lineNum">   27729 </span>            :      a '&gt;&gt;' instead, it's probably just a typo.  */
<span class="lineNum">   27730 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_RSHIFT))
<span class="lineNum">   27731 </span><span class="lineCov">    8373304 :     {</span>
<span class="lineNum">   27732 </span>            :       if (cxx_dialect != cxx98)
<span class="lineNum">   27733 </span><span class="lineCov">    8373304 :         {</span>
<span class="lineNum">   27734 </span><span class="lineCov">    8373304 :           /* In C++0x, a `&gt;&gt;' in a template argument list or cast</span>
<span class="lineNum">   27735 </span><span class="lineCov">    8373304 :              expression is considered to be two separate `&gt;'</span>
<span class="lineNum">   27736 </span><span class="lineCov">    8373304 :              tokens. So, change the current token to a `&gt;', but don't</span>
<span class="lineNum">   27737 </span><span class="lineCov">    8373304 :              consume it: it will be consumed later when the outer</span>
<span class="lineNum">   27738 </span><span class="lineCov">    8373304 :              template argument list (or cast expression) is parsed.</span>
<span class="lineNum">   27739 </span><span class="lineCov">    8373304 :              Note that this replacement of `&gt;' for `&gt;&gt;' is necessary</span>
<span class="lineNum">   27740 </span>            :              even if we are parsing tentatively: in the tentative
<span class="lineNum">   27741 </span>            :              case, after calling
<span class="lineNum">   27742 </span>            :              cp_parser_enclosed_template_argument_list we will always
<span class="lineNum">   27743 </span>            :              throw away all of the template arguments and the first
<span class="lineNum">   27744 </span>            :              closing `&gt;', either because the template argument list
<span class="lineNum">   27745 </span>            :              was erroneous or because we are replacing those tokens
<span class="lineNum">   27746 </span><span class="lineCov">    8373304 :              with a CPP_TEMPLATE_ID token.  The second `&gt;' (which will</span>
<span class="lineNum">   27747 </span><span class="lineCov">    8373304 :              not have been thrown away) is needed either to close an</span>
<span class="lineNum">   27748 </span><span class="lineCov">    8373304 :              outer template argument list or to complete a new-style</span>
<span class="lineNum">   27749 </span>            :              cast.  */
<span class="lineNum">   27750 </span>            :           cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   27751 </span><span class="lineCov">    8373304 :           token-&gt;type = CPP_GREATER;</span>
<span class="lineNum">   27752 </span><span class="lineCov">    8373304 :         }</span>
<span class="lineNum">   27753 </span><span class="lineCov">    8373304 :       else if (!saved_greater_than_is_operator_p)</span>
<span class="lineNum">   27754 </span>            :         {
<span class="lineNum">   27755 </span>            :           /* If we're in a nested template argument list, the '&gt;&gt;' has
<span class="lineNum">   27756 </span><span class="lineCov">    8373304 :             to be a typo for '&gt; &gt;'. We emit the error message, but we</span>
<span class="lineNum">   27757 </span><span class="lineCov">    8373304 :             continue parsing and we push a '&gt;' as next token, so that</span>
<span class="lineNum">   27758 </span><span class="lineCov">    8373304 :             the argument list will be parsed correctly.  Note that the</span>
<span class="lineNum">   27759 </span><span class="lineCov">    8373304 :             global source location is still on the token before the</span>
<span class="lineNum">   27760 </span>            :             '&gt;&gt;', so we need to say explicitly where we want it.  */
<span class="lineNum">   27761 </span><span class="lineCov">   16746608 :           cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   27762 </span><span class="lineCov">    8373304 :           gcc_rich_location richloc (token-&gt;location);</span>
<span class="lineNum">   27763 </span>            :           richloc.add_fixit_replace (&quot;&gt; &gt;&quot;);
<span class="lineNum">   27764 </span>            :           error_at (&amp;richloc, &quot;%&lt;&gt;&gt;%&gt; should be %&lt;&gt; &gt;%&gt; &quot;
<span class="lineNum">   27765 </span><span class="lineCov">    8351532 :                     &quot;within a nested template argument list&quot;);</span>
<span class="lineNum">   27766 </span>            : 
<span class="lineNum">   27767 </span>            :           token-&gt;type = CPP_GREATER;
<span class="lineNum">   27768 </span><span class="lineCov">    8373304 :         }</span>
<span class="lineNum">   27769 </span>            :       else
<span class="lineNum">   27770 </span><span class="lineCov">     412720 :         {</span>
<span class="lineNum">   27771 </span>            :           /* If this is not a nested template argument list, the '&gt;&gt;'
<span class="lineNum">   27772 </span>            :             is a typo for '&gt;'. Emit an error message and continue.
<span class="lineNum">   27773 </span>            :             Same deal about the token location, but here we can get it
<span class="lineNum">   27774 </span>            :             right by consuming the '&gt;&gt;' before issuing the diagnostic.  */
<span class="lineNum">   27775 </span>            :           cp_token *token = cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   27776 </span>            :           error_at (token-&gt;location,
<span class="lineNum">   27777 </span>            :                     &quot;spurious %&lt;&gt;&gt;%&gt;, use %&lt;&gt;%&gt; to terminate &quot;
<span class="lineNum">   27778 </span>            :                     &quot;a template argument list&quot;);
<span class="lineNum">   27779 </span>            :         }
<span class="lineNum">   27780 </span>            :     }
<span class="lineNum">   27781 </span>            :   else
<span class="lineNum">   27782 </span>            :     cp_parser_skip_to_end_of_template_parameter_list (parser);
<span class="lineNum">   27783 </span>            :   /* The `&gt;' token might be a greater-than operator again now.  */
<span class="lineNum">   27784 </span>            :   parser-&gt;greater_than_is_operator_p
<span class="lineNum">   27785 </span>            :     = saved_greater_than_is_operator_p;
<span class="lineNum">   27786 </span>            :   /* Restore the SAVED_SCOPE.  */
<span class="lineNum">   27787 </span>            :   parser-&gt;scope = saved_scope;
<span class="lineNum">   27788 </span><span class="lineCov">     825430 :   parser-&gt;qualifying_scope = saved_qualifying_scope;</span>
<span class="lineNum">   27789 </span><span class="lineCov">     412715 :   parser-&gt;object_scope = saved_object_scope;</span>
<span class="lineNum">   27790 </span>            :   cp_unevaluated_operand = saved_unevaluated_operand;
<span class="lineNum">   27791 </span><span class="lineCov">          5 :   c_inhibit_evaluation_warnings = saved_inhibit_evaluation_warnings;</span>
<span class="lineNum">   27792 </span>            : 
<span class="lineNum">   27793 </span>            :   return arguments;
<span class="lineNum">   27794 </span>            : }
<span class="lineNum">   27795 </span>            : 
<span class="lineNum">   27796 </span>            : /* MEMBER_FUNCTION is a member function, or a friend.  If default
<span class="lineNum">   27797 </span>            :    arguments, or the body of the function have not yet been parsed,
<span class="lineNum">   27798 </span>            :    parse them now.  */
<a name="27799"><span class="lineNum">   27799 </span><span class="lineCov">          8 : </span></a>
<span class="lineNum">   27800 </span><span class="lineCov">          8 : static void</span>
<span class="lineNum">   27801 </span><span class="lineCov">          4 : cp_parser_late_parsing_for_member (cp_parser* parser, tree member_function)</span>
<span class="lineNum">   27802 </span><span class="lineCov">          4 : {</span>
<span class="lineNum">   27803 </span>            :   timevar_push (TV_PARSE_INMETH);
<span class="lineNum">   27804 </span>            :   /* If this member is a template, get the underlying
<span class="lineNum">   27805 </span><span class="lineCov">          4 :      FUNCTION_DECL.  */</span>
<span class="lineNum">   27806 </span>            :   if (DECL_FUNCTION_TEMPLATE_P (member_function))
<span class="lineNum">   27807 </span>            :     member_function = DECL_TEMPLATE_RESULT (member_function);
<span class="lineNum">   27808 </span>            : 
<span class="lineNum">   27809 </span>            :   /* There should not be any class definitions in progress at this
<span class="lineNum">   27810 </span>            :      point; the bodies of members are only parsed outside of all class
<span class="lineNum">   27811 </span>            :      definitions.  */
<span class="lineNum">   27812 </span>            :   gcc_assert (parser-&gt;num_classes_being_defined == 0);
<span class="lineNum">   27813 </span><span class="lineCov">          1 :   /* While we're parsing the member functions we might encounter more</span>
<span class="lineNum">   27814 </span><span class="lineCov">          1 :      classes.  We want to handle them right away, but we don't want</span>
<span class="lineNum">   27815 </span>            :      them getting mixed up with functions that are currently in the
<span class="lineNum">   27816 </span>            :      queue.  */
<span class="lineNum">   27817 </span>            :   push_unparsed_function_queues (parser);
<span class="lineNum">   27818 </span>            : 
<span class="lineNum">   27819 </span>            :   /* Make sure that any template parameters are in scope.  */
<span class="lineNum">   27820 </span><span class="lineCov">    7960584 :   maybe_begin_member_template_processing (member_function);</span>
<span class="lineNum">   27821 </span>            : 
<span class="lineNum">   27822 </span><span class="lineCov">    8373304 :   /* If the body of the function has not yet been parsed, parse it</span>
<span class="lineNum">   27823 </span><span class="lineCov">    8373304 :      now.  */</span>
<span class="lineNum">   27824 </span>            :   if (DECL_PENDING_INLINE_P (member_function))
<span class="lineNum">   27825 </span><span class="lineCov">    8373304 :     {</span>
<span class="lineNum">   27826 </span><span class="lineCov">    8373304 :       tree function_scope;</span>
<span class="lineNum">   27827 </span><span class="lineCov">    8373304 :       cp_token_cache *tokens;</span>
<span class="lineNum">   27828 </span><span class="lineCov">    8373304 : </span>
<span class="lineNum">   27829 </span><span class="lineCov">    8373304 :       /* The function is no longer pending; we are processing it.  */</span>
<span class="lineNum">   27830 </span>            :       tokens = DECL_PENDING_INLINE_INFO (member_function);
<span class="lineNum">   27831 </span><span class="lineCov">    8373304 :       DECL_PENDING_INLINE_INFO (member_function) = NULL;</span>
<span class="lineNum">   27832 </span>            :       DECL_PENDING_INLINE_P (member_function) = 0;
<span class="lineNum">   27833 </span>            : 
<span class="lineNum">   27834 </span>            :       /* If this is a local class, enter the scope of the containing
<span class="lineNum">   27835 </span>            :          function.  */
<span class="lineNum">   27836 </span>            :       function_scope = current_function_decl;
<span class="lineNum">   27837 </span>            :       if (function_scope)
<span class="lineNum">   27838 </span>            :         push_function_context ();
<span class="lineNum">   27839 </span><span class="lineCov">    3784494 : </span>
<span class="lineNum">   27840 </span>            :       /* Push the body of the function onto the lexer stack.  */
<span class="lineNum">   27841 </span><span class="lineCov">    3784494 :       cp_parser_push_lexer_for_tokens (parser, tokens);</span>
<span class="lineNum">   27842 </span>            : 
<span class="lineNum">   27843 </span>            :       /* Let the front end know that we going to be defining this
<span class="lineNum">   27844 </span><span class="lineCov">    3784494 :          function.  */</span>
<span class="lineNum">   27845 </span>            :       start_preparsed_function (member_function, NULL_TREE,
<span class="lineNum">   27846 </span>            :                                 SF_PRE_PARSED | SF_INCLASS_INLINE);
<span class="lineNum">   27847 </span>            : 
<span class="lineNum">   27848 </span>            :       /* Don't do access checking if it is a templated function.  */
<span class="lineNum">   27849 </span>            :       if (processing_template_decl)
<span class="lineNum">   27850 </span><span class="lineCov">    3784494 :         push_deferring_access_checks (dk_no_check);</span>
<span class="lineNum">   27851 </span>            : 
<span class="lineNum">   27852 </span>            :       /* #pragma omp declare reduction needs special parsing.  */
<span class="lineNum">   27853 </span>            :       if (DECL_OMP_DECLARE_REDUCTION_P (member_function))
<span class="lineNum">   27854 </span>            :         {
<span class="lineNum">   27855 </span><span class="lineCov">    3784494 :           parser-&gt;lexer-&gt;in_pragma = true;</span>
<span class="lineNum">   27856 </span>            :           cp_parser_omp_declare_reduction_exprs (member_function, parser);
<span class="lineNum">   27857 </span>            :           finish_function (/*inline_p=*/true);
<span class="lineNum">   27858 </span><span class="lineCov">    3784494 :           cp_check_omp_declare_reduction (member_function);</span>
<span class="lineNum">   27859 </span>            :         }
<span class="lineNum">   27860 </span>            :       else
<span class="lineNum">   27861 </span>            :         /* Now, parse the body of the function.  */
<span class="lineNum">   27862 </span><span class="lineCov">    3784494 :         cp_parser_function_definition_after_declarator (parser,</span>
<span class="lineNum">   27863 </span>            :                                                         /*inline_p=*/true);
<span class="lineNum">   27864 </span><span class="lineCov">    3058415 : </span>
<span class="lineNum">   27865 </span><span class="lineCov">    3058415 :       if (processing_template_decl)</span>
<span class="lineNum">   27866 </span>            :         pop_deferring_access_checks ();
<span class="lineNum">   27867 </span>            : 
<span class="lineNum">   27868 </span><span class="lineCov">    6116830 :       /* Leave the scope of the containing function.  */</span>
<span class="lineNum">   27869 </span><span class="lineCov">    6116830 :       if (function_scope)</span>
<span class="lineNum">   27870 </span><span class="lineCov">    3058415 :         pop_function_context ();</span>
<span class="lineNum">   27871 </span>            :       cp_parser_pop_lexer (parser);
<span class="lineNum">   27872 </span>            :     }
<span class="lineNum">   27873 </span>            : 
<span class="lineNum">   27874 </span><span class="lineCov">    3058415 :   /* Remove any template parameters from the symbol table.  */</span>
<span class="lineNum">   27875 </span><span class="lineCov">    3058415 :   maybe_end_member_template_processing ();</span>
<span class="lineNum">   27876 </span><span class="lineCov">      11892 : </span>
<span class="lineNum">   27877 </span>            :   /* Restore the queue.  */
<span class="lineNum">   27878 </span>            :   pop_unparsed_function_queues (parser);
<span class="lineNum">   27879 </span><span class="lineCov">    3058415 :   timevar_pop (TV_PARSE_INMETH);</span>
<span class="lineNum">   27880 </span>            : }
<span class="lineNum">   27881 </span>            : 
<span class="lineNum">   27882 </span>            : /* If DECL contains any default args, remember it on the unparsed
<span class="lineNum">   27883 </span><span class="lineCov">    3058415 :    functions queue.  */</span>
<a name="27884"><span class="lineNum">   27884 </span>            : </a>
<span class="lineNum">   27885 </span>            : static void
<span class="lineNum">   27886 </span>            : cp_parser_save_default_args (cp_parser* parser, tree decl)
<span class="lineNum">   27887 </span><span class="lineCov">    3058415 : {</span>
<span class="lineNum">   27888 </span><span class="lineCov">    2297740 :   tree probe;</span>
<span class="lineNum">   27889 </span>            : 
<span class="lineNum">   27890 </span>            :   for (probe = TYPE_ARG_TYPES (TREE_TYPE (decl));
<span class="lineNum">   27891 </span><span class="lineCov">    3058415 :        probe;</span>
<span class="lineNum">   27892 </span>            :        probe = TREE_CHAIN (probe))
<span class="lineNum">   27893 </span><span class="lineCov">        169 :     if (TREE_PURPOSE (probe))</span>
<span class="lineNum">   27894 </span><span class="lineCov">        169 :       {</span>
<span class="lineNum">   27895 </span><span class="lineCov">        169 :         cp_default_arg_entry entry = {current_class_type, decl};</span>
<span class="lineNum">   27896 </span><span class="lineCov">        169 :         vec_safe_push (unparsed_funs_with_default_args, entry);</span>
<span class="lineNum">   27897 </span>            :         break;
<span class="lineNum">   27898 </span>            :       }
<span class="lineNum">   27899 </span>            : }
<span class="lineNum">   27900 </span><span class="lineCov">    3058246 : </span>
<span class="lineNum">   27901 </span>            : /* DEFAULT_ARG contains the saved tokens for the initializer of DECL,
<span class="lineNum">   27902 </span>            :    which is either a FIELD_DECL or PARM_DECL.  Parse it and return
<span class="lineNum">   27903 </span><span class="lineCov">    3058415 :    the result.  For a PARM_DECL, PARMTYPE is the corresponding type</span>
<span class="lineNum">   27904 </span><span class="lineCov">    2297740 :    from the parameter-type-list.  */</span>
<a name="27905"><span class="lineNum">   27905 </span>            : </a>
<span class="lineNum">   27906 </span>            : static tree
<span class="lineNum">   27907 </span><span class="lineCov">    3058415 : cp_parser_late_parse_one_default_arg (cp_parser *parser, tree decl,</span>
<span class="lineNum">   27908 </span><span class="lineCov">      11892 :                                       tree default_arg, tree parmtype)</span>
<span class="lineNum">   27909 </span><span class="lineCov">    3058415 : {</span>
<span class="lineNum">   27910 </span>            :   cp_token_cache *tokens;
<span class="lineNum">   27911 </span>            :   tree parsed_arg;
<span class="lineNum">   27912 </span>            :   bool dummy;
<span class="lineNum">   27913 </span><span class="lineCov">    3784494 : </span>
<span class="lineNum">   27914 </span>            :   if (default_arg == error_mark_node)
<span class="lineNum">   27915 </span>            :     return error_mark_node;
<span class="lineNum">   27916 </span><span class="lineCov">    3784494 : </span>
<span class="lineNum">   27917 </span><span class="lineCov">    3784494 :   /* Push the saved tokens for the default argument onto the parser's</span>
<span class="lineNum">   27918 </span><span class="lineCov">    3784494 :      lexer stack.  */</span>
<span class="lineNum">   27919 </span>            :   tokens = DEFARG_TOKENS (default_arg);
<span class="lineNum">   27920 </span>            :   cp_parser_push_lexer_for_tokens (parser, tokens);
<span class="lineNum">   27921 </span>            : 
<span class="lineNum">   27922 </span>            :   start_lambda_scope (decl);
<span class="lineNum">   27923 </span>            : 
<span class="lineNum">   27924 </span><span class="lineCov">    4247161 :   /* Parse the default argument.  */</span>
<span class="lineNum">   27925 </span>            :   parsed_arg = cp_parser_initializer (parser, &amp;dummy, &amp;dummy);
<span class="lineNum">   27926 </span><span class="lineCov">    4247161 :   if (BRACE_ENCLOSED_INITIALIZER_P (parsed_arg))</span>
<span class="lineNum">   27927 </span>            :     maybe_warn_cpp0x (CPP0X_INITIALIZER_LISTS);
<span class="lineNum">   27928 </span><span class="lineCov">    7635307 : </span>
<span class="lineNum">   27929 </span><span class="lineCov">   16278579 :   finish_lambda_scope ();</span>
<span class="lineNum">   27930 </span><span class="lineCov">   12031418 : </span>
<span class="lineNum">   27931 </span><span class="lineCov">   12242361 :   if (parsed_arg == error_mark_node)</span>
<span class="lineNum">   27932 </span>            :     cp_parser_skip_to_end_of_statement (parser);
<span class="lineNum">   27933 </span><span class="lineCov">     210943 : </span>
<span class="lineNum">   27934 </span><span class="lineCov">     210943 :   if (!processing_template_decl)</span>
<span class="lineNum">   27935 </span><span class="lineCov">     210943 :     {</span>
<span class="lineNum">   27936 </span>            :       /* In a non-template class, check conversions now.  In a template,
<span class="lineNum">   27937 </span><span class="lineCov">    4247161 :          we'll wait and instantiate these as needed.  */</span>
<span class="lineNum">   27938 </span>            :       if (TREE_CODE (decl) == PARM_DECL)
<span class="lineNum">   27939 </span>            :         parsed_arg = check_default_argument (parmtype, parsed_arg,
<span class="lineNum">   27940 </span>            :                                              tf_warning_or_error);
<span class="lineNum">   27941 </span>            :       else if (maybe_reject_flexarray_init (decl, parsed_arg))
<span class="lineNum">   27942 </span>            :         parsed_arg = error_mark_node;
<span class="lineNum">   27943 </span>            :       else
<span class="lineNum">   27944 </span>            :         parsed_arg = digest_nsdmi_init (decl, parsed_arg, tf_warning_or_error);
<span class="lineNum">   27945 </span><span class="lineCov">     256498 :     }</span>
<span class="lineNum">   27946 </span>            : 
<span class="lineNum">   27947 </span>            :   /* If the token stream has not been completely used up, then
<span class="lineNum">   27948 </span><span class="lineCov">     256498 :      there was extra junk after the end of the default</span>
<span class="lineNum">   27949 </span><span class="lineCov">     256498 :      argument.  */</span>
<span class="lineNum">   27950 </span><span class="lineCov">     256498 :   if (!cp_lexer_next_token_is (parser-&gt;lexer, CPP_EOF))</span>
<span class="lineNum">   27951 </span>            :     {
<span class="lineNum">   27952 </span><span class="lineCov">     256498 :       if (TREE_CODE (decl) == PARM_DECL)</span>
<span class="lineNum">   27953 </span>            :         cp_parser_error (parser, &quot;expected %&lt;,%&gt;&quot;);
<span class="lineNum">   27954 </span>            :       else
<span class="lineNum">   27955 </span>            :         cp_parser_error (parser, &quot;expected %&lt;;%&gt;&quot;);
<span class="lineNum">   27956 </span>            :     }
<span class="lineNum">   27957 </span><span class="lineCov">     256489 : </span>
<span class="lineNum">   27958 </span><span class="lineCov">     256489 :   /* Revert to the main lexer.  */</span>
<span class="lineNum">   27959 </span>            :   cp_parser_pop_lexer (parser);
<span class="lineNum">   27960 </span><span class="lineCov">     256489 : </span>
<span class="lineNum">   27961 </span>            :   return parsed_arg;
<span class="lineNum">   27962 </span>            : }
<span class="lineNum">   27963 </span><span class="lineCov">     256489 : </span>
<span class="lineNum">   27964 </span><span class="lineCov">     256489 : /* FIELD is a non-static data member with an initializer which we saved for</span>
<span class="lineNum">   27965 </span><span class="lineCov">       3508 :    later; parse it now.  */</span>
<a name="27966"><span class="lineNum">   27966 </span>            : </a>
<span class="lineNum">   27967 </span><span class="lineCov">     256489 : static void</span>
<span class="lineNum">   27968 </span>            : cp_parser_late_parsing_nsdmi (cp_parser *parser, tree field)
<span class="lineNum">   27969 </span><span class="lineCov">     256489 : {</span>
<span class="lineNum">   27970 </span><span class="lineCov">         79 :   tree def;</span>
<span class="lineNum">   27971 </span>            : 
<span class="lineNum">   27972 </span><span class="lineCov">     256489 :   maybe_begin_member_template_processing (field);</span>
<span class="lineNum">   27973 </span>            : 
<span class="lineNum">   27974 </span>            :   push_unparsed_function_queues (parser);
<span class="lineNum">   27975 </span>            :   def = cp_parser_late_parse_one_default_arg (parser, field,
<span class="lineNum">   27976 </span><span class="lineCov">      48630 :                                               DECL_INITIAL (field),</span>
<span class="lineNum">   27977 </span><span class="lineCov">      43669 :                                               NULL_TREE);</span>
<span class="lineNum">   27978 </span>            :   pop_unparsed_function_queues (parser);
<span class="lineNum">   27979 </span><span class="lineCov">       4961 : </span>
<span class="lineNum">   27980 </span><span class="lineCov">         17 :   maybe_end_member_template_processing ();</span>
<span class="lineNum">   27981 </span>            : 
<span class="lineNum">   27982 </span><span class="lineCov">       4944 :   DECL_INITIAL (field) = def;</span>
<span class="lineNum">   27983 </span>            : }
<span class="lineNum">   27984 </span>            : 
<span class="lineNum">   27985 </span>            : /* FN is a FUNCTION_DECL which may contains a parameter with an
<span class="lineNum">   27986 </span>            :    unparsed DEFAULT_ARG.  Parse the default args now.  This function
<span class="lineNum">   27987 </span>            :    assumes that the current scope is the scope in which the default
<span class="lineNum">   27988 </span><span class="lineCov">     256489 :    argument should be processed.  */</span>
<a name="27989"><span class="lineNum">   27989 </span>            : </a>
<span class="lineNum">   27990 </span><span class="lineCov">          5 : static void</span>
<span class="lineNum">   27991 </span><span class="lineCov">          3 : cp_parser_late_parsing_default_args (cp_parser *parser, tree fn)</span>
<span class="lineNum">   27992 </span>            : {
<span class="lineNum">   27993 </span><span class="lineCov">          2 :   bool saved_local_variables_forbidden_p;</span>
<span class="lineNum">   27994 </span>            :   tree parm, parmdecl;
<span class="lineNum">   27995 </span>            : 
<span class="lineNum">   27996 </span>            :   /* While we're parsing the default args, we might (due to the
<span class="lineNum">   27997 </span><span class="lineCov">     256489 :      statement expression extension) encounter more classes.  We want</span>
<span class="lineNum">   27998 </span>            :      to handle them right away, but we don't want them getting mixed
<span class="lineNum">   27999 </span><span class="lineCov">     256489 :      up with default args that are currently in the queue.  */</span>
<span class="lineNum">   28000 </span>            :   push_unparsed_function_queues (parser);
<span class="lineNum">   28001 </span>            : 
<span class="lineNum">   28002 </span>            :   /* Local variable names (and the `this' keyword) may not appear
<span class="lineNum">   28003 </span>            :      in a default argument.  */
<span class="lineNum">   28004 </span>            :   saved_local_variables_forbidden_p = parser-&gt;local_variables_forbidden_p;
<span class="lineNum">   28005 </span>            :   parser-&gt;local_variables_forbidden_p = true;
<span class="lineNum">   28006 </span><span class="lineCov">       8270 : </span>
<span class="lineNum">   28007 </span>            :   push_defarg_context (fn);
<span class="lineNum">   28008 </span><span class="lineCov">       8270 : </span>
<span class="lineNum">   28009 </span>            :   for (parm = TYPE_ARG_TYPES (TREE_TYPE (fn)),
<span class="lineNum">   28010 </span><span class="lineCov">       8270 :          parmdecl = DECL_ARGUMENTS (fn);</span>
<span class="lineNum">   28011 </span>            :        parm &amp;&amp; parm != void_list_node;
<span class="lineNum">   28012 </span><span class="lineCov">       8270 :        parm = TREE_CHAIN (parm),</span>
<span class="lineNum">   28013 </span><span class="lineCov">      24810 :          parmdecl = DECL_CHAIN (parmdecl))</span>
<span class="lineNum">   28014 </span><span class="lineCov">       8270 :     {</span>
<span class="lineNum">   28015 </span>            :       tree default_arg = TREE_PURPOSE (parm);
<span class="lineNum">   28016 </span><span class="lineCov">       8270 :       tree parsed_arg;</span>
<span class="lineNum">   28017 </span>            :       vec&lt;tree, va_gc&gt; *insts;
<span class="lineNum">   28018 </span><span class="lineCov">       8270 :       tree copy;</span>
<span class="lineNum">   28019 </span>            :       unsigned ix;
<span class="lineNum">   28020 </span><span class="lineCov">       8270 : </span>
<span class="lineNum">   28021 </span><span class="lineCov">       8270 :       if (!default_arg)</span>
<span class="lineNum">   28022 </span>            :         continue;
<span class="lineNum">   28023 </span>            : 
<span class="lineNum">   28024 </span>            :       if (TREE_CODE (default_arg) != DEFAULT_ARG)
<span class="lineNum">   28025 </span>            :         /* This can happen for a friend declaration for a function
<span class="lineNum">   28026 </span>            :            already declared with default arguments.  */
<span class="lineNum">   28027 </span>            :         continue;
<span class="lineNum">   28028 </span>            : 
<span class="lineNum">   28029 </span><span class="lineCov">     210943 :       parsed_arg</span>
<span class="lineNum">   28030 </span>            :         = cp_parser_late_parse_one_default_arg (parser, parmdecl,
<span class="lineNum">   28031 </span><span class="lineCov">     210943 :                                                 default_arg,</span>
<span class="lineNum">   28032 </span><span class="lineCov">     210943 :                                                 TREE_VALUE (parm));</span>
<span class="lineNum">   28033 </span>            :       TREE_PURPOSE (parm) = parsed_arg;
<span class="lineNum">   28034 </span>            : 
<span class="lineNum">   28035 </span>            :       /* Update any instantiations we've already created.  */
<span class="lineNum">   28036 </span>            :       for (insts = DEFARG_INSTANTIATIONS (default_arg), ix = 0;
<span class="lineNum">   28037 </span>            :            vec_safe_iterate (insts, ix, &amp;copy); ix++)
<span class="lineNum">   28038 </span><span class="lineCov">     210943 :         TREE_PURPOSE (copy) = parsed_arg;</span>
<span class="lineNum">   28039 </span>            :     }
<span class="lineNum">   28040 </span>            : 
<span class="lineNum">   28041 </span>            :   pop_defarg_context ();
<span class="lineNum">   28042 </span><span class="lineCov">     210943 : </span>
<span class="lineNum">   28043 </span><span class="lineCov">     210943 :   /* Make sure no default arg is missing.  */</span>
<span class="lineNum">   28044 </span>            :   check_default_args (fn);
<span class="lineNum">   28045 </span><span class="lineCov">     210943 : </span>
<span class="lineNum">   28046 </span>            :   /* Restore the state of local_variables_forbidden_p.  */
<span class="lineNum">   28047 </span><span class="lineCov">     210943 :   parser-&gt;local_variables_forbidden_p = saved_local_variables_forbidden_p;</span>
<span class="lineNum">   28048 </span><span class="lineCov">     210943 : </span>
<span class="lineNum">   28049 </span><span class="lineCov">     880969 :   /* Restore the queue.  */</span>
<span class="lineNum">   28050 </span><span class="lineCov">     670026 :   pop_unparsed_function_queues (parser);</span>
<span class="lineNum">   28051 </span><span class="lineCov">     670026 : }</span>
<span class="lineNum">   28052 </span>            : 
<span class="lineNum">   28053 </span><span class="lineCov">     670026 : /* Subroutine of cp_parser_sizeof_operand, for handling C++11</span>
<span class="lineNum">   28054 </span><span class="lineCov">     670026 : </span>
<span class="lineNum">   28055 </span><span class="lineCov">     670026 :      sizeof ... ( identifier )</span>
<span class="lineNum">   28056 </span><span class="lineCov">     670026 : </span>
<span class="lineNum">   28057 </span><span class="lineCov">     670026 :    where the 'sizeof' token has already been consumed.  */</span>
<a name="28058"><span class="lineNum">   28058 </span>            : </a>
<span class="lineNum">   28059 </span><span class="lineCov">     670026 : static tree</span>
<span class="lineNum">   28060 </span>            : cp_parser_sizeof_pack (cp_parser *parser)
<span class="lineNum">   28061 </span>            : {
<span class="lineNum">   28062 </span><span class="lineCov">     248255 :   /* Consume the `...'.  */</span>
<span class="lineNum">   28063 </span>            :   cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   28064 </span>            :   maybe_warn_variadic_templates ();
<span class="lineNum">   28065 </span>            : 
<span class="lineNum">   28066 </span>            :   matching_parens parens;
<span class="lineNum">   28067 </span><span class="lineCov">     248228 :   bool paren = cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_PAREN);</span>
<span class="lineNum">   28068 </span><span class="lineCov">     496456 :   if (paren)</span>
<span class="lineNum">   28069 </span>            :     parens.consume_open (parser);
<span class="lineNum">   28070 </span><span class="lineCov">     496456 :   else</span>
<span class="lineNum">   28071 </span><span class="lineCov">     248228 :     permerror (cp_lexer_peek_token (parser-&gt;lexer)-&gt;location,</span>
<span class="lineNum">   28072 </span>            :                &quot;%&lt;sizeof...%&gt; argument must be surrounded by parentheses&quot;);
<span class="lineNum">   28073 </span>            : 
<span class="lineNum">   28074 </span><span class="lineCov">     248228 :   cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   28075 </span><span class="lineCov">     248231 :   tree name = cp_parser_identifier (parser);</span>
<span class="lineNum">   28076 </span><span class="lineCov">          3 :   if (name == error_mark_node)</span>
<span class="lineNum">   28077 </span>            :     return error_mark_node;
<span class="lineNum">   28078 </span>            :   /* The name is not qualified.  */
<span class="lineNum">   28079 </span><span class="lineCov">     210943 :   parser-&gt;scope = NULL_TREE;</span>
<span class="lineNum">   28080 </span>            :   parser-&gt;qualifying_scope = NULL_TREE;
<span class="lineNum">   28081 </span>            :   parser-&gt;object_scope = NULL_TREE;
<span class="lineNum">   28082 </span><span class="lineCov">     210943 :   tree expr = cp_parser_lookup_name_simple (parser, name, token-&gt;location);</span>
<span class="lineNum">   28083 </span>            :   if (expr == error_mark_node)
<span class="lineNum">   28084 </span>            :     cp_parser_name_lookup_error (parser, name, expr, NLE_NULL,
<span class="lineNum">   28085 </span><span class="lineCov">     210943 :                                  token-&gt;location);</span>
<span class="lineNum">   28086 </span>            :   if (TREE_CODE (expr) == TYPE_DECL || TREE_CODE (expr) == TEMPLATE_DECL)
<span class="lineNum">   28087 </span>            :     expr = TREE_TYPE (expr);
<span class="lineNum">   28088 </span><span class="lineCov">     210943 :   else if (TREE_CODE (expr) == CONST_DECL)</span>
<span class="lineNum">   28089 </span><span class="lineCov">     210943 :     expr = DECL_INITIAL (expr);</span>
<span class="lineNum">   28090 </span>            :   expr = make_pack_expansion (expr);
<span class="lineNum">   28091 </span>            :   PACK_EXPANSION_SIZEOF_P (expr) = true;
<span class="lineNum">   28092 </span>            : 
<span class="lineNum">   28093 </span>            :   if (paren)
<span class="lineNum">   28094 </span>            :     parens.require_close (parser);
<span class="lineNum">   28095 </span>            : 
<span class="lineNum">   28096 </span>            :   return expr;
<span class="lineNum">   28097 </span>            : }
<span class="lineNum">   28098 </span><span class="lineCov">      29160 : </span>
<span class="lineNum">   28099 </span>            : /* Parse the operand of `sizeof' (or a similar operator).  Returns
<span class="lineNum">   28100 </span>            :    either a TYPE or an expression, depending on the form of the
<span class="lineNum">   28101 </span><span class="lineCov">      29160 :    input.  The KEYWORD indicates which kind of expression we have</span>
<span class="lineNum">   28102 </span><span class="lineCov">      29160 :    encountered.  */</span>
<a name="28103"><span class="lineNum">   28103 </span>            : </a>
<span class="lineNum">   28104 </span><span class="lineCov">      58320 : static tree</span>
<span class="lineNum">   28105 </span><span class="lineCov">      58320 : cp_parser_sizeof_operand (cp_parser* parser, enum rid keyword)</span>
<span class="lineNum">   28106 </span><span class="lineCov">      29160 : {</span>
<span class="lineNum">   28107 </span><span class="lineCov">      29156 :   tree expr = NULL_TREE;</span>
<span class="lineNum">   28108 </span>            :   const char *saved_message;
<span class="lineNum">   28109 </span><span class="lineCov">          4 :   char *tmp;</span>
<span class="lineNum">   28110 </span>            :   bool saved_integral_constant_expression_p;
<span class="lineNum">   28111 </span>            :   bool saved_non_integral_constant_expression_p;
<span class="lineNum">   28112 </span><span class="lineCov">      58320 : </span>
<span class="lineNum">   28113 </span><span class="lineCov">      29160 :   /* If it's a `...', then we are computing the length of a parameter</span>
<span class="lineNum">   28114 </span><span class="lineCov">      29160 :      pack.  */</span>
<span class="lineNum">   28115 </span>            :   if (keyword == RID_SIZEOF
<span class="lineNum">   28116 </span>            :       &amp;&amp; cp_lexer_next_token_is (parser-&gt;lexer, CPP_ELLIPSIS))
<span class="lineNum">   28117 </span><span class="lineCov">      29160 :     return cp_parser_sizeof_pack (parser);</span>
<span class="lineNum">   28118 </span><span class="lineCov">      29160 : </span>
<span class="lineNum">   28119 </span><span class="lineCov">      29160 :   /* Types cannot be defined in a `sizeof' expression.  Save away the</span>
<span class="lineNum">   28120 </span><span class="lineCov">      29160 :      old message.  */</span>
<span class="lineNum">   28121 </span><span class="lineCov">      29160 :   saved_message = parser-&gt;type_definition_forbidden_message;</span>
<span class="lineNum">   28122 </span><span class="lineNoCov">          0 :   /* And create the new one.  */</span>
<span class="lineNum">   28123 </span>            :   tmp = concat (&quot;types may not be defined in %&lt;&quot;,
<span class="lineNum">   28124 </span><span class="lineCov">      29160 :                 IDENTIFIER_POINTER (ridpointers[keyword]),</span>
<span class="lineNum">   28125 </span><span class="lineCov">      27863 :                 &quot;%&gt; expressions&quot;, NULL);</span>
<span class="lineNum">   28126 </span><span class="lineCov">       1297 :   parser-&gt;type_definition_forbidden_message = tmp;</span>
<span class="lineNum">   28127 </span><span class="lineCov">       1286 : </span>
<span class="lineNum">   28128 </span><span class="lineCov">      29160 :   /* The restrictions on constant-expressions do not apply inside</span>
<span class="lineNum">   28129 </span><span class="lineCov">      29160 :      sizeof expressions.  */</span>
<span class="lineNum">   28130 </span>            :   saved_integral_constant_expression_p
<span class="lineNum">   28131 </span><span class="lineCov">      29160 :     = parser-&gt;integral_constant_expression_p;</span>
<span class="lineNum">   28132 </span><span class="lineCov">      29156 :   saved_non_integral_constant_expression_p</span>
<span class="lineNum">   28133 </span>            :     = parser-&gt;non_integral_constant_expression_p;
<span class="lineNum">   28134 </span>            :   parser-&gt;integral_constant_expression_p = false;
<span class="lineNum">   28135 </span>            : 
<span class="lineNum">   28136 </span>            :   /* Do not actually evaluate the expression.  */
<span class="lineNum">   28137 </span>            :   ++cp_unevaluated_operand;
<span class="lineNum">   28138 </span>            :   ++c_inhibit_evaluation_warnings;
<span class="lineNum">   28139 </span>            :   /* If it's a `(', then we might be looking at the type-id
<span class="lineNum">   28140 </span>            :      construction.  */
<span class="lineNum">   28141 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_PAREN))
<span class="lineNum">   28142 </span>            :     {
<span class="lineNum">   28143 </span><span class="lineCov">     470351 :       tree type = NULL_TREE;</span>
<span class="lineNum">   28144 </span>            : 
<span class="lineNum">   28145 </span><span class="lineCov">     470351 :       /* We can't be sure yet whether we're looking at a type-id or an</span>
<span class="lineNum">   28146 </span><span class="lineCov">     470351 :          expression.  */</span>
<span class="lineNum">   28147 </span><span class="lineCov">     470351 :       cp_parser_parse_tentatively (parser);</span>
<span class="lineNum">   28148 </span><span class="lineCov">     470351 : </span>
<span class="lineNum">   28149 </span><span class="lineCov">     470351 :       matching_parens parens;</span>
<span class="lineNum">   28150 </span>            :       parens.consume_open (parser);
<span class="lineNum">   28151 </span>            : 
<span class="lineNum">   28152 </span>            :       /* Note: as a GNU Extension, compound literals are considered
<span class="lineNum">   28153 </span><span class="lineCov">     470351 :          postfix-expressions as they are in C99, so they are valid</span>
<span class="lineNum">   28154 </span><span class="lineCov">     470351 :          arguments to sizeof.  See comment in cp_parser_cast_expression</span>
<span class="lineNum">   28155 </span><span class="lineCov">      29160 :          for details.  */</span>
<span class="lineNum">   28156 </span>            :       if (cp_parser_compound_literal_p (parser))
<span class="lineNum">   28157 </span>            :         cp_parser_simulate_error (parser);
<span class="lineNum">   28158 </span>            :       else
<span class="lineNum">   28159 </span><span class="lineCov">     441191 :         {</span>
<span class="lineNum">   28160 </span>            :           bool saved_in_type_id_in_expr_p = parser-&gt;in_type_id_in_expr_p;
<span class="lineNum">   28161 </span><span class="lineCov">    1323573 :           parser-&gt;in_type_id_in_expr_p = true;</span>
<span class="lineNum">   28162 </span><span class="lineCov">     441191 :           /* Look for the type-id.  */</span>
<span class="lineNum">   28163 </span>            :           type = cp_parser_type_id (parser);
<span class="lineNum">   28164 </span><span class="lineCov">     441191 :           /* Look for the closing `)'.  */</span>
<span class="lineNum">   28165 </span>            :           parens.require_close (parser);
<span class="lineNum">   28166 </span>            :           parser-&gt;in_type_id_in_expr_p = saved_in_type_id_in_expr_p;
<span class="lineNum">   28167 </span>            :         }
<span class="lineNum">   28168 </span><span class="lineCov">     441191 : </span>
<span class="lineNum">   28169 </span><span class="lineCov">     441191 :       /* If all went well, then we're done.  */</span>
<span class="lineNum">   28170 </span><span class="lineCov">     441191 :       if (cp_parser_parse_definitely (parser))</span>
<span class="lineNum">   28171 </span><span class="lineCov">     441191 :         {</span>
<span class="lineNum">   28172 </span><span class="lineCov">     441191 :           cp_decl_specifier_seq decl_specs;</span>
<span class="lineNum">   28173 </span>            : 
<span class="lineNum">   28174 </span>            :           /* Build a trivial decl-specifier-seq.  */
<span class="lineNum">   28175 </span><span class="lineCov">     441191 :           clear_decl_specs (&amp;decl_specs);</span>
<span class="lineNum">   28176 </span><span class="lineCov">     441191 :           decl_specs.type = type;</span>
<span class="lineNum">   28177 </span>            : 
<span class="lineNum">   28178 </span>            :           /* Call grokdeclarator to figure out what type this is.  */
<span class="lineNum">   28179 </span><span class="lineCov">     441191 :           expr = grokdeclarator (NULL,</span>
<span class="lineNum">   28180 </span>            :                                  &amp;decl_specs,
<span class="lineNum">   28181 </span><span class="lineCov">     437721 :                                  TYPENAME,</span>
<span class="lineNum">   28182 </span>            :                                  /*initialized=*/0,
<span class="lineNum">   28183 </span>            :                                  /*attrlist=*/NULL);
<span class="lineNum">   28184 </span>            :         }
<span class="lineNum">   28185 </span><span class="lineCov">     437721 :     }</span>
<span class="lineNum">   28186 </span>            : 
<span class="lineNum">   28187 </span><span class="lineCov">     875442 :   /* If the type-id production did not work out, then we must be</span>
<span class="lineNum">   28188 </span><span class="lineCov">     437721 :      looking at the unary-expression production.  */</span>
<span class="lineNum">   28189 </span>            :   if (!expr)
<span class="lineNum">   28190 </span>            :     expr = cp_parser_unary_expression (parser);
<span class="lineNum">   28191 </span>            : 
<span class="lineNum">   28192 </span>            :   /* Go back to evaluating expressions.  */
<span class="lineNum">   28193 </span>            :   --cp_unevaluated_operand;
<span class="lineNum">   28194 </span><span class="lineCov">     437721 :   --c_inhibit_evaluation_warnings;</span>
<span class="lineNum">   28195 </span><span class="lineCov">         21 : </span>
<span class="lineNum">   28196 </span>            :   /* Free the message we created.  */
<span class="lineNum">   28197 </span>            :   free (tmp);
<span class="lineNum">   28198 </span><span class="lineCov">     437700 :   /* And restore the old one.  */</span>
<span class="lineNum">   28199 </span><span class="lineCov">     437700 :   parser-&gt;type_definition_forbidden_message = saved_message;</span>
<span class="lineNum">   28200 </span>            :   parser-&gt;integral_constant_expression_p
<span class="lineNum">   28201 </span><span class="lineCov">     437700 :     = saved_integral_constant_expression_p;</span>
<span class="lineNum">   28202 </span>            :   parser-&gt;non_integral_constant_expression_p
<span class="lineNum">   28203 </span><span class="lineCov">     437700 :     = saved_non_integral_constant_expression_p;</span>
<span class="lineNum">   28204 </span><span class="lineCov">     437700 : </span>
<span class="lineNum">   28205 </span>            :   return expr;
<span class="lineNum">   28206 </span>            : }
<span class="lineNum">   28207 </span>            : 
<span class="lineNum">   28208 </span><span class="lineCov">     437721 : /* If the current declaration has no declarator, return true.  */</span>
<a name="28209"><span class="lineNum">   28209 </span>            : </a>
<span class="lineNum">   28210 </span><span class="lineCov">     233429 : static bool</span>
<span class="lineNum">   28211 </span>            : cp_parser_declares_only_class_p (cp_parser *parser)
<span class="lineNum">   28212 </span>            : {
<span class="lineNum">   28213 </span><span class="lineCov">     466858 :   /* If the next token is a `;' or a `,' then there is no</span>
<span class="lineNum">   28214 </span><span class="lineCov">     233429 :      declarator.  */</span>
<span class="lineNum">   28215 </span>            :   return (cp_lexer_next_token_is (parser-&gt;lexer, CPP_SEMICOLON)
<span class="lineNum">   28216 </span>            :           || cp_lexer_next_token_is (parser-&gt;lexer, CPP_COMMA));
<span class="lineNum">   28217 </span><span class="lineCov">     233429 : }</span>
<span class="lineNum">   28218 </span>            : 
<span class="lineNum">   28219 </span>            : /* Update the DECL_SPECS to reflect the storage class indicated by
<span class="lineNum">   28220 </span>            :    KEYWORD.  */
<a name="28221"><span class="lineNum">   28221 </span>            : </a>
<span class="lineNum">   28222 </span>            : static void
<span class="lineNum">   28223 </span>            : cp_parser_set_storage_class (cp_parser *parser,
<span class="lineNum">   28224 </span>            :                              cp_decl_specifier_seq *decl_specs,
<span class="lineNum">   28225 </span>            :                              enum rid keyword,
<span class="lineNum">   28226 </span>            :                              cp_token *token)
<span class="lineNum">   28227 </span><span class="lineCov">     437721 : {</span>
<span class="lineNum">   28228 </span><span class="lineCov">     207762 :   cp_storage_class storage_class;</span>
<span class="lineNum">   28229 </span>            : 
<span class="lineNum">   28230 </span>            :   if (parser-&gt;in_unbraced_linkage_specification_p)
<span class="lineNum">   28231 </span><span class="lineCov">     441191 :     {</span>
<span class="lineNum">   28232 </span><span class="lineCov">     441191 :       error_at (token-&gt;location, &quot;invalid use of %qD in linkage specification&quot;,</span>
<span class="lineNum">   28233 </span>            :                 ridpointers[keyword]);
<span class="lineNum">   28234 </span>            :       return;
<span class="lineNum">   28235 </span><span class="lineCov">     441191 :     }</span>
<span class="lineNum">   28236 </span>            :   else if (decl_specs-&gt;storage_class != sc_none)
<span class="lineNum">   28237 </span><span class="lineCov">     441191 :     {</span>
<span class="lineNum">   28238 </span><span class="lineCov">     441191 :       decl_specs-&gt;conflicting_specifiers_p = true;</span>
<span class="lineNum">   28239 </span><span class="lineCov">     441191 :       return;</span>
<span class="lineNum">   28240 </span><span class="lineCov">     441191 :     }</span>
<span class="lineNum">   28241 </span><span class="lineCov">     441191 : </span>
<span class="lineNum">   28242 </span>            :   if ((keyword == RID_EXTERN || keyword == RID_STATIC)
<span class="lineNum">   28243 </span><span class="lineCov">     441191 :       &amp;&amp; decl_spec_seq_has_spec_p (decl_specs, ds_thread)</span>
<span class="lineNum">   28244 </span>            :       &amp;&amp; decl_specs-&gt;gnu_thread_keyword_p)
<span class="lineNum">   28245 </span>            :     {
<span class="lineNum">   28246 </span>            :       pedwarn (decl_specs-&gt;locations[ds_thread], 0,
<span class="lineNum">   28247 </span>            :                 &quot;%&lt;__thread%&gt; before %qD&quot;, ridpointers[keyword]);
<span class="lineNum">   28248 </span>            :     }
<span class="lineNum">   28249 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   28250 </span>            :   switch (keyword)
<span class="lineNum">   28251 </span>            :     {
<span class="lineNum">   28252 </span>            :     case RID_AUTO:
<span class="lineNum">   28253 </span><span class="lineCov">    9790456 :       storage_class = sc_auto;</span>
<span class="lineNum">   28254 </span><span class="lineCov">    4895228 :       break;</span>
<span class="lineNum">   28255 </span>            :     case RID_REGISTER:
<span class="lineNum">   28256 </span>            :       storage_class = sc_register;
<span class="lineNum">   28257 </span>            :       break;
<span class="lineNum">   28258 </span>            :     case RID_STATIC:
<span class="lineNum">   28259 </span>            :       storage_class = sc_static;
<span class="lineNum">   28260 </span>            :       break;
<span class="lineNum">   28261 </span><span class="lineCov">    5399046 :     case RID_EXTERN:</span>
<span class="lineNum">   28262 </span>            :       storage_class = sc_extern;
<span class="lineNum">   28263 </span>            :       break;
<span class="lineNum">   28264 </span>            :     case RID_MUTABLE:
<span class="lineNum">   28265 </span>            :       storage_class = sc_mutable;
<span class="lineNum">   28266 </span><span class="lineCov">    5399046 :       break;</span>
<span class="lineNum">   28267 </span>            :     default:
<span class="lineNum">   28268 </span><span class="lineCov">    5399046 :       gcc_unreachable ();</span>
<span class="lineNum">   28269 </span>            :     }
<span class="lineNum">   28270 </span><span class="lineCov">         26 :   decl_specs-&gt;storage_class = storage_class;</span>
<span class="lineNum">   28271 </span><span class="lineCov">         13 :   set_and_check_decl_spec_loc (decl_specs, ds_storage_class, token);</span>
<span class="lineNum">   28272 </span><span class="lineCov">         13 : </span>
<span class="lineNum">   28273 </span>            :   /* A storage class specifier cannot be applied alongside a typedef 
<span class="lineNum">   28274 </span><span class="lineCov">    5399033 :      specifier. If there is a typedef specifier present then set </span>
<span class="lineNum">   28275 </span>            :      conflicting_specifiers_p which will trigger an error later
<span class="lineNum">   28276 </span><span class="lineCov">         10 :      on in grokdeclarator. */</span>
<span class="lineNum">   28277 </span><span class="lineCov">         10 :   if (decl_spec_seq_has_spec_p (decl_specs, ds_typedef))</span>
<span class="lineNum">   28278 </span>            :     decl_specs-&gt;conflicting_specifiers_p = true;
<span class="lineNum">   28279 </span>            : }
<span class="lineNum">   28280 </span><span class="lineCov">    5399023 : </span>
<span class="lineNum">   28281 </span><span class="lineCov">    5387701 : /* Update the DECL_SPECS to reflect the TYPE_SPEC.  If TYPE_DEFINITION_P</span>
<span class="lineNum">   28282 </span><span class="lineCov">    5399034 :    is true, the type is a class or enum definition.  */</span>
<a name="28283"><span class="lineNum">   28283 </span>            : </a>
<span class="lineNum">   28284 </span><span class="lineCov">         18 : static void</span>
<span class="lineNum">   28285 </span><span class="lineCov">          9 : cp_parser_set_decl_spec_type (cp_decl_specifier_seq *decl_specs,</span>
<span class="lineNum">   28286 </span>            :                               tree type_spec,
<span class="lineNum">   28287 </span>            :                               cp_token *token,
<span class="lineNum">   28288 </span><span class="lineCov">    5399023 :                               bool type_definition_p)</span>
<span class="lineNum">   28289 </span>            : {
<span class="lineNum">   28290 </span>            :   decl_specs-&gt;any_specifiers_p = true;
<span class="lineNum">   28291 </span>            : 
<span class="lineNum">   28292 </span>            :   /* If the user tries to redeclare bool, char16_t, char32_t, or wchar_t
<span class="lineNum">   28293 </span><span class="lineCov">        683 :      (with, for example, in &quot;typedef int wchar_t;&quot;) we remember that</span>
<span class="lineNum">   28294 </span><span class="lineCov">        683 :      this is what happened.  In system headers, we ignore these</span>
<span class="lineNum">   28295 </span><span class="lineCov">        683 :      declarations so that G++ can work with system headers that are not</span>
<span class="lineNum">   28296 </span><span class="lineCov">    1738641 :      C++-safe.  */</span>
<span class="lineNum">   28297 </span><span class="lineCov">    1738641 :   if (decl_spec_seq_has_spec_p (decl_specs, ds_typedef)</span>
<span class="lineNum">   28298 </span><span class="lineCov">    1738641 :       &amp;&amp; !type_definition_p</span>
<span class="lineNum">   28299 </span><span class="lineCov">    3649060 :       &amp;&amp; (type_spec == boolean_type_node</span>
<span class="lineNum">   28300 </span><span class="lineCov">    3649060 :           || type_spec == char16_type_node</span>
<span class="lineNum">   28301 </span><span class="lineCov">    3649060 :           || type_spec == char32_type_node</span>
<span class="lineNum">   28302 </span><span class="lineCov">      10624 :           || type_spec == wchar_type_node)</span>
<span class="lineNum">   28303 </span><span class="lineCov">      10624 :       &amp;&amp; (decl_specs-&gt;type</span>
<span class="lineNum">   28304 </span><span class="lineCov">      10624 :           || decl_spec_seq_has_spec_p (decl_specs, ds_long)</span>
<span class="lineNum">   28305 </span><span class="lineNoCov">          0 :           || decl_spec_seq_has_spec_p (decl_specs, ds_short)</span>
<span class="lineNum">   28306 </span><span class="lineNoCov">          0 :           || decl_spec_seq_has_spec_p (decl_specs, ds_unsigned)</span>
<span class="lineNum">   28307 </span>            :           || decl_spec_seq_has_spec_p (decl_specs, ds_signed)))
<span class="lineNum">   28308 </span><span class="lineCov">    5399023 :     {</span>
<span class="lineNum">   28309 </span><span class="lineCov">    5399023 :       decl_specs-&gt;redefined_builtin_type = type_spec;</span>
<span class="lineNum">   28310 </span>            :       set_and_check_decl_spec_loc (decl_specs,
<span class="lineNum">   28311 </span>            :                                    ds_redefined_builtin_type_spec,
<span class="lineNum">   28312 </span>            :                                    token);
<span class="lineNum">   28313 </span>            :       if (!decl_specs-&gt;type)
<span class="lineNum">   28314 </span>            :         {
<span class="lineNum">   28315 </span><span class="lineCov">    5399023 :           decl_specs-&gt;type = type_spec;</span>
<span class="lineNum">   28316 </span><span class="lineCov">         10 :           decl_specs-&gt;type_definition_p = false;</span>
<span class="lineNum">   28317 </span>            :           set_and_check_decl_spec_loc (decl_specs,ds_type_spec, token);
<span class="lineNum">   28318 </span>            :         }
<span class="lineNum">   28319 </span>            :     }
<span class="lineNum">   28320 </span>            :   else if (decl_specs-&gt;type)
<span class="lineNum">   28321 </span>            :     decl_specs-&gt;multiple_types_p = true;
<span class="lineNum">   28322 </span>            :   else
<span class="lineNum">   28323 </span><span class="lineCov">   54251909 :     {</span>
<span class="lineNum">   28324 </span>            :       decl_specs-&gt;type = type_spec;
<span class="lineNum">   28325 </span>            :       decl_specs-&gt;type_definition_p = type_definition_p;
<span class="lineNum">   28326 </span>            :       decl_specs-&gt;redefined_builtin_type = NULL_TREE;
<span class="lineNum">   28327 </span>            :       set_and_check_decl_spec_loc (decl_specs, ds_type_spec, token);
<span class="lineNum">   28328 </span><span class="lineCov">   54251909 :     }</span>
<span class="lineNum">   28329 </span>            : }
<span class="lineNum">   28330 </span>            : 
<span class="lineNum">   28331 </span>            : /* True iff TOKEN is the GNU keyword __thread.  */
<a name="28332"><span class="lineNum">   28332 </span>            : </a>
<span class="lineNum">   28333 </span>            : static bool
<span class="lineNum">   28334 </span>            : token_is__thread (cp_token *token)
<span class="lineNum">   28335 </span><span class="lineCov">   54251909 : {</span>
<span class="lineNum">   28336 </span><span class="lineCov">    2328058 :   gcc_assert (token-&gt;keyword == RID_THREAD);</span>
<span class="lineNum">   28337 </span><span class="lineCov">    2258771 :   return id_equal (token-&gt;u.value, &quot;__thread&quot;);</span>
<span class="lineNum">   28338 </span><span class="lineCov">    2252390 : }</span>
<span class="lineNum">   28339 </span><span class="lineCov">    2249324 : </span>
<span class="lineNum">   28340 </span><span class="lineCov">    2246258 : /* Set the location for a declarator specifier and check if it is</span>
<span class="lineNum">   28341 </span><span class="lineCov">   54268702 :    duplicated.</span>
<span class="lineNum">   28342 </span><span class="lineCov">      16783 : </span>
<span class="lineNum">   28343 </span><span class="lineCov">      16780 :    DECL_SPECS is the sequence of declarator specifiers onto which to</span>
<span class="lineNum">   28344 </span><span class="lineCov">      16780 :    set the location.</span>
<span class="lineNum">   28345 </span><span class="lineCov">      16780 : </span>
<span class="lineNum">   28346 </span>            :    DS is the single declarator specifier to set which location  is to
<span class="lineNum">   28347 </span><span class="lineCov">         13 :    be set onto the existing sequence of declarators.</span>
<span class="lineNum">   28348 </span><span class="lineCov">         13 : </span>
<span class="lineNum">   28349 </span>            :    LOCATION is the location for the declarator specifier to
<span class="lineNum">   28350 </span>            :    consider.  */
<a name="28351"><span class="lineNum">   28351 </span><span class="lineCov">         13 : </span></a>
<span class="lineNum">   28352 </span>            : static void
<span class="lineNum">   28353 </span><span class="lineCov">          3 : set_and_check_decl_spec_loc (cp_decl_specifier_seq *decl_specs,</span>
<span class="lineNum">   28354 </span><span class="lineCov">          3 :                              cp_decl_spec ds, cp_token *token)</span>
<span class="lineNum">   28355 </span><span class="lineCov">          3 : {</span>
<span class="lineNum">   28356 </span>            :   gcc_assert (ds &lt; ds_last);
<span class="lineNum">   28357 </span>            : 
<span class="lineNum">   28358 </span><span class="lineCov">   54251896 :   if (decl_specs == NULL)</span>
<span class="lineNum">   28359 </span><span class="lineCov">       1505 :     return;</span>
<span class="lineNum">   28360 </span>            : 
<span class="lineNum">   28361 </span>            :   source_location location = token-&gt;location;
<span class="lineNum">   28362 </span><span class="lineCov">   54250391 : </span>
<span class="lineNum">   28363 </span><span class="lineCov">   54250391 :   if (decl_specs-&gt;locations[ds] == 0)</span>
<span class="lineNum">   28364 </span><span class="lineCov">   54250391 :     {</span>
<span class="lineNum">   28365 </span><span class="lineCov">   54250391 :       decl_specs-&gt;locations[ds] = location;</span>
<span class="lineNum">   28366 </span>            :       if (ds == ds_thread)
<span class="lineNum">   28367 </span><span class="lineCov">   54251909 :         decl_specs-&gt;gnu_thread_keyword_p = token_is__thread (token);</span>
<span class="lineNum">   28368 </span>            :     }
<span class="lineNum">   28369 </span>            :   else
<span class="lineNum">   28370 </span>            :     {
<span class="lineNum">   28371 </span>            :       if (ds == ds_long)
<span class="lineNum">   28372 </span><span class="lineCov">        804 :         {</span>
<span class="lineNum">   28373 </span>            :           if (decl_specs-&gt;locations[ds_long_long] != 0)
<span class="lineNum">   28374 </span><span class="lineCov">        804 :             error_at (location,</span>
<span class="lineNum">   28375 </span><span class="lineCov">        804 :                       &quot;%&lt;long long long%&gt; is too long for GCC&quot;);</span>
<span class="lineNum">   28376 </span>            :           else
<span class="lineNum">   28377 </span>            :             {
<span class="lineNum">   28378 </span>            :               decl_specs-&gt;locations[ds_long_long] = location;
<span class="lineNum">   28379 </span>            :               pedwarn_cxx98 (location,
<span class="lineNum">   28380 </span>            :                              OPT_Wlong_long, 
<span class="lineNum">   28381 </span>            :                              &quot;ISO C++ 1998 does not support %&lt;long long%&gt;&quot;);
<span class="lineNum">   28382 </span>            :             }
<span class="lineNum">   28383 </span>            :         }
<span class="lineNum">   28384 </span>            :       else if (ds == ds_thread)
<span class="lineNum">   28385 </span>            :         {
<span class="lineNum">   28386 </span>            :           bool gnu = token_is__thread (token);
<span class="lineNum">   28387 </span>            :           gcc_rich_location richloc (location);
<span class="lineNum">   28388 </span>            :           if (gnu != decl_specs-&gt;gnu_thread_keyword_p)
<span class="lineNum">   28389 </span>            :             {
<span class="lineNum">   28390 </span>            :               richloc.add_range (decl_specs-&gt;locations[ds_thread]);
<span class="lineNum">   28391 </span><span class="lineCov">   76180566 :               error_at (&amp;richloc,</span>
<span class="lineNum">   28392 </span>            :                         &quot;both %&lt;__thread%&gt; and %&lt;thread_local%&gt; specified&quot;);
<span class="lineNum">   28393 </span>            :             }
<span class="lineNum">   28394 </span><span class="lineCov">   76180566 :           else</span>
<span class="lineNum">   28395 </span>            :             {
<span class="lineNum">   28396 </span><span class="lineCov">   76180566 :               richloc.add_fixit_remove ();</span>
<span class="lineNum">   28397 </span>            :               error_at (&amp;richloc, &quot;duplicate %qD&quot;, token-&gt;u.value);
<span class="lineNum">   28398 </span>            :             }
<span class="lineNum">   28399 </span><span class="lineCov">   76175365 :         }</span>
<span class="lineNum">   28400 </span>            :       else
<span class="lineNum">   28401 </span><span class="lineCov">   76175365 :         {</span>
<span class="lineNum">   28402 </span>            :           static const char *const decl_spec_names[] = {
<span class="lineNum">   28403 </span><span class="lineCov">   75848826 :             &quot;signed&quot;,</span>
<span class="lineNum">   28404 </span><span class="lineCov">   75848826 :             &quot;unsigned&quot;,</span>
<span class="lineNum">   28405 </span><span class="lineCov">        795 :             &quot;short&quot;,</span>
<span class="lineNum">   28406 </span>            :             &quot;long&quot;,
<span class="lineNum">   28407 </span>            :             &quot;const&quot;,
<span class="lineNum">   28408 </span>            :             &quot;volatile&quot;,
<span class="lineNum">   28409 </span><span class="lineCov">     326539 :             &quot;restrict&quot;,</span>
<span class="lineNum">   28410 </span>            :             &quot;inline&quot;,
<span class="lineNum">   28411 </span><span class="lineCov">     326427 :             &quot;virtual&quot;,</span>
<span class="lineNum">   28412 </span><span class="lineCov">          3 :             &quot;explicit&quot;,</span>
<span class="lineNum">   28413 </span>            :             &quot;friend&quot;,
<span class="lineNum">   28414 </span>            :             &quot;typedef&quot;,
<span class="lineNum">   28415 </span>            :             &quot;using&quot;,
<span class="lineNum">   28416 </span><span class="lineCov">     326424 :             &quot;constexpr&quot;,</span>
<span class="lineNum">   28417 </span><span class="lineCov">     326424 :             &quot;__complex&quot;</span>
<span class="lineNum">   28418 </span>            :           };
<span class="lineNum">   28419 </span>            :           gcc_rich_location richloc (location);
<span class="lineNum">   28420 </span>            :           richloc.add_fixit_remove ();
<span class="lineNum">   28421 </span>            :           error_at (&amp;richloc, &quot;duplicate %qs&quot;, decl_spec_names[ds]);
<span class="lineNum">   28422 </span><span class="lineCov">        112 :         }</span>
<span class="lineNum">   28423 </span>            :     }
<span class="lineNum">   28424 </span><span class="lineCov">          9 : }</span>
<span class="lineNum">   28425 </span><span class="lineCov">         18 : </span>
<span class="lineNum">   28426 </span><span class="lineCov">          9 : /* Return true iff the declarator specifier DS is present in the</span>
<span class="lineNum">   28427 </span>            :    sequence of declarator specifiers DECL_SPECS.  */
<a name="28428"><span class="lineNum">   28428 </span><span class="lineCov">          4 : </span></a>
<span class="lineNum">   28429 </span><span class="lineCov">          4 : bool</span>
<span class="lineNum">   28430 </span>            : decl_spec_seq_has_spec_p (const cp_decl_specifier_seq * decl_specs,
<span class="lineNum">   28431 </span>            :                           cp_decl_spec ds)
<span class="lineNum">   28432 </span>            : {
<span class="lineNum">   28433 </span>            :   gcc_assert (ds &lt; ds_last);
<span class="lineNum">   28434 </span><span class="lineCov">          5 : </span>
<span class="lineNum">   28435 </span><span class="lineCov">          5 :   if (decl_specs == NULL)</span>
<span class="lineNum">   28436 </span>            :     return false;
<span class="lineNum">   28437 </span>            : 
<span class="lineNum">   28438 </span>            :   return decl_specs-&gt;locations[ds] != 0;
<span class="lineNum">   28439 </span>            : }
<span class="lineNum">   28440 </span><span class="lineCov">        103 : </span>
<span class="lineNum">   28441 </span>            : /* DECL_SPECIFIERS is the representation of a decl-specifier-seq.
<span class="lineNum">   28442 </span>            :    Returns TRUE iff `friend' appears among the DECL_SPECIFIERS.  */
<a name="28443"><span class="lineNum">   28443 </span>            : </a>
<span class="lineNum">   28444 </span>            : static bool
<span class="lineNum">   28445 </span>            : cp_parser_friend_p (const cp_decl_specifier_seq *decl_specifiers)
<span class="lineNum">   28446 </span>            : {
<span class="lineNum">   28447 </span>            :   return decl_spec_seq_has_spec_p (decl_specifiers, ds_friend);
<span class="lineNum">   28448 </span>            : }
<span class="lineNum">   28449 </span>            : 
<span class="lineNum">   28450 </span>            : /* Issue an error message indicating that TOKEN_DESC was expected.
<span class="lineNum">   28451 </span>            :    If KEYWORD is true, it indicated this function is called by
<span class="lineNum">   28452 </span>            :    cp_parser_require_keword and the required token can only be
<span class="lineNum">   28453 </span>            :    a indicated keyword.
<span class="lineNum">   28454 </span>            : 
<span class="lineNum">   28455 </span>            :    If MATCHING_LOCATION is not UNKNOWN_LOCATION, then highlight it
<span class="lineNum">   28456 </span>            :    within any error as the location of an &quot;opening&quot; token matching
<span class="lineNum">   28457 </span><span class="lineCov">        206 :    the close token TYPE (e.g. the location of the '(' when TOKEN_DESC is</span>
<span class="lineNum">   28458 </span><span class="lineCov">        103 :    RT_CLOSE_PAREN).  */</span>
<a name="28459"><span class="lineNum">   28459 </span><span class="lineCov">        103 : </span></a>
<span class="lineNum">   28460 </span>            : static void
<span class="lineNum">   28461 </span>            : cp_parser_required_error (cp_parser *parser,
<span class="lineNum">   28462 </span>            :                           required_token token_desc,
<span class="lineNum">   28463 </span>            :                           bool keyword,
<span class="lineNum">   28464 </span>            :                           location_t matching_location)
<span class="lineNum">   28465 </span>            : {
<span class="lineNum">   28466 </span>            :   if (cp_parser_simulate_error (parser))
<span class="lineNum">   28467 </span>            :     return;
<span class="lineNum">   28468 </span><span class="lineCov"> 1094198180 : </span>
<span class="lineNum">   28469 </span>            :   const char *gmsgid = NULL;
<span class="lineNum">   28470 </span>            :   switch (token_desc)
<span class="lineNum">   28471 </span><span class="lineCov"> 1094198180 :     {</span>
<span class="lineNum">   28472 </span>            :       case RT_NEW:
<span class="lineNum">   28473 </span><span class="lineCov"> 1094198180 :         gmsgid = G_(&quot;expected %&lt;new%&gt;&quot;);</span>
<span class="lineNum">   28474 </span>            :         break;
<span class="lineNum">   28475 </span>            :       case RT_DELETE:
<span class="lineNum">   28476 </span><span class="lineCov"> 1094198180 :         gmsgid = G_(&quot;expected %&lt;delete%&gt;&quot;);</span>
<span class="lineNum">   28477 </span>            :         break;
<span class="lineNum">   28478 </span>            :       case RT_RETURN:
<span class="lineNum">   28479 </span>            :         gmsgid = G_(&quot;expected %&lt;return%&gt;&quot;);
<span class="lineNum">   28480 </span>            :         break;
<span class="lineNum">   28481 </span>            :       case RT_WHILE:
<span class="lineNum">   28482 </span>            :         gmsgid = G_(&quot;expected %&lt;while%&gt;&quot;);
<span class="lineNum">   28483 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">   28484 </span>            :       case RT_EXTERN:
<span class="lineNum">   28485 </span><span class="lineCov">   21329989 :         gmsgid = G_(&quot;expected %&lt;extern%&gt;&quot;);</span>
<span class="lineNum">   28486 </span>            :         break;
<span class="lineNum">   28487 </span>            :       case RT_STATIC_ASSERT:
<span class="lineNum">   28488 </span>            :         gmsgid = G_(&quot;expected %&lt;static_assert%&gt;&quot;);
<span class="lineNum">   28489 </span>            :         break;
<span class="lineNum">   28490 </span>            :       case RT_DECLTYPE:
<span class="lineNum">   28491 </span>            :         gmsgid = G_(&quot;expected %&lt;decltype%&gt;&quot;);
<span class="lineNum">   28492 </span>            :         break;
<span class="lineNum">   28493 </span>            :       case RT_OPERATOR:
<span class="lineNum">   28494 </span>            :         gmsgid = G_(&quot;expected %&lt;operator%&gt;&quot;);
<span class="lineNum">   28495 </span>            :         break;
<span class="lineNum">   28496 </span>            :       case RT_CLASS:
<span class="lineNum">   28497 </span>            :         gmsgid = G_(&quot;expected %&lt;class%&gt;&quot;);
<span class="lineNum">   28498 </span>            :         break;
<span class="lineNum">   28499 </span><span class="lineCov">       1461 :       case RT_TEMPLATE:</span>
<span class="lineNum">   28500 </span>            :         gmsgid = G_(&quot;expected %&lt;template%&gt;&quot;);
<span class="lineNum">   28501 </span>            :         break;
<span class="lineNum">   28502 </span>            :       case RT_NAMESPACE:
<span class="lineNum">   28503 </span>            :         gmsgid = G_(&quot;expected %&lt;namespace%&gt;&quot;);
<span class="lineNum">   28504 </span><span class="lineCov">       1461 :         break;</span>
<span class="lineNum">   28505 </span><span class="lineNoCov">          0 :       case RT_USING:</span>
<span class="lineNum">   28506 </span>            :         gmsgid = G_(&quot;expected %&lt;using%&gt;&quot;);
<span class="lineNum">   28507 </span><span class="lineCov">       1461 :         break;</span>
<span class="lineNum">   28508 </span><span class="lineCov">       1461 :       case RT_ASM:</span>
<span class="lineNum">   28509 </span>            :         gmsgid = G_(&quot;expected %&lt;asm%&gt;&quot;);
<span class="lineNum">   28510 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">   28511 </span><span class="lineNoCov">          0 :       case RT_TRY:</span>
<span class="lineNum">   28512 </span><span class="lineNoCov">          0 :         gmsgid = G_(&quot;expected %&lt;try%&gt;&quot;);</span>
<span class="lineNum">   28513 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">   28514 </span><span class="lineNoCov">          0 :       case RT_CATCH:</span>
<span class="lineNum">   28515 </span><span class="lineNoCov">          0 :         gmsgid = G_(&quot;expected %&lt;catch%&gt;&quot;);</span>
<span class="lineNum">   28516 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">   28517 </span><span class="lineNoCov">          0 :       case RT_THROW:</span>
<span class="lineNum">   28518 </span><span class="lineNoCov">          0 :         gmsgid = G_(&quot;expected %&lt;throw%&gt;&quot;);</span>
<span class="lineNum">   28519 </span><span class="lineCov">         33 :         break;</span>
<span class="lineNum">   28520 </span><span class="lineCov">         33 :       case RT_LABEL:</span>
<span class="lineNum">   28521 </span><span class="lineCov">         33 :         gmsgid = G_(&quot;expected %&lt;__label__%&gt;&quot;);</span>
<span class="lineNum">   28522 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">   28523 </span><span class="lineNoCov">          0 :       case RT_AT_TRY:</span>
<span class="lineNum">   28524 </span><span class="lineNoCov">          0 :         gmsgid = G_(&quot;expected %&lt;@try%&gt;&quot;);</span>
<span class="lineNum">   28525 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">   28526 </span><span class="lineNoCov">          0 :       case RT_AT_SYNCHRONIZED:</span>
<span class="lineNum">   28527 </span><span class="lineNoCov">          0 :         gmsgid = G_(&quot;expected %&lt;@synchronized%&gt;&quot;);</span>
<span class="lineNum">   28528 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">   28529 </span><span class="lineNoCov">          0 :       case RT_AT_THROW:</span>
<span class="lineNum">   28530 </span><span class="lineNoCov">          0 :         gmsgid = G_(&quot;expected %&lt;@throw%&gt;&quot;);</span>
<span class="lineNum">   28531 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">   28532 </span><span class="lineNoCov">          0 :       case RT_TRANSACTION_ATOMIC:</span>
<span class="lineNum">   28533 </span><span class="lineNoCov">          0 :         gmsgid = G_(&quot;expected %&lt;__transaction_atomic%&gt;&quot;);</span>
<span class="lineNum">   28534 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">   28535 </span><span class="lineNoCov">          0 :       case RT_TRANSACTION_RELAXED:</span>
<span class="lineNum">   28536 </span><span class="lineNoCov">          0 :         gmsgid = G_(&quot;expected %&lt;__transaction_relaxed%&gt;&quot;);</span>
<span class="lineNum">   28537 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">   28538 </span><span class="lineNoCov">          0 :       default:</span>
<span class="lineNum">   28539 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">   28540 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   28541 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   28542 </span><span class="lineNoCov">          0 :   if (!gmsgid &amp;&amp; !keyword)</span>
<span class="lineNum">   28543 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   28544 </span><span class="lineNoCov">          0 :       switch (token_desc)</span>
<span class="lineNum">   28545 </span><span class="lineNoCov">          0 :         {</span>
<span class="lineNum">   28546 </span><span class="lineNoCov">          0 :           case RT_SEMICOLON:</span>
<span class="lineNum">   28547 </span><span class="lineNoCov">          0 :             gmsgid = G_(&quot;expected %&lt;;%&gt;&quot;);</span>
<span class="lineNum">   28548 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">   28549 </span><span class="lineNoCov">          0 :           case RT_OPEN_PAREN:</span>
<span class="lineNum">   28550 </span><span class="lineNoCov">          0 :             gmsgid = G_(&quot;expected %&lt;(%&gt;&quot;);</span>
<span class="lineNum">   28551 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">   28552 </span><span class="lineCov">          3 :           case RT_CLOSE_BRACE:</span>
<span class="lineNum">   28553 </span><span class="lineCov">          3 :             gmsgid = G_(&quot;expected %&lt;}%&gt;&quot;);</span>
<span class="lineNum">   28554 </span><span class="lineCov">          3 :             break;</span>
<span class="lineNum">   28555 </span><span class="lineNoCov">          0 :           case RT_OPEN_BRACE:</span>
<span class="lineNum">   28556 </span><span class="lineNoCov">          0 :             gmsgid = G_(&quot;expected %&lt;{%&gt;&quot;);</span>
<span class="lineNum">   28557 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">   28558 </span><span class="lineNoCov">          0 :           case RT_CLOSE_SQUARE:</span>
<span class="lineNum">   28559 </span><span class="lineNoCov">          0 :             gmsgid = G_(&quot;expected %&lt;]%&gt;&quot;);</span>
<span class="lineNum">   28560 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">   28561 </span><span class="lineNoCov">          0 :           case RT_OPEN_SQUARE:</span>
<span class="lineNum">   28562 </span><span class="lineNoCov">          0 :             gmsgid = G_(&quot;expected %&lt;[%&gt;&quot;);</span>
<span class="lineNum">   28563 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">   28564 </span><span class="lineNoCov">          0 :           case RT_COMMA:</span>
<span class="lineNum">   28565 </span><span class="lineNoCov">          0 :             gmsgid = G_(&quot;expected %&lt;,%&gt;&quot;);</span>
<span class="lineNum">   28566 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">   28567 </span><span class="lineNoCov">          0 :           case RT_SCOPE:</span>
<span class="lineNum">   28568 </span><span class="lineNoCov">          0 :             gmsgid = G_(&quot;expected %&lt;::%&gt;&quot;);</span>
<span class="lineNum">   28569 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">   28570 </span><span class="lineNoCov">          0 :           case RT_LESS:</span>
<span class="lineNum">   28571 </span><span class="lineNoCov">          0 :             gmsgid = G_(&quot;expected %&lt;&lt;%&gt;&quot;);</span>
<span class="lineNum">   28572 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">   28573 </span><span class="lineNoCov">          0 :           case RT_GREATER:</span>
<span class="lineNum">   28574 </span><span class="lineNoCov">          0 :             gmsgid = G_(&quot;expected %&lt;&gt;%&gt;&quot;);</span>
<span class="lineNum">   28575 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">   28576 </span>            :           case RT_EQ:
<span class="lineNum">   28577 </span>            :             gmsgid = G_(&quot;expected %&lt;=%&gt;&quot;);
<span class="lineNum">   28578 </span>            :             break;
<span class="lineNum">   28579 </span>            :           case RT_ELLIPSIS:
<span class="lineNum">   28580 </span><span class="lineCov">       1461 :             gmsgid = G_(&quot;expected %&lt;...%&gt;&quot;);</span>
<span class="lineNum">   28581 </span>            :             break;
<span class="lineNum">   28582 </span><span class="lineCov">       1425 :           case RT_MULT:</span>
<span class="lineNum">   28583 </span>            :             gmsgid = G_(&quot;expected %&lt;*%&gt;&quot;);
<span class="lineNum">   28584 </span>            :             break;
<span class="lineNum">   28585 </span>            :           case RT_COMPL:
<span class="lineNum">   28586 </span>            :             gmsgid = G_(&quot;expected %&lt;~%&gt;&quot;);
<span class="lineNum">   28587 </span><span class="lineCov">        129 :             break;</span>
<span class="lineNum">   28588 </span><span class="lineCov">        129 :           case RT_COLON:</span>
<span class="lineNum">   28589 </span><span class="lineCov">        129 :             gmsgid = G_(&quot;expected %&lt;:%&gt;&quot;);</span>
<span class="lineNum">   28590 </span><span class="lineCov">        118 :             break;</span>
<span class="lineNum">   28591 </span><span class="lineCov">        118 :           case RT_COLON_SCOPE:</span>
<span class="lineNum">   28592 </span><span class="lineCov">        118 :             gmsgid = G_(&quot;expected %&lt;:%&gt; or %&lt;::%&gt;&quot;);</span>
<span class="lineNum">   28593 </span><span class="lineCov">         82 :             break;</span>
<span class="lineNum">   28594 </span><span class="lineCov">         82 :           case RT_CLOSE_PAREN:</span>
<span class="lineNum">   28595 </span><span class="lineCov">         82 :             gmsgid = G_(&quot;expected %&lt;)%&gt;&quot;);</span>
<span class="lineNum">   28596 </span><span class="lineCov">         47 :             break;</span>
<span class="lineNum">   28597 </span><span class="lineCov">         47 :           case RT_COMMA_CLOSE_PAREN:</span>
<span class="lineNum">   28598 </span><span class="lineCov">         47 :             gmsgid = G_(&quot;expected %&lt;,%&gt; or %&lt;)%&gt;&quot;);</span>
<span class="lineNum">   28599 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">   28600 </span><span class="lineNoCov">          0 :           case RT_PRAGMA_EOL:</span>
<span class="lineNum">   28601 </span><span class="lineNoCov">          0 :             gmsgid = G_(&quot;expected end of line&quot;);</span>
<span class="lineNum">   28602 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">   28603 </span><span class="lineNoCov">          0 :           case RT_NAME:</span>
<span class="lineNum">   28604 </span><span class="lineNoCov">          0 :             gmsgid = G_(&quot;expected identifier&quot;);</span>
<span class="lineNum">   28605 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">   28606 </span><span class="lineNoCov">          0 :           case RT_SELECT:</span>
<span class="lineNum">   28607 </span><span class="lineNoCov">          0 :             gmsgid = G_(&quot;expected selection-statement&quot;);</span>
<span class="lineNum">   28608 </span><span class="lineCov">          4 :             break;</span>
<span class="lineNum">   28609 </span><span class="lineCov">          4 :           case RT_ITERATION:</span>
<span class="lineNum">   28610 </span><span class="lineCov">          4 :             gmsgid = G_(&quot;expected iteration-statement&quot;);</span>
<span class="lineNum">   28611 </span><span class="lineCov">         62 :             break;</span>
<span class="lineNum">   28612 </span><span class="lineCov">         62 :           case RT_JUMP:</span>
<span class="lineNum">   28613 </span><span class="lineCov">         62 :             gmsgid = G_(&quot;expected jump-statement&quot;);</span>
<span class="lineNum">   28614 </span><span class="lineCov">          7 :             break;</span>
<span class="lineNum">   28615 </span><span class="lineCov">          7 :           case RT_CLASS_KEY:</span>
<span class="lineNum">   28616 </span><span class="lineCov">          7 :             gmsgid = G_(&quot;expected class-key&quot;);</span>
<span class="lineNum">   28617 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">   28618 </span><span class="lineNoCov">          0 :           case RT_CLASS_TYPENAME_TEMPLATE:</span>
<span class="lineNum">   28619 </span><span class="lineNoCov">          0 :             gmsgid = G_(&quot;expected %&lt;class%&gt;, %&lt;typename%&gt;, or %&lt;template%&gt;&quot;);</span>
<span class="lineNum">   28620 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">   28621 </span><span class="lineNoCov">          0 :           default:</span>
<span class="lineNum">   28622 </span><span class="lineNoCov">          0 :             gcc_unreachable ();</span>
<span class="lineNum">   28623 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">   28624 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   28625 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   28626 </span><span class="lineCov">         24 :   if (gmsgid)</span>
<span class="lineNum">   28627 </span><span class="lineCov">         24 :     cp_parser_error_1 (parser, gmsgid, token_desc, matching_location);</span>
<span class="lineNum">   28628 </span><span class="lineCov">         24 : }</span>
<span class="lineNum">   28629 </span><span class="lineCov">         18 : </span>
<span class="lineNum">   28630 </span><span class="lineCov">         18 : </span>
<span class="lineNum">   28631 </span><span class="lineCov">         18 : /* If the next token is of the indicated TYPE, consume it.  Otherwise,</span>
<span class="lineNum">   28632 </span><span class="lineCov">        524 :    issue an error message indicating that TOKEN_DESC was expected.</span>
<span class="lineNum">   28633 </span><span class="lineCov">        524 : </span>
<span class="lineNum">   28634 </span><span class="lineCov">        524 :    Returns the token consumed, if the token had the appropriate type.</span>
<span class="lineNum">   28635 </span><span class="lineCov">          9 :    Otherwise, returns NULL.</span>
<span class="lineNum">   28636 </span><span class="lineCov">          9 : </span>
<span class="lineNum">   28637 </span><span class="lineCov">          9 :    If MATCHING_LOCATION is not UNKNOWN_LOCATION, then highlight it</span>
<span class="lineNum">   28638 </span><span class="lineCov">         36 :    within any error as the location of an &quot;opening&quot; token matching</span>
<span class="lineNum">   28639 </span><span class="lineCov">         36 :    the close token TYPE (e.g. the location of the '(' when TOKEN_DESC is</span>
<span class="lineNum">   28640 </span><span class="lineCov">         36 :    RT_CLOSE_PAREN).  */</span>
<a name="28641"><span class="lineNum">   28641 </span><span class="lineCov">        166 : </span></a>
<span class="lineNum">   28642 </span><span class="lineCov">        166 : static cp_token *</span>
<span class="lineNum">   28643 </span><span class="lineCov">        166 : cp_parser_require (cp_parser* parser,</span>
<span class="lineNum">   28644 </span><span class="lineNoCov">          0 :                    enum cpp_ttype type,</span>
<span class="lineNum">   28645 </span><span class="lineNoCov">          0 :                    required_token token_desc,</span>
<span class="lineNum">   28646 </span><span class="lineNoCov">          0 :                    location_t matching_location)</span>
<span class="lineNum">   28647 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   28648 </span><span class="lineNoCov">          0 :   if (cp_lexer_next_token_is (parser-&gt;lexer, type))</span>
<span class="lineNum">   28649 </span><span class="lineNoCov">          0 :     return cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   28650 </span><span class="lineNoCov">          0 :   else</span>
<span class="lineNum">   28651 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   28652 </span><span class="lineNoCov">          0 :       /* Output the MESSAGE -- unless we're parsing tentatively.  */</span>
<span class="lineNum">   28653 </span><span class="lineCov">          4 :       if (!cp_parser_simulate_error (parser))</span>
<span class="lineNum">   28654 </span><span class="lineCov">          4 :         cp_parser_required_error (parser, token_desc, /*keyword=*/false,</span>
<span class="lineNum">   28655 </span><span class="lineCov">          4 :                                   matching_location);</span>
<span class="lineNum">   28656 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">   28657 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   28658 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   28659 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   28660 </span><span class="lineNoCov">          0 : /* An error message is produced if the next token is not '&gt;'.</span>
<span class="lineNum">   28661 </span>            :    All further tokens are skipped until the desired token is
<span class="lineNum">   28662 </span>            :    found or '{', '}', ';' or an unbalanced ')' or ']'.  */
<a name="28663"><span class="lineNum">   28663 </span>            : </a>
<span class="lineNum">   28664 </span><span class="lineCov">       1461 : static void</span>
<span class="lineNum">   28665 </span><span class="lineCov">       1461 : cp_parser_skip_to_end_of_template_parameter_list (cp_parser* parser)</span>
<span class="lineNum">   28666 </span>            : {
<span class="lineNum">   28667 </span>            :   /* Current level of '&lt; ... &gt;'.  */
<span class="lineNum">   28668 </span>            :   unsigned level = 0;
<span class="lineNum">   28669 </span>            :   /* Ignore '&lt;' and '&gt;' nested inside '( ... )' or '[ ... ]'.  */
<span class="lineNum">   28670 </span>            :   unsigned nesting_depth = 0;
<span class="lineNum">   28671 </span>            : 
<span class="lineNum">   28672 </span>            :   /* Are we ready, yet?  If not, issue error message.  */
<span class="lineNum">   28673 </span>            :   if (cp_parser_require (parser, CPP_GREATER, RT_GREATER))
<span class="lineNum">   28674 </span>            :     return;
<span class="lineNum">   28675 </span>            : 
<span class="lineNum">   28676 </span>            :   /* Skip tokens until the desired token is found.  */
<span class="lineNum">   28677 </span>            :   while (true)
<span class="lineNum">   28678 </span>            :     {
<span class="lineNum">   28679 </span>            :       /* Peek at the next token.  */
<span class="lineNum">   28680 </span>            :       switch (cp_lexer_peek_token (parser-&gt;lexer)-&gt;type)
<span class="lineNum">   28681 </span><span class="lineCov">  455313689 :         {</span>
<span class="lineNum">   28682 </span>            :         case CPP_LESS:
<span class="lineNum">   28683 </span>            :           if (!nesting_depth)
<span class="lineNum">   28684 </span>            :             ++level;
<span class="lineNum">   28685 </span>            :           break;
<span class="lineNum">   28686 </span><span class="lineCov">  455313689 : </span>
<span class="lineNum">   28687 </span><span class="lineCov">  399738032 :         case CPP_RSHIFT:</span>
<span class="lineNum">   28688 </span>            :           if (cxx_dialect == cxx98)
<span class="lineNum">   28689 </span>            :             /* C++0x views the `&gt;&gt;' operator as two `&gt;' tokens, but
<span class="lineNum">   28690 </span>            :                C++98 does not. */
<span class="lineNum">   28691 </span><span class="lineCov">   55574196 :             break;</span>
<span class="lineNum">   28692 </span><span class="lineCov">       1461 :           else if (!nesting_depth &amp;&amp; level-- == 0)</span>
<span class="lineNum">   28693 </span>            :             {
<span class="lineNum">   28694 </span><span class="lineCov">   55575657 :               /* We've hit a `&gt;&gt;' where the first `&gt;' closes the</span>
<span class="lineNum">   28695 </span>            :                  template argument list, and the second `&gt;' is
<span class="lineNum">   28696 </span>            :                  spurious.  Just consume the `&gt;&gt;' and stop; we've
<span class="lineNum">   28697 </span>            :                  already produced at least one error.  */
<span class="lineNum">   28698 </span>            :               cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   28699 </span>            :               return;
<span class="lineNum">   28700 </span>            :             }
<span class="lineNum">   28701 </span>            :           /* Fall through for C++0x, so we handle the second `&gt;' in
<span class="lineNum">   28702 </span>            :              the `&gt;&gt;'.  */
<span class="lineNum">   28703 </span><span class="lineCov">   12155202 :           gcc_fallthrough ();</span>
<span class="lineNum">   28704 </span>            : 
<span class="lineNum">   28705 </span>            :         case CPP_GREATER:
<span class="lineNum">   28706 </span><span class="lineCov">   12155202 :           if (!nesting_depth &amp;&amp; level-- == 0)</span>
<span class="lineNum">   28707 </span>            :             {
<span class="lineNum">   28708 </span><span class="lineCov">   12155202 :               /* We've reached the token we want, consume it and stop.  */</span>
<span class="lineNum">   28709 </span>            :               cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   28710 </span>            :               return;
<span class="lineNum">   28711 </span><span class="lineCov">   12155202 :             }</span>
<span class="lineNum">   28712 </span>            :           break;
<span class="lineNum">   28713 </span>            : 
<span class="lineNum">   28714 </span>            :         case CPP_OPEN_PAREN:
<span class="lineNum">   28715 </span><span class="lineCov">        430 :         case CPP_OPEN_SQUARE:</span>
<span class="lineNum">   28716 </span>            :           ++nesting_depth;
<span class="lineNum">   28717 </span>            :           break;
<span class="lineNum">   28718 </span><span class="lineCov">        430 : </span>
<span class="lineNum">   28719 </span>            :         case CPP_CLOSE_PAREN:
<span class="lineNum">   28720 </span><span class="lineCov">         29 :         case CPP_CLOSE_SQUARE:</span>
<span class="lineNum">   28721 </span><span class="lineCov">         29 :           if (nesting_depth-- == 0)</span>
<span class="lineNum">   28722 </span><span class="lineCov">         29 :             return;</span>
<span class="lineNum">   28723 </span>            :           break;
<span class="lineNum">   28724 </span>            : 
<span class="lineNum">   28725 </span><span class="lineCov">          2 :         case CPP_EOF:</span>
<span class="lineNum">   28726 </span><span class="lineCov">          2 :         case CPP_PRAGMA_EOL:</span>
<span class="lineNum">   28727 </span>            :         case CPP_SEMICOLON:
<span class="lineNum">   28728 </span>            :         case CPP_OPEN_BRACE:
<span class="lineNum">   28729 </span>            :         case CPP_CLOSE_BRACE:
<span class="lineNum">   28730 </span><span class="lineNoCov">          0 :           /* The '&gt;' was probably forgotten, don't look further.  */</span>
<span class="lineNum">   28731 </span>            :           return;
<span class="lineNum">   28732 </span>            : 
<span class="lineNum">   28733 </span>            :         default:
<span class="lineNum">   28734 </span>            :           break;
<span class="lineNum">   28735 </span>            :         }
<span class="lineNum">   28736 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   28737 </span><span class="lineNoCov">          0 :       /* Consume this token.  */</span>
<span class="lineNum">   28738 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   28739 </span>            :     }
<span class="lineNum">   28740 </span>            : }
<span class="lineNum">   28741 </span><span class="lineCov">        108 : </span>
<span class="lineNum">   28742 </span>            : /* If the next token is the indicated keyword, consume it.  Otherwise,
<span class="lineNum">   28743 </span><span class="lineCov">        108 :    issue an error message indicating that TOKEN_DESC was expected.</span>
<span class="lineNum">   28744 </span><span class="lineCov">        108 : </span>
<span class="lineNum">   28745 </span>            :    Returns the token consumed, if the token had the appropriate type.
<span class="lineNum">   28746 </span>            :    Otherwise, returns NULL.  */
<a name="28747"><span class="lineNum">   28747 </span><span class="lineCov">         79 : </span></a>
<span class="lineNum">   28748 </span><span class="lineCov">         79 : static cp_token *</span>
<span class="lineNum">   28749 </span>            : cp_parser_require_keyword (cp_parser* parser,
<span class="lineNum">   28750 </span>            :                            enum rid keyword,
<span class="lineNum">   28751 </span>            :                            required_token token_desc)
<span class="lineNum">   28752 </span><span class="lineCov">         18 : {</span>
<span class="lineNum">   28753 </span><span class="lineCov">         18 :   cp_token *token = cp_parser_require (parser, CPP_KEYWORD, token_desc);</span>
<span class="lineNum">   28754 </span><span class="lineCov">         18 : </span>
<span class="lineNum">   28755 </span><span class="lineCov">         18 :   if (token &amp;&amp; token-&gt;keyword != keyword)</span>
<span class="lineNum">   28756 </span>            :     {
<span class="lineNum">   28757 </span><span class="lineCov">         29 :       cp_parser_required_error (parser, token_desc, /*keyword=*/true,</span>
<span class="lineNum">   28758 </span><span class="lineCov">         29 :                                 UNKNOWN_LOCATION);</span>
<span class="lineNum">   28759 </span><span class="lineCov">         29 :       return NULL;</span>
<span class="lineNum">   28760 </span>            :     }
<span class="lineNum">   28761 </span>            : 
<span class="lineNum">   28762 </span>            :   return token;
<span class="lineNum">   28763 </span>            : }
<span class="lineNum">   28764 </span>            : 
<span class="lineNum">   28765 </span>            : /* Returns TRUE iff TOKEN is a token that can begin the body of a
<span class="lineNum">   28766 </span>            :    function-definition.  */
<a name="28767"><span class="lineNum">   28767 </span>            : </a>
<span class="lineNum">   28768 </span>            : static bool
<span class="lineNum">   28769 </span>            : cp_parser_token_starts_function_definition_p (cp_token* token)
<span class="lineNum">   28770 </span>            : {
<span class="lineNum">   28771 </span>            :   return (/* An ordinary function-body begins with an `{'.  */
<span class="lineNum">   28772 </span>            :           token-&gt;type == CPP_OPEN_BRACE
<span class="lineNum">   28773 </span>            :           /* A ctor-initializer begins with a `:'.  */
<span class="lineNum">   28774 </span>            :           || token-&gt;type == CPP_COLON
<span class="lineNum">   28775 </span>            :           /* A function-try-block begins with `try'.  */
<span class="lineNum">   28776 </span><span class="lineCov">        285 :           || token-&gt;keyword == RID_TRY</span>
<span class="lineNum">   28777 </span>            :           /* A function-transaction-block begins with `__transaction_atomic'
<span class="lineNum">   28778 </span>            :              or `__transaction_relaxed'.  */
<span class="lineNum">   28779 </span>            :           || token-&gt;keyword == RID_TRANSACTION_ATOMIC
<span class="lineNum">   28780 </span>            :           || token-&gt;keyword == RID_TRANSACTION_RELAXED
<span class="lineNum">   28781 </span>            :           /* The named return value extension begins with `return'.  */
<span class="lineNum">   28782 </span>            :           || token-&gt;keyword == RID_RETURN);
<span class="lineNum">   28783 </span>            : }
<span class="lineNum">   28784 </span>            : 
<span class="lineNum">   28785 </span>            : /* Returns TRUE iff the next token is the &quot;:&quot; or &quot;{&quot; beginning a class
<span class="lineNum">   28786 </span>            :    definition.  */
<a name="28787"><span class="lineNum">   28787 </span><span class="lineCov">    5994196 : </span></a>
<span class="lineNum">   28788 </span>            : static bool
<span class="lineNum">   28789 </span>            : cp_parser_next_token_starts_class_definition_p (cp_parser *parser)
<span class="lineNum">   28790 </span>            : {
<span class="lineNum">   28791 </span><span class="lineCov">    5994196 :   cp_token *token;</span>
<span class="lineNum">   28792 </span>            : 
<span class="lineNum">   28793 </span><span class="lineCov">    5994196 :   token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   28794 </span>            :   return (token-&gt;type == CPP_OPEN_BRACE
<span class="lineNum">   28795 </span><span class="lineNoCov">          0 :           || (token-&gt;type == CPP_COLON</span>
<span class="lineNum">   28796 </span>            :               &amp;&amp; !parser-&gt;colon_doesnt_start_class_def_p));
<span class="lineNum">   28797 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   28798 </span>            : 
<span class="lineNum">   28799 </span>            : /* Returns TRUE iff the next token is the &quot;,&quot; or &quot;&gt;&quot; (or `&gt;&gt;', in
<span class="lineNum">   28800 </span>            :    C++0x) ending a template-argument.  */
<a name="28801"><span class="lineNum">   28801 </span>            : </a>
<span class="lineNum">   28802 </span>            : static bool
<span class="lineNum">   28803 </span>            : cp_parser_next_token_ends_template_argument_p (cp_parser *parser)
<span class="lineNum">   28804 </span>            : {
<span class="lineNum">   28805 </span>            :   cp_token *token;
<span class="lineNum">   28806 </span>            : 
<span class="lineNum">   28807 </span><span class="lineNoCov">          0 :   token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   28808 </span>            :   return (token-&gt;type == CPP_COMMA 
<span class="lineNum">   28809 </span><span class="lineCov">   13451676 :           || token-&gt;type == CPP_GREATER</span>
<span class="lineNum">   28810 </span><span class="lineCov">   13451676 :           || token-&gt;type == CPP_ELLIPSIS</span>
<span class="lineNum">   28811 </span>            :           || ((cxx_dialect != cxx98) &amp;&amp; token-&gt;type == CPP_RSHIFT));
<span class="lineNum">   28812 </span><span class="lineCov">   13451676 : }</span>
<span class="lineNum">   28813 </span>            : 
<span class="lineNum">   28814 </span><span class="lineCov">    7785325 : /* Returns TRUE iff the n-th token is a &quot;&lt;&quot;, or the n-th is a &quot;[&quot; and the</span>
<span class="lineNum">   28815 </span>            :    (n+1)-th is a &quot;:&quot; (which is a possible digraph typo for &quot;&lt; ::&quot;).  */
<a name="28816"><span class="lineNum">   28816 </span>            : </a>
<span class="lineNum">   28817 </span><span class="lineCov">    7785234 : static bool</span>
<span class="lineNum">   28818 </span><span class="lineCov">    7785217 : cp_parser_nth_token_starts_template_argument_list_p (cp_parser * parser,</span>
<span class="lineNum">   28819 </span>            :                                                      size_t n)
<span class="lineNum">   28820 </span><span class="lineCov">   21236893 : {</span>
<span class="lineNum">   28821 </span>            :   cp_token *token;
<span class="lineNum">   28822 </span>            : 
<span class="lineNum">   28823 </span>            :   token = cp_lexer_peek_nth_token (parser-&gt;lexer, n);
<span class="lineNum">   28824 </span>            :   if (token-&gt;type == CPP_LESS)
<span class="lineNum">   28825 </span>            :     return true;
<span class="lineNum">   28826 </span>            :   /* Check for the sequence `&lt;::' in the original code. It would be lexed as
<span class="lineNum">   28827 </span><span class="lineNoCov">          0 :      `[:', where `[' is a digraph, and there is no whitespace before</span>
<span class="lineNum">   28828 </span>            :      `:'.  */
<span class="lineNum">   28829 </span><span class="lineCov">    3550514 :   if (token-&gt;type == CPP_OPEN_SQUARE &amp;&amp; token-&gt;flags &amp; DIGRAPH)</span>
<span class="lineNum">   28830 </span>            :     {
<span class="lineNum">   28831 </span><span class="lineCov">    7101028 :       cp_token *token2;</span>
<span class="lineNum">   28832 </span><span class="lineCov">    3550514 :       token2 = cp_lexer_peek_nth_token (parser-&gt;lexer, n+1);</span>
<span class="lineNum">   28833 </span><span class="lineCov">    3550514 :       if (token2-&gt;type == CPP_COLON &amp;&amp; !(token2-&gt;flags &amp; PREV_WHITE))</span>
<span class="lineNum">   28834 </span><span class="lineCov">    1134877 :         return true;</span>
<span class="lineNum">   28835 </span>            :     }
<span class="lineNum">   28836 </span>            :   return false;
<span class="lineNum">   28837 </span>            : }
<span class="lineNum">   28838 </span>            : 
<span class="lineNum">   28839 </span>            : /* Returns the kind of tag indicated by TOKEN, if it is a class-key,
<span class="lineNum">   28840 </span>            :    or none_type otherwise.  */
<a name="28841"><span class="lineNum">   28841 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   28842 </span>            : static enum tag_types
<span class="lineNum">   28843 </span><span class="lineCov">   16646359 : cp_parser_token_is_class_key (cp_token* token)</span>
<span class="lineNum">   28844 </span>            : {
<span class="lineNum">   28845 </span><span class="lineCov">   33292718 :   switch (token-&gt;keyword)</span>
<span class="lineNum">   28846 </span><span class="lineCov">   16646359 :     {</span>
<span class="lineNum">   28847 </span><span class="lineCov">   16646359 :     case RID_CLASS:</span>
<span class="lineNum">   28848 </span><span class="lineCov">    3675313 :       return class_type;</span>
<span class="lineNum">   28849 </span><span class="lineCov">   19881653 :     case RID_STRUCT:</span>
<span class="lineNum">   28850 </span>            :       return record_type;
<span class="lineNum">   28851 </span>            :     case RID_UNION:
<span class="lineNum">   28852 </span>            :       return union_type;
<span class="lineNum">   28853 </span>            : 
<span class="lineNum">   28854 </span>            :     default:
<span class="lineNum">   28855 </span>            :       return none_type;
<span class="lineNum">   28856 </span><span class="lineCov">  417139361 :     }</span>
<span class="lineNum">   28857 </span>            : }
<span class="lineNum">   28858 </span>            : 
<span class="lineNum">   28859 </span><span class="lineCov">  417139361 : /* Returns the kind of tag indicated by TOKEN, if it is a type-parameter-key,</span>
<span class="lineNum">   28860 </span>            :    or none_type otherwise or if the token is null.  */
<a name="28861"><span class="lineNum">   28861 </span><span class="lineCov">  417139361 : </span></a>
<span class="lineNum">   28862 </span><span class="lineCov">  417139361 : static enum tag_types</span>
<span class="lineNum">   28863 </span>            : cp_parser_token_is_type_parameter_key (cp_token* token)
<span class="lineNum">   28864 </span>            : {
<span class="lineNum">   28865 </span>            :   if (!token)
<span class="lineNum">   28866 </span>            :     return none_type;
<span class="lineNum">   28867 </span><span class="lineCov">  378517945 : </span>
<span class="lineNum">   28868 </span>            :   switch (token-&gt;keyword)
<span class="lineNum">   28869 </span><span class="lineCov">         11 :     {</span>
<span class="lineNum">   28870 </span><span class="lineCov">         11 :     case RID_CLASS:</span>
<span class="lineNum">   28871 </span><span class="lineCov">         11 :       return class_type;</span>
<span class="lineNum">   28872 </span><span class="lineCov">          3 :     case RID_TYPENAME:</span>
<span class="lineNum">   28873 </span>            :       return typename_type;
<span class="lineNum">   28874 </span>            : 
<span class="lineNum">   28875 </span>            :     default:
<span class="lineNum">   28876 </span>            :       return none_type;
<span class="lineNum">   28877 </span>            :     }
<span class="lineNum">   28878 </span>            : }
<span class="lineNum">   28879 </span>            : 
<span class="lineNum">   28880 </span>            : /* Issue an error message if the CLASS_KEY does not match the TYPE.  */
<a name="28881"><span class="lineNum">   28881 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   28882 </span>            : static void
<span class="lineNum">   28883 </span><span class="lineCov">    4159972 : cp_parser_check_class_key (enum tag_types class_key, tree type)</span>
<span class="lineNum">   28884 </span>            : {
<span class="lineNum">   28885 </span>            :   if (type == error_mark_node)
<span class="lineNum">   28886 </span>            :     return;
<span class="lineNum">   28887 </span><span class="lineCov">    3320428 :   if ((TREE_CODE (type) == UNION_TYPE) != (class_key == union_type))</span>
<span class="lineNum">   28888 </span><span class="lineCov">    3320428 :     {</span>
<span class="lineNum">   28889 </span><span class="lineCov">      82764 :       if (permerror (input_location, &quot;%qs tag used in naming %q#T&quot;,</span>
<span class="lineNum">   28890 </span><span class="lineCov">      82764 :                      class_key == union_type ? &quot;union&quot;</span>
<span class="lineNum">   28891 </span>            :                      : class_key == record_type ? &quot;struct&quot; : &quot;class&quot;,
<span class="lineNum">   28892 </span><span class="lineNoCov">          0 :                      type))</span>
<span class="lineNum">   28893 </span><span class="lineNoCov">          0 :         inform (DECL_SOURCE_LOCATION (TYPE_NAME (type)),</span>
<span class="lineNum">   28894 </span>            :                 &quot;%q#T was previously declared here&quot;, type);
<span class="lineNum">   28895 </span>            :     }
<span class="lineNum">   28896 </span>            : }
<span class="lineNum">   28897 </span>            : 
<span class="lineNum">   28898 </span>            : /* Issue an error message if DECL is redeclared with different
<span class="lineNum">   28899 </span>            :    access than its original declaration [class.access.spec/3].
<span class="lineNum">   28900 </span>            :    This applies to nested classes, nested class templates and
<span class="lineNum">   28901 </span><span class="lineNoCov">          0 :    enumerations [class.mem/1].  */</span>
<a name="28902"><span class="lineNum">   28902 </span>            : </a>
<span class="lineNum">   28903 </span><span class="lineCov">      36630 : static void</span>
<span class="lineNum">   28904 </span>            : cp_parser_check_access_in_redeclaration (tree decl, location_t location)
<span class="lineNum">   28905 </span>            : {
<span class="lineNum">   28906 </span><span class="lineCov">      36630 :   if (!decl</span>
<span class="lineNum">   28907 </span>            :       || (!CLASS_TYPE_P (TREE_TYPE (decl))
<span class="lineNum">   28908 </span>            :           &amp;&amp; TREE_CODE (TREE_TYPE (decl)) != ENUMERAL_TYPE))
<span class="lineNum">   28909 </span>            :     return;
<span class="lineNum">   28910 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   28911 </span><span class="lineNoCov">          0 :   if ((TREE_PRIVATE (decl)</span>
<span class="lineNum">   28912 </span>            :        != (current_access_specifier == access_private_node))
<span class="lineNum">   28913 </span><span class="lineNoCov">          0 :       || (TREE_PROTECTED (decl)</span>
<span class="lineNum">   28914 </span><span class="lineNoCov">          0 :           != (current_access_specifier == access_protected_node)))</span>
<span class="lineNum">   28915 </span>            :     error_at (location, &quot;%qD redeclared with different access&quot;, decl);
<span class="lineNum">   28916 </span>            : }
<span class="lineNum">   28917 </span>            : 
<span class="lineNum">   28918 </span>            : /* Look for the `template' keyword, as a syntactic disambiguator.
<span class="lineNum">   28919 </span>            :    Return TRUE iff it is present, in which case it will be
<span class="lineNum">   28920 </span>            :    consumed.  */
<a name="28921"><span class="lineNum">   28921 </span><span class="lineCov">    3299762 : </span></a>
<span class="lineNum">   28922 </span>            : static bool
<span class="lineNum">   28923 </span><span class="lineCov">    3299762 : cp_parser_optional_template_keyword (cp_parser *parser)</span>
<span class="lineNum">   28924 </span>            : {
<span class="lineNum">   28925 </span><span class="lineCov">    3299592 :   if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_TEMPLATE))</span>
<span class="lineNum">   28926 </span>            :     {
<span class="lineNum">   28927 </span><span class="lineCov">         18 :       /* In C++98 the `template' keyword can only be used within templates;</span>
<span class="lineNum">   28928 </span>            :          outside templates the parser can always figure out what is a
<span class="lineNum">   28929 </span><span class="lineCov">          3 :          template and what is not.  In C++11,  per the resolution of DR 468,</span>
<span class="lineNum">   28930 </span>            :          `template' is allowed in cases where it is not strictly necessary.  */
<span class="lineNum">   28931 </span><span class="lineCov">         15 :       if (!processing_template_decl</span>
<span class="lineNum">   28932 </span>            :           &amp;&amp; pedantic &amp;&amp; cxx_dialect == cxx98)
<span class="lineNum">   28933 </span>            :         {
<span class="lineNum">   28934 </span>            :           cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   28935 </span>            :           pedwarn (token-&gt;location, OPT_Wpedantic,
<span class="lineNum">   28936 </span>            :                    &quot;in C++98 %&lt;template%&gt; (as a disambiguator) is only &quot;
<span class="lineNum">   28937 </span>            :                    &quot;allowed within templates&quot;);
<span class="lineNum">   28938 </span>            :           /* If this part of the token stream is rescanned, the same
<span class="lineNum">   28939 </span>            :              error message would be generated.  So, we purge the token
<span class="lineNum">   28940 </span>            :              from the stream.  */
<span class="lineNum">   28941 </span>            :           cp_lexer_purge_token (parser-&gt;lexer);
<span class="lineNum">   28942 </span><span class="lineCov">     225292 :           return false;</span>
<span class="lineNum">   28943 </span>            :         }
<span class="lineNum">   28944 </span><span class="lineCov">     225292 :       else</span>
<span class="lineNum">   28945 </span><span class="lineCov">     225292 :         {</span>
<span class="lineNum">   28946 </span><span class="lineCov">     201320 :           /* Consume the `template' keyword.  */</span>
<span class="lineNum">   28947 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   28948 </span>            :           return true;
<span class="lineNum">   28949 </span><span class="lineCov">     450580 :         }</span>
<span class="lineNum">   28950 </span><span class="lineCov">     225290 :     }</span>
<span class="lineNum">   28951 </span><span class="lineCov">     450560 :   return false;</span>
<span class="lineNum">   28952 </span><span class="lineCov">     225280 : }</span>
<span class="lineNum">   28953 </span><span class="lineCov">         10 : </span>
<span class="lineNum">   28954 </span>            : /* The next token is a CPP_NESTED_NAME_SPECIFIER.  Consume the token,
<span class="lineNum">   28955 </span>            :    set PARSER-&gt;SCOPE, and perform other related actions.  */
<a name="28956"><span class="lineNum">   28956 </span>            : </a>
<span class="lineNum">   28957 </span>            : static void
<span class="lineNum">   28958 </span>            : cp_parser_pre_parsed_nested_name_specifier (cp_parser *parser)
<span class="lineNum">   28959 </span>            : {
<span class="lineNum">   28960 </span>            :   struct tree_check *check_value;
<span class="lineNum">   28961 </span><span class="lineCov">   20993605 : </span>
<span class="lineNum">   28962 </span>            :   /* Get the stored value.  */
<span class="lineNum">   28963 </span><span class="lineCov">   20993605 :   check_value = cp_lexer_consume_token (parser-&gt;lexer)-&gt;u.tree_check_value;</span>
<span class="lineNum">   28964 </span>            :   /* Set the scope from the stored value.  */
<span class="lineNum">   28965 </span>            :   parser-&gt;scope = saved_checks_value (check_value);
<span class="lineNum">   28966 </span>            :   parser-&gt;qualifying_scope = check_value-&gt;qualifying_scope;
<span class="lineNum">   28967 </span>            :   parser-&gt;object_scope = NULL_TREE;
<span class="lineNum">   28968 </span>            : }
<span class="lineNum">   28969 </span><span class="lineCov">     841966 : </span>
<span class="lineNum">   28970 </span><span class="lineCov">         60 : /* Consume tokens up through a non-nested END token.  Returns TRUE if we</span>
<span class="lineNum">   28971 </span>            :    encounter the end of a block before what we were looking for.  */
<a name="28972"><span class="lineNum">   28972 </span><span class="lineCov">         12 : </span></a>
<span class="lineNum">   28973 </span><span class="lineCov">          6 : static bool</span>
<span class="lineNum">   28974 </span>            : cp_parser_cache_group (cp_parser *parser,
<span class="lineNum">   28975 </span>            :                        enum cpp_ttype end,
<span class="lineNum">   28976 </span>            :                        unsigned depth)
<span class="lineNum">   28977 </span>            : {
<span class="lineNum">   28978 </span>            :   while (true)
<span class="lineNum">   28979 </span><span class="lineCov">          6 :     {</span>
<span class="lineNum">   28980 </span><span class="lineCov">          6 :       cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   28981 </span>            : 
<span class="lineNum">   28982 </span>            :       /* Abort a parenthesized expression if we encounter a semicolon.  */
<span class="lineNum">   28983 </span>            :       if ((end == CPP_CLOSE_PAREN || depth == 0)
<span class="lineNum">   28984 </span>            :           &amp;&amp; token-&gt;type == CPP_SEMICOLON)
<span class="lineNum">   28985 </span><span class="lineCov">     841960 :         return true;</span>
<span class="lineNum">   28986 </span><span class="lineCov">     841960 :       /* If we've reached the end of the file, stop.  */</span>
<span class="lineNum">   28987 </span>            :       if (token-&gt;type == CPP_EOF
<span class="lineNum">   28988 </span>            :           || (end != CPP_PRAGMA_EOL
<span class="lineNum">   28989 </span>            :               &amp;&amp; token-&gt;type == CPP_PRAGMA_EOL))
<span class="lineNum">   28990 </span>            :         return true;
<span class="lineNum">   28991 </span>            :       if (token-&gt;type == CPP_CLOSE_BRACE &amp;&amp; depth == 0)
<span class="lineNum">   28992 </span>            :         /* We've hit the end of an enclosing block, so there's been some
<span class="lineNum">   28993 </span>            :            kind of syntax error.  */
<span class="lineNum">   28994 </span>            :         return true;
<span class="lineNum">   28995 </span>            : 
<span class="lineNum">   28996 </span><span class="lineCov">    7326627 :       /* Consume the token.  */</span>
<span class="lineNum">   28997 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   28998 </span><span class="lineCov">    7326627 :       /* See if it starts a new group.  */</span>
<span class="lineNum">   28999 </span>            :       if (token-&gt;type == CPP_OPEN_BRACE)
<span class="lineNum">   29000 </span>            :         {
<span class="lineNum">   29001 </span><span class="lineCov">    7326627 :           cp_parser_cache_group (parser, CPP_CLOSE_BRACE, depth + 1);</span>
<span class="lineNum">   29002 </span>            :           /* In theory this should probably check end == '}', but
<span class="lineNum">   29003 </span><span class="lineCov">    7326627 :              cp_parser_save_member_function_body needs it to exit</span>
<span class="lineNum">   29004 </span><span class="lineCov">    7326627 :              after either '}' or ')' when called with ')'.  */</span>
<span class="lineNum">   29005 </span><span class="lineCov">    7326627 :           if (depth == 0)</span>
<span class="lineNum">   29006 </span><span class="lineCov">    7326627 :             return false;</span>
<span class="lineNum">   29007 </span>            :         }
<span class="lineNum">   29008 </span>            :       else if (token-&gt;type == CPP_OPEN_PAREN)
<span class="lineNum">   29009 </span>            :         {
<span class="lineNum">   29010 </span>            :           cp_parser_cache_group (parser, CPP_CLOSE_PAREN, depth + 1);
<span class="lineNum">   29011 </span>            :           if (depth == 0 &amp;&amp; end == CPP_CLOSE_PAREN)
<span class="lineNum">   29012 </span><span class="lineCov">   13297282 :             return false;</span>
<span class="lineNum">   29013 </span>            :         }
<span class="lineNum">   29014 </span>            :       else if (token-&gt;type == CPP_PRAGMA)
<span class="lineNum">   29015 </span>            :         cp_parser_cache_group (parser, CPP_PRAGMA_EOL, depth + 1);
<span class="lineNum">   29016 </span><span class="lineCov">   55708700 :       else if (token-&gt;type == end)</span>
<span class="lineNum">   29017 </span>            :         return false;
<span class="lineNum">   29018 </span><span class="lineCov">  111417400 :     }</span>
<span class="lineNum">   29019 </span>            : }
<span class="lineNum">   29020 </span>            : 
<span class="lineNum">   29021 </span><span class="lineCov">   55708700 : /* Like above, for caching a default argument or NSDMI.  Both of these are</span>
<span class="lineNum">   29022 </span><span class="lineCov">   28365153 :    terminated by a non-nested comma, but it can be unclear whether or not a</span>
<span class="lineNum">   29023 </span>            :    comma is nested in a template argument list unless we do more parsing.
<span class="lineNum">   29024 </span>            :    In order to handle this ambiguity, when we encounter a ',' after a '&lt;'
<span class="lineNum">   29025 </span><span class="lineCov">   55651939 :    we try to parse what follows as a parameter-declaration-list (in the</span>
<span class="lineNum">   29026 </span><span class="lineCov">   55651936 :    case of a default argument) or a member-declarator (in the case of an</span>
<span class="lineNum">   29027 </span><span class="lineCov">   55651514 :    NSDMI).  If that succeeds, then we stop caching.  */</span>
<a name="29028"><span class="lineNum">   29028 </span>            : </a>
<span class="lineNum">   29029 </span><span class="lineCov">   55651936 : static tree</span>
<span class="lineNum">   29030 </span>            : cp_parser_cache_defarg (cp_parser *parser, bool nsdmi)
<span class="lineNum">   29031 </span>            : {
<span class="lineNum">   29032 </span>            :   unsigned depth = 0;
<span class="lineNum">   29033 </span>            :   int maybe_template_id = 0;
<span class="lineNum">   29034 </span>            :   cp_token *first_token;
<span class="lineNum">   29035 </span><span class="lineCov">   55651926 :   cp_token *token;</span>
<span class="lineNum">   29036 </span>            :   tree default_argument;
<span class="lineNum">   29037 </span><span class="lineCov">   55651926 : </span>
<span class="lineNum">   29038 </span>            :   /* Add tokens until we have processed the entire default
<span class="lineNum">   29039 </span><span class="lineCov">    3326443 :      argument.  We add the range [first_token, token).  */</span>
<span class="lineNum">   29040 </span>            :   first_token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   29041 </span>            :   if (first_token-&gt;type == CPP_OPEN_BRACE)
<span class="lineNum">   29042 </span>            :     {
<span class="lineNum">   29043 </span><span class="lineCov">    3326443 :       /* For list-initialization, this is straightforward.  */</span>
<span class="lineNum">   29044 </span>            :       cp_parser_cache_group (parser, CPP_CLOSE_BRACE, /*depth=*/0);
<span class="lineNum">   29045 </span>            :       token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   29046 </span><span class="lineCov">   52325483 :     }</span>
<span class="lineNum">   29047 </span>            :   else while (true)
<span class="lineNum">   29048 </span><span class="lineCov">    6117401 :     {</span>
<span class="lineNum">   29049 </span><span class="lineCov">    6117401 :       bool done = false;</span>
<span class="lineNum">   29050 </span>            : 
<span class="lineNum">   29051 </span>            :       /* Peek at the next token.  */
<span class="lineNum">   29052 </span><span class="lineCov">   46208082 :       token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   29053 </span><span class="lineCov">        147 :       /* What we do depends on what token we have.  */</span>
<span class="lineNum">   29054 </span><span class="lineCov">   46207935 :       switch (token-&gt;type)</span>
<span class="lineNum">   29055 </span>            :         {
<span class="lineNum">   29056 </span>            :           /* In valid code, a default argument must be
<span class="lineNum">   29057 </span>            :              immediately followed by a `,' `)', or `...'.  */
<span class="lineNum">   29058 </span>            :         case CPP_COMMA:
<span class="lineNum">   29059 </span>            :           if (depth == 0 &amp;&amp; maybe_template_id)
<span class="lineNum">   29060 </span>            :             {
<span class="lineNum">   29061 </span>            :               /* If we've seen a '&lt;', we might be in a
<span class="lineNum">   29062 </span>            :                  template-argument-list.  Until Core issue 325 is
<span class="lineNum">   29063 </span>            :                  resolved, we don't know how this situation ought
<span class="lineNum">   29064 </span>            :                  to be handled, so try to DTRT.  We check whether
<span class="lineNum">   29065 </span>            :                  what comes after the comma is a valid parameter
<span class="lineNum">   29066 </span>            :                  declaration list.  If it is, then the comma ends
<span class="lineNum">   29067 </span>            :                  the default argument; otherwise the default
<span class="lineNum">   29068 </span><span class="lineCov">     256583 :                  argument continues.  */</span>
<span class="lineNum">   29069 </span>            :               bool error = false;
<span class="lineNum">   29070 </span><span class="lineCov">     256583 :               cp_token *peek;</span>
<span class="lineNum">   29071 </span><span class="lineCov">     256583 : </span>
<span class="lineNum">   29072 </span><span class="lineCov">     256583 :               /* Set ITALP so cp_parser_parameter_declaration_list</span>
<span class="lineNum">   29073 </span><span class="lineCov">     256583 :                  doesn't decide to commit to this parse.  */</span>
<span class="lineNum">   29074 </span><span class="lineCov">     256583 :               bool saved_italp = parser-&gt;in_template_argument_list_p;</span>
<span class="lineNum">   29075 </span>            :               parser-&gt;in_template_argument_list_p = true;
<span class="lineNum">   29076 </span>            : 
<span class="lineNum">   29077 </span>            :               cp_parser_parse_tentatively (parser);
<span class="lineNum">   29078 </span><span class="lineCov">     513166 : </span>
<span class="lineNum">   29079 </span><span class="lineCov">     256583 :               if (nsdmi)</span>
<span class="lineNum">   29080 </span>            :                 {
<span class="lineNum">   29081 </span>            :                   /* Parse declarators until we reach a non-comma or
<span class="lineNum">   29082 </span><span class="lineCov">        287 :                      somthing that cannot be an initializer.</span>
<span class="lineNum">   29083 </span><span class="lineCov">        287 :                      Just checking whether we're looking at a single</span>
<span class="lineNum">   29084 </span>            :                      declarator is insufficient.  Consider:
<span class="lineNum">   29085 </span><span class="lineCov">    1064439 :                        int var = tuple&lt;T,U&gt;::x;</span>
<span class="lineNum">   29086 </span>            :                      The template parameter 'U' looks exactly like a
<span class="lineNum">   29087 </span><span class="lineCov">    1064439 :                      declarator.  */</span>
<span class="lineNum">   29088 </span>            :                   do
<span class="lineNum">   29089 </span>            :                     {
<span class="lineNum">   29090 </span><span class="lineCov">    2128878 :                       int ctor_dtor_or_conv_p;</span>
<span class="lineNum">   29091 </span>            :                       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   29092 </span><span class="lineCov">    1064439 :                       cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,</span>
<span class="lineNum">   29093 </span>            :                                             &amp;ctor_dtor_or_conv_p,
<span class="lineNum">   29094 </span>            :                                             /*parenthesized_p=*/NULL,
<span class="lineNum">   29095 </span>            :                                             /*member_p=*/true,
<span class="lineNum">   29096 </span><span class="lineCov">      60445 :                                             /*friend_p=*/false);</span>
<span class="lineNum">   29097 </span><span class="lineCov">      60445 :                       peek = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   29098 </span>            :                       if (cp_parser_error_occurred (parser))
<span class="lineNum">   29099 </span>            :                         break;
<span class="lineNum">   29100 </span>            :                     }
<span class="lineNum">   29101 </span>            :                   while (peek-&gt;type == CPP_COMMA);
<span class="lineNum">   29102 </span>            :                   /* If we met an '=' or ';' then the original comma
<span class="lineNum">   29103 </span>            :                      was the end of the NSDMI.  Otherwise assume
<span class="lineNum">   29104 </span>            :                      we're still in the NSDMI.  */
<span class="lineNum">   29105 </span>            :                   error = (peek-&gt;type != CPP_EQ
<span class="lineNum">   29106 </span>            :                            &amp;&amp; peek-&gt;type != CPP_SEMICOLON);
<span class="lineNum">   29107 </span><span class="lineCov">         20 :                 }</span>
<span class="lineNum">   29108 </span><span class="lineCov">         20 :               else</span>
<span class="lineNum">   29109 </span>            :                 {
<span class="lineNum">   29110 </span>            :                   cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   29111 </span>            :                   begin_scope (sk_function_parms, NULL_TREE);
<span class="lineNum">   29112 </span><span class="lineCov">         20 :                   if (cp_parser_parameter_declaration_list (parser)</span>
<span class="lineNum">   29113 </span><span class="lineCov">         20 :                       == error_mark_node)</span>
<span class="lineNum">   29114 </span>            :                     error = true;
<span class="lineNum">   29115 </span><span class="lineCov">         20 :                   pop_bindings_and_leave_scope ();</span>
<span class="lineNum">   29116 </span>            :                 }
<span class="lineNum">   29117 </span><span class="lineCov">         20 :               if (!cp_parser_error_occurred (parser) &amp;&amp; !error)</span>
<span class="lineNum">   29118 </span>            :                 done = true;
<span class="lineNum">   29119 </span>            :               cp_parser_abort_tentative_parse (parser);
<span class="lineNum">   29120 </span>            : 
<span class="lineNum">   29121 </span>            :               parser-&gt;in_template_argument_list_p = saved_italp;
<span class="lineNum">   29122 </span>            :               break;
<span class="lineNum">   29123 </span>            :             }
<span class="lineNum">   29124 </span>            :           /* FALLTHRU */
<span class="lineNum">   29125 </span>            :         case CPP_CLOSE_PAREN:
<span class="lineNum">   29126 </span><span class="lineCov">         10 :         case CPP_ELLIPSIS:</span>
<span class="lineNum">   29127 </span>            :           /* If we run into a non-nested `;', `}', or `]',
<span class="lineNum">   29128 </span><span class="lineCov">         10 :              then the code is invalid -- but the default</span>
<span class="lineNum">   29129 </span><span class="lineCov">         10 :              argument is certainly over.  */</span>
<span class="lineNum">   29130 </span><span class="lineCov">         10 :         case CPP_SEMICOLON:</span>
<span class="lineNum">   29131 </span>            :         case CPP_CLOSE_BRACE:
<span class="lineNum">   29132 </span>            :         case CPP_CLOSE_SQUARE:
<span class="lineNum">   29133 </span>            :           if (depth == 0
<span class="lineNum">   29134 </span>            :               /* Handle correctly int n = sizeof ... ( p );  */
<span class="lineNum">   29135 </span><span class="lineCov">         20 :               &amp;&amp; token-&gt;type != CPP_ELLIPSIS)</span>
<span class="lineNum">   29136 </span><span class="lineCov">          4 :             done = true;</span>
<span class="lineNum">   29137 </span>            :           /* Update DEPTH, if necessary.  */
<span class="lineNum">   29138 </span>            :           else if (token-&gt;type == CPP_CLOSE_PAREN
<span class="lineNum">   29139 </span><span class="lineCov">          6 :                    || token-&gt;type == CPP_CLOSE_BRACE</span>
<span class="lineNum">   29140 </span>            :                    || token-&gt;type == CPP_CLOSE_SQUARE)
<span class="lineNum">   29141 </span>            :             --depth;
<span class="lineNum">   29142 </span>            :           break;
<span class="lineNum">   29143 </span><span class="lineCov">         10 : </span>
<span class="lineNum">   29144 </span><span class="lineCov">         10 :         case CPP_OPEN_PAREN:</span>
<span class="lineNum">   29145 </span>            :         case CPP_OPEN_SQUARE:
<span class="lineNum">   29146 </span>            :         case CPP_OPEN_BRACE:
<span class="lineNum">   29147 </span>            :           ++depth;
<span class="lineNum">   29148 </span><span class="lineCov">         10 :           break;</span>
<span class="lineNum">   29149 </span><span class="lineCov">         10 : </span>
<span class="lineNum">   29150 </span><span class="lineCov">         10 :         case CPP_LESS:</span>
<span class="lineNum">   29151 </span><span class="lineCov">         10 :           if (depth == 0)</span>
<span class="lineNum">   29152 </span><span class="lineNoCov">          0 :             /* This might be the comparison operator, or it might</span>
<span class="lineNum">   29153 </span><span class="lineCov">         10 :                start a template argument list.  */</span>
<span class="lineNum">   29154 </span>            :             ++maybe_template_id;
<span class="lineNum">   29155 </span><span class="lineCov">          9 :           break;</span>
<span class="lineNum">   29156 </span>            : 
<span class="lineNum">   29157 </span><span class="lineCov">         20 :         case CPP_RSHIFT:</span>
<span class="lineNum">   29158 </span>            :           if (cxx_dialect == cxx98)
<span class="lineNum">   29159 </span><span class="lineCov">         20 :             break;</span>
<span class="lineNum">   29160 </span><span class="lineCov">         20 :           /* Fall through for C++0x, which treats the `&gt;&gt;'</span>
<span class="lineNum">   29161 </span><span class="lineCov">      60425 :              operator like two `&gt;' tokens in certain</span>
<span class="lineNum">   29162 </span>            :              cases.  */
<span class="lineNum">   29163 </span><span class="lineCov">     355652 :           gcc_fallthrough ();</span>
<span class="lineNum">   29164 </span><span class="lineCov">     355652 : </span>
<span class="lineNum">   29165 </span>            :         case CPP_GREATER:
<span class="lineNum">   29166 </span>            :           if (depth == 0)
<span class="lineNum">   29167 </span>            :             {
<span class="lineNum">   29168 </span><span class="lineCov">     355652 :               /* This might be an operator, or it might close a</span>
<span class="lineNum">   29169 </span><span class="lineCov">     355652 :                  template argument list.  But if a previous '&lt;'</span>
<span class="lineNum">   29170 </span><span class="lineCov">     355652 :                  started a template argument list, this will have</span>
<span class="lineNum">   29171 </span><span class="lineCov">     355652 :                  closed it, so we can't be in one anymore.  */</span>
<span class="lineNum">   29172 </span>            :               maybe_template_id -= 1 + (token-&gt;type == CPP_RSHIFT);
<span class="lineNum">   29173 </span><span class="lineCov">     256292 :               if (maybe_template_id &lt; 0)</span>
<span class="lineNum">   29174 </span>            :                 maybe_template_id = 0;
<span class="lineNum">   29175 </span>            :             }
<span class="lineNum">   29176 </span><span class="lineCov">      99364 :           break;</span>
<span class="lineNum">   29177 </span><span class="lineCov">      35736 : </span>
<span class="lineNum">   29178 </span><span class="lineCov">      23233 :           /* If we run out of tokens, issue an error message.  */</span>
<span class="lineNum">   29179 </span><span class="lineCov">      76222 :         case CPP_EOF:</span>
<span class="lineNum">   29180 </span>            :         case CPP_PRAGMA_EOL:
<span class="lineNum">   29181 </span>            :           error_at (token-&gt;location, &quot;file ends in default argument&quot;);
<span class="lineNum">   29182 </span><span class="lineCov">      76222 :           return error_mark_node;</span>
<span class="lineNum">   29183 </span><span class="lineCov">      76222 : </span>
<span class="lineNum">   29184 </span><span class="lineCov">      76222 :         case CPP_NAME:</span>
<span class="lineNum">   29185 </span><span class="lineCov">      76222 :         case CPP_SCOPE:</span>
<span class="lineNum">   29186 </span><span class="lineCov">      76222 :           /* In these cases, we should look for template-ids.</span>
<span class="lineNum">   29187 </span>            :              For example, if the default argument is
<span class="lineNum">   29188 </span><span class="lineCov">       5752 :              `X&lt;int, double&gt;()', we need to do name lookup to</span>
<span class="lineNum">   29189 </span><span class="lineCov">       5752 :              figure out whether or not `X' is a template; if</span>
<span class="lineNum">   29190 </span>            :              so, the `,' does not end the default argument.
<span class="lineNum">   29191 </span>            : 
<span class="lineNum">   29192 </span><span class="lineCov">       5730 :              That is not yet done.  */</span>
<span class="lineNum">   29193 </span>            :           break;
<span class="lineNum">   29194 </span>            : 
<span class="lineNum">   29195 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">   29196 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   29197 </span>            :         }
<span class="lineNum">   29198 </span>            : 
<span class="lineNum">   29199 </span>            :       /* If we've reached the end, stop.  */
<span class="lineNum">   29200 </span>            :       if (done)
<span class="lineNum">   29201 </span><span class="lineCov">       5747 :         break;</span>
<span class="lineNum">   29202 </span>            : 
<span class="lineNum">   29203 </span><span class="lineCov">       5747 :       /* Add the token to the token block.  */</span>
<span class="lineNum">   29204 </span><span class="lineCov">       5747 :       token = cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   29205 </span>            :     }
<span class="lineNum">   29206 </span>            : 
<span class="lineNum">   29207 </span>            :   /* Create a DEFAULT_ARG to represent the unparsed default
<span class="lineNum">   29208 </span>            :      argument.  */
<span class="lineNum">   29209 </span>            :   default_argument = make_node (DEFAULT_ARG);
<span class="lineNum">   29210 </span><span class="lineCov">       5723 :   DEFARG_TOKENS (default_argument)</span>
<span class="lineNum">   29211 </span><span class="lineCov">       5723 :     = cp_token_cache_new (first_token, token);</span>
<span class="lineNum">   29212 </span><span class="lineNoCov">          0 :   DEFARG_INSTANTIATIONS (default_argument) = NULL;</span>
<span class="lineNum">   29213 </span>            : 
<span class="lineNum">   29214 </span>            :   return default_argument;
<span class="lineNum">   29215 </span>            : }
<span class="lineNum">   29216 </span>            : 
<span class="lineNum">   29217 </span><span class="lineCov">          3 : /* A location to use for diagnostics about an unparsed DEFAULT_ARG.  */</span>
<a name="29218"><span class="lineNum">   29218 </span><span class="lineCov">          3 : </span></a>
<span class="lineNum">   29219 </span><span class="lineCov">          3 : location_t</span>
<span class="lineNum">   29220 </span><span class="lineCov">          3 : defarg_location (tree default_argument)</span>
<span class="lineNum">   29221 </span>            : {
<span class="lineNum">   29222 </span>            :   cp_token_cache *tokens = DEFARG_TOKENS (default_argument);
<span class="lineNum">   29223 </span>            :   location_t start = tokens-&gt;first-&gt;location;
<span class="lineNum">   29224 </span>            :   location_t end = tokens-&gt;last-&gt;location;
<span class="lineNum">   29225 </span>            :   return make_location (start, start, end);
<span class="lineNum">   29226 </span>            : }
<span class="lineNum">   29227 </span>            : 
<span class="lineNum">   29228 </span>            : /* Begin parsing tentatively.  We always save tokens while parsing
<span class="lineNum">   29229 </span>            :    tentatively so that if the tentative parsing fails we can restore the
<span class="lineNum">   29230 </span>            :    tokens.  */
<a name="29231"><span class="lineNum">   29231 </span>            : </a>
<span class="lineNum">   29232 </span>            : static void
<span class="lineNum">   29233 </span>            : cp_parser_parse_tentatively (cp_parser* parser)
<span class="lineNum">   29234 </span>            : {
<span class="lineNum">   29235 </span>            :   /* Enter a new parsing context.  */
<span class="lineNum">   29236 </span>            :   parser-&gt;context = cp_parser_context_new (parser-&gt;context);
<span class="lineNum">   29237 </span>            :   /* Begin saving tokens.  */
<span class="lineNum">   29238 </span><span class="lineCov">    1064436 :   cp_lexer_save_tokens (parser-&gt;lexer);</span>
<span class="lineNum">   29239 </span>            :   /* In order to avoid repetitive access control error messages,
<span class="lineNum">   29240 </span>            :      access checks are queued up until we are no longer parsing
<span class="lineNum">   29241 </span>            :      tentatively.  */
<span class="lineNum">   29242 </span><span class="lineCov">     808143 :   push_deferring_access_checks (dk_deferred);</span>
<span class="lineNum">   29243 </span><span class="lineCov">     808143 : }</span>
<span class="lineNum">   29244 </span>            : 
<span class="lineNum">   29245 </span>            : /* Commit to the currently active tentative parse.  */
<a name="29246"><span class="lineNum">   29246 </span>            : </a>
<span class="lineNum">   29247 </span><span class="lineCov">     256580 : static void</span>
<span class="lineNum">   29248 </span><span class="lineCov">     256580 : cp_parser_commit_to_tentative_parse (cp_parser* parser)</span>
<span class="lineNum">   29249 </span><span class="lineCov">     256580 : {</span>
<span class="lineNum">   29250 </span><span class="lineCov">     256580 :   cp_parser_context *context;</span>
<span class="lineNum">   29251 </span>            :   cp_lexer *lexer;
<span class="lineNum">   29252 </span><span class="lineCov">     256580 : </span>
<span class="lineNum">   29253 </span>            :   /* Mark all of the levels as committed.  */
<span class="lineNum">   29254 </span>            :   lexer = parser-&gt;lexer;
<span class="lineNum">   29255 </span>            :   for (context = parser-&gt;context; context-&gt;next; context = context-&gt;next)
<span class="lineNum">   29256 </span>            :     {
<span class="lineNum">   29257 </span>            :       if (context-&gt;status == CP_PARSER_STATUS_KIND_COMMITTED)
<span class="lineNum">   29258 </span><span class="lineCov">         11 :         break;</span>
<span class="lineNum">   29259 </span>            :       context-&gt;status = CP_PARSER_STATUS_KIND_COMMITTED;
<span class="lineNum">   29260 </span><span class="lineCov">         11 :       while (!cp_lexer_saving_tokens (lexer))</span>
<span class="lineNum">   29261 </span><span class="lineCov">         11 :         lexer = lexer-&gt;next;</span>
<span class="lineNum">   29262 </span><span class="lineCov">         11 :       cp_lexer_commit_tokens (lexer);</span>
<span class="lineNum">   29263 </span><span class="lineCov">         11 :     }</span>
<span class="lineNum">   29264 </span>            : }
<span class="lineNum">   29265 </span>            : 
<span class="lineNum">   29266 </span>            : /* Commit to the topmost currently active tentative parse.
<span class="lineNum">   29267 </span>            : 
<span class="lineNum">   29268 </span>            :    Note that this function shouldn't be called when there are
<span class="lineNum">   29269 </span>            :    irreversible side-effects while in a tentative state.  For
<span class="lineNum">   29270 </span>            :    example, we shouldn't create a permanent entry in the symbol
<span class="lineNum">   29271 </span><span class="lineCov">  637665989 :    table, or issue an error message that might not apply if the</span>
<span class="lineNum">   29272 </span>            :    tentative parse is aborted.  */
<a name="29273"><span class="lineNum">   29273 </span>            : </a>
<span class="lineNum">   29274 </span><span class="lineCov">  637665989 : static void</span>
<span class="lineNum">   29275 </span>            : cp_parser_commit_to_topmost_tentative_parse (cp_parser* parser)
<span class="lineNum">   29276 </span><span class="lineCov">  637665989 : {</span>
<span class="lineNum">   29277 </span>            :   cp_parser_context *context = parser-&gt;context;
<span class="lineNum">   29278 </span>            :   cp_lexer *lexer = parser-&gt;lexer;
<span class="lineNum">   29279 </span>            : 
<span class="lineNum">   29280 </span><span class="lineCov">  637665989 :   if (context)</span>
<span class="lineNum">   29281 </span><span class="lineCov">  637665989 :     {</span>
<span class="lineNum">   29282 </span>            :       if (context-&gt;status == CP_PARSER_STATUS_KIND_COMMITTED)
<span class="lineNum">   29283 </span>            :         return;
<span class="lineNum">   29284 </span>            :       context-&gt;status = CP_PARSER_STATUS_KIND_COMMITTED;
<span class="lineNum">   29285 </span>            : 
<span class="lineNum">   29286 </span><span class="lineCov">   26657117 :       while (!cp_lexer_saving_tokens (lexer))</span>
<span class="lineNum">   29287 </span>            :         lexer = lexer-&gt;next;
<span class="lineNum">   29288 </span><span class="lineCov">   26657117 :       cp_lexer_commit_tokens (lexer);</span>
<span class="lineNum">   29289 </span><span class="lineCov">   26657117 :     }</span>
<span class="lineNum">   29290 </span>            : }
<span class="lineNum">   29291 </span>            : 
<span class="lineNum">   29292 </span><span class="lineCov">   26657117 : /* Abort the currently active tentative parse.  All consumed tokens</span>
<span class="lineNum">   29293 </span><span class="lineCov">   37549568 :    will be rolled back, and no diagnostics will be issued.  */</span>
<a name="29294"><span class="lineNum">   29294 </span>            : </a>
<span class="lineNum">   29295 </span><span class="lineCov">   16685784 : static void</span>
<span class="lineNum">   29296 </span>            : cp_parser_abort_tentative_parse (cp_parser* parser)
<span class="lineNum">   29297 </span><span class="lineCov">   10892451 : {</span>
<span class="lineNum">   29298 </span><span class="lineCov">   10892451 :   gcc_assert (parser-&gt;context-&gt;status != CP_PARSER_STATUS_KIND_COMMITTED</span>
<span class="lineNum">   29299 </span><span class="lineNoCov">          0 :               || errorcount &gt; 0);</span>
<span class="lineNum">   29300 </span><span class="lineCov">   10892451 :   cp_parser_simulate_error (parser);</span>
<span class="lineNum">   29301 </span>            :   /* Now, pretend that we want to see if the construct was
<span class="lineNum">   29302 </span><span class="lineCov">   26657117 :      successfully parsed.  */</span>
<span class="lineNum">   29303 </span>            :   cp_parser_parse_definitely (parser);
<span class="lineNum">   29304 </span>            : }
<span class="lineNum">   29305 </span>            : 
<span class="lineNum">   29306 </span>            : /* Stop parsing tentatively.  If a parse error has occurred, restore the
<span class="lineNum">   29307 </span>            :    token stream.  Otherwise, commit to the tokens we have consumed.
<span class="lineNum">   29308 </span>            :    Returns true if no error occurred; false otherwise.  */
<a name="29309"><span class="lineNum">   29309 </span>            : </a>
<span class="lineNum">   29310 </span>            : static bool
<span class="lineNum">   29311 </span>            : cp_parser_parse_definitely (cp_parser* parser)
<span class="lineNum">   29312 </span>            : {
<span class="lineNum">   29313 </span><span class="lineCov">   11673441 :   bool error_occurred;</span>
<span class="lineNum">   29314 </span>            :   cp_parser_context *context;
<span class="lineNum">   29315 </span><span class="lineCov">   11673441 : </span>
<span class="lineNum">   29316 </span><span class="lineCov">   11673441 :   /* Remember whether or not an error occurred, since we are about to</span>
<span class="lineNum">   29317 </span>            :      destroy that information.  */
<span class="lineNum">   29318 </span><span class="lineCov">   11673441 :   error_occurred = cp_parser_error_occurred (parser);</span>
<span class="lineNum">   29319 </span>            :   /* Remove the topmost context from the stack.  */
<span class="lineNum">   29320 </span><span class="lineCov">   11673441 :   context = parser-&gt;context;</span>
<span class="lineNum">   29321 </span>            :   parser-&gt;context = context-&gt;next;
<span class="lineNum">   29322 </span><span class="lineCov">   11673426 :   /* If no parse errors occurred, commit to the tentative parse.  */</span>
<span class="lineNum">   29323 </span>            :   if (!error_occurred)
<span class="lineNum">   29324 </span><span class="lineCov">   11673426 :     {</span>
<span class="lineNum">   29325 </span><span class="lineNoCov">          0 :       /* Commit to the tokens read tentatively, unless that was</span>
<span class="lineNum">   29326 </span><span class="lineCov">   11673426 :          already done.  */</span>
<span class="lineNum">   29327 </span>            :       if (context-&gt;status != CP_PARSER_STATUS_KIND_COMMITTED)
<span class="lineNum">   29328 </span>            :         cp_lexer_commit_tokens (parser-&gt;lexer);
<span class="lineNum">   29329 </span>            : 
<span class="lineNum">   29330 </span>            :       pop_to_parent_deferring_access_checks ();
<span class="lineNum">   29331 </span>            :     }
<span class="lineNum">   29332 </span>            :   /* Otherwise, if errors occurred, roll back our state so that things
<span class="lineNum">   29333 </span>            :      are just as they were before we began the tentative parse.  */
<span class="lineNum">   29334 </span><span class="lineCov">   14642100 :   else</span>
<span class="lineNum">   29335 </span>            :     {
<span class="lineNum">   29336 </span><span class="lineCov">   14642100 :       cp_lexer_rollback_tokens (parser-&gt;lexer);</span>
<span class="lineNum">   29337 </span>            :       pop_deferring_access_checks ();
<span class="lineNum">   29338 </span><span class="lineCov">   29284200 :     }</span>
<span class="lineNum">   29339 </span>            :   /* Add the context to the front of the free list.  */
<span class="lineNum">   29340 </span>            :   context-&gt;next = cp_parser_context_free_list;
<span class="lineNum">   29341 </span><span class="lineCov">   14642100 :   cp_parser_context_free_list = context;</span>
<span class="lineNum">   29342 </span><span class="lineCov">   14642100 : </span>
<span class="lineNum">   29343 </span>            :   return !error_occurred;
<span class="lineNum">   29344 </span>            : }
<span class="lineNum">   29345 </span>            : 
<span class="lineNum">   29346 </span>            : /* Returns true if we are parsing tentatively and are not committed to
<span class="lineNum">   29347 </span>            :    this tentative parse.  */
<a name="29348"><span class="lineNum">   29348 </span>            : </a>
<span class="lineNum">   29349 </span><span class="lineCov">  637665971 : static bool</span>
<span class="lineNum">   29350 </span>            : cp_parser_uncommitted_to_tentative_parse_p (cp_parser* parser)
<span class="lineNum">   29351 </span><span class="lineCov">  637665971 : {</span>
<span class="lineNum">   29352 </span><span class="lineCov">  637665971 :   return (cp_parser_parsing_tentatively (parser)</span>
<span class="lineNum">   29353 </span>            :           &amp;&amp; parser-&gt;context-&gt;status != CP_PARSER_STATUS_KIND_COMMITTED);
<span class="lineNum">   29354 </span>            : }
<span class="lineNum">   29355 </span>            : 
<span class="lineNum">   29356 </span><span class="lineCov"> 1275331942 : /* Returns nonzero iff an error has occurred during the most recent</span>
<span class="lineNum">   29357 </span>            :    tentative parse.  */
<a name="29358"><span class="lineNum">   29358 </span><span class="lineCov">  637665971 : </span></a>
<span class="lineNum">   29359 </span><span class="lineCov">  637665971 : static bool</span>
<span class="lineNum">   29360 </span>            : cp_parser_error_occurred (cp_parser* parser)
<span class="lineNum">   29361 </span><span class="lineCov">  637665971 : {</span>
<span class="lineNum">   29362 </span>            :   return (cp_parser_parsing_tentatively (parser)
<span class="lineNum">   29363 </span>            :           &amp;&amp; parser-&gt;context-&gt;status == CP_PARSER_STATUS_KIND_ERROR);
<span class="lineNum">   29364 </span>            : }
<span class="lineNum">   29365 </span><span class="lineCov">  156128829 : </span>
<span class="lineNum">   29366 </span><span class="lineCov">  133562964 : /* Returns nonzero if GNU extensions are allowed.  */</span>
<a name="29367"><span class="lineNum">   29367 </span>            : </a>
<span class="lineNum">   29368 </span><span class="lineCov">  156128829 : static bool</span>
<span class="lineNum">   29369 </span>            : cp_parser_allow_gnu_extensions_p (cp_parser* parser)
<span class="lineNum">   29370 </span>            : {
<span class="lineNum">   29371 </span>            :   return parser-&gt;allow_gnu_extensions_p;
<span class="lineNum">   29372 </span>            : }
<span class="lineNum">   29373 </span>            : 
<span class="lineNum">   29374 </span><span class="lineCov">  481537142 : /* Objective-C++ Productions */</span>
<span class="lineNum">   29375 </span><span class="lineCov">  481537142 : </span>
<span class="lineNum">   29376 </span>            : 
<span class="lineNum">   29377 </span>            : /* Parse an Objective-C expression, which feeds into a primary-expression
<span class="lineNum">   29378 </span><span class="lineCov">  637665971 :    above.</span>
<span class="lineNum">   29379 </span><span class="lineCov">  637665971 : </span>
<span class="lineNum">   29380 </span>            :    objc-expression:
<span class="lineNum">   29381 </span><span class="lineCov">  637665971 :      objc-message-expression</span>
<span class="lineNum">   29382 </span>            :      objc-string-literal
<span class="lineNum">   29383 </span>            :      objc-encode-expression
<span class="lineNum">   29384 </span>            :      objc-protocol-expression
<span class="lineNum">   29385 </span>            :      objc-selector-expression
<span class="lineNum">   29386 </span>            : 
<span class="lineNum">   29387 </span>            :   Returns a tree representation of the expression.  */
<a name="29388"><span class="lineNum">   29388 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   29389 </span>            : static cp_expr
<span class="lineNum">   29390 </span><span class="lineCov">      18634 : cp_parser_objc_expression (cp_parser* parser)</span>
<span class="lineNum">   29391 </span><span class="lineCov">  900912786 : {</span>
<span class="lineNum">   29392 </span>            :   /* Try to figure out what kind of declaration is present.  */
<span class="lineNum">   29393 </span>            :   cp_token *kwd = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   29394 </span>            : 
<span class="lineNum">   29395 </span>            :   switch (kwd-&gt;type)
<span class="lineNum">   29396 </span>            :     {
<span class="lineNum">   29397 </span>            :     case CPP_OPEN_SQUARE:
<span class="lineNum">   29398 </span><span class="lineNoCov">          0 :       return cp_parser_objc_message_expression (parser);</span>
<span class="lineNum">   29399 </span>            : 
<span class="lineNum">   29400 </span><span class="lineCov">  875662803 :     case CPP_OBJC_STRING:</span>
<span class="lineNum">   29401 </span><span class="lineCov">  875662803 :       kwd = cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   29402 </span>            :       return objc_build_string_object (kwd-&gt;u.value);
<span class="lineNum">   29403 </span>            : 
<span class="lineNum">   29404 </span>            :     case CPP_KEYWORD:
<span class="lineNum">   29405 </span>            :       switch (kwd-&gt;keyword)
<span class="lineNum">   29406 </span>            :         {
<span class="lineNum">   29407 </span><span class="lineNoCov">          0 :         case RID_AT_ENCODE:</span>
<span class="lineNum">   29408 </span>            :           return cp_parser_objc_encode_expression (parser);
<span class="lineNum">   29409 </span><span class="lineCov">  187805976 : </span>
<span class="lineNum">   29410 </span>            :         case RID_AT_PROTOCOL:
<span class="lineNum">   29411 </span>            :           return cp_parser_objc_protocol_expression (parser);
<span class="lineNum">   29412 </span>            : 
<span class="lineNum">   29413 </span>            :         case RID_AT_SELECTOR:
<span class="lineNum">   29414 </span>            :           return cp_parser_objc_selector_expression (parser);
<span class="lineNum">   29415 </span>            : 
<span class="lineNum">   29416 </span>            :         default:
<span class="lineNum">   29417 </span>            :           break;
<span class="lineNum">   29418 </span>            :         }
<span class="lineNum">   29419 </span>            :       /* FALLTHRU */
<span class="lineNum">   29420 </span>            :     default:
<span class="lineNum">   29421 </span>            :       error_at (kwd-&gt;location,
<span class="lineNum">   29422 </span>            :                 &quot;misplaced %&lt;@%D%&gt; Objective-C++ construct&quot;,
<span class="lineNum">   29423 </span>            :                 kwd-&gt;u.value);
<span class="lineNum">   29424 </span>            :       cp_parser_skip_to_end_of_block_or_statement (parser);
<span class="lineNum">   29425 </span>            :     }
<span class="lineNum">   29426 </span>            : 
<span class="lineNum">   29427 </span>            :   return error_mark_node;
<span class="lineNum">   29428 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   29429 </span>            : 
<span class="lineNum">   29430 </span>            : /* Parse an Objective-C message expression.
<span class="lineNum">   29431 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29432 </span>            :    objc-message-expression:
<span class="lineNum">   29433 </span><span class="lineNoCov">          0 :      [ objc-message-receiver objc-message-args ]</span>
<span class="lineNum">   29434 </span>            : 
<span class="lineNum">   29435 </span><span class="lineNoCov">          0 :    Returns a representation of an Objective-C message.  */</span>
<a name="29436"><span class="lineNum">   29436 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   29437 </span>            : static tree
<span class="lineNum">   29438 </span><span class="lineNoCov">          0 : cp_parser_objc_message_expression (cp_parser* parser)</span>
<span class="lineNum">   29439 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   29440 </span><span class="lineNoCov">          0 :   tree receiver, messageargs;</span>
<span class="lineNum">   29441 </span>            : 
<span class="lineNum">   29442 </span><span class="lineNoCov">          0 :   location_t start_loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;</span>
<span class="lineNum">   29443 </span><span class="lineNoCov">          0 :   cp_lexer_consume_token (parser-&gt;lexer);  /* Eat '['.  */</span>
<span class="lineNum">   29444 </span>            :   receiver = cp_parser_objc_message_receiver (parser);
<span class="lineNum">   29445 </span><span class="lineNoCov">          0 :   messageargs = cp_parser_objc_message_args (parser);</span>
<span class="lineNum">   29446 </span><span class="lineNoCov">          0 :   location_t end_loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;</span>
<span class="lineNum">   29447 </span>            :   cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);
<span class="lineNum">   29448 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29449 </span><span class="lineNoCov">          0 :   tree result = objc_build_message_expr (receiver, messageargs);</span>
<span class="lineNum">   29450 </span>            : 
<span class="lineNum">   29451 </span><span class="lineNoCov">          0 :   /* Construct a location e.g.</span>
<span class="lineNum">   29452 </span><span class="lineNoCov">          0 :        [self func1:5]</span>
<span class="lineNum">   29453 </span>            :        ^~~~~~~~~~~~~~
<span class="lineNum">   29454 </span>            :      ranging from the '[' to the ']', with the caret at the start.  */
<span class="lineNum">   29455 </span>            :   location_t combined_loc = make_location (start_loc, start_loc, end_loc);
<span class="lineNum">   29456 </span>            :   protected_set_expr_location (result, combined_loc);
<span class="lineNum">   29457 </span>            : 
<span class="lineNum">   29458 </span><span class="lineNoCov">          0 :   return result;</span>
<span class="lineNum">   29459 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   29460 </span>            : 
<span class="lineNum">   29461 </span>            : /* Parse an objc-message-receiver.
<span class="lineNum">   29462 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29463 </span>            :    objc-message-receiver:
<span class="lineNum">   29464 </span>            :      expression
<span class="lineNum">   29465 </span><span class="lineNoCov">          0 :      simple-type-specifier</span>
<span class="lineNum">   29466 </span>            : 
<span class="lineNum">   29467 </span>            :   Returns a representation of the type or expression.  */
<a name="29468"><span class="lineNum">   29468 </span>            : </a>
<span class="lineNum">   29469 </span>            : static tree
<span class="lineNum">   29470 </span>            : cp_parser_objc_message_receiver (cp_parser* parser)
<span class="lineNum">   29471 </span>            : {
<span class="lineNum">   29472 </span>            :   tree rcv;
<span class="lineNum">   29473 </span>            : 
<span class="lineNum">   29474 </span>            :   /* An Objective-C message receiver may be either (1) a type
<span class="lineNum">   29475 </span>            :      or (2) an expression.  */
<span class="lineNum">   29476 </span><span class="lineNoCov">          0 :   cp_parser_parse_tentatively (parser);</span>
<span class="lineNum">   29477 </span>            :   rcv = cp_parser_expression (parser);
<span class="lineNum">   29478 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29479 </span>            :   /* If that worked out, fine.  */
<span class="lineNum">   29480 </span><span class="lineNoCov">          0 :   if (cp_parser_parse_definitely (parser))</span>
<span class="lineNum">   29481 </span><span class="lineNoCov">          0 :     return rcv;</span>
<span class="lineNum">   29482 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29483 </span><span class="lineNoCov">          0 :   cp_parser_parse_tentatively (parser);</span>
<span class="lineNum">   29484 </span><span class="lineNoCov">          0 :   rcv = cp_parser_simple_type_specifier (parser,</span>
<span class="lineNum">   29485 </span><span class="lineNoCov">          0 :                                          /*decl_specs=*/NULL,</span>
<span class="lineNum">   29486 </span>            :                                          CP_PARSER_FLAGS_NONE);
<span class="lineNum">   29487 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29488 </span>            :   if (cp_parser_parse_definitely (parser))
<span class="lineNum">   29489 </span>            :     return objc_get_class_reference (rcv);
<span class="lineNum">   29490 </span>            :   
<span class="lineNum">   29491 </span>            :   cp_parser_error (parser, &quot;objective-c++ message receiver expected&quot;);
<span class="lineNum">   29492 </span>            :   return error_mark_node;
<span class="lineNum">   29493 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   29494 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29495 </span>            : /* Parse the arguments and selectors comprising an Objective-C message.
<span class="lineNum">   29496 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29497 </span>            :    objc-message-args:
<span class="lineNum">   29498 </span>            :      objc-selector
<span class="lineNum">   29499 </span>            :      objc-selector-args
<span class="lineNum">   29500 </span>            :      objc-selector-args , objc-comma-args
<span class="lineNum">   29501 </span>            : 
<span class="lineNum">   29502 </span>            :    objc-selector-args:
<span class="lineNum">   29503 </span>            :      objc-selector [opt] : assignment-expression
<span class="lineNum">   29504 </span>            :      objc-selector-args objc-selector [opt] : assignment-expression
<span class="lineNum">   29505 </span>            : 
<span class="lineNum">   29506 </span>            :    objc-comma-args:
<span class="lineNum">   29507 </span>            :      assignment-expression
<span class="lineNum">   29508 </span><span class="lineNoCov">          0 :      objc-comma-args , assignment-expression</span>
<span class="lineNum">   29509 </span>            : 
<span class="lineNum">   29510 </span><span class="lineNoCov">          0 :    Returns a TREE_LIST, with TREE_PURPOSE containing a list of</span>
<span class="lineNum">   29511 </span>            :    selector arguments and TREE_VALUE containing a list of comma
<span class="lineNum">   29512 </span>            :    arguments.  */
<a name="29513"><span class="lineNum">   29513 </span>            : </a>
<span class="lineNum">   29514 </span><span class="lineNoCov">          0 : static tree</span>
<span class="lineNum">   29515 </span><span class="lineNoCov">          0 : cp_parser_objc_message_args (cp_parser* parser)</span>
<span class="lineNum">   29516 </span>            : {
<span class="lineNum">   29517 </span>            :   tree sel_args = NULL_TREE, addl_args = NULL_TREE;
<span class="lineNum">   29518 </span><span class="lineNoCov">          0 :   bool maybe_unary_selector_p = true;</span>
<span class="lineNum">   29519 </span>            :   cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   29520 </span>            : 
<span class="lineNum">   29521 </span><span class="lineNoCov">          0 :   while (cp_parser_objc_selector_p (token-&gt;type) || token-&gt;type == CPP_COLON)</span>
<span class="lineNum">   29522 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   29523 </span>            :       tree selector = NULL_TREE, arg;
<span class="lineNum">   29524 </span>            : 
<span class="lineNum">   29525 </span>            :       if (token-&gt;type != CPP_COLON)
<span class="lineNum">   29526 </span><span class="lineNoCov">          0 :         selector = cp_parser_objc_selector (parser);</span>
<span class="lineNum">   29527 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29528 </span>            :       /* Detect if we have a unary selector.  */
<span class="lineNum">   29529 </span><span class="lineNoCov">          0 :       if (maybe_unary_selector_p</span>
<span class="lineNum">   29530 </span><span class="lineNoCov">          0 :           &amp;&amp; cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_COLON))</span>
<span class="lineNum">   29531 </span>            :         return build_tree_list (selector, NULL_TREE);
<span class="lineNum">   29532 </span>            : 
<span class="lineNum">   29533 </span>            :       maybe_unary_selector_p = false;
<span class="lineNum">   29534 </span>            :       cp_parser_require (parser, CPP_COLON, RT_COLON);
<span class="lineNum">   29535 </span>            :       arg = cp_parser_assignment_expression (parser);
<span class="lineNum">   29536 </span>            : 
<span class="lineNum">   29537 </span>            :       sel_args
<span class="lineNum">   29538 </span>            :         = chainon (sel_args,
<span class="lineNum">   29539 </span>            :                    build_tree_list (selector, arg));
<span class="lineNum">   29540 </span>            : 
<span class="lineNum">   29541 </span>            :       token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   29542 </span>            :     }
<span class="lineNum">   29543 </span>            : 
<span class="lineNum">   29544 </span>            :   /* Handle non-selector arguments, if any. */
<span class="lineNum">   29545 </span>            :   while (token-&gt;type == CPP_COMMA)
<span class="lineNum">   29546 </span>            :     {
<span class="lineNum">   29547 </span>            :       tree arg;
<span class="lineNum">   29548 </span>            : 
<span class="lineNum">   29549 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   29550 </span>            :       arg = cp_parser_assignment_expression (parser);
<span class="lineNum">   29551 </span>            : 
<span class="lineNum">   29552 </span>            :       addl_args
<span class="lineNum">   29553 </span><span class="lineNoCov">          0 :         = chainon (addl_args,</span>
<span class="lineNum">   29554 </span>            :                    build_tree_list (NULL_TREE, arg));
<span class="lineNum">   29555 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29556 </span><span class="lineNoCov">          0 :       token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   29557 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   29558 </span>            : 
<span class="lineNum">   29559 </span><span class="lineNoCov">          0 :   if (sel_args == NULL_TREE &amp;&amp; addl_args == NULL_TREE)</span>
<span class="lineNum">   29560 </span>            :     {
<span class="lineNum">   29561 </span><span class="lineNoCov">          0 :       cp_parser_error (parser, &quot;objective-c++ message argument(s) are expected&quot;);</span>
<span class="lineNum">   29562 </span>            :       return build_tree_list (error_mark_node, error_mark_node);
<span class="lineNum">   29563 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   29564 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29565 </span>            :   return build_tree_list (sel_args, addl_args);
<span class="lineNum">   29566 </span>            : }
<span class="lineNum">   29567 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29568 </span><span class="lineNoCov">          0 : /* Parse an Objective-C encode expression.</span>
<span class="lineNum">   29569 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29570 </span>            :    objc-encode-expression:
<span class="lineNum">   29571 </span><span class="lineNoCov">          0 :      @encode objc-typename</span>
<span class="lineNum">   29572 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29573 </span><span class="lineNoCov">          0 :    Returns an encoded representation of the type argument.  */</span>
<a name="29574"><span class="lineNum">   29574 </span>            : </a>
<span class="lineNum">   29575 </span><span class="lineNoCov">          0 : static cp_expr</span>
<span class="lineNum">   29576 </span><span class="lineNoCov">          0 : cp_parser_objc_encode_expression (cp_parser* parser)</span>
<span class="lineNum">   29577 </span>            : {
<span class="lineNum">   29578 </span>            :   tree type;
<span class="lineNum">   29579 </span><span class="lineNoCov">          0 :   cp_token *token;</span>
<span class="lineNum">   29580 </span>            :   location_t start_loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">   29581 </span>            : 
<span class="lineNum">   29582 </span>            :   cp_lexer_consume_token (parser-&gt;lexer);  /* Eat '@encode'.  */
<span class="lineNum">   29583 </span><span class="lineNoCov">          0 :   matching_parens parens;</span>
<span class="lineNum">   29584 </span>            :   parens.require_open (parser);
<span class="lineNum">   29585 </span><span class="lineNoCov">          0 :   token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   29586 </span>            :   type = complete_type (cp_parser_type_id (parser));
<span class="lineNum">   29587 </span><span class="lineNoCov">          0 :   parens.require_close (parser);</span>
<span class="lineNum">   29588 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29589 </span>            :   if (!type)
<span class="lineNum">   29590 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   29591 </span><span class="lineNoCov">          0 :       error_at (token-&gt;location, </span>
<span class="lineNum">   29592 </span>            :                 &quot;%&lt;@encode%&gt; must specify a type as an argument&quot;);
<span class="lineNum">   29593 </span>            :       return error_mark_node;
<span class="lineNum">   29594 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   29595 </span>            : 
<span class="lineNum">   29596 </span>            :   /* This happens if we find @encode(T) (where T is a template
<span class="lineNum">   29597 </span><span class="lineNoCov">          0 :      typename or something dependent on a template typename) when</span>
<span class="lineNum">   29598 </span>            :      parsing a template.  In that case, we can't compile it
<span class="lineNum">   29599 </span><span class="lineNoCov">          0 :      immediately, but we rather create an AT_ENCODE_EXPR which will</span>
<span class="lineNum">   29600 </span><span class="lineNoCov">          0 :      need to be instantiated when the template is used.</span>
<span class="lineNum">   29601 </span>            :   */
<span class="lineNum">   29602 </span>            :   if (dependent_type_p (type))
<span class="lineNum">   29603 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   29604 </span>            :       tree value = build_min (AT_ENCODE_EXPR, size_type_node, type);
<span class="lineNum">   29605 </span>            :       TREE_READONLY (value) = 1;
<span class="lineNum">   29606 </span>            :       return value;
<span class="lineNum">   29607 </span>            :     }
<span class="lineNum">   29608 </span>            : 
<span class="lineNum">   29609 </span>            : 
<span class="lineNum">   29610 </span>            :   /* Build a location of the form:
<span class="lineNum">   29611 </span>            :        @encode(int)
<span class="lineNum">   29612 </span>            :        ^~~~~~~~~~~~
<span class="lineNum">   29613 </span>            :      with caret==start at the @ token, finishing at the close paren.  */
<span class="lineNum">   29614 </span><span class="lineNoCov">          0 :   location_t combined_loc</span>
<span class="lineNum">   29615 </span>            :     = make_location (start_loc, start_loc,
<span class="lineNum">   29616 </span><span class="lineNoCov">          0 :                      cp_lexer_previous_token (parser-&gt;lexer)-&gt;location);</span>
<span class="lineNum">   29617 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29618 </span><span class="lineNoCov">          0 :   return cp_expr (objc_build_encode_expr (type), combined_loc);</span>
<span class="lineNum">   29619 </span>            : }
<span class="lineNum">   29620 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29621 </span><span class="lineNoCov">          0 : /* Parse an Objective-C @defs expression.  */</span>
<a name="29622"><span class="lineNum">   29622 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   29623 </span><span class="lineNoCov">          0 : static tree</span>
<span class="lineNum">   29624 </span><span class="lineNoCov">          0 : cp_parser_objc_defs_expression (cp_parser *parser)</span>
<span class="lineNum">   29625 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   29626 </span>            :   tree name;
<span class="lineNum">   29627 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29628 </span>            :   cp_lexer_consume_token (parser-&gt;lexer);  /* Eat '@defs'.  */
<span class="lineNum">   29629 </span><span class="lineNoCov">          0 :   matching_parens parens;</span>
<span class="lineNum">   29630 </span>            :   parens.require_open (parser);
<span class="lineNum">   29631 </span><span class="lineNoCov">          0 :   name = cp_parser_identifier (parser);</span>
<span class="lineNum">   29632 </span>            :   parens.require_close (parser);
<span class="lineNum">   29633 </span>            : 
<span class="lineNum">   29634 </span>            :   return objc_get_class_ivars (name);
<span class="lineNum">   29635 </span>            : }
<span class="lineNum">   29636 </span>            : 
<span class="lineNum">   29637 </span>            : /* Parse an Objective-C protocol expression.
<span class="lineNum">   29638 </span>            : 
<span class="lineNum">   29639 </span>            :   objc-protocol-expression:
<span class="lineNum">   29640 </span><span class="lineNoCov">          0 :     @protocol ( identifier )</span>
<span class="lineNum">   29641 </span>            : 
<span class="lineNum">   29642 </span><span class="lineNoCov">          0 :   Returns a representation of the protocol expression.  */</span>
<a name="29643"><span class="lineNum">   29643 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   29644 </span><span class="lineNoCov">          0 : static tree</span>
<span class="lineNum">   29645 </span>            : cp_parser_objc_protocol_expression (cp_parser* parser)
<span class="lineNum">   29646 </span>            : {
<span class="lineNum">   29647 </span>            :   tree proto;
<span class="lineNum">   29648 </span>            :   location_t start_loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">   29649 </span>            : 
<span class="lineNum">   29650 </span>            :   cp_lexer_consume_token (parser-&gt;lexer);  /* Eat '@protocol'.  */
<span class="lineNum">   29651 </span>            :   matching_parens parens;
<span class="lineNum">   29652 </span><span class="lineNoCov">          0 :   parens.require_open (parser);</span>
<span class="lineNum">   29653 </span><span class="lineNoCov">          0 :   proto = cp_parser_identifier (parser);</span>
<span class="lineNum">   29654 </span><span class="lineNoCov">          0 :   parens.require_close (parser);</span>
<span class="lineNum">   29655 </span>            : 
<span class="lineNum">   29656 </span><span class="lineNoCov">          0 :   /* Build a location of the form:</span>
<span class="lineNum">   29657 </span>            :        @protocol(prot)
<span class="lineNum">   29658 </span>            :        ^~~~~~~~~~~~~~~
<span class="lineNum">   29659 </span>            :      with caret==start at the @ token, finishing at the close paren.  */
<span class="lineNum">   29660 </span>            :   location_t combined_loc
<span class="lineNum">   29661 </span>            :     = make_location (start_loc, start_loc,
<span class="lineNum">   29662 </span><span class="lineNoCov">          0 :                      cp_lexer_previous_token (parser-&gt;lexer)-&gt;location);</span>
<span class="lineNum">   29663 </span>            :   tree result = objc_build_protocol_expr (proto);
<span class="lineNum">   29664 </span><span class="lineNoCov">          0 :   protected_set_expr_location (result, combined_loc);</span>
<span class="lineNum">   29665 </span>            :   return result;
<span class="lineNum">   29666 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   29667 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29668 </span><span class="lineNoCov">          0 : /* Parse an Objective-C selector expression.</span>
<span class="lineNum">   29669 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29670 </span><span class="lineNoCov">          0 :    objc-selector-expression:</span>
<span class="lineNum">   29671 </span>            :      @selector ( objc-method-signature )
<span class="lineNum">   29672 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29673 </span>            :    objc-method-signature:
<span class="lineNum">   29674 </span>            :      objc-selector
<span class="lineNum">   29675 </span>            :      objc-selector-seq
<span class="lineNum">   29676 </span>            : 
<span class="lineNum">   29677 </span>            :    objc-selector-seq:
<span class="lineNum">   29678 </span>            :      objc-selector :
<span class="lineNum">   29679 </span>            :      objc-selector-seq objc-selector :
<span class="lineNum">   29680 </span>            : 
<span class="lineNum">   29681 </span>            :   Returns a representation of the method selector.  */
<a name="29682"><span class="lineNum">   29682 </span>            : </a>
<span class="lineNum">   29683 </span><span class="lineNoCov">          0 : static tree</span>
<span class="lineNum">   29684 </span>            : cp_parser_objc_selector_expression (cp_parser* parser)
<span class="lineNum">   29685 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   29686 </span><span class="lineNoCov">          0 :   tree sel_seq = NULL_TREE;</span>
<span class="lineNum">   29687 </span>            :   bool maybe_unary_selector_p = true;
<span class="lineNum">   29688 </span><span class="lineNoCov">          0 :   cp_token *token;</span>
<span class="lineNum">   29689 </span><span class="lineNoCov">          0 :   location_t loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;</span>
<span class="lineNum">   29690 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29691 </span><span class="lineNoCov">          0 :   cp_lexer_consume_token (parser-&gt;lexer);  /* Eat '@selector'.  */</span>
<span class="lineNum">   29692 </span><span class="lineNoCov">          0 :   matching_parens parens;</span>
<span class="lineNum">   29693 </span>            :   parens.require_open (parser);
<span class="lineNum">   29694 </span>            :   token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   29695 </span>            : 
<span class="lineNum">   29696 </span>            :   while (cp_parser_objc_selector_p (token-&gt;type) || token-&gt;type == CPP_COLON
<span class="lineNum">   29697 </span>            :          || token-&gt;type == CPP_SCOPE)
<span class="lineNum">   29698 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   29699 </span><span class="lineNoCov">          0 :       tree selector = NULL_TREE;</span>
<span class="lineNum">   29700 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29701 </span><span class="lineNoCov">          0 :       if (token-&gt;type != CPP_COLON</span>
<span class="lineNum">   29702 </span><span class="lineNoCov">          0 :           || token-&gt;type == CPP_SCOPE)</span>
<span class="lineNum">   29703 </span><span class="lineNoCov">          0 :         selector = cp_parser_objc_selector (parser);</span>
<span class="lineNum">   29704 </span>            : 
<span class="lineNum">   29705 </span>            :       if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_COLON)
<span class="lineNum">   29706 </span>            :           &amp;&amp; cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_SCOPE))
<span class="lineNum">   29707 </span>            :         {
<span class="lineNum">   29708 </span>            :           /* Detect if we have a unary selector.  */
<span class="lineNum">   29709 </span>            :           if (maybe_unary_selector_p)
<span class="lineNum">   29710 </span>            :             {
<span class="lineNum">   29711 </span>            :               sel_seq = selector;
<span class="lineNum">   29712 </span>            :               goto finish_selector;
<span class="lineNum">   29713 </span>            :             }
<span class="lineNum">   29714 </span>            :           else
<span class="lineNum">   29715 </span>            :             {
<span class="lineNum">   29716 </span>            :               cp_parser_error (parser, &quot;expected %&lt;:%&gt;&quot;);
<span class="lineNum">   29717 </span>            :             }
<span class="lineNum">   29718 </span>            :         }
<span class="lineNum">   29719 </span>            :       maybe_unary_selector_p = false;
<span class="lineNum">   29720 </span>            :       token = cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   29721 </span>            : 
<span class="lineNum">   29722 </span><span class="lineNoCov">          0 :       if (token-&gt;type == CPP_SCOPE)</span>
<span class="lineNum">   29723 </span>            :         {
<span class="lineNum">   29724 </span><span class="lineNoCov">          0 :           sel_seq</span>
<span class="lineNum">   29725 </span><span class="lineNoCov">          0 :             = chainon (sel_seq,</span>
<span class="lineNum">   29726 </span><span class="lineNoCov">          0 :                        build_tree_list (selector, NULL_TREE));</span>
<span class="lineNum">   29727 </span><span class="lineNoCov">          0 :           sel_seq</span>
<span class="lineNum">   29728 </span>            :             = chainon (sel_seq,
<span class="lineNum">   29729 </span><span class="lineNoCov">          0 :                        build_tree_list (NULL_TREE, NULL_TREE));</span>
<span class="lineNum">   29730 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">   29731 </span><span class="lineNoCov">          0 :       else</span>
<span class="lineNum">   29732 </span><span class="lineNoCov">          0 :         sel_seq</span>
<span class="lineNum">   29733 </span>            :           = chainon (sel_seq,
<span class="lineNum">   29734 </span><span class="lineNoCov">          0 :                      build_tree_list (selector, NULL_TREE));</span>
<span class="lineNum">   29735 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29736 </span>            :       token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   29737 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   29738 </span>            : 
<span class="lineNum">   29739 </span><span class="lineNoCov">          0 :  finish_selector:</span>
<span class="lineNum">   29740 </span>            :   parens.require_close (parser);
<span class="lineNum">   29741 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29742 </span>            : 
<span class="lineNum">   29743 </span><span class="lineNoCov">          0 :   /* Build a location of the form:</span>
<span class="lineNum">   29744 </span><span class="lineNoCov">          0 :        @selector(func)</span>
<span class="lineNum">   29745 </span>            :        ^~~~~~~~~~~~~~~
<span class="lineNum">   29746 </span>            :      with caret==start at the @ token, finishing at the close paren.  */
<span class="lineNum">   29747 </span><span class="lineNoCov">          0 :   location_t combined_loc</span>
<span class="lineNum">   29748 </span>            :     = make_location (loc, loc,
<span class="lineNum">   29749 </span><span class="lineNoCov">          0 :                      cp_lexer_previous_token (parser-&gt;lexer)-&gt;location);</span>
<span class="lineNum">   29750 </span><span class="lineNoCov">          0 :   tree result = objc_build_selector_expr (combined_loc, sel_seq);</span>
<span class="lineNum">   29751 </span>            :   /* TODO: objc_build_selector_expr doesn't always honor the location.  */
<span class="lineNum">   29752 </span>            :   protected_set_expr_location (result, combined_loc);
<span class="lineNum">   29753 </span>            :   return result;
<span class="lineNum">   29754 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   29755 </span>            : 
<span class="lineNum">   29756 </span>            : /* Parse a list of identifiers.
<span class="lineNum">   29757 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29758 </span><span class="lineNoCov">          0 :    objc-identifier-list:</span>
<span class="lineNum">   29759 </span>            :      identifier
<span class="lineNum">   29760 </span><span class="lineNoCov">          0 :      objc-identifier-list , identifier</span>
<span class="lineNum">   29761 </span>            : 
<span class="lineNum">   29762 </span><span class="lineNoCov">          0 :    Returns a TREE_LIST of identifier nodes.  */</span>
<a name="29763"><span class="lineNum">   29763 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   29764 </span>            : static tree
<span class="lineNum">   29765 </span><span class="lineNoCov">          0 : cp_parser_objc_identifier_list (cp_parser* parser)</span>
<span class="lineNum">   29766 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   29767 </span>            :   tree identifier;
<span class="lineNum">   29768 </span>            :   tree list;
<span class="lineNum">   29769 </span>            :   cp_token *sep;
<span class="lineNum">   29770 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29771 </span><span class="lineNoCov">          0 :   identifier = cp_parser_identifier (parser);</span>
<span class="lineNum">   29772 </span>            :   if (identifier == error_mark_node)
<span class="lineNum">   29773 </span>            :     return error_mark_node;      
<span class="lineNum">   29774 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29775 </span>            :   list = build_tree_list (NULL_TREE, identifier);
<span class="lineNum">   29776 </span>            :   sep = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   29777 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29778 </span><span class="lineNoCov">          0 :   while (sep-&gt;type == CPP_COMMA)</span>
<span class="lineNum">   29779 </span>            :     {
<span class="lineNum">   29780 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);  /* Eat ','.  */
<span class="lineNum">   29781 </span>            :       identifier = cp_parser_identifier (parser);
<span class="lineNum">   29782 </span>            :       if (identifier == error_mark_node)
<span class="lineNum">   29783 </span>            :         return list;
<span class="lineNum">   29784 </span>            : 
<span class="lineNum">   29785 </span><span class="lineNoCov">          0 :       list = chainon (list, build_tree_list (NULL_TREE,</span>
<span class="lineNum">   29786 </span><span class="lineNoCov">          0 :                                              identifier));</span>
<span class="lineNum">   29787 </span><span class="lineNoCov">          0 :       sep = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   29788 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   29789 </span>            :   
<span class="lineNum">   29790 </span><span class="lineNoCov">          0 :   return list;</span>
<span class="lineNum">   29791 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   29792 </span>            : 
<span class="lineNum">   29793 </span>            : /* Parse an Objective-C alias declaration.
<span class="lineNum">   29794 </span>            : 
<span class="lineNum">   29795 </span>            :    objc-alias-declaration:
<span class="lineNum">   29796 </span>            :      @compatibility_alias identifier identifier ;
<span class="lineNum">   29797 </span>            : 
<span class="lineNum">   29798 </span>            :    This function registers the alias mapping with the Objective-C front end.
<span class="lineNum">   29799 </span>            :    It returns nothing.  */
<a name="29800"><span class="lineNum">   29800 </span>            : </a>
<span class="lineNum">   29801 </span>            : static void
<span class="lineNum">   29802 </span>            : cp_parser_objc_alias_declaration (cp_parser* parser)
<span class="lineNum">   29803 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   29804 </span>            :   tree alias, orig;
<span class="lineNum">   29805 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29806 </span><span class="lineNoCov">          0 :   cp_lexer_consume_token (parser-&gt;lexer);  /* Eat '@compatibility_alias'.  */</span>
<span class="lineNum">   29807 </span><span class="lineNoCov">          0 :   alias = cp_parser_identifier (parser);</span>
<span class="lineNum">   29808 </span>            :   orig = cp_parser_identifier (parser);
<span class="lineNum">   29809 </span><span class="lineNoCov">          0 :   objc_declare_alias (alias, orig);</span>
<span class="lineNum">   29810 </span><span class="lineNoCov">          0 :   cp_parser_consume_semicolon_at_end_of_statement (parser);</span>
<span class="lineNum">   29811 </span>            : }
<span class="lineNum">   29812 </span>            : 
<span class="lineNum">   29813 </span><span class="lineNoCov">          0 : /* Parse an Objective-C class forward-declaration.</span>
<span class="lineNum">   29814 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29815 </span>            :    objc-class-declaration:
<span class="lineNum">   29816 </span><span class="lineNoCov">          0 :      @class objc-identifier-list ;</span>
<span class="lineNum">   29817 </span>            : 
<span class="lineNum">   29818 </span><span class="lineNoCov">          0 :    The function registers the forward declarations with the Objective-C</span>
<span class="lineNum">   29819 </span><span class="lineNoCov">          0 :    front end.  It returns nothing.  */</span>
<a name="29820"><span class="lineNum">   29820 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   29821 </span><span class="lineNoCov">          0 : static void</span>
<span class="lineNum">   29822 </span>            : cp_parser_objc_class_declaration (cp_parser* parser)
<span class="lineNum">   29823 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   29824 </span>            :   cp_lexer_consume_token (parser-&gt;lexer);  /* Eat '@class'.  */
<span class="lineNum">   29825 </span><span class="lineNoCov">          0 :   while (true)</span>
<span class="lineNum">   29826 </span>            :     {
<span class="lineNum">   29827 </span>            :       tree id;
<span class="lineNum">   29828 </span>            :       
<span class="lineNum">   29829 </span>            :       id = cp_parser_identifier (parser);
<span class="lineNum">   29830 </span>            :       if (id == error_mark_node)
<span class="lineNum">   29831 </span>            :         break;
<span class="lineNum">   29832 </span>            :       
<span class="lineNum">   29833 </span>            :       objc_declare_class (id);
<span class="lineNum">   29834 </span>            : 
<span class="lineNum">   29835 </span>            :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_COMMA))
<span class="lineNum">   29836 </span>            :         cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   29837 </span>            :       else
<span class="lineNum">   29838 </span>            :         break;
<span class="lineNum">   29839 </span>            :     }
<span class="lineNum">   29840 </span><span class="lineNoCov">          0 :   cp_parser_consume_semicolon_at_end_of_statement (parser);</span>
<span class="lineNum">   29841 </span>            : }
<span class="lineNum">   29842 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29843 </span>            : /* Parse a list of Objective-C protocol references.
<span class="lineNum">   29844 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29845 </span><span class="lineNoCov">          0 :    objc-protocol-refs-opt:</span>
<span class="lineNum">   29846 </span><span class="lineNoCov">          0 :      objc-protocol-refs [opt]</span>
<span class="lineNum">   29847 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29848 </span><span class="lineNoCov">          0 :    objc-protocol-refs:</span>
<span class="lineNum">   29849 </span><span class="lineNoCov">          0 :      &lt; objc-identifier-list &gt;</span>
<span class="lineNum">   29850 </span>            : 
<span class="lineNum">   29851 </span>            :    Returns a TREE_LIST of identifiers, if any.  */
<a name="29852"><span class="lineNum">   29852 </span>            : </a>
<span class="lineNum">   29853 </span>            : static tree
<span class="lineNum">   29854 </span>            : cp_parser_objc_protocol_refs_opt (cp_parser* parser)
<span class="lineNum">   29855 </span>            : {
<span class="lineNum">   29856 </span>            :   tree protorefs = NULL_TREE;
<span class="lineNum">   29857 </span>            : 
<span class="lineNum">   29858 </span>            :   if(cp_lexer_next_token_is (parser-&gt;lexer, CPP_LESS))
<span class="lineNum">   29859 </span>            :     {
<span class="lineNum">   29860 </span><span class="lineNoCov">          0 :       cp_lexer_consume_token (parser-&gt;lexer);  /* Eat '&lt;'.  */</span>
<span class="lineNum">   29861 </span>            :       protorefs = cp_parser_objc_identifier_list (parser);
<span class="lineNum">   29862 </span><span class="lineNoCov">          0 :       cp_parser_require (parser, CPP_GREATER, RT_GREATER);</span>
<span class="lineNum">   29863 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   29864 </span>            : 
<span class="lineNum">   29865 </span><span class="lineNoCov">          0 :   return protorefs;</span>
<span class="lineNum">   29866 </span>            : }
<span class="lineNum">   29867 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29868 </span><span class="lineNoCov">          0 : /* Parse a Objective-C visibility specification.  */</span>
<a name="29869"><span class="lineNum">   29869 </span>            : </a>
<span class="lineNum">   29870 </span>            : static void
<span class="lineNum">   29871 </span><span class="lineNoCov">          0 : cp_parser_objc_visibility_spec (cp_parser* parser)</span>
<span class="lineNum">   29872 </span>            : {
<span class="lineNum">   29873 </span><span class="lineNoCov">          0 :   cp_token *vis = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   29874 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29875 </span>            :   switch (vis-&gt;keyword)
<span class="lineNum">   29876 </span>            :     {
<span class="lineNum">   29877 </span><span class="lineNoCov">          0 :     case RID_AT_PRIVATE:</span>
<span class="lineNum">   29878 </span><span class="lineNoCov">          0 :       objc_set_visibility (OBJC_IVAR_VIS_PRIVATE);</span>
<span class="lineNum">   29879 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">   29880 </span>            :     case RID_AT_PROTECTED:
<span class="lineNum">   29881 </span>            :       objc_set_visibility (OBJC_IVAR_VIS_PROTECTED);
<span class="lineNum">   29882 </span>            :       break;
<span class="lineNum">   29883 </span>            :     case RID_AT_PUBLIC:
<span class="lineNum">   29884 </span>            :       objc_set_visibility (OBJC_IVAR_VIS_PUBLIC);
<span class="lineNum">   29885 </span>            :       break;
<span class="lineNum">   29886 </span>            :     case RID_AT_PACKAGE:
<span class="lineNum">   29887 </span>            :       objc_set_visibility (OBJC_IVAR_VIS_PACKAGE);
<span class="lineNum">   29888 </span>            :       break;
<span class="lineNum">   29889 </span>            :     default:
<span class="lineNum">   29890 </span>            :       return;
<span class="lineNum">   29891 </span>            :     }
<span class="lineNum">   29892 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29893 </span>            :   /* Eat '@private'/'@protected'/'@public'.  */
<span class="lineNum">   29894 </span><span class="lineNoCov">          0 :   cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   29895 </span>            : }
<span class="lineNum">   29896 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29897 </span>            : /* Parse an Objective-C method type.  Return 'true' if it is a class
<span class="lineNum">   29898 </span><span class="lineNoCov">          0 :    (+) method, and 'false' if it is an instance (-) method.  */</span>
<a name="29899"><span class="lineNum">   29899 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   29900 </span><span class="lineNoCov">          0 : static inline bool</span>
<span class="lineNum">   29901 </span>            : cp_parser_objc_method_type (cp_parser* parser)
<span class="lineNum">   29902 </span>            : {
<span class="lineNum">   29903 </span><span class="lineNoCov">          0 :   if (cp_lexer_consume_token (parser-&gt;lexer)-&gt;type == CPP_PLUS)</span>
<span class="lineNum">   29904 </span>            :     return true;
<span class="lineNum">   29905 </span>            :   else
<span class="lineNum">   29906 </span>            :     return false;
<span class="lineNum">   29907 </span>            : }
<span class="lineNum">   29908 </span>            : 
<span class="lineNum">   29909 </span><span class="lineNoCov">          0 : /* Parse an Objective-C protocol qualifier.  */</span>
<a name="29910"><span class="lineNum">   29910 </span>            : </a>
<span class="lineNum">   29911 </span><span class="lineNoCov">          0 : static tree</span>
<span class="lineNum">   29912 </span>            : cp_parser_objc_protocol_qualifiers (cp_parser* parser)
<span class="lineNum">   29913 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   29914 </span>            :   tree quals = NULL_TREE, node;
<span class="lineNum">   29915 </span><span class="lineNoCov">          0 :   cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   29916 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29917 </span><span class="lineNoCov">          0 :   node = token-&gt;u.value;</span>
<span class="lineNum">   29918 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29919 </span><span class="lineNoCov">          0 :   while (node &amp;&amp; identifier_p (node)</span>
<span class="lineNum">   29920 </span><span class="lineNoCov">          0 :          &amp;&amp; (node == ridpointers [(int) RID_IN]</span>
<span class="lineNum">   29921 </span><span class="lineNoCov">          0 :              || node == ridpointers [(int) RID_OUT]</span>
<span class="lineNum">   29922 </span><span class="lineNoCov">          0 :              || node == ridpointers [(int) RID_INOUT]</span>
<span class="lineNum">   29923 </span><span class="lineNoCov">          0 :              || node == ridpointers [(int) RID_BYCOPY]</span>
<span class="lineNum">   29924 </span><span class="lineNoCov">          0 :              || node == ridpointers [(int) RID_BYREF]</span>
<span class="lineNum">   29925 </span><span class="lineNoCov">          0 :              || node == ridpointers [(int) RID_ONEWAY]))</span>
<span class="lineNum">   29926 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   29927 </span>            :       quals = tree_cons (NULL_TREE, node, quals);
<span class="lineNum">   29928 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   29929 </span>            :       token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   29930 </span>            :       node = token-&gt;u.value;
<span class="lineNum">   29931 </span>            :     }
<span class="lineNum">   29932 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29933 </span>            :   return quals;
<span class="lineNum">   29934 </span>            : }
<span class="lineNum">   29935 </span>            : 
<span class="lineNum">   29936 </span>            : /* Parse an Objective-C typename.  */
<a name="29937"><span class="lineNum">   29937 </span>            : </a>
<span class="lineNum">   29938 </span>            : static tree
<span class="lineNum">   29939 </span><span class="lineNoCov">          0 : cp_parser_objc_typename (cp_parser* parser)</span>
<span class="lineNum">   29940 </span>            : {
<span class="lineNum">   29941 </span><span class="lineNoCov">          0 :   tree type_name = NULL_TREE;</span>
<span class="lineNum">   29942 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29943 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_PAREN))
<span class="lineNum">   29944 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   29945 </span>            :       tree proto_quals, cp_type = NULL_TREE;
<span class="lineNum">   29946 </span>            : 
<span class="lineNum">   29947 </span>            :       matching_parens parens;
<span class="lineNum">   29948 </span>            :       parens.consume_open (parser); /* Eat '('.  */
<span class="lineNum">   29949 </span>            :       proto_quals = cp_parser_objc_protocol_qualifiers (parser);
<span class="lineNum">   29950 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29951 </span>            :       /* An ObjC type name may consist of just protocol qualifiers, in which
<span class="lineNum">   29952 </span><span class="lineNoCov">          0 :          case the type shall default to 'id'.  */</span>
<span class="lineNum">   29953 </span><span class="lineNoCov">          0 :       if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_CLOSE_PAREN))</span>
<span class="lineNum">   29954 </span>            :         {
<span class="lineNum">   29955 </span><span class="lineNoCov">          0 :           cp_type = cp_parser_type_id (parser);</span>
<span class="lineNum">   29956 </span>            :           
<span class="lineNum">   29957 </span><span class="lineNoCov">          0 :           /* If the type could not be parsed, an error has already</span>
<span class="lineNum">   29958 </span><span class="lineNoCov">          0 :              been produced.  For error recovery, behave as if it had</span>
<span class="lineNum">   29959 </span><span class="lineNoCov">          0 :              not been specified, which will use the default type</span>
<span class="lineNum">   29960 </span><span class="lineNoCov">          0 :              'id'.  */</span>
<span class="lineNum">   29961 </span><span class="lineNoCov">          0 :           if (cp_type == error_mark_node)</span>
<span class="lineNum">   29962 </span><span class="lineNoCov">          0 :             {</span>
<span class="lineNum">   29963 </span><span class="lineNoCov">          0 :               cp_type = NULL_TREE;</span>
<span class="lineNum">   29964 </span>            :               /* We need to skip to the closing parenthesis as
<span class="lineNum">   29965 </span><span class="lineNoCov">          0 :                  cp_parser_type_id() does not seem to do it for</span>
<span class="lineNum">   29966 </span><span class="lineNoCov">          0 :                  us.  */</span>
<span class="lineNum">   29967 </span><span class="lineNoCov">          0 :               cp_parser_skip_to_closing_parenthesis (parser,</span>
<span class="lineNum">   29968 </span><span class="lineNoCov">          0 :                                                      /*recovering=*/true,</span>
<span class="lineNum">   29969 </span>            :                                                      /*or_comma=*/false,
<span class="lineNum">   29970 </span>            :                                                      /*consume_paren=*/false);
<span class="lineNum">   29971 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">   29972 </span>            :         }
<span class="lineNum">   29973 </span>            : 
<span class="lineNum">   29974 </span>            :       parens.require_close (parser);
<span class="lineNum">   29975 </span>            :       type_name = build_tree_list (proto_quals, cp_type);
<span class="lineNum">   29976 </span>            :     }
<span class="lineNum">   29977 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   29978 </span>            :   return type_name;
<span class="lineNum">   29979 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   29980 </span>            : 
<span class="lineNum">   29981 </span><span class="lineNoCov">          0 : /* Check to see if TYPE refers to an Objective-C selector name.  */</span>
<a name="29982"><span class="lineNum">   29982 </span>            : </a>
<span class="lineNum">   29983 </span><span class="lineNoCov">          0 : static bool</span>
<span class="lineNum">   29984 </span>            : cp_parser_objc_selector_p (enum cpp_ttype type)
<span class="lineNum">   29985 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   29986 </span><span class="lineNoCov">          0 :   return (type == CPP_NAME || type == CPP_KEYWORD</span>
<span class="lineNum">   29987 </span><span class="lineNoCov">          0 :           || type == CPP_AND_AND || type == CPP_AND_EQ || type == CPP_AND</span>
<span class="lineNum">   29988 </span>            :           || type == CPP_OR || type == CPP_COMPL || type == CPP_NOT
<span class="lineNum">   29989 </span>            :           || type == CPP_NOT_EQ || type == CPP_OR_OR || type == CPP_OR_EQ
<span class="lineNum">   29990 </span>            :           || type == CPP_XOR || type == CPP_XOR_EQ);
<span class="lineNum">   29991 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   29992 </span>            : 
<span class="lineNum">   29993 </span><span class="lineNoCov">          0 : /* Parse an Objective-C selector.  */</span>
<a name="29994"><span class="lineNum">   29994 </span>            : </a>
<span class="lineNum">   29995 </span>            : static tree
<span class="lineNum">   29996 </span>            : cp_parser_objc_selector (cp_parser* parser)
<span class="lineNum">   29997 </span>            : {
<span class="lineNum">   29998 </span>            :   cp_token *token = cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   29999 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30000 </span>            :   if (!cp_parser_objc_selector_p (token-&gt;type))
<span class="lineNum">   30001 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   30002 </span>            :       error_at (token-&gt;location, &quot;invalid Objective-C++ selector name&quot;);
<span class="lineNum">   30003 </span>            :       return error_mark_node;
<span class="lineNum">   30004 </span>            :     }
<span class="lineNum">   30005 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30006 </span>            :   /* C++ operator names are allowed to appear in ObjC selectors.  */
<span class="lineNum">   30007 </span>            :   switch (token-&gt;type)
<span class="lineNum">   30008 </span>            :     {
<span class="lineNum">   30009 </span>            :     case CPP_AND_AND: return get_identifier (&quot;and&quot;);
<span class="lineNum">   30010 </span>            :     case CPP_AND_EQ: return get_identifier (&quot;and_eq&quot;);
<span class="lineNum">   30011 </span>            :     case CPP_AND: return get_identifier (&quot;bitand&quot;);
<span class="lineNum">   30012 </span><span class="lineNoCov">          0 :     case CPP_OR: return get_identifier (&quot;bitor&quot;);</span>
<span class="lineNum">   30013 </span><span class="lineNoCov">          0 :     case CPP_COMPL: return get_identifier (&quot;compl&quot;);</span>
<span class="lineNum">   30014 </span>            :     case CPP_NOT: return get_identifier (&quot;not&quot;);
<span class="lineNum">   30015 </span>            :     case CPP_NOT_EQ: return get_identifier (&quot;not_eq&quot;);
<span class="lineNum">   30016 </span><span class="lineNoCov">          0 :     case CPP_OR_OR: return get_identifier (&quot;or&quot;);</span>
<span class="lineNum">   30017 </span>            :     case CPP_OR_EQ: return get_identifier (&quot;or_eq&quot;);
<span class="lineNum">   30018 </span>            :     case CPP_XOR: return get_identifier (&quot;xor&quot;);
<span class="lineNum">   30019 </span>            :     case CPP_XOR_EQ: return get_identifier (&quot;xor_eq&quot;);
<span class="lineNum">   30020 </span>            :     default: return token-&gt;u.value;
<span class="lineNum">   30021 </span>            :     }
<span class="lineNum">   30022 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   30023 </span>            : 
<span class="lineNum">   30024 </span><span class="lineNoCov">          0 : /* Parse an Objective-C params list.  */</span>
<a name="30025"><span class="lineNum">   30025 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   30026 </span><span class="lineNoCov">          0 : static tree</span>
<span class="lineNum">   30027 </span><span class="lineNoCov">          0 : cp_parser_objc_method_keyword_params (cp_parser* parser, tree* attributes)</span>
<span class="lineNum">   30028 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   30029 </span>            :   tree params = NULL_TREE;
<span class="lineNum">   30030 </span>            :   bool maybe_unary_selector_p = true;
<span class="lineNum">   30031 </span>            :   cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   30032 </span>            : 
<span class="lineNum">   30033 </span>            :   while (cp_parser_objc_selector_p (token-&gt;type) || token-&gt;type == CPP_COLON)
<span class="lineNum">   30034 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   30035 </span>            :       tree selector = NULL_TREE, type_name, identifier;
<span class="lineNum">   30036 </span><span class="lineNoCov">          0 :       tree parm_attr = NULL_TREE;</span>
<span class="lineNum">   30037 </span>            : 
<span class="lineNum">   30038 </span><span class="lineNoCov">          0 :       if (token-&gt;keyword == RID_ATTRIBUTE)</span>
<span class="lineNum">   30039 </span>            :         break;
<span class="lineNum">   30040 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30041 </span><span class="lineNoCov">          0 :       if (token-&gt;type != CPP_COLON)</span>
<span class="lineNum">   30042 </span>            :         selector = cp_parser_objc_selector (parser);
<span class="lineNum">   30043 </span>            : 
<span class="lineNum">   30044 </span>            :       /* Detect if we have a unary selector.  */
<span class="lineNum">   30045 </span><span class="lineNoCov">          0 :       if (maybe_unary_selector_p</span>
<span class="lineNum">   30046 </span>            :           &amp;&amp; cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_COLON))
<span class="lineNum">   30047 </span><span class="lineNoCov">          0 :         {</span>
<span class="lineNum">   30048 </span><span class="lineNoCov">          0 :           params = selector; /* Might be followed by attributes.  */</span>
<span class="lineNum">   30049 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   30050 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">   30051 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30052 </span><span class="lineNoCov">          0 :       maybe_unary_selector_p = false;</span>
<span class="lineNum">   30053 </span><span class="lineNoCov">          0 :       if (!cp_parser_require (parser, CPP_COLON, RT_COLON))</span>
<span class="lineNum">   30054 </span><span class="lineNoCov">          0 :         {</span>
<span class="lineNum">   30055 </span><span class="lineNoCov">          0 :           /* Something went quite wrong.  There should be a colon</span>
<span class="lineNum">   30056 </span><span class="lineNoCov">          0 :              here, but there is not.  Stop parsing parameters.  */</span>
<span class="lineNum">   30057 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   30058 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">   30059 </span>            :       type_name = cp_parser_objc_typename (parser);
<span class="lineNum">   30060 </span>            :       /* New ObjC allows attributes on parameters too.  */
<span class="lineNum">   30061 </span>            :       if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_ATTRIBUTE))
<span class="lineNum">   30062 </span>            :         parm_attr = cp_parser_attributes_opt (parser);
<span class="lineNum">   30063 </span>            :       identifier = cp_parser_identifier (parser);
<span class="lineNum">   30064 </span>            : 
<span class="lineNum">   30065 </span><span class="lineNoCov">          0 :       params</span>
<span class="lineNum">   30066 </span>            :         = chainon (params,
<span class="lineNum">   30067 </span><span class="lineNoCov">          0 :                    objc_build_keyword_decl (selector,</span>
<span class="lineNum">   30068 </span><span class="lineNoCov">          0 :                                             type_name,</span>
<span class="lineNum">   30069 </span><span class="lineNoCov">          0 :                                             identifier,</span>
<span class="lineNum">   30070 </span>            :                                             parm_attr));
<span class="lineNum">   30071 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30072 </span>            :       token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   30073 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   30074 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30075 </span>            :   if (params == NULL_TREE)
<span class="lineNum">   30076 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   30077 </span>            :       cp_parser_error (parser, &quot;objective-c++ method declaration is expected&quot;);
<span class="lineNum">   30078 </span>            :       return error_mark_node;
<span class="lineNum">   30079 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   30080 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30081 </span>            :   /* We allow tail attributes for the method.  */
<span class="lineNum">   30082 </span>            :   if (token-&gt;keyword == RID_ATTRIBUTE)
<span class="lineNum">   30083 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   30084 </span><span class="lineNoCov">          0 :       *attributes = cp_parser_attributes_opt (parser);</span>
<span class="lineNum">   30085 </span>            :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_SEMICOLON)
<span class="lineNum">   30086 </span>            :           || cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_BRACE))
<span class="lineNum">   30087 </span>            :         return params;
<span class="lineNum">   30088 </span>            :       cp_parser_error (parser, 
<span class="lineNum">   30089 </span>            :                        &quot;method attributes must be specified at the end&quot;);
<span class="lineNum">   30090 </span><span class="lineNoCov">          0 :       return error_mark_node;</span>
<span class="lineNum">   30091 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   30092 </span>            : 
<span class="lineNum">   30093 </span>            :   if (params == NULL_TREE)
<span class="lineNum">   30094 </span>            :     {
<span class="lineNum">   30095 </span>            :       cp_parser_error (parser, &quot;objective-c++ method declaration is expected&quot;);
<span class="lineNum">   30096 </span>            :       return error_mark_node;
<span class="lineNum">   30097 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   30098 </span>            :   return params;
<span class="lineNum">   30099 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   30100 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30101 </span><span class="lineNoCov">          0 : /* Parse the non-keyword Objective-C params.  */</span>
<a name="30102"><span class="lineNum">   30102 </span>            : </a>
<span class="lineNum">   30103 </span><span class="lineNoCov">          0 : static tree</span>
<span class="lineNum">   30104 </span><span class="lineNoCov">          0 : cp_parser_objc_method_tail_params_opt (cp_parser* parser, bool *ellipsisp, </span>
<span class="lineNum">   30105 </span>            :                                        tree* attributes)
<span class="lineNum">   30106 </span>            : {
<span class="lineNum">   30107 </span>            :   tree params = make_node (TREE_LIST);
<span class="lineNum">   30108 </span>            :   cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   30109 </span>            :   *ellipsisp = false;  /* Initially, assume no ellipsis.  */
<span class="lineNum">   30110 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30111 </span>            :   while (token-&gt;type == CPP_COMMA)
<span class="lineNum">   30112 </span>            :     {
<span class="lineNum">   30113 </span><span class="lineNoCov">          0 :       cp_parameter_declarator *parmdecl;</span>
<span class="lineNum">   30114 </span>            :       tree parm;
<span class="lineNum">   30115 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30116 </span><span class="lineNoCov">          0 :       cp_lexer_consume_token (parser-&gt;lexer);  /* Eat ','.  */</span>
<span class="lineNum">   30117 </span>            :       token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   30118 </span>            : 
<span class="lineNum">   30119 </span>            :       if (token-&gt;type == CPP_ELLIPSIS)
<span class="lineNum">   30120 </span><span class="lineNoCov">          0 :         {</span>
<span class="lineNum">   30121 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);  /* Eat '...'.  */
<span class="lineNum">   30122 </span><span class="lineNoCov">          0 :           *ellipsisp = true;</span>
<span class="lineNum">   30123 </span><span class="lineNoCov">          0 :           token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   30124 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   30125 </span>            :         }
<span class="lineNum">   30126 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30127 </span>            :       /* TODO: parse attributes for tail parameters.  */
<span class="lineNum">   30128 </span><span class="lineNoCov">          0 :       parmdecl = cp_parser_parameter_declaration (parser, false, NULL);</span>
<span class="lineNum">   30129 </span>            :       parm = grokdeclarator (parmdecl-&gt;declarator,
<span class="lineNum">   30130 </span>            :                              &amp;parmdecl-&gt;decl_specifiers,
<span class="lineNum">   30131 </span>            :                              PARM, /*initialized=*/0,
<span class="lineNum">   30132 </span>            :                              /*attrlist=*/NULL);
<span class="lineNum">   30133 </span>            : 
<span class="lineNum">   30134 </span>            :       chainon (params, build_tree_list (NULL_TREE, parm));
<span class="lineNum">   30135 </span>            :       token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   30136 </span>            :     }
<span class="lineNum">   30137 </span>            : 
<span class="lineNum">   30138 </span>            :   /* We allow tail attributes for the method.  */
<span class="lineNum">   30139 </span>            :   if (token-&gt;keyword == RID_ATTRIBUTE)
<span class="lineNum">   30140 </span>            :     {
<span class="lineNum">   30141 </span>            :       if (*attributes == NULL_TREE)
<span class="lineNum">   30142 </span><span class="lineNoCov">          0 :         {</span>
<span class="lineNum">   30143 </span>            :           *attributes = cp_parser_attributes_opt (parser);
<span class="lineNum">   30144 </span>            :           if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_SEMICOLON)
<span class="lineNum">   30145 </span><span class="lineNoCov">          0 :               || cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_BRACE))</span>
<span class="lineNum">   30146 </span><span class="lineNoCov">          0 :             return params;</span>
<span class="lineNum">   30147 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">   30148 </span>            :       else        
<span class="lineNum">   30149 </span><span class="lineNoCov">          0 :         /* We have an error, but parse the attributes, so that we can </span>
<span class="lineNum">   30150 </span>            :            carry on.  */
<span class="lineNum">   30151 </span><span class="lineNoCov">          0 :         *attributes = cp_parser_attributes_opt (parser);</span>
<span class="lineNum">   30152 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30153 </span>            :       cp_parser_error (parser, 
<span class="lineNum">   30154 </span><span class="lineNoCov">          0 :                        &quot;method attributes must be specified at the end&quot;);</span>
<span class="lineNum">   30155 </span><span class="lineNoCov">          0 :       return error_mark_node;</span>
<span class="lineNum">   30156 </span>            :     }
<span class="lineNum">   30157 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30158 </span>            :   return params;
<span class="lineNum">   30159 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   30160 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30161 </span><span class="lineNoCov">          0 : /* Parse a linkage specification, a pragma, an extra semicolon or a block.  */</span>
<a name="30162"><span class="lineNum">   30162 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   30163 </span>            : static void
<span class="lineNum">   30164 </span>            : cp_parser_objc_interstitial_code (cp_parser* parser)
<span class="lineNum">   30165 </span>            : {
<span class="lineNum">   30166 </span><span class="lineNoCov">          0 :   cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   30167 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30168 </span>            :   /* If the next token is `extern' and the following token is a string
<span class="lineNum">   30169 </span>            :      literal, then we have a linkage specification.  */
<span class="lineNum">   30170 </span>            :   if (token-&gt;keyword == RID_EXTERN
<span class="lineNum">   30171 </span>            :       &amp;&amp; cp_parser_is_pure_string_literal
<span class="lineNum">   30172 </span><span class="lineNoCov">          0 :          (cp_lexer_peek_nth_token (parser-&gt;lexer, 2)))</span>
<span class="lineNum">   30173 </span><span class="lineNoCov">          0 :     cp_parser_linkage_specification (parser);</span>
<span class="lineNum">   30174 </span>            :   /* Handle #pragma, if any.  */
<span class="lineNum">   30175 </span>            :   else if (token-&gt;type == CPP_PRAGMA)
<span class="lineNum">   30176 </span>            :     cp_parser_pragma (parser, pragma_objc_icode, NULL);
<span class="lineNum">   30177 </span><span class="lineNoCov">          0 :   /* Allow stray semicolons.  */</span>
<span class="lineNum">   30178 </span>            :   else if (token-&gt;type == CPP_SEMICOLON)
<span class="lineNum">   30179 </span><span class="lineNoCov">          0 :     cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   30180 </span>            :   /* Mark methods as optional or required, when building protocols.  */
<span class="lineNum">   30181 </span><span class="lineNoCov">          0 :   else if (token-&gt;keyword == RID_AT_OPTIONAL)</span>
<span class="lineNum">   30182 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   30183 </span><span class="lineNoCov">          0 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   30184 </span>            :       objc_set_method_opt (true);
<span class="lineNum">   30185 </span>            :     }
<span class="lineNum">   30186 </span>            :   else if (token-&gt;keyword == RID_AT_REQUIRED)
<span class="lineNum">   30187 </span>            :     {
<span class="lineNum">   30188 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   30189 </span><span class="lineNoCov">          0 :       objc_set_method_opt (false);</span>
<span class="lineNum">   30190 </span>            :     }
<span class="lineNum">   30191 </span><span class="lineNoCov">          0 :   else if (token-&gt;keyword == RID_NAMESPACE)</span>
<span class="lineNum">   30192 </span>            :     cp_parser_namespace_definition (parser);
<span class="lineNum">   30193 </span><span class="lineNoCov">          0 :   /* Other stray characters must generate errors.  */</span>
<span class="lineNum">   30194 </span>            :   else if (token-&gt;type == CPP_OPEN_BRACE || token-&gt;type == CPP_CLOSE_BRACE)
<span class="lineNum">   30195 </span>            :     {
<span class="lineNum">   30196 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   30197 </span>            :       error (&quot;stray %qs between Objective-C++ methods&quot;,
<span class="lineNum">   30198 </span>            :              token-&gt;type == CPP_OPEN_BRACE ? &quot;{&quot; : &quot;}&quot;);
<span class="lineNum">   30199 </span>            :     }
<span class="lineNum">   30200 </span>            :   /* Finally, try to parse a block-declaration, or a function-definition.  */
<span class="lineNum">   30201 </span>            :   else
<span class="lineNum">   30202 </span><span class="lineNoCov">          0 :     cp_parser_block_declaration (parser, /*statement_p=*/false);</span>
<span class="lineNum">   30203 </span>            : }
<span class="lineNum">   30204 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30205 </span>            : /* Parse a method signature.  */
<a name="30206"><span class="lineNum">   30206 </span>            : </a>
<span class="lineNum">   30207 </span>            : static tree
<span class="lineNum">   30208 </span><span class="lineNoCov">          0 : cp_parser_objc_method_signature (cp_parser* parser, tree* attributes)</span>
<span class="lineNum">   30209 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   30210 </span><span class="lineNoCov">          0 :   tree rettype, kwdparms, optparms;</span>
<span class="lineNum">   30211 </span><span class="lineNoCov">          0 :   bool ellipsis = false;</span>
<span class="lineNum">   30212 </span>            :   bool is_class_method;
<span class="lineNum">   30213 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30214 </span><span class="lineNoCov">          0 :   is_class_method = cp_parser_objc_method_type (parser);</span>
<span class="lineNum">   30215 </span>            :   rettype = cp_parser_objc_typename (parser);
<span class="lineNum">   30216 </span><span class="lineNoCov">          0 :   *attributes = NULL_TREE;</span>
<span class="lineNum">   30217 </span><span class="lineNoCov">          0 :   kwdparms = cp_parser_objc_method_keyword_params (parser, attributes);</span>
<span class="lineNum">   30218 </span>            :   if (kwdparms == error_mark_node)
<span class="lineNum">   30219 </span><span class="lineNoCov">          0 :     return error_mark_node;</span>
<span class="lineNum">   30220 </span>            :   optparms = cp_parser_objc_method_tail_params_opt (parser, &amp;ellipsis, attributes);
<span class="lineNum">   30221 </span><span class="lineNoCov">          0 :   if (optparms == error_mark_node)</span>
<span class="lineNum">   30222 </span><span class="lineNoCov">          0 :     return error_mark_node;</span>
<span class="lineNum">   30223 </span>            : 
<span class="lineNum">   30224 </span><span class="lineNoCov">          0 :   return objc_build_method_signature (is_class_method, rettype, kwdparms, optparms, ellipsis);</span>
<span class="lineNum">   30225 </span>            : }
<a name="30226"><span class="lineNum">   30226 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   30227 </span><span class="lineNoCov">          0 : static bool</span>
<span class="lineNum">   30228 </span>            : cp_parser_objc_method_maybe_bad_prefix_attributes (cp_parser* parser)
<span class="lineNum">   30229 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   30230 </span><span class="lineNoCov">          0 :   tree tattr;  </span>
<span class="lineNum">   30231 </span>            :   cp_lexer_save_tokens (parser-&gt;lexer);
<span class="lineNum">   30232 </span><span class="lineNoCov">          0 :   tattr = cp_parser_attributes_opt (parser);</span>
<span class="lineNum">   30233 </span>            :   gcc_assert (tattr) ;
<span class="lineNum">   30234 </span><span class="lineNoCov">          0 :   </span>
<span class="lineNum">   30235 </span><span class="lineNoCov">          0 :   /* If the attributes are followed by a method introducer, this is not allowed.</span>
<span class="lineNum">   30236 </span><span class="lineNoCov">          0 :      Dump the attributes and flag the situation.  */</span>
<span class="lineNum">   30237 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_PLUS)
<span class="lineNum">   30238 </span>            :       || cp_lexer_next_token_is (parser-&gt;lexer, CPP_MINUS))
<span class="lineNum">   30239 </span>            :     return true;
<span class="lineNum">   30240 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30241 </span><span class="lineNoCov">          0 :   /* Otherwise, the attributes introduce some interstitial code, possibly so</span>
<span class="lineNum">   30242 </span>            :      rewind to allow that check.  */
<span class="lineNum">   30243 </span>            :   cp_lexer_rollback_tokens (parser-&gt;lexer);
<span class="lineNum">   30244 </span>            :   return false;  
<span class="lineNum">   30245 </span>            : }
<span class="lineNum">   30246 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30247 </span>            : /* Parse an Objective-C method prototype list.  */
<a name="30248"><span class="lineNum">   30248 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   30249 </span><span class="lineNoCov">          0 : static void</span>
<span class="lineNum">   30250 </span><span class="lineNoCov">          0 : cp_parser_objc_method_prototype_list (cp_parser* parser)</span>
<span class="lineNum">   30251 </span>            : {
<span class="lineNum">   30252 </span><span class="lineNoCov">          0 :   cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   30253 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30254 </span><span class="lineNoCov">          0 :   while (token-&gt;keyword != RID_AT_END &amp;&amp; token-&gt;type != CPP_EOF)</span>
<span class="lineNum">   30255 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   30256 </span><span class="lineNoCov">          0 :       if (token-&gt;type == CPP_PLUS || token-&gt;type == CPP_MINUS)</span>
<span class="lineNum">   30257 </span>            :         {
<span class="lineNum">   30258 </span><span class="lineNoCov">          0 :           tree attributes, sig;</span>
<span class="lineNum">   30259 </span><span class="lineNoCov">          0 :           bool is_class_method;</span>
<span class="lineNum">   30260 </span>            :           if (token-&gt;type == CPP_PLUS)
<span class="lineNum">   30261 </span>            :             is_class_method = true;
<span class="lineNum">   30262 </span><span class="lineNoCov">          0 :           else</span>
<span class="lineNum">   30263 </span>            :             is_class_method = false;
<span class="lineNum">   30264 </span>            :           sig = cp_parser_objc_method_signature (parser, &amp;attributes);
<span class="lineNum">   30265 </span>            :           if (sig == error_mark_node)
<span class="lineNum">   30266 </span><span class="lineNoCov">          0 :             {</span>
<span class="lineNum">   30267 </span>            :               cp_parser_skip_to_end_of_block_or_statement (parser);
<span class="lineNum">   30268 </span><span class="lineNoCov">          0 :               token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   30269 </span><span class="lineNoCov">          0 :               continue;</span>
<span class="lineNum">   30270 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">   30271 </span><span class="lineNoCov">          0 :           objc_add_method_declaration (is_class_method, sig, attributes);</span>
<span class="lineNum">   30272 </span>            :           cp_parser_consume_semicolon_at_end_of_statement (parser);
<span class="lineNum">   30273 </span>            :         }
<span class="lineNum">   30274 </span>            :       else if (token-&gt;keyword == RID_AT_PROPERTY)
<span class="lineNum">   30275 </span><span class="lineNoCov">          0 :         cp_parser_objc_at_property_declaration (parser);</span>
<span class="lineNum">   30276 </span><span class="lineNoCov">          0 :       else if (token-&gt;keyword == RID_ATTRIBUTE </span>
<span class="lineNum">   30277 </span>            :                &amp;&amp; cp_parser_objc_method_maybe_bad_prefix_attributes(parser))
<span class="lineNum">   30278 </span>            :         warning_at (cp_lexer_peek_token (parser-&gt;lexer)-&gt;location, 
<span class="lineNum">   30279 </span>            :                     OPT_Wattributes, 
<span class="lineNum">   30280 </span>            :                     &quot;prefix attributes are ignored for methods&quot;);
<span class="lineNum">   30281 </span><span class="lineNoCov">          0 :       else</span>
<span class="lineNum">   30282 </span><span class="lineNoCov">          0 :         /* Allow for interspersed non-ObjC++ code.  */</span>
<span class="lineNum">   30283 </span>            :         cp_parser_objc_interstitial_code (parser);
<span class="lineNum">   30284 </span>            : 
<span class="lineNum">   30285 </span>            :       token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   30286 </span>            :     }
<span class="lineNum">   30287 </span>            : 
<span class="lineNum">   30288 </span><span class="lineNoCov">          0 :   if (token-&gt;type != CPP_EOF)</span>
<span class="lineNum">   30289 </span>            :     cp_lexer_consume_token (parser-&gt;lexer);  /* Eat '@end'.  */
<span class="lineNum">   30290 </span><span class="lineNoCov">          0 :   else</span>
<span class="lineNum">   30291 </span>            :     cp_parser_error (parser, &quot;expected %&lt;@end%&gt;&quot;);
<span class="lineNum">   30292 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30293 </span>            :   objc_finish_interface ();
<span class="lineNum">   30294 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   30295 </span>            : 
<span class="lineNum">   30296 </span><span class="lineNoCov">          0 : /* Parse an Objective-C method definition list.  */</span>
<a name="30297"><span class="lineNum">   30297 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   30298 </span><span class="lineNoCov">          0 : static void</span>
<span class="lineNum">   30299 </span>            : cp_parser_objc_method_definition_list (cp_parser* parser)
<span class="lineNum">   30300 </span>            : {
<span class="lineNum">   30301 </span><span class="lineNoCov">          0 :   cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   30302 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30303 </span><span class="lineNoCov">          0 :   while (token-&gt;keyword != RID_AT_END &amp;&amp; token-&gt;type != CPP_EOF)</span>
<span class="lineNum">   30304 </span>            :     {
<span class="lineNum">   30305 </span><span class="lineNoCov">          0 :       tree meth;</span>
<span class="lineNum">   30306 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30307 </span><span class="lineNoCov">          0 :       if (token-&gt;type == CPP_PLUS || token-&gt;type == CPP_MINUS)</span>
<span class="lineNum">   30308 </span>            :         {
<span class="lineNum">   30309 </span><span class="lineNoCov">          0 :           cp_token *ptk;</span>
<span class="lineNum">   30310 </span><span class="lineNoCov">          0 :           tree sig, attribute;</span>
<span class="lineNum">   30311 </span>            :           bool is_class_method;
<span class="lineNum">   30312 </span><span class="lineNoCov">          0 :           if (token-&gt;type == CPP_PLUS)</span>
<span class="lineNum">   30313 </span><span class="lineNoCov">          0 :             is_class_method = true;</span>
<span class="lineNum">   30314 </span><span class="lineNoCov">          0 :           else</span>
<span class="lineNum">   30315 </span><span class="lineNoCov">          0 :             is_class_method = false;</span>
<span class="lineNum">   30316 </span><span class="lineNoCov">          0 :           push_deferring_access_checks (dk_deferred);</span>
<span class="lineNum">   30317 </span>            :           sig = cp_parser_objc_method_signature (parser, &amp;attribute);
<span class="lineNum">   30318 </span>            :           if (sig == error_mark_node)
<span class="lineNum">   30319 </span>            :             {
<span class="lineNum">   30320 </span>            :               cp_parser_skip_to_end_of_block_or_statement (parser);
<span class="lineNum">   30321 </span><span class="lineNoCov">          0 :               token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   30322 </span>            :               continue;
<span class="lineNum">   30323 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">   30324 </span>            :           objc_start_method_definition (is_class_method, sig, attribute,
<span class="lineNum">   30325 </span>            :                                         NULL_TREE);
<span class="lineNum">   30326 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30327 </span><span class="lineNoCov">          0 :           /* For historical reasons, we accept an optional semicolon.  */</span>
<span class="lineNum">   30328 </span>            :           if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_SEMICOLON))
<span class="lineNum">   30329 </span><span class="lineNoCov">          0 :             cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   30330 </span>            : 
<span class="lineNum">   30331 </span><span class="lineNoCov">          0 :           ptk = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   30332 </span><span class="lineNoCov">          0 :           if (!(ptk-&gt;type == CPP_PLUS || ptk-&gt;type == CPP_MINUS </span>
<span class="lineNum">   30333 </span>            :                 || ptk-&gt;type == CPP_EOF || ptk-&gt;keyword == RID_AT_END))
<span class="lineNum">   30334 </span>            :             {
<span class="lineNum">   30335 </span>            :               perform_deferred_access_checks (tf_warning_or_error);
<span class="lineNum">   30336 </span>            :               stop_deferring_access_checks ();
<span class="lineNum">   30337 </span><span class="lineNoCov">          0 :               meth = cp_parser_function_definition_after_declarator (parser,</span>
<span class="lineNum">   30338 </span>            :                                                                      false);
<span class="lineNum">   30339 </span><span class="lineNoCov">          0 :               pop_deferring_access_checks ();</span>
<span class="lineNum">   30340 </span>            :               objc_finish_method_definition (meth);
<span class="lineNum">   30341 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">   30342 </span>            :         }
<span class="lineNum">   30343 </span><span class="lineNoCov">          0 :       /* The following case will be removed once @synthesize is</span>
<span class="lineNum">   30344 </span>            :          completely implemented.  */
<span class="lineNum">   30345 </span><span class="lineNoCov">          0 :       else if (token-&gt;keyword == RID_AT_PROPERTY)</span>
<span class="lineNum">   30346 </span>            :         cp_parser_objc_at_property_declaration (parser);
<span class="lineNum">   30347 </span><span class="lineNoCov">          0 :       else if (token-&gt;keyword == RID_AT_SYNTHESIZE)</span>
<span class="lineNum">   30348 </span><span class="lineNoCov">          0 :         cp_parser_objc_at_synthesize_declaration (parser);</span>
<span class="lineNum">   30349 </span><span class="lineNoCov">          0 :       else if (token-&gt;keyword == RID_AT_DYNAMIC)</span>
<span class="lineNum">   30350 </span><span class="lineNoCov">          0 :         cp_parser_objc_at_dynamic_declaration (parser);</span>
<span class="lineNum">   30351 </span>            :       else if (token-&gt;keyword == RID_ATTRIBUTE 
<span class="lineNum">   30352 </span>            :                &amp;&amp; cp_parser_objc_method_maybe_bad_prefix_attributes(parser))
<span class="lineNum">   30353 </span><span class="lineNoCov">          0 :         warning_at (token-&gt;location, OPT_Wattributes,</span>
<span class="lineNum">   30354 </span><span class="lineNoCov">          0 :                     &quot;prefix attributes are ignored for methods&quot;);</span>
<span class="lineNum">   30355 </span><span class="lineNoCov">          0 :       else</span>
<span class="lineNum">   30356 </span><span class="lineNoCov">          0 :         /* Allow for interspersed non-ObjC++ code.  */</span>
<span class="lineNum">   30357 </span>            :         cp_parser_objc_interstitial_code (parser);
<span class="lineNum">   30358 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30359 </span><span class="lineNoCov">          0 :       token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   30360 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   30361 </span>            : 
<span class="lineNum">   30362 </span><span class="lineNoCov">          0 :   if (token-&gt;type != CPP_EOF)</span>
<span class="lineNum">   30363 </span>            :     cp_lexer_consume_token (parser-&gt;lexer);  /* Eat '@end'.  */
<span class="lineNum">   30364 </span>            :   else
<span class="lineNum">   30365 </span>            :     cp_parser_error (parser, &quot;expected %&lt;@end%&gt;&quot;);
<span class="lineNum">   30366 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30367 </span><span class="lineNoCov">          0 :   objc_finish_implementation ();</span>
<span class="lineNum">   30368 </span>            : }
<span class="lineNum">   30369 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30370 </span><span class="lineNoCov">          0 : /* Parse Objective-C ivars.  */</span>
<a name="30371"><span class="lineNum">   30371 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   30372 </span>            : static void
<span class="lineNum">   30373 </span><span class="lineNoCov">          0 : cp_parser_objc_class_ivars (cp_parser* parser)</span>
<span class="lineNum">   30374 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   30375 </span><span class="lineNoCov">          0 :   cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   30376 </span>            : 
<span class="lineNum">   30377 </span><span class="lineNoCov">          0 :   if (token-&gt;type != CPP_OPEN_BRACE)</span>
<span class="lineNum">   30378 </span><span class="lineNoCov">          0 :     return;     /* No ivars specified.  */</span>
<span class="lineNum">   30379 </span>            : 
<span class="lineNum">   30380 </span>            :   cp_lexer_consume_token (parser-&gt;lexer);  /* Eat '{'.  */
<span class="lineNum">   30381 </span>            :   token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   30382 </span>            : 
<span class="lineNum">   30383 </span><span class="lineNoCov">          0 :   while (token-&gt;type != CPP_CLOSE_BRACE </span>
<span class="lineNum">   30384 </span><span class="lineNoCov">          0 :         &amp;&amp; token-&gt;keyword != RID_AT_END &amp;&amp; token-&gt;type != CPP_EOF)</span>
<span class="lineNum">   30385 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   30386 </span><span class="lineNoCov">          0 :       cp_decl_specifier_seq declspecs;</span>
<span class="lineNum">   30387 </span><span class="lineNoCov">          0 :       int decl_class_or_enum_p;</span>
<span class="lineNum">   30388 </span><span class="lineNoCov">          0 :       tree prefix_attributes;</span>
<span class="lineNum">   30389 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30390 </span><span class="lineNoCov">          0 :       cp_parser_objc_visibility_spec (parser);</span>
<span class="lineNum">   30391 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30392 </span>            :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_CLOSE_BRACE))
<span class="lineNum">   30393 </span>            :         break;
<span class="lineNum">   30394 </span>            : 
<span class="lineNum">   30395 </span><span class="lineNoCov">          0 :       cp_parser_decl_specifier_seq (parser,</span>
<span class="lineNum">   30396 </span>            :                                     CP_PARSER_FLAGS_OPTIONAL,
<span class="lineNum">   30397 </span><span class="lineNoCov">          0 :                                     &amp;declspecs,</span>
<span class="lineNum">   30398 </span>            :                                     &amp;decl_class_or_enum_p);
<span class="lineNum">   30399 </span>            : 
<span class="lineNum">   30400 </span><span class="lineNoCov">          0 :       /* auto, register, static, extern, mutable.  */</span>
<span class="lineNum">   30401 </span><span class="lineNoCov">          0 :       if (declspecs.storage_class != sc_none)</span>
<span class="lineNum">   30402 </span>            :         {
<span class="lineNum">   30403 </span><span class="lineNoCov">          0 :           cp_parser_error (parser, &quot;invalid type for instance variable&quot;);       </span>
<span class="lineNum">   30404 </span>            :           declspecs.storage_class = sc_none;
<span class="lineNum">   30405 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">   30406 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30407 </span>            :       /* thread_local.  */
<span class="lineNum">   30408 </span>            :       if (decl_spec_seq_has_spec_p (&amp;declspecs, ds_thread))
<span class="lineNum">   30409 </span>            :         {
<span class="lineNum">   30410 </span>            :           cp_parser_error (parser, &quot;invalid type for instance variable&quot;);
<span class="lineNum">   30411 </span><span class="lineNoCov">          0 :           declspecs.locations[ds_thread] = 0;</span>
<span class="lineNum">   30412 </span>            :         }
<span class="lineNum">   30413 </span><span class="lineNoCov">          0 :       </span>
<span class="lineNum">   30414 </span>            :       /* typedef.  */
<span class="lineNum">   30415 </span><span class="lineNoCov">          0 :       if (decl_spec_seq_has_spec_p (&amp;declspecs, ds_typedef))</span>
<span class="lineNum">   30416 </span>            :         {
<span class="lineNum">   30417 </span>            :           cp_parser_error (parser, &quot;invalid type for instance variable&quot;);
<span class="lineNum">   30418 </span><span class="lineNoCov">          0 :           declspecs.locations[ds_typedef] = 0;</span>
<span class="lineNum">   30419 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">   30420 </span>            : 
<span class="lineNum">   30421 </span><span class="lineNoCov">          0 :       prefix_attributes = declspecs.attributes;</span>
<span class="lineNum">   30422 </span><span class="lineNoCov">          0 :       declspecs.attributes = NULL_TREE;</span>
<span class="lineNum">   30423 </span>            : 
<span class="lineNum">   30424 </span><span class="lineNoCov">          0 :       /* Keep going until we hit the `;' at the end of the</span>
<span class="lineNum">   30425 </span><span class="lineNoCov">          0 :          declaration.  */</span>
<span class="lineNum">   30426 </span><span class="lineNoCov">          0 :       while (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_SEMICOLON))</span>
<span class="lineNum">   30427 </span>            :         {
<span class="lineNum">   30428 </span><span class="lineNoCov">          0 :           tree width = NULL_TREE, attributes, first_attribute, decl;</span>
<span class="lineNum">   30429 </span>            :           cp_declarator *declarator = NULL;
<span class="lineNum">   30430 </span><span class="lineNoCov">          0 :           int ctor_dtor_or_conv_p;</span>
<span class="lineNum">   30431 </span>            : 
<span class="lineNum">   30432 </span>            :           /* Check for a (possibly unnamed) bitfield declaration.  */
<span class="lineNum">   30433 </span><span class="lineNoCov">          0 :           token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   30434 </span>            :           if (token-&gt;type == CPP_COLON)
<span class="lineNum">   30435 </span>            :             goto eat_colon;
<span class="lineNum">   30436 </span>            : 
<span class="lineNum">   30437 </span>            :           if (token-&gt;type == CPP_NAME
<span class="lineNum">   30438 </span>            :               &amp;&amp; (cp_lexer_peek_nth_token (parser-&gt;lexer, 2)-&gt;type
<span class="lineNum">   30439 </span><span class="lineNoCov">          0 :                   == CPP_COLON))</span>
<span class="lineNum">   30440 </span>            :             {
<span class="lineNum">   30441 </span><span class="lineNoCov">          0 :               /* Get the name of the bitfield.  */</span>
<span class="lineNum">   30442 </span><span class="lineNoCov">          0 :               declarator = make_id_declarator (NULL_TREE,</span>
<span class="lineNum">   30443 </span>            :                                                cp_parser_identifier (parser),
<span class="lineNum">   30444 </span>            :                                                sfk_none);
<span class="lineNum">   30445 </span>            : 
<span class="lineNum">   30446 </span><span class="lineNoCov">          0 :              eat_colon:</span>
<span class="lineNum">   30447 </span>            :               cp_lexer_consume_token (parser-&gt;lexer);  /* Eat ':'.  */
<span class="lineNum">   30448 </span><span class="lineNoCov">          0 :               /* Get the width of the bitfield.  */</span>
<span class="lineNum">   30449 </span><span class="lineNoCov">          0 :               width</span>
<span class="lineNum">   30450 </span>            :                 = cp_parser_constant_expression (parser);
<span class="lineNum">   30451 </span>            :             }
<span class="lineNum">   30452 </span>            :           else
<span class="lineNum">   30453 </span><span class="lineNoCov">          0 :             {</span>
<span class="lineNum">   30454 </span>            :               /* Parse the declarator.  */
<span class="lineNum">   30455 </span><span class="lineNoCov">          0 :               declarator</span>
<span class="lineNum">   30456 </span><span class="lineNoCov">          0 :                 = cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,</span>
<span class="lineNum">   30457 </span>            :                                         &amp;ctor_dtor_or_conv_p,
<span class="lineNum">   30458 </span>            :                                         /*parenthesized_p=*/NULL,
<span class="lineNum">   30459 </span><span class="lineNoCov">          0 :                                         /*member_p=*/false,</span>
<span class="lineNum">   30460 </span><span class="lineNoCov">          0 :                                         /*friend_p=*/false);</span>
<span class="lineNum">   30461 </span>            :             }
<span class="lineNum">   30462 </span>            : 
<span class="lineNum">   30463 </span>            :           /* Look for attributes that apply to the ivar.  */
<span class="lineNum">   30464 </span><span class="lineNoCov">          0 :           attributes = cp_parser_attributes_opt (parser);</span>
<span class="lineNum">   30465 </span>            :           /* Remember which attributes are prefix attributes and
<span class="lineNum">   30466 </span><span class="lineNoCov">          0 :              which are not.  */</span>
<span class="lineNum">   30467 </span><span class="lineNoCov">          0 :           first_attribute = attributes;</span>
<span class="lineNum">   30468 </span><span class="lineNoCov">          0 :           /* Combine the attributes.  */</span>
<span class="lineNum">   30469 </span>            :           attributes = attr_chainon (prefix_attributes, attributes);
<span class="lineNum">   30470 </span>            : 
<span class="lineNum">   30471 </span><span class="lineNoCov">          0 :           if (width)</span>
<span class="lineNum">   30472 </span><span class="lineNoCov">          0 :             /* Create the bitfield declaration.  */</span>
<span class="lineNum">   30473 </span>            :             decl = grokbitfield (declarator, &amp;declspecs,
<span class="lineNum">   30474 </span>            :                                  width, NULL_TREE, attributes);
<span class="lineNum">   30475 </span><span class="lineNoCov">          0 :           else</span>
<span class="lineNum">   30476 </span><span class="lineNoCov">          0 :             decl = grokfield (declarator, &amp;declspecs,</span>
<span class="lineNum">   30477 </span>            :                               NULL_TREE, /*init_const_expr_p=*/false,
<span class="lineNum">   30478 </span>            :                               NULL_TREE, attributes);
<span class="lineNum">   30479 </span>            : 
<span class="lineNum">   30480 </span><span class="lineNoCov">          0 :           /* Add the instance variable.  */</span>
<span class="lineNum">   30481 </span><span class="lineNoCov">          0 :           if (decl != error_mark_node &amp;&amp; decl != NULL_TREE)</span>
<span class="lineNum">   30482 </span>            :             objc_add_instance_variable (decl);
<span class="lineNum">   30483 </span>            : 
<span class="lineNum">   30484 </span><span class="lineNoCov">          0 :           /* Reset PREFIX_ATTRIBUTES.  */</span>
<span class="lineNum">   30485 </span><span class="lineNoCov">          0 :           if (attributes != error_mark_node)</span>
<span class="lineNum">   30486 </span>            :             {
<span class="lineNum">   30487 </span><span class="lineNoCov">          0 :               while (attributes &amp;&amp; TREE_CHAIN (attributes) != first_attribute)</span>
<span class="lineNum">   30488 </span><span class="lineNoCov">          0 :                 attributes = TREE_CHAIN (attributes);</span>
<span class="lineNum">   30489 </span>            :               if (attributes)
<span class="lineNum">   30490 </span>            :                 TREE_CHAIN (attributes) = NULL_TREE;
<span class="lineNum">   30491 </span>            :             }
<span class="lineNum">   30492 </span>            : 
<span class="lineNum">   30493 </span><span class="lineNoCov">          0 :           token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   30494 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30495 </span>            :           if (token-&gt;type == CPP_COMMA)
<span class="lineNum">   30496 </span>            :             {
<span class="lineNum">   30497 </span>            :               cp_lexer_consume_token (parser-&gt;lexer);  /* Eat ','.  */
<span class="lineNum">   30498 </span>            :               continue;
<span class="lineNum">   30499 </span>            :             }
<span class="lineNum">   30500 </span>            :           break;
<span class="lineNum">   30501 </span>            :         }
<span class="lineNum">   30502 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30503 </span>            :       cp_parser_consume_semicolon_at_end_of_statement (parser);
<span class="lineNum">   30504 </span>            :       token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   30505 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   30506 </span>            : 
<span class="lineNum">   30507 </span><span class="lineNoCov">          0 :   if (token-&gt;keyword == RID_AT_END)</span>
<span class="lineNum">   30508 </span>            :     cp_parser_error (parser, &quot;expected %&lt;}%&gt;&quot;);
<span class="lineNum">   30509 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30510 </span>            :   /* Do not consume the RID_AT_END, so it will be read again as terminating
<span class="lineNum">   30511 </span><span class="lineNoCov">          0 :      the @interface of @implementation.  */ </span>
<span class="lineNum">   30512 </span>            :   if (token-&gt;keyword != RID_AT_END &amp;&amp; token-&gt;type != CPP_EOF)
<span class="lineNum">   30513 </span>            :     cp_lexer_consume_token (parser-&gt;lexer);  /* Eat '}'.  */
<span class="lineNum">   30514 </span><span class="lineNoCov">          0 :     </span>
<span class="lineNum">   30515 </span>            :   /* For historical reasons, we accept an optional semicolon.  */
<span class="lineNum">   30516 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_SEMICOLON))
<span class="lineNum">   30517 </span>            :     cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   30518 </span>            : }
<span class="lineNum">   30519 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30520 </span><span class="lineNoCov">          0 : /* Parse an Objective-C protocol declaration.  */</span>
<a name="30521"><span class="lineNum">   30521 </span>            : </a>
<span class="lineNum">   30522 </span>            : static void
<span class="lineNum">   30523 </span><span class="lineNoCov">          0 : cp_parser_objc_protocol_declaration (cp_parser* parser, tree attributes)</span>
<span class="lineNum">   30524 </span>            : {
<span class="lineNum">   30525 </span><span class="lineNoCov">          0 :   tree proto, protorefs;</span>
<span class="lineNum">   30526 </span>            :   cp_token *tok;
<span class="lineNum">   30527 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30528 </span><span class="lineNoCov">          0 :   cp_lexer_consume_token (parser-&gt;lexer);  /* Eat '@protocol'.  */</span>
<span class="lineNum">   30529 </span>            :   if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_NAME))
<span class="lineNum">   30530 </span>            :     {
<span class="lineNum">   30531 </span><span class="lineNoCov">          0 :       tok = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   30532 </span>            :       error_at (tok-&gt;location, &quot;identifier expected after %&lt;@protocol%&gt;&quot;);
<span class="lineNum">   30533 </span><span class="lineNoCov">          0 :       cp_parser_consume_semicolon_at_end_of_statement (parser);</span>
<span class="lineNum">   30534 </span>            :       return;
<span class="lineNum">   30535 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   30536 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30537 </span>            :   /* See if we have a forward declaration or a definition.  */
<span class="lineNum">   30538 </span><span class="lineNoCov">          0 :   tok = cp_lexer_peek_nth_token (parser-&gt;lexer, 2);</span>
<span class="lineNum">   30539 </span>            : 
<span class="lineNum">   30540 </span>            :   /* Try a forward declaration first.  */
<span class="lineNum">   30541 </span><span class="lineNoCov">          0 :   if (tok-&gt;type == CPP_COMMA || tok-&gt;type == CPP_SEMICOLON)</span>
<span class="lineNum">   30542 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   30543 </span>            :       while (true)
<span class="lineNum">   30544 </span>            :         {
<span class="lineNum">   30545 </span><span class="lineNoCov">          0 :           tree id;</span>
<span class="lineNum">   30546 </span><span class="lineNoCov">          0 :           </span>
<span class="lineNum">   30547 </span>            :           id = cp_parser_identifier (parser);
<span class="lineNum">   30548 </span>            :           if (id == error_mark_node)
<span class="lineNum">   30549 </span>            :             break;
<span class="lineNum">   30550 </span><span class="lineNoCov">          0 :           </span>
<span class="lineNum">   30551 </span><span class="lineNoCov">          0 :           objc_declare_protocol (id, attributes);</span>
<span class="lineNum">   30552 </span>            :           
<span class="lineNum">   30553 </span>            :           if(cp_lexer_next_token_is (parser-&gt;lexer, CPP_COMMA))
<span class="lineNum">   30554 </span><span class="lineNoCov">          0 :             cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   30555 </span><span class="lineNoCov">          0 :           else</span>
<span class="lineNum">   30556 </span>            :             break;
<span class="lineNum">   30557 </span>            :         }
<span class="lineNum">   30558 </span>            :       cp_parser_consume_semicolon_at_end_of_statement (parser);
<span class="lineNum">   30559 </span>            :     }
<span class="lineNum">   30560 </span>            : 
<span class="lineNum">   30561 </span><span class="lineNoCov">          0 :   /* Ok, we got a full-fledged definition (or at least should).  */</span>
<span class="lineNum">   30562 </span>            :   else
<span class="lineNum">   30563 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   30564 </span><span class="lineNoCov">          0 :       proto = cp_parser_identifier (parser);</span>
<span class="lineNum">   30565 </span>            :       protorefs = cp_parser_objc_protocol_refs_opt (parser);
<span class="lineNum">   30566 </span><span class="lineNoCov">          0 :       objc_start_protocol (proto, protorefs, attributes);</span>
<span class="lineNum">   30567 </span><span class="lineNoCov">          0 :       cp_parser_objc_method_prototype_list (parser);</span>
<span class="lineNum">   30568 </span>            :     }
<span class="lineNum">   30569 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   30570 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30571 </span><span class="lineNoCov">          0 : /* Parse an Objective-C superclass or category.  */</span>
<a name="30572"><span class="lineNum">   30572 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   30573 </span>            : static void
<span class="lineNum">   30574 </span>            : cp_parser_objc_superclass_or_category (cp_parser *parser, 
<span class="lineNum">   30575 </span>            :                                        bool iface_p,
<span class="lineNum">   30576 </span><span class="lineNoCov">          0 :                                        tree *super,</span>
<span class="lineNum">   30577 </span>            :                                        tree *categ, bool *is_class_extension)
<span class="lineNum">   30578 </span>            : {
<span class="lineNum">   30579 </span><span class="lineNoCov">          0 :   cp_token *next = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   30580 </span>            : 
<span class="lineNum">   30581 </span><span class="lineNoCov">          0 :   *super = *categ = NULL_TREE;</span>
<span class="lineNum">   30582 </span>            :   *is_class_extension = false;
<span class="lineNum">   30583 </span><span class="lineNoCov">          0 :   if (next-&gt;type == CPP_COLON)</span>
<span class="lineNum">   30584 </span>            :     {
<span class="lineNum">   30585 </span><span class="lineNoCov">          0 :       cp_lexer_consume_token (parser-&gt;lexer);  /* Eat ':'.  */</span>
<span class="lineNum">   30586 </span><span class="lineNoCov">          0 :       *super = cp_parser_identifier (parser);</span>
<span class="lineNum">   30587 </span>            :     }
<span class="lineNum">   30588 </span>            :   else if (next-&gt;type == CPP_OPEN_PAREN)
<span class="lineNum">   30589 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   30590 </span>            :       matching_parens parens;
<span class="lineNum">   30591 </span><span class="lineNoCov">          0 :       parens.consume_open (parser);  /* Eat '('.  */</span>
<span class="lineNum">   30592 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30593 </span>            :       /* If there is no category name, and this is an @interface, we
<span class="lineNum">   30594 </span>            :          have a class extension.  */
<span class="lineNum">   30595 </span><span class="lineNoCov">          0 :       if (iface_p &amp;&amp; cp_lexer_next_token_is (parser-&gt;lexer, CPP_CLOSE_PAREN))</span>
<span class="lineNum">   30596 </span><span class="lineNoCov">          0 :         {</span>
<span class="lineNum">   30597 </span>            :           *categ = NULL_TREE;
<span class="lineNum">   30598 </span>            :           *is_class_extension = true;
<span class="lineNum">   30599 </span>            :         }
<span class="lineNum">   30600 </span>            :       else
<span class="lineNum">   30601 </span>            :         *categ = cp_parser_identifier (parser);
<span class="lineNum">   30602 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30603 </span><span class="lineNoCov">          0 :       parens.require_close (parser);</span>
<span class="lineNum">   30604 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   30605 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   30606 </span>            : 
<span class="lineNum">   30607 </span>            : /* Parse an Objective-C class interface.  */
<a name="30608"><span class="lineNum">   30608 </span>            : </a>
<span class="lineNum">   30609 </span>            : static void
<span class="lineNum">   30610 </span>            : cp_parser_objc_class_interface (cp_parser* parser, tree attributes)
<span class="lineNum">   30611 </span>            : {
<span class="lineNum">   30612 </span><span class="lineNoCov">          0 :   tree name, super, categ, protos;</span>
<span class="lineNum">   30613 </span>            :   bool is_class_extension;
<span class="lineNum">   30614 </span>            : 
<span class="lineNum">   30615 </span>            :   cp_lexer_consume_token (parser-&gt;lexer);  /* Eat '@interface'.  */
<span class="lineNum">   30616 </span>            :   name = cp_parser_identifier (parser);
<span class="lineNum">   30617 </span><span class="lineNoCov">          0 :   if (name == error_mark_node)</span>
<span class="lineNum">   30618 </span>            :     {
<span class="lineNum">   30619 </span><span class="lineNoCov">          0 :       /* It's hard to recover because even if valid @interface stuff</span>
<span class="lineNum">   30620 </span><span class="lineNoCov">          0 :          is to follow, we can't compile it (or validate it) if we</span>
<span class="lineNum">   30621 </span><span class="lineNoCov">          0 :          don't even know which class it refers to.  Let's assume this</span>
<span class="lineNum">   30622 </span>            :          was a stray '@interface' token in the stream and skip it.
<span class="lineNum">   30623 </span><span class="lineNoCov">          0 :       */</span>
<span class="lineNum">   30624 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">   30625 </span>            :     }
<span class="lineNum">   30626 </span><span class="lineNoCov">          0 :   cp_parser_objc_superclass_or_category (parser, true, &amp;super, &amp;categ,</span>
<span class="lineNum">   30627 </span>            :                                          &amp;is_class_extension);
<span class="lineNum">   30628 </span><span class="lineNoCov">          0 :   protos = cp_parser_objc_protocol_refs_opt (parser);</span>
<span class="lineNum">   30629 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30630 </span>            :   /* We have either a class or a category on our hands.  */
<span class="lineNum">   30631 </span>            :   if (categ || is_class_extension)
<span class="lineNum">   30632 </span>            :     objc_start_category_interface (name, categ, protos, attributes);
<span class="lineNum">   30633 </span><span class="lineNoCov">          0 :   else</span>
<span class="lineNum">   30634 </span>            :     {
<span class="lineNum">   30635 </span><span class="lineNoCov">          0 :       objc_start_class_interface (name, super, protos, attributes);</span>
<span class="lineNum">   30636 </span><span class="lineNoCov">          0 :       /* Handle instance variable declarations, if any.  */</span>
<span class="lineNum">   30637 </span>            :       cp_parser_objc_class_ivars (parser);
<span class="lineNum">   30638 </span>            :       objc_continue_interface ();
<span class="lineNum">   30639 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   30640 </span>            : 
<span class="lineNum">   30641 </span><span class="lineNoCov">          0 :   cp_parser_objc_method_prototype_list (parser);</span>
<span class="lineNum">   30642 </span>            : }
<span class="lineNum">   30643 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30644 </span>            : /* Parse an Objective-C class implementation.  */
<a name="30645"><span class="lineNum">   30645 </span>            : </a>
<span class="lineNum">   30646 </span>            : static void
<span class="lineNum">   30647 </span>            : cp_parser_objc_class_implementation (cp_parser* parser)
<span class="lineNum">   30648 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   30649 </span>            :   tree name, super, categ;
<span class="lineNum">   30650 </span><span class="lineNoCov">          0 :   bool is_class_extension;</span>
<span class="lineNum">   30651 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30652 </span>            :   cp_lexer_consume_token (parser-&gt;lexer);  /* Eat '@implementation'.  */
<span class="lineNum">   30653 </span><span class="lineNoCov">          0 :   name = cp_parser_identifier (parser);</span>
<span class="lineNum">   30654 </span><span class="lineNoCov">          0 :   if (name == error_mark_node)</span>
<span class="lineNum">   30655 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   30656 </span>            :       /* It's hard to recover because even if valid @implementation
<span class="lineNum">   30657 </span>            :          stuff is to follow, we can't compile it (or validate it) if
<span class="lineNum">   30658 </span>            :          we don't even know which class it refers to.  Let's assume
<span class="lineNum">   30659 </span>            :          this was a stray '@implementation' token in the stream and
<span class="lineNum">   30660 </span>            :          skip it.
<span class="lineNum">   30661 </span>            :       */
<span class="lineNum">   30662 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">   30663 </span>            :     }
<span class="lineNum">   30664 </span><span class="lineNoCov">          0 :   cp_parser_objc_superclass_or_category (parser, false, &amp;super, &amp;categ,</span>
<span class="lineNum">   30665 </span>            :                                          &amp;is_class_extension);
<span class="lineNum">   30666 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30667 </span>            :   /* We have either a class or a category on our hands.  */
<span class="lineNum">   30668 </span>            :   if (categ)
<span class="lineNum">   30669 </span><span class="lineNoCov">          0 :     objc_start_category_implementation (name, categ);</span>
<span class="lineNum">   30670 </span><span class="lineNoCov">          0 :   else</span>
<span class="lineNum">   30671 </span>            :     {
<span class="lineNum">   30672 </span>            :       objc_start_class_implementation (name, super);
<span class="lineNum">   30673 </span><span class="lineNoCov">          0 :       /* Handle instance variable declarations, if any.  */</span>
<span class="lineNum">   30674 </span>            :       cp_parser_objc_class_ivars (parser);
<span class="lineNum">   30675 </span><span class="lineNoCov">          0 :       objc_continue_implementation ();</span>
<span class="lineNum">   30676 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   30677 </span>            : 
<span class="lineNum">   30678 </span>            :   cp_parser_objc_method_definition_list (parser);
<span class="lineNum">   30679 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   30680 </span>            : 
<span class="lineNum">   30681 </span>            : /* Consume the @end token and finish off the implementation.  */
<a name="30682"><span class="lineNum">   30682 </span>            : </a>
<span class="lineNum">   30683 </span>            : static void
<span class="lineNum">   30684 </span>            : cp_parser_objc_end_implementation (cp_parser* parser)
<span class="lineNum">   30685 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   30686 </span>            :   cp_lexer_consume_token (parser-&gt;lexer);  /* Eat '@end'.  */
<span class="lineNum">   30687 </span><span class="lineNoCov">          0 :   objc_finish_implementation ();</span>
<span class="lineNum">   30688 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   30689 </span>            : 
<span class="lineNum">   30690 </span><span class="lineNoCov">          0 : /* Parse an Objective-C declaration.  */</span>
<a name="30691"><span class="lineNum">   30691 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   30692 </span><span class="lineNoCov">          0 : static void</span>
<span class="lineNum">   30693 </span>            : cp_parser_objc_declaration (cp_parser* parser, tree attributes)
<span class="lineNum">   30694 </span>            : {
<span class="lineNum">   30695 </span>            :   /* Try to figure out what kind of declaration is present.  */
<span class="lineNum">   30696 </span>            :   cp_token *kwd = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   30697 </span>            : 
<span class="lineNum">   30698 </span>            :   if (attributes)
<span class="lineNum">   30699 </span>            :     switch (kwd-&gt;keyword)
<span class="lineNum">   30700 </span><span class="lineNoCov">          0 :       {</span>
<span class="lineNum">   30701 </span>            :         case RID_AT_ALIAS:
<span class="lineNum">   30702 </span><span class="lineNoCov">          0 :         case RID_AT_CLASS:</span>
<span class="lineNum">   30703 </span>            :         case RID_AT_END:
<span class="lineNum">   30704 </span>            :           error_at (kwd-&gt;location, &quot;attributes may not be specified before&quot;
<span class="lineNum">   30705 </span>            :                     &quot; the %&lt;@%D%&gt; Objective-C++ keyword&quot;,
<span class="lineNum">   30706 </span><span class="lineNoCov">          0 :                     kwd-&gt;u.value);</span>
<span class="lineNum">   30707 </span><span class="lineNoCov">          0 :           attributes = NULL;</span>
<span class="lineNum">   30708 </span>            :           break;
<span class="lineNum">   30709 </span>            :         case RID_AT_IMPLEMENTATION:
<span class="lineNum">   30710 </span><span class="lineNoCov">          0 :           warning_at (kwd-&gt;location, OPT_Wattributes,</span>
<span class="lineNum">   30711 </span>            :                       &quot;prefix attributes are ignored before %&lt;@%D%&gt;&quot;,
<span class="lineNum">   30712 </span><span class="lineNoCov">          0 :                       kwd-&gt;u.value);</span>
<span class="lineNum">   30713 </span><span class="lineNoCov">          0 :           attributes = NULL;</span>
<span class="lineNum">   30714 </span>            :         default:
<span class="lineNum">   30715 </span>            :           break;
<span class="lineNum">   30716 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">   30717 </span>            : 
<span class="lineNum">   30718 </span>            :   switch (kwd-&gt;keyword)
<span class="lineNum">   30719 </span>            :     {
<span class="lineNum">   30720 </span>            :     case RID_AT_ALIAS:
<span class="lineNum">   30721 </span>            :       cp_parser_objc_alias_declaration (parser);
<span class="lineNum">   30722 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">   30723 </span>            :     case RID_AT_CLASS:
<span class="lineNum">   30724 </span><span class="lineNoCov">          0 :       cp_parser_objc_class_declaration (parser);</span>
<span class="lineNum">   30725 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">   30726 </span><span class="lineNoCov">          0 :     case RID_AT_PROTOCOL:</span>
<span class="lineNum">   30727 </span>            :       cp_parser_objc_protocol_declaration (parser, attributes);
<span class="lineNum">   30728 </span>            :       break;
<span class="lineNum">   30729 </span>            :     case RID_AT_INTERFACE:
<span class="lineNum">   30730 </span>            :       cp_parser_objc_class_interface (parser, attributes);
<span class="lineNum">   30731 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">   30732 </span>            :     case RID_AT_IMPLEMENTATION:
<span class="lineNum">   30733 </span>            :       cp_parser_objc_class_implementation (parser);
<span class="lineNum">   30734 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">   30735 </span>            :     case RID_AT_END:
<span class="lineNum">   30736 </span><span class="lineNoCov">          0 :       cp_parser_objc_end_implementation (parser);</span>
<span class="lineNum">   30737 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">   30738 </span>            :     default:
<span class="lineNum">   30739 </span><span class="lineNoCov">          0 :       error_at (kwd-&gt;location, &quot;misplaced %&lt;@%D%&gt; Objective-C++ construct&quot;,</span>
<span class="lineNum">   30740 </span><span class="lineNoCov">          0 :                 kwd-&gt;u.value);</span>
<span class="lineNum">   30741 </span><span class="lineNoCov">          0 :       cp_parser_skip_to_end_of_block_or_statement (parser);</span>
<span class="lineNum">   30742 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   30743 </span>            : }
<span class="lineNum">   30744 </span>            : 
<span class="lineNum">   30745 </span><span class="lineNoCov">          0 : /* Parse an Objective-C try-catch-finally statement.</span>
<span class="lineNum">   30746 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30747 </span><span class="lineNoCov">          0 :    objc-try-catch-finally-stmt:</span>
<span class="lineNum">   30748 </span><span class="lineNoCov">          0 :      @try compound-statement objc-catch-clause-seq [opt]</span>
<span class="lineNum">   30749 </span>            :        objc-finally-clause [opt]
<span class="lineNum">   30750 </span>            : 
<span class="lineNum">   30751 </span><span class="lineNoCov">          0 :    objc-catch-clause-seq:</span>
<span class="lineNum">   30752 </span>            :      objc-catch-clause objc-catch-clause-seq [opt]
<span class="lineNum">   30753 </span>            : 
<span class="lineNum">   30754 </span>            :    objc-catch-clause:
<span class="lineNum">   30755 </span>            :      @catch ( objc-exception-declaration ) compound-statement
<span class="lineNum">   30756 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30757 </span>            :    objc-finally-clause:
<span class="lineNum">   30758 </span><span class="lineNoCov">          0 :      @finally compound-statement</span>
<span class="lineNum">   30759 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30760 </span><span class="lineNoCov">          0 :    objc-exception-declaration:</span>
<span class="lineNum">   30761 </span><span class="lineNoCov">          0 :      parameter-declaration</span>
<span class="lineNum">   30762 </span><span class="lineNoCov">          0 :      '...'</span>
<span class="lineNum">   30763 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30764 </span><span class="lineNoCov">          0 :    where '...' is to be interpreted literally, that is, it means CPP_ELLIPSIS.</span>
<span class="lineNum">   30765 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30766 </span><span class="lineNoCov">          0 :    Returns NULL_TREE.</span>
<span class="lineNum">   30767 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30768 </span><span class="lineNoCov">          0 :    PS: This function is identical to c_parser_objc_try_catch_finally_statement</span>
<span class="lineNum">   30769 </span><span class="lineNoCov">          0 :    for C.  Keep them in sync.  */   </span>
<a name="30770"><span class="lineNum">   30770 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   30771 </span><span class="lineNoCov">          0 : static tree</span>
<span class="lineNum">   30772 </span><span class="lineNoCov">          0 : cp_parser_objc_try_catch_finally_statement (cp_parser *parser)</span>
<span class="lineNum">   30773 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   30774 </span><span class="lineNoCov">          0 :   location_t location;</span>
<span class="lineNum">   30775 </span>            :   tree stmt;
<span class="lineNum">   30776 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30777 </span><span class="lineNoCov">          0 :   cp_parser_require_keyword (parser, RID_AT_TRY, RT_AT_TRY);</span>
<span class="lineNum">   30778 </span>            :   location = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">   30779 </span><span class="lineNoCov">          0 :   objc_maybe_warn_exceptions (location);</span>
<span class="lineNum">   30780 </span>            :   /* NB: The @try block needs to be wrapped in its own STATEMENT_LIST
<span class="lineNum">   30781 </span><span class="lineNoCov">          0 :      node, lest it get absorbed into the surrounding block.  */</span>
<span class="lineNum">   30782 </span>            :   stmt = push_stmt_list ();
<span class="lineNum">   30783 </span>            :   cp_parser_compound_statement (parser, NULL, BCS_NORMAL, false);
<span class="lineNum">   30784 </span>            :   objc_begin_try_stmt (location, pop_stmt_list (stmt));
<span class="lineNum">   30785 </span>            : 
<span class="lineNum">   30786 </span>            :   while (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_AT_CATCH))
<span class="lineNum">   30787 </span>            :     {
<span class="lineNum">   30788 </span>            :       cp_parameter_declarator *parm;
<span class="lineNum">   30789 </span>            :       tree parameter_declaration = error_mark_node;
<span class="lineNum">   30790 </span>            :       bool seen_open_paren = false;
<span class="lineNum">   30791 </span>            :       matching_parens parens;
<span class="lineNum">   30792 </span>            : 
<span class="lineNum">   30793 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   30794 </span>            :       if (parens.require_open (parser))
<span class="lineNum">   30795 </span>            :         seen_open_paren = true;
<span class="lineNum">   30796 </span>            :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_ELLIPSIS))
<span class="lineNum">   30797 </span>            :         {
<span class="lineNum">   30798 </span>            :           /* We have &quot;@catch (...)&quot; (where the '...' are literally
<span class="lineNum">   30799 </span>            :              what is in the code).  Skip the '...'.
<span class="lineNum">   30800 </span>            :              parameter_declaration is set to NULL_TREE, and
<span class="lineNum">   30801 </span>            :              objc_being_catch_clauses() knows that that means
<span class="lineNum">   30802 </span>            :              '...'.  */
<span class="lineNum">   30803 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   30804 </span>            :           parameter_declaration = NULL_TREE;
<span class="lineNum">   30805 </span>            :         }
<span class="lineNum">   30806 </span>            :       else
<span class="lineNum">   30807 </span>            :         {
<span class="lineNum">   30808 </span>            :           /* We have &quot;@catch (NSException *exception)&quot; or something
<span class="lineNum">   30809 </span>            :              like that.  Parse the parameter declaration.  */
<span class="lineNum">   30810 </span><span class="lineNoCov">          0 :           parm = cp_parser_parameter_declaration (parser, false, NULL);</span>
<span class="lineNum">   30811 </span>            :           if (parm == NULL)
<span class="lineNum">   30812 </span><span class="lineNoCov">          0 :             parameter_declaration = error_mark_node;</span>
<span class="lineNum">   30813 </span><span class="lineNoCov">          0 :           else</span>
<span class="lineNum">   30814 </span>            :             parameter_declaration = grokdeclarator (parm-&gt;declarator,
<span class="lineNum">   30815 </span><span class="lineNoCov">          0 :                                                     &amp;parm-&gt;decl_specifiers,</span>
<span class="lineNum">   30816 </span><span class="lineNoCov">          0 :                                                     PARM, /*initialized=*/0,</span>
<span class="lineNum">   30817 </span><span class="lineNoCov">          0 :                                                     /*attrlist=*/NULL);</span>
<span class="lineNum">   30818 </span>            :         }
<span class="lineNum">   30819 </span>            :       if (seen_open_paren)
<span class="lineNum">   30820 </span><span class="lineNoCov">          0 :         parens.require_close (parser);</span>
<span class="lineNum">   30821 </span><span class="lineNoCov">          0 :       else</span>
<span class="lineNum">   30822 </span><span class="lineNoCov">          0 :         {</span>
<span class="lineNum">   30823 </span>            :           /* If there was no open parenthesis, we are recovering from
<span class="lineNum">   30824 </span><span class="lineNoCov">          0 :              an error, and we are trying to figure out what mistake</span>
<span class="lineNum">   30825 </span>            :              the user has made.  */
<span class="lineNum">   30826 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30827 </span><span class="lineNoCov">          0 :           /* If there is an immediate closing parenthesis, the user</span>
<span class="lineNum">   30828 </span><span class="lineNoCov">          0 :              probably forgot the opening one (ie, they typed &quot;@catch</span>
<span class="lineNum">   30829 </span><span class="lineNoCov">          0 :              NSException *e)&quot;.  Parse the closing parenthesis and keep</span>
<span class="lineNum">   30830 </span>            :              going.  */
<span class="lineNum">   30831 </span><span class="lineNoCov">          0 :           if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_CLOSE_PAREN))</span>
<span class="lineNum">   30832 </span><span class="lineNoCov">          0 :             cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   30833 </span><span class="lineNoCov">          0 :           </span>
<span class="lineNum">   30834 </span><span class="lineNoCov">          0 :           /* If these is no immediate closing parenthesis, the user</span>
<span class="lineNum">   30835 </span>            :              probably doesn't know that parenthesis are required at
<span class="lineNum">   30836 </span>            :              all (ie, they typed &quot;@catch NSException *e&quot;).  So, just
<span class="lineNum">   30837 </span>            :              forget about the closing parenthesis and keep going.  */
<span class="lineNum">   30838 </span>            :         }
<span class="lineNum">   30839 </span>            :       objc_begin_catch_clause (parameter_declaration);
<span class="lineNum">   30840 </span>            :       cp_parser_compound_statement (parser, NULL, BCS_NORMAL, false);
<span class="lineNum">   30841 </span><span class="lineNoCov">          0 :       objc_finish_catch_clause ();</span>
<span class="lineNum">   30842 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   30843 </span>            :   if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_AT_FINALLY))
<span class="lineNum">   30844 </span>            :     {
<span class="lineNum">   30845 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   30846 </span>            :       location = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">   30847 </span>            :       /* NB: The @finally block needs to be wrapped in its own STATEMENT_LIST
<span class="lineNum">   30848 </span><span class="lineNoCov">          0 :          node, lest it get absorbed into the surrounding block.  */</span>
<span class="lineNum">   30849 </span><span class="lineNoCov">          0 :       stmt = push_stmt_list ();</span>
<span class="lineNum">   30850 </span><span class="lineNoCov">          0 :       cp_parser_compound_statement (parser, NULL, BCS_NORMAL, false);</span>
<span class="lineNum">   30851 </span>            :       objc_build_finally_clause (location, pop_stmt_list (stmt));
<span class="lineNum">   30852 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   30853 </span>            : 
<span class="lineNum">   30854 </span>            :   return objc_finish_try_stmt ();
<span class="lineNum">   30855 </span>            : }
<span class="lineNum">   30856 </span>            : 
<span class="lineNum">   30857 </span><span class="lineNoCov">          0 : /* Parse an Objective-C synchronized statement.</span>
<span class="lineNum">   30858 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30859 </span>            :    objc-synchronized-stmt:
<span class="lineNum">   30860 </span>            :      @synchronized ( expression ) compound-statement
<span class="lineNum">   30861 </span>            : 
<span class="lineNum">   30862 </span>            :    Returns NULL_TREE.  */
<a name="30863"><span class="lineNum">   30863 </span>            : </a>
<span class="lineNum">   30864 </span>            : static tree
<span class="lineNum">   30865 </span>            : cp_parser_objc_synchronized_statement (cp_parser *parser)
<span class="lineNum">   30866 </span>            : {
<span class="lineNum">   30867 </span>            :   location_t location;
<span class="lineNum">   30868 </span>            :   tree lock, stmt;
<span class="lineNum">   30869 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30870 </span><span class="lineNoCov">          0 :   cp_parser_require_keyword (parser, RID_AT_SYNCHRONIZED, RT_AT_SYNCHRONIZED);</span>
<span class="lineNum">   30871 </span>            : 
<span class="lineNum">   30872 </span>            :   location = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">   30873 </span>            :   objc_maybe_warn_exceptions (location);
<span class="lineNum">   30874 </span>            :   matching_parens parens;
<span class="lineNum">   30875 </span>            :   parens.require_open (parser);
<span class="lineNum">   30876 </span>            :   lock = cp_parser_expression (parser);
<span class="lineNum">   30877 </span><span class="lineNoCov">          0 :   parens.require_close (parser);</span>
<span class="lineNum">   30878 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30879 </span><span class="lineNoCov">          0 :   /* NB: The @synchronized block needs to be wrapped in its own STATEMENT_LIST</span>
<span class="lineNum">   30880 </span>            :      node, lest it get absorbed into the surrounding block.  */
<span class="lineNum">   30881 </span><span class="lineNoCov">          0 :   stmt = push_stmt_list ();</span>
<span class="lineNum">   30882 </span>            :   cp_parser_compound_statement (parser, NULL, BCS_NORMAL, false);
<span class="lineNum">   30883 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30884 </span><span class="lineNoCov">          0 :   return objc_build_synchronized (location, lock, pop_stmt_list (stmt));</span>
<span class="lineNum">   30885 </span>            : }
<span class="lineNum">   30886 </span>            : 
<span class="lineNum">   30887 </span><span class="lineNoCov">          0 : /* Parse an Objective-C throw statement.</span>
<span class="lineNum">   30888 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30889 </span><span class="lineNoCov">          0 :    objc-throw-stmt:</span>
<span class="lineNum">   30890 </span>            :      @throw assignment-expression [opt] ;
<span class="lineNum">   30891 </span>            : 
<span class="lineNum">   30892 </span><span class="lineNoCov">          0 :    Returns a constructed '@throw' statement.  */</span>
<a name="30893"><span class="lineNum">   30893 </span>            : </a>
<span class="lineNum">   30894 </span>            : static tree
<span class="lineNum">   30895 </span>            : cp_parser_objc_throw_statement (cp_parser *parser)
<span class="lineNum">   30896 </span>            : {
<span class="lineNum">   30897 </span>            :   tree expr = NULL_TREE;
<span class="lineNum">   30898 </span>            :   location_t loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">   30899 </span>            : 
<span class="lineNum">   30900 </span>            :   cp_parser_require_keyword (parser, RID_AT_THROW, RT_AT_THROW);
<span class="lineNum">   30901 </span>            : 
<span class="lineNum">   30902 </span>            :   if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_SEMICOLON))
<span class="lineNum">   30903 </span><span class="lineNoCov">          0 :     expr = cp_parser_expression (parser);</span>
<span class="lineNum">   30904 </span>            : 
<span class="lineNum">   30905 </span><span class="lineNoCov">          0 :   cp_parser_consume_semicolon_at_end_of_statement (parser);</span>
<span class="lineNum">   30906 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30907 </span>            :   return objc_build_throw_stmt (loc, expr);
<span class="lineNum">   30908 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   30909 </span>            : 
<span class="lineNum">   30910 </span><span class="lineNoCov">          0 : /* Parse an Objective-C statement.  */</span>
<a name="30911"><span class="lineNum">   30911 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   30912 </span><span class="lineNoCov">          0 : static tree</span>
<span class="lineNum">   30913 </span><span class="lineNoCov">          0 : cp_parser_objc_statement (cp_parser * parser)</span>
<span class="lineNum">   30914 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   30915 </span><span class="lineNoCov">          0 :   /* Try to figure out what kind of declaration is present.  */</span>
<span class="lineNum">   30916 </span>            :   cp_token *kwd = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   30917 </span>            : 
<span class="lineNum">   30918 </span>            :   switch (kwd-&gt;keyword)
<span class="lineNum">   30919 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   30920 </span><span class="lineNoCov">          0 :     case RID_AT_TRY:</span>
<span class="lineNum">   30921 </span>            :       return cp_parser_objc_try_catch_finally_statement (parser);
<span class="lineNum">   30922 </span><span class="lineNoCov">          0 :     case RID_AT_SYNCHRONIZED:</span>
<span class="lineNum">   30923 </span>            :       return cp_parser_objc_synchronized_statement (parser);
<span class="lineNum">   30924 </span>            :     case RID_AT_THROW:
<span class="lineNum">   30925 </span>            :       return cp_parser_objc_throw_statement (parser);
<span class="lineNum">   30926 </span>            :     default:
<span class="lineNum">   30927 </span>            :       error_at (kwd-&gt;location, &quot;misplaced %&lt;@%D%&gt; Objective-C++ construct&quot;,
<span class="lineNum">   30928 </span>            :                kwd-&gt;u.value);
<span class="lineNum">   30929 </span>            :       cp_parser_skip_to_end_of_block_or_statement (parser);
<span class="lineNum">   30930 </span>            :     }
<span class="lineNum">   30931 </span>            : 
<span class="lineNum">   30932 </span>            :   return error_mark_node;
<span class="lineNum">   30933 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   30934 </span>            : 
<span class="lineNum">   30935 </span><span class="lineNoCov">          0 : /* If we are compiling ObjC++ and we see an __attribute__ we neeed to </span>
<span class="lineNum">   30936 </span><span class="lineNoCov">          0 :    look ahead to see if an objc keyword follows the attributes.  This</span>
<span class="lineNum">   30937 </span>            :    is to detect the use of prefix attributes on ObjC @interface and 
<span class="lineNum">   30938 </span><span class="lineNoCov">          0 :    @protocol.  */</span>
<a name="30939"><span class="lineNum">   30939 </span>            : </a>
<span class="lineNum">   30940 </span><span class="lineNoCov">          0 : static bool</span>
<span class="lineNum">   30941 </span><span class="lineNoCov">          0 : cp_parser_objc_valid_prefix_attributes (cp_parser* parser, tree *attrib)</span>
<span class="lineNum">   30942 </span>            : {
<span class="lineNum">   30943 </span><span class="lineNoCov">          0 :   cp_lexer_save_tokens (parser-&gt;lexer);</span>
<span class="lineNum">   30944 </span>            :   *attrib = cp_parser_attributes_opt (parser);
<span class="lineNum">   30945 </span><span class="lineNoCov">          0 :   gcc_assert (*attrib);</span>
<span class="lineNum">   30946 </span>            :   if (OBJC_IS_AT_KEYWORD (cp_lexer_peek_token (parser-&gt;lexer)-&gt;keyword))
<span class="lineNum">   30947 </span>            :     {
<span class="lineNum">   30948 </span>            :       cp_lexer_commit_tokens (parser-&gt;lexer);
<span class="lineNum">   30949 </span>            :       return true;
<span class="lineNum">   30950 </span>            :     }
<span class="lineNum">   30951 </span><span class="lineNoCov">          0 :   cp_lexer_rollback_tokens (parser-&gt;lexer);</span>
<span class="lineNum">   30952 </span>            :   return false;  
<span class="lineNum">   30953 </span>            : }
<span class="lineNum">   30954 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30955 </span>            : /* This routine is a minimal replacement for
<span class="lineNum">   30956 </span><span class="lineNoCov">          0 :    c_parser_struct_declaration () used when parsing the list of</span>
<span class="lineNum">   30957 </span>            :    types/names or ObjC++ properties.  For example, when parsing the
<span class="lineNum">   30958 </span><span class="lineNoCov">          0 :    code</span>
<span class="lineNum">   30959 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30960 </span><span class="lineNoCov">          0 :    @property (readonly) int a, b, c;</span>
<span class="lineNum">   30961 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30962 </span><span class="lineNoCov">          0 :    this function is responsible for parsing &quot;int a, int b, int c&quot; and</span>
<span class="lineNum">   30963 </span><span class="lineNoCov">          0 :    returning the declarations as CHAIN of DECLs.</span>
<span class="lineNum">   30964 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30965 </span><span class="lineNoCov">          0 :    TODO: Share this code with cp_parser_objc_class_ivars.  It's very</span>
<a name="30966"><span class="lineNum">   30966 </span>            :    similar parsing.  */</a>
<span class="lineNum">   30967 </span><span class="lineNoCov">          0 : static tree</span>
<span class="lineNum">   30968 </span>            : cp_parser_objc_struct_declaration (cp_parser *parser)
<span class="lineNum">   30969 </span>            : {
<span class="lineNum">   30970 </span><span class="lineNoCov">          0 :   tree decls = NULL_TREE;</span>
<span class="lineNum">   30971 </span>            :   cp_decl_specifier_seq declspecs;
<span class="lineNum">   30972 </span>            :   int decl_class_or_enum_p;
<span class="lineNum">   30973 </span>            :   tree prefix_attributes;
<span class="lineNum">   30974 </span>            : 
<span class="lineNum">   30975 </span>            :   cp_parser_decl_specifier_seq (parser,
<span class="lineNum">   30976 </span>            :                                 CP_PARSER_FLAGS_NONE,
<span class="lineNum">   30977 </span>            :                                 &amp;declspecs,
<span class="lineNum">   30978 </span>            :                                 &amp;decl_class_or_enum_p);
<span class="lineNum">   30979 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30980 </span>            :   if (declspecs.type == error_mark_node)
<span class="lineNum">   30981 </span><span class="lineNoCov">          0 :     return error_mark_node;</span>
<span class="lineNum">   30982 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   30983 </span><span class="lineNoCov">          0 :   /* auto, register, static, extern, mutable.  */</span>
<span class="lineNum">   30984 </span><span class="lineNoCov">          0 :   if (declspecs.storage_class != sc_none)</span>
<span class="lineNum">   30985 </span>            :     {
<span class="lineNum">   30986 </span><span class="lineNoCov">          0 :       cp_parser_error (parser, &quot;invalid type for property&quot;);</span>
<span class="lineNum">   30987 </span><span class="lineNoCov">          0 :       declspecs.storage_class = sc_none;</span>
<span class="lineNum">   30988 </span>            :     }
<span class="lineNum">   30989 </span><span class="lineNoCov">          0 :   </span>
<span class="lineNum">   30990 </span><span class="lineNoCov">          0 :   /* thread_local.  */</span>
<span class="lineNum">   30991 </span>            :   if (decl_spec_seq_has_spec_p (&amp;declspecs, ds_thread))
<span class="lineNum">   30992 </span>            :     {
<span class="lineNum">   30993 </span>            :       cp_parser_error (parser, &quot;invalid type for property&quot;);
<span class="lineNum">   30994 </span>            :       declspecs.locations[ds_thread] = 0;
<span class="lineNum">   30995 </span>            :     }
<span class="lineNum">   30996 </span>            :   
<span class="lineNum">   30997 </span>            :   /* typedef.  */
<span class="lineNum">   30998 </span>            :   if (decl_spec_seq_has_spec_p (&amp;declspecs, ds_typedef))
<span class="lineNum">   30999 </span>            :     {
<span class="lineNum">   31000 </span>            :       cp_parser_error (parser, &quot;invalid type for property&quot;);
<span class="lineNum">   31001 </span>            :       declspecs.locations[ds_typedef] = 0;
<span class="lineNum">   31002 </span>            :     }
<span class="lineNum">   31003 </span>            : 
<span class="lineNum">   31004 </span>            :   prefix_attributes = declspecs.attributes;
<span class="lineNum">   31005 </span>            :   declspecs.attributes = NULL_TREE;
<span class="lineNum">   31006 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   31007 </span>            :   /* Keep going until we hit the `;' at the end of the declaration. */
<span class="lineNum">   31008 </span><span class="lineNoCov">          0 :   while (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_SEMICOLON))</span>
<span class="lineNum">   31009 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   31010 </span><span class="lineNoCov">          0 :       tree attributes, first_attribute, decl;</span>
<span class="lineNum">   31011 </span><span class="lineNoCov">          0 :       cp_declarator *declarator;</span>
<span class="lineNum">   31012 </span>            :       cp_token *token;
<span class="lineNum">   31013 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   31014 </span>            :       /* Parse the declarator.  */
<span class="lineNum">   31015 </span>            :       declarator = cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,
<span class="lineNum">   31016 </span>            :                                          NULL, NULL, false, false);
<span class="lineNum">   31017 </span>            : 
<span class="lineNum">   31018 </span><span class="lineNoCov">          0 :       /* Look for attributes that apply to the ivar.  */</span>
<span class="lineNum">   31019 </span>            :       attributes = cp_parser_attributes_opt (parser);
<span class="lineNum">   31020 </span>            :       /* Remember which attributes are prefix attributes and
<span class="lineNum">   31021 </span>            :          which are not.  */
<span class="lineNum">   31022 </span><span class="lineNoCov">          0 :       first_attribute = attributes;</span>
<span class="lineNum">   31023 </span>            :       /* Combine the attributes.  */
<span class="lineNum">   31024 </span><span class="lineNoCov">          0 :       attributes = attr_chainon (prefix_attributes, attributes);</span>
<span class="lineNum">   31025 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   31026 </span>            :       decl = grokfield (declarator, &amp;declspecs,
<span class="lineNum">   31027 </span>            :                         NULL_TREE, /*init_const_expr_p=*/false,
<span class="lineNum">   31028 </span>            :                         NULL_TREE, attributes);
<span class="lineNum">   31029 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   31030 </span>            :       if (decl == error_mark_node || decl == NULL_TREE)
<span class="lineNum">   31031 </span><span class="lineNoCov">          0 :         return error_mark_node;</span>
<span class="lineNum">   31032 </span><span class="lineNoCov">          0 :       </span>
<span class="lineNum">   31033 </span>            :       /* Reset PREFIX_ATTRIBUTES.  */
<span class="lineNum">   31034 </span>            :       if (attributes != error_mark_node)
<span class="lineNum">   31035 </span>            :         {
<span class="lineNum">   31036 </span><span class="lineNoCov">          0 :           while (attributes &amp;&amp; TREE_CHAIN (attributes) != first_attribute)</span>
<span class="lineNum">   31037 </span>            :             attributes = TREE_CHAIN (attributes);
<span class="lineNum">   31038 </span><span class="lineNoCov">          0 :           if (attributes)</span>
<span class="lineNum">   31039 </span><span class="lineNoCov">          0 :             TREE_CHAIN (attributes) = NULL_TREE;</span>
<span class="lineNum">   31040 </span>            :         }
<span class="lineNum">   31041 </span>            : 
<span class="lineNum">   31042 </span><span class="lineNoCov">          0 :       DECL_CHAIN (decl) = decls;</span>
<span class="lineNum">   31043 </span><span class="lineNoCov">          0 :       decls = decl;</span>
<span class="lineNum">   31044 </span>            : 
<span class="lineNum">   31045 </span>            :       token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   31046 </span><span class="lineNoCov">          0 :       if (token-&gt;type == CPP_COMMA)</span>
<span class="lineNum">   31047 </span>            :         {
<span class="lineNum">   31048 </span><span class="lineNoCov">          0 :           cp_lexer_consume_token (parser-&gt;lexer);  /* Eat ','.  */</span>
<span class="lineNum">   31049 </span><span class="lineNoCov">          0 :           continue;</span>
<span class="lineNum">   31050 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">   31051 </span>            :       else
<span class="lineNum">   31052 </span>            :         break;
<span class="lineNum">   31053 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   31054 </span>            :   return decls;
<span class="lineNum">   31055 </span>            : }
<span class="lineNum">   31056 </span>            : 
<span class="lineNum">   31057 </span><span class="lineNoCov">          0 : /* Parse an Objective-C @property declaration.  The syntax is:</span>
<span class="lineNum">   31058 </span>            : 
<span class="lineNum">   31059 </span>            :    objc-property-declaration:
<span class="lineNum">   31060 </span><span class="lineNoCov">          0 :      '@property' objc-property-attributes[opt] struct-declaration ;</span>
<span class="lineNum">   31061 </span>            : 
<span class="lineNum">   31062 </span><span class="lineNoCov">          0 :    objc-property-attributes:</span>
<span class="lineNum">   31063 </span>            :     '(' objc-property-attribute-list ')'
<span class="lineNum">   31064 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   31065 </span>            :    objc-property-attribute-list:
<span class="lineNum">   31066 </span>            :      objc-property-attribute
<span class="lineNum">   31067 </span>            :      objc-property-attribute-list, objc-property-attribute
<span class="lineNum">   31068 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   31069 </span><span class="lineNoCov">          0 :    objc-property-attribute</span>
<span class="lineNum">   31070 </span>            :      'getter' = identifier
<span class="lineNum">   31071 </span>            :      'setter' = identifier
<span class="lineNum">   31072 </span><span class="lineNoCov">          0 :      'readonly'</span>
<span class="lineNum">   31073 </span>            :      'readwrite'
<span class="lineNum">   31074 </span><span class="lineNoCov">          0 :      'assign'</span>
<span class="lineNum">   31075 </span>            :      'retain'
<span class="lineNum">   31076 </span><span class="lineNoCov">          0 :      'copy'</span>
<span class="lineNum">   31077 </span><span class="lineNoCov">          0 :      'nonatomic'</span>
<span class="lineNum">   31078 </span>            : 
<span class="lineNum">   31079 </span>            :   For example:
<span class="lineNum">   31080 </span><span class="lineNoCov">          0 :     @property NSString *name;</span>
<span class="lineNum">   31081 </span><span class="lineNoCov">          0 :     @property (readonly) id object;</span>
<span class="lineNum">   31082 </span>            :     @property (retain, nonatomic, getter=getTheName) id name;
<span class="lineNum">   31083 </span><span class="lineNoCov">          0 :     @property int a, b, c;</span>
<span class="lineNum">   31084 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   31085 </span>            :    PS: This function is identical to
<a name="31086"><span class="lineNum">   31086 </span><span class="lineNoCov">          0 :    c_parser_objc_at_property_declaration for C.  Keep them in sync.  */</span></a>
<span class="lineNum">   31087 </span><span class="lineNoCov">          0 : static void </span>
<span class="lineNum">   31088 </span>            : cp_parser_objc_at_property_declaration (cp_parser *parser)
<span class="lineNum">   31089 </span>            : {
<span class="lineNum">   31090 </span>            :   /* The following variables hold the attributes of the properties as
<span class="lineNum">   31091 </span>            :      parsed.  They are 'false' or 'NULL_TREE' if the attribute was not
<span class="lineNum">   31092 </span>            :      seen.  When we see an attribute, we set them to 'true' (if they
<span class="lineNum">   31093 </span>            :      are boolean properties) or to the identifier (if they have an
<span class="lineNum">   31094 </span>            :      argument, ie, for getter and setter).  Note that here we only
<span class="lineNum">   31095 </span>            :      parse the list of attributes, check the syntax and accumulate the
<span class="lineNum">   31096 </span>            :      attributes that we find.  objc_add_property_declaration() will
<span class="lineNum">   31097 </span>            :      then process the information.  */
<span class="lineNum">   31098 </span>            :   bool property_assign = false;
<span class="lineNum">   31099 </span>            :   bool property_copy = false;
<span class="lineNum">   31100 </span>            :   tree property_getter_ident = NULL_TREE;
<span class="lineNum">   31101 </span>            :   bool property_nonatomic = false;
<span class="lineNum">   31102 </span>            :   bool property_readonly = false;
<span class="lineNum">   31103 </span>            :   bool property_readwrite = false;
<span class="lineNum">   31104 </span>            :   bool property_retain = false;
<span class="lineNum">   31105 </span>            :   tree property_setter_ident = NULL_TREE;
<span class="lineNum">   31106 </span>            : 
<span class="lineNum">   31107 </span>            :   /* 'properties' is the list of properties that we read.  Usually a
<span class="lineNum">   31108 </span>            :      single one, but maybe more (eg, in &quot;@property int a, b, c;&quot; there
<span class="lineNum">   31109 </span>            :      are three).  */
<span class="lineNum">   31110 </span>            :   tree properties;
<span class="lineNum">   31111 </span>            :   location_t loc;
<span class="lineNum">   31112 </span>            : 
<span class="lineNum">   31113 </span>            :   loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">   31114 </span>            : 
<span class="lineNum">   31115 </span>            :   cp_lexer_consume_token (parser-&gt;lexer);  /* Eat '@property'.  */
<span class="lineNum">   31116 </span>            : 
<span class="lineNum">   31117 </span>            :   /* Parse the optional attribute list...  */
<span class="lineNum">   31118 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_PAREN))
<span class="lineNum">   31119 </span>            :     {
<span class="lineNum">   31120 </span>            :       /* Eat the '('.  */
<span class="lineNum">   31121 </span>            :       matching_parens parens;
<span class="lineNum">   31122 </span>            :       parens.consume_open (parser);
<span class="lineNum">   31123 </span>            : 
<span class="lineNum">   31124 </span>            :       while (true)
<span class="lineNum">   31125 </span>            :         {
<span class="lineNum">   31126 </span><span class="lineNoCov">          0 :           bool syntax_error = false;</span>
<span class="lineNum">   31127 </span>            :           cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   31128 </span>            :           enum rid keyword;
<span class="lineNum">   31129 </span>            : 
<span class="lineNum">   31130 </span>            :           if (token-&gt;type != CPP_NAME)
<span class="lineNum">   31131 </span>            :             {
<span class="lineNum">   31132 </span>            :               cp_parser_error (parser, &quot;expected identifier&quot;);
<span class="lineNum">   31133 </span>            :               break;
<span class="lineNum">   31134 </span>            :             }
<span class="lineNum">   31135 </span>            :           keyword = C_RID_CODE (token-&gt;u.value);
<span class="lineNum">   31136 </span><span class="lineNoCov">          0 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   31137 </span><span class="lineNoCov">          0 :           switch (keyword)</span>
<span class="lineNum">   31138 </span><span class="lineNoCov">          0 :             {</span>
<span class="lineNum">   31139 </span><span class="lineNoCov">          0 :             case RID_ASSIGN:    property_assign = true;    break;</span>
<span class="lineNum">   31140 </span><span class="lineNoCov">          0 :             case RID_COPY:      property_copy = true;      break;</span>
<span class="lineNum">   31141 </span><span class="lineNoCov">          0 :             case RID_NONATOMIC: property_nonatomic = true; break;</span>
<span class="lineNum">   31142 </span><span class="lineNoCov">          0 :             case RID_READONLY:  property_readonly = true;  break;</span>
<span class="lineNum">   31143 </span><span class="lineNoCov">          0 :             case RID_READWRITE: property_readwrite = true; break;</span>
<span class="lineNum">   31144 </span>            :             case RID_RETAIN:    property_retain = true;    break;
<span class="lineNum">   31145 </span>            : 
<span class="lineNum">   31146 </span>            :             case RID_GETTER:
<span class="lineNum">   31147 </span>            :             case RID_SETTER:
<span class="lineNum">   31148 </span><span class="lineNoCov">          0 :               if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_EQ))</span>
<span class="lineNum">   31149 </span><span class="lineNoCov">          0 :                 {</span>
<span class="lineNum">   31150 </span>            :                   if (keyword == RID_GETTER)
<span class="lineNum">   31151 </span><span class="lineNoCov">          0 :                     cp_parser_error (parser,</span>
<span class="lineNum">   31152 </span>            :                                      &quot;missing %&lt;=%&gt; (after %&lt;getter%&gt; attribute)&quot;);
<span class="lineNum">   31153 </span><span class="lineNoCov">          0 :                   else</span>
<span class="lineNum">   31154 </span>            :                     cp_parser_error (parser,
<span class="lineNum">   31155 </span>            :                                      &quot;missing %&lt;=%&gt; (after %&lt;setter%&gt; attribute)&quot;);
<span class="lineNum">   31156 </span><span class="lineNoCov">          0 :                   syntax_error = true;</span>
<span class="lineNum">   31157 </span>            :                   break;
<span class="lineNum">   31158 </span>            :                 }
<span class="lineNum">   31159 </span><span class="lineNoCov">          0 :               cp_lexer_consume_token (parser-&gt;lexer); /* eat the = */</span>
<span class="lineNum">   31160 </span><span class="lineNoCov">          0 :               if (!cp_parser_objc_selector_p (cp_lexer_peek_token (parser-&gt;lexer)-&gt;type))</span>
<span class="lineNum">   31161 </span>            :                 {
<span class="lineNum">   31162 </span><span class="lineNoCov">          0 :                   cp_parser_error (parser, &quot;expected identifier&quot;);</span>
<span class="lineNum">   31163 </span>            :                   syntax_error = true;
<span class="lineNum">   31164 </span><span class="lineNoCov">          0 :                   break;</span>
<span class="lineNum">   31165 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">   31166 </span><span class="lineNoCov">          0 :               if (keyword == RID_SETTER)</span>
<span class="lineNum">   31167 </span>            :                 {
<span class="lineNum">   31168 </span><span class="lineNoCov">          0 :                   if (property_setter_ident != NULL_TREE)</span>
<span class="lineNum">   31169 </span>            :                     {
<span class="lineNum">   31170 </span><span class="lineNoCov">          0 :                       cp_parser_error (parser, &quot;the %&lt;setter%&gt; attribute may only be specified once&quot;);</span>
<span class="lineNum">   31171 </span><span class="lineNoCov">          0 :                       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   31172 </span>            :                     }
<span class="lineNum">   31173 </span><span class="lineNoCov">          0 :                   else</span>
<span class="lineNum">   31174 </span><span class="lineNoCov">          0 :                     property_setter_ident = cp_parser_objc_selector (parser);</span>
<span class="lineNum">   31175 </span><span class="lineNoCov">          0 :                   if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_COLON))</span>
<span class="lineNum">   31176 </span>            :                     cp_parser_error (parser, &quot;setter name must terminate with %&lt;:%&gt;&quot;);
<span class="lineNum">   31177 </span>            :                   else
<span class="lineNum">   31178 </span><span class="lineNoCov">          0 :                     cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   31179 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">   31180 </span><span class="lineNoCov">          0 :               else</span>
<span class="lineNum">   31181 </span><span class="lineNoCov">          0 :                 {</span>
<span class="lineNum">   31182 </span><span class="lineNoCov">          0 :                   if (property_getter_ident != NULL_TREE)</span>
<span class="lineNum">   31183 </span>            :                     {
<span class="lineNum">   31184 </span><span class="lineNoCov">          0 :                       cp_parser_error (parser, &quot;the %&lt;getter%&gt; attribute may only be specified once&quot;);</span>
<span class="lineNum">   31185 </span><span class="lineNoCov">          0 :                       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   31186 </span><span class="lineNoCov">          0 :                     }</span>
<span class="lineNum">   31187 </span>            :                   else
<span class="lineNum">   31188 </span><span class="lineNoCov">          0 :                     property_getter_ident = cp_parser_objc_selector (parser);</span>
<span class="lineNum">   31189 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">   31190 </span>            :               break;
<span class="lineNum">   31191 </span>            :             default:
<span class="lineNum">   31192 </span><span class="lineNoCov">          0 :               cp_parser_error (parser, &quot;unknown property attribute&quot;);</span>
<span class="lineNum">   31193 </span>            :               syntax_error = true;
<span class="lineNum">   31194 </span>            :               break;
<span class="lineNum">   31195 </span>            :             }
<span class="lineNum">   31196 </span>            : 
<span class="lineNum">   31197 </span><span class="lineNoCov">          0 :           if (syntax_error)</span>
<span class="lineNum">   31198 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">   31199 </span>            : 
<span class="lineNum">   31200 </span><span class="lineNoCov">          0 :           if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_COMMA))</span>
<span class="lineNum">   31201 </span><span class="lineNoCov">          0 :             cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   31202 </span><span class="lineNoCov">          0 :           else</span>
<span class="lineNum">   31203 </span>            :             break;
<span class="lineNum">   31204 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">   31205 </span>            : 
<span class="lineNum">   31206 </span><span class="lineNoCov">          0 :       /* FIXME: &quot;@property (setter, assign);&quot; will generate a spurious</span>
<span class="lineNum">   31207 </span>            :          &quot;error: expected ) before , token&quot;.  This is because
<span class="lineNum">   31208 </span><span class="lineNoCov">          0 :          cp_parser_require, unlike the C counterpart, will produce an</span>
<span class="lineNum">   31209 </span><span class="lineNoCov">          0 :          error even if we are in error recovery.  */</span>
<span class="lineNum">   31210 </span>            :       if (!parens.require_close (parser))
<span class="lineNum">   31211 </span>            :         {
<span class="lineNum">   31212 </span><span class="lineNoCov">          0 :           cp_parser_skip_to_closing_parenthesis (parser,</span>
<span class="lineNum">   31213 </span><span class="lineNoCov">          0 :                                                  /*recovering=*/true,</span>
<span class="lineNum">   31214 </span><span class="lineNoCov">          0 :                                                  /*or_comma=*/false,</span>
<span class="lineNum">   31215 </span>            :                                                  /*consume_paren=*/true);
<span class="lineNum">   31216 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">   31217 </span>            :     }
<span class="lineNum">   31218 </span>            : 
<span class="lineNum">   31219 </span>            :   /* ... and the property declaration(s).  */
<span class="lineNum">   31220 </span><span class="lineNoCov">          0 :   properties = cp_parser_objc_struct_declaration (parser);</span>
<span class="lineNum">   31221 </span>            : 
<span class="lineNum">   31222 </span><span class="lineNoCov">          0 :   if (properties == error_mark_node)</span>
<span class="lineNum">   31223 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   31224 </span>            :       cp_parser_skip_to_end_of_statement (parser);
<span class="lineNum">   31225 </span>            :       /* If the next token is now a `;', consume it.  */
<span class="lineNum">   31226 </span><span class="lineNoCov">          0 :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_SEMICOLON))</span>
<span class="lineNum">   31227 </span>            :         cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   31228 </span>            :       return;
<span class="lineNum">   31229 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   31230 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   31231 </span><span class="lineNoCov">          0 :   if (properties == NULL_TREE)</span>
<span class="lineNum">   31232 </span><span class="lineNoCov">          0 :     cp_parser_error (parser, &quot;expected identifier&quot;);</span>
<span class="lineNum">   31233 </span>            :   else
<span class="lineNum">   31234 </span>            :     {
<span class="lineNum">   31235 </span><span class="lineNoCov">          0 :       /* Comma-separated properties are chained together in</span>
<span class="lineNum">   31236 </span>            :          reverse order; add them one by one.  */
<span class="lineNum">   31237 </span>            :       properties = nreverse (properties);
<span class="lineNum">   31238 </span><span class="lineNoCov">          0 :       </span>
<span class="lineNum">   31239 </span><span class="lineNoCov">          0 :       for (; properties; properties = TREE_CHAIN (properties))</span>
<span class="lineNum">   31240 </span>            :         objc_add_property_declaration (loc, copy_node (properties),
<span class="lineNum">   31241 </span>            :                                        property_readonly, property_readwrite,
<span class="lineNum">   31242 </span><span class="lineNoCov">          0 :                                        property_assign, property_retain,</span>
<span class="lineNum">   31243 </span>            :                                        property_copy, property_nonatomic,
<span class="lineNum">   31244 </span>            :                                        property_getter_ident, property_setter_ident);
<span class="lineNum">   31245 </span>            :     }
<span class="lineNum">   31246 </span>            :   
<span class="lineNum">   31247 </span>            :   cp_parser_consume_semicolon_at_end_of_statement (parser);
<span class="lineNum">   31248 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   31249 </span>            : 
<span class="lineNum">   31250 </span><span class="lineNoCov">          0 : /* Parse an Objective-C++ @synthesize declaration.  The syntax is:</span>
<span class="lineNum">   31251 </span>            : 
<span class="lineNum">   31252 </span>            :    objc-synthesize-declaration:
<span class="lineNum">   31253 </span>            :      @synthesize objc-synthesize-identifier-list ;
<span class="lineNum">   31254 </span>            : 
<span class="lineNum">   31255 </span>            :    objc-synthesize-identifier-list:
<span class="lineNum">   31256 </span>            :      objc-synthesize-identifier
<span class="lineNum">   31257 </span>            :      objc-synthesize-identifier-list, objc-synthesize-identifier
<span class="lineNum">   31258 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   31259 </span>            :    objc-synthesize-identifier
<span class="lineNum">   31260 </span><span class="lineNoCov">          0 :      identifier</span>
<span class="lineNum">   31261 </span>            :      identifier = identifier
<span class="lineNum">   31262 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   31263 </span>            :   For example:
<span class="lineNum">   31264 </span><span class="lineNoCov">          0 :     @synthesize MyProperty;</span>
<span class="lineNum">   31265 </span><span class="lineNoCov">          0 :     @synthesize OneProperty, AnotherProperty=MyIvar, YetAnotherProperty;</span>
<span class="lineNum">   31266 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   31267 </span>            :   PS: This function is identical to c_parser_objc_at_synthesize_declaration
<span class="lineNum">   31268 </span>            :   for C.  Keep them in sync.
<a name="31269"><span class="lineNum">   31269 </span><span class="lineNoCov">          0 : */</span></a>
<span class="lineNum">   31270 </span><span class="lineNoCov">          0 : static void </span>
<span class="lineNum">   31271 </span>            : cp_parser_objc_at_synthesize_declaration (cp_parser *parser)
<span class="lineNum">   31272 </span>            : {
<span class="lineNum">   31273 </span>            :   tree list = NULL_TREE;
<span class="lineNum">   31274 </span>            :   location_t loc;
<span class="lineNum">   31275 </span><span class="lineNoCov">          0 :   loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;</span>
<span class="lineNum">   31276 </span>            : 
<span class="lineNum">   31277 </span><span class="lineNoCov">          0 :   cp_lexer_consume_token (parser-&gt;lexer);  /* Eat '@synthesize'.  */</span>
<span class="lineNum">   31278 </span><span class="lineNoCov">          0 :   while (true)</span>
<span class="lineNum">   31279 </span>            :     {
<span class="lineNum">   31280 </span>            :       tree property, ivar;
<span class="lineNum">   31281 </span>            :       property = cp_parser_identifier (parser);
<span class="lineNum">   31282 </span>            :       if (property == error_mark_node)
<span class="lineNum">   31283 </span>            :         {
<span class="lineNum">   31284 </span>            :           cp_parser_consume_semicolon_at_end_of_statement (parser);
<span class="lineNum">   31285 </span><span class="lineNoCov">          0 :           return;</span>
<span class="lineNum">   31286 </span>            :         }
<span class="lineNum">   31287 </span>            :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_EQ))
<span class="lineNum">   31288 </span>            :         {
<span class="lineNum">   31289 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   31290 </span>            :           ivar = cp_parser_identifier (parser);
<span class="lineNum">   31291 </span>            :           if (ivar == error_mark_node)
<span class="lineNum">   31292 </span>            :             {
<span class="lineNum">   31293 </span>            :               cp_parser_consume_semicolon_at_end_of_statement (parser);
<span class="lineNum">   31294 </span>            :               return;
<span class="lineNum">   31295 </span>            :             }
<span class="lineNum">   31296 </span>            :         }
<span class="lineNum">   31297 </span>            :       else
<span class="lineNum">   31298 </span>            :         ivar = NULL_TREE;
<span class="lineNum">   31299 </span>            :       list = chainon (list, build_tree_list (ivar, property));
<span class="lineNum">   31300 </span>            :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_COMMA))
<span class="lineNum">   31301 </span>            :         cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   31302 </span>            :       else
<span class="lineNum">   31303 </span>            :         break;
<span class="lineNum">   31304 </span>            :     }
<span class="lineNum">   31305 </span>            :   cp_parser_consume_semicolon_at_end_of_statement (parser);
<span class="lineNum">   31306 </span>            :   objc_add_synthesize_declaration (loc, list);
<span class="lineNum">   31307 </span>            : }
<span class="lineNum">   31308 </span>            : 
<span class="lineNum">   31309 </span><span class="lineNoCov">          0 : /* Parse an Objective-C++ @dynamic declaration.  The syntax is:</span>
<span class="lineNum">   31310 </span>            : 
<span class="lineNum">   31311 </span><span class="lineNoCov">          0 :    objc-dynamic-declaration:</span>
<span class="lineNum">   31312 </span><span class="lineNoCov">          0 :      @dynamic identifier-list ;</span>
<span class="lineNum">   31313 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   31314 </span>            :    For example:
<span class="lineNum">   31315 </span><span class="lineNoCov">          0 :      @dynamic MyProperty;</span>
<span class="lineNum">   31316 </span><span class="lineNoCov">          0 :      @dynamic MyProperty, AnotherProperty;</span>
<span class="lineNum">   31317 </span>            : 
<span class="lineNum">   31318 </span><span class="lineNoCov">          0 :   PS: This function is identical to c_parser_objc_at_dynamic_declaration</span>
<span class="lineNum">   31319 </span><span class="lineNoCov">          0 :   for C.  Keep them in sync.</span>
<a name="31320"><span class="lineNum">   31320 </span><span class="lineNoCov">          0 : */</span></a>
<span class="lineNum">   31321 </span>            : static void 
<span class="lineNum">   31322 </span><span class="lineNoCov">          0 : cp_parser_objc_at_dynamic_declaration (cp_parser *parser)</span>
<span class="lineNum">   31323 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   31324 </span>            :   tree list = NULL_TREE;
<span class="lineNum">   31325 </span><span class="lineNoCov">          0 :   location_t loc;</span>
<span class="lineNum">   31326 </span>            :   loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">   31327 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   31328 </span><span class="lineNoCov">          0 :   cp_lexer_consume_token (parser-&gt;lexer);  /* Eat '@dynamic'.  */</span>
<span class="lineNum">   31329 </span><span class="lineNoCov">          0 :   while (true)</span>
<span class="lineNum">   31330 </span>            :     {
<span class="lineNum">   31331 </span><span class="lineNoCov">          0 :       tree property;</span>
<span class="lineNum">   31332 </span><span class="lineNoCov">          0 :       property = cp_parser_identifier (parser);</span>
<span class="lineNum">   31333 </span>            :       if (property == error_mark_node)
<span class="lineNum">   31334 </span>            :         {
<span class="lineNum">   31335 </span>            :           cp_parser_consume_semicolon_at_end_of_statement (parser);
<span class="lineNum">   31336 </span>            :           return;
<span class="lineNum">   31337 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">   31338 </span><span class="lineNoCov">          0 :       list = chainon (list, build_tree_list (NULL, property));</span>
<span class="lineNum">   31339 </span><span class="lineNoCov">          0 :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_COMMA))</span>
<span class="lineNum">   31340 </span>            :         cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   31341 </span>            :       else
<span class="lineNum">   31342 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">   31343 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   31344 </span><span class="lineNoCov">          0 :   cp_parser_consume_semicolon_at_end_of_statement (parser);</span>
<span class="lineNum">   31345 </span>            :   objc_add_dynamic_declaration (loc, list);
<span class="lineNum">   31346 </span>            : }
<span class="lineNum">   31347 </span>            : 
<span class="lineNum">   31348 </span>            : 
<span class="lineNum">   31349 </span>            : /* OpenMP 2.5 / 3.0 / 3.1 / 4.0 parsing routines.  */
<span class="lineNum">   31350 </span>            : 
<span class="lineNum">   31351 </span>            : /* Returns name of the next clause.
<span class="lineNum">   31352 </span>            :    If the clause is not recognized PRAGMA_OMP_CLAUSE_NONE is returned and
<span class="lineNum">   31353 </span>            :    the token is not consumed.  Otherwise appropriate pragma_omp_clause is
<span class="lineNum">   31354 </span>            :    returned and the token is consumed.  */
<a name="31355"><span class="lineNum">   31355 </span>            : </a>
<span class="lineNum">   31356 </span>            : static pragma_omp_clause
<span class="lineNum">   31357 </span>            : cp_parser_omp_clause_name (cp_parser *parser)
<span class="lineNum">   31358 </span>            : {
<span class="lineNum">   31359 </span>            :   pragma_omp_clause result = PRAGMA_OMP_CLAUSE_NONE;
<span class="lineNum">   31360 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   31361 </span>            :   if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_AUTO))
<span class="lineNum">   31362 </span><span class="lineNoCov">          0 :     result = PRAGMA_OACC_CLAUSE_AUTO;</span>
<span class="lineNum">   31363 </span><span class="lineNoCov">          0 :   else if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_IF))</span>
<span class="lineNum">   31364 </span><span class="lineNoCov">          0 :     result = PRAGMA_OMP_CLAUSE_IF;</span>
<span class="lineNum">   31365 </span>            :   else if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_DEFAULT))
<span class="lineNum">   31366 </span><span class="lineNoCov">          0 :     result = PRAGMA_OMP_CLAUSE_DEFAULT;</span>
<span class="lineNum">   31367 </span><span class="lineNoCov">          0 :   else if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_DELETE))</span>
<span class="lineNum">   31368 </span>            :     result = PRAGMA_OACC_CLAUSE_DELETE;
<span class="lineNum">   31369 </span><span class="lineNoCov">          0 :   else if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_PRIVATE))</span>
<span class="lineNum">   31370 </span><span class="lineNoCov">          0 :     result = PRAGMA_OMP_CLAUSE_PRIVATE;</span>
<span class="lineNum">   31371 </span><span class="lineNoCov">          0 :   else if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_FOR))</span>
<span class="lineNum">   31372 </span>            :     result = PRAGMA_OMP_CLAUSE_FOR;
<span class="lineNum">   31373 </span><span class="lineNoCov">          0 :   else if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))</span>
<span class="lineNum">   31374 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   31375 </span>            :       tree id = cp_lexer_peek_token (parser-&gt;lexer)-&gt;u.value;
<span class="lineNum">   31376 </span><span class="lineNoCov">          0 :       const char *p = IDENTIFIER_POINTER (id);</span>
<span class="lineNum">   31377 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   31378 </span><span class="lineNoCov">          0 :       switch (p[0])</span>
<span class="lineNum">   31379 </span>            :         {
<span class="lineNum">   31380 </span>            :         case 'a':
<span class="lineNum">   31381 </span><span class="lineNoCov">          0 :           if (!strcmp (&quot;aligned&quot;, p))</span>
<span class="lineNum">   31382 </span><span class="lineNoCov">          0 :             result = PRAGMA_OMP_CLAUSE_ALIGNED;</span>
<span class="lineNum">   31383 </span><span class="lineNoCov">          0 :           else if (!strcmp (&quot;async&quot;, p))</span>
<span class="lineNum">   31384 </span>            :             result = PRAGMA_OACC_CLAUSE_ASYNC;
<span class="lineNum">   31385 </span>            :           break;
<span class="lineNum">   31386 </span>            :         case 'c':
<span class="lineNum">   31387 </span>            :           if (!strcmp (&quot;collapse&quot;, p))
<span class="lineNum">   31388 </span>            :             result = PRAGMA_OMP_CLAUSE_COLLAPSE;
<span class="lineNum">   31389 </span>            :           else if (!strcmp (&quot;copy&quot;, p))
<span class="lineNum">   31390 </span>            :             result = PRAGMA_OACC_CLAUSE_COPY;
<span class="lineNum">   31391 </span>            :           else if (!strcmp (&quot;copyin&quot;, p))
<span class="lineNum">   31392 </span>            :             result = PRAGMA_OMP_CLAUSE_COPYIN;
<span class="lineNum">   31393 </span>            :           else if (!strcmp (&quot;copyout&quot;, p))
<span class="lineNum">   31394 </span>            :             result = PRAGMA_OACC_CLAUSE_COPYOUT;
<span class="lineNum">   31395 </span><span class="lineCov">      21734 :           else if (!strcmp (&quot;copyprivate&quot;, p))</span>
<span class="lineNum">   31396 </span>            :             result = PRAGMA_OMP_CLAUSE_COPYPRIVATE;
<span class="lineNum">   31397 </span><span class="lineCov">      21734 :           else if (!strcmp (&quot;create&quot;, p))</span>
<span class="lineNum">   31398 </span>            :             result = PRAGMA_OACC_CLAUSE_CREATE;
<span class="lineNum">   31399 </span><span class="lineCov">      21734 :           break;</span>
<span class="lineNum">   31400 </span>            :         case 'd':
<span class="lineNum">   31401 </span><span class="lineCov">      21487 :           if (!strcmp (&quot;defaultmap&quot;, p))</span>
<span class="lineNum">   31402 </span>            :             result = PRAGMA_OMP_CLAUSE_DEFAULTMAP;
<span class="lineNum">   31403 </span><span class="lineCov">      20974 :           else if (!strcmp (&quot;depend&quot;, p))</span>
<span class="lineNum">   31404 </span>            :             result = PRAGMA_OMP_CLAUSE_DEPEND;
<span class="lineNum">   31405 </span><span class="lineCov">      20595 :           else if (!strcmp (&quot;device&quot;, p))</span>
<span class="lineNum">   31406 </span>            :             result = PRAGMA_OMP_CLAUSE_DEVICE;
<span class="lineNum">   31407 </span><span class="lineCov">      20505 :           else if (!strcmp (&quot;deviceptr&quot;, p))</span>
<span class="lineNum">   31408 </span>            :             result = PRAGMA_OACC_CLAUSE_DEVICEPTR;
<span class="lineNum">   31409 </span><span class="lineCov">      19953 :           else if (!strcmp (&quot;device_resident&quot;, p))</span>
<span class="lineNum">   31410 </span>            :             result = PRAGMA_OACC_CLAUSE_DEVICE_RESIDENT;
<span class="lineNum">   31411 </span><span class="lineCov">      19752 :           else if (!strcmp (&quot;dist_schedule&quot;, p))</span>
<span class="lineNum">   31412 </span>            :             result = PRAGMA_OMP_CLAUSE_DIST_SCHEDULE;
<span class="lineNum">   31413 </span><span class="lineCov">      39444 :           break;</span>
<span class="lineNum">   31414 </span><span class="lineCov">      19722 :         case 'f':</span>
<span class="lineNum">   31415 </span>            :           if (!strcmp (&quot;final&quot;, p))
<span class="lineNum">   31416 </span><span class="lineCov">      19722 :             result = PRAGMA_OMP_CLAUSE_FINAL;</span>
<span class="lineNum">   31417 </span>            :           else if (!strcmp (&quot;finalize&quot;, p))
<span class="lineNum">   31418 </span><span class="lineCov">        577 :             result = PRAGMA_OACC_CLAUSE_FINALIZE;</span>
<span class="lineNum">   31419 </span><span class="lineCov">        577 :           else if (!strcmp (&quot;firstprivate&quot;, p))</span>
<span class="lineNum">   31420 </span>            :             result = PRAGMA_OMP_CLAUSE_FIRSTPRIVATE;
<span class="lineNum">   31421 </span><span class="lineCov">        277 :           else if (!strcmp (&quot;from&quot;, p))</span>
<span class="lineNum">   31422 </span>            :             result = PRAGMA_OMP_CLAUSE_FROM;
<span class="lineNum">   31423 </span>            :           break;
<span class="lineNum">   31424 </span><span class="lineCov">       3074 :         case 'g':</span>
<span class="lineNum">   31425 </span><span class="lineCov">       3074 :           if (!strcmp (&quot;gang&quot;, p))</span>
<span class="lineNum">   31426 </span>            :             result = PRAGMA_OACC_CLAUSE_GANG;
<span class="lineNum">   31427 </span><span class="lineCov">       1633 :           else if (!strcmp (&quot;grainsize&quot;, p))</span>
<span class="lineNum">   31428 </span>            :             result = PRAGMA_OMP_CLAUSE_GRAINSIZE;
<span class="lineNum">   31429 </span><span class="lineCov">        950 :           break;</span>
<span class="lineNum">   31430 </span>            :         case 'h':
<span class="lineNum">   31431 </span><span class="lineCov">        514 :           if (!strcmp (&quot;hint&quot;, p))</span>
<span class="lineNum">   31432 </span>            :             result = PRAGMA_OMP_CLAUSE_HINT;
<span class="lineNum">   31433 </span><span class="lineCov">        205 :           else if (!strcmp (&quot;host&quot;, p))</span>
<span class="lineNum">   31434 </span>            :             result = PRAGMA_OACC_CLAUSE_HOST;
<span class="lineNum">   31435 </span><span class="lineCov">        143 :           break;</span>
<span class="lineNum">   31436 </span>            :         case 'i':
<span class="lineNum">   31437 </span>            :           if (!strcmp (&quot;if_present&quot;, p))
<span class="lineNum">   31438 </span><span class="lineCov">       1565 :             result = PRAGMA_OACC_CLAUSE_IF_PRESENT;</span>
<span class="lineNum">   31439 </span><span class="lineCov">       1565 :           else if (!strcmp (&quot;inbranch&quot;, p))</span>
<span class="lineNum">   31440 </span>            :             result = PRAGMA_OMP_CLAUSE_INBRANCH;
<span class="lineNum">   31441 </span><span class="lineCov">       1525 :           else if (!strcmp (&quot;independent&quot;, p))</span>
<span class="lineNum">   31442 </span>            :             result = PRAGMA_OACC_CLAUSE_INDEPENDENT;
<span class="lineNum">   31443 </span><span class="lineCov">        923 :           else if (!strcmp (&quot;is_device_ptr&quot;, p))</span>
<span class="lineNum">   31444 </span>            :             result = PRAGMA_OMP_CLAUSE_IS_DEVICE_PTR;
<span class="lineNum">   31445 </span><span class="lineCov">        763 :           break;</span>
<span class="lineNum">   31446 </span>            :         case 'l':
<span class="lineNum">   31447 </span><span class="lineCov">        692 :           if (!strcmp (&quot;lastprivate&quot;, p))</span>
<span class="lineNum">   31448 </span>            :             result = PRAGMA_OMP_CLAUSE_LASTPRIVATE;
<span class="lineNum">   31449 </span><span class="lineCov">        673 :           else if (!strcmp (&quot;linear&quot;, p))</span>
<span class="lineNum">   31450 </span>            :             result = PRAGMA_OMP_CLAUSE_LINEAR;
<span class="lineNum">   31451 </span>            :           else if (!strcmp (&quot;link&quot;, p))
<span class="lineNum">   31452 </span><span class="lineCov">       1515 :             result = PRAGMA_OMP_CLAUSE_LINK;</span>
<span class="lineNum">   31453 </span><span class="lineCov">       1515 :           break;</span>
<span class="lineNum">   31454 </span>            :         case 'm':
<span class="lineNum">   31455 </span><span class="lineCov">       1493 :           if (!strcmp (&quot;map&quot;, p))</span>
<span class="lineNum">   31456 </span>            :             result = PRAGMA_OMP_CLAUSE_MAP;
<span class="lineNum">   31457 </span><span class="lineCov">       1475 :           else if (!strcmp (&quot;mergeable&quot;, p))</span>
<span class="lineNum">   31458 </span>            :             result = PRAGMA_OMP_CLAUSE_MERGEABLE;
<span class="lineNum">   31459 </span><span class="lineCov">        920 :           break;</span>
<span class="lineNum">   31460 </span>            :         case 'n':
<span class="lineNum">   31461 </span>            :           if (!strcmp (&quot;nogroup&quot;, p))
<span class="lineNum">   31462 </span><span class="lineCov">        737 :             result = PRAGMA_OMP_CLAUSE_NOGROUP;</span>
<span class="lineNum">   31463 </span><span class="lineCov">        737 :           else if (!strcmp (&quot;notinbranch&quot;, p))</span>
<span class="lineNum">   31464 </span>            :             result = PRAGMA_OMP_CLAUSE_NOTINBRANCH;
<span class="lineNum">   31465 </span><span class="lineCov">          6 :           else if (!strcmp (&quot;nowait&quot;, p))</span>
<span class="lineNum">   31466 </span>            :             result = PRAGMA_OMP_CLAUSE_NOWAIT;
<span class="lineNum">   31467 </span>            :           else if (!strcmp (&quot;num_gangs&quot;, p))
<span class="lineNum">   31468 </span><span class="lineCov">         80 :             result = PRAGMA_OACC_CLAUSE_NUM_GANGS;</span>
<span class="lineNum">   31469 </span><span class="lineCov">         80 :           else if (!strcmp (&quot;num_tasks&quot;, p))</span>
<span class="lineNum">   31470 </span>            :             result = PRAGMA_OMP_CLAUSE_NUM_TASKS;
<span class="lineNum">   31471 </span><span class="lineCov">         80 :           else if (!strcmp (&quot;num_teams&quot;, p))</span>
<span class="lineNum">   31472 </span>            :             result = PRAGMA_OMP_CLAUSE_NUM_TEAMS;
<span class="lineNum">   31473 </span>            :           else if (!strcmp (&quot;num_threads&quot;, p))
<span class="lineNum">   31474 </span><span class="lineCov">        119 :             result = PRAGMA_OMP_CLAUSE_NUM_THREADS;</span>
<span class="lineNum">   31475 </span><span class="lineCov">        119 :           else if (!strcmp (&quot;num_workers&quot;, p))</span>
<span class="lineNum">   31476 </span>            :             result = PRAGMA_OACC_CLAUSE_NUM_WORKERS;
<span class="lineNum">   31477 </span><span class="lineCov">         83 :           break;</span>
<span class="lineNum">   31478 </span>            :         case 'o':
<span class="lineNum">   31479 </span><span class="lineCov">         62 :           if (!strcmp (&quot;ordered&quot;, p))</span>
<span class="lineNum">   31480 </span>            :             result = PRAGMA_OMP_CLAUSE_ORDERED;
<span class="lineNum">   31481 </span><span class="lineCov">         32 :           break;</span>
<span class="lineNum">   31482 </span>            :         case 'p':
<span class="lineNum">   31483 </span>            :           if (!strcmp (&quot;parallel&quot;, p))
<span class="lineNum">   31484 </span><span class="lineCov">       1246 :             result = PRAGMA_OMP_CLAUSE_PARALLEL;</span>
<span class="lineNum">   31485 </span><span class="lineCov">       1246 :           else if (!strcmp (&quot;present&quot;, p))</span>
<span class="lineNum">   31486 </span>            :             result = PRAGMA_OACC_CLAUSE_PRESENT;
<span class="lineNum">   31487 </span><span class="lineCov">        844 :           else if (!strcmp (&quot;present_or_copy&quot;, p)</span>
<span class="lineNum">   31488 </span>            :                    || !strcmp (&quot;pcopy&quot;, p))
<span class="lineNum">   31489 </span><span class="lineCov">         57 :             result = PRAGMA_OACC_CLAUSE_COPY;</span>
<span class="lineNum">   31490 </span><span class="lineCov">         57 :           else if (!strcmp (&quot;present_or_copyin&quot;, p)</span>
<span class="lineNum">   31491 </span>            :                    || !strcmp (&quot;pcopyin&quot;, p))
<span class="lineNum">   31492 </span><span class="lineCov">       1021 :             result = PRAGMA_OACC_CLAUSE_COPYIN;</span>
<span class="lineNum">   31493 </span><span class="lineCov">       1021 :           else if (!strcmp (&quot;present_or_copyout&quot;, p)</span>
<span class="lineNum">   31494 </span>            :                    || !strcmp (&quot;pcopyout&quot;, p))
<span class="lineNum">   31495 </span><span class="lineCov">          3 :             result = PRAGMA_OACC_CLAUSE_COPYOUT;</span>
<span class="lineNum">   31496 </span>            :           else if (!strcmp (&quot;present_or_create&quot;, p)
<span class="lineNum">   31497 </span>            :                    || !strcmp (&quot;pcreate&quot;, p))
<span class="lineNum">   31498 </span><span class="lineCov">       1527 :             result = PRAGMA_OACC_CLAUSE_CREATE;</span>
<span class="lineNum">   31499 </span><span class="lineCov">       1527 :           else if (!strcmp (&quot;priority&quot;, p))</span>
<span class="lineNum">   31500 </span>            :             result = PRAGMA_OMP_CLAUSE_PRIORITY;
<span class="lineNum">   31501 </span><span class="lineCov">       1516 :           else if (!strcmp (&quot;proc_bind&quot;, p))</span>
<span class="lineNum">   31502 </span>            :             result = PRAGMA_OMP_CLAUSE_PROC_BIND;
<span class="lineNum">   31503 </span><span class="lineCov">       1322 :           break;</span>
<span class="lineNum">   31504 </span>            :         case 'r':
<span class="lineNum">   31505 </span><span class="lineCov">       1145 :           if (!strcmp (&quot;reduction&quot;, p))</span>
<span class="lineNum">   31506 </span>            :             result = PRAGMA_OMP_CLAUSE_REDUCTION;
<span class="lineNum">   31507 </span><span class="lineCov">        746 :           break;</span>
<span class="lineNum">   31508 </span>            :         case 's':
<span class="lineNum">   31509 </span><span class="lineCov">        740 :           if (!strcmp (&quot;safelen&quot;, p))</span>
<span class="lineNum">   31510 </span>            :             result = PRAGMA_OMP_CLAUSE_SAFELEN;
<span class="lineNum">   31511 </span><span class="lineCov">        556 :           else if (!strcmp (&quot;schedule&quot;, p))</span>
<span class="lineNum">   31512 </span>            :             result = PRAGMA_OMP_CLAUSE_SCHEDULE;
<span class="lineNum">   31513 </span><span class="lineCov">        293 :           else if (!strcmp (&quot;sections&quot;, p))</span>
<span class="lineNum">   31514 </span><span class="lineCov">        293 :             result = PRAGMA_OMP_CLAUSE_SECTIONS;</span>
<span class="lineNum">   31515 </span>            :           else if (!strcmp (&quot;self&quot;, p)) /* &quot;self&quot; is a synonym for &quot;host&quot;.  */
<span class="lineNum">   31516 </span><span class="lineCov">        208 :             result = PRAGMA_OACC_CLAUSE_HOST;</span>
<span class="lineNum">   31517 </span><span class="lineCov">        208 :           else if (!strcmp (&quot;seq&quot;, p))</span>
<span class="lineNum">   31518 </span>            :             result = PRAGMA_OACC_CLAUSE_SEQ;
<span class="lineNum">   31519 </span>            :           else if (!strcmp (&quot;shared&quot;, p))
<span class="lineNum">   31520 </span><span class="lineCov">        658 :             result = PRAGMA_OMP_CLAUSE_SHARED;</span>
<span class="lineNum">   31521 </span><span class="lineCov">        658 :           else if (!strcmp (&quot;simd&quot;, p))</span>
<span class="lineNum">   31522 </span>            :             result = PRAGMA_OMP_CLAUSE_SIMD;
<span class="lineNum">   31523 </span><span class="lineCov">        462 :           else if (!strcmp (&quot;simdlen&quot;, p))</span>
<span class="lineNum">   31524 </span>            :             result = PRAGMA_OMP_CLAUSE_SIMDLEN;
<span class="lineNum">   31525 </span><span class="lineCov">        306 :           break;</span>
<span class="lineNum">   31526 </span><span class="lineCov">        291 :         case 't':</span>
<span class="lineNum">   31527 </span>            :           if (!strcmp (&quot;taskgroup&quot;, p))
<span class="lineNum">   31528 </span><span class="lineCov">        269 :             result = PRAGMA_OMP_CLAUSE_TASKGROUP;</span>
<span class="lineNum">   31529 </span><span class="lineCov">        251 :           else if (!strcmp (&quot;thread_limit&quot;, p))</span>
<span class="lineNum">   31530 </span>            :             result = PRAGMA_OMP_CLAUSE_THREAD_LIMIT;
<span class="lineNum">   31531 </span><span class="lineCov">        231 :           else if (!strcmp (&quot;threads&quot;, p))</span>
<span class="lineNum">   31532 </span><span class="lineCov">        174 :             result = PRAGMA_OMP_CLAUSE_THREADS;</span>
<span class="lineNum">   31533 </span>            :           else if (!strcmp (&quot;tile&quot;, p))
<span class="lineNum">   31534 </span><span class="lineCov">        148 :             result = PRAGMA_OACC_CLAUSE_TILE;</span>
<span class="lineNum">   31535 </span><span class="lineCov">        134 :           else if (!strcmp (&quot;to&quot;, p))</span>
<span class="lineNum">   31536 </span>            :             result = PRAGMA_OMP_CLAUSE_TO;
<span class="lineNum">   31537 </span><span class="lineCov">        126 :           break;</span>
<span class="lineNum">   31538 </span>            :         case 'u':
<span class="lineNum">   31539 </span><span class="lineCov">        108 :           if (!strcmp (&quot;uniform&quot;, p))</span>
<span class="lineNum">   31540 </span><span class="lineCov">        108 :             result = PRAGMA_OMP_CLAUSE_UNIFORM;</span>
<span class="lineNum">   31541 </span>            :           else if (!strcmp (&quot;untied&quot;, p))
<span class="lineNum">   31542 </span><span class="lineCov">       1394 :             result = PRAGMA_OMP_CLAUSE_UNTIED;</span>
<span class="lineNum">   31543 </span><span class="lineCov">       1394 :           else if (!strcmp (&quot;use_device&quot;, p))</span>
<span class="lineNum">   31544 </span>            :             result = PRAGMA_OACC_CLAUSE_USE_DEVICE;
<span class="lineNum">   31545 </span>            :           else if (!strcmp (&quot;use_device_ptr&quot;, p))
<span class="lineNum">   31546 </span><span class="lineCov">       3069 :             result = PRAGMA_OMP_CLAUSE_USE_DEVICE_PTR;</span>
<span class="lineNum">   31547 </span><span class="lineCov">       3069 :           break;</span>
<span class="lineNum">   31548 </span>            :         case 'v':
<span class="lineNum">   31549 </span><span class="lineCov">       2938 :           if (!strcmp (&quot;vector&quot;, p))</span>
<span class="lineNum">   31550 </span>            :             result = PRAGMA_OACC_CLAUSE_VECTOR;
<span class="lineNum">   31551 </span><span class="lineCov">       1198 :           else if (!strcmp (&quot;vector_length&quot;, p))</span>
<span class="lineNum">   31552 </span>            :             result = PRAGMA_OACC_CLAUSE_VECTOR_LENGTH;
<span class="lineNum">   31553 </span><span class="lineCov">       1002 :           break;</span>
<span class="lineNum">   31554 </span>            :         case 'w':
<span class="lineNum">   31555 </span><span class="lineCov">        966 :           if (!strcmp (&quot;wait&quot;, p))</span>
<span class="lineNum">   31556 </span>            :             result = PRAGMA_OACC_CLAUSE_WAIT;
<span class="lineNum">   31557 </span><span class="lineCov">        705 :           else if (!strcmp (&quot;worker&quot;, p))</span>
<span class="lineNum">   31558 </span>            :             result = PRAGMA_OACC_CLAUSE_WORKER;
<span class="lineNum">   31559 </span><span class="lineCov">        300 :           break;</span>
<span class="lineNum">   31560 </span>            :         }
<span class="lineNum">   31561 </span><span class="lineCov">        183 :     }</span>
<span class="lineNum">   31562 </span><span class="lineCov">        183 : </span>
<span class="lineNum">   31563 </span>            :   if (result != PRAGMA_OMP_CLAUSE_NONE)
<span class="lineNum">   31564 </span><span class="lineCov">       1101 :     cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   31565 </span><span class="lineCov">       1101 : </span>
<span class="lineNum">   31566 </span>            :   return result;
<span class="lineNum">   31567 </span><span class="lineCov">        878 : }</span>
<span class="lineNum">   31568 </span>            : 
<span class="lineNum">   31569 </span><span class="lineCov">        694 : /* Validate that a clause of the given type does not already exist.  */</span>
<a name="31570"><span class="lineNum">   31570 </span>            : </a>
<span class="lineNum">   31571 </span><span class="lineCov">        602 : static void</span>
<span class="lineNum">   31572 </span>            : check_no_duplicate_clause (tree clauses, enum omp_clause_code code,
<span class="lineNum">   31573 </span><span class="lineCov">        291 :                            const char *name, location_t location)</span>
<span class="lineNum">   31574 </span><span class="lineCov">        288 : {</span>
<span class="lineNum">   31575 </span>            :   tree c;
<span class="lineNum">   31576 </span><span class="lineCov">        255 : </span>
<span class="lineNum">   31577 </span><span class="lineCov">        255 :   for (c = clauses; c ; c = OMP_CLAUSE_CHAIN (c))</span>
<span class="lineNum">   31578 </span>            :     if (OMP_CLAUSE_CODE (c) == code)
<span class="lineNum">   31579 </span><span class="lineCov">         43 :       {</span>
<span class="lineNum">   31580 </span>            :         error_at (location, &quot;too many %qs clauses&quot;, name);
<span class="lineNum">   31581 </span><span class="lineCov">         38 :         break;</span>
<span class="lineNum">   31582 </span>            :       }
<span class="lineNum">   31583 </span><span class="lineCov">          5 : }</span>
<span class="lineNum">   31584 </span><span class="lineCov">          5 : </span>
<span class="lineNum">   31585 </span>            : /* OpenMP 2.5:
<span class="lineNum">   31586 </span><span class="lineCov">        921 :    variable-list:</span>
<span class="lineNum">   31587 </span><span class="lineCov">        921 :      identifier</span>
<span class="lineNum">   31588 </span>            :      variable-list , identifier
<span class="lineNum">   31589 </span><span class="lineCov">        301 : </span>
<span class="lineNum">   31590 </span>            :    In addition, we match a closing parenthesis (or, if COLON is non-NULL,
<span class="lineNum">   31591 </span>            :    colon).  An opening parenthesis will have been consumed by the caller.
<span class="lineNum">   31592 </span><span class="lineCov">        649 : </span>
<span class="lineNum">   31593 </span><span class="lineCov">        649 :    If KIND is nonzero, create the appropriate node and install the decl</span>
<span class="lineNum">   31594 </span>            :    in OMP_CLAUSE_DECL and add the node to the head of the list.
<span class="lineNum">   31595 </span><span class="lineCov">        545 : </span>
<span class="lineNum">   31596 </span>            :    If KIND is zero, create a TREE_LIST with the decl in TREE_PURPOSE;
<span class="lineNum">   31597 </span>            :    return the list created.
<span class="lineNum">   31598 </span>            : 
<span class="lineNum">   31599 </span>            :    COLON can be NULL if only closing parenthesis should end the list,
<span class="lineNum">   31600 </span>            :    or pointer to bool which will receive false if the list is terminated
<span class="lineNum">   31601 </span><span class="lineCov">       7414 :    by closing parenthesis or true if the list is terminated by colon.  */</span>
<a name="31602"><span class="lineNum">   31602 </span><span class="lineCov">      21686 : </span></a>
<span class="lineNum">   31603 </span>            : static tree
<span class="lineNum">   31604 </span><span class="lineCov">      21734 : cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,</span>
<span class="lineNum">   31605 </span>            :                                 tree list, bool *colon)
<span class="lineNum">   31606 </span>            : {
<span class="lineNum">   31607 </span>            :   cp_token *token;
<span class="lineNum">   31608 </span>            :   bool saved_colon_corrects_to_scope_p = parser-&gt;colon_corrects_to_scope_p;
<span class="lineNum">   31609 </span>            :   if (colon)
<span class="lineNum">   31610 </span><span class="lineCov">      11802 :     {</span>
<span class="lineNum">   31611 </span>            :       parser-&gt;colon_corrects_to_scope_p = false;
<span class="lineNum">   31612 </span>            :       *colon = false;
<span class="lineNum">   31613 </span><span class="lineCov">      11802 :     }</span>
<span class="lineNum">   31614 </span>            :   while (1)
<span class="lineNum">   31615 </span><span class="lineCov">      42156 :     {</span>
<span class="lineNum">   31616 </span><span class="lineCov">      15222 :       tree name, decl;</span>
<span class="lineNum">   31617 </span>            : 
<span class="lineNum">   31618 </span><span class="lineCov">         45 :       token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   31619 </span><span class="lineCov">         45 :       if (kind != 0</span>
<span class="lineNum">   31620 </span>            :           &amp;&amp; current_class_ptr
<span class="lineNum">   31621 </span><span class="lineCov">      11802 :           &amp;&amp; cp_parser_is_keyword (token, RID_THIS))</span>
<span class="lineNum">   31622 </span>            :         {
<span class="lineNum">   31623 </span>            :           decl = finish_this_expr ();
<span class="lineNum">   31624 </span>            :           if (TREE_CODE (decl) == NON_LVALUE_EXPR
<span class="lineNum">   31625 </span>            :               || CONVERT_EXPR_P (decl))
<span class="lineNum">   31626 </span>            :             decl = TREE_OPERAND (decl, 0);
<span class="lineNum">   31627 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   31628 </span>            :         }
<span class="lineNum">   31629 </span>            :       else
<span class="lineNum">   31630 </span>            :         {
<span class="lineNum">   31631 </span>            :           name = cp_parser_id_expression (parser, /*template_p=*/false,
<span class="lineNum">   31632 </span>            :                                           /*check_dependency_p=*/true,
<span class="lineNum">   31633 </span>            :                                           /*template_p=*/NULL,
<span class="lineNum">   31634 </span>            :                                           /*declarator_p=*/false,
<span class="lineNum">   31635 </span>            :                                           /*optional_p=*/false);
<span class="lineNum">   31636 </span>            :           if (name == error_mark_node)
<span class="lineNum">   31637 </span>            :             goto skip_comma;
<span class="lineNum">   31638 </span>            : 
<span class="lineNum">   31639 </span>            :           if (identifier_p (name))
<span class="lineNum">   31640 </span>            :             decl = cp_parser_lookup_name_simple (parser, name, token-&gt;location);
<span class="lineNum">   31641 </span>            :           else
<span class="lineNum">   31642 </span><span class="lineCov">       9972 :             decl = name;</span>
<span class="lineNum">   31643 </span>            :           if (decl == error_mark_node)
<span class="lineNum">   31644 </span>            :             cp_parser_name_lookup_error (parser, name, decl, NLE_NULL,
<span class="lineNum">   31645 </span><span class="lineCov">       9972 :                                          token-&gt;location);</span>
<span class="lineNum">   31646 </span><span class="lineCov">       9972 :         }</span>
<span class="lineNum">   31647 </span><span class="lineCov">       9972 :       if (decl == error_mark_node)</span>
<span class="lineNum">   31648 </span>            :         ;
<span class="lineNum">   31649 </span><span class="lineCov">        928 :       else if (kind != 0)</span>
<span class="lineNum">   31650 </span><span class="lineCov">        928 :         {</span>
<span class="lineNum">   31651 </span>            :           switch (kind)
<span class="lineNum">   31652 </span><span class="lineCov">      12097 :             {</span>
<span class="lineNum">   31653 </span>            :             case OMP_CLAUSE__CACHE_:
<span class="lineNum">   31654 </span><span class="lineCov">      12097 :               /* The OpenACC cache directive explicitly only allows &quot;array</span>
<span class="lineNum">   31655 </span>            :                  elements or subarrays&quot;.  */
<span class="lineNum">   31656 </span><span class="lineCov">      24194 :               if (cp_lexer_peek_token (parser-&gt;lexer)-&gt;type != CPP_OPEN_SQUARE)</span>
<span class="lineNum">   31657 </span><span class="lineCov">      12097 :                 {</span>
<span class="lineNum">   31658 </span><span class="lineCov">      11864 :                   error_at (token-&gt;location, &quot;expected %&lt;[%&gt;&quot;);</span>
<span class="lineNum">   31659 </span><span class="lineCov">      13412 :                   decl = error_mark_node;</span>
<span class="lineNum">   31660 </span>            :                   break;
<span class="lineNum">   31661 </span><span class="lineCov">        210 :                 }</span>
<span class="lineNum">   31662 </span><span class="lineCov">        210 :               /* FALLTHROUGH.  */</span>
<span class="lineNum">   31663 </span><span class="lineCov">        210 :             case OMP_CLAUSE_MAP:</span>
<span class="lineNum">   31664 </span><span class="lineCov">        210 :             case OMP_CLAUSE_FROM:</span>
<span class="lineNum">   31665 </span><span class="lineCov">        210 :             case OMP_CLAUSE_TO:</span>
<span class="lineNum">   31666 </span>            :               while (cp_lexer_next_token_is (parser-&gt;lexer, CPP_DOT))
<span class="lineNum">   31667 </span>            :                 {
<span class="lineNum">   31668 </span>            :                   location_t loc
<span class="lineNum">   31669 </span><span class="lineCov">      23774 :                     = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;</span>
<span class="lineNum">   31670 </span>            :                   cp_id_kind idk = CP_ID_KIND_NONE;
<span class="lineNum">   31671 </span>            :                   cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   31672 </span>            :                   decl = convert_from_reference (decl);
<span class="lineNum">   31673 </span><span class="lineCov">      11887 :                   decl</span>
<span class="lineNum">   31674 </span><span class="lineCov">      11887 :                     = cp_parser_postfix_dot_deref_expression (parser, CPP_DOT,</span>
<span class="lineNum">   31675 </span>            :                                                               decl, false,
<span class="lineNum">   31676 </span>            :                                                               &amp;idk, loc);
<span class="lineNum">   31677 </span><span class="lineCov">      11866 :                 }</span>
<span class="lineNum">   31678 </span><span class="lineCov">      11860 :               /* FALLTHROUGH.  */</span>
<span class="lineNum">   31679 </span>            :             case OMP_CLAUSE_DEPEND:
<span class="lineNum">   31680 </span>            :             case OMP_CLAUSE_REDUCTION:
<span class="lineNum">   31681 </span><span class="lineCov">      11866 :               while (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_SQUARE))</span>
<span class="lineNum">   31682 </span><span class="lineCov">         15 :                 {</span>
<span class="lineNum">   31683 </span>            :                   tree low_bound = NULL_TREE, length = NULL_TREE;
<span class="lineNum">   31684 </span>            : 
<span class="lineNum">   31685 </span><span class="lineCov">      12076 :                   parser-&gt;colon_corrects_to_scope_p = false;</span>
<span class="lineNum">   31686 </span>            :                   cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   31687 </span><span class="lineCov">      12061 :                   if (!cp_lexer_next_token_is (parser-&gt;lexer, CPP_COLON))</span>
<span class="lineNum">   31688 </span>            :                     low_bound = cp_parser_expression (parser);
<span class="lineNum">   31689 </span><span class="lineCov">      11843 :                   if (!colon)</span>
<span class="lineNum">   31690 </span>            :                     parser-&gt;colon_corrects_to_scope_p
<span class="lineNum">   31691 </span><span class="lineCov">        142 :                       = saved_colon_corrects_to_scope_p;</span>
<span class="lineNum">   31692 </span>            :                   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_CLOSE_SQUARE))
<span class="lineNum">   31693 </span>            :                     length = integer_one_node;
<span class="lineNum">   31694 </span><span class="lineCov">        142 :                   else</span>
<span class="lineNum">   31695 </span>            :                     {
<span class="lineNum">   31696 </span><span class="lineCov">          3 :                       /* Look for `:'.  */</span>
<span class="lineNum">   31697 </span><span class="lineCov">          3 :                       if (!cp_parser_require (parser, CPP_COLON, RT_COLON))</span>
<span class="lineNum">   31698 </span><span class="lineCov">          3 :                         goto skip_comma;</span>
<span class="lineNum">   31699 </span>            :                       if (!cp_lexer_next_token_is (parser-&gt;lexer,
<span class="lineNum">   31700 </span>            :                                                    CPP_CLOSE_SQUARE))
<span class="lineNum">   31701 </span><span class="lineCov">       5994 :                         length = cp_parser_expression (parser);</span>
<span class="lineNum">   31702 </span><span class="lineCov">       5994 :                     }</span>
<span class="lineNum">   31703 </span><span class="lineCov">       5994 :                   /* Look for the closing `]'.  */</span>
<span class="lineNum">   31704 </span><span class="lineCov">       5994 :                   if (!cp_parser_require (parser, CPP_CLOSE_SQUARE,</span>
<span class="lineNum">   31705 </span>            :                                           RT_CLOSE_SQUARE))
<span class="lineNum">   31706 </span><span class="lineCov">        540 :                     goto skip_comma;</span>
<span class="lineNum">   31707 </span><span class="lineCov">       1080 : </span>
<span class="lineNum">   31708 </span><span class="lineCov">        540 :                   decl = tree_cons (low_bound, length, decl);</span>
<span class="lineNum">   31709 </span><span class="lineCov">        540 :                 }</span>
<span class="lineNum">   31710 </span><span class="lineCov">        540 :               break;</span>
<span class="lineNum">   31711 </span><span class="lineCov">        540 :             default:</span>
<span class="lineNum">   31712 </span><span class="lineCov">        540 :               break;</span>
<span class="lineNum">   31713 </span>            :             }
<span class="lineNum">   31714 </span>            : 
<span class="lineNum">   31715 </span>            :           tree u = build_omp_clause (token-&gt;location, kind);
<span class="lineNum">   31716 </span>            :           OMP_CLAUSE_DECL (u) = decl;
<span class="lineNum">   31717 </span><span class="lineCov">      10561 :           OMP_CLAUSE_CHAIN (u) = list;</span>
<span class="lineNum">   31718 </span><span class="lineCov">      10561 :           list = u;</span>
<span class="lineNum">   31719 </span><span class="lineCov">      10561 :         }</span>
<span class="lineNum">   31720 </span>            :       else
<span class="lineNum">   31721 </span><span class="lineCov">       3119 :         list = tree_cons (decl, NULL_TREE, list);</span>
<span class="lineNum">   31722 </span>            : 
<span class="lineNum">   31723 </span><span class="lineCov">       3119 :     get_comma:</span>
<span class="lineNum">   31724 </span><span class="lineCov">       3119 :       if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_COMMA))</span>
<span class="lineNum">   31725 </span><span class="lineCov">       3119 :         break;</span>
<span class="lineNum">   31726 </span><span class="lineCov">       2655 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   31727 </span><span class="lineCov">       3119 :     }</span>
<span class="lineNum">   31728 </span><span class="lineCov">       3119 : </span>
<span class="lineNum">   31729 </span><span class="lineCov">       3119 :   if (colon)</span>
<span class="lineNum">   31730 </span><span class="lineCov">       3119 :     parser-&gt;colon_corrects_to_scope_p = saved_colon_corrects_to_scope_p;</span>
<span class="lineNum">   31731 </span><span class="lineCov">        160 : </span>
<span class="lineNum">   31732 </span>            :   if (colon != NULL &amp;&amp; cp_lexer_next_token_is (parser-&gt;lexer, CPP_COLON))
<span class="lineNum">   31733 </span>            :     {
<span class="lineNum">   31734 </span>            :       *colon = true;
<span class="lineNum">   31735 </span><span class="lineCov">       2959 :       cp_parser_require (parser, CPP_COLON, RT_COLON);</span>
<span class="lineNum">   31736 </span>            :       return list;
<span class="lineNum">   31737 </span><span class="lineCov">       2959 :     }</span>
<span class="lineNum">   31738 </span>            : 
<span class="lineNum">   31739 </span><span class="lineCov">       2681 :   if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))</span>
<span class="lineNum">   31740 </span>            :     {
<span class="lineNum">   31741 </span>            :       int ending;
<span class="lineNum">   31742 </span><span class="lineCov">       3119 : </span>
<span class="lineNum">   31743 </span>            :       /* Try to resync to an unnested comma.  Copied from
<span class="lineNum">   31744 </span>            :          cp_parser_parenthesized_expression_list.  */
<span class="lineNum">   31745 </span>            :     skip_comma:
<span class="lineNum">   31746 </span><span class="lineCov">       3119 :       if (colon)</span>
<span class="lineNum">   31747 </span>            :         parser-&gt;colon_corrects_to_scope_p = saved_colon_corrects_to_scope_p;
<span class="lineNum">   31748 </span>            :       ending = cp_parser_skip_to_closing_parenthesis (parser,
<span class="lineNum">   31749 </span>            :                                                       /*recovering=*/true,
<span class="lineNum">   31750 </span>            :                                                       /*or_comma=*/true,
<span class="lineNum">   31751 </span>            :                                                       /*consume_paren=*/true);
<span class="lineNum">   31752 </span>            :       if (ending &lt; 0)
<span class="lineNum">   31753 </span><span class="lineCov">      11843 :         goto get_comma;</span>
<span class="lineNum">   31754 </span><span class="lineCov">      11843 :     }</span>
<span class="lineNum">   31755 </span><span class="lineCov">      11843 : </span>
<span class="lineNum">   31756 </span><span class="lineCov">      11843 :   return list;</span>
<span class="lineNum">   31757 </span>            : }
<span class="lineNum">   31758 </span>            : 
<span class="lineNum">   31759 </span><span class="lineCov">        218 : /* Similarly, but expect leading and trailing parenthesis.  This is a very</span>
<span class="lineNum">   31760 </span>            :    common case for omp clauses.  */
<a name="31761"><span class="lineNum">   31761 </span><span class="lineCov">      12079 : </span></a>
<span class="lineNum">   31762 </span><span class="lineCov">      12079 : static tree</span>
<span class="lineNum">   31763 </span>            : cp_parser_omp_var_list (cp_parser *parser, enum omp_clause_code kind, tree list)
<span class="lineNum">   31764 </span><span class="lineCov">       2125 : {</span>
<span class="lineNum">   31765 </span><span class="lineCov">       2125 :   if (cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))</span>
<span class="lineNum">   31766 </span>            :     return cp_parser_omp_var_list_no_open (parser, kind, list, NULL);
<span class="lineNum">   31767 </span><span class="lineCov">       9954 :   return list;</span>
<span class="lineNum">   31768 </span><span class="lineCov">        928 : }</span>
<span class="lineNum">   31769 </span>            : 
<span class="lineNum">   31770 </span><span class="lineCov">       9954 : /* OpenACC 2.0:</span>
<span class="lineNum">   31771 </span>            :    copy ( variable-list )
<span class="lineNum">   31772 </span><span class="lineCov">        767 :    copyin ( variable-list )</span>
<span class="lineNum">   31773 </span><span class="lineCov">        767 :    copyout ( variable-list )</span>
<span class="lineNum">   31774 </span><span class="lineCov">        767 :    create ( variable-list )</span>
<span class="lineNum">   31775 </span>            :    delete ( variable-list )
<span class="lineNum">   31776 </span>            :    present ( variable-list ) */
<a name="31777"><span class="lineNum">   31777 </span><span class="lineCov">       9187 : </span></a>
<span class="lineNum">   31778 </span>            : static tree
<span class="lineNum">   31779 </span><span class="lineCov">         87 : cp_parser_oacc_data_clause (cp_parser *parser, pragma_omp_clause c_kind,</span>
<span class="lineNum">   31780 </span>            :                             tree list)
<span class="lineNum">   31781 </span>            : {
<span class="lineNum">   31782 </span>            :   enum gomp_map_kind kind;
<span class="lineNum">   31783 </span><span class="lineCov">         66 :   switch (c_kind)</span>
<span class="lineNum">   31784 </span><span class="lineCov">         87 :     {</span>
<span class="lineNum">   31785 </span><span class="lineNoCov">          0 :     case PRAGMA_OACC_CLAUSE_COPY:</span>
<span class="lineNum">   31786 </span><span class="lineCov">         87 :       kind = GOMP_MAP_TOFROM;</span>
<span class="lineNum">   31787 </span>            :       break;
<span class="lineNum">   31788 </span>            :     case PRAGMA_OACC_CLAUSE_COPYIN:
<span class="lineNum">   31789 </span>            :       kind = GOMP_MAP_TO;
<span class="lineNum">   31790 </span><span class="lineCov">         87 :       break;</span>
<span class="lineNum">   31791 </span>            :     case PRAGMA_OACC_CLAUSE_COPYOUT:
<span class="lineNum">   31792 </span>            :       kind = GOMP_MAP_FROM;
<span class="lineNum">   31793 </span>            :       break;
<span class="lineNum">   31794 </span>            :     case PRAGMA_OACC_CLAUSE_CREATE:
<span class="lineNum">   31795 </span>            :       kind = GOMP_MAP_ALLOC;
<span class="lineNum">   31796 </span>            :       break;
<span class="lineNum">   31797 </span>            :     case PRAGMA_OACC_CLAUSE_DELETE:
<span class="lineNum">   31798 </span>            :       kind = GOMP_MAP_RELEASE;
<span class="lineNum">   31799 </span>            :       break;
<span class="lineNum">   31800 </span>            :     case PRAGMA_OACC_CLAUSE_DEVICE:
<span class="lineNum">   31801 </span><span class="lineCov">       6239 :       kind = GOMP_MAP_FORCE_TO;</span>
<span class="lineNum">   31802 </span>            :       break;
<span class="lineNum">   31803 </span><span class="lineCov">       6239 :     case PRAGMA_OACC_CLAUSE_DEVICE_RESIDENT:</span>
<span class="lineNum">   31804 </span><span class="lineCov">       6233 :       kind = GOMP_MAP_DEVICE_RESIDENT;</span>
<span class="lineNum">   31805 </span>            :       break;
<span class="lineNum">   31806 </span>            :     case PRAGMA_OACC_CLAUSE_HOST:
<span class="lineNum">   31807 </span>            :       kind = GOMP_MAP_FORCE_FROM;
<span class="lineNum">   31808 </span>            :       break;
<span class="lineNum">   31809 </span>            :     case PRAGMA_OACC_CLAUSE_LINK:
<span class="lineNum">   31810 </span>            :       kind = GOMP_MAP_LINK;
<span class="lineNum">   31811 </span>            :       break;
<span class="lineNum">   31812 </span>            :     case PRAGMA_OACC_CLAUSE_PRESENT:
<span class="lineNum">   31813 </span>            :       kind = GOMP_MAP_FORCE_PRESENT;
<span class="lineNum">   31814 </span>            :       break;
<span class="lineNum">   31815 </span>            :     default:
<span class="lineNum">   31816 </span>            :       gcc_unreachable ();
<span class="lineNum">   31817 </span><span class="lineCov">       2153 :     }</span>
<span class="lineNum">   31818 </span>            :   tree nl, c;
<span class="lineNum">   31819 </span>            :   nl = cp_parser_omp_var_list (parser, OMP_CLAUSE_MAP, list);
<span class="lineNum">   31820 </span><span class="lineCov">       2153 : </span>
<span class="lineNum">   31821 </span><span class="lineCov">       2153 :   for (c = nl; c != list; c = OMP_CLAUSE_CHAIN (c))</span>
<span class="lineNum">   31822 </span>            :     OMP_CLAUSE_SET_MAP_KIND (c, kind);
<span class="lineNum">   31823 </span>            : 
<span class="lineNum">   31824 </span>            :   return nl;
<span class="lineNum">   31825 </span>            : }
<span class="lineNum">   31826 </span><span class="lineCov">        425 : </span>
<span class="lineNum">   31827 </span><span class="lineCov">        425 : /* OpenACC 2.0:</span>
<span class="lineNum">   31828 </span><span class="lineCov">        425 :    deviceptr ( variable-list ) */</span>
<a name="31829"><span class="lineNum">   31829 </span><span class="lineCov">        392 : </span></a>
<span class="lineNum">   31830 </span><span class="lineCov">        392 : static tree</span>
<span class="lineNum">   31831 </span><span class="lineCov">        392 : cp_parser_oacc_data_clause_deviceptr (cp_parser *parser, tree list)</span>
<span class="lineNum">   31832 </span><span class="lineCov">        165 : {</span>
<span class="lineNum">   31833 </span><span class="lineCov">        165 :   location_t loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;</span>
<span class="lineNum">   31834 </span><span class="lineCov">        165 :   tree vars, t;</span>
<span class="lineNum">   31835 </span><span class="lineCov">         90 : </span>
<span class="lineNum">   31836 </span><span class="lineCov">         90 :   /* Can't use OMP_CLAUSE_MAP here (that is, can't use the generic</span>
<span class="lineNum">   31837 </span><span class="lineCov">         90 :      cp_parser_oacc_data_clause), as for PRAGMA_OACC_CLAUSE_DEVICEPTR,</span>
<span class="lineNum">   31838 </span><span class="lineCov">         43 :      variable-list must only allow for pointer variables.  */</span>
<span class="lineNum">   31839 </span><span class="lineCov">         43 :   vars = cp_parser_omp_var_list (parser, OMP_CLAUSE_ERROR, NULL);</span>
<span class="lineNum">   31840 </span><span class="lineCov">         43 :   for (t = vars; t; t = TREE_CHAIN (t))</span>
<span class="lineNum">   31841 </span><span class="lineCov">         19 :     {</span>
<span class="lineNum">   31842 </span><span class="lineCov">         19 :       tree v = TREE_PURPOSE (t);</span>
<span class="lineNum">   31843 </span><span class="lineCov">         19 :       tree u = build_omp_clause (loc, OMP_CLAUSE_MAP);</span>
<span class="lineNum">   31844 </span><span class="lineCov">        116 :       OMP_CLAUSE_SET_MAP_KIND (u, GOMP_MAP_FORCE_DEVICEPTR);</span>
<span class="lineNum">   31845 </span><span class="lineCov">        116 :       OMP_CLAUSE_DECL (u) = v;</span>
<span class="lineNum">   31846 </span><span class="lineCov">        116 :       OMP_CLAUSE_CHAIN (u) = list;</span>
<span class="lineNum">   31847 </span><span class="lineCov">         27 :       list = u;</span>
<span class="lineNum">   31848 </span><span class="lineCov">         27 :     }</span>
<span class="lineNum">   31849 </span><span class="lineCov">         27 : </span>
<span class="lineNum">   31850 </span><span class="lineCov">        156 :   return list;</span>
<span class="lineNum">   31851 </span><span class="lineCov">        156 : }</span>
<span class="lineNum">   31852 </span><span class="lineCov">        156 : </span>
<span class="lineNum">   31853 </span><span class="lineNoCov">          0 : /* OpenACC 2.5:</span>
<span class="lineNum">   31854 </span><span class="lineNoCov">          0 :    auto</span>
<span class="lineNum">   31855 </span>            :    finalize
<span class="lineNum">   31856 </span><span class="lineCov">       2153 :    independent</span>
<span class="lineNum">   31857 </span><span class="lineCov">       2153 :    nohost</span>
<span class="lineNum">   31858 </span>            :    seq */
<a name="31859"><span class="lineNum">   31859 </span><span class="lineCov">       4902 : </span></a>
<span class="lineNum">   31860 </span><span class="lineCov">       2749 : static tree</span>
<span class="lineNum">   31861 </span>            : cp_parser_oacc_simple_clause (cp_parser * /* parser  */,
<span class="lineNum">   31862 </span><span class="lineCov">       2153 :                               enum omp_clause_code code,</span>
<span class="lineNum">   31863 </span>            :                               tree list, location_t location)
<span class="lineNum">   31864 </span>            : {
<span class="lineNum">   31865 </span>            :   check_no_duplicate_clause (list, code, omp_clause_code_name[code], location);
<span class="lineNum">   31866 </span>            :   tree c = build_omp_clause (location, code);
<span class="lineNum">   31867 </span>            :   OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   31868 </span>            :   return c;
<span class="lineNum">   31869 </span><span class="lineCov">         71 : }</span>
<span class="lineNum">   31870 </span>            : 
<span class="lineNum">   31871 </span><span class="lineCov">        142 :  /* OpenACC:</span>
<span class="lineNum">   31872 </span><span class="lineCov">         71 :    num_gangs ( expression )</span>
<span class="lineNum">   31873 </span>            :    num_workers ( expression )
<span class="lineNum">   31874 </span>            :    vector_length ( expression )  */
<a name="31875"><span class="lineNum">   31875 </span>            : </a>
<span class="lineNum">   31876 </span>            : static tree
<span class="lineNum">   31877 </span><span class="lineCov">         71 : cp_parser_oacc_single_int_clause (cp_parser *parser, omp_clause_code code,</span>
<span class="lineNum">   31878 </span><span class="lineCov">        142 :                                   const char *str, tree list)</span>
<span class="lineNum">   31879 </span>            : {
<span class="lineNum">   31880 </span><span class="lineCov">         71 :   location_t loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;</span>
<span class="lineNum">   31881 </span><span class="lineCov">         71 : </span>
<span class="lineNum">   31882 </span><span class="lineCov">         71 :   matching_parens parens;</span>
<span class="lineNum">   31883 </span><span class="lineCov">         71 :   if (!parens.require_open (parser))</span>
<span class="lineNum">   31884 </span><span class="lineCov">         71 :     return list;</span>
<span class="lineNum">   31885 </span><span class="lineCov">         71 : </span>
<span class="lineNum">   31886 </span>            :   tree t = cp_parser_assignment_expression (parser, NULL, false, false);
<span class="lineNum">   31887 </span>            : 
<span class="lineNum">   31888 </span><span class="lineCov">         71 :   if (t == error_mark_node</span>
<span class="lineNum">   31889 </span>            :       || !parens.require_close (parser))
<span class="lineNum">   31890 </span>            :     {
<span class="lineNum">   31891 </span>            :       cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,
<span class="lineNum">   31892 </span>            :                                              /*or_comma=*/false,
<span class="lineNum">   31893 </span>            :                                              /*consume_paren=*/true);
<span class="lineNum">   31894 </span>            :       return list;
<span class="lineNum">   31895 </span>            :     }
<span class="lineNum">   31896 </span>            : 
<span class="lineNum">   31897 </span>            :   check_no_duplicate_clause (list, code, str, loc);
<span class="lineNum">   31898 </span>            : 
<span class="lineNum">   31899 </span><span class="lineCov">        592 :   tree c = build_omp_clause (loc, code);</span>
<span class="lineNum">   31900 </span>            :   OMP_CLAUSE_OPERAND (c, 0) = t;
<span class="lineNum">   31901 </span>            :   OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   31902 </span>            :   return c;
<span class="lineNum">   31903 </span><span class="lineCov">        592 : }</span>
<span class="lineNum">   31904 </span><span class="lineCov">        592 : </span>
<span class="lineNum">   31905 </span><span class="lineCov">        592 : /* OpenACC:</span>
<span class="lineNum">   31906 </span><span class="lineCov">        592 : </span>
<span class="lineNum">   31907 </span>            :     gang [( gang-arg-list )]
<span class="lineNum">   31908 </span>            :     worker [( [num:] int-expr )]
<span class="lineNum">   31909 </span>            :     vector [( [length:] int-expr )]
<span class="lineNum">   31910 </span>            : 
<span class="lineNum">   31911 </span>            :   where gang-arg is one of:
<span class="lineNum">   31912 </span>            : 
<span class="lineNum">   31913 </span>            :     [num:] int-expr
<span class="lineNum">   31914 </span>            :     static: size-expr
<span class="lineNum">   31915 </span><span class="lineCov">        993 : </span>
<span class="lineNum">   31916 </span>            :   and size-expr may be:
<span class="lineNum">   31917 </span>            : 
<span class="lineNum">   31918 </span><span class="lineCov">       1986 :     *</span>
<span class="lineNum">   31919 </span>            :     int-expr
<span class="lineNum">   31920 </span><span class="lineCov">       1986 : */</span>
<a name="31921"><span class="lineNum">   31921 </span><span class="lineCov">        993 : </span></a>
<span class="lineNum">   31922 </span>            : static tree
<span class="lineNum">   31923 </span>            : cp_parser_oacc_shape_clause (cp_parser *parser, omp_clause_code kind,
<span class="lineNum">   31924 </span><span class="lineCov">        975 :                              const char *str, tree list)</span>
<span class="lineNum">   31925 </span>            : {
<span class="lineNum">   31926 </span><span class="lineCov">        975 :   const char *id = &quot;num&quot;;</span>
<span class="lineNum">   31927 </span><span class="lineCov">        975 :   cp_lexer *lexer = parser-&gt;lexer;</span>
<span class="lineNum">   31928 </span>            :   tree ops[2] = { NULL_TREE, NULL_TREE }, c;
<span class="lineNum">   31929 </span><span class="lineCov">        360 :   location_t loc = cp_lexer_peek_token (lexer)-&gt;location;</span>
<span class="lineNum">   31930 </span>            : 
<span class="lineNum">   31931 </span>            :   if (kind == OMP_CLAUSE_VECTOR)
<span class="lineNum">   31932 </span><span class="lineCov">        180 :     id = &quot;length&quot;;</span>
<span class="lineNum">   31933 </span>            : 
<span class="lineNum">   31934 </span>            :   if (cp_lexer_next_token_is (lexer, CPP_OPEN_PAREN))
<span class="lineNum">   31935 </span><span class="lineCov">        795 :     {</span>
<span class="lineNum">   31936 </span>            :       matching_parens parens;
<span class="lineNum">   31937 </span><span class="lineCov">        795 :       parens.consume_open (parser);</span>
<span class="lineNum">   31938 </span><span class="lineCov">        795 : </span>
<span class="lineNum">   31939 </span><span class="lineCov">        795 :       do</span>
<span class="lineNum">   31940 </span><span class="lineCov">        795 :         {</span>
<span class="lineNum">   31941 </span>            :           cp_token *next = cp_lexer_peek_token (lexer);
<span class="lineNum">   31942 </span>            :           int idx = 0;
<span class="lineNum">   31943 </span>            : 
<span class="lineNum">   31944 </span>            :           /* Gang static argument.  */
<span class="lineNum">   31945 </span>            :           if (kind == OMP_CLAUSE_GANG
<span class="lineNum">   31946 </span>            :               &amp;&amp; cp_lexer_next_token_is_keyword (lexer, RID_STATIC))
<span class="lineNum">   31947 </span>            :             {
<span class="lineNum">   31948 </span>            :               cp_lexer_consume_token (lexer);
<span class="lineNum">   31949 </span>            : 
<span class="lineNum">   31950 </span>            :               if (!cp_parser_require (parser, CPP_COLON, RT_COLON))
<span class="lineNum">   31951 </span>            :                 goto cleanup_error;
<span class="lineNum">   31952 </span>            : 
<span class="lineNum">   31953 </span>            :               idx = 1;
<span class="lineNum">   31954 </span>            :               if (ops[idx] != NULL)
<span class="lineNum">   31955 </span>            :                 {
<span class="lineNum">   31956 </span>            :                   cp_parser_error (parser, &quot;too many %&lt;static%&gt; arguments&quot;);
<span class="lineNum">   31957 </span>            :                   goto cleanup_error;
<span class="lineNum">   31958 </span>            :                 }
<span class="lineNum">   31959 </span>            : 
<span class="lineNum">   31960 </span>            :               /* Check for the '*' argument.  */
<span class="lineNum">   31961 </span><span class="lineCov">       1896 :               if (cp_lexer_next_token_is (lexer, CPP_MULT)</span>
<span class="lineNum">   31962 </span>            :                   &amp;&amp; (cp_lexer_nth_token_is (parser-&gt;lexer, 2, CPP_COMMA)
<span class="lineNum">   31963 </span>            :                       || cp_lexer_nth_token_is (parser-&gt;lexer, 2,
<span class="lineNum">   31964 </span><span class="lineCov">       1896 :                                                 CPP_CLOSE_PAREN)))</span>
<span class="lineNum">   31965 </span><span class="lineCov">       1896 :                 {</span>
<span class="lineNum">   31966 </span><span class="lineCov">       1896 :                   cp_lexer_consume_token (lexer);</span>
<span class="lineNum">   31967 </span><span class="lineCov">       3792 :                   ops[idx] = integer_minus_one_node;</span>
<span class="lineNum">   31968 </span>            : 
<span class="lineNum">   31969 </span><span class="lineCov">       1896 :                   if (cp_lexer_next_token_is (lexer, CPP_COMMA))</span>
<span class="lineNum">   31970 </span><span class="lineCov">        620 :                     {</span>
<span class="lineNum">   31971 </span>            :                       cp_lexer_consume_token (lexer);
<span class="lineNum">   31972 </span><span class="lineCov">       1896 :                       continue;</span>
<span class="lineNum">   31973 </span>            :                     }
<span class="lineNum">   31974 </span><span class="lineCov">        792 :                   else break;</span>
<span class="lineNum">   31975 </span><span class="lineCov">        396 :                 }</span>
<span class="lineNum">   31976 </span>            :             }
<span class="lineNum">   31977 </span><span class="lineCov">        441 :           /* Worker num: argument and vector length: arguments.  */</span>
<span class="lineNum">   31978 </span>            :           else if (cp_lexer_next_token_is (lexer, CPP_NAME)
<span class="lineNum">   31979 </span><span class="lineCov">        882 :                    &amp;&amp; id_equal (next-&gt;u.value, id)</span>
<span class="lineNum">   31980 </span><span class="lineCov">        441 :                    &amp;&amp; cp_lexer_nth_token_is (lexer, 2, CPP_COLON))</span>
<span class="lineNum">   31981 </span>            :             {
<span class="lineNum">   31982 </span>            :               cp_lexer_consume_token (lexer);  /* id  */
<span class="lineNum">   31983 </span><span class="lineCov">        441 :               cp_lexer_consume_token (lexer);  /* ':'  */</span>
<span class="lineNum">   31984 </span><span class="lineCov">        441 :             }</span>
<span class="lineNum">   31985 </span>            : 
<span class="lineNum">   31986 </span><span class="lineCov">        114 :           /* Now collect the actual argument.  */</span>
<span class="lineNum">   31987 </span>            :           if (ops[idx] != NULL_TREE)
<span class="lineNum">   31988 </span><span class="lineCov">        114 :             {</span>
<span class="lineNum">   31989 </span><span class="lineCov">         57 :               cp_parser_error (parser, &quot;unexpected argument&quot;);</span>
<span class="lineNum">   31990 </span>            :               goto cleanup_error;
<span class="lineNum">   31991 </span><span class="lineCov">        114 :             }</span>
<span class="lineNum">   31992 </span><span class="lineCov">        114 : </span>
<span class="lineNum">   31993 </span>            :           tree expr = cp_parser_assignment_expression (parser, NULL, false,
<span class="lineNum">   31994 </span><span class="lineNoCov">          0 :                                                        false);</span>
<span class="lineNum">   31995 </span><span class="lineNoCov">          0 :           if (expr == error_mark_node)</span>
<span class="lineNum">   31996 </span>            :             goto cleanup_error;
<span class="lineNum">   31997 </span>            : 
<span class="lineNum">   31998 </span>            :           mark_exp_read (expr);
<span class="lineNum">   31999 </span><span class="lineCov">        228 :           ops[idx] = expr;</span>
<span class="lineNum">   32000 </span><span class="lineCov">        114 : </span>
<span class="lineNum">   32001 </span><span class="lineCov">         47 :           if (kind == OMP_CLAUSE_GANG</span>
<span class="lineNum">   32002 </span>            :               &amp;&amp; cp_lexer_next_token_is (lexer, CPP_COMMA))
<span class="lineNum">   32003 </span>            :             {
<span class="lineNum">   32004 </span><span class="lineCov">         44 :               cp_lexer_consume_token (lexer);</span>
<span class="lineNum">   32005 </span><span class="lineCov">         44 :               continue;</span>
<span class="lineNum">   32006 </span>            :             }
<span class="lineNum">   32007 </span><span class="lineCov">         44 :           break;</span>
<span class="lineNum">   32008 </span>            :         }
<span class="lineNum">   32009 </span><span class="lineCov">          3 :       while (1);</span>
<span class="lineNum">   32010 </span><span class="lineCov">          3 : </span>
<span class="lineNum">   32011 </span>            :       if (!parens.require_close (parser))
<span class="lineNum">   32012 </span>            :         goto cleanup_error;
<span class="lineNum">   32013 </span>            :     }
<span class="lineNum">   32014 </span>            : 
<span class="lineNum">   32015 </span>            :   check_no_duplicate_clause (list, kind, str, loc);
<span class="lineNum">   32016 </span><span class="lineCov">        654 : </span>
<span class="lineNum">   32017 </span><span class="lineCov">        219 :   c = build_omp_clause (loc, kind);</span>
<span class="lineNum">   32018 </span><span class="lineCov">        522 : </span>
<span class="lineNum">   32019 </span>            :   if (ops[1])
<span class="lineNum">   32020 </span><span class="lineCov">        177 :     OMP_CLAUSE_OPERAND (c, 1) = ops[1];</span>
<span class="lineNum">   32021 </span><span class="lineCov">        177 : </span>
<span class="lineNum">   32022 </span>            :   OMP_CLAUSE_OPERAND (c, 0) = ops[0];
<span class="lineNum">   32023 </span>            :   OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   32024 </span>            : 
<span class="lineNum">   32025 </span><span class="lineCov">        397 :   return c;</span>
<span class="lineNum">   32026 </span>            : 
<span class="lineNum">   32027 </span><span class="lineCov">         15 :  cleanup_error:</span>
<span class="lineNum">   32028 </span><span class="lineCov">         15 :   cp_parser_skip_to_closing_parenthesis (parser, false, false, true);</span>
<span class="lineNum">   32029 </span>            :   return list;
<span class="lineNum">   32030 </span>            : }
<span class="lineNum">   32031 </span><span class="lineCov">        764 : </span>
<span class="lineNum">   32032 </span><span class="lineCov">        382 : /* OpenACC 2.0:</span>
<span class="lineNum">   32033 </span><span class="lineCov">        382 :    tile ( size-expr-list ) */</span>
<a name="32034"><span class="lineNum">   32034 </span>            : </a>
<span class="lineNum">   32035 </span>            : static tree
<span class="lineNum">   32036 </span><span class="lineCov">        355 : cp_parser_oacc_clause_tile (cp_parser *parser, location_t clause_loc, tree list)</span>
<span class="lineNum">   32037 </span><span class="lineCov">        355 : {</span>
<span class="lineNum">   32038 </span>            :   tree c, expr = error_mark_node;
<span class="lineNum">   32039 </span><span class="lineCov">        355 :   tree tile = NULL_TREE;</span>
<span class="lineNum">   32040 </span><span class="lineCov">        355 : </span>
<span class="lineNum">   32041 </span>            :   /* Collapse and tile are mutually exclusive.  (The spec doesn't say
<span class="lineNum">   32042 </span><span class="lineCov">         42 :      so, but the spec authors never considered such a case and have</span>
<span class="lineNum">   32043 </span><span class="lineCov">         42 :      differing opinions on what it might mean, including 'not</span>
<span class="lineNum">   32044 </span>            :      allowed'.)  */
<span class="lineNum">   32045 </span>            :   check_no_duplicate_clause (list, OMP_CLAUSE_TILE, &quot;tile&quot;, clause_loc);
<span class="lineNum">   32046 </span>            :   check_no_duplicate_clause (list, OMP_CLAUSE_COLLAPSE, &quot;collapse&quot;,
<span class="lineNum">   32047 </span>            :                              clause_loc);
<span class="lineNum">   32048 </span>            : 
<span class="lineNum">   32049 </span><span class="lineCov">        354 :   if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))</span>
<span class="lineNum">   32050 </span>            :     return list;
<span class="lineNum">   32051 </span>            : 
<span class="lineNum">   32052 </span>            :   do
<span class="lineNum">   32053 </span><span class="lineCov">       1839 :     {</span>
<span class="lineNum">   32054 </span>            :       if (tile &amp;&amp; !cp_parser_require (parser, CPP_COMMA, RT_COMMA))
<span class="lineNum">   32055 </span><span class="lineCov">       1839 :         return list;</span>
<span class="lineNum">   32056 </span>            :       
<span class="lineNum">   32057 </span><span class="lineCov">       1839 :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_MULT)</span>
<span class="lineNum">   32058 </span><span class="lineCov">        111 :           &amp;&amp; (cp_lexer_nth_token_is (parser-&gt;lexer, 2, CPP_COMMA)</span>
<span class="lineNum">   32059 </span>            :               || cp_lexer_nth_token_is (parser-&gt;lexer, 2, CPP_CLOSE_PAREN)))
<span class="lineNum">   32060 </span><span class="lineCov">       1839 :         {</span>
<span class="lineNum">   32061 </span><span class="lineCov">       1839 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   32062 </span>            :           expr = integer_zero_node;
<span class="lineNum">   32063 </span><span class="lineCov">       1839 :         }</span>
<span class="lineNum">   32064 </span>            :       else
<span class="lineNum">   32065 </span><span class="lineCov">         57 :         expr = cp_parser_constant_expression (parser);</span>
<span class="lineNum">   32066 </span><span class="lineCov">        114 : </span>
<span class="lineNum">   32067 </span><span class="lineCov">         57 :       tile = tree_cons (NULL_TREE, expr, tile);</span>
<span class="lineNum">   32068 </span>            :     }
<span class="lineNum">   32069 </span>            :   while (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_CLOSE_PAREN));
<span class="lineNum">   32070 </span>            : 
<span class="lineNum">   32071 </span>            :   /* Consume the trailing ')'.  */
<span class="lineNum">   32072 </span>            :   cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   32073 </span>            : 
<span class="lineNum">   32074 </span><span class="lineCov">        311 :   c = build_omp_clause (clause_loc, OMP_CLAUSE_TILE);</span>
<span class="lineNum">   32075 </span>            :   tile = nreverse (tile);
<span class="lineNum">   32076 </span><span class="lineCov">        311 :   OMP_CLAUSE_TILE_LIST (c) = tile;</span>
<span class="lineNum">   32077 </span><span class="lineCov">        311 :   OMP_CLAUSE_CHAIN (c) = list;</span>
<span class="lineNum">   32078 </span>            :   return c;
<span class="lineNum">   32079 </span>            : }
<span class="lineNum">   32080 </span>            : 
<span class="lineNum">   32081 </span>            : /* OpenACC 2.0
<span class="lineNum">   32082 </span>            :    Parse wait clause or directive parameters.  */
<a name="32083"><span class="lineNum">   32083 </span><span class="lineCov">        311 : </span></a>
<span class="lineNum">   32084 </span><span class="lineCov">        311 : static tree</span>
<span class="lineNum">   32085 </span>            : cp_parser_oacc_wait_list (cp_parser *parser, location_t clause_loc, tree list)
<span class="lineNum">   32086 </span>            : {
<span class="lineNum">   32087 </span><span class="lineCov">        311 :   vec&lt;tree, va_gc&gt; *args;</span>
<span class="lineNum">   32088 </span>            :   tree t, args_tree;
<span class="lineNum">   32089 </span>            : 
<span class="lineNum">   32090 </span><span class="lineCov">        407 :   args = cp_parser_parenthesized_expression_list (parser, non_attr,</span>
<span class="lineNum">   32091 </span>            :                                                   /*cast_p=*/false,
<span class="lineNum">   32092 </span><span class="lineCov">        407 :                                                   /*allow_expansion_p=*/true,</span>
<span class="lineNum">   32093 </span>            :                                                   /*non_constant_p=*/NULL);
<span class="lineNum">   32094 </span>            : 
<span class="lineNum">   32095 </span><span class="lineCov">        814 :   if (args == NULL || args-&gt;length () == 0)</span>
<span class="lineNum">   32096 </span><span class="lineCov">        407 :     {</span>
<span class="lineNum">   32097 </span><span class="lineCov">        143 :       cp_parser_error (parser, &quot;expected integer expression before ')'&quot;);</span>
<span class="lineNum">   32098 </span>            :       if (args != NULL)
<span class="lineNum">   32099 </span><span class="lineCov">        160 :         release_tree_vector (args);</span>
<span class="lineNum">   32100 </span><span class="lineCov">        160 :       return list;</span>
<span class="lineNum">   32101 </span>            :     }
<span class="lineNum">   32102 </span>            : 
<span class="lineNum">   32103 </span><span class="lineCov">        247 :   args_tree = build_tree_list_vec (args);</span>
<span class="lineNum">   32104 </span>            : 
<span class="lineNum">   32105 </span><span class="lineCov">        407 :   release_tree_vector (args);</span>
<span class="lineNum">   32106 </span>            : 
<span class="lineNum">   32107 </span><span class="lineCov">        407 :   for (t = args_tree; t; t = TREE_CHAIN (t))</span>
<span class="lineNum">   32108 </span>            :     {
<span class="lineNum">   32109 </span>            :       tree targ = TREE_VALUE (t);
<span class="lineNum">   32110 </span><span class="lineCov">        296 : </span>
<span class="lineNum">   32111 </span>            :       if (targ != error_mark_node)
<span class="lineNum">   32112 </span><span class="lineCov">        296 :         {</span>
<span class="lineNum">   32113 </span><span class="lineCov">        296 :           if (!INTEGRAL_TYPE_P (TREE_TYPE (targ)))</span>
<span class="lineNum">   32114 </span><span class="lineCov">        296 :             error (&quot;%&lt;wait%&gt; expression must be integral&quot;);</span>
<span class="lineNum">   32115 </span><span class="lineCov">        296 :           else</span>
<span class="lineNum">   32116 </span><span class="lineCov">        296 :             {</span>
<span class="lineNum">   32117 </span>            :               tree c = build_omp_clause (clause_loc, OMP_CLAUSE_WAIT);
<span class="lineNum">   32118 </span>            : 
<span class="lineNum">   32119 </span>            :               targ = mark_rvalue_use (targ);
<span class="lineNum">   32120 </span>            :               OMP_CLAUSE_DECL (c) = targ;
<span class="lineNum">   32121 </span>            :               OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   32122 </span>            :               list = c;
<span class="lineNum">   32123 </span><span class="lineCov">        135 :             }</span>
<span class="lineNum">   32124 </span>            :         }
<span class="lineNum">   32125 </span><span class="lineCov">        135 :     }</span>
<span class="lineNum">   32126 </span><span class="lineCov">        135 : </span>
<span class="lineNum">   32127 </span>            :   return list;
<span class="lineNum">   32128 </span><span class="lineCov">        135 : }</span>
<span class="lineNum">   32129 </span>            : 
<span class="lineNum">   32130 </span>            : /* OpenACC:
<span class="lineNum">   32131 </span>            :    wait ( int-expr-list ) */
<a name="32132"><span class="lineNum">   32132 </span>            : </a>
<span class="lineNum">   32133 </span><span class="lineCov">        135 : static tree</span>
<span class="lineNum">   32134 </span>            : cp_parser_oacc_clause_wait (cp_parser *parser, tree list)
<span class="lineNum">   32135 </span><span class="lineCov">          9 : {</span>
<span class="lineNum">   32136 </span><span class="lineCov">          9 :   location_t location = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;</span>
<span class="lineNum">   32137 </span><span class="lineCov">          3 : </span>
<span class="lineNum">   32138 </span><span class="lineCov">          9 :   if (cp_lexer_peek_token (parser-&gt;lexer)-&gt;type != CPP_OPEN_PAREN)</span>
<span class="lineNum">   32139 </span>            :     return list;
<span class="lineNum">   32140 </span>            : 
<span class="lineNum">   32141 </span><span class="lineCov">        126 :   list = cp_parser_oacc_wait_list (parser, location, list);</span>
<span class="lineNum">   32142 </span>            : 
<span class="lineNum">   32143 </span><span class="lineCov">        126 :   return list;</span>
<span class="lineNum">   32144 </span>            : }
<span class="lineNum">   32145 </span><span class="lineCov">        330 : </span>
<span class="lineNum">   32146 </span>            : /* OpenMP 3.0:
<span class="lineNum">   32147 </span><span class="lineCov">        204 :    collapse ( constant-expression ) */</span>
<a name="32148"><span class="lineNum">   32148 </span>            : </a>
<span class="lineNum">   32149 </span><span class="lineCov">        204 : static tree</span>
<span class="lineNum">   32150 </span>            : cp_parser_omp_clause_collapse (cp_parser *parser, tree list, location_t location)
<span class="lineNum">   32151 </span><span class="lineCov">        168 : {</span>
<span class="lineNum">   32152 </span><span class="lineCov">         18 :   tree c, num;</span>
<span class="lineNum">   32153 </span>            :   location_t loc;
<span class="lineNum">   32154 </span>            :   HOST_WIDE_INT n;
<span class="lineNum">   32155 </span><span class="lineCov">        150 : </span>
<span class="lineNum">   32156 </span>            :   loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">   32157 </span><span class="lineCov">        150 :   matching_parens parens;</span>
<span class="lineNum">   32158 </span><span class="lineCov">        150 :   if (!parens.require_open (parser))</span>
<span class="lineNum">   32159 </span><span class="lineCov">        150 :     return list;</span>
<span class="lineNum">   32160 </span><span class="lineCov">        150 : </span>
<span class="lineNum">   32161 </span>            :   num = cp_parser_constant_expression (parser);
<span class="lineNum">   32162 </span>            : 
<span class="lineNum">   32163 </span>            :   if (!parens.require_close (parser))
<span class="lineNum">   32164 </span>            :     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,
<span class="lineNum">   32165 </span>            :                                            /*or_comma=*/false,
<span class="lineNum">   32166 </span>            :                                            /*consume_paren=*/true);
<span class="lineNum">   32167 </span>            : 
<span class="lineNum">   32168 </span>            :   if (num == error_mark_node)
<span class="lineNum">   32169 </span>            :     return list;
<span class="lineNum">   32170 </span>            :   num = fold_non_dependent_expr (num);
<span class="lineNum">   32171 </span>            :   if (!tree_fits_shwi_p (num)
<span class="lineNum">   32172 </span><span class="lineNoCov">          0 :       || !INTEGRAL_TYPE_P (TREE_TYPE (num))</span>
<span class="lineNum">   32173 </span>            :       || (n = tree_to_shwi (num)) &lt;= 0
<span class="lineNum">   32174 </span><span class="lineCov">        208 :       || (int) n != n)</span>
<span class="lineNum">   32175 </span>            :     {
<span class="lineNum">   32176 </span><span class="lineNoCov">          0 :       error_at (loc, &quot;collapse argument needs positive constant integer expression&quot;);</span>
<span class="lineNum">   32177 </span>            :       return list;
<span class="lineNum">   32178 </span>            :     }
<span class="lineNum">   32179 </span><span class="lineCov">         74 : </span>
<span class="lineNum">   32180 </span>            :   check_no_duplicate_clause (list, OMP_CLAUSE_COLLAPSE, &quot;collapse&quot;, location);
<span class="lineNum">   32181 </span><span class="lineCov">         74 :   check_no_duplicate_clause (list, OMP_CLAUSE_TILE, &quot;tile&quot;, location);</span>
<span class="lineNum">   32182 </span>            :   c = build_omp_clause (loc, OMP_CLAUSE_COLLAPSE);
<span class="lineNum">   32183 </span>            :   OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   32184 </span>            :   OMP_CLAUSE_COLLAPSE_EXPR (c) = num;
<span class="lineNum">   32185 </span>            : 
<span class="lineNum">   32186 </span>            :   return c;
<span class="lineNum">   32187 </span>            : }
<span class="lineNum">   32188 </span><span class="lineCov">       1441 : </span>
<span class="lineNum">   32189 </span>            : /* OpenMP 2.5:
<span class="lineNum">   32190 </span><span class="lineCov">       1441 :    default ( none | shared )</span>
<span class="lineNum">   32191 </span><span class="lineCov">       1441 : </span>
<span class="lineNum">   32192 </span><span class="lineCov">       1441 :    OpenACC:</span>
<span class="lineNum">   32193 </span>            :    default ( none | present ) */
<a name="32194"><span class="lineNum">   32194 </span><span class="lineCov">       2882 : </span></a>
<span class="lineNum">   32195 </span><span class="lineCov">       2882 : static tree</span>
<span class="lineNum">   32196 </span><span class="lineCov">       1441 : cp_parser_omp_clause_default (cp_parser *parser, tree list,</span>
<span class="lineNum">   32197 </span>            :                               location_t location, bool is_oacc)
<span class="lineNum">   32198 </span>            : {
<span class="lineNum">   32199 </span><span class="lineCov">       1441 :   enum omp_clause_default_kind kind = OMP_CLAUSE_DEFAULT_UNSPECIFIED;</span>
<span class="lineNum">   32200 </span>            :   tree c;
<span class="lineNum">   32201 </span><span class="lineCov">       1441 : </span>
<span class="lineNum">   32202 </span><span class="lineNoCov">          0 :   matching_parens parens;</span>
<span class="lineNum">   32203 </span>            :   if (!parens.require_open (parser))
<span class="lineNum">   32204 </span>            :     return list;
<span class="lineNum">   32205 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))
<span class="lineNum">   32206 </span><span class="lineCov">       1441 :     {</span>
<span class="lineNum">   32207 </span>            :       tree id = cp_lexer_peek_token (parser-&gt;lexer)-&gt;u.value;
<span class="lineNum">   32208 </span><span class="lineCov">       1441 :       const char *p = IDENTIFIER_POINTER (id);</span>
<span class="lineNum">   32209 </span><span class="lineCov">       1441 : </span>
<span class="lineNum">   32210 </span><span class="lineCov">       1438 :       switch (p[0])</span>
<span class="lineNum">   32211 </span><span class="lineCov">       1438 :         {</span>
<span class="lineNum">   32212 </span><span class="lineCov">       2879 :         case 'n':</span>
<span class="lineNum">   32213 </span>            :           if (strcmp (&quot;none&quot;, p) != 0)
<span class="lineNum">   32214 </span><span class="lineCov">          3 :             goto invalid_kind;</span>
<span class="lineNum">   32215 </span><span class="lineCov">          3 :           kind = OMP_CLAUSE_DEFAULT_NONE;</span>
<span class="lineNum">   32216 </span>            :           break;
<span class="lineNum">   32217 </span>            : 
<span class="lineNum">   32218 </span><span class="lineCov">       1438 :         case 'p':</span>
<span class="lineNum">   32219 </span><span class="lineCov">       1438 :           if (strcmp (&quot;present&quot;, p) != 0 || !is_oacc)</span>
<span class="lineNum">   32220 </span><span class="lineCov">       1438 :             goto invalid_kind;</span>
<span class="lineNum">   32221 </span><span class="lineCov">       1438 :           kind = OMP_CLAUSE_DEFAULT_PRESENT;</span>
<span class="lineNum">   32222 </span><span class="lineCov">       1438 :           break;</span>
<span class="lineNum">   32223 </span>            : 
<span class="lineNum">   32224 </span><span class="lineCov">       1438 :         case 's':</span>
<span class="lineNum">   32225 </span>            :           if (strcmp (&quot;shared&quot;, p) != 0 || is_oacc)
<span class="lineNum">   32226 </span>            :             goto invalid_kind;
<span class="lineNum">   32227 </span>            :           kind = OMP_CLAUSE_DEFAULT_SHARED;
<span class="lineNum">   32228 </span>            :           break;
<span class="lineNum">   32229 </span>            : 
<span class="lineNum">   32230 </span>            :         default:
<span class="lineNum">   32231 </span>            :           goto invalid_kind;
<span class="lineNum">   32232 </span>            :         }
<span class="lineNum">   32233 </span>            : 
<span class="lineNum">   32234 </span><span class="lineCov">        379 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   32235 </span>            :     }
<span class="lineNum">   32236 </span>            :   else
<span class="lineNum">   32237 </span><span class="lineCov">        379 :     {</span>
<span class="lineNum">   32238 </span><span class="lineCov">        379 :     invalid_kind:</span>
<span class="lineNum">   32239 </span>            :       if (is_oacc)
<span class="lineNum">   32240 </span><span class="lineCov">        758 :         cp_parser_error (parser, &quot;expected %&lt;none%&gt; or %&lt;present%&gt;&quot;);</span>
<span class="lineNum">   32241 </span><span class="lineCov">        379 :       else</span>
<span class="lineNum">   32242 </span>            :         cp_parser_error (parser, &quot;expected %&lt;none%&gt; or %&lt;shared%&gt;&quot;);
<span class="lineNum">   32243 </span><span class="lineCov">        373 :     }</span>
<span class="lineNum">   32244 </span>            : 
<span class="lineNum">   32245 </span><span class="lineCov">        686 :   if (kind == OMP_CLAUSE_DEFAULT_UNSPECIFIED</span>
<span class="lineNum">   32246 </span><span class="lineCov">        343 :       || !parens.require_close (parser))</span>
<span class="lineNum">   32247 </span>            :     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,
<span class="lineNum">   32248 </span><span class="lineCov">        343 :                                            /*or_comma=*/false,</span>
<span class="lineNum">   32249 </span>            :                                            /*consume_paren=*/true);
<span class="lineNum">   32250 </span><span class="lineCov">        158 : </span>
<span class="lineNum">   32251 </span><span class="lineCov">        158 :   if (kind == OMP_CLAUSE_DEFAULT_UNSPECIFIED)</span>
<span class="lineNum">   32252 </span>            :     return list;
<span class="lineNum">   32253 </span>            : 
<span class="lineNum">   32254 </span>            :   check_no_duplicate_clause (list, OMP_CLAUSE_DEFAULT, &quot;default&quot;, location);
<span class="lineNum">   32255 </span>            :   c = build_omp_clause (location, OMP_CLAUSE_DEFAULT);
<span class="lineNum">   32256 </span><span class="lineCov">         21 :   OMP_CLAUSE_CHAIN (c) = list;</span>
<span class="lineNum">   32257 </span><span class="lineCov">         21 :   OMP_CLAUSE_DEFAULT_KIND (c) = kind;</span>
<span class="lineNum">   32258 </span>            : 
<span class="lineNum">   32259 </span>            :   return c;
<span class="lineNum">   32260 </span>            : }
<span class="lineNum">   32261 </span>            : 
<span class="lineNum">   32262 </span><span class="lineCov">        158 : /* OpenMP 3.1:</span>
<span class="lineNum">   32263 </span><span class="lineCov">        158 :    final ( expression ) */</span>
<a name="32264"><span class="lineNum">   32264 </span>            : </a>
<span class="lineNum">   32265 </span>            : static tree
<span class="lineNum">   32266 </span>            : cp_parser_omp_clause_final (cp_parser *parser, tree list, location_t location)
<span class="lineNum">   32267 </span>            : {
<span class="lineNum">   32268 </span>            :   tree t, c;
<span class="lineNum">   32269 </span>            : 
<span class="lineNum">   32270 </span>            :   matching_parens parens;
<span class="lineNum">   32271 </span>            :   if (!parens.require_open (parser))
<span class="lineNum">   32272 </span><span class="lineCov">        331 :     return list;</span>
<span class="lineNum">   32273 </span>            : 
<span class="lineNum">   32274 </span>            :   t = cp_parser_condition (parser);
<span class="lineNum">   32275 </span>            : 
<span class="lineNum">   32276 </span><span class="lineCov">         30 :   if (t == error_mark_node</span>
<span class="lineNum">   32277 </span><span class="lineCov">         42 :       || !parens.require_close (parser))</span>
<span class="lineNum">   32278 </span><span class="lineCov">         42 :     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,</span>
<span class="lineNum">   32279 </span>            :                                            /*or_comma=*/false,
<span class="lineNum">   32280 </span><span class="lineNoCov">          0 :                                            /*consume_paren=*/true);</span>
<span class="lineNum">   32281 </span>            : 
<span class="lineNum">   32282 </span>            :   check_no_duplicate_clause (list, OMP_CLAUSE_FINAL, &quot;final&quot;, location);
<span class="lineNum">   32283 </span><span class="lineCov">         42 : </span>
<span class="lineNum">   32284 </span><span class="lineCov">        331 :   c = build_omp_clause (location, OMP_CLAUSE_FINAL);</span>
<span class="lineNum">   32285 </span><span class="lineCov">         60 :   OMP_CLAUSE_FINAL_EXPR (c) = t;</span>
<span class="lineNum">   32286 </span>            :   OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   32287 </span>            : 
<span class="lineNum">   32288 </span>            :   return c;
<span class="lineNum">   32289 </span><span class="lineCov">        373 : }</span>
<span class="lineNum">   32290 </span>            : 
<span class="lineNum">   32291 </span>            : /* OpenMP 2.5:
<span class="lineNum">   32292 </span><span class="lineCov">        331 :    if ( expression )</span>
<span class="lineNum">   32293 </span><span class="lineCov">        331 : </span>
<span class="lineNum">   32294 </span><span class="lineCov">        331 :    OpenMP 4.5:</span>
<span class="lineNum">   32295 </span><span class="lineCov">        331 :    if ( directive-name-modifier : expression )</span>
<span class="lineNum">   32296 </span>            : 
<span class="lineNum">   32297 </span><span class="lineCov">        331 :    directive-name-modifier:</span>
<span class="lineNum">   32298 </span>            :      parallel | task | taskloop | target data | target | target update
<span class="lineNum">   32299 </span>            :      | target enter data | target exit data  */
<a name="32300"><span class="lineNum">   32300 </span>            : </a>
<span class="lineNum">   32301 </span>            : static tree
<span class="lineNum">   32302 </span>            : cp_parser_omp_clause_if (cp_parser *parser, tree list, location_t location,
<span class="lineNum">   32303 </span>            :                          bool is_omp)
<span class="lineNum">   32304 </span><span class="lineCov">         22 : {</span>
<span class="lineNum">   32305 </span>            :   tree t, c;
<span class="lineNum">   32306 </span><span class="lineCov">         22 :   enum tree_code if_modifier = ERROR_MARK;</span>
<span class="lineNum">   32307 </span>            : 
<span class="lineNum">   32308 </span><span class="lineCov">         44 :   matching_parens parens;</span>
<span class="lineNum">   32309 </span><span class="lineCov">         22 :   if (!parens.require_open (parser))</span>
<span class="lineNum">   32310 </span>            :     return list;
<span class="lineNum">   32311 </span>            : 
<span class="lineNum">   32312 </span><span class="lineCov">         22 :   if (is_omp &amp;&amp; cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))</span>
<span class="lineNum">   32313 </span>            :     {
<span class="lineNum">   32314 </span><span class="lineCov">         22 :       tree id = cp_lexer_peek_token (parser-&gt;lexer)-&gt;u.value;</span>
<span class="lineNum">   32315 </span><span class="lineCov">         22 :       const char *p = IDENTIFIER_POINTER (id);</span>
<span class="lineNum">   32316 </span><span class="lineNoCov">          0 :       int n = 2;</span>
<span class="lineNum">   32317 </span>            : 
<span class="lineNum">   32318 </span>            :       if (strcmp (&quot;parallel&quot;, p) == 0)
<span class="lineNum">   32319 </span>            :         if_modifier = OMP_PARALLEL;
<span class="lineNum">   32320 </span><span class="lineCov">         22 :       else if (strcmp (&quot;task&quot;, p) == 0)</span>
<span class="lineNum">   32321 </span>            :         if_modifier = OMP_TASK;
<span class="lineNum">   32322 </span><span class="lineCov">         22 :       else if (strcmp (&quot;taskloop&quot;, p) == 0)</span>
<span class="lineNum">   32323 </span><span class="lineCov">         22 :         if_modifier = OMP_TASKLOOP;</span>
<span class="lineNum">   32324 </span><span class="lineCov">         22 :       else if (strcmp (&quot;target&quot;, p) == 0)</span>
<span class="lineNum">   32325 </span>            :         {
<span class="lineNum">   32326 </span><span class="lineCov">         22 :           if_modifier = OMP_TARGET;</span>
<span class="lineNum">   32327 </span>            :           if (cp_lexer_nth_token_is (parser-&gt;lexer, 2, CPP_NAME))
<span class="lineNum">   32328 </span>            :             {
<span class="lineNum">   32329 </span>            :               id = cp_lexer_peek_nth_token (parser-&gt;lexer, 2)-&gt;u.value;
<span class="lineNum">   32330 </span>            :               p = IDENTIFIER_POINTER (id);
<span class="lineNum">   32331 </span>            :               if (strcmp (&quot;data&quot;, p) == 0)
<span class="lineNum">   32332 </span>            :                 if_modifier = OMP_TARGET_DATA;
<span class="lineNum">   32333 </span>            :               else if (strcmp (&quot;update&quot;, p) == 0)
<span class="lineNum">   32334 </span>            :                 if_modifier = OMP_TARGET_UPDATE;
<span class="lineNum">   32335 </span>            :               else if (strcmp (&quot;enter&quot;, p) == 0)
<span class="lineNum">   32336 </span>            :                 if_modifier = OMP_TARGET_ENTER_DATA;
<span class="lineNum">   32337 </span>            :               else if (strcmp (&quot;exit&quot;, p) == 0)
<span class="lineNum">   32338 </span>            :                 if_modifier = OMP_TARGET_EXIT_DATA;
<span class="lineNum">   32339 </span>            :               if (if_modifier != OMP_TARGET)
<span class="lineNum">   32340 </span><span class="lineCov">        513 :                 n = 3;</span>
<span class="lineNum">   32341 </span>            :               else
<span class="lineNum">   32342 </span>            :                 {
<span class="lineNum">   32343 </span><span class="lineCov">        513 :                   location_t loc</span>
<span class="lineNum">   32344 </span><span class="lineCov">        513 :                     = cp_lexer_peek_nth_token (parser-&gt;lexer, 2)-&gt;location;</span>
<span class="lineNum">   32345 </span>            :                   error_at (loc, &quot;expected %&lt;data%&gt;, %&lt;update%&gt;, %&lt;enter%&gt; &quot;
<span class="lineNum">   32346 </span><span class="lineCov">       1026 :                                  &quot;or %&lt;exit%&gt;&quot;);</span>
<span class="lineNum">   32347 </span><span class="lineCov">        513 :                   if_modifier = ERROR_MARK;</span>
<span class="lineNum">   32348 </span>            :                 }
<span class="lineNum">   32349 </span>            :               if (if_modifier == OMP_TARGET_ENTER_DATA
<span class="lineNum">   32350 </span><span class="lineCov">        513 :                   || if_modifier == OMP_TARGET_EXIT_DATA)</span>
<span class="lineNum">   32351 </span>            :                 {
<span class="lineNum">   32352 </span><span class="lineCov">        734 :                   if (cp_lexer_nth_token_is (parser-&gt;lexer, 3, CPP_NAME))</span>
<span class="lineNum">   32353 </span><span class="lineCov">        367 :                     {</span>
<span class="lineNum">   32354 </span><span class="lineCov">        367 :                       id = cp_lexer_peek_nth_token (parser-&gt;lexer, 3)-&gt;u.value;</span>
<span class="lineNum">   32355 </span>            :                       p = IDENTIFIER_POINTER (id);
<span class="lineNum">   32356 </span><span class="lineCov">        367 :                       if (strcmp (&quot;data&quot;, p) == 0)</span>
<span class="lineNum">   32357 </span>            :                         n = 4;
<span class="lineNum">   32358 </span><span class="lineCov">        307 :                     }</span>
<span class="lineNum">   32359 </span>            :                   if (n != 4)
<span class="lineNum">   32360 </span><span class="lineCov">        292 :                     {</span>
<span class="lineNum">   32361 </span>            :                       location_t loc
<span class="lineNum">   32362 </span><span class="lineCov">        277 :                         = cp_lexer_peek_nth_token (parser-&gt;lexer, 3)-&gt;location;</span>
<span class="lineNum">   32363 </span>            :                       error_at (loc, &quot;expected %&lt;data%&gt;&quot;);
<span class="lineNum">   32364 </span><span class="lineCov">         66 :                       if_modifier = ERROR_MARK;</span>
<span class="lineNum">   32365 </span><span class="lineCov">         66 :                     }</span>
<span class="lineNum">   32366 </span>            :                 }
<span class="lineNum">   32367 </span><span class="lineCov">         30 :             }</span>
<span class="lineNum">   32368 </span><span class="lineCov">         30 :         }</span>
<span class="lineNum">   32369 </span><span class="lineCov">         30 :       if (if_modifier != ERROR_MARK)</span>
<span class="lineNum">   32370 </span>            :         {
<span class="lineNum">   32371 </span><span class="lineCov">         24 :           if (cp_lexer_nth_token_is (parser-&gt;lexer, n, CPP_COLON))</span>
<span class="lineNum">   32372 </span>            :             {
<span class="lineNum">   32373 </span><span class="lineCov">         15 :               while (n-- &gt; 0)</span>
<span class="lineNum">   32374 </span>            :                 cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   32375 </span><span class="lineCov">          9 :             }</span>
<span class="lineNum">   32376 </span>            :           else
<span class="lineNum">   32377 </span><span class="lineNoCov">          0 :             {</span>
<span class="lineNum">   32378 </span>            :               if (n &gt; 2)
<span class="lineNum">   32379 </span>            :                 {
<span class="lineNum">   32380 </span>            :                   location_t loc
<span class="lineNum">   32381 </span><span class="lineNoCov">          0 :                     = cp_lexer_peek_nth_token (parser-&gt;lexer, n)-&gt;location;</span>
<span class="lineNum">   32382 </span><span class="lineNoCov">          0 :                   error_at (loc, &quot;expected %&lt;:%&gt;&quot;);</span>
<span class="lineNum">   32383 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">   32384 </span>            :               if_modifier = ERROR_MARK;
<span class="lineNum">   32385 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">   32386 </span>            :         }
<span class="lineNum">   32387 </span><span class="lineCov">         60 :     }</span>
<span class="lineNum">   32388 </span><span class="lineCov">         30 : </span>
<span class="lineNum">   32389 </span>            :   t = cp_parser_condition (parser);
<span class="lineNum">   32390 </span><span class="lineCov">         15 : </span>
<span class="lineNum">   32391 </span>            :   if (t == error_mark_node
<span class="lineNum">   32392 </span><span class="lineCov">         15 :       || !parens.require_close (parser))</span>
<span class="lineNum">   32393 </span><span class="lineCov">         15 :     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,</span>
<span class="lineNum">   32394 </span><span class="lineCov">         15 :                                            /*or_comma=*/false,</span>
<span class="lineNum">   32395 </span>            :                                            /*consume_paren=*/true);
<span class="lineNum">   32396 </span>            : 
<span class="lineNum">   32397 </span><span class="lineNoCov">          0 :   for (c = list; c ; c = OMP_CLAUSE_CHAIN (c))</span>
<span class="lineNum">   32398 </span>            :     if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_IF)
<span class="lineNum">   32399 </span><span class="lineNoCov">          0 :       {</span>
<span class="lineNum">   32400 </span><span class="lineNoCov">          0 :         if (if_modifier != ERROR_MARK</span>
<span class="lineNum">   32401 </span><span class="lineNoCov">          0 :             &amp;&amp; OMP_CLAUSE_IF_MODIFIER (c) == if_modifier)</span>
<span class="lineNum">   32402 </span><span class="lineNoCov">          0 :           {</span>
<span class="lineNum">   32403 </span>            :             const char *p = NULL;
<span class="lineNum">   32404 </span>            :             switch (if_modifier)
<span class="lineNum">   32405 </span>            :               {
<span class="lineNum">   32406 </span>            :               case OMP_PARALLEL: p = &quot;parallel&quot;; break;
<span class="lineNum">   32407 </span><span class="lineCov">         30 :               case OMP_TASK: p = &quot;task&quot;; break;</span>
<span class="lineNum">   32408 </span>            :               case OMP_TASKLOOP: p = &quot;taskloop&quot;; break;
<span class="lineNum">   32409 </span><span class="lineCov">        156 :               case OMP_TARGET_DATA: p = &quot;target data&quot;; break;</span>
<span class="lineNum">   32410 </span>            :               case OMP_TARGET: p = &quot;target&quot;; break;
<span class="lineNum">   32411 </span><span class="lineCov">        504 :               case OMP_TARGET_UPDATE: p = &quot;target update&quot;; break;</span>
<span class="lineNum">   32412 </span><span class="lineCov">        351 :               case OMP_TARGET_ENTER_DATA: p = &quot;enter data&quot;; break;</span>
<span class="lineNum">   32413 </span>            :               case OMP_TARGET_EXIT_DATA: p = &quot;exit data&quot;; break;
<span class="lineNum">   32414 </span>            :               default: gcc_unreachable ();
<span class="lineNum">   32415 </span>            :               }
<span class="lineNum">   32416 </span><span class="lineCov">          3 :             error_at (location, &quot;too many %&lt;if%&gt; clauses with %qs modifier&quot;,</span>
<span class="lineNum">   32417 </span>            :                       p);
<span class="lineNum">   32418 </span><span class="lineNoCov">          0 :             return list;</span>
<span class="lineNum">   32419 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">   32420 </span><span class="lineNoCov">          0 :         else if (OMP_CLAUSE_IF_MODIFIER (c) == if_modifier)</span>
<span class="lineNum">   32421 </span>            :           {
<span class="lineNum">   32422 </span>            :             if (!is_omp)
<span class="lineNum">   32423 </span>            :               error_at (location, &quot;too many %&lt;if%&gt; clauses&quot;);
<span class="lineNum">   32424 </span>            :             else
<span class="lineNum">   32425 </span>            :               error_at (location, &quot;too many %&lt;if%&gt; clauses without modifier&quot;);
<span class="lineNum">   32426 </span>            :             return list;
<span class="lineNum">   32427 </span><span class="lineCov">        513 :           }</span>
<span class="lineNum">   32428 </span>            :         else if (if_modifier == ERROR_MARK
<span class="lineNum">   32429 </span><span class="lineCov">        513 :                  || OMP_CLAUSE_IF_MODIFIER (c) == ERROR_MARK)</span>
<span class="lineNum">   32430 </span><span class="lineCov">        513 :           {</span>
<span class="lineNum">   32431 </span><span class="lineNoCov">          0 :             error_at (location, &quot;if any %&lt;if%&gt; clause has modifier, then all &quot;</span>
<span class="lineNum">   32432 </span>            :                                 &quot;%&lt;if%&gt; clauses have to use modifier&quot;);
<span class="lineNum">   32433 </span>            :             return list;
<span class="lineNum">   32434 </span>            :           }
<span class="lineNum">   32435 </span><span class="lineCov">       1737 :       }</span>
<span class="lineNum">   32436 </span><span class="lineCov">        627 : </span>
<span class="lineNum">   32437 </span>            :   c = build_omp_clause (location, OMP_CLAUSE_IF);
<span class="lineNum">   32438 </span><span class="lineCov">         36 :   OMP_CLAUSE_IF_MODIFIER (c) = if_modifier;</span>
<span class="lineNum">   32439 </span><span class="lineCov">         36 :   OMP_CLAUSE_IF_EXPR (c) = t;</span>
<span class="lineNum">   32440 </span>            :   OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   32441 </span><span class="lineCov">          3 : </span>
<span class="lineNum">   32442 </span><span class="lineCov">          3 :   return c;</span>
<span class="lineNum">   32443 </span>            : }
<span class="lineNum">   32444 </span>            : 
<span class="lineNum">   32445 </span><span class="lineNoCov">          0 : /* OpenMP 3.1:</span>
<span class="lineNum">   32446 </span><span class="lineNoCov">          0 :    mergeable */</span>
<a name="32447"><span class="lineNum">   32447 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   32448 </span><span class="lineNoCov">          0 : static tree</span>
<span class="lineNum">   32449 </span><span class="lineNoCov">          0 : cp_parser_omp_clause_mergeable (cp_parser * /*parser*/,</span>
<span class="lineNum">   32450 </span><span class="lineNoCov">          0 :                                 tree list, location_t location)</span>
<span class="lineNum">   32451 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   32452 </span><span class="lineNoCov">          0 :   tree c;</span>
<span class="lineNum">   32453 </span>            : 
<span class="lineNum">   32454 </span><span class="lineCov">          3 :   check_no_duplicate_clause (list, OMP_CLAUSE_MERGEABLE, &quot;mergeable&quot;,</span>
<span class="lineNum">   32455 </span>            :                              location);
<span class="lineNum">   32456 </span><span class="lineCov">          3 : </span>
<span class="lineNum">   32457 </span>            :   c = build_omp_clause (location, OMP_CLAUSE_MERGEABLE);
<span class="lineNum">   32458 </span><span class="lineCov">         33 :   OMP_CLAUSE_CHAIN (c) = list;</span>
<span class="lineNum">   32459 </span>            :   return c;
<span class="lineNum">   32460 </span><span class="lineCov">          6 : }</span>
<span class="lineNum">   32461 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   32462 </span>            : /* OpenMP 2.5:
<span class="lineNum">   32463 </span><span class="lineCov">          6 :    nowait */</span>
<a name="32464"><span class="lineNum">   32464 </span><span class="lineCov">          6 : </span></a>
<span class="lineNum">   32465 </span>            : static tree
<span class="lineNum">   32466 </span><span class="lineCov">         27 : cp_parser_omp_clause_nowait (cp_parser * /*parser*/,</span>
<span class="lineNum">   32467 </span><span class="lineCov">         27 :                              tree list, location_t location)</span>
<span class="lineNum">   32468 </span>            : {
<span class="lineNum">   32469 </span><span class="lineCov">          6 :   tree c;</span>
<span class="lineNum">   32470 </span>            : 
<span class="lineNum">   32471 </span><span class="lineCov">          6 :   check_no_duplicate_clause (list, OMP_CLAUSE_NOWAIT, &quot;nowait&quot;, location);</span>
<span class="lineNum">   32472 </span>            : 
<span class="lineNum">   32473 </span>            :   c = build_omp_clause (location, OMP_CLAUSE_NOWAIT);
<span class="lineNum">   32474 </span>            :   OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   32475 </span><span class="lineCov">        498 :   return c;</span>
<span class="lineNum">   32476 </span><span class="lineCov">        498 : }</span>
<span class="lineNum">   32477 </span><span class="lineCov">        498 : </span>
<span class="lineNum">   32478 </span><span class="lineCov">        498 : /* OpenMP 2.5:</span>
<span class="lineNum">   32479 </span>            :    num_threads ( expression ) */
<a name="32480"><span class="lineNum">   32480 </span><span class="lineCov">        498 : </span></a>
<span class="lineNum">   32481 </span>            : static tree
<span class="lineNum">   32482 </span>            : cp_parser_omp_clause_num_threads (cp_parser *parser, tree list,
<span class="lineNum">   32483 </span>            :                                   location_t location)
<span class="lineNum">   32484 </span>            : {
<span class="lineNum">   32485 </span>            :   tree t, c;
<span class="lineNum">   32486 </span>            : 
<span class="lineNum">   32487 </span><span class="lineCov">          3 :   matching_parens parens;</span>
<span class="lineNum">   32488 </span>            :   if (!parens.require_open (parser))
<span class="lineNum">   32489 </span>            :     return list;
<span class="lineNum">   32490 </span><span class="lineCov">          3 : </span>
<span class="lineNum">   32491 </span>            :   t = cp_parser_expression (parser);
<span class="lineNum">   32492 </span><span class="lineCov">          3 : </span>
<span class="lineNum">   32493 </span>            :   if (t == error_mark_node
<span class="lineNum">   32494 </span>            :       || !parens.require_close (parser))
<span class="lineNum">   32495 </span><span class="lineCov">          3 :     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,</span>
<span class="lineNum">   32496 </span><span class="lineCov">          3 :                                            /*or_comma=*/false,</span>
<span class="lineNum">   32497 </span><span class="lineCov">          3 :                                            /*consume_paren=*/true);</span>
<span class="lineNum">   32498 </span>            : 
<span class="lineNum">   32499 </span>            :   check_no_duplicate_clause (list, OMP_CLAUSE_NUM_THREADS,
<span class="lineNum">   32500 </span>            :                              &quot;num_threads&quot;, location);
<span class="lineNum">   32501 </span>            : 
<span class="lineNum">   32502 </span>            :   c = build_omp_clause (location, OMP_CLAUSE_NUM_THREADS);
<span class="lineNum">   32503 </span>            :   OMP_CLAUSE_NUM_THREADS_EXPR (c) = t;
<span class="lineNum">   32504 </span><span class="lineCov">        177 :   OMP_CLAUSE_CHAIN (c) = list;</span>
<span class="lineNum">   32505 </span>            : 
<span class="lineNum">   32506 </span>            :   return c;
<span class="lineNum">   32507 </span><span class="lineCov">        177 : }</span>
<span class="lineNum">   32508 </span>            : 
<span class="lineNum">   32509 </span><span class="lineCov">        177 : /* OpenMP 4.5:</span>
<span class="lineNum">   32510 </span>            :    num_tasks ( expression ) */
<a name="32511"><span class="lineNum">   32511 </span><span class="lineCov">        177 : </span></a>
<span class="lineNum">   32512 </span><span class="lineCov">        177 : static tree</span>
<span class="lineNum">   32513 </span><span class="lineCov">        177 : cp_parser_omp_clause_num_tasks (cp_parser *parser, tree list,</span>
<span class="lineNum">   32514 </span>            :                                 location_t location)
<span class="lineNum">   32515 </span>            : {
<span class="lineNum">   32516 </span>            :   tree t, c;
<span class="lineNum">   32517 </span>            : 
<span class="lineNum">   32518 </span>            :   matching_parens parens;
<span class="lineNum">   32519 </span>            :   if (!parens.require_open (parser))
<span class="lineNum">   32520 </span><span class="lineCov">        263 :     return list;</span>
<span class="lineNum">   32521 </span>            : 
<span class="lineNum">   32522 </span>            :   t = cp_parser_expression (parser);
<span class="lineNum">   32523 </span><span class="lineCov">        263 : </span>
<span class="lineNum">   32524 </span>            :   if (t == error_mark_node
<span class="lineNum">   32525 </span><span class="lineCov">        526 :       || !parens.require_close (parser))</span>
<span class="lineNum">   32526 </span><span class="lineCov">        263 :     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,</span>
<span class="lineNum">   32527 </span>            :                                            /*or_comma=*/false,
<span class="lineNum">   32528 </span>            :                                            /*consume_paren=*/true);
<span class="lineNum">   32529 </span><span class="lineCov">        263 : </span>
<span class="lineNum">   32530 </span>            :   check_no_duplicate_clause (list, OMP_CLAUSE_NUM_TASKS,
<span class="lineNum">   32531 </span><span class="lineCov">        263 :                              &quot;num_tasks&quot;, location);</span>
<span class="lineNum">   32532 </span><span class="lineCov">        263 : </span>
<span class="lineNum">   32533 </span><span class="lineNoCov">          0 :   c = build_omp_clause (location, OMP_CLAUSE_NUM_TASKS);</span>
<span class="lineNum">   32534 </span>            :   OMP_CLAUSE_NUM_TASKS_EXPR (c) = t;
<span class="lineNum">   32535 </span>            :   OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   32536 </span>            : 
<span class="lineNum">   32537 </span><span class="lineCov">        263 :   return c;</span>
<span class="lineNum">   32538 </span>            : }
<span class="lineNum">   32539 </span>            : 
<span class="lineNum">   32540 </span><span class="lineCov">        263 : /* OpenMP 4.5:</span>
<span class="lineNum">   32541 </span><span class="lineCov">        263 :    grainsize ( expression ) */</span>
<a name="32542"><span class="lineNum">   32542 </span><span class="lineCov">        263 : </span></a>
<span class="lineNum">   32543 </span>            : static tree
<span class="lineNum">   32544 </span><span class="lineCov">        263 : cp_parser_omp_clause_grainsize (cp_parser *parser, tree list,</span>
<span class="lineNum">   32545 </span>            :                                 location_t location)
<span class="lineNum">   32546 </span>            : {
<span class="lineNum">   32547 </span>            :   tree t, c;
<span class="lineNum">   32548 </span>            : 
<span class="lineNum">   32549 </span>            :   matching_parens parens;
<span class="lineNum">   32550 </span>            :   if (!parens.require_open (parser))
<span class="lineNum">   32551 </span><span class="lineCov">          6 :     return list;</span>
<span class="lineNum">   32552 </span>            : 
<span class="lineNum">   32553 </span>            :   t = cp_parser_expression (parser);
<span class="lineNum">   32554 </span><span class="lineCov">          6 : </span>
<span class="lineNum">   32555 </span>            :   if (t == error_mark_node
<span class="lineNum">   32556 </span><span class="lineCov">         12 :       || !parens.require_close (parser))</span>
<span class="lineNum">   32557 </span><span class="lineCov">          6 :     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,</span>
<span class="lineNum">   32558 </span>            :                                            /*or_comma=*/false,
<span class="lineNum">   32559 </span>            :                                            /*consume_paren=*/true);
<span class="lineNum">   32560 </span><span class="lineCov">          6 : </span>
<span class="lineNum">   32561 </span>            :   check_no_duplicate_clause (list, OMP_CLAUSE_GRAINSIZE,
<span class="lineNum">   32562 </span><span class="lineCov">          6 :                              &quot;grainsize&quot;, location);</span>
<span class="lineNum">   32563 </span><span class="lineCov">          6 : </span>
<span class="lineNum">   32564 </span><span class="lineNoCov">          0 :   c = build_omp_clause (location, OMP_CLAUSE_GRAINSIZE);</span>
<span class="lineNum">   32565 </span>            :   OMP_CLAUSE_GRAINSIZE_EXPR (c) = t;
<span class="lineNum">   32566 </span>            :   OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   32567 </span>            : 
<span class="lineNum">   32568 </span><span class="lineCov">          6 :   return c;</span>
<span class="lineNum">   32569 </span>            : }
<span class="lineNum">   32570 </span>            : 
<span class="lineNum">   32571 </span><span class="lineCov">          6 : /* OpenMP 4.5:</span>
<span class="lineNum">   32572 </span><span class="lineCov">          6 :    priority ( expression ) */</span>
<a name="32573"><span class="lineNum">   32573 </span><span class="lineCov">          6 : </span></a>
<span class="lineNum">   32574 </span>            : static tree
<span class="lineNum">   32575 </span><span class="lineCov">          6 : cp_parser_omp_clause_priority (cp_parser *parser, tree list,</span>
<span class="lineNum">   32576 </span>            :                                location_t location)
<span class="lineNum">   32577 </span>            : {
<span class="lineNum">   32578 </span>            :   tree t, c;
<span class="lineNum">   32579 </span>            : 
<span class="lineNum">   32580 </span>            :   matching_parens parens;
<span class="lineNum">   32581 </span>            :   if (!parens.require_open (parser))
<span class="lineNum">   32582 </span><span class="lineCov">          6 :     return list;</span>
<span class="lineNum">   32583 </span>            : 
<span class="lineNum">   32584 </span>            :   t = cp_parser_expression (parser);
<span class="lineNum">   32585 </span><span class="lineCov">          6 : </span>
<span class="lineNum">   32586 </span>            :   if (t == error_mark_node
<span class="lineNum">   32587 </span><span class="lineCov">         12 :       || !parens.require_close (parser))</span>
<span class="lineNum">   32588 </span><span class="lineCov">          6 :     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,</span>
<span class="lineNum">   32589 </span>            :                                            /*or_comma=*/false,
<span class="lineNum">   32590 </span>            :                                            /*consume_paren=*/true);
<span class="lineNum">   32591 </span><span class="lineCov">          6 : </span>
<span class="lineNum">   32592 </span>            :   check_no_duplicate_clause (list, OMP_CLAUSE_PRIORITY,
<span class="lineNum">   32593 </span><span class="lineCov">          6 :                              &quot;priority&quot;, location);</span>
<span class="lineNum">   32594 </span><span class="lineCov">          6 : </span>
<span class="lineNum">   32595 </span><span class="lineNoCov">          0 :   c = build_omp_clause (location, OMP_CLAUSE_PRIORITY);</span>
<span class="lineNum">   32596 </span>            :   OMP_CLAUSE_PRIORITY_EXPR (c) = t;
<span class="lineNum">   32597 </span>            :   OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   32598 </span>            : 
<span class="lineNum">   32599 </span><span class="lineCov">          6 :   return c;</span>
<span class="lineNum">   32600 </span>            : }
<span class="lineNum">   32601 </span>            : 
<span class="lineNum">   32602 </span><span class="lineCov">          6 : /* OpenMP 4.5:</span>
<span class="lineNum">   32603 </span><span class="lineCov">          6 :    hint ( expression ) */</span>
<a name="32604"><span class="lineNum">   32604 </span><span class="lineCov">          6 : </span></a>
<span class="lineNum">   32605 </span>            : static tree
<span class="lineNum">   32606 </span><span class="lineCov">          6 : cp_parser_omp_clause_hint (cp_parser *parser, tree list,</span>
<span class="lineNum">   32607 </span>            :                            location_t location)
<span class="lineNum">   32608 </span>            : {
<span class="lineNum">   32609 </span>            :   tree t, c;
<span class="lineNum">   32610 </span>            : 
<span class="lineNum">   32611 </span>            :   matching_parens parens;
<span class="lineNum">   32612 </span>            :   if (!parens.require_open (parser))
<span class="lineNum">   32613 </span><span class="lineCov">         18 :     return list;</span>
<span class="lineNum">   32614 </span>            : 
<span class="lineNum">   32615 </span>            :   t = cp_parser_expression (parser);
<span class="lineNum">   32616 </span><span class="lineCov">         18 : </span>
<span class="lineNum">   32617 </span>            :   if (t == error_mark_node
<span class="lineNum">   32618 </span><span class="lineCov">         36 :       || !parens.require_close (parser))</span>
<span class="lineNum">   32619 </span><span class="lineCov">         18 :     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,</span>
<span class="lineNum">   32620 </span>            :                                            /*or_comma=*/false,
<span class="lineNum">   32621 </span>            :                                            /*consume_paren=*/true);
<span class="lineNum">   32622 </span><span class="lineCov">         18 : </span>
<span class="lineNum">   32623 </span>            :   check_no_duplicate_clause (list, OMP_CLAUSE_HINT, &quot;hint&quot;, location);
<span class="lineNum">   32624 </span><span class="lineCov">         18 : </span>
<span class="lineNum">   32625 </span><span class="lineCov">         18 :   c = build_omp_clause (location, OMP_CLAUSE_HINT);</span>
<span class="lineNum">   32626 </span><span class="lineNoCov">          0 :   OMP_CLAUSE_HINT_EXPR (c) = t;</span>
<span class="lineNum">   32627 </span>            :   OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   32628 </span>            : 
<span class="lineNum">   32629 </span>            :   return c;
<span class="lineNum">   32630 </span><span class="lineCov">         18 : }</span>
<span class="lineNum">   32631 </span>            : 
<span class="lineNum">   32632 </span>            : /* OpenMP 4.5:
<span class="lineNum">   32633 </span><span class="lineCov">         18 :    defaultmap ( tofrom : scalar ) */</span>
<a name="32634"><span class="lineNum">   32634 </span><span class="lineCov">         18 : </span></a>
<span class="lineNum">   32635 </span><span class="lineCov">         18 : static tree</span>
<span class="lineNum">   32636 </span>            : cp_parser_omp_clause_defaultmap (cp_parser *parser, tree list,
<span class="lineNum">   32637 </span><span class="lineCov">         18 :                                  location_t location)</span>
<span class="lineNum">   32638 </span>            : {
<span class="lineNum">   32639 </span>            :   tree c, id;
<span class="lineNum">   32640 </span>            :   const char *p;
<span class="lineNum">   32641 </span>            : 
<span class="lineNum">   32642 </span>            :   matching_parens parens;
<span class="lineNum">   32643 </span>            :   if (!parens.require_open (parser))
<span class="lineNum">   32644 </span><span class="lineNoCov">          0 :     return list;</span>
<span class="lineNum">   32645 </span>            : 
<span class="lineNum">   32646 </span>            :   if (!cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))
<span class="lineNum">   32647 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   32648 </span>            :       cp_parser_error (parser, &quot;expected %&lt;tofrom%&gt;&quot;);
<span class="lineNum">   32649 </span><span class="lineNoCov">          0 :       goto out_err;</span>
<span class="lineNum">   32650 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   32651 </span>            :   id = cp_lexer_peek_token (parser-&gt;lexer)-&gt;u.value;
<span class="lineNum">   32652 </span>            :   p = IDENTIFIER_POINTER (id);
<span class="lineNum">   32653 </span><span class="lineNoCov">          0 :   if (strcmp (p, &quot;tofrom&quot;) != 0)</span>
<span class="lineNum">   32654 </span>            :     {
<span class="lineNum">   32655 </span><span class="lineNoCov">          0 :       cp_parser_error (parser, &quot;expected %&lt;tofrom%&gt;&quot;);</span>
<span class="lineNum">   32656 </span><span class="lineNoCov">          0 :       goto out_err;</span>
<span class="lineNum">   32657 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   32658 </span>            :   cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   32659 </span>            :   if (!cp_parser_require (parser, CPP_COLON, RT_COLON))
<span class="lineNum">   32660 </span>            :     goto out_err;
<span class="lineNum">   32661 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   32662 </span>            :   if (!cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))
<span class="lineNum">   32663 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   32664 </span><span class="lineNoCov">          0 :       cp_parser_error (parser, &quot;expected %&lt;scalar%&gt;&quot;);</span>
<span class="lineNum">   32665 </span><span class="lineNoCov">          0 :       goto out_err;</span>
<span class="lineNum">   32666 </span>            :     }
<span class="lineNum">   32667 </span><span class="lineNoCov">          0 :   id = cp_lexer_peek_token (parser-&gt;lexer)-&gt;u.value;</span>
<span class="lineNum">   32668 </span>            :   p = IDENTIFIER_POINTER (id);
<span class="lineNum">   32669 </span>            :   if (strcmp (p, &quot;scalar&quot;) != 0)
<span class="lineNum">   32670 </span>            :     {
<span class="lineNum">   32671 </span>            :       cp_parser_error (parser, &quot;expected %&lt;scalar%&gt;&quot;);
<span class="lineNum">   32672 </span>            :       goto out_err;
<span class="lineNum">   32673 </span>            :     }
<span class="lineNum">   32674 </span><span class="lineCov">         40 :   cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   32675 </span>            :   if (!parens.require_close (parser))
<span class="lineNum">   32676 </span>            :     goto out_err;
<span class="lineNum">   32677 </span><span class="lineCov">         40 : </span>
<span class="lineNum">   32678 </span><span class="lineCov">         40 :   check_no_duplicate_clause (list, OMP_CLAUSE_DEFAULTMAP, &quot;defaultmap&quot;,</span>
<span class="lineNum">   32679 </span>            :                              location);
<span class="lineNum">   32680 </span><span class="lineCov">         80 : </span>
<span class="lineNum">   32681 </span><span class="lineCov">         40 :   c = build_omp_clause (location, OMP_CLAUSE_DEFAULTMAP);</span>
<span class="lineNum">   32682 </span>            :   OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   32683 </span>            :   return c;
<span class="lineNum">   32684 </span><span class="lineCov">         40 : </span>
<span class="lineNum">   32685 </span>            :  out_err:
<span class="lineNum">   32686 </span><span class="lineNoCov">          0 :   cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,</span>
<span class="lineNum">   32687 </span><span class="lineNoCov">          0 :                                          /*or_comma=*/false,</span>
<span class="lineNum">   32688 </span>            :                                          /*consume_paren=*/true);
<span class="lineNum">   32689 </span><span class="lineCov">         80 :   return list;</span>
<span class="lineNum">   32690 </span><span class="lineCov">         40 : }</span>
<span class="lineNum">   32691 </span><span class="lineCov">         40 : </span>
<span class="lineNum">   32692 </span>            : /* OpenMP 2.5:
<span class="lineNum">   32693 </span><span class="lineNoCov">          0 :    ordered</span>
<span class="lineNum">   32694 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   32695 </span>            :    OpenMP 4.5:
<span class="lineNum">   32696 </span><span class="lineCov">         40 :    ordered ( constant-expression ) */</span>
<a name="32697"><span class="lineNum">   32697 </span><span class="lineCov">         40 : </span></a>
<span class="lineNum">   32698 </span>            : static tree
<span class="lineNum">   32699 </span>            : cp_parser_omp_clause_ordered (cp_parser *parser,
<span class="lineNum">   32700 </span><span class="lineCov">         40 :                               tree list, location_t location)</span>
<span class="lineNum">   32701 </span>            : {
<span class="lineNum">   32702 </span><span class="lineNoCov">          0 :   tree c, num = NULL_TREE;</span>
<span class="lineNum">   32703 </span><span class="lineNoCov">          0 :   HOST_WIDE_INT n;</span>
<span class="lineNum">   32704 </span>            : 
<span class="lineNum">   32705 </span><span class="lineCov">         80 :   check_no_duplicate_clause (list, OMP_CLAUSE_ORDERED,</span>
<span class="lineNum">   32706 </span><span class="lineCov">         40 :                              &quot;ordered&quot;, location);</span>
<span class="lineNum">   32707 </span><span class="lineCov">         40 : </span>
<span class="lineNum">   32708 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_PAREN))
<span class="lineNum">   32709 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   32710 </span><span class="lineNoCov">          0 :       matching_parens parens;</span>
<span class="lineNum">   32711 </span>            :       parens.consume_open (parser);
<span class="lineNum">   32712 </span><span class="lineCov">         40 : </span>
<span class="lineNum">   32713 </span><span class="lineCov">         40 :       num = cp_parser_constant_expression (parser);</span>
<span class="lineNum">   32714 </span>            : 
<span class="lineNum">   32715 </span>            :       if (!parens.require_close (parser))
<span class="lineNum">   32716 </span><span class="lineCov">         40 :         cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,</span>
<span class="lineNum">   32717 </span>            :                                                /*or_comma=*/false,
<span class="lineNum">   32718 </span>            :                                                /*consume_paren=*/true);
<span class="lineNum">   32719 </span><span class="lineCov">         40 : </span>
<span class="lineNum">   32720 </span><span class="lineCov">         40 :       if (num == error_mark_node)</span>
<span class="lineNum">   32721 </span><span class="lineCov">         40 :         return list;</span>
<span class="lineNum">   32722 </span>            :       num = fold_non_dependent_expr (num);
<span class="lineNum">   32723 </span><span class="lineNoCov">          0 :       if (!tree_fits_shwi_p (num)</span>
<span class="lineNum">   32724 </span><span class="lineNoCov">          0 :           || !INTEGRAL_TYPE_P (TREE_TYPE (num))</span>
<span class="lineNum">   32725 </span>            :           || (n = tree_to_shwi (num)) &lt;= 0
<span class="lineNum">   32726 </span>            :           || (int) n != n)
<span class="lineNum">   32727 </span><span class="lineNoCov">          0 :         {</span>
<span class="lineNum">   32728 </span>            :           error_at (location,
<span class="lineNum">   32729 </span>            :                     &quot;ordered argument needs positive constant integer &quot;
<span class="lineNum">   32730 </span>            :                     &quot;expression&quot;);
<span class="lineNum">   32731 </span>            :           return list;
<span class="lineNum">   32732 </span>            :         }
<span class="lineNum">   32733 </span>            :     }
<span class="lineNum">   32734 </span>            : 
<span class="lineNum">   32735 </span>            :   c = build_omp_clause (location, OMP_CLAUSE_ORDERED);
<span class="lineNum">   32736 </span>            :   OMP_CLAUSE_ORDERED_EXPR (c) = num;
<span class="lineNum">   32737 </span><span class="lineCov">        205 :   OMP_CLAUSE_CHAIN (c) = list;</span>
<span class="lineNum">   32738 </span>            :   return c;
<span class="lineNum">   32739 </span>            : }
<span class="lineNum">   32740 </span><span class="lineCov">        205 : </span>
<span class="lineNum">   32741 </span><span class="lineCov">        205 : /* OpenMP 2.5:</span>
<span class="lineNum">   32742 </span>            :    reduction ( reduction-operator : variable-list )
<span class="lineNum">   32743 </span><span class="lineCov">        205 : </span>
<span class="lineNum">   32744 </span>            :    reduction-operator:
<span class="lineNum">   32745 </span>            :      One of: + * - &amp; ^ | &amp;&amp; ||
<span class="lineNum">   32746 </span><span class="lineCov">        205 : </span>
<span class="lineNum">   32747 </span>            :    OpenMP 3.1:
<span class="lineNum">   32748 </span><span class="lineCov">        222 : </span>
<span class="lineNum">   32749 </span><span class="lineCov">        111 :    reduction-operator:</span>
<span class="lineNum">   32750 </span>            :      One of: + * - &amp; ^ | &amp;&amp; || min max
<span class="lineNum">   32751 </span><span class="lineCov">        111 : </span>
<span class="lineNum">   32752 </span>            :    OpenMP 4.0:
<span class="lineNum">   32753 </span><span class="lineCov">        111 : </span>
<span class="lineNum">   32754 </span><span class="lineNoCov">          0 :    reduction-operator:</span>
<span class="lineNum">   32755 </span>            :      One of: + * - &amp; ^ | &amp;&amp; ||
<span class="lineNum">   32756 </span>            :      id-expression  */
<a name="32757"><span class="lineNum">   32757 </span>            : </a>
<span class="lineNum">   32758 </span><span class="lineCov">        111 : static tree</span>
<span class="lineNum">   32759 </span><span class="lineCov">          3 : cp_parser_omp_clause_reduction (cp_parser *parser, tree list)</span>
<span class="lineNum">   32760 </span><span class="lineCov">        111 : {</span>
<span class="lineNum">   32761 </span><span class="lineCov">        111 :   enum tree_code code = ERROR_MARK;</span>
<span class="lineNum">   32762 </span><span class="lineCov">        108 :   tree nlist, c, id = NULL_TREE;</span>
<span class="lineNum">   32763 </span><span class="lineCov">        108 : </span>
<span class="lineNum">   32764 </span><span class="lineCov">        219 :   if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))</span>
<span class="lineNum">   32765 </span>            :     return list;
<span class="lineNum">   32766 </span><span class="lineCov">          3 : </span>
<span class="lineNum">   32767 </span>            :   switch (cp_lexer_peek_token (parser-&gt;lexer)-&gt;type)
<span class="lineNum">   32768 </span>            :     {
<span class="lineNum">   32769 </span><span class="lineCov">          3 :     case CPP_PLUS: code = PLUS_EXPR; break;</span>
<span class="lineNum">   32770 </span>            :     case CPP_MULT: code = MULT_EXPR; break;
<span class="lineNum">   32771 </span>            :     case CPP_MINUS: code = MINUS_EXPR; break;
<span class="lineNum">   32772 </span>            :     case CPP_AND: code = BIT_AND_EXPR; break;
<span class="lineNum">   32773 </span><span class="lineCov">        202 :     case CPP_XOR: code = BIT_XOR_EXPR; break;</span>
<span class="lineNum">   32774 </span><span class="lineCov">        202 :     case CPP_OR: code = BIT_IOR_EXPR; break;</span>
<span class="lineNum">   32775 </span><span class="lineCov">        202 :     case CPP_AND_AND: code = TRUTH_ANDIF_EXPR; break;</span>
<span class="lineNum">   32776 </span><span class="lineCov">        202 :     case CPP_OR_OR: code = TRUTH_ORIF_EXPR; break;</span>
<span class="lineNum">   32777 </span>            :     default: break;
<span class="lineNum">   32778 </span>            :     }
<span class="lineNum">   32779 </span>            : 
<span class="lineNum">   32780 </span>            :   if (code != ERROR_MARK)
<span class="lineNum">   32781 </span>            :     cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   32782 </span>            :   else
<span class="lineNum">   32783 </span>            :     {
<span class="lineNum">   32784 </span>            :       bool saved_colon_corrects_to_scope_p;
<span class="lineNum">   32785 </span>            :       saved_colon_corrects_to_scope_p = parser-&gt;colon_corrects_to_scope_p;
<span class="lineNum">   32786 </span>            :       parser-&gt;colon_corrects_to_scope_p = false;
<span class="lineNum">   32787 </span>            :       id = cp_parser_id_expression (parser, /*template_p=*/false,
<span class="lineNum">   32788 </span>            :                                     /*check_dependency_p=*/true,
<span class="lineNum">   32789 </span>            :                                     /*template_p=*/NULL,
<span class="lineNum">   32790 </span>            :                                     /*declarator_p=*/false,
<span class="lineNum">   32791 </span>            :                                     /*optional_p=*/false);
<span class="lineNum">   32792 </span>            :       parser-&gt;colon_corrects_to_scope_p = saved_colon_corrects_to_scope_p;
<span class="lineNum">   32793 </span>            :       if (identifier_p (id))
<span class="lineNum">   32794 </span>            :         {
<span class="lineNum">   32795 </span>            :           const char *p = IDENTIFIER_POINTER (id);
<span class="lineNum">   32796 </span>            : 
<span class="lineNum">   32797 </span><span class="lineCov">       1394 :           if (strcmp (p, &quot;min&quot;) == 0)</span>
<span class="lineNum">   32798 </span>            :             code = MIN_EXPR;
<span class="lineNum">   32799 </span><span class="lineCov">       1394 :           else if (strcmp (p, &quot;max&quot;) == 0)</span>
<span class="lineNum">   32800 </span><span class="lineCov">       1394 :             code = MAX_EXPR;</span>
<span class="lineNum">   32801 </span>            :           else if (id == ovl_op_identifier (false, PLUS_EXPR))
<span class="lineNum">   32802 </span><span class="lineCov">       1394 :             code = PLUS_EXPR;</span>
<span class="lineNum">   32803 </span>            :           else if (id == ovl_op_identifier (false, MULT_EXPR))
<span class="lineNum">   32804 </span>            :             code = MULT_EXPR;
<span class="lineNum">   32805 </span><span class="lineCov">       1394 :           else if (id == ovl_op_identifier (false, MINUS_EXPR))</span>
<span class="lineNum">   32806 </span>            :             code = MINUS_EXPR;
<span class="lineNum">   32807 </span>            :           else if (id == ovl_op_identifier (false, BIT_AND_EXPR))
<span class="lineNum">   32808 </span><span class="lineCov">         94 :             code = BIT_AND_EXPR;</span>
<span class="lineNum">   32809 </span><span class="lineCov">          6 :           else if (id == ovl_op_identifier (false, BIT_IOR_EXPR))</span>
<span class="lineNum">   32810 </span><span class="lineCov">         32 :             code = BIT_IOR_EXPR;</span>
<span class="lineNum">   32811 </span><span class="lineCov">         16 :           else if (id == ovl_op_identifier (false, BIT_XOR_EXPR))</span>
<span class="lineNum">   32812 </span><span class="lineCov">         48 :             code = BIT_XOR_EXPR;</span>
<span class="lineNum">   32813 </span><span class="lineCov">         19 :           else if (id == ovl_op_identifier (false, TRUTH_ANDIF_EXPR))</span>
<span class="lineNum">   32814 </span><span class="lineCov">         20 :             code = TRUTH_ANDIF_EXPR;</span>
<span class="lineNum">   32815 </span>            :           else if (id == ovl_op_identifier (false, TRUTH_ORIF_EXPR))
<span class="lineNum">   32816 </span>            :             code = TRUTH_ORIF_EXPR;
<span class="lineNum">   32817 </span>            :           id = omp_reduction_id (code, id, NULL_TREE);
<span class="lineNum">   32818 </span><span class="lineCov">        235 :           tree scope = parser-&gt;scope;</span>
<span class="lineNum">   32819 </span><span class="lineCov">       1174 :           if (scope)</span>
<span class="lineNum">   32820 </span>            :             id = build_qualified_name (NULL_TREE, scope, id, false);
<span class="lineNum">   32821 </span>            :           parser-&gt;scope = NULL_TREE;
<span class="lineNum">   32822 </span><span class="lineCov">        220 :           parser-&gt;qualifying_scope = NULL_TREE;</span>
<span class="lineNum">   32823 </span><span class="lineCov">        220 :           parser-&gt;object_scope = NULL_TREE;</span>
<span class="lineNum">   32824 </span><span class="lineCov">        220 :         }</span>
<span class="lineNum">   32825 </span><span class="lineCov">        440 :       else</span>
<span class="lineNum">   32826 </span>            :         {
<span class="lineNum">   32827 </span>            :           error (&quot;invalid reduction-identifier&quot;);
<span class="lineNum">   32828 </span>            :          resync_fail:
<span class="lineNum">   32829 </span><span class="lineCov">        220 :           cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,</span>
<span class="lineNum">   32830 </span><span class="lineCov">        220 :                                                  /*or_comma=*/false,</span>
<span class="lineNum">   32831 </span><span class="lineCov">        220 :                                                  /*consume_paren=*/true);</span>
<span class="lineNum">   32832 </span>            :           return list;
<span class="lineNum">   32833 </span><span class="lineCov">        217 :         }</span>
<span class="lineNum">   32834 </span>            :     }
<span class="lineNum">   32835 </span><span class="lineCov">        217 : </span>
<span class="lineNum">   32836 </span>            :   if (!cp_parser_require (parser, CPP_COLON, RT_COLON))
<span class="lineNum">   32837 </span><span class="lineCov">        169 :     goto resync_fail;</span>
<span class="lineNum">   32838 </span>            : 
<span class="lineNum">   32839 </span><span class="lineCov">        111 :   nlist = cp_parser_omp_var_list_no_open (parser, OMP_CLAUSE_REDUCTION, list,</span>
<span class="lineNum">   32840 </span>            :                                           NULL);
<span class="lineNum">   32841 </span><span class="lineCov">         83 :   for (c = nlist; c != list; c = OMP_CLAUSE_CHAIN (c))</span>
<span class="lineNum">   32842 </span>            :     {
<span class="lineNum">   32843 </span><span class="lineCov">         83 :       OMP_CLAUSE_REDUCTION_CODE (c) = code;</span>
<span class="lineNum">   32844 </span>            :       OMP_CLAUSE_REDUCTION_PLACEHOLDER (c) = id;
<span class="lineNum">   32845 </span><span class="lineCov">         77 :     }</span>
<span class="lineNum">   32846 </span>            : 
<span class="lineNum">   32847 </span><span class="lineCov">         77 :   return nlist;</span>
<span class="lineNum">   32848 </span>            : }
<span class="lineNum">   32849 </span><span class="lineCov">         77 : </span>
<span class="lineNum">   32850 </span>            : /* OpenMP 2.5:
<span class="lineNum">   32851 </span><span class="lineCov">         77 :    schedule ( schedule-kind )</span>
<span class="lineNum">   32852 </span>            :    schedule ( schedule-kind , expression )
<span class="lineNum">   32853 </span><span class="lineCov">         77 : </span>
<span class="lineNum">   32854 </span><span class="lineNoCov">          0 :    schedule-kind:</span>
<span class="lineNum">   32855 </span><span class="lineCov">        217 :      static | dynamic | guided | runtime | auto</span>
<span class="lineNum">   32856 </span><span class="lineCov">        217 : </span>
<span class="lineNum">   32857 </span><span class="lineCov">        217 :    OpenMP 4.5:</span>
<span class="lineNum">   32858 </span><span class="lineCov">         45 :    schedule ( schedule-modifier : schedule-kind )</span>
<span class="lineNum">   32859 </span><span class="lineCov">        217 :    schedule ( schedule-modifier [ , schedule-modifier ] : schedule-kind , expression )</span>
<span class="lineNum">   32860 </span><span class="lineCov">        217 : </span>
<span class="lineNum">   32861 </span><span class="lineCov">        217 :    schedule-modifier:</span>
<span class="lineNum">   32862 </span>            :      simd
<span class="lineNum">   32863 </span>            :      monotonic
<span class="lineNum">   32864 </span>            :      nonmonotonic  */
<a name="32865"><span class="lineNum">   32865 </span><span class="lineCov">          3 : </span></a>
<span class="lineNum">   32866 </span><span class="lineCov">          3 : static tree</span>
<span class="lineNum">   32867 </span><span class="lineCov">          6 : cp_parser_omp_clause_schedule (cp_parser *parser, tree list, location_t location)</span>
<span class="lineNum">   32868 </span>            : {
<span class="lineNum">   32869 </span>            :   tree c, t;
<span class="lineNum">   32870 </span><span class="lineCov">          3 :   int modifiers = 0, nmodifiers = 0;</span>
<span class="lineNum">   32871 </span>            : 
<span class="lineNum">   32872 </span>            :   matching_parens parens;
<span class="lineNum">   32873 </span>            :   if (!parens.require_open (parser))
<span class="lineNum">   32874 </span><span class="lineCov">       1391 :     return list;</span>
<span class="lineNum">   32875 </span>            : 
<span class="lineNum">   32876 </span>            :   c = build_omp_clause (location, OMP_CLAUSE_SCHEDULE);
<span class="lineNum">   32877 </span><span class="lineCov">       1391 : </span>
<span class="lineNum">   32878 </span>            :   while (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))
<span class="lineNum">   32879 </span><span class="lineCov">       2971 :     {</span>
<span class="lineNum">   32880 </span>            :       tree id = cp_lexer_peek_token (parser-&gt;lexer)-&gt;u.value;
<span class="lineNum">   32881 </span><span class="lineCov">       1580 :       const char *p = IDENTIFIER_POINTER (id);</span>
<span class="lineNum">   32882 </span><span class="lineCov">       1580 :       if (strcmp (&quot;simd&quot;, p) == 0)</span>
<span class="lineNum">   32883 </span>            :         OMP_CLAUSE_SCHEDULE_SIMD (c) = 1;
<span class="lineNum">   32884 </span>            :       else if (strcmp (&quot;monotonic&quot;, p) == 0)
<span class="lineNum">   32885 </span>            :         modifiers |= OMP_CLAUSE_SCHEDULE_MONOTONIC;
<span class="lineNum">   32886 </span>            :       else if (strcmp (&quot;nonmonotonic&quot;, p) == 0)
<span class="lineNum">   32887 </span>            :         modifiers |= OMP_CLAUSE_SCHEDULE_NONMONOTONIC;
<span class="lineNum">   32888 </span>            :       else
<span class="lineNum">   32889 </span>            :         break;
<span class="lineNum">   32890 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   32891 </span>            :       if (nmodifiers++ == 0
<span class="lineNum">   32892 </span>            :           &amp;&amp; cp_lexer_next_token_is (parser-&gt;lexer, CPP_COMMA))
<span class="lineNum">   32893 </span>            :         cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   32894 </span>            :       else
<span class="lineNum">   32895 </span>            :         {
<span class="lineNum">   32896 </span>            :           cp_parser_require (parser, CPP_COLON, RT_COLON);
<span class="lineNum">   32897 </span>            :           break;
<span class="lineNum">   32898 </span>            :         }
<span class="lineNum">   32899 </span>            :     }
<span class="lineNum">   32900 </span>            : 
<span class="lineNum">   32901 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))
<span class="lineNum">   32902 </span>            :     {
<span class="lineNum">   32903 </span>            :       tree id = cp_lexer_peek_token (parser-&gt;lexer)-&gt;u.value;
<span class="lineNum">   32904 </span>            :       const char *p = IDENTIFIER_POINTER (id);
<span class="lineNum">   32905 </span><span class="lineCov">       1740 : </span>
<span class="lineNum">   32906 </span>            :       switch (p[0])
<span class="lineNum">   32907 </span><span class="lineCov">       1740 :         {</span>
<span class="lineNum">   32908 </span><span class="lineCov">       1740 :         case 'd':</span>
<span class="lineNum">   32909 </span>            :           if (strcmp (&quot;dynamic&quot;, p) != 0)
<span class="lineNum">   32910 </span><span class="lineCov">       3480 :             goto invalid_kind;</span>
<span class="lineNum">   32911 </span><span class="lineCov">       1740 :           OMP_CLAUSE_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_DYNAMIC;</span>
<span class="lineNum">   32912 </span>            :           break;
<span class="lineNum">   32913 </span>            : 
<span class="lineNum">   32914 </span><span class="lineCov">       1734 :         case 'g':</span>
<span class="lineNum">   32915 </span>            :           if (strcmp (&quot;guided&quot;, p) != 0)
<span class="lineNum">   32916 </span><span class="lineCov">       1775 :             goto invalid_kind;</span>
<span class="lineNum">   32917 </span>            :           OMP_CLAUSE_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_GUIDED;
<span class="lineNum">   32918 </span><span class="lineCov">       1820 :           break;</span>
<span class="lineNum">   32919 </span><span class="lineCov">        910 : </span>
<span class="lineNum">   32920 </span><span class="lineCov">        910 :         case 'r':</span>
<span class="lineNum">   32921 </span><span class="lineCov">         35 :           if (strcmp (&quot;runtime&quot;, p) != 0)</span>
<span class="lineNum">   32922 </span><span class="lineCov">        875 :             goto invalid_kind;</span>
<span class="lineNum">   32923 </span><span class="lineCov">         50 :           OMP_CLAUSE_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_RUNTIME;</span>
<span class="lineNum">   32924 </span><span class="lineCov">        825 :           break;</span>
<span class="lineNum">   32925 </span><span class="lineCov">         70 : </span>
<span class="lineNum">   32926 </span>            :         default:
<span class="lineNum">   32927 </span>            :           goto invalid_kind;
<span class="lineNum">   32928 </span><span class="lineCov">        155 :         }</span>
<span class="lineNum">   32929 </span><span class="lineCov">        155 :     }</span>
<span class="lineNum">   32930 </span><span class="lineCov">        155 :   else if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_STATIC))</span>
<span class="lineNum">   32931 </span><span class="lineCov">         41 :     OMP_CLAUSE_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_STATIC;</span>
<span class="lineNum">   32932 </span>            :   else if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_AUTO))
<span class="lineNum">   32933 </span>            :     OMP_CLAUSE_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_AUTO;
<span class="lineNum">   32934 </span><span class="lineCov">        114 :   else</span>
<span class="lineNum">   32935 </span><span class="lineCov">        114 :     goto invalid_kind;</span>
<span class="lineNum">   32936 </span>            :   cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   32937 </span>            : 
<span class="lineNum">   32938 </span>            :   if ((modifiers &amp; (OMP_CLAUSE_SCHEDULE_MONOTONIC
<span class="lineNum">   32939 </span><span class="lineCov">       1734 :                     | OMP_CLAUSE_SCHEDULE_NONMONOTONIC))</span>
<span class="lineNum">   32940 </span>            :       == (OMP_CLAUSE_SCHEDULE_MONOTONIC
<span class="lineNum">   32941 </span><span class="lineCov">       1652 :           | OMP_CLAUSE_SCHEDULE_NONMONOTONIC))</span>
<span class="lineNum">   32942 </span><span class="lineCov">        826 :     {</span>
<span class="lineNum">   32943 </span>            :       error_at (location, &quot;both %&lt;monotonic%&gt; and %&lt;nonmonotonic%&gt; modifiers &quot;
<span class="lineNum">   32944 </span><span class="lineCov">        826 :                           &quot;specified&quot;);</span>
<span class="lineNum">   32945 </span>            :       modifiers = 0;
<span class="lineNum">   32946 </span><span class="lineCov">        119 :     }</span>
<span class="lineNum">   32947 </span><span class="lineCov">        119 : </span>
<span class="lineNum">   32948 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_COMMA))
<span class="lineNum">   32949 </span><span class="lineCov">        119 :     {</span>
<span class="lineNum">   32950 </span><span class="lineCov">        119 :       cp_token *token;</span>
<span class="lineNum">   32951 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   32952 </span><span class="lineCov">        331 : </span>
<span class="lineNum">   32953 </span><span class="lineCov">        331 :       token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   32954 </span>            :       t = cp_parser_assignment_expression (parser);
<span class="lineNum">   32955 </span><span class="lineCov">        331 : </span>
<span class="lineNum">   32956 </span><span class="lineCov">        331 :       if (t == error_mark_node)</span>
<span class="lineNum">   32957 </span>            :         goto resync_fail;
<span class="lineNum">   32958 </span><span class="lineCov">        373 :       else if (OMP_CLAUSE_SCHEDULE_KIND (c) == OMP_CLAUSE_SCHEDULE_RUNTIME)</span>
<span class="lineNum">   32959 </span><span class="lineCov">        373 :         error_at (token-&gt;location, &quot;schedule %&lt;runtime%&gt; does not take &quot;</span>
<span class="lineNum">   32960 </span>            :                   &quot;a %&lt;chunk_size%&gt; parameter&quot;);
<span class="lineNum">   32961 </span><span class="lineCov">        373 :       else if (OMP_CLAUSE_SCHEDULE_KIND (c) == OMP_CLAUSE_SCHEDULE_AUTO)</span>
<span class="lineNum">   32962 </span><span class="lineCov">        373 :         error_at (token-&gt;location, &quot;schedule %&lt;auto%&gt; does not take &quot;</span>
<span class="lineNum">   32963 </span>            :                   &quot;a %&lt;chunk_size%&gt; parameter&quot;);
<span class="lineNum">   32964 </span>            :       else
<span class="lineNum">   32965 </span>            :         OMP_CLAUSE_SCHEDULE_CHUNK_EXPR (c) = t;
<span class="lineNum">   32966 </span>            : 
<span class="lineNum">   32967 </span>            :       if (!parens.require_close (parser))
<span class="lineNum">   32968 </span><span class="lineCov">        908 :         goto resync_fail;</span>
<span class="lineNum">   32969 </span><span class="lineCov">        626 :     }</span>
<span class="lineNum">   32970 </span><span class="lineCov">        282 :   else if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_COMMA_CLOSE_PAREN))</span>
<span class="lineNum">   32971 </span><span class="lineCov">        279 :     goto resync_fail;</span>
<span class="lineNum">   32972 </span>            : 
<span class="lineNum">   32973 </span>            :   OMP_CLAUSE_SCHEDULE_KIND (c)
<span class="lineNum">   32974 </span><span class="lineCov">       1728 :     = (enum omp_clause_schedule_kind)</span>
<span class="lineNum">   32975 </span>            :       (OMP_CLAUSE_SCHEDULE_KIND (c) | modifiers);
<span class="lineNum">   32976 </span><span class="lineCov">       1728 : </span>
<span class="lineNum">   32977 </span>            :   check_no_duplicate_clause (list, OMP_CLAUSE_SCHEDULE, &quot;schedule&quot;, location);
<span class="lineNum">   32978 </span>            :   OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   32979 </span>            :   return c;
<span class="lineNum">   32980 </span>            : 
<span class="lineNum">   32981 </span><span class="lineCov">          6 :  invalid_kind:</span>
<span class="lineNum">   32982 </span>            :   cp_parser_error (parser, &quot;invalid schedule kind&quot;);
<span class="lineNum">   32983 </span><span class="lineCov">          6 :  resync_fail:</span>
<span class="lineNum">   32984 </span>            :   cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,
<span class="lineNum">   32985 </span>            :                                          /*or_comma=*/false,
<span class="lineNum">   32986 </span><span class="lineCov">       1728 :                                          /*consume_paren=*/true);</span>
<span class="lineNum">   32987 </span>            :   return list;
<span class="lineNum">   32988 </span><span class="lineCov">        942 : }</span>
<span class="lineNum">   32989 </span><span class="lineCov">        942 : </span>
<span class="lineNum">   32990 </span>            : /* OpenMP 3.0:
<span class="lineNum">   32991 </span><span class="lineCov">       1884 :    untied */</span>
<a name="32992"><span class="lineNum">   32992 </span><span class="lineCov">        942 : </span></a>
<span class="lineNum">   32993 </span>            : static tree
<span class="lineNum">   32994 </span><span class="lineCov">        942 : cp_parser_omp_clause_untied (cp_parser * /*parser*/,</span>
<span class="lineNum">   32995 </span>            :                              tree list, location_t location)
<span class="lineNum">   32996 </span><span class="lineCov">        942 : {</span>
<span class="lineNum">   32997 </span><span class="lineCov">          3 :   tree c;</span>
<span class="lineNum">   32998 </span>            : 
<span class="lineNum">   32999 </span><span class="lineCov">        939 :   check_no_duplicate_clause (list, OMP_CLAUSE_UNTIED, &quot;untied&quot;, location);</span>
<span class="lineNum">   33000 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   33001 </span>            :   c = build_omp_clause (location, OMP_CLAUSE_UNTIED);
<span class="lineNum">   33002 </span>            :   OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   33003 </span><span class="lineCov">        939 :   return c;</span>
<span class="lineNum">   33004 </span>            : }
<span class="lineNum">   33005 </span><span class="lineCov">        942 : </span>
<span class="lineNum">   33006 </span>            : /* OpenMP 4.0:
<span class="lineNum">   33007 </span>            :    inbranch
<span class="lineNum">   33008 </span><span class="lineCov">        786 :    notinbranch */</span>
<a name="33009"><span class="lineNum">   33009 </span>            : </a>
<span class="lineNum">   33010 </span>            : static tree
<span class="lineNum">   33011 </span><span class="lineCov">       3432 : cp_parser_omp_clause_branch (cp_parser * /*parser*/, enum omp_clause_code code,</span>
<span class="lineNum">   33012 </span><span class="lineCov">       1716 :                              tree list, location_t location)</span>
<span class="lineNum">   33013 </span><span class="lineCov">       1716 : {</span>
<span class="lineNum">   33014 </span>            :   check_no_duplicate_clause (list, code, omp_clause_code_name[code], location);
<span class="lineNum">   33015 </span><span class="lineCov">       1716 :   tree c = build_omp_clause (location, code);</span>
<span class="lineNum">   33016 </span><span class="lineCov">       1716 :   OMP_CLAUSE_CHAIN (c) = list;</span>
<span class="lineNum">   33017 </span><span class="lineCov">       1716 :   return c;</span>
<span class="lineNum">   33018 </span>            : }
<span class="lineNum">   33019 </span><span class="lineCov">          6 : </span>
<span class="lineNum">   33020 </span><span class="lineCov">          6 : /* OpenMP 4.0:</span>
<span class="lineNum">   33021 </span><span class="lineCov">         18 :    parallel</span>
<span class="lineNum">   33022 </span><span class="lineCov">         36 :    for</span>
<span class="lineNum">   33023 </span>            :    sections
<span class="lineNum">   33024 </span>            :    taskgroup */
<a name="33025"><span class="lineNum">   33025 </span><span class="lineCov">         18 : </span></a>
<span class="lineNum">   33026 </span>            : static tree
<span class="lineNum">   33027 </span>            : cp_parser_omp_clause_cancelkind (cp_parser * /*parser*/,
<span class="lineNum">   33028 </span>            :                                  enum omp_clause_code code,
<span class="lineNum">   33029 </span>            :                                  tree list, location_t location)
<span class="lineNum">   33030 </span>            : {
<span class="lineNum">   33031 </span>            :   tree c = build_omp_clause (location, code);
<span class="lineNum">   33032 </span><span class="lineCov">          5 :   OMP_CLAUSE_CHAIN (c) = list;</span>
<span class="lineNum">   33033 </span>            :   return c;
<span class="lineNum">   33034 </span>            : }
<span class="lineNum">   33035 </span><span class="lineCov">          5 : </span>
<span class="lineNum">   33036 </span>            : /* OpenMP 4.5:
<span class="lineNum">   33037 </span><span class="lineCov">          5 :    nogroup */</span>
<a name="33038"><span class="lineNum">   33038 </span>            : </a>
<span class="lineNum">   33039 </span><span class="lineCov">          5 : static tree</span>
<span class="lineNum">   33040 </span><span class="lineCov">          5 : cp_parser_omp_clause_nogroup (cp_parser * /*parser*/,</span>
<span class="lineNum">   33041 </span><span class="lineCov">          5 :                               tree list, location_t location)</span>
<span class="lineNum">   33042 </span>            : {
<span class="lineNum">   33043 </span>            :   check_no_duplicate_clause (list, OMP_CLAUSE_NOGROUP, &quot;nogroup&quot;, location);
<span class="lineNum">   33044 </span>            :   tree c = build_omp_clause (location, OMP_CLAUSE_NOGROUP);
<span class="lineNum">   33045 </span>            :   OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   33046 </span>            :   return c;
<span class="lineNum">   33047 </span>            : }
<span class="lineNum">   33048 </span>            : 
<span class="lineNum">   33049 </span><span class="lineCov">        215 : /* OpenMP 4.5:</span>
<span class="lineNum">   33050 </span>            :    simd
<span class="lineNum">   33051 </span>            :    threads */
<a name="33052"><span class="lineNum">   33052 </span><span class="lineCov">        215 : </span></a>
<span class="lineNum">   33053 </span><span class="lineCov">        215 : static tree</span>
<span class="lineNum">   33054 </span><span class="lineCov">        215 : cp_parser_omp_clause_orderedkind (cp_parser * /*parser*/,</span>
<span class="lineNum">   33055 </span><span class="lineCov">        215 :                                   enum omp_clause_code code,</span>
<span class="lineNum">   33056 </span>            :                                   tree list, location_t location)
<span class="lineNum">   33057 </span>            : {
<span class="lineNum">   33058 </span>            :   check_no_duplicate_clause (list, code, omp_clause_code_name[code], location);
<span class="lineNum">   33059 </span>            :   tree c = build_omp_clause (location, code);
<span class="lineNum">   33060 </span>            :   OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   33061 </span>            :   return c;
<span class="lineNum">   33062 </span>            : }
<span class="lineNum">   33063 </span>            : 
<span class="lineNum">   33064 </span>            : /* OpenMP 4.0:
<span class="lineNum">   33065 </span><span class="lineCov">        816 :    num_teams ( expression ) */</span>
<a name="33066"><span class="lineNum">   33066 </span>            : </a>
<span class="lineNum">   33067 </span>            : static tree
<span class="lineNum">   33068 </span>            : cp_parser_omp_clause_num_teams (cp_parser *parser, tree list,
<span class="lineNum">   33069 </span><span class="lineCov">        816 :                                 location_t location)</span>
<span class="lineNum">   33070 </span><span class="lineCov">        816 : {</span>
<span class="lineNum">   33071 </span><span class="lineCov">        816 :   tree t, c;</span>
<span class="lineNum">   33072 </span>            : 
<span class="lineNum">   33073 </span>            :   matching_parens parens;
<span class="lineNum">   33074 </span>            :   if (!parens.require_open (parser))
<span class="lineNum">   33075 </span>            :     return list;
<span class="lineNum">   33076 </span>            : 
<span class="lineNum">   33077 </span>            :   t = cp_parser_expression (parser);
<span class="lineNum">   33078 </span><span class="lineCov">         11 : </span>
<span class="lineNum">   33079 </span>            :   if (t == error_mark_node
<span class="lineNum">   33080 </span>            :       || !parens.require_close (parser))
<span class="lineNum">   33081 </span><span class="lineCov">         11 :     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,</span>
<span class="lineNum">   33082 </span><span class="lineCov">         11 :                                            /*or_comma=*/false,</span>
<span class="lineNum">   33083 </span><span class="lineCov">         11 :                                            /*consume_paren=*/true);</span>
<span class="lineNum">   33084 </span><span class="lineCov">         11 : </span>
<span class="lineNum">   33085 </span>            :   check_no_duplicate_clause (list, OMP_CLAUSE_NUM_TEAMS,
<span class="lineNum">   33086 </span>            :                              &quot;num_teams&quot;, location);
<span class="lineNum">   33087 </span>            : 
<span class="lineNum">   33088 </span>            :   c = build_omp_clause (location, OMP_CLAUSE_NUM_TEAMS);
<span class="lineNum">   33089 </span>            :   OMP_CLAUSE_NUM_TEAMS_EXPR (c) = t;
<span class="lineNum">   33090 </span>            :   OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   33091 </span>            : 
<span class="lineNum">   33092 </span><span class="lineCov">        209 :   return c;</span>
<span class="lineNum">   33093 </span>            : }
<span class="lineNum">   33094 </span>            : 
<span class="lineNum">   33095 </span>            : /* OpenMP 4.0:
<span class="lineNum">   33096 </span><span class="lineCov">        209 :    thread_limit ( expression ) */</span>
<a name="33097"><span class="lineNum">   33097 </span><span class="lineCov">        209 : </span></a>
<span class="lineNum">   33098 </span><span class="lineCov">        209 : static tree</span>
<span class="lineNum">   33099 </span><span class="lineCov">        209 : cp_parser_omp_clause_thread_limit (cp_parser *parser, tree list,</span>
<span class="lineNum">   33100 </span>            :                                    location_t location)
<span class="lineNum">   33101 </span>            : {
<span class="lineNum">   33102 </span>            :   tree t, c;
<span class="lineNum">   33103 </span>            : 
<span class="lineNum">   33104 </span>            :   matching_parens parens;
<span class="lineNum">   33105 </span>            :   if (!parens.require_open (parser))
<span class="lineNum">   33106 </span><span class="lineCov">        184 :     return list;</span>
<span class="lineNum">   33107 </span>            : 
<span class="lineNum">   33108 </span>            :   t = cp_parser_expression (parser);
<span class="lineNum">   33109 </span><span class="lineCov">        184 : </span>
<span class="lineNum">   33110 </span>            :   if (t == error_mark_node
<span class="lineNum">   33111 </span><span class="lineCov">        368 :       || !parens.require_close (parser))</span>
<span class="lineNum">   33112 </span><span class="lineCov">        184 :     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,</span>
<span class="lineNum">   33113 </span>            :                                            /*or_comma=*/false,
<span class="lineNum">   33114 </span>            :                                            /*consume_paren=*/true);
<span class="lineNum">   33115 </span><span class="lineCov">        184 : </span>
<span class="lineNum">   33116 </span>            :   check_no_duplicate_clause (list, OMP_CLAUSE_THREAD_LIMIT,
<span class="lineNum">   33117 </span><span class="lineCov">        184 :                              &quot;thread_limit&quot;, location);</span>
<span class="lineNum">   33118 </span><span class="lineCov">        184 : </span>
<span class="lineNum">   33119 </span><span class="lineNoCov">          0 :   c = build_omp_clause (location, OMP_CLAUSE_THREAD_LIMIT);</span>
<span class="lineNum">   33120 </span>            :   OMP_CLAUSE_THREAD_LIMIT_EXPR (c) = t;
<span class="lineNum">   33121 </span>            :   OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   33122 </span>            : 
<span class="lineNum">   33123 </span><span class="lineCov">        184 :   return c;</span>
<span class="lineNum">   33124 </span>            : }
<span class="lineNum">   33125 </span>            : 
<span class="lineNum">   33126 </span><span class="lineCov">        184 : /* OpenMP 4.0:</span>
<span class="lineNum">   33127 </span><span class="lineCov">        184 :    aligned ( variable-list )</span>
<span class="lineNum">   33128 </span><span class="lineCov">        184 :    aligned ( variable-list : constant-expression )  */</span>
<a name="33129"><span class="lineNum">   33129 </span>            : </a>
<span class="lineNum">   33130 </span><span class="lineCov">        184 : static tree</span>
<span class="lineNum">   33131 </span>            : cp_parser_omp_clause_aligned (cp_parser *parser, tree list)
<span class="lineNum">   33132 </span>            : {
<span class="lineNum">   33133 </span>            :   tree nlist, c, alignment = NULL_TREE;
<span class="lineNum">   33134 </span>            :   bool colon;
<span class="lineNum">   33135 </span>            : 
<span class="lineNum">   33136 </span>            :   matching_parens parens;
<span class="lineNum">   33137 </span><span class="lineCov">        184 :   if (!parens.require_open (parser))</span>
<span class="lineNum">   33138 </span>            :     return list;
<span class="lineNum">   33139 </span>            : 
<span class="lineNum">   33140 </span><span class="lineCov">        184 :   nlist = cp_parser_omp_var_list_no_open (parser, OMP_CLAUSE_ALIGNED, list,</span>
<span class="lineNum">   33141 </span>            :                                           &amp;colon);
<span class="lineNum">   33142 </span><span class="lineCov">        368 : </span>
<span class="lineNum">   33143 </span><span class="lineCov">        184 :   if (colon)</span>
<span class="lineNum">   33144 </span>            :     {
<span class="lineNum">   33145 </span>            :       alignment = cp_parser_constant_expression (parser);
<span class="lineNum">   33146 </span><span class="lineCov">        184 : </span>
<span class="lineNum">   33147 </span>            :       if (!parens.require_close (parser))
<span class="lineNum">   33148 </span><span class="lineCov">        184 :         cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,</span>
<span class="lineNum">   33149 </span><span class="lineCov">        184 :                                                /*or_comma=*/false,</span>
<span class="lineNum">   33150 </span><span class="lineNoCov">          0 :                                                /*consume_paren=*/true);</span>
<span class="lineNum">   33151 </span>            : 
<span class="lineNum">   33152 </span>            :       if (alignment == error_mark_node)
<span class="lineNum">   33153 </span>            :         alignment = NULL_TREE;
<span class="lineNum">   33154 </span><span class="lineCov">        184 :     }</span>
<span class="lineNum">   33155 </span>            : 
<span class="lineNum">   33156 </span>            :   for (c = nlist; c != list; c = OMP_CLAUSE_CHAIN (c))
<span class="lineNum">   33157 </span><span class="lineCov">        184 :     OMP_CLAUSE_ALIGNED_ALIGNMENT (c) = alignment;</span>
<span class="lineNum">   33158 </span><span class="lineCov">        184 : </span>
<span class="lineNum">   33159 </span><span class="lineCov">        184 :   return nlist;</span>
<span class="lineNum">   33160 </span>            : }
<span class="lineNum">   33161 </span><span class="lineCov">        184 : </span>
<span class="lineNum">   33162 </span>            : /* OpenMP 4.0:
<span class="lineNum">   33163 </span>            :    linear ( variable-list )
<span class="lineNum">   33164 </span>            :    linear ( variable-list : expression )
<span class="lineNum">   33165 </span>            : 
<span class="lineNum">   33166 </span>            :    OpenMP 4.5:
<span class="lineNum">   33167 </span>            :    linear ( modifier ( variable-list ) )
<span class="lineNum">   33168 </span>            :    linear ( modifier ( variable-list ) : expression ) */
<a name="33169"><span class="lineNum">   33169 </span><span class="lineCov">        300 : </span></a>
<span class="lineNum">   33170 </span>            : static tree
<span class="lineNum">   33171 </span><span class="lineCov">        300 : cp_parser_omp_clause_linear (cp_parser *parser, tree list, </span>
<span class="lineNum">   33172 </span><span class="lineCov">        300 :                              bool declare_simd)</span>
<span class="lineNum">   33173 </span>            : {
<span class="lineNum">   33174 </span><span class="lineCov">        600 :   tree nlist, c, step = integer_one_node;</span>
<span class="lineNum">   33175 </span><span class="lineCov">        300 :   bool colon;</span>
<span class="lineNum">   33176 </span>            :   enum omp_clause_linear_kind kind = OMP_CLAUSE_LINEAR_DEFAULT;
<span class="lineNum">   33177 </span>            : 
<span class="lineNum">   33178 </span><span class="lineCov">        300 :   matching_parens parens;</span>
<span class="lineNum">   33179 </span>            :   if (!parens.require_open (parser))
<span class="lineNum">   33180 </span>            :     return list;
<span class="lineNum">   33181 </span><span class="lineCov">        300 : </span>
<span class="lineNum">   33182 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))
<span class="lineNum">   33183 </span><span class="lineCov">        270 :     {</span>
<span class="lineNum">   33184 </span>            :       tree id = cp_lexer_peek_token (parser-&gt;lexer)-&gt;u.value;
<span class="lineNum">   33185 </span><span class="lineCov">        270 :       const char *p = IDENTIFIER_POINTER (id);</span>
<span class="lineNum">   33186 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   33187 </span>            :       if (strcmp (&quot;ref&quot;, p) == 0)
<span class="lineNum">   33188 </span>            :         kind = OMP_CLAUSE_LINEAR_REF;
<span class="lineNum">   33189 </span>            :       else if (strcmp (&quot;val&quot;, p) == 0)
<span class="lineNum">   33190 </span><span class="lineCov">        270 :         kind = OMP_CLAUSE_LINEAR_VAL;</span>
<span class="lineNum">   33191 </span><span class="lineNoCov">          0 :       else if (strcmp (&quot;uval&quot;, p) == 0)</span>
<span class="lineNum">   33192 </span>            :         kind = OMP_CLAUSE_LINEAR_UVAL;
<span class="lineNum">   33193 </span>            :       if (cp_lexer_nth_token_is (parser-&gt;lexer, 2, CPP_OPEN_PAREN))
<span class="lineNum">   33194 </span><span class="lineCov">        636 :         cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   33195 </span><span class="lineCov">        336 :       else</span>
<span class="lineNum">   33196 </span>            :         kind = OMP_CLAUSE_LINEAR_DEFAULT;
<span class="lineNum">   33197 </span>            :     }
<span class="lineNum">   33198 </span>            : 
<span class="lineNum">   33199 </span>            :   if (kind == OMP_CLAUSE_LINEAR_DEFAULT)
<span class="lineNum">   33200 </span>            :     nlist = cp_parser_omp_var_list_no_open (parser, OMP_CLAUSE_LINEAR, list,
<span class="lineNum">   33201 </span>            :                                             &amp;colon);
<span class="lineNum">   33202 </span>            :   else
<span class="lineNum">   33203 </span>            :     {
<span class="lineNum">   33204 </span>            :       nlist = cp_parser_omp_var_list (parser, OMP_CLAUSE_LINEAR, list);
<span class="lineNum">   33205 </span>            :       colon = cp_lexer_next_token_is (parser-&gt;lexer, CPP_COLON);
<span class="lineNum">   33206 </span>            :       if (colon)
<span class="lineNum">   33207 </span>            :         cp_parser_require (parser, CPP_COLON, RT_COLON);
<span class="lineNum">   33208 </span>            :       else if (!parens.require_close (parser))
<span class="lineNum">   33209 </span><span class="lineCov">        787 :         cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,</span>
<span class="lineNum">   33210 </span>            :                                                /*or_comma=*/false,
<span class="lineNum">   33211 </span>            :                                                /*consume_paren=*/true);
<span class="lineNum">   33212 </span><span class="lineCov">        787 :     }</span>
<span class="lineNum">   33213 </span><span class="lineCov">        787 : </span>
<span class="lineNum">   33214 </span><span class="lineCov">        787 :   if (colon)</span>
<span class="lineNum">   33215 </span>            :     {
<span class="lineNum">   33216 </span><span class="lineCov">       1574 :       step = NULL_TREE;</span>
<span class="lineNum">   33217 </span><span class="lineCov">        787 :       if (declare_simd</span>
<span class="lineNum">   33218 </span>            :           &amp;&amp; cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME)
<span class="lineNum">   33219 </span>            :           &amp;&amp; cp_lexer_nth_token_is (parser-&gt;lexer, 2, CPP_CLOSE_PAREN))
<span class="lineNum">   33220 </span><span class="lineCov">        787 :         {</span>
<span class="lineNum">   33221 </span>            :           cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   33222 </span><span class="lineCov">       1490 :           cp_parser_parse_tentatively (parser);</span>
<span class="lineNum">   33223 </span><span class="lineCov">        745 :           step = cp_parser_id_expression (parser, /*template_p=*/false,</span>
<span class="lineNum">   33224 </span>            :                                           /*check_dependency_p=*/true,
<span class="lineNum">   33225 </span><span class="lineCov">        745 :                                           /*template_p=*/NULL,</span>
<span class="lineNum">   33226 </span>            :                                           /*declarator_p=*/false,
<span class="lineNum">   33227 </span><span class="lineCov">        691 :                                           /*optional_p=*/false);</span>
<span class="lineNum">   33228 </span>            :           if (step != error_mark_node)
<span class="lineNum">   33229 </span><span class="lineCov">        637 :             step = cp_parser_lookup_name_simple (parser, step, token-&gt;location);</span>
<span class="lineNum">   33230 </span><span class="lineCov">         51 :           if (step == error_mark_node)</span>
<span class="lineNum">   33231 </span><span class="lineCov">        745 :             {</span>
<span class="lineNum">   33232 </span><span class="lineCov">        159 :               step = NULL_TREE;</span>
<span class="lineNum">   33233 </span>            :               cp_parser_abort_tentative_parse (parser);
<span class="lineNum">   33234 </span>            :             }
<span class="lineNum">   33235 </span>            :           else if (!cp_parser_parse_definitely (parser))
<span class="lineNum">   33236 </span>            :             step = NULL_TREE;
<span class="lineNum">   33237 </span><span class="lineCov">        159 :         }</span>
<span class="lineNum">   33238 </span><span class="lineCov">        628 :       if (!step)</span>
<span class="lineNum">   33239 </span>            :         step = cp_parser_expression (parser);
<span class="lineNum">   33240 </span>            : 
<span class="lineNum">   33241 </span>            :       if (!parens.require_close (parser))
<span class="lineNum">   33242 </span><span class="lineCov">        159 :         cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,</span>
<span class="lineNum">   33243 </span><span class="lineCov">        318 :                                                /*or_comma=*/false,</span>
<span class="lineNum">   33244 </span><span class="lineCov">        159 :                                                /*consume_paren=*/true);</span>
<span class="lineNum">   33245 </span><span class="lineCov">        129 : </span>
<span class="lineNum">   33246 </span><span class="lineCov">         30 :       if (step == error_mark_node)</span>
<span class="lineNum">   33247 </span><span class="lineNoCov">          0 :         return list;</span>
<span class="lineNum">   33248 </span>            :     }
<span class="lineNum">   33249 </span>            : 
<span class="lineNum">   33250 </span>            :   for (c = nlist; c != list; c = OMP_CLAUSE_CHAIN (c))
<span class="lineNum">   33251 </span>            :     {
<span class="lineNum">   33252 </span><span class="lineCov">        787 :       OMP_CLAUSE_LINEAR_STEP (c) = step;</span>
<span class="lineNum">   33253 </span>            :       OMP_CLAUSE_LINEAR_KIND (c) = kind;
<span class="lineNum">   33254 </span><span class="lineCov">        626 :     }</span>
<span class="lineNum">   33255 </span><span class="lineCov">        626 : </span>
<span class="lineNum">   33256 </span><span class="lineCov">        316 :   return nlist;</span>
<span class="lineNum">   33257 </span><span class="lineCov">        665 : }</span>
<span class="lineNum">   33258 </span>            : 
<span class="lineNum">   33259 </span><span class="lineCov">         72 : /* OpenMP 4.0:</span>
<span class="lineNum">   33260 </span><span class="lineCov">         36 :    safelen ( constant-expression )  */</span>
<a name="33261"><span class="lineNum">   33261 </span><span class="lineCov">         72 : </span></a>
<span class="lineNum">   33262 </span>            : static tree
<span class="lineNum">   33263 </span>            : cp_parser_omp_clause_safelen (cp_parser *parser, tree list,
<span class="lineNum">   33264 </span>            :                               location_t location)
<span class="lineNum">   33265 </span><span class="lineCov">         36 : {</span>
<span class="lineNum">   33266 </span><span class="lineCov">         36 :   tree t, c;</span>
<span class="lineNum">   33267 </span><span class="lineCov">         36 : </span>
<span class="lineNum">   33268 </span><span class="lineCov">         36 :   matching_parens parens;</span>
<span class="lineNum">   33269 </span>            :   if (!parens.require_open (parser))
<span class="lineNum">   33270 </span><span class="lineNoCov">          0 :     return list;</span>
<span class="lineNum">   33271 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   33272 </span>            :   t = cp_parser_constant_expression (parser);
<span class="lineNum">   33273 </span><span class="lineCov">         36 : </span>
<span class="lineNum">   33274 </span>            :   if (t == error_mark_node
<span class="lineNum">   33275 </span>            :       || !parens.require_close (parser))
<span class="lineNum">   33276 </span><span class="lineCov">         36 :     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,</span>
<span class="lineNum">   33277 </span><span class="lineCov">        590 :                                            /*or_comma=*/false,</span>
<span class="lineNum">   33278 </span>            :                                            /*consume_paren=*/true);
<span class="lineNum">   33279 </span><span class="lineCov">        626 : </span>
<span class="lineNum">   33280 </span><span class="lineNoCov">          0 :   check_no_duplicate_clause (list, OMP_CLAUSE_SAFELEN, &quot;safelen&quot;, location);</span>
<span class="lineNum">   33281 </span>            : 
<span class="lineNum">   33282 </span>            :   c = build_omp_clause (location, OMP_CLAUSE_SAFELEN);
<span class="lineNum">   33283 </span>            :   OMP_CLAUSE_SAFELEN_EXPR (c) = t;
<span class="lineNum">   33284 </span><span class="lineCov">        626 :   OMP_CLAUSE_CHAIN (c) = list;</span>
<span class="lineNum">   33285 </span>            : 
<span class="lineNum">   33286 </span>            :   return c;
<span class="lineNum">   33287 </span>            : }
<span class="lineNum">   33288 </span><span class="lineCov">       1589 : </span>
<span class="lineNum">   33289 </span>            : /* OpenMP 4.0:
<span class="lineNum">   33290 </span><span class="lineCov">        814 :    simdlen ( constant-expression )  */</span>
<a name="33291"><span class="lineNum">   33291 </span><span class="lineCov">        814 : </span></a>
<span class="lineNum">   33292 </span>            : static tree
<span class="lineNum">   33293 </span>            : cp_parser_omp_clause_simdlen (cp_parser *parser, tree list,
<span class="lineNum">   33294 </span>            :                               location_t location)
<span class="lineNum">   33295 </span>            : {
<span class="lineNum">   33296 </span>            :   tree t, c;
<span class="lineNum">   33297 </span>            : 
<span class="lineNum">   33298 </span>            :   matching_parens parens;
<span class="lineNum">   33299 </span>            :   if (!parens.require_open (parser))
<span class="lineNum">   33300 </span>            :     return list;
<span class="lineNum">   33301 </span><span class="lineCov">        131 : </span>
<span class="lineNum">   33302 </span>            :   t = cp_parser_constant_expression (parser);
<span class="lineNum">   33303 </span>            : 
<span class="lineNum">   33304 </span><span class="lineCov">        131 :   if (t == error_mark_node</span>
<span class="lineNum">   33305 </span>            :       || !parens.require_close (parser))
<span class="lineNum">   33306 </span><span class="lineCov">        262 :     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,</span>
<span class="lineNum">   33307 </span><span class="lineCov">        131 :                                            /*or_comma=*/false,</span>
<span class="lineNum">   33308 </span>            :                                            /*consume_paren=*/true);
<span class="lineNum">   33309 </span>            : 
<span class="lineNum">   33310 </span><span class="lineCov">        131 :   check_no_duplicate_clause (list, OMP_CLAUSE_SIMDLEN, &quot;simdlen&quot;, location);</span>
<span class="lineNum">   33311 </span>            : 
<span class="lineNum">   33312 </span><span class="lineCov">        131 :   c = build_omp_clause (location, OMP_CLAUSE_SIMDLEN);</span>
<span class="lineNum">   33313 </span><span class="lineCov">        131 :   OMP_CLAUSE_SIMDLEN_EXPR (c) = t;</span>
<span class="lineNum">   33314 </span><span class="lineNoCov">          0 :   OMP_CLAUSE_CHAIN (c) = list;</span>
<span class="lineNum">   33315 </span>            : 
<span class="lineNum">   33316 </span>            :   return c;
<span class="lineNum">   33317 </span>            : }
<span class="lineNum">   33318 </span><span class="lineCov">        131 : </span>
<span class="lineNum">   33319 </span>            : /* OpenMP 4.5:
<span class="lineNum">   33320 </span><span class="lineCov">        131 :    vec:</span>
<span class="lineNum">   33321 </span><span class="lineCov">        131 :      identifier [+/- integer]</span>
<span class="lineNum">   33322 </span><span class="lineCov">        131 :      vec , identifier [+/- integer]</span>
<span class="lineNum">   33323 </span>            : */
<a name="33324"><span class="lineNum">   33324 </span><span class="lineCov">        131 : </span></a>
<span class="lineNum">   33325 </span>            : static tree
<span class="lineNum">   33326 </span>            : cp_parser_omp_clause_depend_sink (cp_parser *parser, location_t clause_loc,
<span class="lineNum">   33327 </span>            :                                   tree list)
<span class="lineNum">   33328 </span>            : {
<span class="lineNum">   33329 </span>            :   tree vec = NULL;
<span class="lineNum">   33330 </span>            : 
<span class="lineNum">   33331 </span><span class="lineCov">        183 :   if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_NAME))</span>
<span class="lineNum">   33332 </span>            :     {
<span class="lineNum">   33333 </span>            :       cp_parser_error (parser, &quot;expected identifier&quot;);
<span class="lineNum">   33334 </span><span class="lineCov">        183 :       return list;</span>
<span class="lineNum">   33335 </span>            :     }
<span class="lineNum">   33336 </span><span class="lineCov">        366 : </span>
<span class="lineNum">   33337 </span><span class="lineCov">        183 :   while (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))</span>
<span class="lineNum">   33338 </span>            :     {
<span class="lineNum">   33339 </span>            :       location_t id_loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">   33340 </span><span class="lineCov">        183 :       tree t, identifier = cp_parser_identifier (parser);</span>
<span class="lineNum">   33341 </span>            :       tree addend = NULL;
<span class="lineNum">   33342 </span><span class="lineCov">        183 : </span>
<span class="lineNum">   33343 </span><span class="lineCov">        183 :       if (identifier == error_mark_node)</span>
<span class="lineNum">   33344 </span><span class="lineNoCov">          0 :         t = error_mark_node;</span>
<span class="lineNum">   33345 </span>            :       else
<span class="lineNum">   33346 </span>            :         {
<span class="lineNum">   33347 </span>            :           t = cp_parser_lookup_name_simple
<span class="lineNum">   33348 </span><span class="lineCov">        183 :                 (parser, identifier,</span>
<span class="lineNum">   33349 </span>            :                  cp_lexer_peek_token (parser-&gt;lexer)-&gt;location);
<span class="lineNum">   33350 </span><span class="lineCov">        183 :           if (t == error_mark_node)</span>
<span class="lineNum">   33351 </span><span class="lineCov">        183 :             cp_parser_name_lookup_error (parser, identifier, t, NLE_NULL,</span>
<span class="lineNum">   33352 </span><span class="lineCov">        183 :                                          id_loc);</span>
<span class="lineNum">   33353 </span>            :         }
<span class="lineNum">   33354 </span><span class="lineCov">        183 : </span>
<span class="lineNum">   33355 </span>            :       bool neg = false;
<span class="lineNum">   33356 </span>            :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_MINUS))
<span class="lineNum">   33357 </span>            :         neg = true;
<span class="lineNum">   33358 </span>            :       else if (!cp_lexer_next_token_is (parser-&gt;lexer, CPP_PLUS))
<span class="lineNum">   33359 </span>            :         {
<span class="lineNum">   33360 </span>            :           addend = integer_zero_node;
<span class="lineNum">   33361 </span>            :           goto add_to_vector;
<span class="lineNum">   33362 </span>            :         }
<span class="lineNum">   33363 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   33364 </span><span class="lineCov">        110 : </span>
<span class="lineNum">   33365 </span>            :       if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_NUMBER))
<span class="lineNum">   33366 </span>            :         {
<span class="lineNum">   33367 </span><span class="lineCov">        110 :           cp_parser_error (parser, &quot;expected integer&quot;);</span>
<span class="lineNum">   33368 </span>            :           return list;
<span class="lineNum">   33369 </span><span class="lineCov">        110 :         }</span>
<span class="lineNum">   33370 </span>            : 
<span class="lineNum">   33371 </span><span class="lineNoCov">          0 :       addend = cp_lexer_peek_token (parser-&gt;lexer)-&gt;u.value;</span>
<span class="lineNum">   33372 </span><span class="lineNoCov">          0 :       if (TREE_CODE (addend) != INTEGER_CST)</span>
<span class="lineNum">   33373 </span>            :         {
<span class="lineNum">   33374 </span>            :           cp_parser_error (parser, &quot;expected integer&quot;);
<span class="lineNum">   33375 </span><span class="lineCov">        167 :           return list;</span>
<span class="lineNum">   33376 </span>            :         }
<span class="lineNum">   33377 </span><span class="lineCov">        334 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   33378 </span><span class="lineCov">        167 : </span>
<span class="lineNum">   33379 </span><span class="lineCov">        167 :     add_to_vector:</span>
<span class="lineNum">   33380 </span>            :       if (t != error_mark_node)
<span class="lineNum">   33381 </span><span class="lineCov">        167 :         {</span>
<span class="lineNum">   33382 </span>            :           vec = tree_cons (addend, t, vec);
<span class="lineNum">   33383 </span>            :           if (neg)
<span class="lineNum">   33384 </span>            :             OMP_CLAUSE_DEPEND_SINK_NEGATIVE (vec) = 1;
<span class="lineNum">   33385 </span><span class="lineCov">        167 :         }</span>
<span class="lineNum">   33386 </span><span class="lineCov">        334 : </span>
<span class="lineNum">   33387 </span><span class="lineCov">        167 :       if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_COMMA))</span>
<span class="lineNum">   33388 </span><span class="lineCov">        167 :         break;</span>
<span class="lineNum">   33389 </span><span class="lineCov">          6 : </span>
<span class="lineNum">   33390 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   33391 </span>            :     }
<span class="lineNum">   33392 </span>            : 
<span class="lineNum">   33393 </span><span class="lineCov">        167 :   if (cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN) &amp;&amp; vec)</span>
<span class="lineNum">   33394 </span><span class="lineCov">        167 :     {</span>
<span class="lineNum">   33395 </span>            :       tree u = build_omp_clause (clause_loc, OMP_CLAUSE_DEPEND);
<span class="lineNum">   33396 </span><span class="lineCov">         55 :       OMP_CLAUSE_DEPEND_KIND (u) = OMP_CLAUSE_DEPEND_SINK;</span>
<span class="lineNum">   33397 </span>            :       OMP_CLAUSE_DECL (u) = nreverse (vec);
<span class="lineNum">   33398 </span><span class="lineCov">         30 :       OMP_CLAUSE_CHAIN (u) = list;</span>
<span class="lineNum">   33399 </span><span class="lineCov">         30 :       return u;</span>
<span class="lineNum">   33400 </span>            :     }
<span class="lineNum">   33401 </span><span class="lineCov">        137 :   return list;</span>
<span class="lineNum">   33402 </span>            : }
<span class="lineNum">   33403 </span><span class="lineCov">        137 : </span>
<span class="lineNum">   33404 </span>            : /* OpenMP 4.0:
<span class="lineNum">   33405 </span><span class="lineNoCov">          0 :    depend ( depend-kind : variable-list )</span>
<span class="lineNum">   33406 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   33407 </span>            :    depend-kind:
<span class="lineNum">   33408 </span>            :      in | out | inout
<span class="lineNum">   33409 </span><span class="lineCov">        274 : </span>
<span class="lineNum">   33410 </span><span class="lineCov">        137 :    OpenMP 4.5:</span>
<span class="lineNum">   33411 </span>            :    depend ( source )
<span class="lineNum">   33412 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   33413 </span><span class="lineNoCov">          0 :    depend ( sink : vec ) */</span>
<a name="33414"><span class="lineNum">   33414 </span>            : </a>
<span class="lineNum">   33415 </span><span class="lineCov">        137 : static tree</span>
<span class="lineNum">   33416 </span>            : cp_parser_omp_clause_depend (cp_parser *parser, tree list, location_t loc)
<span class="lineNum">   33417 </span><span class="lineCov">        167 : {</span>
<span class="lineNum">   33418 </span><span class="lineCov">        167 :   tree nlist, c;</span>
<span class="lineNum">   33419 </span>            :   enum omp_clause_depend_kind kind = OMP_CLAUSE_DEPEND_INOUT;
<span class="lineNum">   33420 </span><span class="lineCov">        161 : </span>
<span class="lineNum">   33421 </span><span class="lineCov">        161 :   matching_parens parens;</span>
<span class="lineNum">   33422 </span><span class="lineCov">        109 :   if (!parens.require_open (parser))</span>
<span class="lineNum">   33423 </span>            :     return list;
<span class="lineNum">   33424 </span>            : 
<span class="lineNum">   33425 </span><span class="lineCov">        167 :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))</span>
<span class="lineNum">   33426 </span>            :     {
<span class="lineNum">   33427 </span>            :       tree id = cp_lexer_peek_token (parser-&gt;lexer)-&gt;u.value;
<span class="lineNum">   33428 </span><span class="lineCov">         57 :       const char *p = IDENTIFIER_POINTER (id);</span>
<span class="lineNum">   33429 </span>            : 
<span class="lineNum">   33430 </span>            :       if (strcmp (&quot;in&quot;, p) == 0)
<span class="lineNum">   33431 </span><span class="lineCov">        110 :         kind = OMP_CLAUSE_DEPEND_IN;</span>
<span class="lineNum">   33432 </span>            :       else if (strcmp (&quot;inout&quot;, p) == 0)
<span class="lineNum">   33433 </span><span class="lineCov">        107 :         kind = OMP_CLAUSE_DEPEND_INOUT;</span>
<span class="lineNum">   33434 </span><span class="lineCov">        107 :       else if (strcmp (&quot;out&quot;, p) == 0)</span>
<span class="lineNum">   33435 </span><span class="lineCov">        107 :         kind = OMP_CLAUSE_DEPEND_OUT;</span>
<span class="lineNum">   33436 </span><span class="lineCov">        107 :       else if (strcmp (&quot;source&quot;, p) == 0)</span>
<span class="lineNum">   33437 </span><span class="lineCov">        107 :         kind = OMP_CLAUSE_DEPEND_SOURCE;</span>
<span class="lineNum">   33438 </span>            :       else if (strcmp (&quot;sink&quot;, p) == 0)
<span class="lineNum">   33439 </span>            :         kind = OMP_CLAUSE_DEPEND_SINK;
<span class="lineNum">   33440 </span>            :       else
<span class="lineNum">   33441 </span>            :         goto invalid_kind;
<span class="lineNum">   33442 </span>            :     }
<span class="lineNum">   33443 </span>            :   else
<span class="lineNum">   33444 </span>            :     goto invalid_kind;
<span class="lineNum">   33445 </span>            : 
<span class="lineNum">   33446 </span>            :   cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   33447 </span>            : 
<span class="lineNum">   33448 </span>            :   if (kind == OMP_CLAUSE_DEPEND_SOURCE)
<span class="lineNum">   33449 </span>            :     {
<span class="lineNum">   33450 </span>            :       c = build_omp_clause (loc, OMP_CLAUSE_DEPEND);
<span class="lineNum">   33451 </span>            :       OMP_CLAUSE_DEPEND_KIND (c) = kind;
<span class="lineNum">   33452 </span>            :       OMP_CLAUSE_DECL (c) = NULL_TREE;
<span class="lineNum">   33453 </span>            :       OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   33454 </span><span class="lineCov">        602 :       if (!parens.require_close (parser))</span>
<span class="lineNum">   33455 </span>            :         cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,
<span class="lineNum">   33456 </span><span class="lineCov">        602 :                                                /*or_comma=*/false,</span>
<span class="lineNum">   33457 </span><span class="lineCov">        602 :                                                /*consume_paren=*/true);</span>
<span class="lineNum">   33458 </span>            :       return c;
<span class="lineNum">   33459 </span><span class="lineCov">       1204 :     }</span>
<span class="lineNum">   33460 </span><span class="lineCov">        602 : </span>
<span class="lineNum">   33461 </span>            :   if (!cp_parser_require (parser, CPP_COLON, RT_COLON))
<span class="lineNum">   33462 </span>            :     goto resync_fail;
<span class="lineNum">   33463 </span><span class="lineCov">        602 : </span>
<span class="lineNum">   33464 </span>            :   if (kind == OMP_CLAUSE_DEPEND_SINK)
<span class="lineNum">   33465 </span><span class="lineCov">       1204 :     nlist = cp_parser_omp_clause_depend_sink (parser, loc, list);</span>
<span class="lineNum">   33466 </span><span class="lineCov">        602 :   else</span>
<span class="lineNum">   33467 </span>            :     {
<span class="lineNum">   33468 </span><span class="lineCov">        602 :       nlist = cp_parser_omp_var_list_no_open (parser, OMP_CLAUSE_DEPEND,</span>
<span class="lineNum">   33469 </span>            :                                               list, NULL);
<span class="lineNum">   33470 </span><span class="lineCov">        500 : </span>
<span class="lineNum">   33471 </span>            :       for (c = nlist; c != list; c = OMP_CLAUSE_CHAIN (c))
<span class="lineNum">   33472 </span><span class="lineCov">        326 :         OMP_CLAUSE_DEPEND_KIND (c) = kind;</span>
<span class="lineNum">   33473 </span>            :     }
<span class="lineNum">   33474 </span><span class="lineCov">        200 :   return nlist;</span>
<span class="lineNum">   33475 </span>            : 
<span class="lineNum">   33476 </span><span class="lineCov">        110 :  invalid_kind:</span>
<span class="lineNum">   33477 </span>            :   cp_parser_error (parser, &quot;invalid depend kind&quot;);
<span class="lineNum">   33478 </span>            :  resync_fail:
<span class="lineNum">   33479 </span>            :   cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,
<span class="lineNum">   33480 </span>            :                                          /*or_comma=*/false,
<span class="lineNum">   33481 </span>            :                                          /*consume_paren=*/true);
<span class="lineNum">   33482 </span>            :   return list;
<span class="lineNum">   33483 </span>            : }
<span class="lineNum">   33484 </span><span class="lineCov">        602 : </span>
<span class="lineNum">   33485 </span>            : /* OpenMP 4.0:
<span class="lineNum">   33486 </span><span class="lineCov">        602 :    map ( map-kind : variable-list )</span>
<span class="lineNum">   33487 </span>            :    map ( variable-list )
<span class="lineNum">   33488 </span><span class="lineCov">         90 : </span>
<span class="lineNum">   33489 </span><span class="lineCov">         90 :    map-kind:</span>
<span class="lineNum">   33490 </span><span class="lineCov">         90 :      alloc | to | from | tofrom</span>
<span class="lineNum">   33491 </span><span class="lineCov">         90 : </span>
<span class="lineNum">   33492 </span><span class="lineCov">         90 :    OpenMP 4.5:</span>
<span class="lineNum">   33493 </span><span class="lineNoCov">          0 :    map-kind:</span>
<span class="lineNum">   33494 </span>            :      alloc | to | from | tofrom | release | delete
<span class="lineNum">   33495 </span>            : 
<span class="lineNum">   33496 </span><span class="lineCov">         90 :    map ( always [,] map-kind: variable-list ) */</span>
<a name="33497"><span class="lineNum">   33497 </span>            : </a>
<span class="lineNum">   33498 </span>            : static tree
<span class="lineNum">   33499 </span><span class="lineCov">        512 : cp_parser_omp_clause_map (cp_parser *parser, tree list)</span>
<span class="lineNum">   33500 </span>            : {
<span class="lineNum">   33501 </span>            :   tree nlist, c;
<span class="lineNum">   33502 </span><span class="lineCov">        512 :   enum gomp_map_kind kind = GOMP_MAP_TOFROM;</span>
<span class="lineNum">   33503 </span><span class="lineCov">        110 :   bool always = false;</span>
<span class="lineNum">   33504 </span>            : 
<span class="lineNum">   33505 </span>            :   if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))
<span class="lineNum">   33506 </span><span class="lineCov">        402 :     return list;</span>
<span class="lineNum">   33507 </span>            : 
<span class="lineNum">   33508 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))
<span class="lineNum">   33509 </span><span class="lineCov">        810 :     {</span>
<span class="lineNum">   33510 </span><span class="lineCov">        408 :       tree id = cp_lexer_peek_token (parser-&gt;lexer)-&gt;u.value;</span>
<span class="lineNum">   33511 </span>            :       const char *p = IDENTIFIER_POINTER (id);
<span class="lineNum">   33512 </span>            : 
<span class="lineNum">   33513 </span>            :       if (strcmp (&quot;always&quot;, p) == 0)
<span class="lineNum">   33514 </span><span class="lineNoCov">          0 :         {</span>
<span class="lineNum">   33515 </span><span class="lineNoCov">          0 :           int nth = 2;</span>
<span class="lineNum">   33516 </span><span class="lineNoCov">          0 :           if (cp_lexer_peek_nth_token (parser-&gt;lexer, 2)-&gt;type == CPP_COMMA)</span>
<span class="lineNum">   33517 </span><span class="lineNoCov">          0 :             nth++;</span>
<span class="lineNum">   33518 </span>            :           if ((cp_lexer_peek_nth_token (parser-&gt;lexer, nth)-&gt;type == CPP_NAME
<span class="lineNum">   33519 </span>            :                || (cp_lexer_peek_nth_token (parser-&gt;lexer, nth)-&gt;keyword
<span class="lineNum">   33520 </span><span class="lineNoCov">          0 :                    == RID_DELETE))</span>
<span class="lineNum">   33521 </span>            :               &amp;&amp; (cp_lexer_peek_nth_token (parser-&gt;lexer, nth + 1)-&gt;type
<span class="lineNum">   33522 </span>            :                   == CPP_COLON))
<span class="lineNum">   33523 </span>            :             {
<span class="lineNum">   33524 </span>            :               always = true;
<span class="lineNum">   33525 </span>            :               cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   33526 </span>            :               if (nth == 3)
<span class="lineNum">   33527 </span>            :                 cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   33528 </span>            :             }
<span class="lineNum">   33529 </span>            :         }
<span class="lineNum">   33530 </span>            :     }
<span class="lineNum">   33531 </span>            : 
<span class="lineNum">   33532 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME)
<span class="lineNum">   33533 </span>            :       &amp;&amp; cp_lexer_peek_nth_token (parser-&gt;lexer, 2)-&gt;type == CPP_COLON)
<span class="lineNum">   33534 </span>            :     {
<span class="lineNum">   33535 </span>            :       tree id = cp_lexer_peek_token (parser-&gt;lexer)-&gt;u.value;
<span class="lineNum">   33536 </span>            :       const char *p = IDENTIFIER_POINTER (id);
<span class="lineNum">   33537 </span><span class="lineCov">       1018 : </span>
<span class="lineNum">   33538 </span>            :       if (strcmp (&quot;alloc&quot;, p) == 0)
<span class="lineNum">   33539 </span><span class="lineCov">       1018 :         kind = GOMP_MAP_ALLOC;</span>
<span class="lineNum">   33540 </span><span class="lineCov">       1018 :       else if (strcmp (&quot;to&quot;, p) == 0)</span>
<span class="lineNum">   33541 </span><span class="lineCov">       1018 :         kind = always ? GOMP_MAP_ALWAYS_TO : GOMP_MAP_TO;</span>
<span class="lineNum">   33542 </span>            :       else if (strcmp (&quot;from&quot;, p) == 0)
<span class="lineNum">   33543 </span><span class="lineCov">       1018 :         kind = always ? GOMP_MAP_ALWAYS_FROM : GOMP_MAP_FROM;</span>
<span class="lineNum">   33544 </span>            :       else if (strcmp (&quot;tofrom&quot;, p) == 0)
<span class="lineNum">   33545 </span>            :         kind = always ? GOMP_MAP_ALWAYS_TOFROM : GOMP_MAP_TOFROM;
<span class="lineNum">   33546 </span><span class="lineCov">       1018 :       else if (strcmp (&quot;release&quot;, p) == 0)</span>
<span class="lineNum">   33547 </span>            :         kind = GOMP_MAP_RELEASE;
<span class="lineNum">   33548 </span><span class="lineCov">       2010 :       else</span>
<span class="lineNum">   33549 </span><span class="lineCov">       1005 :         {</span>
<span class="lineNum">   33550 </span>            :           cp_parser_error (parser, &quot;invalid map kind&quot;);
<span class="lineNum">   33551 </span><span class="lineCov">       1005 :           cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,</span>
<span class="lineNum">   33552 </span>            :                                                  /*or_comma=*/false,
<span class="lineNum">   33553 </span><span class="lineCov">         27 :                                                  /*consume_paren=*/true);</span>
<span class="lineNum">   33554 </span><span class="lineCov">         27 :           return list;</span>
<span class="lineNum">   33555 </span><span class="lineCov">         22 :         }</span>
<span class="lineNum">   33556 </span><span class="lineCov">         27 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   33557 </span><span class="lineCov">          2 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   33558 </span>            :     }
<span class="lineNum">   33559 </span><span class="lineCov">         29 :   else if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_DELETE)</span>
<span class="lineNum">   33560 </span>            :            &amp;&amp; cp_lexer_peek_nth_token (parser-&gt;lexer, 2)-&gt;type == CPP_COLON)
<span class="lineNum">   33561 </span>            :     {
<span class="lineNum">   33562 </span><span class="lineCov">         27 :       kind = GOMP_MAP_DELETE;</span>
<span class="lineNum">   33563 </span><span class="lineCov">         27 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   33564 </span><span class="lineCov">         27 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   33565 </span><span class="lineCov">         22 :     }</span>
<span class="lineNum">   33566 </span>            : 
<span class="lineNum">   33567 </span>            :   nlist = cp_parser_omp_var_list_no_open (parser, OMP_CLAUSE_MAP, list,
<span class="lineNum">   33568 </span>            :                                           NULL);
<span class="lineNum">   33569 </span>            : 
<span class="lineNum">   33570 </span><span class="lineCov">       2036 :   for (c = nlist; c != list; c = OMP_CLAUSE_CHAIN (c))</span>
<span class="lineNum">   33571 </span><span class="lineCov">       1018 :     OMP_CLAUSE_SET_MAP_KIND (c, kind);</span>
<span class="lineNum">   33572 </span>            : 
<span class="lineNum">   33573 </span><span class="lineCov">       1388 :   return nlist;</span>
<span class="lineNum">   33574 </span><span class="lineCov">        694 : }</span>
<span class="lineNum">   33575 </span>            : 
<span class="lineNum">   33576 </span><span class="lineCov">        694 : /* OpenMP 4.0:</span>
<span class="lineNum">   33577 </span>            :    device ( expression ) */
<a name="33578"><span class="lineNum">   33578 </span><span class="lineCov">        571 : </span></a>
<span class="lineNum">   33579 </span><span class="lineCov">        140 : static tree</span>
<span class="lineNum">   33580 </span><span class="lineCov">        431 : cp_parser_omp_clause_device (cp_parser *parser, tree list,</span>
<span class="lineNum">   33581 </span><span class="lineCov">        229 :                              location_t location)</span>
<span class="lineNum">   33582 </span><span class="lineCov">        202 : {</span>
<span class="lineNum">   33583 </span><span class="lineCov">        189 :   tree t, c;</span>
<span class="lineNum">   33584 </span><span class="lineCov">         13 : </span>
<span class="lineNum">   33585 </span>            :   matching_parens parens;
<span class="lineNum">   33586 </span>            :   if (!parens.require_open (parser))
<span class="lineNum">   33587 </span>            :     return list;
<span class="lineNum">   33588 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   33589 </span><span class="lineNoCov">          0 :   t = cp_parser_expression (parser);</span>
<span class="lineNum">   33590 </span>            : 
<span class="lineNum">   33591 </span>            :   if (t == error_mark_node
<span class="lineNum">   33592 </span><span class="lineNoCov">          0 :       || !parens.require_close (parser))</span>
<span class="lineNum">   33593 </span>            :     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,
<span class="lineNum">   33594 </span><span class="lineCov">        694 :                                            /*or_comma=*/false,</span>
<span class="lineNum">   33595 </span><span class="lineCov">        694 :                                            /*consume_paren=*/true);</span>
<span class="lineNum">   33596 </span>            : 
<span class="lineNum">   33597 </span><span class="lineCov">        648 :   check_no_duplicate_clause (list, OMP_CLAUSE_DEVICE,</span>
<span class="lineNum">   33598 </span><span class="lineCov">        324 :                              &quot;device&quot;, location);</span>
<span class="lineNum">   33599 </span>            : 
<span class="lineNum">   33600 </span><span class="lineCov">          3 :   c = build_omp_clause (location, OMP_CLAUSE_DEVICE);</span>
<span class="lineNum">   33601 </span><span class="lineCov">          3 :   OMP_CLAUSE_DEVICE_ID (c) = t;</span>
<span class="lineNum">   33602 </span><span class="lineCov">          3 :   OMP_CLAUSE_CHAIN (c) = list;</span>
<span class="lineNum">   33603 </span>            : 
<span class="lineNum">   33604 </span>            :   return c;
<span class="lineNum">   33605 </span><span class="lineCov">       1018 : }</span>
<span class="lineNum">   33606 </span>            : 
<span class="lineNum">   33607 </span>            : /* OpenMP 4.0:
<span class="lineNum">   33608 </span><span class="lineCov">       2385 :    dist_schedule ( static )</span>
<span class="lineNum">   33609 </span><span class="lineCov">       1367 :    dist_schedule ( static , expression )  */</span>
<a name="33610"><span class="lineNum">   33610 </span>            : </a>
<span class="lineNum">   33611 </span>            : static tree
<span class="lineNum">   33612 </span>            : cp_parser_omp_clause_dist_schedule (cp_parser *parser, tree list,
<span class="lineNum">   33613 </span>            :                                     location_t location)
<span class="lineNum">   33614 </span>            : {
<span class="lineNum">   33615 </span>            :   tree c, t;
<span class="lineNum">   33616 </span>            : 
<span class="lineNum">   33617 </span>            :   matching_parens parens;
<span class="lineNum">   33618 </span><span class="lineCov">        117 :   if (!parens.require_open (parser))</span>
<span class="lineNum">   33619 </span>            :     return list;
<span class="lineNum">   33620 </span>            : 
<span class="lineNum">   33621 </span><span class="lineCov">        117 :   c = build_omp_clause (location, OMP_CLAUSE_DIST_SCHEDULE);</span>
<span class="lineNum">   33622 </span>            : 
<span class="lineNum">   33623 </span><span class="lineCov">        234 :   if (!cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_STATIC))</span>
<span class="lineNum">   33624 </span><span class="lineCov">        117 :     goto invalid_kind;</span>
<span class="lineNum">   33625 </span>            :   cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   33626 </span>            : 
<span class="lineNum">   33627 </span><span class="lineCov">        117 :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_COMMA))</span>
<span class="lineNum">   33628 </span>            :     {
<span class="lineNum">   33629 </span><span class="lineCov">        117 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   33630 </span><span class="lineCov">        117 : </span>
<span class="lineNum">   33631 </span><span class="lineNoCov">          0 :       t = cp_parser_assignment_expression (parser);</span>
<span class="lineNum">   33632 </span>            : 
<span class="lineNum">   33633 </span>            :       if (t == error_mark_node)
<span class="lineNum">   33634 </span>            :         goto resync_fail;
<span class="lineNum">   33635 </span><span class="lineCov">        117 :       OMP_CLAUSE_DIST_SCHEDULE_CHUNK_EXPR (c) = t;</span>
<span class="lineNum">   33636 </span>            : 
<span class="lineNum">   33637 </span>            :       if (!parens.require_close (parser))
<span class="lineNum">   33638 </span><span class="lineCov">        117 :         goto resync_fail;</span>
<span class="lineNum">   33639 </span><span class="lineCov">        117 :     }</span>
<span class="lineNum">   33640 </span><span class="lineCov">        117 :   else if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_COMMA_CLOSE_PAREN))</span>
<span class="lineNum">   33641 </span>            :     goto resync_fail;
<span class="lineNum">   33642 </span><span class="lineCov">        117 : </span>
<span class="lineNum">   33643 </span>            :   check_no_duplicate_clause (list, OMP_CLAUSE_DIST_SCHEDULE, &quot;dist_schedule&quot;,
<span class="lineNum">   33644 </span>            :                              location);
<span class="lineNum">   33645 </span>            :   OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   33646 </span>            :   return c;
<span class="lineNum">   33647 </span>            : 
<span class="lineNum">   33648 </span>            :  invalid_kind:
<span class="lineNum">   33649 </span>            :   cp_parser_error (parser, &quot;invalid dist_schedule kind&quot;);
<span class="lineNum">   33650 </span><span class="lineCov">        670 :  resync_fail:</span>
<span class="lineNum">   33651 </span>            :   cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,
<span class="lineNum">   33652 </span>            :                                          /*or_comma=*/false,
<span class="lineNum">   33653 </span><span class="lineCov">        670 :                                          /*consume_paren=*/true);</span>
<span class="lineNum">   33654 </span>            :   return list;
<span class="lineNum">   33655 </span><span class="lineCov">       1340 : }</span>
<span class="lineNum">   33656 </span><span class="lineCov">        670 : </span>
<span class="lineNum">   33657 </span>            : /* OpenMP 4.0:
<span class="lineNum">   33658 </span>            :    proc_bind ( proc-bind-kind )
<span class="lineNum">   33659 </span><span class="lineCov">        670 : </span>
<span class="lineNum">   33660 </span>            :    proc-bind-kind:
<span class="lineNum">   33661 </span><span class="lineCov">        670 :      master | close | spread  */</span>
<a name="33662"><span class="lineNum">   33662 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   33663 </span><span class="lineCov">        670 : static tree</span>
<span class="lineNum">   33664 </span>            : cp_parser_omp_clause_proc_bind (cp_parser *parser, tree list,
<span class="lineNum">   33665 </span><span class="lineCov">        670 :                                 location_t location)</span>
<span class="lineNum">   33666 </span>            : {
<span class="lineNum">   33667 </span><span class="lineCov">        670 :   tree c;</span>
<span class="lineNum">   33668 </span>            :   enum omp_clause_proc_bind_kind kind;
<span class="lineNum">   33669 </span><span class="lineCov">        670 : </span>
<span class="lineNum">   33670 </span>            :   if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))
<span class="lineNum">   33671 </span><span class="lineCov">        670 :     return list;</span>
<span class="lineNum">   33672 </span>            : 
<span class="lineNum">   33673 </span><span class="lineCov">        670 :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))</span>
<span class="lineNum">   33674 </span>            :     {
<span class="lineNum">   33675 </span><span class="lineCov">        670 :       tree id = cp_lexer_peek_token (parser-&gt;lexer)-&gt;u.value;</span>
<span class="lineNum">   33676 </span>            :       const char *p = IDENTIFIER_POINTER (id);
<span class="lineNum">   33677 </span>            : 
<span class="lineNum">   33678 </span><span class="lineNoCov">          0 :       if (strcmp (&quot;master&quot;, p) == 0)</span>
<span class="lineNum">   33679 </span>            :         kind = OMP_CLAUSE_PROC_BIND_MASTER;
<span class="lineNum">   33680 </span>            :       else if (strcmp (&quot;close&quot;, p) == 0)
<span class="lineNum">   33681 </span><span class="lineCov">        670 :         kind = OMP_CLAUSE_PROC_BIND_CLOSE;</span>
<span class="lineNum">   33682 </span>            :       else if (strcmp (&quot;spread&quot;, p) == 0)
<span class="lineNum">   33683 </span><span class="lineCov">        670 :         kind = OMP_CLAUSE_PROC_BIND_SPREAD;</span>
<span class="lineNum">   33684 </span><span class="lineCov">        670 :       else</span>
<span class="lineNum">   33685 </span>            :         goto invalid_kind;
<span class="lineNum">   33686 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   33687 </span><span class="lineNoCov">          0 :   else</span>
<span class="lineNum">   33688 </span><span class="lineNoCov">          0 :     goto invalid_kind;</span>
<span class="lineNum">   33689 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   33690 </span>            :   cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   33691 </span>            :   if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_COMMA_CLOSE_PAREN))
<span class="lineNum">   33692 </span><span class="lineNoCov">          0 :     goto resync_fail;</span>
<span class="lineNum">   33693 </span>            : 
<span class="lineNum">   33694 </span>            :   c = build_omp_clause (location, OMP_CLAUSE_PROC_BIND);
<span class="lineNum">   33695 </span>            :   check_no_duplicate_clause (list, OMP_CLAUSE_PROC_BIND, &quot;proc_bind&quot;,
<span class="lineNum">   33696 </span>            :                              location);
<span class="lineNum">   33697 </span>            :   OMP_CLAUSE_PROC_BIND_KIND (c) = kind;
<span class="lineNum">   33698 </span>            :   OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   33699 </span>            :   return c;
<span class="lineNum">   33700 </span>            : 
<span class="lineNum">   33701 </span>            :  invalid_kind:
<span class="lineNum">   33702 </span><span class="lineCov">        108 :   cp_parser_error (parser, &quot;invalid depend kind&quot;);</span>
<span class="lineNum">   33703 </span>            :  resync_fail:
<span class="lineNum">   33704 </span>            :   cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,
<span class="lineNum">   33705 </span><span class="lineCov">        108 :                                          /*or_comma=*/false,</span>
<span class="lineNum">   33706 </span><span class="lineCov">        108 :                                          /*consume_paren=*/true);</span>
<span class="lineNum">   33707 </span>            :   return list;
<span class="lineNum">   33708 </span><span class="lineCov">        108 : }</span>
<span class="lineNum">   33709 </span>            : 
<span class="lineNum">   33710 </span>            : /* OpenACC:
<span class="lineNum">   33711 </span><span class="lineCov">        108 :    async [( int-expr )] */</span>
<a name="33712"><span class="lineNum">   33712 </span>            : </a>
<span class="lineNum">   33713 </span><span class="lineCov">        216 : static tree</span>
<span class="lineNum">   33714 </span><span class="lineCov">        108 : cp_parser_oacc_clause_async (cp_parser *parser, tree list)</span>
<span class="lineNum">   33715 </span>            : {
<span class="lineNum">   33716 </span><span class="lineCov">        108 :   tree c, t;</span>
<span class="lineNum">   33717 </span>            :   location_t loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">   33718 </span><span class="lineCov">         78 : </span>
<span class="lineNum">   33719 </span>            :   t = build_int_cst (integer_type_node, GOMP_ASYNC_NOVAL);
<span class="lineNum">   33720 </span><span class="lineCov">         67 : </span>
<span class="lineNum">   33721 </span>            :   if (cp_lexer_peek_token (parser-&gt;lexer)-&gt;type == CPP_OPEN_PAREN)
<span class="lineNum">   33722 </span>            :     {
<span class="lineNum">   33723 </span>            :       matching_parens parens;
<span class="lineNum">   33724 </span>            :       parens.consume_open (parser);
<span class="lineNum">   33725 </span>            : 
<span class="lineNum">   33726 </span>            :       t = cp_parser_expression (parser);
<span class="lineNum">   33727 </span>            :       if (t == error_mark_node
<span class="lineNum">   33728 </span><span class="lineCov">        108 :           || !parens.require_close (parser))</span>
<span class="lineNum">   33729 </span><span class="lineCov">        108 :         cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,</span>
<span class="lineNum">   33730 </span>            :                                                 /*or_comma=*/false,
<span class="lineNum">   33731 </span>            :                                                 /*consume_paren=*/true);
<span class="lineNum">   33732 </span><span class="lineCov">        108 :     }</span>
<span class="lineNum">   33733 </span><span class="lineCov">        108 : </span>
<span class="lineNum">   33734 </span>            :   check_no_duplicate_clause (list, OMP_CLAUSE_ASYNC, &quot;async&quot;, loc);
<span class="lineNum">   33735 </span><span class="lineCov">        108 : </span>
<span class="lineNum">   33736 </span><span class="lineCov">        108 :   c = build_omp_clause (loc, OMP_CLAUSE_ASYNC);</span>
<span class="lineNum">   33737 </span><span class="lineCov">        108 :   OMP_CLAUSE_ASYNC_EXPR (c) = t;</span>
<span class="lineNum">   33738 </span>            :   OMP_CLAUSE_CHAIN (c) = list;
<span class="lineNum">   33739 </span><span class="lineNoCov">          0 :   list = c;</span>
<span class="lineNum">   33740 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   33741 </span><span class="lineNoCov">          0 :   return list;</span>
<span class="lineNum">   33742 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   33743 </span>            : 
<span class="lineNum">   33744 </span>            : /* Parse all OpenACC clauses.  The set clauses allowed by the directive
<span class="lineNum">   33745 </span><span class="lineNoCov">          0 :    is a bitmask in MASK.  Return the list of clauses found.  */</span>
<a name="33746"><span class="lineNum">   33746 </span>            : </a>
<span class="lineNum">   33747 </span>            : static tree
<span class="lineNum">   33748 </span>            : cp_parser_oacc_all_clauses (cp_parser *parser, omp_clause_mask mask,
<span class="lineNum">   33749 </span>            :                            const char *where, cp_token *pragma_tok,
<span class="lineNum">   33750 </span>            :                            bool finish_p = true)
<span class="lineNum">   33751 </span>            : {
<span class="lineNum">   33752 </span><span class="lineCov">        274 :   tree clauses = NULL;</span>
<span class="lineNum">   33753 </span>            :   bool first = true;
<span class="lineNum">   33754 </span><span class="lineCov">        274 : </span>
<span class="lineNum">   33755 </span><span class="lineCov">        548 :   while (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_PRAGMA_EOL))</span>
<span class="lineNum">   33756 </span>            :     {
<span class="lineNum">   33757 </span><span class="lineCov">        548 :       location_t here;</span>
<span class="lineNum">   33758 </span>            :       pragma_omp_clause c_kind;
<span class="lineNum">   33759 </span><span class="lineCov">        274 :       omp_clause_code code;</span>
<span class="lineNum">   33760 </span>            :       const char *c_name;
<span class="lineNum">   33761 </span><span class="lineCov">        360 :       tree prev = clauses;</span>
<span class="lineNum">   33762 </span><span class="lineCov">        180 : </span>
<span class="lineNum">   33763 </span>            :       if (!first &amp;&amp; cp_lexer_next_token_is (parser-&gt;lexer, CPP_COMMA))
<span class="lineNum">   33764 </span><span class="lineCov">        180 :         cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   33765 </span><span class="lineCov">        180 : </span>
<span class="lineNum">   33766 </span><span class="lineCov">        180 :       here = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;</span>
<span class="lineNum">   33767 </span><span class="lineCov">         54 :       c_kind = cp_parser_omp_clause_name (parser);</span>
<span class="lineNum">   33768 </span>            : 
<span class="lineNum">   33769 </span>            :       switch (c_kind)
<span class="lineNum">   33770 </span>            :         {
<span class="lineNum">   33771 </span>            :         case PRAGMA_OACC_CLAUSE_ASYNC:
<span class="lineNum">   33772 </span><span class="lineCov">        274 :           clauses = cp_parser_oacc_clause_async (parser, clauses);</span>
<span class="lineNum">   33773 </span>            :           c_name = &quot;async&quot;;
<span class="lineNum">   33774 </span><span class="lineCov">        274 :           break;</span>
<span class="lineNum">   33775 </span><span class="lineCov">        274 :         case PRAGMA_OACC_CLAUSE_AUTO:</span>
<span class="lineNum">   33776 </span><span class="lineCov">        274 :           clauses = cp_parser_oacc_simple_clause (parser, OMP_CLAUSE_AUTO,</span>
<span class="lineNum">   33777 </span><span class="lineCov">        274 :                                                  clauses, here);</span>
<span class="lineNum">   33778 </span>            :           c_name = &quot;auto&quot;;
<span class="lineNum">   33779 </span><span class="lineCov">        274 :           break;</span>
<span class="lineNum">   33780 </span>            :         case PRAGMA_OACC_CLAUSE_COLLAPSE:
<span class="lineNum">   33781 </span>            :           clauses = cp_parser_omp_clause_collapse (parser, clauses, here);
<span class="lineNum">   33782 </span>            :           c_name = &quot;collapse&quot;;
<span class="lineNum">   33783 </span>            :           break;
<span class="lineNum">   33784 </span>            :         case PRAGMA_OACC_CLAUSE_COPY:
<span class="lineNum">   33785 </span>            :           clauses = cp_parser_oacc_data_clause (parser, c_kind, clauses);
<span class="lineNum">   33786 </span><span class="lineCov">       5976 :           c_name = &quot;copy&quot;;</span>
<span class="lineNum">   33787 </span>            :           break;
<span class="lineNum">   33788 </span>            :         case PRAGMA_OACC_CLAUSE_COPYIN:
<span class="lineNum">   33789 </span>            :           clauses = cp_parser_oacc_data_clause (parser, c_kind, clauses);
<span class="lineNum">   33790 </span><span class="lineCov">       5976 :           c_name = &quot;copyin&quot;;</span>
<span class="lineNum">   33791 </span><span class="lineCov">       5976 :           break;</span>
<span class="lineNum">   33792 </span>            :         case PRAGMA_OACC_CLAUSE_COPYOUT:
<span class="lineNum">   33793 </span><span class="lineCov">      13229 :           clauses = cp_parser_oacc_data_clause (parser, c_kind, clauses);</span>
<span class="lineNum">   33794 </span>            :           c_name = &quot;copyout&quot;;
<span class="lineNum">   33795 </span><span class="lineCov">       7280 :           break;</span>
<span class="lineNum">   33796 </span><span class="lineCov">       7280 :         case PRAGMA_OACC_CLAUSE_CREATE:</span>
<span class="lineNum">   33797 </span><span class="lineCov">       7280 :           clauses = cp_parser_oacc_data_clause (parser, c_kind, clauses);</span>
<span class="lineNum">   33798 </span><span class="lineCov">       7280 :           c_name = &quot;create&quot;;</span>
<span class="lineNum">   33799 </span><span class="lineCov">       7280 :           break;</span>
<span class="lineNum">   33800 </span>            :         case PRAGMA_OACC_CLAUSE_DELETE:
<span class="lineNum">   33801 </span><span class="lineCov">       7280 :           clauses = cp_parser_oacc_data_clause (parser, c_kind, clauses);</span>
<span class="lineNum">   33802 </span><span class="lineNoCov">          0 :           c_name = &quot;delete&quot;;</span>
<span class="lineNum">   33803 </span>            :           break;
<span class="lineNum">   33804 </span><span class="lineCov">      14560 :         case PRAGMA_OMP_CLAUSE_DEFAULT:</span>
<span class="lineNum">   33805 </span><span class="lineCov">       7280 :           clauses = cp_parser_omp_clause_default (parser, clauses, here, true);</span>
<span class="lineNum">   33806 </span>            :           c_name = &quot;default&quot;;
<span class="lineNum">   33807 </span><span class="lineCov">       7280 :           break;</span>
<span class="lineNum">   33808 </span>            :         case PRAGMA_OACC_CLAUSE_DEVICE:
<span class="lineNum">   33809 </span><span class="lineCov">        274 :           clauses = cp_parser_oacc_data_clause (parser, c_kind, clauses);</span>
<span class="lineNum">   33810 </span><span class="lineCov">        274 :           c_name = &quot;device&quot;;</span>
<span class="lineNum">   33811 </span><span class="lineCov">        274 :           break;</span>
<span class="lineNum">   33812 </span><span class="lineCov">        274 :         case PRAGMA_OACC_CLAUSE_DEVICEPTR:</span>
<span class="lineNum">   33813 </span><span class="lineCov">        247 :           clauses = cp_parser_oacc_data_clause_deviceptr (parser, clauses);</span>
<span class="lineNum">   33814 </span><span class="lineCov">        247 :           c_name = &quot;deviceptr&quot;;</span>
<span class="lineNum">   33815 </span>            :           break;
<span class="lineNum">   33816 </span><span class="lineCov">        247 :         case PRAGMA_OACC_CLAUSE_DEVICE_RESIDENT:</span>
<span class="lineNum">   33817 </span><span class="lineCov">        247 :           clauses = cp_parser_oacc_data_clause (parser, c_kind, clauses);</span>
<span class="lineNum">   33818 </span><span class="lineCov">         19 :           c_name = &quot;device_resident&quot;;</span>
<span class="lineNum">   33819 </span><span class="lineCov">         19 :           break;</span>
<span class="lineNum">   33820 </span><span class="lineCov">         19 :         case PRAGMA_OACC_CLAUSE_FINALIZE:</span>
<span class="lineNum">   33821 </span><span class="lineCov">         19 :           clauses = cp_parser_oacc_simple_clause (parser, OMP_CLAUSE_FINALIZE,</span>
<span class="lineNum">   33822 </span><span class="lineCov">        720 :                                                   clauses, here);</span>
<span class="lineNum">   33823 </span><span class="lineCov">        720 :           c_name = &quot;finalize&quot;;</span>
<span class="lineNum">   33824 </span><span class="lineCov">        720 :           break;</span>
<span class="lineNum">   33825 </span><span class="lineCov">        720 :         case PRAGMA_OACC_CLAUSE_FIRSTPRIVATE:</span>
<span class="lineNum">   33826 </span><span class="lineCov">        425 :           clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_FIRSTPRIVATE,</span>
<span class="lineNum">   33827 </span><span class="lineCov">        425 :                                             clauses);</span>
<span class="lineNum">   33828 </span><span class="lineCov">        425 :           c_name = &quot;firstprivate&quot;;</span>
<span class="lineNum">   33829 </span><span class="lineCov">        425 :           break;</span>
<span class="lineNum">   33830 </span><span class="lineCov">        392 :         case PRAGMA_OACC_CLAUSE_GANG:</span>
<span class="lineNum">   33831 </span><span class="lineCov">        392 :           c_name = &quot;gang&quot;;</span>
<span class="lineNum">   33832 </span><span class="lineCov">        392 :           clauses = cp_parser_oacc_shape_clause (parser, OMP_CLAUSE_GANG,</span>
<span class="lineNum">   33833 </span><span class="lineCov">        392 :                                                  c_name, clauses);</span>
<span class="lineNum">   33834 </span><span class="lineCov">        165 :           break;</span>
<span class="lineNum">   33835 </span><span class="lineCov">        165 :         case PRAGMA_OACC_CLAUSE_HOST:</span>
<span class="lineNum">   33836 </span><span class="lineCov">        165 :           clauses = cp_parser_oacc_data_clause (parser, c_kind, clauses);</span>
<span class="lineNum">   33837 </span><span class="lineCov">        165 :           c_name = &quot;host&quot;;</span>
<span class="lineNum">   33838 </span><span class="lineCov">         90 :           break;</span>
<span class="lineNum">   33839 </span><span class="lineCov">         90 :         case PRAGMA_OACC_CLAUSE_IF:</span>
<span class="lineNum">   33840 </span><span class="lineCov">         90 :           clauses = cp_parser_omp_clause_if (parser, clauses, here, false);</span>
<span class="lineNum">   33841 </span><span class="lineCov">         90 :           c_name = &quot;if&quot;;</span>
<span class="lineNum">   33842 </span><span class="lineCov">        119 :           break;</span>
<span class="lineNum">   33843 </span><span class="lineCov">        119 :         case PRAGMA_OACC_CLAUSE_IF_PRESENT:</span>
<span class="lineNum">   33844 </span><span class="lineCov">        119 :           clauses = cp_parser_oacc_simple_clause (parser,</span>
<span class="lineNum">   33845 </span><span class="lineCov">        119 :                                                   OMP_CLAUSE_IF_PRESENT,</span>
<span class="lineNum">   33846 </span><span class="lineCov">         43 :                                                   clauses, here);</span>
<span class="lineNum">   33847 </span><span class="lineCov">         43 :           c_name = &quot;if_present&quot;;</span>
<span class="lineNum">   33848 </span><span class="lineCov">         43 :           break;</span>
<span class="lineNum">   33849 </span><span class="lineCov">         43 :         case PRAGMA_OACC_CLAUSE_INDEPENDENT:</span>
<span class="lineNum">   33850 </span><span class="lineCov">         71 :           clauses = cp_parser_oacc_simple_clause (parser,</span>
<span class="lineNum">   33851 </span><span class="lineCov">         71 :                                                   OMP_CLAUSE_INDEPENDENT,</span>
<span class="lineNum">   33852 </span><span class="lineCov">         71 :                                                   clauses, here);</span>
<span class="lineNum">   33853 </span><span class="lineCov">         71 :           c_name = &quot;independent&quot;;</span>
<span class="lineNum">   33854 </span><span class="lineCov">         19 :           break;</span>
<span class="lineNum">   33855 </span><span class="lineCov">         19 :         case PRAGMA_OACC_CLAUSE_LINK:</span>
<span class="lineNum">   33856 </span><span class="lineCov">         19 :           clauses = cp_parser_oacc_data_clause (parser, c_kind, clauses);</span>
<span class="lineNum">   33857 </span><span class="lineCov">         19 :           c_name = &quot;link&quot;;</span>
<span class="lineNum">   33858 </span><span class="lineCov">         18 :           break;</span>
<span class="lineNum">   33859 </span><span class="lineCov">         18 :         case PRAGMA_OACC_CLAUSE_NUM_GANGS:</span>
<span class="lineNum">   33860 </span>            :           code = OMP_CLAUSE_NUM_GANGS;
<span class="lineNum">   33861 </span><span class="lineCov">         18 :           c_name = &quot;num_gangs&quot;;</span>
<span class="lineNum">   33862 </span><span class="lineCov">         18 :           clauses = cp_parser_oacc_single_int_clause (parser, code, c_name,</span>
<span class="lineNum">   33863 </span><span class="lineCov">         37 :                                                       clauses);</span>
<span class="lineNum">   33864 </span><span class="lineCov">         37 :           break;</span>
<span class="lineNum">   33865 </span>            :         case PRAGMA_OACC_CLAUSE_NUM_WORKERS:
<span class="lineNum">   33866 </span><span class="lineCov">         37 :           c_name = &quot;num_workers&quot;;</span>
<span class="lineNum">   33867 </span><span class="lineCov">         37 :           code = OMP_CLAUSE_NUM_WORKERS;</span>
<span class="lineNum">   33868 </span><span class="lineCov">        731 :           clauses = cp_parser_oacc_single_int_clause (parser, code, c_name,</span>
<span class="lineNum">   33869 </span><span class="lineCov">        731 :                                                       clauses);</span>
<span class="lineNum">   33870 </span><span class="lineCov">        731 :           break;</span>
<span class="lineNum">   33871 </span>            :         case PRAGMA_OACC_CLAUSE_PRESENT:
<span class="lineNum">   33872 </span><span class="lineCov">        731 :           clauses = cp_parser_oacc_data_clause (parser, c_kind, clauses);</span>
<span class="lineNum">   33873 </span><span class="lineCov">        116 :           c_name = &quot;present&quot;;</span>
<span class="lineNum">   33874 </span><span class="lineCov">        116 :           break;</span>
<span class="lineNum">   33875 </span><span class="lineCov">        116 :         case PRAGMA_OACC_CLAUSE_PRIVATE:</span>
<span class="lineNum">   33876 </span><span class="lineCov">        116 :           clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_PRIVATE,</span>
<span class="lineNum">   33877 </span><span class="lineCov">        119 :                                             clauses);</span>
<span class="lineNum">   33878 </span><span class="lineCov">        119 :           c_name = &quot;private&quot;;</span>
<span class="lineNum">   33879 </span><span class="lineCov">        119 :           break;</span>
<span class="lineNum">   33880 </span><span class="lineCov">        119 :         case PRAGMA_OACC_CLAUSE_REDUCTION:</span>
<span class="lineNum">   33881 </span><span class="lineCov">         36 :           clauses = cp_parser_omp_clause_reduction (parser, clauses);</span>
<span class="lineNum">   33882 </span><span class="lineCov">         36 :           c_name = &quot;reduction&quot;;</span>
<span class="lineNum">   33883 </span>            :           break;
<span class="lineNum">   33884 </span>            :         case PRAGMA_OACC_CLAUSE_SEQ:
<span class="lineNum">   33885 </span><span class="lineCov">         36 :           clauses = cp_parser_oacc_simple_clause (parser, OMP_CLAUSE_SEQ,</span>
<span class="lineNum">   33886 </span><span class="lineCov">         36 :                                                  clauses, here);</span>
<span class="lineNum">   33887 </span><span class="lineCov">         30 :           c_name = &quot;seq&quot;;</span>
<span class="lineNum">   33888 </span><span class="lineCov">         30 :           break;</span>
<span class="lineNum">   33889 </span>            :         case PRAGMA_OACC_CLAUSE_TILE:
<span class="lineNum">   33890 </span>            :           clauses = cp_parser_oacc_clause_tile (parser, here, clauses);
<span class="lineNum">   33891 </span><span class="lineCov">         30 :           c_name = &quot;tile&quot;;</span>
<span class="lineNum">   33892 </span><span class="lineCov">         30 :           break;</span>
<span class="lineNum">   33893 </span><span class="lineCov">         27 :         case PRAGMA_OACC_CLAUSE_USE_DEVICE:</span>
<span class="lineNum">   33894 </span><span class="lineCov">         27 :           clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_USE_DEVICE_PTR,</span>
<span class="lineNum">   33895 </span><span class="lineCov">         27 :                                             clauses);</span>
<span class="lineNum">   33896 </span><span class="lineCov">         27 :           c_name = &quot;use_device&quot;;</span>
<span class="lineNum">   33897 </span><span class="lineCov">        399 :           break;</span>
<span class="lineNum">   33898 </span><span class="lineCov">        399 :         case PRAGMA_OACC_CLAUSE_VECTOR:</span>
<span class="lineNum">   33899 </span><span class="lineCov">        399 :           c_name = &quot;vector&quot;;</span>
<span class="lineNum">   33900 </span><span class="lineCov">        399 :           clauses = cp_parser_oacc_shape_clause (parser, OMP_CLAUSE_VECTOR,</span>
<span class="lineNum">   33901 </span>            :                                                  c_name, clauses);
<span class="lineNum">   33902 </span><span class="lineCov">        399 :           break;</span>
<span class="lineNum">   33903 </span><span class="lineCov">        293 :         case PRAGMA_OACC_CLAUSE_VECTOR_LENGTH:</span>
<span class="lineNum">   33904 </span><span class="lineCov">        293 :           c_name = &quot;vector_length&quot;;</span>
<span class="lineNum">   33905 </span><span class="lineCov">        293 :           code = OMP_CLAUSE_VECTOR_LENGTH;</span>
<span class="lineNum">   33906 </span><span class="lineCov">        293 :           clauses = cp_parser_oacc_single_int_clause (parser, code, c_name,</span>
<span class="lineNum">   33907 </span>            :                                                       clauses);
<span class="lineNum">   33908 </span><span class="lineCov">        293 :           break;</span>
<span class="lineNum">   33909 </span><span class="lineCov">        156 :         case PRAGMA_OACC_CLAUSE_WAIT:</span>
<span class="lineNum">   33910 </span><span class="lineCov">        156 :           clauses = cp_parser_oacc_clause_wait (parser, clauses);</span>
<span class="lineNum">   33911 </span><span class="lineCov">        156 :           c_name = &quot;wait&quot;;</span>
<span class="lineNum">   33912 </span><span class="lineCov">        156 :           break;</span>
<span class="lineNum">   33913 </span><span class="lineCov">         67 :         case PRAGMA_OACC_CLAUSE_WORKER:</span>
<span class="lineNum">   33914 </span><span class="lineCov">         67 :           c_name = &quot;worker&quot;;</span>
<span class="lineNum">   33915 </span>            :           clauses = cp_parser_oacc_shape_clause (parser, OMP_CLAUSE_WORKER,
<span class="lineNum">   33916 </span><span class="lineCov">         67 :                                                  c_name, clauses);</span>
<span class="lineNum">   33917 </span><span class="lineCov">         67 :           break;</span>
<span class="lineNum">   33918 </span><span class="lineCov">        465 :         default:</span>
<span class="lineNum">   33919 </span><span class="lineCov">        465 :           cp_parser_error (parser, &quot;expected %&lt;#pragma acc%&gt; clause&quot;);</span>
<span class="lineNum">   33920 </span><span class="lineCov">        465 :           goto saw_error;</span>
<span class="lineNum">   33921 </span><span class="lineCov">        465 :         }</span>
<span class="lineNum">   33922 </span><span class="lineCov">        261 : </span>
<span class="lineNum">   33923 </span><span class="lineCov">        261 :       first = false;</span>
<span class="lineNum">   33924 </span>            : 
<span class="lineNum">   33925 </span><span class="lineCov">        261 :       if (((mask &gt;&gt; c_kind) &amp; 1) == 0)</span>
<span class="lineNum">   33926 </span><span class="lineCov">        261 :         {</span>
<span class="lineNum">   33927 </span><span class="lineCov">        311 :           /* Remove the invalid clause(s) from the list to avoid</span>
<span class="lineNum">   33928 </span><span class="lineCov">        311 :              confusing the rest of the compiler.  */</span>
<span class="lineNum">   33929 </span><span class="lineCov">        311 :           clauses = prev;</span>
<span class="lineNum">   33930 </span><span class="lineCov">        311 :           error_at (here, &quot;%qs is not valid for %qs&quot;, c_name, where);</span>
<span class="lineNum">   33931 </span><span class="lineCov">         33 :         }</span>
<span class="lineNum">   33932 </span><span class="lineCov">         33 :     }</span>
<span class="lineNum">   33933 </span>            : 
<span class="lineNum">   33934 </span><span class="lineCov">         33 :  saw_error:</span>
<span class="lineNum">   33935 </span><span class="lineCov">         33 :   cp_parser_skip_to_pragma_eol (parser, pragma_tok);</span>
<span class="lineNum">   33936 </span><span class="lineCov">        620 : </span>
<span class="lineNum">   33937 </span><span class="lineCov">        620 :   if (finish_p)</span>
<span class="lineNum">   33938 </span><span class="lineCov">        620 :     return finish_omp_clauses (clauses, C_ORT_ACC);</span>
<span class="lineNum">   33939 </span>            : 
<span class="lineNum">   33940 </span><span class="lineCov">        620 :   return clauses;</span>
<span class="lineNum">   33941 </span><span class="lineCov">        301 : }</span>
<span class="lineNum">   33942 </span><span class="lineCov">        301 : </span>
<span class="lineNum">   33943 </span><span class="lineCov">        301 : /* Parse all OpenMP clauses.  The set clauses allowed by the directive</span>
<span class="lineNum">   33944 </span><span class="lineCov">        301 :    is a bitmask in MASK.  Return the list of clauses found; the result</span>
<span class="lineNum">   33945 </span>            :    of clause default goes in *pdefault.  */
<a name="33946"><span class="lineNum">   33946 </span><span class="lineCov">        301 : </span></a>
<span class="lineNum">   33947 </span><span class="lineCov">        104 : static tree</span>
<span class="lineNum">   33948 </span><span class="lineCov">        104 : cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,</span>
<span class="lineNum">   33949 </span>            :                            const char *where, cp_token *pragma_tok,
<span class="lineNum">   33950 </span>            :                            bool finish_p = true)
<span class="lineNum">   33951 </span><span class="lineCov">        545 : {</span>
<span class="lineNum">   33952 </span><span class="lineCov">        545 :   tree clauses = NULL;</span>
<span class="lineNum">   33953 </span><span class="lineCov">        545 :   bool first = true;</span>
<span class="lineNum">   33954 </span>            :   cp_token *token = NULL;
<span class="lineNum">   33955 </span><span class="lineCov">        545 : </span>
<span class="lineNum">   33956 </span><span class="lineCov">         27 :   while (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_PRAGMA_EOL))</span>
<span class="lineNum">   33957 </span><span class="lineCov">         27 :     {</span>
<span class="lineNum">   33958 </span><span class="lineCov">         27 :       pragma_omp_clause c_kind;</span>
<span class="lineNum">   33959 </span>            :       const char *c_name;
<span class="lineNum">   33960 </span>            :       tree prev = clauses;
<span class="lineNum">   33961 </span><span class="lineCov">       7253 : </span>
<span class="lineNum">   33962 </span>            :       if (!first &amp;&amp; cp_lexer_next_token_is (parser-&gt;lexer, CPP_COMMA))
<span class="lineNum">   33963 </span><span class="lineCov">      21759 :         cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   33964 </span>            : 
<span class="lineNum">   33965 </span>            :       token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   33966 </span>            :       c_kind = cp_parser_omp_clause_name (parser);
<span class="lineNum">   33967 </span><span class="lineCov">         27 : </span>
<span class="lineNum">   33968 </span><span class="lineCov">         27 :       switch (c_kind)</span>
<span class="lineNum">   33969 </span>            :         {
<span class="lineNum">   33970 </span>            :         case PRAGMA_OMP_CLAUSE_COLLAPSE:
<span class="lineNum">   33971 </span>            :           clauses = cp_parser_omp_clause_collapse (parser, clauses,
<span class="lineNum">   33972 </span><span class="lineCov">       5949 :                                                    token-&gt;location);</span>
<span class="lineNum">   33973 </span><span class="lineCov">       5976 :           c_name = &quot;collapse&quot;;</span>
<span class="lineNum">   33974 </span>            :           break;
<span class="lineNum">   33975 </span><span class="lineCov">       5976 :         case PRAGMA_OMP_CLAUSE_COPYIN:</span>
<span class="lineNum">   33976 </span><span class="lineCov">       5210 :           clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_COPYIN, clauses);</span>
<span class="lineNum">   33977 </span>            :           c_name = &quot;copyin&quot;;
<span class="lineNum">   33978 </span>            :           break;
<span class="lineNum">   33979 </span>            :         case PRAGMA_OMP_CLAUSE_COPYPRIVATE:
<span class="lineNum">   33980 </span>            :           clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_COPYPRIVATE,
<span class="lineNum">   33981 </span>            :                                             clauses);
<span class="lineNum">   33982 </span>            :           c_name = &quot;copyprivate&quot;;
<span class="lineNum">   33983 </span>            :           break;
<span class="lineNum">   33984 </span>            :         case PRAGMA_OMP_CLAUSE_DEFAULT:
<span class="lineNum">   33985 </span>            :           clauses = cp_parser_omp_clause_default (parser, clauses,
<span class="lineNum">   33986 </span><span class="lineCov">      11980 :                                                   token-&gt;location, false);</span>
<span class="lineNum">   33987 </span>            :           c_name = &quot;default&quot;;
<span class="lineNum">   33988 </span>            :           break;
<span class="lineNum">   33989 </span>            :         case PRAGMA_OMP_CLAUSE_FINAL:
<span class="lineNum">   33990 </span><span class="lineCov">      11980 :           clauses = cp_parser_omp_clause_final (parser, clauses, token-&gt;location);</span>
<span class="lineNum">   33991 </span><span class="lineCov">      11980 :           c_name = &quot;final&quot;;</span>
<span class="lineNum">   33992 </span><span class="lineCov">      11980 :           break;</span>
<span class="lineNum">   33993 </span>            :         case PRAGMA_OMP_CLAUSE_FIRSTPRIVATE:
<span class="lineNum">   33994 </span><span class="lineCov">      26413 :           clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_FIRSTPRIVATE,</span>
<span class="lineNum">   33995 </span>            :                                             clauses);
<span class="lineNum">   33996 </span><span class="lineCov">      14454 :           c_name = &quot;firstprivate&quot;;</span>
<span class="lineNum">   33997 </span><span class="lineCov">      14454 :           break;</span>
<span class="lineNum">   33998 </span><span class="lineCov">      14454 :         case PRAGMA_OMP_CLAUSE_GRAINSIZE:</span>
<span class="lineNum">   33999 </span>            :           clauses = cp_parser_omp_clause_grainsize (parser, clauses,
<span class="lineNum">   34000 </span><span class="lineCov">      14454 :                                                     token-&gt;location);</span>
<span class="lineNum">   34001 </span><span class="lineCov">         69 :           c_name = &quot;grainsize&quot;;</span>
<span class="lineNum">   34002 </span>            :           break;
<span class="lineNum">   34003 </span><span class="lineCov">      28908 :         case PRAGMA_OMP_CLAUSE_HINT:</span>
<span class="lineNum">   34004 </span><span class="lineCov">      14454 :           clauses = cp_parser_omp_clause_hint (parser, clauses,</span>
<span class="lineNum">   34005 </span>            :                                                token-&gt;location);
<span class="lineNum">   34006 </span><span class="lineCov">      14454 :           c_name = &quot;hint&quot;;</span>
<span class="lineNum">   34007 </span>            :           break;
<span class="lineNum">   34008 </span><span class="lineCov">       1422 :         case PRAGMA_OMP_CLAUSE_DEFAULTMAP:</span>
<span class="lineNum">   34009 </span><span class="lineCov">       1422 :           clauses = cp_parser_omp_clause_defaultmap (parser, clauses,</span>
<span class="lineNum">   34010 </span>            :                                                      token-&gt;location);
<span class="lineNum">   34011 </span><span class="lineCov">       1422 :           c_name = &quot;defaultmap&quot;;</span>
<span class="lineNum">   34012 </span><span class="lineCov">       1422 :           break;</span>
<span class="lineNum">   34013 </span><span class="lineCov">         49 :         case PRAGMA_OMP_CLAUSE_USE_DEVICE_PTR:</span>
<span class="lineNum">   34014 </span><span class="lineCov">         49 :           clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_USE_DEVICE_PTR,</span>
<span class="lineNum">   34015 </span><span class="lineCov">         49 :                                             clauses);</span>
<span class="lineNum">   34016 </span><span class="lineCov">         49 :           c_name = &quot;use_device_ptr&quot;;</span>
<span class="lineNum">   34017 </span><span class="lineCov">         62 :           break;</span>
<span class="lineNum">   34018 </span><span class="lineCov">         62 :         case PRAGMA_OMP_CLAUSE_IS_DEVICE_PTR:</span>
<span class="lineNum">   34019 </span>            :           clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_IS_DEVICE_PTR,
<span class="lineNum">   34020 </span><span class="lineCov">         62 :                                             clauses);</span>
<span class="lineNum">   34021 </span><span class="lineCov">         62 :           c_name = &quot;is_device_ptr&quot;;</span>
<span class="lineNum">   34022 </span><span class="lineCov">        260 :           break;</span>
<span class="lineNum">   34023 </span><span class="lineCov">        260 :         case PRAGMA_OMP_CLAUSE_IF:</span>
<span class="lineNum">   34024 </span>            :           clauses = cp_parser_omp_clause_if (parser, clauses, token-&gt;location,
<span class="lineNum">   34025 </span><span class="lineCov">        260 :                                              true);</span>
<span class="lineNum">   34026 </span><span class="lineCov">        260 :           c_name = &quot;if&quot;;</span>
<span class="lineNum">   34027 </span><span class="lineCov">         22 :           break;</span>
<span class="lineNum">   34028 </span><span class="lineCov">         22 :         case PRAGMA_OMP_CLAUSE_LASTPRIVATE:</span>
<span class="lineNum">   34029 </span><span class="lineCov">         22 :           clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_LASTPRIVATE,</span>
<span class="lineNum">   34030 </span><span class="lineCov">         22 :                                             clauses);</span>
<span class="lineNum">   34031 </span><span class="lineCov">        518 :           c_name = &quot;lastprivate&quot;;</span>
<span class="lineNum">   34032 </span><span class="lineCov">        518 :           break;</span>
<span class="lineNum">   34033 </span>            :         case PRAGMA_OMP_CLAUSE_MERGEABLE:
<span class="lineNum">   34034 </span><span class="lineCov">        518 :           clauses = cp_parser_omp_clause_mergeable (parser, clauses,</span>
<span class="lineNum">   34035 </span><span class="lineCov">        518 :                                                     token-&gt;location);</span>
<span class="lineNum">   34036 </span><span class="lineCov">          6 :           c_name = &quot;mergeable&quot;;</span>
<span class="lineNum">   34037 </span><span class="lineCov">          6 :           break;</span>
<span class="lineNum">   34038 </span>            :         case PRAGMA_OMP_CLAUSE_NOWAIT:
<span class="lineNum">   34039 </span><span class="lineCov">          6 :           clauses = cp_parser_omp_clause_nowait (parser, clauses, token-&gt;location);</span>
<span class="lineNum">   34040 </span><span class="lineCov">          6 :           c_name = &quot;nowait&quot;;</span>
<span class="lineNum">   34041 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   34042 </span><span class="lineNoCov">          0 :         case PRAGMA_OMP_CLAUSE_NUM_TASKS:</span>
<span class="lineNum">   34043 </span>            :           clauses = cp_parser_omp_clause_num_tasks (parser, clauses,
<span class="lineNum">   34044 </span><span class="lineNoCov">          0 :                                                     token-&gt;location);</span>
<span class="lineNum">   34045 </span><span class="lineNoCov">          0 :           c_name = &quot;num_tasks&quot;;</span>
<span class="lineNum">   34046 </span><span class="lineCov">         40 :           break;</span>
<span class="lineNum">   34047 </span><span class="lineCov">         40 :         case PRAGMA_OMP_CLAUSE_NUM_THREADS:</span>
<span class="lineNum">   34048 </span>            :           clauses = cp_parser_omp_clause_num_threads (parser, clauses,
<span class="lineNum">   34049 </span><span class="lineCov">         40 :                                                       token-&gt;location);</span>
<span class="lineNum">   34050 </span><span class="lineCov">         40 :           c_name = &quot;num_threads&quot;;</span>
<span class="lineNum">   34051 </span><span class="lineCov">          5 :           break;</span>
<span class="lineNum">   34052 </span><span class="lineCov">          5 :         case PRAGMA_OMP_CLAUSE_ORDERED:</span>
<span class="lineNum">   34053 </span>            :           clauses = cp_parser_omp_clause_ordered (parser, clauses,
<span class="lineNum">   34054 </span><span class="lineCov">          5 :                                                   token-&gt;location);</span>
<span class="lineNum">   34055 </span><span class="lineCov">          5 :           c_name = &quot;ordered&quot;;</span>
<span class="lineNum">   34056 </span><span class="lineCov">         32 :           break;</span>
<span class="lineNum">   34057 </span><span class="lineCov">         32 :         case PRAGMA_OMP_CLAUSE_PRIORITY:</span>
<span class="lineNum">   34058 </span>            :           clauses = cp_parser_omp_clause_priority (parser, clauses,
<span class="lineNum">   34059 </span><span class="lineCov">         32 :                                                    token-&gt;location);</span>
<span class="lineNum">   34060 </span><span class="lineCov">         32 :           c_name = &quot;priority&quot;;</span>
<span class="lineNum">   34061 </span><span class="lineCov">        394 :           break;</span>
<span class="lineNum">   34062 </span><span class="lineCov">        394 :         case PRAGMA_OMP_CLAUSE_PRIVATE:</span>
<span class="lineNum">   34063 </span>            :           clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_PRIVATE,
<span class="lineNum">   34064 </span><span class="lineCov">        394 :                                             clauses);</span>
<span class="lineNum">   34065 </span><span class="lineCov">        394 :           c_name = &quot;private&quot;;</span>
<span class="lineNum">   34066 </span><span class="lineCov">        402 :           break;</span>
<span class="lineNum">   34067 </span><span class="lineCov">        402 :         case PRAGMA_OMP_CLAUSE_REDUCTION:</span>
<span class="lineNum">   34068 </span>            :           clauses = cp_parser_omp_clause_reduction (parser, clauses);
<span class="lineNum">   34069 </span><span class="lineCov">        402 :           c_name = &quot;reduction&quot;;</span>
<span class="lineNum">   34070 </span><span class="lineCov">        402 :           break;</span>
<span class="lineNum">   34071 </span><span class="lineCov">          3 :         case PRAGMA_OMP_CLAUSE_SCHEDULE:</span>
<span class="lineNum">   34072 </span><span class="lineCov">          3 :           clauses = cp_parser_omp_clause_schedule (parser, clauses,</span>
<span class="lineNum">   34073 </span>            :                                                    token-&gt;location);
<span class="lineNum">   34074 </span><span class="lineCov">          3 :           c_name = &quot;schedule&quot;;</span>
<span class="lineNum">   34075 </span><span class="lineCov">          3 :           break;</span>
<span class="lineNum">   34076 </span><span class="lineCov">        177 :         case PRAGMA_OMP_CLAUSE_SHARED:</span>
<span class="lineNum">   34077 </span><span class="lineCov">        177 :           clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_SHARED,</span>
<span class="lineNum">   34078 </span><span class="lineCov">        177 :                                             clauses);</span>
<span class="lineNum">   34079 </span><span class="lineCov">        177 :           c_name = &quot;shared&quot;;</span>
<span class="lineNum">   34080 </span><span class="lineCov">          6 :           break;</span>
<span class="lineNum">   34081 </span><span class="lineCov">          6 :         case PRAGMA_OMP_CLAUSE_UNTIED:</span>
<span class="lineNum">   34082 </span>            :           clauses = cp_parser_omp_clause_untied (parser, clauses,
<span class="lineNum">   34083 </span><span class="lineCov">          6 :                                                  token-&gt;location);</span>
<span class="lineNum">   34084 </span><span class="lineCov">          6 :           c_name = &quot;untied&quot;;</span>
<span class="lineNum">   34085 </span><span class="lineCov">        263 :           break;</span>
<span class="lineNum">   34086 </span><span class="lineCov">        263 :         case PRAGMA_OMP_CLAUSE_INBRANCH:</span>
<span class="lineNum">   34087 </span>            :           clauses = cp_parser_omp_clause_branch (parser, OMP_CLAUSE_INBRANCH,
<span class="lineNum">   34088 </span><span class="lineCov">        263 :                                                  clauses, token-&gt;location);</span>
<span class="lineNum">   34089 </span><span class="lineCov">        263 :           c_name = &quot;inbranch&quot;;</span>
<span class="lineNum">   34090 </span><span class="lineCov">        205 :           break;</span>
<span class="lineNum">   34091 </span><span class="lineCov">        205 :         case PRAGMA_OMP_CLAUSE_NOTINBRANCH:</span>
<span class="lineNum">   34092 </span>            :           clauses = cp_parser_omp_clause_branch (parser,
<span class="lineNum">   34093 </span><span class="lineCov">        205 :                                                  OMP_CLAUSE_NOTINBRANCH,</span>
<span class="lineNum">   34094 </span><span class="lineCov">        205 :                                                  clauses, token-&gt;location);</span>
<span class="lineNum">   34095 </span><span class="lineCov">         18 :           c_name = &quot;notinbranch&quot;;</span>
<span class="lineNum">   34096 </span><span class="lineCov">         18 :           break;</span>
<span class="lineNum">   34097 </span>            :         case PRAGMA_OMP_CLAUSE_PARALLEL:
<span class="lineNum">   34098 </span><span class="lineCov">         18 :           clauses = cp_parser_omp_clause_cancelkind (parser, OMP_CLAUSE_PARALLEL,</span>
<span class="lineNum">   34099 </span><span class="lineCov">         18 :                                                      clauses, token-&gt;location);</span>
<span class="lineNum">   34100 </span><span class="lineCov">        485 :           c_name = &quot;parallel&quot;;</span>
<span class="lineNum">   34101 </span><span class="lineCov">        485 :           if (!first)</span>
<span class="lineNum">   34102 </span>            :             {
<span class="lineNum">   34103 </span><span class="lineCov">        485 :              clause_not_first:</span>
<span class="lineNum">   34104 </span><span class="lineCov">        485 :               error_at (token-&gt;location, &quot;%qs must be the first clause of %qs&quot;,</span>
<span class="lineNum">   34105 </span><span class="lineCov">        929 :                         c_name, where);</span>
<span class="lineNum">   34106 </span><span class="lineCov">        929 :               clauses = prev;</span>
<span class="lineNum">   34107 </span><span class="lineCov">        929 :             }</span>
<span class="lineNum">   34108 </span><span class="lineCov">        929 :           break;</span>
<span class="lineNum">   34109 </span><span class="lineCov">       1740 :         case PRAGMA_OMP_CLAUSE_FOR:</span>
<span class="lineNum">   34110 </span><span class="lineCov">       1740 :           clauses = cp_parser_omp_clause_cancelkind (parser, OMP_CLAUSE_FOR,</span>
<span class="lineNum">   34111 </span>            :                                                      clauses, token-&gt;location);
<span class="lineNum">   34112 </span><span class="lineCov">       1740 :           c_name = &quot;for&quot;;</span>
<span class="lineNum">   34113 </span><span class="lineCov">       1740 :           if (!first)</span>
<span class="lineNum">   34114 </span><span class="lineCov">        405 :             goto clause_not_first;</span>
<span class="lineNum">   34115 </span><span class="lineCov">        405 :           break;</span>
<span class="lineNum">   34116 </span>            :         case PRAGMA_OMP_CLAUSE_SECTIONS:
<span class="lineNum">   34117 </span><span class="lineCov">        405 :           clauses = cp_parser_omp_clause_cancelkind (parser, OMP_CLAUSE_SECTIONS,</span>
<span class="lineNum">   34118 </span><span class="lineCov">        405 :                                                      clauses, token-&gt;location);</span>
<span class="lineNum">   34119 </span><span class="lineCov">          5 :           c_name = &quot;sections&quot;;</span>
<span class="lineNum">   34120 </span><span class="lineCov">          5 :           if (!first)</span>
<span class="lineNum">   34121 </span>            :             goto clause_not_first;
<span class="lineNum">   34122 </span><span class="lineCov">          5 :           break;</span>
<span class="lineNum">   34123 </span><span class="lineCov">          5 :         case PRAGMA_OMP_CLAUSE_TASKGROUP:</span>
<span class="lineNum">   34124 </span><span class="lineCov">         21 :           clauses = cp_parser_omp_clause_cancelkind (parser, OMP_CLAUSE_TASKGROUP,</span>
<span class="lineNum">   34125 </span><span class="lineCov">         21 :                                                      clauses, token-&gt;location);</span>
<span class="lineNum">   34126 </span>            :           c_name = &quot;taskgroup&quot;;
<span class="lineNum">   34127 </span><span class="lineCov">         21 :           if (!first)</span>
<span class="lineNum">   34128 </span><span class="lineCov">         21 :             goto clause_not_first;</span>
<span class="lineNum">   34129 </span><span class="lineCov">        194 :           break;</span>
<span class="lineNum">   34130 </span><span class="lineCov">        194 :         case PRAGMA_OMP_CLAUSE_LINK:</span>
<span class="lineNum">   34131 </span>            :           clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_LINK, clauses);
<span class="lineNum">   34132 </span>            :           c_name = &quot;to&quot;;
<span class="lineNum">   34133 </span><span class="lineCov">        194 :           break;</span>
<span class="lineNum">   34134 </span><span class="lineCov">        194 :         case PRAGMA_OMP_CLAUSE_TO:</span>
<span class="lineNum">   34135 </span><span class="lineCov">        196 :           if ((mask &amp; (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_LINK)) != 0)</span>
<span class="lineNum">   34136 </span><span class="lineCov">        196 :             clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_TO_DECLARE,</span>
<span class="lineNum">   34137 </span>            :                                               clauses);
<span class="lineNum">   34138 </span><span class="lineCov">        196 :           else</span>
<span class="lineNum">   34139 </span><span class="lineCov">        196 :             clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_TO, clauses);</span>
<span class="lineNum">   34140 </span>            :           c_name = &quot;to&quot;;
<span class="lineNum">   34141 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   34142 </span><span class="lineNoCov">          0 :         case PRAGMA_OMP_CLAUSE_FROM:</span>
<span class="lineNum">   34143 </span>            :           clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_FROM, clauses);
<span class="lineNum">   34144 </span><span class="lineNoCov">          0 :           c_name = &quot;from&quot;;</span>
<span class="lineNum">   34145 </span>            :           break;
<span class="lineNum">   34146 </span>            :         case PRAGMA_OMP_CLAUSE_UNIFORM:
<span class="lineNum">   34147 </span><span class="lineCov">        201 :           clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_UNIFORM,</span>
<span class="lineNum">   34148 </span><span class="lineCov">        201 :                                             clauses);</span>
<span class="lineNum">   34149 </span>            :           c_name = &quot;uniform&quot;;
<span class="lineNum">   34150 </span><span class="lineCov">        201 :           break;</span>
<span class="lineNum">   34151 </span><span class="lineCov">        201 :         case PRAGMA_OMP_CLAUSE_NUM_TEAMS:</span>
<span class="lineNum">   34152 </span>            :           clauses = cp_parser_omp_clause_num_teams (parser, clauses,
<span class="lineNum">   34153 </span>            :                                                     token-&gt;location);
<span class="lineNum">   34154 </span><span class="lineCov">        196 :           c_name = &quot;num_teams&quot;;</span>
<span class="lineNum">   34155 </span><span class="lineCov">        196 :           break;</span>
<span class="lineNum">   34156 </span>            :         case PRAGMA_OMP_CLAUSE_THREAD_LIMIT:
<span class="lineNum">   34157 </span><span class="lineCov">        196 :           clauses = cp_parser_omp_clause_thread_limit (parser, clauses,</span>
<span class="lineNum">   34158 </span><span class="lineCov">        196 :                                                        token-&gt;location);</span>
<span class="lineNum">   34159 </span>            :           c_name = &quot;thread_limit&quot;;
<span class="lineNum">   34160 </span>            :           break;
<span class="lineNum">   34161 </span><span class="lineCov">        223 :         case PRAGMA_OMP_CLAUSE_ALIGNED:</span>
<span class="lineNum">   34162 </span><span class="lineCov">        223 :           clauses = cp_parser_omp_clause_aligned (parser, clauses);</span>
<span class="lineNum">   34163 </span>            :           c_name = &quot;aligned&quot;;
<span class="lineNum">   34164 </span><span class="lineCov">        223 :           break;</span>
<span class="lineNum">   34165 </span><span class="lineCov">        223 :         case PRAGMA_OMP_CLAUSE_LINEAR:</span>
<span class="lineNum">   34166 </span>            :           {
<span class="lineNum">   34167 </span>            :             bool declare_simd = false;
<span class="lineNum">   34168 </span><span class="lineCov">         30 :             if (((mask &gt;&gt; PRAGMA_OMP_CLAUSE_UNIFORM) &amp; 1) != 0)</span>
<span class="lineNum">   34169 </span><span class="lineCov">         30 :               declare_simd = true;</span>
<span class="lineNum">   34170 </span><span class="lineCov">         30 :             clauses = cp_parser_omp_clause_linear (parser, clauses, declare_simd);</span>
<span class="lineNum">   34171 </span><span class="lineCov">         30 :           }</span>
<span class="lineNum">   34172 </span><span class="lineCov">        288 :           c_name = &quot;linear&quot;;</span>
<span class="lineNum">   34173 </span><span class="lineCov">        864 :           break;</span>
<span class="lineNum">   34174 </span><span class="lineCov">         85 :         case PRAGMA_OMP_CLAUSE_DEPEND:</span>
<span class="lineNum">   34175 </span>            :           clauses = cp_parser_omp_clause_depend (parser, clauses,
<span class="lineNum">   34176 </span>            :                                                  token-&gt;location);
<span class="lineNum">   34177 </span><span class="lineCov">        203 :           c_name = &quot;depend&quot;;</span>
<span class="lineNum">   34178 </span>            :           break;
<span class="lineNum">   34179 </span>            :         case PRAGMA_OMP_CLAUSE_MAP:
<span class="lineNum">   34180 </span><span class="lineCov">        920 :           clauses = cp_parser_omp_clause_map (parser, clauses);</span>
<span class="lineNum">   34181 </span><span class="lineCov">        920 :           c_name = &quot;map&quot;;</span>
<span class="lineNum">   34182 </span><span class="lineCov">        920 :           break;</span>
<span class="lineNum">   34183 </span><span class="lineCov">        920 :         case PRAGMA_OMP_CLAUSE_DEVICE:</span>
<span class="lineNum">   34184 </span><span class="lineCov">        212 :           clauses = cp_parser_omp_clause_device (parser, clauses,</span>
<span class="lineNum">   34185 </span><span class="lineCov">        212 :                                                  token-&gt;location);</span>
<span class="lineNum">   34186 </span>            :           c_name = &quot;device&quot;;
<span class="lineNum">   34187 </span><span class="lineCov">        212 :           break;</span>
<span class="lineNum">   34188 </span><span class="lineCov">        212 :         case PRAGMA_OMP_CLAUSE_DIST_SCHEDULE:</span>
<span class="lineNum">   34189 </span><span class="lineCov">        184 :           clauses = cp_parser_omp_clause_dist_schedule (parser, clauses,</span>
<span class="lineNum">   34190 </span><span class="lineCov">        184 :                                                         token-&gt;location);</span>
<span class="lineNum">   34191 </span>            :           c_name = &quot;dist_schedule&quot;;
<span class="lineNum">   34192 </span><span class="lineCov">        184 :           break;</span>
<span class="lineNum">   34193 </span><span class="lineCov">        184 :         case PRAGMA_OMP_CLAUSE_PROC_BIND:</span>
<span class="lineNum">   34194 </span><span class="lineCov">        184 :           clauses = cp_parser_omp_clause_proc_bind (parser, clauses,</span>
<span class="lineNum">   34195 </span><span class="lineCov">        184 :                                                     token-&gt;location);</span>
<span class="lineNum">   34196 </span>            :           c_name = &quot;proc_bind&quot;;
<span class="lineNum">   34197 </span><span class="lineCov">        184 :           break;</span>
<span class="lineNum">   34198 </span><span class="lineCov">        184 :         case PRAGMA_OMP_CLAUSE_SAFELEN:</span>
<span class="lineNum">   34199 </span><span class="lineCov">        300 :           clauses = cp_parser_omp_clause_safelen (parser, clauses,</span>
<span class="lineNum">   34200 </span><span class="lineCov">        300 :                                                   token-&gt;location);</span>
<span class="lineNum">   34201 </span><span class="lineCov">        300 :           c_name = &quot;safelen&quot;;</span>
<span class="lineNum">   34202 </span><span class="lineCov">        300 :           break;</span>
<span class="lineNum">   34203 </span><span class="lineCov">        787 :         case PRAGMA_OMP_CLAUSE_SIMDLEN:</span>
<span class="lineNum">   34204 </span><span class="lineCov">        787 :           clauses = cp_parser_omp_clause_simdlen (parser, clauses,</span>
<span class="lineNum">   34205 </span><span class="lineCov">        787 :                                                   token-&gt;location);</span>
<span class="lineNum">   34206 </span><span class="lineCov">       2361 :           c_name = &quot;simdlen&quot;;</span>
<span class="lineNum">   34207 </span>            :           break;
<span class="lineNum">   34208 </span><span class="lineCov">        787 :         case PRAGMA_OMP_CLAUSE_NOGROUP:</span>
<span class="lineNum">   34209 </span>            :           clauses = cp_parser_omp_clause_nogroup (parser, clauses,
<span class="lineNum">   34210 </span><span class="lineCov">        787 :                                                   token-&gt;location);</span>
<span class="lineNum">   34211 </span><span class="lineCov">        787 :           c_name = &quot;nogroup&quot;;</span>
<span class="lineNum">   34212 </span><span class="lineCov">        602 :           break;</span>
<span class="lineNum">   34213 </span><span class="lineCov">        602 :         case PRAGMA_OMP_CLAUSE_THREADS:</span>
<span class="lineNum">   34214 </span>            :           clauses
<span class="lineNum">   34215 </span><span class="lineCov">        602 :             = cp_parser_omp_clause_orderedkind (parser, OMP_CLAUSE_THREADS,</span>
<span class="lineNum">   34216 </span><span class="lineCov">        602 :                                                 clauses, token-&gt;location);</span>
<span class="lineNum">   34217 </span><span class="lineCov">       1018 :           c_name = &quot;threads&quot;;</span>
<span class="lineNum">   34218 </span><span class="lineCov">       1018 :           break;</span>
<span class="lineNum">   34219 </span><span class="lineCov">       1018 :         case PRAGMA_OMP_CLAUSE_SIMD:</span>
<span class="lineNum">   34220 </span><span class="lineCov">       1018 :           clauses</span>
<span class="lineNum">   34221 </span><span class="lineCov">        117 :             = cp_parser_omp_clause_orderedkind (parser, OMP_CLAUSE_SIMD,</span>
<span class="lineNum">   34222 </span><span class="lineCov">        117 :                                                 clauses, token-&gt;location);</span>
<span class="lineNum">   34223 </span>            :           c_name = &quot;simd&quot;;
<span class="lineNum">   34224 </span><span class="lineCov">        117 :           break;</span>
<span class="lineNum">   34225 </span><span class="lineCov">        117 :         default:</span>
<span class="lineNum">   34226 </span><span class="lineCov">        670 :           cp_parser_error (parser, &quot;expected %&lt;#pragma omp%&gt; clause&quot;);</span>
<span class="lineNum">   34227 </span><span class="lineCov">        670 :           goto saw_error;</span>
<span class="lineNum">   34228 </span>            :         }
<span class="lineNum">   34229 </span><span class="lineCov">        670 : </span>
<span class="lineNum">   34230 </span><span class="lineCov">        670 :       first = false;</span>
<span class="lineNum">   34231 </span><span class="lineCov">        108 : </span>
<span class="lineNum">   34232 </span><span class="lineCov">        108 :       if (((mask &gt;&gt; c_kind) &amp; 1) == 0)</span>
<span class="lineNum">   34233 </span>            :         {
<span class="lineNum">   34234 </span><span class="lineCov">        108 :           /* Remove the invalid clause(s) from the list to avoid</span>
<span class="lineNum">   34235 </span><span class="lineCov">        108 :              confusing the rest of the compiler.  */</span>
<span class="lineNum">   34236 </span><span class="lineCov">        131 :           clauses = prev;</span>
<span class="lineNum">   34237 </span><span class="lineCov">        131 :           error_at (token-&gt;location, &quot;%qs is not valid for %qs&quot;, c_name, where);</span>
<span class="lineNum">   34238 </span>            :         }
<span class="lineNum">   34239 </span><span class="lineCov">        131 :     }</span>
<span class="lineNum">   34240 </span><span class="lineCov">        131 :  saw_error:</span>
<span class="lineNum">   34241 </span><span class="lineCov">        183 :   cp_parser_skip_to_pragma_eol (parser, pragma_tok);</span>
<span class="lineNum">   34242 </span><span class="lineCov">        183 :   if (finish_p)</span>
<span class="lineNum">   34243 </span>            :     {
<span class="lineNum">   34244 </span><span class="lineCov">        183 :       if ((mask &amp; (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_UNIFORM)) != 0)</span>
<span class="lineNum">   34245 </span><span class="lineCov">        183 :         return finish_omp_clauses (clauses, C_ORT_OMP_DECLARE_SIMD);</span>
<span class="lineNum">   34246 </span><span class="lineCov">         11 :       else</span>
<span class="lineNum">   34247 </span><span class="lineCov">         11 :         return finish_omp_clauses (clauses, C_ORT_OMP);</span>
<span class="lineNum">   34248 </span>            :     }
<span class="lineNum">   34249 </span><span class="lineCov">         11 :   return clauses;</span>
<span class="lineNum">   34250 </span><span class="lineCov">         11 : }</span>
<span class="lineNum">   34251 </span><span class="lineCov">         92 : </span>
<span class="lineNum">   34252 </span><span class="lineCov">         92 : /* OpenMP 2.5:</span>
<span class="lineNum">   34253 </span><span class="lineCov">         92 :    structured-block:</span>
<span class="lineNum">   34254 </span>            :      statement
<span class="lineNum">   34255 </span><span class="lineCov">         92 : </span>
<span class="lineNum">   34256 </span><span class="lineCov">         92 :    In practice, we're also interested in adding the statement to an</span>
<span class="lineNum">   34257 </span><span class="lineCov">        117 :    outer node.  So it is convenient if we work around the fact that</span>
<span class="lineNum">   34258 </span><span class="lineCov">        117 :    cp_parser_statement calls add_stmt.  */</span>
<a name="34259"><span class="lineNum">   34259 </span><span class="lineCov">        117 : </span></a>
<span class="lineNum">   34260 </span>            : static unsigned
<span class="lineNum">   34261 </span><span class="lineCov">        117 : cp_parser_begin_omp_structured_block (cp_parser *parser)</span>
<span class="lineNum">   34262 </span><span class="lineCov">        117 : {</span>
<span class="lineNum">   34263 </span><span class="lineCov">         21 :   unsigned save = parser-&gt;in_statement;</span>
<span class="lineNum">   34264 </span><span class="lineCov">         21 : </span>
<span class="lineNum">   34265 </span><span class="lineCov">         21 :   /* Only move the values to IN_OMP_BLOCK if they weren't false.</span>
<span class="lineNum">   34266 </span>            :      This preserves the &quot;not within loop or switch&quot; style error messages
<span class="lineNum">   34267 </span>            :      for nonsense cases like
<span class="lineNum">   34268 </span><span class="lineCov">      14433 :         void foo() {</span>
<span class="lineNum">   34269 </span>            :         #pragma omp single
<span class="lineNum">   34270 </span><span class="lineCov">      43299 :           break;</span>
<span class="lineNum">   34271 </span>            :         }
<span class="lineNum">   34272 </span>            :   */
<span class="lineNum">   34273 </span>            :   if (parser-&gt;in_statement)
<span class="lineNum">   34274 </span><span class="lineCov">         60 :     parser-&gt;in_statement = IN_OMP_BLOCK;</span>
<span class="lineNum">   34275 </span><span class="lineCov">         60 : </span>
<span class="lineNum">   34276 </span>            :   return save;
<span class="lineNum">   34277 </span>            : }
<a name="34278"><span class="lineNum">   34278 </span><span class="lineCov">      11959 : </span></a>
<span class="lineNum">   34279 </span><span class="lineCov">      11980 : static void</span>
<span class="lineNum">   34280 </span><span class="lineCov">      11980 : cp_parser_end_omp_structured_block (cp_parser *parser, unsigned save)</span>
<span class="lineNum">   34281 </span>            : {
<span class="lineNum">   34282 </span><span class="lineCov">      27150 :   parser-&gt;in_statement = save;</span>
<span class="lineNum">   34283 </span><span class="lineCov">        533 : }</span>
<a name="34284"><span class="lineNum">   34284 </span>            : </a>
<span class="lineNum">   34285 </span><span class="lineCov">       8517 : static tree</span>
<span class="lineNum">   34286 </span>            : cp_parser_omp_structured_block (cp_parser *parser, bool *if_p)
<span class="lineNum">   34287 </span>            : {
<span class="lineNum">   34288 </span>            :   tree stmt = begin_omp_structured_block ();
<span class="lineNum">   34289 </span>            :   unsigned int save = cp_parser_begin_omp_structured_block (parser);
<span class="lineNum">   34290 </span>            : 
<span class="lineNum">   34291 </span>            :   cp_parser_statement (parser, NULL_TREE, false, if_p);
<span class="lineNum">   34292 </span>            : 
<span class="lineNum">   34293 </span>            :   cp_parser_end_omp_structured_block (parser, save);
<span class="lineNum">   34294 </span>            :   return finish_omp_structured_block (stmt);
<span class="lineNum">   34295 </span>            : }
<span class="lineNum">   34296 </span>            : 
<span class="lineNum">   34297 </span>            : /* OpenMP 2.5:
<span class="lineNum">   34298 </span>            :    # pragma omp atomic new-line
<span class="lineNum">   34299 </span><span class="lineNoCov">          0 :      expression-stmt</span>
<span class="lineNum">   34300 </span>            : 
<span class="lineNum">   34301 </span><span class="lineCov">      20750 :    expression-stmt:</span>
<span class="lineNum">   34302 </span>            :      x binop= expr | x++ | ++x | x-- | --x
<span class="lineNum">   34303 </span>            :    binop:
<span class="lineNum">   34304 </span>            :      +, *, -, /, &amp;, ^, |, &lt;&lt;, &gt;&gt;
<span class="lineNum">   34305 </span>            : 
<span class="lineNum">   34306 </span>            :   where x is an lvalue expression with scalar type.
<span class="lineNum">   34307 </span>            : 
<span class="lineNum">   34308 </span>            :    OpenMP 3.1:
<span class="lineNum">   34309 </span>            :    # pragma omp atomic new-line
<span class="lineNum">   34310 </span>            :      update-stmt
<span class="lineNum">   34311 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   34312 </span><span class="lineCov">       1602 :    # pragma omp atomic read new-line</span>
<span class="lineNum">   34313 </span>            :      read-stmt
<span class="lineNum">   34314 </span><span class="lineCov">      20750 : </span>
<span class="lineNum">   34315 </span>            :    # pragma omp atomic write new-line
<span class="lineNum">   34316 </span>            :      write-stmt
<span class="lineNum">   34317 </span>            : 
<span class="lineNum">   34318 </span><span class="lineNoCov">          0 :    # pragma omp atomic update new-line</span>
<span class="lineNum">   34319 </span>            :      update-stmt
<span class="lineNum">   34320 </span><span class="lineCov">      20750 : </span>
<span class="lineNum">   34321 </span><span class="lineNoCov">          0 :    # pragma omp atomic capture new-line</span>
<span class="lineNum">   34322 </span>            :      capture-stmt
<span class="lineNum">   34323 </span>            : 
<span class="lineNum">   34324 </span><span class="lineCov">       2699 :    # pragma omp atomic capture new-line</span>
<span class="lineNum">   34325 </span>            :      capture-block
<span class="lineNum">   34326 </span><span class="lineCov">       2699 : </span>
<span class="lineNum">   34327 </span><span class="lineCov">       2699 :    read-stmt:</span>
<span class="lineNum">   34328 </span>            :      v = x
<span class="lineNum">   34329 </span><span class="lineCov">       2699 :    write-stmt:</span>
<span class="lineNum">   34330 </span>            :      x = expr
<span class="lineNum">   34331 </span><span class="lineCov">       5398 :    update-stmt:</span>
<span class="lineNum">   34332 </span><span class="lineCov">       2699 :      expression-stmt | x = x binop expr</span>
<span class="lineNum">   34333 </span>            :    capture-stmt:
<span class="lineNum">   34334 </span>            :      v = expression-stmt
<span class="lineNum">   34335 </span>            :    capture-block:
<span class="lineNum">   34336 </span>            :      { v = x; update-stmt; } | { update-stmt; v = x; }
<span class="lineNum">   34337 </span>            : 
<span class="lineNum">   34338 </span>            :    OpenMP 4.0:
<span class="lineNum">   34339 </span>            :    update-stmt:
<span class="lineNum">   34340 </span>            :      expression-stmt | x = x binop expr | x = expr binop x
<span class="lineNum">   34341 </span>            :    capture-stmt:
<span class="lineNum">   34342 </span>            :      v = update-stmt
<span class="lineNum">   34343 </span>            :    capture-block:
<span class="lineNum">   34344 </span>            :      { v = x; update-stmt; } | { update-stmt; v = x; } | { v = x; x = expr; }
<span class="lineNum">   34345 </span>            : 
<span class="lineNum">   34346 </span>            :   where x and v are lvalue expressions with scalar type.  */
<a name="34347"><span class="lineNum">   34347 </span>            : </a>
<span class="lineNum">   34348 </span>            : static void
<span class="lineNum">   34349 </span>            : cp_parser_omp_atomic (cp_parser *parser, cp_token *pragma_tok)
<span class="lineNum">   34350 </span>            : {
<span class="lineNum">   34351 </span>            :   tree lhs = NULL_TREE, rhs = NULL_TREE, v = NULL_TREE, lhs1 = NULL_TREE;
<span class="lineNum">   34352 </span>            :   tree rhs1 = NULL_TREE, orig_lhs;
<span class="lineNum">   34353 </span>            :   enum tree_code code = OMP_ATOMIC, opcode = NOP_EXPR;
<span class="lineNum">   34354 </span>            :   bool structured_block = false;
<span class="lineNum">   34355 </span>            :   bool seq_cst = false;
<span class="lineNum">   34356 </span>            : 
<span class="lineNum">   34357 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))
<span class="lineNum">   34358 </span>            :     {
<span class="lineNum">   34359 </span>            :       tree id = cp_lexer_peek_token (parser-&gt;lexer)-&gt;u.value;
<span class="lineNum">   34360 </span>            :       const char *p = IDENTIFIER_POINTER (id);
<span class="lineNum">   34361 </span>            : 
<span class="lineNum">   34362 </span>            :       if (!strcmp (p, &quot;seq_cst&quot;))
<span class="lineNum">   34363 </span>            :         {
<span class="lineNum">   34364 </span>            :           seq_cst = true;
<span class="lineNum">   34365 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   34366 </span>            :           if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_COMMA)
<span class="lineNum">   34367 </span>            :               &amp;&amp; cp_lexer_peek_nth_token (parser-&gt;lexer, 2)-&gt;type == CPP_NAME)
<span class="lineNum">   34368 </span>            :             cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   34369 </span>            :         }
<span class="lineNum">   34370 </span>            :     }
<span class="lineNum">   34371 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))
<span class="lineNum">   34372 </span>            :     {
<span class="lineNum">   34373 </span>            :       tree id = cp_lexer_peek_token (parser-&gt;lexer)-&gt;u.value;
<span class="lineNum">   34374 </span>            :       const char *p = IDENTIFIER_POINTER (id);
<span class="lineNum">   34375 </span>            : 
<span class="lineNum">   34376 </span>            :       if (!strcmp (p, &quot;read&quot;))
<span class="lineNum">   34377 </span>            :         code = OMP_ATOMIC_READ;
<span class="lineNum">   34378 </span>            :       else if (!strcmp (p, &quot;write&quot;))
<span class="lineNum">   34379 </span>            :         code = NOP_EXPR;
<span class="lineNum">   34380 </span>            :       else if (!strcmp (p, &quot;update&quot;))
<span class="lineNum">   34381 </span>            :         code = OMP_ATOMIC;
<span class="lineNum">   34382 </span>            :       else if (!strcmp (p, &quot;capture&quot;))
<span class="lineNum">   34383 </span>            :         code = OMP_ATOMIC_CAPTURE_NEW;
<span class="lineNum">   34384 </span>            :       else
<span class="lineNum">   34385 </span>            :         p = NULL;
<span class="lineNum">   34386 </span>            :       if (p)
<span class="lineNum">   34387 </span><span class="lineCov">       1694 :         cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   34388 </span>            :     }
<span class="lineNum">   34389 </span><span class="lineCov">       1694 :   if (!seq_cst)</span>
<span class="lineNum">   34390 </span><span class="lineCov">       1694 :     {</span>
<span class="lineNum">   34391 </span><span class="lineCov">       1694 :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_COMMA)</span>
<span class="lineNum">   34392 </span><span class="lineCov">       1694 :           &amp;&amp; cp_lexer_peek_nth_token (parser-&gt;lexer, 2)-&gt;type == CPP_NAME)</span>
<span class="lineNum">   34393 </span><span class="lineCov">       1694 :         cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   34394 </span>            : 
<span class="lineNum">   34395 </span><span class="lineCov">       1694 :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))</span>
<span class="lineNum">   34396 </span>            :         {
<span class="lineNum">   34397 </span><span class="lineCov">       1248 :           tree id = cp_lexer_peek_token (parser-&gt;lexer)-&gt;u.value;</span>
<span class="lineNum">   34398 </span><span class="lineCov">        624 :           const char *p = IDENTIFIER_POINTER (id);</span>
<span class="lineNum">   34399 </span>            : 
<span class="lineNum">   34400 </span><span class="lineCov">        624 :           if (!strcmp (p, &quot;seq_cst&quot;))</span>
<span class="lineNum">   34401 </span>            :             {
<span class="lineNum">   34402 </span><span class="lineCov">         42 :               seq_cst = true;</span>
<span class="lineNum">   34403 </span><span class="lineCov">         42 :               cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   34404 </span><span class="lineCov">         84 :             }</span>
<span class="lineNum">   34405 </span><span class="lineCov">         42 :         }</span>
<span class="lineNum">   34406 </span><span class="lineCov">         16 :     }</span>
<span class="lineNum">   34407 </span>            :   cp_parser_require_pragma_eol (parser, pragma_tok);
<span class="lineNum">   34408 </span>            : 
<span class="lineNum">   34409 </span><span class="lineCov">       1694 :   switch (code)</span>
<span class="lineNum">   34410 </span>            :     {
<span class="lineNum">   34411 </span><span class="lineCov">       1244 :     case OMP_ATOMIC_READ:</span>
<span class="lineNum">   34412 </span><span class="lineCov">        622 :     case NOP_EXPR: /* atomic write */</span>
<span class="lineNum">   34413 </span>            :       v = cp_parser_unary_expression (parser);
<span class="lineNum">   34414 </span><span class="lineCov">        622 :       if (v == error_mark_node)</span>
<span class="lineNum">   34415 </span>            :         goto saw_error;
<span class="lineNum">   34416 </span><span class="lineCov">        490 :       if (!cp_parser_require (parser, CPP_EQ, RT_EQ))</span>
<span class="lineNum">   34417 </span>            :         goto saw_error;
<span class="lineNum">   34418 </span><span class="lineCov">        417 :       if (code == NOP_EXPR)</span>
<span class="lineNum">   34419 </span>            :         lhs = cp_parser_expression (parser);
<span class="lineNum">   34420 </span><span class="lineCov">        348 :       else</span>
<span class="lineNum">   34421 </span>            :         lhs = cp_parser_unary_expression (parser);
<span class="lineNum">   34422 </span>            :       if (lhs == error_mark_node)
<span class="lineNum">   34423 </span>            :         goto saw_error;
<span class="lineNum">   34424 </span><span class="lineCov">        619 :       if (code == NOP_EXPR)</span>
<span class="lineNum">   34425 </span><span class="lineCov">        619 :         {</span>
<span class="lineNum">   34426 </span>            :           /* atomic write is represented by OMP_ATOMIC with NOP_EXPR
<span class="lineNum">   34427 </span><span class="lineCov">       1694 :              opcode.  */</span>
<span class="lineNum">   34428 </span>            :           code = OMP_ATOMIC;
<span class="lineNum">   34429 </span><span class="lineCov">       3304 :           rhs = lhs;</span>
<span class="lineNum">   34430 </span><span class="lineCov">       1652 :           lhs = v;</span>
<span class="lineNum">   34431 </span><span class="lineCov">         22 :           v = NULL_TREE;</span>
<span class="lineNum">   34432 </span>            :         }
<span class="lineNum">   34433 </span><span class="lineCov">       1652 :       goto done;</span>
<span class="lineNum">   34434 </span>            :     case OMP_ATOMIC_CAPTURE_NEW:
<span class="lineNum">   34435 </span><span class="lineCov">         86 :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_BRACE))</span>
<span class="lineNum">   34436 </span><span class="lineCov">         43 :         {</span>
<span class="lineNum">   34437 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   34438 </span><span class="lineCov">         43 :           structured_block = true;</span>
<span class="lineNum">   34439 </span>            :         }
<span class="lineNum">   34440 </span><span class="lineCov">         40 :       else</span>
<span class="lineNum">   34441 </span><span class="lineCov">         40 :         {</span>
<span class="lineNum">   34442 </span>            :           v = cp_parser_unary_expression (parser);
<span class="lineNum">   34443 </span>            :           if (v == error_mark_node)
<span class="lineNum">   34444 </span>            :             goto saw_error;
<span class="lineNum">   34445 </span><span class="lineCov">       1694 :           if (!cp_parser_require (parser, CPP_EQ, RT_EQ))</span>
<span class="lineNum">   34446 </span>            :             goto saw_error;
<span class="lineNum">   34447 </span><span class="lineCov">       1694 :         }</span>
<span class="lineNum">   34448 </span>            :     default:
<span class="lineNum">   34449 </span><span class="lineCov">        205 :       break;</span>
<span class="lineNum">   34450 </span><span class="lineCov">        205 :     }</span>
<span class="lineNum">   34451 </span><span class="lineCov">        205 : </span>
<span class="lineNum">   34452 </span><span class="lineCov">        205 : restart:</span>
<span class="lineNum">   34453 </span>            :   lhs = cp_parser_unary_expression (parser);
<span class="lineNum">   34454 </span><span class="lineCov">        205 :   orig_lhs = lhs;</span>
<span class="lineNum">   34455 </span>            :   switch (TREE_CODE (lhs))
<span class="lineNum">   34456 </span><span class="lineCov">        205 :     {</span>
<span class="lineNum">   34457 </span><span class="lineCov">         73 :     case ERROR_MARK:</span>
<span class="lineNum">   34458 </span>            :       goto saw_error;
<span class="lineNum">   34459 </span><span class="lineCov">        132 : </span>
<span class="lineNum">   34460 </span><span class="lineCov">        205 :     case POSTINCREMENT_EXPR:</span>
<span class="lineNum">   34461 </span>            :       if (code == OMP_ATOMIC_CAPTURE_NEW &amp;&amp; !structured_block)
<span class="lineNum">   34462 </span><span class="lineCov">        205 :         code = OMP_ATOMIC_CAPTURE_OLD;</span>
<span class="lineNum">   34463 </span>            :       /* FALLTHROUGH */
<span class="lineNum">   34464 </span>            :     case PREINCREMENT_EXPR:
<span class="lineNum">   34465 </span>            :       lhs = TREE_OPERAND (lhs, 0);
<span class="lineNum">   34466 </span><span class="lineCov">         73 :       opcode = PLUS_EXPR;</span>
<span class="lineNum">   34467 </span><span class="lineCov">         73 :       rhs = integer_one_node;</span>
<span class="lineNum">   34468 </span><span class="lineCov">         73 :       break;</span>
<span class="lineNum">   34469 </span><span class="lineCov">         73 : </span>
<span class="lineNum">   34470 </span>            :     case POSTDECREMENT_EXPR:
<span class="lineNum">   34471 </span><span class="lineCov">        205 :       if (code == OMP_ATOMIC_CAPTURE_NEW &amp;&amp; !structured_block)</span>
<span class="lineNum">   34472 </span><span class="lineCov">        345 :         code = OMP_ATOMIC_CAPTURE_OLD;</span>
<span class="lineNum">   34473 </span><span class="lineCov">        345 :       /* FALLTHROUGH */</span>
<span class="lineNum">   34474 </span>            :     case PREDECREMENT_EXPR:
<span class="lineNum">   34475 </span><span class="lineCov">        239 :       lhs = TREE_OPERAND (lhs, 0);</span>
<span class="lineNum">   34476 </span><span class="lineCov">        239 :       opcode = MINUS_EXPR;</span>
<span class="lineNum">   34477 </span>            :       rhs = integer_one_node;
<span class="lineNum">   34478 </span>            :       break;
<span class="lineNum">   34479 </span>            : 
<span class="lineNum">   34480 </span><span class="lineCov">        106 :     case COMPOUND_EXPR:</span>
<span class="lineNum">   34481 </span><span class="lineCov">        106 :       if (TREE_CODE (TREE_OPERAND (lhs, 0)) == SAVE_EXPR</span>
<span class="lineNum">   34482 </span>            :          &amp;&amp; TREE_CODE (TREE_OPERAND (lhs, 1)) == COMPOUND_EXPR
<span class="lineNum">   34483 </span><span class="lineCov">        106 :          &amp;&amp; TREE_CODE (TREE_OPERAND (TREE_OPERAND (lhs, 1), 0)) == MODIFY_EXPR</span>
<span class="lineNum">   34484 </span>            :          &amp;&amp; TREE_OPERAND (TREE_OPERAND (lhs, 1), 1) == TREE_OPERAND (lhs, 0)
<span class="lineNum">   34485 </span>            :          &amp;&amp; TREE_CODE (TREE_TYPE (TREE_OPERAND (TREE_OPERAND
<span class="lineNum">   34486 </span>            :                                              (TREE_OPERAND (lhs, 1), 0), 0)))
<span class="lineNum">   34487 </span>            :             == BOOLEAN_TYPE)
<span class="lineNum">   34488 </span>            :        /* Undo effects of boolean_increment for post {in,de}crement.  */
<span class="lineNum">   34489 </span>            :        lhs = TREE_OPERAND (TREE_OPERAND (lhs, 1), 0);
<span class="lineNum">   34490 </span><span class="lineCov">       1489 :       /* FALLTHRU */</span>
<span class="lineNum">   34491 </span><span class="lineCov">       1625 :     case MODIFY_EXPR:</span>
<span class="lineNum">   34492 </span><span class="lineCov">       1625 :       if (TREE_CODE (lhs) == MODIFY_EXPR</span>
<span class="lineNum">   34493 </span><span class="lineCov">       1625 :          &amp;&amp; TREE_CODE (TREE_TYPE (TREE_OPERAND (lhs, 0))) == BOOLEAN_TYPE)</span>
<span class="lineNum">   34494 </span>            :         {
<span class="lineNum">   34495 </span><span class="lineCov">         18 :           /* Undo effects of boolean_increment.  */</span>
<span class="lineNum">   34496 </span><span class="lineCov">         18 :           if (integer_onep (TREE_OPERAND (lhs, 1)))</span>
<span class="lineNum">   34497 </span>            :             {
<span class="lineNum">   34498 </span><span class="lineCov">        165 :               /* This is pre or post increment.  */</span>
<span class="lineNum">   34499 </span><span class="lineCov">        165 :               rhs = TREE_OPERAND (lhs, 1);</span>
<span class="lineNum">   34500 </span><span class="lineCov">         12 :               lhs = TREE_OPERAND (lhs, 0);</span>
<span class="lineNum">   34501 </span>            :               opcode = NOP_EXPR;
<span class="lineNum">   34502 </span><span class="lineCov">        213 :               if (code == OMP_ATOMIC_CAPTURE_NEW</span>
<span class="lineNum">   34503 </span><span class="lineCov">        213 :                   &amp;&amp; !structured_block</span>
<span class="lineNum">   34504 </span><span class="lineCov">        213 :                   &amp;&amp; TREE_CODE (orig_lhs) == COMPOUND_EXPR)</span>
<span class="lineNum">   34505 </span><span class="lineCov">        213 :                 code = OMP_ATOMIC_CAPTURE_OLD;</span>
<span class="lineNum">   34506 </span><span class="lineCov">        213 :               break;</span>
<span class="lineNum">   34507 </span>            :             }
<span class="lineNum">   34508 </span><span class="lineCov">         50 :         }</span>
<span class="lineNum">   34509 </span><span class="lineCov">         50 :       /* FALLTHRU */</span>
<span class="lineNum">   34510 </span><span class="lineCov">          2 :     default:</span>
<span class="lineNum">   34511 </span>            :       switch (cp_lexer_peek_token (parser-&gt;lexer)-&gt;type)
<span class="lineNum">   34512 </span><span class="lineCov">         92 :         {</span>
<span class="lineNum">   34513 </span><span class="lineCov">         92 :         case CPP_MULT_EQ:</span>
<span class="lineNum">   34514 </span><span class="lineCov">         92 :           opcode = MULT_EXPR;</span>
<span class="lineNum">   34515 </span><span class="lineCov">         92 :           break;</span>
<span class="lineNum">   34516 </span><span class="lineCov">         92 :         case CPP_DIV_EQ:</span>
<span class="lineNum">   34517 </span>            :           opcode = TRUNC_DIV_EXPR;
<span class="lineNum">   34518 </span><span class="lineCov">         12 :           break;</span>
<span class="lineNum">   34519 </span><span class="lineCov">         12 :         case CPP_PLUS_EQ:</span>
<span class="lineNum">   34520 </span><span class="lineCov">         12 :           opcode = PLUS_EXPR;</span>
<span class="lineNum">   34521 </span><span class="lineCov">         12 :           break;</span>
<span class="lineNum">   34522 </span><span class="lineCov">         12 :         case CPP_MINUS_EQ:</span>
<span class="lineNum">   34523 </span><span class="lineCov">         24 :           opcode = MINUS_EXPR;</span>
<span class="lineNum">   34524 </span>            :           break;
<span class="lineNum">   34525 </span>            :         case CPP_LSHIFT_EQ:
<span class="lineNum">   34526 </span>            :           opcode = LSHIFT_EXPR;
<span class="lineNum">   34527 </span><span class="lineCov">         12 :           break;</span>
<span class="lineNum">   34528 </span>            :         case CPP_RSHIFT_EQ:
<span class="lineNum">   34529 </span><span class="lineCov">         24 :           opcode = RSHIFT_EXPR;</span>
<span class="lineNum">   34530 </span><span class="lineCov">         24 :           break;</span>
<span class="lineNum">   34531 </span><span class="lineCov">         24 :         case CPP_AND_EQ:</span>
<span class="lineNum">   34532 </span>            :           opcode = BIT_AND_EXPR;
<span class="lineNum">   34533 </span>            :           break;
<span class="lineNum">   34534 </span><span class="lineCov">         24 :         case CPP_OR_EQ:</span>
<span class="lineNum">   34535 </span>            :           opcode = BIT_IOR_EXPR;
<span class="lineNum">   34536 </span>            :           break;
<span class="lineNum">   34537 </span><span class="lineCov">         24 :         case CPP_XOR_EQ:</span>
<span class="lineNum">   34538 </span><span class="lineCov">         24 :           opcode = BIT_XOR_EXPR;</span>
<span class="lineNum">   34539 </span><span class="lineCov">         24 :           break;</span>
<span class="lineNum">   34540 </span><span class="lineCov">         48 :         case CPP_EQ:</span>
<span class="lineNum">   34541 </span><span class="lineCov">         24 :           enum cp_parser_prec oprec;</span>
<span class="lineNum">   34542 </span><span class="lineCov">          2 :           cp_token *token;</span>
<span class="lineNum">   34543 </span><span class="lineCov">          1 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   34544 </span>            :           cp_parser_parse_tentatively (parser);
<span class="lineNum">   34545 </span>            :           rhs1 = cp_parser_simple_cast_expression (parser);
<span class="lineNum">   34546 </span>            :           if (rhs1 == error_mark_node)
<span class="lineNum">   34547 </span>            :             {
<span class="lineNum">   34548 </span><span class="lineCov">       1278 :               cp_parser_abort_tentative_parse (parser);</span>
<span class="lineNum">   34549 </span><span class="lineCov">       1278 :               cp_parser_simple_cast_expression (parser);</span>
<span class="lineNum">   34550 </span>            :               goto saw_error;
<span class="lineNum">   34551 </span>            :             }
<span class="lineNum">   34552 </span>            :           token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   34553 </span>            :           if (token-&gt;type != CPP_SEMICOLON &amp;&amp; !cp_tree_equal (lhs, rhs1))
<span class="lineNum">   34554 </span>            :             {
<span class="lineNum">   34555 </span>            :               cp_parser_abort_tentative_parse (parser);
<span class="lineNum">   34556 </span>            :               cp_parser_parse_tentatively (parser);
<span class="lineNum">   34557 </span>            :               rhs = cp_parser_binary_expression (parser, false, true,
<span class="lineNum">   34558 </span>            :                                                  PREC_NOT_OPERATOR, NULL);
<span class="lineNum">   34559 </span>            :               if (rhs == error_mark_node)
<span class="lineNum">   34560 </span>            :                 {
<span class="lineNum">   34561 </span>            :                   cp_parser_abort_tentative_parse (parser);
<span class="lineNum">   34562 </span>            :                   cp_parser_binary_expression (parser, false, true,
<span class="lineNum">   34563 </span>            :                                                PREC_NOT_OPERATOR, NULL);
<span class="lineNum">   34564 </span>            :                   goto saw_error;
<span class="lineNum">   34565 </span>            :                 }
<span class="lineNum">   34566 </span>            :               switch (TREE_CODE (rhs))
<span class="lineNum">   34567 </span>            :                 {
<span class="lineNum">   34568 </span>            :                 case MULT_EXPR:
<span class="lineNum">   34569 </span>            :                 case TRUNC_DIV_EXPR:
<span class="lineNum">   34570 </span>            :                 case RDIV_EXPR:
<span class="lineNum">   34571 </span>            :                 case PLUS_EXPR:
<span class="lineNum">   34572 </span>            :                 case MINUS_EXPR:
<span class="lineNum">   34573 </span>            :                 case LSHIFT_EXPR:
<span class="lineNum">   34574 </span>            :                 case RSHIFT_EXPR:
<span class="lineNum">   34575 </span>            :                 case BIT_AND_EXPR:
<span class="lineNum">   34576 </span>            :                 case BIT_IOR_EXPR:
<span class="lineNum">   34577 </span>            :                 case BIT_XOR_EXPR:
<span class="lineNum">   34578 </span><span class="lineCov">        422 :                   if (cp_tree_equal (lhs, TREE_OPERAND (rhs, 1)))</span>
<span class="lineNum">   34579 </span><span class="lineCov">        422 :                     {</span>
<span class="lineNum">   34580 </span><span class="lineCov">        422 :                       if (cp_parser_parse_definitely (parser))</span>
<span class="lineNum">   34581 </span><span class="lineCov">        422 :                         {</span>
<span class="lineNum">   34582 </span><span class="lineCov">        422 :                           opcode = TREE_CODE (rhs);</span>
<span class="lineNum">   34583 </span><span class="lineCov">        422 :                           rhs1 = TREE_OPERAND (rhs, 0);</span>
<span class="lineNum">   34584 </span><span class="lineCov">        422 :                           rhs = TREE_OPERAND (rhs, 1);</span>
<span class="lineNum">   34585 </span>            :                           goto stmt_done;
<span class="lineNum">   34586 </span><span class="lineNoCov">          0 :                         }</span>
<span class="lineNum">   34587 </span><span class="lineNoCov">          0 :                       else</span>
<span class="lineNum">   34588 </span><span class="lineNoCov">          0 :                         goto saw_error;</span>
<span class="lineNum">   34589 </span>            :                     }
<span class="lineNum">   34590 </span><span class="lineCov">        844 :                   break;</span>
<span class="lineNum">   34591 </span><span class="lineCov">        422 :                 default:</span>
<span class="lineNum">   34592 </span>            :                   break;
<span class="lineNum">   34593 </span><span class="lineCov">        133 :                 }</span>
<span class="lineNum">   34594 </span><span class="lineCov">        133 :               cp_parser_abort_tentative_parse (parser);</span>
<span class="lineNum">   34595 </span><span class="lineCov">        266 :               if (structured_block &amp;&amp; code == OMP_ATOMIC_CAPTURE_OLD)</span>
<span class="lineNum">   34596 </span><span class="lineCov">        133 :                 {</span>
<span class="lineNum">   34597 </span><span class="lineCov">        133 :                   rhs = cp_parser_expression (parser);</span>
<span class="lineNum">   34598 </span>            :                   if (rhs == error_mark_node)
<span class="lineNum">   34599 </span><span class="lineNoCov">          0 :                     goto saw_error;</span>
<span class="lineNum">   34600 </span><span class="lineNoCov">          0 :                   opcode = NOP_EXPR;</span>
<span class="lineNum">   34601 </span><span class="lineNoCov">          0 :                   rhs1 = NULL_TREE;</span>
<span class="lineNum">   34602 </span><span class="lineNoCov">          0 :                   goto stmt_done;</span>
<span class="lineNum">   34603 </span>            :                 }
<span class="lineNum">   34604 </span><span class="lineCov">        133 :               cp_parser_error (parser,</span>
<span class="lineNum">   34605 </span>            :                                &quot;invalid form of %&lt;#pragma omp atomic%&gt;&quot;);
<span class="lineNum">   34606 </span><span class="lineCov">        123 :               goto saw_error;</span>
<span class="lineNum">   34607 </span><span class="lineCov">        123 :             }</span>
<span class="lineNum">   34608 </span><span class="lineCov">        123 :           if (!cp_parser_parse_definitely (parser))</span>
<span class="lineNum">   34609 </span><span class="lineCov">        123 :             goto saw_error;</span>
<span class="lineNum">   34610 </span><span class="lineCov">        123 :           switch (token-&gt;type)</span>
<span class="lineNum">   34611 </span><span class="lineCov">        123 :             {</span>
<span class="lineNum">   34612 </span><span class="lineCov">        123 :             case CPP_SEMICOLON:</span>
<span class="lineNum">   34613 </span><span class="lineCov">        123 :               if (structured_block &amp;&amp; code == OMP_ATOMIC_CAPTURE_NEW)</span>
<span class="lineNum">   34614 </span><span class="lineCov">        123 :                 {</span>
<span class="lineNum">   34615 </span><span class="lineCov">        123 :                   code = OMP_ATOMIC_CAPTURE_OLD;</span>
<span class="lineNum">   34616 </span><span class="lineCov">        123 :                   v = lhs;</span>
<span class="lineNum">   34617 </span>            :                   lhs = NULL_TREE;
<span class="lineNum">   34618 </span><span class="lineCov">        112 :                   lhs1 = rhs1;</span>
<span class="lineNum">   34619 </span>            :                   rhs1 = NULL_TREE;
<span class="lineNum">   34620 </span><span class="lineCov">        112 :                   cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   34621 </span><span class="lineCov">        112 :                   goto restart;</span>
<span class="lineNum">   34622 </span><span class="lineCov">        112 :                 }</span>
<span class="lineNum">   34623 </span><span class="lineCov">        112 :               else if (structured_block)</span>
<span class="lineNum">   34624 </span>            :                 {
<span class="lineNum">   34625 </span>            :                   opcode = NOP_EXPR;
<span class="lineNum">   34626 </span>            :                   rhs = rhs1;
<span class="lineNum">   34627 </span>            :                   rhs1 = NULL_TREE;
<span class="lineNum">   34628 </span>            :                   goto stmt_done;
<span class="lineNum">   34629 </span>            :                 }
<span class="lineNum">   34630 </span>            :               cp_parser_error (parser,
<span class="lineNum">   34631 </span>            :                                &quot;invalid form of %&lt;#pragma omp atomic%&gt;&quot;);
<span class="lineNum">   34632 </span><span class="lineCov">         21 :               goto saw_error;</span>
<span class="lineNum">   34633 </span><span class="lineCov">         21 :             case CPP_MULT:</span>
<span class="lineNum">   34634 </span>            :               opcode = MULT_EXPR;
<span class="lineNum">   34635 </span><span class="lineCov">         18 :               break;</span>
<span class="lineNum">   34636 </span><span class="lineCov">         18 :             case CPP_DIV:</span>
<span class="lineNum">   34637 </span>            :               opcode = TRUNC_DIV_EXPR;
<span class="lineNum">   34638 </span>            :               break;
<span class="lineNum">   34639 </span>            :             case CPP_PLUS:
<span class="lineNum">   34640 </span>            :               opcode = PLUS_EXPR;
<span class="lineNum">   34641 </span>            :               break;
<span class="lineNum">   34642 </span><span class="lineCov">          3 :             case CPP_MINUS:</span>
<span class="lineNum">   34643 </span>            :               opcode = MINUS_EXPR;
<span class="lineNum">   34644 </span><span class="lineCov">          3 :               break;</span>
<span class="lineNum">   34645 </span>            :             case CPP_LSHIFT:
<span class="lineNum">   34646 </span><span class="lineCov">        289 :               opcode = LSHIFT_EXPR;</span>
<span class="lineNum">   34647 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">   34648 </span><span class="lineCov">        289 :             case CPP_RSHIFT:</span>
<span class="lineNum">   34649 </span>            :               opcode = RSHIFT_EXPR;
<span class="lineNum">   34650 </span><span class="lineCov">        144 :               break;</span>
<span class="lineNum">   34651 </span><span class="lineCov">        144 :             case CPP_AND:</span>
<span class="lineNum">   34652 </span>            :               opcode = BIT_AND_EXPR;
<span class="lineNum">   34653 </span><span class="lineCov">        136 :               break;</span>
<span class="lineNum">   34654 </span><span class="lineCov">        136 :             case CPP_OR:</span>
<span class="lineNum">   34655 </span><span class="lineCov">        136 :               opcode = BIT_IOR_EXPR;</span>
<span class="lineNum">   34656 </span><span class="lineCov">        136 :               break;</span>
<span class="lineNum">   34657 </span><span class="lineCov">        136 :             case CPP_XOR:</span>
<span class="lineNum">   34658 </span><span class="lineCov">        136 :               opcode = BIT_XOR_EXPR;</span>
<span class="lineNum">   34659 </span><span class="lineCov">        136 :               break;</span>
<span class="lineNum">   34660 </span>            :             default:
<span class="lineNum">   34661 </span><span class="lineCov">          8 :               cp_parser_error (parser,</span>
<span class="lineNum">   34662 </span>            :                                &quot;invalid operator for %&lt;#pragma omp atomic%&gt;&quot;);
<span class="lineNum">   34663 </span>            :               goto saw_error;
<span class="lineNum">   34664 </span>            :             }
<span class="lineNum">   34665 </span>            :           oprec = TOKEN_PRECEDENCE (token);
<span class="lineNum">   34666 </span>            :           gcc_assert (oprec != PREC_NOT_OPERATOR);
<span class="lineNum">   34667 </span>            :           if (commutative_tree_code (opcode))
<span class="lineNum">   34668 </span><span class="lineCov">          3 :             oprec = (enum cp_parser_prec) (oprec - 1);</span>
<span class="lineNum">   34669 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   34670 </span><span class="lineCov">          3 :           rhs = cp_parser_binary_expression (parser, false, false,</span>
<span class="lineNum">   34671 </span>            :                                              oprec, NULL);
<span class="lineNum">   34672 </span>            :           if (rhs == error_mark_node)
<span class="lineNum">   34673 </span>            :             goto saw_error;
<span class="lineNum">   34674 </span>            :           goto stmt_done;
<span class="lineNum">   34675 </span>            :           /* FALLTHROUGH */
<span class="lineNum">   34676 </span>            :         default:
<span class="lineNum">   34677 </span>            :           cp_parser_error (parser,
<span class="lineNum">   34678 </span>            :                            &quot;invalid operator for %&lt;#pragma omp atomic%&gt;&quot;);
<span class="lineNum">   34679 </span>            :           goto saw_error;
<span class="lineNum">   34680 </span>            :         }
<span class="lineNum">   34681 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   34682 </span>            : 
<span class="lineNum">   34683 </span>            :       rhs = cp_parser_expression (parser);
<span class="lineNum">   34684 </span>            :       if (rhs == error_mark_node)
<span class="lineNum">   34685 </span>            :         goto saw_error;
<span class="lineNum">   34686 </span>            :       break;
<span class="lineNum">   34687 </span>            :     }
<span class="lineNum">   34688 </span>            : stmt_done:
<span class="lineNum">   34689 </span>            :   if (structured_block &amp;&amp; code == OMP_ATOMIC_CAPTURE_NEW)
<span class="lineNum">   34690 </span>            :     {
<span class="lineNum">   34691 </span>            :       if (!cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON))
<span class="lineNum">   34692 </span>            :         goto saw_error;
<span class="lineNum">   34693 </span>            :       v = cp_parser_unary_expression (parser);
<span class="lineNum">   34694 </span>            :       if (v == error_mark_node)
<span class="lineNum">   34695 </span>            :         goto saw_error;
<span class="lineNum">   34696 </span>            :       if (!cp_parser_require (parser, CPP_EQ, RT_EQ))
<span class="lineNum">   34697 </span>            :         goto saw_error;
<span class="lineNum">   34698 </span><span class="lineNoCov">          0 :       lhs1 = cp_parser_unary_expression (parser);</span>
<span class="lineNum">   34699 </span><span class="lineNoCov">          0 :       if (lhs1 == error_mark_node)</span>
<span class="lineNum">   34700 </span>            :         goto saw_error;
<span class="lineNum">   34701 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   34702 </span>            :   if (structured_block)
<span class="lineNum">   34703 </span><span class="lineCov">        145 :     {</span>
<span class="lineNum">   34704 </span><span class="lineCov">        145 :       cp_parser_consume_semicolon_at_end_of_statement (parser);</span>
<span class="lineNum">   34705 </span><span class="lineCov">        145 :       cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE);</span>
<span class="lineNum">   34706 </span><span class="lineCov">         86 :     }</span>
<span class="lineNum">   34707 </span><span class="lineCov">        145 : done:</span>
<span class="lineNum">   34708 </span><span class="lineCov">        290 :   finish_omp_atomic (code, opcode, lhs, rhs, v, lhs1, rhs1, seq_cst);</span>
<span class="lineNum">   34709 </span><span class="lineCov">        145 :   if (!structured_block)</span>
<span class="lineNum">   34710 </span><span class="lineCov">        145 :     cp_parser_consume_semicolon_at_end_of_statement (parser);</span>
<span class="lineNum">   34711 </span>            :   return;
<span class="lineNum">   34712 </span>            : 
<span class="lineNum">   34713 </span>            :  saw_error:
<span class="lineNum">   34714 </span><span class="lineCov">          6 :   cp_parser_skip_to_end_of_block_or_statement (parser);</span>
<span class="lineNum">   34715 </span><span class="lineCov">          6 :   if (structured_block)</span>
<span class="lineNum">   34716 </span>            :     {
<span class="lineNum">   34717 </span><span class="lineCov">          6 :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_CLOSE_BRACE))</span>
<span class="lineNum">   34718 </span>            :         cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   34719 </span><span class="lineCov">        850 :       else if (code == OMP_ATOMIC_CAPTURE_NEW)</span>
<span class="lineNum">   34720 </span>            :         {
<span class="lineNum">   34721 </span><span class="lineCov">        850 :           cp_parser_skip_to_end_of_block_or_statement (parser);</span>
<span class="lineNum">   34722 </span><span class="lineCov">        850 :           if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_CLOSE_BRACE))</span>
<span class="lineNum">   34723 </span>            :             cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   34724 </span>            :         }
<span class="lineNum">   34725 </span>            :     }
<span class="lineNum">   34726 </span><span class="lineCov">       1459 : }</span>
<span class="lineNum">   34727 </span><span class="lineCov">       1459 : </span>
<span class="lineNum">   34728 </span>            : 
<span class="lineNum">   34729 </span><span class="lineCov">        103 : /* OpenMP 2.5:</span>
<span class="lineNum">   34730 </span>            :    # pragma omp barrier new-line  */
<a name="34731"><span class="lineNum">   34731 </span><span class="lineCov">         91 : </span></a>
<span class="lineNum">   34732 </span><span class="lineCov">         91 : static void</span>
<span class="lineNum">   34733 </span>            : cp_parser_omp_barrier (cp_parser *parser, cp_token *pragma_tok)
<span class="lineNum">   34734 </span><span class="lineCov">         91 : {</span>
<span class="lineNum">   34735 </span>            :   cp_parser_require_pragma_eol (parser, pragma_tok);
<span class="lineNum">   34736 </span><span class="lineCov">         91 :   finish_omp_barrier ();</span>
<span class="lineNum">   34737 </span><span class="lineCov">         91 : }</span>
<span class="lineNum">   34738 </span>            : 
<span class="lineNum">   34739 </span>            : /* OpenMP 2.5:
<span class="lineNum">   34740 </span><span class="lineCov">       1447 :    # pragma omp critical [(name)] new-line</span>
<span class="lineNum">   34741 </span>            :      structured-block
<span class="lineNum">   34742 </span><span class="lineCov">        227 : </span>
<span class="lineNum">   34743 </span><span class="lineCov">        227 :    OpenMP 4.5:</span>
<span class="lineNum">   34744 </span>            :    # pragma omp critical [(name) [hint(expression)]] new-line
<span class="lineNum">   34745 </span><span class="lineCov">       1220 :      structured-block  */</span>
<span class="lineNum">   34746 </span><span class="lineCov">       1652 : </span>
<span class="lineNum">   34747 </span><span class="lineCov">       1652 : #define OMP_CRITICAL_CLAUSE_MASK                \</span>
<span class="lineNum">   34748 </span><span class="lineCov">       1425 :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_HINT) )</span>
<a name="34749"><span class="lineNum">   34749 </span>            : </a>
<span class="lineNum">   34750 </span>            : static tree
<span class="lineNum">   34751 </span><span class="lineCov">         42 : cp_parser_omp_critical (cp_parser *parser, cp_token *pragma_tok, bool *if_p)</span>
<span class="lineNum">   34752 </span><span class="lineCov">         42 : {</span>
<span class="lineNum">   34753 </span><span class="lineCov">         42 :   tree stmt, name = NULL_TREE, clauses = NULL_TREE;</span>
<span class="lineNum">   34754 </span>            : 
<span class="lineNum">   34755 </span><span class="lineCov">         12 :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_PAREN))</span>
<span class="lineNum">   34756 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   34757 </span><span class="lineCov">         12 :       matching_parens parens;</span>
<span class="lineNum">   34758 </span>            :       parens.consume_open (parser);
<span class="lineNum">   34759 </span><span class="lineCov">         12 : </span>
<span class="lineNum">   34760 </span><span class="lineCov">         12 :       name = cp_parser_identifier (parser);</span>
<span class="lineNum">   34761 </span><span class="lineCov">         12 : </span>
<span class="lineNum">   34762 </span>            :       if (name == error_mark_node
<span class="lineNum">   34763 </span>            :           || !parens.require_close (parser))
<span class="lineNum">   34764 </span>            :         cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,
<span class="lineNum">   34765 </span>            :                                                /*or_comma=*/false,
<span class="lineNum">   34766 </span>            :                                                /*consume_paren=*/true);
<span class="lineNum">   34767 </span>            :       if (name == error_mark_node)
<span class="lineNum">   34768 </span>            :         name = NULL;
<span class="lineNum">   34769 </span>            : 
<span class="lineNum">   34770 </span>            :       clauses = cp_parser_omp_all_clauses (parser,
<span class="lineNum">   34771 </span><span class="lineNoCov">          0 :                                            OMP_CRITICAL_CLAUSE_MASK,</span>
<span class="lineNum">   34772 </span>            :                                            &quot;#pragma omp critical&quot;, pragma_tok);
<span class="lineNum">   34773 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">   34774 </span><span class="lineNoCov">          0 :   else</span>
<span class="lineNum">   34775 </span><span class="lineNoCov">          0 :     cp_parser_require_pragma_eol (parser, pragma_tok);</span>
<span class="lineNum">   34776 </span>            : 
<span class="lineNum">   34777 </span>            :   stmt = cp_parser_omp_structured_block (parser, if_p);
<span class="lineNum">   34778 </span>            :   return c_finish_omp_critical (input_location, stmt, name, clauses);
<span class="lineNum">   34779 </span>            : }
<span class="lineNum">   34780 </span>            : 
<span class="lineNum">   34781 </span>            : /* OpenMP 2.5:
<span class="lineNum">   34782 </span>            :    # pragma omp flush flush-vars[opt] new-line
<span class="lineNum">   34783 </span>            : 
<span class="lineNum">   34784 </span>            :    flush-vars:
<span class="lineNum">   34785 </span>            :      ( variable-list ) */
<a name="34786"><span class="lineNum">   34786 </span>            : </a>
<span class="lineNum">   34787 </span>            : static void
<span class="lineNum">   34788 </span>            : cp_parser_omp_flush (cp_parser *parser, cp_token *pragma_tok)
<span class="lineNum">   34789 </span><span class="lineCov">        129 : {</span>
<span class="lineNum">   34790 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_PAREN))
<span class="lineNum">   34791 </span><span class="lineCov">        129 :     (void) cp_parser_omp_var_list (parser, OMP_CLAUSE_ERROR, NULL);</span>
<span class="lineNum">   34792 </span>            :   cp_parser_require_pragma_eol (parser, pragma_tok);
<span class="lineNum">   34793 </span><span class="lineCov">        129 : </span>
<span class="lineNum">   34794 </span>            :   finish_omp_flush ();
<span class="lineNum">   34795 </span><span class="lineCov">         36 : }</span>
<span class="lineNum">   34796 </span><span class="lineCov">         18 : </span>
<span class="lineNum">   34797 </span>            : /* Helper function, to parse omp for increment expression.  */
<a name="34798"><span class="lineNum">   34798 </span><span class="lineCov">         18 : </span></a>
<span class="lineNum">   34799 </span>            : static tree
<span class="lineNum">   34800 </span><span class="lineCov">         18 : cp_parser_omp_for_cond (cp_parser *parser, tree decl)</span>
<span class="lineNum">   34801 </span><span class="lineCov">         18 : {</span>
<span class="lineNum">   34802 </span><span class="lineCov">          9 :   tree cond = cp_parser_binary_expression (parser, false, true,</span>
<span class="lineNum">   34803 </span>            :                                            PREC_NOT_OPERATOR, NULL);
<span class="lineNum">   34804 </span>            :   if (cond == error_mark_node
<span class="lineNum">   34805 </span><span class="lineCov">         18 :       || cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_SEMICOLON))</span>
<span class="lineNum">   34806 </span><span class="lineCov">          3 :     {</span>
<span class="lineNum">   34807 </span>            :       cp_parser_skip_to_end_of_statement (parser);
<span class="lineNum">   34808 </span><span class="lineCov">         18 :       return error_mark_node;</span>
<span class="lineNum">   34809 </span><span class="lineCov">         18 :     }</span>
<span class="lineNum">   34810 </span>            : 
<span class="lineNum">   34811 </span>            :   switch (TREE_CODE (cond))
<span class="lineNum">   34812 </span>            :     {
<span class="lineNum">   34813 </span><span class="lineCov">        111 :     case GT_EXPR:</span>
<span class="lineNum">   34814 </span>            :     case GE_EXPR:
<span class="lineNum">   34815 </span><span class="lineCov">        129 :     case LT_EXPR:</span>
<span class="lineNum">   34816 </span><span class="lineCov">        129 :     case LE_EXPR:</span>
<span class="lineNum">   34817 </span>            :       break;
<span class="lineNum">   34818 </span>            :     case NE_EXPR:
<span class="lineNum">   34819 </span>            :       /* Fall through: OpenMP disallows NE_EXPR.  */
<span class="lineNum">   34820 </span>            :       gcc_fallthrough ();
<span class="lineNum">   34821 </span>            :     default:
<span class="lineNum">   34822 </span>            :       return error_mark_node;
<span class="lineNum">   34823 </span>            :     }
<span class="lineNum">   34824 </span>            : 
<span class="lineNum">   34825 </span>            :   /* If decl is an iterator, preserve LHS and RHS of the relational
<span class="lineNum">   34826 </span><span class="lineCov">         24 :      expr until finish_omp_for.  */</span>
<span class="lineNum">   34827 </span>            :   if (decl
<span class="lineNum">   34828 </span><span class="lineCov">         24 :       &amp;&amp; (type_dependent_expression_p (decl)</span>
<span class="lineNum">   34829 </span><span class="lineCov">         18 :           || CLASS_TYPE_P (TREE_TYPE (decl))))</span>
<span class="lineNum">   34830 </span><span class="lineCov">         24 :     return cond;</span>
<span class="lineNum">   34831 </span>            : 
<span class="lineNum">   34832 </span><span class="lineCov">         24 :   return build_x_binary_op (cp_expr_loc_or_loc (cond, input_location),</span>
<span class="lineNum">   34833 </span><span class="lineCov">         24 :                             TREE_CODE (cond),</span>
<span class="lineNum">   34834 </span>            :                             TREE_OPERAND (cond, 0), ERROR_MARK,
<span class="lineNum">   34835 </span>            :                             TREE_OPERAND (cond, 1), ERROR_MARK,
<span class="lineNum">   34836 </span>            :                             /*overload=*/NULL, tf_warning_or_error);
<span class="lineNum">   34837 </span>            : }
<span class="lineNum">   34838 </span><span class="lineCov">       9874 : </span>
<span class="lineNum">   34839 </span>            : /* Helper function, to parse omp for increment expression.  */
<a name="34840"><span class="lineNum">   34840 </span><span class="lineCov">       9874 : </span></a>
<span class="lineNum">   34841 </span><span class="lineCov">       9874 : static tree</span>
<span class="lineNum">   34842 </span><span class="lineCov">       9874 : cp_parser_omp_for_incr (cp_parser *parser, tree decl)</span>
<span class="lineNum">   34843 </span><span class="lineCov">       9874 : {</span>
<span class="lineNum">   34844 </span>            :   cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   34845 </span><span class="lineCov">         12 :   enum tree_code op;</span>
<span class="lineNum">   34846 </span><span class="lineCov">         12 :   tree lhs, rhs;</span>
<span class="lineNum">   34847 </span>            :   cp_id_kind idk;
<span class="lineNum">   34848 </span>            :   bool decl_first;
<span class="lineNum">   34849 </span><span class="lineCov">       9862 : </span>
<span class="lineNum">   34850 </span>            :   if (token-&gt;type == CPP_PLUS_PLUS || token-&gt;type == CPP_MINUS_MINUS)
<span class="lineNum">   34851 </span><span class="lineCov">       9829 :     {</span>
<span class="lineNum">   34852 </span><span class="lineCov">       9829 :       op = (token-&gt;type == CPP_PLUS_PLUS</span>
<span class="lineNum">   34853 </span><span class="lineCov">       9829 :             ? PREINCREMENT_EXPR : PREDECREMENT_EXPR);</span>
<span class="lineNum">   34854 </span><span class="lineCov">       9829 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   34855 </span><span class="lineCov">       9829 :       lhs = cp_parser_simple_cast_expression (parser);</span>
<span class="lineNum">   34856 </span>            :       if (lhs != decl
<span class="lineNum">   34857 </span>            :           &amp;&amp; (!processing_template_decl || !cp_tree_equal (lhs, decl)))
<span class="lineNum">   34858 </span>            :         return error_mark_node;
<span class="lineNum">   34859 </span>            :       return build2 (op, TREE_TYPE (decl), decl, NULL_TREE);
<span class="lineNum">   34860 </span>            :     }
<span class="lineNum">   34861 </span>            : 
<span class="lineNum">   34862 </span>            :   lhs = cp_parser_primary_expression (parser, false, false, false, &amp;idk);
<span class="lineNum">   34863 </span>            :   if (lhs != decl
<span class="lineNum">   34864 </span>            :       &amp;&amp; (!processing_template_decl || !cp_tree_equal (lhs, decl)))
<span class="lineNum">   34865 </span><span class="lineCov">       9829 :     return error_mark_node;</span>
<span class="lineNum">   34866 </span><span class="lineCov">       9829 : </span>
<span class="lineNum">   34867 </span><span class="lineCov">       2803 :   token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   34868 </span>            :   if (token-&gt;type == CPP_PLUS_PLUS || token-&gt;type == CPP_MINUS_MINUS)
<span class="lineNum">   34869 </span>            :     {
<span class="lineNum">   34870 </span><span class="lineCov">       9273 :       op = (token-&gt;type == CPP_PLUS_PLUS</span>
<span class="lineNum">   34871 </span><span class="lineCov">       9273 :             ? POSTINCREMENT_EXPR : POSTDECREMENT_EXPR);</span>
<span class="lineNum">   34872 </span><span class="lineCov">       9273 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   34873 </span><span class="lineCov">       9273 :       return build2 (op, TREE_TYPE (decl), decl, NULL_TREE);</span>
<span class="lineNum">   34874 </span><span class="lineCov">       9273 :     }</span>
<span class="lineNum">   34875 </span>            : 
<span class="lineNum">   34876 </span>            :   op = cp_parser_assignment_operator_opt (parser);
<span class="lineNum">   34877 </span>            :   if (op == ERROR_MARK)
<span class="lineNum">   34878 </span>            :     return error_mark_node;
<span class="lineNum">   34879 </span>            : 
<span class="lineNum">   34880 </span><span class="lineCov">       1159 :   if (op != NOP_EXPR)</span>
<span class="lineNum">   34881 </span>            :     {
<span class="lineNum">   34882 </span><span class="lineCov">       2318 :       rhs = cp_parser_assignment_expression (parser);</span>
<span class="lineNum">   34883 </span><span class="lineCov">       1159 :       rhs = build2 (op, TREE_TYPE (decl), decl, rhs);</span>
<span class="lineNum">   34884 </span><span class="lineCov">       1159 :       return build2 (MODIFY_EXPR, TREE_TYPE (decl), decl, rhs);</span>
<span class="lineNum">   34885 </span><span class="lineCov">       1159 :     }</span>
<span class="lineNum">   34886 </span><span class="lineCov">       1159 : </span>
<span class="lineNum">   34887 </span>            :   lhs = cp_parser_binary_expression (parser, false, false,
<span class="lineNum">   34888 </span><span class="lineCov">       1159 :                                      PREC_ADDITIVE_EXPRESSION, NULL);</span>
<span class="lineNum">   34889 </span>            :   token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   34890 </span><span class="lineCov">        246 :   decl_first = (lhs == decl</span>
<span class="lineNum">   34891 </span><span class="lineCov">        123 :                 || (processing_template_decl &amp;&amp; cp_tree_equal (lhs, decl)));</span>
<span class="lineNum">   34892 </span><span class="lineCov">        123 :   if (decl_first)</span>
<span class="lineNum">   34893 </span><span class="lineCov">        123 :     lhs = NULL_TREE;</span>
<span class="lineNum">   34894 </span><span class="lineCov">        123 :   if (token-&gt;type != CPP_PLUS</span>
<span class="lineNum">   34895 </span><span class="lineCov">        123 :       &amp;&amp; token-&gt;type != CPP_MINUS)</span>
<span class="lineNum">   34896 </span><span class="lineNoCov">          0 :     return error_mark_node;</span>
<span class="lineNum">   34897 </span><span class="lineCov">        123 : </span>
<span class="lineNum">   34898 </span>            :   do
<span class="lineNum">   34899 </span>            :     {
<span class="lineNum">   34900 </span><span class="lineCov">       1036 :       op = token-&gt;type == CPP_PLUS ? PLUS_EXPR : MINUS_EXPR;</span>
<span class="lineNum">   34901 </span><span class="lineCov">       1036 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   34902 </span><span class="lineCov">       1036 :       rhs = cp_parser_binary_expression (parser, false, false,</span>
<span class="lineNum">   34903 </span><span class="lineCov">          3 :                                          PREC_ADDITIVE_EXPRESSION, NULL);</span>
<span class="lineNum">   34904 </span>            :       token = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   34905 </span><span class="lineCov">       2066 :       if (token-&gt;type == CPP_PLUS || token-&gt;type == CPP_MINUS || decl_first)</span>
<span class="lineNum">   34906 </span><span class="lineCov">       1033 :         {</span>
<span class="lineNum">   34907 </span>            :           if (lhs == NULL_TREE)
<span class="lineNum">   34908 </span><span class="lineCov">       1228 :             {</span>
<span class="lineNum">   34909 </span><span class="lineCov">        614 :               if (op == PLUS_EXPR)</span>
<span class="lineNum">   34910 </span><span class="lineCov">        614 :                 lhs = rhs;</span>
<span class="lineNum">   34911 </span><span class="lineCov">        614 :               else</span>
<span class="lineNum">   34912 </span>            :                 lhs = build_x_unary_op (input_location, NEGATE_EXPR, rhs,
<span class="lineNum">   34913 </span>            :                                         tf_warning_or_error);
<span class="lineNum">   34914 </span><span class="lineCov">        419 :             }</span>
<span class="lineNum">   34915 </span><span class="lineCov">        419 :           else</span>
<span class="lineNum">   34916 </span><span class="lineNoCov">          0 :             lhs = build_x_binary_op (input_location, op, lhs, ERROR_MARK, rhs,</span>
<span class="lineNum">   34917 </span>            :                                      ERROR_MARK, NULL, tf_warning_or_error);
<span class="lineNum">   34918 </span><span class="lineCov">        419 :         }</span>
<span class="lineNum">   34919 </span>            :     }
<span class="lineNum">   34920 </span><span class="lineCov">        213 :   while (token-&gt;type == CPP_PLUS || token-&gt;type == CPP_MINUS);</span>
<span class="lineNum">   34921 </span><span class="lineCov">        213 : </span>
<span class="lineNum">   34922 </span><span class="lineCov">        213 :   if (!decl_first)</span>
<span class="lineNum">   34923 </span>            :     {
<span class="lineNum">   34924 </span>            :       if ((rhs != decl
<span class="lineNum">   34925 </span><span class="lineCov">        206 :            &amp;&amp; (!processing_template_decl || !cp_tree_equal (rhs, decl)))</span>
<span class="lineNum">   34926 </span><span class="lineCov">        206 :           || op == MINUS_EXPR)</span>
<span class="lineNum">   34927 </span><span class="lineCov">        412 :         return error_mark_node;</span>
<span class="lineNum">   34928 </span><span class="lineCov">        206 :       rhs = build2 (op, TREE_TYPE (decl), lhs, decl);</span>
<span class="lineNum">   34929 </span><span class="lineCov">        206 :     }</span>
<span class="lineNum">   34930 </span>            :   else
<span class="lineNum">   34931 </span>            :     rhs = build2 (PLUS_EXPR, TREE_TYPE (decl), decl, lhs);
<span class="lineNum">   34932 </span><span class="lineCov">        412 : </span>
<span class="lineNum">   34933 </span><span class="lineCov">        206 :   return build2 (MODIFY_EXPR, TREE_TYPE (decl), decl, rhs);</span>
<span class="lineNum">   34934 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   34935 </span>            : 
<span class="lineNum">   34936 </span><span class="lineCov">        246 : /* Parse the initialization statement of an OpenMP for loop.</span>
<span class="lineNum">   34937 </span>            : 
<span class="lineNum">   34938 </span><span class="lineCov">        246 :    Return true if the resulting construct should have an</span>
<span class="lineNum">   34939 </span><span class="lineCov">        246 :    OMP_CLAUSE_PRIVATE added to it.  */</span>
<a name="34940"><span class="lineNum">   34940 </span><span class="lineCov">        246 : </span></a>
<span class="lineNum">   34941 </span><span class="lineCov">        246 : static tree</span>
<span class="lineNum">   34942 </span><span class="lineCov">        492 : cp_parser_omp_for_loop_init (cp_parser *parser,</span>
<span class="lineNum">   34943 </span><span class="lineCov">        246 :                              tree &amp;this_pre_body,</span>
<span class="lineNum">   34944 </span>            :                              vec&lt;tree, va_gc&gt; *&amp;for_block,
<span class="lineNum">   34945 </span><span class="lineCov">        186 :                              tree &amp;init,</span>
<span class="lineNum">   34946 </span>            :                              tree &amp;orig_init,
<span class="lineNum">   34947 </span><span class="lineCov">        146 :                              tree &amp;decl,</span>
<span class="lineNum">   34948 </span>            :                              tree &amp;real_decl)
<span class="lineNum">   34949 </span>            : {
<span class="lineNum">   34950 </span><span class="lineCov">         10 :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_SEMICOLON))</span>
<span class="lineNum">   34951 </span>            :     return NULL_TREE;
<span class="lineNum">   34952 </span>            : 
<span class="lineNum">   34953 </span>            :   tree add_private_clause = NULL_TREE;
<span class="lineNum">   34954 </span><span class="lineCov">         40 : </span>
<span class="lineNum">   34955 </span>            :   /* See 2.5.1 (in OpenMP 3.0, similar wording is in 2.5 standard too):
<span class="lineNum">   34956 </span>            : 
<span class="lineNum">   34957 </span>            :      init-expr:
<span class="lineNum">   34958 </span><span class="lineCov">        246 :      var = lb</span>
<span class="lineNum">   34959 </span>            :      integer-type var = lb
<span class="lineNum">   34960 </span><span class="lineCov">        206 :      random-access-iterator-type var = lb</span>
<span class="lineNum">   34961 </span>            :      pointer-type var = lb
<span class="lineNum">   34962 </span><span class="lineCov">         60 :   */</span>
<span class="lineNum">   34963 </span><span class="lineNoCov">          0 :   cp_decl_specifier_seq type_specifiers;</span>
<span class="lineNum">   34964 </span><span class="lineCov">         60 : </span>
<span class="lineNum">   34965 </span><span class="lineNoCov">          0 :   /* First, try to parse as an initialized declaration.  See</span>
<span class="lineNum">   34966 </span><span class="lineCov">         60 :      cp_parser_condition, from whence the bulk of this is copied.  */</span>
<span class="lineNum">   34967 </span>            : 
<span class="lineNum">   34968 </span>            :   cp_parser_parse_tentatively (parser);
<span class="lineNum">   34969 </span><span class="lineCov">        146 :   cp_parser_type_specifier_seq (parser, /*is_declaration=*/true,</span>
<span class="lineNum">   34970 </span>            :                                 /*is_trailing_return=*/false,
<span class="lineNum">   34971 </span><span class="lineCov">        206 :                                 &amp;type_specifiers);</span>
<span class="lineNum">   34972 </span>            :   if (cp_parser_parse_definitely (parser))
<span class="lineNum">   34973 </span>            :     {
<span class="lineNum">   34974 </span>            :       /* If parsing a type specifier seq succeeded, then this
<span class="lineNum">   34975 </span>            :          MUST be a initialized declaration.  */
<span class="lineNum">   34976 </span>            :       tree asm_specification, attributes;
<span class="lineNum">   34977 </span>            :       cp_declarator *declarator;
<span class="lineNum">   34978 </span>            : 
<span class="lineNum">   34979 </span>            :       declarator = cp_parser_declarator (parser,
<span class="lineNum">   34980 </span><span class="lineCov">       9886 :                                          CP_PARSER_DECLARATOR_NAMED,</span>
<span class="lineNum">   34981 </span>            :                                          /*ctor_dtor_or_conv_p=*/NULL,
<span class="lineNum">   34982 </span>            :                                          /*parenthesized_p=*/NULL,
<span class="lineNum">   34983 </span>            :                                          /*member_p=*/false,
<span class="lineNum">   34984 </span>            :                                          /*friend_p=*/false);
<span class="lineNum">   34985 </span>            :       attributes = cp_parser_attributes_opt (parser);
<span class="lineNum">   34986 </span>            :       asm_specification = cp_parser_asm_specification_opt (parser);
<span class="lineNum">   34987 </span>            : 
<span class="lineNum">   34988 </span><span class="lineCov">       9886 :       if (declarator == cp_error_declarator) </span>
<span class="lineNum">   34989 </span>            :         cp_parser_skip_to_end_of_statement (parser);
<span class="lineNum">   34990 </span>            : 
<span class="lineNum">   34991 </span><span class="lineCov">       9883 :       else </span>
<span class="lineNum">   34992 </span>            :         {
<span class="lineNum">   34993 </span>            :           tree pushed_scope, auto_node;
<span class="lineNum">   34994 </span>            : 
<span class="lineNum">   34995 </span>            :           decl = start_decl (declarator, &amp;type_specifiers,
<span class="lineNum">   34996 </span>            :                              SD_INITIALIZED, attributes,
<span class="lineNum">   34997 </span>            :                              /*prefix_attributes=*/NULL_TREE,
<span class="lineNum">   34998 </span>            :                              &amp;pushed_scope);
<span class="lineNum">   34999 </span>            : 
<span class="lineNum">   35000 </span>            :           auto_node = type_uses_auto (TREE_TYPE (decl));
<span class="lineNum">   35001 </span><span class="lineCov">       9883 :           if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_EQ))</span>
<span class="lineNum">   35002 </span>            :             {
<span class="lineNum">   35003 </span>            :               if (cp_lexer_next_token_is (parser-&gt;lexer, 
<span class="lineNum">   35004 </span>            :                                           CPP_OPEN_PAREN))
<span class="lineNum">   35005 </span>            :                 error (&quot;parenthesized initialization is not allowed in &quot;
<span class="lineNum">   35006 </span><span class="lineCov">       9883 :                        &quot;OpenMP %&lt;for%&gt; loop&quot;);</span>
<span class="lineNum">   35007 </span><span class="lineCov">       9883 :               else</span>
<span class="lineNum">   35008 </span>            :                 /* Trigger an error.  */
<span class="lineNum">   35009 </span>            :                 cp_parser_require (parser, CPP_EQ, RT_EQ);
<span class="lineNum">   35010 </span><span class="lineCov">       9883 : </span>
<span class="lineNum">   35011 </span>            :               init = error_mark_node;
<span class="lineNum">   35012 </span>            :               cp_parser_skip_to_end_of_statement (parser);
<span class="lineNum">   35013 </span>            :             }
<span class="lineNum">   35014 </span><span class="lineCov">       2694 :           else if (CLASS_TYPE_P (TREE_TYPE (decl))</span>
<span class="lineNum">   35015 </span><span class="lineCov">       2694 :                    || type_dependent_expression_p (decl)</span>
<span class="lineNum">   35016 </span>            :                    || auto_node)
<span class="lineNum">   35017 </span><span class="lineCov">       2694 :             {</span>
<span class="lineNum">   35018 </span>            :               bool is_direct_init, is_non_constant_init;
<span class="lineNum">   35019 </span>            : 
<span class="lineNum">   35020 </span>            :               init = cp_parser_initializer (parser,
<span class="lineNum">   35021 </span>            :                                             &amp;is_direct_init,
<span class="lineNum">   35022 </span>            :                                             &amp;is_non_constant_init);
<span class="lineNum">   35023 </span><span class="lineCov">       2694 : </span>
<span class="lineNum">   35024 </span><span class="lineCov">       2694 :               if (auto_node)</span>
<span class="lineNum">   35025 </span>            :                 {
<span class="lineNum">   35026 </span><span class="lineCov">       2694 :                   TREE_TYPE (decl)</span>
<span class="lineNum">   35027 </span><span class="lineNoCov">          0 :                     = do_auto_deduction (TREE_TYPE (decl), init,</span>
<span class="lineNum">   35028 </span>            :                                          auto_node);
<span class="lineNum">   35029 </span>            : 
<span class="lineNum">   35030 </span>            :                   if (!CLASS_TYPE_P (TREE_TYPE (decl))
<span class="lineNum">   35031 </span><span class="lineCov">       2694 :                       &amp;&amp; !type_dependent_expression_p (decl))</span>
<span class="lineNum">   35032 </span>            :                     goto non_class;
<span class="lineNum">   35033 </span><span class="lineCov">       2694 :                 }</span>
<span class="lineNum">   35034 </span>            :                       
<span class="lineNum">   35035 </span>            :               cp_finish_decl (decl, init, !is_non_constant_init,
<span class="lineNum">   35036 </span>            :                               asm_specification,
<span class="lineNum">   35037 </span>            :                               LOOKUP_ONLYCONVERTING);
<span class="lineNum">   35038 </span><span class="lineCov">       2694 :               orig_init = init;</span>
<span class="lineNum">   35039 </span><span class="lineCov">       2694 :               if (CLASS_TYPE_P (TREE_TYPE (decl)))</span>
<span class="lineNum">   35040 </span>            :                 {
<span class="lineNum">   35041 </span><span class="lineCov">          6 :                   vec_safe_push (for_block, this_pre_body);</span>
<span class="lineNum">   35042 </span>            :                   init = NULL_TREE;
<span class="lineNum">   35043 </span><span class="lineCov">          3 :                 }</span>
<span class="lineNum">   35044 </span>            :               else
<span class="lineNum">   35045 </span>            :                 {
<span class="lineNum">   35046 </span>            :                   init = pop_stmt_list (this_pre_body);
<span class="lineNum">   35047 </span><span class="lineCov">          3 :                   if (init &amp;&amp; TREE_CODE (init) == STATEMENT_LIST)</span>
<span class="lineNum">   35048 </span>            :                     {
<span class="lineNum">   35049 </span><span class="lineCov">          6 :                       tree_stmt_iterator i = tsi_start (init);</span>
<span class="lineNum">   35050 </span><span class="lineCov">          6 :                       /* Move lambda DECL_EXPRs to FOR_BLOCK.  */</span>
<span class="lineNum">   35051 </span>            :                       while (!tsi_end_p (i))
<span class="lineNum">   35052 </span><span class="lineCov">       8064 :                         {</span>
<span class="lineNum">   35053 </span><span class="lineCov">       2489 :                           tree t = tsi_stmt (i);</span>
<span class="lineNum">   35054 </span><span class="lineCov">       5066 :                           if (TREE_CODE (t) == DECL_EXPR</span>
<span class="lineNum">   35055 </span>            :                               &amp;&amp; TREE_CODE (DECL_EXPR_DECL (t)) == TYPE_DECL)
<span class="lineNum">   35056 </span><span class="lineCov">        322 :                             {</span>
<span class="lineNum">   35057 </span>            :                               tsi_delink (&amp;i);
<span class="lineNum">   35058 </span><span class="lineCov">        322 :                               vec_safe_push (for_block, t);</span>
<span class="lineNum">   35059 </span>            :                               continue;
<span class="lineNum">   35060 </span>            :                             }
<span class="lineNum">   35061 </span>            :                           break;
<span class="lineNum">   35062 </span><span class="lineCov">        322 :                         }</span>
<span class="lineNum">   35063 </span>            :                       if (tsi_one_before_end_p (i))
<span class="lineNum">   35064 </span><span class="lineCov">         54 :                         {</span>
<span class="lineNum">   35065 </span><span class="lineCov">         18 :                           tree t = tsi_stmt (i);</span>
<span class="lineNum">   35066 </span>            :                           tsi_delink (&amp;i);
<span class="lineNum">   35067 </span>            :                           free_stmt_list (init);
<span class="lineNum">   35068 </span><span class="lineCov">         54 :                           init = t;</span>
<span class="lineNum">   35069 </span><span class="lineCov">         26 :                         }</span>
<span class="lineNum">   35070 </span><span class="lineCov">          4 :                     }</span>
<span class="lineNum">   35071 </span>            :                 }
<span class="lineNum">   35072 </span>            :               this_pre_body = NULL_TREE;
<span class="lineNum">   35073 </span><span class="lineCov">        318 :             }</span>
<span class="lineNum">   35074 </span>            :           else
<span class="lineNum">   35075 </span>            :             {
<span class="lineNum">   35076 </span><span class="lineCov">        318 :               /* Consume '='.  */</span>
<span class="lineNum">   35077 </span><span class="lineCov">        318 :               cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   35078 </span>            :               init = cp_parser_assignment_expression (parser);
<span class="lineNum">   35079 </span><span class="lineCov">        209 : </span>
<span class="lineNum">   35080 </span><span class="lineCov">        209 :             non_class:</span>
<span class="lineNum">   35081 </span>            :               if (TYPE_REF_P (TREE_TYPE (decl)))
<span class="lineNum">   35082 </span>            :                 init = error_mark_node;
<span class="lineNum">   35083 </span>            :               else
<span class="lineNum">   35084 </span><span class="lineCov">        109 :                 cp_finish_decl (decl, NULL_TREE,</span>
<span class="lineNum">   35085 </span><span class="lineCov">        109 :                                 /*init_const_expr_p=*/false,</span>
<span class="lineNum">   35086 </span>            :                                 asm_specification,
<span class="lineNum">   35087 </span><span class="lineCov">          2 :                                 LOOKUP_ONLYCONVERTING);</span>
<span class="lineNum">   35088 </span>            :             }
<span class="lineNum">   35089 </span><span class="lineCov">         10 : </span>
<span class="lineNum">   35090 </span>            :           if (pushed_scope)
<span class="lineNum">   35091 </span><span class="lineCov">          5 :             pop_scope (pushed_scope);</span>
<span class="lineNum">   35092 </span><span class="lineCov">          5 :         }</span>
<span class="lineNum">   35093 </span><span class="lineCov">          5 :     }</span>
<span class="lineNum">   35094 </span>            :   else 
<span class="lineNum">   35095 </span><span class="lineCov">          3 :     {</span>
<span class="lineNum">   35096 </span><span class="lineCov">          3 :       cp_id_kind idk;</span>
<span class="lineNum">   35097 </span><span class="lineCov">          3 :       /* If parsing a type specifier sequence failed, then</span>
<span class="lineNum">   35098 </span>            :          this MUST be a simple expression.  */
<span class="lineNum">   35099 </span><span class="lineCov">          2 :       cp_parser_parse_tentatively (parser);</span>
<span class="lineNum">   35100 </span>            :       decl = cp_parser_primary_expression (parser, false, false,
<span class="lineNum">   35101 </span><span class="lineCov">          2 :                                            false, &amp;idk);</span>
<span class="lineNum">   35102 </span>            :       cp_token *last_tok = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   35103 </span><span class="lineCov">          2 :       if (!cp_parser_error_occurred (parser)</span>
<span class="lineNum">   35104 </span><span class="lineCov">          2 :           &amp;&amp; decl</span>
<span class="lineNum">   35105 </span><span class="lineCov">          2 :           &amp;&amp; (TREE_CODE (decl) == COMPONENT_REF</span>
<span class="lineNum">   35106 </span><span class="lineCov">          2 :               || (TREE_CODE (decl) == SCOPE_REF &amp;&amp; TREE_TYPE (decl))))</span>
<span class="lineNum">   35107 </span>            :         {
<span class="lineNum">   35108 </span>            :           cp_parser_abort_tentative_parse (parser);
<span class="lineNum">   35109 </span>            :           cp_parser_parse_tentatively (parser);
<span class="lineNum">   35110 </span><span class="lineCov">        318 :           cp_token *token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   35111 </span>            :           tree name = cp_parser_id_expression (parser, /*template_p=*/false,
<span class="lineNum">   35112 </span>            :                                                /*check_dependency_p=*/true,
<span class="lineNum">   35113 </span>            :                                                /*template_p=*/NULL,
<span class="lineNum">   35114 </span>            :                                                /*declarator_p=*/false,
<span class="lineNum">   35115 </span><span class="lineCov">       2366 :                                                /*optional_p=*/false);</span>
<span class="lineNum">   35116 </span><span class="lineCov">       2366 :           if (name != error_mark_node</span>
<span class="lineNum">   35117 </span>            :               &amp;&amp; last_tok == cp_lexer_peek_token (parser-&gt;lexer))
<span class="lineNum">   35118 </span><span class="lineCov">       2370 :             {</span>
<span class="lineNum">   35119 </span><span class="lineCov">       2370 :               decl = cp_parser_lookup_name_simple (parser, name,</span>
<span class="lineNum">   35120 </span><span class="lineCov">          6 :                                                    token-&gt;location);</span>
<span class="lineNum">   35121 </span>            :               if (TREE_CODE (decl) == FIELD_DECL)
<span class="lineNum">   35122 </span><span class="lineCov">       2364 :                 add_private_clause = omp_privatize_field (decl, false);</span>
<span class="lineNum">   35123 </span>            :             }
<span class="lineNum">   35124 </span>            :           cp_parser_abort_tentative_parse (parser);
<span class="lineNum">   35125 </span>            :           cp_parser_parse_tentatively (parser);
<span class="lineNum">   35126 </span>            :           decl = cp_parser_primary_expression (parser, false, false,
<span class="lineNum">   35127 </span>            :                                                false, &amp;idk);
<span class="lineNum">   35128 </span><span class="lineCov">       2694 :         }</span>
<span class="lineNum">   35129 </span><span class="lineNoCov">          0 :       if (!cp_parser_error_occurred (parser)</span>
<span class="lineNum">   35130 </span>            :           &amp;&amp; decl
<span class="lineNum">   35131 </span>            :           &amp;&amp; DECL_P (decl)
<span class="lineNum">   35132 </span>            :           &amp;&amp; CLASS_TYPE_P (TREE_TYPE (decl)))
<span class="lineNum">   35133 </span>            :         {
<span class="lineNum">   35134 </span><span class="lineCov">       7189 :           tree rhs;</span>
<span class="lineNum">   35135 </span>            : 
<span class="lineNum">   35136 </span>            :           cp_parser_parse_definitely (parser);
<span class="lineNum">   35137 </span><span class="lineCov">       7189 :           cp_parser_require (parser, CPP_EQ, RT_EQ);</span>
<span class="lineNum">   35138 </span><span class="lineCov">      14378 :           rhs = cp_parser_assignment_expression (parser);</span>
<span class="lineNum">   35139 </span><span class="lineCov">       7189 :           orig_init = rhs;</span>
<span class="lineNum">   35140 </span><span class="lineCov">      14378 :           finish_expr_stmt (build_x_modify_expr (EXPR_LOCATION (rhs),</span>
<span class="lineNum">   35141 </span><span class="lineCov">       7189 :                                                  decl, NOP_EXPR,</span>
<span class="lineNum">   35142 </span><span class="lineCov">       7189 :                                                  rhs,</span>
<span class="lineNum">   35143 </span><span class="lineCov">       7189 :                                                  tf_warning_or_error));</span>
<span class="lineNum">   35144 </span><span class="lineCov">       7174 :           if (!add_private_clause)</span>
<span class="lineNum">   35145 </span>            :             add_private_clause = decl;
<span class="lineNum">   35146 </span><span class="lineCov">         19 :         }</span>
<span class="lineNum">   35147 </span><span class="lineCov">         19 :       else</span>
<span class="lineNum">   35148 </span><span class="lineCov">         38 :         {</span>
<span class="lineNum">   35149 </span><span class="lineCov">         38 :           decl = NULL;</span>
<span class="lineNum">   35150 </span>            :           cp_parser_abort_tentative_parse (parser);
<span class="lineNum">   35151 </span>            :           init = cp_parser_expression (parser);
<span class="lineNum">   35152 </span>            :           if (init)
<span class="lineNum">   35153 </span><span class="lineCov">         19 :             {</span>
<span class="lineNum">   35154 </span><span class="lineCov">         19 :               if (TREE_CODE (init) == MODIFY_EXPR</span>
<span class="lineNum">   35155 </span><span class="lineCov">         19 :                   || TREE_CODE (init) == MODOP_EXPR)</span>
<span class="lineNum">   35156 </span>            :                 real_decl = TREE_OPERAND (init, 0);
<span class="lineNum">   35157 </span><span class="lineCov">         19 :             }</span>
<span class="lineNum">   35158 </span>            :         }
<span class="lineNum">   35159 </span><span class="lineCov">         19 :     }</span>
<span class="lineNum">   35160 </span><span class="lineCov">         19 :   return add_private_clause;</span>
<span class="lineNum">   35161 </span>            : }
<span class="lineNum">   35162 </span><span class="lineCov">         19 : </span>
<span class="lineNum">   35163 </span><span class="lineCov">         19 : /* Parse the restricted form of the for statement allowed by OpenMP.  */</span>
<a name="35164"><span class="lineNum">   35164 </span><span class="lineCov">         19 : </span></a>
<span class="lineNum">   35165 </span><span class="lineCov">         19 : static tree</span>
<span class="lineNum">   35166 </span>            : cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,
<span class="lineNum">   35167 </span><span class="lineCov">       7189 :                         tree *cclauses, bool *if_p)</span>
<span class="lineNum">   35168 </span><span class="lineCov">       7189 : {</span>
<span class="lineNum">   35169 </span><span class="lineCov">       7189 :   tree init, orig_init, cond, incr, body, decl, pre_body = NULL_TREE, ret;</span>
<span class="lineNum">   35170 </span><span class="lineCov">       7174 :   tree real_decl, initv, condv, incrv, declv;</span>
<span class="lineNum">   35171 </span>            :   tree this_pre_body, cl, ordered_cl = NULL_TREE;
<span class="lineNum">   35172 </span><span class="lineCov">        247 :   location_t loc_first;</span>
<span class="lineNum">   35173 </span>            :   bool collapse_err = false;
<span class="lineNum">   35174 </span><span class="lineCov">        247 :   int i, collapse = 1, ordered = 0, count, nbraces = 0;</span>
<span class="lineNum">   35175 </span><span class="lineCov">        247 :   vec&lt;tree, va_gc&gt; *for_block = make_tree_vector ();</span>
<span class="lineNum">   35176 </span><span class="lineCov">        247 :   auto_vec&lt;tree, 4&gt; orig_inits;</span>
<span class="lineNum">   35177 </span><span class="lineCov">        247 :   bool tiling = false;</span>
<span class="lineNum">   35178 </span><span class="lineCov">        741 : </span>
<span class="lineNum">   35179 </span>            :   for (cl = clauses; cl; cl = OMP_CLAUSE_CHAIN (cl))
<span class="lineNum">   35180 </span>            :     if (OMP_CLAUSE_CODE (cl) == OMP_CLAUSE_COLLAPSE)
<span class="lineNum">   35181 </span><span class="lineCov">        494 :       collapse = tree_to_shwi (OMP_CLAUSE_COLLAPSE_EXPR (cl));</span>
<span class="lineNum">   35182 </span><span class="lineCov">        247 :     else if (OMP_CLAUSE_CODE (cl) == OMP_CLAUSE_TILE)</span>
<span class="lineNum">   35183 </span><span class="lineCov">        242 :       {</span>
<span class="lineNum">   35184 </span>            :         tiling = true;
<span class="lineNum">   35185 </span>            :         collapse = list_length (OMP_CLAUSE_TILE_LIST (cl));
<span class="lineNum">   35186 </span>            :       }
<span class="lineNum">   35187 </span><span class="lineCov">       6942 :     else if (OMP_CLAUSE_CODE (cl) == OMP_CLAUSE_ORDERED</span>
<span class="lineNum">   35188 </span><span class="lineCov">       6942 :              &amp;&amp; OMP_CLAUSE_ORDERED_EXPR (cl))</span>
<span class="lineNum">   35189 </span><span class="lineCov">       6942 :       {</span>
<span class="lineNum">   35190 </span><span class="lineCov">       6942 :         ordered_cl = cl;</span>
<span class="lineNum">   35191 </span>            :         ordered = tree_to_shwi (OMP_CLAUSE_ORDERED_EXPR (cl));
<span class="lineNum">   35192 </span><span class="lineCov">       6942 :       }</span>
<span class="lineNum">   35193 </span><span class="lineCov">        293 : </span>
<span class="lineNum">   35194 </span><span class="lineCov">       6930 :   if (ordered &amp;&amp; ordered &lt; collapse)</span>
<span class="lineNum">   35195 </span>            :     {
<span class="lineNum">   35196 </span>            :       error_at (OMP_CLAUSE_LOCATION (ordered_cl),
<span class="lineNum">   35197 </span>            :                 &quot;%&lt;ordered%&gt; clause parameter is less than %&lt;collapse%&gt;&quot;);
<span class="lineNum">   35198 </span>            :       OMP_CLAUSE_ORDERED_EXPR (ordered_cl)
<span class="lineNum">   35199 </span>            :         = build_int_cst (NULL_TREE, collapse);
<span class="lineNum">   35200 </span>            :       ordered = collapse;
<span class="lineNum">   35201 </span>            :     }
<span class="lineNum">   35202 </span>            :   if (ordered)
<span class="lineNum">   35203 </span>            :     {
<span class="lineNum">   35204 </span><span class="lineCov">       7524 :       for (tree *pc = &amp;clauses; *pc; )</span>
<span class="lineNum">   35205 </span>            :         if (OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_LINEAR)
<span class="lineNum">   35206 </span>            :           {
<span class="lineNum">   35207 </span><span class="lineCov">       7524 :             error_at (OMP_CLAUSE_LOCATION (*pc),</span>
<span class="lineNum">   35208 </span><span class="lineCov">       7524 :                       &quot;%&lt;linear%&gt; clause may not be specified together &quot;</span>
<span class="lineNum">   35209 </span><span class="lineCov">       7524 :                       &quot;with %&lt;ordered%&gt; clause with a parameter&quot;);</span>
<span class="lineNum">   35210 </span><span class="lineCov">       7524 :             *pc = OMP_CLAUSE_CHAIN (*pc);</span>
<span class="lineNum">   35211 </span><span class="lineCov">       7524 :           }</span>
<span class="lineNum">   35212 </span><span class="lineCov">       7524 :         else</span>
<span class="lineNum">   35213 </span><span class="lineCov">       7524 :           pc = &amp;OMP_CLAUSE_CHAIN (*pc);</span>
<span class="lineNum">   35214 </span><span class="lineCov">      15048 :     }</span>
<span class="lineNum">   35215 </span><span class="lineCov">       7524 : </span>
<span class="lineNum">   35216 </span>            :   gcc_assert (tiling || (collapse &gt;= 1 &amp;&amp; ordered &gt;= 0));
<span class="lineNum">   35217 </span><span class="lineCov">      16125 :   count = ordered ? ordered : collapse;</span>
<span class="lineNum">   35218 </span><span class="lineCov">       8601 : </span>
<span class="lineNum">   35219 </span><span class="lineCov">       1438 :   declv = make_tree_vec (count);</span>
<span class="lineNum">   35220 </span><span class="lineCov">      14326 :   initv = make_tree_vec (count);</span>
<span class="lineNum">   35221 </span>            :   condv = make_tree_vec (count);
<span class="lineNum">   35222 </span><span class="lineCov">        227 :   incrv = make_tree_vec (count);</span>
<span class="lineNum">   35223 </span><span class="lineCov">        227 : </span>
<span class="lineNum">   35224 </span>            :   loc_first = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">   35225 </span><span class="lineCov">       6936 : </span>
<span class="lineNum">   35226 </span><span class="lineCov">       6936 :   for (i = 0; i &lt; count; i++)</span>
<span class="lineNum">   35227 </span>            :     {
<span class="lineNum">   35228 </span><span class="lineCov">        102 :       int bracecount = 0;</span>
<span class="lineNum">   35229 </span><span class="lineCov">        102 :       tree add_private_clause = NULL_TREE;</span>
<span class="lineNum">   35230 </span>            :       location_t loc;
<span class="lineNum">   35231 </span>            : 
<span class="lineNum">   35232 </span><span class="lineCov">       7524 :       if (!cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_FOR))</span>
<span class="lineNum">   35233 </span>            :         {
<span class="lineNum">   35234 </span><span class="lineCov">          6 :           if (!collapse_err)</span>
<span class="lineNum">   35235 </span>            :             cp_parser_error (parser, &quot;for statement expected&quot;);
<span class="lineNum">   35236 </span><span class="lineCov">          6 :           return NULL;</span>
<span class="lineNum">   35237 </span><span class="lineCov">         18 :         }</span>
<span class="lineNum">   35238 </span><span class="lineCov">          6 :       loc = cp_lexer_consume_token (parser-&gt;lexer)-&gt;location;</span>
<span class="lineNum">   35239 </span>            : 
<span class="lineNum">   35240 </span><span class="lineCov">       7524 :       matching_parens parens;</span>
<span class="lineNum">   35241 </span>            :       if (!parens.require_open (parser))
<span class="lineNum">   35242 </span><span class="lineCov">        279 :         return NULL;</span>
<span class="lineNum">   35243 </span><span class="lineCov">        177 : </span>
<span class="lineNum">   35244 </span>            :       init = orig_init = decl = real_decl = NULL;
<span class="lineNum">   35245 </span><span class="lineNoCov">          0 :       this_pre_body = push_stmt_list ();</span>
<span class="lineNum">   35246 </span>            : 
<span class="lineNum">   35247 </span>            :       add_private_clause
<span class="lineNum">   35248 </span><span class="lineNoCov">          0 :         = cp_parser_omp_for_loop_init (parser, this_pre_body, for_block,</span>
<span class="lineNum">   35249 </span>            :                                        init, orig_init, decl, real_decl);
<span class="lineNum">   35250 </span>            : 
<span class="lineNum">   35251 </span><span class="lineCov">        354 :       cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);</span>
<span class="lineNum">   35252 </span>            :       if (this_pre_body)
<span class="lineNum">   35253 </span>            :         {
<span class="lineNum">   35254 </span><span class="lineCov">       7524 :           this_pre_body = pop_stmt_list (this_pre_body);</span>
<span class="lineNum">   35255 </span><span class="lineCov">       7524 :           if (pre_body)</span>
<span class="lineNum">   35256 </span>            :             {
<span class="lineNum">   35257 </span><span class="lineCov">       7524 :               tree t = pre_body;</span>
<span class="lineNum">   35258 </span><span class="lineCov">       7524 :               pre_body = push_stmt_list ();</span>
<span class="lineNum">   35259 </span><span class="lineCov">       7524 :               add_stmt (t);</span>
<span class="lineNum">   35260 </span><span class="lineCov">       7524 :               add_stmt (this_pre_body);</span>
<span class="lineNum">   35261 </span>            :               pre_body = pop_stmt_list (pre_body);
<span class="lineNum">   35262 </span><span class="lineCov">      15048 :             }</span>
<span class="lineNum">   35263 </span>            :           else
<span class="lineNum">   35264 </span><span class="lineCov">       9904 :             pre_body = this_pre_body;</span>
<span class="lineNum">   35265 </span>            :         }
<span class="lineNum">   35266 </span><span class="lineCov">       9904 : </span>
<span class="lineNum">   35267 </span><span class="lineCov">       9904 :       if (decl)</span>
<span class="lineNum">   35268 </span><span class="lineCov">       9904 :         real_decl = decl;</span>
<span class="lineNum">   35269 </span>            :       if (cclauses != NULL
<span class="lineNum">   35270 </span><span class="lineCov">       9904 :           &amp;&amp; cclauses[C_OMP_CLAUSE_SPLIT_PARALLEL] != NULL</span>
<span class="lineNum">   35271 </span>            :           &amp;&amp; real_decl != NULL_TREE)
<span class="lineNum">   35272 </span><span class="lineCov">         18 :         {</span>
<span class="lineNum">   35273 </span><span class="lineCov">         15 :           tree *c;</span>
<span class="lineNum">   35274 </span><span class="lineCov">         18 :           for (c = &amp;cclauses[C_OMP_CLAUSE_SPLIT_PARALLEL]; *c ; )</span>
<span class="lineNum">   35275 </span>            :             if (OMP_CLAUSE_CODE (*c) == OMP_CLAUSE_FIRSTPRIVATE
<span class="lineNum">   35276 </span><span class="lineCov">       9886 :                 &amp;&amp; OMP_CLAUSE_DECL (*c) == real_decl)</span>
<span class="lineNum">   35277 </span>            :               {
<span class="lineNum">   35278 </span><span class="lineCov">      19772 :                 error_at (loc, &quot;iteration variable %qD&quot;</span>
<span class="lineNum">   35279 </span><span class="lineCov">       9886 :                           &quot; should not be firstprivate&quot;, real_decl);</span>
<span class="lineNum">   35280 </span>            :                 *c = OMP_CLAUSE_CHAIN (*c);
<span class="lineNum">   35281 </span>            :               }
<span class="lineNum">   35282 </span><span class="lineCov">       9886 :             else if (OMP_CLAUSE_CODE (*c) == OMP_CLAUSE_LASTPRIVATE</span>
<span class="lineNum">   35283 </span><span class="lineCov">       9886 :                      &amp;&amp; OMP_CLAUSE_DECL (*c) == real_decl)</span>
<span class="lineNum">   35284 </span>            :               {
<span class="lineNum">   35285 </span><span class="lineCov">       9886 :                 /* Move lastprivate (decl) clause to OMP_FOR_CLAUSES.  */</span>
<span class="lineNum">   35286 </span><span class="lineCov">       9886 :                 tree l = *c;</span>
<span class="lineNum">   35287 </span>            :                 *c = OMP_CLAUSE_CHAIN (*c);
<span class="lineNum">   35288 </span>            :                 if (code == OMP_SIMD)
<span class="lineNum">   35289 </span><span class="lineCov">       9886 :                   {</span>
<span class="lineNum">   35290 </span><span class="lineCov">       9886 :                     OMP_CLAUSE_CHAIN (l) = cclauses[C_OMP_CLAUSE_SPLIT_FOR];</span>
<span class="lineNum">   35291 </span>            :                     cclauses[C_OMP_CLAUSE_SPLIT_FOR] = l;
<span class="lineNum">   35292 </span><span class="lineCov">       9568 :                   }</span>
<span class="lineNum">   35293 </span><span class="lineCov">       9568 :                 else</span>
<span class="lineNum">   35294 </span>            :                   {
<span class="lineNum">   35295 </span><span class="lineCov">       2301 :                     OMP_CLAUSE_CHAIN (l) = clauses;</span>
<span class="lineNum">   35296 </span><span class="lineCov">       2301 :                     clauses = l;</span>
<span class="lineNum">   35297 </span><span class="lineCov">       2301 :                   }</span>
<span class="lineNum">   35298 </span><span class="lineCov">       2301 :                 add_private_clause = NULL_TREE;</span>
<span class="lineNum">   35299 </span><span class="lineCov">       2301 :               }</span>
<span class="lineNum">   35300 </span>            :             else
<span class="lineNum">   35301 </span>            :               {
<span class="lineNum">   35302 </span>            :                 if (OMP_CLAUSE_CODE (*c) == OMP_CLAUSE_PRIVATE
<span class="lineNum">   35303 </span>            :                     &amp;&amp; OMP_CLAUSE_DECL (*c) == real_decl)
<span class="lineNum">   35304 </span>            :                   add_private_clause = NULL_TREE;
<span class="lineNum">   35305 </span><span class="lineCov">       9886 :                 c = &amp;OMP_CLAUSE_CHAIN (*c);</span>
<span class="lineNum">   35306 </span><span class="lineCov">       2941 :               }</span>
<span class="lineNum">   35307 </span><span class="lineCov">       9886 :         }</span>
<span class="lineNum">   35308 </span><span class="lineCov">       4225 : </span>
<span class="lineNum">   35309 </span><span class="lineCov">        547 :       if (add_private_clause)</span>
<span class="lineNum">   35310 </span>            :         {
<span class="lineNum">   35311 </span><span class="lineCov">        547 :           tree c;</span>
<span class="lineNum">   35312 </span><span class="lineCov">       2379 :           for (c = clauses; c ; c = OMP_CLAUSE_CHAIN (c))</span>
<span class="lineNum">   35313 </span><span class="lineCov">       1832 :             {</span>
<span class="lineNum">   35314 </span><span class="lineCov">       1832 :               if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_PRIVATE</span>
<span class="lineNum">   35315 </span>            :                    || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE)
<span class="lineNum">   35316 </span><span class="lineCov">          3 :                   &amp;&amp; OMP_CLAUSE_DECL (c) == decl)</span>
<span class="lineNum">   35317 </span>            :                 break;
<span class="lineNum">   35318 </span><span class="lineCov">          3 :               else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FIRSTPRIVATE</span>
<span class="lineNum">   35319 </span>            :                        &amp;&amp; OMP_CLAUSE_DECL (c) == decl)
<span class="lineNum">   35320 </span><span class="lineCov">       1829 :                 error_at (loc, &quot;iteration variable %qD &quot;</span>
<span class="lineNum">   35321 </span><span class="lineCov">       1829 :                           &quot;should not be firstprivate&quot;,</span>
<span class="lineNum">   35322 </span>            :                           decl);
<span class="lineNum">   35323 </span>            :               else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION
<span class="lineNum">   35324 </span><span class="lineCov">         50 :                        &amp;&amp; OMP_CLAUSE_DECL (c) == decl)</span>
<span class="lineNum">   35325 </span><span class="lineCov">        100 :                 error_at (loc, &quot;iteration variable %qD should not be reduction&quot;,</span>
<span class="lineNum">   35326 </span><span class="lineCov">         50 :                           decl);</span>
<span class="lineNum">   35327 </span>            :             }
<span class="lineNum">   35328 </span><span class="lineCov">         10 :           if (c == NULL)</span>
<span class="lineNum">   35329 </span><span class="lineCov">         10 :             {</span>
<span class="lineNum">   35330 </span>            :               if (code != OMP_SIMD)
<span class="lineNum">   35331 </span>            :                 c = build_omp_clause (loc, OMP_CLAUSE_PRIVATE);
<span class="lineNum">   35332 </span>            :               else if (collapse == 1)
<span class="lineNum">   35333 </span><span class="lineCov">         40 :                 c = build_omp_clause (loc, OMP_CLAUSE_LINEAR);</span>
<span class="lineNum">   35334 </span><span class="lineCov">         40 :               else</span>
<span class="lineNum">   35335 </span>            :                 c = build_omp_clause (loc, OMP_CLAUSE_LASTPRIVATE);
<span class="lineNum">   35336 </span>            :               OMP_CLAUSE_DECL (c) = add_private_clause;
<span class="lineNum">   35337 </span>            :               c = finish_omp_clauses (c, C_ORT_OMP);
<span class="lineNum">   35338 </span>            :               if (c)
<span class="lineNum">   35339 </span>            :                 {
<span class="lineNum">   35340 </span><span class="lineCov">       1779 :                   OMP_CLAUSE_CHAIN (c) = clauses;</span>
<span class="lineNum">   35341 </span><span class="lineCov">       1779 :                   clauses = c;</span>
<span class="lineNum">   35342 </span>            :                   /* For linear, signal that we need to fill up
<span class="lineNum">   35343 </span><span class="lineCov">       3558 :                      the so far unknown linear step.  */</span>
<span class="lineNum">   35344 </span>            :                   if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LINEAR)
<span class="lineNum">   35345 </span>            :                     OMP_CLAUSE_LINEAR_STEP (c) = NULL_TREE;
<span class="lineNum">   35346 </span>            :                 }
<span class="lineNum">   35347 </span><span class="lineCov">       9886 :             }</span>
<span class="lineNum">   35348 </span>            :         }
<span class="lineNum">   35349 </span><span class="lineCov">        238 : </span>
<span class="lineNum">   35350 </span><span class="lineCov">        497 :       cond = NULL;</span>
<span class="lineNum">   35351 </span>            :       if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_SEMICOLON))
<span class="lineNum">   35352 </span><span class="lineCov">        299 :         cond = cp_parser_omp_for_cond (parser, decl);</span>
<span class="lineNum">   35353 </span><span class="lineCov">        482 :       cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);</span>
<span class="lineNum">   35354 </span><span class="lineCov">        419 : </span>
<span class="lineNum">   35355 </span>            :       incr = NULL;
<span class="lineNum">   35356 </span><span class="lineCov">        259 :       if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_CLOSE_PAREN))</span>
<span class="lineNum">   35357 </span><span class="lineCov">        259 :         {</span>
<span class="lineNum">   35358 </span><span class="lineNoCov">          0 :           /* If decl is an iterator, preserve the operator on decl</span>
<span class="lineNum">   35359 </span>            :              until finish_omp_for.  */
<span class="lineNum">   35360 </span>            :           if (real_decl
<span class="lineNum">   35361 </span><span class="lineCov">        259 :               &amp;&amp; ((processing_template_decl</span>
<span class="lineNum">   35362 </span><span class="lineCov">        259 :                    &amp;&amp; (TREE_TYPE (real_decl) == NULL_TREE</span>
<span class="lineNum">   35363 </span><span class="lineNoCov">          0 :                        || !INDIRECT_TYPE_P (TREE_TYPE (real_decl))))</span>
<span class="lineNum">   35364 </span>            :                   || CLASS_TYPE_P (TREE_TYPE (real_decl))))
<span class="lineNum">   35365 </span>            :             incr = cp_parser_omp_for_incr (parser, real_decl);
<span class="lineNum">   35366 </span><span class="lineCov">        238 :           else</span>
<span class="lineNum">   35367 </span>            :             incr = cp_parser_expression (parser);
<span class="lineNum">   35368 </span><span class="lineCov">        198 :           if (!EXPR_HAS_LOCATION (incr))</span>
<span class="lineNum">   35369 </span><span class="lineCov">        188 :             protected_set_expr_location (incr, input_location);</span>
<span class="lineNum">   35370 </span><span class="lineCov">         10 :         }</span>
<span class="lineNum">   35371 </span><span class="lineCov">          4 : </span>
<span class="lineNum">   35372 </span>            :       if (!parens.require_close (parser))
<span class="lineNum">   35373 </span><span class="lineCov">          6 :         cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,</span>
<span class="lineNum">   35374 </span><span class="lineCov">        198 :                                                /*or_comma=*/false,</span>
<span class="lineNum">   35375 </span><span class="lineCov">        198 :                                                /*consume_paren=*/true);</span>
<span class="lineNum">   35376 </span><span class="lineCov">        198 : </span>
<span class="lineNum">   35377 </span>            :       TREE_VEC_ELT (declv, i) = decl;
<span class="lineNum">   35378 </span><span class="lineCov">        198 :       TREE_VEC_ELT (initv, i) = init;</span>
<span class="lineNum">   35379 </span><span class="lineCov">        198 :       TREE_VEC_ELT (condv, i) = cond;</span>
<span class="lineNum">   35380 </span>            :       TREE_VEC_ELT (incrv, i) = incr;
<span class="lineNum">   35381 </span>            :       if (orig_init)
<span class="lineNum">   35382 </span><span class="lineCov">        396 :         {</span>
<span class="lineNum">   35383 </span><span class="lineCov">          4 :           orig_inits.safe_grow_cleared (i + 1);</span>
<span class="lineNum">   35384 </span>            :           orig_inits[i] = orig_init;
<span class="lineNum">   35385 </span>            :         }
<span class="lineNum">   35386 </span>            : 
<span class="lineNum">   35387 </span>            :       if (i == count - 1)
<span class="lineNum">   35388 </span><span class="lineCov">       9886 :         break;</span>
<span class="lineNum">   35389 </span><span class="lineCov">       9886 : </span>
<span class="lineNum">   35390 </span><span class="lineCov">       9874 :       /* FIXME: OpenMP 3.0 draft isn't very clear on what exactly is allowed</span>
<span class="lineNum">   35391 </span><span class="lineCov">       9886 :          in between the collapsed for loops to be still considered perfectly</span>
<span class="lineNum">   35392 </span>            :          nested.  Hopefully the final version clarifies this.
<span class="lineNum">   35393 </span><span class="lineCov">       9886 :          For now handle (multiple) {'s and empty statements.  */</span>
<span class="lineNum">   35394 </span><span class="lineCov">       9886 :       cp_parser_parse_tentatively (parser);</span>
<span class="lineNum">   35395 </span>            :       for (;;)
<span class="lineNum">   35396 </span>            :         {
<span class="lineNum">   35397 </span>            :           if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_FOR))
<span class="lineNum">   35398 </span><span class="lineCov">       9877 :             break;</span>
<span class="lineNum">   35399 </span><span class="lineCov">       9865 :           else if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_BRACE))</span>
<span class="lineNum">   35400 </span><span class="lineCov">        813 :             {</span>
<span class="lineNum">   35401 </span><span class="lineCov">       1608 :               cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   35402 </span><span class="lineCov">      18949 :               bracecount++;</span>
<span class="lineNum">   35403 </span><span class="lineCov">       1159 :             }</span>
<span class="lineNum">   35404 </span>            :           else if (bracecount
<span class="lineNum">   35405 </span><span class="lineCov">       8718 :                    &amp;&amp; cp_lexer_next_token_is (parser-&gt;lexer, CPP_SEMICOLON))</span>
<span class="lineNum">   35406 </span><span class="lineCov">       9877 :             cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   35407 </span><span class="lineCov">       1177 :           else</span>
<span class="lineNum">   35408 </span>            :             {
<span class="lineNum">   35409 </span>            :               loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">   35410 </span><span class="lineCov">       9886 :               error_at (loc, &quot;not enough for loops to collapse&quot;);</span>
<span class="lineNum">   35411 </span><span class="lineCov">          9 :               collapse_err = true;</span>
<span class="lineNum">   35412 </span>            :               cp_parser_abort_tentative_parse (parser);
<span class="lineNum">   35413 </span>            :               declv = NULL_TREE;
<span class="lineNum">   35414 </span>            :               break;
<span class="lineNum">   35415 </span><span class="lineCov">       9886 :             }</span>
<span class="lineNum">   35416 </span><span class="lineCov">       9886 :         }</span>
<span class="lineNum">   35417 </span><span class="lineCov">       9886 : </span>
<span class="lineNum">   35418 </span><span class="lineCov">       9886 :       if (declv)</span>
<span class="lineNum">   35419 </span><span class="lineCov">       9886 :         {</span>
<span class="lineNum">   35420 </span>            :           cp_parser_parse_definitely (parser);
<span class="lineNum">   35421 </span><span class="lineCov">        565 :           nbraces += bracecount;</span>
<span class="lineNum">   35422 </span><span class="lineCov">        565 :         }</span>
<span class="lineNum">   35423 </span>            :     }
<span class="lineNum">   35424 </span>            : 
<span class="lineNum">   35425 </span><span class="lineCov">       9886 :   if (nbraces)</span>
<span class="lineNum">   35426 </span>            :     if_p = NULL;
<span class="lineNum">   35427 </span>            : 
<span class="lineNum">   35428 </span>            :   /* Note that we saved the original contents of this flag when we entered
<span class="lineNum">   35429 </span>            :      the structured block, and so we don't need to re-save it here.  */
<span class="lineNum">   35430 </span>            :   parser-&gt;in_statement = IN_OMP_FOR;
<span class="lineNum">   35431 </span>            : 
<span class="lineNum">   35432 </span><span class="lineCov">       2380 :   /* Note that the grammar doesn't call for a structured block here,</span>
<span class="lineNum">   35433 </span><span class="lineCov">       2437 :      though the loop as a whole is a structured block.  */</span>
<span class="lineNum">   35434 </span>            :   body = push_stmt_list ();
<span class="lineNum">   35435 </span><span class="lineCov">       2437 :   cp_parser_statement (parser, NULL_TREE, false, if_p);</span>
<span class="lineNum">   35436 </span>            :   body = pop_stmt_list (body);
<span class="lineNum">   35437 </span><span class="lineCov">         60 : </span>
<span class="lineNum">   35438 </span>            :   if (declv == NULL_TREE)
<span class="lineNum">   35439 </span><span class="lineCov">         57 :     ret = NULL_TREE;</span>
<span class="lineNum">   35440 </span><span class="lineCov">         57 :   else</span>
<span class="lineNum">   35441 </span>            :     ret = finish_omp_for (loc_first, code, declv, NULL, initv, condv, incrv,
<span class="lineNum">   35442 </span><span class="lineCov">          3 :                           body, pre_body, &amp;orig_inits, clauses);</span>
<span class="lineNum">   35443 </span><span class="lineCov">          3 : </span>
<span class="lineNum">   35444 </span><span class="lineNoCov">          0 :   while (nbraces)</span>
<span class="lineNum">   35445 </span>            :     {
<span class="lineNum">   35446 </span>            :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_CLOSE_BRACE))
<span class="lineNum">   35447 </span><span class="lineCov">          6 :         {</span>
<span class="lineNum">   35448 </span><span class="lineCov">          3 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   35449 </span><span class="lineCov">          3 :           nbraces--;</span>
<span class="lineNum">   35450 </span><span class="lineCov">          3 :         }</span>
<span class="lineNum">   35451 </span><span class="lineCov">          3 :       else if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_SEMICOLON))</span>
<span class="lineNum">   35452 </span><span class="lineCov">          3 :         cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   35453 </span>            :       else
<span class="lineNum">   35454 </span>            :         {
<span class="lineNum">   35455 </span>            :           if (!collapse_err)
<span class="lineNum">   35456 </span><span class="lineCov">       2380 :             {</span>
<span class="lineNum">   35457 </span>            :               error_at (cp_lexer_peek_token (parser-&gt;lexer)-&gt;location,
<span class="lineNum">   35458 </span><span class="lineCov">       2377 :                         &quot;collapsed loops not perfectly nested&quot;);</span>
<span class="lineNum">   35459 </span><span class="lineCov">       2377 :             }</span>
<span class="lineNum">   35460 </span>            :           collapse_err = true;
<span class="lineNum">   35461 </span>            :           cp_parser_statement_seq_opt (parser, NULL);
<span class="lineNum">   35462 </span>            :           if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_EOF))
<span class="lineNum">   35463 </span><span class="lineCov">       7506 :             break;</span>
<span class="lineNum">   35464 </span><span class="lineCov">         49 :         }</span>
<span class="lineNum">   35465 </span>            :     }
<span class="lineNum">   35466 </span>            : 
<span class="lineNum">   35467 </span>            :   while (!for_block-&gt;is_empty ())
<span class="lineNum">   35468 </span><span class="lineCov">       7506 :     {</span>
<span class="lineNum">   35469 </span>            :       tree t = for_block-&gt;pop ();
<span class="lineNum">   35470 </span>            :       if (TREE_CODE (t) == STATEMENT_LIST)
<span class="lineNum">   35471 </span>            :         add_stmt (pop_stmt_list (t));
<span class="lineNum">   35472 </span><span class="lineCov">       7506 :       else</span>
<span class="lineNum">   35473 </span><span class="lineCov">       7506 :         add_stmt (t);</span>
<span class="lineNum">   35474 </span><span class="lineCov">       7506 :     }</span>
<span class="lineNum">   35475 </span>            :   release_tree_vector (for_block);
<span class="lineNum">   35476 </span><span class="lineCov">       7506 : </span>
<span class="lineNum">   35477 </span>            :   return ret;
<span class="lineNum">   35478 </span>            : }
<span class="lineNum">   35479 </span><span class="lineCov">       7506 : </span>
<span class="lineNum">   35480 </span>            : /* Helper function for OpenMP parsing, split clauses and call
<span class="lineNum">   35481 </span>            :    finish_omp_clauses on each of the set of clauses afterwards.  */
<a name="35482"><span class="lineNum">   35482 </span><span class="lineCov">       7566 : </span></a>
<span class="lineNum">   35483 </span>            : static void
<span class="lineNum">   35484 </span><span class="lineCov">         60 : cp_omp_split_clauses (location_t loc, enum tree_code code,</span>
<span class="lineNum">   35485 </span>            :                       omp_clause_mask mask, tree clauses, tree *cclauses)
<span class="lineNum">   35486 </span><span class="lineCov">         57 : {</span>
<span class="lineNum">   35487 </span><span class="lineCov">         57 :   int i;</span>
<span class="lineNum">   35488 </span>            :   c_omp_split_clauses (loc, code, mask, clauses, cclauses);
<span class="lineNum">   35489 </span><span class="lineCov">          3 :   for (i = 0; i &lt; C_OMP_CLAUSE_SPLIT_COUNT; i++)</span>
<span class="lineNum">   35490 </span><span class="lineNoCov">          0 :     if (cclauses[i])</span>
<span class="lineNum">   35491 </span>            :       cclauses[i] = finish_omp_clauses (cclauses[i], C_ORT_OMP);
<span class="lineNum">   35492 </span>            : }
<span class="lineNum">   35493 </span><span class="lineCov">          3 : </span>
<span class="lineNum">   35494 </span>            : /* OpenMP 4.0:
<span class="lineNum">   35495 </span><span class="lineCov">          3 :    #pragma omp simd simd-clause[optseq] new-line</span>
<span class="lineNum">   35496 </span>            :      for-loop  */
<span class="lineNum">   35497 </span>            : 
<span class="lineNum">   35498 </span><span class="lineCov">          3 : #define OMP_SIMD_CLAUSE_MASK                                    \</span>
<span class="lineNum">   35499 </span><span class="lineCov">          3 :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_SAFELEN)        \</span>
<span class="lineNum">   35500 </span><span class="lineCov">          3 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_SIMDLEN)        \</span>
<span class="lineNum">   35501 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_LINEAR) \
<span class="lineNum">   35502 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_ALIGNED)        \
<span class="lineNum">   35503 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_PRIVATE)        \
<span class="lineNum">   35504 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_LASTPRIVATE)    \
<span class="lineNum">   35505 </span><span class="lineCov">       7718 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_REDUCTION)      \</span>
<span class="lineNum">   35506 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_COLLAPSE))
<a name="35507"><span class="lineNum">   35507 </span><span class="lineCov">        212 : </span></a>
<span class="lineNum">   35508 </span><span class="lineCov">        212 : static tree</span>
<span class="lineNum">   35509 </span><span class="lineCov">        209 : cp_parser_omp_simd (cp_parser *parser, cp_token *pragma_tok,</span>
<span class="lineNum">   35510 </span>            :                     char *p_name, omp_clause_mask mask, tree *cclauses,
<span class="lineNum">   35511 </span><span class="lineCov">          3 :                     bool *if_p)</span>
<span class="lineNum">   35512 </span>            : {
<span class="lineNum">   35513 </span><span class="lineCov">       7506 :   tree clauses, sb, ret;</span>
<span class="lineNum">   35514 </span>            :   unsigned int save;
<span class="lineNum">   35515 </span><span class="lineCov">       7506 :   location_t loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;</span>
<span class="lineNum">   35516 </span>            : 
<span class="lineNum">   35517 </span>            :   strcat (p_name, &quot; simd&quot;);
<span class="lineNum">   35518 </span>            :   mask |= OMP_SIMD_CLAUSE_MASK;
<span class="lineNum">   35519 </span>            : 
<span class="lineNum">   35520 </span>            :   clauses = cp_parser_omp_all_clauses (parser, mask, p_name, pragma_tok,
<span class="lineNum">   35521 </span>            :                                        cclauses == NULL);
<span class="lineNum">   35522 </span><span class="lineCov">       2930 :   if (cclauses)</span>
<span class="lineNum">   35523 </span>            :     {
<span class="lineNum">   35524 </span>            :       cp_omp_split_clauses (loc, OMP_SIMD, mask, clauses, cclauses);
<span class="lineNum">   35525 </span><span class="lineCov">       2930 :       clauses = cclauses[C_OMP_CLAUSE_SPLIT_SIMD];</span>
<span class="lineNum">   35526 </span><span class="lineCov">       2930 :       tree c = omp_find_clause (cclauses[C_OMP_CLAUSE_SPLIT_FOR],</span>
<span class="lineNum">   35527 </span><span class="lineCov">      20510 :                                 OMP_CLAUSE_ORDERED);</span>
<span class="lineNum">   35528 </span><span class="lineCov">      17580 :       if (c &amp;&amp; OMP_CLAUSE_ORDERED_EXPR (c))</span>
<span class="lineNum">   35529 </span><span class="lineCov">       4699 :         {</span>
<span class="lineNum">   35530 </span><span class="lineCov">       2930 :           error_at (OMP_CLAUSE_LOCATION (c),</span>
<span class="lineNum">   35531 </span>            :                     &quot;%&lt;ordered%&gt; clause with parameter may not be specified &quot;
<span class="lineNum">   35532 </span>            :                     &quot;on %qs construct&quot;, p_name);
<span class="lineNum">   35533 </span>            :           OMP_CLAUSE_ORDERED_EXPR (c) = NULL_TREE;
<span class="lineNum">   35534 </span>            :         }
<span class="lineNum">   35535 </span>            :     }
<span class="lineNum">   35536 </span>            : 
<span class="lineNum">   35537 </span>            :   sb = begin_omp_structured_block ();
<span class="lineNum">   35538 </span>            :   save = cp_parser_begin_omp_structured_block (parser);
<span class="lineNum">   35539 </span>            : 
<span class="lineNum">   35540 </span>            :   ret = cp_parser_omp_for_loop (parser, OMP_SIMD, clauses, cclauses, if_p);
<span class="lineNum">   35541 </span>            : 
<span class="lineNum">   35542 </span>            :   cp_parser_end_omp_structured_block (parser, save);
<span class="lineNum">   35543 </span>            :   add_stmt (finish_omp_structured_block (sb));
<span class="lineNum">   35544 </span>            : 
<span class="lineNum">   35545 </span>            :   return ret;
<span class="lineNum">   35546 </span>            : }
<span class="lineNum">   35547 </span><span class="lineCov">       1580 : </span>
<span class="lineNum">   35548 </span>            : /* OpenMP 2.5:
<span class="lineNum">   35549 </span>            :    #pragma omp for for-clause[optseq] new-line
<span class="lineNum">   35550 </span>            :      for-loop
<span class="lineNum">   35551 </span><span class="lineCov">       1580 : </span>
<span class="lineNum">   35552 </span><span class="lineCov">       1580 :    OpenMP 4.0:</span>
<span class="lineNum">   35553 </span><span class="lineCov">       3160 :    #pragma omp for simd for-simd-clause[optseq] new-line</span>
<span class="lineNum">   35554 </span>            :      for-loop  */
<span class="lineNum">   35555 </span><span class="lineCov">       1580 : </span>
<span class="lineNum">   35556 </span><span class="lineCov">      25280 : #define OMP_FOR_CLAUSE_MASK                                     \</span>
<span class="lineNum">   35557 </span>            :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_PRIVATE)        \
<span class="lineNum">   35558 </span><span class="lineCov">       1580 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)   \</span>
<span class="lineNum">   35559 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_LASTPRIVATE)    \
<span class="lineNum">   35560 </span><span class="lineCov">       1580 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_LINEAR) \</span>
<span class="lineNum">   35561 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_REDUCTION)      \
<span class="lineNum">   35562 </span><span class="lineCov">       1220 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_ORDERED)        \</span>
<span class="lineNum">   35563 </span><span class="lineCov">       1220 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_SCHEDULE)       \</span>
<span class="lineNum">   35564 </span><span class="lineCov">       1220 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_NOWAIT) \</span>
<span class="lineNum">   35565 </span><span class="lineCov">       1220 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_COLLAPSE))</span>
<a name="35566"><span class="lineNum">   35566 </span><span class="lineCov">       1220 : </span></a>
<span class="lineNum">   35567 </span>            : static tree
<span class="lineNum">   35568 </span><span class="lineCov">          6 : cp_parser_omp_for (cp_parser *parser, cp_token *pragma_tok,</span>
<span class="lineNum">   35569 </span>            :                    char *p_name, omp_clause_mask mask, tree *cclauses,
<span class="lineNum">   35570 </span>            :                    bool *if_p)
<span class="lineNum">   35571 </span><span class="lineCov">          6 : {</span>
<span class="lineNum">   35572 </span>            :   tree clauses, sb, ret;
<span class="lineNum">   35573 </span>            :   unsigned int save;
<span class="lineNum">   35574 </span>            :   location_t loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">   35575 </span><span class="lineCov">       1580 : </span>
<span class="lineNum">   35576 </span><span class="lineCov">       1580 :   strcat (p_name, &quot; for&quot;);</span>
<span class="lineNum">   35577 </span>            :   mask |= OMP_FOR_CLAUSE_MASK;
<span class="lineNum">   35578 </span><span class="lineCov">       1580 :   /* parallel for{, simd} disallows nowait clause, but for</span>
<span class="lineNum">   35579 </span>            :      target {teams distribute ,}parallel for{, simd} it should be accepted.  */
<span class="lineNum">   35580 </span><span class="lineCov">       3160 :   if (cclauses &amp;&amp; (mask &amp; (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_MAP)) == 0)</span>
<span class="lineNum">   35581 </span><span class="lineCov">       1580 :     mask &amp;= ~(OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_NOWAIT);</span>
<span class="lineNum">   35582 </span>            :   /* Composite distribute parallel for{, simd} disallows ordered clause.  */
<span class="lineNum">   35583 </span><span class="lineCov">       1580 :   if ((mask &amp; (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DIST_SCHEDULE)) != 0)</span>
<span class="lineNum">   35584 </span>            :     mask &amp;= ~(OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_ORDERED);
<span class="lineNum">   35585 </span>            : 
<span class="lineNum">   35586 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))
<span class="lineNum">   35587 </span>            :     {
<span class="lineNum">   35588 </span>            :       tree id = cp_lexer_peek_token (parser-&gt;lexer)-&gt;u.value;
<span class="lineNum">   35589 </span>            :       const char *p = IDENTIFIER_POINTER (id);
<span class="lineNum">   35590 </span>            : 
<span class="lineNum">   35591 </span>            :       if (strcmp (p, &quot;simd&quot;) == 0)
<span class="lineNum">   35592 </span>            :         {
<span class="lineNum">   35593 </span>            :           tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];
<span class="lineNum">   35594 </span>            :           if (cclauses == NULL)
<span class="lineNum">   35595 </span>            :             cclauses = cclauses_buf;
<span class="lineNum">   35596 </span>            : 
<span class="lineNum">   35597 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   35598 </span>            :           if (!flag_openmp)  /* flag_openmp_simd  */
<span class="lineNum">   35599 </span>            :             return cp_parser_omp_simd (parser, pragma_tok, p_name, mask,
<span class="lineNum">   35600 </span>            :                                        cclauses, if_p);
<span class="lineNum">   35601 </span>            :           sb = begin_omp_structured_block ();
<span class="lineNum">   35602 </span>            :           save = cp_parser_begin_omp_structured_block (parser);
<span class="lineNum">   35603 </span>            :           ret = cp_parser_omp_simd (parser, pragma_tok, p_name, mask,
<span class="lineNum">   35604 </span>            :                                     cclauses, if_p);
<span class="lineNum">   35605 </span>            :           cp_parser_end_omp_structured_block (parser, save);
<span class="lineNum">   35606 </span><span class="lineCov">       4079 :           tree body = finish_omp_structured_block (sb);</span>
<span class="lineNum">   35607 </span>            :           if (ret == NULL)
<span class="lineNum">   35608 </span>            :             return ret;
<span class="lineNum">   35609 </span>            :           ret = make_node (OMP_FOR);
<span class="lineNum">   35610 </span><span class="lineCov">       4079 :           TREE_TYPE (ret) = void_type_node;</span>
<span class="lineNum">   35611 </span><span class="lineCov">       4079 :           OMP_FOR_BODY (ret) = body;</span>
<span class="lineNum">   35612 </span><span class="lineCov">       8158 :           OMP_FOR_CLAUSES (ret) = cclauses[C_OMP_CLAUSE_SPLIT_FOR];</span>
<span class="lineNum">   35613 </span>            :           SET_EXPR_LOCATION (ret, loc);
<span class="lineNum">   35614 </span><span class="lineCov">       4079 :           add_stmt (ret);</span>
<span class="lineNum">   35615 </span><span class="lineCov">      73422 :           return ret;</span>
<span class="lineNum">   35616 </span>            :         }
<span class="lineNum">   35617 </span>            :     }
<span class="lineNum">   35618 </span><span class="lineCov">       4079 :   if (!flag_openmp)  /* flag_openmp_simd  */</span>
<span class="lineNum">   35619 </span><span class="lineCov">       6840 :     {</span>
<span class="lineNum">   35620 </span>            :       cp_parser_skip_to_pragma_eol (parser, pragma_tok);
<span class="lineNum">   35621 </span><span class="lineCov">      12237 :       return NULL_TREE;</span>
<span class="lineNum">   35622 </span><span class="lineCov">       4412 :     }</span>
<span class="lineNum">   35623 </span>            : 
<span class="lineNum">   35624 </span><span class="lineCov">       4079 :   /* Composite distribute parallel for disallows linear clause.  */</span>
<span class="lineNum">   35625 </span>            :   if ((mask &amp; (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DIST_SCHEDULE)) != 0)
<span class="lineNum">   35626 </span><span class="lineCov">       6004 :     mask &amp;= ~(OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_LINEAR);</span>
<span class="lineNum">   35627 </span><span class="lineCov">       3002 : </span>
<span class="lineNum">   35628 </span>            :   clauses = cp_parser_omp_all_clauses (parser, mask, p_name, pragma_tok,
<span class="lineNum">   35629 </span><span class="lineCov">       3002 :                                        cclauses == NULL);</span>
<span class="lineNum">   35630 </span>            :   if (cclauses)
<span class="lineNum">   35631 </span><span class="lineCov">        966 :     {</span>
<span class="lineNum">   35632 </span><span class="lineCov">        966 :       cp_omp_split_clauses (loc, OMP_FOR, mask, clauses, cclauses);</span>
<span class="lineNum">   35633 </span><span class="lineCov">        153 :       clauses = cclauses[C_OMP_CLAUSE_SPLIT_FOR];</span>
<span class="lineNum">   35634 </span>            :     }
<span class="lineNum">   35635 </span><span class="lineCov">        966 : </span>
<span class="lineNum">   35636 </span><span class="lineCov">        966 :   sb = begin_omp_structured_block ();</span>
<span class="lineNum">   35637 </span><span class="lineCov">         21 :   save = cp_parser_begin_omp_structured_block (parser);</span>
<span class="lineNum">   35638 </span><span class="lineCov">         21 : </span>
<span class="lineNum">   35639 </span><span class="lineCov">        945 :   ret = cp_parser_omp_for_loop (parser, OMP_FOR, clauses, cclauses, if_p);</span>
<span class="lineNum">   35640 </span><span class="lineCov">        945 : </span>
<span class="lineNum">   35641 </span><span class="lineCov">        945 :   cp_parser_end_omp_structured_block (parser, save);</span>
<span class="lineNum">   35642 </span>            :   add_stmt (finish_omp_structured_block (sb));
<span class="lineNum">   35643 </span><span class="lineCov">       1890 : </span>
<span class="lineNum">   35644 </span><span class="lineCov">        945 :   return ret;</span>
<span class="lineNum">   35645 </span><span class="lineCov">        945 : }</span>
<span class="lineNum">   35646 </span>            : 
<span class="lineNum">   35647 </span><span class="lineCov">        936 : /* OpenMP 2.5:</span>
<span class="lineNum">   35648 </span><span class="lineCov">        936 :    # pragma omp master new-line</span>
<span class="lineNum">   35649 </span><span class="lineCov">       1872 :      structured-block  */</span>
<a name="35650"><span class="lineNum">   35650 </span><span class="lineCov">       1872 : </span></a>
<span class="lineNum">   35651 </span><span class="lineCov">        936 : static tree</span>
<span class="lineNum">   35652 </span><span class="lineCov">        936 : cp_parser_omp_master (cp_parser *parser, cp_token *pragma_tok, bool *if_p)</span>
<span class="lineNum">   35653 </span><span class="lineCov">        936 : {</span>
<span class="lineNum">   35654 </span>            :   cp_parser_require_pragma_eol (parser, pragma_tok);
<span class="lineNum">   35655 </span>            :   return c_finish_omp_master (input_location,
<span class="lineNum">   35656 </span><span class="lineCov">       3113 :                               cp_parser_omp_structured_block (parser, if_p));</span>
<span class="lineNum">   35657 </span>            : }
<span class="lineNum">   35658 </span><span class="lineCov">         12 : </span>
<span class="lineNum">   35659 </span><span class="lineCov">         12 : /* OpenMP 2.5:</span>
<span class="lineNum">   35660 </span>            :    # pragma omp ordered new-line
<span class="lineNum">   35661 </span>            :      structured-block
<span class="lineNum">   35662 </span>            : 
<span class="lineNum">   35663 </span><span class="lineCov">       9303 :    OpenMP 4.5:</span>
<span class="lineNum">   35664 </span><span class="lineCov">       2208 :    # pragma omp ordered ordered-clauses new-line</span>
<span class="lineNum">   35665 </span>            :      structured-block  */
<span class="lineNum">   35666 </span><span class="lineCov">       3101 : </span>
<span class="lineNum">   35667 </span>            : #define OMP_ORDERED_CLAUSE_MASK                                 \
<span class="lineNum">   35668 </span><span class="lineCov">       3101 :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_THREADS)        \</span>
<span class="lineNum">   35669 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_SIMD))
<span class="lineNum">   35670 </span><span class="lineCov">       1415 : </span>
<span class="lineNum">   35671 </span><span class="lineCov">       1415 : #define OMP_ORDERED_DEPEND_CLAUSE_MASK                          \</span>
<span class="lineNum">   35672 </span>            :         (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DEPEND)
<a name="35673"><span class="lineNum">   35673 </span>            : </a>
<span class="lineNum">   35674 </span><span class="lineCov">       3101 : static bool</span>
<span class="lineNum">   35675 </span><span class="lineCov">       3101 : cp_parser_omp_ordered (cp_parser *parser, cp_token *pragma_tok,</span>
<span class="lineNum">   35676 </span>            :                        enum pragma_context context, bool *if_p)
<span class="lineNum">   35677 </span><span class="lineCov">       3101 : {</span>
<span class="lineNum">   35678 </span>            :   location_t loc = pragma_tok-&gt;location;
<span class="lineNum">   35679 </span><span class="lineCov">       6202 : </span>
<span class="lineNum">   35680 </span><span class="lineCov">       3101 :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))</span>
<span class="lineNum">   35681 </span>            :     {
<span class="lineNum">   35682 </span><span class="lineCov">       3101 :       tree id = cp_lexer_peek_token (parser-&gt;lexer)-&gt;u.value;</span>
<span class="lineNum">   35683 </span>            :       const char *p = IDENTIFIER_POINTER (id);
<span class="lineNum">   35684 </span>            : 
<span class="lineNum">   35685 </span>            :       if (strcmp (p, &quot;depend&quot;) == 0)
<span class="lineNum">   35686 </span>            :         {
<span class="lineNum">   35687 </span>            :           if (!flag_openmp)     /* flag_openmp_simd */
<span class="lineNum">   35688 </span>            :             {
<span class="lineNum">   35689 </span>            :               cp_parser_skip_to_pragma_eol (parser, pragma_tok);
<span class="lineNum">   35690 </span><span class="lineCov">        112 :               return false;</span>
<span class="lineNum">   35691 </span>            :             }
<span class="lineNum">   35692 </span><span class="lineCov">        112 :           if (context == pragma_stmt)</span>
<span class="lineNum">   35693 </span><span class="lineCov">        112 :             {</span>
<span class="lineNum">   35694 </span><span class="lineCov">        112 :               error_at (pragma_tok-&gt;location, &quot;%&lt;#pragma omp ordered%&gt; with &quot;</span>
<span class="lineNum">   35695 </span>            :                         &quot;%&lt;depend%&gt; clause may only be used in compound &quot;
<span class="lineNum">   35696 </span>            :                         &quot;statements&quot;);
<span class="lineNum">   35697 </span>            :               cp_parser_skip_to_pragma_eol (parser, pragma_tok);
<span class="lineNum">   35698 </span>            :               return false;
<span class="lineNum">   35699 </span>            :             }
<span class="lineNum">   35700 </span>            :           tree clauses
<span class="lineNum">   35701 </span>            :             = cp_parser_omp_all_clauses (parser,
<span class="lineNum">   35702 </span>            :                                          OMP_ORDERED_DEPEND_CLAUSE_MASK,
<span class="lineNum">   35703 </span>            :                                          &quot;#pragma omp ordered&quot;, pragma_tok);
<span class="lineNum">   35704 </span>            :           c_finish_omp_ordered (loc, clauses, NULL_TREE);
<span class="lineNum">   35705 </span>            :           return false;
<span class="lineNum">   35706 </span>            :         }
<span class="lineNum">   35707 </span>            :     }
<span class="lineNum">   35708 </span>            : 
<span class="lineNum">   35709 </span>            :   tree clauses
<span class="lineNum">   35710 </span>            :     = cp_parser_omp_all_clauses (parser, OMP_ORDERED_CLAUSE_MASK,
<span class="lineNum">   35711 </span>            :                                  &quot;#pragma omp ordered&quot;, pragma_tok);
<span class="lineNum">   35712 </span>            : 
<span class="lineNum">   35713 </span><span class="lineCov">        511 :   if (!flag_openmp     /* flag_openmp_simd  */</span>
<span class="lineNum">   35714 </span>            :       &amp;&amp; omp_find_clause (clauses, OMP_CLAUSE_SIMD) == NULL_TREE)
<span class="lineNum">   35715 </span>            :     return false;
<span class="lineNum">   35716 </span><span class="lineCov">        511 : </span>
<span class="lineNum">   35717 </span>            :   c_finish_omp_ordered (loc, clauses,
<span class="lineNum">   35718 </span><span class="lineCov">        511 :                         cp_parser_omp_structured_block (parser, if_p));</span>
<span class="lineNum">   35719 </span>            :   return true;
<span class="lineNum">   35720 </span><span class="lineCov">        794 : }</span>
<span class="lineNum">   35721 </span><span class="lineCov">        397 : </span>
<span class="lineNum">   35722 </span>            : /* OpenMP 2.5:
<span class="lineNum">   35723 </span><span class="lineCov">        397 : </span>
<span class="lineNum">   35724 </span>            :    section-scope:
<span class="lineNum">   35725 </span><span class="lineCov">        236 :      { section-sequence }</span>
<span class="lineNum">   35726 </span>            : 
<span class="lineNum">   35727 </span><span class="lineCov">          6 :    section-sequence:</span>
<span class="lineNum">   35728 </span><span class="lineCov">          6 :      section-directive[opt] structured-block</span>
<span class="lineNum">   35729 </span>            :      section-sequence section-directive structured-block  */
<a name="35730"><span class="lineNum">   35730 </span><span class="lineCov">        230 : </span></a>
<span class="lineNum">   35731 </span>            : static tree
<span class="lineNum">   35732 </span><span class="lineCov">         48 : cp_parser_omp_sections_scope (cp_parser *parser)</span>
<span class="lineNum">   35733 </span>            : {
<span class="lineNum">   35734 </span>            :   tree stmt, substmt;
<span class="lineNum">   35735 </span><span class="lineCov">         48 :   bool error_suppress = false;</span>
<span class="lineNum">   35736 </span><span class="lineCov">         48 :   cp_token *tok;</span>
<span class="lineNum">   35737 </span>            : 
<span class="lineNum">   35738 </span><span class="lineCov">        182 :   matching_braces braces;</span>
<span class="lineNum">   35739 </span><span class="lineCov">        182 :   if (!braces.require_open (parser))</span>
<span class="lineNum">   35740 </span><span class="lineCov">        182 :     return NULL_TREE;</span>
<span class="lineNum">   35741 </span>            : 
<span class="lineNum">   35742 </span><span class="lineCov">        182 :   stmt = push_stmt_list ();</span>
<span class="lineNum">   35743 </span><span class="lineCov">        182 : </span>
<span class="lineNum">   35744 </span>            :   if (cp_parser_pragma_kind (cp_lexer_peek_token (parser-&gt;lexer))
<span class="lineNum">   35745 </span>            :       != PRAGMA_OMP_SECTION)
<span class="lineNum">   35746 </span>            :     {
<span class="lineNum">   35747 </span><span class="lineCov">        275 :       substmt = cp_parser_omp_structured_block (parser, NULL);</span>
<span class="lineNum">   35748 </span><span class="lineCov">       1100 :       substmt = build1 (OMP_SECTION, void_type_node, substmt);</span>
<span class="lineNum">   35749 </span>            :       add_stmt (substmt);
<span class="lineNum">   35750 </span>            :     }
<span class="lineNum">   35751 </span><span class="lineCov">        275 : </span>
<span class="lineNum">   35752 </span><span class="lineCov">        275 :   while (1)</span>
<span class="lineNum">   35753 </span>            :     {
<span class="lineNum">   35754 </span>            :       tok = cp_lexer_peek_token (parser-&gt;lexer);
<span class="lineNum">   35755 </span><span class="lineCov">        269 :       if (tok-&gt;type == CPP_CLOSE_BRACE)</span>
<span class="lineNum">   35756 </span>            :         break;
<span class="lineNum">   35757 </span><span class="lineCov">        269 :       if (tok-&gt;type == CPP_EOF)</span>
<span class="lineNum">   35758 </span>            :         break;
<span class="lineNum">   35759 </span>            : 
<span class="lineNum">   35760 </span>            :       if (cp_parser_pragma_kind (tok) == PRAGMA_OMP_SECTION)
<span class="lineNum">   35761 </span>            :         {
<span class="lineNum">   35762 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   35763 </span>            :           cp_parser_require_pragma_eol (parser, tok);
<span class="lineNum">   35764 </span>            :           error_suppress = false;
<span class="lineNum">   35765 </span>            :         }
<span class="lineNum">   35766 </span>            :       else if (!error_suppress)
<span class="lineNum">   35767 </span>            :         {
<span class="lineNum">   35768 </span>            :           cp_parser_error (parser, &quot;expected %&lt;#pragma omp section%&gt; or %&lt;}%&gt;&quot;);
<span class="lineNum">   35769 </span>            :           error_suppress = true;
<span class="lineNum">   35770 </span><span class="lineCov">        253 :         }</span>
<span class="lineNum">   35771 </span>            : 
<span class="lineNum">   35772 </span><span class="lineCov">        253 :       substmt = cp_parser_omp_structured_block (parser, NULL);</span>
<span class="lineNum">   35773 </span><span class="lineCov">        253 :       substmt = build1 (OMP_SECTION, void_type_node, substmt);</span>
<span class="lineNum">   35774 </span><span class="lineCov">        253 :       add_stmt (substmt);</span>
<span class="lineNum">   35775 </span>            :     }
<span class="lineNum">   35776 </span><span class="lineCov">        506 :   braces.require_close (parser);</span>
<span class="lineNum">   35777 </span><span class="lineCov">        253 : </span>
<span class="lineNum">   35778 </span>            :   substmt = pop_stmt_list (stmt);
<span class="lineNum">   35779 </span>            : 
<span class="lineNum">   35780 </span><span class="lineCov">        247 :   stmt = make_node (OMP_SECTIONS);</span>
<span class="lineNum">   35781 </span>            :   TREE_TYPE (stmt) = void_type_node;
<span class="lineNum">   35782 </span><span class="lineCov">        247 :   OMP_SECTIONS_BODY (stmt) = substmt;</span>
<span class="lineNum">   35783 </span>            : 
<span class="lineNum">   35784 </span>            :   add_stmt (stmt);
<span class="lineNum">   35785 </span><span class="lineCov">        150 :   return stmt;</span>
<span class="lineNum">   35786 </span><span class="lineCov">        150 : }</span>
<span class="lineNum">   35787 </span><span class="lineCov">        150 : </span>
<span class="lineNum">   35788 </span>            : /* OpenMP 2.5:
<span class="lineNum">   35789 </span>            :    # pragma omp sections sections-clause[optseq] newline
<span class="lineNum">   35790 </span><span class="lineCov">        531 :      sections-scope  */</span>
<span class="lineNum">   35791 </span>            : 
<span class="lineNum">   35792 </span><span class="lineCov">        284 : #define OMP_SECTIONS_CLAUSE_MASK                                \</span>
<span class="lineNum">   35793 </span><span class="lineCov">        531 :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_PRIVATE)        \</span>
<span class="lineNum">   35794 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)   \
<span class="lineNum">   35795 </span><span class="lineCov">        284 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_LASTPRIVATE)    \</span>
<span class="lineNum">   35796 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_REDUCTION)      \
<span class="lineNum">   35797 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_NOWAIT))
<a name="35798"><span class="lineNum">   35798 </span><span class="lineCov">        284 : </span></a>
<span class="lineNum">   35799 </span>            : static tree
<span class="lineNum">   35800 </span><span class="lineCov">        266 : cp_parser_omp_sections (cp_parser *parser, cp_token *pragma_tok,</span>
<span class="lineNum">   35801 </span><span class="lineCov">        266 :                         char *p_name, omp_clause_mask mask, tree *cclauses)</span>
<span class="lineNum">   35802 </span><span class="lineCov">        266 : {</span>
<span class="lineNum">   35803 </span>            :   tree clauses, ret;
<span class="lineNum">   35804 </span><span class="lineCov">         18 :   location_t loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;</span>
<span class="lineNum">   35805 </span>            : 
<span class="lineNum">   35806 </span><span class="lineCov">         12 :   strcat (p_name, &quot; sections&quot;);</span>
<span class="lineNum">   35807 </span><span class="lineCov">         12 :   mask |= OMP_SECTIONS_CLAUSE_MASK;</span>
<span class="lineNum">   35808 </span>            :   if (cclauses)
<span class="lineNum">   35809 </span>            :     mask &amp;= ~(OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_NOWAIT);
<span class="lineNum">   35810 </span><span class="lineCov">        284 : </span>
<span class="lineNum">   35811 </span><span class="lineCov">        284 :   clauses = cp_parser_omp_all_clauses (parser, mask, p_name, pragma_tok,</span>
<span class="lineNum">   35812 </span><span class="lineCov">        284 :                                        cclauses == NULL);</span>
<span class="lineNum">   35813 </span>            :   if (cclauses)
<span class="lineNum">   35814 </span><span class="lineCov">        247 :     {</span>
<span class="lineNum">   35815 </span>            :       cp_omp_split_clauses (loc, OMP_SECTIONS, mask, clauses, cclauses);
<span class="lineNum">   35816 </span><span class="lineCov">        247 :       clauses = cclauses[C_OMP_CLAUSE_SPLIT_SECTIONS];</span>
<span class="lineNum">   35817 </span>            :     }
<span class="lineNum">   35818 </span><span class="lineCov">        247 : </span>
<span class="lineNum">   35819 </span><span class="lineCov">        247 :   ret = cp_parser_omp_sections_scope (parser);</span>
<span class="lineNum">   35820 </span><span class="lineCov">        247 :   if (ret)</span>
<span class="lineNum">   35821 </span>            :     OMP_SECTIONS_CLAUSES (ret) = clauses;
<span class="lineNum">   35822 </span><span class="lineCov">        247 : </span>
<span class="lineNum">   35823 </span><span class="lineCov">        247 :   return ret;</span>
<span class="lineNum">   35824 </span>            : }
<span class="lineNum">   35825 </span>            : 
<span class="lineNum">   35826 </span>            : /* OpenMP 2.5:
<span class="lineNum">   35827 </span>            :    # pragma omp parallel parallel-clause[optseq] new-line
<span class="lineNum">   35828 </span>            :      structured-block
<span class="lineNum">   35829 </span>            :    # pragma omp parallel for parallel-for-clause[optseq] new-line
<span class="lineNum">   35830 </span>            :      structured-block
<span class="lineNum">   35831 </span>            :    # pragma omp parallel sections parallel-sections-clause[optseq] new-line
<span class="lineNum">   35832 </span>            :      structured-block
<span class="lineNum">   35833 </span>            : 
<span class="lineNum">   35834 </span>            :    OpenMP 4.0:
<span class="lineNum">   35835 </span>            :    # pragma omp parallel for simd parallel-for-simd-clause[optseq] new-line
<span class="lineNum">   35836 </span>            :      structured-block */
<span class="lineNum">   35837 </span>            : 
<span class="lineNum">   35838 </span><span class="lineCov">        253 : #define OMP_PARALLEL_CLAUSE_MASK                                \</span>
<span class="lineNum">   35839 </span>            :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_IF)             \
<span class="lineNum">   35840 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_PRIVATE)        \
<span class="lineNum">   35841 </span><span class="lineCov">        253 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)   \</span>
<span class="lineNum">   35842 </span><span class="lineCov">        506 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DEFAULT)        \</span>
<span class="lineNum">   35843 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_SHARED) \
<span class="lineNum">   35844 </span><span class="lineCov">        253 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_COPYIN) \</span>
<span class="lineNum">   35845 </span><span class="lineCov">       2530 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_REDUCTION)      \</span>
<span class="lineNum">   35846 </span><span class="lineCov">        253 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_NUM_THREADS)    \</span>
<span class="lineNum">   35847 </span><span class="lineCov">        260 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_PROC_BIND))</span>
<a name="35848"><span class="lineNum">   35848 </span>            : </a>
<span class="lineNum">   35849 </span><span class="lineCov">        253 : static tree</span>
<span class="lineNum">   35850 </span>            : cp_parser_omp_parallel (cp_parser *parser, cp_token *pragma_tok,
<span class="lineNum">   35851 </span><span class="lineCov">        253 :                         char *p_name, omp_clause_mask mask, tree *cclauses,</span>
<span class="lineNum">   35852 </span>            :                         bool *if_p)
<span class="lineNum">   35853 </span><span class="lineCov">         65 : {</span>
<span class="lineNum">   35854 </span><span class="lineCov">         65 :   tree stmt, clauses, block;</span>
<span class="lineNum">   35855 </span>            :   unsigned int save;
<span class="lineNum">   35856 </span>            :   location_t loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">   35857 </span><span class="lineCov">        253 : </span>
<span class="lineNum">   35858 </span><span class="lineCov">        253 :   strcat (p_name, &quot; parallel&quot;);</span>
<span class="lineNum">   35859 </span><span class="lineCov">        247 :   mask |= OMP_PARALLEL_CLAUSE_MASK;</span>
<span class="lineNum">   35860 </span>            :   /* #pragma omp target parallel{, for, for simd} disallow copyin clause.  */
<span class="lineNum">   35861 </span><span class="lineCov">        253 :   if ((mask &amp; (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_MAP)) != 0</span>
<span class="lineNum">   35862 </span>            :       &amp;&amp; (mask &amp; (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DIST_SCHEDULE)) == 0)
<span class="lineNum">   35863 </span>            :     mask &amp;= ~(OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_COPYIN);
<span class="lineNum">   35864 </span>            : 
<span class="lineNum">   35865 </span>            :   if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_FOR))
<span class="lineNum">   35866 </span>            :     {
<span class="lineNum">   35867 </span>            :       tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];
<span class="lineNum">   35868 </span>            :       if (cclauses == NULL)
<span class="lineNum">   35869 </span>            :         cclauses = cclauses_buf;
<span class="lineNum">   35870 </span>            : 
<span class="lineNum">   35871 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   35872 </span>            :       if (!flag_openmp)  /* flag_openmp_simd  */
<span class="lineNum">   35873 </span>            :         return cp_parser_omp_for (parser, pragma_tok, p_name, mask, cclauses,
<span class="lineNum">   35874 </span>            :                                   if_p);
<span class="lineNum">   35875 </span>            :       block = begin_omp_parallel ();
<span class="lineNum">   35876 </span>            :       save = cp_parser_begin_omp_structured_block (parser);
<span class="lineNum">   35877 </span>            :       tree ret = cp_parser_omp_for (parser, pragma_tok, p_name, mask, cclauses,
<span class="lineNum">   35878 </span>            :                                     if_p);
<span class="lineNum">   35879 </span>            :       cp_parser_end_omp_structured_block (parser, save);
<span class="lineNum">   35880 </span>            :       stmt = finish_omp_parallel (cclauses[C_OMP_CLAUSE_SPLIT_PARALLEL],
<span class="lineNum">   35881 </span>            :                                   block);
<span class="lineNum">   35882 </span>            :       if (ret == NULL_TREE)
<span class="lineNum">   35883 </span>            :         return ret;
<span class="lineNum">   35884 </span>            :       OMP_PARALLEL_COMBINED (stmt) = 1;
<span class="lineNum">   35885 </span>            :       return stmt;
<span class="lineNum">   35886 </span>            :     }
<span class="lineNum">   35887 </span>            :   /* When combined with distribute, parallel has to be followed by for.
<span class="lineNum">   35888 </span><span class="lineCov">       3619 :      #pragma omp target parallel is allowed though.  */</span>
<span class="lineNum">   35889 </span>            :   else if (cclauses
<span class="lineNum">   35890 </span>            :            &amp;&amp; (mask &amp; (OMP_CLAUSE_MASK_1
<span class="lineNum">   35891 </span>            :                        &lt;&lt; PRAGMA_OMP_CLAUSE_DIST_SCHEDULE)) != 0)
<span class="lineNum">   35892 </span><span class="lineCov">       3619 :     {</span>
<span class="lineNum">   35893 </span><span class="lineCov">       3619 :       error_at (loc, &quot;expected %&lt;for%&gt; after %qs&quot;, p_name);</span>
<span class="lineNum">   35894 </span><span class="lineCov">       7238 :       cp_parser_skip_to_pragma_eol (parser, pragma_tok);</span>
<span class="lineNum">   35895 </span>            :       return NULL_TREE;
<span class="lineNum">   35896 </span><span class="lineCov">       3619 :     }</span>
<span class="lineNum">   35897 </span><span class="lineCov">      65142 :   else if (!flag_openmp)  /* flag_openmp_simd  */</span>
<span class="lineNum">   35898 </span>            :     {
<span class="lineNum">   35899 </span><span class="lineCov">      10857 :       cp_parser_skip_to_pragma_eol (parser, pragma_tok);</span>
<span class="lineNum">   35900 </span><span class="lineCov">       1617 :       return NULL_TREE;</span>
<span class="lineNum">   35901 </span><span class="lineCov">        696 :     }</span>
<span class="lineNum">   35902 </span>            :   else if (cclauses == NULL &amp;&amp; cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))
<span class="lineNum">   35903 </span><span class="lineCov">       3619 :     {</span>
<span class="lineNum">   35904 </span>            :       tree id = cp_lexer_peek_token (parser-&gt;lexer)-&gt;u.value;
<span class="lineNum">   35905 </span><span class="lineCov">       2237 :       const char *p = IDENTIFIER_POINTER (id);</span>
<span class="lineNum">   35906 </span><span class="lineCov">       2237 :       if (strcmp (p, &quot;sections&quot;) == 0)</span>
<span class="lineNum">   35907 </span><span class="lineCov">        972 :         {</span>
<span class="lineNum">   35908 </span>            :           tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];
<span class="lineNum">   35909 </span><span class="lineCov">       2237 :           cclauses = cclauses_buf;</span>
<span class="lineNum">   35910 </span><span class="lineCov">       2237 : </span>
<span class="lineNum">   35911 </span><span class="lineCov">         27 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   35912 </span><span class="lineCov">         27 :           block = begin_omp_parallel ();</span>
<span class="lineNum">   35913 </span><span class="lineCov">       2210 :           save = cp_parser_begin_omp_structured_block (parser);</span>
<span class="lineNum">   35914 </span><span class="lineCov">       2210 :           cp_parser_omp_sections (parser, pragma_tok, p_name, mask, cclauses);</span>
<span class="lineNum">   35915 </span><span class="lineCov">       2210 :           cp_parser_end_omp_structured_block (parser, save);</span>
<span class="lineNum">   35916 </span>            :           stmt = finish_omp_parallel (cclauses[C_OMP_CLAUSE_SPLIT_PARALLEL],
<span class="lineNum">   35917 </span><span class="lineCov">       4420 :                                       block);</span>
<span class="lineNum">   35918 </span><span class="lineCov">       2210 :           OMP_PARALLEL_COMBINED (stmt) = 1;</span>
<span class="lineNum">   35919 </span>            :           return stmt;
<span class="lineNum">   35920 </span><span class="lineCov">       2210 :         }</span>
<span class="lineNum">   35921 </span>            :     }
<span class="lineNum">   35922 </span><span class="lineCov">       2184 : </span>
<span class="lineNum">   35923 </span><span class="lineCov">       2184 :   clauses = cp_parser_omp_all_clauses (parser, mask, p_name, pragma_tok,</span>
<span class="lineNum">   35924 </span>            :                                        cclauses == NULL);
<span class="lineNum">   35925 </span>            :   if (cclauses)
<span class="lineNum">   35926 </span>            :     {
<span class="lineNum">   35927 </span><span class="lineCov">       1382 :       cp_omp_split_clauses (loc, OMP_PARALLEL, mask, clauses, cclauses);</span>
<span class="lineNum">   35928 </span><span class="lineCov">       1382 :       clauses = cclauses[C_OMP_CLAUSE_SPLIT_PARALLEL];</span>
<span class="lineNum">   35929 </span><span class="lineCov">         36 :     }</span>
<span class="lineNum">   35930 </span>            : 
<span class="lineNum">   35931 </span><span class="lineNoCov">          0 :   block = begin_omp_parallel ();</span>
<span class="lineNum">   35932 </span><span class="lineNoCov">          0 :   save = cp_parser_begin_omp_structured_block (parser);</span>
<span class="lineNum">   35933 </span><span class="lineNoCov">          0 :   cp_parser_statement (parser, NULL_TREE, false, if_p);</span>
<span class="lineNum">   35934 </span>            :   cp_parser_end_omp_structured_block (parser, save);
<span class="lineNum">   35935 </span><span class="lineCov">       1382 :   stmt = finish_omp_parallel (clauses, block);</span>
<span class="lineNum">   35936 </span>            :   return stmt;
<span class="lineNum">   35937 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   35938 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   35939 </span>            : /* OpenMP 2.5:
<span class="lineNum">   35940 </span><span class="lineCov">       1382 :    # pragma omp single single-clause[optseq] new-line</span>
<span class="lineNum">   35941 </span>            :      structured-block  */
<span class="lineNum">   35942 </span><span class="lineCov">       1386 : </span>
<span class="lineNum">   35943 </span><span class="lineCov">        693 : #define OMP_SINGLE_CLAUSE_MASK                                  \</span>
<span class="lineNum">   35944 </span><span class="lineCov">        693 :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_PRIVATE)        \</span>
<span class="lineNum">   35945 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)   \
<span class="lineNum">   35946 </span><span class="lineCov">         65 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_COPYPRIVATE)    \</span>
<span class="lineNum">   35947 </span><span class="lineCov">         65 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_NOWAIT))</span>
<a name="35948"><span class="lineNum">   35948 </span>            : </a>
<span class="lineNum">   35949 </span><span class="lineCov">         65 : static tree</span>
<span class="lineNum">   35950 </span><span class="lineCov">         65 : cp_parser_omp_single (cp_parser *parser, cp_token *pragma_tok, bool *if_p)</span>
<span class="lineNum">   35951 </span><span class="lineCov">         65 : {</span>
<span class="lineNum">   35952 </span><span class="lineCov">         65 :   tree stmt = make_node (OMP_SINGLE);</span>
<span class="lineNum">   35953 </span><span class="lineCov">        130 :   TREE_TYPE (stmt) = void_type_node;</span>
<span class="lineNum">   35954 </span><span class="lineCov">         65 : </span>
<span class="lineNum">   35955 </span>            :   OMP_SINGLE_CLAUSES (stmt)
<span class="lineNum">   35956 </span><span class="lineCov">         65 :     = cp_parser_omp_all_clauses (parser, OMP_SINGLE_CLAUSE_MASK,</span>
<span class="lineNum">   35957 </span><span class="lineCov">         65 :                                  &quot;#pragma omp single&quot;, pragma_tok);</span>
<span class="lineNum">   35958 </span>            :   OMP_SINGLE_BODY (stmt) = cp_parser_omp_structured_block (parser, if_p);
<span class="lineNum">   35959 </span>            : 
<span class="lineNum">   35960 </span>            :   return add_stmt (stmt);
<span class="lineNum">   35961 </span><span class="lineCov">       1317 : }</span>
<span class="lineNum">   35962 </span>            : 
<span class="lineNum">   35963 </span><span class="lineCov">       1317 : /* OpenMP 3.0:</span>
<span class="lineNum">   35964 </span>            :    # pragma omp task task-clause[optseq] new-line
<span class="lineNum">   35965 </span><span class="lineCov">         12 :      structured-block  */</span>
<span class="lineNum">   35966 </span><span class="lineCov">         12 : </span>
<span class="lineNum">   35967 </span>            : #define OMP_TASK_CLAUSE_MASK                                    \
<span class="lineNum">   35968 </span>            :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_IF)             \
<span class="lineNum">   35969 </span><span class="lineCov">       1317 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_UNTIED) \</span>
<span class="lineNum">   35970 </span><span class="lineCov">       1317 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DEFAULT)        \</span>
<span class="lineNum">   35971 </span><span class="lineCov">       1317 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_PRIVATE)        \</span>
<span class="lineNum">   35972 </span><span class="lineCov">       2634 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)   \</span>
<span class="lineNum">   35973 </span><span class="lineCov">       1317 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_SHARED) \</span>
<span class="lineNum">   35974 </span><span class="lineCov">       1317 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_FINAL)  \</span>
<span class="lineNum">   35975 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_MERGEABLE)      \
<span class="lineNum">   35976 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DEPEND) \
<span class="lineNum">   35977 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_PRIORITY))
<a name="35978"><span class="lineNum">   35978 </span>            : </a>
<span class="lineNum">   35979 </span>            : static tree
<span class="lineNum">   35980 </span>            : cp_parser_omp_task (cp_parser *parser, cp_token *pragma_tok, bool *if_p)
<span class="lineNum">   35981 </span>            : {
<span class="lineNum">   35982 </span>            :   tree clauses, block;
<span class="lineNum">   35983 </span>            :   unsigned int save;
<span class="lineNum">   35984 </span>            : 
<span class="lineNum">   35985 </span>            :   clauses = cp_parser_omp_all_clauses (parser, OMP_TASK_CLAUSE_MASK,
<span class="lineNum">   35986 </span>            :                                        &quot;#pragma omp task&quot;, pragma_tok);
<span class="lineNum">   35987 </span>            :   block = begin_omp_task ();
<span class="lineNum">   35988 </span><span class="lineCov">        254 :   save = cp_parser_begin_omp_structured_block (parser);</span>
<span class="lineNum">   35989 </span>            :   cp_parser_statement (parser, NULL_TREE, false, if_p);
<span class="lineNum">   35990 </span><span class="lineCov">        254 :   cp_parser_end_omp_structured_block (parser, save);</span>
<span class="lineNum">   35991 </span><span class="lineCov">        254 :   return finish_omp_task (clauses, block);</span>
<span class="lineNum">   35992 </span>            : }
<span class="lineNum">   35993 </span><span class="lineCov">        254 : </span>
<span class="lineNum">   35994 </span><span class="lineCov">       2286 : /* OpenMP 3.0:</span>
<span class="lineNum">   35995 </span>            :    # pragma omp taskwait new-line  */
<a name="35996"><span class="lineNum">   35996 </span><span class="lineCov">        254 : </span></a>
<span class="lineNum">   35997 </span>            : static void
<span class="lineNum">   35998 </span><span class="lineCov">        254 : cp_parser_omp_taskwait (cp_parser *parser, cp_token *pragma_tok)</span>
<span class="lineNum">   35999 </span>            : {
<span class="lineNum">   36000 </span>            :   cp_parser_require_pragma_eol (parser, pragma_tok);
<span class="lineNum">   36001 </span>            :   finish_omp_taskwait ();
<span class="lineNum">   36002 </span>            : }
<span class="lineNum">   36003 </span>            : 
<span class="lineNum">   36004 </span>            : /* OpenMP 3.1:
<span class="lineNum">   36005 </span>            :    # pragma omp taskyield new-line  */
<a name="36006"><span class="lineNum">   36006 </span>            : </a>
<span class="lineNum">   36007 </span>            : static void
<span class="lineNum">   36008 </span>            : cp_parser_omp_taskyield (cp_parser *parser, cp_token *pragma_tok)
<span class="lineNum">   36009 </span>            : {
<span class="lineNum">   36010 </span>            :   cp_parser_require_pragma_eol (parser, pragma_tok);
<span class="lineNum">   36011 </span>            :   finish_omp_taskyield ();
<span class="lineNum">   36012 </span>            : }
<span class="lineNum">   36013 </span>            : 
<span class="lineNum">   36014 </span>            : /* OpenMP 4.0:
<span class="lineNum">   36015 </span>            :    # pragma omp taskgroup new-line
<span class="lineNum">   36016 </span>            :      structured-block  */
<a name="36017"><span class="lineNum">   36017 </span>            : </a>
<span class="lineNum">   36018 </span><span class="lineCov">        590 : static tree</span>
<span class="lineNum">   36019 </span>            : cp_parser_omp_taskgroup (cp_parser *parser, cp_token *pragma_tok, bool *if_p)
<span class="lineNum">   36020 </span><span class="lineCov">        590 : {</span>
<span class="lineNum">   36021 </span><span class="lineCov">        590 :   cp_parser_require_pragma_eol (parser, pragma_tok);</span>
<span class="lineNum">   36022 </span>            :   return c_finish_omp_taskgroup (input_location,
<span class="lineNum">   36023 </span><span class="lineCov">      11800 :                                  cp_parser_omp_structured_block (parser,</span>
<span class="lineNum">   36024 </span>            :                                                                  if_p));
<span class="lineNum">   36025 </span><span class="lineCov">        590 : }</span>
<span class="lineNum">   36026 </span><span class="lineCov">        590 : </span>
<span class="lineNum">   36027 </span><span class="lineCov">        590 : </span>
<span class="lineNum">   36028 </span><span class="lineCov">       1180 : /* OpenMP 2.5:</span>
<span class="lineNum">   36029 </span><span class="lineCov">        590 :    # pragma omp threadprivate (variable-list) */</span>
<a name="36030"><span class="lineNum">   36030 </span>            : </a>
<span class="lineNum">   36031 </span>            : static void
<span class="lineNum">   36032 </span>            : cp_parser_omp_threadprivate (cp_parser *parser, cp_token *pragma_tok)
<span class="lineNum">   36033 </span>            : {
<span class="lineNum">   36034 </span>            :   tree vars;
<span class="lineNum">   36035 </span>            : 
<span class="lineNum">   36036 </span><span class="lineNoCov">          0 :   vars = cp_parser_omp_var_list (parser, OMP_CLAUSE_ERROR, NULL);</span>
<span class="lineNum">   36037 </span>            :   cp_parser_require_pragma_eol (parser, pragma_tok);
<span class="lineNum">   36038 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   36039 </span><span class="lineNoCov">          0 :   finish_omp_threadprivate (vars);</span>
<span class="lineNum">   36040 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   36041 </span>            : 
<span class="lineNum">   36042 </span>            : /* OpenMP 4.0:
<span class="lineNum">   36043 </span>            :    # pragma omp cancel cancel-clause[optseq] new-line  */
<span class="lineNum">   36044 </span>            : 
<span class="lineNum">   36045 </span>            : #define OMP_CANCEL_CLAUSE_MASK                                  \
<span class="lineNum">   36046 </span><span class="lineNoCov">          0 :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_PARALLEL)       \</span>
<span class="lineNum">   36047 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_FOR)            \
<span class="lineNum">   36048 </span><span class="lineNoCov">          0 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_SECTIONS)       \</span>
<span class="lineNum">   36049 </span><span class="lineNoCov">          0 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_TASKGROUP)      \</span>
<span class="lineNum">   36050 </span><span class="lineNoCov">          0 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_IF))</span>
<a name="36051"><span class="lineNum">   36051 </span>            : </a>
<span class="lineNum">   36052 </span>            : static void
<span class="lineNum">   36053 </span>            : cp_parser_omp_cancel (cp_parser *parser, cp_token *pragma_tok)
<span class="lineNum">   36054 </span>            : {
<span class="lineNum">   36055 </span>            :   tree clauses = cp_parser_omp_all_clauses (parser, OMP_CANCEL_CLAUSE_MASK,
<span class="lineNum">   36056 </span>            :                                             &quot;#pragma omp cancel&quot;, pragma_tok);
<span class="lineNum">   36057 </span><span class="lineCov">         44 :   finish_omp_cancel (clauses);</span>
<span class="lineNum">   36058 </span>            : }
<span class="lineNum">   36059 </span><span class="lineCov">         44 : </span>
<span class="lineNum">   36060 </span><span class="lineCov">         44 : /* OpenMP 4.0:</span>
<span class="lineNum">   36061 </span>            :    # pragma omp cancellation point cancelpt-clause[optseq] new-line  */
<span class="lineNum">   36062 </span><span class="lineCov">         44 : </span>
<span class="lineNum">   36063 </span>            : #define OMP_CANCELLATION_POINT_CLAUSE_MASK                      \
<span class="lineNum">   36064 </span>            :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_PARALLEL)       \
<span class="lineNum">   36065 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_FOR)            \
<span class="lineNum">   36066 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_SECTIONS)       \
<span class="lineNum">   36067 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_TASKGROUP))
<a name="36068"><span class="lineNum">   36068 </span>            : </a>
<span class="lineNum">   36069 </span>            : static void
<span class="lineNum">   36070 </span><span class="lineCov">        114 : cp_parser_omp_cancellation_point (cp_parser *parser, cp_token *pragma_tok,</span>
<span class="lineNum">   36071 </span>            :                                   enum pragma_context context)
<span class="lineNum">   36072 </span><span class="lineCov">        114 : {</span>
<span class="lineNum">   36073 </span>            :   tree clauses;
<span class="lineNum">   36074 </span><span class="lineCov">        114 :   bool point_seen = false;</span>
<span class="lineNum">   36075 </span><span class="lineCov">        114 : </span>
<span class="lineNum">   36076 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))
<span class="lineNum">   36077 </span><span class="lineCov">        114 :     {</span>
<span class="lineNum">   36078 </span><span class="lineCov">        114 :       tree id = cp_lexer_peek_token (parser-&gt;lexer)-&gt;u.value;</span>
<span class="lineNum">   36079 </span>            :       const char *p = IDENTIFIER_POINTER (id);
<span class="lineNum">   36080 </span>            : 
<span class="lineNum">   36081 </span>            :       if (strcmp (p, &quot;point&quot;) == 0)
<span class="lineNum">   36082 </span>            :         {
<span class="lineNum">   36083 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   36084 </span>            :           point_seen = true;
<span class="lineNum">   36085 </span>            :         }
<span class="lineNum">   36086 </span>            :     }
<span class="lineNum">   36087 </span>            :   if (!point_seen)
<span class="lineNum">   36088 </span>            :     {
<span class="lineNum">   36089 </span>            :       cp_parser_error (parser, &quot;expected %&lt;point%&gt;&quot;);
<span class="lineNum">   36090 </span>            :       cp_parser_skip_to_pragma_eol (parser, pragma_tok);
<span class="lineNum">   36091 </span><span class="lineCov">        425 :       return;</span>
<span class="lineNum">   36092 </span>            :     }
<span class="lineNum">   36093 </span><span class="lineCov">       4250 : </span>
<span class="lineNum">   36094 </span>            :   if (context != pragma_compound)
<span class="lineNum">   36095 </span><span class="lineCov">        425 :     {</span>
<span class="lineNum">   36096 </span><span class="lineCov">        425 :       if (context == pragma_stmt)</span>
<span class="lineNum">   36097 </span>            :         error_at (pragma_tok-&gt;location,
<span class="lineNum">   36098 </span>            :                   &quot;%&lt;#pragma %s%&gt; may only be used in compound statements&quot;,
<span class="lineNum">   36099 </span>            :                   &quot;omp cancellation point&quot;);
<span class="lineNum">   36100 </span>            :       else
<span class="lineNum">   36101 </span>            :         cp_parser_error (parser, &quot;expected declaration specifiers&quot;);
<span class="lineNum">   36102 </span>            :       cp_parser_skip_to_pragma_eol (parser, pragma_tok);
<span class="lineNum">   36103 </span>            :       return;
<span class="lineNum">   36104 </span>            :     }
<span class="lineNum">   36105 </span>            : 
<span class="lineNum">   36106 </span>            :   clauses = cp_parser_omp_all_clauses (parser,
<span class="lineNum">   36107 </span>            :                                        OMP_CANCELLATION_POINT_CLAUSE_MASK,
<span class="lineNum">   36108 </span><span class="lineCov">        430 :                                        &quot;#pragma omp cancellation point&quot;,</span>
<span class="lineNum">   36109 </span>            :                                        pragma_tok);
<span class="lineNum">   36110 </span>            :   finish_omp_cancellation_point (clauses);
<span class="lineNum">   36111 </span><span class="lineCov">        430 : }</span>
<span class="lineNum">   36112 </span><span class="lineCov">        430 : </span>
<span class="lineNum">   36113 </span>            : /* OpenMP 4.0:
<span class="lineNum">   36114 </span><span class="lineCov">        430 :    #pragma omp distribute distribute-clause[optseq] new-line</span>
<span class="lineNum">   36115 </span>            :      for-loop  */
<span class="lineNum">   36116 </span><span class="lineCov">        860 : </span>
<span class="lineNum">   36117 </span><span class="lineCov">        430 : #define OMP_DISTRIBUTE_CLAUSE_MASK                              \</span>
<span class="lineNum">   36118 </span>            :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_PRIVATE)        \
<span class="lineNum">   36119 </span><span class="lineCov">        430 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)   \</span>
<span class="lineNum">   36120 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_LASTPRIVATE)    \
<span class="lineNum">   36121 </span><span class="lineCov">        424 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DIST_SCHEDULE)\</span>
<span class="lineNum">   36122 </span><span class="lineCov">        424 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_COLLAPSE))</span>
<a name="36123"><span class="lineNum">   36123 </span>            : </a>
<span class="lineNum">   36124 </span>            : static tree
<span class="lineNum">   36125 </span><span class="lineCov">        424 : cp_parser_omp_distribute (cp_parser *parser, cp_token *pragma_tok,</span>
<span class="lineNum">   36126 </span>            :                           char *p_name, omp_clause_mask mask, tree *cclauses,
<span class="lineNum">   36127 </span><span class="lineCov">          6 :                           bool *if_p)</span>
<span class="lineNum">   36128 </span><span class="lineCov">          6 : {</span>
<span class="lineNum">   36129 </span><span class="lineCov">          6 :   tree clauses, sb, ret;</span>
<span class="lineNum">   36130 </span>            :   unsigned int save;
<span class="lineNum">   36131 </span>            :   location_t loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">   36132 </span><span class="lineCov">        424 : </span>
<span class="lineNum">   36133 </span>            :   strcat (p_name, &quot; distribute&quot;);
<span class="lineNum">   36134 </span><span class="lineCov">         30 :   mask |= OMP_DISTRIBUTE_CLAUSE_MASK;</span>
<span class="lineNum">   36135 </span><span class="lineCov">         27 : </span>
<span class="lineNum">   36136 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))
<span class="lineNum">   36137 </span>            :     {
<span class="lineNum">   36138 </span>            :       tree id = cp_lexer_peek_token (parser-&gt;lexer)-&gt;u.value;
<span class="lineNum">   36139 </span><span class="lineCov">          3 :       const char *p = IDENTIFIER_POINTER (id);</span>
<span class="lineNum">   36140 </span><span class="lineCov">         30 :       bool simd = false;</span>
<span class="lineNum">   36141 </span><span class="lineCov">         30 :       bool parallel = false;</span>
<span class="lineNum">   36142 </span>            : 
<span class="lineNum">   36143 </span>            :       if (strcmp (p, &quot;simd&quot;) == 0)
<span class="lineNum">   36144 </span><span class="lineCov">        394 :         simd = true;</span>
<span class="lineNum">   36145 </span><span class="lineCov">       2758 :       else</span>
<span class="lineNum">   36146 </span>            :         parallel = strcmp (p, &quot;parallel&quot;) == 0;
<span class="lineNum">   36147 </span>            :       if (parallel || simd)
<span class="lineNum">   36148 </span><span class="lineCov">        394 :         {</span>
<span class="lineNum">   36149 </span>            :           tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];
<span class="lineNum">   36150 </span>            :           if (cclauses == NULL)
<span class="lineNum">   36151 </span>            :             cclauses = cclauses_buf;
<span class="lineNum">   36152 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   36153 </span>            :           if (!flag_openmp)  /* flag_openmp_simd  */
<span class="lineNum">   36154 </span>            :             {
<span class="lineNum">   36155 </span>            :               if (simd)
<span class="lineNum">   36156 </span>            :                 return cp_parser_omp_simd (parser, pragma_tok, p_name, mask,
<span class="lineNum">   36157 </span>            :                                            cclauses, if_p);
<span class="lineNum">   36158 </span>            :               else
<span class="lineNum">   36159 </span>            :                 return cp_parser_omp_parallel (parser, pragma_tok, p_name, mask,
<span class="lineNum">   36160 </span>            :                                                cclauses, if_p);
<span class="lineNum">   36161 </span>            :             }
<span class="lineNum">   36162 </span>            :           sb = begin_omp_structured_block ();
<span class="lineNum">   36163 </span><span class="lineCov">       1456 :           save = cp_parser_begin_omp_structured_block (parser);</span>
<span class="lineNum">   36164 </span>            :           if (simd)
<span class="lineNum">   36165 </span>            :             ret = cp_parser_omp_simd (parser, pragma_tok, p_name, mask,
<span class="lineNum">   36166 </span>            :                                       cclauses, if_p);
<span class="lineNum">   36167 </span><span class="lineCov">       1456 :           else</span>
<span class="lineNum">   36168 </span><span class="lineCov">       1456 :             ret = cp_parser_omp_parallel (parser, pragma_tok, p_name, mask,</span>
<span class="lineNum">   36169 </span><span class="lineCov">       2912 :                                           cclauses, if_p);</span>
<span class="lineNum">   36170 </span>            :           cp_parser_end_omp_structured_block (parser, save);
<span class="lineNum">   36171 </span><span class="lineCov">       1456 :           tree body = finish_omp_structured_block (sb);</span>
<span class="lineNum">   36172 </span><span class="lineCov">      14560 :           if (ret == NULL)</span>
<span class="lineNum">   36173 </span>            :             return ret;
<span class="lineNum">   36174 </span><span class="lineCov">       1456 :           ret = make_node (OMP_DISTRIBUTE);</span>
<span class="lineNum">   36175 </span>            :           TREE_TYPE (ret) = void_type_node;
<span class="lineNum">   36176 </span><span class="lineCov">       2792 :           OMP_FOR_BODY (ret) = body;</span>
<span class="lineNum">   36177 </span><span class="lineCov">       1396 :           OMP_FOR_CLAUSES (ret) = cclauses[C_OMP_CLAUSE_SPLIT_DISTRIBUTE];</span>
<span class="lineNum">   36178 </span><span class="lineCov">       1396 :           SET_EXPR_LOCATION (ret, loc);</span>
<span class="lineNum">   36179 </span><span class="lineCov">       1396 :           add_stmt (ret);</span>
<span class="lineNum">   36180 </span>            :           return ret;
<span class="lineNum">   36181 </span><span class="lineCov">       1396 :         }</span>
<span class="lineNum">   36182 </span>            :     }
<span class="lineNum">   36183 </span>            :   if (!flag_openmp)  /* flag_openmp_simd  */
<span class="lineNum">   36184 </span><span class="lineCov">       1214 :     {</span>
<span class="lineNum">   36185 </span><span class="lineCov">       1396 :       cp_parser_skip_to_pragma_eol (parser, pragma_tok);</span>
<span class="lineNum">   36186 </span>            :       return NULL_TREE;
<span class="lineNum">   36187 </span><span class="lineCov">       1285 :     }</span>
<span class="lineNum">   36188 </span><span class="lineCov">       1285 : </span>
<span class="lineNum">   36189 </span><span class="lineCov">        454 :   clauses = cp_parser_omp_all_clauses (parser, mask, p_name, pragma_tok,</span>
<span class="lineNum">   36190 </span><span class="lineCov">       1285 :                                        cclauses == NULL);</span>
<span class="lineNum">   36191 </span><span class="lineCov">       1285 :   if (cclauses)</span>
<span class="lineNum">   36192 </span>            :     {
<span class="lineNum">   36193 </span><span class="lineCov">         18 :       cp_omp_split_clauses (loc, OMP_DISTRIBUTE, mask, clauses, cclauses);</span>
<span class="lineNum">   36194 </span><span class="lineCov">          9 :       clauses = cclauses[C_OMP_CLAUSE_SPLIT_DISTRIBUTE];</span>
<span class="lineNum">   36195 </span><span class="lineCov">          9 :     }</span>
<span class="lineNum">   36196 </span>            : 
<span class="lineNum">   36197 </span><span class="lineCov">          9 :   sb = begin_omp_structured_block ();</span>
<span class="lineNum">   36198 </span><span class="lineCov">          9 :   save = cp_parser_begin_omp_structured_block (parser);</span>
<span class="lineNum">   36199 </span>            : 
<span class="lineNum">   36200 </span><span class="lineCov">       1267 :   ret = cp_parser_omp_for_loop (parser, OMP_DISTRIBUTE, clauses, NULL, if_p);</span>
<span class="lineNum">   36201 </span><span class="lineCov">       1267 : </span>
<span class="lineNum">   36202 </span><span class="lineCov">       1267 :   cp_parser_end_omp_structured_block (parser, save);</span>
<span class="lineNum">   36203 </span><span class="lineCov">        173 :   add_stmt (finish_omp_structured_block (sb));</span>
<span class="lineNum">   36204 </span>            : 
<span class="lineNum">   36205 </span>            :   return ret;
<span class="lineNum">   36206 </span><span class="lineCov">       1094 : }</span>
<span class="lineNum">   36207 </span>            : 
<span class="lineNum">   36208 </span><span class="lineCov">       2534 : /* OpenMP 4.0:</span>
<span class="lineNum">   36209 </span><span class="lineCov">       1267 :    # pragma omp teams teams-clause[optseq] new-line</span>
<span class="lineNum">   36210 </span><span class="lineCov">       1267 :      structured-block  */</span>
<span class="lineNum">   36211 </span>            : 
<span class="lineNum">   36212 </span><span class="lineCov">       1264 : #define OMP_TEAMS_CLAUSE_MASK                                   \</span>
<span class="lineNum">   36213 </span><span class="lineCov">       1264 :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_PRIVATE)        \</span>
<span class="lineNum">   36214 </span><span class="lineCov">       2528 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)   \</span>
<span class="lineNum">   36215 </span><span class="lineCov">       2528 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_SHARED) \</span>
<span class="lineNum">   36216 </span><span class="lineCov">       1264 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_REDUCTION)      \</span>
<span class="lineNum">   36217 </span><span class="lineCov">       1264 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_NUM_TEAMS)      \</span>
<span class="lineNum">   36218 </span><span class="lineCov">       1264 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_THREAD_LIMIT)   \</span>
<span class="lineNum">   36219 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DEFAULT))
<a name="36220"><span class="lineNum">   36220 </span>            : </a>
<span class="lineNum">   36221 </span><span class="lineCov">        171 : static tree</span>
<span class="lineNum">   36222 </span>            : cp_parser_omp_teams (cp_parser *parser, cp_token *pragma_tok,
<span class="lineNum">   36223 </span><span class="lineNoCov">          0 :                      char *p_name, omp_clause_mask mask, tree *cclauses,</span>
<span class="lineNum">   36224 </span><span class="lineNoCov">          0 :                      bool *if_p)</span>
<span class="lineNum">   36225 </span>            : {
<span class="lineNum">   36226 </span>            :   tree clauses, sb, ret;
<span class="lineNum">   36227 </span><span class="lineCov">        171 :   unsigned int save;</span>
<span class="lineNum">   36228 </span>            :   location_t loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">   36229 </span><span class="lineCov">        171 : </span>
<span class="lineNum">   36230 </span>            :   strcat (p_name, &quot; teams&quot;);
<span class="lineNum">   36231 </span><span class="lineCov">         93 :   mask |= OMP_TEAMS_CLAUSE_MASK;</span>
<span class="lineNum">   36232 </span><span class="lineCov">         93 : </span>
<span class="lineNum">   36233 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))
<span class="lineNum">   36234 </span>            :     {
<span class="lineNum">   36235 </span><span class="lineCov">        171 :       tree id = cp_lexer_peek_token (parser-&gt;lexer)-&gt;u.value;</span>
<span class="lineNum">   36236 </span><span class="lineCov">        171 :       const char *p = IDENTIFIER_POINTER (id);</span>
<span class="lineNum">   36237 </span>            :       if (strcmp (p, &quot;distribute&quot;) == 0)
<span class="lineNum">   36238 </span><span class="lineCov">        171 :         {</span>
<span class="lineNum">   36239 </span>            :           tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];
<span class="lineNum">   36240 </span><span class="lineCov">        342 :           if (cclauses == NULL)</span>
<span class="lineNum">   36241 </span><span class="lineCov">        171 :             cclauses = cclauses_buf;</span>
<span class="lineNum">   36242 </span>            : 
<span class="lineNum">   36243 </span><span class="lineCov">        171 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   36244 </span>            :           if (!flag_openmp)  /* flag_openmp_simd  */
<span class="lineNum">   36245 </span>            :             return cp_parser_omp_distribute (parser, pragma_tok, p_name, mask,
<span class="lineNum">   36246 </span>            :                                              cclauses, if_p);
<span class="lineNum">   36247 </span>            :           sb = begin_omp_structured_block ();
<span class="lineNum">   36248 </span>            :           save = cp_parser_begin_omp_structured_block (parser);
<span class="lineNum">   36249 </span>            :           ret = cp_parser_omp_distribute (parser, pragma_tok, p_name, mask,
<span class="lineNum">   36250 </span>            :                                           cclauses, if_p);
<span class="lineNum">   36251 </span>            :           cp_parser_end_omp_structured_block (parser, save);
<span class="lineNum">   36252 </span>            :           tree body = finish_omp_structured_block (sb);
<span class="lineNum">   36253 </span>            :           if (ret == NULL)
<span class="lineNum">   36254 </span>            :             return ret;
<span class="lineNum">   36255 </span>            :           clauses = cclauses[C_OMP_CLAUSE_SPLIT_TEAMS];
<span class="lineNum">   36256 </span>            :           ret = make_node (OMP_TEAMS);
<span class="lineNum">   36257 </span>            :           TREE_TYPE (ret) = void_type_node;
<span class="lineNum">   36258 </span>            :           OMP_TEAMS_CLAUSES (ret) = clauses;
<span class="lineNum">   36259 </span>            :           OMP_TEAMS_BODY (ret) = body;
<span class="lineNum">   36260 </span><span class="lineCov">       1149 :           OMP_TEAMS_COMBINED (ret) = 1;</span>
<span class="lineNum">   36261 </span>            :           SET_EXPR_LOCATION (ret, loc);
<span class="lineNum">   36262 </span>            :           return add_stmt (ret);
<span class="lineNum">   36263 </span>            :         }
<span class="lineNum">   36264 </span><span class="lineCov">       1149 :     }</span>
<span class="lineNum">   36265 </span><span class="lineCov">       1149 :   if (!flag_openmp)  /* flag_openmp_simd  */</span>
<span class="lineNum">   36266 </span><span class="lineCov">       2298 :     {</span>
<span class="lineNum">   36267 </span>            :       cp_parser_skip_to_pragma_eol (parser, pragma_tok);
<span class="lineNum">   36268 </span><span class="lineCov">       1149 :       return NULL_TREE;</span>
<span class="lineNum">   36269 </span><span class="lineCov">      16086 :     }</span>
<span class="lineNum">   36270 </span>            : 
<span class="lineNum">   36271 </span><span class="lineCov">       1149 :   clauses = cp_parser_omp_all_clauses (parser, mask, p_name, pragma_tok,</span>
<span class="lineNum">   36272 </span>            :                                        cclauses == NULL);
<span class="lineNum">   36273 </span><span class="lineCov">       2140 :   if (cclauses)</span>
<span class="lineNum">   36274 </span><span class="lineCov">       1070 :     {</span>
<span class="lineNum">   36275 </span><span class="lineCov">       1070 :       cp_omp_split_clauses (loc, OMP_TEAMS, mask, clauses, cclauses);</span>
<span class="lineNum">   36276 </span>            :       clauses = cclauses[C_OMP_CLAUSE_SPLIT_TEAMS];
<span class="lineNum">   36277 </span><span class="lineCov">        924 :     }</span>
<span class="lineNum">   36278 </span><span class="lineCov">        924 : </span>
<span class="lineNum">   36279 </span><span class="lineCov">        457 :   tree stmt = make_node (OMP_TEAMS);</span>
<span class="lineNum">   36280 </span>            :   TREE_TYPE (stmt) = void_type_node;
<span class="lineNum">   36281 </span><span class="lineCov">        924 :   OMP_TEAMS_CLAUSES (stmt) = clauses;</span>
<span class="lineNum">   36282 </span><span class="lineCov">        924 :   OMP_TEAMS_BODY (stmt) = cp_parser_omp_structured_block (parser, if_p);</span>
<span class="lineNum">   36283 </span><span class="lineCov">         12 :   SET_EXPR_LOCATION (stmt, loc);</span>
<span class="lineNum">   36284 </span><span class="lineCov">         12 : </span>
<span class="lineNum">   36285 </span><span class="lineCov">        912 :   return add_stmt (stmt);</span>
<span class="lineNum">   36286 </span><span class="lineCov">        912 : }</span>
<span class="lineNum">   36287 </span><span class="lineCov">        912 : </span>
<span class="lineNum">   36288 </span>            : /* OpenMP 4.0:
<span class="lineNum">   36289 </span><span class="lineCov">       1824 :    # pragma omp target data target-data-clause[optseq] new-line</span>
<span class="lineNum">   36290 </span><span class="lineCov">        912 :      structured-block  */</span>
<span class="lineNum">   36291 </span><span class="lineCov">        912 : </span>
<span class="lineNum">   36292 </span>            : #define OMP_TARGET_DATA_CLAUSE_MASK                             \
<span class="lineNum">   36293 </span><span class="lineCov">        912 :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DEVICE) \</span>
<span class="lineNum">   36294 </span><span class="lineCov">        912 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_MAP)            \</span>
<span class="lineNum">   36295 </span><span class="lineCov">        912 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_IF)             \</span>
<span class="lineNum">   36296 </span><span class="lineCov">        912 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_USE_DEVICE_PTR))</span>
<a name="36297"><span class="lineNum">   36297 </span><span class="lineCov">        912 : </span></a>
<span class="lineNum">   36298 </span><span class="lineCov">        912 : static tree</span>
<span class="lineNum">   36299 </span><span class="lineCov">        912 : cp_parser_omp_target_data (cp_parser *parser, cp_token *pragma_tok, bool *if_p)</span>
<span class="lineNum">   36300 </span><span class="lineCov">        912 : {</span>
<span class="lineNum">   36301 </span>            :   tree clauses
<span class="lineNum">   36302 </span>            :     = cp_parser_omp_all_clauses (parser, OMP_TARGET_DATA_CLAUSE_MASK,
<span class="lineNum">   36303 </span><span class="lineCov">        225 :                                  &quot;#pragma omp target data&quot;, pragma_tok);</span>
<span class="lineNum">   36304 </span>            :   int map_seen = 0;
<span class="lineNum">   36305 </span><span class="lineCov">          3 :   for (tree *pc = &amp;clauses; *pc;)</span>
<span class="lineNum">   36306 </span><span class="lineCov">          3 :     {</span>
<span class="lineNum">   36307 </span>            :       if (OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_MAP)
<span class="lineNum">   36308 </span>            :         switch (OMP_CLAUSE_MAP_KIND (*pc))
<span class="lineNum">   36309 </span><span class="lineCov">        222 :           {</span>
<span class="lineNum">   36310 </span>            :           case GOMP_MAP_TO:
<span class="lineNum">   36311 </span><span class="lineCov">        222 :           case GOMP_MAP_ALWAYS_TO:</span>
<span class="lineNum">   36312 </span>            :           case GOMP_MAP_FROM:
<span class="lineNum">   36313 </span><span class="lineCov">        125 :           case GOMP_MAP_ALWAYS_FROM:</span>
<span class="lineNum">   36314 </span><span class="lineCov">        125 :           case GOMP_MAP_TOFROM:</span>
<span class="lineNum">   36315 </span>            :           case GOMP_MAP_ALWAYS_TOFROM:
<span class="lineNum">   36316 </span>            :           case GOMP_MAP_ALLOC:
<span class="lineNum">   36317 </span><span class="lineCov">        222 :             map_seen = 3;</span>
<span class="lineNum">   36318 </span><span class="lineCov">        222 :             break;</span>
<span class="lineNum">   36319 </span><span class="lineCov">        222 :           case GOMP_MAP_FIRSTPRIVATE_POINTER:</span>
<span class="lineNum">   36320 </span><span class="lineCov">        222 :           case GOMP_MAP_FIRSTPRIVATE_REFERENCE:</span>
<span class="lineNum">   36321 </span><span class="lineCov">        222 :           case GOMP_MAP_ALWAYS_POINTER:</span>
<span class="lineNum">   36322 </span>            :             break;
<span class="lineNum">   36323 </span><span class="lineCov">        222 :           default:</span>
<span class="lineNum">   36324 </span>            :             map_seen |= 1;
<span class="lineNum">   36325 </span>            :             error_at (OMP_CLAUSE_LOCATION (*pc),
<span class="lineNum">   36326 </span>            :                       &quot;%&lt;#pragma omp target data%&gt; with map-type other &quot;
<span class="lineNum">   36327 </span>            :                       &quot;than %&lt;to%&gt;, %&lt;from%&gt;, %&lt;tofrom%&gt; or %&lt;alloc%&gt; &quot;
<span class="lineNum">   36328 </span>            :                       &quot;on %&lt;map%&gt; clause&quot;);
<span class="lineNum">   36329 </span>            :             *pc = OMP_CLAUSE_CHAIN (*pc);
<span class="lineNum">   36330 </span>            :             continue;
<span class="lineNum">   36331 </span>            :           }
<span class="lineNum">   36332 </span>            :       pc = &amp;OMP_CLAUSE_CHAIN (*pc);
<span class="lineNum">   36333 </span>            :     }
<span class="lineNum">   36334 </span>            : 
<span class="lineNum">   36335 </span>            :   if (map_seen != 3)
<span class="lineNum">   36336 </span>            :     {
<span class="lineNum">   36337 </span><span class="lineCov">        127 :       if (map_seen == 0)</span>
<span class="lineNum">   36338 </span>            :         error_at (pragma_tok-&gt;location,
<span class="lineNum">   36339 </span><span class="lineCov">        127 :                   &quot;%&lt;#pragma omp target data%&gt; must contain at least &quot;</span>
<span class="lineNum">   36340 </span><span class="lineCov">       1016 :                   &quot;one %&lt;map%&gt; clause&quot;);</span>
<span class="lineNum">   36341 </span><span class="lineCov">        127 :       return NULL_TREE;</span>
<span class="lineNum">   36342 </span><span class="lineCov">        127 :     }</span>
<span class="lineNum">   36343 </span><span class="lineCov">        344 : </span>
<span class="lineNum">   36344 </span>            :   tree stmt = make_node (OMP_TARGET_DATA);
<span class="lineNum">   36345 </span><span class="lineCov">        217 :   TREE_TYPE (stmt) = void_type_node;</span>
<span class="lineNum">   36346 </span><span class="lineCov">        197 :   OMP_TARGET_DATA_CLAUSES (stmt) = clauses;</span>
<span class="lineNum">   36347 </span>            : 
<span class="lineNum">   36348 </span><span class="lineCov">        174 :   keep_next_level (true);</span>
<span class="lineNum">   36349 </span><span class="lineCov">        174 :   OMP_TARGET_DATA_BODY (stmt) = cp_parser_omp_structured_block (parser, if_p);</span>
<span class="lineNum">   36350 </span><span class="lineCov">        174 : </span>
<span class="lineNum">   36351 </span><span class="lineCov">        174 :   SET_EXPR_LOCATION (stmt, pragma_tok-&gt;location);</span>
<span class="lineNum">   36352 </span><span class="lineCov">        174 :   return add_stmt (stmt);</span>
<span class="lineNum">   36353 </span><span class="lineCov">        174 : }</span>
<span class="lineNum">   36354 </span><span class="lineCov">        174 : </span>
<span class="lineNum">   36355 </span><span class="lineCov">        174 : /* OpenMP 4.5:</span>
<span class="lineNum">   36356 </span><span class="lineCov">        174 :    # pragma omp target enter data target-enter-data-clause[optseq] new-line</span>
<span class="lineNum">   36357 </span>            :      structured-block  */
<span class="lineNum">   36358 </span>            : 
<span class="lineNum">   36359 </span>            : #define OMP_TARGET_ENTER_DATA_CLAUSE_MASK                       \
<span class="lineNum">   36360 </span>            :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DEVICE) \
<span class="lineNum">   36361 </span><span class="lineNoCov">          0 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_MAP)            \</span>
<span class="lineNum">   36362 </span><span class="lineNoCov">          0 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_IF)             \</span>
<span class="lineNum">   36363 </span><span class="lineNoCov">          0 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DEPEND) \</span>
<span class="lineNum">   36364 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_NOWAIT))
<a name="36365"><span class="lineNum">   36365 </span>            : </a>
<span class="lineNum">   36366 </span>            : static tree
<span class="lineNum">   36367 </span><span class="lineNoCov">          0 : cp_parser_omp_target_enter_data (cp_parser *parser, cp_token *pragma_tok,</span>
<span class="lineNum">   36368 </span><span class="lineNoCov">          0 :                                  enum pragma_context context)</span>
<span class="lineNum">   36369 </span>            : {
<span class="lineNum">   36370 </span><span class="lineCov">        434 :   bool data_seen = false;</span>
<span class="lineNum">   36371 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))
<span class="lineNum">   36372 </span>            :     {
<span class="lineNum">   36373 </span><span class="lineCov">        127 :       tree id = cp_lexer_peek_token (parser-&gt;lexer)-&gt;u.value;</span>
<span class="lineNum">   36374 </span>            :       const char *p = IDENTIFIER_POINTER (id);
<span class="lineNum">   36375 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   36376 </span><span class="lineNoCov">          0 :       if (strcmp (p, &quot;data&quot;) == 0)</span>
<span class="lineNum">   36377 </span>            :         {
<span class="lineNum">   36378 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   36379 </span><span class="lineNoCov">          0 :           data_seen = true;</span>
<span class="lineNum">   36380 </span>            :         }
<span class="lineNum">   36381 </span>            :     }
<span class="lineNum">   36382 </span><span class="lineCov">        127 :   if (!data_seen)</span>
<span class="lineNum">   36383 </span><span class="lineCov">        127 :     {</span>
<span class="lineNum">   36384 </span><span class="lineCov">        127 :       cp_parser_error (parser, &quot;expected %&lt;data%&gt;&quot;);</span>
<span class="lineNum">   36385 </span>            :       cp_parser_skip_to_pragma_eol (parser, pragma_tok);
<span class="lineNum">   36386 </span><span class="lineCov">        127 :       return NULL_TREE;</span>
<span class="lineNum">   36387 </span><span class="lineCov">        127 :     }</span>
<span class="lineNum">   36388 </span>            : 
<span class="lineNum">   36389 </span><span class="lineCov">        127 :   if (context == pragma_stmt)</span>
<span class="lineNum">   36390 </span><span class="lineCov">        127 :     {</span>
<span class="lineNum">   36391 </span>            :       error_at (pragma_tok-&gt;location,
<span class="lineNum">   36392 </span>            :                 &quot;%&lt;#pragma %s%&gt; may only be used in compound statements&quot;,
<span class="lineNum">   36393 </span>            :                 &quot;omp target enter data&quot;);
<span class="lineNum">   36394 </span>            :       cp_parser_skip_to_pragma_eol (parser, pragma_tok);
<span class="lineNum">   36395 </span>            :       return NULL_TREE;
<span class="lineNum">   36396 </span>            :     }
<span class="lineNum">   36397 </span>            : 
<span class="lineNum">   36398 </span>            :   tree clauses
<span class="lineNum">   36399 </span>            :     = cp_parser_omp_all_clauses (parser, OMP_TARGET_ENTER_DATA_CLAUSE_MASK,
<span class="lineNum">   36400 </span>            :                                  &quot;#pragma omp target enter data&quot;, pragma_tok);
<span class="lineNum">   36401 </span>            :   int map_seen = 0;
<span class="lineNum">   36402 </span>            :   for (tree *pc = &amp;clauses; *pc;)
<span class="lineNum">   36403 </span>            :     {
<span class="lineNum">   36404 </span>            :       if (OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_MAP)
<span class="lineNum">   36405 </span><span class="lineCov">         47 :         switch (OMP_CLAUSE_MAP_KIND (*pc))</span>
<span class="lineNum">   36406 </span>            :           {
<span class="lineNum">   36407 </span>            :           case GOMP_MAP_TO:
<span class="lineNum">   36408 </span><span class="lineCov">         47 :           case GOMP_MAP_ALWAYS_TO:</span>
<span class="lineNum">   36409 </span><span class="lineCov">         47 :           case GOMP_MAP_ALLOC:</span>
<span class="lineNum">   36410 </span>            :             map_seen = 3;
<span class="lineNum">   36411 </span><span class="lineCov">         94 :             break;</span>
<span class="lineNum">   36412 </span><span class="lineCov">         47 :           case GOMP_MAP_FIRSTPRIVATE_POINTER:</span>
<span class="lineNum">   36413 </span>            :           case GOMP_MAP_FIRSTPRIVATE_REFERENCE:
<span class="lineNum">   36414 </span><span class="lineCov">         47 :           case GOMP_MAP_ALWAYS_POINTER:</span>
<span class="lineNum">   36415 </span>            :             break;
<span class="lineNum">   36416 </span><span class="lineCov">         47 :           default:</span>
<span class="lineNum">   36417 </span><span class="lineCov">         47 :             map_seen |= 1;</span>
<span class="lineNum">   36418 </span>            :             error_at (OMP_CLAUSE_LOCATION (*pc),
<span class="lineNum">   36419 </span>            :                       &quot;%&lt;#pragma omp target enter data%&gt; with map-type other &quot;
<span class="lineNum">   36420 </span><span class="lineCov">         47 :                       &quot;than %&lt;to%&gt; or %&lt;alloc%&gt; on %&lt;map%&gt; clause&quot;);</span>
<span class="lineNum">   36421 </span>            :             *pc = OMP_CLAUSE_CHAIN (*pc);
<span class="lineNum">   36422 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">   36423 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">   36424 </span><span class="lineNoCov">          0 :       pc = &amp;OMP_CLAUSE_CHAIN (*pc);</span>
<span class="lineNum">   36425 </span>            :     }
<span class="lineNum">   36426 </span>            : 
<span class="lineNum">   36427 </span><span class="lineCov">         47 :   if (map_seen != 3)</span>
<span class="lineNum">   36428 </span>            :     {
<span class="lineNum">   36429 </span><span class="lineCov">         24 :       if (map_seen == 0)</span>
<span class="lineNum">   36430 </span>            :         error_at (pragma_tok-&gt;location,
<span class="lineNum">   36431 </span>            :                   &quot;%&lt;#pragma omp target enter data%&gt; must contain at least &quot;
<span class="lineNum">   36432 </span><span class="lineCov">         24 :                   &quot;one %&lt;map%&gt; clause&quot;);</span>
<span class="lineNum">   36433 </span><span class="lineCov">         24 :       return NULL_TREE;</span>
<span class="lineNum">   36434 </span>            :     }
<span class="lineNum">   36435 </span>            : 
<span class="lineNum">   36436 </span><span class="lineCov">         23 :   tree stmt = make_node (OMP_TARGET_ENTER_DATA);</span>
<span class="lineNum">   36437 </span><span class="lineCov">        230 :   TREE_TYPE (stmt) = void_type_node;</span>
<span class="lineNum">   36438 </span><span class="lineCov">         23 :   OMP_TARGET_ENTER_DATA_CLAUSES (stmt) = clauses;</span>
<span class="lineNum">   36439 </span><span class="lineCov">         23 :   SET_EXPR_LOCATION (stmt, pragma_tok-&gt;location);</span>
<span class="lineNum">   36440 </span><span class="lineCov">        133 :   return add_stmt (stmt);</span>
<span class="lineNum">   36441 </span>            : }
<span class="lineNum">   36442 </span><span class="lineCov">        110 : </span>
<span class="lineNum">   36443 </span><span class="lineCov">        101 : /* OpenMP 4.5:</span>
<span class="lineNum">   36444 </span>            :    # pragma omp target exit data target-enter-data-clause[optseq] new-line
<span class="lineNum">   36445 </span><span class="lineCov">         73 :      structured-block  */</span>
<span class="lineNum">   36446 </span><span class="lineCov">         73 : </span>
<span class="lineNum">   36447 </span><span class="lineCov">         73 : #define OMP_TARGET_EXIT_DATA_CLAUSE_MASK                        \</span>
<span class="lineNum">   36448 </span><span class="lineCov">         73 :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DEVICE) \</span>
<span class="lineNum">   36449 </span><span class="lineCov">         73 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_MAP)            \</span>
<span class="lineNum">   36450 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_IF)             \
<span class="lineNum">   36451 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DEPEND) \
<span class="lineNum">   36452 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_NOWAIT))
<a name="36453"><span class="lineNum">   36453 </span>            : </a>
<span class="lineNum">   36454 </span><span class="lineNoCov">          0 : static tree</span>
<span class="lineNum">   36455 </span><span class="lineNoCov">          0 : cp_parser_omp_target_exit_data (cp_parser *parser, cp_token *pragma_tok,</span>
<span class="lineNum">   36456 </span><span class="lineNoCov">          0 :                                 enum pragma_context context)</span>
<span class="lineNum">   36457 </span>            : {
<span class="lineNum">   36458 </span>            :   bool data_seen = false;
<span class="lineNum">   36459 </span><span class="lineNoCov">          0 :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))</span>
<span class="lineNum">   36460 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   36461 </span>            :       tree id = cp_lexer_peek_token (parser-&gt;lexer)-&gt;u.value;
<span class="lineNum">   36462 </span><span class="lineCov">        220 :       const char *p = IDENTIFIER_POINTER (id);</span>
<span class="lineNum">   36463 </span>            : 
<span class="lineNum">   36464 </span>            :       if (strcmp (p, &quot;data&quot;) == 0)
<span class="lineNum">   36465 </span><span class="lineCov">         23 :         {</span>
<span class="lineNum">   36466 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   36467 </span><span class="lineNoCov">          0 :           data_seen = true;</span>
<span class="lineNum">   36468 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">   36469 </span>            :     }
<span class="lineNum">   36470 </span>            :   if (!data_seen)
<span class="lineNum">   36471 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   36472 </span>            :       cp_parser_error (parser, &quot;expected %&lt;data%&gt;&quot;);
<span class="lineNum">   36473 </span>            :       cp_parser_skip_to_pragma_eol (parser, pragma_tok);
<span class="lineNum">   36474 </span><span class="lineCov">         23 :       return NULL_TREE;</span>
<span class="lineNum">   36475 </span><span class="lineCov">         23 :     }</span>
<span class="lineNum">   36476 </span><span class="lineCov">         23 : </span>
<span class="lineNum">   36477 </span><span class="lineCov">         23 :   if (context == pragma_stmt)</span>
<span class="lineNum">   36478 </span><span class="lineCov">         23 :     {</span>
<span class="lineNum">   36479 </span>            :       error_at (pragma_tok-&gt;location,
<span class="lineNum">   36480 </span>            :                 &quot;%&lt;#pragma %s%&gt; may only be used in compound statements&quot;,
<span class="lineNum">   36481 </span>            :                 &quot;omp target exit data&quot;);
<span class="lineNum">   36482 </span>            :       cp_parser_skip_to_pragma_eol (parser, pragma_tok);
<span class="lineNum">   36483 </span>            :       return NULL_TREE;
<span class="lineNum">   36484 </span>            :     }
<span class="lineNum">   36485 </span>            : 
<span class="lineNum">   36486 </span>            :   tree clauses
<span class="lineNum">   36487 </span>            :     = cp_parser_omp_all_clauses (parser, OMP_TARGET_EXIT_DATA_CLAUSE_MASK,
<span class="lineNum">   36488 </span>            :                                  &quot;#pragma omp target exit data&quot;, pragma_tok);
<span class="lineNum">   36489 </span>            :   int map_seen = 0;
<span class="lineNum">   36490 </span>            :   for (tree *pc = &amp;clauses; *pc;)
<span class="lineNum">   36491 </span>            :     {
<span class="lineNum">   36492 </span>            :       if (OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_MAP)
<span class="lineNum">   36493 </span><span class="lineCov">         53 :         switch (OMP_CLAUSE_MAP_KIND (*pc))</span>
<span class="lineNum">   36494 </span>            :           {
<span class="lineNum">   36495 </span>            :           case GOMP_MAP_FROM:
<span class="lineNum">   36496 </span><span class="lineCov">         53 :           case GOMP_MAP_ALWAYS_FROM:</span>
<span class="lineNum">   36497 </span><span class="lineCov">         53 :           case GOMP_MAP_RELEASE:</span>
<span class="lineNum">   36498 </span>            :           case GOMP_MAP_DELETE:
<span class="lineNum">   36499 </span><span class="lineCov">        106 :             map_seen = 3;</span>
<span class="lineNum">   36500 </span><span class="lineCov">         53 :             break;</span>
<span class="lineNum">   36501 </span>            :           case GOMP_MAP_FIRSTPRIVATE_POINTER:
<span class="lineNum">   36502 </span><span class="lineCov">         53 :           case GOMP_MAP_FIRSTPRIVATE_REFERENCE:</span>
<span class="lineNum">   36503 </span>            :           case GOMP_MAP_ALWAYS_POINTER:
<span class="lineNum">   36504 </span><span class="lineCov">         53 :             break;</span>
<span class="lineNum">   36505 </span><span class="lineCov">         53 :           default:</span>
<span class="lineNum">   36506 </span>            :             map_seen |= 1;
<span class="lineNum">   36507 </span>            :             error_at (OMP_CLAUSE_LOCATION (*pc),
<span class="lineNum">   36508 </span><span class="lineCov">         53 :                       &quot;%&lt;#pragma omp target exit data%&gt; with map-type other &quot;</span>
<span class="lineNum">   36509 </span>            :                       &quot;than %&lt;from%&gt;, %&lt;release%&gt; or %&lt;delete%&gt; on %&lt;map%&gt;&quot;
<span class="lineNum">   36510 </span><span class="lineNoCov">          0 :                       &quot; clause&quot;);</span>
<span class="lineNum">   36511 </span><span class="lineNoCov">          0 :             *pc = OMP_CLAUSE_CHAIN (*pc);</span>
<span class="lineNum">   36512 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">   36513 </span>            :           }
<span class="lineNum">   36514 </span>            :       pc = &amp;OMP_CLAUSE_CHAIN (*pc);
<span class="lineNum">   36515 </span><span class="lineCov">         53 :     }</span>
<span class="lineNum">   36516 </span>            : 
<span class="lineNum">   36517 </span><span class="lineCov">         24 :   if (map_seen != 3)</span>
<span class="lineNum">   36518 </span>            :     {
<span class="lineNum">   36519 </span>            :       if (map_seen == 0)
<span class="lineNum">   36520 </span><span class="lineCov">         24 :         error_at (pragma_tok-&gt;location,</span>
<span class="lineNum">   36521 </span><span class="lineCov">         24 :                   &quot;%&lt;#pragma omp target exit data%&gt; must contain at least &quot;</span>
<span class="lineNum">   36522 </span>            :                   &quot;one %&lt;map%&gt; clause&quot;);
<span class="lineNum">   36523 </span>            :       return NULL_TREE;
<span class="lineNum">   36524 </span><span class="lineCov">         29 :     }</span>
<span class="lineNum">   36525 </span><span class="lineCov">        290 : </span>
<span class="lineNum">   36526 </span><span class="lineCov">         29 :   tree stmt = make_node (OMP_TARGET_EXIT_DATA);</span>
<span class="lineNum">   36527 </span><span class="lineCov">         29 :   TREE_TYPE (stmt) = void_type_node;</span>
<span class="lineNum">   36528 </span><span class="lineCov">        138 :   OMP_TARGET_EXIT_DATA_CLAUSES (stmt) = clauses;</span>
<span class="lineNum">   36529 </span>            :   SET_EXPR_LOCATION (stmt, pragma_tok-&gt;location);
<span class="lineNum">   36530 </span><span class="lineCov">        109 :   return add_stmt (stmt);</span>
<span class="lineNum">   36531 </span><span class="lineCov">        100 : }</span>
<span class="lineNum">   36532 </span>            : 
<span class="lineNum">   36533 </span><span class="lineCov">         74 : /* OpenMP 4.0:</span>
<span class="lineNum">   36534 </span><span class="lineCov">         74 :    # pragma omp target update target-update-clause[optseq] new-line */</span>
<span class="lineNum">   36535 </span><span class="lineCov">         74 : </span>
<span class="lineNum">   36536 </span><span class="lineCov">         74 : #define OMP_TARGET_UPDATE_CLAUSE_MASK                           \</span>
<span class="lineNum">   36537 </span><span class="lineCov">         74 :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_FROM)           \</span>
<span class="lineNum">   36538 </span><span class="lineCov">         74 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_TO)             \</span>
<span class="lineNum">   36539 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DEVICE) \
<span class="lineNum">   36540 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_IF)             \
<span class="lineNum">   36541 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DEPEND) \
<span class="lineNum">   36542 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_NOWAIT))
<a name="36543"><span class="lineNum">   36543 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   36544 </span><span class="lineNoCov">          0 : static bool</span>
<span class="lineNum">   36545 </span><span class="lineNoCov">          0 : cp_parser_omp_target_update (cp_parser *parser, cp_token *pragma_tok,</span>
<span class="lineNum">   36546 </span>            :                              enum pragma_context context)
<span class="lineNum">   36547 </span>            : {
<span class="lineNum">   36548 </span>            :   if (context == pragma_stmt)
<span class="lineNum">   36549 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   36550 </span><span class="lineNoCov">          0 :       error_at (pragma_tok-&gt;location,</span>
<span class="lineNum">   36551 </span>            :                 &quot;%&lt;#pragma %s%&gt; may only be used in compound statements&quot;,
<span class="lineNum">   36552 </span><span class="lineCov">        218 :                 &quot;omp target update&quot;);</span>
<span class="lineNum">   36553 </span>            :       cp_parser_skip_to_pragma_eol (parser, pragma_tok);
<span class="lineNum">   36554 </span>            :       return false;
<span class="lineNum">   36555 </span><span class="lineCov">         29 :     }</span>
<span class="lineNum">   36556 </span>            : 
<span class="lineNum">   36557 </span><span class="lineNoCov">          0 :   tree clauses</span>
<span class="lineNum">   36558 </span><span class="lineNoCov">          0 :     = cp_parser_omp_all_clauses (parser, OMP_TARGET_UPDATE_CLAUSE_MASK,</span>
<span class="lineNum">   36559 </span>            :                                  &quot;#pragma omp target update&quot;, pragma_tok);
<span class="lineNum">   36560 </span>            :   if (omp_find_clause (clauses, OMP_CLAUSE_TO) == NULL_TREE
<span class="lineNum">   36561 </span><span class="lineNoCov">          0 :       &amp;&amp; omp_find_clause (clauses, OMP_CLAUSE_FROM) == NULL_TREE)</span>
<span class="lineNum">   36562 </span>            :     {
<span class="lineNum">   36563 </span>            :       error_at (pragma_tok-&gt;location,
<span class="lineNum">   36564 </span><span class="lineCov">         29 :                 &quot;%&lt;#pragma omp target update%&gt; must contain at least one &quot;</span>
<span class="lineNum">   36565 </span><span class="lineCov">         29 :                 &quot;%&lt;from%&gt; or %&lt;to%&gt; clauses&quot;);</span>
<span class="lineNum">   36566 </span><span class="lineCov">         29 :       return false;</span>
<span class="lineNum">   36567 </span><span class="lineCov">         29 :     }</span>
<span class="lineNum">   36568 </span><span class="lineCov">         29 : </span>
<span class="lineNum">   36569 </span>            :   tree stmt = make_node (OMP_TARGET_UPDATE);
<span class="lineNum">   36570 </span>            :   TREE_TYPE (stmt) = void_type_node;
<span class="lineNum">   36571 </span>            :   OMP_TARGET_UPDATE_CLAUSES (stmt) = clauses;
<span class="lineNum">   36572 </span>            :   SET_EXPR_LOCATION (stmt, pragma_tok-&gt;location);
<span class="lineNum">   36573 </span>            :   add_stmt (stmt);
<span class="lineNum">   36574 </span>            :   return false;
<span class="lineNum">   36575 </span>            : }
<span class="lineNum">   36576 </span>            : 
<span class="lineNum">   36577 </span>            : /* OpenMP 4.0:
<span class="lineNum">   36578 </span>            :    # pragma omp target target-clause[optseq] new-line
<span class="lineNum">   36579 </span>            :      structured-block  */
<span class="lineNum">   36580 </span>            : 
<span class="lineNum">   36581 </span>            : #define OMP_TARGET_CLAUSE_MASK                                  \
<span class="lineNum">   36582 </span>            :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DEVICE) \
<span class="lineNum">   36583 </span><span class="lineCov">       1131 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_MAP)            \</span>
<span class="lineNum">   36584 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_IF)             \
<span class="lineNum">   36585 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DEPEND) \
<span class="lineNum">   36586 </span><span class="lineCov">       1131 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_NOWAIT) \</span>
<span class="lineNum">   36587 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_PRIVATE)        \
<span class="lineNum">   36588 </span><span class="lineCov">         24 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)   \</span>
<span class="lineNum">   36589 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DEFAULTMAP)     \
<span class="lineNum">   36590 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_IS_DEVICE_PTR))
<a name="36591"><span class="lineNum">   36591 </span><span class="lineCov">         24 : </span></a>
<span class="lineNum">   36592 </span><span class="lineCov">         24 : static bool</span>
<span class="lineNum">   36593 </span>            : cp_parser_omp_target (cp_parser *parser, cp_token *pragma_tok,
<span class="lineNum">   36594 </span>            :                       enum pragma_context context, bool *if_p)
<span class="lineNum">   36595 </span><span class="lineCov">       1107 : {</span>
<span class="lineNum">   36596 </span><span class="lineCov">      13284 :   tree *pc = NULL, stmt;</span>
<span class="lineNum">   36597 </span>            : 
<span class="lineNum">   36598 </span><span class="lineCov">       1107 :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))</span>
<span class="lineNum">   36599 </span><span class="lineCov">       1107 :     {</span>
<span class="lineNum">   36600 </span>            :       tree id = cp_lexer_peek_token (parser-&gt;lexer)-&gt;u.value;
<span class="lineNum">   36601 </span><span class="lineNoCov">          0 :       const char *p = IDENTIFIER_POINTER (id);</span>
<span class="lineNum">   36602 </span>            :       enum tree_code ccode = ERROR_MARK;
<span class="lineNum">   36603 </span>            : 
<span class="lineNum">   36604 </span><span class="lineNoCov">          0 :       if (strcmp (p, &quot;teams&quot;) == 0)</span>
<span class="lineNum">   36605 </span>            :         ccode = OMP_TEAMS;
<span class="lineNum">   36606 </span>            :       else if (strcmp (p, &quot;parallel&quot;) == 0)
<span class="lineNum">   36607 </span><span class="lineCov">       1107 :         ccode = OMP_PARALLEL;</span>
<span class="lineNum">   36608 </span><span class="lineCov">       1107 :       else if (strcmp (p, &quot;simd&quot;) == 0)</span>
<span class="lineNum">   36609 </span><span class="lineCov">       1107 :         ccode = OMP_SIMD;</span>
<span class="lineNum">   36610 </span><span class="lineCov">       1107 :       if (ccode != ERROR_MARK)</span>
<span class="lineNum">   36611 </span><span class="lineCov">       1107 :         {</span>
<span class="lineNum">   36612 </span><span class="lineCov">       1107 :           tree cclauses[C_OMP_CLAUSE_SPLIT_COUNT];</span>
<span class="lineNum">   36613 </span>            :           char p_name[sizeof (&quot;#pragma omp target teams distribute &quot;
<span class="lineNum">   36614 </span>            :                               &quot;parallel for simd&quot;)];
<span class="lineNum">   36615 </span>            : 
<span class="lineNum">   36616 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   36617 </span>            :           strcpy (p_name, &quot;#pragma omp target&quot;);
<span class="lineNum">   36618 </span>            :           if (!flag_openmp)  /* flag_openmp_simd  */
<span class="lineNum">   36619 </span>            :             {
<span class="lineNum">   36620 </span>            :               tree stmt;
<span class="lineNum">   36621 </span>            :               switch (ccode)
<span class="lineNum">   36622 </span>            :                 {
<span class="lineNum">   36623 </span>            :                 case OMP_TEAMS:
<span class="lineNum">   36624 </span>            :                   stmt = cp_parser_omp_teams (parser, pragma_tok, p_name,
<span class="lineNum">   36625 </span>            :                                               OMP_TARGET_CLAUSE_MASK,
<span class="lineNum">   36626 </span>            :                                               cclauses, if_p);
<span class="lineNum">   36627 </span>            :                   break;
<span class="lineNum">   36628 </span>            :                 case OMP_PARALLEL:
<span class="lineNum">   36629 </span>            :                   stmt = cp_parser_omp_parallel (parser, pragma_tok, p_name,
<span class="lineNum">   36630 </span>            :                                                  OMP_TARGET_CLAUSE_MASK,
<span class="lineNum">   36631 </span><span class="lineCov">       3271 :                                                  cclauses, if_p);</span>
<span class="lineNum">   36632 </span>            :                   break;
<span class="lineNum">   36633 </span>            :                 case OMP_SIMD:
<span class="lineNum">   36634 </span><span class="lineCov">       3271 :                   stmt = cp_parser_omp_simd (parser, pragma_tok, p_name,</span>
<span class="lineNum">   36635 </span>            :                                              OMP_TARGET_CLAUSE_MASK,
<span class="lineNum">   36636 </span><span class="lineCov">       3271 :                                              cclauses, if_p);</span>
<span class="lineNum">   36637 </span>            :                   break;
<span class="lineNum">   36638 </span><span class="lineCov">       5336 :                 default:</span>
<span class="lineNum">   36639 </span><span class="lineCov">       2668 :                   gcc_unreachable ();</span>
<span class="lineNum">   36640 </span><span class="lineCov">       2668 :                 }</span>
<span class="lineNum">   36641 </span>            :               return stmt != NULL_TREE;
<span class="lineNum">   36642 </span><span class="lineCov">       2668 :             }</span>
<span class="lineNum">   36643 </span>            :           keep_next_level (true);
<span class="lineNum">   36644 </span><span class="lineCov">       2076 :           tree sb = begin_omp_structured_block (), ret;</span>
<span class="lineNum">   36645 </span>            :           unsigned save = cp_parser_begin_omp_structured_block (parser);
<span class="lineNum">   36646 </span><span class="lineCov">       1902 :           switch (ccode)</span>
<span class="lineNum">   36647 </span>            :             {
<span class="lineNum">   36648 </span><span class="lineCov">       1866 :             case OMP_TEAMS:</span>
<span class="lineNum">   36649 </span>            :               ret = cp_parser_omp_teams (parser, pragma_tok, p_name,
<span class="lineNum">   36650 </span><span class="lineCov">        802 :                                          OMP_TARGET_CLAUSE_MASK, cclauses,</span>
<span class="lineNum">   36651 </span><span class="lineCov">        802 :                                          if_p);</span>
<span class="lineNum">   36652 </span>            :               break;
<span class="lineNum">   36653 </span>            :             case OMP_PARALLEL:
<span class="lineNum">   36654 </span><span class="lineCov">        802 :               ret = cp_parser_omp_parallel (parser, pragma_tok, p_name,</span>
<span class="lineNum">   36655 </span><span class="lineCov">        802 :                                             OMP_TARGET_CLAUSE_MASK, cclauses,</span>
<span class="lineNum">   36656 </span><span class="lineCov">        802 :                                             if_p);</span>
<span class="lineNum">   36657 </span>            :               break;
<span class="lineNum">   36658 </span><span class="lineCov">          6 :             case OMP_SIMD:</span>
<span class="lineNum">   36659 </span><span class="lineCov">          6 :               ret = cp_parser_omp_simd (parser, pragma_tok, p_name,</span>
<span class="lineNum">   36660 </span>            :                                         OMP_TARGET_CLAUSE_MASK, cclauses,
<span class="lineNum">   36661 </span><span class="lineCov">          6 :                                         if_p);</span>
<span class="lineNum">   36662 </span><span class="lineCov">         30 :               break;</span>
<span class="lineNum">   36663 </span><span class="lineCov">        102 :             default:</span>
<span class="lineNum">   36664 </span>            :               gcc_unreachable ();
<span class="lineNum">   36665 </span><span class="lineCov">          6 :             }</span>
<span class="lineNum">   36666 </span><span class="lineNoCov">          0 :           cp_parser_end_omp_structured_block (parser, save);</span>
<span class="lineNum">   36667 </span><span class="lineNoCov">          0 :           tree body = finish_omp_structured_block (sb);</span>
<span class="lineNum">   36668 </span><span class="lineNoCov">          0 :           if (ret == NULL_TREE)</span>
<span class="lineNum">   36669 </span>            :             return false;
<span class="lineNum">   36670 </span><span class="lineNoCov">          0 :           if (ccode == OMP_TEAMS &amp;&amp; !processing_template_decl)</span>
<span class="lineNum">   36671 </span><span class="lineNoCov">          0 :             {</span>
<span class="lineNum">   36672 </span><span class="lineNoCov">          0 :               /* For combined target teams, ensure the num_teams and</span>
<span class="lineNum">   36673 </span><span class="lineNoCov">          0 :                  thread_limit clause expressions are evaluated on the host,</span>
<span class="lineNum">   36674 </span>            :                  before entering the target construct.  */
<span class="lineNum">   36675 </span><span class="lineNoCov">          0 :               tree c;</span>
<span class="lineNum">   36676 </span><span class="lineNoCov">          0 :               for (c = cclauses[C_OMP_CLAUSE_SPLIT_TEAMS];</span>
<span class="lineNum">   36677 </span><span class="lineNoCov">          0 :                    c; c = OMP_CLAUSE_CHAIN (c))</span>
<span class="lineNum">   36678 </span>            :                 if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_NUM_TEAMS
<span class="lineNum">   36679 </span><span class="lineCov">          6 :                      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_THREAD_LIMIT)</span>
<span class="lineNum">   36680 </span>            :                     &amp;&amp; TREE_CODE (OMP_CLAUSE_OPERAND (c, 0)) != INTEGER_CST)
<span class="lineNum">   36681 </span><span class="lineCov">        796 :                   {</span>
<span class="lineNum">   36682 </span><span class="lineCov">        796 :                     tree expr = OMP_CLAUSE_OPERAND (c, 0);</span>
<span class="lineNum">   36683 </span><span class="lineCov">        796 :                     expr = force_target_expr (TREE_TYPE (expr), expr, tf_none);</span>
<span class="lineNum">   36684 </span><span class="lineCov">        796 :                     if (expr == error_mark_node)</span>
<span class="lineNum">   36685 </span>            :                       continue;
<span class="lineNum">   36686 </span><span class="lineCov">        586 :                     tree tmp = TARGET_EXPR_SLOT (expr);</span>
<span class="lineNum">   36687 </span><span class="lineCov">       2930 :                     add_stmt (expr);</span>
<span class="lineNum">   36688 </span><span class="lineCov">       9962 :                     OMP_CLAUSE_OPERAND (c, 0) = expr;</span>
<span class="lineNum">   36689 </span>            :                     tree tc = build_omp_clause (OMP_CLAUSE_LOCATION (c),
<span class="lineNum">   36690 </span><span class="lineCov">        586 :                                                 OMP_CLAUSE_FIRSTPRIVATE);</span>
<span class="lineNum">   36691 </span><span class="lineCov">        174 :                     OMP_CLAUSE_DECL (tc) = tmp;</span>
<span class="lineNum">   36692 </span><span class="lineCov">        870 :                     OMP_CLAUSE_CHAIN (tc)</span>
<span class="lineNum">   36693 </span><span class="lineCov">       2958 :                       = cclauses[C_OMP_CLAUSE_SPLIT_TARGET];</span>
<span class="lineNum">   36694 </span>            :                     cclauses[C_OMP_CLAUSE_SPLIT_TARGET] = tc;
<span class="lineNum">   36695 </span><span class="lineCov">        174 :                   }</span>
<span class="lineNum">   36696 </span><span class="lineCov">         36 :             }</span>
<span class="lineNum">   36697 </span><span class="lineCov">        180 :           tree stmt = make_node (OMP_TARGET);</span>
<span class="lineNum">   36698 </span><span class="lineCov">        612 :           TREE_TYPE (stmt) = void_type_node;</span>
<span class="lineNum">   36699 </span>            :           OMP_TARGET_CLAUSES (stmt) = cclauses[C_OMP_CLAUSE_SPLIT_TARGET];
<span class="lineNum">   36700 </span><span class="lineCov">         36 :           OMP_TARGET_BODY (stmt) = body;</span>
<span class="lineNum">   36701 </span><span class="lineNoCov">          0 :           OMP_TARGET_COMBINED (stmt) = 1;</span>
<span class="lineNum">   36702 </span><span class="lineNoCov">          0 :           SET_EXPR_LOCATION (stmt, pragma_tok-&gt;location);</span>
<span class="lineNum">   36703 </span>            :           add_stmt (stmt);
<span class="lineNum">   36704 </span><span class="lineCov">       1592 :           pc = &amp;OMP_TARGET_CLAUSES (stmt);</span>
<span class="lineNum">   36705 </span><span class="lineCov">        796 :           goto check_clauses;</span>
<span class="lineNum">   36706 </span><span class="lineCov">        796 :         }</span>
<span class="lineNum">   36707 </span>            :       else if (!flag_openmp)  /* flag_openmp_simd  */
<span class="lineNum">   36708 </span><span class="lineCov">        796 :         {</span>
<span class="lineNum">   36709 </span>            :           cp_parser_skip_to_pragma_eol (parser, pragma_tok);
<span class="lineNum">   36710 </span>            :           return false;
<span class="lineNum">   36711 </span>            :         }
<span class="lineNum">   36712 </span>            :       else if (strcmp (p, &quot;data&quot;) == 0)
<span class="lineNum">   36713 </span><span class="lineCov">        556 :         {</span>
<span class="lineNum">   36714 </span><span class="lineCov">        556 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   36715 </span><span class="lineCov">        990 :           cp_parser_omp_target_data (parser, pragma_tok, if_p);</span>
<span class="lineNum">   36716 </span><span class="lineCov">        434 :           return true;</span>
<span class="lineNum">   36717 </span><span class="lineCov">        706 :         }</span>
<span class="lineNum">   36718 </span><span class="lineCov">        515 :       else if (strcmp (p, &quot;enter&quot;) == 0)</span>
<span class="lineNum">   36719 </span>            :         {
<span class="lineNum">   36720 </span><span class="lineCov">        150 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   36721 </span><span class="lineCov">        150 :           cp_parser_omp_target_enter_data (parser, pragma_tok, context);</span>
<span class="lineNum">   36722 </span><span class="lineCov">        150 :           return false;</span>
<span class="lineNum">   36723 </span>            :         }
<span class="lineNum">   36724 </span><span class="lineCov">        150 :       else if (strcmp (p, &quot;exit&quot;) == 0)</span>
<span class="lineNum">   36725 </span><span class="lineCov">        150 :         {</span>
<span class="lineNum">   36726 </span><span class="lineCov">        150 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   36727 </span><span class="lineCov">        150 :           cp_parser_omp_target_exit_data (parser, pragma_tok, context);</span>
<span class="lineNum">   36728 </span><span class="lineCov">        150 :           return false;</span>
<span class="lineNum">   36729 </span><span class="lineCov">        150 :         }</span>
<span class="lineNum">   36730 </span><span class="lineCov">        150 :       else if (strcmp (p, &quot;update&quot;) == 0)</span>
<span class="lineNum">   36731 </span><span class="lineCov">        150 :         {</span>
<span class="lineNum">   36732 </span><span class="lineCov">        150 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   36733 </span>            :           return cp_parser_omp_target_update (parser, pragma_tok, context);
<span class="lineNum">   36734 </span>            :         }
<span class="lineNum">   36735 </span><span class="lineCov">        796 :     }</span>
<span class="lineNum">   36736 </span><span class="lineCov">        796 :   if (!flag_openmp)  /* flag_openmp_simd  */</span>
<span class="lineNum">   36737 </span><span class="lineCov">        796 :     {</span>
<span class="lineNum">   36738 </span><span class="lineCov">        796 :       cp_parser_skip_to_pragma_eol (parser, pragma_tok);</span>
<span class="lineNum">   36739 </span><span class="lineCov">        796 :       return false;</span>
<span class="lineNum">   36740 </span><span class="lineCov">        796 :     }</span>
<span class="lineNum">   36741 </span><span class="lineCov">        796 : </span>
<span class="lineNum">   36742 </span><span class="lineCov">        796 :   stmt = make_node (OMP_TARGET);</span>
<span class="lineNum">   36743 </span><span class="lineCov">        796 :   TREE_TYPE (stmt) = void_type_node;</span>
<span class="lineNum">   36744 </span>            : 
<span class="lineNum">   36745 </span><span class="lineCov">       1866 :   OMP_TARGET_CLAUSES (stmt)</span>
<span class="lineNum">   36746 </span>            :     = cp_parser_omp_all_clauses (parser, OMP_TARGET_CLAUSE_MASK,
<span class="lineNum">   36747 </span><span class="lineNoCov">          0 :                                  &quot;#pragma omp target&quot;, pragma_tok);</span>
<span class="lineNum">   36748 </span><span class="lineNoCov">          0 :   pc = &amp;OMP_TARGET_CLAUSES (stmt);</span>
<span class="lineNum">   36749 </span>            :   keep_next_level (true);
<span class="lineNum">   36750 </span><span class="lineCov">       1866 :   OMP_TARGET_BODY (stmt) = cp_parser_omp_structured_block (parser, if_p);</span>
<span class="lineNum">   36751 </span>            : 
<span class="lineNum">   36752 </span><span class="lineCov">        127 :   SET_EXPR_LOCATION (stmt, pragma_tok-&gt;location);</span>
<span class="lineNum">   36753 </span><span class="lineCov">        127 :   add_stmt (stmt);</span>
<span class="lineNum">   36754 </span><span class="lineCov">        127 : </span>
<span class="lineNum">   36755 </span>            : check_clauses:
<span class="lineNum">   36756 </span><span class="lineCov">       1739 :   while (*pc)</span>
<span class="lineNum">   36757 </span>            :     {
<span class="lineNum">   36758 </span><span class="lineCov">         47 :       if (OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_MAP)</span>
<span class="lineNum">   36759 </span><span class="lineCov">         47 :         switch (OMP_CLAUSE_MAP_KIND (*pc))</span>
<span class="lineNum">   36760 </span><span class="lineCov">         47 :           {</span>
<span class="lineNum">   36761 </span>            :           case GOMP_MAP_TO:
<span class="lineNum">   36762 </span><span class="lineCov">       1692 :           case GOMP_MAP_ALWAYS_TO:</span>
<span class="lineNum">   36763 </span>            :           case GOMP_MAP_FROM:
<span class="lineNum">   36764 </span><span class="lineCov">         53 :           case GOMP_MAP_ALWAYS_FROM:</span>
<span class="lineNum">   36765 </span><span class="lineCov">         53 :           case GOMP_MAP_TOFROM:</span>
<span class="lineNum">   36766 </span><span class="lineCov">         53 :           case GOMP_MAP_ALWAYS_TOFROM:</span>
<span class="lineNum">   36767 </span>            :           case GOMP_MAP_ALLOC:
<span class="lineNum">   36768 </span><span class="lineCov">       1639 :           case GOMP_MAP_FIRSTPRIVATE_POINTER:</span>
<span class="lineNum">   36769 </span>            :           case GOMP_MAP_FIRSTPRIVATE_REFERENCE:
<span class="lineNum">   36770 </span><span class="lineCov">       1131 :           case GOMP_MAP_ALWAYS_POINTER:</span>
<span class="lineNum">   36771 </span><span class="lineCov">       1131 :             break;</span>
<span class="lineNum">   36772 </span>            :           default:
<span class="lineNum">   36773 </span>            :             error_at (OMP_CLAUSE_LOCATION (*pc),
<span class="lineNum">   36774 </span><span class="lineCov">       1111 :                       &quot;%&lt;#pragma omp target%&gt; with map-type other &quot;</span>
<span class="lineNum">   36775 </span>            :                       &quot;than %&lt;to%&gt;, %&lt;from%&gt;, %&lt;tofrom%&gt; or %&lt;alloc%&gt; &quot;
<span class="lineNum">   36776 </span><span class="lineCov">          3 :                       &quot;on %&lt;map%&gt; clause&quot;);</span>
<span class="lineNum">   36777 </span><span class="lineCov">          3 :             *pc = OMP_CLAUSE_CHAIN (*pc);</span>
<span class="lineNum">   36778 </span>            :             continue;
<span class="lineNum">   36779 </span>            :           }
<span class="lineNum">   36780 </span><span class="lineCov">       1108 :       pc = &amp;OMP_CLAUSE_CHAIN (*pc);</span>
<span class="lineNum">   36781 </span><span class="lineCov">       1108 :     }</span>
<span class="lineNum">   36782 </span>            :   return true;
<span class="lineNum">   36783 </span><span class="lineCov">       1108 : }</span>
<span class="lineNum">   36784 </span><span class="lineCov">      21052 : </span>
<span class="lineNum">   36785 </span>            : /* OpenACC 2.0:
<span class="lineNum">   36786 </span><span class="lineCov">       1108 :    # pragma acc cache (variable-list) new-line</span>
<span class="lineNum">   36787 </span><span class="lineCov">       1108 : */</span>
<a name="36788"><span class="lineNum">   36788 </span><span class="lineCov">       1108 : </span></a>
<span class="lineNum">   36789 </span>            : static tree
<span class="lineNum">   36790 </span><span class="lineCov">       1108 : cp_parser_oacc_cache (cp_parser *parser, cp_token *pragma_tok)</span>
<span class="lineNum">   36791 </span><span class="lineCov">       1108 : {</span>
<span class="lineNum">   36792 </span>            :   tree stmt, clauses;
<span class="lineNum">   36793 </span><span class="lineCov">       3714 : </span>
<span class="lineNum">   36794 </span><span class="lineCov">       3714 :   clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE__CACHE_, NULL_TREE);</span>
<span class="lineNum">   36795 </span>            :   clauses = finish_omp_clauses (clauses, C_ORT_ACC);
<span class="lineNum">   36796 </span><span class="lineCov">       1810 : </span>
<span class="lineNum">   36797 </span><span class="lineCov">       1146 :   cp_parser_require_pragma_eol (parser, cp_lexer_peek_token (parser-&gt;lexer));</span>
<span class="lineNum">   36798 </span>            : 
<span class="lineNum">   36799 </span>            :   stmt = make_node (OACC_CACHE);
<span class="lineNum">   36800 </span>            :   TREE_TYPE (stmt) = void_type_node;
<span class="lineNum">   36801 </span>            :   OACC_CACHE_CLAUSES (stmt) = clauses;
<span class="lineNum">   36802 </span>            :   SET_EXPR_LOCATION (stmt, pragma_tok-&gt;location);
<span class="lineNum">   36803 </span>            :   add_stmt (stmt);
<span class="lineNum">   36804 </span>            : 
<span class="lineNum">   36805 </span>            :   return stmt;
<span class="lineNum">   36806 </span>            : }
<span class="lineNum">   36807 </span>            : 
<span class="lineNum">   36808 </span>            : /* OpenACC 2.0:
<span class="lineNum">   36809 </span>            :    # pragma acc data oacc-data-clause[optseq] new-line
<span class="lineNum">   36810 </span><span class="lineNoCov">          0 :      structured-block  */</span>
<span class="lineNum">   36811 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   36812 </span>            : #define OACC_DATA_CLAUSE_MASK                                           \
<span class="lineNum">   36813 </span>            :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_COPY)          \
<span class="lineNum">   36814 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_COPYIN)                \
<span class="lineNum">   36815 </span><span class="lineNoCov">          0 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_COPYOUT)               \</span>
<span class="lineNum">   36816 </span><span class="lineNoCov">          0 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_CREATE)                \</span>
<span class="lineNum">   36817 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_DEVICEPTR)             \
<span class="lineNum">   36818 </span><span class="lineCov">       3620 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_IF)                    \</span>
<span class="lineNum">   36819 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_PRESENT) )
<a name="36820"><span class="lineNum">   36820 </span>            : </a>
<span class="lineNum">   36821 </span>            : static tree
<span class="lineNum">   36822 </span>            : cp_parser_oacc_data (cp_parser *parser, cp_token *pragma_tok, bool *if_p)
<span class="lineNum">   36823 </span>            : {
<span class="lineNum">   36824 </span>            :   tree stmt, clauses, block;
<span class="lineNum">   36825 </span>            :   unsigned int save;
<span class="lineNum">   36826 </span>            : 
<span class="lineNum">   36827 </span>            :   clauses = cp_parser_oacc_all_clauses (parser, OACC_DATA_CLAUSE_MASK,
<span class="lineNum">   36828 </span><span class="lineCov">        144 :                                         &quot;#pragma acc data&quot;, pragma_tok);</span>
<span class="lineNum">   36829 </span>            : 
<span class="lineNum">   36830 </span><span class="lineCov">        144 :   block = begin_omp_parallel ();</span>
<span class="lineNum">   36831 </span>            :   save = cp_parser_begin_omp_structured_block (parser);
<span class="lineNum">   36832 </span><span class="lineCov">        144 :   cp_parser_statement (parser, NULL_TREE, false, if_p);</span>
<span class="lineNum">   36833 </span><span class="lineCov">        144 :   cp_parser_end_omp_structured_block (parser, save);</span>
<span class="lineNum">   36834 </span>            :   stmt = finish_oacc_data (clauses, block);
<span class="lineNum">   36835 </span><span class="lineCov">        144 :   return stmt;</span>
<span class="lineNum">   36836 </span>            : }
<span class="lineNum">   36837 </span><span class="lineCov">        144 : </span>
<span class="lineNum">   36838 </span><span class="lineCov">        144 : /* OpenACC 2.0:</span>
<span class="lineNum">   36839 </span><span class="lineCov">        144 :   # pragma acc host_data &lt;clauses&gt; new-line</span>
<span class="lineNum">   36840 </span><span class="lineCov">        144 :   structured-block  */</span>
<span class="lineNum">   36841 </span><span class="lineCov">        144 : </span>
<span class="lineNum">   36842 </span>            : #define OACC_HOST_DATA_CLAUSE_MASK                                      \
<span class="lineNum">   36843 </span><span class="lineCov">        144 :   ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_USE_DEVICE) )</span>
<a name="36844"><span class="lineNum">   36844 </span>            : </a>
<span class="lineNum">   36845 </span>            : static tree
<span class="lineNum">   36846 </span>            : cp_parser_oacc_host_data (cp_parser *parser, cp_token *pragma_tok, bool *if_p)
<span class="lineNum">   36847 </span>            : {
<span class="lineNum">   36848 </span>            :   tree stmt, clauses, block;
<span class="lineNum">   36849 </span>            :   unsigned int save;
<span class="lineNum">   36850 </span>            : 
<span class="lineNum">   36851 </span>            :   clauses = cp_parser_oacc_all_clauses (parser, OACC_HOST_DATA_CLAUSE_MASK,
<span class="lineNum">   36852 </span>            :                                         &quot;#pragma acc host_data&quot;, pragma_tok);
<span class="lineNum">   36853 </span>            : 
<span class="lineNum">   36854 </span>            :   block = begin_omp_parallel ();
<span class="lineNum">   36855 </span>            :   save = cp_parser_begin_omp_structured_block (parser);
<span class="lineNum">   36856 </span>            :   cp_parser_statement (parser, NULL_TREE, false, if_p);
<span class="lineNum">   36857 </span>            :   cp_parser_end_omp_structured_block (parser, save);
<span class="lineNum">   36858 </span>            :   stmt = finish_oacc_host_data (clauses, block);
<span class="lineNum">   36859 </span>            :   return stmt;
<span class="lineNum">   36860 </span><span class="lineCov">        455 : }</span>
<span class="lineNum">   36861 </span>            : 
<span class="lineNum">   36862 </span><span class="lineCov">        455 : /* OpenACC 2.0:</span>
<span class="lineNum">   36863 </span><span class="lineCov">        455 :    # pragma acc declare oacc-data-clause[optseq] new-line</span>
<span class="lineNum">   36864 </span>            : */
<span class="lineNum">   36865 </span><span class="lineCov">       6370 : </span>
<span class="lineNum">   36866 </span>            : #define OACC_DECLARE_CLAUSE_MASK                                        \
<span class="lineNum">   36867 </span>            :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_COPY)          \
<span class="lineNum">   36868 </span><span class="lineCov">        455 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_COPYIN)                \</span>
<span class="lineNum">   36869 </span><span class="lineCov">        455 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_COPYOUT)               \</span>
<span class="lineNum">   36870 </span><span class="lineCov">        455 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_CREATE)                \</span>
<span class="lineNum">   36871 </span><span class="lineCov">        910 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_DEVICEPTR)             \</span>
<span class="lineNum">   36872 </span><span class="lineCov">        455 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_DEVICE_RESIDENT)       \</span>
<span class="lineNum">   36873 </span><span class="lineCov">        455 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_LINK)          \</span>
<span class="lineNum">   36874 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_PRESENT) )
<a name="36875"><span class="lineNum">   36875 </span>            : </a>
<span class="lineNum">   36876 </span>            : static tree
<span class="lineNum">   36877 </span>            : cp_parser_oacc_declare (cp_parser *parser, cp_token *pragma_tok)
<span class="lineNum">   36878 </span>            : {
<span class="lineNum">   36879 </span>            :   tree clauses, stmt;
<span class="lineNum">   36880 </span>            :   bool error = false;
<span class="lineNum">   36881 </span>            : 
<span class="lineNum">   36882 </span>            :   clauses = cp_parser_oacc_all_clauses (parser, OACC_DECLARE_CLAUSE_MASK,
<span class="lineNum">   36883 </span>            :                                         &quot;#pragma acc declare&quot;, pragma_tok, true);
<span class="lineNum">   36884 </span><span class="lineCov">         36 : </span>
<span class="lineNum">   36885 </span>            : 
<span class="lineNum">   36886 </span><span class="lineCov">         36 :   if (omp_find_clause (clauses, OMP_CLAUSE_MAP) == NULL_TREE)</span>
<span class="lineNum">   36887 </span><span class="lineCov">         36 :     {</span>
<span class="lineNum">   36888 </span>            :       error_at (pragma_tok-&gt;location,
<span class="lineNum">   36889 </span><span class="lineCov">        108 :                 &quot;no valid clauses specified in %&lt;#pragma acc declare%&gt;&quot;);</span>
<span class="lineNum">   36890 </span>            :       return NULL_TREE;
<span class="lineNum">   36891 </span>            :     }
<span class="lineNum">   36892 </span><span class="lineCov">         36 : </span>
<span class="lineNum">   36893 </span><span class="lineCov">         36 :   for (tree t = clauses; t; t = OMP_CLAUSE_CHAIN (t))</span>
<span class="lineNum">   36894 </span><span class="lineCov">         36 :     {</span>
<span class="lineNum">   36895 </span><span class="lineCov">         72 :       location_t loc = OMP_CLAUSE_LOCATION (t);</span>
<span class="lineNum">   36896 </span><span class="lineCov">         36 :       tree decl = OMP_CLAUSE_DECL (t);</span>
<span class="lineNum">   36897 </span><span class="lineCov">         36 :       if (!DECL_P (decl))</span>
<span class="lineNum">   36898 </span>            :         {
<span class="lineNum">   36899 </span>            :           error_at (loc, &quot;array section in %&lt;#pragma acc declare%&gt;&quot;);
<span class="lineNum">   36900 </span>            :           error = true;
<span class="lineNum">   36901 </span>            :           continue;
<span class="lineNum">   36902 </span>            :         }
<span class="lineNum">   36903 </span>            :       gcc_assert (OMP_CLAUSE_CODE (t) == OMP_CLAUSE_MAP);
<span class="lineNum">   36904 </span>            :       switch (OMP_CLAUSE_MAP_KIND (t))
<span class="lineNum">   36905 </span>            :         {
<span class="lineNum">   36906 </span>            :         case GOMP_MAP_FIRSTPRIVATE_POINTER:
<span class="lineNum">   36907 </span>            :         case GOMP_MAP_ALLOC:
<span class="lineNum">   36908 </span>            :         case GOMP_MAP_TO:
<span class="lineNum">   36909 </span>            :         case GOMP_MAP_FORCE_DEVICEPTR:
<span class="lineNum">   36910 </span>            :         case GOMP_MAP_DEVICE_RESIDENT:
<span class="lineNum">   36911 </span>            :           break;
<span class="lineNum">   36912 </span>            : 
<span class="lineNum">   36913 </span>            :         case GOMP_MAP_LINK:
<span class="lineNum">   36914 </span>            :           if (!global_bindings_p ()
<span class="lineNum">   36915 </span><span class="lineCov">        198 :               &amp;&amp; (TREE_STATIC (decl)</span>
<span class="lineNum">   36916 </span>            :                || !DECL_EXTERNAL (decl)))
<span class="lineNum">   36917 </span><span class="lineCov">        198 :             {</span>
<span class="lineNum">   36918 </span><span class="lineCov">        198 :               error_at (loc,</span>
<span class="lineNum">   36919 </span>            :                         &quot;%qD must be a global variable in &quot;
<span class="lineNum">   36920 </span><span class="lineCov">       3168 :                         &quot;%&lt;#pragma acc declare link%&gt;&quot;,</span>
<span class="lineNum">   36921 </span>            :                         decl);
<span class="lineNum">   36922 </span>            :               error = true;
<span class="lineNum">   36923 </span>            :               continue;
<span class="lineNum">   36924 </span><span class="lineCov">        198 :             }</span>
<span class="lineNum">   36925 </span>            :           break;
<span class="lineNum">   36926 </span><span class="lineCov">          6 : </span>
<span class="lineNum">   36927 </span>            :         default:
<span class="lineNum">   36928 </span><span class="lineCov">          6 :           if (global_bindings_p ())</span>
<span class="lineNum">   36929 </span>            :             {
<span class="lineNum">   36930 </span>            :               error_at (loc, &quot;invalid OpenACC clause at file scope&quot;);
<span class="lineNum">   36931 </span><span class="lineCov">        402 :               error = true;</span>
<span class="lineNum">   36932 </span>            :               continue;
<span class="lineNum">   36933 </span><span class="lineCov">        210 :             }</span>
<span class="lineNum">   36934 </span><span class="lineCov">        420 :           if (DECL_EXTERNAL (decl))</span>
<span class="lineNum">   36935 </span><span class="lineCov">        210 :             {</span>
<span class="lineNum">   36936 </span>            :               error_at (loc,
<span class="lineNum">   36937 </span><span class="lineCov">          3 :                         &quot;invalid use of %&lt;extern%&gt; variable %qD &quot;</span>
<span class="lineNum">   36938 </span><span class="lineCov">          3 :                         &quot;in %&lt;#pragma acc declare%&gt;&quot;, decl);</span>
<span class="lineNum">   36939 </span><span class="lineCov">          3 :               error = true;</span>
<span class="lineNum">   36940 </span>            :               continue;
<span class="lineNum">   36941 </span><span class="lineCov">        414 :             }</span>
<span class="lineNum">   36942 </span><span class="lineCov">        207 :           else if (TREE_PUBLIC (decl))</span>
<span class="lineNum">   36943 </span>            :             {
<span class="lineNum">   36944 </span>            :               error_at (loc,
<span class="lineNum">   36945 </span>            :                         &quot;invalid use of %&lt;global%&gt; variable %qD &quot;
<span class="lineNum">   36946 </span>            :                         &quot;in %&lt;#pragma acc declare%&gt;&quot;, decl);
<span class="lineNum">   36947 </span>            :               error = true;
<span class="lineNum">   36948 </span>            :               continue;
<span class="lineNum">   36949 </span>            :             }
<span class="lineNum">   36950 </span>            :           break;
<span class="lineNum">   36951 </span><span class="lineCov">         27 :         }</span>
<span class="lineNum">   36952 </span><span class="lineCov">         27 : </span>
<span class="lineNum">   36953 </span><span class="lineCov">         27 :       if (lookup_attribute (&quot;omp declare target&quot;, DECL_ATTRIBUTES (decl))</span>
<span class="lineNum">   36954 </span><span class="lineCov">          6 :           || lookup_attribute (&quot;omp declare target link&quot;,</span>
<span class="lineNum">   36955 </span>            :                                DECL_ATTRIBUTES (decl)))
<span class="lineNum">   36956 </span><span class="lineCov">          3 :         {</span>
<span class="lineNum">   36957 </span>            :           error_at (loc, &quot;variable %qD used more than once with &quot;
<span class="lineNum">   36958 </span>            :                     &quot;%&lt;#pragma acc declare%&gt;&quot;, decl);
<span class="lineNum">   36959 </span>            :           error = true;
<span class="lineNum">   36960 </span><span class="lineCov">          3 :           continue;</span>
<span class="lineNum">   36961 </span><span class="lineCov">          3 :         }</span>
<span class="lineNum">   36962 </span>            : 
<span class="lineNum">   36963 </span>            :       if (!error)
<span class="lineNum">   36964 </span>            :         {
<span class="lineNum">   36965 </span><span class="lineCov">         51 :           tree id;</span>
<span class="lineNum">   36966 </span><span class="lineCov">         51 : </span>
<span class="lineNum">   36967 </span>            :           if (OMP_CLAUSE_MAP_KIND (t) == GOMP_MAP_LINK)
<span class="lineNum">   36968 </span><span class="lineCov">         15 :             id = get_identifier (&quot;omp declare target link&quot;);</span>
<span class="lineNum">   36969 </span><span class="lineCov">         15 :           else</span>
<span class="lineNum">   36970 </span><span class="lineCov">         15 :             id = get_identifier (&quot;omp declare target&quot;);</span>
<span class="lineNum">   36971 </span>            : 
<span class="lineNum">   36972 </span><span class="lineCov">         36 :           DECL_ATTRIBUTES (decl)</span>
<span class="lineNum">   36973 </span>            :             = tree_cons (id, NULL_TREE, DECL_ATTRIBUTES (decl));
<span class="lineNum">   36974 </span><span class="lineCov">         15 :           if (global_bindings_p ())</span>
<span class="lineNum">   36975 </span>            :             {
<span class="lineNum">   36976 </span>            :               symtab_node *node = symtab_node::get (decl);
<span class="lineNum">   36977 </span><span class="lineCov">         15 :               if (node != NULL)</span>
<span class="lineNum">   36978 </span><span class="lineCov">         15 :                 {</span>
<span class="lineNum">   36979 </span>            :                   node-&gt;offloadable = 1;
<span class="lineNum">   36980 </span><span class="lineCov">         21 :                   if (ENABLE_OFFLOADING)</span>
<span class="lineNum">   36981 </span>            :                     {
<span class="lineNum">   36982 </span><span class="lineCov">          3 :                       g-&gt;have_offload = true;</span>
<span class="lineNum">   36983 </span>            :                       if (is_a &lt;varpool_node *&gt; (node))
<span class="lineNum">   36984 </span>            :                         vec_safe_push (offload_vars, decl);
<span class="lineNum">   36985 </span><span class="lineCov">          3 :                     }</span>
<span class="lineNum">   36986 </span><span class="lineCov">          3 :                 }</span>
<span class="lineNum">   36987 </span>            :             }
<span class="lineNum">   36988 </span>            :         }
<span class="lineNum">   36989 </span>            :     }
<span class="lineNum">   36990 </span>            : 
<span class="lineNum">   36991 </span><span class="lineCov">        171 :   if (error || global_bindings_p ())</span>
<span class="lineNum">   36992 </span><span class="lineCov">        336 :     return NULL_TREE;</span>
<span class="lineNum">   36993 </span><span class="lineCov">        165 : </span>
<span class="lineNum">   36994 </span>            :   stmt = make_node (OACC_DECLARE);
<span class="lineNum">   36995 </span><span class="lineCov">          9 :   TREE_TYPE (stmt) = void_type_node;</span>
<span class="lineNum">   36996 </span>            :   OACC_DECLARE_CLAUSES (stmt) = clauses;
<span class="lineNum">   36997 </span><span class="lineCov">          9 :   SET_EXPR_LOCATION (stmt, pragma_tok-&gt;location);</span>
<span class="lineNum">   36998 </span><span class="lineCov">          9 : </span>
<span class="lineNum">   36999 </span>            :   add_stmt (stmt);
<span class="lineNum">   37000 </span>            : 
<span class="lineNum">   37001 </span><span class="lineCov">        162 :   return NULL_TREE;</span>
<span class="lineNum">   37002 </span>            : }
<span class="lineNum">   37003 </span><span class="lineCov">        159 : </span>
<span class="lineNum">   37004 </span>            : /* OpenACC 2.0:
<span class="lineNum">   37005 </span><span class="lineCov">        159 :    # pragma acc enter data oacc-enter-data-clause[optseq] new-line</span>
<span class="lineNum">   37006 </span><span class="lineCov">         18 : </span>
<span class="lineNum">   37007 </span>            :    or
<span class="lineNum">   37008 </span><span class="lineCov">        141 : </span>
<span class="lineNum">   37009 </span>            :    # pragma acc exit data oacc-exit-data-clause[optseq] new-line
<span class="lineNum">   37010 </span><span class="lineCov">        477 : </span>
<span class="lineNum">   37011 </span><span class="lineCov">        159 :    LOC is the location of the #pragma token.</span>
<span class="lineNum">   37012 </span><span class="lineCov">        159 : */</span>
<span class="lineNum">   37013 </span>            : 
<span class="lineNum">   37014 </span><span class="lineCov">         89 : #define OACC_ENTER_DATA_CLAUSE_MASK                                     \</span>
<span class="lineNum">   37015 </span><span class="lineCov">         89 :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_IF)                    \</span>
<span class="lineNum">   37016 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_ASYNC)         \
<span class="lineNum">   37017 </span><span class="lineCov">         65 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_COPYIN)                \</span>
<span class="lineNum">   37018 </span><span class="lineCov">         65 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_CREATE)                \</span>
<span class="lineNum">   37019 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_WAIT) )
<span class="lineNum">   37020 </span>            : 
<span class="lineNum">   37021 </span>            : #define OACC_EXIT_DATA_CLAUSE_MASK                                      \
<span class="lineNum">   37022 </span>            :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_IF)                    \
<span class="lineNum">   37023 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_ASYNC)         \
<span class="lineNum">   37024 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_COPYOUT)               \
<span class="lineNum">   37025 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_DELETE)                \
<span class="lineNum">   37026 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_FINALIZE)              \
<span class="lineNum">   37027 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_WAIT) )
<a name="37028"><span class="lineNum">   37028 </span>            : </a>
<span class="lineNum">   37029 </span><span class="lineCov">        192 : static tree</span>
<span class="lineNum">   37030 </span><span class="lineCov">        122 : cp_parser_oacc_enter_exit_data (cp_parser *parser, cp_token *pragma_tok,</span>
<span class="lineNum">   37031 </span>            :                                 bool enter)
<span class="lineNum">   37032 </span><span class="lineCov">         70 : {</span>
<span class="lineNum">   37033 </span><span class="lineCov">         70 :   location_t loc = pragma_tok-&gt;location;</span>
<span class="lineNum">   37034 </span><span class="lineCov">         70 :   tree stmt, clauses;</span>
<span class="lineNum">   37035 </span><span class="lineCov">         70 :   const char *p = &quot;&quot;;</span>
<span class="lineNum">   37036 </span>            : 
<span class="lineNum">   37037 </span><span class="lineCov">         70 :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))</span>
<span class="lineNum">   37038 </span>            :     p = IDENTIFIER_POINTER (cp_lexer_peek_token (parser-&gt;lexer)-&gt;u.value);
<span class="lineNum">   37039 </span><span class="lineCov">         70 : </span>
<span class="lineNum">   37040 </span>            :   if (strcmp (p, &quot;data&quot;) != 0)
<span class="lineNum">   37041 </span>            :     {
<span class="lineNum">   37042 </span>            :       error_at (loc, &quot;expected %&lt;data%&gt; after %&lt;#pragma acc %s%&gt;&quot;,
<span class="lineNum">   37043 </span>            :                 enter ? &quot;enter&quot; : &quot;exit&quot;);
<span class="lineNum">   37044 </span>            :       cp_parser_skip_to_pragma_eol (parser, pragma_tok);
<span class="lineNum">   37045 </span>            :       return NULL_TREE;
<span class="lineNum">   37046 </span>            :     }
<span class="lineNum">   37047 </span>            : 
<span class="lineNum">   37048 </span>            :   cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   37049 </span>            : 
<span class="lineNum">   37050 </span>            :   if (enter)
<span class="lineNum">   37051 </span>            :     clauses = cp_parser_oacc_all_clauses (parser, OACC_ENTER_DATA_CLAUSE_MASK,
<span class="lineNum">   37052 </span>            :                                          &quot;#pragma acc enter data&quot;, pragma_tok);
<span class="lineNum">   37053 </span>            :   else
<span class="lineNum">   37054 </span>            :     clauses = cp_parser_oacc_all_clauses (parser, OACC_EXIT_DATA_CLAUSE_MASK,
<span class="lineNum">   37055 </span>            :                                          &quot;#pragma acc exit data&quot;, pragma_tok);
<span class="lineNum">   37056 </span>            : 
<span class="lineNum">   37057 </span>            :   if (omp_find_clause (clauses, OMP_CLAUSE_MAP) == NULL_TREE)
<span class="lineNum">   37058 </span>            :     {
<span class="lineNum">   37059 </span>            :       error_at (loc, &quot;%&lt;#pragma acc %s data%&gt; has no data movement clause&quot;,
<span class="lineNum">   37060 </span>            :                 enter ? &quot;enter&quot; : &quot;exit&quot;);
<span class="lineNum">   37061 </span>            :       return NULL_TREE;
<span class="lineNum">   37062 </span>            :     }
<span class="lineNum">   37063 </span>            : 
<span class="lineNum">   37064 </span>            :   stmt = enter ? make_node (OACC_ENTER_DATA) : make_node (OACC_EXIT_DATA);
<span class="lineNum">   37065 </span>            :   TREE_TYPE (stmt) = void_type_node;
<span class="lineNum">   37066 </span>            :   OMP_STANDALONE_CLAUSES (stmt) = clauses;
<span class="lineNum">   37067 </span>            :   SET_EXPR_LOCATION (stmt, pragma_tok-&gt;location);
<span class="lineNum">   37068 </span><span class="lineCov">        359 :   add_stmt (stmt);</span>
<span class="lineNum">   37069 </span>            :   return stmt;
<span class="lineNum">   37070 </span>            : }
<span class="lineNum">   37071 </span><span class="lineCov">        359 : </span>
<span class="lineNum">   37072 </span><span class="lineCov">        359 : /* OpenACC 2.0:</span>
<span class="lineNum">   37073 </span><span class="lineCov">        359 :    # pragma acc loop oacc-loop-clause[optseq] new-line</span>
<span class="lineNum">   37074 </span>            :      structured-block  */
<span class="lineNum">   37075 </span><span class="lineCov">        359 : </span>
<span class="lineNum">   37076 </span><span class="lineCov">        338 : #define OACC_LOOP_CLAUSE_MASK                                           \</span>
<span class="lineNum">   37077 </span>            :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_COLLAPSE)              \
<span class="lineNum">   37078 </span><span class="lineCov">        359 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_PRIVATE)               \</span>
<span class="lineNum">   37079 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_REDUCTION)             \
<span class="lineNum">   37080 </span><span class="lineCov">         60 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_GANG)          \</span>
<span class="lineNum">   37081 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_VECTOR)                \
<span class="lineNum">   37082 </span><span class="lineCov">         42 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_WORKER)                \</span>
<span class="lineNum">   37083 </span><span class="lineCov">         42 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_AUTO)          \</span>
<span class="lineNum">   37084 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_INDEPENDENT)           \
<span class="lineNum">   37085 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_SEQ)                   \
<span class="lineNum">   37086 </span><span class="lineCov">        317 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_TILE))</span>
<a name="37087"><span class="lineNum">   37087 </span>            : </a>
<span class="lineNum">   37088 </span><span class="lineCov">        317 : static tree</span>
<span class="lineNum">   37089 </span><span class="lineCov">       1760 : cp_parser_oacc_loop (cp_parser *parser, cp_token *pragma_tok, char *p_name,</span>
<span class="lineNum">   37090 </span>            :                      omp_clause_mask mask, tree *cclauses, bool *if_p)
<span class="lineNum">   37091 </span>            : {
<span class="lineNum">   37092 </span><span class="lineCov">       2041 :   bool is_parallel = ((mask &gt;&gt; PRAGMA_OACC_CLAUSE_REDUCTION) &amp; 1) == 1;</span>
<span class="lineNum">   37093 </span>            : 
<span class="lineNum">   37094 </span>            :   strcat (p_name, &quot; loop&quot;);
<span class="lineNum">   37095 </span><span class="lineCov">        317 :   mask |= OACC_LOOP_CLAUSE_MASK;</span>
<span class="lineNum">   37096 </span>            : 
<span class="lineNum">   37097 </span><span class="lineCov">         27 :   tree clauses = cp_parser_oacc_all_clauses (parser, mask, p_name, pragma_tok,</span>
<span class="lineNum">   37098 </span>            :                                              cclauses == NULL);
<span class="lineNum">   37099 </span><span class="lineCov">         27 :   if (cclauses)</span>
<span class="lineNum">   37100 </span>            :     {
<span class="lineNum">   37101 </span>            :       clauses = c_oacc_split_loop_clauses (clauses, cclauses, is_parallel);
<span class="lineNum">   37102 </span><span class="lineCov">        290 :       if (*cclauses)</span>
<span class="lineNum">   37103 </span><span class="lineCov">        290 :         *cclauses = finish_omp_clauses (*cclauses, C_ORT_ACC);</span>
<span class="lineNum">   37104 </span><span class="lineCov">        580 :       if (clauses)</span>
<span class="lineNum">   37105 </span><span class="lineCov">        290 :         clauses = finish_omp_clauses (clauses, C_ORT_ACC);</span>
<span class="lineNum">   37106 </span><span class="lineCov">        290 :     }</span>
<span class="lineNum">   37107 </span><span class="lineCov">        290 : </span>
<span class="lineNum">   37108 </span>            :   tree block = begin_omp_structured_block ();
<span class="lineNum">   37109 </span>            :   int save = cp_parser_begin_omp_structured_block (parser);
<span class="lineNum">   37110 </span>            :   tree stmt = cp_parser_omp_for_loop (parser, OACC_LOOP, clauses, NULL, if_p);
<span class="lineNum">   37111 </span>            :   cp_parser_end_omp_structured_block (parser, save);
<span class="lineNum">   37112 </span>            :   add_stmt (finish_omp_structured_block (block));
<span class="lineNum">   37113 </span>            : 
<span class="lineNum">   37114 </span>            :   return stmt;
<span class="lineNum">   37115 </span>            : }
<span class="lineNum">   37116 </span>            : 
<span class="lineNum">   37117 </span>            : /* OpenACC 2.0:
<span class="lineNum">   37118 </span>            :    # pragma acc kernels oacc-kernels-clause[optseq] new-line
<span class="lineNum">   37119 </span>            :      structured-block
<span class="lineNum">   37120 </span>            : 
<span class="lineNum">   37121 </span>            :    or
<span class="lineNum">   37122 </span>            : 
<span class="lineNum">   37123 </span>            :    # pragma acc parallel oacc-parallel-clause[optseq] new-line
<span class="lineNum">   37124 </span>            :      structured-block
<span class="lineNum">   37125 </span>            : */
<span class="lineNum">   37126 </span>            : 
<span class="lineNum">   37127 </span><span class="lineCov">       2498 : #define OACC_KERNELS_CLAUSE_MASK                                        \</span>
<span class="lineNum">   37128 </span>            :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_ASYNC)         \
<span class="lineNum">   37129 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_COPY)          \
<span class="lineNum">   37130 </span><span class="lineCov">       7494 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_COPYIN)                \</span>
<span class="lineNum">   37131 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_COPYOUT)               \
<span class="lineNum">   37132 </span><span class="lineCov">       2498 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_CREATE)                \</span>
<span class="lineNum">   37133 </span><span class="lineCov">      59952 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_DEFAULT)               \</span>
<span class="lineNum">   37134 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_DEVICEPTR)             \
<span class="lineNum">   37135 </span><span class="lineCov">       2498 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_IF)                    \</span>
<span class="lineNum">   37136 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_NUM_GANGS)             \
<span class="lineNum">   37137 </span><span class="lineCov">       2498 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_NUM_WORKERS)           \</span>
<span class="lineNum">   37138 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_PRESENT)               \
<span class="lineNum">   37139 </span><span class="lineCov">        766 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_VECTOR_LENGTH) \</span>
<span class="lineNum">   37140 </span><span class="lineCov">        766 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_WAIT) )</span>
<span class="lineNum">   37141 </span><span class="lineCov">        159 : </span>
<span class="lineNum">   37142 </span><span class="lineCov">        766 : #define OACC_PARALLEL_CLAUSE_MASK                                       \</span>
<span class="lineNum">   37143 </span><span class="lineCov">        471 :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_ASYNC)         \</span>
<span class="lineNum">   37144 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_COPY)          \
<span class="lineNum">   37145 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_COPYIN)                \
<span class="lineNum">   37146 </span><span class="lineCov">       2498 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_COPYOUT)               \</span>
<span class="lineNum">   37147 </span><span class="lineCov">       2498 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_CREATE)                \</span>
<span class="lineNum">   37148 </span><span class="lineCov">       2498 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_DEFAULT)               \</span>
<span class="lineNum">   37149 </span><span class="lineCov">       4996 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_DEVICEPTR)             \</span>
<span class="lineNum">   37150 </span><span class="lineCov">       2498 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_FIRSTPRIVATE)          \</span>
<span class="lineNum">   37151 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_IF)                    \
<span class="lineNum">   37152 </span><span class="lineCov">       2498 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_NUM_GANGS)             \</span>
<span class="lineNum">   37153 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_NUM_WORKERS)           \
<span class="lineNum">   37154 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_PRESENT)               \
<span class="lineNum">   37155 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_PRIVATE)               \
<span class="lineNum">   37156 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_REDUCTION)             \
<span class="lineNum">   37157 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_VECTOR_LENGTH)       \
<span class="lineNum">   37158 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_WAIT) )
<a name="37159"><span class="lineNum">   37159 </span>            : </a>
<span class="lineNum">   37160 </span>            : static tree
<span class="lineNum">   37161 </span>            : cp_parser_oacc_kernels_parallel (cp_parser *parser, cp_token *pragma_tok,
<span class="lineNum">   37162 </span>            :                                  char *p_name, bool *if_p)
<span class="lineNum">   37163 </span>            : {
<span class="lineNum">   37164 </span>            :   omp_clause_mask mask;
<span class="lineNum">   37165 </span>            :   enum tree_code code;
<span class="lineNum">   37166 </span>            :   switch (cp_parser_pragma_kind (pragma_tok))
<span class="lineNum">   37167 </span>            :     {
<span class="lineNum">   37168 </span>            :     case PRAGMA_OACC_KERNELS:
<span class="lineNum">   37169 </span>            :       strcat (p_name, &quot; kernels&quot;);
<span class="lineNum">   37170 </span>            :       mask = OACC_KERNELS_CLAUSE_MASK;
<span class="lineNum">   37171 </span>            :       code = OACC_KERNELS;
<span class="lineNum">   37172 </span>            :       break;
<span class="lineNum">   37173 </span>            :     case PRAGMA_OACC_PARALLEL:
<span class="lineNum">   37174 </span>            :       strcat (p_name, &quot; parallel&quot;);
<span class="lineNum">   37175 </span>            :       mask = OACC_PARALLEL_CLAUSE_MASK;
<span class="lineNum">   37176 </span>            :       code = OACC_PARALLEL;
<span class="lineNum">   37177 </span>            :       break;
<span class="lineNum">   37178 </span>            :     default:
<span class="lineNum">   37179 </span>            :       gcc_unreachable ();
<span class="lineNum">   37180 </span>            :     }
<span class="lineNum">   37181 </span>            : 
<span class="lineNum">   37182 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))
<span class="lineNum">   37183 </span>            :     {
<span class="lineNum">   37184 </span>            :       const char *p
<span class="lineNum">   37185 </span>            :         = IDENTIFIER_POINTER (cp_lexer_peek_token (parser-&gt;lexer)-&gt;u.value);
<span class="lineNum">   37186 </span>            :       if (strcmp (p, &quot;loop&quot;) == 0)
<span class="lineNum">   37187 </span>            :         {
<span class="lineNum">   37188 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   37189 </span>            :           tree block = begin_omp_parallel ();
<span class="lineNum">   37190 </span>            :           tree clauses;
<span class="lineNum">   37191 </span>            :           cp_parser_oacc_loop (parser, pragma_tok, p_name, mask, &amp;clauses,
<span class="lineNum">   37192 </span>            :                                if_p);
<span class="lineNum">   37193 </span>            :           return finish_omp_construct (code, block, clauses);
<span class="lineNum">   37194 </span>            :         }
<span class="lineNum">   37195 </span>            :     }
<span class="lineNum">   37196 </span>            : 
<span class="lineNum">   37197 </span>            :   tree clauses = cp_parser_oacc_all_clauses (parser, mask, p_name, pragma_tok);
<span class="lineNum">   37198 </span>            : 
<span class="lineNum">   37199 </span><span class="lineCov">       2664 :   tree block = begin_omp_parallel ();</span>
<span class="lineNum">   37200 </span>            :   unsigned int save = cp_parser_begin_omp_structured_block (parser);
<span class="lineNum">   37201 </span>            :   cp_parser_statement (parser, NULL_TREE, false, if_p);
<span class="lineNum">   37202 </span><span class="lineCov">       2664 :   cp_parser_end_omp_structured_block (parser, save);</span>
<span class="lineNum">   37203 </span><span class="lineCov">       2664 :   return finish_omp_construct (code, block, clauses);</span>
<span class="lineNum">   37204 </span><span class="lineCov">       2664 : }</span>
<span class="lineNum">   37205 </span>            : 
<span class="lineNum">   37206 </span><span class="lineCov">        994 : /* OpenACC 2.0:</span>
<span class="lineNum">   37207 </span><span class="lineCov">        994 :    # pragma acc update oacc-update-clause[optseq] new-line</span>
<span class="lineNum">   37208 </span><span class="lineCov">      26838 : */</span>
<span class="lineNum">   37209 </span><span class="lineCov">        994 : </span>
<span class="lineNum">   37210 </span><span class="lineCov">        994 : #define OACC_UPDATE_CLAUSE_MASK                                         \</span>
<span class="lineNum">   37211 </span><span class="lineCov">       1670 :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_ASYNC)         \</span>
<span class="lineNum">   37212 </span><span class="lineCov">       1670 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_DEVICE)                \</span>
<span class="lineNum">   37213 </span><span class="lineCov">      55110 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_HOST)          \</span>
<span class="lineNum">   37214 </span><span class="lineCov">       1670 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_IF)                    \</span>
<span class="lineNum">   37215 </span><span class="lineCov">       1670 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_IF_PRESENT)            \</span>
<span class="lineNum">   37216 </span><span class="lineNoCov">          0 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_WAIT))</span>
<a name="37217"><span class="lineNum">   37217 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   37218 </span>            : static tree
<span class="lineNum">   37219 </span>            : cp_parser_oacc_update (cp_parser *parser, cp_token *pragma_tok)
<span class="lineNum">   37220 </span><span class="lineCov">       2664 : {</span>
<span class="lineNum">   37221 </span>            :   tree stmt, clauses;
<span class="lineNum">   37222 </span><span class="lineCov">       1954 : </span>
<span class="lineNum">   37223 </span><span class="lineCov">       1954 :   clauses = cp_parser_oacc_all_clauses (parser, OACC_UPDATE_CLAUSE_MASK,</span>
<span class="lineNum">   37224 </span><span class="lineCov">       1954 :                                          &quot;#pragma acc update&quot;, pragma_tok);</span>
<span class="lineNum">   37225 </span>            : 
<span class="lineNum">   37226 </span><span class="lineCov">        766 :   if (omp_find_clause (clauses, OMP_CLAUSE_MAP) == NULL_TREE)</span>
<span class="lineNum">   37227 </span><span class="lineCov">        766 :     {</span>
<span class="lineNum">   37228 </span><span class="lineCov">        766 :       error_at (pragma_tok-&gt;location,</span>
<span class="lineNum">   37229 </span><span class="lineCov">        766 :                 &quot;%&lt;#pragma acc update%&gt; must contain at least one &quot;</span>
<span class="lineNum">   37230 </span>            :                 &quot;%&lt;device%&gt; or %&lt;host%&gt; or %&lt;self%&gt; clause&quot;);
<span class="lineNum">   37231 </span><span class="lineCov">        766 :       return NULL_TREE;</span>
<span class="lineNum">   37232 </span>            :     }
<span class="lineNum">   37233 </span>            : 
<span class="lineNum">   37234 </span>            :   stmt = make_node (OACC_UPDATE);
<span class="lineNum">   37235 </span><span class="lineCov">       1898 :   TREE_TYPE (stmt) = void_type_node;</span>
<span class="lineNum">   37236 </span>            :   OACC_UPDATE_CLAUSES (stmt) = clauses;
<span class="lineNum">   37237 </span><span class="lineCov">       1898 :   SET_EXPR_LOCATION (stmt, pragma_tok-&gt;location);</span>
<span class="lineNum">   37238 </span><span class="lineCov">       1898 :   add_stmt (stmt);</span>
<span class="lineNum">   37239 </span><span class="lineCov">       1898 :   return stmt;</span>
<span class="lineNum">   37240 </span><span class="lineCov">       3796 : }</span>
<span class="lineNum">   37241 </span><span class="lineCov">       1898 : </span>
<span class="lineNum">   37242 </span>            : /* OpenACC 2.0:
<span class="lineNum">   37243 </span>            :    # pragma acc wait [(intseq)] oacc-wait-clause[optseq] new-line
<span class="lineNum">   37244 </span>            : 
<span class="lineNum">   37245 </span>            :    LOC is the location of the #pragma token.
<span class="lineNum">   37246 </span>            : */
<span class="lineNum">   37247 </span>            : 
<span class="lineNum">   37248 </span>            : #define OACC_WAIT_CLAUSE_MASK                                   \
<span class="lineNum">   37249 </span>            :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_ASYNC))
<a name="37250"><span class="lineNum">   37250 </span>            : </a>
<span class="lineNum">   37251 </span>            : static tree
<span class="lineNum">   37252 </span>            : cp_parser_oacc_wait (cp_parser *parser, cp_token *pragma_tok)
<span class="lineNum">   37253 </span>            : {
<span class="lineNum">   37254 </span>            :   tree clauses, list = NULL_TREE, stmt = NULL_TREE;
<span class="lineNum">   37255 </span>            :   location_t loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">   37256 </span>            : 
<span class="lineNum">   37257 </span><span class="lineCov">        150 :   if (cp_lexer_peek_token (parser-&gt;lexer)-&gt;type == CPP_OPEN_PAREN)</span>
<span class="lineNum">   37258 </span>            :     list = cp_parser_oacc_wait_list (parser, loc, list);
<span class="lineNum">   37259 </span><span class="lineCov">        150 : </span>
<span class="lineNum">   37260 </span>            :   clauses = cp_parser_oacc_all_clauses (parser, OACC_WAIT_CLAUSE_MASK,
<span class="lineNum">   37261 </span><span class="lineCov">       2100 :                                         &quot;#pragma acc wait&quot;, pragma_tok);</span>
<span class="lineNum">   37262 </span>            : 
<span class="lineNum">   37263 </span>            :   stmt = c_finish_oacc_wait (loc, list, clauses);
<span class="lineNum">   37264 </span><span class="lineCov">        150 :   stmt = finish_expr_stmt (stmt);</span>
<span class="lineNum">   37265 </span>            : 
<span class="lineNum">   37266 </span><span class="lineCov">          3 :   return stmt;</span>
<span class="lineNum">   37267 </span>            : }
<span class="lineNum">   37268 </span>            : 
<span class="lineNum">   37269 </span><span class="lineCov">          3 : /* OpenMP 4.0:</span>
<span class="lineNum">   37270 </span>            :    # pragma omp declare simd declare-simd-clauses[optseq] new-line  */
<span class="lineNum">   37271 </span>            : 
<span class="lineNum">   37272 </span><span class="lineCov">        147 : #define OMP_DECLARE_SIMD_CLAUSE_MASK                            \</span>
<span class="lineNum">   37273 </span><span class="lineCov">        147 :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_SIMDLEN)        \</span>
<span class="lineNum">   37274 </span><span class="lineCov">        147 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_LINEAR) \</span>
<span class="lineNum">   37275 </span><span class="lineCov">        147 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_ALIGNED)        \</span>
<span class="lineNum">   37276 </span><span class="lineCov">        147 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_UNIFORM)        \</span>
<span class="lineNum">   37277 </span><span class="lineCov">        147 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_INBRANCH)       \</span>
<span class="lineNum">   37278 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_NOTINBRANCH))
<a name="37279"><span class="lineNum">   37279 </span>            : </a>
<span class="lineNum">   37280 </span>            : static void
<span class="lineNum">   37281 </span>            : cp_parser_omp_declare_simd (cp_parser *parser, cp_token *pragma_tok,
<span class="lineNum">   37282 </span>            :                             enum pragma_context context)
<span class="lineNum">   37283 </span>            : {
<span class="lineNum">   37284 </span>            :   bool first_p = parser-&gt;omp_declare_simd == NULL;
<span class="lineNum">   37285 </span>            :   cp_omp_declare_simd_data data;
<span class="lineNum">   37286 </span>            :   if (first_p)
<span class="lineNum">   37287 </span>            :     {
<span class="lineNum">   37288 </span>            :       data.error_seen = false;
<span class="lineNum">   37289 </span>            :       data.fndecl_seen = false;
<span class="lineNum">   37290 </span><span class="lineCov">        116 :       data.tokens = vNULL;</span>
<span class="lineNum">   37291 </span>            :       data.clauses = NULL_TREE;
<span class="lineNum">   37292 </span><span class="lineCov">        116 :       /* It is safe to take the address of a local variable; it will only be</span>
<span class="lineNum">   37293 </span><span class="lineCov">        232 :          used while this scope is live.  */</span>
<span class="lineNum">   37294 </span>            :       parser-&gt;omp_declare_simd = &amp;data;
<span class="lineNum">   37295 </span><span class="lineCov">        116 :     }</span>
<span class="lineNum">   37296 </span><span class="lineCov">         61 : </span>
<span class="lineNum">   37297 </span>            :   /* Store away all pragma tokens.  */
<span class="lineNum">   37298 </span><span class="lineCov">        232 :   while (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_PRAGMA_EOL)</span>
<span class="lineNum">   37299 </span>            :          &amp;&amp; cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_EOF))
<span class="lineNum">   37300 </span>            :     cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   37301 </span><span class="lineCov">        116 :   if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_PRAGMA_EOL))</span>
<span class="lineNum">   37302 </span><span class="lineCov">        116 :     parser-&gt;omp_declare_simd-&gt;error_seen = true;</span>
<span class="lineNum">   37303 </span>            :   cp_parser_require_pragma_eol (parser, pragma_tok);
<span class="lineNum">   37304 </span><span class="lineCov">        116 :   struct cp_token_cache *cp</span>
<span class="lineNum">   37305 </span>            :     = cp_token_cache_new (pragma_tok, cp_lexer_peek_token (parser-&gt;lexer));
<span class="lineNum">   37306 </span>            :   parser-&gt;omp_declare_simd-&gt;tokens.safe_push (cp);
<span class="lineNum">   37307 </span>            : 
<span class="lineNum">   37308 </span>            :   if (first_p)
<span class="lineNum">   37309 </span>            :     {
<span class="lineNum">   37310 </span>            :       while (cp_lexer_next_token_is (parser-&gt;lexer, CPP_PRAGMA))
<span class="lineNum">   37311 </span>            :         cp_parser_pragma (parser, context, NULL);
<span class="lineNum">   37312 </span>            :       switch (context)
<span class="lineNum">   37313 </span>            :         {
<span class="lineNum">   37314 </span>            :         case pragma_external:
<span class="lineNum">   37315 </span>            :           cp_parser_declaration (parser);
<span class="lineNum">   37316 </span>            :           break;
<span class="lineNum">   37317 </span>            :         case pragma_member:
<span class="lineNum">   37318 </span>            :           cp_parser_member_declaration (parser);
<span class="lineNum">   37319 </span><span class="lineCov">        560 :           break;</span>
<span class="lineNum">   37320 </span>            :         case pragma_objc_icode:
<span class="lineNum">   37321 </span>            :           cp_parser_block_declaration (parser, /*statement_p=*/false);
<span class="lineNum">   37322 </span><span class="lineCov">        560 :           break;</span>
<span class="lineNum">   37323 </span><span class="lineCov">        560 :         default:</span>
<span class="lineNum">   37324 </span><span class="lineCov">        560 :           cp_parser_declaration_statement (parser);</span>
<span class="lineNum">   37325 </span>            :           break;
<span class="lineNum">   37326 </span><span class="lineCov">        530 :         }</span>
<span class="lineNum">   37327 </span><span class="lineCov">        530 :       if (parser-&gt;omp_declare_simd</span>
<span class="lineNum">   37328 </span><span class="lineCov">        530 :           &amp;&amp; !parser-&gt;omp_declare_simd-&gt;error_seen</span>
<span class="lineNum">   37329 </span><span class="lineCov">        530 :           &amp;&amp; !parser-&gt;omp_declare_simd-&gt;fndecl_seen)</span>
<span class="lineNum">   37330 </span>            :         error_at (pragma_tok-&gt;location,
<span class="lineNum">   37331 </span>            :                   &quot;%&lt;#pragma omp declare simd%&gt; not immediately followed by &quot;
<span class="lineNum">   37332 </span><span class="lineCov">        530 :                   &quot;function declaration or definition&quot;);</span>
<span class="lineNum">   37333 </span>            :       data.tokens.release ();
<span class="lineNum">   37334 </span>            :       parser-&gt;omp_declare_simd = NULL;
<span class="lineNum">   37335 </span>            :     }
<span class="lineNum">   37336 </span><span class="lineCov">       6407 : }</span>
<span class="lineNum">   37337 </span><span class="lineCov">       6967 : </span>
<span class="lineNum">   37338 </span><span class="lineCov">       6407 : /* Finalize #pragma omp declare simd clauses after direct declarator has</span>
<span class="lineNum">   37339 </span><span class="lineCov">        560 :    been parsed, and put that into &quot;omp declare simd&quot; attribute.  */</span>
<a name="37340"><span class="lineNum">   37340 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   37341 </span><span class="lineCov">        560 : static tree</span>
<span class="lineNum">   37342 </span><span class="lineCov">        560 : cp_parser_late_parsing_omp_declare_simd (cp_parser *parser, tree attrs)</span>
<span class="lineNum">   37343 </span><span class="lineCov">        560 : {</span>
<span class="lineNum">   37344 </span><span class="lineCov">        560 :   struct cp_token_cache *ce;</span>
<span class="lineNum">   37345 </span>            :   cp_omp_declare_simd_data *data = parser-&gt;omp_declare_simd;
<span class="lineNum">   37346 </span><span class="lineCov">        560 :   int i;</span>
<span class="lineNum">   37347 </span>            : 
<span class="lineNum">   37348 </span><span class="lineCov">        563 :   if (!data-&gt;error_seen &amp;&amp; data-&gt;fndecl_seen)</span>
<span class="lineNum">   37349 </span><span class="lineCov">         33 :     {</span>
<span class="lineNum">   37350 </span><span class="lineCov">        530 :       error (&quot;%&lt;#pragma omp declare simd%&gt; not immediately followed by &quot;</span>
<span class="lineNum">   37351 </span>            :              &quot;a single function declaration or definition&quot;);
<span class="lineNum">   37352 </span><span class="lineCov">        383 :       data-&gt;error_seen = true;</span>
<span class="lineNum">   37353 </span><span class="lineCov">        383 :     }</span>
<span class="lineNum">   37354 </span><span class="lineCov">        383 :   if (data-&gt;error_seen)</span>
<span class="lineNum">   37355 </span><span class="lineCov">        132 :     return attrs;</span>
<span class="lineNum">   37356 </span><span class="lineCov">        132 : </span>
<span class="lineNum">   37357 </span><span class="lineCov">        132 :   FOR_EACH_VEC_ELT (data-&gt;tokens, i, ce)</span>
<span class="lineNum">   37358 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   37359 </span><span class="lineNoCov">          0 :       tree c, cl;</span>
<span class="lineNum">   37360 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   37361 </span><span class="lineCov">         15 :       cp_parser_push_lexer_for_tokens (parser, ce);</span>
<span class="lineNum">   37362 </span><span class="lineCov">         15 :       parser-&gt;lexer-&gt;in_pragma = true;</span>
<span class="lineNum">   37363 </span><span class="lineCov">         15 :       gcc_assert (cp_lexer_peek_token (parser-&gt;lexer)-&gt;type == CPP_PRAGMA);</span>
<span class="lineNum">   37364 </span>            :       cp_token *pragma_tok = cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   37365 </span><span class="lineCov">        530 :       cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   37366 </span><span class="lineCov">        348 :       cl = cp_parser_omp_all_clauses (parser, OMP_DECLARE_SIMD_CLAUSE_MASK,</span>
<span class="lineNum">   37367 </span><span class="lineCov">        345 :                                       &quot;#pragma omp declare simd&quot;, pragma_tok);</span>
<span class="lineNum">   37368 </span><span class="lineCov">          3 :       cp_parser_pop_lexer (parser);</span>
<span class="lineNum">   37369 </span>            :       if (cl)
<span class="lineNum">   37370 </span>            :         cl = tree_cons (NULL_TREE, cl, NULL_TREE);
<span class="lineNum">   37371 </span><span class="lineCov">        530 :       c = build_tree_list (get_identifier (&quot;omp declare simd&quot;), cl);</span>
<span class="lineNum">   37372 </span><span class="lineCov">        530 :       TREE_CHAIN (c) = attrs;</span>
<span class="lineNum">   37373 </span>            :       if (processing_template_decl)
<span class="lineNum">   37374 </span><span class="lineCov">        560 :         ATTR_IS_DEPENDENT (c) = 1;</span>
<span class="lineNum">   37375 </span>            :       attrs = c;
<span class="lineNum">   37376 </span>            :     }
<span class="lineNum">   37377 </span>            : 
<span class="lineNum">   37378 </span>            :   data-&gt;fndecl_seen = true;
<span class="lineNum">   37379 </span>            :   return attrs;
<span class="lineNum">   37380 </span><span class="lineCov">        509 : }</span>
<span class="lineNum">   37381 </span>            : 
<span class="lineNum">   37382 </span><span class="lineCov">        509 : </span>
<span class="lineNum">   37383 </span><span class="lineCov">        509 : /* OpenMP 4.0:</span>
<span class="lineNum">   37384 </span><span class="lineCov">        509 :    # pragma omp declare target new-line</span>
<span class="lineNum">   37385 </span>            :    declarations and definitions
<span class="lineNum">   37386 </span><span class="lineCov">        509 :    # pragma omp end declare target new-line</span>
<span class="lineNum">   37387 </span>            : 
<span class="lineNum">   37388 </span><span class="lineCov">          3 :    OpenMP 4.5:</span>
<span class="lineNum">   37389 </span>            :    # pragma omp declare target ( extended-list ) new-line
<span class="lineNum">   37390 </span><span class="lineCov">          3 : </span>
<span class="lineNum">   37391 </span>            :    # pragma omp declare target declare-target-clauses[seq] new-line  */
<span class="lineNum">   37392 </span><span class="lineCov">        509 : </span>
<span class="lineNum">   37393 </span>            : #define OMP_DECLARE_TARGET_CLAUSE_MASK                          \
<span class="lineNum">   37394 </span>            :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_TO)             \
<span class="lineNum">   37395 </span><span class="lineCov">       1039 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_LINK))</span>
<a name="37396"><span class="lineNum">   37396 </span>            : </a>
<span class="lineNum">   37397 </span><span class="lineCov">        533 : static void</span>
<span class="lineNum">   37398 </span>            : cp_parser_omp_declare_target (cp_parser *parser, cp_token *pragma_tok)
<span class="lineNum">   37399 </span><span class="lineCov">        533 : {</span>
<span class="lineNum">   37400 </span><span class="lineCov">        533 :   tree clauses = NULL_TREE;</span>
<span class="lineNum">   37401 </span><span class="lineCov">        533 :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))</span>
<span class="lineNum">   37402 </span><span class="lineCov">        533 :     clauses</span>
<span class="lineNum">   37403 </span><span class="lineCov">        533 :       = cp_parser_omp_all_clauses (parser, OMP_DECLARE_TARGET_CLAUSE_MASK,</span>
<span class="lineNum">   37404 </span><span class="lineCov">       6396 :                                    &quot;#pragma omp declare target&quot;, pragma_tok);</span>
<span class="lineNum">   37405 </span>            :   else if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_PAREN))
<span class="lineNum">   37406 </span><span class="lineCov">        533 :     {</span>
<span class="lineNum">   37407 </span><span class="lineCov">        533 :       clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_TO_DECLARE,</span>
<span class="lineNum">   37408 </span><span class="lineCov">        446 :                                         clauses);</span>
<span class="lineNum">   37409 </span><span class="lineCov">        533 :       clauses = finish_omp_clauses (clauses, C_ORT_OMP);</span>
<span class="lineNum">   37410 </span><span class="lineCov">        533 :       cp_parser_require_pragma_eol (parser, pragma_tok);</span>
<span class="lineNum">   37411 </span><span class="lineCov">        533 :     }</span>
<span class="lineNum">   37412 </span><span class="lineCov">        129 :   else</span>
<span class="lineNum">   37413 </span><span class="lineCov">        533 :     {</span>
<span class="lineNum">   37414 </span>            :       cp_parser_require_pragma_eol (parser, pragma_tok);
<span class="lineNum">   37415 </span>            :       scope_chain-&gt;omp_declare_target_attribute++;
<span class="lineNum">   37416 </span><span class="lineCov">        506 :       return;</span>
<span class="lineNum">   37417 </span><span class="lineCov">        506 :     }</span>
<span class="lineNum">   37418 </span>            :   if (scope_chain-&gt;omp_declare_target_attribute)
<span class="lineNum">   37419 </span>            :     error_at (pragma_tok-&gt;location,
<span class="lineNum">   37420 </span>            :               &quot;%&lt;#pragma omp declare target%&gt; with clauses in between &quot;
<span class="lineNum">   37421 </span>            :               &quot;%&lt;#pragma omp declare target%&gt; without clauses and &quot;
<span class="lineNum">   37422 </span>            :               &quot;%&lt;#pragma omp end declare target%&gt;&quot;);
<span class="lineNum">   37423 </span>            :   for (tree c = clauses; c; c = OMP_CLAUSE_CHAIN (c))
<span class="lineNum">   37424 </span>            :     {
<span class="lineNum">   37425 </span>            :       tree t = OMP_CLAUSE_DECL (c), id;
<span class="lineNum">   37426 </span>            :       tree at1 = lookup_attribute (&quot;omp declare target&quot;, DECL_ATTRIBUTES (t));
<span class="lineNum">   37427 </span>            :       tree at2 = lookup_attribute (&quot;omp declare target link&quot;,
<span class="lineNum">   37428 </span>            :                                    DECL_ATTRIBUTES (t));
<span class="lineNum">   37429 </span>            :       if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LINK)
<span class="lineNum">   37430 </span>            :         {
<span class="lineNum">   37431 </span>            :           id = get_identifier (&quot;omp declare target link&quot;);
<span class="lineNum">   37432 </span>            :           std::swap (at1, at2);
<span class="lineNum">   37433 </span>            :         }
<span class="lineNum">   37434 </span>            :       else
<span class="lineNum">   37435 </span>            :         id = get_identifier (&quot;omp declare target&quot;);
<span class="lineNum">   37436 </span><span class="lineCov">        183 :       if (at2)</span>
<span class="lineNum">   37437 </span>            :         {
<span class="lineNum">   37438 </span><span class="lineCov">        183 :           error_at (OMP_CLAUSE_LOCATION (c),</span>
<span class="lineNum">   37439 </span><span class="lineCov">        183 :                     &quot;%qD specified both in declare target %&lt;link%&gt; and %&lt;to%&gt;&quot;</span>
<span class="lineNum">   37440 </span><span class="lineCov">         97 :                     &quot; clauses&quot;, t);</span>
<span class="lineNum">   37441 </span><span class="lineCov">        388 :           continue;</span>
<span class="lineNum">   37442 </span>            :         }
<span class="lineNum">   37443 </span><span class="lineCov">         86 :       if (!at1)</span>
<span class="lineNum">   37444 </span>            :         {
<span class="lineNum">   37445 </span><span class="lineCov">         35 :           DECL_ATTRIBUTES (t) = tree_cons (id, NULL_TREE, DECL_ATTRIBUTES (t));</span>
<span class="lineNum">   37446 </span>            :           if (TREE_CODE (t) != FUNCTION_DECL &amp;&amp; !is_global_var (t))
<span class="lineNum">   37447 </span><span class="lineCov">         35 :             continue;</span>
<span class="lineNum">   37448 </span><span class="lineCov">         35 : </span>
<span class="lineNum">   37449 </span>            :           symtab_node *node = symtab_node::get (t);
<span class="lineNum">   37450 </span>            :           if (node != NULL)
<span class="lineNum">   37451 </span>            :             {
<span class="lineNum">   37452 </span><span class="lineCov">         51 :               node-&gt;offloadable = 1;</span>
<span class="lineNum">   37453 </span><span class="lineCov">         51 :               if (ENABLE_OFFLOADING)</span>
<span class="lineNum">   37454 </span><span class="lineCov">         51 :                 {</span>
<span class="lineNum">   37455 </span>            :                   g-&gt;have_offload = true;
<span class="lineNum">   37456 </span><span class="lineCov">        132 :                   if (is_a &lt;varpool_node *&gt; (node))</span>
<span class="lineNum">   37457 </span><span class="lineCov">          3 :                     vec_safe_push (offload_vars, t);</span>
<span class="lineNum">   37458 </span>            :                 }
<span class="lineNum">   37459 </span>            :             }
<span class="lineNum">   37460 </span>            :         }
<span class="lineNum">   37461 </span><span class="lineCov">        306 :     }</span>
<span class="lineNum">   37462 </span>            : }
<a name="37463"><span class="lineNum">   37463 </span><span class="lineCov">        174 : </span></a>
<span class="lineNum">   37464 </span><span class="lineCov">        174 : static void</span>
<span class="lineNum">   37465 </span><span class="lineCov">        348 : cp_parser_omp_end_declare_target (cp_parser *parser, cp_token *pragma_tok)</span>
<span class="lineNum">   37466 </span><span class="lineCov">        174 : {</span>
<span class="lineNum">   37467 </span><span class="lineCov">        174 :   const char *p = &quot;&quot;;</span>
<span class="lineNum">   37468 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))
<span class="lineNum">   37469 </span><span class="lineCov">         21 :     {</span>
<span class="lineNum">   37470 </span><span class="lineCov">         21 :       tree id = cp_lexer_peek_token (parser-&gt;lexer)-&gt;u.value;</span>
<span class="lineNum">   37471 </span>            :       p = IDENTIFIER_POINTER (id);
<span class="lineNum">   37472 </span>            :     }
<span class="lineNum">   37473 </span><span class="lineCov">        153 :   if (strcmp (p, &quot;declare&quot;) == 0)</span>
<span class="lineNum">   37474 </span><span class="lineCov">        174 :     {</span>
<span class="lineNum">   37475 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   37476 </span><span class="lineCov">          3 :       p = &quot;&quot;;</span>
<span class="lineNum">   37477 </span>            :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))
<span class="lineNum">   37478 </span>            :         {
<span class="lineNum">   37479 </span><span class="lineCov">          3 :           tree id = cp_lexer_peek_token (parser-&gt;lexer)-&gt;u.value;</span>
<span class="lineNum">   37480 </span>            :           p = IDENTIFIER_POINTER (id);
<span class="lineNum">   37481 </span><span class="lineCov">        171 :         }</span>
<span class="lineNum">   37482 </span>            :       if (strcmp (p, &quot;target&quot;) == 0)
<span class="lineNum">   37483 </span><span class="lineCov">        156 :         cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   37484 </span><span class="lineCov">        156 :       else</span>
<span class="lineNum">   37485 </span>            :         {
<span class="lineNum">   37486 </span>            :           cp_parser_error (parser, &quot;expected %&lt;target%&gt;&quot;);
<span class="lineNum">   37487 </span><span class="lineCov">        153 :           cp_parser_skip_to_pragma_eol (parser, pragma_tok);</span>
<span class="lineNum">   37488 </span><span class="lineCov">        153 :           return;</span>
<span class="lineNum">   37489 </span>            :         }
<span class="lineNum">   37490 </span><span class="lineCov">         96 :     }</span>
<span class="lineNum">   37491 </span><span class="lineCov">         96 :   else</span>
<span class="lineNum">   37492 </span>            :     {
<span class="lineNum">   37493 </span>            :       cp_parser_error (parser, &quot;expected %&lt;declare%&gt;&quot;);
<span class="lineNum">   37494 </span>            :       cp_parser_skip_to_pragma_eol (parser, pragma_tok);
<span class="lineNum">   37495 </span>            :       return;
<span class="lineNum">   37496 </span>            :     }
<span class="lineNum">   37497 </span>            :   cp_parser_require_pragma_eol (parser, pragma_tok);
<span class="lineNum">   37498 </span>            :   if (!scope_chain-&gt;omp_declare_target_attribute)
<span class="lineNum">   37499 </span>            :     error_at (pragma_tok-&gt;location,
<span class="lineNum">   37500 </span>            :               &quot;%&lt;#pragma omp end declare target%&gt; without corresponding &quot;
<span class="lineNum">   37501 </span>            :               &quot;%&lt;#pragma omp declare target%&gt;&quot;);
<span class="lineNum">   37502 </span>            :   else
<span class="lineNum">   37503 </span><span class="lineCov">         51 :     scope_chain-&gt;omp_declare_target_attribute--;</span>
<span class="lineNum">   37504 </span>            : }
<span class="lineNum">   37505 </span><span class="lineCov">         51 : </span>
<span class="lineNum">   37506 </span><span class="lineCov">         51 : /* Helper function of cp_parser_omp_declare_reduction.  Parse the combiner</span>
<span class="lineNum">   37507 </span>            :    expression and optional initializer clause of
<span class="lineNum">   37508 </span><span class="lineCov">        102 :    #pragma omp declare reduction.  We store the expression(s) as</span>
<span class="lineNum">   37509 </span><span class="lineCov">         51 :    either 3, 6 or 7 special statements inside of the artificial function's</span>
<span class="lineNum">   37510 </span>            :    body.  The first two statements are DECL_EXPRs for the artificial
<span class="lineNum">   37511 </span><span class="lineCov">         51 :    OMP_OUT resp. OMP_IN variables, followed by a statement with the combiner</span>
<span class="lineNum">   37512 </span>            :    expression that uses those variables.
<span class="lineNum">   37513 </span><span class="lineCov">         51 :    If there was any INITIALIZER clause, this is followed by further statements,</span>
<span class="lineNum">   37514 </span><span class="lineCov">         51 :    the fourth and fifth statements are DECL_EXPRs for the artificial</span>
<span class="lineNum">   37515 </span><span class="lineCov">         51 :    OMP_PRIV resp. OMP_ORIG variables.  If the INITIALIZER clause wasn't the</span>
<span class="lineNum">   37516 </span>            :    constructor variant (first token after open paren is not omp_priv),
<span class="lineNum">   37517 </span><span class="lineCov">        102 :    then the sixth statement is a statement with the function call expression</span>
<span class="lineNum">   37518 </span><span class="lineCov">         51 :    that uses the OMP_PRIV and optionally OMP_ORIG variable.</span>
<span class="lineNum">   37519 </span>            :    Otherwise, the sixth statement is whatever statement cp_finish_decl emits
<span class="lineNum">   37520 </span><span class="lineCov">         51 :    to initialize the OMP_PRIV artificial variable and there is seventh</span>
<span class="lineNum">   37521 </span><span class="lineCov">         51 :    statement, a DECL_EXPR of the OMP_PRIV statement again.  */</span>
<a name="37522"><span class="lineNum">   37522 </span>            : </a>
<span class="lineNum">   37523 </span>            : static bool
<span class="lineNum">   37524 </span><span class="lineNoCov">          0 : cp_parser_omp_declare_reduction_exprs (tree fndecl, cp_parser *parser)</span>
<span class="lineNum">   37525 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   37526 </span><span class="lineNoCov">          0 :   tree type = TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (fndecl)));</span>
<span class="lineNum">   37527 </span>            :   gcc_assert (TYPE_REF_P (type));
<span class="lineNum">   37528 </span>            :   type = TREE_TYPE (type);
<span class="lineNum">   37529 </span>            :   tree omp_out = build_lang_decl (VAR_DECL, get_identifier (&quot;omp_out&quot;), type);
<span class="lineNum">   37530 </span>            :   DECL_ARTIFICIAL (omp_out) = 1;
<span class="lineNum">   37531 </span><span class="lineNoCov">          0 :   pushdecl (omp_out);</span>
<span class="lineNum">   37532 </span><span class="lineNoCov">          0 :   add_decl_expr (omp_out);</span>
<span class="lineNum">   37533 </span><span class="lineNoCov">          0 :   tree omp_in = build_lang_decl (VAR_DECL, get_identifier (&quot;omp_in&quot;), type);</span>
<span class="lineNum">   37534 </span>            :   DECL_ARTIFICIAL (omp_in) = 1;
<span class="lineNum">   37535 </span><span class="lineCov">         51 :   pushdecl (omp_in);</span>
<span class="lineNum">   37536 </span><span class="lineCov">         51 :   add_decl_expr (omp_in);</span>
<span class="lineNum">   37537 </span><span class="lineNoCov">          0 :   tree combiner;</span>
<span class="lineNum">   37538 </span>            :   tree omp_priv = NULL_TREE, omp_orig = NULL_TREE, initializer = NULL_TREE;
<span class="lineNum">   37539 </span>            : 
<span class="lineNum">   37540 </span>            :   keep_next_level (true);
<span class="lineNum">   37541 </span><span class="lineCov">         51 :   tree block = begin_omp_structured_block ();</span>
<span class="lineNum">   37542 </span>            :   combiner = cp_parser_expression (parser);
<span class="lineNum">   37543 </span>            :   finish_expr_stmt (combiner);
<span class="lineNum">   37544 </span>            :   block = finish_omp_structured_block (block);
<span class="lineNum">   37545 </span>            :   add_stmt (block);
<span class="lineNum">   37546 </span>            : 
<span class="lineNum">   37547 </span>            :   if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))
<span class="lineNum">   37548 </span>            :     return false;
<span class="lineNum">   37549 </span>            : 
<span class="lineNum">   37550 </span>            :   const char *p = &quot;&quot;;
<span class="lineNum">   37551 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))
<span class="lineNum">   37552 </span>            :     {
<span class="lineNum">   37553 </span>            :       tree id = cp_lexer_peek_token (parser-&gt;lexer)-&gt;u.value;
<span class="lineNum">   37554 </span>            :       p = IDENTIFIER_POINTER (id);
<span class="lineNum">   37555 </span>            :     }
<span class="lineNum">   37556 </span>            : 
<span class="lineNum">   37557 </span>            :   if (strcmp (p, &quot;initializer&quot;) == 0)
<span class="lineNum">   37558 </span>            :     {
<span class="lineNum">   37559 </span>            :       cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   37560 </span>            :       matching_parens parens;
<span class="lineNum">   37561 </span>            :       if (!parens.require_open (parser))
<span class="lineNum">   37562 </span><span class="lineCov">        605 :         return false;</span>
<span class="lineNum">   37563 </span>            : 
<span class="lineNum">   37564 </span><span class="lineCov">        605 :       p = &quot;&quot;;</span>
<span class="lineNum">   37565 </span><span class="lineCov">        605 :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))</span>
<span class="lineNum">   37566 </span><span class="lineCov">        605 :         {</span>
<span class="lineNum">   37567 </span><span class="lineCov">        605 :           tree id = cp_lexer_peek_token (parser-&gt;lexer)-&gt;u.value;</span>
<span class="lineNum">   37568 </span><span class="lineCov">        605 :           p = IDENTIFIER_POINTER (id);</span>
<span class="lineNum">   37569 </span><span class="lineCov">        605 :         }</span>
<span class="lineNum">   37570 </span><span class="lineCov">        605 : </span>
<span class="lineNum">   37571 </span><span class="lineCov">        605 :       omp_priv = build_lang_decl (VAR_DECL, get_identifier (&quot;omp_priv&quot;), type);</span>
<span class="lineNum">   37572 </span><span class="lineCov">        605 :       DECL_ARTIFICIAL (omp_priv) = 1;</span>
<span class="lineNum">   37573 </span><span class="lineCov">        605 :       pushdecl (omp_priv);</span>
<span class="lineNum">   37574 </span><span class="lineCov">        605 :       add_decl_expr (omp_priv);</span>
<span class="lineNum">   37575 </span><span class="lineCov">        605 :       omp_orig = build_lang_decl (VAR_DECL, get_identifier (&quot;omp_orig&quot;), type);</span>
<span class="lineNum">   37576 </span><span class="lineCov">        605 :       DECL_ARTIFICIAL (omp_orig) = 1;</span>
<span class="lineNum">   37577 </span>            :       pushdecl (omp_orig);
<span class="lineNum">   37578 </span><span class="lineCov">        605 :       add_decl_expr (omp_orig);</span>
<span class="lineNum">   37579 </span><span class="lineCov">        605 : </span>
<span class="lineNum">   37580 </span><span class="lineCov">        605 :       keep_next_level (true);</span>
<span class="lineNum">   37581 </span><span class="lineCov">        605 :       block = begin_omp_structured_block ();</span>
<span class="lineNum">   37582 </span><span class="lineCov">        605 : </span>
<span class="lineNum">   37583 </span><span class="lineCov">        605 :       bool ctor = false;</span>
<span class="lineNum">   37584 </span>            :       if (strcmp (p, &quot;omp_priv&quot;) == 0)
<span class="lineNum">   37585 </span><span class="lineCov">        605 :         {</span>
<span class="lineNum">   37586 </span>            :           bool is_direct_init, is_non_constant_init;
<span class="lineNum">   37587 </span>            :           ctor = true;
<span class="lineNum">   37588 </span><span class="lineCov">        602 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   37589 </span><span class="lineCov">        602 :           /* Reject initializer (omp_priv) and initializer (omp_priv ()).  */</span>
<span class="lineNum">   37590 </span>            :           if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_CLOSE_PAREN)
<span class="lineNum">   37591 </span><span class="lineCov">        414 :               || (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_PAREN)</span>
<span class="lineNum">   37592 </span><span class="lineCov">        207 :                   &amp;&amp; cp_lexer_peek_nth_token (parser-&gt;lexer, 2)-&gt;type</span>
<span class="lineNum">   37593 </span>            :                      == CPP_CLOSE_PAREN
<span class="lineNum">   37594 </span>            :                   &amp;&amp; cp_lexer_peek_nth_token (parser-&gt;lexer, 3)-&gt;type
<span class="lineNum">   37595 </span><span class="lineCov">        602 :                      == CPP_CLOSE_PAREN))</span>
<span class="lineNum">   37596 </span>            :             {
<span class="lineNum">   37597 </span><span class="lineCov">        207 :               finish_omp_structured_block (block);</span>
<span class="lineNum">   37598 </span><span class="lineCov">        414 :               error (&quot;invalid initializer clause&quot;);</span>
<span class="lineNum">   37599 </span><span class="lineCov">        207 :               return false;</span>
<span class="lineNum">   37600 </span>            :             }
<span class="lineNum">   37601 </span>            :           initializer = cp_parser_initializer (parser, &amp;is_direct_init,
<span class="lineNum">   37602 </span><span class="lineCov">        207 :                                                &amp;is_non_constant_init);</span>
<span class="lineNum">   37603 </span><span class="lineCov">        207 :           cp_finish_decl (omp_priv, initializer, !is_non_constant_init,</span>
<span class="lineNum">   37604 </span>            :                           NULL_TREE, LOOKUP_ONLYCONVERTING);
<span class="lineNum">   37605 </span><span class="lineCov">        410 :         }</span>
<span class="lineNum">   37606 </span><span class="lineCov">        205 :       else</span>
<span class="lineNum">   37607 </span>            :         {
<span class="lineNum">   37608 </span>            :           cp_parser_parse_tentatively (parser);
<span class="lineNum">   37609 </span><span class="lineCov">        207 :           tree fn_name = cp_parser_id_expression (parser, /*template_p=*/false,</span>
<span class="lineNum">   37610 </span><span class="lineCov">        207 :                                                   /*check_dependency_p=*/true,</span>
<span class="lineNum">   37611 </span><span class="lineCov">        207 :                                                   /*template_p=*/NULL,</span>
<span class="lineNum">   37612 </span><span class="lineCov">        207 :                                                   /*declarator_p=*/false,</span>
<span class="lineNum">   37613 </span><span class="lineCov">        207 :                                                   /*optional_p=*/false);</span>
<span class="lineNum">   37614 </span><span class="lineCov">        207 :           vec&lt;tree, va_gc&gt; *args;</span>
<span class="lineNum">   37615 </span><span class="lineCov">        207 :           if (fn_name == error_mark_node</span>
<span class="lineNum">   37616 </span><span class="lineCov">        207 :               || cp_parser_error_occurred (parser)</span>
<span class="lineNum">   37617 </span>            :               || !cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_PAREN)
<span class="lineNum">   37618 </span><span class="lineCov">        207 :               || ((args = cp_parser_parenthesized_expression_list</span>
<span class="lineNum">   37619 </span><span class="lineCov">        207 :                                 (parser, non_attr, /*cast_p=*/false,</span>
<span class="lineNum">   37620 </span>            :                                  /*allow_expansion_p=*/true,
<span class="lineNum">   37621 </span><span class="lineCov">        207 :                                  /*non_constant_p=*/NULL)),</span>
<span class="lineNum">   37622 </span><span class="lineCov">        207 :                   cp_parser_error_occurred (parser)))</span>
<span class="lineNum">   37623 </span>            :             {
<span class="lineNum">   37624 </span><span class="lineCov">        124 :               finish_omp_structured_block (block);</span>
<span class="lineNum">   37625 </span><span class="lineCov">        124 :               cp_parser_abort_tentative_parse (parser);</span>
<span class="lineNum">   37626 </span><span class="lineCov">        124 :               cp_parser_error (parser, &quot;expected id-expression (arguments)&quot;);</span>
<span class="lineNum">   37627 </span>            :               return false;
<span class="lineNum">   37628 </span><span class="lineCov">        248 :             }</span>
<span class="lineNum">   37629 </span><span class="lineCov">        124 :           unsigned int i;</span>
<span class="lineNum">   37630 </span><span class="lineCov">         66 :           tree arg;</span>
<span class="lineNum">   37631 </span>            :           FOR_EACH_VEC_SAFE_ELT (args, i, arg)
<span class="lineNum">   37632 </span><span class="lineCov">          3 :             if (arg == omp_priv</span>
<span class="lineNum">   37633 </span>            :                 || (TREE_CODE (arg) == ADDR_EXPR
<span class="lineNum">   37634 </span>            :                     &amp;&amp; TREE_OPERAND (arg, 0) == omp_priv))
<span class="lineNum">   37635 </span><span class="lineCov">          6 :               break;</span>
<span class="lineNum">   37636 </span><span class="lineCov">          6 :           cp_parser_abort_tentative_parse (parser);</span>
<span class="lineNum">   37637 </span><span class="lineCov">          6 :           if (arg == NULL_TREE)</span>
<span class="lineNum">   37638 </span>            :             error (&quot;one of the initializer call arguments should be %&lt;omp_priv%&gt;&quot;
<span class="lineNum">   37639 </span><span class="lineCov">        118 :                    &quot; or %&lt;&amp;omp_priv%&gt;&quot;);</span>
<span class="lineNum">   37640 </span>            :           initializer = cp_parser_postfix_expression (parser, false, false, false,
<span class="lineNum">   37641 </span><span class="lineCov">        118 :                                                       false, NULL);</span>
<span class="lineNum">   37642 </span>            :           finish_expr_stmt (initializer);
<span class="lineNum">   37643 </span>            :         }
<span class="lineNum">   37644 </span>            : 
<span class="lineNum">   37645 </span>            :       block = finish_omp_structured_block (block);
<span class="lineNum">   37646 </span><span class="lineCov">         83 :       cp_walk_tree (&amp;block, cp_remove_omp_priv_cleanup_stmt, omp_priv, NULL);</span>
<span class="lineNum">   37647 </span><span class="lineCov">        166 :       add_stmt (block);</span>
<span class="lineNum">   37648 </span>            : 
<span class="lineNum">   37649 </span>            :       if (ctor)
<span class="lineNum">   37650 </span>            :         add_decl_expr (omp_orig);
<span class="lineNum">   37651 </span><span class="lineCov">         83 : </span>
<span class="lineNum">   37652 </span><span class="lineCov">         83 :       if (!parens.require_close (parser))</span>
<span class="lineNum">   37653 </span><span class="lineCov">         83 :         return false;</span>
<span class="lineNum">   37654 </span><span class="lineCov">         83 :     }</span>
<span class="lineNum">   37655 </span><span class="lineCov">         83 : </span>
<span class="lineNum">   37656 </span><span class="lineCov">         83 :   if (!cp_lexer_next_token_is (parser-&gt;lexer, CPP_PRAGMA_EOL))</span>
<span class="lineNum">   37657 </span><span class="lineCov">         83 :     cp_parser_required_error (parser, RT_PRAGMA_EOL, /*keyword=*/false,</span>
<span class="lineNum">   37658 </span>            :                               UNKNOWN_LOCATION);
<span class="lineNum">   37659 </span>            : 
<span class="lineNum">   37660 </span><span class="lineCov">         83 :   return true;</span>
<span class="lineNum">   37661 </span>            : }
<span class="lineNum">   37662 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   37663 </span><span class="lineNoCov">          0 : /* OpenMP 4.0</span>
<span class="lineNum">   37664 </span><span class="lineNoCov">          0 :    #pragma omp declare reduction (reduction-id : typename-list : expression) \</span>
<span class="lineNum">   37665 </span><span class="lineNoCov">          0 :       initializer-clause[opt] new-line</span>
<span class="lineNum">   37666 </span>            : 
<span class="lineNum">   37667 </span>            :    initializer-clause:
<span class="lineNum">   37668 </span>            :       initializer (omp_priv initializer)
<span class="lineNum">   37669 </span><span class="lineCov">         89 :       initializer (function-name (argument-list))  */</span>
<a name="37670"><span class="lineNum">   37670 </span><span class="lineCov">         83 : </span></a>
<span class="lineNum">   37671 </span><span class="lineCov">         83 : static void</span>
<span class="lineNum">   37672 </span><span class="lineCov">         28 : cp_parser_omp_declare_reduction (cp_parser *parser, cp_token *pragma_tok,</span>
<span class="lineNum">   37673 </span>            :                                  enum pragma_context)
<span class="lineNum">   37674 </span><span class="lineCov">         83 : {</span>
<span class="lineNum">   37675 </span><span class="lineCov">         83 :   auto_vec&lt;tree&gt; types;</span>
<span class="lineNum">   37676 </span><span class="lineCov">          6 :   enum tree_code reduc_code = ERROR_MARK;</span>
<span class="lineNum">   37677 </span>            :   tree reduc_id = NULL_TREE, orig_reduc_id = NULL_TREE, type;
<span class="lineNum">   37678 </span><span class="lineCov">        166 :   unsigned int i;</span>
<span class="lineNum">   37679 </span><span class="lineCov">         83 :   cp_token *first_token;</span>
<span class="lineNum">   37680 </span><span class="lineCov">         83 :   cp_token_cache *cp;</span>
<span class="lineNum">   37681 </span>            :   int errs;
<span class="lineNum">   37682 </span>            :   void *p;
<span class="lineNum">   37683 </span><span class="lineCov">        201 :     </span>
<span class="lineNum">   37684 </span><span class="lineCov">        201 :   /* Get the high-water mark for the DECLARATOR_OBSTACK.  */</span>
<span class="lineNum">   37685 </span><span class="lineCov">        201 :   p = obstack_alloc (&amp;declarator_obstack, 0);</span>
<span class="lineNum">   37686 </span>            : 
<span class="lineNum">   37687 </span><span class="lineCov">        201 :   if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))</span>
<span class="lineNum">   37688 </span><span class="lineCov">        118 :     goto fail;</span>
<span class="lineNum">   37689 </span>            : 
<span class="lineNum">   37690 </span><span class="lineCov">        201 :   switch (cp_lexer_peek_token (parser-&gt;lexer)-&gt;type)</span>
<span class="lineNum">   37691 </span>            :     {
<span class="lineNum">   37692 </span>            :     case CPP_PLUS:
<span class="lineNum">   37693 </span>            :       reduc_code = PLUS_EXPR;
<span class="lineNum">   37694 </span><span class="lineCov">        596 :       break;</span>
<span class="lineNum">   37695 </span><span class="lineNoCov">          0 :     case CPP_MULT:</span>
<span class="lineNum">   37696 </span>            :       reduc_code = MULT_EXPR;
<span class="lineNum">   37697 </span>            :       break;
<span class="lineNum">   37698 </span>            :     case CPP_MINUS:
<span class="lineNum">   37699 </span>            :       reduc_code = MINUS_EXPR;
<span class="lineNum">   37700 </span>            :       break;
<span class="lineNum">   37701 </span>            :     case CPP_AND:
<span class="lineNum">   37702 </span>            :       reduc_code = BIT_AND_EXPR;
<span class="lineNum">   37703 </span>            :       break;
<span class="lineNum">   37704 </span>            :     case CPP_XOR:
<span class="lineNum">   37705 </span>            :       reduc_code = BIT_XOR_EXPR;
<span class="lineNum">   37706 </span>            :       break;
<span class="lineNum">   37707 </span>            :     case CPP_OR:
<span class="lineNum">   37708 </span>            :       reduc_code = BIT_IOR_EXPR;
<span class="lineNum">   37709 </span>            :       break;
<span class="lineNum">   37710 </span><span class="lineCov">        631 :     case CPP_AND_AND:</span>
<span class="lineNum">   37711 </span>            :       reduc_code = TRUTH_ANDIF_EXPR;
<span class="lineNum">   37712 </span>            :       break;
<span class="lineNum">   37713 </span><span class="lineCov">       1262 :     case CPP_OR_OR:</span>
<span class="lineNum">   37714 </span><span class="lineCov">        631 :       reduc_code = TRUTH_ORIF_EXPR;</span>
<span class="lineNum">   37715 </span><span class="lineCov">        631 :       break;</span>
<span class="lineNum">   37716 </span><span class="lineCov">        631 :     case CPP_NAME:</span>
<span class="lineNum">   37717 </span><span class="lineCov">        631 :       reduc_id = orig_reduc_id = cp_parser_identifier (parser);</span>
<span class="lineNum">   37718 </span><span class="lineCov">        631 :       break;</span>
<span class="lineNum">   37719 </span><span class="lineCov">        631 :     default:</span>
<span class="lineNum">   37720 </span><span class="lineCov">        631 :       cp_parser_error (parser, &quot;expected %&lt;+%&gt;, %&lt;*%&gt;, %&lt;-%&gt;, %&lt;&amp;%&gt;, %&lt;^%&gt;, &quot;</span>
<span class="lineNum">   37721 </span>            :                                &quot;%&lt;|%&gt;, %&lt;&amp;&amp;%&gt;, %&lt;||%&gt; or identifier&quot;);
<span class="lineNum">   37722 </span>            :       goto fail;
<span class="lineNum">   37723 </span><span class="lineCov">        631 :     }</span>
<span class="lineNum">   37724 </span>            : 
<span class="lineNum">   37725 </span><span class="lineCov">        631 :   if (reduc_code != ERROR_MARK)</span>
<span class="lineNum">   37726 </span>            :     cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   37727 </span>            : 
<span class="lineNum">   37728 </span><span class="lineCov">        631 :   reduc_id = omp_reduction_id (reduc_code, reduc_id, NULL_TREE);</span>
<span class="lineNum">   37729 </span>            :   if (reduc_id == error_mark_node)
<span class="lineNum">   37730 </span>            :     goto fail;
<span class="lineNum">   37731 </span>            : 
<span class="lineNum">   37732 </span>            :   if (!cp_parser_require (parser, CPP_COLON, RT_COLON))
<span class="lineNum">   37733 </span><span class="lineCov">         48 :     goto fail;</span>
<span class="lineNum">   37734 </span><span class="lineCov">         48 : </span>
<span class="lineNum">   37735 </span><span class="lineCov">         48 :   /* Types may not be defined in declare reduction type list.  */</span>
<span class="lineNum">   37736 </span><span class="lineCov">          3 :   const char *saved_message;</span>
<span class="lineNum">   37737 </span><span class="lineCov">          3 :   saved_message = parser-&gt;type_definition_forbidden_message;</span>
<span class="lineNum">   37738 </span><span class="lineCov">          3 :   parser-&gt;type_definition_forbidden_message</span>
<span class="lineNum">   37739 </span><span class="lineCov">          4 :     = G_(&quot;types may not be defined in declare reduction type list&quot;);</span>
<span class="lineNum">   37740 </span><span class="lineCov">          4 :   bool saved_colon_corrects_to_scope_p;</span>
<span class="lineNum">   37741 </span><span class="lineCov">          4 :   saved_colon_corrects_to_scope_p = parser-&gt;colon_corrects_to_scope_p;</span>
<span class="lineNum">   37742 </span><span class="lineNoCov">          0 :   parser-&gt;colon_corrects_to_scope_p = false;</span>
<span class="lineNum">   37743 </span><span class="lineNoCov">          0 :   bool saved_colon_doesnt_start_class_def_p;</span>
<span class="lineNum">   37744 </span><span class="lineNoCov">          0 :   saved_colon_doesnt_start_class_def_p</span>
<span class="lineNum">   37745 </span><span class="lineCov">         49 :     = parser-&gt;colon_doesnt_start_class_def_p;</span>
<span class="lineNum">   37746 </span><span class="lineCov">         49 :   parser-&gt;colon_doesnt_start_class_def_p = true;</span>
<span class="lineNum">   37747 </span><span class="lineCov">         49 : </span>
<span class="lineNum">   37748 </span><span class="lineNoCov">          0 :   while (true)</span>
<span class="lineNum">   37749 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   37750 </span><span class="lineNoCov">          0 :       location_t loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;</span>
<span class="lineNum">   37751 </span><span class="lineNoCov">          0 :       type = cp_parser_type_id (parser);</span>
<span class="lineNum">   37752 </span><span class="lineNoCov">          0 :       if (type == error_mark_node)</span>
<span class="lineNum">   37753 </span><span class="lineNoCov">          0 :         ;</span>
<span class="lineNum">   37754 </span><span class="lineCov">        394 :       else if (ARITHMETIC_TYPE_P (type)</span>
<span class="lineNum">   37755 </span><span class="lineCov">        394 :                &amp;&amp; (orig_reduc_id == NULL_TREE</span>
<span class="lineNum">   37756 </span><span class="lineCov">        394 :                    || (TREE_CODE (type) != COMPLEX_TYPE</span>
<span class="lineNum">   37757 </span><span class="lineNoCov">          0 :                        &amp;&amp; (id_equal (orig_reduc_id, &quot;min&quot;)</span>
<span class="lineNum">   37758 </span><span class="lineNoCov">          0 :                            || id_equal (orig_reduc_id, &quot;max&quot;)))))</span>
<span class="lineNum">   37759 </span>            :         error_at (loc, &quot;predeclared arithmetic type %qT in &quot;
<span class="lineNum">   37760 </span><span class="lineNoCov">          0 :                        &quot;%&lt;#pragma omp declare reduction%&gt;&quot;, type);</span>
<span class="lineNum">   37761 </span>            :       else if (TREE_CODE (type) == FUNCTION_TYPE
<span class="lineNum">   37762 </span>            :                || TREE_CODE (type) == METHOD_TYPE
<span class="lineNum">   37763 </span><span class="lineCov">        631 :                || TREE_CODE (type) == ARRAY_TYPE)</span>
<span class="lineNum">   37764 </span><span class="lineCov">        237 :         error_at (loc, &quot;function or array type %qT in &quot;</span>
<span class="lineNum">   37765 </span>            :                        &quot;%&lt;#pragma omp declare reduction%&gt;&quot;, type);
<span class="lineNum">   37766 </span><span class="lineCov">        631 :       else if (TYPE_REF_P (type))</span>
<span class="lineNum">   37767 </span><span class="lineCov">        631 :         error_at (loc, &quot;reference type %qT in &quot;</span>
<span class="lineNum">   37768 </span>            :                        &quot;%&lt;#pragma omp declare reduction%&gt;&quot;, type);
<span class="lineNum">   37769 </span>            :       else if (TYPE_QUALS_NO_ADDR_SPACE (type))
<span class="lineNum">   37770 </span><span class="lineCov">        631 :         error_at (loc, &quot;const, volatile or __restrict qualified type %qT in &quot;</span>
<span class="lineNum">   37771 </span>            :                        &quot;%&lt;#pragma omp declare reduction%&gt;&quot;, type);
<span class="lineNum">   37772 </span>            :       else
<span class="lineNum">   37773 </span>            :         types.safe_push (type);
<span class="lineNum">   37774 </span><span class="lineCov">        631 : </span>
<span class="lineNum">   37775 </span><span class="lineCov">        631 :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_COMMA))</span>
<span class="lineNum">   37776 </span><span class="lineCov">        631 :         cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   37777 </span><span class="lineCov">        631 :       else</span>
<span class="lineNum">   37778 </span><span class="lineCov">        631 :         break;</span>
<span class="lineNum">   37779 </span><span class="lineCov">        631 :     }</span>
<span class="lineNum">   37780 </span><span class="lineCov">        631 : </span>
<span class="lineNum">   37781 </span><span class="lineCov">        631 :   /* Restore the saved message.  */</span>
<span class="lineNum">   37782 </span><span class="lineCov">        631 :   parser-&gt;type_definition_forbidden_message = saved_message;</span>
<span class="lineNum">   37783 </span><span class="lineCov">        631 :   parser-&gt;colon_corrects_to_scope_p = saved_colon_corrects_to_scope_p;</span>
<span class="lineNum">   37784 </span><span class="lineCov">        631 :   parser-&gt;colon_doesnt_start_class_def_p</span>
<span class="lineNum">   37785 </span>            :     = saved_colon_doesnt_start_class_def_p;
<span class="lineNum">   37786 </span><span class="lineCov">        647 : </span>
<span class="lineNum">   37787 </span>            :   if (!cp_parser_require (parser, CPP_COLON, RT_COLON)
<span class="lineNum">   37788 </span><span class="lineCov">       1294 :       || types.is_empty ())</span>
<span class="lineNum">   37789 </span><span class="lineCov">        647 :     {</span>
<span class="lineNum">   37790 </span><span class="lineCov">        647 :      fail:</span>
<span class="lineNum">   37791 </span>            :       cp_parser_skip_to_pragma_eol (parser, pragma_tok);
<span class="lineNum">   37792 </span><span class="lineCov">        502 :       goto done;</span>
<span class="lineNum">   37793 </span><span class="lineCov">        656 :     }</span>
<span class="lineNum">   37794 </span><span class="lineCov">        145 : </span>
<span class="lineNum">   37795 </span><span class="lineCov">        139 :   first_token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   37796 </span><span class="lineCov">        136 :   cp = NULL;</span>
<span class="lineNum">   37797 </span><span class="lineCov">         12 :   errs = errorcount;</span>
<span class="lineNum">   37798 </span>            :   FOR_EACH_VEC_ELT (types, i, type)
<span class="lineNum">   37799 </span><span class="lineCov">       1270 :     {</span>
<span class="lineNum">   37800 </span><span class="lineCov">        635 :       tree fntype</span>
<span class="lineNum">   37801 </span><span class="lineCov">        626 :         = build_function_type_list (void_type_node,</span>
<span class="lineNum">   37802 </span><span class="lineCov">         15 :                                     cp_build_reference_type (type, false),</span>
<span class="lineNum">   37803 </span>            :                                     NULL_TREE);
<span class="lineNum">   37804 </span><span class="lineCov">        620 :       tree this_reduc_id = reduc_id;</span>
<span class="lineNum">   37805 </span><span class="lineCov">          3 :       if (!dependent_type_p (type))</span>
<span class="lineNum">   37806 </span>            :         this_reduc_id = omp_reduction_id (ERROR_MARK, reduc_id, type);
<span class="lineNum">   37807 </span><span class="lineCov">        617 :       tree fndecl = build_lang_decl (FUNCTION_DECL, this_reduc_id, fntype);</span>
<span class="lineNum">   37808 </span><span class="lineCov">         12 :       DECL_SOURCE_LOCATION (fndecl) = pragma_tok-&gt;location;</span>
<span class="lineNum">   37809 </span>            :       DECL_ARTIFICIAL (fndecl) = 1;
<span class="lineNum">   37810 </span>            :       DECL_EXTERNAL (fndecl) = 1;
<span class="lineNum">   37811 </span><span class="lineCov">        605 :       DECL_DECLARED_INLINE_P (fndecl) = 1;</span>
<span class="lineNum">   37812 </span>            :       DECL_IGNORED_P (fndecl) = 1;
<span class="lineNum">   37813 </span><span class="lineCov">        647 :       DECL_OMP_DECLARE_REDUCTION_P (fndecl) = 1;</span>
<span class="lineNum">   37814 </span><span class="lineCov">         16 :       SET_DECL_ASSEMBLER_NAME (fndecl, get_identifier (&quot;&lt;udr&gt;&quot;));</span>
<span class="lineNum">   37815 </span>            :       DECL_ATTRIBUTES (fndecl)
<span class="lineNum">   37816 </span>            :         = tree_cons (get_identifier (&quot;gnu_inline&quot;), NULL_TREE,
<span class="lineNum">   37817 </span><span class="lineCov">         16 :                      DECL_ATTRIBUTES (fndecl));</span>
<span class="lineNum">   37818 </span>            :       if (processing_template_decl)
<span class="lineNum">   37819 </span>            :         fndecl = push_template_decl (fndecl);
<span class="lineNum">   37820 </span><span class="lineCov">        631 :       bool block_scope = false;</span>
<span class="lineNum">   37821 </span><span class="lineCov">        631 :       tree block = NULL_TREE;</span>
<span class="lineNum">   37822 </span><span class="lineCov">        631 :       if (current_function_decl)</span>
<span class="lineNum">   37823 </span><span class="lineCov">        631 :         {</span>
<span class="lineNum">   37824 </span>            :           block_scope = true;
<span class="lineNum">   37825 </span><span class="lineCov">        631 :           DECL_CONTEXT (fndecl) = global_namespace;</span>
<span class="lineNum">   37826 </span><span class="lineCov">        631 :           if (!processing_template_decl)</span>
<span class="lineNum">   37827 </span>            :             pushdecl (fndecl);
<span class="lineNum">   37828 </span><span class="lineCov">         51 :         }</span>
<span class="lineNum">   37829 </span><span class="lineCov">         51 :       else if (current_class_type)</span>
<span class="lineNum">   37830 </span><span class="lineCov">         51 :         {</span>
<span class="lineNum">   37831 </span>            :           if (cp == NULL)
<span class="lineNum">   37832 </span>            :             {
<span class="lineNum">   37833 </span><span class="lineCov">       1178 :               while (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_PRAGMA_EOL)</span>
<span class="lineNum">   37834 </span><span class="lineCov">        589 :                      &amp;&amp; cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_EOF))</span>
<span class="lineNum">   37835 </span><span class="lineCov">        589 :                 cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   37836 </span><span class="lineCov">       1531 :               if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_PRAGMA_EOL))</span>
<span class="lineNum">   37837 </span>            :                 goto fail;
<span class="lineNum">   37838 </span><span class="lineCov">        605 :               cp = cp_token_cache_new (first_token,</span>
<span class="lineNum">   37839 </span><span class="lineCov">        605 :                                        cp_lexer_peek_nth_token (parser-&gt;lexer,</span>
<span class="lineNum">   37840 </span>            :                                                                 2));
<span class="lineNum">   37841 </span>            :             }
<span class="lineNum">   37842 </span><span class="lineCov">        605 :           DECL_STATIC_FUNCTION_P (fndecl) = 1;</span>
<span class="lineNum">   37843 </span><span class="lineCov">        605 :           finish_member_declaration (fndecl);</span>
<span class="lineNum">   37844 </span><span class="lineCov">        398 :           DECL_PENDING_INLINE_INFO (fndecl) = cp;</span>
<span class="lineNum">   37845 </span><span class="lineCov">        605 :           DECL_PENDING_INLINE_P (fndecl) = 1;</span>
<span class="lineNum">   37846 </span><span class="lineCov">        605 :           vec_safe_push (unparsed_funs_with_definitions, fndecl);</span>
<span class="lineNum">   37847 </span><span class="lineCov">        605 :           continue;</span>
<span class="lineNum">   37848 </span><span class="lineCov">        605 :         }</span>
<span class="lineNum">   37849 </span><span class="lineCov">        605 :       else</span>
<span class="lineNum">   37850 </span><span class="lineCov">        605 :         {</span>
<span class="lineNum">   37851 </span><span class="lineCov">        605 :           DECL_CONTEXT (fndecl) = current_namespace;</span>
<span class="lineNum">   37852 </span><span class="lineCov">        605 :           pushdecl (fndecl);</span>
<span class="lineNum">   37853 </span><span class="lineCov">        605 :         }</span>
<span class="lineNum">   37854 </span><span class="lineCov">        605 :       if (!block_scope)</span>
<span class="lineNum">   37855 </span><span class="lineCov">        605 :         start_preparsed_function (fndecl, NULL_TREE, SF_PRE_PARSED);</span>
<span class="lineNum">   37856 </span><span class="lineCov">        605 :       else</span>
<span class="lineNum">   37857 </span><span class="lineCov">        258 :         block = begin_omp_structured_block ();</span>
<span class="lineNum">   37858 </span><span class="lineCov">        605 :       if (cp)</span>
<span class="lineNum">   37859 </span><span class="lineCov">        605 :         {</span>
<span class="lineNum">   37860 </span><span class="lineCov">        605 :           cp_parser_push_lexer_for_tokens (parser, cp);</span>
<span class="lineNum">   37861 </span>            :           parser-&gt;lexer-&gt;in_pragma = true;
<span class="lineNum">   37862 </span><span class="lineCov">        182 :         }</span>
<span class="lineNum">   37863 </span><span class="lineCov">        182 :       if (!cp_parser_omp_declare_reduction_exprs (fndecl, parser))</span>
<span class="lineNum">   37864 </span><span class="lineCov">        182 :         {</span>
<span class="lineNum">   37865 </span><span class="lineCov">         52 :           if (!block_scope)</span>
<span class="lineNum">   37866 </span>            :             finish_function (/*inline_p=*/false);
<span class="lineNum">   37867 </span><span class="lineCov">        423 :           else</span>
<span class="lineNum">   37868 </span>            :             DECL_CONTEXT (fndecl) = current_function_decl;
<span class="lineNum">   37869 </span><span class="lineCov">        169 :           if (cp)</span>
<span class="lineNum">   37870 </span>            :             cp_parser_pop_lexer (parser);
<span class="lineNum">   37871 </span><span class="lineCov">       1252 :           goto fail;</span>
<span class="lineNum">   37872 </span><span class="lineCov">       1417 :         }</span>
<span class="lineNum">   37873 </span><span class="lineCov">       1252 :       if (cp)</span>
<span class="lineNum">   37874 </span><span class="lineCov">        165 :         cp_parser_pop_lexer (parser);</span>
<span class="lineNum">   37875 </span><span class="lineCov">          9 :       if (!block_scope)</span>
<span class="lineNum">   37876 </span><span class="lineCov">        165 :         finish_function (/*inline_p=*/false);</span>
<span class="lineNum">   37877 </span>            :       else
<span class="lineNum">   37878 </span>            :         {
<span class="lineNum">   37879 </span>            :           DECL_CONTEXT (fndecl) = current_function_decl;
<span class="lineNum">   37880 </span><span class="lineCov">        169 :           block = finish_omp_structured_block (block);</span>
<span class="lineNum">   37881 </span><span class="lineCov">        169 :           if (TREE_CODE (block) == BIND_EXPR)</span>
<span class="lineNum">   37882 </span><span class="lineCov">        169 :             DECL_SAVED_TREE (fndecl) = BIND_EXPR_BODY (block);</span>
<span class="lineNum">   37883 </span><span class="lineCov">        169 :           else if (TREE_CODE (block) == STATEMENT_LIST)</span>
<span class="lineNum">   37884 </span><span class="lineCov">        169 :             DECL_SAVED_TREE (fndecl) = block;</span>
<span class="lineNum">   37885 </span><span class="lineCov">        169 :           if (processing_template_decl)</span>
<span class="lineNum">   37886 </span>            :             add_decl_expr (fndecl);
<span class="lineNum">   37887 </span>            :         }
<span class="lineNum">   37888 </span>            :       cp_check_omp_declare_reduction (fndecl);
<span class="lineNum">   37889 </span><span class="lineCov">        254 :       if (cp == NULL &amp;&amp; types.length () &gt; 1)</span>
<span class="lineNum">   37890 </span><span class="lineCov">        254 :         cp = cp_token_cache_new (first_token,</span>
<span class="lineNum">   37891 </span>            :                                  cp_lexer_peek_nth_token (parser-&gt;lexer, 2));
<span class="lineNum">   37892 </span><span class="lineCov">         52 :       if (errs != errorcount)</span>
<span class="lineNum">   37893 </span><span class="lineCov">        254 :         break;</span>
<span class="lineNum">   37894 </span>            :     }
<span class="lineNum">   37895 </span><span class="lineCov">        182 : </span>
<span class="lineNum">   37896 </span><span class="lineCov">        436 :   cp_parser_require_pragma_eol (parser, pragma_tok);</span>
<span class="lineNum">   37897 </span>            : 
<span class="lineNum">   37898 </span><span class="lineCov">         12 :  done:</span>
<span class="lineNum">   37899 </span><span class="lineCov">         12 :   /* Free any declarators allocated.  */</span>
<span class="lineNum">   37900 </span>            :   obstack_free (&amp;declarator_obstack, p);
<span class="lineNum">   37901 </span><span class="lineCov">        436 : }</span>
<span class="lineNum">   37902 </span>            : 
<span class="lineNum">   37903 </span><span class="lineCov">          9 : /* OpenMP 4.0</span>
<span class="lineNum">   37904 </span><span class="lineCov">          6 :    #pragma omp declare simd declare-simd-clauses[optseq] new-line</span>
<span class="lineNum">   37905 </span>            :    #pragma omp declare reduction (reduction-id : typename-list : expression) \
<span class="lineNum">   37906 </span><span class="lineCov">          3 :       initializer-clause[opt] new-line</span>
<span class="lineNum">   37907 </span><span class="lineCov">          9 :    #pragma omp declare target new-line  */</span>
<a name="37908"><span class="lineNum">   37908 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   37909 </span><span class="lineCov">          9 : static bool</span>
<span class="lineNum">   37910 </span>            : cp_parser_omp_declare (cp_parser *parser, cp_token *pragma_tok,
<span class="lineNum">   37911 </span><span class="lineCov">        427 :                        enum pragma_context context)</span>
<span class="lineNum">   37912 </span><span class="lineCov">         12 : {</span>
<span class="lineNum">   37913 </span><span class="lineCov">        427 :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))</span>
<span class="lineNum">   37914 </span><span class="lineCov">        248 :     {</span>
<span class="lineNum">   37915 </span>            :       tree id = cp_lexer_peek_token (parser-&gt;lexer)-&gt;u.value;
<span class="lineNum">   37916 </span>            :       const char *p = IDENTIFIER_POINTER (id);
<span class="lineNum">   37917 </span><span class="lineCov">        179 : </span>
<span class="lineNum">   37918 </span><span class="lineCov">        179 :       if (strcmp (p, &quot;simd&quot;) == 0)</span>
<span class="lineNum">   37919 </span><span class="lineCov">        179 :         {</span>
<span class="lineNum">   37920 </span><span class="lineCov">         98 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   37921 </span><span class="lineCov">        130 :           cp_parser_omp_declare_simd (parser, pragma_tok,</span>
<span class="lineNum">   37922 </span><span class="lineCov">        130 :                                       context);</span>
<span class="lineNum">   37923 </span><span class="lineCov">        179 :           return true;</span>
<span class="lineNum">   37924 </span><span class="lineCov">        130 :         }</span>
<span class="lineNum">   37925 </span>            :       cp_ensure_no_omp_declare_simd (parser);
<span class="lineNum">   37926 </span><span class="lineCov">        427 :       if (strcmp (p, &quot;reduction&quot;) == 0)</span>
<span class="lineNum">   37927 </span><span class="lineCov">        427 :         {</span>
<span class="lineNum">   37928 </span><span class="lineCov">          8 :           cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   37929 </span>            :           cp_parser_omp_declare_reduction (parser, pragma_tok,
<span class="lineNum">   37930 </span><span class="lineCov">        427 :                                            context);</span>
<span class="lineNum">   37931 </span>            :           return false;
<span class="lineNum">   37932 </span>            :         }
<span class="lineNum">   37933 </span>            :       if (!flag_openmp)  /* flag_openmp_simd  */
<span class="lineNum">   37934 </span><span class="lineCov">        580 :         {</span>
<span class="lineNum">   37935 </span>            :           cp_parser_skip_to_pragma_eol (parser, pragma_tok);
<span class="lineNum">   37936 </span><span class="lineCov">        631 :           return false;</span>
<span class="lineNum">   37937 </span>            :         }
<span class="lineNum">   37938 </span><span class="lineCov">        631 :       if (strcmp (p, &quot;target&quot;) == 0)</span>
<span class="lineNum">   37939 </span><span class="lineCov">        631 :         {</span>
<span class="lineNum">   37940 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   37941 </span>            :           cp_parser_omp_declare_target (parser, pragma_tok);
<span class="lineNum">   37942 </span>            :           return false;
<span class="lineNum">   37943 </span>            :         }
<span class="lineNum">   37944 </span>            :     }
<span class="lineNum">   37945 </span>            :   cp_parser_error (parser, &quot;expected %&lt;simd%&gt; or %&lt;reduction%&gt; &quot;
<span class="lineNum">   37946 </span>            :                            &quot;or %&lt;target%&gt;&quot;);
<span class="lineNum">   37947 </span>            :   cp_parser_require_pragma_eol (parser, pragma_tok);
<span class="lineNum">   37948 </span><span class="lineCov">       1374 :   return false;</span>
<span class="lineNum">   37949 </span>            : }
<span class="lineNum">   37950 </span>            : 
<span class="lineNum">   37951 </span><span class="lineCov">       1374 : /* OpenMP 4.5:</span>
<span class="lineNum">   37952 </span>            :    #pragma omp taskloop taskloop-clause[optseq] new-line
<span class="lineNum">   37953 </span><span class="lineCov">       2748 :      for-loop</span>
<span class="lineNum">   37954 </span><span class="lineCov">       1374 : </span>
<span class="lineNum">   37955 </span>            :    #pragma omp taskloop simd taskloop-simd-clause[optseq] new-line
<span class="lineNum">   37956 </span><span class="lineCov">       1374 :      for-loop  */</span>
<span class="lineNum">   37957 </span>            : 
<span class="lineNum">   37958 </span><span class="lineCov">        560 : #define OMP_TASKLOOP_CLAUSE_MASK                                \</span>
<span class="lineNum">   37959 </span><span class="lineCov">        560 :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_SHARED) \</span>
<span class="lineNum">   37960 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_PRIVATE)        \
<span class="lineNum">   37961 </span><span class="lineCov">        560 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)   \</span>
<span class="lineNum">   37962 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_LASTPRIVATE)    \
<span class="lineNum">   37963 </span><span class="lineCov">        814 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_DEFAULT)        \</span>
<span class="lineNum">   37964 </span><span class="lineCov">        814 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_GRAINSIZE)      \</span>
<span class="lineNum">   37965 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_NUM_TASKS)      \
<span class="lineNum">   37966 </span><span class="lineCov">        631 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_COLLAPSE)       \</span>
<span class="lineNum">   37967 </span><span class="lineCov">        631 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_UNTIED) \</span>
<span class="lineNum">   37968 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_IF)             \
<span class="lineNum">   37969 </span><span class="lineCov">        631 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_FINAL)  \</span>
<span class="lineNum">   37970 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_MERGEABLE)      \
<span class="lineNum">   37971 </span><span class="lineCov">        183 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_NOGROUP)        \</span>
<span class="lineNum">   37972 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OMP_CLAUSE_PRIORITY))
<a name="37973"><span class="lineNum">   37973 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   37974 </span><span class="lineNoCov">          0 : static tree</span>
<span class="lineNum">   37975 </span>            : cp_parser_omp_taskloop (cp_parser *parser, cp_token *pragma_tok,
<span class="lineNum">   37976 </span><span class="lineCov">        183 :                         char *p_name, omp_clause_mask mask, tree *cclauses,</span>
<span class="lineNum">   37977 </span>            :                         bool *if_p)
<span class="lineNum">   37978 </span><span class="lineCov">        183 : {</span>
<span class="lineNum">   37979 </span><span class="lineCov">        183 :   tree clauses, sb, ret;</span>
<span class="lineNum">   37980 </span><span class="lineCov">        183 :   unsigned int save;</span>
<span class="lineNum">   37981 </span>            :   location_t loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">   37982 </span>            : 
<span class="lineNum">   37983 </span><span class="lineNoCov">          0 :   strcat (p_name, &quot; taskloop&quot;);</span>
<span class="lineNum">   37984 </span>            :   mask |= OMP_TASKLOOP_CLAUSE_MASK;
<span class="lineNum">   37985 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   37986 </span><span class="lineNoCov">          0 :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_NAME))</span>
<span class="lineNum">   37987 </span>            :     {
<span class="lineNum">   37988 </span>            :       tree id = cp_lexer_peek_token (parser-&gt;lexer)-&gt;u.value;
<span class="lineNum">   37989 </span>            :       const char *p = IDENTIFIER_POINTER (id);
<span class="lineNum">   37990 </span>            : 
<span class="lineNum">   37991 </span>            :       if (strcmp (p, &quot;simd&quot;) == 0)
<span class="lineNum">   37992 </span>            :         {
<span class="lineNum">   37993 </span>            :           tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];
<span class="lineNum">   37994 </span>            :           if (cclauses == NULL)
<span class="lineNum">   37995 </span>            :             cclauses = cclauses_buf;
<span class="lineNum">   37996 </span>            : 
<span class="lineNum">   37997 </span>            :           cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   37998 </span>            :           if (!flag_openmp)  /* flag_openmp_simd  */
<span class="lineNum">   37999 </span>            :             return cp_parser_omp_simd (parser, pragma_tok, p_name, mask,
<span class="lineNum">   38000 </span>            :                                        cclauses, if_p);
<span class="lineNum">   38001 </span>            :           sb = begin_omp_structured_block ();
<span class="lineNum">   38002 </span>            :           save = cp_parser_begin_omp_structured_block (parser);
<span class="lineNum">   38003 </span>            :           ret = cp_parser_omp_simd (parser, pragma_tok, p_name, mask,
<span class="lineNum">   38004 </span>            :                                     cclauses, if_p);
<span class="lineNum">   38005 </span>            :           cp_parser_end_omp_structured_block (parser, save);
<span class="lineNum">   38006 </span>            :           tree body = finish_omp_structured_block (sb);
<span class="lineNum">   38007 </span>            :           if (ret == NULL)
<span class="lineNum">   38008 </span>            :             return ret;
<span class="lineNum">   38009 </span>            :           ret = make_node (OMP_TASKLOOP);
<span class="lineNum">   38010 </span>            :           TREE_TYPE (ret) = void_type_node;
<span class="lineNum">   38011 </span>            :           OMP_FOR_BODY (ret) = body;
<span class="lineNum">   38012 </span>            :           OMP_FOR_CLAUSES (ret) = cclauses[C_OMP_CLAUSE_SPLIT_TASKLOOP];
<span class="lineNum">   38013 </span><span class="lineCov">        210 :           SET_EXPR_LOCATION (ret, loc);</span>
<span class="lineNum">   38014 </span>            :           add_stmt (ret);
<span class="lineNum">   38015 </span>            :           return ret;
<span class="lineNum">   38016 </span>            :         }
<span class="lineNum">   38017 </span><span class="lineCov">        210 :     }</span>
<span class="lineNum">   38018 </span><span class="lineCov">        210 :   if (!flag_openmp)  /* flag_openmp_simd  */</span>
<span class="lineNum">   38019 </span><span class="lineCov">        420 :     {</span>
<span class="lineNum">   38020 </span>            :       cp_parser_skip_to_pragma_eol (parser, pragma_tok);
<span class="lineNum">   38021 </span><span class="lineCov">        210 :       return NULL_TREE;</span>
<span class="lineNum">   38022 </span><span class="lineCov">       5880 :     }</span>
<span class="lineNum">   38023 </span>            : 
<span class="lineNum">   38024 </span><span class="lineCov">        210 :   clauses = cp_parser_omp_all_clauses (parser, mask, p_name, pragma_tok,</span>
<span class="lineNum">   38025 </span>            :                                        cclauses == NULL);
<span class="lineNum">   38026 </span><span class="lineCov">        248 :   if (cclauses)</span>
<span class="lineNum">   38027 </span><span class="lineCov">        124 :     {</span>
<span class="lineNum">   38028 </span>            :       cp_omp_split_clauses (loc, OMP_TASKLOOP, mask, clauses, cclauses);
<span class="lineNum">   38029 </span><span class="lineCov">        124 :       clauses = cclauses[C_OMP_CLAUSE_SPLIT_TASKLOOP];</span>
<span class="lineNum">   38030 </span>            :     }
<span class="lineNum">   38031 </span><span class="lineCov">         36 : </span>
<span class="lineNum">   38032 </span><span class="lineCov">         36 :   sb = begin_omp_structured_block ();</span>
<span class="lineNum">   38033 </span><span class="lineCov">         36 :   save = cp_parser_begin_omp_structured_block (parser);</span>
<span class="lineNum">   38034 </span>            : 
<span class="lineNum">   38035 </span><span class="lineCov">         36 :   ret = cp_parser_omp_for_loop (parser, OMP_TASKLOOP, clauses, cclauses,</span>
<span class="lineNum">   38036 </span><span class="lineCov">         36 :                                 if_p);</span>
<span class="lineNum">   38037 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   38038 </span><span class="lineNoCov">          0 :   cp_parser_end_omp_structured_block (parser, save);</span>
<span class="lineNum">   38039 </span><span class="lineCov">         36 :   add_stmt (finish_omp_structured_block (sb));</span>
<span class="lineNum">   38040 </span><span class="lineCov">         36 : </span>
<span class="lineNum">   38041 </span><span class="lineCov">         36 :   return ret;</span>
<span class="lineNum">   38042 </span>            : }
<span class="lineNum">   38043 </span><span class="lineCov">         72 : </span>
<span class="lineNum">   38044 </span><span class="lineCov">         36 : </span>
<span class="lineNum">   38045 </span><span class="lineCov">         36 : /* OpenACC 2.0:</span>
<span class="lineNum">   38046 </span>            :    # pragma acc routine oacc-routine-clause[optseq] new-line
<span class="lineNum">   38047 </span><span class="lineCov">         36 :      function-definition</span>
<span class="lineNum">   38048 </span><span class="lineCov">         36 : </span>
<span class="lineNum">   38049 </span><span class="lineCov">         72 :    # pragma acc routine ( name ) oacc-routine-clause[optseq] new-line</span>
<span class="lineNum">   38050 </span><span class="lineCov">         72 : */</span>
<span class="lineNum">   38051 </span><span class="lineCov">         36 : </span>
<span class="lineNum">   38052 </span><span class="lineCov">         36 : #define OACC_ROUTINE_CLAUSE_MASK                                        \</span>
<span class="lineNum">   38053 </span><span class="lineCov">         36 :         ( (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_GANG)          \</span>
<span class="lineNum">   38054 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_WORKER)                \
<span class="lineNum">   38055 </span>            :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_VECTOR)                \
<span class="lineNum">   38056 </span><span class="lineCov">        174 :         | (OMP_CLAUSE_MASK_1 &lt;&lt; PRAGMA_OACC_CLAUSE_SEQ))</span>
<span class="lineNum">   38057 </span>            : 
<span class="lineNum">   38058 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   38059 </span><span class="lineNoCov">          0 : /* Parse the OpenACC routine pragma.  This has an optional '( name )'</span>
<span class="lineNum">   38060 </span>            :    component, which must resolve to a declared namespace-scope
<span class="lineNum">   38061 </span>            :    function.  The clauses are either processed directly (for a named
<span class="lineNum">   38062 </span><span class="lineCov">        174 :    function), or defered until the immediatley following declaration</span>
<span class="lineNum">   38063 </span>            :    is parsed.  */
<a name="38064"><span class="lineNum">   38064 </span><span class="lineCov">        174 : </span></a>
<span class="lineNum">   38065 </span>            : static void
<span class="lineNum">   38066 </span><span class="lineNoCov">          0 : cp_parser_oacc_routine (cp_parser *parser, cp_token *pragma_tok,</span>
<span class="lineNum">   38067 </span><span class="lineNoCov">          0 :                         enum pragma_context context)</span>
<span class="lineNum">   38068 </span>            : {
<span class="lineNum">   38069 </span>            :   gcc_checking_assert (context == pragma_external);
<span class="lineNum">   38070 </span><span class="lineCov">        174 :   /* The checking for &quot;another pragma following this one&quot; in the &quot;no optional</span>
<span class="lineNum">   38071 </span><span class="lineCov">        174 :      '( name )'&quot; case makes sure that we dont re-enter.  */</span>
<span class="lineNum">   38072 </span>            :   gcc_checking_assert (parser-&gt;oacc_routine == NULL);
<span class="lineNum">   38073 </span><span class="lineCov">        174 : </span>
<span class="lineNum">   38074 </span>            :   cp_oacc_routine_data data;
<span class="lineNum">   38075 </span>            :   data.error_seen = false;
<span class="lineNum">   38076 </span><span class="lineCov">        348 :   data.fndecl_seen = false;</span>
<span class="lineNum">   38077 </span><span class="lineCov">        174 :   data.tokens = vNULL;</span>
<span class="lineNum">   38078 </span>            :   data.clauses = NULL_TREE;
<span class="lineNum">   38079 </span><span class="lineCov">        174 :   data.loc = pragma_tok-&gt;location;</span>
<span class="lineNum">   38080 </span>            :   /* It is safe to take the address of a local variable; it will only be
<span class="lineNum">   38081 </span>            :      used while this scope is live.  */
<span class="lineNum">   38082 </span>            :   parser-&gt;oacc_routine = &amp;data;
<span class="lineNum">   38083 </span>            : 
<span class="lineNum">   38084 </span>            :   /* Look for optional '( name )'.  */
<span class="lineNum">   38085 </span>            :   if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_OPEN_PAREN))
<span class="lineNum">   38086 </span>            :     {
<span class="lineNum">   38087 </span>            :       matching_parens parens;
<span class="lineNum">   38088 </span>            :       parens.consume_open (parser); /* '(' */
<span class="lineNum">   38089 </span>            : 
<span class="lineNum">   38090 </span>            :       /* We parse the name as an id-expression.  If it resolves to
<span class="lineNum">   38091 </span>            :          anything other than a non-overloaded function at namespace
<span class="lineNum">   38092 </span>            :          scope, it's an error.  */
<span class="lineNum">   38093 </span>            :       location_t name_loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;
<span class="lineNum">   38094 </span>            :       tree name = cp_parser_id_expression (parser,
<span class="lineNum">   38095 </span>            :                                            /*template_keyword_p=*/false,
<span class="lineNum">   38096 </span>            :                                            /*check_dependency_p=*/false,
<span class="lineNum">   38097 </span>            :                                            /*template_p=*/NULL,
<span class="lineNum">   38098 </span>            :                                            /*declarator_p=*/false,
<span class="lineNum">   38099 </span>            :                                            /*optional_p=*/false);
<span class="lineNum">   38100 </span>            :       tree decl = (identifier_p (name)
<span class="lineNum">   38101 </span>            :                    ? cp_parser_lookup_name_simple (parser, name, name_loc)
<span class="lineNum">   38102 </span>            :                    : name);
<span class="lineNum">   38103 </span>            :       if (name != error_mark_node &amp;&amp; decl == error_mark_node)
<span class="lineNum">   38104 </span><span class="lineCov">        416 :         cp_parser_name_lookup_error (parser, name, decl, NLE_NULL, name_loc);</span>
<span class="lineNum">   38105 </span>            : 
<span class="lineNum">   38106 </span>            :       if (decl == error_mark_node
<span class="lineNum">   38107 </span><span class="lineCov">        416 :           || !parens.require_close (parser))</span>
<span class="lineNum">   38108 </span>            :         {
<span class="lineNum">   38109 </span>            :           cp_parser_skip_to_pragma_eol (parser, pragma_tok);
<span class="lineNum">   38110 </span><span class="lineCov">        416 :           parser-&gt;oacc_routine = NULL;</span>
<span class="lineNum">   38111 </span>            :           return;
<span class="lineNum">   38112 </span><span class="lineCov">        416 :         }</span>
<span class="lineNum">   38113 </span><span class="lineCov">        416 : </span>
<span class="lineNum">   38114 </span><span class="lineCov">        416 :       data.clauses</span>
<span class="lineNum">   38115 </span><span class="lineCov">        416 :         = cp_parser_oacc_all_clauses (parser, OACC_ROUTINE_CLAUSE_MASK,</span>
<span class="lineNum">   38116 </span><span class="lineCov">        416 :                                       &quot;#pragma acc routine&quot;,</span>
<span class="lineNum">   38117 </span><span class="lineCov">        416 :                                       cp_lexer_peek_token (parser-&gt;lexer));</span>
<span class="lineNum">   38118 </span>            : 
<span class="lineNum">   38119 </span>            :       if (decl &amp;&amp; is_overloaded_fn (decl)
<span class="lineNum">   38120 </span><span class="lineCov">        416 :           &amp;&amp; (TREE_CODE (decl) != FUNCTION_DECL</span>
<span class="lineNum">   38121 </span>            :               || DECL_FUNCTION_TEMPLATE_P  (decl)))
<span class="lineNum">   38122 </span>            :         {
<span class="lineNum">   38123 </span><span class="lineCov">        416 :           error_at (name_loc,</span>
<span class="lineNum">   38124 </span>            :                     &quot;%&lt;#pragma acc routine%&gt; names a set of overloads&quot;);
<span class="lineNum">   38125 </span><span class="lineCov">        222 :           parser-&gt;oacc_routine = NULL;</span>
<span class="lineNum">   38126 </span><span class="lineCov">        111 :           return;</span>
<span class="lineNum">   38127 </span>            :         }
<span class="lineNum">   38128 </span>            : 
<span class="lineNum">   38129 </span>            :       /* Perhaps we should use the same rule as declarations in different
<span class="lineNum">   38130 </span>            :          namespaces?  */
<span class="lineNum">   38131 </span><span class="lineCov">        222 :       if (!DECL_NAMESPACE_SCOPE_P (decl))</span>
<span class="lineNum">   38132 </span><span class="lineCov">        222 :         {</span>
<span class="lineNum">   38133 </span>            :           error_at (name_loc,
<span class="lineNum">   38134 </span>            :                     &quot;%qD does not refer to a namespace scope function&quot;, decl);
<span class="lineNum">   38135 </span>            :           parser-&gt;oacc_routine = NULL;
<span class="lineNum">   38136 </span>            :           return;
<span class="lineNum">   38137 </span><span class="lineCov">        111 :         }</span>
<span class="lineNum">   38138 </span><span class="lineCov">        111 : </span>
<span class="lineNum">   38139 </span><span class="lineCov">         87 :       if (TREE_CODE (decl) != FUNCTION_DECL)</span>
<span class="lineNum">   38140 </span><span class="lineCov">        111 :         {</span>
<span class="lineNum">   38141 </span><span class="lineCov">        111 :           error_at (name_loc, &quot;%qD does not refer to a function&quot;, decl);</span>
<span class="lineNum">   38142 </span><span class="lineCov">         12 :           parser-&gt;oacc_routine = NULL;</span>
<span class="lineNum">   38143 </span>            :           return;
<span class="lineNum">   38144 </span><span class="lineCov">        111 :         }</span>
<span class="lineNum">   38145 </span><span class="lineCov">        111 : </span>
<span class="lineNum">   38146 </span>            :       cp_finalize_oacc_routine (parser, decl, false);
<span class="lineNum">   38147 </span><span class="lineCov">         42 :       parser-&gt;oacc_routine = NULL;</span>
<span class="lineNum">   38148 </span><span class="lineCov">         42 :     }</span>
<span class="lineNum">   38149 </span><span class="lineCov">         63 :   else /* No optional '( name )'.  */</span>
<span class="lineNum">   38150 </span>            :     {
<span class="lineNum">   38151 </span>            :       /* Store away all pragma tokens.  */
<span class="lineNum">   38152 </span><span class="lineCov">         69 :       while (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_PRAGMA_EOL)</span>
<span class="lineNum">   38153 </span><span class="lineCov">        759 :              &amp;&amp; cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_EOF))</span>
<span class="lineNum">   38154 </span>            :         cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   38155 </span>            :       if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_PRAGMA_EOL))
<span class="lineNum">   38156 </span>            :         parser-&gt;oacc_routine-&gt;error_seen = true;
<span class="lineNum">   38157 </span><span class="lineCov">         69 :       cp_parser_require_pragma_eol (parser, pragma_tok);</span>
<span class="lineNum">   38158 </span><span class="lineCov">        126 :       struct cp_token_cache *cp</span>
<span class="lineNum">   38159 </span>            :         = cp_token_cache_new (pragma_tok, cp_lexer_peek_token (parser-&gt;lexer));
<span class="lineNum">   38160 </span>            :       parser-&gt;oacc_routine-&gt;tokens.safe_push (cp);
<span class="lineNum">   38161 </span><span class="lineCov">          9 : </span>
<span class="lineNum">   38162 </span>            :       /* Emit a helpful diagnostic if there's another pragma following this
<span class="lineNum">   38163 </span><span class="lineCov">          9 :          one.  */</span>
<span class="lineNum">   38164 </span><span class="lineCov">          9 :       if (cp_lexer_next_token_is (parser-&gt;lexer, CPP_PRAGMA))</span>
<span class="lineNum">   38165 </span>            :         {
<span class="lineNum">   38166 </span>            :           cp_ensure_no_oacc_routine (parser);
<span class="lineNum">   38167 </span>            :           data.tokens.release ();
<span class="lineNum">   38168 </span>            :           /* ..., and then just keep going.  */
<span class="lineNum">   38169 </span><span class="lineCov">         60 :           return;</span>
<span class="lineNum">   38170 </span>            :         }
<span class="lineNum">   38171 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   38172 </span>            :       /* We only have to consider the pragma_external case here.  */
<span class="lineNum">   38173 </span><span class="lineNoCov">          0 :       cp_parser_declaration (parser);</span>
<span class="lineNum">   38174 </span><span class="lineNoCov">          0 :       if (parser-&gt;oacc_routine</span>
<span class="lineNum">   38175 </span>            :           &amp;&amp; !parser-&gt;oacc_routine-&gt;fndecl_seen)
<span class="lineNum">   38176 </span>            :         cp_ensure_no_oacc_routine (parser);
<span class="lineNum">   38177 </span><span class="lineCov">         60 :       else</span>
<span class="lineNum">   38178 </span>            :         parser-&gt;oacc_routine = NULL;
<span class="lineNum">   38179 </span><span class="lineCov">         12 :       data.tokens.release ();</span>
<span class="lineNum">   38180 </span><span class="lineCov">         12 :     }</span>
<span class="lineNum">   38181 </span><span class="lineCov">         12 : }</span>
<span class="lineNum">   38182 </span>            : 
<span class="lineNum">   38183 </span>            : /* Finalize #pragma acc routine clauses after direct declarator has
<span class="lineNum">   38184 </span><span class="lineCov">         48 :    been parsed.  */</span>
<a name="38185"><span class="lineNum">   38185 </span><span class="lineCov">         48 : </span></a>
<span class="lineNum">   38186 </span>            : static tree
<span class="lineNum">   38187 </span>            : cp_parser_late_parsing_oacc_routine (cp_parser *parser, tree attrs)
<span class="lineNum">   38188 </span>            : {
<span class="lineNum">   38189 </span>            :   struct cp_token_cache *ce;
<span class="lineNum">   38190 </span><span class="lineCov">        275 :   cp_oacc_routine_data *data = parser-&gt;oacc_routine;</span>
<span class="lineNum">   38191 </span><span class="lineCov">        580 : </span>
<span class="lineNum">   38192 </span><span class="lineCov">        275 :   if (!data-&gt;error_seen &amp;&amp; data-&gt;fndecl_seen)</span>
<span class="lineNum">   38193 </span><span class="lineCov">        305 :     {</span>
<span class="lineNum">   38194 </span><span class="lineNoCov">          0 :       error_at (data-&gt;loc,</span>
<span class="lineNum">   38195 </span><span class="lineCov">        305 :                 &quot;%&lt;#pragma acc routine%&gt; not immediately followed by &quot;</span>
<span class="lineNum">   38196 </span><span class="lineCov">        305 :                 &quot;a single function declaration or definition&quot;);</span>
<span class="lineNum">   38197 </span><span class="lineCov">        305 :       data-&gt;error_seen = true;</span>
<span class="lineNum">   38198 </span><span class="lineCov">        305 :     }</span>
<span class="lineNum">   38199 </span>            :   if (data-&gt;error_seen)
<span class="lineNum">   38200 </span>            :     return attrs;
<span class="lineNum">   38201 </span>            : 
<span class="lineNum">   38202 </span><span class="lineCov">        305 :   gcc_checking_assert (data-&gt;tokens.length () == 1);</span>
<span class="lineNum">   38203 </span>            :   ce = data-&gt;tokens[0];
<span class="lineNum">   38204 </span><span class="lineCov">         27 : </span>
<span class="lineNum">   38205 </span><span class="lineCov">         27 :   cp_parser_push_lexer_for_tokens (parser, ce);</span>
<span class="lineNum">   38206 </span>            :   parser-&gt;lexer-&gt;in_pragma = true;
<span class="lineNum">   38207 </span><span class="lineCov">         27 :   gcc_assert (cp_lexer_peek_token (parser-&gt;lexer)-&gt;type == CPP_PRAGMA);</span>
<span class="lineNum">   38208 </span>            : 
<span class="lineNum">   38209 </span>            :   cp_token *pragma_tok = cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   38210 </span>            :   gcc_checking_assert (parser-&gt;oacc_routine-&gt;clauses == NULL_TREE);
<span class="lineNum">   38211 </span><span class="lineCov">        278 :   parser-&gt;oacc_routine-&gt;clauses</span>
<span class="lineNum">   38212 </span><span class="lineCov">        278 :     = cp_parser_oacc_all_clauses (parser, OACC_ROUTINE_CLAUSE_MASK,</span>
<span class="lineNum">   38213 </span><span class="lineCov">         26 :                                   &quot;#pragma acc routine&quot;, pragma_tok);</span>
<span class="lineNum">   38214 </span><span class="lineCov">          5 :   cp_parser_pop_lexer (parser);</span>
<span class="lineNum">   38215 </span>            :   /* Later, cp_finalize_oacc_routine will process the clauses, and then set
<span class="lineNum">   38216 </span><span class="lineCov">        273 :      fndecl_seen.  */</span>
<span class="lineNum">   38217 </span><span class="lineCov">        556 : </span>
<span class="lineNum">   38218 </span>            :   return attrs;
<span class="lineNum">   38219 </span>            : }
<span class="lineNum">   38220 </span>            : 
<span class="lineNum">   38221 </span>            : /* Apply any saved OpenACC routine clauses to a just-parsed
<span class="lineNum">   38222 </span>            :    declaration.  */
<a name="38223"><span class="lineNum">   38223 </span>            : </a>
<span class="lineNum">   38224 </span>            : static void
<span class="lineNum">   38225 </span><span class="lineCov">        245 : cp_finalize_oacc_routine (cp_parser *parser, tree fndecl, bool is_defn)</span>
<span class="lineNum">   38226 </span>            : {
<span class="lineNum">   38227 </span><span class="lineCov">        245 :   if (__builtin_expect (parser-&gt;oacc_routine != NULL, 0))</span>
<span class="lineNum">   38228 </span><span class="lineCov">        245 :     {</span>
<span class="lineNum">   38229 </span>            :       /* Keep going if we're in error reporting mode.  */
<span class="lineNum">   38230 </span><span class="lineCov">        245 :       if (parser-&gt;oacc_routine-&gt;error_seen</span>
<span class="lineNum">   38231 </span>            :           || fndecl == error_mark_node)
<span class="lineNum">   38232 </span><span class="lineCov">          6 :         return;</span>
<span class="lineNum">   38233 </span>            : 
<span class="lineNum">   38234 </span>            :       if (parser-&gt;oacc_routine-&gt;fndecl_seen)
<span class="lineNum">   38235 </span><span class="lineCov">          6 :         {</span>
<span class="lineNum">   38236 </span>            :           error_at (parser-&gt;oacc_routine-&gt;loc,
<span class="lineNum">   38237 </span><span class="lineCov">        245 :                     &quot;%&lt;#pragma acc routine%&gt; not immediately followed by&quot;</span>
<span class="lineNum">   38238 </span>            :                     &quot; a single function declaration or definition&quot;);
<span class="lineNum">   38239 </span>            :           parser-&gt;oacc_routine = NULL;
<span class="lineNum">   38240 </span><span class="lineCov">        239 :           return;</span>
<span class="lineNum">   38241 </span><span class="lineCov">        239 :         }</span>
<span class="lineNum">   38242 </span>            :       if (TREE_CODE (fndecl) != FUNCTION_DECL)
<span class="lineNum">   38243 </span><span class="lineCov">        239 :         {</span>
<span class="lineNum">   38244 </span><span class="lineCov">        239 :           cp_ensure_no_oacc_routine (parser);</span>
<span class="lineNum">   38245 </span><span class="lineCov">        239 :           return;</span>
<span class="lineNum">   38246 </span>            :         }
<span class="lineNum">   38247 </span><span class="lineCov">        239 : </span>
<span class="lineNum">   38248 </span><span class="lineCov">        239 :       if (oacc_get_fn_attrib (fndecl))</span>
<span class="lineNum">   38249 </span><span class="lineCov">        239 :         {</span>
<span class="lineNum">   38250 </span><span class="lineCov">       2629 :           error_at (parser-&gt;oacc_routine-&gt;loc,</span>
<span class="lineNum">   38251 </span>            :                     &quot;%&lt;#pragma acc routine%&gt; already applied to %qD&quot;, fndecl);
<span class="lineNum">   38252 </span><span class="lineCov">        239 :           parser-&gt;oacc_routine = NULL;</span>
<span class="lineNum">   38253 </span>            :           return;
<span class="lineNum">   38254 </span>            :         }
<span class="lineNum">   38255 </span>            : 
<span class="lineNum">   38256 </span><span class="lineCov">        239 :       if (TREE_USED (fndecl) || (!is_defn &amp;&amp; DECL_SAVED_TREE (fndecl)))</span>
<span class="lineNum">   38257 </span>            :         {
<span class="lineNum">   38258 </span>            :           error_at (parser-&gt;oacc_routine-&gt;loc,
<span class="lineNum">   38259 </span>            :                     TREE_USED (fndecl)
<span class="lineNum">   38260 </span>            :                     ? G_(&quot;%&lt;#pragma acc routine%&gt; must be applied before use&quot;)
<span class="lineNum">   38261 </span>            :                     : G_(&quot;%&lt;#pragma acc routine%&gt; must be applied before &quot;
<span class="lineNum">   38262 </span>            :                          &quot;definition&quot;));
<span class="lineNum">   38263 </span><span class="lineCov">   17142195 :           parser-&gt;oacc_routine = NULL;</span>
<span class="lineNum">   38264 </span>            :           return;
<span class="lineNum">   38265 </span><span class="lineCov">   17142195 :         }</span>
<span class="lineNum">   38266 </span>            : 
<span class="lineNum">   38267 </span>            :       /* Process the routine's dimension clauses.  */
<span class="lineNum">   38268 </span><span class="lineCov">        324 :       tree dims = oacc_build_routine_dims (parser-&gt;oacc_routine-&gt;clauses);</span>
<span class="lineNum">   38269 </span><span class="lineCov">        318 :       oacc_replace_fn_attrib (fndecl, dims);</span>
<span class="lineNum">   38270 </span>            : 
<span class="lineNum">   38271 </span>            :       /* Add an &quot;omp declare target&quot; attribute.  */
<span class="lineNum">   38272 </span><span class="lineCov">        318 :       DECL_ATTRIBUTES (fndecl)</span>
<span class="lineNum">   38273 </span>            :         = tree_cons (get_identifier (&quot;omp declare target&quot;),
<span class="lineNum">   38274 </span><span class="lineCov">          6 :                      NULL_TREE, DECL_ATTRIBUTES (fndecl));</span>
<span class="lineNum">   38275 </span>            : 
<span class="lineNum">   38276 </span>            :       /* Don't unset parser-&gt;oacc_routine here: we may still need it to
<span class="lineNum">   38277 </span><span class="lineCov">          6 :          diagnose wrong usage.  But, remember that we've used this &quot;#pragma acc</span>
<span class="lineNum">   38278 </span><span class="lineCov">          6 :          routine&quot;.  */</span>
<span class="lineNum">   38279 </span>            :       parser-&gt;oacc_routine-&gt;fndecl_seen = true;
<span class="lineNum">   38280 </span><span class="lineCov">        312 :     }</span>
<span class="lineNum">   38281 </span>            : }
<span class="lineNum">   38282 </span><span class="lineCov">         25 : </span>
<span class="lineNum">   38283 </span><span class="lineCov">         25 : /* Main entry point to OpenMP statement pragmas.  */</span>
<a name="38284"><span class="lineNum">   38284 </span>            : </a>
<span class="lineNum">   38285 </span>            : static void
<span class="lineNum">   38286 </span><span class="lineCov">        287 : cp_parser_omp_construct (cp_parser *parser, cp_token *pragma_tok, bool *if_p)</span>
<span class="lineNum">   38287 </span>            : {
<span class="lineNum">   38288 </span><span class="lineCov">          6 :   tree stmt;</span>
<span class="lineNum">   38289 </span>            :   char p_name[sizeof &quot;#pragma omp teams distribute parallel for simd&quot;];
<span class="lineNum">   38290 </span><span class="lineCov">          6 :   omp_clause_mask mask (0);</span>
<span class="lineNum">   38291 </span><span class="lineCov">          6 : </span>
<span class="lineNum">   38292 </span>            :   switch (cp_parser_pragma_kind (pragma_tok))
<span class="lineNum">   38293 </span>            :     {
<span class="lineNum">   38294 </span><span class="lineCov">        281 :     case PRAGMA_OACC_ATOMIC:</span>
<span class="lineNum">   38295 </span>            :       cp_parser_omp_atomic (parser, pragma_tok);
<span class="lineNum">   38296 </span><span class="lineCov">          9 :       return;</span>
<span class="lineNum">   38297 </span>            :     case PRAGMA_OACC_CACHE:
<span class="lineNum">   38298 </span>            :       stmt = cp_parser_oacc_cache (parser, pragma_tok);
<span class="lineNum">   38299 </span>            :       break;
<span class="lineNum">   38300 </span>            :     case PRAGMA_OACC_DATA:
<span class="lineNum">   38301 </span><span class="lineCov">          6 :       stmt = cp_parser_oacc_data (parser, pragma_tok, if_p);</span>
<span class="lineNum">   38302 </span><span class="lineCov">          6 :       break;</span>
<span class="lineNum">   38303 </span>            :     case PRAGMA_OACC_ENTER_DATA:
<span class="lineNum">   38304 </span>            :       stmt = cp_parser_oacc_enter_exit_data (parser, pragma_tok, true);
<span class="lineNum">   38305 </span>            :       break;
<span class="lineNum">   38306 </span><span class="lineCov">        275 :     case PRAGMA_OACC_EXIT_DATA:</span>
<span class="lineNum">   38307 </span><span class="lineCov">        275 :       stmt = cp_parser_oacc_enter_exit_data (parser, pragma_tok, false);</span>
<span class="lineNum">   38308 </span>            :       break;
<span class="lineNum">   38309 </span>            :     case PRAGMA_OACC_HOST_DATA:
<span class="lineNum">   38310 </span><span class="lineCov">        275 :       stmt = cp_parser_oacc_host_data (parser, pragma_tok, if_p);</span>
<span class="lineNum">   38311 </span><span class="lineCov">        275 :       break;</span>
<span class="lineNum">   38312 </span><span class="lineCov">        275 :     case PRAGMA_OACC_KERNELS:</span>
<span class="lineNum">   38313 </span>            :     case PRAGMA_OACC_PARALLEL:
<span class="lineNum">   38314 </span>            :       strcpy (p_name, &quot;#pragma acc&quot;);
<span class="lineNum">   38315 </span>            :       stmt = cp_parser_oacc_kernels_parallel (parser, pragma_tok, p_name,
<span class="lineNum">   38316 </span>            :                                               if_p);
<span class="lineNum">   38317 </span><span class="lineCov">        275 :       break;</span>
<span class="lineNum">   38318 </span>            :     case PRAGMA_OACC_LOOP:
<span class="lineNum">   38319 </span>            :       strcpy (p_name, &quot;#pragma acc&quot;);
<span class="lineNum">   38320 </span>            :       stmt = cp_parser_oacc_loop (parser, pragma_tok, p_name, mask, NULL,
<span class="lineNum">   38321 </span>            :                                   if_p);
<span class="lineNum">   38322 </span>            :       break;
<span class="lineNum">   38323 </span>            :     case PRAGMA_OACC_UPDATE:
<span class="lineNum">   38324 </span><span class="lineCov">      14510 :       stmt = cp_parser_oacc_update (parser, pragma_tok);</span>
<span class="lineNum">   38325 </span>            :       break;
<span class="lineNum">   38326 </span><span class="lineCov">      14510 :     case PRAGMA_OACC_WAIT:</span>
<span class="lineNum">   38327 </span><span class="lineCov">      14510 :       stmt = cp_parser_oacc_wait (parser, pragma_tok);</span>
<span class="lineNum">   38328 </span><span class="lineCov">      14510 :       break;</span>
<span class="lineNum">   38329 </span>            :     case PRAGMA_OMP_ATOMIC:
<span class="lineNum">   38330 </span><span class="lineCov">      14510 :       cp_parser_omp_atomic (parser, pragma_tok);</span>
<span class="lineNum">   38331 </span>            :       return;
<span class="lineNum">   38332 </span><span class="lineCov">        197 :     case PRAGMA_OMP_CRITICAL:</span>
<span class="lineNum">   38333 </span><span class="lineCov">        197 :       stmt = cp_parser_omp_critical (parser, pragma_tok, if_p);</span>
<span class="lineNum">   38334 </span><span class="lineCov">       1694 :       break;</span>
<span class="lineNum">   38335 </span><span class="lineCov">        144 :     case PRAGMA_OMP_DISTRIBUTE:</span>
<span class="lineNum">   38336 </span><span class="lineCov">        144 :       strcpy (p_name, &quot;#pragma omp&quot;);</span>
<span class="lineNum">   38337 </span><span class="lineCov">        144 :       stmt = cp_parser_omp_distribute (parser, pragma_tok, p_name, mask, NULL,</span>
<span class="lineNum">   38338 </span><span class="lineCov">        455 :                                        if_p);</span>
<span class="lineNum">   38339 </span><span class="lineCov">        455 :       break;</span>
<span class="lineNum">   38340 </span><span class="lineCov">        455 :     case PRAGMA_OMP_FOR:</span>
<span class="lineNum">   38341 </span><span class="lineCov">        184 :       strcpy (p_name, &quot;#pragma omp&quot;);</span>
<span class="lineNum">   38342 </span><span class="lineCov">        184 :       stmt = cp_parser_omp_for (parser, pragma_tok, p_name, mask, NULL,</span>
<span class="lineNum">   38343 </span><span class="lineCov">        184 :                                 if_p);</span>
<span class="lineNum">   38344 </span><span class="lineCov">        175 :       break;</span>
<span class="lineNum">   38345 </span><span class="lineCov">        175 :     case PRAGMA_OMP_MASTER:</span>
<span class="lineNum">   38346 </span><span class="lineCov">        175 :       stmt = cp_parser_omp_master (parser, pragma_tok, if_p);</span>
<span class="lineNum">   38347 </span><span class="lineCov">         36 :       break;</span>
<span class="lineNum">   38348 </span><span class="lineCov">         36 :     case PRAGMA_OMP_PARALLEL:</span>
<span class="lineNum">   38349 </span><span class="lineCov">         36 :       strcpy (p_name, &quot;#pragma omp&quot;);</span>
<span class="lineNum">   38350 </span><span class="lineCov">       2664 :       stmt = cp_parser_omp_parallel (parser, pragma_tok, p_name, mask, NULL,</span>
<span class="lineNum">   38351 </span><span class="lineCov">       2664 :                                      if_p);</span>
<span class="lineNum">   38352 </span><span class="lineCov">       2664 :       break;</span>
<span class="lineNum">   38353 </span><span class="lineCov">       2664 :     case PRAGMA_OMP_SECTIONS:</span>
<span class="lineNum">   38354 </span>            :       strcpy (p_name, &quot;#pragma omp&quot;);
<span class="lineNum">   38355 </span><span class="lineCov">       2664 :       stmt = cp_parser_omp_sections (parser, pragma_tok, p_name, mask, NULL);</span>
<span class="lineNum">   38356 </span><span class="lineCov">       1732 :       break;</span>
<span class="lineNum">   38357 </span><span class="lineCov">       1732 :     case PRAGMA_OMP_SIMD:</span>
<span class="lineNum">   38358 </span><span class="lineCov">       1732 :       strcpy (p_name, &quot;#pragma omp&quot;);</span>
<span class="lineNum">   38359 </span>            :       stmt = cp_parser_omp_simd (parser, pragma_tok, p_name, mask, NULL,
<span class="lineNum">   38360 </span><span class="lineCov">       1732 :                                  if_p);</span>
<span class="lineNum">   38361 </span><span class="lineCov">        150 :       break;</span>
<span class="lineNum">   38362 </span><span class="lineCov">        150 :     case PRAGMA_OMP_SINGLE:</span>
<span class="lineNum">   38363 </span><span class="lineCov">        150 :       stmt = cp_parser_omp_single (parser, pragma_tok, if_p);</span>
<span class="lineNum">   38364 </span><span class="lineCov">        116 :       break;</span>
<span class="lineNum">   38365 </span><span class="lineCov">        116 :     case PRAGMA_OMP_TASK:</span>
<span class="lineNum">   38366 </span><span class="lineCov">        116 :       stmt = cp_parser_omp_task (parser, pragma_tok, if_p);</span>
<span class="lineNum">   38367 </span><span class="lineCov">       1497 :       break;</span>
<span class="lineNum">   38368 </span><span class="lineCov">       1497 :     case PRAGMA_OMP_TASKGROUP:</span>
<span class="lineNum">   38369 </span><span class="lineCov">       1497 :       stmt = cp_parser_omp_taskgroup (parser, pragma_tok, if_p);</span>
<span class="lineNum">   38370 </span><span class="lineCov">        129 :       break;</span>
<span class="lineNum">   38371 </span><span class="lineCov">        129 :     case PRAGMA_OMP_TASKLOOP:</span>
<span class="lineNum">   38372 </span><span class="lineCov">        129 :       strcpy (p_name, &quot;#pragma omp&quot;);</span>
<span class="lineNum">   38373 </span><span class="lineCov">        532 :       stmt = cp_parser_omp_taskloop (parser, pragma_tok, p_name, mask, NULL,</span>
<span class="lineNum">   38374 </span><span class="lineCov">        532 :                                      if_p);</span>
<span class="lineNum">   38375 </span><span class="lineCov">        532 :       break;</span>
<span class="lineNum">   38376 </span>            :     case PRAGMA_OMP_TEAMS:
<span class="lineNum">   38377 </span><span class="lineCov">        532 :       strcpy (p_name, &quot;#pragma omp&quot;);</span>
<span class="lineNum">   38378 </span><span class="lineCov">       1842 :       stmt = cp_parser_omp_teams (parser, pragma_tok, p_name, mask, NULL,</span>
<span class="lineNum">   38379 </span><span class="lineCov">       1842 :                                   if_p);</span>
<span class="lineNum">   38380 </span><span class="lineCov">       1842 :       break;</span>
<span class="lineNum">   38381 </span>            :     default:
<span class="lineNum">   38382 </span><span class="lineCov">       1842 :       gcc_unreachable ();</span>
<span class="lineNum">   38383 </span><span class="lineCov">        112 :     }</span>
<span class="lineNum">   38384 </span><span class="lineCov">        112 : </span>
<span class="lineNum">   38385 </span><span class="lineCov">        112 :   protected_set_expr_location (stmt, pragma_tok-&gt;location);</span>
<span class="lineNum">   38386 </span><span class="lineCov">       2342 : }</span>
<span class="lineNum">   38387 </span><span class="lineCov">       2342 : </span>
<span class="lineNum">   38388 </span><span class="lineCov">       2342 : /* Transactional Memory parsing routines.  */</span>
<span class="lineNum">   38389 </span>            : 
<span class="lineNum">   38390 </span><span class="lineCov">       2342 : /* Parse a transaction attribute.</span>
<span class="lineNum">   38391 </span><span class="lineCov">        188 : </span>
<span class="lineNum">   38392 </span><span class="lineCov">        188 :    txn-attribute:</span>
<span class="lineNum">   38393 </span><span class="lineCov">        188 :         attribute</span>
<span class="lineNum">   38394 </span><span class="lineCov">        188 :         [ [ identifier ] ]</span>
<span class="lineNum">   38395 </span><span class="lineCov">        360 : </span>
<span class="lineNum">   38396 </span><span class="lineCov">        360 :    We use this instead of cp_parser_attributes_opt for transactions to avoid</span>
<span class="lineNum">   38397 </span><span class="lineCov">        360 :    the pedwarn in C++98 mode.  */</span>
<a name="38398"><span class="lineNum">   38398 </span>            : </a>
<span class="lineNum">   38399 </span><span class="lineCov">        360 : static tree</span>
<span class="lineNum">   38400 </span><span class="lineCov">        254 : cp_parser_txn_attribute_opt (cp_parser *parser)</span>
<span class="lineNum">   38401 </span><span class="lineCov">        254 : {</span>
<span class="lineNum">   38402 </span><span class="lineCov">        254 :   cp_token *token;</span>
<span class="lineNum">   38403 </span><span class="lineCov">        590 :   tree attr_name, attr = NULL;</span>
<span class="lineNum">   38404 </span><span class="lineCov">        590 : </span>
<span class="lineNum">   38405 </span><span class="lineCov">        590 :   if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_ATTRIBUTE))</span>
<span class="lineNum">   38406 </span><span class="lineCov">         44 :     return cp_parser_attributes_opt (parser);</span>
<span class="lineNum">   38407 </span><span class="lineCov">         44 : </span>
<span class="lineNum">   38408 </span><span class="lineCov">         44 :   if (cp_lexer_next_token_is_not (parser-&gt;lexer, CPP_OPEN_SQUARE))</span>
<span class="lineNum">   38409 </span><span class="lineCov">        210 :     return NULL_TREE;</span>
<span class="lineNum">   38410 </span><span class="lineCov">        210 :   cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   38411 </span><span class="lineCov">        210 :   if (!cp_parser_require (parser, CPP_OPEN_SQUARE, RT_OPEN_SQUARE))</span>
<span class="lineNum">   38412 </span>            :     goto error1;
<span class="lineNum">   38413 </span><span class="lineCov">        210 : </span>
<span class="lineNum">   38414 </span><span class="lineCov">        557 :   token = cp_lexer_peek_token (parser-&gt;lexer);</span>
<span class="lineNum">   38415 </span><span class="lineCov">        557 :   if (token-&gt;type == CPP_NAME || token-&gt;type == CPP_KEYWORD)</span>
<span class="lineNum">   38416 </span><span class="lineCov">        557 :     {</span>
<span class="lineNum">   38417 </span>            :       token = cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   38418 </span><span class="lineCov">        557 : </span>
<span class="lineNum">   38419 </span><span class="lineNoCov">          0 :       attr_name = (token-&gt;type == CPP_KEYWORD</span>
<span class="lineNum">   38420 </span><span class="lineNoCov">          0 :                    /* For keywords, use the canonical spelling,</span>
<span class="lineNum">   38421 </span>            :                       not the parsed identifier.  */
<span class="lineNum">   38422 </span>            :                    ? ridpointers[(int) token-&gt;keyword]
<span class="lineNum">   38423 </span><span class="lineCov">      12816 :                    : token-&gt;u.value);</span>
<span class="lineNum">   38424 </span>            :       attr = build_tree_list (attr_name, NULL_TREE);
<span class="lineNum">   38425 </span>            :     }
<span class="lineNum">   38426 </span>            :   else
<span class="lineNum">   38427 </span>            :     cp_parser_error (parser, &quot;expected identifier&quot;);
<span class="lineNum">   38428 </span>            : 
<span class="lineNum">   38429 </span>            :   cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);
<span class="lineNum">   38430 </span>            :  error1:
<span class="lineNum">   38431 </span>            :   cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);
<span class="lineNum">   38432 </span>            :   return attr;
<span class="lineNum">   38433 </span>            : }
<span class="lineNum">   38434 </span>            : 
<span class="lineNum">   38435 </span>            : /* Parse a __transaction_atomic or __transaction_relaxed statement.
<span class="lineNum">   38436 </span>            : 
<span class="lineNum">   38437 </span>            :    transaction-statement:
<span class="lineNum">   38438 </span><span class="lineCov">        203 :      __transaction_atomic txn-attribute[opt] txn-noexcept-spec[opt]</span>
<span class="lineNum">   38439 </span>            :        compound-statement
<span class="lineNum">   38440 </span><span class="lineCov">        203 :      __transaction_relaxed txn-noexcept-spec[opt] compound-statement</span>
<span class="lineNum">   38441 </span><span class="lineCov">        203 : */</span>
<a name="38442"><span class="lineNum">   38442 </span>            : </a>
<span class="lineNum">   38443 </span><span class="lineCov">        203 : static tree</span>
<span class="lineNum">   38444 </span><span class="lineCov">          4 : cp_parser_transaction (cp_parser *parser, cp_token *token)</span>
<span class="lineNum">   38445 </span>            : {
<span class="lineNum">   38446 </span><span class="lineCov">        199 :   unsigned char old_in = parser-&gt;in_transaction;</span>
<span class="lineNum">   38447 </span>            :   unsigned char this_in = 1, new_in;
<span class="lineNum">   38448 </span><span class="lineCov">         19 :   enum rid keyword = token-&gt;keyword;</span>
<span class="lineNum">   38449 </span><span class="lineCov">         19 :   tree stmt, attrs, noex;</span>
<span class="lineNum">   38450 </span>            : 
<span class="lineNum">   38451 </span>            :   cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   38452 </span><span class="lineCov">         38 : </span>
<span class="lineNum">   38453 </span><span class="lineCov">         19 :   if (keyword == RID_TRANSACTION_RELAXED</span>
<span class="lineNum">   38454 </span>            :       || keyword == RID_SYNCHRONIZED)
<span class="lineNum">   38455 </span><span class="lineCov">         19 :     this_in |= TM_STMT_ATTR_RELAXED;</span>
<span class="lineNum">   38456 </span>            :   else
<span class="lineNum">   38457 </span><span class="lineCov">         38 :     {</span>
<span class="lineNum">   38458 </span>            :       attrs = cp_parser_txn_attribute_opt (parser);
<span class="lineNum">   38459 </span>            :       if (attrs)
<span class="lineNum">   38460 </span><span class="lineCov">         19 :         this_in |= parse_tm_stmt_attr (attrs, TM_STMT_ATTR_OUTER);</span>
<span class="lineNum">   38461 </span>            :     }
<span class="lineNum">   38462 </span><span class="lineCov">         19 : </span>
<span class="lineNum">   38463 </span>            :   /* Parse a noexcept specification.  */
<span class="lineNum">   38464 </span>            :   if (keyword == RID_ATOMIC_NOEXCEPT)
<span class="lineNum">   38465 </span><span class="lineNoCov">          0 :     noex = boolean_true_node;</span>
<span class="lineNum">   38466 </span>            :   else if (keyword == RID_ATOMIC_CANCEL)
<span class="lineNum">   38467 </span><span class="lineCov">         19 :     {</span>
<span class="lineNum">   38468 </span><span class="lineCov">         19 :       /* cancel-and-throw is unimplemented.  */</span>
<span class="lineNum">   38469 </span><span class="lineCov">         19 :       sorry (&quot;atomic_cancel&quot;);</span>
<span class="lineNum">   38470 </span><span class="lineCov">         19 :       noex = NULL_TREE;</span>
<span class="lineNum">   38471 </span>            :     }
<span class="lineNum">   38472 </span>            :   else
<span class="lineNum">   38473 </span>            :     noex = cp_parser_noexcept_specification_opt (parser, true, NULL, true);
<span class="lineNum">   38474 </span>            : 
<span class="lineNum">   38475 </span>            :   /* Keep track if we're in the lexical scope of an outer transaction.  */
<span class="lineNum">   38476 </span>            :   new_in = this_in | (old_in &amp; TM_STMT_ATTR_OUTER);
<span class="lineNum">   38477 </span>            : 
<span class="lineNum">   38478 </span>            :   stmt = begin_transaction_stmt (token-&gt;location, NULL, this_in);
<span class="lineNum">   38479 </span>            : 
<span class="lineNum">   38480 </span>            :   parser-&gt;in_transaction = new_in;
<span class="lineNum">   38481 </span>            :   cp_parser_compound_statement (parser, NULL, BCS_TRANSACTION, false);
<span class="lineNum">   38482 </span><span class="lineCov">        222 :   parser-&gt;in_transaction = old_in;</span>
<span class="lineNum">   38483 </span>            : 
<span class="lineNum">   38484 </span><span class="lineCov">        222 :   finish_transaction_stmt (stmt, NULL, this_in, noex);</span>
<span class="lineNum">   38485 </span><span class="lineCov">        222 : </span>
<span class="lineNum">   38486 </span><span class="lineCov">        222 :   return stmt;</span>
<span class="lineNum">   38487 </span><span class="lineCov">        222 : }</span>
<span class="lineNum">   38488 </span>            : 
<span class="lineNum">   38489 </span><span class="lineCov">        222 : /* Parse a __transaction_atomic or __transaction_relaxed expression.</span>
<span class="lineNum">   38490 </span>            : 
<span class="lineNum">   38491 </span><span class="lineCov">        444 :    transaction-expression:</span>
<span class="lineNum">   38492 </span><span class="lineCov">        222 :      __transaction_atomic txn-noexcept-spec[opt] ( expression )</span>
<span class="lineNum">   38493 </span>            :      __transaction_relaxed txn-noexcept-spec[opt] ( expression )
<span class="lineNum">   38494 </span>            : */
<a name="38495"><span class="lineNum">   38495 </span>            : </a>
<span class="lineNum">   38496 </span><span class="lineCov">        174 : static tree</span>
<span class="lineNum">   38497 </span><span class="lineCov">        174 : cp_parser_transaction_expression (cp_parser *parser, enum rid keyword)</span>
<span class="lineNum">   38498 </span><span class="lineCov">         15 : {</span>
<span class="lineNum">   38499 </span>            :   unsigned char old_in = parser-&gt;in_transaction;
<span class="lineNum">   38500 </span>            :   unsigned char this_in = 1;
<span class="lineNum">   38501 </span>            :   cp_token *token;
<span class="lineNum">   38502 </span><span class="lineCov">        222 :   tree expr, noex;</span>
<span class="lineNum">   38503 </span><span class="lineCov">          3 :   bool noex_expr;</span>
<span class="lineNum">   38504 </span><span class="lineCov">        219 :   location_t loc = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;</span>
<span class="lineNum">   38505 </span>            : 
<span class="lineNum">   38506 </span>            :   gcc_assert (keyword == RID_TRANSACTION_ATOMIC
<span class="lineNum">   38507 </span><span class="lineNoCov">          0 :       || keyword == RID_TRANSACTION_RELAXED);</span>
<span class="lineNum">   38508 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   38509 </span>            :   if (!flag_tm)
<span class="lineNum">   38510 </span>            :     error_at (loc,
<span class="lineNum">   38511 </span><span class="lineCov">        219 :               keyword == RID_TRANSACTION_RELAXED</span>
<span class="lineNum">   38512 </span>            :               ? G_(&quot;%&lt;__transaction_relaxed%&gt; without transactional memory &quot;
<span class="lineNum">   38513 </span>            :                   &quot;support enabled&quot;)
<span class="lineNum">   38514 </span><span class="lineCov">        222 :               : G_(&quot;%&lt;__transaction_atomic%&gt; without transactional memory &quot;</span>
<span class="lineNum">   38515 </span>            :                    &quot;support enabled&quot;));
<span class="lineNum">   38516 </span><span class="lineCov">        222 : </span>
<span class="lineNum">   38517 </span>            :   token = cp_parser_require_keyword (parser, keyword,
<span class="lineNum">   38518 </span><span class="lineCov">        222 :       (keyword == RID_TRANSACTION_ATOMIC ? RT_TRANSACTION_ATOMIC</span>
<span class="lineNum">   38519 </span><span class="lineCov">        222 :           : RT_TRANSACTION_RELAXED));</span>
<span class="lineNum">   38520 </span><span class="lineCov">        222 :   gcc_assert (token != NULL);</span>
<span class="lineNum">   38521 </span>            : 
<span class="lineNum">   38522 </span><span class="lineCov">        222 :   if (keyword == RID_TRANSACTION_RELAXED)</span>
<span class="lineNum">   38523 </span>            :     this_in |= TM_STMT_ATTR_RELAXED;
<span class="lineNum">   38524 </span><span class="lineCov">        222 : </span>
<span class="lineNum">   38525 </span>            :   /* Set this early.  This might mean that we allow transaction_cancel in
<span class="lineNum">   38526 </span>            :      an expression that we find out later actually has to be a constexpr.
<span class="lineNum">   38527 </span>            :      However, we expect that cxx_constant_value will be able to deal with
<span class="lineNum">   38528 </span>            :      this; also, if the noexcept has no constexpr, then what we parse next
<span class="lineNum">   38529 </span>            :      really is a transaction's body.  */
<span class="lineNum">   38530 </span>            :   parser-&gt;in_transaction = this_in;
<span class="lineNum">   38531 </span>            : 
<span class="lineNum">   38532 </span>            :   /* Parse a noexcept specification.  */
<span class="lineNum">   38533 </span>            :   noex = cp_parser_noexcept_specification_opt (parser, false, &amp;noex_expr,
<span class="lineNum">   38534 </span>            :                                                true);
<span class="lineNum">   38535 </span><span class="lineCov">         62 : </span>
<span class="lineNum">   38536 </span>            :   if (!noex || !noex_expr
<span class="lineNum">   38537 </span><span class="lineCov">         62 :       || cp_lexer_peek_token (parser-&gt;lexer)-&gt;type == CPP_OPEN_PAREN)</span>
<span class="lineNum">   38538 </span><span class="lineCov">         62 :     {</span>
<span class="lineNum">   38539 </span><span class="lineCov">         62 :       matching_parens parens;</span>
<span class="lineNum">   38540 </span><span class="lineCov">         62 :       parens.require_open (parser);</span>
<span class="lineNum">   38541 </span><span class="lineCov">         62 : </span>
<span class="lineNum">   38542 </span><span class="lineCov">        124 :       expr = cp_parser_expression (parser);</span>
<span class="lineNum">   38543 </span>            :       expr = finish_parenthesized_expr (expr);
<span class="lineNum">   38544 </span><span class="lineCov">         62 : </span>
<span class="lineNum">   38545 </span>            :       parens.require_close (parser);
<span class="lineNum">   38546 </span>            :     }
<span class="lineNum">   38547 </span><span class="lineCov">         62 :   else</span>
<span class="lineNum">   38548 </span><span class="lineCov">         12 :     {</span>
<span class="lineNum">   38549 </span>            :       /* The only expression that is available got parsed for the noexcept
<span class="lineNum">   38550 </span>            :          already.  noexcept is true then.  */
<span class="lineNum">   38551 </span>            :       expr = noex;
<span class="lineNum">   38552 </span>            :       noex = boolean_true_node;
<span class="lineNum">   38553 </span>            :     }
<span class="lineNum">   38554 </span>            : 
<span class="lineNum">   38555 </span><span class="lineCov">         66 :   expr = build_transaction_expr (token-&gt;location, expr, this_in, noex);</span>
<span class="lineNum">   38556 </span>            :   parser-&gt;in_transaction = old_in;
<span class="lineNum">   38557 </span>            : 
<span class="lineNum">   38558 </span><span class="lineCov">         62 :   if (cp_parser_non_integral_constant_expression (parser, NIC_TRANSACTION))</span>
<span class="lineNum">   38559 </span>            :     return error_mark_node;
<span class="lineNum">   38560 </span><span class="lineCov">         62 : </span>
<span class="lineNum">   38561 </span><span class="lineCov">          4 :   return (flag_tm ? expr : error_mark_node);</span>
<span class="lineNum">   38562 </span>            : }
<span class="lineNum">   38563 </span>            : 
<span class="lineNum">   38564 </span>            : /* Parse a function-transaction-block.
<span class="lineNum">   38565 </span>            : 
<span class="lineNum">   38566 </span>            :    function-transaction-block:
<span class="lineNum">   38567 </span>            :      __transaction_atomic txn-attribute[opt] ctor-initializer[opt]
<span class="lineNum">   38568 </span><span class="lineCov">         62 :          function-body</span>
<span class="lineNum">   38569 </span>            :      __transaction_atomic txn-attribute[opt] function-try-block
<span class="lineNum">   38570 </span>            :      __transaction_relaxed ctor-initializer[opt] function-body
<span class="lineNum">   38571 </span><span class="lineCov">         62 :      __transaction_relaxed function-try-block</span>
<span class="lineNum">   38572 </span>            : */
<a name="38573"><span class="lineNum">   38573 </span>            : </a>
<span class="lineNum">   38574 </span><span class="lineCov">         38 : static void</span>
<span class="lineNum">   38575 </span><span class="lineCov">        100 : cp_parser_function_transaction (cp_parser *parser, enum rid keyword)</span>
<span class="lineNum">   38576 </span>            : {
<span class="lineNum">   38577 </span><span class="lineCov">        108 :   unsigned char old_in = parser-&gt;in_transaction;</span>
<span class="lineNum">   38578 </span><span class="lineCov">         54 :   unsigned char new_in = 1;</span>
<span class="lineNum">   38579 </span>            :   tree compound_stmt, stmt, attrs;
<span class="lineNum">   38580 </span><span class="lineCov">         54 :   cp_token *token;</span>
<span class="lineNum">   38581 </span><span class="lineCov">         54 : </span>
<span class="lineNum">   38582 </span>            :   gcc_assert (keyword == RID_TRANSACTION_ATOMIC
<span class="lineNum">   38583 </span><span class="lineCov">         54 :       || keyword == RID_TRANSACTION_RELAXED);</span>
<span class="lineNum">   38584 </span>            :   token = cp_parser_require_keyword (parser, keyword,
<span class="lineNum">   38585 </span>            :       (keyword == RID_TRANSACTION_ATOMIC ? RT_TRANSACTION_ATOMIC
<span class="lineNum">   38586 </span>            :           : RT_TRANSACTION_RELAXED));
<span class="lineNum">   38587 </span>            :   gcc_assert (token != NULL);
<span class="lineNum">   38588 </span>            : 
<span class="lineNum">   38589 </span><span class="lineCov">          8 :   if (keyword == RID_TRANSACTION_RELAXED)</span>
<span class="lineNum">   38590 </span><span class="lineCov">          8 :     new_in |= TM_STMT_ATTR_RELAXED;</span>
<span class="lineNum">   38591 </span>            :   else
<span class="lineNum">   38592 </span>            :     {
<span class="lineNum">   38593 </span><span class="lineCov">         62 :       attrs = cp_parser_txn_attribute_opt (parser);</span>
<span class="lineNum">   38594 </span><span class="lineCov">         62 :       if (attrs)</span>
<span class="lineNum">   38595 </span>            :         new_in |= parse_tm_stmt_attr (attrs, TM_STMT_ATTR_OUTER);
<span class="lineNum">   38596 </span><span class="lineCov">         62 :     }</span>
<span class="lineNum">   38597 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   38598 </span>            :   stmt = begin_transaction_stmt (token-&gt;location, &amp;compound_stmt, new_in);
<span class="lineNum">   38599 </span><span class="lineCov">         62 : </span>
<span class="lineNum">   38600 </span>            :   parser-&gt;in_transaction = new_in;
<span class="lineNum">   38601 </span>            : 
<span class="lineNum">   38602 </span>            :   if (cp_lexer_next_token_is_keyword (parser-&gt;lexer, RID_TRY))
<span class="lineNum">   38603 </span>            :     cp_parser_function_try_block (parser);
<span class="lineNum">   38604 </span>            :   else
<span class="lineNum">   38605 </span>            :     cp_parser_ctor_initializer_opt_and_function_body
<span class="lineNum">   38606 </span>            :       (parser, /*in_function_try_block=*/false);
<span class="lineNum">   38607 </span>            : 
<span class="lineNum">   38608 </span>            :   parser-&gt;in_transaction = old_in;
<span class="lineNum">   38609 </span>            : 
<span class="lineNum">   38610 </span>            :   finish_transaction_stmt (stmt, compound_stmt, new_in, NULL_TREE);
<span class="lineNum">   38611 </span>            : }
<span class="lineNum">   38612 </span>            : 
<span class="lineNum">   38613 </span><span class="lineCov">         17 : /* Parse a __transaction_cancel statement.</span>
<span class="lineNum">   38614 </span>            : 
<span class="lineNum">   38615 </span><span class="lineCov">         17 :    cancel-statement:</span>
<span class="lineNum">   38616 </span><span class="lineCov">         17 :      __transaction_cancel txn-attribute[opt] ;</span>
<span class="lineNum">   38617 </span><span class="lineCov">         17 :      __transaction_cancel txn-attribute[opt] throw-expression ;</span>
<span class="lineNum">   38618 </span><span class="lineCov">         17 : </span>
<span class="lineNum">   38619 </span>            :    ??? Cancel and throw is not yet implemented.  */
<a name="38620"><span class="lineNum">   38620 </span><span class="lineCov">         17 : </span></a>
<span class="lineNum">   38621 </span>            : static tree
<span class="lineNum">   38622 </span><span class="lineCov">         17 : cp_parser_transaction_cancel (cp_parser *parser)</span>
<span class="lineNum">   38623 </span>            : {
<span class="lineNum">   38624 </span>            :   cp_token *token;
<span class="lineNum">   38625 </span><span class="lineCov">         17 :   bool is_outer = false;</span>
<span class="lineNum">   38626 </span>            :   tree stmt, attrs;
<span class="lineNum">   38627 </span><span class="lineCov">         17 : </span>
<span class="lineNum">   38628 </span>            :   token = cp_parser_require_keyword (parser, RID_TRANSACTION_CANCEL,
<span class="lineNum">   38629 </span>            :                                      RT_TRANSACTION_CANCEL);
<span class="lineNum">   38630 </span>            :   gcc_assert (token != NULL);
<span class="lineNum">   38631 </span><span class="lineCov">         17 : </span>
<span class="lineNum">   38632 </span><span class="lineCov">         17 :   attrs = cp_parser_txn_attribute_opt (parser);</span>
<span class="lineNum">   38633 </span><span class="lineCov">          8 :   if (attrs)</span>
<span class="lineNum">   38634 </span>            :     is_outer = (parse_tm_stmt_attr (attrs, TM_STMT_ATTR_OUTER) != 0);
<span class="lineNum">   38635 </span>            : 
<span class="lineNum">   38636 </span><span class="lineCov">         17 :   /* ??? Parse cancel-and-throw here.  */</span>
<span class="lineNum">   38637 </span>            : 
<span class="lineNum">   38638 </span><span class="lineCov">         17 :   cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);</span>
<span class="lineNum">   38639 </span>            : 
<span class="lineNum">   38640 </span><span class="lineCov">         17 :   if (!flag_tm)</span>
<span class="lineNum">   38641 </span><span class="lineCov">          8 :     {</span>
<span class="lineNum">   38642 </span>            :       error_at (token-&gt;location, &quot;%&lt;__transaction_cancel%&gt; without &quot;
<span class="lineNum">   38643 </span><span class="lineCov">          9 :                 &quot;transactional memory support enabled&quot;);</span>
<span class="lineNum">   38644 </span><span class="lineCov">          9 :       return error_mark_node;</span>
<span class="lineNum">   38645 </span>            :     }
<span class="lineNum">   38646 </span><span class="lineCov">         17 :   else if (parser-&gt;in_transaction &amp; TM_STMT_ATTR_RELAXED)</span>
<span class="lineNum">   38647 </span>            :     {
<span class="lineNum">   38648 </span><span class="lineCov">         17 :       error_at (token-&gt;location, &quot;%&lt;__transaction_cancel%&gt; within a &quot;</span>
<span class="lineNum">   38649 </span><span class="lineCov">         17 :                 &quot;%&lt;__transaction_relaxed%&gt;&quot;);</span>
<span class="lineNum">   38650 </span>            :       return error_mark_node;
<span class="lineNum">   38651 </span>            :     }
<span class="lineNum">   38652 </span>            :   else if (is_outer)
<span class="lineNum">   38653 </span>            :     {
<span class="lineNum">   38654 </span>            :       if ((parser-&gt;in_transaction &amp; TM_STMT_ATTR_OUTER) == 0
<span class="lineNum">   38655 </span>            :           &amp;&amp; !is_tm_may_cancel_outer (current_function_decl))
<span class="lineNum">   38656 </span>            :         {
<span class="lineNum">   38657 </span>            :           error_at (token-&gt;location, &quot;outer %&lt;__transaction_cancel%&gt; not &quot;
<span class="lineNum">   38658 </span>            :                     &quot;within outer %&lt;__transaction_atomic%&gt;&quot;);
<span class="lineNum">   38659 </span>            :           error_at (token-&gt;location,
<span class="lineNum">   38660 </span><span class="lineCov">         12 :                     &quot;  or a %&lt;transaction_may_cancel_outer%&gt; function&quot;);</span>
<span class="lineNum">   38661 </span>            :           return error_mark_node;
<span class="lineNum">   38662 </span><span class="lineCov">         12 :         }</span>
<span class="lineNum">   38663 </span><span class="lineCov">         12 :     }</span>
<span class="lineNum">   38664 </span><span class="lineCov">         12 :   else if (parser-&gt;in_transaction == 0)</span>
<span class="lineNum">   38665 </span>            :     {
<span class="lineNum">   38666 </span><span class="lineCov">         12 :       error_at (token-&gt;location, &quot;%&lt;__transaction_cancel%&gt; not within &quot;</span>
<span class="lineNum">   38667 </span>            :                 &quot;%&lt;__transaction_atomic%&gt;&quot;);
<span class="lineNum">   38668 </span><span class="lineCov">         12 :       return error_mark_node;</span>
<span class="lineNum">   38669 </span>            :     }
<span class="lineNum">   38670 </span><span class="lineCov">         12 : </span>
<span class="lineNum">   38671 </span><span class="lineCov">         12 :   stmt = build_tm_abort_call (token-&gt;location, is_outer);</span>
<span class="lineNum">   38672 </span><span class="lineNoCov">          0 :   add_stmt (stmt);</span>
<span class="lineNum">   38673 </span>            : 
<span class="lineNum">   38674 </span>            :   return stmt;
<span class="lineNum">   38675 </span>            : }
<span class="lineNum">   38676 </span><span class="lineCov">         12 : </span>
<span class="lineNum">   38677 </span>            : /* The parser.  */
<span class="lineNum">   38678 </span><span class="lineCov">         12 : </span>
<span class="lineNum">   38679 </span>            : static GTY (()) cp_parser *the_parser;
<span class="lineNum">   38680 </span><span class="lineCov">          6 : </span>
<span class="lineNum">   38681 </span>            : 
<span class="lineNum">   38682 </span><span class="lineCov">          6 : /* Special handling for the first token or line in the file.  The first</span>
<span class="lineNum">   38683 </span>            :    thing in the file might be #pragma GCC pch_preprocess, which loads a
<span class="lineNum">   38684 </span><span class="lineCov">          6 :    PCH file, which is a GC collection point.  So we need to handle this</span>
<span class="lineNum">   38685 </span>            :    first pragma without benefit of an existing lexer structure.
<span class="lineNum">   38686 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   38687 </span>            :    Always returns one token to the caller in *FIRST_TOKEN.  This is
<span class="lineNum">   38688 </span><span class="lineNoCov">          0 :    either the true first token of the file, or the first token after</span>
<span class="lineNum">   38689 </span>            :    the initial pragma.  */
<a name="38690"><span class="lineNum">   38690 </span><span class="lineCov">          6 : </span></a>
<span class="lineNum">   38691 </span>            : static void
<span class="lineNum">   38692 </span><span class="lineNoCov">          0 : cp_parser_initial_pragma (cp_token *first_token)</span>
<span class="lineNum">   38693 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">   38694 </span>            :   tree name = NULL;
<span class="lineNum">   38695 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   38696 </span>            :   cp_lexer_get_preprocessor_token (NULL, first_token);
<span class="lineNum">   38697 </span><span class="lineNoCov">          0 :   if (cp_parser_pragma_kind (first_token) != PRAGMA_GCC_PCH_PREPROCESS)</span>
<span class="lineNum">   38698 </span>            :     return;
<span class="lineNum">   38699 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   38700 </span>            :   cp_lexer_get_preprocessor_token (NULL, first_token);
<span class="lineNum">   38701 </span>            :   if (first_token-&gt;type == CPP_STRING)
<span class="lineNum">   38702 </span><span class="lineCov">          6 :     {</span>
<span class="lineNum">   38703 </span>            :       name = first_token-&gt;u.value;
<span class="lineNum">   38704 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   38705 </span>            :       cp_lexer_get_preprocessor_token (NULL, first_token);
<span class="lineNum">   38706 </span><span class="lineNoCov">          0 :       if (first_token-&gt;type != CPP_PRAGMA_EOL)</span>
<span class="lineNum">   38707 </span>            :         error_at (first_token-&gt;location,
<span class="lineNum">   38708 </span>            :                   &quot;junk at end of %&lt;#pragma GCC pch_preprocess%&gt;&quot;);
<span class="lineNum">   38709 </span><span class="lineCov">          6 :     }</span>
<span class="lineNum">   38710 </span><span class="lineCov">          6 :   else</span>
<span class="lineNum">   38711 </span>            :     error_at (first_token-&gt;location, &quot;expected string literal&quot;);
<span class="lineNum">   38712 </span><span class="lineCov">          6 : </span>
<span class="lineNum">   38713 </span>            :   /* Skip to the end of the pragma.  */
<span class="lineNum">   38714 </span>            :   while (first_token-&gt;type != CPP_PRAGMA_EOL &amp;&amp; first_token-&gt;type != CPP_EOF)
<span class="lineNum">   38715 </span>            :     cp_lexer_get_preprocessor_token (NULL, first_token);
<span class="lineNum">   38716 </span>            : 
<span class="lineNum">   38717 </span>            :   /* Now actually load the PCH file.  */
<span class="lineNum">   38718 </span>            :   if (name)
<span class="lineNum">   38719 </span>            :     c_common_pch_pragma (parse_in, TREE_STRING_POINTER (name));
<span class="lineNum">   38720 </span>            : 
<span class="lineNum">   38721 </span>            :   /* Read one more token to return to our caller.  We have to do this
<span class="lineNum">   38722 </span>            :      after reading the PCH file in, since its pointers have to be
<span class="lineNum">   38723 </span>            :      live.  */
<span class="lineNum">   38724 </span>            :   cp_lexer_get_preprocessor_token (NULL, first_token);
<span class="lineNum">   38725 </span>            : }
<span class="lineNum">   38726 </span>            : 
<span class="lineNum">   38727 </span>            : /* Parse a pragma GCC ivdep.  */
<a name="38728"><span class="lineNum">   38728 </span>            : </a>
<span class="lineNum">   38729 </span>            : static bool
<span class="lineNum">   38730 </span><span class="lineCov">      56260 : cp_parser_pragma_ivdep (cp_parser *parser, cp_token *pragma_tok)</span>
<span class="lineNum">   38731 </span>            : {
<span class="lineNum">   38732 </span><span class="lineCov">      56260 :   cp_parser_skip_to_pragma_eol (parser, pragma_tok);</span>
<span class="lineNum">   38733 </span>            :   return true;
<span class="lineNum">   38734 </span><span class="lineCov">      56260 : }</span>
<span class="lineNum">   38735 </span><span class="lineCov">      56241 : </span>
<span class="lineNum">   38736 </span>            : /* Parse a pragma GCC unroll.  */
<a name="38737"><span class="lineNum">   38737 </span>            : </a>
<span class="lineNum">   38738 </span><span class="lineCov">          3 : static unsigned short</span>
<span class="lineNum">   38739 </span><span class="lineCov">          3 : cp_parser_pragma_unroll (cp_parser *parser, cp_token *pragma_tok)</span>
<span class="lineNum">   38740 </span>            : {
<span class="lineNum">   38741 </span><span class="lineCov">          3 :   location_t location = cp_lexer_peek_token (parser-&gt;lexer)-&gt;location;</span>
<span class="lineNum">   38742 </span>            :   tree expr = cp_parser_constant_expression (parser);
<span class="lineNum">   38743 </span><span class="lineCov">          3 :   unsigned short unroll;</span>
<span class="lineNum">   38744 </span><span class="lineCov">          3 :   expr = maybe_constant_value (expr);</span>
<span class="lineNum">   38745 </span><span class="lineNoCov">          0 :   HOST_WIDE_INT lunroll = 0;</span>
<span class="lineNum">   38746 </span>            :   if (!INTEGRAL_TYPE_P (TREE_TYPE (expr))
<span class="lineNum">   38747 </span>            :       || TREE_CODE (expr) != INTEGER_CST
<span class="lineNum">   38748 </span>            :       || (lunroll = tree_to_shwi (expr)) &lt; 0
<span class="lineNum">   38749 </span><span class="lineNoCov">          0 :       || lunroll &gt;= USHRT_MAX)</span>
<span class="lineNum">   38750 </span>            :     {
<span class="lineNum">   38751 </span>            :       error_at (location, &quot;%&lt;#pragma GCC unroll%&gt; requires an&quot;
<span class="lineNum">   38752 </span><span class="lineCov">          3 :                 &quot; assignment-expression that evaluates to a non-negative&quot;</span>
<span class="lineNum">   38753 </span><span class="lineNoCov">          0 :                 &quot; integral constant less than %u&quot;, USHRT_MAX);</span>
<span class="lineNum">   38754 </span>            :       unroll = 0;
<span class="lineNum">   38755 </span>            :     }
<span class="lineNum">   38756 </span><span class="lineCov">          3 :   else</span>
<span class="lineNum">   38757 </span><span class="lineCov">          3 :     {</span>
<span class="lineNum">   38758 </span>            :       unroll = (unsigned short)lunroll;
<span class="lineNum">   38759 </span>            :       if (unroll == 0)
<span class="lineNum">   38760 </span>            :         unroll = 1;
<span class="lineNum">   38761 </span>            :     }
<span class="lineNum">   38762 </span><span class="lineCov">          3 :   cp_parser_skip_to_pragma_eol (parser, pragma_tok);</span>
<span class="lineNum">   38763 </span>            :   return unroll;
<span class="lineNum">   38764 </span>            : }
<span class="lineNum">   38765 </span>            : 
<span class="lineNum">   38766 </span>            : /* Normal parsing of a pragma token.  Here we can (and must) use the
<span class="lineNum">   38767 </span>            :    regular lexer.  */
<a name="38768"><span class="lineNum">   38768 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">   38769 </span>            : static bool
<span class="lineNum">   38770 </span><span class="lineNoCov">          0 : cp_parser_pragma (cp_parser *parser, enum pragma_context context, bool *if_p)</span>
<span class="lineNum">   38771 </span><span class="lineCov">         47 : {</span>
<span class="lineNum">   38772 </span>            :   cp_token *pragma_tok;
<span class="lineNum">   38773 </span>            :   unsigned int id;
<span class="lineNum">   38774 </span>            :   tree stmt;
<span class="lineNum">   38775 </span>            :   bool ret;
<span class="lineNum">   38776 </span>            : 
<span class="lineNum">   38777 </span><span class="lineCov">         80 :   pragma_tok = cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   38778 </span>            :   gcc_assert (pragma_tok-&gt;type == CPP_PRAGMA);
<span class="lineNum">   38779 </span><span class="lineCov">        160 :   parser-&gt;lexer-&gt;in_pragma = true;</span>
<span class="lineNum">   38780 </span><span class="lineCov">         80 : </span>
<span class="lineNum">   38781 </span><span class="lineCov">         80 :   id = cp_parser_pragma_kind (pragma_tok);</span>
<span class="lineNum">   38782 </span><span class="lineCov">         80 :   if (id != PRAGMA_OMP_DECLARE &amp;&amp; id != PRAGMA_OACC_ROUTINE)</span>
<span class="lineNum">   38783 </span><span class="lineCov">         80 :     cp_ensure_no_omp_declare_simd (parser);</span>
<span class="lineNum">   38784 </span><span class="lineCov">        240 :   switch (id)</span>
<span class="lineNum">   38785 </span><span class="lineCov">         76 :     {</span>
<span class="lineNum">   38786 </span><span class="lineCov">         74 :     case PRAGMA_GCC_PCH_PREPROCESS:</span>
<span class="lineNum">   38787 </span><span class="lineCov">        151 :       error_at (pragma_tok-&gt;location,</span>
<span class="lineNum">   38788 </span>            :                 &quot;%&lt;#pragma GCC pch_preprocess%&gt; must be first&quot;);
<span class="lineNum">   38789 </span><span class="lineCov">         12 :       break;</span>
<span class="lineNum">   38790 </span>            : 
<span class="lineNum">   38791 </span>            :     case PRAGMA_OMP_BARRIER:
<span class="lineNum">   38792 </span><span class="lineCov">         12 :       switch (context)</span>
<span class="lineNum">   38793 </span>            :         {
<span class="lineNum">   38794 </span>            :         case pragma_compound:
<span class="lineNum">   38795 </span>            :           cp_parser_omp_barrier (parser, pragma_tok);
<span class="lineNum">   38796 </span><span class="lineCov">         68 :           return false;</span>
<span class="lineNum">   38797 </span><span class="lineCov">         68 :         case pragma_stmt:</span>
<span class="lineNum">   38798 </span><span class="lineCov">          6 :           error_at (pragma_tok-&gt;location, &quot;%&lt;#pragma %s%&gt; may only be &quot;</span>
<span class="lineNum">   38799 </span>            :                     &quot;used in compound statements&quot;, &quot;omp barrier&quot;);
<span class="lineNum">   38800 </span><span class="lineCov">         80 :           break;</span>
<span class="lineNum">   38801 </span><span class="lineCov">         80 :         default:</span>
<span class="lineNum">   38802 </span>            :           goto bad_stmt;
<span class="lineNum">   38803 </span>            :         }
<span class="lineNum">   38804 </span>            :       break;
<span class="lineNum">   38805 </span>            : 
<span class="lineNum">   38806 </span>            :     case PRAGMA_OMP_FLUSH:
<span class="lineNum">   38807 </span>            :       switch (context)
<span class="lineNum">   38808 </span><span class="lineCov">     119535 :         {</span>
<span class="lineNum">   38809 </span>            :         case pragma_compound:
<span class="lineNum">   38810 </span><span class="lineCov">     119535 :           cp_parser_omp_flush (parser, pragma_tok);</span>
<span class="lineNum">   38811 </span><span class="lineCov">     119535 :           return false;</span>
<span class="lineNum">   38812 </span><span class="lineCov">     119535 :         case pragma_stmt:</span>
<span class="lineNum">   38813 </span><span class="lineCov">     119535 :           error_at (pragma_tok-&gt;location, &quot;%&lt;#pragma %s%&gt; may only be &quot;</span>
<span class="lineNum">   38814 </span>            :                     &quot;used in compound statements&quot;, &quot;omp flush&quot;);
<span class="lineNum">   38815 </span><span class="lineCov">     119535 :           break;</span>
<span class="lineNum">   38816 </span><span class="lineCov">     119535 :         default:</span>
<span class="lineNum">   38817 </span><span class="lineCov">     119535 :           goto bad_stmt;</span>
<span class="lineNum">   38818 </span>            :         }
<span class="lineNum">   38819 </span><span class="lineCov">     119535 :       break;</span>
<span class="lineNum">   38820 </span><span class="lineCov">     119535 : </span>
<span class="lineNum">   38821 </span><span class="lineCov">     117733 :     case PRAGMA_OMP_TASKWAIT:</span>
<span class="lineNum">   38822 </span><span class="lineCov">     119535 :       switch (context)</span>
<span class="lineNum">   38823 </span>            :         {
<span class="lineNum">   38824 </span><span class="lineCov">          3 :         case pragma_compound:</span>
<span class="lineNum">   38825 </span><span class="lineCov">          3 :           cp_parser_omp_taskwait (parser, pragma_tok);</span>
<span class="lineNum">   38826 </span>            :           return false;
<span class="lineNum">   38827 </span><span class="lineCov">          3 :         case pragma_stmt:</span>
<span class="lineNum">   38828 </span>            :           error_at (pragma_tok-&gt;location,
<span class="lineNum">   38829 </span><span class="lineCov">        654 :                     &quot;%&lt;#pragma %s%&gt; may only be used in compound statements&quot;,</span>
<span class="lineNum">   38830 </span><span class="lineCov">        654 :                     &quot;omp taskwait&quot;);</span>
<span class="lineNum">   38831 </span>            :           break;
<span class="lineNum">   38832 </span><span class="lineCov">        627 :         default:</span>
<span class="lineNum">   38833 </span><span class="lineCov">        627 :           goto bad_stmt;</span>
<span class="lineNum">   38834 </span><span class="lineCov">        627 :         }</span>
<span class="lineNum">   38835 </span><span class="lineCov">         27 :       break;</span>
<span class="lineNum">   38836 </span><span class="lineCov">         27 : </span>
<span class="lineNum">   38837 </span>            :     case PRAGMA_OMP_TASKYIELD:
<span class="lineNum">   38838 </span><span class="lineCov">         27 :       switch (context)</span>
<span class="lineNum">   38839 </span>            :         {
<span class="lineNum">   38840 </span>            :         case pragma_compound:
<span class="lineNum">   38841 </span>            :           cp_parser_omp_taskyield (parser, pragma_tok);
<span class="lineNum">   38842 </span><span class="lineCov">         27 :           return false;</span>
<span class="lineNum">   38843 </span>            :         case pragma_stmt:
<span class="lineNum">   38844 </span><span class="lineCov">         48 :           error_at (pragma_tok-&gt;location,</span>
<span class="lineNum">   38845 </span><span class="lineCov">         48 :                     &quot;%&lt;#pragma %s%&gt; may only be used in compound statements&quot;,</span>
<span class="lineNum">   38846 </span>            :                     &quot;omp taskyield&quot;);
<span class="lineNum">   38847 </span><span class="lineCov">         24 :           break;</span>
<span class="lineNum">   38848 </span><span class="lineCov">         24 :         default:</span>
<span class="lineNum">   38849 </span><span class="lineCov">         24 :           goto bad_stmt;</span>
<span class="lineNum">   38850 </span><span class="lineCov">         24 :         }</span>
<span class="lineNum">   38851 </span><span class="lineCov">         24 :       break;</span>
<span class="lineNum">   38852 </span>            : 
<span class="lineNum">   38853 </span><span class="lineCov">         24 :     case PRAGMA_OMP_CANCEL:</span>
<span class="lineNum">   38854 </span>            :       switch (context)
<span class="lineNum">   38855 </span>            :         {
<span class="lineNum">   38856 </span>            :         case pragma_compound:
<span class="lineNum">   38857 </span><span class="lineCov">         24 :           cp_parser_omp_cancel (parser, pragma_tok);</span>
<span class="lineNum">   38858 </span>            :           return false;
<span class="lineNum">   38859 </span><span class="lineCov">         42 :         case pragma_stmt:</span>
<span class="lineNum">   38860 </span><span class="lineCov">         42 :           error_at (pragma_tok-&gt;location,</span>
<span class="lineNum">   38861 </span>            :                     &quot;%&lt;#pragma %s%&gt; may only be used in compound statements&quot;,
<span class="lineNum">   38862 </span><span class="lineCov">         18 :                     &quot;omp cancel&quot;);</span>
<span class="lineNum">   38863 </span><span class="lineCov">         18 :           break;</span>
<span class="lineNum">   38864 </span><span class="lineCov">         18 :         default:</span>
<span class="lineNum">   38865 </span><span class="lineCov">         24 :           goto bad_stmt;</span>
<span class="lineNum">   38866 </span><span class="lineCov">         24 :         }</span>
<span class="lineNum">   38867 </span>            :       break;
<span class="lineNum">   38868 </span>            : 
<span class="lineNum">   38869 </span><span class="lineCov">         24 :     case PRAGMA_OMP_CANCELLATION_POINT:</span>
<span class="lineNum">   38870 </span>            :       cp_parser_omp_cancellation_point (parser, pragma_tok, context);
<span class="lineNum">   38871 </span>            :       return false;
<span class="lineNum">   38872 </span>            : 
<span class="lineNum">   38873 </span><span class="lineCov">         24 :     case PRAGMA_OMP_THREADPRIVATE:</span>
<span class="lineNum">   38874 </span>            :       cp_parser_omp_threadprivate (parser, pragma_tok);
<span class="lineNum">   38875 </span><span class="lineCov">         25 :       return false;</span>
<span class="lineNum">   38876 </span><span class="lineCov">         25 : </span>
<span class="lineNum">   38877 </span>            :     case PRAGMA_OMP_DECLARE:
<span class="lineNum">   38878 </span><span class="lineCov">          1 :       return cp_parser_omp_declare (parser, pragma_tok, context);</span>
<span class="lineNum">   38879 </span><span class="lineCov">          1 : </span>
<span class="lineNum">   38880 </span><span class="lineCov">          1 :     case PRAGMA_OACC_DECLARE:</span>
<span class="lineNum">   38881 </span><span class="lineCov">         24 :       cp_parser_oacc_declare (parser, pragma_tok);</span>
<span class="lineNum">   38882 </span><span class="lineCov">         24 :       return false;</span>
<span class="lineNum">   38883 </span>            : 
<span class="lineNum">   38884 </span>            :     case PRAGMA_OACC_ENTER_DATA:
<span class="lineNum">   38885 </span><span class="lineCov">         24 :       if (context == pragma_stmt)</span>
<span class="lineNum">   38886 </span>            :         {
<span class="lineNum">   38887 </span>            :           error_at (pragma_tok-&gt;location,
<span class="lineNum">   38888 </span>            :                     &quot;%&lt;#pragma %s%&gt; may only be used in compound statements&quot;,
<span class="lineNum">   38889 </span><span class="lineCov">         24 :                     &quot;acc enter data&quot;);</span>
<span class="lineNum">   38890 </span>            :           break;
<span class="lineNum">   38891 </span><span class="lineCov">        449 :         }</span>
<span class="lineNum">   38892 </span><span class="lineCov">        449 :       else if (context != pragma_compound)</span>
<span class="lineNum">   38893 </span>            :         goto bad_stmt;
<span class="lineNum">   38894 </span><span class="lineCov">        425 :       cp_parser_omp_construct (parser, pragma_tok, if_p);</span>
<span class="lineNum">   38895 </span><span class="lineCov">        425 :       return true;</span>
<span class="lineNum">   38896 </span><span class="lineCov">        425 : </span>
<span class="lineNum">   38897 </span><span class="lineCov">         24 :     case PRAGMA_OACC_EXIT_DATA:</span>
<span class="lineNum">   38898 </span><span class="lineCov">         24 :       if (context == pragma_stmt)</span>
<span class="lineNum">   38899 </span>            :         {
<span class="lineNum">   38900 </span>            :           error_at (pragma_tok-&gt;location,
<span class="lineNum">   38901 </span><span class="lineCov">         24 :                     &quot;%&lt;#pragma %s%&gt; may only be used in compound statements&quot;,</span>
<span class="lineNum">   38902 </span>            :                     &quot;acc exit data&quot;);
<span class="lineNum">   38903 </span>            :           break;
<span class="lineNum">   38904 </span>            :         }
<span class="lineNum">   38905 </span><span class="lineCov">         24 :       else if (context != pragma_compound)</span>
<span class="lineNum">   38906 </span>            :         goto bad_stmt;
<span class="lineNum">   38907 </span><span class="lineCov">        430 :       cp_parser_omp_construct (parser, pragma_tok, if_p);</span>
<span class="lineNum">   38908 </span><span class="lineCov">        430 :       return true;</span>
<span class="lineNum">   38909 </span><span class="lineCov">        430 : </span>
<span class="lineNum">   38910 </span>            :     case PRAGMA_OACC_ROUTINE:
<span class="lineNum">   38911 </span><span class="lineCov">        114 :       if (context != pragma_external)</span>
<span class="lineNum">   38912 </span><span class="lineCov">        114 :         {</span>
<span class="lineNum">   38913 </span><span class="lineCov">        114 :           error_at (pragma_tok-&gt;location,</span>
<span class="lineNum">   38914 </span>            :                     &quot;%&lt;#pragma acc routine%&gt; must be at file scope&quot;);
<span class="lineNum">   38915 </span><span class="lineCov">       1374 :           break;</span>
<span class="lineNum">   38916 </span><span class="lineCov">       1374 :         }</span>
<span class="lineNum">   38917 </span>            :       cp_parser_oacc_routine (parser, pragma_tok, context);
<span class="lineNum">   38918 </span><span class="lineCov">        198 :       return false;</span>
<span class="lineNum">   38919 </span><span class="lineCov">        198 : </span>
<span class="lineNum">   38920 </span><span class="lineCov">        198 :     case PRAGMA_OACC_UPDATE:</span>
<span class="lineNum">   38921 </span>            :       if (context == pragma_stmt)
<span class="lineNum">   38922 </span><span class="lineCov">        193 :         {</span>
<span class="lineNum">   38923 </span><span class="lineCov">        193 :           error_at (pragma_tok-&gt;location,</span>
<span class="lineNum">   38924 </span>            :                     &quot;%&lt;#pragma %s%&gt; may only be used in compound statements&quot;,
<span class="lineNum">   38925 </span><span class="lineCov">          9 :                     &quot;acc update&quot;);</span>
<span class="lineNum">   38926 </span>            :           break;
<span class="lineNum">   38927 </span>            :         }
<span class="lineNum">   38928 </span><span class="lineCov">          9 :       else if (context != pragma_compound)</span>
<span class="lineNum">   38929 </span>            :         goto bad_stmt;
<span class="lineNum">   38930 </span><span class="lineCov">        184 :       cp_parser_omp_construct (parser, pragma_tok, if_p);</span>
<span class="lineNum">   38931 </span>            :       return true;
<span class="lineNum">   38932 </span><span class="lineCov">        184 : </span>
<span class="lineNum">   38933 </span><span class="lineCov">        184 :     case PRAGMA_OACC_WAIT:</span>
<span class="lineNum">   38934 </span>            :       if (context == pragma_stmt)
<span class="lineNum">   38935 </span><span class="lineCov">        184 :         {</span>
<span class="lineNum">   38936 </span><span class="lineCov">        184 :           error_at (pragma_tok-&gt;location,</span>
<span class="lineNum">   38937 </span>            :                     &quot;%&lt;#pragma %s%&gt; may only be used in compound statements&quot;,
<span class="lineNum">   38938 </span><span class="lineCov">          9 :                     &quot;acc wait&quot;);</span>
<span class="lineNum">   38939 </span>            :           break;
<span class="lineNum">   38940 </span>            :         }
<span class="lineNum">   38941 </span><span class="lineCov">          9 :       else if (context != pragma_compound)</span>
<span class="lineNum">   38942 </span>            :         goto bad_stmt;
<span class="lineNum">   38943 </span><span class="lineCov">        175 :       cp_parser_omp_construct (parser, pragma_tok, if_p);</span>
<span class="lineNum">   38944 </span>            :       return true;
<span class="lineNum">   38945 </span><span class="lineCov">        175 : </span>
<span class="lineNum">   38946 </span><span class="lineCov">        175 :     case PRAGMA_OACC_ATOMIC:</span>
<span class="lineNum">   38947 </span>            :     case PRAGMA_OACC_CACHE:
<span class="lineNum">   38948 </span><span class="lineCov">        428 :     case PRAGMA_OACC_DATA:</span>
<span class="lineNum">   38949 </span><span class="lineCov">        428 :     case PRAGMA_OACC_HOST_DATA:</span>
<span class="lineNum">   38950 </span>            :     case PRAGMA_OACC_KERNELS:
<span class="lineNum">   38951 </span><span class="lineCov">         12 :     case PRAGMA_OACC_PARALLEL:</span>
<span class="lineNum">   38952 </span>            :     case PRAGMA_OACC_LOOP:
<span class="lineNum">   38953 </span><span class="lineCov">         12 :     case PRAGMA_OMP_ATOMIC:</span>
<span class="lineNum">   38954 </span>            :     case PRAGMA_OMP_CRITICAL:
<span class="lineNum">   38955 </span><span class="lineCov">        416 :     case PRAGMA_OMP_DISTRIBUTE:</span>
<span class="lineNum">   38956 </span><span class="lineCov">        416 :     case PRAGMA_OMP_FOR:</span>
<span class="lineNum">   38957 </span>            :     case PRAGMA_OMP_MASTER:
<span class="lineNum">   38958 </span><span class="lineCov">        162 :     case PRAGMA_OMP_PARALLEL:</span>
<span class="lineNum">   38959 </span><span class="lineCov">        162 :     case PRAGMA_OMP_SECTIONS:</span>
<span class="lineNum">   38960 </span>            :     case PRAGMA_OMP_SIMD:
<span class="lineNum">   38961 </span><span class="lineCov">         12 :     case PRAGMA_OMP_SINGLE:</span>
<span class="lineNum">   38962 </span>            :     case PRAGMA_OMP_TASK:
<span class="lineNum">   38963 </span>            :     case PRAGMA_OMP_TASKGROUP:
<span class="lineNum">   38964 </span><span class="lineCov">         12 :     case PRAGMA_OMP_TASKLOOP:</span>
<span class="lineNum">   38965 </span>            :     case PRAGMA_OMP_TEAMS:
<span class="lineNum">   38966 </span><span class="lineCov">        150 :       if (context != pragma_stmt &amp;&amp; context != pragma_compound)</span>
<span class="lineNum">   38967 </span>            :         goto bad_stmt;
<span class="lineNum">   38968 </span><span class="lineCov">        150 :       stmt = push_omp_privatization_clauses (false);</span>
<span class="lineNum">   38969 </span><span class="lineCov">        150 :       cp_parser_omp_construct (parser, pragma_tok, if_p);</span>
<span class="lineNum">   38970 </span>            :       pop_omp_privatization_clauses (stmt);
<span class="lineNum">   38971 </span><span class="lineCov">        125 :       return true;</span>
<span class="lineNum">   38972 </span><span class="lineCov">        125 : </span>
<span class="lineNum">   38973 </span>            :     case PRAGMA_OMP_ORDERED:
<span class="lineNum">   38974 </span><span class="lineCov">          9 :       if (context != pragma_stmt &amp;&amp; context != pragma_compound)</span>
<span class="lineNum">   38975 </span>            :         goto bad_stmt;
<span class="lineNum">   38976 </span>            :       stmt = push_omp_privatization_clauses (false);
<span class="lineNum">   38977 </span><span class="lineCov">          9 :       ret = cp_parser_omp_ordered (parser, pragma_tok, context, if_p);</span>
<span class="lineNum">   38978 </span>            :       pop_omp_privatization_clauses (stmt);
<span class="lineNum">   38979 </span><span class="lineCov">        116 :       return ret;</span>
<span class="lineNum">   38980 </span>            : 
<span class="lineNum">   38981 </span><span class="lineCov">        116 :     case PRAGMA_OMP_TARGET:</span>
<span class="lineNum">   38982 </span><span class="lineCov">        116 :       if (context != pragma_stmt &amp;&amp; context != pragma_compound)</span>
<span class="lineNum">   38983 </span>            :         goto bad_stmt;
<span class="lineNum">   38984 </span><span class="lineCov">      13888 :       stmt = push_omp_privatization_clauses (false);</span>
<span class="lineNum">   38985 </span><span class="lineCov">      13888 :       ret = cp_parser_omp_target (parser, pragma_tok, context, if_p);</span>
<span class="lineNum">   38986 </span><span class="lineCov">      13888 :       pop_omp_privatization_clauses (stmt);</span>
<span class="lineNum">   38987 </span><span class="lineCov">      13888 :       return ret;</span>
<span class="lineNum">   38988 </span><span class="lineCov">      13888 : </span>
<span class="lineNum">   38989 </span><span class="lineCov">      13888 :     case PRAGMA_OMP_END_DECLARE_TARGET:</span>
<span class="lineNum">   38990 </span><span class="lineCov">      13888 :       cp_parser_omp_end_declare_target (parser, pragma_tok);</span>
<span class="lineNum">   38991 </span><span class="lineCov">      13888 :       return false;</span>
<span class="lineNum">   38992 </span><span class="lineCov">      13888 : </span>
<span class="lineNum">   38993 </span><span class="lineCov">      13888 :     case PRAGMA_OMP_SECTION:</span>
<span class="lineNum">   38994 </span><span class="lineCov">      13888 :       error_at (pragma_tok-&gt;location, </span>
<span class="lineNum">   38995 </span><span class="lineCov">      13888 :                 &quot;%&lt;#pragma omp section%&gt; may only be used in &quot;</span>
<span class="lineNum">   38996 </span><span class="lineCov">      13888 :                 &quot;%&lt;#pragma omp sections%&gt; construct&quot;);</span>
<span class="lineNum">   38997 </span><span class="lineCov">      13888 :       break;</span>
<span class="lineNum">   38998 </span><span class="lineCov">      13888 : </span>
<span class="lineNum">   38999 </span><span class="lineCov">      13888 :     case PRAGMA_IVDEP:</span>
<span class="lineNum">   39000 </span><span class="lineCov">      13888 :       {</span>
<span class="lineNum">   39001 </span><span class="lineCov">      13888 :         if (context == pragma_external)</span>
<span class="lineNum">   39002 </span><span class="lineCov">      13888 :           {</span>
<span class="lineNum">   39003 </span><span class="lineCov">      13888 :             error_at (pragma_tok-&gt;location,</span>
<span class="lineNum">   39004 </span><span class="lineCov">      13888 :                       &quot;%&lt;#pragma GCC ivdep%&gt; must be inside a function&quot;);</span>
<span class="lineNum">   39005 </span>            :             break;
<span class="lineNum">   39006 </span><span class="lineCov">      13885 :           }</span>
<span class="lineNum">   39007 </span><span class="lineCov">      13885 :         const bool ivdep = cp_parser_pragma_ivdep (parser, pragma_tok);</span>
<span class="lineNum">   39008 </span><span class="lineCov">      13885 :         unsigned short unroll;</span>
<span class="lineNum">   39009 </span><span class="lineCov">      13885 :         cp_token *tok = cp_lexer_peek_token (the_parser-&gt;lexer);</span>
<span class="lineNum">   39010 </span>            :         if (tok-&gt;type == CPP_PRAGMA
<span class="lineNum">   39011 </span><span class="lineCov">        517 :             &amp;&amp; cp_parser_pragma_kind (tok) == PRAGMA_UNROLL)</span>
<span class="lineNum">   39012 </span><span class="lineCov">        517 :           {</span>
<span class="lineNum">   39013 </span>            :             tok = cp_lexer_consume_token (parser-&gt;lexer);
<span class="lineNum">   39014 </span><span class="lineCov">        511 :             unroll = cp_parser_pragma_unroll (parser, tok);</span>
<span class="lineNum">   39015 </span><span class="lineCov">        511 :             tok = cp_lexer_peek_token (the_parser-&gt;lexer);</span>
<span class="lineNum">   39016 </span><span class="lineCov">        511 :           }</span>
<span class="lineNum">   39017 </span><span class="lineCov">        511 :         else</span>
<span class="lineNum">   39018 </span>            :           unroll = 0;
<span class="lineNum">   39019 </span><span class="lineCov">       3277 :         if (tok-&gt;type != CPP_KEYWORD</span>
<span class="lineNum">   39020 </span><span class="lineCov">       3277 :             || (tok-&gt;keyword != RID_FOR</span>
<span class="lineNum">   39021 </span>            :                 &amp;&amp; tok-&gt;keyword != RID_WHILE
<span class="lineNum">   39022 </span><span class="lineCov">       3271 :                 &amp;&amp; tok-&gt;keyword != RID_DO))</span>
<span class="lineNum">   39023 </span><span class="lineCov">       3271 :           {</span>
<span class="lineNum">   39024 </span><span class="lineCov">       3271 :             cp_parser_error (parser, &quot;for, while or do statement expected&quot;);</span>
<span class="lineNum">   39025 </span><span class="lineCov">       3271 :             return false;</span>
<span class="lineNum">   39026 </span>            :           }
<span class="lineNum">   39027 </span><span class="lineCov">         51 :         cp_parser_iteration_statement (parser, if_p, ivdep, unroll);</span>
<span class="lineNum">   39028 </span><span class="lineCov">         51 :         return true;</span>
<span class="lineNum">   39029 </span><span class="lineCov">         51 :       }</span>
<span class="lineNum">   39030 </span>            : 
<span class="lineNum">   39031 </span><span class="lineCov">          6 :     case PRAGMA_UNROLL:</span>
<span class="lineNum">   39032 </span><span class="lineCov">          6 :       {</span>
<span class="lineNum">   39033 </span>            :         if (context == pragma_external)
<span class="lineNum">   39034 </span>            :           {
<span class="lineNum">   39035 </span><span class="lineCov">          6 :             error_at (pragma_tok-&gt;location,</span>
<span class="lineNum">   39036 </span>            :                       &quot;%&lt;#pragma GCC unroll%&gt; must be inside a function&quot;);
<span class="lineNum">   39037 </span><span class="lineCov">         50 :             break;</span>
<span class="lineNum">   39038 </span><span class="lineCov">         50 :           }</span>
<span class="lineNum">   39039 </span><span class="lineCov">         50 :         const unsigned short unroll</span>
<span class="lineNum">   39040 </span>            :           = cp_parser_pragma_unroll (parser, pragma_tok);
<span class="lineNum">   39041 </span><span class="lineCov">          6 :         bool ivdep;</span>
<span class="lineNum">   39042 </span>            :         cp_token *tok = cp_lexer_peek_token (the_parser-&gt;lexer);
<span class="lineNum">   39043 </span><span class="lineCov">          6 :         if (tok-&gt;type == CPP_PRAGMA</span>
<span class="lineNum">   39044 </span>            :             &amp;&amp; cp_parser_pragma_kind (tok) == PRAGMA_IVDEP)
<span class="lineNum">   39045 </span><span class="lineCov">         44 :           {</span>
<span class="lineNum">   39046 </span><span class="lineCov">         44 :             tok = cp_lexer_consume_token (parser-&gt;lexer);</span>
<span class="lineNum">   39047 </span><span class="lineCov">         88 :             ivdep = cp_parser_pragma_ivdep (parser, tok);</span>
<span class="lineNum">   39048 </span><span class="lineCov">         44 :             tok = cp_lexer_peek_token (the_parser-&gt;lexer);</span>
<span class="lineNum">   39049 </span><span class="lineCov">         44 :           }</span>
<span class="lineNum">   39050 </span>            :         else
<span class="lineNum">   39051 </span><span class="lineCov">          3 :           ivdep = false;</span>
<span class="lineNum">   39052 </span><span class="lineCov">          3 :         if (tok-&gt;type != CPP_KEYWORD</span>
<span class="lineNum">   39053 </span><span class="lineCov">          3 :             || (tok-&gt;keyword != RID_FOR</span>
<span class="lineNum">   39054 </span>            :                 &amp;&amp; tok-&gt;keyword != RID_WHILE
<span class="lineNum">   39055 </span>            :                 &amp;&amp; tok-&gt;keyword != RID_DO))
<span class="lineNum">   39056 </span>            :           {
<span class="lineNum">   39057 </span><span class="lineCov">         44 :             cp_parser_error (parser, &quot;for, while or do statement expected&quot;);</span>
<span class="lineNum">   39058 </span><span class="lineCov">         44 :             return false;</span>
<span class="lineNum">   39059 </span><span class="lineCov">         12 :           }</span>
<span class="lineNum">   39060 </span><span class="lineCov">          3 :         cp_parser_iteration_statement (parser, if_p, ivdep, unroll);</span>
<span class="lineNum">   39061 </span>            :         return true;
<span class="lineNum">   39062 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">   39063 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   39064 </span>            :     default:
<span class="lineNum">   39065 </span><span class="lineCov">         44 :       gcc_assert (id &gt;= PRAGMA_FIRST_EXTERNAL);</span>
<span class="lineNum">   39066 </span><span class="lineCov">         44 :       c_invoke_pragma_handler (id);</span>
<span class="lineNum">   39067 </span>            :       break;
<span class="lineNum">   39068 </span>            : 
<span class="lineNum">   39069 </span><span class="lineCov">         77 :     bad_stmt:</span>
<span class="lineNum">   39070 </span><span class="lineCov">         77 :       cp_parser_error (parser, &quot;expected declaration specifiers&quot;);</span>
<span class="lineNum">   39071 </span><span class="lineCov">         77 :       break;</span>
<span class="lineNum">   39072 </span>            :     }
<span class="lineNum">   39073 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">   39074 </span>            :   cp_parser_skip_to_pragma_eol (parser, pragma_tok);
<span class="lineNum">   39075 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">   39076 </span>            : }
<span class="lineNum">   39077 </span><span class="lineCov">         77 : </span>
<span class="lineNum">   39078 </span><span class="lineCov">         77 : /* The interface the pragma parsers have to the lexer.  */</span>
<a name="39079"><span class="lineNum">   39079 </span><span class="lineCov">         77 : </span></a>
<span class="lineNum">   39080 </span><span class="lineCov">        154 : enum cpp_ttype</span>
<span class="lineNum">   39081 </span><span class="lineCov">         77 : pragma_lex (tree *value, location_t *loc)</span>
<span class="lineNum">   39082 </span><span class="lineCov">         77 : {</span>
<span class="lineNum">   39083 </span>            :   cp_token *tok = cp_lexer_peek_token (the_parser-&gt;lexer);
<span class="lineNum">   39084 </span><span class="lineCov">          3 :   enum cpp_ttype ret = tok-&gt;type;</span>
<span class="lineNum">   39085 </span><span class="lineCov">          3 : </span>
<span class="lineNum">   39086 </span><span class="lineCov">          3 :   *value = tok-&gt;u.value;</span>
<span class="lineNum">   39087 </span>            :   if (loc)
<span class="lineNum">   39088 </span>            :     *loc = tok-&gt;location;
<span class="lineNum">   39089 </span>            : 
<span class="lineNum">   39090 </span><span class="lineCov">         77 :   if (ret == CPP_PRAGMA_EOL || ret == CPP_EOF)</span>
<span class="lineNum">   39091 </span><span class="lineCov">        154 :     ret = CPP_EOF;</span>
<span class="lineNum">   39092 </span><span class="lineCov">         77 :   else if (ret == CPP_STRING)</span>
<span class="lineNum">   39093 </span><span class="lineCov">          9 :     *value = cp_parser_string_literal (the_parser, false, false);</span>
<span class="lineNum">   39094 </span>            :   else
<span class="lineNum">   39095 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">   39096 </span><span class="lineNoCov">          0 :       if (ret == CPP_KEYWORD)</span>
<span class="lineNum">   39097 </span>            :         ret = CPP_NAME;
<span class="lineNum">   39098 </span><span class="lineCov">         77 :       cp_lexer_consume_token (the_parser-&gt;lexer);</span>
<span class="lineNum">   39099 </span><span class="lineCov">         77 :     }</span>
<span class="lineNum">   39100 </span>            : 
<span class="lineNum">   39101 </span>            :   return ret;
<span class="lineNum">   39102 </span><span class="lineCov">      97240 : }</span>
<span class="lineNum">   39103 </span><span class="lineCov">      97240 : </span>
<span class="lineNum">   39104 </span><span class="lineCov">      97240 : </span>
<span class="lineNum">   39105 </span><span class="lineCov">      97240 : /* External interface.  */</span>
<span class="lineNum">   39106 </span>            : 
<span class="lineNum">   39107 </span><span class="lineCov">         15 : /* Parse one entire translation unit.  */</span>
<a name="39108"><span class="lineNum">   39108 </span><span class="lineCov">         15 : </span></a>
<span class="lineNum">   39109 </span><span class="lineCov">         15 : void</span>
<span class="lineNum">   39110 </span>            : c_parse_file (void)
<span class="lineNum">   39111 </span>            : {
<span class="lineNum">   39112 </span><span class="lineCov">      97444 :   static bool already_called = false;</span>
<span class="lineNum">   39113 </span><span class="lineCov">      97444 : </span>
<span class="lineNum">   39114 </span>            :   if (already_called)
<span class="lineNum">   39115 </span>            :     fatal_error (input_location,
<span class="lineNum">   39116 </span>            :                  &quot;inter-module optimizations not implemented for C++&quot;);
<span class="lineNum">   39117 </span>            :   already_called = true;
<span class="lineNum">   39118 </span>            : 
<span class="lineNum">   39119 </span><span class="lineCov">     239472 :   the_parser = cp_parser_new ();</span>
<span class="lineNum">   39120 </span>            :   push_deferring_access_checks (flag_access_control
<span class="lineNum">   39121 </span><span class="lineCov">     478944 :                                 ? dk_no_deferred : dk_no_check);</span>
<span class="lineNum">   39122 </span><span class="lineCov">     239472 :   cp_parser_translation_unit (the_parser);</span>
<span class="lineNum">   39123 </span>            :   the_parser = NULL;
<span class="lineNum">   39124 </span><span class="lineCov">     239472 : }</span>
<span class="lineNum">   39125 </span><span class="lineCov">     239472 : </span>
<span class="lineNum">   39126 </span><span class="lineCov">      37168 : /* Create an identifier for a generic parameter type (a synthesized</span>
<span class="lineNum">   39127 </span>            :    template parameter implied by `auto' or a concept identifier). */
<span class="lineNum">   39128 </span><span class="lineCov">     239472 : </span>
<a name="39129"><span class="lineNum">   39129 </span>            : static GTY(()) int generic_parm_count;</a>
<span class="lineNum">   39130 </span><span class="lineCov">     170067 : static tree</span>
<span class="lineNum">   39131 </span><span class="lineCov">      18396 : make_generic_type_name ()</span>
<span class="lineNum">   39132 </span>            : {
<span class="lineNum">   39133 </span>            :   char buf[32];
<span class="lineNum">   39134 </span><span class="lineCov">     151671 :   sprintf (buf, &quot;auto:%d&quot;, ++generic_parm_count);</span>
<span class="lineNum">   39135 </span><span class="lineCov">      21109 :   return get_identifier (buf);</span>
<span class="lineNum">   39136 </span><span class="lineCov">     151671 : }</span>
<span class="lineNum">   39137 </span>            : 
<span class="lineNum">   39138 </span>            : /* Add an implicit template type parameter to the CURRENT_TEMPLATE_PARMS
<span class="lineNum">   39139 </span><span class="lineCov">     239472 :    (creating a new template parameter list if necessary).  Returns the newly</span>
<span class="lineNum">   39140 </span>            :    created template type parm.  */
<a name="39141"><span class="lineNum">   39141 </span>            : </a>
<span class="lineNum">   39142 </span>            : static tree
<span class="lineNum">   39143 </span>            : synthesize_implicit_template_parm  (cp_parser *parser, tree constr)
<span class="lineNum">   39144 </span>            : {
<span class="lineNum">   39145 </span>            :   gcc_assert (current_binding_level-&gt;kind == sk_function_parms);
<span class="lineNum">   39146 </span>            : 
<span class="lineNum">   39147 </span>            :    /* Before committing to modifying any scope, if we're in an
<span class="lineNum">   39148 </span><span class="lineCov">      56260 :       implicit template scope, and we're trying to synthesize a</span>
<span class="lineNum">   39149 </span>            :       constrained parameter, try to find a previous parameter with
<span class="lineNum">   39150 </span><span class="lineCov">      56260 :       the same name.  This is the same-type rule for abbreviated</span>
<span class="lineNum">   39151 </span>            :       function templates.
<span class="lineNum">   39152 </span><span class="lineCov">      56260 : </span>
<span class="lineNum">   39153 </span><span class="lineNoCov">          0 :       NOTE: We can generate implicit parameters when tentatively</span>
<span class="lineNum">   39154 </span>            :       parsing a nested name specifier, only to reject that parse
<span class="lineNum">   39155 </span><span class="lineCov">      56260 :       later. However, matching the same template-id as part of a</span>
<span class="lineNum">   39156 </span>            :       direct-declarator should generate an identical template
<span class="lineNum">   39157 </span><span class="lineCov">      56260 :       parameter, so this rule will merge them. */</span>
<span class="lineNum">   39158 </span><span class="lineCov">      56245 :   if (parser-&gt;implicit_template_scope &amp;&amp; constr)</span>
<span class="lineNum">   39159 </span>            :     {
<span class="lineNum">   39160 </span><span class="lineCov">      56241 :       tree t = parser-&gt;implicit_template_parms;</span>
<span class="lineNum">   39161 </span><span class="lineCov">      56204 :       while (t)</span>
<span class="lineNum">   39162 </span><span class="lineCov">      56204 :         {</span>
<span class="lineNum">   39163 </span>            :           if (equivalent_placeholder_constraints (TREE_TYPE (t), constr))
<span class="lineNum">   39164 </span>            :             {
<span class="lineNum">   39165 </span>            :               tree d = TREE_VALUE (t);
<span class="lineNum">   39166 </span>            :               if (TREE_CODE (d) == PARM_DECL)
<span class="lineNum">   39167 </span>            :                 /* Return the TEMPLATE_PARM_INDEX.  */
<span class="lineNum">   39168 </span>            :                 d = DECL_INITIAL (d);
<span class="lineNum">   39169 </span><span class="lineCov">        385 :               return d;</span>
<span class="lineNum">   39170 </span>            :             }
<span class="lineNum">   39171 </span><span class="lineCov">        385 :           t = TREE_CHAIN (t);</span>
<span class="lineNum">   39172 </span><span class="lineCov">        385 :         }</span>
<span class="lineNum">   39173 </span><span class="lineCov">        385 :     }</span>
<span class="lineNum">   39174 </span>            : 
<span class="lineNum">   39175 </span>            :   /* We are either continuing a function template that already contains implicit
<span class="lineNum">   39176 </span>            :      template parameters, creating a new fully-implicit function template, or
<span class="lineNum">   39177 </span>            :      extending an existing explicit function template with implicit template
<span class="lineNum">   39178 </span>            :      parameters.  */
<span class="lineNum">   39179 </span>            : 
<span class="lineNum">   39180 </span>            :   cp_binding_level *const entry_scope = current_binding_level;
<span class="lineNum">   39181 </span><span class="lineCov">        398 : </span>
<span class="lineNum">   39182 </span>            :   bool become_template = false;
<span class="lineNum">   39183 </span><span class="lineCov">        398 :   cp_binding_level *parent_scope = 0;</span>
<span class="lineNum">   39184 </span>            : 
<span class="lineNum">   39185 </span>            :   if (parser-&gt;implicit_template_scope)
<span class="lineNum">   39186 </span>            :     {
<span class="lineNum">   39187 </span>            :       gcc_assert (parser-&gt;implicit_template_parms);
<span class="lineNum">   39188 </span>            : 
<span class="lineNum">   39189 </span>            :       current_binding_level = parser-&gt;implicit_template_scope;
<span class="lineNum">   39190 </span>            :     }
<span class="lineNum">   39191 </span>            :   else
<span class="lineNum">   39192 </span>            :     {
<span class="lineNum">   39193 </span>            :       /* Roll back to the existing template parameter scope (in the case of
<span class="lineNum">   39194 </span>            :          extending an explicit function template) or introduce a new template
<span class="lineNum">   39195 </span>            :          parameter scope ahead of the function parameter scope (or class scope
<span class="lineNum">   39196 </span><span class="lineCov">        398 :          in the case of out-of-line member definitions).  The function scope is</span>
<span class="lineNum">   39197 </span>            :          added back after template parameter synthesis below.  */
<span class="lineNum">   39198 </span><span class="lineCov">         16 : </span>
<span class="lineNum">   39199 </span><span class="lineCov">         19 :       cp_binding_level *scope = entry_scope;</span>
<span class="lineNum">   39200 </span>            : 
<span class="lineNum">   39201 </span><span class="lineCov">         16 :       while (scope-&gt;kind == sk_function_parms)</span>
<span class="lineNum">   39202 </span>            :         {
<span class="lineNum">   39203 </span><span class="lineCov">         13 :           parent_scope = scope;</span>
<span class="lineNum">   39204 </span><span class="lineCov">         13 :           scope = scope-&gt;level_chain;</span>
<span class="lineNum">   39205 </span>            :         }
<span class="lineNum">   39206 </span><span class="lineCov">          1 :       if (current_class_type &amp;&amp; !LAMBDA_TYPE_P (current_class_type))</span>
<span class="lineNum">   39207 </span><span class="lineCov">         13 :         {</span>
<span class="lineNum">   39208 </span>            :           /* If not defining a class, then any class scope is a scope level in
<span class="lineNum">   39209 </span><span class="lineCov">          3 :              an out-of-line member definition.  In this case simply wind back</span>
<span class="lineNum">   39210 </span>            :              beyond the first such scope to inject the template parameter list.
<span class="lineNum">   39211 </span>            :              Otherwise wind back to the class being defined.  The latter can
<span class="lineNum">   39212 </span>            :              occur in class member friend declarations such as:
<span class="lineNum">   39213 </span>            : 
<span class="lineNum">   39214 </span>            :                class A {
<span class="lineNum">   39215 </span>            :                  void foo (auto);
<span class="lineNum">   39216 </span>            :                };
<span class="lineNum">   39217 </span>            :                class B {
<span class="lineNum">   39218 </span><span class="lineCov">        385 :                  friend void A::foo (auto);</span>
<span class="lineNum">   39219 </span>            :                };
<span class="lineNum">   39220 </span><span class="lineCov">        385 : </span>
<span class="lineNum">   39221 </span><span class="lineCov">        385 :             The template parameter list synthesized for the friend declaration</span>
<span class="lineNum">   39222 </span>            :             must be injected in the scope of 'B'.  This can also occur in
<span class="lineNum">   39223 </span><span class="lineCov">        385 :             erroneous cases such as:</span>
<span class="lineNum">   39224 </span>            : 
<span class="lineNum">   39225 </span><span class="lineCov">         38 :                struct A {</span>
<span class="lineNum">   39226 </span>            :                  struct B {
<span class="lineNum">   39227 </span><span class="lineCov">         38 :                    void foo (auto);</span>
<span class="lineNum">   39228 </span>            :                  };
<span class="lineNum">   39229 </span>            :                  void B::foo (auto) {}
<span class="lineNum">   39230 </span>            :                };
<span class="lineNum">   39231 </span>            : 
<span class="lineNum">   39232 </span>            :             Here the attempted definition of 'B::foo' within 'A' is ill-formed
<span class="lineNum">   39233 </span>            :             but, nevertheless, the template parameter list synthesized for the
<span class="lineNum">   39234 </span>            :             declarator should be injected into the scope of 'A' as if the
<span class="lineNum">   39235 </span>            :             ill-formed template was specified explicitly.  */
<span class="lineNum">   39236 </span>            : 
<span class="lineNum">   39237 </span>            :           while (scope-&gt;kind == sk_class &amp;&amp; !scope-&gt;defining_class_p)
<span class="lineNum">   39238 </span>            :             {
<span class="lineNum">   39239 </span><span class="lineCov">        694 :               parent_scope = scope;</span>
<span class="lineNum">   39240 </span>            :               scope = scope-&gt;level_chain;
<span class="lineNum">   39241 </span><span class="lineCov">        347 :             }</span>
<span class="lineNum">   39242 </span><span class="lineCov">        347 :         }</span>
<span class="lineNum">   39243 </span>            : 
<span class="lineNum">   39244 </span><span class="lineCov">        347 :       current_binding_level = scope;</span>
<span class="lineNum">   39245 </span>            : 
<span class="lineNum">   39246 </span>            :       if (scope-&gt;kind != sk_template_parms
<span class="lineNum">   39247 </span>            :           || !function_being_declared_is_template_p (parser))
<span class="lineNum">   39248 </span>            :         {
<span class="lineNum">   39249 </span>            :           /* Introduce a new template parameter list for implicit template
<span class="lineNum">   39250 </span>            :              parameters.  */
<span class="lineNum">   39251 </span>            : 
<span class="lineNum">   39252 </span>            :           become_template = true;
<span class="lineNum">   39253 </span>            : 
<span class="lineNum">   39254 </span>            :           parser-&gt;implicit_template_scope
<span class="lineNum">   39255 </span>            :               = begin_scope (sk_template_parms, NULL);
<span class="lineNum">   39256 </span>            : 
<span class="lineNum">   39257 </span>            :           ++processing_template_decl;
<span class="lineNum">   39258 </span>            : 
<span class="lineNum">   39259 </span>            :           parser-&gt;fully_implicit_function_template_p = true;
<span class="lineNum">   39260 </span>            :           ++parser-&gt;num_template_parameter_lists;
<span class="lineNum">   39261 </span>            :         }
<span class="lineNum">   39262 </span>            :       else
<span class="lineNum">   39263 </span>            :         {
<span class="lineNum">   39264 </span>            :           /* Synthesize implicit template parameters at the end of the explicit
<span class="lineNum">   39265 </span>            :              template parameter list.  */
<span class="lineNum">   39266 </span>            : 
<span class="lineNum">   39267 </span>            :           gcc_assert (current_template_parms);
<span class="lineNum">   39268 </span>            : 
<span class="lineNum">   39269 </span>            :           parser-&gt;implicit_template_scope = scope;
<span class="lineNum">   39270 </span>            : 
<span class="lineNum">   39271 </span>            :           tree v = INNERMOST_TEMPLATE_PARMS (current_template_parms);
<span class="lineNum">   39272 </span>            :           parser-&gt;implicit_template_parms
<span class="lineNum">   39273 </span>            :             = TREE_VEC_ELT (v, TREE_VEC_LENGTH (v) - 1);
<span class="lineNum">   39274 </span>            :         }
<span class="lineNum">   39275 </span><span class="lineCov">         77 :     }</span>
<span class="lineNum">   39276 </span>            : 
<span class="lineNum">   39277 </span><span class="lineCov">         24 :   /* Synthesize a new template parameter and track the current template</span>
<span class="lineNum">   39278 </span><span class="lineCov">         24 :      parameter chain with implicit_template_parms.  */</span>
<span class="lineNum">   39279 </span>            : 
<span class="lineNum">   39280 </span>            :   tree proto = constr ? DECL_INITIAL (constr) : NULL_TREE;
<span class="lineNum">   39281 </span>            :   tree synth_id = make_generic_type_name ();
<span class="lineNum">   39282 </span><span class="lineCov">        347 :   tree synth_tmpl_parm;</span>
<span class="lineNum">   39283 </span>            :   bool non_type = false;
<span class="lineNum">   39284 </span><span class="lineCov">        347 : </span>
<span class="lineNum">   39285 </span><span class="lineCov">        347 :   if (proto == NULL_TREE || TREE_CODE (proto) == TYPE_DECL)</span>
<span class="lineNum">   39286 </span>            :     synth_tmpl_parm
<span class="lineNum">   39287 </span>            :       = finish_template_type_parm (class_type_node, synth_id);
<span class="lineNum">   39288 </span>            :   else if (TREE_CODE (proto) == TEMPLATE_DECL)
<span class="lineNum">   39289 </span>            :     synth_tmpl_parm
<span class="lineNum">   39290 </span><span class="lineCov">        333 :       = finish_constrained_template_template_parm (proto, synth_id);</span>
<span class="lineNum">   39291 </span>            :   else
<span class="lineNum">   39292 </span><span class="lineCov">        333 :     {</span>
<span class="lineNum">   39293 </span><span class="lineCov">        333 :       synth_tmpl_parm = copy_decl (proto);</span>
<span class="lineNum">   39294 </span>            :       DECL_NAME (synth_tmpl_parm) = synth_id;
<span class="lineNum">   39295 </span><span class="lineCov">        333 :       non_type = true;</span>
<span class="lineNum">   39296 </span>            :     }
<span class="lineNum">   39297 </span><span class="lineCov">        333 : </span>
<span class="lineNum">   39298 </span><span class="lineCov">        333 :   // Attach the constraint to the parm before processing.</span>
<span class="lineNum">   39299 </span>            :   tree node = build_tree_list (NULL_TREE, synth_tmpl_parm);
<span class="lineNum">   39300 </span>            :   TREE_TYPE (node) = constr;
<span class="lineNum">   39301 </span>            :   tree new_parm
<span class="lineNum">   39302 </span>            :     = process_template_parm (parser-&gt;implicit_template_parms,
<span class="lineNum">   39303 </span>            :                              input_location,
<span class="lineNum">   39304 </span>            :                              node,
<span class="lineNum">   39305 </span><span class="lineCov">         14 :                              /*non_type=*/non_type,</span>
<span class="lineNum">   39306 </span>            :                              /*param_pack=*/false);
<span class="lineNum">   39307 </span><span class="lineCov">         14 : </span>
<span class="lineNum">   39308 </span>            :   // Chain the new parameter to the list of implicit parameters.
<span class="lineNum">   39309 </span><span class="lineCov">         14 :   if (parser-&gt;implicit_template_parms)</span>
<span class="lineNum">   39310 </span><span class="lineCov">         14 :     parser-&gt;implicit_template_parms</span>
<span class="lineNum">   39311 </span><span class="lineCov">         14 :       = TREE_CHAIN (parser-&gt;implicit_template_parms);</span>
<span class="lineNum">   39312 </span>            :   else
<span class="lineNum">   39313 </span>            :     parser-&gt;implicit_template_parms = new_parm;
<span class="lineNum">   39314 </span>            : 
<span class="lineNum">   39315 </span>            :   tree new_decl = get_local_decls ();
<span class="lineNum">   39316 </span>            :   if (non_type)
<span class="lineNum">   39317 </span>            :     /* Return the TEMPLATE_PARM_INDEX, not the PARM_DECL.  */
<span class="lineNum">   39318 </span><span class="lineCov">        385 :     new_decl = DECL_INITIAL (new_decl);</span>
<span class="lineNum">   39319 </span><span class="lineCov">        385 : </span>
<span class="lineNum">   39320 </span><span class="lineCov">        385 :   /* If creating a fully implicit function template, start the new implicit</span>
<span class="lineNum">   39321 </span><span class="lineCov">        385 :      template parameter list with this synthesized type, otherwise grow the</span>
<span class="lineNum">   39322 </span>            :      current template parameter list.  */
<span class="lineNum">   39323 </span><span class="lineCov">        385 : </span>
<span class="lineNum">   39324 </span><span class="lineCov">        382 :   if (become_template)</span>
<span class="lineNum">   39325 </span><span class="lineCov">        382 :     {</span>
<span class="lineNum">   39326 </span><span class="lineCov">          3 :       parent_scope-&gt;level_chain = current_binding_level;</span>
<span class="lineNum">   39327 </span><span class="lineCov">          1 : </span>
<span class="lineNum">   39328 </span><span class="lineCov">          1 :       tree new_parms = make_tree_vec (1);</span>
<span class="lineNum">   39329 </span>            :       TREE_VEC_ELT (new_parms, 0) = parser-&gt;implicit_template_parms;
<span class="lineNum">   39330 </span>            :       current_template_parms = tree_cons (size_int (processing_template_decl),
<span class="lineNum">   39331 </span><span class="lineCov">          2 :                                           new_parms, current_template_parms);</span>
<span class="lineNum">   39332 </span><span class="lineCov">          2 :     }</span>
<span class="lineNum">   39333 </span><span class="lineCov">          2 :   else</span>
<span class="lineNum">   39334 </span>            :     {
<span class="lineNum">   39335 </span>            :       tree&amp; new_parms = INNERMOST_TEMPLATE_PARMS (current_template_parms);
<span class="lineNum">   39336 </span>            :       int new_parm_idx = TREE_VEC_LENGTH (new_parms);
<span class="lineNum">   39337 </span><span class="lineCov">        385 :       new_parms = grow_tree_vec (new_parms, new_parm_idx + 1);</span>
<span class="lineNum">   39338 </span><span class="lineCov">        385 :       TREE_VEC_ELT (new_parms, new_parm_idx) = parser-&gt;implicit_template_parms;</span>
<span class="lineNum">   39339 </span><span class="lineCov">        385 :     }</span>
<span class="lineNum">   39340 </span><span class="lineCov">        385 : </span>
<span class="lineNum">   39341 </span>            :   // If the new parameter was constrained, we need to add that to the
<span class="lineNum">   39342 </span>            :   // constraints in the template parameter list.
<span class="lineNum">   39343 </span>            :   if (tree req = TEMPLATE_PARM_CONSTRAINTS (tree_last (new_parm)))
<span class="lineNum">   39344 </span>            :     {
<span class="lineNum">   39345 </span>            :       tree reqs = TEMPLATE_PARMS_CONSTRAINTS (current_template_parms);
<span class="lineNum">   39346 </span>            :       reqs = conjoin_constraints (reqs, req);
<span class="lineNum">   39347 </span><span class="lineCov">        385 :       TEMPLATE_PARMS_CONSTRAINTS (current_template_parms) = reqs;</span>
<span class="lineNum">   39348 </span><span class="lineCov">         52 :     }</span>
<span class="lineNum">   39349 </span><span class="lineCov">         52 : </span>
<span class="lineNum">   39350 </span>            :   current_binding_level = entry_scope;
<span class="lineNum">   39351 </span><span class="lineCov">        333 : </span>
<span class="lineNum">   39352 </span>            :   return new_decl;
<span class="lineNum">   39353 </span><span class="lineCov">        385 : }</span>
<span class="lineNum">   39354 </span><span class="lineCov">        385 : </span>
<span class="lineNum">   39355 </span>            : /* Finish the declaration of a fully implicit function template.  Such a
<span class="lineNum">   39356 </span><span class="lineCov">          2 :    template has no explicit template parameter list so has not been through the</span>
<span class="lineNum">   39357 </span>            :    normal template head and tail processing.  synthesize_implicit_template_parm
<span class="lineNum">   39358 </span>            :    tries to do the head; this tries to do the tail.  MEMBER_DECL_OPT should be
<span class="lineNum">   39359 </span>            :    provided if the declaration is a class member such that its template
<span class="lineNum">   39360 </span>            :    declaration can be completed.  If MEMBER_DECL_OPT is provided the finished
<span class="lineNum">   39361 </span>            :    form is returned.  Otherwise NULL_TREE is returned. */
<a name="39362"><span class="lineNum">   39362 </span><span class="lineCov">        385 : </span></a>
<span class="lineNum">   39363 </span>            : static tree
<span class="lineNum">   39364 </span><span class="lineCov">        333 : finish_fully_implicit_template (cp_parser *parser, tree member_decl_opt)</span>
<span class="lineNum">   39365 </span>            : {
<span class="lineNum">   39366 </span><span class="lineCov">        333 :   gcc_assert (parser-&gt;fully_implicit_function_template_p);</span>
<span class="lineNum">   39367 </span><span class="lineCov">        333 : </span>
<span class="lineNum">   39368 </span><span class="lineCov">        666 :   if (member_decl_opt &amp;&amp; member_decl_opt != error_mark_node</span>
<span class="lineNum">   39369 </span>            :       &amp;&amp; DECL_VIRTUAL_P (member_decl_opt))
<span class="lineNum">   39370 </span>            :     {
<span class="lineNum">   39371 </span>            :       error_at (DECL_SOURCE_LOCATION (member_decl_opt),
<span class="lineNum">   39372 </span>            :                 &quot;implicit templates may not be %&lt;virtual%&gt;&quot;);
<span class="lineNum">   39373 </span><span class="lineCov">         52 :       DECL_VIRTUAL_P (member_decl_opt) = false;</span>
<span class="lineNum">   39374 </span><span class="lineCov">         52 :     }</span>
<span class="lineNum">   39375 </span><span class="lineCov">         52 : </span>
<span class="lineNum">   39376 </span><span class="lineCov">         52 :   if (member_decl_opt)</span>
<span class="lineNum">   39377 </span>            :     member_decl_opt = finish_member_template_decl (member_decl_opt);
<span class="lineNum">   39378 </span>            :   end_template_decl ();
<span class="lineNum">   39379 </span>            : 
<span class="lineNum">   39380 </span>            :   parser-&gt;fully_implicit_function_template_p = false;
<span class="lineNum">   39381 </span><span class="lineCov">        385 :   parser-&gt;implicit_template_parms = 0;</span>
<span class="lineNum">   39382 </span>            :   parser-&gt;implicit_template_scope = 0;
<span class="lineNum">   39383 </span><span class="lineCov">         52 :   --parser-&gt;num_template_parameter_lists;</span>
<span class="lineNum">   39384 </span><span class="lineCov">         52 : </span>
<span class="lineNum">   39385 </span><span class="lineCov">         52 :   return member_decl_opt;</span>
<span class="lineNum">   39386 </span>            : }
<span class="lineNum">   39387 </span>            : 
<span class="lineNum">   39388 </span><span class="lineCov">        385 : /* Like finish_fully_implicit_template, but to be used in error</span>
<span class="lineNum">   39389 </span>            :    recovery, rearranging scopes so that we restore the state we had
<span class="lineNum">   39390 </span><span class="lineCov">        385 :    before synthesize_implicit_template_parm inserted the implement</span>
<span class="lineNum">   39391 </span>            :    template parms scope.  */
<a name="39392"><span class="lineNum">   39392 </span>            : </a>
<span class="lineNum">   39393 </span>            : static void
<span class="lineNum">   39394 </span>            : abort_fully_implicit_template (cp_parser *parser)
<span class="lineNum">   39395 </span>            : {
<span class="lineNum">   39396 </span>            :   cp_binding_level *return_to_scope = current_binding_level;
<span class="lineNum">   39397 </span>            : 
<span class="lineNum">   39398 </span>            :   if (parser-&gt;implicit_template_scope
<span class="lineNum">   39399 </span>            :       &amp;&amp; return_to_scope != parser-&gt;implicit_template_scope)
<span class="lineNum">   39400 </span>            :     {
<span class="lineNum">   39401 </span>            :       cp_binding_level *child = return_to_scope;
<span class="lineNum">   39402 </span><span class="lineCov">        333 :       for (cp_binding_level *scope = child-&gt;level_chain;</span>
<span class="lineNum">   39403 </span>            :            scope != parser-&gt;implicit_template_scope;
<span class="lineNum">   39404 </span><span class="lineCov">        333 :            scope = child-&gt;level_chain)</span>
<span class="lineNum">   39405 </span>            :         child = scope;
<span class="lineNum">   39406 </span><span class="lineCov">        247 :       child-&gt;level_chain = parser-&gt;implicit_template_scope-&gt;level_chain;</span>
<span class="lineNum">   39407 </span><span class="lineCov">        580 :       parser-&gt;implicit_template_scope-&gt;level_chain = return_to_scope;</span>
<span class="lineNum">   39408 </span>            :       current_binding_level = parser-&gt;implicit_template_scope;
<span class="lineNum">   39409 </span><span class="lineCov">          1 :     }</span>
<span class="lineNum">   39410 </span>            :   else
<span class="lineNum">   39411 </span><span class="lineCov">          1 :     return_to_scope = return_to_scope-&gt;level_chain;</span>
<span class="lineNum">   39412 </span>            : 
<span class="lineNum">   39413 </span>            :   finish_fully_implicit_template (parser, NULL);
<span class="lineNum">   39414 </span><span class="lineCov">        333 : </span>
<span class="lineNum">   39415 </span><span class="lineCov">        247 :   gcc_assert (current_binding_level == return_to_scope);</span>
<span class="lineNum">   39416 </span><span class="lineCov">        333 : }</span>
<span class="lineNum">   39417 </span>            : 
<span class="lineNum">   39418 </span><span class="lineCov">        333 : /* Helper function for diagnostics that have complained about things</span>
<span class="lineNum">   39419 </span><span class="lineCov">        333 :    being used with 'extern &quot;C&quot;' linkage.</span>
<span class="lineNum">   39420 </span><span class="lineCov">        333 : </span>
<span class="lineNum">   39421 </span><span class="lineCov">        333 :    Attempt to issue a note showing where the 'extern &quot;C&quot;' linkage began.  */</span>
<a name="39422"><span class="lineNum">   39422 </span>            : </a>
<span class="lineNum">   39423 </span><span class="lineCov">        333 : void</span>
<span class="lineNum">   39424 </span>            : maybe_show_extern_c_location (void)
<span class="lineNum">   39425 </span>            : {
<span class="lineNum">   39426 </span>            :   if (the_parser-&gt;innermost_linkage_specification_location != UNKNOWN_LOCATION)
<span class="lineNum">   39427 </span>            :     inform (the_parser-&gt;innermost_linkage_specification_location,
<span class="lineNum">   39428 </span>            :             &quot;%&lt;extern \&quot;C\&quot;%&gt; linkage started here&quot;);
<span class="lineNum">   39429 </span>            : }
<span class="lineNum">   39430 </span>            : 
<span class="lineNum">   39431 </span>            : #include &quot;gt-cp-parser.h&quot;
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.0</a></td></tr>
  </table>
  <br>
<h3>LCOV profile is generated on x86_64 machine using following configure options: configure --disable-bootstrap --enable-coverage=opt --enable-languages=c,c++,fortran,go,jit,lto --enable-host-shared. GCC test suite is run with the built compiler.</h3></body></html>
