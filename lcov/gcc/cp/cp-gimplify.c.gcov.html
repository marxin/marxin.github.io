<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - gcc.info - gcc/cp/cp-gimplify.c</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">gcc/cp</a> - cp-gimplify.c<span style="font-size: 80%;"> (source / <a href="cp-gimplify.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">gcc.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">1378</td>
            <td class="headerCovTableEntry">1422</td>
            <td class="headerCovTableEntryHi">96.9 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-09-22 10:58:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">51</td>
            <td class="headerCovTableEntry">52</td>
            <td class="headerCovTableEntryHi">98.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* C++-specific tree lowering bits; see also c-gimplify.c and tree-gimple.c.</a>
<span class="lineNum">       2 </span>            : 
<span class="lineNum">       3 </span>            :    Copyright (C) 2002-2018 Free Software Foundation, Inc.
<span class="lineNum">       4 </span>            :    Contributed by Jason Merrill &lt;jason@redhat.com&gt;
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : This file is part of GCC.
<span class="lineNum">       7 </span>            : 
<span class="lineNum">       8 </span>            : GCC is free software; you can redistribute it and/or modify it under
<span class="lineNum">       9 </span>            : the terms of the GNU General Public License as published by the Free
<span class="lineNum">      10 </span>            : Software Foundation; either version 3, or (at your option) any later
<span class="lineNum">      11 </span>            : version.
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            : GCC is distributed in the hope that it will be useful, but WITHOUT ANY
<span class="lineNum">      14 </span>            : WARRANTY; without even the implied warranty of MERCHANTABILITY or
<span class="lineNum">      15 </span>            : FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
<span class="lineNum">      16 </span>            : for more details.
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : You should have received a copy of the GNU General Public License
<span class="lineNum">      19 </span>            : along with GCC; see the file COPYING3.  If not see
<span class="lineNum">      20 </span>            : &lt;http://www.gnu.org/licenses/&gt;.  */
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : #include &quot;config.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;system.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;coretypes.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;target.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;basic-block.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;cp-tree.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;gimple.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;predict.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;stor-layout.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;tree-iterator.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;gimplify.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;c-family/c-ubsan.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;stringpool.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;attribs.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;asan.h&quot;
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : /* Forward declarations.  */
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span>            : static tree cp_genericize_r (tree *, int *, void *);
<span class="lineNum">      41 </span>            : static tree cp_fold_r (tree *, int *, void *);
<span class="lineNum">      42 </span>            : static void cp_genericize_tree (tree*, bool);
<span class="lineNum">      43 </span>            : static tree cp_fold (tree);
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            : /* Local declarations.  */
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            : enum bc_t { bc_break = 0, bc_continue = 1 };
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            : /* Stack of labels which are targets for &quot;break&quot; or &quot;continue&quot;,
<span class="lineNum">      50 </span>            :    linked through TREE_CHAIN.  */
<span class="lineNum">      51 </span>            : static tree bc_label[2];
<span class="lineNum">      52 </span>            : 
<span class="lineNum">      53 </span>            : /* Begin a scope which can be exited by a break or continue statement.  BC
<span class="lineNum">      54 </span>            :    indicates which.
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            :    Just creates a label with location LOCATION and pushes it into the current
<span class="lineNum">      57 </span>            :    context.  */
<span class="lineNum">      58 </span>            : 
<span class="lineNum">      59 </span>            : static tree
<span class="lineNum">      60 </span><span class="lineCov">     479880 : begin_bc_block (enum bc_t bc, location_t location)</span>
<span class="lineNum">      61 </span>            : {
<span class="lineNum">      62 </span><span class="lineCov">     479880 :   tree label = create_artificial_label (location);</span>
<span class="lineNum">      63 </span><span class="lineCov">     479880 :   DECL_CHAIN (label) = bc_label[bc];</span>
<span class="lineNum">      64 </span><span class="lineCov">     479880 :   bc_label[bc] = label;</span>
<span class="lineNum">      65 </span><span class="lineCov">     479880 :   if (bc == bc_break)</span>
<span class="lineNum">      66 </span><span class="lineCov">     246680 :     LABEL_DECL_BREAK (label) = true;</span>
<span class="lineNum">      67 </span>            :   else
<span class="lineNum">      68 </span><span class="lineCov">     233200 :     LABEL_DECL_CONTINUE (label) = true;</span>
<span class="lineNum">      69 </span><span class="lineCov">     479880 :   return label;</span>
<span class="lineNum">      70 </span>            : }
<span class="lineNum">      71 </span>            : 
<span class="lineNum">      72 </span>            : /* Finish a scope which can be exited by a break or continue statement.
<span class="lineNum">      73 </span>            :    LABEL was returned from the most recent call to begin_bc_block.  BLOCK is
<span class="lineNum">      74 </span>            :    an expression for the contents of the scope.
<span class="lineNum">      75 </span>            : 
<span class="lineNum">      76 </span>            :    If we saw a break (or continue) in the scope, append a LABEL_EXPR to
<span class="lineNum">      77 </span>            :    BLOCK.  Otherwise, just forget the label.  */
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span>            : static void
<span class="lineNum">      80 </span><span class="lineCov">     479880 : finish_bc_block (tree *block, enum bc_t bc, tree label)</span>
<span class="lineNum">      81 </span>            : {
<span class="lineNum">      82 </span><span class="lineCov">     479880 :   gcc_assert (label == bc_label[bc]);</span>
<span class="lineNum">      83 </span>            : 
<span class="lineNum">      84 </span><span class="lineCov">     479880 :   if (TREE_USED (label))</span>
<span class="lineNum">      85 </span><span class="lineCov">     150085 :     append_to_statement_list (build1 (LABEL_EXPR, void_type_node, label),</span>
<span class="lineNum">      86 </span>            :                               block);
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span><span class="lineCov">     479880 :   bc_label[bc] = DECL_CHAIN (label);</span>
<span class="lineNum">      89 </span><span class="lineCov">     479880 :   DECL_CHAIN (label) = NULL_TREE;</span>
<span class="lineNum">      90 </span><span class="lineCov">     479880 : }</span>
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span>            : /* Get the LABEL_EXPR to represent a break or continue statement
<span class="lineNum">      93 </span>            :    in the current block scope.  BC indicates which.  */
<a name="94"><span class="lineNum">      94 </span>            : </a>
<span class="lineNum">      95 </span>            : static tree
<span class="lineNum">      96 </span><span class="lineNoCov">          0 : get_bc_label (enum bc_t bc)</span>
<span class="lineNum">      97 </span>            : {
<span class="lineNum">      98 </span><span class="lineCov">     239230 :   tree label = bc_label[bc];</span>
<span class="lineNum">      99 </span>            : 
<span class="lineNum">     100 </span>            :   /* Mark the label used for finish_bc_block.  */
<span class="lineNum">     101 </span><span class="lineCov">     239230 :   TREE_USED (label) = 1;</span>
<span class="lineNum">     102 </span><span class="lineCov">     239230 :   return label;</span>
<span class="lineNum">     103 </span>            : }
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span>            : /* Genericize a TRY_BLOCK.  */
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span>            : static void
<span class="lineNum">     108 </span><span class="lineCov">      19560 : genericize_try_block (tree *stmt_p)</span>
<span class="lineNum">     109 </span>            : {
<span class="lineNum">     110 </span><span class="lineCov">      19560 :   tree body = TRY_STMTS (*stmt_p);</span>
<span class="lineNum">     111 </span><span class="lineCov">      39120 :   tree cleanup = TRY_HANDLERS (*stmt_p);</span>
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span><span class="lineCov">      19560 :   *stmt_p = build2 (TRY_CATCH_EXPR, void_type_node, body, cleanup);</span>
<span class="lineNum">     114 </span><span class="lineCov">      19560 : }</span>
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span>            : /* Genericize a HANDLER by converting to a CATCH_EXPR.  */
<span class="lineNum">     117 </span>            : 
<span class="lineNum">     118 </span>            : static void
<span class="lineNum">     119 </span><span class="lineCov">      21435 : genericize_catch_block (tree *stmt_p)</span>
<span class="lineNum">     120 </span>            : {
<span class="lineNum">     121 </span><span class="lineCov">      21435 :   tree type = HANDLER_TYPE (*stmt_p);</span>
<span class="lineNum">     122 </span><span class="lineCov">      42870 :   tree body = HANDLER_BODY (*stmt_p);</span>
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span>            :   /* FIXME should the caught type go in TREE_TYPE?  */
<span class="lineNum">     125 </span><span class="lineCov">      21435 :   *stmt_p = build2 (CATCH_EXPR, void_type_node, type, body);</span>
<span class="lineNum">     126 </span><span class="lineCov">      21435 : }</span>
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span>            : /* A terser interface for building a representation of an exception
<span class="lineNum">     129 </span>            :    specification.  */
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span>            : static tree
<span class="lineNum">     132 </span><span class="lineCov">       8070 : build_gimple_eh_filter_tree (tree body, tree allowed, tree failure)</span>
<span class="lineNum">     133 </span>            : {
<span class="lineNum">     134 </span><span class="lineCov">       8070 :   tree t;</span>
<span class="lineNum">     135 </span>            : 
<span class="lineNum">     136 </span>            :   /* FIXME should the allowed types go in TREE_TYPE?  */
<span class="lineNum">     137 </span><span class="lineCov">       8070 :   t = build2 (EH_FILTER_EXPR, void_type_node, allowed, NULL_TREE);</span>
<span class="lineNum">     138 </span><span class="lineCov">       8070 :   append_to_statement_list (failure, &amp;EH_FILTER_FAILURE (t));</span>
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span><span class="lineCov">       8070 :   t = build2 (TRY_CATCH_EXPR, void_type_node, NULL_TREE, t);</span>
<span class="lineNum">     141 </span><span class="lineCov">       8070 :   append_to_statement_list (body, &amp;TREE_OPERAND (t, 0));</span>
<span class="lineNum">     142 </span>            : 
<span class="lineNum">     143 </span><span class="lineCov">       8070 :   return t;</span>
<span class="lineNum">     144 </span>            : }
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span>            : /* Genericize an EH_SPEC_BLOCK by converting it to a
<span class="lineNum">     147 </span>            :    TRY_CATCH_EXPR/EH_FILTER_EXPR pair.  */
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span>            : static void
<span class="lineNum">     150 </span><span class="lineCov">       8070 : genericize_eh_spec_block (tree *stmt_p)</span>
<span class="lineNum">     151 </span>            : {
<span class="lineNum">     152 </span><span class="lineCov">       8070 :   tree body = EH_SPEC_STMTS (*stmt_p);</span>
<span class="lineNum">     153 </span><span class="lineCov">      16140 :   tree allowed = EH_SPEC_RAISES (*stmt_p);</span>
<span class="lineNum">     154 </span><span class="lineCov">       8070 :   tree failure = build_call_n (call_unexpected_fn, 1, build_exc_ptr ());</span>
<span class="lineNum">     155 </span>            : 
<span class="lineNum">     156 </span><span class="lineCov">       8070 :   *stmt_p = build_gimple_eh_filter_tree (body, allowed, failure);</span>
<span class="lineNum">     157 </span><span class="lineCov">       8070 :   TREE_NO_WARNING (*stmt_p) = true;</span>
<span class="lineNum">     158 </span><span class="lineCov">       8070 :   TREE_NO_WARNING (TREE_OPERAND (*stmt_p, 1)) = true;</span>
<span class="lineNum">     159 </span><span class="lineCov">       8070 : }</span>
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span>            : /* Genericize an IF_STMT by turning it into a COND_EXPR.  */
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span>            : static void
<span class="lineNum">     164 </span><span class="lineCov">    1885084 : genericize_if_stmt (tree *stmt_p)</span>
<span class="lineNum">     165 </span>            : {
<span class="lineNum">     166 </span><span class="lineCov">    1885084 :   tree stmt, cond, then_, else_;</span>
<span class="lineNum">     167 </span><span class="lineCov">    1885084 :   location_t locus = EXPR_LOCATION (*stmt_p);</span>
<span class="lineNum">     168 </span>            : 
<span class="lineNum">     169 </span><span class="lineCov">    1885084 :   stmt = *stmt_p;</span>
<span class="lineNum">     170 </span><span class="lineCov">    1885084 :   cond = IF_COND (stmt);</span>
<span class="lineNum">     171 </span><span class="lineCov">    3770168 :   then_ = THEN_CLAUSE (stmt);</span>
<span class="lineNum">     172 </span><span class="lineCov">    3770168 :   else_ = ELSE_CLAUSE (stmt);</span>
<span class="lineNum">     173 </span>            : 
<span class="lineNum">     174 </span><span class="lineCov">    1885084 :   if (!then_)</span>
<span class="lineNum">     175 </span><span class="lineCov">         17 :     then_ = build_empty_stmt (locus);</span>
<span class="lineNum">     176 </span><span class="lineCov">    1885084 :   if (!else_)</span>
<span class="lineNum">     177 </span><span class="lineCov">    1336234 :     else_ = build_empty_stmt (locus);</span>
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span><span class="lineCov">    1885084 :   if (integer_nonzerop (cond) &amp;&amp; !TREE_SIDE_EFFECTS (else_))</span>
<span class="lineNum">     180 </span>            :     stmt = then_;
<span class="lineNum">     181 </span><span class="lineCov">    1864533 :   else if (integer_zerop (cond) &amp;&amp; !TREE_SIDE_EFFECTS (then_))</span>
<span class="lineNum">     182 </span>            :     stmt = else_;
<span class="lineNum">     183 </span>            :   else
<span class="lineNum">     184 </span><span class="lineCov">    1830566 :     stmt = build3 (COND_EXPR, void_type_node, cond, then_, else_);</span>
<span class="lineNum">     185 </span><span class="lineCov">    1885084 :   if (!EXPR_HAS_LOCATION (stmt))</span>
<span class="lineNum">     186 </span><span class="lineCov">    1846617 :     protected_set_expr_location (stmt, locus);</span>
<span class="lineNum">     187 </span><span class="lineCov">    1885084 :   *stmt_p = stmt;</span>
<span class="lineNum">     188 </span><span class="lineCov">    1885084 : }</span>
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span>            : /* Build a generic representation of one of the C loop forms.  COND is the
<span class="lineNum">     191 </span>            :    loop condition or NULL_TREE.  BODY is the (possibly compound) statement
<span class="lineNum">     192 </span>            :    controlled by the loop.  INCR is the increment expression of a for-loop,
<span class="lineNum">     193 </span>            :    or NULL_TREE.  COND_IS_FIRST indicates whether the condition is
<span class="lineNum">     194 </span>            :    evaluated before the loop body as in while and for loops, or after the
<span class="lineNum">     195 </span>            :    loop body as in do-while loops.  */
<span class="lineNum">     196 </span>            : 
<span class="lineNum">     197 </span>            : static void
<span class="lineNum">     198 </span><span class="lineCov">     223984 : genericize_cp_loop (tree *stmt_p, location_t start_locus, tree cond, tree body,</span>
<span class="lineNum">     199 </span>            :                     tree incr, bool cond_is_first, int *walk_subtrees,
<span class="lineNum">     200 </span>            :                     void *data)
<span class="lineNum">     201 </span>            : {
<span class="lineNum">     202 </span><span class="lineCov">     223984 :   tree blab, clab;</span>
<span class="lineNum">     203 </span><span class="lineCov">     223984 :   tree exit = NULL;</span>
<span class="lineNum">     204 </span><span class="lineCov">     223984 :   tree stmt_list = NULL;</span>
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span><span class="lineCov">     223984 :   blab = begin_bc_block (bc_break, start_locus);</span>
<span class="lineNum">     207 </span><span class="lineCov">     223984 :   clab = begin_bc_block (bc_continue, start_locus);</span>
<span class="lineNum">     208 </span>            : 
<span class="lineNum">     209 </span><span class="lineCov">     223984 :   protected_set_expr_location (incr, start_locus);</span>
<span class="lineNum">     210 </span>            : 
<span class="lineNum">     211 </span><span class="lineCov">     223984 :   cp_walk_tree (&amp;cond, cp_genericize_r, data, NULL);</span>
<span class="lineNum">     212 </span><span class="lineCov">     223984 :   cp_walk_tree (&amp;body, cp_genericize_r, data, NULL);</span>
<span class="lineNum">     213 </span><span class="lineCov">     223984 :   cp_walk_tree (&amp;incr, cp_genericize_r, data, NULL);</span>
<span class="lineNum">     214 </span><span class="lineCov">     223984 :   *walk_subtrees = 0;</span>
<span class="lineNum">     215 </span>            : 
<span class="lineNum">     216 </span><span class="lineCov">     223984 :   if (cond &amp;&amp; TREE_CODE (cond) != INTEGER_CST)</span>
<span class="lineNum">     217 </span>            :     {
<span class="lineNum">     218 </span>            :       /* If COND is constant, don't bother building an exit.  If it's false,
<span class="lineNum">     219 </span>            :          we won't build a loop.  If it's true, any exits are in the body.  */
<span class="lineNum">     220 </span><span class="lineCov">     126088 :       location_t cloc = cp_expr_loc_or_loc (cond, start_locus);</span>
<span class="lineNum">     221 </span><span class="lineCov">     126088 :       exit = build1_loc (cloc, GOTO_EXPR, void_type_node,</span>
<span class="lineNum">     222 </span>            :                          get_bc_label (bc_break));
<span class="lineNum">     223 </span><span class="lineCov">     126088 :       exit = fold_build3_loc (cloc, COND_EXPR, void_type_node, cond,</span>
<span class="lineNum">     224 </span>            :                               build_empty_stmt (cloc), exit);
<span class="lineNum">     225 </span>            :     }
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span><span class="lineCov">     223984 :   if (exit &amp;&amp; cond_is_first)</span>
<span class="lineNum">     228 </span><span class="lineCov">     123056 :     append_to_statement_list (exit, &amp;stmt_list);</span>
<span class="lineNum">     229 </span><span class="lineCov">     223984 :   append_to_statement_list (body, &amp;stmt_list);</span>
<span class="lineNum">     230 </span><span class="lineCov">     223984 :   finish_bc_block (&amp;stmt_list, bc_continue, clab);</span>
<span class="lineNum">     231 </span><span class="lineCov">     223984 :   append_to_statement_list (incr, &amp;stmt_list);</span>
<span class="lineNum">     232 </span><span class="lineCov">     223984 :   if (exit &amp;&amp; !cond_is_first)</span>
<span class="lineNum">     233 </span><span class="lineCov">       3032 :     append_to_statement_list (exit, &amp;stmt_list);</span>
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span><span class="lineCov">     223984 :   if (!stmt_list)</span>
<span class="lineNum">     236 </span><span class="lineCov">       1221 :     stmt_list = build_empty_stmt (start_locus);</span>
<span class="lineNum">     237 </span>            : 
<span class="lineNum">     238 </span><span class="lineCov">     223984 :   tree loop;</span>
<span class="lineNum">     239 </span><span class="lineCov">     223984 :   if (cond &amp;&amp; integer_zerop (cond))</span>
<span class="lineNum">     240 </span>            :     {
<span class="lineNum">     241 </span><span class="lineCov">      86077 :       if (cond_is_first)</span>
<span class="lineNum">     242 </span><span class="lineCov">         58 :         loop = fold_build3_loc (start_locus, COND_EXPR,</span>
<span class="lineNum">     243 </span>            :                                 void_type_node, cond, stmt_list,
<span class="lineNum">     244 </span>            :                                 build_empty_stmt (start_locus));
<span class="lineNum">     245 </span>            :       else
<span class="lineNum">     246 </span><span class="lineCov">      86019 :         loop = stmt_list;</span>
<span class="lineNum">     247 </span>            :     }
<span class="lineNum">     248 </span>            :   else
<span class="lineNum">     249 </span>            :     {
<span class="lineNum">     250 </span><span class="lineCov">     137907 :       location_t loc = start_locus;</span>
<span class="lineNum">     251 </span><span class="lineCov">     137907 :       if (!cond || integer_nonzerop (cond))</span>
<span class="lineNum">     252 </span><span class="lineCov">      11819 :         loc = EXPR_LOCATION (expr_first (body));</span>
<span class="lineNum">     253 </span><span class="lineCov">     137696 :       if (loc == UNKNOWN_LOCATION)</span>
<span class="lineNum">     254 </span>            :         loc = start_locus;
<span class="lineNum">     255 </span><span class="lineCov">     137907 :       loop = build1_loc (loc, LOOP_EXPR, void_type_node, stmt_list);</span>
<span class="lineNum">     256 </span>            :     }
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span><span class="lineCov">     223984 :   stmt_list = NULL;</span>
<span class="lineNum">     259 </span><span class="lineCov">     223984 :   append_to_statement_list (loop, &amp;stmt_list);</span>
<span class="lineNum">     260 </span><span class="lineCov">     223984 :   finish_bc_block (&amp;stmt_list, bc_break, blab);</span>
<span class="lineNum">     261 </span><span class="lineCov">     223984 :   if (!stmt_list)</span>
<span class="lineNum">     262 </span><span class="lineCov">       1047 :     stmt_list = build_empty_stmt (start_locus);</span>
<span class="lineNum">     263 </span>            : 
<span class="lineNum">     264 </span><span class="lineCov">     223984 :   *stmt_p = stmt_list;</span>
<span class="lineNum">     265 </span><span class="lineCov">     223984 : }</span>
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span>            : /* Genericize a FOR_STMT node *STMT_P.  */
<span class="lineNum">     268 </span>            : 
<span class="lineNum">     269 </span>            : static void
<span class="lineNum">     270 </span><span class="lineCov">      96604 : genericize_for_stmt (tree *stmt_p, int *walk_subtrees, void *data)</span>
<span class="lineNum">     271 </span>            : {
<span class="lineNum">     272 </span><span class="lineCov">      96604 :   tree stmt = *stmt_p;</span>
<span class="lineNum">     273 </span><span class="lineCov">      96604 :   tree expr = NULL;</span>
<span class="lineNum">     274 </span><span class="lineCov">      96604 :   tree loop;</span>
<span class="lineNum">     275 </span><span class="lineCov">      96604 :   tree init = FOR_INIT_STMT (stmt);</span>
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span><span class="lineCov">      96604 :   if (init)</span>
<span class="lineNum">     278 </span>            :     {
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :       cp_walk_tree (&amp;init, cp_genericize_r, data, NULL);</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :       append_to_statement_list (init, &amp;expr);</span>
<span class="lineNum">     281 </span>            :     }
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span><span class="lineCov">     193208 :   genericize_cp_loop (&amp;loop, EXPR_LOCATION (stmt), FOR_COND (stmt),</span>
<span class="lineNum">     284 </span><span class="lineCov">      96604 :                       FOR_BODY (stmt), FOR_EXPR (stmt), 1, walk_subtrees, data);</span>
<span class="lineNum">     285 </span><span class="lineCov">      96604 :   append_to_statement_list (loop, &amp;expr);</span>
<span class="lineNum">     286 </span><span class="lineCov">      96604 :   if (expr == NULL_TREE)</span>
<span class="lineNum">     287 </span><span class="lineCov">         17 :     expr = loop;</span>
<span class="lineNum">     288 </span><span class="lineCov">      96604 :   *stmt_p = expr;</span>
<span class="lineNum">     289 </span><span class="lineCov">      96604 : }</span>
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span>            : /* Genericize a WHILE_STMT node *STMT_P.  */
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span>            : static void
<span class="lineNum">     294 </span><span class="lineCov">      38268 : genericize_while_stmt (tree *stmt_p, int *walk_subtrees, void *data)</span>
<span class="lineNum">     295 </span>            : {
<span class="lineNum">     296 </span><span class="lineCov">      38268 :   tree stmt = *stmt_p;</span>
<span class="lineNum">     297 </span><span class="lineCov">      76536 :   genericize_cp_loop (stmt_p, EXPR_LOCATION (stmt), WHILE_COND (stmt),</span>
<span class="lineNum">     298 </span><span class="lineCov">      38268 :                       WHILE_BODY (stmt), NULL_TREE, 1, walk_subtrees, data);</span>
<span class="lineNum">     299 </span><span class="lineCov">      38268 : }</span>
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span>            : /* Genericize a DO_STMT node *STMT_P.  */
<span class="lineNum">     302 </span>            : 
<span class="lineNum">     303 </span>            : static void
<span class="lineNum">     304 </span><span class="lineCov">      89112 : genericize_do_stmt (tree *stmt_p, int *walk_subtrees, void *data)</span>
<span class="lineNum">     305 </span>            : {
<span class="lineNum">     306 </span><span class="lineCov">      89112 :   tree stmt = *stmt_p;</span>
<span class="lineNum">     307 </span><span class="lineCov">     178224 :   genericize_cp_loop (stmt_p, EXPR_LOCATION (stmt), DO_COND (stmt),</span>
<span class="lineNum">     308 </span><span class="lineCov">      89112 :                       DO_BODY (stmt), NULL_TREE, 0, walk_subtrees, data);</span>
<span class="lineNum">     309 </span><span class="lineCov">      89112 : }</span>
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span>            : /* Genericize a SWITCH_STMT node *STMT_P by turning it into a SWITCH_EXPR.  */
<span class="lineNum">     312 </span>            : 
<span class="lineNum">     313 </span>            : static void
<span class="lineNum">     314 </span><span class="lineCov">      22696 : genericize_switch_stmt (tree *stmt_p, int *walk_subtrees, void *data)</span>
<span class="lineNum">     315 </span>            : {
<span class="lineNum">     316 </span><span class="lineCov">      22696 :   tree stmt = *stmt_p;</span>
<span class="lineNum">     317 </span><span class="lineCov">      22696 :   tree break_block, body, cond, type;</span>
<span class="lineNum">     318 </span><span class="lineCov">      22696 :   location_t stmt_locus = EXPR_LOCATION (stmt);</span>
<span class="lineNum">     319 </span>            : 
<span class="lineNum">     320 </span><span class="lineCov">      22696 :   break_block = begin_bc_block (bc_break, stmt_locus);</span>
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span><span class="lineCov">      22696 :   body = SWITCH_STMT_BODY (stmt);</span>
<span class="lineNum">     323 </span><span class="lineCov">      22696 :   if (!body)</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :     body = build_empty_stmt (stmt_locus);</span>
<span class="lineNum">     325 </span><span class="lineCov">      22696 :   cond = SWITCH_STMT_COND (stmt);</span>
<span class="lineNum">     326 </span><span class="lineCov">      22696 :   type = SWITCH_STMT_TYPE (stmt);</span>
<span class="lineNum">     327 </span>            : 
<span class="lineNum">     328 </span><span class="lineCov">      22696 :   cp_walk_tree (&amp;body, cp_genericize_r, data, NULL);</span>
<span class="lineNum">     329 </span><span class="lineCov">      22696 :   cp_walk_tree (&amp;cond, cp_genericize_r, data, NULL);</span>
<span class="lineNum">     330 </span><span class="lineCov">      22696 :   cp_walk_tree (&amp;type, cp_genericize_r, data, NULL);</span>
<span class="lineNum">     331 </span><span class="lineCov">      22696 :   *walk_subtrees = 0;</span>
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span><span class="lineCov">      22696 :   if (TREE_USED (break_block))</span>
<span class="lineNum">     334 </span><span class="lineCov">      19825 :     SWITCH_BREAK_LABEL_P (break_block) = 1;</span>
<span class="lineNum">     335 </span><span class="lineCov">      22696 :   finish_bc_block (&amp;body, bc_break, break_block);</span>
<span class="lineNum">     336 </span><span class="lineCov">      22696 :   *stmt_p = build2_loc (stmt_locus, SWITCH_EXPR, type, cond, body);</span>
<span class="lineNum">     337 </span><span class="lineCov">      22696 :   SWITCH_ALL_CASES_P (*stmt_p) = SWITCH_STMT_ALL_CASES_P (stmt);</span>
<span class="lineNum">     338 </span><span class="lineCov">      22696 :   gcc_checking_assert (!SWITCH_STMT_NO_BREAK_P (stmt)</span>
<span class="lineNum">     339 </span>            :                        || !TREE_USED (break_block));
<span class="lineNum">     340 </span><span class="lineCov">      22696 : }</span>
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span>            : /* Genericize a CONTINUE_STMT node *STMT_P.  */
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span>            : static void
<span class="lineNum">     345 </span><span class="lineCov">       1011 : genericize_continue_stmt (tree *stmt_p)</span>
<span class="lineNum">     346 </span>            : {
<span class="lineNum">     347 </span><span class="lineCov">       1011 :   tree stmt_list = NULL;</span>
<span class="lineNum">     348 </span><span class="lineCov">       1011 :   tree pred = build_predict_expr (PRED_CONTINUE, NOT_TAKEN);</span>
<span class="lineNum">     349 </span><span class="lineCov">       2022 :   tree label = get_bc_label (bc_continue);</span>
<span class="lineNum">     350 </span><span class="lineCov">       1011 :   location_t location = EXPR_LOCATION (*stmt_p);</span>
<span class="lineNum">     351 </span><span class="lineCov">       1011 :   tree jump = build1_loc (location, GOTO_EXPR, void_type_node, label);</span>
<span class="lineNum">     352 </span><span class="lineCov">       1011 :   append_to_statement_list_force (pred, &amp;stmt_list);</span>
<span class="lineNum">     353 </span><span class="lineCov">       1011 :   append_to_statement_list (jump, &amp;stmt_list);</span>
<span class="lineNum">     354 </span><span class="lineCov">       1011 :   *stmt_p = stmt_list;</span>
<span class="lineNum">     355 </span><span class="lineCov">       1011 : }</span>
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span>            : /* Genericize a BREAK_STMT node *STMT_P.  */
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span>            : static void
<span class="lineNum">     360 </span><span class="lineCov">     112131 : genericize_break_stmt (tree *stmt_p)</span>
<span class="lineNum">     361 </span>            : {
<span class="lineNum">     362 </span><span class="lineCov">     224262 :   tree label = get_bc_label (bc_break);</span>
<span class="lineNum">     363 </span><span class="lineCov">     112131 :   location_t location = EXPR_LOCATION (*stmt_p);</span>
<span class="lineNum">     364 </span><span class="lineCov">     112131 :   *stmt_p = build1_loc (location, GOTO_EXPR, void_type_node, label);</span>
<span class="lineNum">     365 </span><span class="lineCov">     112131 : }</span>
<span class="lineNum">     366 </span>            : 
<span class="lineNum">     367 </span>            : /* Genericize a OMP_FOR node *STMT_P.  */
<span class="lineNum">     368 </span>            : 
<span class="lineNum">     369 </span>            : static void
<span class="lineNum">     370 </span><span class="lineCov">       9216 : genericize_omp_for_stmt (tree *stmt_p, int *walk_subtrees, void *data)</span>
<span class="lineNum">     371 </span>            : {
<span class="lineNum">     372 </span><span class="lineCov">       9216 :   tree stmt = *stmt_p;</span>
<span class="lineNum">     373 </span><span class="lineCov">       9216 :   location_t locus = EXPR_LOCATION (stmt);</span>
<span class="lineNum">     374 </span><span class="lineCov">       9216 :   tree clab = begin_bc_block (bc_continue, locus);</span>
<span class="lineNum">     375 </span>            : 
<span class="lineNum">     376 </span><span class="lineCov">      18432 :   cp_walk_tree (&amp;OMP_FOR_BODY (stmt), cp_genericize_r, data, NULL);</span>
<span class="lineNum">     377 </span><span class="lineCov">       9216 :   if (TREE_CODE (stmt) != OMP_TASKLOOP)</span>
<span class="lineNum">     378 </span><span class="lineCov">      17962 :     cp_walk_tree (&amp;OMP_FOR_CLAUSES (stmt), cp_genericize_r, data, NULL);</span>
<span class="lineNum">     379 </span><span class="lineCov">      18432 :   cp_walk_tree (&amp;OMP_FOR_INIT (stmt), cp_genericize_r, data, NULL);</span>
<span class="lineNum">     380 </span><span class="lineCov">      18432 :   cp_walk_tree (&amp;OMP_FOR_COND (stmt), cp_genericize_r, data, NULL);</span>
<span class="lineNum">     381 </span><span class="lineCov">      18432 :   cp_walk_tree (&amp;OMP_FOR_INCR (stmt), cp_genericize_r, data, NULL);</span>
<span class="lineNum">     382 </span><span class="lineCov">      18432 :   cp_walk_tree (&amp;OMP_FOR_PRE_BODY (stmt), cp_genericize_r, data, NULL);</span>
<span class="lineNum">     383 </span><span class="lineCov">       9216 :   *walk_subtrees = 0;</span>
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span><span class="lineCov">      18432 :   finish_bc_block (&amp;OMP_FOR_BODY (stmt), bc_continue, clab);</span>
<span class="lineNum">     386 </span><span class="lineCov">       9216 : }</span>
<span class="lineNum">     387 </span>            : 
<span class="lineNum">     388 </span>            : /* Hook into the middle of gimplifying an OMP_FOR node.  */
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span>            : static enum gimplify_status
<span class="lineNum">     391 </span><span class="lineCov">      13979 : cp_gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)</span>
<span class="lineNum">     392 </span>            : {
<span class="lineNum">     393 </span><span class="lineCov">      13979 :   tree for_stmt = *expr_p;</span>
<span class="lineNum">     394 </span><span class="lineCov">      13979 :   gimple_seq seq = NULL;</span>
<span class="lineNum">     395 </span>            : 
<span class="lineNum">     396 </span>            :   /* Protect ourselves from recursion.  */
<span class="lineNum">     397 </span><span class="lineCov">      41937 :   if (OMP_FOR_GIMPLIFYING_P (for_stmt))</span>
<span class="lineNum">     398 </span>            :     return GS_UNHANDLED;
<span class="lineNum">     399 </span><span class="lineCov">      13472 :   OMP_FOR_GIMPLIFYING_P (for_stmt) = 1;</span>
<span class="lineNum">     400 </span>            : 
<span class="lineNum">     401 </span><span class="lineCov">       6736 :   gimplify_and_add (for_stmt, &amp;seq);</span>
<span class="lineNum">     402 </span><span class="lineCov">       6736 :   gimple_seq_add_seq (pre_p, seq);</span>
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span><span class="lineCov">      13472 :   OMP_FOR_GIMPLIFYING_P (for_stmt) = 0;</span>
<span class="lineNum">     405 </span>            : 
<span class="lineNum">     406 </span><span class="lineCov">       6736 :   return GS_ALL_DONE;</span>
<span class="lineNum">     407 </span>            : }
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span>            : /*  Gimplify an EXPR_STMT node.  */
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span>            : static void
<span class="lineNum">     412 </span><span class="lineCov">    2267776 : gimplify_expr_stmt (tree *stmt_p)</span>
<span class="lineNum">     413 </span>            : {
<span class="lineNum">     414 </span><span class="lineCov">    2267776 :   tree stmt = EXPR_STMT_EXPR (*stmt_p);</span>
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span><span class="lineCov">    2267776 :   if (stmt == error_mark_node)</span>
<span class="lineNum">     417 </span>            :     stmt = NULL;
<span class="lineNum">     418 </span>            : 
<span class="lineNum">     419 </span>            :   /* Gimplification of a statement expression will nullify the
<span class="lineNum">     420 </span>            :      statement if all its side effects are moved to *PRE_P and *POST_P.
<span class="lineNum">     421 </span>            : 
<span class="lineNum">     422 </span>            :      In this case we will not want to emit the gimplified statement.
<span class="lineNum">     423 </span>            :      However, we may still want to emit a warning, so we do that before
<span class="lineNum">     424 </span>            :      gimplification.  */
<span class="lineNum">     425 </span><span class="lineCov">    2267307 :   if (stmt &amp;&amp; warn_unused_value)</span>
<span class="lineNum">     426 </span>            :     {
<span class="lineNum">     427 </span><span class="lineCov">     229083 :       if (!TREE_SIDE_EFFECTS (stmt))</span>
<span class="lineNum">     428 </span>            :         {
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :           if (!IS_EMPTY_STMT (stmt)</span>
<span class="lineNum">     430 </span><span class="lineCov">       6394 :               &amp;&amp; !VOID_TYPE_P (TREE_TYPE (stmt))</span>
<span class="lineNum">     431 </span><span class="lineCov">       6394 :               &amp;&amp; !TREE_NO_WARNING (stmt))</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :             warning (OPT_Wunused_value, &quot;statement with no effect&quot;);</span>
<span class="lineNum">     433 </span>            :         }
<span class="lineNum">     434 </span>            :       else
<span class="lineNum">     435 </span><span class="lineCov">     222689 :         warn_if_unused_value (stmt, input_location);</span>
<span class="lineNum">     436 </span>            :     }
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span><span class="lineCov">    2267776 :   if (stmt == NULL_TREE)</span>
<span class="lineNum">     439 </span><span class="lineCov">        469 :     stmt = alloc_stmt_list ();</span>
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span><span class="lineCov">    2267776 :   *stmt_p = stmt;</span>
<span class="lineNum">     442 </span><span class="lineCov">    2267776 : }</span>
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span>            : /* Gimplify initialization from an AGGR_INIT_EXPR.  */
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span>            : static void
<span class="lineNum">     447 </span><span class="lineCov">    5925804 : cp_gimplify_init_expr (tree *expr_p)</span>
<span class="lineNum">     448 </span>            : {
<span class="lineNum">     449 </span><span class="lineCov">    5925804 :   tree from = TREE_OPERAND (*expr_p, 1);</span>
<span class="lineNum">     450 </span><span class="lineCov">    5925804 :   tree to = TREE_OPERAND (*expr_p, 0);</span>
<span class="lineNum">     451 </span><span class="lineCov">    5925804 :   tree t;</span>
<span class="lineNum">     452 </span>            : 
<span class="lineNum">     453 </span>            :   /* What about code that pulls out the temp and uses it elsewhere?  I
<span class="lineNum">     454 </span>            :      think that such code never uses the TARGET_EXPR as an initializer.  If
<span class="lineNum">     455 </span>            :      I'm wrong, we'll abort because the temp won't have any RTL.  In that
<span class="lineNum">     456 </span>            :      case, I guess we'll need to replace references somehow.  */
<span class="lineNum">     457 </span><span class="lineCov">    5925804 :   if (TREE_CODE (from) == TARGET_EXPR)</span>
<span class="lineNum">     458 </span><span class="lineCov">      74108 :     from = TARGET_EXPR_INITIAL (from);</span>
<span class="lineNum">     459 </span>            : 
<span class="lineNum">     460 </span>            :   /* Look through any COMPOUND_EXPRs, since build_compound_expr pushes them
<span class="lineNum">     461 </span>            :      inside the TARGET_EXPR.  */
<span class="lineNum">     462 </span><span class="lineCov">    5959795 :   for (t = from; t; )</span>
<span class="lineNum">     463 </span>            :     {
<span class="lineNum">     464 </span><span class="lineCov">    5959795 :       tree sub = TREE_CODE (t) == COMPOUND_EXPR ? TREE_OPERAND (t, 0) : t;</span>
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span>            :       /* If we are initializing from an AGGR_INIT_EXPR, drop the INIT_EXPR and
<span class="lineNum">     467 </span>            :          replace the slot operand with our target.
<span class="lineNum">     468 </span>            : 
<span class="lineNum">     469 </span>            :          Should we add a target parm to gimplify_expr instead?  No, as in this
<span class="lineNum">     470 </span>            :          case we want to replace the INIT_EXPR.  */
<span class="lineNum">     471 </span><span class="lineCov">   11919590 :       if (TREE_CODE (sub) == AGGR_INIT_EXPR</span>
<span class="lineNum">     472 </span><span class="lineCov">    5959795 :           || TREE_CODE (sub) == VEC_INIT_EXPR)</span>
<span class="lineNum">     473 </span>            :         {
<span class="lineNum">     474 </span><span class="lineCov">      55701 :           if (TREE_CODE (sub) == AGGR_INIT_EXPR)</span>
<span class="lineNum">     475 </span><span class="lineCov">     110580 :             AGGR_INIT_EXPR_SLOT (sub) = to;</span>
<span class="lineNum">     476 </span>            :           else
<span class="lineNum">     477 </span><span class="lineCov">        822 :             VEC_INIT_EXPR_SLOT (sub) = to;</span>
<span class="lineNum">     478 </span><span class="lineCov">      55701 :           *expr_p = from;</span>
<span class="lineNum">     479 </span>            : 
<span class="lineNum">     480 </span>            :           /* The initialization is now a side-effect, so the container can
<span class="lineNum">     481 </span>            :              become void.  */
<span class="lineNum">     482 </span><span class="lineCov">      55701 :           if (from != sub)</span>
<span class="lineNum">     483 </span><span class="lineCov">         20 :             TREE_TYPE (from) = void_type_node;</span>
<span class="lineNum">     484 </span>            :         }
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span>            :       /* Handle aggregate NSDMI.  */
<span class="lineNum">     487 </span><span class="lineCov">    5959795 :       replace_placeholders (sub, to);</span>
<span class="lineNum">     488 </span>            : 
<span class="lineNum">     489 </span><span class="lineCov">    5959795 :       if (t == sub)</span>
<span class="lineNum">     490 </span>            :         break;
<span class="lineNum">     491 </span>            :       else
<span class="lineNum">     492 </span><span class="lineCov">      33991 :         t = TREE_OPERAND (t, 1);</span>
<span class="lineNum">     493 </span>            :     }
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span><span class="lineCov">    5925804 : }</span>
<span class="lineNum">     496 </span>            : 
<span class="lineNum">     497 </span>            : /* Gimplify a MUST_NOT_THROW_EXPR.  */
<a name="498"><span class="lineNum">     498 </span>            : </a>
<span class="lineNum">     499 </span>            : static enum gimplify_status
<span class="lineNum">     500 </span><span class="lineCov">     289426 : gimplify_must_not_throw_expr (tree *expr_p, gimple_seq *pre_p)</span>
<span class="lineNum">     501 </span>            : {
<span class="lineNum">     502 </span><span class="lineCov">     289426 :   tree stmt = *expr_p;</span>
<span class="lineNum">     503 </span><span class="lineCov">     289426 :   tree temp = voidify_wrapper_expr (stmt, NULL);</span>
<span class="lineNum">     504 </span><span class="lineCov">     289426 :   tree body = TREE_OPERAND (stmt, 0);</span>
<span class="lineNum">     505 </span><span class="lineCov">     289426 :   gimple_seq try_ = NULL;</span>
<span class="lineNum">     506 </span><span class="lineCov">     289426 :   gimple_seq catch_ = NULL;</span>
<span class="lineNum">     507 </span><span class="lineCov">     289426 :   gimple *mnt;</span>
<span class="lineNum">     508 </span>            : 
<span class="lineNum">     509 </span><span class="lineCov">     289426 :   gimplify_and_add (body, &amp;try_);</span>
<span class="lineNum">     510 </span><span class="lineCov">     289426 :   mnt = gimple_build_eh_must_not_throw (terminate_fn);</span>
<span class="lineNum">     511 </span><span class="lineCov">     289426 :   gimple_seq_add_stmt_without_update (&amp;catch_, mnt);</span>
<span class="lineNum">     512 </span><span class="lineCov">     289426 :   mnt = gimple_build_try (try_, catch_, GIMPLE_TRY_CATCH);</span>
<span class="lineNum">     513 </span>            : 
<span class="lineNum">     514 </span><span class="lineCov">     289426 :   gimple_seq_add_stmt_without_update (pre_p, mnt);</span>
<span class="lineNum">     515 </span><span class="lineCov">     289426 :   if (temp)</span>
<span class="lineNum">     516 </span>            :     {
<span class="lineNum">     517 </span><span class="lineCov">         22 :       *expr_p = temp;</span>
<span class="lineNum">     518 </span><span class="lineCov">         22 :       return GS_OK;</span>
<span class="lineNum">     519 </span>            :     }
<span class="lineNum">     520 </span>            : 
<span class="lineNum">     521 </span><span class="lineCov">     289404 :   *expr_p = NULL;</span>
<span class="lineNum">     522 </span><span class="lineCov">     289404 :   return GS_ALL_DONE;</span>
<span class="lineNum">     523 </span>            : }
<span class="lineNum">     524 </span>            : 
<span class="lineNum">     525 </span>            : /* Return TRUE if an operand (OP) of a given TYPE being copied is
<span class="lineNum">     526 </span>            :    really just an empty class copy.
<span class="lineNum">     527 </span>            : 
<span class="lineNum">     528 </span>            :    Check that the operand has a simple form so that TARGET_EXPRs and
<span class="lineNum">     529 </span>            :    non-empty CONSTRUCTORs get reduced properly, and we leave the
<span class="lineNum">     530 </span>            :    return slot optimization alone because it isn't a copy.  */
<span class="lineNum">     531 </span>            : 
<span class="lineNum">     532 </span>            : static bool
<span class="lineNum">     533 </span><span class="lineCov">    8158305 : simple_empty_class_p (tree type, tree op)</span>
<span class="lineNum">     534 </span>            : {
<span class="lineNum">     535 </span><span class="lineCov">    8158305 :   return</span>
<span class="lineNum">     536 </span><span class="lineCov">    8158305 :     ((TREE_CODE (op) == COMPOUND_EXPR</span>
<span class="lineNum">     537 </span><span class="lineCov">      78713 :       &amp;&amp; simple_empty_class_p (type, TREE_OPERAND (op, 1)))</span>
<span class="lineNum">     538 </span><span class="lineCov">    8157295 :      || TREE_CODE (op) == EMPTY_CLASS_EXPR</span>
<span class="lineNum">     539 </span><span class="lineCov">    8156640 :      || is_gimple_lvalue (op)</span>
<span class="lineNum">     540 </span><span class="lineCov">    6268839 :      || INDIRECT_REF_P (op)</span>
<span class="lineNum">     541 </span><span class="lineCov">    6205253 :      || (TREE_CODE (op) == CONSTRUCTOR</span>
<span class="lineNum">     542 </span><span class="lineCov">     963086 :          &amp;&amp; CONSTRUCTOR_NELTS (op) == 0</span>
<span class="lineNum">     543 </span><span class="lineCov">     460799 :          &amp;&amp; !TREE_CLOBBER_P (op))</span>
<span class="lineNum">     544 </span><span class="lineCov">    6124455 :      || (TREE_CODE (op) == CALL_EXPR</span>
<span class="lineNum">     545 </span><span class="lineCov">    2789120 :          &amp;&amp; !CALL_EXPR_RETURN_SLOT_OPT (op)))</span>
<span class="lineNum">     546 </span><span class="lineCov">   11545666 :     &amp;&amp; is_really_empty_class (type);</span>
<span class="lineNum">     547 </span>            : }
<span class="lineNum">     548 </span>            : 
<span class="lineNum">     549 </span>            : /* Returns true if evaluating E as an lvalue has side-effects;
<span class="lineNum">     550 </span>            :    specifically, a volatile lvalue has TREE_SIDE_EFFECTS, but it doesn't really
<span class="lineNum">     551 </span>            :    have side-effects until there is a read or write through it.  */
<span class="lineNum">     552 </span>            : 
<span class="lineNum">     553 </span>            : static bool
<span class="lineNum">     554 </span><span class="lineCov">      56008 : lvalue_has_side_effects (tree e)</span>
<span class="lineNum">     555 </span>            : {
<span class="lineNum">     556 </span><span class="lineCov">      56008 :   if (!TREE_SIDE_EFFECTS (e))</span>
<span class="lineNum">     557 </span>            :     return false;
<span class="lineNum">     558 </span><span class="lineCov">        486 :   while (handled_component_p (e))</span>
<span class="lineNum">     559 </span>            :     {
<span class="lineNum">     560 </span><span class="lineCov">         10 :       if (TREE_CODE (e) == ARRAY_REF</span>
<span class="lineNum">     561 </span><span class="lineCov">         10 :           &amp;&amp; TREE_SIDE_EFFECTS (TREE_OPERAND (e, 1)))</span>
<span class="lineNum">     562 </span>            :         return true;
<span class="lineNum">     563 </span><span class="lineCov">          8 :       e = TREE_OPERAND (e, 0);</span>
<span class="lineNum">     564 </span>            :     }
<span class="lineNum">     565 </span><span class="lineCov">        476 :   if (DECL_P (e))</span>
<span class="lineNum">     566 </span>            :     /* Just naming a variable has no side-effects.  */
<span class="lineNum">     567 </span>            :     return false;
<span class="lineNum">     568 </span><span class="lineCov">        474 :   else if (INDIRECT_REF_P (e))</span>
<span class="lineNum">     569 </span>            :     /* Similarly, indirection has no side-effects.  */
<span class="lineNum">     570 </span><span class="lineCov">        453 :     return TREE_SIDE_EFFECTS (TREE_OPERAND (e, 0));</span>
<span class="lineNum">     571 </span>            :   else
<span class="lineNum">     572 </span>            :     /* For anything else, trust TREE_SIDE_EFFECTS.  */
<span class="lineNum">     573 </span><span class="lineCov">         21 :     return TREE_SIDE_EFFECTS (e);</span>
<span class="lineNum">     574 </span>            : }
<span class="lineNum">     575 </span>            : 
<span class="lineNum">     576 </span>            : /* Do C++-specific gimplification.  Args are as for gimplify_expr.  */
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span>            : int
<span class="lineNum">     579 </span><span class="lineCov">   90487712 : cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)</span>
<span class="lineNum">     580 </span>            : {
<span class="lineNum">     581 </span><span class="lineCov">   90487712 :   int saved_stmts_are_full_exprs_p = 0;</span>
<span class="lineNum">     582 </span><span class="lineCov">   90487712 :   location_t loc = cp_expr_loc_or_loc (*expr_p, input_location);</span>
<span class="lineNum">     583 </span><span class="lineCov">   90487712 :   enum tree_code code = TREE_CODE (*expr_p);</span>
<span class="lineNum">     584 </span><span class="lineCov">   90487712 :   enum gimplify_status ret;</span>
<span class="lineNum">     585 </span>            : 
<span class="lineNum">     586 </span><span class="lineCov">   90487712 :   if (STATEMENT_CODE_P (code))</span>
<span class="lineNum">     587 </span>            :     {
<span class="lineNum">     588 </span><span class="lineCov">    2316841 :       saved_stmts_are_full_exprs_p = stmts_are_full_exprs_p ();</span>
<span class="lineNum">     589 </span><span class="lineCov">    4633682 :       current_stmt_tree ()-&gt;stmts_are_full_exprs_p</span>
<span class="lineNum">     590 </span><span class="lineCov">    4633682 :         = STMT_IS_FULL_EXPR_P (*expr_p);</span>
<span class="lineNum">     591 </span>            :     }
<span class="lineNum">     592 </span>            : 
<span class="lineNum">     593 </span><span class="lineCov">   90487712 :   switch (code)</span>
<span class="lineNum">     594 </span>            :     {
<span class="lineNum">     595 </span><span class="lineCov">     179480 :     case AGGR_INIT_EXPR:</span>
<span class="lineNum">     596 </span><span class="lineCov">     179480 :       simplify_aggr_init_expr (expr_p);</span>
<span class="lineNum">     597 </span><span class="lineCov">     179480 :       ret = GS_OK;</span>
<span class="lineNum">     598 </span><span class="lineCov">     179480 :       break;</span>
<span class="lineNum">     599 </span>            : 
<span class="lineNum">     600 </span><span class="lineCov">        411 :     case VEC_INIT_EXPR:</span>
<span class="lineNum">     601 </span><span class="lineCov">        411 :       {</span>
<span class="lineNum">     602 </span><span class="lineCov">        411 :         location_t loc = input_location;</span>
<span class="lineNum">     603 </span><span class="lineCov">        411 :         tree init = VEC_INIT_EXPR_INIT (*expr_p);</span>
<span class="lineNum">     604 </span><span class="lineCov">        411 :         int from_array = (init &amp;&amp; TREE_CODE (TREE_TYPE (init)) == ARRAY_TYPE);</span>
<span class="lineNum">     605 </span><span class="lineCov">        411 :         gcc_assert (EXPR_HAS_LOCATION (*expr_p));</span>
<span class="lineNum">     606 </span><span class="lineCov">        411 :         input_location = EXPR_LOCATION (*expr_p);</span>
<span class="lineNum">     607 </span><span class="lineCov">        411 :         *expr_p = build_vec_init (VEC_INIT_EXPR_SLOT (*expr_p), NULL_TREE,</span>
<span class="lineNum">     608 </span><span class="lineCov">        411 :                                   init, VEC_INIT_EXPR_VALUE_INIT (*expr_p),</span>
<span class="lineNum">     609 </span>            :                                   from_array,
<span class="lineNum">     610 </span><span class="lineCov">        411 :                                   tf_warning_or_error);</span>
<span class="lineNum">     611 </span><span class="lineCov">        411 :         hash_set&lt;tree&gt; pset;</span>
<span class="lineNum">     612 </span><span class="lineCov">        411 :         cp_walk_tree (expr_p, cp_fold_r, &amp;pset, NULL);</span>
<span class="lineNum">     613 </span><span class="lineCov">        411 :         cp_genericize_tree (expr_p, false);</span>
<span class="lineNum">     614 </span><span class="lineCov">        411 :         ret = GS_OK;</span>
<span class="lineNum">     615 </span><span class="lineCov">        411 :         input_location = loc;</span>
<span class="lineNum">     616 </span>            :       }
<span class="lineNum">     617 </span><span class="lineCov">        411 :       break;</span>
<span class="lineNum">     618 </span>            : 
<span class="lineNum">     619 </span><span class="lineCov">      21644 :     case THROW_EXPR:</span>
<span class="lineNum">     620 </span>            :       /* FIXME communicate throw type to back end, probably by moving
<span class="lineNum">     621 </span>            :          THROW_EXPR into ../tree.def.  */
<span class="lineNum">     622 </span><span class="lineCov">      21644 :       *expr_p = TREE_OPERAND (*expr_p, 0);</span>
<span class="lineNum">     623 </span><span class="lineCov">      21644 :       ret = GS_OK;</span>
<span class="lineNum">     624 </span><span class="lineCov">      21644 :       break;</span>
<span class="lineNum">     625 </span>            : 
<span class="lineNum">     626 </span><span class="lineCov">     289426 :     case MUST_NOT_THROW_EXPR:</span>
<span class="lineNum">     627 </span><span class="lineCov">     289426 :       ret = gimplify_must_not_throw_expr (expr_p, pre_p);</span>
<span class="lineNum">     628 </span><span class="lineCov">     289426 :       break;</span>
<span class="lineNum">     629 </span>            : 
<span class="lineNum">     630 </span>            :       /* We used to do this for MODIFY_EXPR as well, but that's unsafe; the
<span class="lineNum">     631 </span>            :          LHS of an assignment might also be involved in the RHS, as in bug
<span class="lineNum">     632 </span>            :          25979.  */
<span class="lineNum">     633 </span><span class="lineCov">    5925804 :     case INIT_EXPR:</span>
<span class="lineNum">     634 </span><span class="lineCov">    5925804 :       cp_gimplify_init_expr (expr_p);</span>
<span class="lineNum">     635 </span><span class="lineCov">    5925804 :       if (TREE_CODE (*expr_p) != INIT_EXPR)</span>
<span class="lineNum">     636 </span>            :         return GS_OK;
<span class="lineNum">     637 </span>            :       /* Fall through.  */
<span class="lineNum">     638 </span><span class="lineCov">    8079601 :     case MODIFY_EXPR:</span>
<span class="lineNum">     639 </span><span class="lineCov">    5870103 :     modify_expr_case:</span>
<span class="lineNum">     640 </span><span class="lineCov">    8079601 :       {</span>
<span class="lineNum">     641 </span>            :         /* If the back end isn't clever enough to know that the lhs and rhs
<span class="lineNum">     642 </span>            :            types are the same, add an explicit conversion.  */
<span class="lineNum">     643 </span><span class="lineCov">    8079601 :         tree op0 = TREE_OPERAND (*expr_p, 0);</span>
<span class="lineNum">     644 </span><span class="lineCov">    8079601 :         tree op1 = TREE_OPERAND (*expr_p, 1);</span>
<span class="lineNum">     645 </span>            : 
<span class="lineNum">     646 </span><span class="lineCov">    8079601 :         if (!error_operand_p (op0)</span>
<span class="lineNum">     647 </span><span class="lineCov">    8079601 :             &amp;&amp; !error_operand_p (op1)</span>
<span class="lineNum">     648 </span><span class="lineCov">    8079594 :             &amp;&amp; (TYPE_STRUCTURAL_EQUALITY_P (TREE_TYPE (op0))</span>
<span class="lineNum">     649 </span><span class="lineCov">    8077803 :                 || TYPE_STRUCTURAL_EQUALITY_P (TREE_TYPE (op1)))</span>
<span class="lineNum">     650 </span><span class="lineCov">    8083501 :             &amp;&amp; !useless_type_conversion_p (TREE_TYPE (op1), TREE_TYPE (op0)))</span>
<span class="lineNum">     651 </span><span class="lineCov">          9 :           TREE_OPERAND (*expr_p, 1) = build1 (VIEW_CONVERT_EXPR,</span>
<span class="lineNum">     652 </span><span class="lineCov">          9 :                                               TREE_TYPE (op0), op1);</span>
<span class="lineNum">     653 </span>            : 
<span class="lineNum">     654 </span><span class="lineCov">    8079592 :         else if (simple_empty_class_p (TREE_TYPE (op0), op1))</span>
<span class="lineNum">     655 </span>            :           {
<span class="lineNum">     656 </span>            :             /* Remove any copies of empty classes.  Also drop volatile
<span class="lineNum">     657 </span>            :                variables on the RHS to avoid infinite recursion from
<span class="lineNum">     658 </span>            :                gimplify_expr trying to load the value.  */
<span class="lineNum">     659 </span><span class="lineCov">     104465 :             if (TREE_SIDE_EFFECTS (op1))</span>
<span class="lineNum">     660 </span>            :               {
<span class="lineNum">     661 </span><span class="lineCov">      25368 :                 if (TREE_THIS_VOLATILE (op1)</span>
<span class="lineNum">     662 </span><span class="lineCov">      12684 :                     &amp;&amp; (REFERENCE_CLASS_P (op1) || DECL_P (op1)))</span>
<span class="lineNum">     663 </span><span class="lineCov">         19 :                   op1 = build_fold_addr_expr (op1);</span>
<span class="lineNum">     664 </span>            : 
<span class="lineNum">     665 </span><span class="lineCov">      12684 :                 gimplify_and_add (op1, pre_p);</span>
<span class="lineNum">     666 </span>            :               }
<span class="lineNum">     667 </span><span class="lineCov">     104465 :             gimplify_expr (&amp;TREE_OPERAND (*expr_p, 0), pre_p, post_p,</span>
<span class="lineNum">     668 </span>            :                            is_gimple_lvalue, fb_lvalue);
<span class="lineNum">     669 </span><span class="lineCov">     104465 :             *expr_p = TREE_OPERAND (*expr_p, 0);</span>
<span class="lineNum">     670 </span>            :           }
<span class="lineNum">     671 </span>            :         /* P0145 says that the RHS is sequenced before the LHS.
<span class="lineNum">     672 </span>            :            gimplify_modify_expr gimplifies the RHS before the LHS, but that
<span class="lineNum">     673 </span>            :            isn't quite strong enough in two cases:
<span class="lineNum">     674 </span>            : 
<span class="lineNum">     675 </span>            :            1) gimplify.c wants to leave a CALL_EXPR on the RHS, which would
<span class="lineNum">     676 </span>            :            mean it's evaluated after the LHS.
<span class="lineNum">     677 </span>            : 
<span class="lineNum">     678 </span>            :            2) the value calculation of the RHS is also sequenced before the
<span class="lineNum">     679 </span>            :            LHS, so for scalar assignment we need to preevaluate if the
<span class="lineNum">     680 </span>            :            RHS could be affected by LHS side-effects even if it has no
<span class="lineNum">     681 </span>            :            side-effects of its own.  We don't need this for classes because
<span class="lineNum">     682 </span>            :            class assignment takes its RHS by reference.  */
<span class="lineNum">     683 </span><span class="lineCov">    7975127 :        else if (flag_strong_eval_order &gt; 1</span>
<span class="lineNum">     684 </span><span class="lineCov">     360875 :                 &amp;&amp; TREE_CODE (*expr_p) == MODIFY_EXPR</span>
<span class="lineNum">     685 </span><span class="lineCov">      56008 :                 &amp;&amp; lvalue_has_side_effects (op0)</span>
<span class="lineNum">     686 </span><span class="lineCov">    7975603 :                 &amp;&amp; (TREE_CODE (op1) == CALL_EXPR</span>
<span class="lineNum">     687 </span><span class="lineCov">        394 :                     || (SCALAR_TYPE_P (TREE_TYPE (op1))</span>
<span class="lineNum">     688 </span><span class="lineCov">        340 :                         &amp;&amp; !TREE_CONSTANT (op1))))</span>
<span class="lineNum">     689 </span><span class="lineCov">        342 :          TREE_OPERAND (*expr_p, 1) = get_formal_tmp_var (op1, pre_p);</span>
<span class="lineNum">     690 </span>            :       }
<span class="lineNum">     691 </span>            :       ret = GS_OK;
<span class="lineNum">     692 </span>            :       break;
<span class="lineNum">     693 </span>            : 
<span class="lineNum">     694 </span><span class="lineCov">      40049 :     case EMPTY_CLASS_EXPR:</span>
<span class="lineNum">     695 </span>            :       /* We create an empty CONSTRUCTOR with RECORD_TYPE.  */
<span class="lineNum">     696 </span><span class="lineCov">      40049 :       *expr_p = build_constructor (TREE_TYPE (*expr_p), NULL);</span>
<span class="lineNum">     697 </span><span class="lineCov">      40049 :       ret = GS_OK;</span>
<span class="lineNum">     698 </span><span class="lineCov">      40049 :       break;</span>
<span class="lineNum">     699 </span>            : 
<span class="lineNum">     700 </span><span class="lineCov">          7 :     case BASELINK:</span>
<span class="lineNum">     701 </span><span class="lineCov">          7 :       *expr_p = BASELINK_FUNCTIONS (*expr_p);</span>
<span class="lineNum">     702 </span><span class="lineCov">          7 :       ret = GS_OK;</span>
<span class="lineNum">     703 </span><span class="lineCov">          7 :       break;</span>
<span class="lineNum">     704 </span>            : 
<span class="lineNum">     705 </span><span class="lineCov">      19560 :     case TRY_BLOCK:</span>
<span class="lineNum">     706 </span><span class="lineCov">      19560 :       genericize_try_block (expr_p);</span>
<span class="lineNum">     707 </span><span class="lineCov">      19560 :       ret = GS_OK;</span>
<span class="lineNum">     708 </span><span class="lineCov">      19560 :       break;</span>
<span class="lineNum">     709 </span>            : 
<span class="lineNum">     710 </span><span class="lineCov">      21435 :     case HANDLER:</span>
<span class="lineNum">     711 </span><span class="lineCov">      21435 :       genericize_catch_block (expr_p);</span>
<span class="lineNum">     712 </span><span class="lineCov">      21435 :       ret = GS_OK;</span>
<span class="lineNum">     713 </span><span class="lineCov">      21435 :       break;</span>
<span class="lineNum">     714 </span>            : 
<span class="lineNum">     715 </span><span class="lineCov">       8070 :     case EH_SPEC_BLOCK:</span>
<span class="lineNum">     716 </span><span class="lineCov">       8070 :       genericize_eh_spec_block (expr_p);</span>
<span class="lineNum">     717 </span><span class="lineCov">       8070 :       ret = GS_OK;</span>
<span class="lineNum">     718 </span><span class="lineCov">       8070 :       break;</span>
<span class="lineNum">     719 </span>            : 
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :     case USING_STMT:</span>
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">     722 </span>            : 
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :     case FOR_STMT:</span>
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :     case WHILE_STMT:</span>
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :     case DO_STMT:</span>
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :     case SWITCH_STMT:</span>
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :     case CONTINUE_STMT:</span>
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :     case BREAK_STMT:</span>
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">     730 </span>            : 
<span class="lineNum">     731 </span><span class="lineCov">      13979 :     case OMP_FOR:</span>
<span class="lineNum">     732 </span><span class="lineCov">      13979 :     case OMP_SIMD:</span>
<span class="lineNum">     733 </span><span class="lineCov">      13979 :     case OMP_DISTRIBUTE:</span>
<span class="lineNum">     734 </span><span class="lineCov">      13979 :     case OMP_TASKLOOP:</span>
<span class="lineNum">     735 </span><span class="lineCov">      13979 :       ret = cp_gimplify_omp_for (expr_p, pre_p);</span>
<span class="lineNum">     736 </span><span class="lineCov">      13979 :       break;</span>
<span class="lineNum">     737 </span>            : 
<span class="lineNum">     738 </span><span class="lineCov">    2267776 :     case EXPR_STMT:</span>
<span class="lineNum">     739 </span><span class="lineCov">    2267776 :       gimplify_expr_stmt (expr_p);</span>
<span class="lineNum">     740 </span><span class="lineCov">    2267776 :       ret = GS_OK;</span>
<span class="lineNum">     741 </span><span class="lineCov">    2267776 :       break;</span>
<span class="lineNum">     742 </span>            : 
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :     case UNARY_PLUS_EXPR:</span>
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :       {</span>
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :         tree arg = TREE_OPERAND (*expr_p, 0);</span>
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :         tree type = TREE_TYPE (*expr_p);</span>
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :         *expr_p = (TREE_TYPE (arg) != type) ? fold_convert (type, arg)</span>
<span class="lineNum">     748 </span>            :                                             : arg;
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :         ret = GS_OK;</span>
<span class="lineNum">     750 </span>            :       }
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     752 </span>            : 
<span class="lineNum">     753 </span><span class="lineCov">    4774135 :     case CALL_EXPR:</span>
<span class="lineNum">     754 </span><span class="lineCov">    4774135 :       ret = GS_OK;</span>
<span class="lineNum">     755 </span><span class="lineCov">    4774135 :       if (!CALL_EXPR_FN (*expr_p))</span>
<span class="lineNum">     756 </span>            :         /* Internal function call.  */;
<span class="lineNum">     757 </span><span class="lineCov">   13943775 :       else if (CALL_EXPR_REVERSE_ARGS (*expr_p))</span>
<span class="lineNum">     758 </span>            :         {
<span class="lineNum">     759 </span>            :           /* This is a call to a (compound) assignment operator that used
<span class="lineNum">     760 </span>            :              the operator syntax; gimplify the RHS first.  */
<span class="lineNum">     761 </span><span class="lineCov">       1952 :           gcc_assert (call_expr_nargs (*expr_p) == 2);</span>
<span class="lineNum">     762 </span><span class="lineCov">       5856 :           gcc_assert (!CALL_EXPR_ORDERED_ARGS (*expr_p));</span>
<span class="lineNum">     763 </span><span class="lineCov">       1952 :           enum gimplify_status t</span>
<span class="lineNum">     764 </span><span class="lineCov">       3904 :             = gimplify_arg (&amp;CALL_EXPR_ARG (*expr_p, 1), pre_p, loc);</span>
<span class="lineNum">     765 </span><span class="lineCov">       1952 :           if (t == GS_ERROR)</span>
<span class="lineNum">     766 </span>            :             ret = GS_ERROR;
<span class="lineNum">     767 </span>            :         }
<span class="lineNum">     768 </span><span class="lineCov">   13937919 :       else if (CALL_EXPR_ORDERED_ARGS (*expr_p))</span>
<span class="lineNum">     769 </span>            :         {
<span class="lineNum">     770 </span>            :           /* Leave the last argument for gimplify_call_expr, to avoid problems
<span class="lineNum">     771 </span>            :              with __builtin_va_arg_pack().  */
<span class="lineNum">     772 </span><span class="lineCov">     114857 :           int nargs = call_expr_nargs (*expr_p) - 1;</span>
<span class="lineNum">     773 </span><span class="lineCov">     233104 :           for (int i = 0; i &lt; nargs; ++i)</span>
<span class="lineNum">     774 </span>            :             {
<span class="lineNum">     775 </span><span class="lineCov">     118247 :               enum gimplify_status t</span>
<span class="lineNum">     776 </span><span class="lineCov">     118247 :                 = gimplify_arg (&amp;CALL_EXPR_ARG (*expr_p, i), pre_p, loc);</span>
<span class="lineNum">     777 </span><span class="lineCov">     118247 :               if (t == GS_ERROR)</span>
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :                 ret = GS_ERROR;</span>
<span class="lineNum">     779 </span>            :             }
<span class="lineNum">     780 </span>            :         }
<span class="lineNum">     781 </span><span class="lineCov">    4531116 :       else if (flag_strong_eval_order</span>
<span class="lineNum">     782 </span><span class="lineCov">    4531116 :                &amp;&amp; !CALL_EXPR_OPERATOR_SYNTAX (*expr_p))</span>
<span class="lineNum">     783 </span>            :         {
<span class="lineNum">     784 </span>            :           /* If flag_strong_eval_order, evaluate the object argument first.  */
<span class="lineNum">     785 </span><span class="lineCov">    8446164 :           tree fntype = TREE_TYPE (CALL_EXPR_FN (*expr_p));</span>
<span class="lineNum">     786 </span><span class="lineCov">    4223082 :           if (INDIRECT_TYPE_P (fntype))</span>
<span class="lineNum">     787 </span><span class="lineCov">    4223082 :             fntype = TREE_TYPE (fntype);</span>
<span class="lineNum">     788 </span><span class="lineCov">    4223082 :           if (TREE_CODE (fntype) == METHOD_TYPE)</span>
<span class="lineNum">     789 </span>            :             {
<span class="lineNum">     790 </span><span class="lineCov">    1990171 :               enum gimplify_status t</span>
<span class="lineNum">     791 </span><span class="lineCov">    3980342 :                 = gimplify_arg (&amp;CALL_EXPR_ARG (*expr_p, 0), pre_p, loc);</span>
<span class="lineNum">     792 </span><span class="lineCov">    1990171 :               if (t == GS_ERROR)</span>
<span class="lineNum">     793 </span>            :                 ret = GS_ERROR;
<span class="lineNum">     794 </span>            :             }
<span class="lineNum">     795 </span>            :         }
<span class="lineNum">     796 </span><span class="lineCov">     114857 :       if (ret != GS_ERROR)</span>
<span class="lineNum">     797 </span>            :         {
<span class="lineNum">     798 </span><span class="lineCov">    4774135 :           tree decl = cp_get_callee_fndecl_nofold (*expr_p);</span>
<span class="lineNum">     799 </span><span class="lineCov">    4774135 :           if (decl</span>
<span class="lineNum">     800 </span><span class="lineCov">    4774135 :               &amp;&amp; fndecl_built_in_p (decl, CP_BUILT_IN_IS_CONSTANT_EVALUATED,</span>
<span class="lineNum">     801 </span>            :                                   BUILT_IN_FRONTEND))
<span class="lineNum">     802 </span><span class="lineCov">          5 :             *expr_p = boolean_false_node;</span>
<span class="lineNum">     803 </span>            :         }
<span class="lineNum">     804 </span>            :       break;
<span class="lineNum">     805 </span>            : 
<span class="lineNum">     806 </span><span class="lineCov">     600930 :     case RETURN_EXPR:</span>
<span class="lineNum">     807 </span><span class="lineCov">     600930 :       if (TREE_OPERAND (*expr_p, 0)</span>
<span class="lineNum">     808 </span><span class="lineCov">     600930 :           &amp;&amp; (TREE_CODE (TREE_OPERAND (*expr_p, 0)) == INIT_EXPR</span>
<span class="lineNum">     809 </span><span class="lineCov">       4742 :               || TREE_CODE (TREE_OPERAND (*expr_p, 0)) == MODIFY_EXPR))</span>
<span class="lineNum">     810 </span>            :         {
<span class="lineNum">     811 </span><span class="lineCov">     585451 :           expr_p = &amp;TREE_OPERAND (*expr_p, 0);</span>
<span class="lineNum">     812 </span><span class="lineCov">     585451 :           code = TREE_CODE (*expr_p);</span>
<span class="lineNum">     813 </span>            :           /* Avoid going through the INIT_EXPR case, which can
<span class="lineNum">     814 </span>            :              degrade INIT_EXPRs into AGGR_INIT_EXPRs.  */
<span class="lineNum">     815 </span><span class="lineCov">     585451 :           goto modify_expr_case;</span>
<span class="lineNum">     816 </span>            :         }
<span class="lineNum">     817 </span>            :       /* Fall through.  */
<span class="lineNum">     818 </span>            : 
<span class="lineNum">     819 </span><span class="lineCov">   74716438 :     default:</span>
<span class="lineNum">     820 </span><span class="lineCov">   74716438 :       ret = (enum gimplify_status) c_gimplify_expr (expr_p, pre_p, post_p);</span>
<span class="lineNum">     821 </span><span class="lineCov">   74716438 :       break;</span>
<span class="lineNum">     822 </span>            :     }
<span class="lineNum">     823 </span>            : 
<span class="lineNum">     824 </span>            :   /* Restore saved state.  */
<span class="lineNum">     825 </span><span class="lineCov">   90432011 :   if (STATEMENT_CODE_P (code))</span>
<span class="lineNum">     826 </span><span class="lineCov">    2316841 :     current_stmt_tree ()-&gt;stmts_are_full_exprs_p</span>
<span class="lineNum">     827 </span><span class="lineCov">    2316841 :       = saved_stmts_are_full_exprs_p;</span>
<span class="lineNum">     828 </span>            : 
<span class="lineNum">     829 </span>            :   return ret;
<span class="lineNum">     830 </span>            : }
<span class="lineNum">     831 </span>            : 
<span class="lineNum">     832 </span>            : static inline bool
<span class="lineNum">     833 </span><span class="lineCov">  268572990 : is_invisiref_parm (const_tree t)</span>
<span class="lineNum">     834 </span>            : {
<span class="lineNum">     835 </span><span class="lineCov">  268572990 :   return ((TREE_CODE (t) == PARM_DECL || TREE_CODE (t) == RESULT_DECL)</span>
<span class="lineNum">     836 </span><span class="lineCov">  292255552 :           &amp;&amp; DECL_BY_REFERENCE (t));</span>
<span class="lineNum">     837 </span>            : }
<span class="lineNum">     838 </span>            : 
<span class="lineNum">     839 </span>            : /* Return true if the uid in both int tree maps are equal.  */
<a name="840"><span class="lineNum">     840 </span>            : </a>
<span class="lineNum">     841 </span>            : bool
<span class="lineNum">     842 </span><span class="lineCov">        279 : cxx_int_tree_map_hasher::equal (cxx_int_tree_map *a, cxx_int_tree_map *b)</span>
<span class="lineNum">     843 </span>            : {
<span class="lineNum">     844 </span><span class="lineCov">        279 :   return (a-&gt;uid == b-&gt;uid);</span>
<span class="lineNum">     845 </span>            : }
<span class="lineNum">     846 </span>            : 
<span class="lineNum">     847 </span>            : /* Hash a UID in a cxx_int_tree_map.  */
<a name="848"><span class="lineNum">     848 </span>            : </a>
<span class="lineNum">     849 </span>            : unsigned int
<span class="lineNum">     850 </span><span class="lineCov">        120 : cxx_int_tree_map_hasher::hash (cxx_int_tree_map *item)</span>
<span class="lineNum">     851 </span>            : {
<span class="lineNum">     852 </span><span class="lineCov">        120 :   return item-&gt;uid;</span>
<span class="lineNum">     853 </span>            : }
<span class="lineNum">     854 </span>            : 
<span class="lineNum">     855 </span>            : /* A stable comparison routine for use with splay trees and DECLs.  */
<span class="lineNum">     856 </span>            : 
<span class="lineNum">     857 </span>            : static int
<span class="lineNum">     858 </span><span class="lineCov">      14210 : splay_tree_compare_decl_uid (splay_tree_key xa, splay_tree_key xb)</span>
<span class="lineNum">     859 </span>            : {
<span class="lineNum">     860 </span><span class="lineCov">      14210 :   tree a = (tree) xa;</span>
<span class="lineNum">     861 </span><span class="lineCov">      14210 :   tree b = (tree) xb;</span>
<span class="lineNum">     862 </span>            : 
<span class="lineNum">     863 </span><span class="lineCov">      14210 :   return DECL_UID (a) - DECL_UID (b);</span>
<span class="lineNum">     864 </span>            : }
<span class="lineNum">     865 </span>            : 
<span class="lineNum">     866 </span>            : /* OpenMP context during genericization.  */
<span class="lineNum">     867 </span>            : 
<span class="lineNum">     868 </span>            : struct cp_genericize_omp_taskreg
<span class="lineNum">     869 </span>            : {
<span class="lineNum">     870 </span>            :   bool is_parallel;
<span class="lineNum">     871 </span>            :   bool default_shared;
<span class="lineNum">     872 </span>            :   struct cp_genericize_omp_taskreg *outer;
<span class="lineNum">     873 </span>            :   splay_tree variables;
<span class="lineNum">     874 </span>            : };
<span class="lineNum">     875 </span>            : 
<span class="lineNum">     876 </span>            : /* Return true if genericization should try to determine if
<span class="lineNum">     877 </span>            :    DECL is firstprivate or shared within task regions.  */
<span class="lineNum">     878 </span>            : 
<span class="lineNum">     879 </span>            : static bool
<span class="lineNum">     880 </span><span class="lineCov">      40996 : omp_var_to_track (tree decl)</span>
<span class="lineNum">     881 </span>            : {
<span class="lineNum">     882 </span><span class="lineCov">      40996 :   tree type = TREE_TYPE (decl);</span>
<span class="lineNum">     883 </span><span class="lineCov">      40996 :   if (is_invisiref_parm (decl))</span>
<span class="lineNum">     884 </span><span class="lineCov">        325 :     type = TREE_TYPE (type);</span>
<span class="lineNum">     885 </span><span class="lineCov">      40671 :   else if (TYPE_REF_P (type))</span>
<span class="lineNum">     886 </span><span class="lineCov">       1250 :     type = TREE_TYPE (type);</span>
<span class="lineNum">     887 </span><span class="lineCov">      47403 :   while (TREE_CODE (type) == ARRAY_TYPE)</span>
<span class="lineNum">     888 </span><span class="lineCov">       6407 :     type = TREE_TYPE (type);</span>
<span class="lineNum">     889 </span><span class="lineCov">      40996 :   if (type == error_mark_node || !CLASS_TYPE_P (type))</span>
<span class="lineNum">     890 </span>            :     return false;
<span class="lineNum">     891 </span><span class="lineCov">       4262 :   if (VAR_P (decl) &amp;&amp; CP_DECL_THREAD_LOCAL_P (decl))</span>
<span class="lineNum">     892 </span>            :     return false;
<span class="lineNum">     893 </span><span class="lineCov">       4259 :   if (cxx_omp_predetermined_sharing (decl) != OMP_CLAUSE_DEFAULT_UNSPECIFIED)</span>
<span class="lineNum">     894 </span><span class="lineCov">         69 :     return false;</span>
<span class="lineNum">     895 </span>            :   return true;
<span class="lineNum">     896 </span>            : }
<span class="lineNum">     897 </span>            : 
<span class="lineNum">     898 </span>            : /* Note DECL use in OpenMP region OMP_CTX during genericization.  */
<span class="lineNum">     899 </span>            : 
<span class="lineNum">     900 </span>            : static void
<span class="lineNum">     901 </span><span class="lineCov">       3889 : omp_cxx_notice_variable (struct cp_genericize_omp_taskreg *omp_ctx, tree decl)</span>
<span class="lineNum">     902 </span>            : {
<span class="lineNum">     903 </span><span class="lineCov">       3889 :   splay_tree_node n = splay_tree_lookup (omp_ctx-&gt;variables,</span>
<span class="lineNum">     904 </span>            :                                          (splay_tree_key) decl);
<span class="lineNum">     905 </span><span class="lineCov">       3889 :   if (n == NULL)</span>
<span class="lineNum">     906 </span>            :     {
<span class="lineNum">     907 </span><span class="lineCov">       1389 :       int flags = OMP_CLAUSE_DEFAULT_SHARED;</span>
<span class="lineNum">     908 </span><span class="lineCov">       1389 :       if (omp_ctx-&gt;outer)</span>
<span class="lineNum">     909 </span><span class="lineCov">        250 :         omp_cxx_notice_variable (omp_ctx-&gt;outer, decl);</span>
<span class="lineNum">     910 </span><span class="lineCov">       1389 :       if (!omp_ctx-&gt;default_shared)</span>
<span class="lineNum">     911 </span>            :         {
<span class="lineNum">     912 </span><span class="lineCov">        248 :           struct cp_genericize_omp_taskreg *octx;</span>
<span class="lineNum">     913 </span>            : 
<span class="lineNum">     914 </span><span class="lineCov">        248 :           for (octx = omp_ctx-&gt;outer; octx; octx = octx-&gt;outer)</span>
<span class="lineNum">     915 </span>            :             {
<span class="lineNum">     916 </span><span class="lineCov">        200 :               n = splay_tree_lookup (octx-&gt;variables, (splay_tree_key) decl);</span>
<span class="lineNum">     917 </span><span class="lineCov">        200 :               if (n &amp;&amp; n-&gt;value != OMP_CLAUSE_DEFAULT_SHARED)</span>
<span class="lineNum">     918 </span>            :                 {
<span class="lineNum">     919 </span>            :                   flags = OMP_CLAUSE_DEFAULT_FIRSTPRIVATE;
<span class="lineNum">     920 </span>            :                   break;
<span class="lineNum">     921 </span>            :                 }
<span class="lineNum">     922 </span><span class="lineCov">        198 :               if (octx-&gt;is_parallel)</span>
<span class="lineNum">     923 </span>            :                 break;
<span class="lineNum">     924 </span>            :             }
<span class="lineNum">     925 </span><span class="lineCov">        248 :           if (octx == NULL</span>
<span class="lineNum">     926 </span><span class="lineCov">        248 :               &amp;&amp; (TREE_CODE (decl) == PARM_DECL</span>
<span class="lineNum">     927 </span><span class="lineCov">         25 :                   || (!(TREE_STATIC (decl) || DECL_EXTERNAL (decl))</span>
<span class="lineNum">     928 </span><span class="lineCov">         25 :                       &amp;&amp; DECL_CONTEXT (decl) == current_function_decl)))</span>
<span class="lineNum">     929 </span>            :             flags = OMP_CLAUSE_DEFAULT_FIRSTPRIVATE;
<span class="lineNum">     930 </span><span class="lineCov">        200 :           if (flags == OMP_CLAUSE_DEFAULT_FIRSTPRIVATE)</span>
<span class="lineNum">     931 </span>            :             {
<span class="lineNum">     932 </span>            :               /* DECL is implicitly determined firstprivate in
<span class="lineNum">     933 </span>            :                  the current task construct.  Ensure copy ctor and
<span class="lineNum">     934 </span>            :                  dtor are instantiated, because during gimplification
<span class="lineNum">     935 </span>            :                  it will be already too late.  */
<span class="lineNum">     936 </span><span class="lineCov">         50 :               tree type = TREE_TYPE (decl);</span>
<span class="lineNum">     937 </span><span class="lineCov">         50 :               if (is_invisiref_parm (decl))</span>
<span class="lineNum">     938 </span><span class="lineCov">          2 :                 type = TREE_TYPE (type);</span>
<span class="lineNum">     939 </span><span class="lineCov">         48 :               else if (TYPE_REF_P (type))</span>
<span class="lineNum">     940 </span><span class="lineCov">         24 :                 type = TREE_TYPE (type);</span>
<span class="lineNum">     941 </span><span class="lineCov">         50 :               while (TREE_CODE (type) == ARRAY_TYPE)</span>
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :                 type = TREE_TYPE (type);</span>
<span class="lineNum">     943 </span><span class="lineCov">         50 :               get_copy_ctor (type, tf_none);</span>
<span class="lineNum">     944 </span><span class="lineCov">         50 :               get_dtor (type, tf_none);</span>
<span class="lineNum">     945 </span>            :             }
<span class="lineNum">     946 </span>            :         }
<span class="lineNum">     947 </span><span class="lineCov">       1389 :       splay_tree_insert (omp_ctx-&gt;variables, (splay_tree_key) decl, flags);</span>
<span class="lineNum">     948 </span>            :     }
<span class="lineNum">     949 </span><span class="lineCov">       3889 : }</span>
<span class="lineNum">     950 </span>            : 
<span class="lineNum">     951 </span>            : /* Genericization context.  */
<span class="lineNum">     952 </span>            : 
<span class="lineNum">     953 </span>            : struct cp_genericize_data
<span class="lineNum">     954 </span>            : {
<span class="lineNum">     955 </span>            :   hash_set&lt;tree&gt; *p_set;
<span class="lineNum">     956 </span>            :   vec&lt;tree&gt; bind_expr_stack;
<span class="lineNum">     957 </span>            :   struct cp_genericize_omp_taskreg *omp_ctx;
<span class="lineNum">     958 </span>            :   tree try_block;
<span class="lineNum">     959 </span>            :   bool no_sanitize_p;
<span class="lineNum">     960 </span>            :   bool handle_invisiref_parm_p;
<span class="lineNum">     961 </span>            : };
<span class="lineNum">     962 </span>            : 
<span class="lineNum">     963 </span>            : /* Perform any pre-gimplification folding of C++ front end trees to
<span class="lineNum">     964 </span>            :    GENERIC.
<span class="lineNum">     965 </span>            :    Note:  The folding of none-omp cases is something to move into
<span class="lineNum">     966 </span>            :      the middle-end.  As for now we have most foldings only on GENERIC
<span class="lineNum">     967 </span>            :      in fold-const, we need to perform this before transformation to
<span class="lineNum">     968 </span>            :      GIMPLE-form.  */
<span class="lineNum">     969 </span>            : 
<span class="lineNum">     970 </span>            : static tree
<span class="lineNum">     971 </span><span class="lineCov">  313918822 : cp_fold_r (tree *stmt_p, int *walk_subtrees, void *data)</span>
<span class="lineNum">     972 </span>            : {
<span class="lineNum">     973 </span><span class="lineCov">  313918822 :   tree stmt;</span>
<span class="lineNum">     974 </span><span class="lineCov">  313918822 :   enum tree_code code;</span>
<span class="lineNum">     975 </span>            : 
<span class="lineNum">     976 </span><span class="lineCov">  313918822 :   *stmt_p = stmt = cp_fold (*stmt_p);</span>
<span class="lineNum">     977 </span>            : 
<span class="lineNum">     978 </span><span class="lineCov">  313918822 :   if (((hash_set&lt;tree&gt; *) data)-&gt;add (stmt))</span>
<span class="lineNum">     979 </span>            :     {
<span class="lineNum">     980 </span>            :       /* Don't walk subtrees of stmts we've already walked once, otherwise
<span class="lineNum">     981 </span>            :          we can have exponential complexity with e.g. lots of nested
<span class="lineNum">     982 </span>            :          SAVE_EXPRs or TARGET_EXPRs.  cp_fold uses a cache and will return
<span class="lineNum">     983 </span>            :          always the same tree, which the first time cp_fold_r has been
<span class="lineNum">     984 </span>            :          called on it had the subtrees walked.  */
<span class="lineNum">     985 </span><span class="lineCov">   40469507 :       *walk_subtrees = 0;</span>
<span class="lineNum">     986 </span><span class="lineCov">   40469507 :       return NULL;</span>
<span class="lineNum">     987 </span>            :     }
<span class="lineNum">     988 </span>            : 
<span class="lineNum">     989 </span><span class="lineCov">  273449315 :   code = TREE_CODE (stmt);</span>
<span class="lineNum">     990 </span><span class="lineCov">  546898630 :   if (code == OMP_FOR || code == OMP_SIMD || code == OMP_DISTRIBUTE</span>
<span class="lineNum">     991 </span><span class="lineCov">  273449315 :       || code == OMP_TASKLOOP || code == OACC_LOOP)</span>
<span class="lineNum">     992 </span>            :     {
<span class="lineNum">     993 </span><span class="lineCov">       9225 :       tree x;</span>
<span class="lineNum">     994 </span><span class="lineCov">       9225 :       int i, n;</span>
<span class="lineNum">     995 </span>            : 
<span class="lineNum">     996 </span><span class="lineCov">      18450 :       cp_walk_tree (&amp;OMP_FOR_BODY (stmt), cp_fold_r, data, NULL);</span>
<span class="lineNum">     997 </span><span class="lineCov">      18450 :       cp_walk_tree (&amp;OMP_FOR_CLAUSES (stmt), cp_fold_r, data, NULL);</span>
<span class="lineNum">     998 </span><span class="lineCov">      18450 :       cp_walk_tree (&amp;OMP_FOR_INIT (stmt), cp_fold_r, data, NULL);</span>
<span class="lineNum">     999 </span><span class="lineCov">      18450 :       x = OMP_FOR_COND (stmt);</span>
<span class="lineNum">    1000 </span><span class="lineCov">       9225 :       if (x &amp;&amp; TREE_CODE_CLASS (TREE_CODE (x)) == tcc_comparison)</span>
<span class="lineNum">    1001 </span>            :         {
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :           cp_walk_tree (&amp;TREE_OPERAND (x, 0), cp_fold_r, data, NULL);</span>
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :           cp_walk_tree (&amp;TREE_OPERAND (x, 1), cp_fold_r, data, NULL);</span>
<span class="lineNum">    1004 </span>            :         }
<span class="lineNum">    1005 </span><span class="lineCov">       9225 :       else if (x &amp;&amp; TREE_CODE (x) == TREE_VEC)</span>
<span class="lineNum">    1006 </span>            :         {
<span class="lineNum">    1007 </span><span class="lineCov">       6971 :           n = TREE_VEC_LENGTH (x);</span>
<span class="lineNum">    1008 </span><span class="lineCov">      16062 :           for (i = 0; i &lt; n; i++)</span>
<span class="lineNum">    1009 </span>            :             {
<span class="lineNum">    1010 </span><span class="lineCov">       9091 :               tree o = TREE_VEC_ELT (x, i);</span>
<span class="lineNum">    1011 </span><span class="lineCov">       9091 :               if (o &amp;&amp; TREE_CODE_CLASS (TREE_CODE (o)) == tcc_comparison)</span>
<span class="lineNum">    1012 </span><span class="lineCov">       9091 :                 cp_walk_tree (&amp;TREE_OPERAND (o, 1), cp_fold_r, data, NULL);</span>
<span class="lineNum">    1013 </span>            :             }
<span class="lineNum">    1014 </span>            :         }
<span class="lineNum">    1015 </span><span class="lineCov">      18450 :       x = OMP_FOR_INCR (stmt);</span>
<span class="lineNum">    1016 </span><span class="lineCov">       9225 :       if (x &amp;&amp; TREE_CODE (x) == TREE_VEC)</span>
<span class="lineNum">    1017 </span>            :         {
<span class="lineNum">    1018 </span><span class="lineCov">       6971 :           n = TREE_VEC_LENGTH (x);</span>
<span class="lineNum">    1019 </span><span class="lineCov">      16062 :           for (i = 0; i &lt; n; i++)</span>
<span class="lineNum">    1020 </span>            :             {
<span class="lineNum">    1021 </span><span class="lineCov">       9091 :               tree o = TREE_VEC_ELT (x, i);</span>
<span class="lineNum">    1022 </span><span class="lineCov">       9091 :               if (o &amp;&amp; TREE_CODE (o) == MODIFY_EXPR)</span>
<span class="lineNum">    1023 </span><span class="lineCov">       2864 :                 o = TREE_OPERAND (o, 1);</span>
<span class="lineNum">    1024 </span><span class="lineCov">       9091 :               if (o &amp;&amp; (TREE_CODE (o) == PLUS_EXPR || TREE_CODE (o) == MINUS_EXPR</span>
<span class="lineNum">    1025 </span><span class="lineCov">       6813 :                         || TREE_CODE (o) == POINTER_PLUS_EXPR))</span>
<span class="lineNum">    1026 </span>            :                 {
<span class="lineNum">    1027 </span><span class="lineCov">       2864 :                   cp_walk_tree (&amp;TREE_OPERAND (o, 0), cp_fold_r, data, NULL);</span>
<span class="lineNum">    1028 </span><span class="lineCov">       2864 :                   cp_walk_tree (&amp;TREE_OPERAND (o, 1), cp_fold_r, data, NULL);</span>
<span class="lineNum">    1029 </span>            :                 }
<span class="lineNum">    1030 </span>            :             }
<span class="lineNum">    1031 </span>            :         }
<span class="lineNum">    1032 </span><span class="lineCov">      18450 :       cp_walk_tree (&amp;OMP_FOR_PRE_BODY (stmt), cp_fold_r, data, NULL);</span>
<span class="lineNum">    1033 </span><span class="lineCov">       9225 :       *walk_subtrees = 0;</span>
<span class="lineNum">    1034 </span>            :     }
<span class="lineNum">    1035 </span>            : 
<span class="lineNum">    1036 </span>            :   return NULL;
<span class="lineNum">    1037 </span>            : }
<span class="lineNum">    1038 </span>            : 
<span class="lineNum">    1039 </span>            : /* Fold ALL the trees!  FIXME we should be able to remove this, but
<span class="lineNum">    1040 </span>            :    apparently that still causes optimization regressions.  */
<span class="lineNum">    1041 </span>            : 
<span class="lineNum">    1042 </span>            : void
<span class="lineNum">    1043 </span><span class="lineCov">   12361187 : cp_fold_function (tree fndecl)</span>
<span class="lineNum">    1044 </span>            : {
<span class="lineNum">    1045 </span><span class="lineCov">   12361187 :   hash_set&lt;tree&gt; pset;</span>
<span class="lineNum">    1046 </span><span class="lineCov">   12361187 :   cp_walk_tree (&amp;DECL_SAVED_TREE (fndecl), cp_fold_r, &amp;pset, NULL);</span>
<span class="lineNum">    1047 </span><span class="lineCov">   12361187 : }</span>
<span class="lineNum">    1048 </span>            : 
<span class="lineNum">    1049 </span>            : /* Perform any pre-gimplification lowering of C++ front end trees to
<span class="lineNum">    1050 </span>            :    GENERIC.  */
<span class="lineNum">    1051 </span>            : 
<span class="lineNum">    1052 </span>            : static tree
<span class="lineNum">    1053 </span><span class="lineCov">  243691939 : cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)</span>
<span class="lineNum">    1054 </span>            : {
<span class="lineNum">    1055 </span><span class="lineCov">  243691939 :   tree stmt = *stmt_p;</span>
<span class="lineNum">    1056 </span><span class="lineCov">  243691939 :   struct cp_genericize_data *wtd = (struct cp_genericize_data *) data;</span>
<span class="lineNum">    1057 </span><span class="lineCov">  243691939 :   hash_set&lt;tree&gt; *p_set = wtd-&gt;p_set;</span>
<span class="lineNum">    1058 </span>            : 
<span class="lineNum">    1059 </span>            :   /* If in an OpenMP context, note var uses.  */
<span class="lineNum">    1060 </span><span class="lineCov">  243691939 :   if (__builtin_expect (wtd-&gt;omp_ctx != NULL, 0)</span>
<span class="lineNum">    1061 </span><span class="lineCov">     195343 :       &amp;&amp; (VAR_P (stmt)</span>
<span class="lineNum">    1062 </span><span class="lineCov">     162281 :           || TREE_CODE (stmt) == PARM_DECL</span>
<span class="lineNum">    1063 </span><span class="lineCov">     158519 :           || TREE_CODE (stmt) == RESULT_DECL)</span>
<span class="lineNum">    1064 </span><span class="lineCov">  243728776 :       &amp;&amp; omp_var_to_track (stmt))</span>
<span class="lineNum">    1065 </span><span class="lineCov">       3315 :     omp_cxx_notice_variable (wtd-&gt;omp_ctx, stmt);</span>
<span class="lineNum">    1066 </span>            : 
<span class="lineNum">    1067 </span>            :   /* Don't dereference parms in a thunk, pass the references through. */
<span class="lineNum">    1068 </span><span class="lineCov">   26611122 :   if ((TREE_CODE (stmt) == CALL_EXPR &amp;&amp; CALL_FROM_THUNK_P (stmt))</span>
<span class="lineNum">    1069 </span><span class="lineCov">  256984677 :       || (TREE_CODE (stmt) == AGGR_INIT_EXPR &amp;&amp; AGGR_INIT_FROM_THUNK_P (stmt)))</span>
<span class="lineNum">    1070 </span>            :     {
<span class="lineNum">    1071 </span><span class="lineCov">      12838 :       *walk_subtrees = 0;</span>
<span class="lineNum">    1072 </span><span class="lineCov">      12838 :       return NULL;</span>
<span class="lineNum">    1073 </span>            :     }
<span class="lineNum">    1074 </span>            : 
<span class="lineNum">    1075 </span>            :   /* Dereference invisible reference parms.  */
<span class="lineNum">    1076 </span><span class="lineCov">  243679101 :   if (wtd-&gt;handle_invisiref_parm_p &amp;&amp; is_invisiref_parm (stmt))</span>
<span class="lineNum">    1077 </span>            :     {
<span class="lineNum">    1078 </span><span class="lineCov">     195453 :       *stmt_p = convert_from_reference (stmt);</span>
<span class="lineNum">    1079 </span><span class="lineCov">     195453 :       p_set-&gt;add (*stmt_p);</span>
<span class="lineNum">    1080 </span><span class="lineCov">     195453 :       *walk_subtrees = 0;</span>
<span class="lineNum">    1081 </span><span class="lineCov">     195453 :       return NULL;</span>
<span class="lineNum">    1082 </span>            :     }
<span class="lineNum">    1083 </span>            : 
<span class="lineNum">    1084 </span>            :   /* Map block scope extern declarations to visible declarations with the
<span class="lineNum">    1085 </span>            :      same name and type in outer scopes if any.  */
<span class="lineNum">    1086 </span><span class="lineCov">  243483648 :   if (cp_function_chain-&gt;extern_decl_map</span>
<span class="lineNum">    1087 </span><span class="lineCov">       7020 :       &amp;&amp; VAR_OR_FUNCTION_DECL_P (stmt)</span>
<span class="lineNum">    1088 </span><span class="lineCov">  243484953 :       &amp;&amp; DECL_EXTERNAL (stmt))</span>
<span class="lineNum">    1089 </span>            :     {
<span class="lineNum">    1090 </span><span class="lineCov">        443 :       struct cxx_int_tree_map *h, in;</span>
<span class="lineNum">    1091 </span><span class="lineCov">        443 :       in.uid = DECL_UID (stmt);</span>
<span class="lineNum">    1092 </span><span class="lineCov">        443 :       h = cp_function_chain-&gt;extern_decl_map-&gt;find_with_hash (&amp;in, in.uid);</span>
<span class="lineNum">    1093 </span><span class="lineCov">        443 :       if (h)</span>
<span class="lineNum">    1094 </span>            :         {
<span class="lineNum">    1095 </span><span class="lineCov">        277 :           *stmt_p = h-&gt;to;</span>
<span class="lineNum">    1096 </span><span class="lineCov">        277 :           TREE_USED (h-&gt;to) |= TREE_USED (stmt);</span>
<span class="lineNum">    1097 </span><span class="lineCov">        277 :           *walk_subtrees = 0;</span>
<span class="lineNum">    1098 </span><span class="lineCov">        277 :           return NULL;</span>
<span class="lineNum">    1099 </span>            :         }
<span class="lineNum">    1100 </span>            :     }
<span class="lineNum">    1101 </span>            : 
<span class="lineNum">    1102 </span><span class="lineCov">  243483371 :   if (TREE_CODE (stmt) == INTEGER_CST</span>
<span class="lineNum">    1103 </span><span class="lineCov">   27166556 :       &amp;&amp; TYPE_REF_P (TREE_TYPE (stmt))</span>
<span class="lineNum">    1104 </span><span class="lineCov">         77 :       &amp;&amp; (flag_sanitize &amp; (SANITIZE_NULL | SANITIZE_ALIGNMENT))</span>
<span class="lineNum">    1105 </span><span class="lineCov">  243483378 :       &amp;&amp; !wtd-&gt;no_sanitize_p)</span>
<span class="lineNum">    1106 </span>            :     {
<span class="lineNum">    1107 </span><span class="lineCov">          7 :       ubsan_maybe_instrument_reference (stmt_p);</span>
<span class="lineNum">    1108 </span><span class="lineCov">          7 :       if (*stmt_p != stmt)</span>
<span class="lineNum">    1109 </span>            :         {
<span class="lineNum">    1110 </span><span class="lineCov">          7 :           *walk_subtrees = 0;</span>
<span class="lineNum">    1111 </span><span class="lineCov">          7 :           return NULL_TREE;</span>
<span class="lineNum">    1112 </span>            :         }
<span class="lineNum">    1113 </span>            :     }
<span class="lineNum">    1114 </span>            : 
<span class="lineNum">    1115 </span>            :   /* Other than invisiref parms, don't walk the same tree twice.  */
<span class="lineNum">    1116 </span><span class="lineCov">  243483364 :   if (p_set-&gt;contains (stmt))</span>
<span class="lineNum">    1117 </span>            :     {
<span class="lineNum">    1118 </span><span class="lineCov">   35682986 :       *walk_subtrees = 0;</span>
<span class="lineNum">    1119 </span><span class="lineCov">   35682986 :       return NULL_TREE;</span>
<span class="lineNum">    1120 </span>            :     }
<span class="lineNum">    1121 </span>            : 
<span class="lineNum">    1122 </span><span class="lineCov">  207800378 :   switch (TREE_CODE (stmt))</span>
<span class="lineNum">    1123 </span>            :     {
<span class="lineNum">    1124 </span><span class="lineCov">   19604089 :     case ADDR_EXPR:</span>
<span class="lineNum">    1125 </span><span class="lineCov">   19604089 :       if (is_invisiref_parm (TREE_OPERAND (stmt, 0)))</span>
<span class="lineNum">    1126 </span>            :         {
<span class="lineNum">    1127 </span>            :           /* If in an OpenMP context, note var uses.  */
<span class="lineNum">    1128 </span><span class="lineCov">      94536 :           if (__builtin_expect (wtd-&gt;omp_ctx != NULL, 0)</span>
<span class="lineNum">    1129 </span><span class="lineCov">      94536 :               &amp;&amp; omp_var_to_track (TREE_OPERAND (stmt, 0)))</span>
<span class="lineNum">    1130 </span><span class="lineCov">        250 :             omp_cxx_notice_variable (wtd-&gt;omp_ctx, TREE_OPERAND (stmt, 0));</span>
<span class="lineNum">    1131 </span><span class="lineCov">      94536 :           *stmt_p = fold_convert (TREE_TYPE (stmt), TREE_OPERAND (stmt, 0));</span>
<span class="lineNum">    1132 </span><span class="lineCov">      94536 :           *walk_subtrees = 0;</span>
<span class="lineNum">    1133 </span>            :         }
<span class="lineNum">    1134 </span>            :       break;
<span class="lineNum">    1135 </span>            : 
<span class="lineNum">    1136 </span><span class="lineCov">    5165845 :     case RETURN_EXPR:</span>
<span class="lineNum">    1137 </span><span class="lineCov">    5165845 :       if (TREE_OPERAND (stmt, 0) &amp;&amp; is_invisiref_parm (TREE_OPERAND (stmt, 0)))</span>
<span class="lineNum">    1138 </span>            :         /* Don't dereference an invisiref RESULT_DECL inside a RETURN_EXPR.  */
<span class="lineNum">    1139 </span><span class="lineCov">       9559 :         *walk_subtrees = 0;</span>
<span class="lineNum">    1140 </span>            :       break;
<span class="lineNum">    1141 </span>            : 
<span class="lineNum">    1142 </span><span class="lineCov">      25506 :     case OMP_CLAUSE:</span>
<span class="lineNum">    1143 </span><span class="lineCov">      25506 :       switch (OMP_CLAUSE_CODE (stmt))</span>
<span class="lineNum">    1144 </span>            :         {
<span class="lineNum">    1145 </span><span class="lineCov">        719 :         case OMP_CLAUSE_LASTPRIVATE:</span>
<span class="lineNum">    1146 </span>            :           /* Don't dereference an invisiref in OpenMP clauses.  */
<span class="lineNum">    1147 </span><span class="lineCov">       1438 :           if (is_invisiref_parm (OMP_CLAUSE_DECL (stmt)))</span>
<span class="lineNum">    1148 </span>            :             {
<span class="lineNum">    1149 </span><span class="lineCov">         32 :               *walk_subtrees = 0;</span>
<span class="lineNum">    1150 </span><span class="lineCov">         32 :               if (OMP_CLAUSE_LASTPRIVATE_STMT (stmt))</span>
<span class="lineNum">    1151 </span><span class="lineCov">         27 :                 cp_walk_tree (&amp;OMP_CLAUSE_LASTPRIVATE_STMT (stmt),</span>
<span class="lineNum">    1152 </span>            :                               cp_genericize_r, data, NULL);
<span class="lineNum">    1153 </span>            :             }
<span class="lineNum">    1154 </span>            :           break;
<span class="lineNum">    1155 </span><span class="lineCov">        676 :         case OMP_CLAUSE_PRIVATE:</span>
<span class="lineNum">    1156 </span>            :           /* Don't dereference an invisiref in OpenMP clauses.  */
<span class="lineNum">    1157 </span><span class="lineCov">       1352 :           if (is_invisiref_parm (OMP_CLAUSE_DECL (stmt)))</span>
<span class="lineNum">    1158 </span><span class="lineCov">          7 :             *walk_subtrees = 0;</span>
<span class="lineNum">    1159 </span><span class="lineCov">        669 :           else if (wtd-&gt;omp_ctx != NULL)</span>
<span class="lineNum">    1160 </span>            :             {
<span class="lineNum">    1161 </span>            :               /* Private clause doesn't cause any references to the
<span class="lineNum">    1162 </span>            :                  var in outer contexts, avoid calling
<span class="lineNum">    1163 </span>            :                  omp_cxx_notice_variable for it.  */
<span class="lineNum">    1164 </span><span class="lineCov">        147 :               struct cp_genericize_omp_taskreg *old = wtd-&gt;omp_ctx;</span>
<span class="lineNum">    1165 </span><span class="lineCov">        147 :               wtd-&gt;omp_ctx = NULL;</span>
<span class="lineNum">    1166 </span><span class="lineCov">        147 :               cp_walk_tree (&amp;OMP_CLAUSE_DECL (stmt), cp_genericize_r,</span>
<span class="lineNum">    1167 </span>            :                             data, NULL);
<span class="lineNum">    1168 </span><span class="lineCov">        147 :               wtd-&gt;omp_ctx = old;</span>
<span class="lineNum">    1169 </span><span class="lineCov">        147 :               *walk_subtrees = 0;</span>
<span class="lineNum">    1170 </span>            :             }
<span class="lineNum">    1171 </span>            :           break;
<span class="lineNum">    1172 </span><span class="lineCov">       1949 :         case OMP_CLAUSE_SHARED:</span>
<span class="lineNum">    1173 </span><span class="lineCov">       1949 :         case OMP_CLAUSE_FIRSTPRIVATE:</span>
<span class="lineNum">    1174 </span><span class="lineCov">       1949 :         case OMP_CLAUSE_COPYIN:</span>
<span class="lineNum">    1175 </span><span class="lineCov">       1949 :         case OMP_CLAUSE_COPYPRIVATE:</span>
<span class="lineNum">    1176 </span>            :           /* Don't dereference an invisiref in OpenMP clauses.  */
<span class="lineNum">    1177 </span><span class="lineCov">       3898 :           if (is_invisiref_parm (OMP_CLAUSE_DECL (stmt)))</span>
<span class="lineNum">    1178 </span><span class="lineCov">         15 :             *walk_subtrees = 0;</span>
<span class="lineNum">    1179 </span>            :           break;
<span class="lineNum">    1180 </span><span class="lineCov">       1592 :         case OMP_CLAUSE_REDUCTION:</span>
<span class="lineNum">    1181 </span>            :           /* Don't dereference an invisiref in reduction clause's
<span class="lineNum">    1182 </span>            :              OMP_CLAUSE_DECL either.  OMP_CLAUSE_REDUCTION_{INIT,MERGE}
<span class="lineNum">    1183 </span>            :              still needs to be genericized.  */
<span class="lineNum">    1184 </span><span class="lineCov">       3184 :           if (is_invisiref_parm (OMP_CLAUSE_DECL (stmt)))</span>
<span class="lineNum">    1185 </span>            :             {
<span class="lineNum">    1186 </span><span class="lineCov">          8 :               *walk_subtrees = 0;</span>
<span class="lineNum">    1187 </span><span class="lineCov">          8 :               if (OMP_CLAUSE_REDUCTION_INIT (stmt))</span>
<span class="lineNum">    1188 </span><span class="lineCov">          8 :                 cp_walk_tree (&amp;OMP_CLAUSE_REDUCTION_INIT (stmt),</span>
<span class="lineNum">    1189 </span>            :                               cp_genericize_r, data, NULL);
<span class="lineNum">    1190 </span><span class="lineCov">          8 :               if (OMP_CLAUSE_REDUCTION_MERGE (stmt))</span>
<span class="lineNum">    1191 </span><span class="lineCov">          8 :                 cp_walk_tree (&amp;OMP_CLAUSE_REDUCTION_MERGE (stmt),</span>
<span class="lineNum">    1192 </span>            :                               cp_genericize_r, data, NULL);
<span class="lineNum">    1193 </span>            :             }
<span class="lineNum">    1194 </span>            :           break;
<span class="lineNum">    1195 </span>            :         default:
<span class="lineNum">    1196 </span>            :           break;
<span class="lineNum">    1197 </span>            :         }
<span class="lineNum">    1198 </span>            :       break;
<span class="lineNum">    1199 </span>            : 
<span class="lineNum">    1200 </span>            :     /* Due to the way voidify_wrapper_expr is written, we don't get a chance
<span class="lineNum">    1201 </span>            :        to lower this construct before scanning it, so we need to lower these
<span class="lineNum">    1202 </span>            :        before doing anything else.  */
<span class="lineNum">    1203 </span><span class="lineCov">    1658092 :     case CLEANUP_STMT:</span>
<span class="lineNum">    1204 </span><span class="lineCov">    1658092 :       *stmt_p = build2_loc (EXPR_LOCATION (stmt),</span>
<span class="lineNum">    1205 </span>            :                             CLEANUP_EH_ONLY (stmt) ? TRY_CATCH_EXPR
<span class="lineNum">    1206 </span><span class="lineCov">    1658092 :                                                    : TRY_FINALLY_EXPR,</span>
<span class="lineNum">    1207 </span>            :                             void_type_node,
<span class="lineNum">    1208 </span><span class="lineCov">    3316184 :                             CLEANUP_BODY (stmt),</span>
<span class="lineNum">    1209 </span><span class="lineCov">    1658092 :                             CLEANUP_EXPR (stmt));</span>
<span class="lineNum">    1210 </span><span class="lineCov">    1658092 :       break;</span>
<span class="lineNum">    1211 </span>            : 
<span class="lineNum">    1212 </span><span class="lineCov">    1885084 :     case IF_STMT:</span>
<span class="lineNum">    1213 </span><span class="lineCov">    1885084 :       genericize_if_stmt (stmt_p);</span>
<span class="lineNum">    1214 </span>            :       /* *stmt_p has changed, tail recurse to handle it again.  */
<span class="lineNum">    1215 </span><span class="lineCov">    1885084 :       return cp_genericize_r (stmt_p, walk_subtrees, data);</span>
<span class="lineNum">    1216 </span>            : 
<span class="lineNum">    1217 </span>            :     /* COND_EXPR might have incompatible types in branches if one or both
<span class="lineNum">    1218 </span>            :        arms are bitfields.  Fix it up now.  */
<span class="lineNum">    1219 </span><span class="lineCov">    2156565 :     case COND_EXPR:</span>
<span class="lineNum">    1220 </span><span class="lineCov">    2156565 :       {</span>
<span class="lineNum">    1221 </span><span class="lineCov">    2156565 :         tree type_left</span>
<span class="lineNum">    1222 </span><span class="lineCov">    2156565 :           = (TREE_OPERAND (stmt, 1)</span>
<span class="lineNum">    1223 </span><span class="lineCov">    2156565 :              ? is_bitfield_expr_with_lowered_type (TREE_OPERAND (stmt, 1))</span>
<span class="lineNum">    1224 </span><span class="lineCov">    2156565 :              : NULL_TREE);</span>
<span class="lineNum">    1225 </span><span class="lineCov">    2156565 :         tree type_right</span>
<span class="lineNum">    1226 </span><span class="lineCov">    2156565 :           = (TREE_OPERAND (stmt, 2)</span>
<span class="lineNum">    1227 </span><span class="lineCov">    2156565 :              ? is_bitfield_expr_with_lowered_type (TREE_OPERAND (stmt, 2))</span>
<span class="lineNum">    1228 </span><span class="lineCov">    2156565 :              : NULL_TREE);</span>
<span class="lineNum">    1229 </span><span class="lineCov">    2156565 :         if (type_left</span>
<span class="lineNum">    1230 </span><span class="lineCov">    2156595 :             &amp;&amp; !useless_type_conversion_p (TREE_TYPE (stmt),</span>
<span class="lineNum">    1231 </span><span class="lineCov">         30 :                                            TREE_TYPE (TREE_OPERAND (stmt, 1))))</span>
<span class="lineNum">    1232 </span>            :           {
<span class="lineNum">    1233 </span><span class="lineCov">         54 :             TREE_OPERAND (stmt, 1)</span>
<span class="lineNum">    1234 </span><span class="lineCov">         27 :               = fold_convert (type_left, TREE_OPERAND (stmt, 1));</span>
<span class="lineNum">    1235 </span><span class="lineCov">         27 :             gcc_assert (useless_type_conversion_p (TREE_TYPE (stmt),</span>
<span class="lineNum">    1236 </span>            :                                                    type_left));
<span class="lineNum">    1237 </span>            :           }
<span class="lineNum">    1238 </span><span class="lineCov">    2156565 :         if (type_right</span>
<span class="lineNum">    1239 </span><span class="lineCov">    2156582 :             &amp;&amp; !useless_type_conversion_p (TREE_TYPE (stmt),</span>
<span class="lineNum">    1240 </span><span class="lineCov">         17 :                                            TREE_TYPE (TREE_OPERAND (stmt, 2))))</span>
<span class="lineNum">    1241 </span>            :           {
<span class="lineNum">    1242 </span><span class="lineCov">         34 :             TREE_OPERAND (stmt, 2)</span>
<span class="lineNum">    1243 </span><span class="lineCov">         17 :               = fold_convert (type_right, TREE_OPERAND (stmt, 2));</span>
<span class="lineNum">    1244 </span><span class="lineCov">         17 :             gcc_assert (useless_type_conversion_p (TREE_TYPE (stmt),</span>
<span class="lineNum">    1245 </span>            :                                                    type_right));
<span class="lineNum">    1246 </span>            :           }
<span class="lineNum">    1247 </span>            :       }
<span class="lineNum">    1248 </span>            :       break;
<span class="lineNum">    1249 </span>            : 
<span class="lineNum">    1250 </span><span class="lineCov">    3529031 :     case BIND_EXPR:</span>
<span class="lineNum">    1251 </span><span class="lineCov">    3529031 :       if (__builtin_expect (wtd-&gt;omp_ctx != NULL, 0))</span>
<span class="lineNum">    1252 </span>            :         {
<span class="lineNum">    1253 </span><span class="lineCov">       6136 :           tree decl;</span>
<span class="lineNum">    1254 </span><span class="lineCov">       8347 :           for (decl = BIND_EXPR_VARS (stmt); decl; decl = DECL_CHAIN (decl))</span>
<span class="lineNum">    1255 </span><span class="lineCov">       2211 :             if (VAR_P (decl)</span>
<span class="lineNum">    1256 </span><span class="lineCov">       2183 :                 &amp;&amp; !DECL_EXTERNAL (decl)</span>
<span class="lineNum">    1257 </span><span class="lineCov">       4394 :                 &amp;&amp; omp_var_to_track (decl))</span>
<span class="lineNum">    1258 </span>            :               {
<span class="lineNum">    1259 </span><span class="lineCov">        210 :                 splay_tree_node n</span>
<span class="lineNum">    1260 </span><span class="lineCov">        210 :                   = splay_tree_lookup (wtd-&gt;omp_ctx-&gt;variables,</span>
<span class="lineNum">    1261 </span>            :                                        (splay_tree_key) decl);
<span class="lineNum">    1262 </span><span class="lineCov">        210 :                 if (n == NULL)</span>
<span class="lineNum">    1263 </span><span class="lineCov">        210 :                   splay_tree_insert (wtd-&gt;omp_ctx-&gt;variables,</span>
<span class="lineNum">    1264 </span>            :                                      (splay_tree_key) decl,
<span class="lineNum">    1265 </span>            :                                      TREE_STATIC (decl)
<span class="lineNum">    1266 </span>            :                                      ? OMP_CLAUSE_DEFAULT_SHARED
<span class="lineNum">    1267 </span><span class="lineCov">        210 :                                      : OMP_CLAUSE_DEFAULT_PRIVATE);</span>
<span class="lineNum">    1268 </span>            :               }
<span class="lineNum">    1269 </span>            :         }
<span class="lineNum">    1270 </span><span class="lineCov">    3529031 :       if (sanitize_flags_p (SANITIZE_NULL | SANITIZE_ALIGNMENT | SANITIZE_VPTR))</span>
<span class="lineNum">    1271 </span>            :         {
<span class="lineNum">    1272 </span>            :           /* The point here is to not sanitize static initializers.  */
<span class="lineNum">    1273 </span><span class="lineCov">       2055 :           bool no_sanitize_p = wtd-&gt;no_sanitize_p;</span>
<span class="lineNum">    1274 </span><span class="lineCov">       2055 :           wtd-&gt;no_sanitize_p = true;</span>
<span class="lineNum">    1275 </span><span class="lineCov">       2055 :           for (tree decl = BIND_EXPR_VARS (stmt);</span>
<span class="lineNum">    1276 </span><span class="lineCov">       3958 :                decl;</span>
<span class="lineNum">    1277 </span><span class="lineCov">       1903 :                decl = DECL_CHAIN (decl))</span>
<span class="lineNum">    1278 </span><span class="lineCov">       1903 :             if (VAR_P (decl)</span>
<span class="lineNum">    1279 </span><span class="lineCov">       1903 :                 &amp;&amp; TREE_STATIC (decl)</span>
<span class="lineNum">    1280 </span><span class="lineCov">       1903 :                 &amp;&amp; DECL_INITIAL (decl))</span>
<span class="lineNum">    1281 </span><span class="lineCov">        112 :               cp_walk_tree (&amp;DECL_INITIAL (decl), cp_genericize_r, data, NULL);</span>
<span class="lineNum">    1282 </span><span class="lineCov">       2055 :           wtd-&gt;no_sanitize_p = no_sanitize_p;</span>
<span class="lineNum">    1283 </span>            :         }
<span class="lineNum">    1284 </span><span class="lineCov">    3529031 :       wtd-&gt;bind_expr_stack.safe_push (stmt);</span>
<span class="lineNum">    1285 </span><span class="lineCov">    3529031 :       cp_walk_tree (&amp;BIND_EXPR_BODY (stmt),</span>
<span class="lineNum">    1286 </span>            :                     cp_genericize_r, data, NULL);
<span class="lineNum">    1287 </span><span class="lineCov">    3529031 :       wtd-&gt;bind_expr_stack.pop ();</span>
<span class="lineNum">    1288 </span>            :       break;
<span class="lineNum">    1289 </span>            : 
<span class="lineNum">    1290 </span><span class="lineCov">      51280 :     case USING_STMT:</span>
<span class="lineNum">    1291 </span><span class="lineCov">      51280 :       {</span>
<span class="lineNum">    1292 </span><span class="lineCov">      51280 :         tree block = NULL_TREE;</span>
<span class="lineNum">    1293 </span>            : 
<span class="lineNum">    1294 </span>            :         /* Get the innermost inclosing GIMPLE_BIND that has a non NULL
<span class="lineNum">    1295 </span>            :            BLOCK, and append an IMPORTED_DECL to its
<span class="lineNum">    1296 </span>            :            BLOCK_VARS chained list.  */
<span class="lineNum">    1297 </span><span class="lineCov">      51280 :         if (wtd-&gt;bind_expr_stack.exists ())</span>
<span class="lineNum">    1298 </span>            :           {
<span class="lineNum">    1299 </span><span class="lineCov">      51280 :             int i;</span>
<span class="lineNum">    1300 </span><span class="lineCov">     102560 :             for (i = wtd-&gt;bind_expr_stack.length () - 1; i &gt;= 0; i--)</span>
<span class="lineNum">    1301 </span><span class="lineCov">      51280 :               if ((block = BIND_EXPR_BLOCK (wtd-&gt;bind_expr_stack[i])))</span>
<span class="lineNum">    1302 </span>            :                 break;
<span class="lineNum">    1303 </span>            :           }
<span class="lineNum">    1304 </span><span class="lineCov">      51280 :         if (block)</span>
<span class="lineNum">    1305 </span>            :           {
<span class="lineNum">    1306 </span><span class="lineCov">      51280 :             tree decl = TREE_OPERAND (stmt, 0);</span>
<span class="lineNum">    1307 </span><span class="lineCov">      51280 :             gcc_assert (decl);</span>
<span class="lineNum">    1308 </span>            : 
<span class="lineNum">    1309 </span><span class="lineCov">      51280 :             if (undeduced_auto_decl (decl))</span>
<span class="lineNum">    1310 </span>            :               /* Omit from the GENERIC, the back-end can't handle it.  */;
<span class="lineNum">    1311 </span>            :             else
<span class="lineNum">    1312 </span>            :               {
<span class="lineNum">    1313 </span><span class="lineCov">      51279 :                 tree using_directive = make_node (IMPORTED_DECL);</span>
<span class="lineNum">    1314 </span><span class="lineCov">      51279 :                 TREE_TYPE (using_directive) = void_type_node;</span>
<span class="lineNum">    1315 </span>            : 
<span class="lineNum">    1316 </span><span class="lineCov">      51279 :                 IMPORTED_DECL_ASSOCIATED_DECL (using_directive) = decl;</span>
<span class="lineNum">    1317 </span><span class="lineCov">      51279 :                 DECL_CHAIN (using_directive) = BLOCK_VARS (block);</span>
<span class="lineNum">    1318 </span><span class="lineCov">      51279 :                 BLOCK_VARS (block) = using_directive;</span>
<span class="lineNum">    1319 </span>            :               }
<span class="lineNum">    1320 </span>            :           }
<span class="lineNum">    1321 </span>            :         /* The USING_STMT won't appear in GENERIC.  */
<span class="lineNum">    1322 </span><span class="lineCov">      51280 :         *stmt_p = build1 (NOP_EXPR, void_type_node, integer_zero_node);</span>
<span class="lineNum">    1323 </span><span class="lineCov">      51280 :         *walk_subtrees = 0;</span>
<span class="lineNum">    1324 </span>            :       }
<span class="lineNum">    1325 </span><span class="lineCov">      51280 :       break;</span>
<span class="lineNum">    1326 </span>            : 
<span class="lineNum">    1327 </span><span class="lineCov">    2141944 :     case DECL_EXPR:</span>
<span class="lineNum">    1328 </span><span class="lineCov">    2141944 :       if (TREE_CODE (DECL_EXPR_DECL (stmt)) == USING_DECL)</span>
<span class="lineNum">    1329 </span>            :         {
<span class="lineNum">    1330 </span>            :           /* Using decls inside DECL_EXPRs are just dropped on the floor.  */
<span class="lineNum">    1331 </span><span class="lineCov">      14057 :           *stmt_p = build1 (NOP_EXPR, void_type_node, integer_zero_node);</span>
<span class="lineNum">    1332 </span><span class="lineCov">      14057 :           *walk_subtrees = 0;</span>
<span class="lineNum">    1333 </span>            :         }
<span class="lineNum">    1334 </span>            :       else
<span class="lineNum">    1335 </span>            :         {
<span class="lineNum">    1336 </span><span class="lineCov">    4255774 :           tree d = DECL_EXPR_DECL (stmt);</span>
<span class="lineNum">    1337 </span><span class="lineCov">    2127887 :           if (VAR_P (d))</span>
<span class="lineNum">    1338 </span><span class="lineCov">    6405271 :             gcc_assert (CP_DECL_THREAD_LOCAL_P (d) == DECL_THREAD_LOCAL_P (d));</span>
<span class="lineNum">    1339 </span>            :         }
<span class="lineNum">    1340 </span>            :       break;
<span class="lineNum">    1341 </span>            : 
<span class="lineNum">    1342 </span><span class="lineCov">       4446 :     case OMP_PARALLEL:</span>
<span class="lineNum">    1343 </span><span class="lineCov">       4446 :     case OMP_TASK:</span>
<span class="lineNum">    1344 </span><span class="lineCov">       4446 :     case OMP_TASKLOOP:</span>
<span class="lineNum">    1345 </span><span class="lineCov">       4446 :       {</span>
<span class="lineNum">    1346 </span><span class="lineCov">       4446 :         struct cp_genericize_omp_taskreg omp_ctx;</span>
<span class="lineNum">    1347 </span><span class="lineCov">       4446 :         tree c, decl;</span>
<span class="lineNum">    1348 </span><span class="lineCov">       4446 :         splay_tree_node n;</span>
<span class="lineNum">    1349 </span>            : 
<span class="lineNum">    1350 </span><span class="lineCov">       4446 :         *walk_subtrees = 0;</span>
<span class="lineNum">    1351 </span><span class="lineCov">       8892 :         cp_walk_tree (&amp;OMP_CLAUSES (stmt), cp_genericize_r, data, NULL);</span>
<span class="lineNum">    1352 </span><span class="lineCov">       4446 :         omp_ctx.is_parallel = TREE_CODE (stmt) == OMP_PARALLEL;</span>
<span class="lineNum">    1353 </span><span class="lineCov">       4446 :         omp_ctx.default_shared = omp_ctx.is_parallel;</span>
<span class="lineNum">    1354 </span><span class="lineCov">       4446 :         omp_ctx.outer = wtd-&gt;omp_ctx;</span>
<span class="lineNum">    1355 </span><span class="lineCov">       4446 :         omp_ctx.variables = splay_tree_new (splay_tree_compare_decl_uid, 0, 0);</span>
<span class="lineNum">    1356 </span><span class="lineCov">       4446 :         wtd-&gt;omp_ctx = &amp;omp_ctx;</span>
<span class="lineNum">    1357 </span><span class="lineCov">      12264 :         for (c = OMP_CLAUSES (stmt); c; c = OMP_CLAUSE_CHAIN (c))</span>
<span class="lineNum">    1358 </span><span class="lineCov">       3372 :           switch (OMP_CLAUSE_CODE (c))</span>
<span class="lineNum">    1359 </span>            :             {
<span class="lineNum">    1360 </span><span class="lineCov">       1714 :             case OMP_CLAUSE_SHARED:</span>
<span class="lineNum">    1361 </span><span class="lineCov">       1714 :             case OMP_CLAUSE_PRIVATE:</span>
<span class="lineNum">    1362 </span><span class="lineCov">       1714 :             case OMP_CLAUSE_FIRSTPRIVATE:</span>
<span class="lineNum">    1363 </span><span class="lineCov">       1714 :             case OMP_CLAUSE_LASTPRIVATE:</span>
<span class="lineNum">    1364 </span><span class="lineCov">       3428 :               decl = OMP_CLAUSE_DECL (c);</span>
<span class="lineNum">    1365 </span><span class="lineCov">       1714 :               if (decl == error_mark_node || !omp_var_to_track (decl))</span>
<span class="lineNum">    1366 </span>            :                 break;
<span class="lineNum">    1367 </span><span class="lineCov">        415 :               n = splay_tree_lookup (omp_ctx.variables, (splay_tree_key) decl);</span>
<span class="lineNum">    1368 </span><span class="lineCov">        415 :               if (n != NULL)</span>
<span class="lineNum">    1369 </span>            :                 break;
<span class="lineNum">    1370 </span><span class="lineCov">        406 :               splay_tree_insert (omp_ctx.variables, (splay_tree_key) decl,</span>
<span class="lineNum">    1371 </span><span class="lineCov">        406 :                                  OMP_CLAUSE_CODE (c) == OMP_CLAUSE_SHARED</span>
<span class="lineNum">    1372 </span>            :                                  ? OMP_CLAUSE_DEFAULT_SHARED
<span class="lineNum">    1373 </span>            :                                  : OMP_CLAUSE_DEFAULT_PRIVATE);
<span class="lineNum">    1374 </span><span class="lineCov">        406 :               if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_PRIVATE &amp;&amp; omp_ctx.outer)</span>
<span class="lineNum">    1375 </span><span class="lineCov">         74 :                 omp_cxx_notice_variable (omp_ctx.outer, decl);</span>
<span class="lineNum">    1376 </span>            :               break;
<span class="lineNum">    1377 </span><span class="lineCov">        196 :             case OMP_CLAUSE_DEFAULT:</span>
<span class="lineNum">    1378 </span><span class="lineCov">        196 :               if (OMP_CLAUSE_DEFAULT_KIND (c) == OMP_CLAUSE_DEFAULT_SHARED)</span>
<span class="lineNum">    1379 </span><span class="lineCov">         95 :                 omp_ctx.default_shared = true;</span>
<span class="lineNum">    1380 </span>            :             default:
<span class="lineNum">    1381 </span>            :               break;
<span class="lineNum">    1382 </span>            :             }
<span class="lineNum">    1383 </span><span class="lineCov">       4446 :         if (TREE_CODE (stmt) == OMP_TASKLOOP)</span>
<span class="lineNum">    1384 </span><span class="lineCov">        235 :           genericize_omp_for_stmt (stmt_p, walk_subtrees, data);</span>
<span class="lineNum">    1385 </span>            :         else
<span class="lineNum">    1386 </span><span class="lineCov">       8422 :           cp_walk_tree (&amp;OMP_BODY (stmt), cp_genericize_r, data, NULL);</span>
<span class="lineNum">    1387 </span><span class="lineCov">       4446 :         wtd-&gt;omp_ctx = omp_ctx.outer;</span>
<span class="lineNum">    1388 </span><span class="lineCov">       4446 :         splay_tree_delete (omp_ctx.variables);</span>
<span class="lineNum">    1389 </span>            :       }
<span class="lineNum">    1390 </span><span class="lineCov">       4446 :       break;</span>
<span class="lineNum">    1391 </span>            : 
<span class="lineNum">    1392 </span><span class="lineCov">      73010 :     case TRY_BLOCK:</span>
<span class="lineNum">    1393 </span><span class="lineCov">      73010 :       {</span>
<span class="lineNum">    1394 </span><span class="lineCov">      73010 :         *walk_subtrees = 0;</span>
<span class="lineNum">    1395 </span><span class="lineCov">      73010 :         tree try_block = wtd-&gt;try_block;</span>
<span class="lineNum">    1396 </span><span class="lineCov">      73010 :         wtd-&gt;try_block = stmt;</span>
<span class="lineNum">    1397 </span><span class="lineCov">      73010 :         cp_walk_tree (&amp;TRY_STMTS (stmt), cp_genericize_r, data, NULL);</span>
<span class="lineNum">    1398 </span><span class="lineCov">      73010 :         wtd-&gt;try_block = try_block;</span>
<span class="lineNum">    1399 </span><span class="lineCov">      73010 :         cp_walk_tree (&amp;TRY_HANDLERS (stmt), cp_genericize_r, data, NULL);</span>
<span class="lineNum">    1400 </span>            :       }
<span class="lineNum">    1401 </span><span class="lineCov">      73010 :       break;</span>
<span class="lineNum">    1402 </span>            : 
<span class="lineNum">    1403 </span><span class="lineCov">    3054668 :     case MUST_NOT_THROW_EXPR:</span>
<span class="lineNum">    1404 </span>            :       /* MUST_NOT_THROW_COND might be something else with TM.  */
<span class="lineNum">    1405 </span><span class="lineCov">    3054668 :       if (MUST_NOT_THROW_COND (stmt) == NULL_TREE)</span>
<span class="lineNum">    1406 </span>            :         {
<span class="lineNum">    1407 </span><span class="lineCov">    3054656 :           *walk_subtrees = 0;</span>
<span class="lineNum">    1408 </span><span class="lineCov">    3054656 :           tree try_block = wtd-&gt;try_block;</span>
<span class="lineNum">    1409 </span><span class="lineCov">    3054656 :           wtd-&gt;try_block = stmt;</span>
<span class="lineNum">    1410 </span><span class="lineCov">    3054656 :           cp_walk_tree (&amp;TREE_OPERAND (stmt, 0), cp_genericize_r, data, NULL);</span>
<span class="lineNum">    1411 </span><span class="lineCov">    3054656 :           wtd-&gt;try_block = try_block;</span>
<span class="lineNum">    1412 </span>            :         }
<span class="lineNum">    1413 </span>            :       break;
<span class="lineNum">    1414 </span>            : 
<span class="lineNum">    1415 </span><span class="lineCov">      68636 :     case THROW_EXPR:</span>
<span class="lineNum">    1416 </span><span class="lineCov">      68636 :       {</span>
<span class="lineNum">    1417 </span><span class="lineCov">      68636 :         location_t loc = location_of (stmt);</span>
<span class="lineNum">    1418 </span><span class="lineCov">      68636 :         if (TREE_NO_WARNING (stmt))</span>
<span class="lineNum">    1419 </span>            :           /* Never mind.  */;
<span class="lineNum">    1420 </span><span class="lineCov">      64850 :         else if (wtd-&gt;try_block)</span>
<span class="lineNum">    1421 </span>            :           {
<span class="lineNum">    1422 </span><span class="lineCov">       1069 :             if (TREE_CODE (wtd-&gt;try_block) == MUST_NOT_THROW_EXPR)</span>
<span class="lineNum">    1423 </span>            :               {
<span class="lineNum">    1424 </span><span class="lineCov">         22 :                 auto_diagnostic_group d;</span>
<span class="lineNum">    1425 </span><span class="lineCov">         11 :                 if (warning_at (loc, OPT_Wterminate,</span>
<span class="lineNum">    1426 </span>            :                                 &quot;throw will always call terminate()&quot;)
<span class="lineNum">    1427 </span><span class="lineCov">          5 :                     &amp;&amp; cxx_dialect &gt;= cxx11</span>
<span class="lineNum">    1428 </span><span class="lineCov">         15 :                     &amp;&amp; DECL_DESTRUCTOR_P (current_function_decl))</span>
<span class="lineNum">    1429 </span><span class="lineCov">          2 :                   inform (loc, &quot;in C++11 destructors default to noexcept&quot;);</span>
<span class="lineNum">    1430 </span>            :               }
<span class="lineNum">    1431 </span>            :           }
<span class="lineNum">    1432 </span>            :         else
<span class="lineNum">    1433 </span>            :           {
<span class="lineNum">    1434 </span><span class="lineCov">        112 :             if (warn_cxx11_compat &amp;&amp; cxx_dialect &lt; cxx11</span>
<span class="lineNum">    1435 </span><span class="lineCov">        112 :                 &amp;&amp; DECL_DESTRUCTOR_P (current_function_decl)</span>
<span class="lineNum">    1436 </span><span class="lineCov">          2 :                 &amp;&amp; (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl))</span>
<span class="lineNum">    1437 </span>            :                     == NULL_TREE)
<span class="lineNum">    1438 </span><span class="lineCov">      63782 :                 &amp;&amp; (get_defaulted_eh_spec (current_function_decl)</span>
<span class="lineNum">    1439 </span><span class="lineCov">          1 :                     == empty_except_spec))</span>
<span class="lineNum">    1440 </span><span class="lineCov">          1 :               warning_at (loc, OPT_Wc__11_compat,</span>
<span class="lineNum">    1441 </span>            :                           &quot;in C++11 this throw will terminate because &quot;
<span class="lineNum">    1442 </span>            :                           &quot;destructors default to noexcept&quot;);
<span class="lineNum">    1443 </span>            :           }
<span class="lineNum">    1444 </span>            :       }
<span class="lineNum">    1445 </span>            :       break;
<span class="lineNum">    1446 </span>            : 
<span class="lineNum">    1447 </span><span class="lineCov">    5124749 :     case CONVERT_EXPR:</span>
<span class="lineNum">    1448 </span><span class="lineCov">    5124749 :       gcc_assert (!CONVERT_EXPR_VBASE_PATH (stmt));</span>
<span class="lineNum">    1449 </span>            :       break;
<span class="lineNum">    1450 </span>            : 
<span class="lineNum">    1451 </span><span class="lineCov">      96604 :     case FOR_STMT:</span>
<span class="lineNum">    1452 </span><span class="lineCov">      96604 :       genericize_for_stmt (stmt_p, walk_subtrees, data);</span>
<span class="lineNum">    1453 </span><span class="lineCov">      96604 :       break;</span>
<span class="lineNum">    1454 </span>            : 
<span class="lineNum">    1455 </span><span class="lineCov">      38268 :     case WHILE_STMT:</span>
<span class="lineNum">    1456 </span><span class="lineCov">      38268 :       genericize_while_stmt (stmt_p, walk_subtrees, data);</span>
<span class="lineNum">    1457 </span><span class="lineCov">      38268 :       break;</span>
<span class="lineNum">    1458 </span>            : 
<span class="lineNum">    1459 </span><span class="lineCov">      89112 :     case DO_STMT:</span>
<span class="lineNum">    1460 </span><span class="lineCov">      89112 :       genericize_do_stmt (stmt_p, walk_subtrees, data);</span>
<span class="lineNum">    1461 </span><span class="lineCov">      89112 :       break;</span>
<span class="lineNum">    1462 </span>            : 
<span class="lineNum">    1463 </span><span class="lineCov">      22696 :     case SWITCH_STMT:</span>
<span class="lineNum">    1464 </span><span class="lineCov">      22696 :       genericize_switch_stmt (stmt_p, walk_subtrees, data);</span>
<span class="lineNum">    1465 </span><span class="lineCov">      22696 :       break;</span>
<span class="lineNum">    1466 </span>            : 
<span class="lineNum">    1467 </span><span class="lineCov">       1011 :     case CONTINUE_STMT:</span>
<span class="lineNum">    1468 </span><span class="lineCov">       1011 :       genericize_continue_stmt (stmt_p);</span>
<span class="lineNum">    1469 </span><span class="lineCov">       1011 :       break;</span>
<span class="lineNum">    1470 </span>            : 
<span class="lineNum">    1471 </span><span class="lineCov">     112131 :     case BREAK_STMT:</span>
<span class="lineNum">    1472 </span><span class="lineCov">     112131 :       genericize_break_stmt (stmt_p);</span>
<span class="lineNum">    1473 </span><span class="lineCov">     112131 :       break;</span>
<span class="lineNum">    1474 </span>            : 
<span class="lineNum">    1475 </span><span class="lineCov">       8981 :     case OMP_FOR:</span>
<span class="lineNum">    1476 </span><span class="lineCov">       8981 :     case OMP_SIMD:</span>
<span class="lineNum">    1477 </span><span class="lineCov">       8981 :     case OMP_DISTRIBUTE:</span>
<span class="lineNum">    1478 </span><span class="lineCov">       8981 :     case OACC_LOOP:</span>
<span class="lineNum">    1479 </span><span class="lineCov">       8981 :       genericize_omp_for_stmt (stmt_p, walk_subtrees, data);</span>
<span class="lineNum">    1480 </span><span class="lineCov">       8981 :       break;</span>
<span class="lineNum">    1481 </span>            : 
<span class="lineNum">    1482 </span><span class="lineCov">       2993 :     case PTRMEM_CST:</span>
<span class="lineNum">    1483 </span>            :       /* By the time we get here we're handing off to the back end, so we don't
<span class="lineNum">    1484 </span>            :          need or want to preserve PTRMEM_CST anymore.  */
<span class="lineNum">    1485 </span><span class="lineCov">       2993 :       *stmt_p = cplus_expand_constant (stmt);</span>
<span class="lineNum">    1486 </span><span class="lineCov">       2993 :       *walk_subtrees = 0;</span>
<span class="lineNum">    1487 </span><span class="lineCov">       2993 :       break;</span>
<span class="lineNum">    1488 </span>            : 
<span class="lineNum">    1489 </span><span class="lineCov">       3086 :     case MEM_REF:</span>
<span class="lineNum">    1490 </span>            :       /* For MEM_REF, make sure not to sanitize the second operand even
<span class="lineNum">    1491 </span>            :          if it has reference type.  It is just an offset with a type
<span class="lineNum">    1492 </span>            :          holding other information.  There is no other processing we
<span class="lineNum">    1493 </span>            :          need to do for INTEGER_CSTs, so just ignore the second argument
<span class="lineNum">    1494 </span>            :          unconditionally.  */
<span class="lineNum">    1495 </span><span class="lineCov">       3086 :       cp_walk_tree (&amp;TREE_OPERAND (stmt, 0), cp_genericize_r, data, NULL);</span>
<span class="lineNum">    1496 </span><span class="lineCov">       3086 :       *walk_subtrees = 0;</span>
<span class="lineNum">    1497 </span><span class="lineCov">       3086 :       break;</span>
<span class="lineNum">    1498 </span>            : 
<span class="lineNum">    1499 </span><span class="lineCov">   17552847 :     case NOP_EXPR:</span>
<span class="lineNum">    1500 </span><span class="lineCov">   17552847 :       if (!wtd-&gt;no_sanitize_p</span>
<span class="lineNum">    1501 </span><span class="lineCov">   17552812 :           &amp;&amp; sanitize_flags_p (SANITIZE_NULL | SANITIZE_ALIGNMENT)</span>
<span class="lineNum">    1502 </span><span class="lineCov">   17559176 :           &amp;&amp; TYPE_REF_P (TREE_TYPE (stmt)))</span>
<span class="lineNum">    1503 </span><span class="lineCov">        846 :         ubsan_maybe_instrument_reference (stmt_p);</span>
<span class="lineNum">    1504 </span>            :       break;
<span class="lineNum">    1505 </span>            : 
<span class="lineNum">    1506 </span><span class="lineCov">   13278623 :     case CALL_EXPR:</span>
<span class="lineNum">    1507 </span><span class="lineCov">   13278623 :       if (!wtd-&gt;no_sanitize_p</span>
<span class="lineNum">    1508 </span><span class="lineCov">   13278623 :           &amp;&amp; sanitize_flags_p ((SANITIZE_NULL</span>
<span class="lineNum">    1509 </span>            :                                 | SANITIZE_ALIGNMENT | SANITIZE_VPTR)))
<span class="lineNum">    1510 </span>            :         {
<span class="lineNum">    1511 </span><span class="lineCov">       9080 :           tree fn = CALL_EXPR_FN (stmt);</span>
<span class="lineNum">    1512 </span><span class="lineCov">       9080 :           if (fn != NULL_TREE</span>
<span class="lineNum">    1513 </span><span class="lineCov">       5882 :               &amp;&amp; !error_operand_p (fn)</span>
<span class="lineNum">    1514 </span><span class="lineCov">       5882 :               &amp;&amp; INDIRECT_TYPE_P (TREE_TYPE (fn))</span>
<span class="lineNum">    1515 </span><span class="lineCov">      20844 :               &amp;&amp; TREE_CODE (TREE_TYPE (TREE_TYPE (fn))) == METHOD_TYPE)</span>
<span class="lineNum">    1516 </span>            :             {
<span class="lineNum">    1517 </span><span class="lineCov">       3187 :               bool is_ctor</span>
<span class="lineNum">    1518 </span>            :                 = TREE_CODE (fn) == ADDR_EXPR
<span class="lineNum">    1519 </span><span class="lineCov">       3083 :                   &amp;&amp; TREE_CODE (TREE_OPERAND (fn, 0)) == FUNCTION_DECL</span>
<span class="lineNum">    1520 </span><span class="lineCov">       6270 :                   &amp;&amp; DECL_CONSTRUCTOR_P (TREE_OPERAND (fn, 0));</span>
<span class="lineNum">    1521 </span><span class="lineCov">       3187 :               if (sanitize_flags_p (SANITIZE_NULL | SANITIZE_ALIGNMENT))</span>
<span class="lineNum">    1522 </span><span class="lineCov">       1761 :                 ubsan_maybe_instrument_member_call (stmt, is_ctor);</span>
<span class="lineNum">    1523 </span><span class="lineCov">       3187 :               if (sanitize_flags_p (SANITIZE_VPTR) &amp;&amp; !is_ctor)</span>
<span class="lineNum">    1524 </span><span class="lineCov">       1713 :                 cp_ubsan_maybe_instrument_member_call (stmt);</span>
<span class="lineNum">    1525 </span>            :             }
<span class="lineNum">    1526 </span><span class="lineCov">       5893 :           else if (fn == NULL_TREE</span>
<span class="lineNum">    1527 </span><span class="lineCov">       6396 :                    &amp;&amp; CALL_EXPR_IFN (stmt) == IFN_UBSAN_NULL</span>
<span class="lineNum">    1528 </span><span class="lineCov">       4082 :                    &amp;&amp; TREE_CODE (CALL_EXPR_ARG (stmt, 0)) == INTEGER_CST</span>
<span class="lineNum">    1529 </span><span class="lineCov">       5921 :                    &amp;&amp; TYPE_REF_P (TREE_TYPE (CALL_EXPR_ARG (stmt, 0))))</span>
<span class="lineNum">    1530 </span><span class="lineCov">         14 :             *walk_subtrees = 0;</span>
<span class="lineNum">    1531 </span>            :         }
<span class="lineNum">    1532 </span>            :       /* Fall through.  */
<span class="lineNum">    1533 </span><span class="lineCov">   13861833 :     case AGGR_INIT_EXPR:</span>
<span class="lineNum">    1534 </span>            :       /* For calls to a multi-versioned function, overload resolution
<span class="lineNum">    1535 </span>            :          returns the function with the highest target priority, that is,
<span class="lineNum">    1536 </span>            :          the version that will checked for dispatching first.  If this
<span class="lineNum">    1537 </span>            :          version is inlinable, a direct call to this version can be made
<span class="lineNum">    1538 </span>            :          otherwise the call should go through the dispatcher.  */
<span class="lineNum">    1539 </span><span class="lineCov">   13861833 :       {</span>
<span class="lineNum">    1540 </span><span class="lineCov">   13861833 :         tree fn = cp_get_callee_fndecl_nofold (stmt);</span>
<span class="lineNum">    1541 </span><span class="lineCov">   13568603 :         if (fn &amp;&amp; DECL_FUNCTION_VERSIONED (fn)</span>
<span class="lineNum">    1542 </span><span class="lineCov">   13861923 :             &amp;&amp; (current_function_decl == NULL</span>
<span class="lineNum">    1543 </span><span class="lineCov">         90 :                 || !targetm.target_option.can_inline_p (current_function_decl,</span>
<span class="lineNum">    1544 </span>            :                                                         fn)))
<span class="lineNum">    1545 </span><span class="lineCov">         81 :           if (tree dis = get_function_version_dispatcher (fn))</span>
<span class="lineNum">    1546 </span>            :             {
<span class="lineNum">    1547 </span><span class="lineCov">         81 :               mark_versions_used (dis);</span>
<span class="lineNum">    1548 </span><span class="lineCov">         81 :               dis = build_address (dis);</span>
<span class="lineNum">    1549 </span><span class="lineCov">         81 :               if (TREE_CODE (stmt) == CALL_EXPR)</span>
<span class="lineNum">    1550 </span><span class="lineCov">        156 :                 CALL_EXPR_FN (stmt) = dis;</span>
<span class="lineNum">    1551 </span>            :               else
<span class="lineNum">    1552 </span><span class="lineCov">          3 :                 AGGR_INIT_EXPR_FN (stmt) = dis;</span>
<span class="lineNum">    1553 </span>            :             }
<span class="lineNum">    1554 </span>            :       }
<span class="lineNum">    1555 </span>            :       break;
<span class="lineNum">    1556 </span>            : 
<span class="lineNum">    1557 </span><span class="lineCov">    1761671 :     case TARGET_EXPR:</span>
<span class="lineNum">    1558 </span><span class="lineCov">    1761671 :       if (TARGET_EXPR_INITIAL (stmt)</span>
<span class="lineNum">    1559 </span><span class="lineCov">    1761671 :           &amp;&amp; TREE_CODE (TARGET_EXPR_INITIAL (stmt)) == CONSTRUCTOR</span>
<span class="lineNum">    1560 </span><span class="lineCov">    2218515 :           &amp;&amp; CONSTRUCTOR_PLACEHOLDER_BOUNDARY (TARGET_EXPR_INITIAL (stmt)))</span>
<span class="lineNum">    1561 </span><span class="lineCov">         10 :         TARGET_EXPR_NO_ELIDE (stmt) = 1;</span>
<span class="lineNum">    1562 </span>            :       break;
<span class="lineNum">    1563 </span>            : 
<span class="lineNum">    1564 </span><span class="lineCov">  129706200 :     default:</span>
<span class="lineNum">    1565 </span><span class="lineCov">  129706200 :       if (IS_TYPE_OR_DECL_P (stmt))</span>
<span class="lineNum">    1566 </span><span class="lineCov">   39462857 :         *walk_subtrees = 0;</span>
<span class="lineNum">    1567 </span>            :       break;
<span class="lineNum">    1568 </span>            :     }
<span class="lineNum">    1569 </span>            : 
<span class="lineNum">    1570 </span><span class="lineCov">  205915294 :   p_set-&gt;add (*stmt_p);</span>
<span class="lineNum">    1571 </span>            : 
<span class="lineNum">    1572 </span><span class="lineCov">  205915294 :   return NULL;</span>
<span class="lineNum">    1573 </span>            : }
<span class="lineNum">    1574 </span>            : 
<span class="lineNum">    1575 </span>            : /* Lower C++ front end trees to GENERIC in T_P.  */
<a name="1576"><span class="lineNum">    1576 </span>            : </a>
<span class="lineNum">    1577 </span>            : static void
<span class="lineNum">    1578 </span><span class="lineCov">    8270767 : cp_genericize_tree (tree* t_p, bool handle_invisiref_parm_p)</span>
<span class="lineNum">    1579 </span>            : {
<span class="lineNum">    1580 </span><span class="lineCov">    8270767 :   struct cp_genericize_data wtd;</span>
<span class="lineNum">    1581 </span>            : 
<span class="lineNum">    1582 </span><span class="lineCov">    8270767 :   wtd.p_set = new hash_set&lt;tree&gt;;</span>
<span class="lineNum">    1583 </span><span class="lineCov">    8270767 :   wtd.bind_expr_stack.create (0);</span>
<span class="lineNum">    1584 </span><span class="lineCov">    8270767 :   wtd.omp_ctx = NULL;</span>
<span class="lineNum">    1585 </span><span class="lineCov">    8270767 :   wtd.try_block = NULL_TREE;</span>
<span class="lineNum">    1586 </span><span class="lineCov">    8270767 :   wtd.no_sanitize_p = false;</span>
<span class="lineNum">    1587 </span><span class="lineCov">    8270767 :   wtd.handle_invisiref_parm_p = handle_invisiref_parm_p;</span>
<span class="lineNum">    1588 </span><span class="lineCov">    8270767 :   cp_walk_tree (t_p, cp_genericize_r, &amp;wtd, NULL);</span>
<span class="lineNum">    1589 </span><span class="lineCov">    8270767 :   delete wtd.p_set;</span>
<span class="lineNum">    1590 </span><span class="lineCov">    8270767 :   wtd.bind_expr_stack.release ();</span>
<span class="lineNum">    1591 </span><span class="lineCov">    8270767 :   if (sanitize_flags_p (SANITIZE_VPTR))</span>
<span class="lineNum">    1592 </span><span class="lineCov">       2828 :     cp_ubsan_instrument_member_accesses (t_p);</span>
<span class="lineNum">    1593 </span><span class="lineCov">    8270767 : }</span>
<span class="lineNum">    1594 </span>            : 
<span class="lineNum">    1595 </span>            : /* If a function that should end with a return in non-void
<span class="lineNum">    1596 </span>            :    function doesn't obviously end with return, add ubsan
<span class="lineNum">    1597 </span>            :    instrumentation code to verify it at runtime.  If -fsanitize=return
<span class="lineNum">    1598 </span>            :    is not enabled, instrument __builtin_unreachable.  */
<span class="lineNum">    1599 </span>            : 
<span class="lineNum">    1600 </span>            : static void
<span class="lineNum">    1601 </span><span class="lineCov">    8270356 : cp_maybe_instrument_return (tree fndecl)</span>
<span class="lineNum">    1602 </span>            : {
<span class="lineNum">    1603 </span><span class="lineCov">    8270356 :   if (VOID_TYPE_P (TREE_TYPE (TREE_TYPE (fndecl)))</span>
<span class="lineNum">    1604 </span><span class="lineCov">    4865248 :       || DECL_CONSTRUCTOR_P (fndecl)</span>
<span class="lineNum">    1605 </span><span class="lineCov">    9730496 :       || DECL_DESTRUCTOR_P (fndecl)</span>
<span class="lineNum">    1606 </span><span class="lineCov">   13135604 :       || !targetm.warn_func_return (fndecl))</span>
<span class="lineNum">    1607 </span><span class="lineCov">    3405114 :     return;</span>
<span class="lineNum">    1608 </span>            : 
<span class="lineNum">    1609 </span><span class="lineCov">    4865242 :   if (!sanitize_flags_p (SANITIZE_RETURN, fndecl)</span>
<span class="lineNum">    1610 </span>            :       /* Don't add __builtin_unreachable () if not optimizing, it will not
<span class="lineNum">    1611 </span>            :          improve any optimizations in that case, just break UB code.
<span class="lineNum">    1612 </span>            :          Don't add it if -fsanitize=unreachable -fno-sanitize=return either,
<span class="lineNum">    1613 </span>            :          UBSan covers this with ubsan_instrument_return above where sufficient
<span class="lineNum">    1614 </span>            :          information is provided, while the __builtin_unreachable () below
<span class="lineNum">    1615 </span>            :          if return sanitization is disabled will just result in hard to
<span class="lineNum">    1616 </span>            :          understand runtime error without location.  */
<span class="lineNum">    1617 </span><span class="lineCov">    4865242 :       &amp;&amp; (!optimize</span>
<span class="lineNum">    1618 </span><span class="lineCov">    4569879 :           || sanitize_flags_p (SANITIZE_UNREACHABLE, fndecl)))</span>
<span class="lineNum">    1619 </span><span class="lineCov">     294218 :     return;</span>
<span class="lineNum">    1620 </span>            : 
<span class="lineNum">    1621 </span><span class="lineCov">    4571024 :   tree t = DECL_SAVED_TREE (fndecl);</span>
<span class="lineNum">    1622 </span><span class="lineCov">    7810421 :   while (t)</span>
<span class="lineNum">    1623 </span>            :     {
<span class="lineNum">    1624 </span><span class="lineCov">    7810421 :       switch (TREE_CODE (t))</span>
<span class="lineNum">    1625 </span>            :         {
<span class="lineNum">    1626 </span><span class="lineCov">     470817 :         case BIND_EXPR:</span>
<span class="lineNum">    1627 </span><span class="lineCov">     470817 :           t = BIND_EXPR_BODY (t);</span>
<span class="lineNum">    1628 </span><span class="lineCov">     470817 :           continue;</span>
<span class="lineNum">    1629 </span><span class="lineCov">    1308049 :         case TRY_FINALLY_EXPR:</span>
<span class="lineNum">    1630 </span><span class="lineCov">    1308049 :         case CLEANUP_POINT_EXPR:</span>
<span class="lineNum">    1631 </span><span class="lineCov">    1308049 :           t = TREE_OPERAND (t, 0);</span>
<span class="lineNum">    1632 </span><span class="lineCov">    1308049 :           continue;</span>
<span class="lineNum">    1633 </span><span class="lineCov">    1461638 :         case STATEMENT_LIST:</span>
<span class="lineNum">    1634 </span><span class="lineCov">    1461638 :           {</span>
<span class="lineNum">    1635 </span><span class="lineCov">    1461638 :             tree_stmt_iterator i = tsi_last (t);</span>
<span class="lineNum">    1636 </span><span class="lineCov">    2923466 :             while (!tsi_end_p (i))</span>
<span class="lineNum">    1637 </span>            :               {
<span class="lineNum">    1638 </span><span class="lineCov">    1460721 :                 tree p = tsi_stmt (i);</span>
<span class="lineNum">    1639 </span><span class="lineCov">    1460721 :                 if (TREE_CODE (p) != DEBUG_BEGIN_STMT)</span>
<span class="lineNum">    1640 </span>            :                   break;
<span class="lineNum">    1641 </span><span class="lineCov">        190 :                 tsi_prev (&amp;i);</span>
<span class="lineNum">    1642 </span>            :               }
<span class="lineNum">    1643 </span><span class="lineCov">    2923276 :             if (!tsi_end_p (i))</span>
<span class="lineNum">    1644 </span>            :               {
<span class="lineNum">    1645 </span><span class="lineCov">    1460531 :                 t = tsi_stmt (i);</span>
<span class="lineNum">    1646 </span><span class="lineCov">    1460531 :                 continue;</span>
<span class="lineNum">    1647 </span><span class="lineCov">    1460531 :               }</span>
<span class="lineNum">    1648 </span>            :           }
<span class="lineNum">    1649 </span><span class="lineCov">       1107 :           break;</span>
<span class="lineNum">    1650 </span>            :         case RETURN_EXPR:
<span class="lineNum">    1651 </span>            :           return;
<span class="lineNum">    1652 </span>            :         default:
<span class="lineNum">    1653 </span>            :           break;
<span class="lineNum">    1654 </span>            :         }
<span class="lineNum">    1655 </span>            :       break;
<span class="lineNum">    1656 </span>            :     }
<span class="lineNum">    1657 </span><span class="lineCov">    1824134 :   if (t == NULL_TREE)</span>
<span class="lineNum">    1658 </span>            :     return;
<span class="lineNum">    1659 </span><span class="lineCov">    1824134 :   tree *p = &amp;DECL_SAVED_TREE (fndecl);</span>
<span class="lineNum">    1660 </span><span class="lineCov">    1824134 :   if (TREE_CODE (*p) == BIND_EXPR)</span>
<span class="lineNum">    1661 </span><span class="lineCov">     111522 :     p = &amp;BIND_EXPR_BODY (*p);</span>
<span class="lineNum">    1662 </span>            : 
<span class="lineNum">    1663 </span><span class="lineCov">    1824134 :   location_t loc = DECL_SOURCE_LOCATION (fndecl);</span>
<span class="lineNum">    1664 </span><span class="lineCov">    1824134 :   if (sanitize_flags_p (SANITIZE_RETURN, fndecl))</span>
<span class="lineNum">    1665 </span><span class="lineCov">        100 :     t = ubsan_instrument_return (loc);</span>
<span class="lineNum">    1666 </span>            :   else
<span class="lineNum">    1667 </span>            :     {
<span class="lineNum">    1668 </span><span class="lineCov">    1824034 :       tree fndecl = builtin_decl_explicit (BUILT_IN_UNREACHABLE);</span>
<span class="lineNum">    1669 </span><span class="lineCov">    1824034 :       t = build_call_expr_loc (BUILTINS_LOCATION, fndecl, 0);</span>
<span class="lineNum">    1670 </span>            :     }
<span class="lineNum">    1671 </span>            : 
<span class="lineNum">    1672 </span><span class="lineCov">    1824134 :   append_to_statement_list (t, p);</span>
<span class="lineNum">    1673 </span>            : }
<span class="lineNum">    1674 </span>            : 
<span class="lineNum">    1675 </span>            : void
<span class="lineNum">    1676 </span><span class="lineCov">   12361187 : cp_genericize (tree fndecl)</span>
<span class="lineNum">    1677 </span>            : {
<span class="lineNum">    1678 </span><span class="lineCov">   12361187 :   tree t;</span>
<span class="lineNum">    1679 </span>            : 
<span class="lineNum">    1680 </span>            :   /* Fix up the types of parms passed by invisible reference.  */
<span class="lineNum">    1681 </span><span class="lineCov">   33697058 :   for (t = DECL_ARGUMENTS (fndecl); t; t = DECL_CHAIN (t))</span>
<span class="lineNum">    1682 </span><span class="lineCov">   21335871 :     if (TREE_ADDRESSABLE (TREE_TYPE (t)))</span>
<span class="lineNum">    1683 </span>            :       {
<span class="lineNum">    1684 </span>            :         /* If a function's arguments are copied to create a thunk,
<span class="lineNum">    1685 </span>            :            then DECL_BY_REFERENCE will be set -- but the type of the
<span class="lineNum">    1686 </span>            :            argument will be a pointer type, so we will never get
<span class="lineNum">    1687 </span>            :            here.  */
<span class="lineNum">    1688 </span><span class="lineCov">      91938 :         gcc_assert (!DECL_BY_REFERENCE (t));</span>
<span class="lineNum">    1689 </span><span class="lineCov">      45969 :         gcc_assert (DECL_ARG_TYPE (t) != TREE_TYPE (t));</span>
<span class="lineNum">    1690 </span><span class="lineCov">      91938 :         TREE_TYPE (t) = DECL_ARG_TYPE (t);</span>
<span class="lineNum">    1691 </span><span class="lineCov">      45969 :         DECL_BY_REFERENCE (t) = 1;</span>
<span class="lineNum">    1692 </span><span class="lineCov">      45969 :         TREE_ADDRESSABLE (t) = 0;</span>
<span class="lineNum">    1693 </span><span class="lineCov">      45969 :         relayout_decl (t);</span>
<span class="lineNum">    1694 </span>            :       }
<span class="lineNum">    1695 </span>            : 
<span class="lineNum">    1696 </span>            :   /* Do the same for the return value.  */
<span class="lineNum">    1697 </span><span class="lineCov">   12361187 :   if (TREE_ADDRESSABLE (TREE_TYPE (DECL_RESULT (fndecl))))</span>
<span class="lineNum">    1698 </span>            :     {
<span class="lineNum">    1699 </span><span class="lineCov">     191937 :       t = DECL_RESULT (fndecl);</span>
<span class="lineNum">    1700 </span><span class="lineCov">     575811 :       TREE_TYPE (t) = build_reference_type (TREE_TYPE (t));</span>
<span class="lineNum">    1701 </span><span class="lineCov">     191937 :       DECL_BY_REFERENCE (t) = 1;</span>
<span class="lineNum">    1702 </span><span class="lineCov">     191937 :       TREE_ADDRESSABLE (t) = 0;</span>
<span class="lineNum">    1703 </span><span class="lineCov">     191937 :       relayout_decl (t);</span>
<span class="lineNum">    1704 </span><span class="lineCov">     191937 :       if (DECL_NAME (t))</span>
<span class="lineNum">    1705 </span>            :         {
<span class="lineNum">    1706 </span>            :           /* Adjust DECL_VALUE_EXPR of the original var.  */
<span class="lineNum">    1707 </span><span class="lineCov">       9477 :           tree outer = outer_curly_brace_block (current_function_decl);</span>
<span class="lineNum">    1708 </span><span class="lineCov">       9477 :           tree var;</span>
<span class="lineNum">    1709 </span>            : 
<span class="lineNum">    1710 </span><span class="lineCov">       9477 :           if (outer)</span>
<span class="lineNum">    1711 </span><span class="lineCov">       9813 :             for (var = BLOCK_VARS (outer); var; var = DECL_CHAIN (var))</span>
<span class="lineNum">    1712 </span><span class="lineCov">       9813 :               if (VAR_P (var)</span>
<span class="lineNum">    1713 </span><span class="lineCov">       9727 :                   &amp;&amp; DECL_NAME (t) == DECL_NAME (var)</span>
<span class="lineNum">    1714 </span><span class="lineCov">      18954 :                   &amp;&amp; DECL_HAS_VALUE_EXPR_P (var)</span>
<span class="lineNum">    1715 </span><span class="lineCov">      19290 :                   &amp;&amp; DECL_VALUE_EXPR (var) == t)</span>
<span class="lineNum">    1716 </span>            :                 {
<span class="lineNum">    1717 </span><span class="lineCov">       9477 :                   tree val = convert_from_reference (t);</span>
<span class="lineNum">    1718 </span><span class="lineCov">       9477 :                   SET_DECL_VALUE_EXPR (var, val);</span>
<span class="lineNum">    1719 </span><span class="lineCov">       9477 :                   break;</span>
<span class="lineNum">    1720 </span>            :                 }
<span class="lineNum">    1721 </span>            :         }
<span class="lineNum">    1722 </span>            :     }
<span class="lineNum">    1723 </span>            : 
<span class="lineNum">    1724 </span>            :   /* If we're a clone, the body is already GIMPLE.  */
<span class="lineNum">    1725 </span><span class="lineCov">   12361187 :   if (DECL_CLONED_FUNCTION_P (fndecl))</span>
<span class="lineNum">    1726 </span><span class="lineCov">    4090831 :     return;</span>
<span class="lineNum">    1727 </span>            : 
<span class="lineNum">    1728 </span>            :   /* Allow cp_genericize calls to be nested.  */
<span class="lineNum">    1729 </span><span class="lineCov">    8270356 :   tree save_bc_label[2];</span>
<span class="lineNum">    1730 </span><span class="lineCov">    8270356 :   save_bc_label[bc_break] = bc_label[bc_break];</span>
<span class="lineNum">    1731 </span><span class="lineCov">    8270356 :   save_bc_label[bc_continue] = bc_label[bc_continue];</span>
<span class="lineNum">    1732 </span><span class="lineCov">    8270356 :   bc_label[bc_break] = NULL_TREE;</span>
<span class="lineNum">    1733 </span><span class="lineCov">    8270356 :   bc_label[bc_continue] = NULL_TREE;</span>
<span class="lineNum">    1734 </span>            : 
<span class="lineNum">    1735 </span>            :   /* We do want to see every occurrence of the parms, so we can't just use
<span class="lineNum">    1736 </span>            :      walk_tree's hash functionality.  */
<span class="lineNum">    1737 </span><span class="lineCov">    8270356 :   cp_genericize_tree (&amp;DECL_SAVED_TREE (fndecl), true);</span>
<span class="lineNum">    1738 </span>            : 
<span class="lineNum">    1739 </span><span class="lineCov">    8270356 :   cp_maybe_instrument_return (fndecl);</span>
<span class="lineNum">    1740 </span>            : 
<span class="lineNum">    1741 </span>            :   /* Do everything else.  */
<span class="lineNum">    1742 </span><span class="lineCov">    8270356 :   c_genericize (fndecl);</span>
<span class="lineNum">    1743 </span>            : 
<span class="lineNum">    1744 </span><span class="lineCov">    8270356 :   gcc_assert (bc_label[bc_break] == NULL);</span>
<span class="lineNum">    1745 </span><span class="lineCov">    8270356 :   gcc_assert (bc_label[bc_continue] == NULL);</span>
<span class="lineNum">    1746 </span><span class="lineCov">    8270356 :   bc_label[bc_break] = save_bc_label[bc_break];</span>
<span class="lineNum">    1747 </span><span class="lineCov">    8270356 :   bc_label[bc_continue] = save_bc_label[bc_continue];</span>
<span class="lineNum">    1748 </span>            : }
<span class="lineNum">    1749 </span>            : 
<span class="lineNum">    1750 </span>            : /* Build code to apply FN to each member of ARG1 and ARG2.  FN may be
<span class="lineNum">    1751 </span>            :    NULL if there is in fact nothing to do.  ARG2 may be null if FN
<span class="lineNum">    1752 </span>            :    actually only takes one argument.  */
<span class="lineNum">    1753 </span>            : 
<span class="lineNum">    1754 </span>            : static tree
<span class="lineNum">    1755 </span><span class="lineCov">       1156 : cxx_omp_clause_apply_fn (tree fn, tree arg1, tree arg2)</span>
<span class="lineNum">    1756 </span>            : {
<span class="lineNum">    1757 </span><span class="lineCov">       1156 :   tree defparm, parm, t;</span>
<span class="lineNum">    1758 </span><span class="lineCov">       1156 :   int i = 0;</span>
<span class="lineNum">    1759 </span><span class="lineCov">       1156 :   int nargs;</span>
<span class="lineNum">    1760 </span><span class="lineCov">       1156 :   tree *argarray;</span>
<span class="lineNum">    1761 </span>            : 
<span class="lineNum">    1762 </span><span class="lineCov">       1156 :   if (fn == NULL)</span>
<span class="lineNum">    1763 </span>            :     return NULL;
<span class="lineNum">    1764 </span>            : 
<span class="lineNum">    1765 </span><span class="lineCov">        871 :   nargs = list_length (DECL_ARGUMENTS (fn));</span>
<span class="lineNum">    1766 </span><span class="lineCov">        871 :   argarray = XALLOCAVEC (tree, nargs);</span>
<span class="lineNum">    1767 </span>            : 
<span class="lineNum">    1768 </span><span class="lineCov">       1742 :   defparm = TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (fn)));</span>
<span class="lineNum">    1769 </span><span class="lineCov">        871 :   if (arg2)</span>
<span class="lineNum">    1770 </span><span class="lineCov">        205 :     defparm = TREE_CHAIN (defparm);</span>
<span class="lineNum">    1771 </span>            : 
<span class="lineNum">    1772 </span><span class="lineCov">        871 :   bool is_method = TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE;</span>
<span class="lineNum">    1773 </span><span class="lineCov">        871 :   if (TREE_CODE (TREE_TYPE (arg1)) == ARRAY_TYPE)</span>
<span class="lineNum">    1774 </span>            :     {
<span class="lineNum">    1775 </span><span class="lineCov">         27 :       tree inner_type = TREE_TYPE (arg1);</span>
<span class="lineNum">    1776 </span><span class="lineCov">         27 :       tree start1, end1, p1;</span>
<span class="lineNum">    1777 </span><span class="lineCov">         27 :       tree start2 = NULL, p2 = NULL;</span>
<span class="lineNum">    1778 </span><span class="lineCov">         27 :       tree ret = NULL, lab;</span>
<span class="lineNum">    1779 </span>            : 
<span class="lineNum">    1780 </span><span class="lineCov">         27 :       start1 = arg1;</span>
<span class="lineNum">    1781 </span><span class="lineCov">         27 :       start2 = arg2;</span>
<span class="lineNum">    1782 </span><span class="lineCov">         27 :       do</span>
<span class="lineNum">    1783 </span>            :         {
<span class="lineNum">    1784 </span><span class="lineCov">         27 :           inner_type = TREE_TYPE (inner_type);</span>
<span class="lineNum">    1785 </span><span class="lineCov">         27 :           start1 = build4 (ARRAY_REF, inner_type, start1,</span>
<span class="lineNum">    1786 </span>            :                            size_zero_node, NULL, NULL);
<span class="lineNum">    1787 </span><span class="lineCov">         27 :           if (arg2)</span>
<span class="lineNum">    1788 </span><span class="lineCov">          9 :             start2 = build4 (ARRAY_REF, inner_type, start2,</span>
<span class="lineNum">    1789 </span>            :                              size_zero_node, NULL, NULL);
<span class="lineNum">    1790 </span>            :         }
<span class="lineNum">    1791 </span><span class="lineCov">         27 :       while (TREE_CODE (inner_type) == ARRAY_TYPE);</span>
<span class="lineNum">    1792 </span><span class="lineCov">         27 :       start1 = build_fold_addr_expr_loc (input_location, start1);</span>
<span class="lineNum">    1793 </span><span class="lineCov">         27 :       if (arg2)</span>
<span class="lineNum">    1794 </span><span class="lineCov">          9 :         start2 = build_fold_addr_expr_loc (input_location, start2);</span>
<span class="lineNum">    1795 </span>            : 
<span class="lineNum">    1796 </span><span class="lineCov">         27 :       end1 = TYPE_SIZE_UNIT (TREE_TYPE (arg1));</span>
<span class="lineNum">    1797 </span><span class="lineCov">         27 :       end1 = fold_build_pointer_plus (start1, end1);</span>
<span class="lineNum">    1798 </span>            : 
<span class="lineNum">    1799 </span><span class="lineCov">         27 :       p1 = create_tmp_var (TREE_TYPE (start1));</span>
<span class="lineNum">    1800 </span><span class="lineCov">         27 :       t = build2 (MODIFY_EXPR, TREE_TYPE (p1), p1, start1);</span>
<span class="lineNum">    1801 </span><span class="lineCov">         27 :       append_to_statement_list (t, &amp;ret);</span>
<span class="lineNum">    1802 </span>            : 
<span class="lineNum">    1803 </span><span class="lineCov">         27 :       if (arg2)</span>
<span class="lineNum">    1804 </span>            :         {
<span class="lineNum">    1805 </span><span class="lineCov">          9 :           p2 = create_tmp_var (TREE_TYPE (start2));</span>
<span class="lineNum">    1806 </span><span class="lineCov">          9 :           t = build2 (MODIFY_EXPR, TREE_TYPE (p2), p2, start2);</span>
<span class="lineNum">    1807 </span><span class="lineCov">          9 :           append_to_statement_list (t, &amp;ret);</span>
<span class="lineNum">    1808 </span>            :         }
<span class="lineNum">    1809 </span>            : 
<span class="lineNum">    1810 </span><span class="lineCov">         27 :       lab = create_artificial_label (input_location);</span>
<span class="lineNum">    1811 </span><span class="lineCov">         27 :       t = build1 (LABEL_EXPR, void_type_node, lab);</span>
<span class="lineNum">    1812 </span><span class="lineCov">         27 :       append_to_statement_list (t, &amp;ret);</span>
<span class="lineNum">    1813 </span>            : 
<span class="lineNum">    1814 </span><span class="lineCov">         27 :       argarray[i++] = p1;</span>
<span class="lineNum">    1815 </span><span class="lineCov">         27 :       if (arg2)</span>
<span class="lineNum">    1816 </span><span class="lineCov">          9 :         argarray[i++] = p2;</span>
<span class="lineNum">    1817 </span>            :       /* Handle default arguments.  */
<span class="lineNum">    1818 </span><span class="lineCov">         27 :       for (parm = defparm; parm &amp;&amp; parm != void_list_node;</span>
<span class="lineNum">    1819 </span><span class="lineNoCov">          0 :            parm = TREE_CHAIN (parm), i++)</span>
<span class="lineNum">    1820 </span><span class="lineNoCov">          0 :         argarray[i] = convert_default_arg (TREE_VALUE (parm),</span>
<span class="lineNum">    1821 </span><span class="lineNoCov">          0 :                                            TREE_PURPOSE (parm), fn,</span>
<span class="lineNum">    1822 </span>            :                                            i - is_method, tf_warning_or_error);
<span class="lineNum">    1823 </span><span class="lineCov">         27 :       t = build_call_a (fn, i, argarray);</span>
<span class="lineNum">    1824 </span><span class="lineCov">         27 :       t = fold_convert (void_type_node, t);</span>
<span class="lineNum">    1825 </span><span class="lineCov">         27 :       t = fold_build_cleanup_point_expr (TREE_TYPE (t), t);</span>
<span class="lineNum">    1826 </span><span class="lineCov">         27 :       append_to_statement_list (t, &amp;ret);</span>
<span class="lineNum">    1827 </span>            : 
<span class="lineNum">    1828 </span><span class="lineCov">         27 :       t = fold_build_pointer_plus (p1, TYPE_SIZE_UNIT (inner_type));</span>
<span class="lineNum">    1829 </span><span class="lineCov">         27 :       t = build2 (MODIFY_EXPR, TREE_TYPE (p1), p1, t);</span>
<span class="lineNum">    1830 </span><span class="lineCov">         27 :       append_to_statement_list (t, &amp;ret);</span>
<span class="lineNum">    1831 </span>            : 
<span class="lineNum">    1832 </span><span class="lineCov">         27 :       if (arg2)</span>
<span class="lineNum">    1833 </span>            :         {
<span class="lineNum">    1834 </span><span class="lineCov">          9 :           t = fold_build_pointer_plus (p2, TYPE_SIZE_UNIT (inner_type));</span>
<span class="lineNum">    1835 </span><span class="lineCov">          9 :           t = build2 (MODIFY_EXPR, TREE_TYPE (p2), p2, t);</span>
<span class="lineNum">    1836 </span><span class="lineCov">          9 :           append_to_statement_list (t, &amp;ret);</span>
<span class="lineNum">    1837 </span>            :         }
<span class="lineNum">    1838 </span>            : 
<span class="lineNum">    1839 </span><span class="lineCov">         27 :       t = build2 (NE_EXPR, boolean_type_node, p1, end1);</span>
<span class="lineNum">    1840 </span><span class="lineCov">         27 :       t = build3 (COND_EXPR, void_type_node, t, build_and_jump (&amp;lab), NULL);</span>
<span class="lineNum">    1841 </span><span class="lineCov">         27 :       append_to_statement_list (t, &amp;ret);</span>
<span class="lineNum">    1842 </span>            : 
<span class="lineNum">    1843 </span><span class="lineCov">         27 :       return ret;</span>
<span class="lineNum">    1844 </span>            :     }
<span class="lineNum">    1845 </span>            :   else
<span class="lineNum">    1846 </span>            :     {
<span class="lineNum">    1847 </span><span class="lineCov">        844 :       argarray[i++] = build_fold_addr_expr_loc (input_location, arg1);</span>
<span class="lineNum">    1848 </span><span class="lineCov">        844 :       if (arg2)</span>
<span class="lineNum">    1849 </span><span class="lineCov">        196 :         argarray[i++] = build_fold_addr_expr_loc (input_location, arg2);</span>
<span class="lineNum">    1850 </span>            :       /* Handle default arguments.  */
<span class="lineNum">    1851 </span><span class="lineCov">        849 :       for (parm = defparm; parm &amp;&amp; parm != void_list_node;</span>
<span class="lineNum">    1852 </span><span class="lineCov">          5 :            parm = TREE_CHAIN (parm), i++)</span>
<span class="lineNum">    1853 </span><span class="lineCov">          5 :         argarray[i] = convert_default_arg (TREE_VALUE (parm),</span>
<span class="lineNum">    1854 </span><span class="lineCov">          5 :                                            TREE_PURPOSE (parm), fn,</span>
<span class="lineNum">    1855 </span>            :                                            i - is_method, tf_warning_or_error);
<span class="lineNum">    1856 </span><span class="lineCov">        844 :       t = build_call_a (fn, i, argarray);</span>
<span class="lineNum">    1857 </span><span class="lineCov">        844 :       t = fold_convert (void_type_node, t);</span>
<span class="lineNum">    1858 </span><span class="lineCov">        844 :       return fold_build_cleanup_point_expr (TREE_TYPE (t), t);</span>
<span class="lineNum">    1859 </span>            :     }
<span class="lineNum">    1860 </span>            : }
<span class="lineNum">    1861 </span>            : 
<span class="lineNum">    1862 </span>            : /* Return code to initialize DECL with its default constructor, or
<span class="lineNum">    1863 </span>            :    NULL if there's nothing to do.  */
<span class="lineNum">    1864 </span>            : 
<span class="lineNum">    1865 </span>            : tree
<span class="lineNum">    1866 </span><span class="lineCov">      15209 : cxx_omp_clause_default_ctor (tree clause, tree decl, tree /*outer*/)</span>
<span class="lineNum">    1867 </span>            : {
<span class="lineNum">    1868 </span><span class="lineCov">      15209 :   tree info = CP_OMP_CLAUSE_INFO (clause);</span>
<span class="lineNum">    1869 </span><span class="lineCov">      15209 :   tree ret = NULL;</span>
<span class="lineNum">    1870 </span>            : 
<span class="lineNum">    1871 </span><span class="lineCov">      15209 :   if (info)</span>
<span class="lineNum">    1872 </span><span class="lineCov">        347 :     ret = cxx_omp_clause_apply_fn (TREE_VEC_ELT (info, 0), decl, NULL);</span>
<span class="lineNum">    1873 </span>            : 
<span class="lineNum">    1874 </span><span class="lineCov">      15209 :   return ret;</span>
<span class="lineNum">    1875 </span>            : }
<span class="lineNum">    1876 </span>            : 
<span class="lineNum">    1877 </span>            : /* Return code to initialize DST with a copy constructor from SRC.  */
<span class="lineNum">    1878 </span>            : 
<span class="lineNum">    1879 </span>            : tree
<span class="lineNum">    1880 </span><span class="lineCov">       4121 : cxx_omp_clause_copy_ctor (tree clause, tree dst, tree src)</span>
<span class="lineNum">    1881 </span>            : {
<span class="lineNum">    1882 </span><span class="lineCov">       4121 :   tree info = CP_OMP_CLAUSE_INFO (clause);</span>
<span class="lineNum">    1883 </span><span class="lineCov">       4121 :   tree ret = NULL;</span>
<span class="lineNum">    1884 </span>            : 
<span class="lineNum">    1885 </span><span class="lineCov">       4121 :   if (info)</span>
<span class="lineNum">    1886 </span><span class="lineCov">        179 :     ret = cxx_omp_clause_apply_fn (TREE_VEC_ELT (info, 0), dst, src);</span>
<span class="lineNum">    1887 </span><span class="lineCov">        179 :   if (ret == NULL)</span>
<span class="lineNum">    1888 </span><span class="lineCov">       3998 :     ret = build2 (MODIFY_EXPR, TREE_TYPE (dst), dst, src);</span>
<span class="lineNum">    1889 </span>            : 
<span class="lineNum">    1890 </span><span class="lineCov">       4121 :   return ret;</span>
<span class="lineNum">    1891 </span>            : }
<span class="lineNum">    1892 </span>            : 
<span class="lineNum">    1893 </span>            : /* Similarly, except use an assignment operator instead.  */
<span class="lineNum">    1894 </span>            : 
<span class="lineNum">    1895 </span>            : tree
<span class="lineNum">    1896 </span><span class="lineCov">       4244 : cxx_omp_clause_assign_op (tree clause, tree dst, tree src)</span>
<span class="lineNum">    1897 </span>            : {
<span class="lineNum">    1898 </span><span class="lineCov">       4244 :   tree info = CP_OMP_CLAUSE_INFO (clause);</span>
<span class="lineNum">    1899 </span><span class="lineCov">       4244 :   tree ret = NULL;</span>
<span class="lineNum">    1900 </span>            : 
<span class="lineNum">    1901 </span><span class="lineCov">       4244 :   if (info)</span>
<span class="lineNum">    1902 </span><span class="lineCov">        104 :     ret = cxx_omp_clause_apply_fn (TREE_VEC_ELT (info, 2), dst, src);</span>
<span class="lineNum">    1903 </span><span class="lineCov">        104 :   if (ret == NULL)</span>
<span class="lineNum">    1904 </span><span class="lineCov">       4162 :     ret = build2 (MODIFY_EXPR, TREE_TYPE (dst), dst, src);</span>
<span class="lineNum">    1905 </span>            : 
<span class="lineNum">    1906 </span><span class="lineCov">       4244 :   return ret;</span>
<span class="lineNum">    1907 </span>            : }
<span class="lineNum">    1908 </span>            : 
<span class="lineNum">    1909 </span>            : /* Return code to destroy DECL.  */
<span class="lineNum">    1910 </span>            : 
<span class="lineNum">    1911 </span>            : tree
<span class="lineNum">    1912 </span><span class="lineCov">      21944 : cxx_omp_clause_dtor (tree clause, tree decl)</span>
<span class="lineNum">    1913 </span>            : {
<span class="lineNum">    1914 </span><span class="lineCov">      21944 :   tree info = CP_OMP_CLAUSE_INFO (clause);</span>
<span class="lineNum">    1915 </span><span class="lineCov">      21944 :   tree ret = NULL;</span>
<span class="lineNum">    1916 </span>            : 
<span class="lineNum">    1917 </span><span class="lineCov">      21944 :   if (info)</span>
<span class="lineNum">    1918 </span><span class="lineCov">        526 :     ret = cxx_omp_clause_apply_fn (TREE_VEC_ELT (info, 1), decl, NULL);</span>
<span class="lineNum">    1919 </span>            : 
<span class="lineNum">    1920 </span><span class="lineCov">      21944 :   return ret;</span>
<span class="lineNum">    1921 </span>            : }
<span class="lineNum">    1922 </span>            : 
<span class="lineNum">    1923 </span>            : /* True if OpenMP should privatize what this DECL points to rather
<span class="lineNum">    1924 </span>            :    than the DECL itself.  */
<span class="lineNum">    1925 </span>            : 
<span class="lineNum">    1926 </span>            : bool
<span class="lineNum">    1927 </span><span class="lineCov">     170068 : cxx_omp_privatize_by_reference (const_tree decl)</span>
<span class="lineNum">    1928 </span>            : {
<span class="lineNum">    1929 </span><span class="lineCov">     170068 :   return (TYPE_REF_P (TREE_TYPE (decl))</span>
<span class="lineNum">    1930 </span><span class="lineCov">     170068 :           || is_invisiref_parm (decl));</span>
<span class="lineNum">    1931 </span>            : }
<span class="lineNum">    1932 </span>            : 
<span class="lineNum">    1933 </span>            : /* Return true if DECL is const qualified var having no mutable member.  */
<span class="lineNum">    1934 </span>            : bool
<span class="lineNum">    1935 </span><span class="lineCov">      17334 : cxx_omp_const_qual_no_mutable (tree decl)</span>
<span class="lineNum">    1936 </span>            : {
<span class="lineNum">    1937 </span><span class="lineCov">      17334 :   tree type = TREE_TYPE (decl);</span>
<span class="lineNum">    1938 </span><span class="lineCov">      17334 :   if (TYPE_REF_P (type))</span>
<span class="lineNum">    1939 </span>            :     {
<span class="lineNum">    1940 </span><span class="lineCov">       1607 :       if (!is_invisiref_parm (decl))</span>
<span class="lineNum">    1941 </span>            :         return false;
<span class="lineNum">    1942 </span><span class="lineCov">        404 :       type = TREE_TYPE (type);</span>
<span class="lineNum">    1943 </span>            : 
<span class="lineNum">    1944 </span><span class="lineCov">        404 :       if (TREE_CODE (decl) == RESULT_DECL &amp;&amp; DECL_NAME (decl))</span>
<span class="lineNum">    1945 </span>            :         {
<span class="lineNum">    1946 </span>            :           /* NVR doesn't preserve const qualification of the
<span class="lineNum">    1947 </span>            :              variable's type.  */
<span class="lineNum">    1948 </span><span class="lineCov">        176 :           tree outer = outer_curly_brace_block (current_function_decl);</span>
<span class="lineNum">    1949 </span><span class="lineCov">        176 :           tree var;</span>
<span class="lineNum">    1950 </span>            : 
<span class="lineNum">    1951 </span><span class="lineCov">        176 :           if (outer)</span>
<span class="lineNum">    1952 </span><span class="lineCov">        196 :             for (var = BLOCK_VARS (outer); var; var = DECL_CHAIN (var))</span>
<span class="lineNum">    1953 </span><span class="lineCov">        196 :               if (VAR_P (var)</span>
<span class="lineNum">    1954 </span><span class="lineCov">        196 :                   &amp;&amp; DECL_NAME (decl) == DECL_NAME (var)</span>
<span class="lineNum">    1955 </span><span class="lineCov">        372 :                   &amp;&amp; (TYPE_MAIN_VARIANT (type)</span>
<span class="lineNum">    1956 </span><span class="lineCov">        176 :                       == TYPE_MAIN_VARIANT (TREE_TYPE (var))))</span>
<span class="lineNum">    1957 </span>            :                 {
<span class="lineNum">    1958 </span><span class="lineCov">        528 :                   if (TYPE_READONLY (TREE_TYPE (var)))</span>
<span class="lineNum">    1959 </span><span class="lineCov">         24 :                     type = TREE_TYPE (var);</span>
<span class="lineNum">    1960 </span>            :                   break;
<span class="lineNum">    1961 </span>            :                 }
<span class="lineNum">    1962 </span>            :         }
<span class="lineNum">    1963 </span>            :     }
<span class="lineNum">    1964 </span>            : 
<span class="lineNum">    1965 </span><span class="lineCov">      16131 :   if (type == error_mark_node)</span>
<span class="lineNum">    1966 </span>            :     return false;
<span class="lineNum">    1967 </span>            : 
<span class="lineNum">    1968 </span>            :   /* Variables with const-qualified type having no mutable member
<span class="lineNum">    1969 </span>            :      are predetermined shared.  */
<span class="lineNum">    1970 </span><span class="lineCov">      16101 :   if (TYPE_READONLY (type) &amp;&amp; !cp_has_mutable_p (type))</span>
<span class="lineNum">    1971 </span><span class="lineCov">        325 :     return true;</span>
<span class="lineNum">    1972 </span>            : 
<span class="lineNum">    1973 </span>            :   return false;
<span class="lineNum">    1974 </span>            : }
<span class="lineNum">    1975 </span>            : 
<span class="lineNum">    1976 </span>            : /* True if OpenMP sharing attribute of DECL is predetermined.  */
<span class="lineNum">    1977 </span>            : 
<span class="lineNum">    1978 </span>            : enum omp_clause_default_kind
<span class="lineNum">    1979 </span><span class="lineCov">      17368 : cxx_omp_predetermined_sharing_1 (tree decl)</span>
<span class="lineNum">    1980 </span>            : {
<span class="lineNum">    1981 </span>            :   /* Static data members are predetermined shared.  */
<span class="lineNum">    1982 </span><span class="lineCov">      17368 :   if (TREE_STATIC (decl))</span>
<span class="lineNum">    1983 </span>            :     {
<span class="lineNum">    1984 </span><span class="lineCov">       3748 :       tree ctx = CP_DECL_CONTEXT (decl);</span>
<span class="lineNum">    1985 </span><span class="lineCov">       3748 :       if (TYPE_P (ctx) &amp;&amp; MAYBE_CLASS_TYPE_P (ctx))</span>
<span class="lineNum">    1986 </span>            :         return OMP_CLAUSE_DEFAULT_SHARED;
<span class="lineNum">    1987 </span>            :     }
<span class="lineNum">    1988 </span>            : 
<span class="lineNum">    1989 </span>            :   /* Const qualified vars having no mutable member are predetermined
<span class="lineNum">    1990 </span>            :      shared.  */
<span class="lineNum">    1991 </span><span class="lineCov">      17313 :   if (cxx_omp_const_qual_no_mutable (decl))</span>
<span class="lineNum">    1992 </span><span class="lineCov">        307 :     return OMP_CLAUSE_DEFAULT_SHARED;</span>
<span class="lineNum">    1993 </span>            : 
<span class="lineNum">    1994 </span>            :   return OMP_CLAUSE_DEFAULT_UNSPECIFIED;
<span class="lineNum">    1995 </span>            : }
<span class="lineNum">    1996 </span>            : 
<span class="lineNum">    1997 </span>            : /* Likewise, but also include the artificial vars.  We don't want to
<span class="lineNum">    1998 </span>            :    disallow the artificial vars being mentioned in explicit clauses,
<span class="lineNum">    1999 </span>            :    as we use artificial vars e.g. for loop constructs with random
<span class="lineNum">    2000 </span>            :    access iterators other than pointers, but during gimplification
<span class="lineNum">    2001 </span>            :    we want to treat them as predetermined.  */
<span class="lineNum">    2002 </span>            : 
<span class="lineNum">    2003 </span>            : enum omp_clause_default_kind
<span class="lineNum">    2004 </span><span class="lineCov">      11686 : cxx_omp_predetermined_sharing (tree decl)</span>
<span class="lineNum">    2005 </span>            : {
<span class="lineNum">    2006 </span><span class="lineCov">      11686 :   enum omp_clause_default_kind ret = cxx_omp_predetermined_sharing_1 (decl);</span>
<span class="lineNum">    2007 </span><span class="lineCov">      11686 :   if (ret != OMP_CLAUSE_DEFAULT_UNSPECIFIED)</span>
<span class="lineNum">    2008 </span>            :     return ret;
<span class="lineNum">    2009 </span>            : 
<span class="lineNum">    2010 </span>            :   /* Predetermine artificial variables holding integral values, those
<span class="lineNum">    2011 </span>            :      are usually result of gimplify_one_sizepos or SAVE_EXPR
<span class="lineNum">    2012 </span>            :      gimplification.  */
<span class="lineNum">    2013 </span><span class="lineCov">      11435 :   if (VAR_P (decl)</span>
<span class="lineNum">    2014 </span><span class="lineCov">       6875 :       &amp;&amp; DECL_ARTIFICIAL (decl)</span>
<span class="lineNum">    2015 </span><span class="lineCov">       1062 :       &amp;&amp; INTEGRAL_TYPE_P (TREE_TYPE (decl))</span>
<span class="lineNum">    2016 </span><span class="lineCov">      11731 :       &amp;&amp; !(DECL_LANG_SPECIFIC (decl)</span>
<span class="lineNum">    2017 </span><span class="lineCov">          6 :            &amp;&amp; DECL_OMP_PRIVATIZED_MEMBER (decl)))</span>
<span class="lineNum">    2018 </span><span class="lineCov">        146 :     return OMP_CLAUSE_DEFAULT_SHARED;</span>
<span class="lineNum">    2019 </span>            : 
<span class="lineNum">    2020 </span>            :   return OMP_CLAUSE_DEFAULT_UNSPECIFIED;
<span class="lineNum">    2021 </span>            : }
<span class="lineNum">    2022 </span>            : 
<span class="lineNum">    2023 </span>            : /* Finalize an implicitly determined clause.  */
<span class="lineNum">    2024 </span>            : 
<span class="lineNum">    2025 </span>            : void
<span class="lineNum">    2026 </span><span class="lineCov">      27607 : cxx_omp_finish_clause (tree c, gimple_seq *)</span>
<span class="lineNum">    2027 </span>            : {
<span class="lineNum">    2028 </span><span class="lineCov">      27607 :   tree decl, inner_type;</span>
<span class="lineNum">    2029 </span><span class="lineCov">      27607 :   bool make_shared = false;</span>
<span class="lineNum">    2030 </span>            : 
<span class="lineNum">    2031 </span><span class="lineCov">      27607 :   if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_FIRSTPRIVATE)</span>
<span class="lineNum">    2032 </span>            :     return;
<span class="lineNum">    2033 </span>            : 
<span class="lineNum">    2034 </span><span class="lineCov">       7802 :   decl = OMP_CLAUSE_DECL (c);</span>
<span class="lineNum">    2035 </span><span class="lineCov">       3901 :   decl = require_complete_type (decl);</span>
<span class="lineNum">    2036 </span><span class="lineCov">       3901 :   inner_type = TREE_TYPE (decl);</span>
<span class="lineNum">    2037 </span><span class="lineCov">       3901 :   if (decl == error_mark_node)</span>
<span class="lineNum">    2038 </span>            :     make_shared = true;
<span class="lineNum">    2039 </span><span class="lineCov">       7802 :   else if (TYPE_REF_P (TREE_TYPE (decl)))</span>
<span class="lineNum">    2040 </span><span class="lineCov">         59 :     inner_type = TREE_TYPE (inner_type);</span>
<span class="lineNum">    2041 </span>            : 
<span class="lineNum">    2042 </span>            :   /* We're interested in the base element, not arrays.  */
<span class="lineNum">    2043 </span><span class="lineCov">       3928 :   while (TREE_CODE (inner_type) == ARRAY_TYPE)</span>
<span class="lineNum">    2044 </span><span class="lineCov">         27 :     inner_type = TREE_TYPE (inner_type);</span>
<span class="lineNum">    2045 </span>            : 
<span class="lineNum">    2046 </span>            :   /* Check for special function availability by building a call to one.
<span class="lineNum">    2047 </span>            :      Save the results, because later we won't be in the right context
<span class="lineNum">    2048 </span>            :      for making these queries.  */
<span class="lineNum">    2049 </span><span class="lineCov">       3901 :   if (!make_shared</span>
<span class="lineNum">    2050 </span><span class="lineCov">       3901 :       &amp;&amp; CLASS_TYPE_P (inner_type)</span>
<span class="lineNum">    2051 </span><span class="lineCov">       4025 :       &amp;&amp; cxx_omp_create_clause_info (c, inner_type, false, true, false, true))</span>
<span class="lineNum">    2052 </span>            :     make_shared = true;
<span class="lineNum">    2053 </span>            : 
<span class="lineNum">    2054 </span><span class="lineCov">       3895 :   if (make_shared)</span>
<span class="lineNum">    2055 </span>            :     {
<span class="lineNum">    2056 </span><span class="lineCov">          6 :       OMP_CLAUSE_CODE (c) = OMP_CLAUSE_SHARED;</span>
<span class="lineNum">    2057 </span><span class="lineCov">          6 :       OMP_CLAUSE_SHARED_FIRSTPRIVATE (c) = 0;</span>
<span class="lineNum">    2058 </span><span class="lineCov">          6 :       OMP_CLAUSE_SHARED_READONLY (c) = 0;</span>
<span class="lineNum">    2059 </span>            :     }
<span class="lineNum">    2060 </span>            : }
<span class="lineNum">    2061 </span>            : 
<span class="lineNum">    2062 </span>            : /* Return true if DECL's DECL_VALUE_EXPR (if any) should be
<span class="lineNum">    2063 </span>            :    disregarded in OpenMP construct, because it is going to be
<span class="lineNum">    2064 </span>            :    remapped during OpenMP lowering.  SHARED is true if DECL
<span class="lineNum">    2065 </span>            :    is going to be shared, false if it is going to be privatized.  */
<span class="lineNum">    2066 </span>            : 
<span class="lineNum">    2067 </span>            : bool
<span class="lineNum">    2068 </span><span class="lineCov">     206437 : cxx_omp_disregard_value_expr (tree decl, bool shared)</span>
<span class="lineNum">    2069 </span>            : {
<span class="lineNum">    2070 </span><span class="lineCov">     206437 :   return !shared</span>
<span class="lineNum">    2071 </span><span class="lineCov">     102217 :          &amp;&amp; VAR_P (decl)</span>
<span class="lineNum">    2072 </span><span class="lineCov">     193990 :          &amp;&amp; DECL_HAS_VALUE_EXPR_P (decl)</span>
<span class="lineNum">    2073 </span><span class="lineCov">       5022 :          &amp;&amp; DECL_ARTIFICIAL (decl)</span>
<span class="lineNum">    2074 </span><span class="lineCov">       9978 :          &amp;&amp; DECL_LANG_SPECIFIC (decl)</span>
<span class="lineNum">    2075 </span><span class="lineCov">     220870 :          &amp;&amp; DECL_OMP_PRIVATIZED_MEMBER (decl);</span>
<span class="lineNum">    2076 </span>            : }
<span class="lineNum">    2077 </span>            : 
<span class="lineNum">    2078 </span>            : /* Fold expression X which is used as an rvalue if RVAL is true.  */
<span class="lineNum">    2079 </span>            : 
<span class="lineNum">    2080 </span>            : static tree
<span class="lineNum">    2081 </span><span class="lineCov">  181035782 : cp_fold_maybe_rvalue (tree x, bool rval)</span>
<span class="lineNum">    2082 </span>            : {
<span class="lineNum">    2083 </span><span class="lineCov">  181850539 :   while (true)</span>
<span class="lineNum">    2084 </span>            :     {
<span class="lineNum">    2085 </span><span class="lineCov">  181850539 :       x = cp_fold (x);</span>
<span class="lineNum">    2086 </span><span class="lineCov">  134976565 :       if (rval &amp;&amp; DECL_P (x)</span>
<span class="lineNum">    2087 </span><span class="lineCov">  213086787 :           &amp;&amp; !TYPE_REF_P (TREE_TYPE (x)))</span>
<span class="lineNum">    2088 </span>            :         {
<span class="lineNum">    2089 </span><span class="lineCov">   25810964 :           tree v = decl_constant_value (x);</span>
<span class="lineNum">    2090 </span><span class="lineCov">   25810964 :           if (v != x &amp;&amp; v != error_mark_node)</span>
<span class="lineNum">    2091 </span>            :             {
<span class="lineNum">    2092 </span>            :               x = v;
<span class="lineNum">    2093 </span>            :               continue;
<span class="lineNum">    2094 </span>            :             }
<span class="lineNum">    2095 </span>            :         }
<span class="lineNum">    2096 </span><span class="lineCov">  181035782 :       break;</span>
<span class="lineNum">    2097 </span>            :     }
<span class="lineNum">    2098 </span><span class="lineCov">  181035782 :   return x;</span>
<span class="lineNum">    2099 </span>            : }
<span class="lineNum">    2100 </span>            : 
<span class="lineNum">    2101 </span>            : /* Fold expression X which is used as an rvalue.  */
<a name="2102"><span class="lineNum">    2102 </span>            : </a>
<span class="lineNum">    2103 </span>            : static tree
<span class="lineNum">    2104 </span><span class="lineCov">   42828894 : cp_fold_rvalue (tree x)</span>
<span class="lineNum">    2105 </span>            : {
<span class="lineNum">    2106 </span><span class="lineCov">   42828894 :   return cp_fold_maybe_rvalue (x, true);</span>
<span class="lineNum">    2107 </span>            : }
<span class="lineNum">    2108 </span>            : 
<span class="lineNum">    2109 </span>            : /* Perform folding on expression X.  */
<span class="lineNum">    2110 </span>            : 
<span class="lineNum">    2111 </span>            : tree
<span class="lineNum">    2112 </span><span class="lineCov">   23155517 : cp_fully_fold (tree x)</span>
<span class="lineNum">    2113 </span>            : {
<span class="lineNum">    2114 </span><span class="lineCov">   23155517 :   if (processing_template_decl)</span>
<span class="lineNum">    2115 </span>            :     return x;
<span class="lineNum">    2116 </span>            :   /* FIXME cp_fold ought to be a superset of maybe_constant_value so we don't
<span class="lineNum">    2117 </span>            :      have to call both.  */
<span class="lineNum">    2118 </span><span class="lineCov">   21946376 :   if (cxx_dialect &gt;= cxx11)</span>
<span class="lineNum">    2119 </span>            :     {
<span class="lineNum">    2120 </span><span class="lineCov">   21107760 :       x = maybe_constant_value (x);</span>
<span class="lineNum">    2121 </span>            :       /* Sometimes we are given a CONSTRUCTOR but the call above wraps it into
<span class="lineNum">    2122 </span>            :          a TARGET_EXPR; undo that here.  */
<span class="lineNum">    2123 </span><span class="lineCov">   21107760 :       if (TREE_CODE (x) == TARGET_EXPR)</span>
<span class="lineNum">    2124 </span><span class="lineCov">      93832 :         x = TARGET_EXPR_INITIAL (x);</span>
<span class="lineNum">    2125 </span><span class="lineCov">   21013928 :       else if (TREE_CODE (x) == VIEW_CONVERT_EXPR</span>
<span class="lineNum">    2126 </span><span class="lineCov">     215038 :                &amp;&amp; TREE_CODE (TREE_OPERAND (x, 0)) == CONSTRUCTOR</span>
<span class="lineNum">    2127 </span><span class="lineCov">   21013964 :                &amp;&amp; TREE_TYPE (TREE_OPERAND (x, 0)) == TREE_TYPE (x))</span>
<span class="lineNum">    2128 </span><span class="lineCov">         36 :         x = TREE_OPERAND (x, 0);</span>
<span class="lineNum">    2129 </span>            :     }
<span class="lineNum">    2130 </span><span class="lineCov">   21946376 :   return cp_fold_rvalue (x);</span>
<span class="lineNum">    2131 </span>            : }
<span class="lineNum">    2132 </span>            : 
<span class="lineNum">    2133 </span>            : /* c-common interface to cp_fold.  If IN_INIT, this is in a static initializer
<span class="lineNum">    2134 </span>            :    and certain changes are made to the folding done.  Or should be (FIXME).  We
<span class="lineNum">    2135 </span>            :    never touch maybe_const, as it is only used for the C front-end
<span class="lineNum">    2136 </span>            :    C_MAYBE_CONST_EXPR.  */
<a name="2137"><span class="lineNum">    2137 </span>            : </a>
<span class="lineNum">    2138 </span>            : tree
<span class="lineNum">    2139 </span><span class="lineCov">    5241408 : c_fully_fold (tree x, bool /*in_init*/, bool */*maybe_const*/, bool lval)</span>
<span class="lineNum">    2140 </span>            : {
<span class="lineNum">    2141 </span><span class="lineCov">    5241408 :   return cp_fold_maybe_rvalue (x, !lval);</span>
<span class="lineNum">    2142 </span>            : }
<span class="lineNum">    2143 </span>            : 
<span class="lineNum">    2144 </span>            : static GTY((deletable)) hash_map&lt;tree, tree&gt; *fold_cache;
<span class="lineNum">    2145 </span>            : 
<span class="lineNum">    2146 </span>            : /* Dispose of the whole FOLD_CACHE.  */
<a name="2147"><span class="lineNum">    2147 </span>            : </a>
<span class="lineNum">    2148 </span>            : void
<span class="lineNum">    2149 </span><span class="lineCov">    2732035 : clear_fold_cache (void)</span>
<span class="lineNum">    2150 </span>            : {
<span class="lineNum">    2151 </span><span class="lineCov">    2732035 :   if (fold_cache != NULL)</span>
<span class="lineNum">    2152 </span><span class="lineCov">    2619312 :     fold_cache-&gt;empty ();</span>
<span class="lineNum">    2153 </span><span class="lineCov">    2732035 : }</span>
<span class="lineNum">    2154 </span>            : 
<span class="lineNum">    2155 </span>            : /*  This function tries to fold an expression X.
<span class="lineNum">    2156 </span>            :     To avoid combinatorial explosion, folding results are kept in fold_cache.
<span class="lineNum">    2157 </span>            :     If X is invalid, we don't fold at all.
<span class="lineNum">    2158 </span>            :     For performance reasons we don't cache expressions representing a
<span class="lineNum">    2159 </span>            :     declaration or constant.
<span class="lineNum">    2160 </span>            :     Function returns X or its folded variant.  */
<span class="lineNum">    2161 </span>            : 
<span class="lineNum">    2162 </span>            : static tree
<span class="lineNum">    2163 </span><span class="lineCov">  534561165 : cp_fold (tree x)</span>
<span class="lineNum">    2164 </span>            : {
<span class="lineNum">    2165 </span><span class="lineCov">  534561165 :   tree op0, op1, op2, op3;</span>
<span class="lineNum">    2166 </span><span class="lineCov">  534561165 :   tree org_x = x, r = NULL_TREE;</span>
<span class="lineNum">    2167 </span><span class="lineCov">  534561165 :   enum tree_code code;</span>
<span class="lineNum">    2168 </span><span class="lineCov">  534561165 :   location_t loc;</span>
<span class="lineNum">    2169 </span><span class="lineCov">  534561165 :   bool rval_ops = true;</span>
<span class="lineNum">    2170 </span>            : 
<span class="lineNum">    2171 </span><span class="lineCov">  534561165 :   if (!x || x == error_mark_node)</span>
<span class="lineNum">    2172 </span>            :     return x;
<span class="lineNum">    2173 </span>            : 
<span class="lineNum">    2174 </span><span class="lineCov">  533947629 :   if (EXPR_P (x) &amp;&amp; (!TREE_TYPE (x) || TREE_TYPE (x) == error_mark_node))</span>
<span class="lineNum">    2175 </span>            :     return x;
<span class="lineNum">    2176 </span>            : 
<span class="lineNum">    2177 </span>            :   /* Don't bother to cache DECLs or constants.  */
<span class="lineNum">    2178 </span><span class="lineCov">  533876510 :   if (DECL_P (x) || CONSTANT_CLASS_P (x))</span>
<span class="lineNum">    2179 </span>            :     return x;
<span class="lineNum">    2180 </span>            : 
<span class="lineNum">    2181 </span><span class="lineCov">  334508925 :   if (fold_cache == NULL)</span>
<span class="lineNum">    2182 </span><span class="lineCov">      62086 :     fold_cache = hash_map&lt;tree, tree&gt;::create_ggc (101);</span>
<span class="lineNum">    2183 </span>            : 
<span class="lineNum">    2184 </span><span class="lineCov">  334508925 :   if (tree *cached = fold_cache-&gt;get (x))</span>
<span class="lineNum">    2185 </span><span class="lineCov">   77699241 :     return *cached;</span>
<span class="lineNum">    2186 </span>            : 
<span class="lineNum">    2187 </span><span class="lineCov">  256809684 :   code = TREE_CODE (x);</span>
<span class="lineNum">    2188 </span><span class="lineCov">  256809684 :   switch (code)</span>
<span class="lineNum">    2189 </span>            :     {
<span class="lineNum">    2190 </span><span class="lineCov">   16888715 :     case CLEANUP_POINT_EXPR:</span>
<span class="lineNum">    2191 </span>            :       /* Strip CLEANUP_POINT_EXPR if the expression doesn't have side
<span class="lineNum">    2192 </span>            :          effects.  */
<span class="lineNum">    2193 </span><span class="lineCov">   16888715 :       r = cp_fold_rvalue (TREE_OPERAND (x, 0));</span>
<span class="lineNum">    2194 </span><span class="lineCov">   16888715 :       if (!TREE_SIDE_EFFECTS (r))</span>
<span class="lineNum">    2195 </span><span class="lineCov">       8813 :         x = r;</span>
<span class="lineNum">    2196 </span>            :       break;
<span class="lineNum">    2197 </span>            : 
<span class="lineNum">    2198 </span><span class="lineCov">     296739 :     case SIZEOF_EXPR:</span>
<span class="lineNum">    2199 </span><span class="lineCov">     296739 :       x = fold_sizeof_expr (x);</span>
<span class="lineNum">    2200 </span><span class="lineCov">     296739 :       break;</span>
<span class="lineNum">    2201 </span>            : 
<span class="lineNum">    2202 </span><span class="lineCov">    5128956 :     case VIEW_CONVERT_EXPR:</span>
<span class="lineNum">    2203 </span><span class="lineCov">    5128956 :       rval_ops = false;</span>
<span class="lineNum">    2204 </span>            :       /* FALLTHRU */
<span class="lineNum">    2205 </span><span class="lineCov">   51476809 :     case CONVERT_EXPR:</span>
<span class="lineNum">    2206 </span><span class="lineCov">   51476809 :     case NOP_EXPR:</span>
<span class="lineNum">    2207 </span><span class="lineCov">   51476809 :     case NON_LVALUE_EXPR:</span>
<span class="lineNum">    2208 </span>            : 
<span class="lineNum">    2209 </span><span class="lineCov">   51476809 :       if (VOID_TYPE_P (TREE_TYPE (x)))</span>
<span class="lineNum">    2210 </span>            :         {
<span class="lineNum">    2211 </span>            :           /* This is just to make sure we don't end up with casts to
<span class="lineNum">    2212 </span>            :              void from error_mark_node.  If we just return x, then
<span class="lineNum">    2213 </span>            :              cp_fold_r might fold the operand into error_mark_node and
<span class="lineNum">    2214 </span>            :              leave the conversion in the IR.  STRIP_USELESS_TYPE_CONVERSION
<span class="lineNum">    2215 </span>            :              during gimplification doesn't like such casts.
<span class="lineNum">    2216 </span>            :              Don't create a new tree if op0 != TREE_OPERAND (x, 0), the
<span class="lineNum">    2217 </span>            :              folding of the operand should be in the caches and if in cp_fold_r
<span class="lineNum">    2218 </span>            :              it will modify it in place.  */
<span class="lineNum">    2219 </span><span class="lineCov">    6413785 :           op0 = cp_fold (TREE_OPERAND (x, 0));</span>
<span class="lineNum">    2220 </span><span class="lineCov">    6413785 :           if (op0 == error_mark_node)</span>
<span class="lineNum">    2221 </span><span class="lineCov">          5 :             x = error_mark_node;</span>
<span class="lineNum">    2222 </span>            :           break;
<span class="lineNum">    2223 </span>            :         }
<span class="lineNum">    2224 </span>            : 
<span class="lineNum">    2225 </span><span class="lineCov">   45063024 :       loc = EXPR_LOCATION (x);</span>
<span class="lineNum">    2226 </span><span class="lineCov">   45063024 :       op0 = cp_fold_maybe_rvalue (TREE_OPERAND (x, 0), rval_ops);</span>
<span class="lineNum">    2227 </span>            : 
<span class="lineNum">    2228 </span><span class="lineCov">   45063024 :       if (code == CONVERT_EXPR</span>
<span class="lineNum">    2229 </span><span class="lineCov">    5827540 :           &amp;&amp; SCALAR_TYPE_P (TREE_TYPE (x))</span>
<span class="lineNum">    2230 </span><span class="lineCov">   50890559 :           &amp;&amp; op0 != void_node)</span>
<span class="lineNum">    2231 </span>            :         /* During parsing we used convert_to_*_nofold; re-convert now using the
<span class="lineNum">    2232 </span>            :            folding variants, since fold() doesn't do those transformations.  */
<span class="lineNum">    2233 </span><span class="lineCov">   10602992 :         x = fold (convert (TREE_TYPE (x), op0));</span>
<span class="lineNum">    2234 </span><span class="lineCov">   39761528 :       else if (op0 != TREE_OPERAND (x, 0))</span>
<span class="lineNum">    2235 </span>            :         {
<span class="lineNum">    2236 </span><span class="lineCov">    8370018 :           if (op0 == error_mark_node)</span>
<span class="lineNum">    2237 </span><span class="lineCov">          8 :             x = error_mark_node;</span>
<span class="lineNum">    2238 </span>            :           else
<span class="lineNum">    2239 </span><span class="lineCov">    8370010 :             x = fold_build1_loc (loc, code, TREE_TYPE (x), op0);</span>
<span class="lineNum">    2240 </span>            :         }
<span class="lineNum">    2241 </span>            :       else
<span class="lineNum">    2242 </span><span class="lineCov">   31391510 :         x = fold (x);</span>
<span class="lineNum">    2243 </span>            : 
<span class="lineNum">    2244 </span>            :       /* Conversion of an out-of-range value has implementation-defined
<span class="lineNum">    2245 </span>            :          behavior; the language considers it different from arithmetic
<span class="lineNum">    2246 </span>            :          overflow, which is undefined.  */
<span class="lineNum">    2247 </span><span class="lineCov">   45063024 :       if (TREE_CODE (op0) == INTEGER_CST</span>
<span class="lineNum">    2248 </span><span class="lineCov">   45063024 :           &amp;&amp; TREE_OVERFLOW_P (x) &amp;&amp; !TREE_OVERFLOW_P (op0))</span>
<span class="lineNum">    2249 </span><span class="lineCov">      29178 :         TREE_OVERFLOW (x) = false;</span>
<span class="lineNum">    2250 </span>            : 
<span class="lineNum">    2251 </span>            :       break;
<span class="lineNum">    2252 </span>            : 
<span class="lineNum">    2253 </span><span class="lineCov">   13027693 :     case INDIRECT_REF:</span>
<span class="lineNum">    2254 </span>            :       /* We don't need the decltype(auto) obfuscation anymore.  */
<span class="lineNum">    2255 </span><span class="lineCov">   26055386 :       if (REF_PARENTHESIZED_P (x))</span>
<span class="lineNum">    2256 </span>            :         {
<span class="lineNum">    2257 </span><span class="lineNoCov">          0 :           tree p = maybe_undo_parenthesized_ref (x);</span>
<span class="lineNum">    2258 </span><span class="lineNoCov">          0 :           return cp_fold (p);</span>
<span class="lineNum">    2259 </span><span class="lineCov">   13027693 :         }</span>
<span class="lineNum">    2260 </span>            :       goto unary;
<span class="lineNum">    2261 </span>            : 
<span class="lineNum">    2262 </span><span class="lineCov">   26820774 :     case ADDR_EXPR:</span>
<span class="lineNum">    2263 </span><span class="lineCov">   26820774 :       loc = EXPR_LOCATION (x);</span>
<span class="lineNum">    2264 </span><span class="lineCov">   26820774 :       op0 = cp_fold_maybe_rvalue (TREE_OPERAND (x, 0), false);</span>
<span class="lineNum">    2265 </span>            : 
<span class="lineNum">    2266 </span>            :       /* Cope with user tricks that amount to offsetof.  */
<span class="lineNum">    2267 </span><span class="lineCov">   26820774 :       if (op0 != error_mark_node</span>
<span class="lineNum">    2268 </span><span class="lineCov">   26820774 :           &amp;&amp; TREE_CODE (TREE_TYPE (op0)) != FUNCTION_TYPE</span>
<span class="lineNum">    2269 </span><span class="lineCov">   64078232 :           &amp;&amp; TREE_CODE (TREE_TYPE (op0)) != METHOD_TYPE)</span>
<span class="lineNum">    2270 </span>            :         {
<span class="lineNum">    2271 </span><span class="lineCov">    8864672 :           tree val = get_base_address (op0);</span>
<span class="lineNum">    2272 </span><span class="lineCov">    8864672 :           if (val</span>
<span class="lineNum">    2273 </span><span class="lineCov">    8864672 :               &amp;&amp; INDIRECT_REF_P (val)</span>
<span class="lineNum">    2274 </span><span class="lineCov">    4199185 :               &amp;&amp; COMPLETE_TYPE_P (TREE_TYPE (val))</span>
<span class="lineNum">    2275 </span><span class="lineCov">   13063857 :               &amp;&amp; TREE_CONSTANT (TREE_OPERAND (val, 0)))</span>
<span class="lineNum">    2276 </span>            :             {
<span class="lineNum">    2277 </span><span class="lineCov">        152 :               val = TREE_OPERAND (val, 0);</span>
<span class="lineNum">    2278 </span><span class="lineCov">        152 :               STRIP_NOPS (val);</span>
<span class="lineNum">    2279 </span><span class="lineCov">        152 :               if (TREE_CODE (val) == INTEGER_CST)</span>
<span class="lineNum">    2280 </span><span class="lineCov">        100 :                 return fold_offsetof (op0, TREE_TYPE (x));</span>
<span class="lineNum">    2281 </span>            :             }
<span class="lineNum">    2282 </span>            :         }
<span class="lineNum">    2283 </span><span class="lineCov">   26820674 :       goto finish_unary;</span>
<span class="lineNum">    2284 </span>            : 
<span class="lineNum">    2285 </span><span class="lineCov">     168699 :     case REALPART_EXPR:</span>
<span class="lineNum">    2286 </span><span class="lineCov">     168699 :     case IMAGPART_EXPR:</span>
<span class="lineNum">    2287 </span><span class="lineCov">     168699 :       rval_ops = false;</span>
<span class="lineNum">    2288 </span>            :       /* FALLTHRU */
<span class="lineNum">    2289 </span><span class="lineCov">   14206339 :     case CONJ_EXPR:</span>
<span class="lineNum">    2290 </span><span class="lineCov">   14206339 :     case FIX_TRUNC_EXPR:</span>
<span class="lineNum">    2291 </span><span class="lineCov">   14206339 :     case FLOAT_EXPR:</span>
<span class="lineNum">    2292 </span><span class="lineCov">   14206339 :     case NEGATE_EXPR:</span>
<span class="lineNum">    2293 </span><span class="lineCov">   14206339 :     case ABS_EXPR:</span>
<span class="lineNum">    2294 </span><span class="lineCov">   14206339 :     case ABSU_EXPR:</span>
<span class="lineNum">    2295 </span><span class="lineCov">   14206339 :     case BIT_NOT_EXPR:</span>
<span class="lineNum">    2296 </span><span class="lineCov">   14206339 :     case TRUTH_NOT_EXPR:</span>
<span class="lineNum">    2297 </span><span class="lineCov">   14206339 :     case FIXED_CONVERT_EXPR:</span>
<span class="lineNum">    2298 </span><span class="lineCov">   28412678 :     unary:</span>
<span class="lineNum">    2299 </span>            : 
<span class="lineNum">    2300 </span><span class="lineCov">   14206339 :       loc = EXPR_LOCATION (x);</span>
<span class="lineNum">    2301 </span><span class="lineCov">   14206339 :       op0 = cp_fold_maybe_rvalue (TREE_OPERAND (x, 0), rval_ops);</span>
<span class="lineNum">    2302 </span>            : 
<span class="lineNum">    2303 </span><span class="lineCov">   41027013 :     finish_unary:</span>
<span class="lineNum">    2304 </span><span class="lineCov">   41027013 :       if (op0 != TREE_OPERAND (x, 0))</span>
<span class="lineNum">    2305 </span>            :         {
<span class="lineNum">    2306 </span><span class="lineCov">    1248781 :           if (op0 == error_mark_node)</span>
<span class="lineNum">    2307 </span><span class="lineNoCov">          0 :             x = error_mark_node;</span>
<span class="lineNum">    2308 </span>            :           else
<span class="lineNum">    2309 </span>            :             {
<span class="lineNum">    2310 </span><span class="lineCov">    1248781 :               x = fold_build1_loc (loc, code, TREE_TYPE (x), op0);</span>
<span class="lineNum">    2311 </span><span class="lineCov">    1248781 :               if (code == INDIRECT_REF</span>
<span class="lineNum">    2312 </span><span class="lineCov">     970028 :                   &amp;&amp; (INDIRECT_REF_P (x) || TREE_CODE (x) == MEM_REF))</span>
<span class="lineNum">    2313 </span>            :                 {
<span class="lineNum">    2314 </span><span class="lineCov">     970018 :                   TREE_READONLY (x) = TREE_READONLY (org_x);</span>
<span class="lineNum">    2315 </span><span class="lineCov">     970018 :                   TREE_SIDE_EFFECTS (x) = TREE_SIDE_EFFECTS (org_x);</span>
<span class="lineNum">    2316 </span><span class="lineCov">     970018 :                   TREE_THIS_VOLATILE (x) = TREE_THIS_VOLATILE (org_x);</span>
<span class="lineNum">    2317 </span>            :                 }
<span class="lineNum">    2318 </span>            :             }
<span class="lineNum">    2319 </span>            :         }
<span class="lineNum">    2320 </span>            :       else
<span class="lineNum">    2321 </span><span class="lineCov">   39778232 :         x = fold (x);</span>
<span class="lineNum">    2322 </span>            : 
<span class="lineNum">    2323 </span><span class="lineCov">   41027013 :       gcc_assert (TREE_CODE (x) != COND_EXPR</span>
<span class="lineNum">    2324 </span>            :                   || !VOID_TYPE_P (TREE_TYPE (TREE_OPERAND (x, 0))));
<span class="lineNum">    2325 </span>            :       break;
<span class="lineNum">    2326 </span>            : 
<span class="lineNum">    2327 </span><span class="lineCov">      34550 :     case UNARY_PLUS_EXPR:</span>
<span class="lineNum">    2328 </span><span class="lineCov">      34550 :       op0 = cp_fold_rvalue (TREE_OPERAND (x, 0));</span>
<span class="lineNum">    2329 </span><span class="lineCov">      34550 :       if (op0 == error_mark_node)</span>
<span class="lineNum">    2330 </span><span class="lineNoCov">          0 :         x = error_mark_node;</span>
<span class="lineNum">    2331 </span>            :       else
<span class="lineNum">    2332 </span><span class="lineCov">      34550 :         x = fold_convert (TREE_TYPE (x), op0);</span>
<span class="lineNum">    2333 </span>            :       break;
<span class="lineNum">    2334 </span>            : 
<span class="lineNum">    2335 </span><span class="lineCov">   14755545 :     case POSTDECREMENT_EXPR:</span>
<span class="lineNum">    2336 </span><span class="lineCov">   14755545 :     case POSTINCREMENT_EXPR:</span>
<span class="lineNum">    2337 </span><span class="lineCov">   14755545 :     case INIT_EXPR:</span>
<span class="lineNum">    2338 </span><span class="lineCov">   14755545 :     case PREDECREMENT_EXPR:</span>
<span class="lineNum">    2339 </span><span class="lineCov">   14755545 :     case PREINCREMENT_EXPR:</span>
<span class="lineNum">    2340 </span><span class="lineCov">   14755545 :     case COMPOUND_EXPR:</span>
<span class="lineNum">    2341 </span><span class="lineCov">   14755545 :     case MODIFY_EXPR:</span>
<span class="lineNum">    2342 </span><span class="lineCov">   14755545 :       rval_ops = false;</span>
<span class="lineNum">    2343 </span>            :       /* FALLTHRU */
<span class="lineNum">    2344 </span><span class="lineCov">   24928967 :     case POINTER_PLUS_EXPR:</span>
<span class="lineNum">    2345 </span><span class="lineCov">   24928967 :     case PLUS_EXPR:</span>
<span class="lineNum">    2346 </span><span class="lineCov">   24928967 :     case POINTER_DIFF_EXPR:</span>
<span class="lineNum">    2347 </span><span class="lineCov">   24928967 :     case MINUS_EXPR:</span>
<span class="lineNum">    2348 </span><span class="lineCov">   24928967 :     case MULT_EXPR:</span>
<span class="lineNum">    2349 </span><span class="lineCov">   24928967 :     case TRUNC_DIV_EXPR:</span>
<span class="lineNum">    2350 </span><span class="lineCov">   24928967 :     case CEIL_DIV_EXPR:</span>
<span class="lineNum">    2351 </span><span class="lineCov">   24928967 :     case FLOOR_DIV_EXPR:</span>
<span class="lineNum">    2352 </span><span class="lineCov">   24928967 :     case ROUND_DIV_EXPR:</span>
<span class="lineNum">    2353 </span><span class="lineCov">   24928967 :     case TRUNC_MOD_EXPR:</span>
<span class="lineNum">    2354 </span><span class="lineCov">   24928967 :     case CEIL_MOD_EXPR:</span>
<span class="lineNum">    2355 </span><span class="lineCov">   24928967 :     case ROUND_MOD_EXPR:</span>
<span class="lineNum">    2356 </span><span class="lineCov">   24928967 :     case RDIV_EXPR:</span>
<span class="lineNum">    2357 </span><span class="lineCov">   24928967 :     case EXACT_DIV_EXPR:</span>
<span class="lineNum">    2358 </span><span class="lineCov">   24928967 :     case MIN_EXPR:</span>
<span class="lineNum">    2359 </span><span class="lineCov">   24928967 :     case MAX_EXPR:</span>
<span class="lineNum">    2360 </span><span class="lineCov">   24928967 :     case LSHIFT_EXPR:</span>
<span class="lineNum">    2361 </span><span class="lineCov">   24928967 :     case RSHIFT_EXPR:</span>
<span class="lineNum">    2362 </span><span class="lineCov">   24928967 :     case LROTATE_EXPR:</span>
<span class="lineNum">    2363 </span><span class="lineCov">   24928967 :     case RROTATE_EXPR:</span>
<span class="lineNum">    2364 </span><span class="lineCov">   24928967 :     case BIT_AND_EXPR:</span>
<span class="lineNum">    2365 </span><span class="lineCov">   24928967 :     case BIT_IOR_EXPR:</span>
<span class="lineNum">    2366 </span><span class="lineCov">   24928967 :     case BIT_XOR_EXPR:</span>
<span class="lineNum">    2367 </span><span class="lineCov">   24928967 :     case TRUTH_AND_EXPR:</span>
<span class="lineNum">    2368 </span><span class="lineCov">   24928967 :     case TRUTH_ANDIF_EXPR:</span>
<span class="lineNum">    2369 </span><span class="lineCov">   24928967 :     case TRUTH_OR_EXPR:</span>
<span class="lineNum">    2370 </span><span class="lineCov">   24928967 :     case TRUTH_ORIF_EXPR:</span>
<span class="lineNum">    2371 </span><span class="lineCov">   24928967 :     case TRUTH_XOR_EXPR:</span>
<span class="lineNum">    2372 </span><span class="lineCov">   24928967 :     case LT_EXPR: case LE_EXPR:</span>
<span class="lineNum">    2373 </span><span class="lineCov">   24928967 :     case GT_EXPR: case GE_EXPR:</span>
<span class="lineNum">    2374 </span><span class="lineCov">   24928967 :     case EQ_EXPR: case NE_EXPR:</span>
<span class="lineNum">    2375 </span><span class="lineCov">   24928967 :     case UNORDERED_EXPR: case ORDERED_EXPR:</span>
<span class="lineNum">    2376 </span><span class="lineCov">   24928967 :     case UNLT_EXPR: case UNLE_EXPR:</span>
<span class="lineNum">    2377 </span><span class="lineCov">   24928967 :     case UNGT_EXPR: case UNGE_EXPR:</span>
<span class="lineNum">    2378 </span><span class="lineCov">   24928967 :     case UNEQ_EXPR: case LTGT_EXPR:</span>
<span class="lineNum">    2379 </span><span class="lineCov">   24928967 :     case RANGE_EXPR: case COMPLEX_EXPR:</span>
<span class="lineNum">    2380 </span>            : 
<span class="lineNum">    2381 </span><span class="lineCov">   24928967 :       loc = EXPR_LOCATION (x);</span>
<span class="lineNum">    2382 </span><span class="lineCov">   24928967 :       op0 = cp_fold_maybe_rvalue (TREE_OPERAND (x, 0), rval_ops);</span>
<span class="lineNum">    2383 </span><span class="lineCov">   24928967 :       op1 = cp_fold_rvalue (TREE_OPERAND (x, 1));</span>
<span class="lineNum">    2384 </span>            : 
<span class="lineNum">    2385 </span><span class="lineCov">   24928967 :       if (op0 != TREE_OPERAND (x, 0) || op1 != TREE_OPERAND (x, 1))</span>
<span class="lineNum">    2386 </span>            :         {
<span class="lineNum">    2387 </span><span class="lineCov">    7426585 :           if (op0 == error_mark_node || op1 == error_mark_node)</span>
<span class="lineNum">    2388 </span><span class="lineCov">         20 :             x = error_mark_node;</span>
<span class="lineNum">    2389 </span>            :           else
<span class="lineNum">    2390 </span><span class="lineCov">    7426565 :             x = fold_build2_loc (loc, code, TREE_TYPE (x), op0, op1);</span>
<span class="lineNum">    2391 </span>            :         }
<span class="lineNum">    2392 </span>            :       else
<span class="lineNum">    2393 </span><span class="lineCov">   17502382 :         x = fold (x);</span>
<span class="lineNum">    2394 </span>            : 
<span class="lineNum">    2395 </span>            :       /* This is only needed for -Wnonnull-compare and only if
<span class="lineNum">    2396 </span>            :          TREE_NO_WARNING (org_x), but to avoid that option affecting code
<span class="lineNum">    2397 </span>            :          generation, we do it always.  */
<span class="lineNum">    2398 </span><span class="lineCov">   24928967 :       if (COMPARISON_CLASS_P (org_x))</span>
<span class="lineNum">    2399 </span>            :         {
<span class="lineNum">    2400 </span><span class="lineCov">    3485317 :           if (x == error_mark_node || TREE_CODE (x) == INTEGER_CST)</span>
<span class="lineNum">    2401 </span>            :             ;
<span class="lineNum">    2402 </span><span class="lineCov">    3058895 :           else if (COMPARISON_CLASS_P (x))</span>
<span class="lineNum">    2403 </span>            :             {
<span class="lineNum">    2404 </span><span class="lineCov">    3034716 :               if (TREE_NO_WARNING (org_x) &amp;&amp; warn_nonnull_compare)</span>
<span class="lineNum">    2405 </span><span class="lineCov">      93155 :                 TREE_NO_WARNING (x) = 1;</span>
<span class="lineNum">    2406 </span>            :             }
<span class="lineNum">    2407 </span>            :           /* Otherwise give up on optimizing these, let GIMPLE folders
<span class="lineNum">    2408 </span>            :              optimize those later on.  */
<span class="lineNum">    2409 </span><span class="lineCov">      24179 :           else if (op0 != TREE_OPERAND (org_x, 0)</span>
<span class="lineNum">    2410 </span><span class="lineCov">      24179 :                    || op1 != TREE_OPERAND (org_x, 1))</span>
<span class="lineNum">    2411 </span>            :             {
<span class="lineNum">    2412 </span><span class="lineCov">      23231 :               x = build2_loc (loc, code, TREE_TYPE (org_x), op0, op1);</span>
<span class="lineNum">    2413 </span><span class="lineCov">      23231 :               if (TREE_NO_WARNING (org_x) &amp;&amp; warn_nonnull_compare)</span>
<span class="lineNum">    2414 </span><span class="lineCov">         17 :                 TREE_NO_WARNING (x) = 1;</span>
<span class="lineNum">    2415 </span>            :             }
<span class="lineNum">    2416 </span>            :           else
<span class="lineNum">    2417 </span><span class="lineCov">        948 :             x = org_x;</span>
<span class="lineNum">    2418 </span>            :         }
<span class="lineNum">    2419 </span>            :       break;
<span class="lineNum">    2420 </span>            : 
<span class="lineNum">    2421 </span><span class="lineCov">     976662 :     case VEC_COND_EXPR:</span>
<span class="lineNum">    2422 </span><span class="lineCov">     976662 :     case COND_EXPR:</span>
<span class="lineNum">    2423 </span><span class="lineCov">     976662 :       loc = EXPR_LOCATION (x);</span>
<span class="lineNum">    2424 </span><span class="lineCov">     976662 :       op0 = cp_fold_rvalue (TREE_OPERAND (x, 0));</span>
<span class="lineNum">    2425 </span><span class="lineCov">     976662 :       op1 = cp_fold (TREE_OPERAND (x, 1));</span>
<span class="lineNum">    2426 </span><span class="lineCov">     976662 :       op2 = cp_fold (TREE_OPERAND (x, 2));</span>
<span class="lineNum">    2427 </span>            : 
<span class="lineNum">    2428 </span><span class="lineCov">     976662 :       if (TREE_CODE (TREE_TYPE (x)) == BOOLEAN_TYPE)</span>
<span class="lineNum">    2429 </span>            :         {
<span class="lineNum">    2430 </span><span class="lineCov">      44850 :           warning_sentinel s (warn_int_in_bool_context);</span>
<span class="lineNum">    2431 </span><span class="lineCov">      14950 :           if (!VOID_TYPE_P (TREE_TYPE (op1)))</span>
<span class="lineNum">    2432 </span><span class="lineCov">      14950 :             op1 = cp_truthvalue_conversion (op1);</span>
<span class="lineNum">    2433 </span><span class="lineCov">      14950 :           if (!VOID_TYPE_P (TREE_TYPE (op2)))</span>
<span class="lineNum">    2434 </span><span class="lineCov">      14941 :             op2 = cp_truthvalue_conversion (op2);</span>
<span class="lineNum">    2435 </span>            :         }
<span class="lineNum">    2436 </span><span class="lineCov">    1923424 :       else if (VOID_TYPE_P (TREE_TYPE (x)))</span>
<span class="lineNum">    2437 </span>            :         {
<span class="lineNum">    2438 </span><span class="lineCov">     425049 :           if (TREE_CODE (op0) == INTEGER_CST)</span>
<span class="lineNum">    2439 </span>            :             {
<span class="lineNum">    2440 </span>            :               /* If the condition is constant, fold can fold away
<span class="lineNum">    2441 </span>            :                  the COND_EXPR.  If some statement-level uses of COND_EXPR
<span class="lineNum">    2442 </span>            :                  have one of the branches NULL, avoid folding crash.  */
<span class="lineNum">    2443 </span><span class="lineCov">     108156 :               if (!op1)</span>
<span class="lineNum">    2444 </span><span class="lineNoCov">          0 :                 op1 = build_empty_stmt (loc);</span>
<span class="lineNum">    2445 </span><span class="lineCov">     108156 :               if (!op2)</span>
<span class="lineNum">    2446 </span><span class="lineNoCov">          0 :                 op2 = build_empty_stmt (loc);</span>
<span class="lineNum">    2447 </span>            :             }
<span class="lineNum">    2448 </span>            :           else
<span class="lineNum">    2449 </span>            :             {
<span class="lineNum">    2450 </span>            :               /* Otherwise, don't bother folding a void condition, since
<span class="lineNum">    2451 </span>            :                  it can't produce a constant value.  */
<span class="lineNum">    2452 </span><span class="lineCov">     316893 :               if (op0 != TREE_OPERAND (x, 0)</span>
<span class="lineNum">    2453 </span><span class="lineCov">     313555 :                   || op1 != TREE_OPERAND (x, 1)</span>
<span class="lineNum">    2454 </span><span class="lineCov">     616438 :                   || op2 != TREE_OPERAND (x, 2))</span>
<span class="lineNum">    2455 </span><span class="lineCov">      53496 :                 x = build3_loc (loc, code, TREE_TYPE (x), op0, op1, op2);</span>
<span class="lineNum">    2456 </span>            :               break;
<span class="lineNum">    2457 </span>            :             }
<span class="lineNum">    2458 </span>            :         }
<span class="lineNum">    2459 </span>            : 
<span class="lineNum">    2460 </span><span class="lineCov">     659769 :       if (op0 != TREE_OPERAND (x, 0)</span>
<span class="lineNum">    2461 </span><span class="lineCov">     254488 :           || op1 != TREE_OPERAND (x, 1)</span>
<span class="lineNum">    2462 </span><span class="lineCov">     868193 :           || op2 != TREE_OPERAND (x, 2))</span>
<span class="lineNum">    2463 </span>            :         {
<span class="lineNum">    2464 </span><span class="lineCov">     452609 :           if (op0 == error_mark_node</span>
<span class="lineNum">    2465 </span><span class="lineCov">     452609 :               || op1 == error_mark_node</span>
<span class="lineNum">    2466 </span><span class="lineCov">     452609 :               || op2 == error_mark_node)</span>
<span class="lineNum">    2467 </span><span class="lineCov">          3 :             x = error_mark_node;</span>
<span class="lineNum">    2468 </span>            :           else
<span class="lineNum">    2469 </span><span class="lineCov">     452606 :             x = fold_build3_loc (loc, code, TREE_TYPE (x), op0, op1, op2);</span>
<span class="lineNum">    2470 </span>            :         }
<span class="lineNum">    2471 </span>            :       else
<span class="lineNum">    2472 </span><span class="lineCov">     207160 :         x = fold (x);</span>
<span class="lineNum">    2473 </span>            : 
<span class="lineNum">    2474 </span>            :       /* A COND_EXPR might have incompatible types in branches if one or both
<span class="lineNum">    2475 </span>            :          arms are bitfields.  If folding exposed such a branch, fix it up.  */
<span class="lineNum">    2476 </span><span class="lineCov">     659769 :       if (TREE_CODE (x) != code</span>
<span class="lineNum">    2477 </span><span class="lineCov">     378052 :           &amp;&amp; x != error_mark_node</span>
<span class="lineNum">    2478 </span><span class="lineCov">    1037818 :           &amp;&amp; !useless_type_conversion_p (TREE_TYPE (org_x), TREE_TYPE (x)))</span>
<span class="lineNum">    2479 </span><span class="lineCov">      14216 :         x = fold_convert (TREE_TYPE (org_x), x);</span>
<span class="lineNum">    2480 </span>            : 
<span class="lineNum">    2481 </span>            :       break;
<span class="lineNum">    2482 </span>            : 
<span class="lineNum">    2483 </span><span class="lineCov">   18556573 :     case CALL_EXPR:</span>
<span class="lineNum">    2484 </span><span class="lineCov">   18556573 :       {</span>
<span class="lineNum">    2485 </span><span class="lineCov">   18556573 :         int i, m, sv = optimize, nw = sv, changed = 0;</span>
<span class="lineNum">    2486 </span><span class="lineCov">   18556573 :         tree callee = get_callee_fndecl (x);</span>
<span class="lineNum">    2487 </span>            : 
<span class="lineNum">    2488 </span>            :         /* Some built-in function calls will be evaluated at compile-time in
<span class="lineNum">    2489 </span>            :            fold ().  Set optimize to 1 when folding __builtin_constant_p inside
<span class="lineNum">    2490 </span>            :            a constexpr function so that fold_builtin_1 doesn't fold it to 0.  */
<span class="lineNum">    2491 </span><span class="lineCov">   18128232 :         if (callee &amp;&amp; fndecl_built_in_p (callee) &amp;&amp; !optimize</span>
<span class="lineNum">    2492 </span><span class="lineCov">     165695 :             &amp;&amp; DECL_IS_BUILTIN_CONSTANT_P (callee)</span>
<span class="lineNum">    2493 </span><span class="lineCov">        522 :             &amp;&amp; current_function_decl</span>
<span class="lineNum">    2494 </span><span class="lineCov">   18557603 :             &amp;&amp; DECL_DECLARED_CONSTEXPR_P (current_function_decl))</span>
<span class="lineNum">    2495 </span>            :           nw = 1;
<span class="lineNum">    2496 </span>            : 
<span class="lineNum">    2497 </span>            :         /* Defer folding __builtin_is_constant_evaluated.  */
<span class="lineNum">    2498 </span><span class="lineCov">   18556573 :         if (callee</span>
<span class="lineNum">    2499 </span><span class="lineCov">   18556573 :             &amp;&amp; fndecl_built_in_p (callee, CP_BUILT_IN_IS_CONSTANT_EVALUATED,</span>
<span class="lineNum">    2500 </span>            :                                 BUILT_IN_FRONTEND))
<span class="lineNum">    2501 </span>            :           break;
<span class="lineNum">    2502 </span>            : 
<span class="lineNum">    2503 </span><span class="lineCov">   18556555 :         x = copy_node (x);</span>
<span class="lineNum">    2504 </span>            : 
<span class="lineNum">    2505 </span><span class="lineCov">   18556555 :         m = call_expr_nargs (x);</span>
<span class="lineNum">    2506 </span><span class="lineCov">   45968163 :         for (i = 0; i &lt; m; i++)</span>
<span class="lineNum">    2507 </span>            :           {
<span class="lineNum">    2508 </span><span class="lineCov">   27411608 :             r = cp_fold (CALL_EXPR_ARG (x, i));</span>
<span class="lineNum">    2509 </span><span class="lineCov">   27411608 :             if (r != CALL_EXPR_ARG (x, i))</span>
<span class="lineNum">    2510 </span>            :               {
<span class="lineNum">    2511 </span><span class="lineCov">   10207564 :                 if (r == error_mark_node)</span>
<span class="lineNum">    2512 </span>            :                   {
<span class="lineNum">    2513 </span><span class="lineNoCov">          0 :                     x = error_mark_node;</span>
<span class="lineNum">    2514 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">    2515 </span>            :                   }
<span class="lineNum">    2516 </span>            :                 changed = 1;
<span class="lineNum">    2517 </span>            :               }
<span class="lineNum">    2518 </span><span class="lineCov">   54823216 :             CALL_EXPR_ARG (x, i) = r;</span>
<span class="lineNum">    2519 </span>            :           }
<span class="lineNum">    2520 </span><span class="lineCov">   18556555 :         if (x == error_mark_node)</span>
<span class="lineNum">    2521 </span>            :           break;
<span class="lineNum">    2522 </span>            : 
<span class="lineNum">    2523 </span><span class="lineCov">   18556555 :         optimize = nw;</span>
<span class="lineNum">    2524 </span><span class="lineCov">   18556555 :         r = fold (x);</span>
<span class="lineNum">    2525 </span><span class="lineCov">   18556555 :         optimize = sv;</span>
<span class="lineNum">    2526 </span>            : 
<span class="lineNum">    2527 </span><span class="lineCov">   18556555 :         if (TREE_CODE (r) != CALL_EXPR)</span>
<span class="lineNum">    2528 </span>            :           {
<span class="lineNum">    2529 </span><span class="lineCov">      92079 :             x = cp_fold (r);</span>
<span class="lineNum">    2530 </span><span class="lineCov">      92079 :             break;</span>
<span class="lineNum">    2531 </span>            :           }
<span class="lineNum">    2532 </span>            : 
<span class="lineNum">    2533 </span><span class="lineCov">   18464476 :         optimize = nw;</span>
<span class="lineNum">    2534 </span>            : 
<span class="lineNum">    2535 </span>            :         /* Invoke maybe_constant_value for functions declared
<span class="lineNum">    2536 </span>            :            constexpr and not called with AGGR_INIT_EXPRs.
<span class="lineNum">    2537 </span>            :            TODO:
<span class="lineNum">    2538 </span>            :            Do constexpr expansion of expressions where the call itself is not
<span class="lineNum">    2539 </span>            :            constant, but the call followed by an INDIRECT_REF is.  */
<span class="lineNum">    2540 </span><span class="lineCov">   36072270 :         if (callee &amp;&amp; DECL_DECLARED_CONSTEXPR_P (callee)</span>
<span class="lineNum">    2541 </span><span class="lineCov">   21290711 :             &amp;&amp; !flag_no_inline)</span>
<span class="lineNum">    2542 </span><span class="lineCov">    2792239 :           r = maybe_constant_value (x);</span>
<span class="lineNum">    2543 </span><span class="lineCov">   18464476 :         optimize = sv;</span>
<span class="lineNum">    2544 </span>            : 
<span class="lineNum">    2545 </span><span class="lineCov">   18464476 :         if (TREE_CODE (r) != CALL_EXPR)</span>
<span class="lineNum">    2546 </span>            :           {
<span class="lineNum">    2547 </span><span class="lineCov">     135175 :             if (DECL_CONSTRUCTOR_P (callee))</span>
<span class="lineNum">    2548 </span>            :               {
<span class="lineNum">    2549 </span><span class="lineNoCov">          0 :                 loc = EXPR_LOCATION (x);</span>
<span class="lineNum">    2550 </span><span class="lineNoCov">          0 :                 tree s = build_fold_indirect_ref_loc (loc,</span>
<span class="lineNum">    2551 </span><span class="lineNoCov">          0 :                                                       CALL_EXPR_ARG (x, 0));</span>
<span class="lineNum">    2552 </span><span class="lineNoCov">          0 :                 r = build2_loc (loc, INIT_EXPR, TREE_TYPE (s), s, r);</span>
<span class="lineNum">    2553 </span>            :               }
<span class="lineNum">    2554 </span><span class="lineCov">     135175 :             x = r;</span>
<span class="lineNum">    2555 </span><span class="lineCov">     135175 :             break;</span>
<span class="lineNum">    2556 </span>            :           }
<span class="lineNum">    2557 </span>            : 
<span class="lineNum">    2558 </span><span class="lineCov">   18329301 :         if (!changed)</span>
<span class="lineNum">    2559 </span><span class="lineCov">   11075889 :           x = org_x;</span>
<span class="lineNum">    2560 </span>            :         break;
<span class="lineNum">    2561 </span>            :       }
<span class="lineNum">    2562 </span>            : 
<span class="lineNum">    2563 </span><span class="lineCov">    4011576 :     case CONSTRUCTOR:</span>
<span class="lineNum">    2564 </span><span class="lineCov">    4011576 :       {</span>
<span class="lineNum">    2565 </span><span class="lineCov">    4011576 :         unsigned i;</span>
<span class="lineNum">    2566 </span><span class="lineCov">    4011576 :         constructor_elt *p;</span>
<span class="lineNum">    2567 </span><span class="lineCov">    4011576 :         vec&lt;constructor_elt, va_gc&gt; *elts = CONSTRUCTOR_ELTS (x);</span>
<span class="lineNum">    2568 </span><span class="lineCov">    4011576 :         vec&lt;constructor_elt, va_gc&gt; *nelts = NULL;</span>
<span class="lineNum">    2569 </span><span class="lineCov">    5599241 :         FOR_EACH_VEC_SAFE_ELT (elts, i, p)</span>
<span class="lineNum">    2570 </span>            :           {
<span class="lineNum">    2571 </span><span class="lineCov">    1587665 :             tree op = cp_fold (p-&gt;value);</span>
<span class="lineNum">    2572 </span><span class="lineCov">    1587665 :             if (op != p-&gt;value)</span>
<span class="lineNum">    2573 </span>            :               {
<span class="lineNum">    2574 </span><span class="lineCov">      46935 :                 if (op == error_mark_node)</span>
<span class="lineNum">    2575 </span>            :                   {
<span class="lineNum">    2576 </span><span class="lineNoCov">          0 :                     x = error_mark_node;</span>
<span class="lineNum">    2577 </span><span class="lineNoCov">          0 :                     vec_free (nelts);</span>
<span class="lineNum">    2578 </span>            :                     break;
<span class="lineNum">    2579 </span>            :                   }
<span class="lineNum">    2580 </span><span class="lineCov">      46935 :                 if (nelts == NULL)</span>
<span class="lineNum">    2581 </span><span class="lineCov">      21026 :                   nelts = elts-&gt;copy ();</span>
<span class="lineNum">    2582 </span><span class="lineCov">      46935 :                 (*nelts)[i].value = op;</span>
<span class="lineNum">    2583 </span>            :               }
<span class="lineNum">    2584 </span>            :           }
<span class="lineNum">    2585 </span><span class="lineCov">    4011576 :         if (nelts)</span>
<span class="lineNum">    2586 </span>            :           {
<span class="lineNum">    2587 </span><span class="lineCov">      21026 :             x = build_constructor (TREE_TYPE (x), nelts);</span>
<span class="lineNum">    2588 </span><span class="lineCov">      21026 :             CONSTRUCTOR_PLACEHOLDER_BOUNDARY (x)</span>
<span class="lineNum">    2589 </span><span class="lineCov">      21026 :               = CONSTRUCTOR_PLACEHOLDER_BOUNDARY (org_x);</span>
<span class="lineNum">    2590 </span>            :           }
<span class="lineNum">    2591 </span><span class="lineCov">    4011576 :         if (VECTOR_TYPE_P (TREE_TYPE (x)))</span>
<span class="lineNum">    2592 </span><span class="lineCov">      16371 :           x = fold (x);</span>
<span class="lineNum">    2593 </span>            :         break;
<span class="lineNum">    2594 </span>            :       }
<span class="lineNum">    2595 </span><span class="lineCov">       6971 :     case TREE_VEC:</span>
<span class="lineNum">    2596 </span><span class="lineCov">       6971 :       {</span>
<span class="lineNum">    2597 </span><span class="lineCov">       6971 :         bool changed = false;</span>
<span class="lineNum">    2598 </span><span class="lineCov">       6971 :         vec&lt;tree, va_gc&gt; *vec = make_tree_vector ();</span>
<span class="lineNum">    2599 </span><span class="lineCov">       6971 :         int i, n = TREE_VEC_LENGTH (x);</span>
<span class="lineNum">    2600 </span><span class="lineCov">       6971 :         vec_safe_reserve (vec, n);</span>
<span class="lineNum">    2601 </span>            : 
<span class="lineNum">    2602 </span><span class="lineCov">      16062 :         for (i = 0; i &lt; n; i++)</span>
<span class="lineNum">    2603 </span>            :           {
<span class="lineNum">    2604 </span><span class="lineCov">       9091 :             tree op = cp_fold (TREE_VEC_ELT (x, i));</span>
<span class="lineNum">    2605 </span><span class="lineCov">       9091 :             vec-&gt;quick_push (op);</span>
<span class="lineNum">    2606 </span><span class="lineCov">       9091 :             if (op != TREE_VEC_ELT (x, i))</span>
<span class="lineNum">    2607 </span><span class="lineCov">        396 :               changed = true;</span>
<span class="lineNum">    2608 </span>            :           }
<span class="lineNum">    2609 </span>            : 
<span class="lineNum">    2610 </span><span class="lineCov">       6971 :         if (changed)</span>
<span class="lineNum">    2611 </span>            :           {
<span class="lineNum">    2612 </span><span class="lineCov">        392 :             r = copy_node (x);</span>
<span class="lineNum">    2613 </span><span class="lineCov">       1008 :             for (i = 0; i &lt; n; i++)</span>
<span class="lineNum">    2614 </span><span class="lineCov">        616 :               TREE_VEC_ELT (r, i) = (*vec)[i];</span>
<span class="lineNum">    2615 </span><span class="lineCov">        392 :             x = r;</span>
<span class="lineNum">    2616 </span>            :           }
<span class="lineNum">    2617 </span>            : 
<span class="lineNum">    2618 </span><span class="lineCov">       6971 :         release_tree_vector (vec);</span>
<span class="lineNum">    2619 </span>            :       }
<span class="lineNum">    2620 </span>            : 
<span class="lineNum">    2621 </span><span class="lineCov">       6971 :       break;</span>
<span class="lineNum">    2622 </span>            : 
<span class="lineNum">    2623 </span><span class="lineCov">     303952 :     case ARRAY_REF:</span>
<span class="lineNum">    2624 </span><span class="lineCov">     303952 :     case ARRAY_RANGE_REF:</span>
<span class="lineNum">    2625 </span>            : 
<span class="lineNum">    2626 </span><span class="lineCov">     303952 :       loc = EXPR_LOCATION (x);</span>
<span class="lineNum">    2627 </span><span class="lineCov">     303952 :       op0 = cp_fold (TREE_OPERAND (x, 0));</span>
<span class="lineNum">    2628 </span><span class="lineCov">     303952 :       op1 = cp_fold (TREE_OPERAND (x, 1));</span>
<span class="lineNum">    2629 </span><span class="lineCov">     303952 :       op2 = cp_fold (TREE_OPERAND (x, 2));</span>
<span class="lineNum">    2630 </span><span class="lineCov">     303952 :       op3 = cp_fold (TREE_OPERAND (x, 3));</span>
<span class="lineNum">    2631 </span>            : 
<span class="lineNum">    2632 </span><span class="lineCov">     303952 :       if (op0 != TREE_OPERAND (x, 0)</span>
<span class="lineNum">    2633 </span><span class="lineCov">     301171 :           || op1 != TREE_OPERAND (x, 1)</span>
<span class="lineNum">    2634 </span><span class="lineCov">     295999 :           || op2 != TREE_OPERAND (x, 2)</span>
<span class="lineNum">    2635 </span><span class="lineCov">     599951 :           || op3 != TREE_OPERAND (x, 3))</span>
<span class="lineNum">    2636 </span>            :         {
<span class="lineNum">    2637 </span><span class="lineCov">       7953 :           if (op0 == error_mark_node</span>
<span class="lineNum">    2638 </span><span class="lineCov">       7953 :               || op1 == error_mark_node</span>
<span class="lineNum">    2639 </span><span class="lineCov">       7953 :               || op2 == error_mark_node</span>
<span class="lineNum">    2640 </span><span class="lineCov">       7953 :               || op3 == error_mark_node)</span>
<span class="lineNum">    2641 </span><span class="lineNoCov">          0 :             x = error_mark_node;</span>
<span class="lineNum">    2642 </span>            :           else
<span class="lineNum">    2643 </span>            :             {
<span class="lineNum">    2644 </span><span class="lineCov">       7953 :               x = build4_loc (loc, code, TREE_TYPE (x), op0, op1, op2, op3);</span>
<span class="lineNum">    2645 </span><span class="lineCov">       7953 :               TREE_READONLY (x) = TREE_READONLY (org_x);</span>
<span class="lineNum">    2646 </span><span class="lineCov">       7953 :               TREE_SIDE_EFFECTS (x) = TREE_SIDE_EFFECTS (org_x);</span>
<span class="lineNum">    2647 </span><span class="lineCov">       7953 :               TREE_THIS_VOLATILE (x) = TREE_THIS_VOLATILE (org_x);</span>
<span class="lineNum">    2648 </span>            :             }
<span class="lineNum">    2649 </span>            :         }
<span class="lineNum">    2650 </span>            : 
<span class="lineNum">    2651 </span><span class="lineCov">     303952 :       x = fold (x);</span>
<span class="lineNum">    2652 </span><span class="lineCov">     303952 :       break;</span>
<span class="lineNum">    2653 </span>            : 
<span class="lineNum">    2654 </span><span class="lineCov">     108444 :     case SAVE_EXPR:</span>
<span class="lineNum">    2655 </span>            :       /* A SAVE_EXPR might contain e.g. (0 * i) + (0 * j), which, after
<span class="lineNum">    2656 </span>            :          folding, evaluates to an invariant.  In that case no need to wrap
<span class="lineNum">    2657 </span>            :          this folded tree with a SAVE_EXPR.  */
<span class="lineNum">    2658 </span><span class="lineCov">     108444 :       r = cp_fold (TREE_OPERAND (x, 0));</span>
<span class="lineNum">    2659 </span><span class="lineCov">     108444 :       if (tree_invariant_p (r))</span>
<span class="lineNum">    2660 </span><span class="lineCov">         23 :         x = r;</span>
<span class="lineNum">    2661 </span>            :       break;
<span class="lineNum">    2662 </span>            : 
<span class="lineNum">    2663 </span><span class="lineCov">   98192613 :     default:</span>
<span class="lineNum">    2664 </span><span class="lineCov">   98192613 :       return org_x;</span>
<span class="lineNum">    2665 </span>            :     }
<span class="lineNum">    2666 </span>            : 
<span class="lineNum">    2667 </span><span class="lineCov">  158616971 :   fold_cache-&gt;put (org_x, x);</span>
<span class="lineNum">    2668 </span>            :   /* Prevent that we try to fold an already folded result again.  */
<span class="lineNum">    2669 </span><span class="lineCov">  158616971 :   if (x != org_x)</span>
<span class="lineNum">    2670 </span><span class="lineCov">   40838799 :     fold_cache-&gt;put (x, x);</span>
<span class="lineNum">    2671 </span>            : 
<span class="lineNum">    2672 </span><span class="lineCov">  158616971 :   return x;</span>
<span class="lineNum">    2673 </span>            : }
<span class="lineNum">    2674 </span>            : 
<span class="lineNum">    2675 </span>            : #include &quot;gt-cp-cp-gimplify.h&quot;
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.0</a></td></tr>
  </table>
  <br>
<h3>LCOV profile is generated on x86_64 machine using following configure options: configure --disable-bootstrap --enable-coverage=opt --enable-languages=c,c++,fortran,go,jit,lto --enable-host-shared. GCC test suite is run with the built compiler.</h3></body></html>
