<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - gcc.info - gcc/go/gofrontend/wb.cc</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">gcc/go/gofrontend</a> - wb.cc<span style="font-size: 80%;"> (source / <a href="wb.cc.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">gcc.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">339</td>
            <td class="headerCovTableEntry">347</td>
            <td class="headerCovTableEntryHi">97.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-09-22 10:58:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">16</td>
            <td class="headerCovTableEntry">16</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // wb.cc -- Add write barriers as needed.</a>
<span class="lineNum">       2 </span>            : 
<span class="lineNum">       3 </span>            : // Copyright 2017 The Go Authors. All rights reserved.
<span class="lineNum">       4 </span>            : // Use of this source code is governed by a BSD-style
<span class="lineNum">       5 </span>            : // license that can be found in the LICENSE file.
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : #include &quot;go-system.h&quot;
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #include &quot;go-c.h&quot;
<span class="lineNum">      10 </span>            : #include &quot;go-diagnostics.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;operator.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;lex.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;types.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;expressions.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;statements.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;runtime.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;gogo.h&quot;
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : // Mark variables whose addresses are taken and do some other
<span class="lineNum">      20 </span>            : // cleanups.  This has to be done before the write barrier pass and
<span class="lineNum">      21 </span>            : // after the escape analysis pass.  It would be nice to do this
<span class="lineNum">      22 </span>            : // elsewhere but there isn't an obvious place.
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span><span class="lineCov">       2629 : class Mark_address_taken : public Traverse</span>
<span class="lineNum">      25 </span>            : {
<span class="lineNum">      26 </span>            :  public:
<span class="lineNum">      27 </span>            :   Mark_address_taken(Gogo* gogo)
<span class="lineNum">      28 </span><span class="lineCov">       2629 :     : Traverse(traverse_functions</span>
<span class="lineNum">      29 </span>            :                | traverse_statements
<span class="lineNum">      30 </span>            :                | traverse_expressions),
<span class="lineNum">      31 </span><span class="lineCov">       5258 :       gogo_(gogo), function_(NULL)</span>
<span class="lineNum">      32 </span>            :   { }
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span>            :   int
<span class="lineNum">      35 </span>            :   function(Named_object*);
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            :   int
<span class="lineNum">      38 </span>            :   statement(Block*, size_t*, Statement*);
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span>            :   int
<span class="lineNum">      41 </span>            :   expression(Expression**);
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            :  private:
<span class="lineNum">      44 </span>            :   // General IR.
<span class="lineNum">      45 </span>            :   Gogo* gogo_;
<span class="lineNum">      46 </span>            :   // The function we are traversing.
<span class="lineNum">      47 </span>            :   Named_object* function_;
<span class="lineNum">      48 </span>            : };
<span class="lineNum">      49 </span>            : 
<span class="lineNum">      50 </span>            : // Record a function.
<a name="51"><span class="lineNum">      51 </span>            : </a>
<span class="lineNum">      52 </span>            : int
<span class="lineNum">      53 </span><span class="lineCov">     190181 : Mark_address_taken::function(Named_object* no)</span>
<span class="lineNum">      54 </span>            : {
<span class="lineNum">      55 </span><span class="lineCov">     190181 :   go_assert(this-&gt;function_ == NULL);</span>
<span class="lineNum">      56 </span><span class="lineCov">     190181 :   this-&gt;function_ = no;</span>
<span class="lineNum">      57 </span><span class="lineCov">     190181 :   int t = no-&gt;func_value()-&gt;traverse(this);</span>
<span class="lineNum">      58 </span><span class="lineCov">     190181 :   this-&gt;function_ = NULL;</span>
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span><span class="lineCov">     190181 :   if (t == TRAVERSE_EXIT)</span>
<span class="lineNum">      61 </span><span class="lineNoCov">          0 :     return t;</span>
<span class="lineNum">      62 </span>            :   return TRAVERSE_SKIP_COMPONENTS;
<span class="lineNum">      63 </span>            : }
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span>            : // Traverse a statement.
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span>            : int
<span class="lineNum">      68 </span><span class="lineCov">    3636318 : Mark_address_taken::statement(Block* block, size_t* pindex, Statement* s)</span>
<span class="lineNum">      69 </span>            : {
<span class="lineNum">      70 </span>            :   // If this is an assignment of the form s = append(s, ...), expand
<span class="lineNum">      71 </span>            :   // it now, so that we can assign it to the left hand side in the
<span class="lineNum">      72 </span>            :   // middle of the expansion and possibly skip a write barrier.
<span class="lineNum">      73 </span><span class="lineCov">    3636318 :   Assignment_statement* as = s-&gt;assignment_statement();</span>
<span class="lineNum">      74 </span><span class="lineCov">    2053575 :   if (as != NULL &amp;&amp; !as-&gt;lhs()-&gt;is_sink_expression())</span>
<span class="lineNum">      75 </span>            :     {
<span class="lineNum">      76 </span><span class="lineCov">    1363132 :       Call_expression* rce = as-&gt;rhs()-&gt;call_expression();</span>
<span class="lineNum">      77 </span><span class="lineCov">      78603 :       if (rce != NULL</span>
<span class="lineNum">      78 </span><span class="lineCov">      78603 :           &amp;&amp; rce-&gt;builtin_call_expression() != NULL</span>
<span class="lineNum">      79 </span><span class="lineCov">      29547 :           &amp;&amp; (rce-&gt;builtin_call_expression()-&gt;code()</span>
<span class="lineNum">      80 </span>            :               == Builtin_call_expression::BUILTIN_APPEND)
<span class="lineNum">      81 </span><span class="lineCov">      38528 :           &amp;&amp; Expression::is_same_variable(as-&gt;lhs(), rce-&gt;args()-&gt;front()))</span>
<span class="lineNum">      82 </span>            :         {
<span class="lineNum">      83 </span><span class="lineCov">       8630 :           Statement_inserter inserter = Statement_inserter(block, pindex);</span>
<span class="lineNum">      84 </span><span class="lineCov">       8630 :           Expression* a =</span>
<span class="lineNum">      85 </span><span class="lineCov">      25890 :             rce-&gt;builtin_call_expression()-&gt;flatten_append(this-&gt;gogo_,</span>
<span class="lineNum">      86 </span>            :                                                            this-&gt;function_,
<span class="lineNum">      87 </span>            :                                                            &amp;inserter,
<span class="lineNum">      88 </span>            :                                                            as-&gt;lhs(),
<span class="lineNum">      89 </span>            :                                                            block);
<span class="lineNum">      90 </span><span class="lineCov">       8630 :           go_assert(a == NULL);</span>
<span class="lineNum">      91 </span>            :           // That does the assignment, so remove this statement.
<span class="lineNum">      92 </span><span class="lineCov">      17260 :           Expression* e = Expression::make_boolean(true, s-&gt;location());</span>
<span class="lineNum">      93 </span><span class="lineCov">       8630 :           Statement* dummy = Statement::make_statement(e, true);</span>
<span class="lineNum">      94 </span><span class="lineCov">       8630 :           block-&gt;replace_statement(*pindex, dummy);</span>
<span class="lineNum">      95 </span>            :         }
<span class="lineNum">      96 </span>            :     }
<span class="lineNum">      97 </span><span class="lineCov">    3636318 :   return TRAVERSE_CONTINUE;</span>
<span class="lineNum">      98 </span>            : }
<span class="lineNum">      99 </span>            : 
<span class="lineNum">     100 </span>            : // Mark variable addresses taken.
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            : int
<span class="lineNum">     103 </span><span class="lineCov">    9532698 : Mark_address_taken::expression(Expression** pexpr)</span>
<span class="lineNum">     104 </span>            : {
<span class="lineNum">     105 </span><span class="lineCov">    9532698 :   Expression* expr = *pexpr;</span>
<span class="lineNum">     106 </span><span class="lineCov">    9532698 :   Unary_expression* ue = expr-&gt;unary_expression();</span>
<span class="lineNum">     107 </span><span class="lineCov">     582889 :   if (ue != NULL)</span>
<span class="lineNum">     108 </span><span class="lineCov">     582889 :     ue-&gt;check_operand_address_taken(this-&gt;gogo_);</span>
<span class="lineNum">     109 </span>            : 
<span class="lineNum">     110 </span><span class="lineCov">    9532698 :   Array_index_expression* aie = expr-&gt;array_index_expression();</span>
<span class="lineNum">     111 </span><span class="lineCov">     139403 :   if (aie != NULL</span>
<span class="lineNum">     112 </span><span class="lineCov">     278806 :       &amp;&amp; aie-&gt;end() != NULL</span>
<span class="lineNum">     113 </span><span class="lineCov">      63206 :       &amp;&amp; !aie-&gt;array()-&gt;type()-&gt;is_slice_type())</span>
<span class="lineNum">     114 </span>            :     {
<span class="lineNum">     115 </span>            :       // Slice of an array. The escape analysis models this with
<span class="lineNum">     116 </span>            :       // a child Node representing the address of the array.
<span class="lineNum">     117 </span><span class="lineCov">      11949 :       bool escapes = false;</span>
<span class="lineNum">     118 </span><span class="lineCov">      11949 :       Node* n = Node::make_node(expr);</span>
<span class="lineNum">     119 </span><span class="lineCov">      11949 :       if (n-&gt;child() == NULL</span>
<span class="lineNum">     120 </span><span class="lineCov">      11949 :           || (n-&gt;child()-&gt;encoding() &amp; ESCAPE_MASK) != Node::ESCAPE_NONE)</span>
<span class="lineNum">     121 </span>            :         escapes = true;
<span class="lineNum">     122 </span><span class="lineCov">      23898 :       aie-&gt;array()-&gt;address_taken(escapes);</span>
<span class="lineNum">     123 </span>            :     }
<span class="lineNum">     124 </span>            : 
<span class="lineNum">     125 </span><span class="lineCov">    9532698 :   if (expr-&gt;allocation_expression() != NULL)</span>
<span class="lineNum">     126 </span>            :     {
<span class="lineNum">     127 </span><span class="lineCov">       5913 :       Node* n = Node::make_node(expr);</span>
<span class="lineNum">     128 </span><span class="lineCov">       5913 :       if ((n-&gt;encoding() &amp; ESCAPE_MASK) == Node::ESCAPE_NONE)</span>
<span class="lineNum">     129 </span><span class="lineCov">       1097 :         expr-&gt;allocation_expression()-&gt;set_allocate_on_stack();</span>
<span class="lineNum">     130 </span>            :     }
<span class="lineNum">     131 </span><span class="lineCov">    9532698 :   if (expr-&gt;heap_expression() != NULL)</span>
<span class="lineNum">     132 </span>            :     {
<span class="lineNum">     133 </span><span class="lineCov">      32761 :       Node* n = Node::make_node(expr);</span>
<span class="lineNum">     134 </span><span class="lineCov">      32761 :       if ((n-&gt;encoding() &amp; ESCAPE_MASK) == Node::ESCAPE_NONE)</span>
<span class="lineNum">     135 </span><span class="lineCov">       3688 :         expr-&gt;heap_expression()-&gt;set_allocate_on_stack();</span>
<span class="lineNum">     136 </span>            :     }
<span class="lineNum">     137 </span><span class="lineCov">    9532698 :   if (expr-&gt;slice_literal() != NULL)</span>
<span class="lineNum">     138 </span>            :     {
<span class="lineNum">     139 </span><span class="lineCov">      71763 :       Node* n = Node::make_node(expr);</span>
<span class="lineNum">     140 </span><span class="lineCov">      71763 :       if ((n-&gt;encoding() &amp; ESCAPE_MASK) == Node::ESCAPE_NONE)</span>
<span class="lineNum">     141 </span><span class="lineCov">      22247 :         expr-&gt;slice_literal()-&gt;set_storage_does_not_escape();</span>
<span class="lineNum">     142 </span>            :     }
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span>            :   // Rewrite non-escaping makeslice with constant size to stack allocation.
<span class="lineNum">     145 </span><span class="lineCov">    9532698 :   Unsafe_type_conversion_expression* uce =</span>
<span class="lineNum">     146 </span><span class="lineCov">    9532698 :     expr-&gt;unsafe_conversion_expression();</span>
<span class="lineNum">     147 </span><span class="lineCov">      61545 :   if (uce != NULL</span>
<span class="lineNum">     148 </span><span class="lineCov">      61545 :       &amp;&amp; uce-&gt;type()-&gt;is_slice_type()</span>
<span class="lineNum">     149 </span><span class="lineCov">      12928 :       &amp;&amp; Node::make_node(uce-&gt;expr())-&gt;encoding() == Node::ESCAPE_NONE</span>
<span class="lineNum">     150 </span><span class="lineCov">       1672 :       &amp;&amp; uce-&gt;expr()-&gt;call_expression() != NULL)</span>
<span class="lineNum">     151 </span>            :     {
<span class="lineNum">     152 </span><span class="lineCov">       1672 :       Call_expression* call = uce-&gt;expr()-&gt;call_expression();</span>
<span class="lineNum">     153 </span><span class="lineCov">       1672 :       if (call-&gt;fn()-&gt;func_expression() != NULL</span>
<span class="lineNum">     154 </span><span class="lineCov">       3344 :           &amp;&amp; call-&gt;fn()-&gt;func_expression()-&gt;runtime_code() == Runtime::MAKESLICE)</span>
<span class="lineNum">     155 </span>            :         {
<span class="lineNum">     156 </span><span class="lineCov">       1658 :           Expression* len_arg = call-&gt;args()-&gt;at(1);</span>
<span class="lineNum">     157 </span><span class="lineCov">       1658 :           Expression* cap_arg = call-&gt;args()-&gt;at(2);</span>
<span class="lineNum">     158 </span><span class="lineCov">       1658 :           Numeric_constant nclen;</span>
<span class="lineNum">     159 </span><span class="lineCov">       1658 :           Numeric_constant nccap;</span>
<span class="lineNum">     160 </span><span class="lineCov">        829 :           unsigned long vlen;</span>
<span class="lineNum">     161 </span><span class="lineCov">        829 :           unsigned long vcap;</span>
<span class="lineNum">     162 </span><span class="lineCov">        829 :           if (len_arg-&gt;numeric_constant_value(&amp;nclen)</span>
<span class="lineNum">     163 </span><span class="lineCov">        323 :               &amp;&amp; cap_arg-&gt;numeric_constant_value(&amp;nccap)</span>
<span class="lineNum">     164 </span><span class="lineCov">        311 :               &amp;&amp; nclen.to_unsigned_long(&amp;vlen) == Numeric_constant::NC_UL_VALID</span>
<span class="lineNum">     165 </span><span class="lineCov">       1140 :               &amp;&amp; nccap.to_unsigned_long(&amp;vcap) == Numeric_constant::NC_UL_VALID)</span>
<span class="lineNum">     166 </span>            :             {
<span class="lineNum">     167 </span>            :               // Turn it into a slice expression of an addressable array,
<span class="lineNum">     168 </span>            :               // which is allocated on stack.
<span class="lineNum">     169 </span><span class="lineCov">        311 :               Location loc = expr-&gt;location();</span>
<span class="lineNum">     170 </span><span class="lineCov">        622 :               Type* elmt_type = expr-&gt;type()-&gt;array_type()-&gt;element_type();</span>
<span class="lineNum">     171 </span><span class="lineCov">        311 :               Expression* len_expr =</span>
<span class="lineNum">     172 </span><span class="lineCov">        311 :                 Expression::make_integer_ul(vcap, cap_arg-&gt;type(), loc);</span>
<span class="lineNum">     173 </span><span class="lineCov">        311 :               Type* array_type = Type::make_array_type(elmt_type, len_expr);</span>
<span class="lineNum">     174 </span><span class="lineCov">        311 :               Expression* alloc = Expression::make_allocation(array_type, loc);</span>
<span class="lineNum">     175 </span><span class="lineCov">        311 :               alloc-&gt;allocation_expression()-&gt;set_allocate_on_stack();</span>
<span class="lineNum">     176 </span><span class="lineCov">        311 :               Expression* array = Expression::make_unary(OPERATOR_MULT, alloc, loc);</span>
<span class="lineNum">     177 </span><span class="lineCov">        311 :               Expression* zero = Expression::make_integer_ul(0, len_arg-&gt;type(), loc);</span>
<span class="lineNum">     178 </span><span class="lineCov">        311 :               Expression* slice =</span>
<span class="lineNum">     179 </span><span class="lineCov">        311 :                 Expression::make_array_index(array, zero, len_arg, cap_arg, loc);</span>
<span class="lineNum">     180 </span><span class="lineCov">        311 :               *pexpr = slice;</span>
<span class="lineNum">     181 </span>            :             }
<span class="lineNum">     182 </span>            :         }
<span class="lineNum">     183 </span>            :     }
<span class="lineNum">     184 </span><span class="lineCov">    9532698 :   return TRAVERSE_CONTINUE;</span>
<span class="lineNum">     185 </span>            : }
<span class="lineNum">     186 </span>            : 
<span class="lineNum">     187 </span>            : // Check variables and closures do not escape when compiling runtime.
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span><span class="lineCov">          7 : class Check_escape : public Traverse</span>
<span class="lineNum">     190 </span>            : {
<span class="lineNum">     191 </span>            :  public:
<span class="lineNum">     192 </span>            :   Check_escape(Gogo* gogo)
<span class="lineNum">     193 </span><span class="lineCov">          7 :     : Traverse(traverse_expressions | traverse_variables),</span>
<span class="lineNum">     194 </span><span class="lineCov">         14 :       gogo_(gogo)</span>
<span class="lineNum">     195 </span>            :   { }
<span class="lineNum">     196 </span>            : 
<span class="lineNum">     197 </span>            :   int
<span class="lineNum">     198 </span>            :   expression(Expression**);
<span class="lineNum">     199 </span>            : 
<span class="lineNum">     200 </span>            :   int
<span class="lineNum">     201 </span>            :   variable(Named_object*);
<span class="lineNum">     202 </span>            : 
<span class="lineNum">     203 </span>            :  private:
<span class="lineNum">     204 </span>            :   Gogo* gogo_;
<span class="lineNum">     205 </span>            : };
<a name="206"><span class="lineNum">     206 </span>            : </a>
<span class="lineNum">     207 </span>            : int
<span class="lineNum">     208 </span><span class="lineCov">      53458 : Check_escape::variable(Named_object* no)</span>
<span class="lineNum">     209 </span>            : {
<span class="lineNum">     210 </span><span class="lineCov">      53458 :   if ((no-&gt;is_variable() &amp;&amp; no-&gt;var_value()-&gt;is_in_heap())</span>
<span class="lineNum">     211 </span><span class="lineCov">     139482 :       || (no-&gt;is_result_variable()</span>
<span class="lineNum">     212 </span><span class="lineCov">      20892 :           &amp;&amp; no-&gt;result_var_value()-&gt;is_in_heap()))</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :     go_error_at(no-&gt;location(),</span>
<span class="lineNum">     214 </span>            :                 &quot;%s escapes to heap, not allowed in runtime&quot;,
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :                 no-&gt;message_name().c_str());</span>
<span class="lineNum">     216 </span><span class="lineCov">      53458 :   return TRAVERSE_CONTINUE;</span>
<span class="lineNum">     217 </span>            : }
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span>            : int
<span class="lineNum">     220 </span><span class="lineCov">     678007 : Check_escape::expression(Expression** pexpr)</span>
<span class="lineNum">     221 </span>            : {
<span class="lineNum">     222 </span><span class="lineCov">     678007 :   Expression* expr = *pexpr;</span>
<span class="lineNum">     223 </span><span class="lineCov">     678007 :   Func_expression* fe = expr-&gt;func_expression();</span>
<span class="lineNum">     224 </span><span class="lineCov">     104380 :   if (fe != NULL &amp;&amp; fe-&gt;closure() != NULL)</span>
<span class="lineNum">     225 </span>            :     {
<span class="lineNum">     226 </span><span class="lineCov">        314 :       Node* n = Node::make_node(expr);</span>
<span class="lineNum">     227 </span><span class="lineCov">        314 :       if (n-&gt;encoding() == Node::ESCAPE_HEAP)</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :         go_error_at(expr-&gt;location(),</span>
<span class="lineNum">     229 </span>            :                     &quot;heap-allocated closure, not allowed in runtime&quot;);
<span class="lineNum">     230 </span>            :     }
<span class="lineNum">     231 </span><span class="lineCov">     678007 :   return TRAVERSE_CONTINUE;</span>
<span class="lineNum">     232 </span>            : }
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span>            : // Collect all writebarrierrec functions.  This is used when compiling
<span class="lineNum">     235 </span>            : // the runtime package, to propagate //go:nowritebarrierrec.
<span class="lineNum">     236 </span>            : 
<span class="lineNum">     237 </span><span class="lineCov">         14 : class Collect_writebarrierrec_functions : public Traverse</span>
<span class="lineNum">     238 </span>            : {
<span class="lineNum">     239 </span>            :  public:
<span class="lineNum">     240 </span>            :   Collect_writebarrierrec_functions(std::vector&lt;Named_object*&gt;* worklist)
<span class="lineNum">     241 </span><span class="lineCov">          7 :     : Traverse(traverse_functions),</span>
<span class="lineNum">     242 </span><span class="lineCov">         14 :       worklist_(worklist)</span>
<span class="lineNum">     243 </span>            :   { }
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span>            :  private:
<span class="lineNum">     246 </span>            :   int
<span class="lineNum">     247 </span>            :   function(Named_object*);
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span>            :   // The collected functions are put here.
<span class="lineNum">     250 </span>            :   std::vector&lt;Named_object*&gt;* worklist_;
<span class="lineNum">     251 </span>            : };
<a name="252"><span class="lineNum">     252 </span>            : </a>
<span class="lineNum">     253 </span>            : int
<span class="lineNum">     254 </span><span class="lineCov">      14876 : Collect_writebarrierrec_functions::function(Named_object* no)</span>
<span class="lineNum">     255 </span>            : {
<span class="lineNum">     256 </span><span class="lineCov">      14876 :   if (no-&gt;is_function()</span>
<span class="lineNum">     257 </span><span class="lineCov">      44628 :       &amp;&amp; no-&gt;func_value()-&gt;enclosing() == NULL</span>
<span class="lineNum">     258 </span><span class="lineCov">      58154 :       &amp;&amp; (no-&gt;func_value()-&gt;pragmas() &amp; GOPRAGMA_NOWRITEBARRIERREC) != 0)</span>
<span class="lineNum">     259 </span>            :     {
<span class="lineNum">     260 </span><span class="lineCov">       1302 :       go_assert((no-&gt;func_value()-&gt;pragmas() &amp; GOPRAGMA_MARK) == 0);</span>
<span class="lineNum">     261 </span><span class="lineCov">        434 :       this-&gt;worklist_-&gt;push_back(no);</span>
<span class="lineNum">     262 </span>            :     }
<span class="lineNum">     263 </span><span class="lineCov">      14876 :   return TRAVERSE_CONTINUE;</span>
<span class="lineNum">     264 </span>            : }
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span>            : // Collect all callees of this function.  We only care about locally
<span class="lineNum">     267 </span>            : // defined, known, functions.
<span class="lineNum">     268 </span>            : 
<span class="lineNum">     269 </span><span class="lineCov">         14 : class Collect_callees : public Traverse</span>
<span class="lineNum">     270 </span>            : {
<span class="lineNum">     271 </span>            :  public:
<span class="lineNum">     272 </span>            :   Collect_callees(std::vector&lt;Named_object*&gt;* worklist)
<span class="lineNum">     273 </span><span class="lineCov">          7 :     : Traverse(traverse_expressions),</span>
<span class="lineNum">     274 </span><span class="lineCov">          7 :       worklist_(worklist)</span>
<span class="lineNum">     275 </span>            :   { }
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span>            :  private:
<span class="lineNum">     278 </span>            :   int
<span class="lineNum">     279 </span>            :   expression(Expression**);
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span>            :   // The collected callees are put here.
<span class="lineNum">     282 </span>            :   std::vector&lt;Named_object*&gt;* worklist_;
<span class="lineNum">     283 </span>            : };
<span class="lineNum">     284 </span>            : 
<span class="lineNum">     285 </span>            : int
<span class="lineNum">     286 </span><span class="lineCov">     130059 : Collect_callees::expression(Expression** pexpr)</span>
<span class="lineNum">     287 </span>            : {
<span class="lineNum">     288 </span><span class="lineCov">     130059 :   Call_expression* ce = (*pexpr)-&gt;call_expression();</span>
<span class="lineNum">     289 </span><span class="lineCov">      11095 :   if (ce != NULL)</span>
<span class="lineNum">     290 </span>            :     {
<span class="lineNum">     291 </span><span class="lineCov">      22190 :       Func_expression* fe = ce-&gt;fn()-&gt;func_expression();</span>
<span class="lineNum">     292 </span><span class="lineCov">      11046 :       if (fe != NULL)</span>
<span class="lineNum">     293 </span>            :         {
<span class="lineNum">     294 </span><span class="lineCov">      11046 :           Named_object* no = fe-&gt;named_object();</span>
<span class="lineNum">     295 </span><span class="lineCov">      22092 :           if (no-&gt;package() == NULL &amp;&amp; no-&gt;is_function())</span>
<span class="lineNum">     296 </span>            :             {
<span class="lineNum">     297 </span>            :               // The function runtime.systemstack is special, in that
<span class="lineNum">     298 </span>            :               // it is a common way to call a function in the runtime:
<span class="lineNum">     299 </span>            :               // mark its argument if we can.
<span class="lineNum">     300 </span><span class="lineCov">      15218 :               if (Gogo::unpack_hidden_name(no-&gt;name()) != &quot;systemstack&quot;)</span>
<span class="lineNum">     301 </span><span class="lineCov">       7350 :                 this-&gt;worklist_-&gt;push_back(no);</span>
<span class="lineNum">     302 </span><span class="lineCov">        315 :               else if (ce-&gt;args()-&gt;size() &gt; 0)</span>
<span class="lineNum">     303 </span>            :                 {
<span class="lineNum">     304 </span><span class="lineCov">        315 :                   fe = ce-&gt;args()-&gt;front()-&gt;func_expression();</span>
<span class="lineNum">     305 </span><span class="lineCov">        105 :                   if (fe != NULL)</span>
<span class="lineNum">     306 </span>            :                     {
<span class="lineNum">     307 </span><span class="lineCov">        105 :                       no = fe-&gt;named_object();</span>
<span class="lineNum">     308 </span><span class="lineCov">        210 :                       if (no-&gt;package() == NULL &amp;&amp; no-&gt;is_function())</span>
<span class="lineNum">     309 </span><span class="lineCov">        105 :                         this-&gt;worklist_-&gt;push_back(no);</span>
<span class="lineNum">     310 </span>            :                     }
<span class="lineNum">     311 </span>            :                 }
<span class="lineNum">     312 </span>            :             }
<span class="lineNum">     313 </span>            :         }
<span class="lineNum">     314 </span>            :     }
<span class="lineNum">     315 </span><span class="lineCov">     130059 :   return TRAVERSE_CONTINUE;</span>
<span class="lineNum">     316 </span>            : }
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span>            : // When compiling the runtime package, propagate //go:nowritebarrierrec
<span class="lineNum">     319 </span>            : // annotations.  A function marked as //go:nowritebarrierrec does not
<span class="lineNum">     320 </span>            : // permit write barriers, and also all the functions that it calls,
<span class="lineNum">     321 </span>            : // recursively, do not permit write barriers.  Except that a
<span class="lineNum">     322 </span>            : // //go:yeswritebarrierrec annotation permits write barriers even if
<span class="lineNum">     323 </span>            : // called by a //go:nowritebarrierrec function.  Here we turn
<span class="lineNum">     324 </span>            : // //go:nowritebarrierrec into //go:nowritebarrier, as appropriate.
<a name="325"><span class="lineNum">     325 </span>            : </a>
<span class="lineNum">     326 </span>            : void
<span class="lineNum">     327 </span><span class="lineCov">          7 : Gogo::propagate_writebarrierrec()</span>
<span class="lineNum">     328 </span>            : {
<span class="lineNum">     329 </span><span class="lineCov">          7 :   std::vector&lt;Named_object*&gt; worklist;</span>
<span class="lineNum">     330 </span><span class="lineCov">         14 :   Collect_writebarrierrec_functions cwf(&amp;worklist);</span>
<span class="lineNum">     331 </span><span class="lineCov">          7 :   this-&gt;traverse(&amp;cwf);</span>
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span><span class="lineCov">         14 :   Collect_callees cc(&amp;worklist);</span>
<span class="lineNum">     334 </span>            : 
<span class="lineNum">     335 </span><span class="lineCov">      15792 :   while (!worklist.empty())</span>
<span class="lineNum">     336 </span>            :     {
<span class="lineNum">     337 </span><span class="lineCov">       7889 :       Named_object* no = worklist.back();</span>
<span class="lineNum">     338 </span><span class="lineCov">       7889 :       worklist.pop_back();</span>
<span class="lineNum">     339 </span>            : 
<span class="lineNum">     340 </span><span class="lineCov">       7889 :       unsigned int pragmas = no-&gt;func_value()-&gt;pragmas();</span>
<span class="lineNum">     341 </span><span class="lineCov">       7889 :       if ((pragmas &amp; GOPRAGMA_MARK) != 0)</span>
<span class="lineNum">     342 </span>            :         {
<span class="lineNum">     343 </span>            :           // We've already seen this function.
<span class="lineNum">     344 </span>            :           continue;
<span class="lineNum">     345 </span>            :         }
<span class="lineNum">     346 </span><span class="lineCov">       2373 :       if ((pragmas &amp; GOPRAGMA_YESWRITEBARRIERREC) != 0)</span>
<span class="lineNum">     347 </span>            :         {
<span class="lineNum">     348 </span>            :           // We don't want to propagate //go:nowritebarrierrec into
<span class="lineNum">     349 </span>            :           // this function or it's callees.
<span class="lineNum">     350 </span>            :           continue;
<span class="lineNum">     351 </span>            :         }
<span class="lineNum">     352 </span>            : 
<span class="lineNum">     353 </span><span class="lineCov">       4508 :       no-&gt;func_value()-&gt;set_pragmas(pragmas</span>
<span class="lineNum">     354 </span>            :                                     | GOPRAGMA_NOWRITEBARRIER
<span class="lineNum">     355 </span>            :                                     | GOPRAGMA_MARK);
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span><span class="lineCov">       4508 :       no-&gt;func_value()-&gt;traverse(&amp;cc);</span>
<span class="lineNum">     358 </span>            :     }
<span class="lineNum">     359 </span><span class="lineCov">          7 : }</span>
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span>            : // Add write barriers to the IR.  This are required by the concurrent
<span class="lineNum">     362 </span>            : // garbage collector.  A write barrier is needed for any write of a
<span class="lineNum">     363 </span>            : // pointer into memory controlled by the garbage collector.  Write
<span class="lineNum">     364 </span>            : // barriers are not required for writes to local variables that live
<span class="lineNum">     365 </span>            : // on the stack.  Write barriers are only required when the runtime
<span class="lineNum">     366 </span>            : // enables them, which can be checked using a run time check on
<span class="lineNum">     367 </span>            : // runtime.writeBarrier.enabled.
<span class="lineNum">     368 </span>            : //
<span class="lineNum">     369 </span>            : // Essentially, for each assignment A = B, where A is or contains a
<span class="lineNum">     370 </span>            : // pointer, and where A is not, or at any rate may not be, a stack
<span class="lineNum">     371 </span>            : // variable, we rewrite it into
<span class="lineNum">     372 </span>            : //     if runtime.writeBarrier.enabled {
<span class="lineNum">     373 </span>            : //         typedmemmove(typeof(A), &amp;A, &amp;B)
<span class="lineNum">     374 </span>            : //     } else {
<span class="lineNum">     375 </span>            : //         A = B
<span class="lineNum">     376 </span>            : //     }
<span class="lineNum">     377 </span>            : //
<span class="lineNum">     378 </span>            : // The test of runtime.writeBarrier.Enabled is implemented by treating
<span class="lineNum">     379 </span>            : // the variable as a *uint32, and testing *runtime.writeBarrier != 0.
<span class="lineNum">     380 </span>            : // This is compatible with the definition in the runtime package.
<span class="lineNum">     381 </span>            : //
<span class="lineNum">     382 </span>            : // For types that are pointer shared (pointers, maps, chans, funcs),
<span class="lineNum">     383 </span>            : // we replaced the call to typedmemmove with gcWriteBarrier(&amp;A, B).
<span class="lineNum">     384 </span>            : // As far as the GC is concerned, all pointers are the same, so it
<span class="lineNum">     385 </span>            : // doesn't need the type descriptor.
<span class="lineNum">     386 </span>            : //
<span class="lineNum">     387 </span>            : // There are possible optimizations that are not implemented.
<span class="lineNum">     388 </span>            : //
<span class="lineNum">     389 </span>            : // runtime.writeBarrier can only change when the goroutine is
<span class="lineNum">     390 </span>            : // preempted, which in practice means when a call is made into the
<span class="lineNum">     391 </span>            : // runtime package, so we could optimize by only testing it once
<span class="lineNum">     392 </span>            : // between function calls.
<span class="lineNum">     393 </span>            : //
<span class="lineNum">     394 </span>            : // A slice could be handled with a call to gcWriteBarrier plus two
<span class="lineNum">     395 </span>            : // integer moves.
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span>            : // Traverse the IR adding write barriers.
<span class="lineNum">     398 </span>            : 
<span class="lineNum">     399 </span><span class="lineCov">       2629 : class Write_barriers : public Traverse</span>
<span class="lineNum">     400 </span>            : {
<span class="lineNum">     401 </span>            :  public:
<span class="lineNum">     402 </span>            :   Write_barriers(Gogo* gogo)
<span class="lineNum">     403 </span>            :     : Traverse(traverse_functions | traverse_variables | traverse_statements),
<span class="lineNum">     404 </span><span class="lineCov">       2629 :       gogo_(gogo), function_(NULL), statements_added_()</span>
<span class="lineNum">     405 </span>            :   { }
<span class="lineNum">     406 </span>            : 
<span class="lineNum">     407 </span>            :   int
<span class="lineNum">     408 </span>            :   function(Named_object*);
<span class="lineNum">     409 </span>            : 
<span class="lineNum">     410 </span>            :   int
<span class="lineNum">     411 </span>            :   variable(Named_object*);
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span>            :   int
<span class="lineNum">     414 </span>            :   statement(Block*, size_t* pindex, Statement*);
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span>            :  private:
<span class="lineNum">     417 </span>            :   // General IR.
<span class="lineNum">     418 </span>            :   Gogo* gogo_;
<span class="lineNum">     419 </span>            :   // Current function.
<span class="lineNum">     420 </span>            :   Function* function_;
<span class="lineNum">     421 </span>            :   // Statements introduced.
<span class="lineNum">     422 </span>            :   Statement_inserter::Statements statements_added_;
<span class="lineNum">     423 </span>            : };
<span class="lineNum">     424 </span>            : 
<span class="lineNum">     425 </span>            : // Traverse a function.  Just record it for later.
<a name="426"><span class="lineNum">     426 </span>            : </a>
<span class="lineNum">     427 </span>            : int
<span class="lineNum">     428 </span><span class="lineCov">     190181 : Write_barriers::function(Named_object* no)</span>
<span class="lineNum">     429 </span>            : {
<span class="lineNum">     430 </span><span class="lineCov">     190181 :   go_assert(this-&gt;function_ == NULL);</span>
<span class="lineNum">     431 </span><span class="lineCov">     190181 :   this-&gt;function_ = no-&gt;func_value();</span>
<span class="lineNum">     432 </span><span class="lineCov">     190181 :   int t = this-&gt;function_-&gt;traverse(this);</span>
<span class="lineNum">     433 </span><span class="lineCov">     190181 :   this-&gt;function_ = NULL;</span>
<span class="lineNum">     434 </span>            : 
<span class="lineNum">     435 </span><span class="lineCov">     190181 :   if (t == TRAVERSE_EXIT)</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :     return t;</span>
<span class="lineNum">     437 </span>            :   return TRAVERSE_SKIP_COMPONENTS;
<span class="lineNum">     438 </span>            : }
<span class="lineNum">     439 </span>            : 
<span class="lineNum">     440 </span>            : // Insert write barriers for a global variable: ensure that variable
<span class="lineNum">     441 </span>            : // initialization is handled correctly.  This is rarely needed, since
<span class="lineNum">     442 </span>            : // we currently don't enable background GC until after all global
<span class="lineNum">     443 </span>            : // variables are initialized.  But we do need this if an init function
<span class="lineNum">     444 </span>            : // calls runtime.GC.
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span>            : int
<span class="lineNum">     447 </span><span class="lineCov">     812868 : Write_barriers::variable(Named_object* no)</span>
<span class="lineNum">     448 </span>            : {
<span class="lineNum">     449 </span>            :   // We handle local variables in the variable declaration statement.
<span class="lineNum">     450 </span>            :   // We only have to handle global variables here.
<span class="lineNum">     451 </span><span class="lineCov">    1625736 :   if (!no-&gt;is_variable())</span>
<span class="lineNum">     452 </span>            :     return TRAVERSE_CONTINUE;
<span class="lineNum">     453 </span><span class="lineCov">     656562 :   Variable* var = no-&gt;var_value();</span>
<span class="lineNum">     454 </span><span class="lineCov">    1313124 :   if (!var-&gt;is_global())</span>
<span class="lineNum">     455 </span>            :     return TRAVERSE_CONTINUE;
<span class="lineNum">     456 </span>            : 
<span class="lineNum">     457 </span>            :   // Nothing to do if there is no initializer.
<span class="lineNum">     458 </span><span class="lineCov">      98119 :   Expression* init = var-&gt;init();</span>
<span class="lineNum">     459 </span><span class="lineCov">      98119 :   if (init == NULL)</span>
<span class="lineNum">     460 </span>            :     return TRAVERSE_CONTINUE;
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span>            :   // Nothing to do for variables that do not contain any pointers.
<span class="lineNum">     463 </span><span class="lineCov">      15893 :   if (!var-&gt;type()-&gt;has_pointer())</span>
<span class="lineNum">     464 </span>            :     return TRAVERSE_CONTINUE;
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span>            :   // Nothing to do if the initializer is static.
<span class="lineNum">     467 </span><span class="lineCov">      27992 :   init = Expression::make_cast(var-&gt;type(), init, var-&gt;location());</span>
<span class="lineNum">     468 </span><span class="lineCov">      27992 :   if (!var-&gt;has_pre_init() &amp;&amp; init-&gt;is_static_initializer())</span>
<span class="lineNum">     469 </span>            :     return TRAVERSE_CONTINUE;
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span>            :   // Nothing to do for a type that can not be in the heap, or a
<span class="lineNum">     472 </span>            :   // pointer to a type that can not be in the heap.
<span class="lineNum">     473 </span><span class="lineCov">       9759 :   if (!var-&gt;type()-&gt;in_heap())</span>
<span class="lineNum">     474 </span>            :     return TRAVERSE_CONTINUE;
<span class="lineNum">     475 </span><span class="lineCov">       9759 :   if (var-&gt;type()-&gt;points_to() != NULL &amp;&amp; !var-&gt;type()-&gt;points_to()-&gt;in_heap())</span>
<span class="lineNum">     476 </span>            :     return TRAVERSE_CONTINUE;
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span>            :   // Otherwise change the initializer into a pre_init assignment
<span class="lineNum">     479 </span>            :   // statement with a write barrier.
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span>            :   // We can't check for a dependency of the variable on itself after
<span class="lineNum">     482 </span>            :   // we make this change, because the preinit statement will always
<span class="lineNum">     483 </span>            :   // depend on the variable (since it assigns to it).  So check for a
<span class="lineNum">     484 </span>            :   // self-dependency now.
<span class="lineNum">     485 </span><span class="lineCov">       9759 :   this-&gt;gogo_-&gt;check_self_dep(no);</span>
<span class="lineNum">     486 </span>            : 
<span class="lineNum">     487 </span>            :   // Replace the initializer.
<span class="lineNum">     488 </span><span class="lineCov">       9759 :   Location loc = init-&gt;location();</span>
<span class="lineNum">     489 </span><span class="lineCov">       9759 :   Expression* ref = Expression::make_var_reference(no, loc);</span>
<span class="lineNum">     490 </span>            : 
<span class="lineNum">     491 </span><span class="lineCov">       9759 :   Statement_inserter inserter(this-&gt;gogo_, var, &amp;this-&gt;statements_added_);</span>
<span class="lineNum">     492 </span><span class="lineCov">       9759 :   Statement* s = this-&gt;gogo_-&gt;assign_with_write_barrier(NULL, NULL, &amp;inserter,</span>
<span class="lineNum">     493 </span><span class="lineCov">       9759 :                                                         ref, init, loc);</span>
<span class="lineNum">     494 </span><span class="lineCov">       9759 :   this-&gt;statements_added_.insert(s);</span>
<span class="lineNum">     495 </span>            : 
<span class="lineNum">     496 </span><span class="lineCov">       9759 :   var-&gt;add_preinit_statement(this-&gt;gogo_, s);</span>
<span class="lineNum">     497 </span><span class="lineCov">       9759 :   var-&gt;clear_init();</span>
<span class="lineNum">     498 </span>            : 
<span class="lineNum">     499 </span><span class="lineCov">       9759 :   return TRAVERSE_CONTINUE;</span>
<span class="lineNum">     500 </span>            : }
<span class="lineNum">     501 </span>            : 
<span class="lineNum">     502 </span>            : // Insert write barriers for statements.
<span class="lineNum">     503 </span>            : 
<span class="lineNum">     504 </span>            : int
<span class="lineNum">     505 </span><span class="lineCov">    3760852 : Write_barriers::statement(Block* block, size_t* pindex, Statement* s)</span>
<span class="lineNum">     506 </span>            : {
<span class="lineNum">     507 </span><span class="lineCov">   11282556 :   if (this-&gt;statements_added_.find(s) != this-&gt;statements_added_.end())</span>
<span class="lineNum">     508 </span>            :     return TRAVERSE_SKIP_COMPONENTS;
<span class="lineNum">     509 </span>            : 
<span class="lineNum">     510 </span><span class="lineCov">    7463150 :   switch (s-&gt;classification())</span>
<span class="lineNum">     511 </span>            :     {
<span class="lineNum">     512 </span>            :     default:
<span class="lineNum">     513 </span>            :       break;
<span class="lineNum">     514 </span>            : 
<span class="lineNum">     515 </span><span class="lineCov">     254939 :     case Statement::STATEMENT_VARIABLE_DECLARATION:</span>
<span class="lineNum">     516 </span><span class="lineCov">     254939 :       {</span>
<span class="lineNum">     517 </span><span class="lineCov">     254939 :         Variable_declaration_statement* vds =</span>
<span class="lineNum">     518 </span><span class="lineCov">     254939 :           s-&gt;variable_declaration_statement();</span>
<span class="lineNum">     519 </span><span class="lineCov">     254939 :         Named_object* no = vds-&gt;var();</span>
<span class="lineNum">     520 </span><span class="lineCov">     254939 :         Variable* var = no-&gt;var_value();</span>
<span class="lineNum">     521 </span>            : 
<span class="lineNum">     522 </span>            :         // We may need to emit a write barrier for the initialization
<span class="lineNum">     523 </span>            :         // of the variable.
<span class="lineNum">     524 </span>            : 
<span class="lineNum">     525 </span>            :         // Nothing to do for a variable with no initializer.
<span class="lineNum">     526 </span><span class="lineCov">     254939 :         Expression* init = var-&gt;init();</span>
<span class="lineNum">     527 </span><span class="lineCov">     254939 :         if (init == NULL)</span>
<span class="lineNum">     528 </span>            :           break;
<span class="lineNum">     529 </span>            : 
<span class="lineNum">     530 </span>            :         // Nothing to do if the variable is not in the heap.  Only
<span class="lineNum">     531 </span>            :         // local variables get declaration statements, and local
<span class="lineNum">     532 </span>            :         // variables on the stack do not require write barriers.
<span class="lineNum">     533 </span><span class="lineCov">     198316 :         if (!var-&gt;is_in_heap())</span>
<span class="lineNum">     534 </span>            :           break;
<span class="lineNum">     535 </span>            : 
<span class="lineNum">     536 </span>            :         // Nothing to do if the variable does not contain any pointers.
<span class="lineNum">     537 </span><span class="lineCov">       4967 :         if (!var-&gt;type()-&gt;has_pointer())</span>
<span class="lineNum">     538 </span>            :           break;
<span class="lineNum">     539 </span>            : 
<span class="lineNum">     540 </span>            :         // Nothing to do for a type that can not be in the heap, or a
<span class="lineNum">     541 </span>            :         // pointer to a type that can not be in the heap.
<span class="lineNum">     542 </span><span class="lineCov">       4059 :         if (!var-&gt;type()-&gt;in_heap())</span>
<span class="lineNum">     543 </span>            :           break;
<span class="lineNum">     544 </span><span class="lineCov">       4059 :         if (var-&gt;type()-&gt;points_to() != NULL</span>
<span class="lineNum">     545 </span><span class="lineCov">       4059 :             &amp;&amp; !var-&gt;type()-&gt;points_to()-&gt;in_heap())</span>
<span class="lineNum">     546 </span>            :           break;
<span class="lineNum">     547 </span>            : 
<span class="lineNum">     548 </span>            :         // Otherwise initialize the variable with a write barrier.
<span class="lineNum">     549 </span>            : 
<span class="lineNum">     550 </span><span class="lineCov">       4059 :         Function* function = this-&gt;function_;</span>
<span class="lineNum">     551 </span><span class="lineCov">       4059 :         Location loc = init-&gt;location();</span>
<span class="lineNum">     552 </span><span class="lineCov">       4059 :         Statement_inserter inserter(block, pindex, &amp;this-&gt;statements_added_);</span>
<span class="lineNum">     553 </span>            : 
<span class="lineNum">     554 </span>            :         // Insert the variable declaration statement with no
<span class="lineNum">     555 </span>            :         // initializer, so that the variable exists.
<span class="lineNum">     556 </span><span class="lineCov">       4059 :         var-&gt;clear_init();</span>
<span class="lineNum">     557 </span><span class="lineCov">       4059 :         inserter.insert(s);</span>
<span class="lineNum">     558 </span>            : 
<span class="lineNum">     559 </span>            :         // Create a statement that initializes the variable with a
<span class="lineNum">     560 </span>            :         // write barrier.
<span class="lineNum">     561 </span><span class="lineCov">       4059 :         Expression* ref = Expression::make_var_reference(no, loc);</span>
<span class="lineNum">     562 </span><span class="lineCov">       4059 :         Statement* assign = this-&gt;gogo_-&gt;assign_with_write_barrier(function,</span>
<span class="lineNum">     563 </span>            :                                                                    block,
<span class="lineNum">     564 </span>            :                                                                    &amp;inserter,
<span class="lineNum">     565 </span>            :                                                                    ref, init,
<span class="lineNum">     566 </span><span class="lineCov">       4059 :                                                                    loc);</span>
<span class="lineNum">     567 </span><span class="lineCov">       4059 :         this-&gt;statements_added_.insert(assign);</span>
<span class="lineNum">     568 </span>            : 
<span class="lineNum">     569 </span>            :         // Replace the old variable declaration statement with the new
<span class="lineNum">     570 </span>            :         // initialization.
<span class="lineNum">     571 </span><span class="lineCov">     254939 :         block-&gt;replace_statement(*pindex, assign);</span>
<span class="lineNum">     572 </span>            :       }
<span class="lineNum">     573 </span><span class="lineCov">       4059 :       break;</span>
<span class="lineNum">     574 </span>            : 
<span class="lineNum">     575 </span><span class="lineCov">     709206 :     case Statement::STATEMENT_ASSIGNMENT:</span>
<span class="lineNum">     576 </span><span class="lineCov">     709206 :       {</span>
<span class="lineNum">     577 </span><span class="lineCov">     709206 :         Assignment_statement* as = s-&gt;assignment_statement();</span>
<span class="lineNum">     578 </span>            : 
<span class="lineNum">     579 </span><span class="lineCov">    1418412 :         if (as-&gt;omit_write_barrier())</span>
<span class="lineNum">     580 </span>            :           break;
<span class="lineNum">     581 </span>            : 
<span class="lineNum">     582 </span><span class="lineCov">     698530 :         Expression* lhs = as-&gt;lhs();</span>
<span class="lineNum">     583 </span><span class="lineCov">     698530 :         Expression* rhs = as-&gt;rhs();</span>
<span class="lineNum">     584 </span>            : 
<span class="lineNum">     585 </span>            :         // We may need to emit a write barrier for the assignment.
<span class="lineNum">     586 </span>            : 
<span class="lineNum">     587 </span><span class="lineCov">     698530 :         if (!this-&gt;gogo_-&gt;assign_needs_write_barrier(lhs))</span>
<span class="lineNum">     588 </span>            :           break;
<span class="lineNum">     589 </span>            : 
<span class="lineNum">     590 </span>            :         // Change the assignment to use a write barrier.
<span class="lineNum">     591 </span><span class="lineCov">      39135 :         Function* function = this-&gt;function_;</span>
<span class="lineNum">     592 </span><span class="lineCov">      39135 :         Location loc = as-&gt;location();</span>
<span class="lineNum">     593 </span><span class="lineCov">      39135 :         Statement_inserter inserter =</span>
<span class="lineNum">     594 </span><span class="lineCov">      39135 :             Statement_inserter(block, pindex, &amp;this-&gt;statements_added_);</span>
<span class="lineNum">     595 </span><span class="lineCov">      39135 :         Statement* assign = this-&gt;gogo_-&gt;assign_with_write_barrier(function,</span>
<span class="lineNum">     596 </span>            :                                                                    block,
<span class="lineNum">     597 </span>            :                                                                    &amp;inserter,
<span class="lineNum">     598 </span>            :                                                                    lhs, rhs,
<span class="lineNum">     599 </span><span class="lineCov">      39135 :                                                                    loc);</span>
<span class="lineNum">     600 </span><span class="lineCov">      39135 :         this-&gt;statements_added_.insert(assign);</span>
<span class="lineNum">     601 </span><span class="lineCov">     709206 :         block-&gt;replace_statement(*pindex, assign);</span>
<span class="lineNum">     602 </span>            :       }
<span class="lineNum">     603 </span><span class="lineCov">      39135 :       break;</span>
<span class="lineNum">     604 </span>            :     }
<span class="lineNum">     605 </span>            : 
<span class="lineNum">     606 </span>            :   return TRAVERSE_CONTINUE;
<span class="lineNum">     607 </span>            : }
<span class="lineNum">     608 </span>            : 
<span class="lineNum">     609 </span>            : // The write barrier pass.
<a name="610"><span class="lineNum">     610 </span>            : </a>
<span class="lineNum">     611 </span>            : void
<span class="lineNum">     612 </span><span class="lineCov">       2886 : Gogo::add_write_barriers()</span>
<span class="lineNum">     613 </span>            : {
<span class="lineNum">     614 </span><span class="lineCov">       2886 :   if (saw_errors())</span>
<span class="lineNum">     615 </span><span class="lineCov">        257 :     return;</span>
<span class="lineNum">     616 </span>            : 
<span class="lineNum">     617 </span><span class="lineCov">       5258 :   Mark_address_taken mat(this);</span>
<span class="lineNum">     618 </span><span class="lineCov">       2629 :   this-&gt;traverse(&amp;mat);</span>
<span class="lineNum">     619 </span>            : 
<span class="lineNum">     620 </span><span class="lineCov">       5258 :   if (this-&gt;compiling_runtime() &amp;&amp; this-&gt;package_name() == &quot;runtime&quot;)</span>
<span class="lineNum">     621 </span>            :     {
<span class="lineNum">     622 </span><span class="lineCov">          7 :       this-&gt;propagate_writebarrierrec();</span>
<span class="lineNum">     623 </span>            : 
<span class="lineNum">     624 </span><span class="lineCov">         14 :       Check_escape chk(this);</span>
<span class="lineNum">     625 </span><span class="lineCov">          7 :       this-&gt;traverse(&amp;chk);</span>
<span class="lineNum">     626 </span>            :     }
<span class="lineNum">     627 </span>            : 
<span class="lineNum">     628 </span><span class="lineCov">       5258 :   Write_barriers wb(this);</span>
<span class="lineNum">     629 </span><span class="lineCov">       2629 :   this-&gt;traverse(&amp;wb);</span>
<span class="lineNum">     630 </span>            : }
<span class="lineNum">     631 </span>            : 
<span class="lineNum">     632 </span>            : // Return the runtime.writeBarrier variable.
<a name="633"><span class="lineNum">     633 </span>            : </a>
<span class="lineNum">     634 </span>            : Named_object*
<span class="lineNum">     635 </span><span class="lineCov">      53641 : Gogo::write_barrier_variable()</span>
<span class="lineNum">     636 </span>            : {
<span class="lineNum">     637 </span><span class="lineCov">      53641 :   static Named_object* write_barrier_var;</span>
<span class="lineNum">     638 </span><span class="lineCov">      53641 :   if (write_barrier_var == NULL)</span>
<span class="lineNum">     639 </span>            :     {
<span class="lineNum">     640 </span><span class="lineCov">       1603 :       Location bloc = Linemap::predeclared_location();</span>
<span class="lineNum">     641 </span>            : 
<span class="lineNum">     642 </span>            :       // We pretend that writeBarrier is a uint32, so that we do a
<span class="lineNum">     643 </span>            :       // 32-bit load.  That is what the gc toolchain does.
<span class="lineNum">     644 </span><span class="lineCov">       1603 :       Type* uint32_type = Type::lookup_integer_type(&quot;uint32&quot;);</span>
<span class="lineNum">     645 </span><span class="lineCov">       1603 :       Variable* var = new Variable(uint32_type, NULL, true, false, false,</span>
<span class="lineNum">     646 </span><span class="lineCov">       1603 :                                    bloc);</span>
<span class="lineNum">     647 </span>            : 
<span class="lineNum">     648 </span><span class="lineCov">       1603 :       bool add_to_globals;</span>
<span class="lineNum">     649 </span><span class="lineCov">       3206 :       Package* package = this-&gt;add_imported_package(&quot;runtime&quot;, &quot;_&quot;, false,</span>
<span class="lineNum">     650 </span>            :                                                     &quot;runtime&quot;, &quot;runtime&quot;,
<span class="lineNum">     651 </span>            :                                                     bloc, &amp;add_to_globals);
<span class="lineNum">     652 </span><span class="lineCov">       3206 :       write_barrier_var = Named_object::make_variable(&quot;writeBarrier&quot;,</span>
<span class="lineNum">     653 </span>            :                                                       package, var);
<span class="lineNum">     654 </span>            :     }
<span class="lineNum">     655 </span>            : 
<span class="lineNum">     656 </span><span class="lineCov">      53641 :   return write_barrier_var;</span>
<span class="lineNum">     657 </span>            : }
<span class="lineNum">     658 </span>            : 
<span class="lineNum">     659 </span>            : // Return whether an assignment that sets LHS needs a write barrier.
<span class="lineNum">     660 </span>            : 
<span class="lineNum">     661 </span>            : bool
<span class="lineNum">     662 </span><span class="lineCov">     700132 : Gogo::assign_needs_write_barrier(Expression* lhs)</span>
<span class="lineNum">     663 </span>            : {
<span class="lineNum">     664 </span>            :   // Nothing to do if the variable does not contain any pointers.
<span class="lineNum">     665 </span><span class="lineCov">     700132 :   if (!lhs-&gt;type()-&gt;has_pointer())</span>
<span class="lineNum">     666 </span>            :     return false;
<span class="lineNum">     667 </span>            : 
<span class="lineNum">     668 </span>            :   // An assignment to a field or an array index is handled like an
<span class="lineNum">     669 </span>            :   // assignment to the struct.
<span class="lineNum">     670 </span><span class="lineCov">     318120 :   while (true)</span>
<span class="lineNum">     671 </span>            :     {
<span class="lineNum">     672 </span>            :       // Nothing to do for a type that can not be in the heap, or a
<span class="lineNum">     673 </span>            :       // pointer to a type that can not be in the heap.  We check this
<span class="lineNum">     674 </span>            :       // at each level of a struct.
<span class="lineNum">     675 </span><span class="lineCov">     318120 :       if (!lhs-&gt;type()-&gt;in_heap())</span>
<span class="lineNum">     676 </span>            :         return false;
<span class="lineNum">     677 </span><span class="lineCov">     318008 :       if (lhs-&gt;type()-&gt;points_to() != NULL</span>
<span class="lineNum">     678 </span><span class="lineCov">     318008 :           &amp;&amp; !lhs-&gt;type()-&gt;points_to()-&gt;in_heap())</span>
<span class="lineNum">     679 </span>            :         return false;
<span class="lineNum">     680 </span>            : 
<span class="lineNum">     681 </span><span class="lineCov">     315742 :       Field_reference_expression* fre = lhs-&gt;field_reference_expression();</span>
<span class="lineNum">     682 </span><span class="lineCov">      39895 :       if (fre != NULL)</span>
<span class="lineNum">     683 </span>            :         {
<span class="lineNum">     684 </span><span class="lineCov">      39895 :           lhs = fre-&gt;expr();</span>
<span class="lineNum">     685 </span><span class="lineCov">      39895 :           continue;</span>
<span class="lineNum">     686 </span>            :         }
<span class="lineNum">     687 </span>            : 
<span class="lineNum">     688 </span><span class="lineCov">     275847 :       Array_index_expression* aie = lhs-&gt;array_index_expression();</span>
<span class="lineNum">     689 </span><span class="lineCov">      22281 :       if (aie != NULL</span>
<span class="lineNum">     690 </span><span class="lineCov">      44562 :           &amp;&amp; aie-&gt;end() == NULL</span>
<span class="lineNum">     691 </span><span class="lineCov">      44562 :           &amp;&amp; !aie-&gt;array()-&gt;type()-&gt;is_slice_type())</span>
<span class="lineNum">     692 </span>            :         {
<span class="lineNum">     693 </span><span class="lineCov">      13451 :           lhs = aie-&gt;array();</span>
<span class="lineNum">     694 </span><span class="lineCov">      13451 :           continue;</span>
<span class="lineNum">     695 </span>            :         }
<span class="lineNum">     696 </span>            : 
<span class="lineNum">     697 </span><span class="lineCov">     262396 :       break;</span>
<span class="lineNum">     698 </span>            :     }
<span class="lineNum">     699 </span>            : 
<span class="lineNum">     700 </span>            :   // Nothing to do for an assignment to a temporary.
<span class="lineNum">     701 </span><span class="lineCov">     262396 :   if (lhs-&gt;temporary_reference_expression() != NULL)</span>
<span class="lineNum">     702 </span>            :     return false;
<span class="lineNum">     703 </span>            : 
<span class="lineNum">     704 </span>            :   // Nothing to do for an assignment to a sink.
<span class="lineNum">     705 </span><span class="lineCov">     449054 :   if (lhs-&gt;is_sink_expression())</span>
<span class="lineNum">     706 </span>            :     return false;
<span class="lineNum">     707 </span>            : 
<span class="lineNum">     708 </span>            :   // Nothing to do for an assignment to a local variable that is not
<span class="lineNum">     709 </span>            :   // on the heap.
<span class="lineNum">     710 </span><span class="lineCov">     224527 :   Var_expression* ve = lhs-&gt;var_expression();</span>
<span class="lineNum">     711 </span><span class="lineCov">     189019 :   if (ve != NULL)</span>
<span class="lineNum">     712 </span>            :     {
<span class="lineNum">     713 </span><span class="lineCov">     189019 :       Named_object* no = ve-&gt;named_object();</span>
<span class="lineNum">     714 </span><span class="lineCov">     378038 :       if (no-&gt;is_variable())</span>
<span class="lineNum">     715 </span>            :         {
<span class="lineNum">     716 </span><span class="lineCov">      65197 :           Variable* var = no-&gt;var_value();</span>
<span class="lineNum">     717 </span><span class="lineCov">     130394 :           if (!var-&gt;is_global() &amp;&amp; !var-&gt;is_in_heap())</span>
<span class="lineNum">     718 </span>            :             return false;
<span class="lineNum">     719 </span>            :         }
<span class="lineNum">     720 </span><span class="lineCov">     247644 :       else if (no-&gt;is_result_variable())</span>
<span class="lineNum">     721 </span>            :         {
<span class="lineNum">     722 </span><span class="lineCov">     123822 :           Result_variable* rvar = no-&gt;result_var_value();</span>
<span class="lineNum">     723 </span><span class="lineCov">     123822 :           if (!rvar-&gt;is_in_heap())</span>
<span class="lineNum">     724 </span>            :             return false;
<span class="lineNum">     725 </span>            :         }
<span class="lineNum">     726 </span>            :     }
<span class="lineNum">     727 </span>            : 
<span class="lineNum">     728 </span>            :   // For a struct assignment, we don't need a write barrier if all the
<span class="lineNum">     729 </span>            :   // pointer types can not be in the heap.
<span class="lineNum">     730 </span><span class="lineCov">      39830 :   Struct_type* st = lhs-&gt;type()-&gt;struct_type();</span>
<span class="lineNum">     731 </span><span class="lineCov">      25796 :   if (st != NULL)</span>
<span class="lineNum">     732 </span>            :     {
<span class="lineNum">     733 </span><span class="lineCov">      25796 :       bool in_heap = false;</span>
<span class="lineNum">     734 </span><span class="lineCov">      25796 :       const Struct_field_list* fields = st-&gt;fields();</span>
<span class="lineNum">     735 </span><span class="lineCov">      51592 :       for (Struct_field_list::const_iterator p = fields-&gt;begin();</span>
<span class="lineNum">     736 </span><span class="lineCov">     116022 :            p != fields-&gt;end();</span>
<span class="lineNum">     737 </span><span class="lineCov">      12878 :            p++)</span>
<span class="lineNum">     738 </span>            :         {
<span class="lineNum">     739 </span><span class="lineCov">      38667 :           Type* ft = p-&gt;type();</span>
<span class="lineNum">     740 </span><span class="lineCov">      38667 :           if (!ft-&gt;has_pointer())</span>
<span class="lineNum">     741 </span>            :             continue;
<span class="lineNum">     742 </span><span class="lineCov">      25936 :           if (!ft-&gt;in_heap())</span>
<span class="lineNum">     743 </span>            :             continue;
<span class="lineNum">     744 </span><span class="lineCov">      25936 :           if (ft-&gt;points_to() != NULL &amp;&amp; !ft-&gt;points_to()-&gt;in_heap())</span>
<span class="lineNum">     745 </span>            :             continue;
<span class="lineNum">     746 </span>            :           in_heap = true;
<span class="lineNum">     747 </span>            :           break;
<span class="lineNum">     748 </span>            :         }
<span class="lineNum">     749 </span><span class="lineCov">      25796 :       if (!in_heap)</span>
<span class="lineNum">     750 </span><span class="lineCov">          7 :         return false;</span>
<span class="lineNum">     751 </span>            :     }
<span class="lineNum">     752 </span>            : 
<span class="lineNum">     753 </span>            :   // Write barrier needed in other cases.
<span class="lineNum">     754 </span>            :   return true;
<span class="lineNum">     755 </span>            : }
<span class="lineNum">     756 </span>            : 
<span class="lineNum">     757 </span>            : // Return a statement that sets LHS to RHS using a write barrier.
<span class="lineNum">     758 </span>            : // ENCLOSING is the enclosing block.
<span class="lineNum">     759 </span>            : 
<span class="lineNum">     760 </span>            : Statement*
<span class="lineNum">     761 </span><span class="lineCov">      53641 : Gogo::assign_with_write_barrier(Function* function, Block* enclosing,</span>
<span class="lineNum">     762 </span>            :                                 Statement_inserter* inserter, Expression* lhs,
<span class="lineNum">     763 </span>            :                                 Expression* rhs, Location loc)
<span class="lineNum">     764 </span>            : {
<span class="lineNum">     765 </span><span class="lineCov">      53641 :   if (function != NULL &amp;&amp; (function-&gt;pragmas() &amp; GOPRAGMA_NOWRITEBARRIER) != 0)</span>
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :     go_error_at(loc, &quot;write barrier prohibited&quot;);</span>
<span class="lineNum">     767 </span>            : 
<span class="lineNum">     768 </span><span class="lineCov">      53641 :   Type* type = lhs-&gt;type();</span>
<span class="lineNum">     769 </span><span class="lineCov">      53641 :   go_assert(type-&gt;has_pointer());</span>
<span class="lineNum">     770 </span>            : 
<span class="lineNum">     771 </span><span class="lineCov">      53641 :   Expression* addr;</span>
<span class="lineNum">     772 </span><span class="lineCov">      53641 :   if (lhs-&gt;unary_expression() != NULL</span>
<span class="lineNum">     773 </span><span class="lineCov">      11001 :       &amp;&amp; lhs-&gt;unary_expression()-&gt;op() == OPERATOR_MULT)</span>
<span class="lineNum">     774 </span><span class="lineCov">      11001 :     addr = lhs-&gt;unary_expression()-&gt;operand();</span>
<span class="lineNum">     775 </span>            :   else
<span class="lineNum">     776 </span>            :     {
<span class="lineNum">     777 </span><span class="lineCov">      49974 :       addr = Expression::make_unary(OPERATOR_AND, lhs, loc);</span>
<span class="lineNum">     778 </span><span class="lineCov">      49974 :       addr-&gt;unary_expression()-&gt;set_does_not_escape();</span>
<span class="lineNum">     779 </span>            :     }
<span class="lineNum">     780 </span><span class="lineCov">      53641 :   Temporary_statement* lhs_temp = Statement::make_temporary(NULL, addr, loc);</span>
<span class="lineNum">     781 </span><span class="lineCov">      53641 :   inserter-&gt;insert(lhs_temp);</span>
<span class="lineNum">     782 </span><span class="lineCov">      53641 :   lhs = Expression::make_temporary_reference(lhs_temp, loc);</span>
<span class="lineNum">     783 </span>            : 
<span class="lineNum">     784 </span><span class="lineCov">      53641 :   if (!Type::are_identical(type, rhs-&gt;type(), false, NULL)</span>
<span class="lineNum">     785 </span><span class="lineCov">       5200 :       &amp;&amp; rhs-&gt;type()-&gt;interface_type() != NULL</span>
<span class="lineNum">     786 </span><span class="lineCov">      53695 :       &amp;&amp; !rhs-&gt;is_variable())</span>
<span class="lineNum">     787 </span>            :     {
<span class="lineNum">     788 </span>            :       // May need a temporary for interface conversion.
<span class="lineNum">     789 </span><span class="lineCov">         32 :       Temporary_statement* temp = Statement::make_temporary(NULL, rhs, loc);</span>
<span class="lineNum">     790 </span><span class="lineCov">         32 :       inserter-&gt;insert(temp);</span>
<span class="lineNum">     791 </span><span class="lineCov">         32 :       rhs = Expression::make_temporary_reference(temp, loc);</span>
<span class="lineNum">     792 </span>            :     }
<span class="lineNum">     793 </span><span class="lineCov">      53641 :   rhs = Expression::convert_for_assignment(this, type, rhs, loc);</span>
<span class="lineNum">     794 </span><span class="lineCov">      53641 :   Temporary_statement* rhs_temp = NULL;</span>
<span class="lineNum">     795 </span><span class="lineCov">      53641 :   if (!rhs-&gt;is_variable() &amp;&amp; !rhs-&gt;is_constant())</span>
<span class="lineNum">     796 </span>            :     {
<span class="lineNum">     797 </span><span class="lineCov">      32980 :       rhs_temp = Statement::make_temporary(NULL, rhs, loc);</span>
<span class="lineNum">     798 </span><span class="lineCov">      32980 :       inserter-&gt;insert(rhs_temp);</span>
<span class="lineNum">     799 </span><span class="lineCov">      32980 :       rhs = Expression::make_temporary_reference(rhs_temp, loc);</span>
<span class="lineNum">     800 </span>            :     }
<span class="lineNum">     801 </span>            : 
<span class="lineNum">     802 </span><span class="lineCov">      53641 :   Expression* indir =</span>
<span class="lineNum">     803 </span><span class="lineCov">      53641 :       Expression::make_dereference(lhs, Expression::NIL_CHECK_DEFAULT, loc);</span>
<span class="lineNum">     804 </span><span class="lineCov">      53641 :   Statement* assign = Statement::make_assignment(indir, rhs, loc);</span>
<span class="lineNum">     805 </span>            : 
<span class="lineNum">     806 </span><span class="lineCov">      53641 :   lhs = Expression::make_temporary_reference(lhs_temp, loc);</span>
<span class="lineNum">     807 </span><span class="lineCov">      53641 :   if (rhs_temp != NULL)</span>
<span class="lineNum">     808 </span><span class="lineCov">      32980 :     rhs = Expression::make_temporary_reference(rhs_temp, loc);</span>
<span class="lineNum">     809 </span>            : 
<span class="lineNum">     810 </span><span class="lineCov">      53641 :   Type* unsafe_ptr_type = Type::make_pointer_type(Type::make_void_type());</span>
<span class="lineNum">     811 </span><span class="lineCov">      53641 :   lhs = Expression::make_unsafe_cast(unsafe_ptr_type, lhs, loc);</span>
<span class="lineNum">     812 </span>            : 
<span class="lineNum">     813 </span><span class="lineCov">      53641 :   Expression* call;</span>
<span class="lineNum">     814 </span><span class="lineCov">      53641 :   switch (type-&gt;base()-&gt;classification())</span>
<span class="lineNum">     815 </span>            :     {
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :       go_unreachable();</span>
<span class="lineNum">     818 </span>            : 
<span class="lineNum">     819 </span>            :     case Type::TYPE_ERROR:
<span class="lineNum">     820 </span>            :       return assign;
<span class="lineNum">     821 </span>            : 
<span class="lineNum">     822 </span><span class="lineCov">      21003 :     case Type::TYPE_POINTER:</span>
<span class="lineNum">     823 </span><span class="lineCov">      21003 :     case Type::TYPE_FUNCTION:</span>
<span class="lineNum">     824 </span><span class="lineCov">      21003 :     case Type::TYPE_MAP:</span>
<span class="lineNum">     825 </span><span class="lineCov">      21003 :     case Type::TYPE_CHANNEL:</span>
<span class="lineNum">     826 </span>            :       // These types are all represented by a single pointer.
<span class="lineNum">     827 </span><span class="lineCov">      21003 :       call = Runtime::make_call(Runtime::GCWRITEBARRIER, loc, 2, lhs, rhs);</span>
<span class="lineNum">     828 </span><span class="lineCov">      21003 :       break;</span>
<span class="lineNum">     829 </span>            : 
<span class="lineNum">     830 </span><span class="lineCov">      32638 :     case Type::TYPE_STRING:</span>
<span class="lineNum">     831 </span><span class="lineCov">      32638 :     case Type::TYPE_STRUCT:</span>
<span class="lineNum">     832 </span><span class="lineCov">      32638 :     case Type::TYPE_ARRAY:</span>
<span class="lineNum">     833 </span><span class="lineCov">      32638 :     case Type::TYPE_INTERFACE:</span>
<span class="lineNum">     834 </span><span class="lineCov">      32638 :       {</span>
<span class="lineNum">     835 </span><span class="lineCov">      32638 :         rhs = Expression::make_unary(OPERATOR_AND, rhs, loc);</span>
<span class="lineNum">     836 </span><span class="lineCov">      32638 :         rhs-&gt;unary_expression()-&gt;set_does_not_escape();</span>
<span class="lineNum">     837 </span><span class="lineCov">      32638 :         call = Runtime::make_call(Runtime::TYPEDMEMMOVE, loc, 3,</span>
<span class="lineNum">     838 </span>            :                                   Expression::make_type_descriptor(type, loc),
<span class="lineNum">     839 </span>            :                                   lhs, rhs);
<span class="lineNum">     840 </span>            :       }
<span class="lineNum">     841 </span><span class="lineCov">      32638 :       break;</span>
<span class="lineNum">     842 </span>            :     }
<span class="lineNum">     843 </span>            : 
<span class="lineNum">     844 </span><span class="lineCov">      53641 :   return this-&gt;check_write_barrier(enclosing, assign,</span>
<span class="lineNum">     845 </span><span class="lineCov">      53641 :                                    Statement::make_statement(call, false));</span>
<span class="lineNum">     846 </span>            : }
<span class="lineNum">     847 </span>            : 
<span class="lineNum">     848 </span>            : // Return a statement that tests whether write barriers are enabled
<span class="lineNum">     849 </span>            : // and executes either the efficient code or the write barrier
<span class="lineNum">     850 </span>            : // function call, depending.
<span class="lineNum">     851 </span>            : 
<span class="lineNum">     852 </span>            : Statement*
<span class="lineNum">     853 </span><span class="lineCov">      53641 : Gogo::check_write_barrier(Block* enclosing, Statement* without,</span>
<span class="lineNum">     854 </span>            :                           Statement* with)
<span class="lineNum">     855 </span>            : {
<span class="lineNum">     856 </span><span class="lineCov">      53641 :   Location loc = without-&gt;location();</span>
<span class="lineNum">     857 </span><span class="lineCov">      53641 :   Named_object* wb = this-&gt;write_barrier_variable();</span>
<span class="lineNum">     858 </span><span class="lineCov">      53641 :   Expression* ref = Expression::make_var_reference(wb, loc);</span>
<span class="lineNum">     859 </span><span class="lineCov">      53641 :   Expression* zero = Expression::make_integer_ul(0, ref-&gt;type(), loc);</span>
<span class="lineNum">     860 </span><span class="lineCov">      53641 :   Expression* cond = Expression::make_binary(OPERATOR_EQEQ, ref, zero, loc);</span>
<span class="lineNum">     861 </span>            : 
<span class="lineNum">     862 </span><span class="lineCov">      53641 :   Block* then_block = new Block(enclosing, loc);</span>
<span class="lineNum">     863 </span><span class="lineCov">      53641 :   then_block-&gt;add_statement(without);</span>
<span class="lineNum">     864 </span>            : 
<span class="lineNum">     865 </span><span class="lineCov">      53641 :   Block* else_block = new Block(enclosing, loc);</span>
<span class="lineNum">     866 </span><span class="lineCov">      53641 :   else_block-&gt;add_statement(with);</span>
<span class="lineNum">     867 </span>            : 
<span class="lineNum">     868 </span><span class="lineCov">      53641 :   return Statement::make_if_statement(cond, then_block, else_block, loc);</span>
<span class="lineNum">     869 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.0</a></td></tr>
  </table>
  <br>
<h3>LCOV profile is generated on x86_64 machine using following configure options: configure --disable-bootstrap --enable-coverage=opt --enable-languages=c,c++,fortran,go,jit,lto --enable-host-shared. GCC test suite is run with the built compiler.</h3></body></html>
