<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - gcc.info - gcc/go/gofrontend/import.cc</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">gcc/go/gofrontend</a> - import.cc<span style="font-size: 80%;"> (source / <a href="import.cc.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">gcc.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">437</td>
            <td class="headerCovTableEntry">551</td>
            <td class="headerCovTableEntryMed">79.3 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-09-22 10:58:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">27</td>
            <td class="headerCovTableEntry">33</td>
            <td class="headerCovTableEntryMed">81.8 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // import.cc -- Go frontend import declarations.</a>
<span class="lineNum">       2 </span>            : 
<span class="lineNum">       3 </span>            : // Copyright 2009 The Go Authors. All rights reserved.
<span class="lineNum">       4 </span>            : // Use of this source code is governed by a BSD-style
<span class="lineNum">       5 </span>            : // license that can be found in the LICENSE file.
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : #include &quot;go-system.h&quot;
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #include &quot;filenames.h&quot;
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : #include &quot;go-c.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;go-diagnostics.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;gogo.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;lex.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;types.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;export.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;import.h&quot;
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : #ifndef O_BINARY
<span class="lineNum">      20 </span>            : #define O_BINARY 0
<span class="lineNum">      21 </span>            : #endif
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            : // The list of paths we search for import files.
<span class="lineNum">      24 </span>            : 
<span class="lineNum">      25 </span>            : static std::vector&lt;std::string&gt; search_path;
<span class="lineNum">      26 </span>            : 
<span class="lineNum">      27 </span>            : // Add a directory to the search path.  This is called from the option
<span class="lineNum">      28 </span>            : // handling language hook.
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : GO_EXTERN_C
<span class="lineNum">      31 </span>            : void
<span class="lineNum">      32 </span><span class="lineCov">      18125 : go_add_search_path(const char* path)</span>
<span class="lineNum">      33 </span>            : {
<span class="lineNum">      34 </span><span class="lineCov">      36250 :   search_path.push_back(std::string(path));</span>
<span class="lineNum">      35 </span><span class="lineCov">      18125 : }</span>
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : // Find import data.  This searches the file system for FILENAME and
<span class="lineNum">      38 </span>            : // returns a pointer to a Stream object to read the data that it
<span class="lineNum">      39 </span>            : // exports.  If the file is not found, it returns NULL.
<span class="lineNum">      40 </span>            : 
<span class="lineNum">      41 </span>            : // When FILENAME is not an absolute path and does not start with ./ or
<span class="lineNum">      42 </span>            : // ../, we use the search path provided by -I and -L options.
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span>            : // When FILENAME does start with ./ or ../, we use
<span class="lineNum">      45 </span>            : // RELATIVE_IMPORT_PATH as a prefix.
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            : // When FILENAME does not exist, we try modifying FILENAME to find the
<span class="lineNum">      48 </span>            : // file.  We use the first of these which exists:
<span class="lineNum">      49 </span>            : //   * We append &quot;.gox&quot;.
<span class="lineNum">      50 </span>            : //   * We turn the base of FILENAME into libFILENAME.so.
<span class="lineNum">      51 </span>            : //   * We turn the base of FILENAME into libFILENAME.a.
<span class="lineNum">      52 </span>            : //   * We append &quot;.o&quot;.
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span>            : // When using a search path, we apply each of these transformations at
<span class="lineNum">      55 </span>            : // each entry on the search path before moving on to the next entry.
<span class="lineNum">      56 </span>            : // If the file exists, but does not contain any Go export data, we
<span class="lineNum">      57 </span>            : // stop; we do not keep looking for another file with the same name
<span class="lineNum">      58 </span>            : // later in the search path.
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span>            : Import::Stream*
<span class="lineNum">      61 </span><span class="lineCov">      14209 : Import::open_package(const std::string&amp; filename, Location location,</span>
<span class="lineNum">      62 </span>            :                      const std::string&amp; relative_import_path)
<span class="lineNum">      63 </span>            : {
<span class="lineNum">      64 </span><span class="lineCov">      14209 :   bool is_local;</span>
<span class="lineNum">      65 </span><span class="lineCov">      28418 :   if (IS_ABSOLUTE_PATH(filename))</span>
<span class="lineNum">      66 </span>            :     is_local = true;
<span class="lineNum">      67 </span><span class="lineCov">      14209 :   else if (filename[0] == '.'</span>
<span class="lineNum">      68 </span><span class="lineCov">      14209 :            &amp;&amp; (filename[1] == '\0' || IS_DIR_SEPARATOR(filename[1])))</span>
<span class="lineNum">      69 </span>            :     is_local = true;
<span class="lineNum">      70 </span><span class="lineCov">      13755 :   else if (filename[0] == '.'</span>
<span class="lineNum">      71 </span><span class="lineCov">          4 :            &amp;&amp; filename[1] == '.'</span>
<span class="lineNum">      72 </span><span class="lineCov">      13759 :            &amp;&amp; (filename[2] == '\0' || IS_DIR_SEPARATOR(filename[2])))</span>
<span class="lineNum">      73 </span>            :     is_local = true;
<span class="lineNum">      74 </span>            :   else
<span class="lineNum">      75 </span>            :     is_local = false;
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span><span class="lineCov">      28418 :   std::string fn = filename;</span>
<span class="lineNum">      78 </span><span class="lineCov">      14209 :   if (is_local &amp;&amp; !IS_ABSOLUTE_PATH(filename) &amp;&amp; !relative_import_path.empty())</span>
<span class="lineNum">      79 </span>            :     {
<span class="lineNum">      80 </span><span class="lineCov">         21 :       if (fn == &quot;.&quot;)</span>
<span class="lineNum">      81 </span>            :         {
<span class="lineNum">      82 </span>            :           // A special case.
<span class="lineNum">      83 </span><span class="lineCov">          2 :           fn = relative_import_path;</span>
<span class="lineNum">      84 </span>            :         }
<span class="lineNum">      85 </span><span class="lineCov">         19 :       else if (fn[0] == '.' &amp;&amp; fn[1] == '.'</span>
<span class="lineNum">      86 </span><span class="lineCov">         23 :                &amp;&amp; (fn[2] == '\0' || IS_DIR_SEPARATOR(fn[2])))</span>
<span class="lineNum">      87 </span>            :         {
<span class="lineNum">      88 </span>            :           // We are going to join relative_import_path and fn, and it
<span class="lineNum">      89 </span>            :           // will look like DIR/../PATH.  But DIR does not necessarily
<span class="lineNum">      90 </span>            :           // exist in this case, and if it doesn't the use of .. will
<span class="lineNum">      91 </span>            :           // fail although it shouldn't.  The gc compiler uses
<span class="lineNum">      92 </span>            :           // path.Join here, which cleans up the .., so we need to do
<span class="lineNum">      93 </span>            :           // the same.
<span class="lineNum">      94 </span><span class="lineCov">          2 :           size_t index;</span>
<span class="lineNum">      95 </span><span class="lineCov">          2 :           for (index = relative_import_path.length() - 1;</span>
<span class="lineNum">      96 </span><span class="lineCov">         22 :                index &gt; 0 &amp;&amp; !IS_DIR_SEPARATOR(relative_import_path[index]);</span>
<span class="lineNum">      97 </span>            :                index--)
<span class="lineNum">      98 </span>            :             ;
<span class="lineNum">      99 </span><span class="lineCov">          2 :           if (index &gt; 0)</span>
<span class="lineNum">     100 </span><span class="lineCov">          2 :             fn = relative_import_path.substr(0, index) + fn.substr(2);</span>
<span class="lineNum">     101 </span>            :           else
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :             fn = relative_import_path + '/' + fn;</span>
<span class="lineNum">     103 </span>            :         }
<span class="lineNum">     104 </span>            :       else
<span class="lineNum">     105 </span><span class="lineCov">         17 :         fn = relative_import_path + '/' + fn;</span>
<span class="lineNum">     106 </span>            :       is_local = false;
<span class="lineNum">     107 </span>            :     }
<span class="lineNum">     108 </span>            : 
<span class="lineNum">     109 </span><span class="lineCov">      14188 :   if (!is_local)</span>
<span class="lineNum">     110 </span>            :     {
<span class="lineNum">     111 </span><span class="lineCov">      41322 :       for (std::vector&lt;std::string&gt;::const_iterator p = search_path.begin();</span>
<span class="lineNum">     112 </span><span class="lineCov">      57441 :            p != search_path.end();</span>
<span class="lineNum">     113 </span><span class="lineCov">       5373 :            ++p)</span>
<span class="lineNum">     114 </span>            :         {
<span class="lineNum">     115 </span><span class="lineCov">      25633 :           std::string indir = *p;</span>
<span class="lineNum">     116 </span><span class="lineCov">      38270 :           if (!indir.empty() &amp;&amp; indir[indir.size() - 1] != '/')</span>
<span class="lineNum">     117 </span><span class="lineCov">      19135 :             indir += '/';</span>
<span class="lineNum">     118 </span><span class="lineCov">      19135 :           indir += fn;</span>
<span class="lineNum">     119 </span><span class="lineCov">      19135 :           Stream* s = Import::try_package_in_directory(indir, location);</span>
<span class="lineNum">     120 </span><span class="lineCov">      19135 :           if (s != NULL)</span>
<span class="lineNum">     121 </span><span class="lineCov">      22542 :             return s;</span>
<span class="lineNum">     122 </span>            :         }
<span class="lineNum">     123 </span>            :     }
<span class="lineNum">     124 </span>            : 
<span class="lineNum">     125 </span><span class="lineCov">        447 :   Stream* s = Import::try_package_in_directory(fn, location);</span>
<span class="lineNum">     126 </span><span class="lineCov">        447 :   if (s != NULL)</span>
<span class="lineNum">     127 </span><span class="lineCov">        437 :     return s;</span>
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span>            :   return NULL;
<span class="lineNum">     130 </span>            : }
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span>            : // Try to find the export data for FILENAME.
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span>            : Import::Stream*
<span class="lineNum">     135 </span><span class="lineCov">      19582 : Import::try_package_in_directory(const std::string&amp; filename,</span>
<span class="lineNum">     136 </span>            :                                  Location location)
<span class="lineNum">     137 </span>            : {
<span class="lineNum">     138 </span><span class="lineCov">      39164 :   std::string found_filename = filename;</span>
<span class="lineNum">     139 </span><span class="lineCov">      39164 :   int fd = open(found_filename.c_str(), O_RDONLY | O_BINARY);</span>
<span class="lineNum">     140 </span>            : 
<span class="lineNum">     141 </span><span class="lineCov">      19582 :   if (fd &gt;= 0)</span>
<span class="lineNum">     142 </span>            :     {
<span class="lineNum">     143 </span><span class="lineCov">       7976 :       struct stat s;</span>
<span class="lineNum">     144 </span><span class="lineCov">       7976 :       if (fstat(fd, &amp;s) &gt;= 0 &amp;&amp; S_ISDIR(s.st_mode))</span>
<span class="lineNum">     145 </span>            :         {
<span class="lineNum">     146 </span><span class="lineCov">       7976 :           close(fd);</span>
<span class="lineNum">     147 </span><span class="lineCov">       7976 :           fd = -1;</span>
<span class="lineNum">     148 </span><span class="lineCov">       7976 :           errno = EISDIR;</span>
<span class="lineNum">     149 </span>            :         }
<span class="lineNum">     150 </span>            :     }
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span><span class="lineCov">      19582 :   if (fd &lt; 0)</span>
<span class="lineNum">     153 </span>            :     {
<span class="lineNum">     154 </span><span class="lineCov">      19582 :       if (errno != ENOENT &amp;&amp; errno != EISDIR)</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :         go_warning_at(location, 0, &quot;%s: %m&quot;, filename.c_str());</span>
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span><span class="lineCov">      19582 :       fd = Import::try_suffixes(&amp;found_filename);</span>
<span class="lineNum">     158 </span><span class="lineCov">      19582 :       if (fd &lt; 0)</span>
<span class="lineNum">     159 </span>            :         return NULL;
<span class="lineNum">     160 </span>            :     }
<span class="lineNum">     161 </span>            : 
<span class="lineNum">     162 </span>            :   // The export data may not be in this file.
<span class="lineNum">     163 </span><span class="lineCov">      14199 :   Stream* s = Import::find_export_data(found_filename, fd, location);</span>
<span class="lineNum">     164 </span><span class="lineCov">      14199 :   if (s != NULL)</span>
<span class="lineNum">     165 </span>            :     return s;
<span class="lineNum">     166 </span>            : 
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :   close(fd);</span>
<span class="lineNum">     168 </span>            : 
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :   go_error_at(location, &quot;%s exists but does not contain any Go export data&quot;,</span>
<span class="lineNum">     170 </span>            :               found_filename.c_str());
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :   return NULL;</span>
<span class="lineNum">     173 </span>            : }
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span>            : // Given import &quot;*PFILENAME&quot;, where *PFILENAME does not exist, try
<span class="lineNum">     176 </span>            : // various suffixes.  If we find one, set *PFILENAME to the one we
<span class="lineNum">     177 </span>            : // found.  Return the open file descriptor.
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span>            : int
<span class="lineNum">     180 </span><span class="lineCov">      19582 : Import::try_suffixes(std::string* pfilename)</span>
<span class="lineNum">     181 </span>            : {
<span class="lineNum">     182 </span><span class="lineCov">      39164 :   std::string filename = *pfilename + &quot;.gox&quot;;</span>
<span class="lineNum">     183 </span><span class="lineCov">      39164 :   int fd = open(filename.c_str(), O_RDONLY | O_BINARY);</span>
<span class="lineNum">     184 </span><span class="lineCov">      19582 :   if (fd &gt;= 0)</span>
<span class="lineNum">     185 </span>            :     {
<span class="lineNum">     186 </span><span class="lineCov">      13399 :       *pfilename = filename;</span>
<span class="lineNum">     187 </span><span class="lineCov">      13399 :       return fd;</span>
<span class="lineNum">     188 </span>            :     }
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span><span class="lineCov">      12366 :   const char* basename = lbasename(pfilename-&gt;c_str());</span>
<span class="lineNum">     191 </span><span class="lineCov">       6183 :   size_t basename_pos = basename - pfilename-&gt;c_str();</span>
<span class="lineNum">     192 </span><span class="lineCov">       8256 :   filename = pfilename-&gt;substr(0, basename_pos) + &quot;lib&quot; + basename + &quot;.so&quot;;</span>
<span class="lineNum">     193 </span><span class="lineCov">      12366 :   fd = open(filename.c_str(), O_RDONLY | O_BINARY);</span>
<span class="lineNum">     194 </span><span class="lineCov">       6183 :   if (fd &gt;= 0)</span>
<span class="lineNum">     195 </span>            :     {
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :       *pfilename = filename;</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :       return fd;</span>
<span class="lineNum">     198 </span>            :     }
<span class="lineNum">     199 </span>            : 
<span class="lineNum">     200 </span><span class="lineCov">       8521 :   filename = pfilename-&gt;substr(0, basename_pos) + &quot;lib&quot; + basename + &quot;.a&quot;;</span>
<span class="lineNum">     201 </span><span class="lineCov">      12366 :   fd = open(filename.c_str(), O_RDONLY | O_BINARY);</span>
<span class="lineNum">     202 </span><span class="lineCov">       6183 :   if (fd &gt;= 0)</span>
<span class="lineNum">     203 </span>            :     {
<span class="lineNum">     204 </span><span class="lineCov">        346 :       *pfilename = filename;</span>
<span class="lineNum">     205 </span><span class="lineCov">        346 :       return fd;</span>
<span class="lineNum">     206 </span>            :     }
<span class="lineNum">     207 </span>            : 
<span class="lineNum">     208 </span><span class="lineCov">       5837 :   filename = *pfilename + &quot;.o&quot;;</span>
<span class="lineNum">     209 </span><span class="lineCov">      11674 :   fd = open(filename.c_str(), O_RDONLY | O_BINARY);</span>
<span class="lineNum">     210 </span><span class="lineCov">       5837 :   if (fd &gt;= 0)</span>
<span class="lineNum">     211 </span>            :     {
<span class="lineNum">     212 </span><span class="lineCov">        454 :       *pfilename = filename;</span>
<span class="lineNum">     213 </span><span class="lineCov">        454 :       return fd;</span>
<span class="lineNum">     214 </span>            :     }
<span class="lineNum">     215 </span>            : 
<span class="lineNum">     216 </span>            :   return -1;
<span class="lineNum">     217 </span>            : }
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span>            : // Look for export data in the file descriptor FD.
<a name="220"><span class="lineNum">     220 </span>            : </a>
<span class="lineNum">     221 </span>            : Import::Stream*
<span class="lineNum">     222 </span><span class="lineCov">      14199 : Import::find_export_data(const std::string&amp; filename, int fd, Location location)</span>
<span class="lineNum">     223 </span>            : {
<span class="lineNum">     224 </span>            :   // See if we can read this as an object file.
<span class="lineNum">     225 </span><span class="lineCov">      14199 :   Import::Stream* stream = Import::find_object_export_data(filename, fd, 0,</span>
<span class="lineNum">     226 </span>            :                                                            location);
<span class="lineNum">     227 </span><span class="lineCov">      14199 :   if (stream != NULL)</span>
<span class="lineNum">     228 </span>            :     return stream;
<span class="lineNum">     229 </span>            : 
<span class="lineNum">     230 </span><span class="lineCov">        260 :   const int len = MAX(Export::magic_len, Import::archive_magic_len);</span>
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span><span class="lineCov">        260 :   if (lseek(fd, 0, SEEK_SET) &lt; 0)</span>
<span class="lineNum">     233 </span>            :     {
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :       go_error_at(location, &quot;lseek %s failed: %m&quot;, filename.c_str());</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">     236 </span>            :     }
<span class="lineNum">     237 </span>            : 
<span class="lineNum">     238 </span><span class="lineCov">        260 :   char buf[len];</span>
<span class="lineNum">     239 </span><span class="lineCov">        260 :   ssize_t c = read(fd, buf, len);</span>
<span class="lineNum">     240 </span><span class="lineCov">        260 :   if (c &lt; len)</span>
<span class="lineNum">     241 </span>            :     return NULL;
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span>            :   // Check for a file containing nothing but Go export data.
<span class="lineNum">     244 </span><span class="lineCov">        260 :   if (memcmp(buf, Export::cur_magic, Export::magic_len) == 0 ||</span>
<span class="lineNum">     245 </span><span class="lineCov">        260 :       memcmp(buf, Export::v1_magic, Export::magic_len) == 0)</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :     return new Stream_from_file(fd);</span>
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span>            :   // See if we can read this as an archive.
<span class="lineNum">     249 </span><span class="lineCov">        260 :   if (Import::is_archive_magic(buf))</span>
<span class="lineNum">     250 </span><span class="lineCov">        260 :     return Import::find_archive_export_data(filename, fd, location);</span>
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span>            :   return NULL;
<span class="lineNum">     253 </span>            : }
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span>            : // Look for export data in an object file.
<a name="256"><span class="lineNum">     256 </span>            : </a>
<span class="lineNum">     257 </span>            : Import::Stream*
<span class="lineNum">     258 </span><span class="lineCov">      14857 : Import::find_object_export_data(const std::string&amp; filename,</span>
<span class="lineNum">     259 </span>            :                                 int fd,
<span class="lineNum">     260 </span>            :                                 off_t offset,
<span class="lineNum">     261 </span>            :                                 Location location)
<span class="lineNum">     262 </span>            : {
<span class="lineNum">     263 </span><span class="lineCov">      14857 :   char *buf;</span>
<span class="lineNum">     264 </span><span class="lineCov">      14857 :   size_t len;</span>
<span class="lineNum">     265 </span><span class="lineCov">      14857 :   int err;</span>
<span class="lineNum">     266 </span><span class="lineCov">      14857 :   const char *errmsg = go_read_export_data(fd, offset, &amp;buf, &amp;len, &amp;err);</span>
<span class="lineNum">     267 </span><span class="lineCov">      14857 :   if (errmsg != NULL)</span>
<span class="lineNum">     268 </span>            :     {
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :       if (err == 0)</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :         go_error_at(location, &quot;%s: %s&quot;, filename.c_str(), errmsg);</span>
<span class="lineNum">     271 </span>            :       else
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :         go_error_at(location, &quot;%s: %s: %s&quot;, filename.c_str(), errmsg,</span>
<span class="lineNum">     273 </span>            :                     xstrerror(err));
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">     275 </span>            :     }
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span><span class="lineCov">      14857 :   if (buf == NULL)</span>
<span class="lineNum">     278 </span>            :     return NULL;
<span class="lineNum">     279 </span>            : 
<span class="lineNum">     280 </span><span class="lineCov">      14199 :   return new Stream_from_buffer(buf, len);</span>
<span class="lineNum">     281 </span>            : }
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span>            : // Class Import.
<span class="lineNum">     284 </span>            : 
<span class="lineNum">     285 </span>            : // Construct an Import object.  We make the builtin_types_ vector
<a name="286"><span class="lineNum">     286 </span>            : // large enough to hold all the builtin types.</a>
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span><span class="lineCov">      14199 : Import::Import(Stream* stream, Location location)</span>
<span class="lineNum">     289 </span>            :   : gogo_(NULL), stream_(stream), location_(location), package_(NULL),
<span class="lineNum">     290 </span>            :     add_to_globals_(false),
<span class="lineNum">     291 </span>            :     builtin_types_((- SMALLEST_BUILTIN_CODE) + 1),
<span class="lineNum">     292 </span><span class="lineCov">      28398 :     types_(), version_(EXPORT_FORMAT_UNKNOWN)</span>
<span class="lineNum">     293 </span>            : {
<span class="lineNum">     294 </span><span class="lineCov">      14199 : }</span>
<span class="lineNum">     295 </span>            : 
<span class="lineNum">     296 </span>            : // Import the data in the associated stream.
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span>            : Package*
<span class="lineNum">     299 </span><span class="lineCov">      14199 : Import::import(Gogo* gogo, const std::string&amp; local_name,</span>
<span class="lineNum">     300 </span>            :                bool is_local_name_exported)
<span class="lineNum">     301 </span>            : {
<span class="lineNum">     302 </span>            :   // Hold on to the Gogo structure.  Otherwise we need to pass it
<span class="lineNum">     303 </span>            :   // through all the import functions, because we need it when reading
<span class="lineNum">     304 </span>            :   // a type.
<span class="lineNum">     305 </span><span class="lineCov">      14199 :   this-&gt;gogo_ = gogo;</span>
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span>            :   // A stream of export data can include data from more than one input
<span class="lineNum">     308 </span>            :   // file.  Here we loop over each input file.
<span class="lineNum">     309 </span><span class="lineCov">      14199 :   Stream* stream = this-&gt;stream_;</span>
<span class="lineNum">     310 </span><span class="lineCov">      28398 :   while (!stream-&gt;at_eof() &amp;&amp; !stream-&gt;saw_error())</span>
<span class="lineNum">     311 </span>            :     {
<span class="lineNum">     312 </span>            :       // The vector of types is package specific.
<span class="lineNum">     313 </span><span class="lineCov">      14199 :       this-&gt;types_.clear();</span>
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span>            :       // Check magic string / version number.
<span class="lineNum">     316 </span><span class="lineCov">      14199 :       if (stream-&gt;match_bytes(Export::cur_magic, Export::magic_len))</span>
<span class="lineNum">     317 </span>            :         {
<span class="lineNum">     318 </span><span class="lineCov">      14199 :           stream-&gt;require_bytes(this-&gt;location_, Export::cur_magic,</span>
<span class="lineNum">     319 </span>            :                                 Export::magic_len);
<span class="lineNum">     320 </span><span class="lineCov">      14199 :           this-&gt;version_ = EXPORT_FORMAT_CURRENT;</span>
<span class="lineNum">     321 </span>            :         }
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :       else if (stream-&gt;match_bytes(Export::v1_magic, Export::magic_len))</span>
<span class="lineNum">     323 </span>            :         {
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :           stream-&gt;require_bytes(this-&gt;location_, Export::v1_magic,</span>
<span class="lineNum">     325 </span>            :                                 Export::magic_len);
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :           this-&gt;version_ = EXPORT_FORMAT_V1;</span>
<span class="lineNum">     327 </span>            :         }
<span class="lineNum">     328 </span>            :       else
<span class="lineNum">     329 </span>            :         {
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :           go_error_at(this-&gt;location_,</span>
<span class="lineNum">     331 </span>            :                       (&quot;error in import data at %d: invalid magic string&quot;),
<span class="lineNum">     332 </span>            :                       stream-&gt;pos());
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :           return NULL;</span>
<span class="lineNum">     334 </span>            :         }
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span><span class="lineCov">      14199 :       this-&gt;require_c_string(&quot;package &quot;);</span>
<span class="lineNum">     337 </span><span class="lineCov">      28398 :       std::string package_name = this-&gt;read_identifier();</span>
<span class="lineNum">     338 </span><span class="lineCov">      14199 :       this-&gt;require_c_string(&quot;;\n&quot;);</span>
<span class="lineNum">     339 </span>            : 
<span class="lineNum">     340 </span><span class="lineCov">      28398 :       std::string pkgpath;</span>
<span class="lineNum">     341 </span><span class="lineCov">      28398 :       std::string pkgpath_symbol;</span>
<span class="lineNum">     342 </span><span class="lineCov">      14199 :       if (this-&gt;match_c_string(&quot;prefix &quot;))</span>
<span class="lineNum">     343 </span>            :         {
<span class="lineNum">     344 </span><span class="lineCov">         85 :           this-&gt;advance(7);</span>
<span class="lineNum">     345 </span><span class="lineCov">        170 :           std::string unique_prefix = this-&gt;read_identifier();</span>
<span class="lineNum">     346 </span><span class="lineCov">         85 :           this-&gt;require_c_string(&quot;;\n&quot;);</span>
<span class="lineNum">     347 </span><span class="lineCov">         85 :           pkgpath = unique_prefix + '.' + package_name;</span>
<span class="lineNum">     348 </span><span class="lineCov">        170 :           pkgpath_symbol = (Gogo::pkgpath_for_symbol(unique_prefix) + '.'</span>
<span class="lineNum">     349 </span><span class="lineCov">        255 :                             + Gogo::pkgpath_for_symbol(package_name));</span>
<span class="lineNum">     350 </span>            :         }
<span class="lineNum">     351 </span>            :       else
<span class="lineNum">     352 </span>            :         {
<span class="lineNum">     353 </span><span class="lineCov">      14114 :           this-&gt;require_c_string(&quot;pkgpath &quot;);</span>
<span class="lineNum">     354 </span><span class="lineCov">      14114 :           pkgpath = this-&gt;read_identifier();</span>
<span class="lineNum">     355 </span><span class="lineCov">      14114 :           this-&gt;require_c_string(&quot;;\n&quot;);</span>
<span class="lineNum">     356 </span><span class="lineCov">      14114 :           pkgpath_symbol = Gogo::pkgpath_for_symbol(pkgpath);</span>
<span class="lineNum">     357 </span>            :         }
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span><span class="lineCov">      14199 :       this-&gt;package_ = gogo-&gt;add_imported_package(package_name, local_name,</span>
<span class="lineNum">     360 </span>            :                                                   is_local_name_exported,
<span class="lineNum">     361 </span>            :                                                   pkgpath, pkgpath_symbol,
<span class="lineNum">     362 </span>            :                                                   this-&gt;location_,
<span class="lineNum">     363 </span>            :                                                   &amp;this-&gt;add_to_globals_);
<span class="lineNum">     364 </span><span class="lineCov">      14199 :       if (this-&gt;package_ == NULL)</span>
<span class="lineNum">     365 </span>            :         {
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :           stream-&gt;set_saw_error();</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :           return NULL;</span>
<span class="lineNum">     368 </span>            :         }
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span>            :       // Read and discard priority if older V1 export data format.
<span class="lineNum">     371 </span><span class="lineCov">      28398 :       if (version() == EXPORT_FORMAT_V1)</span>
<span class="lineNum">     372 </span>            :         {
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :           this-&gt;require_c_string(&quot;priority &quot;);</span>
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :           std::string priority_string = this-&gt;read_identifier();</span>
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :           int prio;</span>
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :           if (!this-&gt;string_to_int(priority_string, false, &amp;prio))</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :             return NULL;</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :           this-&gt;require_c_string(&quot;;\n&quot;);</span>
<span class="lineNum">     379 </span>            :         }
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span><span class="lineCov">      14294 :       while (stream-&gt;match_c_string(&quot;package&quot;))</span>
<span class="lineNum">     382 </span><span class="lineCov">         95 :         this-&gt;read_one_package();</span>
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span><span class="lineCov">     103187 :       while (stream-&gt;match_c_string(&quot;import&quot;))</span>
<span class="lineNum">     385 </span><span class="lineCov">      88988 :         this-&gt;read_one_import();</span>
<span class="lineNum">     386 </span>            : 
<span class="lineNum">     387 </span><span class="lineCov">      14199 :       if (stream-&gt;match_c_string(&quot;init&quot;))</span>
<span class="lineNum">     388 </span><span class="lineCov">      12813 :         this-&gt;read_import_init_fns(gogo);</span>
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span>            :       // Loop over all the input data for this package.
<span class="lineNum">     391 </span><span class="lineCov">    2068606 :       while (!stream-&gt;saw_error())</span>
<span class="lineNum">     392 </span>            :         {
<span class="lineNum">     393 </span><span class="lineCov">    1034303 :           if (stream-&gt;match_c_string(&quot;const &quot;))</span>
<span class="lineNum">     394 </span><span class="lineCov">     490885 :             this-&gt;import_const();</span>
<span class="lineNum">     395 </span><span class="lineCov">     543418 :           else if (stream-&gt;match_c_string(&quot;type &quot;))</span>
<span class="lineNum">     396 </span><span class="lineCov">     109251 :             this-&gt;import_type();</span>
<span class="lineNum">     397 </span><span class="lineCov">     434167 :           else if (stream-&gt;match_c_string(&quot;var &quot;))</span>
<span class="lineNum">     398 </span><span class="lineCov">      75338 :             this-&gt;import_var();</span>
<span class="lineNum">     399 </span><span class="lineCov">     358829 :           else if (stream-&gt;match_c_string(&quot;func &quot;))</span>
<span class="lineNum">     400 </span><span class="lineCov">     344630 :             this-&gt;import_func(this-&gt;package_);</span>
<span class="lineNum">     401 </span><span class="lineCov">      14199 :           else if (stream-&gt;match_c_string(&quot;checksum &quot;))</span>
<span class="lineNum">     402 </span>            :             break;
<span class="lineNum">     403 </span>            :           else
<span class="lineNum">     404 </span>            :             {
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :               go_error_at(this-&gt;location_,</span>
<span class="lineNum">     406 </span>            :                           (&quot;error in import data at %d: &quot;
<span class="lineNum">     407 </span>            :                            &quot;expected %&lt;const%&gt;, %&lt;type%&gt;, %&lt;var%&gt;, &quot;
<span class="lineNum">     408 </span>            :                            &quot;%&lt;func%&gt;, or %&lt;checksum%&gt;&quot;),
<span class="lineNum">     409 </span>            :                           stream-&gt;pos());
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :               stream-&gt;set_saw_error();</span>
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :               return NULL;</span>
<span class="lineNum">     412 </span>            :             }
<span class="lineNum">     413 </span>            :         }
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span>            :       // We currently ignore the checksum.  In the future we could
<span class="lineNum">     416 </span>            :       // store the checksum somewhere in the generated object and then
<span class="lineNum">     417 </span>            :       // verify that the checksum matches at link time or at dynamic
<span class="lineNum">     418 </span>            :       // load time.
<span class="lineNum">     419 </span><span class="lineCov">      14199 :       this-&gt;require_c_string(&quot;checksum &quot;);</span>
<span class="lineNum">     420 </span><span class="lineCov">      14199 :       stream-&gt;advance(Export::checksum_len * 2);</span>
<span class="lineNum">     421 </span><span class="lineCov">      14199 :       this-&gt;require_c_string(&quot;;\n&quot;);</span>
<span class="lineNum">     422 </span>            :     }
<span class="lineNum">     423 </span>            : 
<span class="lineNum">     424 </span><span class="lineCov">      14199 :   return this-&gt;package_;</span>
<span class="lineNum">     425 </span>            : }
<span class="lineNum">     426 </span>            : 
<span class="lineNum">     427 </span>            : // Read a package line.  This let us reliably determine the pkgpath
<span class="lineNum">     428 </span>            : // symbol, even if the package was compiled with a -fgo-prefix option.
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span>            : void
<span class="lineNum">     431 </span><span class="lineCov">         95 : Import::read_one_package()</span>
<span class="lineNum">     432 </span>            : {
<span class="lineNum">     433 </span><span class="lineCov">         95 :   this-&gt;require_c_string(&quot;package &quot;);</span>
<span class="lineNum">     434 </span><span class="lineCov">         95 :   std::string package_name = this-&gt;read_identifier();</span>
<span class="lineNum">     435 </span><span class="lineCov">         95 :   this-&gt;require_c_string(&quot; &quot;);</span>
<span class="lineNum">     436 </span><span class="lineCov">        190 :   std::string pkgpath = this-&gt;read_identifier();</span>
<span class="lineNum">     437 </span><span class="lineCov">         95 :   this-&gt;require_c_string(&quot; &quot;);</span>
<span class="lineNum">     438 </span><span class="lineCov">        190 :   std::string pkgpath_symbol = this-&gt;read_identifier();</span>
<span class="lineNum">     439 </span><span class="lineCov">         95 :   this-&gt;require_c_string(&quot;;\n&quot;);</span>
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span><span class="lineCov">         95 :   Package* p = this-&gt;gogo_-&gt;register_package(pkgpath, pkgpath_symbol,</span>
<span class="lineNum">     442 </span>            :                                              Linemap::unknown_location());
<span class="lineNum">     443 </span><span class="lineCov">        190 :   p-&gt;set_package_name(package_name, this-&gt;location());</span>
<span class="lineNum">     444 </span><span class="lineCov">         95 : }</span>
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span>            : // Read an import line.  We don't actually care about these.
<span class="lineNum">     447 </span>            : 
<span class="lineNum">     448 </span>            : void
<span class="lineNum">     449 </span><span class="lineCov">      88988 : Import::read_one_import()</span>
<span class="lineNum">     450 </span>            : {
<span class="lineNum">     451 </span><span class="lineCov">      88988 :   this-&gt;require_c_string(&quot;import &quot;);</span>
<span class="lineNum">     452 </span><span class="lineCov">      88988 :   std::string package_name = this-&gt;read_identifier();</span>
<span class="lineNum">     453 </span><span class="lineCov">      88988 :   this-&gt;require_c_string(&quot; &quot;);</span>
<span class="lineNum">     454 </span><span class="lineCov">     177976 :   std::string pkgpath = this-&gt;read_identifier();</span>
<span class="lineNum">     455 </span><span class="lineCov">      88988 :   this-&gt;require_c_string(&quot; \&quot;&quot;);</span>
<span class="lineNum">     456 </span><span class="lineCov">      88988 :   Stream* stream = this-&gt;stream_;</span>
<span class="lineNum">     457 </span><span class="lineCov">     756800 :   while (stream-&gt;peek_char() != '&quot;')</span>
<span class="lineNum">     458 </span><span class="lineCov">     667812 :     stream-&gt;advance(1);</span>
<span class="lineNum">     459 </span><span class="lineCov">      88988 :   this-&gt;require_c_string(&quot;\&quot;;\n&quot;);</span>
<span class="lineNum">     460 </span>            : 
<span class="lineNum">     461 </span><span class="lineCov">      88988 :   Package* p = this-&gt;gogo_-&gt;register_package(pkgpath, &quot;&quot;,</span>
<span class="lineNum">     462 </span>            :                                              Linemap::unknown_location());
<span class="lineNum">     463 </span><span class="lineCov">     177976 :   p-&gt;set_package_name(package_name, this-&gt;location());</span>
<span class="lineNum">     464 </span><span class="lineCov">      88988 : }</span>
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span>            : // Read the list of import control functions and/or init graph.
<span class="lineNum">     467 </span>            : 
<span class="lineNum">     468 </span>            : void
<span class="lineNum">     469 </span><span class="lineCov">      12813 : Import::read_import_init_fns(Gogo* gogo)</span>
<span class="lineNum">     470 </span>            : {
<span class="lineNum">     471 </span><span class="lineCov">      12813 :   this-&gt;require_c_string(&quot;init&quot;);</span>
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span>            :   // Maps init function to index in the &quot;init&quot; clause; needed
<span class="lineNum">     474 </span>            :   // to read the init_graph section.
<span class="lineNum">     475 </span><span class="lineCov">      25626 :   std::map&lt;std::string, unsigned&gt; init_idx;</span>
<span class="lineNum">     476 </span>            : 
<span class="lineNum">     477 </span><span class="lineCov">     152691 :   while (!this-&gt;match_c_string(&quot;;&quot;))</span>
<span class="lineNum">     478 </span>            :     {
<span class="lineNum">     479 </span><span class="lineCov">     139878 :       int priority = -1;</span>
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span><span class="lineCov">     139878 :       this-&gt;require_c_string(&quot; &quot;);</span>
<span class="lineNum">     482 </span><span class="lineCov">     279756 :       std::string package_name = this-&gt;read_identifier();</span>
<span class="lineNum">     483 </span><span class="lineCov">     139878 :       this-&gt;require_c_string(&quot; &quot;);</span>
<span class="lineNum">     484 </span><span class="lineCov">     279756 :       std::string init_name = this-&gt;read_identifier();</span>
<span class="lineNum">     485 </span><span class="lineCov">     139878 :       if (this-&gt;version_ == EXPORT_FORMAT_V1)</span>
<span class="lineNum">     486 </span>            :         {
<span class="lineNum">     487 </span>            :           // Older version 1 init fcn export data format is:
<span class="lineNum">     488 </span>            :           //
<span class="lineNum">     489 </span>            :           //   &lt;packname&gt; &lt;fcn&gt; &lt;priority&gt;
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :           this-&gt;require_c_string(&quot; &quot;);</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :           std::string prio_string = this-&gt;read_identifier();</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :           if (!this-&gt;string_to_int(prio_string, false, &amp;priority))</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     494 </span>            :         }
<span class="lineNum">     495 </span><span class="lineCov">     139878 :       gogo-&gt;add_import_init_fn(package_name, init_name, priority);</span>
<span class="lineNum">     496 </span>            : 
<span class="lineNum">     497 </span>            :       // Record the index of this init fcn so that we can look it
<span class="lineNum">     498 </span>            :       // up by index in the subsequent init_graph section.
<span class="lineNum">     499 </span><span class="lineCov">     139878 :       unsigned idx = init_idx.size();</span>
<span class="lineNum">     500 </span><span class="lineCov">     139878 :       init_idx[init_name] = idx;</span>
<span class="lineNum">     501 </span>            :     }
<span class="lineNum">     502 </span><span class="lineCov">      12813 :   this-&gt;require_c_string(&quot;;\n&quot;);</span>
<span class="lineNum">     503 </span>            : 
<span class="lineNum">     504 </span><span class="lineCov">      12813 :   if (this-&gt;match_c_string(&quot;init_graph&quot;))</span>
<span class="lineNum">     505 </span>            :     {
<span class="lineNum">     506 </span><span class="lineCov">      12548 :       this-&gt;require_c_string(&quot;init_graph&quot;);</span>
<span class="lineNum">     507 </span>            : 
<span class="lineNum">     508 </span>            :       // Build a vector mapping init fcn slot to Import_init pointer.
<span class="lineNum">     509 </span><span class="lineCov">      25096 :       go_assert(init_idx.size() &gt; 0);</span>
<span class="lineNum">     510 </span><span class="lineCov">      25096 :       std::vector&lt;Import_init*&gt; import_initvec;</span>
<span class="lineNum">     511 </span><span class="lineCov">      25096 :       import_initvec.resize(init_idx.size());</span>
<span class="lineNum">     512 </span><span class="lineCov">      12548 :       for (std::map&lt;std::string, unsigned&gt;::const_iterator it =</span>
<span class="lineNum">     513 </span><span class="lineCov">      37644 :                init_idx.begin();</span>
<span class="lineNum">     514 </span><span class="lineCov">     304322 :            it != init_idx.end(); ++it)</span>
<span class="lineNum">     515 </span>            :         {
<span class="lineNum">     516 </span><span class="lineCov">     139613 :           const std::string&amp; init_name = it-&gt;first;</span>
<span class="lineNum">     517 </span><span class="lineCov">     139613 :           Import_init* ii = gogo-&gt;lookup_init(init_name);</span>
<span class="lineNum">     518 </span><span class="lineCov">     418839 :           import_initvec[it-&gt;second] = ii;</span>
<span class="lineNum">     519 </span>            :         }
<span class="lineNum">     520 </span>            : 
<span class="lineNum">     521 </span>            :       // Init graph format is:
<span class="lineNum">     522 </span>            :       //
<span class="lineNum">     523 </span>            :       //    init_graph &lt;src1&gt; &lt;sink1&gt; &lt;src2&gt; &lt;sink2&gt; ... ;
<span class="lineNum">     524 </span>            :       //
<span class="lineNum">     525 </span>            :       // where src + sink are init functions indices.
<span class="lineNum">     526 </span>            : 
<span class="lineNum">     527 </span><span class="lineCov">     813013 :       while (!this-&gt;match_c_string(&quot;;&quot;))</span>
<span class="lineNum">     528 </span>            :         {
<span class="lineNum">     529 </span><span class="lineCov">     800465 :           this-&gt;require_c_string(&quot; &quot;);</span>
<span class="lineNum">     530 </span><span class="lineCov">    1600930 :           std::string src_string = this-&gt;read_identifier();</span>
<span class="lineNum">     531 </span><span class="lineCov">     800465 :           unsigned src;</span>
<span class="lineNum">     532 </span><span class="lineCov">    1600930 :           if (!this-&gt;string_to_unsigned(src_string, &amp;src)) return;</span>
<span class="lineNum">     533 </span>            : 
<span class="lineNum">     534 </span><span class="lineCov">     800465 :           this-&gt;require_c_string(&quot; &quot;);</span>
<span class="lineNum">     535 </span><span class="lineCov">    1600930 :           std::string sink_string = this-&gt;read_identifier();</span>
<span class="lineNum">     536 </span><span class="lineCov">     800465 :           unsigned sink;</span>
<span class="lineNum">     537 </span><span class="lineCov">    1600930 :           if (!this-&gt;string_to_unsigned(sink_string, &amp;sink)) return;</span>
<span class="lineNum">     538 </span>            : 
<span class="lineNum">     539 </span><span class="lineCov">    1600930 :           go_assert(src &lt; import_initvec.size());</span>
<span class="lineNum">     540 </span><span class="lineCov">     800465 :           Import_init* ii_src = import_initvec[src];</span>
<span class="lineNum">     541 </span><span class="lineCov">     800465 :           go_assert(sink &lt; import_initvec.size());</span>
<span class="lineNum">     542 </span><span class="lineCov">     800465 :           Import_init* ii_sink = import_initvec[sink];</span>
<span class="lineNum">     543 </span>            : 
<span class="lineNum">     544 </span><span class="lineCov">    1856762 :           ii_src-&gt;record_precursor_fcn(ii_sink-&gt;init_name());</span>
<span class="lineNum">     545 </span>            :         }
<span class="lineNum">     546 </span><span class="lineCov">      12548 :       this-&gt;require_c_string(&quot;;\n&quot;);</span>
<span class="lineNum">     547 </span>            :     }
<span class="lineNum">     548 </span>            : }
<span class="lineNum">     549 </span>            : 
<span class="lineNum">     550 </span>            : // Import a constant.
<span class="lineNum">     551 </span>            : 
<span class="lineNum">     552 </span>            : void
<span class="lineNum">     553 </span><span class="lineCov">     490885 : Import::import_const()</span>
<span class="lineNum">     554 </span>            : {
<span class="lineNum">     555 </span><span class="lineCov">     490885 :   std::string name;</span>
<span class="lineNum">     556 </span><span class="lineCov">     490885 :   Type* type;</span>
<span class="lineNum">     557 </span><span class="lineCov">     490885 :   Expression* expr;</span>
<span class="lineNum">     558 </span><span class="lineCov">     490885 :   Named_constant::import_const(this, &amp;name, &amp;type, &amp;expr);</span>
<span class="lineNum">     559 </span><span class="lineCov">    1100004 :   Typed_identifier tid(name, type, this-&gt;location_);</span>
<span class="lineNum">     560 </span><span class="lineCov">     490885 :   Named_object* no = this-&gt;package_-&gt;add_constant(tid, expr);</span>
<span class="lineNum">     561 </span><span class="lineCov">     490885 :   if (this-&gt;add_to_globals_)</span>
<span class="lineNum">     562 </span><span class="lineCov">        797 :     this-&gt;gogo_-&gt;add_dot_import_object(no);</span>
<span class="lineNum">     563 </span><span class="lineCov">     490885 : }</span>
<span class="lineNum">     564 </span>            : 
<span class="lineNum">     565 </span>            : // Import a type.
<a name="566"><span class="lineNum">     566 </span>            : </a>
<span class="lineNum">     567 </span>            : void
<span class="lineNum">     568 </span><span class="lineCov">     109251 : Import::import_type()</span>
<span class="lineNum">     569 </span>            : {
<span class="lineNum">     570 </span><span class="lineCov">     109251 :   Named_type* type;</span>
<span class="lineNum">     571 </span><span class="lineCov">     109251 :   Named_type::import_named_type(this, &amp;type);</span>
<span class="lineNum">     572 </span>            : 
<span class="lineNum">     573 </span>            :   // The named type has been added to the package by the type import
<span class="lineNum">     574 </span>            :   // process.  Here we need to make it visible to the parser, and it
<span class="lineNum">     575 </span>            :   // to the global bindings if necessary.
<span class="lineNum">     576 </span><span class="lineCov">     109251 :   type-&gt;set_is_visible();</span>
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span><span class="lineCov">     109251 :   if (this-&gt;add_to_globals_)</span>
<span class="lineNum">     579 </span><span class="lineCov">        516 :     this-&gt;gogo_-&gt;add_named_type(type);</span>
<span class="lineNum">     580 </span><span class="lineCov">     109251 : }</span>
<span class="lineNum">     581 </span>            : 
<span class="lineNum">     582 </span>            : // Import a variable.
<span class="lineNum">     583 </span>            : 
<span class="lineNum">     584 </span>            : void
<span class="lineNum">     585 </span><span class="lineCov">      75338 : Import::import_var()</span>
<span class="lineNum">     586 </span>            : {
<span class="lineNum">     587 </span><span class="lineCov">     150676 :   std::string name;</span>
<span class="lineNum">     588 </span><span class="lineCov">      75338 :   Type* type;</span>
<span class="lineNum">     589 </span><span class="lineCov">      75338 :   Variable::import_var(this, &amp;name, &amp;type);</span>
<span class="lineNum">     590 </span><span class="lineCov">      75338 :   Variable* var = new Variable(type, NULL, true, false, false,</span>
<span class="lineNum">     591 </span><span class="lineCov">      75338 :                                this-&gt;location_);</span>
<span class="lineNum">     592 </span><span class="lineCov">      75338 :   Named_object* no;</span>
<span class="lineNum">     593 </span><span class="lineCov">      75338 :   no = this-&gt;package_-&gt;add_variable(name, var);</span>
<span class="lineNum">     594 </span><span class="lineCov">      75338 :   if (this-&gt;add_to_globals_)</span>
<span class="lineNum">     595 </span><span class="lineCov">        684 :     this-&gt;gogo_-&gt;add_dot_import_object(no);</span>
<span class="lineNum">     596 </span><span class="lineCov">      75338 : }</span>
<span class="lineNum">     597 </span>            : 
<span class="lineNum">     598 </span>            : // Import a function into PACKAGE.  PACKAGE is normally
<span class="lineNum">     599 </span>            : // THIS-&gt;PACKAGE_, but it will be different for a method associated
<span class="lineNum">     600 </span>            : // with a type defined in a different package.
<span class="lineNum">     601 </span>            : 
<span class="lineNum">     602 </span>            : Named_object*
<span class="lineNum">     603 </span><span class="lineCov">    1297917 : Import::import_func(Package* package)</span>
<span class="lineNum">     604 </span>            : {
<span class="lineNum">     605 </span><span class="lineCov">    2595834 :   std::string name;</span>
<span class="lineNum">     606 </span><span class="lineCov">    1297917 :   Typed_identifier* receiver;</span>
<span class="lineNum">     607 </span><span class="lineCov">    1297917 :   Typed_identifier_list* parameters;</span>
<span class="lineNum">     608 </span><span class="lineCov">    1297917 :   Typed_identifier_list* results;</span>
<span class="lineNum">     609 </span><span class="lineCov">    1297917 :   bool is_varargs;</span>
<span class="lineNum">     610 </span><span class="lineCov">    1297917 :   bool nointerface;</span>
<span class="lineNum">     611 </span><span class="lineCov">    1297917 :   Function::import_func(this, &amp;name, &amp;receiver,</span>
<span class="lineNum">     612 </span>            :                         &amp;parameters, &amp;results, &amp;is_varargs, &amp;nointerface);
<span class="lineNum">     613 </span><span class="lineCov">    1297917 :   Function_type *fntype = Type::make_function_type(receiver, parameters,</span>
<span class="lineNum">     614 </span>            :                                                    results, this-&gt;location_);
<span class="lineNum">     615 </span><span class="lineCov">    1297917 :   if (is_varargs)</span>
<span class="lineNum">     616 </span><span class="lineCov">      34001 :     fntype-&gt;set_is_varargs();</span>
<span class="lineNum">     617 </span>            : 
<span class="lineNum">     618 </span><span class="lineCov">    1297917 :   Location loc = this-&gt;location_;</span>
<span class="lineNum">     619 </span><span class="lineCov">    1297917 :   Named_object* no;</span>
<span class="lineNum">     620 </span><span class="lineCov">    2595834 :   if (fntype-&gt;is_method())</span>
<span class="lineNum">     621 </span>            :     {
<span class="lineNum">     622 </span><span class="lineCov">     953287 :       Type* rtype = receiver-&gt;type();</span>
<span class="lineNum">     623 </span>            : 
<span class="lineNum">     624 </span>            :       // We may still be reading the definition of RTYPE, so we have
<span class="lineNum">     625 </span>            :       // to be careful to avoid calling base or convert.  If RTYPE is
<span class="lineNum">     626 </span>            :       // a named type or a forward declaration, then we know that it
<span class="lineNum">     627 </span>            :       // is not a pointer, because we are reading a method on RTYPE
<span class="lineNum">     628 </span>            :       // and named pointers can't have methods.
<span class="lineNum">     629 </span>            : 
<span class="lineNum">     630 </span><span class="lineCov">    1906574 :       if (rtype-&gt;classification() == Type::TYPE_POINTER)</span>
<span class="lineNum">     631 </span><span class="lineCov">     658290 :         rtype = rtype-&gt;points_to();</span>
<span class="lineNum">     632 </span>            : 
<span class="lineNum">     633 </span><span class="lineCov">     953287 :       if (rtype-&gt;is_error_type())</span>
<span class="lineNum">     634 </span>            :         return NULL;
<span class="lineNum">     635 </span><span class="lineCov">     953287 :       else if (rtype-&gt;named_type() != NULL)</span>
<span class="lineNum">     636 </span><span class="lineCov">     953287 :         no = rtype-&gt;named_type()-&gt;add_method_declaration(name, package, fntype,</span>
<span class="lineNum">     637 </span>            :                                                          loc);
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :       else if (rtype-&gt;forward_declaration_type() != NULL)</span>
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :         no = rtype-&gt;forward_declaration_type()-&gt;add_method_declaration(name,</span>
<span class="lineNum">     640 </span>            :                                                                        package,
<span class="lineNum">     641 </span>            :                                                                        fntype,
<span class="lineNum">     642 </span>            :                                                                        loc);
<span class="lineNum">     643 </span>            :       else
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :         go_unreachable();</span>
<span class="lineNum">     645 </span>            :     }
<span class="lineNum">     646 </span>            :   else
<span class="lineNum">     647 </span>            :     {
<span class="lineNum">     648 </span><span class="lineCov">     344630 :       no = package-&gt;add_function_declaration(name, fntype, loc);</span>
<span class="lineNum">     649 </span><span class="lineCov">     344630 :       if (this-&gt;add_to_globals_)</span>
<span class="lineNum">     650 </span><span class="lineCov">       1427 :         this-&gt;gogo_-&gt;add_dot_import_object(no);</span>
<span class="lineNum">     651 </span>            :     }
<span class="lineNum">     652 </span>            : 
<span class="lineNum">     653 </span><span class="lineCov">    1297917 :   if (nointerface)</span>
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :     no-&gt;func_declaration_value()-&gt;set_nointerface();</span>
<span class="lineNum">     655 </span>            : 
<span class="lineNum">     656 </span>            :   return no;
<span class="lineNum">     657 </span>            : }
<span class="lineNum">     658 </span>            : 
<span class="lineNum">     659 </span>            : // Read a type in the import stream.  This records the type by the
<span class="lineNum">     660 </span>            : // type index.  If the type is named, it registers the name, but marks
<span class="lineNum">     661 </span>            : // it as invisible.
<span class="lineNum">     662 </span>            : 
<span class="lineNum">     663 </span>            : Type*
<span class="lineNum">     664 </span><span class="lineCov">    5766960 : Import::read_type()</span>
<span class="lineNum">     665 </span>            : {
<span class="lineNum">     666 </span><span class="lineCov">    5766960 :   Stream* stream = this-&gt;stream_;</span>
<span class="lineNum">     667 </span><span class="lineCov">    5766960 :   this-&gt;require_c_string(&quot;&lt;type &quot;);</span>
<span class="lineNum">     668 </span>            : 
<span class="lineNum">     669 </span><span class="lineCov">   11533920 :   std::string number;</span>
<span class="lineNum">     670 </span><span class="lineCov">   19941693 :   int c;</span>
<span class="lineNum">     671 </span><span class="lineCov">   19941693 :   while (true)</span>
<span class="lineNum">     672 </span>            :     {
<span class="lineNum">     673 </span><span class="lineCov">   19941693 :       c = stream-&gt;get_char();</span>
<span class="lineNum">     674 </span><span class="lineCov">   19941693 :       if (c != '-' &amp;&amp; (c &lt; '0' || c &gt; '9'))</span>
<span class="lineNum">     675 </span>            :         break;
<span class="lineNum">     676 </span><span class="lineCov">   14174733 :       number += c;</span>
<span class="lineNum">     677 </span>            :     }
<span class="lineNum">     678 </span>            : 
<span class="lineNum">     679 </span><span class="lineCov">    5766960 :   int index;</span>
<span class="lineNum">     680 </span><span class="lineCov">    5766960 :   if (!this-&gt;string_to_int(number, true, &amp;index))</span>
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :     return Type::make_error_type();</span>
<span class="lineNum">     682 </span>            : 
<span class="lineNum">     683 </span><span class="lineCov">    5766960 :   if (c == '&gt;')</span>
<span class="lineNum">     684 </span>            :     {
<span class="lineNum">     685 </span>            :       // This type was already defined.
<span class="lineNum">     686 </span><span class="lineCov">    4471777 :       if (index &lt; 0</span>
<span class="lineNum">     687 </span><span class="lineCov">    4471777 :           ? (static_cast&lt;size_t&gt;(- index) &gt;= this-&gt;builtin_types_.size()</span>
<span class="lineNum">     688 </span><span class="lineCov">    2655604 :              || this-&gt;builtin_types_[- index] == NULL)</span>
<span class="lineNum">     689 </span><span class="lineCov">    1816173 :           : (static_cast&lt;size_t&gt;(index) &gt;= this-&gt;types_.size()</span>
<span class="lineNum">     690 </span><span class="lineCov">    1816173 :              || this-&gt;types_[index] == NULL))</span>
<span class="lineNum">     691 </span>            :         {
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :           go_error_at(this-&gt;location_,</span>
<span class="lineNum">     693 </span>            :                       &quot;error in import data at %d: bad type index %d&quot;,
<span class="lineNum">     694 </span>            :                       stream-&gt;pos(), index);
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :           stream-&gt;set_saw_error();</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :           return Type::make_error_type();</span>
<span class="lineNum">     697 </span>            :         }
<span class="lineNum">     698 </span>            : 
<span class="lineNum">     699 </span><span class="lineCov">    4471777 :       return index &lt; 0 ? this-&gt;builtin_types_[- index] : this-&gt;types_[index];</span>
<span class="lineNum">     700 </span>            :     }
<span class="lineNum">     701 </span>            : 
<span class="lineNum">     702 </span><span class="lineCov">    1295183 :   if (c != ' ')</span>
<span class="lineNum">     703 </span>            :     {
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :       if (!stream-&gt;saw_error())</span>
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :         go_error_at(this-&gt;location_,</span>
<span class="lineNum">     706 </span>            :                     &quot;error in import data at %d: expect %&lt; %&gt; or %&lt;&gt;%&gt;'&quot;,
<span class="lineNum">     707 </span>            :                     stream-&gt;pos());
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :       stream-&gt;set_saw_error();</span>
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :       stream-&gt;advance(1);</span>
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :       return Type::make_error_type();</span>
<span class="lineNum">     711 </span>            :     }
<span class="lineNum">     712 </span>            : 
<span class="lineNum">     713 </span><span class="lineCov">    1295183 :   if (index &lt;= 0</span>
<span class="lineNum">     714 </span><span class="lineCov">    1295183 :       || (static_cast&lt;size_t&gt;(index) &lt; this-&gt;types_.size()</span>
<span class="lineNum">     715 </span><span class="lineCov">    2421938 :           &amp;&amp; this-&gt;types_[index] != NULL))</span>
<span class="lineNum">     716 </span>            :     {
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :       go_error_at(this-&gt;location_,</span>
<span class="lineNum">     718 </span>            :                   &quot;error in import data at %d: type index already defined&quot;,
<span class="lineNum">     719 </span>            :                   stream-&gt;pos());
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :       stream-&gt;set_saw_error();</span>
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :       return Type::make_error_type();</span>
<span class="lineNum">     722 </span>            :     }
<span class="lineNum">     723 </span>            : 
<span class="lineNum">     724 </span><span class="lineCov">    1295183 :   if (static_cast&lt;size_t&gt;(index) &gt;= this-&gt;types_.size())</span>
<span class="lineNum">     725 </span>            :     {
<span class="lineNum">     726 </span><span class="lineCov">     336856 :       int newsize = std::max(static_cast&lt;size_t&gt;(index) + 1,</span>
<span class="lineNum">     727 </span><span class="lineCov">      84214 :                              this-&gt;types_.size() * 2);</span>
<span class="lineNum">     728 </span><span class="lineCov">      84214 :       this-&gt;types_.resize(newsize, NULL);</span>
<span class="lineNum">     729 </span>            :     }
<span class="lineNum">     730 </span>            : 
<span class="lineNum">     731 </span><span class="lineCov">    1295183 :   if (stream-&gt;peek_char() != '&quot;')</span>
<span class="lineNum">     732 </span>            :     {
<span class="lineNum">     733 </span><span class="lineCov">    1030913 :       Type* type = Type::import_type(this);</span>
<span class="lineNum">     734 </span><span class="lineCov">    1030913 :       this-&gt;require_c_string(&quot;&gt;&quot;);</span>
<span class="lineNum">     735 </span><span class="lineCov">    1030913 :       this-&gt;types_[index] = type;</span>
<span class="lineNum">     736 </span><span class="lineCov">    1030913 :       return type;</span>
<span class="lineNum">     737 </span>            :     }
<span class="lineNum">     738 </span>            : 
<span class="lineNum">     739 </span>            :   // This type has a name.
<span class="lineNum">     740 </span>            : 
<span class="lineNum">     741 </span><span class="lineCov">     264270 :   stream-&gt;advance(1);</span>
<span class="lineNum">     742 </span><span class="lineCov">     264270 :   std::string type_name;</span>
<span class="lineNum">     743 </span><span class="lineCov">    3575473 :   while ((c = stream-&gt;get_char()) != '&quot;')</span>
<span class="lineNum">     744 </span><span class="lineCov">    3311203 :     type_name += c;</span>
<span class="lineNum">     745 </span>            : 
<span class="lineNum">     746 </span>            :   // If this type is in the package we are currently importing, the
<span class="lineNum">     747 </span>            :   // name will be .PKGPATH.NAME or simply NAME with no dots.
<span class="lineNum">     748 </span>            :   // Otherwise, a non-hidden symbol will be PKGPATH.NAME and a hidden
<span class="lineNum">     749 </span>            :   // symbol will be .PKGPATH.NAME.
<span class="lineNum">     750 </span><span class="lineCov">     528540 :   std::string pkgpath;</span>
<span class="lineNum">     751 </span><span class="lineCov">     264270 :   if (type_name.find('.') != std::string::npos)</span>
<span class="lineNum">     752 </span>            :     {
<span class="lineNum">     753 </span><span class="lineCov">     155019 :       size_t start = 0;</span>
<span class="lineNum">     754 </span><span class="lineCov">     310038 :       if (type_name[0] == '.')</span>
<span class="lineNum">     755 </span><span class="lineCov">      46819 :         start = 1;</span>
<span class="lineNum">     756 </span><span class="lineCov">     155019 :       size_t dot = type_name.rfind('.');</span>
<span class="lineNum">     757 </span><span class="lineCov">     155019 :       pkgpath = type_name.substr(start, dot - start);</span>
<span class="lineNum">     758 </span><span class="lineCov">     310038 :       if (type_name[0] != '.')</span>
<span class="lineNum">     759 </span><span class="lineCov">     108200 :         type_name.erase(0, dot + 1);</span>
<span class="lineNum">     760 </span>            :     }
<span class="lineNum">     761 </span>            : 
<span class="lineNum">     762 </span><span class="lineCov">     264270 :   this-&gt;require_c_string(&quot; &quot;);</span>
<span class="lineNum">     763 </span>            : 
<span class="lineNum">     764 </span>            :   // The package name may follow.  This is the name of the package in
<span class="lineNum">     765 </span>            :   // the package clause of that package.  The type name will include
<span class="lineNum">     766 </span>            :   // the pkgpath, which may be different.
<span class="lineNum">     767 </span><span class="lineCov">     528540 :   std::string package_name;</span>
<span class="lineNum">     768 </span><span class="lineCov">     264270 :   if (stream-&gt;peek_char() == '&quot;')</span>
<span class="lineNum">     769 </span>            :     {
<span class="lineNum">     770 </span><span class="lineCov">       4877 :       stream-&gt;advance(1);</span>
<span class="lineNum">     771 </span><span class="lineCov">      26119 :       while ((c = stream-&gt;get_char()) != '&quot;')</span>
<span class="lineNum">     772 </span><span class="lineCov">      21242 :         package_name += c;</span>
<span class="lineNum">     773 </span><span class="lineCov">       4877 :       this-&gt;require_c_string(&quot; &quot;);</span>
<span class="lineNum">     774 </span>            :     }
<span class="lineNum">     775 </span>            : 
<span class="lineNum">     776 </span><span class="lineCov">     264270 :   bool is_alias = false;</span>
<span class="lineNum">     777 </span><span class="lineCov">     264270 :   if (this-&gt;match_c_string(&quot;= &quot;))</span>
<span class="lineNum">     778 </span>            :     {
<span class="lineNum">     779 </span><span class="lineCov">          2 :       stream-&gt;advance(2);</span>
<span class="lineNum">     780 </span><span class="lineCov">          2 :       is_alias = true;</span>
<span class="lineNum">     781 </span>            :     }
<span class="lineNum">     782 </span>            : 
<span class="lineNum">     783 </span>            :   // Declare the type in the appropriate package.  If we haven't seen
<span class="lineNum">     784 </span>            :   // it before, mark it as invisible.  We declare it before we read
<span class="lineNum">     785 </span>            :   // the actual definition of the type, since the definition may refer
<span class="lineNum">     786 </span>            :   // to the type itself.
<span class="lineNum">     787 </span><span class="lineCov">     264270 :   Package* package;</span>
<span class="lineNum">     788 </span><span class="lineCov">     528540 :   if (pkgpath.empty() || pkgpath == this-&gt;gogo_-&gt;pkgpath())</span>
<span class="lineNum">     789 </span><span class="lineCov">     109251 :     package = this-&gt;package_;</span>
<span class="lineNum">     790 </span>            :   else
<span class="lineNum">     791 </span>            :     {
<span class="lineNum">     792 </span><span class="lineCov">     155019 :       package = this-&gt;gogo_-&gt;register_package(pkgpath, &quot;&quot;,</span>
<span class="lineNum">     793 </span>            :                                               Linemap::unknown_location());
<span class="lineNum">     794 </span><span class="lineCov">     310038 :       if (!package_name.empty())</span>
<span class="lineNum">     795 </span><span class="lineCov">       9754 :         package-&gt;set_package_name(package_name, this-&gt;location());</span>
<span class="lineNum">     796 </span>            :     }
<span class="lineNum">     797 </span>            : 
<span class="lineNum">     798 </span><span class="lineCov">     528540 :   Named_object* no = package-&gt;bindings()-&gt;lookup(type_name);</span>
<span class="lineNum">     799 </span><span class="lineCov">     264270 :   if (no == NULL)</span>
<span class="lineNum">     800 </span><span class="lineCov">     189883 :     no = package-&gt;add_type_declaration(type_name, this-&gt;location_);</span>
<span class="lineNum">     801 </span><span class="lineCov">     148774 :   else if (!no-&gt;is_type_declaration() &amp;&amp; !no-&gt;is_type())</span>
<span class="lineNum">     802 </span>            :     {
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :       go_error_at(this-&gt;location_, &quot;imported %&lt;%s.%s%&gt; both type and non-type&quot;,</span>
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :                   pkgpath.c_str(), Gogo::message_name(type_name).c_str());</span>
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :       stream-&gt;set_saw_error();</span>
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :       return Type::make_error_type();</span>
<span class="lineNum">     807 </span>            :     }
<span class="lineNum">     808 </span>            :   else
<span class="lineNum">     809 </span><span class="lineCov">     148774 :     go_assert(no-&gt;package() == package);</span>
<span class="lineNum">     810 </span>            : 
<span class="lineNum">     811 </span><span class="lineCov">     528540 :   if (this-&gt;types_[index] == NULL)</span>
<span class="lineNum">     812 </span>            :     {
<span class="lineNum">     813 </span><span class="lineCov">     528540 :       if (no-&gt;is_type_declaration())</span>
<span class="lineNum">     814 </span>            :         {
<span class="lineNum">     815 </span>            :           // FIXME: It's silly to make a forward declaration every time.
<span class="lineNum">     816 </span><span class="lineCov">     189883 :           this-&gt;types_[index] = Type::make_forward_declaration(no);</span>
<span class="lineNum">     817 </span>            :         }
<span class="lineNum">     818 </span>            :       else
<span class="lineNum">     819 </span>            :         {
<span class="lineNum">     820 </span><span class="lineCov">     148774 :           go_assert(no-&gt;is_type());</span>
<span class="lineNum">     821 </span><span class="lineCov">     148774 :           this-&gt;types_[index] = no-&gt;type_value();</span>
<span class="lineNum">     822 </span>            :         }
<span class="lineNum">     823 </span>            :     }
<span class="lineNum">     824 </span>            : 
<span class="lineNum">     825 </span>            :   // If there is no type definition, then this is just a forward
<span class="lineNum">     826 </span>            :   // declaration of a type defined in some other file.
<span class="lineNum">     827 </span><span class="lineCov">     264270 :   Type* type;</span>
<span class="lineNum">     828 </span><span class="lineCov">     264270 :   if (this-&gt;match_c_string(&quot;&gt;&quot;))</span>
<span class="lineNum">     829 </span><span class="lineNoCov">          0 :     type = this-&gt;types_[index];</span>
<span class="lineNum">     830 </span>            :   else
<span class="lineNum">     831 </span>            :     {
<span class="lineNum">     832 </span><span class="lineCov">     264270 :       type = this-&gt;read_type();</span>
<span class="lineNum">     833 </span>            : 
<span class="lineNum">     834 </span><span class="lineCov">     528540 :       if (no-&gt;is_type_declaration())</span>
<span class="lineNum">     835 </span>            :         {
<span class="lineNum">     836 </span>            :           // We can define the type now.
<span class="lineNum">     837 </span>            : 
<span class="lineNum">     838 </span><span class="lineCov">     189883 :           no = package-&gt;add_type(type_name, type, this-&gt;location_);</span>
<span class="lineNum">     839 </span><span class="lineCov">     189883 :           Named_type* ntype = no-&gt;type_value();</span>
<span class="lineNum">     840 </span>            : 
<span class="lineNum">     841 </span>            :           // This type has not yet been imported.
<span class="lineNum">     842 </span><span class="lineCov">     189883 :           ntype-&gt;clear_is_visible();</span>
<span class="lineNum">     843 </span>            : 
<span class="lineNum">     844 </span><span class="lineCov">     189883 :           if (is_alias)</span>
<span class="lineNum">     845 </span><span class="lineCov">          2 :             ntype-&gt;set_is_alias();</span>
<span class="lineNum">     846 </span>            : 
<span class="lineNum">     847 </span><span class="lineCov">     189883 :           if (!type-&gt;is_undefined() &amp;&amp; type-&gt;interface_type() != NULL)</span>
<span class="lineNum">     848 </span><span class="lineCov">      74190 :             this-&gt;gogo_-&gt;record_interface_type(type-&gt;interface_type());</span>
<span class="lineNum">     849 </span>            : 
<span class="lineNum">     850 </span>            :           type = ntype;
<span class="lineNum">     851 </span>            :         }
<span class="lineNum">     852 </span><span class="lineCov">     148774 :       else if (no-&gt;is_type())</span>
<span class="lineNum">     853 </span>            :         {
<span class="lineNum">     854 </span>            :           // We have seen this type before.  FIXME: it would be a good
<span class="lineNum">     855 </span>            :           // idea to check that the two imported types are identical,
<span class="lineNum">     856 </span>            :           // but we have not finalized the methods yet, which means
<span class="lineNum">     857 </span>            :           // that we can not reliably compare interface types.
<span class="lineNum">     858 </span><span class="lineCov">     148774 :           type = no-&gt;type_value();</span>
<span class="lineNum">     859 </span>            : 
<span class="lineNum">     860 </span>            :           // Don't change the visibility of the existing type.
<span class="lineNum">     861 </span>            :         }
<span class="lineNum">     862 </span>            : 
<span class="lineNum">     863 </span><span class="lineCov">     264270 :       this-&gt;types_[index] = type;</span>
<span class="lineNum">     864 </span>            : 
<span class="lineNum">     865 </span>            :       // Read the type methods.
<span class="lineNum">     866 </span><span class="lineCov">     264270 :       if (this-&gt;match_c_string(&quot;\n&quot;))</span>
<span class="lineNum">     867 </span>            :         {
<span class="lineNum">     868 </span><span class="lineCov">     127242 :           this-&gt;advance(1);</span>
<span class="lineNum">     869 </span><span class="lineCov">    1080529 :           while (this-&gt;match_c_string(&quot; func&quot;))</span>
<span class="lineNum">     870 </span>            :             {
<span class="lineNum">     871 </span><span class="lineCov">     953287 :               this-&gt;advance(1);</span>
<span class="lineNum">     872 </span><span class="lineCov">     953287 :               this-&gt;import_func(package);</span>
<span class="lineNum">     873 </span>            :             }
<span class="lineNum">     874 </span>            :         }
<span class="lineNum">     875 </span>            :     }
<span class="lineNum">     876 </span>            : 
<span class="lineNum">     877 </span><span class="lineCov">     264270 :   this-&gt;require_c_string(&quot;&gt;&quot;);</span>
<span class="lineNum">     878 </span>            : 
<span class="lineNum">     879 </span><span class="lineCov">     264270 :   return type;</span>
<span class="lineNum">     880 </span>            : }
<span class="lineNum">     881 </span>            : 
<span class="lineNum">     882 </span>            : // Read an escape note.
<span class="lineNum">     883 </span>            : 
<span class="lineNum">     884 </span>            : std::string
<span class="lineNum">     885 </span><span class="lineCov">    2650677 : Import::read_escape()</span>
<span class="lineNum">     886 </span>            : {
<span class="lineNum">     887 </span><span class="lineCov">    2650677 :   if (this-&gt;match_c_string(&quot; &lt;esc:&quot;))</span>
<span class="lineNum">     888 </span>            :     {
<span class="lineNum">     889 </span><span class="lineCov">    1004822 :       Stream* stream = this-&gt;stream_;</span>
<span class="lineNum">     890 </span><span class="lineCov">    1004822 :       this-&gt;require_c_string(&quot; &lt;esc:&quot;);</span>
<span class="lineNum">     891 </span>            : 
<span class="lineNum">     892 </span><span class="lineCov">    3014466 :       std::string escape = &quot;esc:&quot;;</span>
<span class="lineNum">     893 </span><span class="lineCov">    4239236 :       int c;</span>
<span class="lineNum">     894 </span><span class="lineCov">    4239236 :       while (true)</span>
<span class="lineNum">     895 </span>            :         {
<span class="lineNum">     896 </span><span class="lineCov">    4239236 :           c = stream-&gt;get_char();</span>
<span class="lineNum">     897 </span><span class="lineCov">    4239236 :           if (c != 'x' &amp;&amp; !ISXDIGIT(c))</span>
<span class="lineNum">     898 </span>            :             break;
<span class="lineNum">     899 </span><span class="lineCov">    3234414 :           escape += c;</span>
<span class="lineNum">     900 </span>            :         }
<span class="lineNum">     901 </span>            : 
<span class="lineNum">     902 </span><span class="lineCov">    1004822 :       if (c != '&gt;')</span>
<span class="lineNum">     903 </span>            :         {
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :           go_error_at(this-&gt;location(),</span>
<span class="lineNum">     905 </span>            :                       (&quot;error in import data at %d: &quot;
<span class="lineNum">     906 </span>            :                        &quot;expect %&lt; %&gt; or %&lt;&gt;%&gt;, got %c&quot;),
<span class="lineNum">     907 </span>            :                       stream-&gt;pos(), c);
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :           stream-&gt;set_saw_error();</span>
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :           stream-&gt;advance(1);</span>
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :           escape = Escape_note::make_tag(Node::ESCAPE_UNKNOWN);</span>
<span class="lineNum">     911 </span>            :         }
<span class="lineNum">     912 </span><span class="lineCov">    2009644 :       return escape;</span>
<span class="lineNum">     913 </span>            :     }
<span class="lineNum">     914 </span>            :   else
<span class="lineNum">     915 </span><span class="lineCov">    1645855 :     return Escape_note::make_tag(Node::ESCAPE_UNKNOWN);</span>
<span class="lineNum">     916 </span>            : }
<span class="lineNum">     917 </span>            : 
<span class="lineNum">     918 </span>            : 
<span class="lineNum">     919 </span>            : // Register the builtin types.
<a name="920"><span class="lineNum">     920 </span>            : </a>
<span class="lineNum">     921 </span>            : void
<span class="lineNum">     922 </span><span class="lineCov">      14199 : Import::register_builtin_types(Gogo* gogo)</span>
<span class="lineNum">     923 </span>            : {
<span class="lineNum">     924 </span><span class="lineCov">      14199 :   this-&gt;register_builtin_type(gogo, &quot;int8&quot;, BUILTIN_INT8);</span>
<span class="lineNum">     925 </span><span class="lineCov">      14199 :   this-&gt;register_builtin_type(gogo, &quot;int16&quot;, BUILTIN_INT16);</span>
<span class="lineNum">     926 </span><span class="lineCov">      14199 :   this-&gt;register_builtin_type(gogo, &quot;int32&quot;, BUILTIN_INT32);</span>
<span class="lineNum">     927 </span><span class="lineCov">      14199 :   this-&gt;register_builtin_type(gogo, &quot;int64&quot;, BUILTIN_INT64);</span>
<span class="lineNum">     928 </span><span class="lineCov">      14199 :   this-&gt;register_builtin_type(gogo, &quot;uint8&quot;, BUILTIN_UINT8);</span>
<span class="lineNum">     929 </span><span class="lineCov">      14199 :   this-&gt;register_builtin_type(gogo, &quot;uint16&quot;, BUILTIN_UINT16);</span>
<span class="lineNum">     930 </span><span class="lineCov">      14199 :   this-&gt;register_builtin_type(gogo, &quot;uint32&quot;, BUILTIN_UINT32);</span>
<span class="lineNum">     931 </span><span class="lineCov">      14199 :   this-&gt;register_builtin_type(gogo, &quot;uint64&quot;, BUILTIN_UINT64);</span>
<span class="lineNum">     932 </span><span class="lineCov">      14199 :   this-&gt;register_builtin_type(gogo, &quot;float32&quot;, BUILTIN_FLOAT32);</span>
<span class="lineNum">     933 </span><span class="lineCov">      14199 :   this-&gt;register_builtin_type(gogo, &quot;float64&quot;, BUILTIN_FLOAT64);</span>
<span class="lineNum">     934 </span><span class="lineCov">      14199 :   this-&gt;register_builtin_type(gogo, &quot;complex64&quot;, BUILTIN_COMPLEX64);</span>
<span class="lineNum">     935 </span><span class="lineCov">      14199 :   this-&gt;register_builtin_type(gogo, &quot;complex128&quot;, BUILTIN_COMPLEX128);</span>
<span class="lineNum">     936 </span><span class="lineCov">      14199 :   this-&gt;register_builtin_type(gogo, &quot;int&quot;, BUILTIN_INT);</span>
<span class="lineNum">     937 </span><span class="lineCov">      14199 :   this-&gt;register_builtin_type(gogo, &quot;uint&quot;, BUILTIN_UINT);</span>
<span class="lineNum">     938 </span><span class="lineCov">      14199 :   this-&gt;register_builtin_type(gogo, &quot;uintptr&quot;, BUILTIN_UINTPTR);</span>
<span class="lineNum">     939 </span><span class="lineCov">      14199 :   this-&gt;register_builtin_type(gogo, &quot;bool&quot;, BUILTIN_BOOL);</span>
<span class="lineNum">     940 </span><span class="lineCov">      14199 :   this-&gt;register_builtin_type(gogo, &quot;string&quot;, BUILTIN_STRING);</span>
<span class="lineNum">     941 </span><span class="lineCov">      14199 :   this-&gt;register_builtin_type(gogo, &quot;error&quot;, BUILTIN_ERROR);</span>
<span class="lineNum">     942 </span><span class="lineCov">      14199 :   this-&gt;register_builtin_type(gogo, &quot;byte&quot;, BUILTIN_BYTE);</span>
<span class="lineNum">     943 </span><span class="lineCov">      14199 :   this-&gt;register_builtin_type(gogo, &quot;rune&quot;, BUILTIN_RUNE);</span>
<span class="lineNum">     944 </span><span class="lineCov">      14199 : }</span>
<span class="lineNum">     945 </span>            : 
<span class="lineNum">     946 </span>            : // Register a single builtin type.
<a name="947"><span class="lineNum">     947 </span>            : </a>
<span class="lineNum">     948 </span>            : void
<span class="lineNum">     949 </span><span class="lineCov">     283980 : Import::register_builtin_type(Gogo* gogo, const char* name, Builtin_code code)</span>
<span class="lineNum">     950 </span>            : {
<span class="lineNum">     951 </span><span class="lineCov">     283980 :   Named_object* named_object = gogo-&gt;lookup_global(name);</span>
<span class="lineNum">     952 </span><span class="lineCov">     283980 :   go_assert(named_object != NULL &amp;&amp; named_object-&gt;is_type());</span>
<span class="lineNum">     953 </span><span class="lineCov">     283980 :   int index = - static_cast&lt;int&gt;(code);</span>
<span class="lineNum">     954 </span><span class="lineCov">     283980 :   go_assert(index &gt; 0</span>
<span class="lineNum">     955 </span>            :              &amp;&amp; static_cast&lt;size_t&gt;(index) &lt; this-&gt;builtin_types_.size());
<span class="lineNum">     956 </span><span class="lineCov">     851940 :   this-&gt;builtin_types_[index] = named_object-&gt;type_value();</span>
<span class="lineNum">     957 </span><span class="lineCov">     283980 : }</span>
<span class="lineNum">     958 </span>            : 
<span class="lineNum">     959 </span>            : // Read an identifier from the stream.
<a name="960"><span class="lineNum">     960 </span>            : </a>
<span class="lineNum">     961 </span>            : std::string
<span class="lineNum">     962 </span><span class="lineCov">    8195881 : Import::read_identifier()</span>
<span class="lineNum">     963 </span>            : {
<span class="lineNum">     964 </span><span class="lineCov">    8195881 :   std::string ret;</span>
<span class="lineNum">     965 </span><span class="lineCov">    8195881 :   Stream* stream = this-&gt;stream_;</span>
<span class="lineNum">     966 </span><span class="lineCov">   50787531 :   int c;</span>
<span class="lineNum">     967 </span><span class="lineCov">   50787531 :   while (true)</span>
<span class="lineNum">     968 </span>            :     {
<span class="lineNum">     969 </span><span class="lineCov">   50787531 :       c = stream-&gt;peek_char();</span>
<span class="lineNum">     970 </span><span class="lineCov">   50787531 :       if (c == -1 || c == ' ' || c == ';')</span>
<span class="lineNum">     971 </span>            :         break;
<span class="lineNum">     972 </span><span class="lineCov">   42591650 :       ret += c;</span>
<span class="lineNum">     973 </span><span class="lineCov">   42591650 :       stream-&gt;advance(1);</span>
<span class="lineNum">     974 </span>            :     }
<span class="lineNum">     975 </span><span class="lineCov">    8195881 :   return ret;</span>
<span class="lineNum">     976 </span>            : }
<span class="lineNum">     977 </span>            : 
<span class="lineNum">     978 </span>            : // Read a name from the stream.
<span class="lineNum">     979 </span>            : 
<span class="lineNum">     980 </span>            : std::string
<span class="lineNum">     981 </span><span class="lineCov">    2859185 : Import::read_name()</span>
<span class="lineNum">     982 </span>            : {
<span class="lineNum">     983 </span><span class="lineCov">    2859185 :   std::string ret = this-&gt;read_identifier();</span>
<span class="lineNum">     984 </span><span class="lineCov">    2859185 :   if (ret == &quot;?&quot;)</span>
<span class="lineNum">     985 </span><span class="lineCov">     284801 :     ret.clear();</span>
<span class="lineNum">     986 </span><span class="lineCov">    2574384 :   else if (!Lex::is_exported_name(ret))</span>
<span class="lineNum">     987 </span><span class="lineCov">    5147098 :     ret = '.' + this-&gt;package_-&gt;pkgpath() + '.' + ret;</span>
<span class="lineNum">     988 </span><span class="lineCov">    2859185 :   return ret;</span>
<span class="lineNum">     989 </span>            : }
<span class="lineNum">     990 </span>            : 
<span class="lineNum">     991 </span>            : // Turn a string into a integer with appropriate error handling.
<a name="992"><span class="lineNum">     992 </span>            : </a>
<span class="lineNum">     993 </span>            : bool
<span class="lineNum">     994 </span><span class="lineCov">    7367890 : Import::string_to_int(const std::string &amp;s, bool is_neg_ok, int* ret)</span>
<span class="lineNum">     995 </span>            : {
<span class="lineNum">     996 </span><span class="lineCov">    7367890 :   char* end;</span>
<span class="lineNum">     997 </span><span class="lineCov">   14735780 :   long prio = strtol(s.c_str(), &amp;end, 10);</span>
<span class="lineNum">     998 </span><span class="lineCov">    7367890 :   if (*end != '\0' || prio &gt; 0x7fffffff || (prio &lt; 0 &amp;&amp; !is_neg_ok))</span>
<span class="lineNum">     999 </span>            :     {
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :       go_error_at(this-&gt;location_, &quot;invalid integer in import data at %d&quot;,</span>
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :                   this-&gt;stream_-&gt;pos());</span>
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :       this-&gt;stream_-&gt;set_saw_error();</span>
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    1004 </span>            :     }
<span class="lineNum">    1005 </span><span class="lineCov">    7367890 :   *ret = prio;</span>
<span class="lineNum">    1006 </span><span class="lineCov">    7367890 :   return true;</span>
<span class="lineNum">    1007 </span>            : }
<span class="lineNum">    1008 </span>            : 
<a name="1009"><span class="lineNum">    1009 </span>            : // Class Import::Stream.</a>
<span class="lineNum">    1010 </span>            : 
<span class="lineNum">    1011 </span><span class="lineCov">      14459 : Import::Stream::Stream()</span>
<span class="lineNum">    1012 </span><span class="lineCov">      14459 :   : pos_(0), saw_error_(false)</span>
<span class="lineNum">    1013 </span>            : {
<a name="1014"><span class="lineNum">    1014 </span><span class="lineCov">      14459 : }</span></a>
<span class="lineNum">    1015 </span>            : 
<span class="lineNum">    1016 </span><span class="lineCov">      14459 : Import::Stream::~Stream()</span>
<span class="lineNum">    1017 </span>            : {
<span class="lineNum">    1018 </span><span class="lineCov">      14459 : }</span>
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    1020 </span>            : // Return the next character to come from the stream.
<a name="1021"><span class="lineNum">    1021 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">    1022 </span><span class="lineCov">      14459 : int</span>
<span class="lineNum">    1023 </span>            : Import::Stream::peek_char()
<span class="lineNum">    1024 </span><span class="lineCov">      14459 : {</span>
<span class="lineNum">    1025 </span>            :   const char* read;
<span class="lineNum">    1026 </span>            :   if (!this-&gt;do_peek(1, &amp;read))
<span class="lineNum">    1027 </span>            :     return -1;
<span class="lineNum">    1028 </span>            :   // Make sure we return an unsigned char, so that we don't get
<span class="lineNum">    1029 </span><span class="lineCov">   93852405 :   // confused by \xff.</span>
<span class="lineNum">    1030 </span>            :   unsigned char ret = *read;
<span class="lineNum">    1031 </span><span class="lineCov">   93852405 :   return ret;</span>
<span class="lineNum">    1032 </span><span class="lineCov">   93852405 : }</span>
<span class="lineNum">    1033 </span>            : 
<span class="lineNum">    1034 </span>            : // Return true if the next LENGTH characters from the stream match
<span class="lineNum">    1035 </span>            : // BYTES
<a name="1036"><span class="lineNum">    1036 </span><span class="lineCov">   93838206 : </span></a>
<span class="lineNum">    1037 </span><span class="lineCov">   93838206 : bool</span>
<span class="lineNum">    1038 </span>            : Import::Stream::match_bytes(const char* bytes, size_t length)
<span class="lineNum">    1039 </span>            : {
<span class="lineNum">    1040 </span>            :   const char* read;
<span class="lineNum">    1041 </span>            :   if (!this-&gt;do_peek(length, &amp;read))
<span class="lineNum">    1042 </span>            :     return false;
<span class="lineNum">    1043 </span>            :   return memcmp(bytes, read, length) == 0;
<span class="lineNum">    1044 </span><span class="lineCov">   17982990 : }</span>
<span class="lineNum">    1045 </span>            : 
<span class="lineNum">    1046 </span><span class="lineCov">   17982990 : // Require that the next LENGTH bytes from the stream match BYTES.</span>
<a name="1047"><span class="lineNum">    1047 </span><span class="lineCov">   17982990 : </span></a>
<span class="lineNum">    1048 </span>            : void
<span class="lineNum">    1049 </span><span class="lineCov">   17982990 : Import::Stream::require_bytes(Location location, const char* bytes,</span>
<span class="lineNum">    1050 </span>            :                               size_t length)
<span class="lineNum">    1051 </span>            : {
<span class="lineNum">    1052 </span>            :   const char* read;
<span class="lineNum">    1053 </span>            :   if (!this-&gt;do_peek(length, &amp;read)
<span class="lineNum">    1054 </span>            :       || memcmp(bytes, read, length) != 0)
<span class="lineNum">    1055 </span><span class="lineCov">   29850382 :     {</span>
<span class="lineNum">    1056 </span>            :       if (!this-&gt;saw_error_)
<span class="lineNum">    1057 </span>            :         go_error_at(location, &quot;import error at %d: expected %&lt;%.*s%&gt;&quot;,
<span class="lineNum">    1058 </span><span class="lineCov">   29850382 :                     this-&gt;pos(), static_cast&lt;int&gt;(length), bytes);</span>
<span class="lineNum">    1059 </span><span class="lineCov">   29850382 :       this-&gt;saw_error_ = true;</span>
<span class="lineNum">    1060 </span><span class="lineCov">   29850382 :       return;</span>
<span class="lineNum">    1061 </span>            :     }
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :   this-&gt;advance(length);</span>
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1064 </span>            : 
<a name="1065"><span class="lineNum">    1065 </span><span class="lineNoCov">          0 : // Class Stream_from_file.</span></a>
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    1067 </span>            : Stream_from_file::Stream_from_file(int fd)
<span class="lineNum">    1068 </span><span class="lineCov">   29850382 :   : fd_(fd), data_()</span>
<span class="lineNum">    1069 </span>            : {
<span class="lineNum">    1070 </span>            :   if (lseek(fd, 0, SEEK_SET) != 0)
<span class="lineNum">    1071 </span>            :     {
<span class="lineNum">    1072 </span>            :       go_fatal_error(Linemap::unknown_location(), &quot;lseek failed: %m&quot;);
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :       this-&gt;set_saw_error();</span>
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :     }</span>
<a name="1075"><span class="lineNum">    1075 </span>            : }</a>
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    1077 </span>            : Stream_from_file::~Stream_from_file()
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 :   close(this-&gt;fd_);</span>
<span class="lineNum">    1080 </span>            : }
<span class="lineNum">    1081 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    1082 </span>            : // Read next bytes.
<a name="1083"><span class="lineNum">    1083 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">    1084 </span>            : bool
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 : Stream_from_file::do_peek(size_t length, const char** bytes)</span>
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :   if (this-&gt;data_.length() &lt;= length)</span>
<span class="lineNum">    1088 </span>            :     {
<span class="lineNum">    1089 </span>            :       *bytes = this-&gt;data_.data();
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 :       return true;</span>
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1092 </span>            :   // Don't bother to handle the general case, since we don't need it.
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :   go_assert(length &lt; 64);</span>
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :   char buf[64];</span>
<span class="lineNum">    1095 </span>            :   ssize_t got = read(this-&gt;fd_, buf, length);
<span class="lineNum">    1096 </span>            : 
<span class="lineNum">    1097 </span>            :   if (got &lt; 0)
<span class="lineNum">    1098 </span>            :     {
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :       if (!this-&gt;saw_error())</span>
<span class="lineNum">    1100 </span>            :         go_fatal_error(Linemap::unknown_location(), &quot;read failed: %m&quot;);
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :       this-&gt;set_saw_error();</span>
<span class="lineNum">    1102 </span>            :       return false;
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    1105 </span>            :   if (lseek(this-&gt;fd_, - got, SEEK_CUR) != 0)
<span class="lineNum">    1106 </span>            :     {
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :       if (!this-&gt;saw_error())</span>
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :         go_fatal_error(Linemap::unknown_location(), &quot;lseek failed: %m&quot;);</span>
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :       this-&gt;set_saw_error();</span>
<span class="lineNum">    1110 </span>            :       return false;
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1112 </span>            : 
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :   if (static_cast&lt;size_t&gt;(got) &lt; length)</span>
<span class="lineNum">    1114 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 :   this-&gt;data_.assign(buf, got);</span>
<span class="lineNum">    1117 </span>            : 
<span class="lineNum">    1118 </span>            :   *bytes = this-&gt;data_.data();
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    1120 </span>            : }
<span class="lineNum">    1121 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    1122 </span><span class="lineNoCov">          0 : // Advance.</span>
<a name="1123"><span class="lineNum">    1123 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 : void</span>
<span class="lineNum">    1125 </span>            : Stream_from_file::do_advance(size_t skip)
<span class="lineNum">    1126 </span>            : {
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :   if (lseek(this-&gt;fd_, skip, SEEK_CUR) != 0)</span>
<span class="lineNum">    1128 </span>            :     {
<span class="lineNum">    1129 </span>            :       if (!this-&gt;saw_error())
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :         go_fatal_error(Linemap::unknown_location(), &quot;lseek failed: %m&quot;);</span>
<span class="lineNum">    1131 </span>            :       this-&gt;set_saw_error();
<span class="lineNum">    1132 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :   if (!this-&gt;data_.empty())</span>
<span class="lineNum">    1134 </span>            :     {
<span class="lineNum">    1135 </span>            :       if (this-&gt;data_.length() &lt; skip)
<span class="lineNum">    1136 </span>            :         this-&gt;data_.erase(0, skip);
<span class="lineNum">    1137 </span>            :       else
<span class="lineNum">    1138 </span>            :         this-&gt;data_.clear();
<span class="lineNum">    1139 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1140 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.0</a></td></tr>
  </table>
  <br>
<h3>LCOV profile is generated on x86_64 machine using following configure options: configure --disable-bootstrap --enable-coverage=opt --enable-languages=c,c++,fortran,go,jit,lto --enable-host-shared. GCC test suite is run with the built compiler.</h3></body></html>
