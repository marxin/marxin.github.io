<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - gcc.info - gcc/go/gofrontend/backend.h</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">gcc/go/gofrontend</a> - backend.h<span style="font-size: 80%;"> (source / <a href="backend.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">gcc.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">3</td>
            <td class="headerCovTableEntry">4</td>
            <td class="headerCovTableEntryMed">75.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-09-22 10:58:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // backend.h -- Go frontend interface to backend  -*- C++ -*-</a>
<span class="lineNum">       2 </span>            : 
<span class="lineNum">       3 </span>            : // Copyright 2011 The Go Authors. All rights reserved.
<span class="lineNum">       4 </span>            : // Use of this source code is governed by a BSD-style
<span class="lineNum">       5 </span>            : // license that can be found in the LICENSE file.
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : #ifndef GO_BACKEND_H
<span class="lineNum">       8 </span>            : #define GO_BACKEND_H
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            : #include &lt;gmp.h&gt;
<span class="lineNum">      11 </span>            : #include &lt;mpfr.h&gt;
<span class="lineNum">      12 </span>            : #include &lt;mpc.h&gt;
<span class="lineNum">      13 </span>            : 
<span class="lineNum">      14 </span>            : #include &quot;operator.h&quot;
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : // Pointers to these types are created by the backend, passed to the
<span class="lineNum">      17 </span>            : // frontend, and passed back to the backend.  The types must be
<span class="lineNum">      18 </span>            : // defined by the backend using these names.
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : // The backend representation of a type.
<span class="lineNum">      21 </span>            : class Btype;
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            : // The backend represention of an expression.
<span class="lineNum">      24 </span>            : class Bexpression;
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            : // The backend representation of a statement.
<span class="lineNum">      27 </span>            : class Bstatement;
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            : // The backend representation of a function definition or declaration.
<span class="lineNum">      30 </span>            : class Bfunction;
<span class="lineNum">      31 </span>            : 
<span class="lineNum">      32 </span>            : // The backend representation of a block.
<span class="lineNum">      33 </span>            : class Bblock;
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : // The backend representation of a variable.
<span class="lineNum">      36 </span>            : class Bvariable;
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : // The backend representation of a label.
<span class="lineNum">      39 </span>            : class Blabel;
<span class="lineNum">      40 </span>            : 
<span class="lineNum">      41 </span>            : // The backend interface.  This is a pure abstract class that a
<span class="lineNum">      42 </span>            : // specific backend will implement.
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span>            : class Backend
<a name="45"><span class="lineNum">      45 </span>            : {</a>
<span class="lineNum">      46 </span>            :  public:
<span class="lineNum">      47 </span><span class="lineNoCov">          0 :   virtual ~Backend() { }</span>
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            :   // Name/type/location.  Used for function parameters, struct fields,
<span class="lineNum">      50 </span>            :   // interface methods.
<span class="lineNum">      51 </span><span class="lineCov">    3813147 :   struct Btyped_identifier</span>
<span class="lineNum">      52 </span>            :   {
<span class="lineNum">      53 </span>            :     std::string name;
<span class="lineNum">      54 </span>            :     Btype* btype;
<span class="lineNum">      55 </span>            :     Location location;
<span class="lineNum">      56 </span>            : 
<span class="lineNum">      57 </span>            :     Btyped_identifier()
<span class="lineNum">      58 </span><span class="lineCov">    6509282 :         : name(), btype(NULL), location(Linemap::unknown_location())</span>
<span class="lineNum">      59 </span>            :     { }
<span class="lineNum">      60 </span>            : 
<span class="lineNum">      61 </span>            :     Btyped_identifier(const std::string&amp; a_name, Btype* a_btype,
<span class="lineNum">      62 </span>            :                      Location a_location)
<span class="lineNum">      63 </span><span class="lineCov">      73083 :       : name(a_name), btype(a_btype), location(a_location)</span>
<span class="lineNum">      64 </span>            :     { }
<span class="lineNum">      65 </span>            :   };
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span>            :   // Types.
<span class="lineNum">      68 </span>            : 
<span class="lineNum">      69 </span>            :   // Produce an error type.  Actually the backend could probably just
<span class="lineNum">      70 </span>            :   // crash if this is called.
<span class="lineNum">      71 </span>            :   virtual Btype*
<span class="lineNum">      72 </span>            :   error_type() = 0;
<span class="lineNum">      73 </span>            : 
<span class="lineNum">      74 </span>            :   // Get a void type.  This is used in (at least) two ways: 1) as the
<span class="lineNum">      75 </span>            :   // return type of a function with no result parameters; 2)
<span class="lineNum">      76 </span>            :   // unsafe.Pointer is represented as *void.
<span class="lineNum">      77 </span>            :   virtual Btype*
<span class="lineNum">      78 </span>            :   void_type() = 0;
<span class="lineNum">      79 </span>            : 
<span class="lineNum">      80 </span>            :   // Get the unnamed boolean type.
<span class="lineNum">      81 </span>            :   virtual Btype*
<span class="lineNum">      82 </span>            :   bool_type() = 0;
<span class="lineNum">      83 </span>            : 
<span class="lineNum">      84 </span>            :   // Get an unnamed integer type with the given signedness and number
<span class="lineNum">      85 </span>            :   // of bits.
<span class="lineNum">      86 </span>            :   virtual Btype*
<span class="lineNum">      87 </span>            :   integer_type(bool is_unsigned, int bits) = 0;
<span class="lineNum">      88 </span>            : 
<span class="lineNum">      89 </span>            :   // Get an unnamed floating point type with the given number of bits
<span class="lineNum">      90 </span>            :   // (32 or 64).
<span class="lineNum">      91 </span>            :   virtual Btype*
<span class="lineNum">      92 </span>            :   float_type(int bits) = 0;
<span class="lineNum">      93 </span>            : 
<span class="lineNum">      94 </span>            :   // Get an unnamed complex type with the given number of bits (64 or 128).
<span class="lineNum">      95 </span>            :   virtual Btype*
<span class="lineNum">      96 </span>            :   complex_type(int bits) = 0;
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span>            :   // Get a pointer type.
<span class="lineNum">      99 </span>            :   virtual Btype*
<span class="lineNum">     100 </span>            :   pointer_type(Btype* to_type) = 0;
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            :   // Get a function type.  The receiver, parameter, and results are
<span class="lineNum">     103 </span>            :   // generated from the types in the Function_type.  The Function_type
<span class="lineNum">     104 </span>            :   // is provided so that the names are available.  This should return
<span class="lineNum">     105 </span>            :   // not the type of a Go function (which is a pointer to a struct)
<span class="lineNum">     106 </span>            :   // but the type of a C function pointer (which will be used as the
<span class="lineNum">     107 </span>            :   // type of the first field of the struct).  If there is more than
<span class="lineNum">     108 </span>            :   // one result, RESULT_STRUCT is a struct type to hold the results,
<span class="lineNum">     109 </span>            :   // and RESULTS may be ignored; if there are zero or one results,
<span class="lineNum">     110 </span>            :   // RESULT_STRUCT is NULL.
<span class="lineNum">     111 </span>            :   virtual Btype*
<span class="lineNum">     112 </span>            :   function_type(const Btyped_identifier&amp; receiver,
<span class="lineNum">     113 </span>            :                 const std::vector&lt;Btyped_identifier&gt;&amp; parameters,
<span class="lineNum">     114 </span>            :                 const std::vector&lt;Btyped_identifier&gt;&amp; results,
<span class="lineNum">     115 </span>            :                 Btype* result_struct,
<span class="lineNum">     116 </span>            :                 Location location) = 0;
<span class="lineNum">     117 </span>            : 
<span class="lineNum">     118 </span>            :   // Get a struct type.
<span class="lineNum">     119 </span>            :   virtual Btype*
<span class="lineNum">     120 </span>            :   struct_type(const std::vector&lt;Btyped_identifier&gt;&amp; fields) = 0;
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span>            :   // Get an array type.
<span class="lineNum">     123 </span>            :   virtual Btype*
<span class="lineNum">     124 </span>            :   array_type(Btype* element_type, Bexpression* length) = 0;
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span>            :   // Create a placeholder pointer type.  This is used for a named
<span class="lineNum">     127 </span>            :   // pointer type, since in Go a pointer type may refer to itself.
<span class="lineNum">     128 </span>            :   // NAME is the name of the type, and the location is where the named
<span class="lineNum">     129 </span>            :   // type is defined.  This function is also used for unnamed function
<span class="lineNum">     130 </span>            :   // types with multiple results, in which case the type has no name
<span class="lineNum">     131 </span>            :   // and NAME will be empty.  FOR_FUNCTION is true if this is for a C
<span class="lineNum">     132 </span>            :   // pointer to function type.  A Go func type is represented as a
<span class="lineNum">     133 </span>            :   // pointer to a struct, and the first field of the struct is a C
<span class="lineNum">     134 </span>            :   // pointer to function.  The return value will later be passed as
<span class="lineNum">     135 </span>            :   // the first parameter to set_placeholder_pointer_type or
<span class="lineNum">     136 </span>            :   // set_placeholder_function_type.
<span class="lineNum">     137 </span>            :   virtual Btype*
<span class="lineNum">     138 </span>            :   placeholder_pointer_type(const std::string&amp; name, Location,
<span class="lineNum">     139 </span>            :                            bool for_function) = 0;
<span class="lineNum">     140 </span>            : 
<span class="lineNum">     141 </span>            :   // Fill in a placeholder pointer type as a pointer.  This takes a
<span class="lineNum">     142 </span>            :   // type returned by placeholder_pointer_type and arranges for it to
<span class="lineNum">     143 </span>            :   // point to the type that TO_TYPE points to (that is, PLACEHOLDER
<span class="lineNum">     144 </span>            :   // becomes the same type as TO_TYPE).  Returns true on success,
<span class="lineNum">     145 </span>            :   // false on failure.
<span class="lineNum">     146 </span>            :   virtual bool
<span class="lineNum">     147 </span>            :   set_placeholder_pointer_type(Btype* placeholder, Btype* to_type) = 0;
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span>            :   // Fill in a placeholder pointer type as a function.  This takes a
<span class="lineNum">     150 </span>            :   // type returned by placeholder_pointer_type and arranges for it to
<span class="lineNum">     151 </span>            :   // become a real Go function type (which corresponds to a C/C++
<span class="lineNum">     152 </span>            :   // pointer to function type).  FT will be something returned by the
<span class="lineNum">     153 </span>            :   // function_type method.  Returns true on success, false on failure.
<span class="lineNum">     154 </span>            :   virtual bool
<span class="lineNum">     155 </span>            :   set_placeholder_function_type(Btype* placeholder, Btype* ft) = 0;
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span>            :   // Create a placeholder struct type.  This is used for a named
<span class="lineNum">     158 </span>            :   // struct type, as with placeholder_pointer_type.  It is also used
<span class="lineNum">     159 </span>            :   // for interface types, in which case NAME will be the empty string.
<span class="lineNum">     160 </span>            :   virtual Btype*
<span class="lineNum">     161 </span>            :   placeholder_struct_type(const std::string&amp; name, Location) = 0;
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span>            :   // Fill in a placeholder struct type.  This takes a type returned by
<span class="lineNum">     164 </span>            :   // placeholder_struct_type and arranges for it to become a real
<span class="lineNum">     165 </span>            :   // struct type.  The parameter is as for struct_type.  Returns true
<span class="lineNum">     166 </span>            :   // on success, false on failure.
<span class="lineNum">     167 </span>            :   virtual bool
<span class="lineNum">     168 </span>            :   set_placeholder_struct_type(Btype* placeholder,
<span class="lineNum">     169 </span>            :                               const std::vector&lt;Btyped_identifier&gt;&amp; fields)
<span class="lineNum">     170 </span>            :                         = 0;
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span>            :   // Create a placeholder array type.  This is used for a named array
<span class="lineNum">     173 </span>            :   // type, as with placeholder_pointer_type, to handle cases like
<span class="lineNum">     174 </span>            :   // type A []*A.
<span class="lineNum">     175 </span>            :   virtual Btype*
<span class="lineNum">     176 </span>            :   placeholder_array_type(const std::string&amp; name, Location) = 0;
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span>            :   // Fill in a placeholder array type.  This takes a type returned by
<span class="lineNum">     179 </span>            :   // placeholder_array_type and arranges for it to become a real array
<span class="lineNum">     180 </span>            :   // type.  The parameters are as for array_type.  Returns true on
<span class="lineNum">     181 </span>            :   // success, false on failure.
<span class="lineNum">     182 </span>            :   virtual bool
<span class="lineNum">     183 </span>            :   set_placeholder_array_type(Btype* placeholder, Btype* element_type,
<span class="lineNum">     184 </span>            :                              Bexpression* length) = 0;
<span class="lineNum">     185 </span>            : 
<span class="lineNum">     186 </span>            :   // Return a named version of a type.  The location is the location
<span class="lineNum">     187 </span>            :   // of the type definition.  This will not be called for a type
<span class="lineNum">     188 </span>            :   // created via placeholder_pointer_type, placeholder_struct_type, or
<span class="lineNum">     189 </span>            :   // placeholder_array_type..  (It may be called for a pointer,
<span class="lineNum">     190 </span>            :   // struct, or array type in a case like &quot;type P *byte; type Q P&quot;.)
<span class="lineNum">     191 </span>            :   virtual Btype*
<span class="lineNum">     192 </span>            :   named_type(const std::string&amp; name, Btype*, Location) = 0;
<span class="lineNum">     193 </span>            : 
<span class="lineNum">     194 </span>            :   // Create a marker for a circular pointer type.  Go pointer and
<span class="lineNum">     195 </span>            :   // function types can refer to themselves in ways that are not
<span class="lineNum">     196 </span>            :   // permitted in C/C++.  When a circular type is found, this function
<span class="lineNum">     197 </span>            :   // is called for the circular reference.  This permits the backend
<span class="lineNum">     198 </span>            :   // to decide how to handle such a type.  PLACEHOLDER is the
<span class="lineNum">     199 </span>            :   // placeholder type which has already been created; if the backend
<span class="lineNum">     200 </span>            :   // is prepared to handle a circular pointer type, it may simply
<span class="lineNum">     201 </span>            :   // return PLACEHOLDER.  FOR_FUNCTION is true if this is for a
<span class="lineNum">     202 </span>            :   // function type.
<span class="lineNum">     203 </span>            :   //
<span class="lineNum">     204 </span>            :   // For &quot;type P *P&quot; the sequence of calls will be
<span class="lineNum">     205 </span>            :   //   bt1 = placeholder_pointer_type();
<span class="lineNum">     206 </span>            :   //   bt2 = circular_pointer_type(bt1, false);
<span class="lineNum">     207 </span>            :   //   set_placeholder_pointer_type(bt1, bt2);
<span class="lineNum">     208 </span>            :   virtual Btype*
<span class="lineNum">     209 </span>            :   circular_pointer_type(Btype* placeholder, bool for_function) = 0;
<span class="lineNum">     210 </span>            : 
<span class="lineNum">     211 </span>            :   // Return whether the argument could be a special type created by
<span class="lineNum">     212 </span>            :   // circular_pointer_type.  This is used to introduce explicit type
<span class="lineNum">     213 </span>            :   // conversions where needed.  If circular_pointer_type returns its
<span class="lineNum">     214 </span>            :   // PLACEHOLDER parameter, this may safely always return false.
<span class="lineNum">     215 </span>            :   virtual bool
<span class="lineNum">     216 </span>            :   is_circular_pointer_type(Btype*) = 0;
<span class="lineNum">     217 </span>            : 
<span class="lineNum">     218 </span>            :   // Return the size of a type.
<span class="lineNum">     219 </span>            :   virtual int64_t
<span class="lineNum">     220 </span>            :   type_size(Btype*) = 0;
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span>            :   // Return the alignment of a type.
<span class="lineNum">     223 </span>            :   virtual int64_t
<span class="lineNum">     224 </span>            :   type_alignment(Btype*) = 0;
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span>            :   // Return the alignment of a struct field of this type.  This is
<span class="lineNum">     227 </span>            :   // normally the same as type_alignment, but not always.
<span class="lineNum">     228 </span>            :   virtual int64_t
<span class="lineNum">     229 </span>            :   type_field_alignment(Btype*) = 0;
<span class="lineNum">     230 </span>            : 
<span class="lineNum">     231 </span>            :   // Return the offset of field INDEX in a struct type.  INDEX is the
<span class="lineNum">     232 </span>            :   // entry in the FIELDS std::vector parameter of struct_type or
<span class="lineNum">     233 </span>            :   // set_placeholder_struct_type.
<span class="lineNum">     234 </span>            :   virtual int64_t
<span class="lineNum">     235 </span>            :   type_field_offset(Btype*, size_t index) = 0;
<span class="lineNum">     236 </span>            : 
<span class="lineNum">     237 </span>            :   // Expressions.
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span>            :   // Return an expression for a zero value of the given type.  This is
<span class="lineNum">     240 </span>            :   // used for cases such as local variable initialization and
<span class="lineNum">     241 </span>            :   // converting nil to other types.
<span class="lineNum">     242 </span>            :   virtual Bexpression*
<span class="lineNum">     243 </span>            :   zero_expression(Btype*) = 0;
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span>            :   // Create an error expression. This is used for cases which should
<span class="lineNum">     246 </span>            :   // not occur in a correct program, in order to keep the compilation
<span class="lineNum">     247 </span>            :   // going without crashing.
<span class="lineNum">     248 </span>            :   virtual Bexpression*
<span class="lineNum">     249 </span>            :   error_expression() = 0;
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span>            :   // Create a nil pointer expression.
<span class="lineNum">     252 </span>            :   virtual Bexpression*
<span class="lineNum">     253 </span>            :   nil_pointer_expression() = 0;
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span>            :   // Create a reference to a variable.
<span class="lineNum">     256 </span>            :   virtual Bexpression*
<span class="lineNum">     257 </span>            :   var_expression(Bvariable* var, Location) = 0;
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span>            :   // Create an expression that indirects through the pointer expression EXPR
<span class="lineNum">     260 </span>            :   // (i.e., return the expression for *EXPR). KNOWN_VALID is true if the pointer
<span class="lineNum">     261 </span>            :   // is known to point to a valid memory location.  BTYPE is the expected type
<span class="lineNum">     262 </span>            :   // of the indirected EXPR.
<span class="lineNum">     263 </span>            :   virtual Bexpression*
<span class="lineNum">     264 </span>            :   indirect_expression(Btype* btype, Bexpression* expr, bool known_valid,
<span class="lineNum">     265 </span>            :                       Location) = 0;
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span>            :   // Return an expression that declares a constant named NAME with the
<span class="lineNum">     268 </span>            :   // constant value VAL in BTYPE.
<span class="lineNum">     269 </span>            :   virtual Bexpression*
<span class="lineNum">     270 </span>            :   named_constant_expression(Btype* btype, const std::string&amp; name,
<span class="lineNum">     271 </span>            :                              Bexpression* val, Location) = 0;
<span class="lineNum">     272 </span>            : 
<span class="lineNum">     273 </span>            :   // Return an expression for the multi-precision integer VAL in BTYPE.
<span class="lineNum">     274 </span>            :   virtual Bexpression*
<span class="lineNum">     275 </span>            :   integer_constant_expression(Btype* btype, mpz_t val) = 0;
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span>            :   // Return an expression for the floating point value VAL in BTYPE.
<span class="lineNum">     278 </span>            :   virtual Bexpression*
<span class="lineNum">     279 </span>            :   float_constant_expression(Btype* btype, mpfr_t val) = 0;
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span>            :   // Return an expression for the complex value VAL in BTYPE.
<span class="lineNum">     282 </span>            :   virtual Bexpression*
<span class="lineNum">     283 </span>            :   complex_constant_expression(Btype* btype, mpc_t val) = 0;
<span class="lineNum">     284 </span>            : 
<span class="lineNum">     285 </span>            :   // Return an expression for the string value VAL.
<span class="lineNum">     286 </span>            :   virtual Bexpression*
<span class="lineNum">     287 </span>            :   string_constant_expression(const std::string&amp; val) = 0;
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span>            :   // Return an expression for the boolean value VAL.
<span class="lineNum">     290 </span>            :   virtual Bexpression*
<span class="lineNum">     291 </span>            :   boolean_constant_expression(bool val) = 0;
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span>            :   // Return an expression for the real part of BCOMPLEX.
<span class="lineNum">     294 </span>            :   virtual Bexpression*
<span class="lineNum">     295 </span>            :   real_part_expression(Bexpression* bcomplex, Location) = 0;
<span class="lineNum">     296 </span>            : 
<span class="lineNum">     297 </span>            :   // Return an expression for the imaginary part of BCOMPLEX.
<span class="lineNum">     298 </span>            :   virtual Bexpression*
<span class="lineNum">     299 </span>            :   imag_part_expression(Bexpression* bcomplex, Location) = 0;
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span>            :   // Return an expression for the complex number (BREAL, BIMAG).
<span class="lineNum">     302 </span>            :   virtual Bexpression*
<span class="lineNum">     303 </span>            :   complex_expression(Bexpression* breal, Bexpression* bimag, Location) = 0;
<span class="lineNum">     304 </span>            : 
<span class="lineNum">     305 </span>            :   // Return an expression that converts EXPR to TYPE.
<span class="lineNum">     306 </span>            :   virtual Bexpression*
<span class="lineNum">     307 </span>            :   convert_expression(Btype* type, Bexpression* expr, Location) = 0;
<span class="lineNum">     308 </span>            : 
<span class="lineNum">     309 </span>            :   // Create an expression for the address of a function.  This is used to
<span class="lineNum">     310 </span>            :   // get the address of the code for a function.
<span class="lineNum">     311 </span>            :   virtual Bexpression*
<span class="lineNum">     312 </span>            :   function_code_expression(Bfunction*, Location) = 0;
<span class="lineNum">     313 </span>            : 
<span class="lineNum">     314 </span>            :   // Create an expression that takes the address of an expression.
<span class="lineNum">     315 </span>            :   virtual Bexpression*
<span class="lineNum">     316 </span>            :   address_expression(Bexpression*, Location) = 0;
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span>            :   // Return an expression for the field at INDEX in BSTRUCT.
<span class="lineNum">     319 </span>            :   virtual Bexpression*
<span class="lineNum">     320 </span>            :   struct_field_expression(Bexpression* bstruct, size_t index, Location) = 0;
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span>            :   // Create an expression that executes BSTAT before BEXPR.
<span class="lineNum">     323 </span>            :   virtual Bexpression*
<span class="lineNum">     324 </span>            :   compound_expression(Bstatement* bstat, Bexpression* bexpr, Location) = 0;
<span class="lineNum">     325 </span>            : 
<span class="lineNum">     326 </span>            :   // Return an expression that executes THEN_EXPR if CONDITION is true, or
<span class="lineNum">     327 </span>            :   // ELSE_EXPR otherwise and returns the result as type BTYPE, within the
<span class="lineNum">     328 </span>            :   // specified function FUNCTION.  ELSE_EXPR may be NULL.  BTYPE may be NULL.
<span class="lineNum">     329 </span>            :   virtual Bexpression*
<span class="lineNum">     330 </span>            :   conditional_expression(Bfunction* function, Btype* btype,
<span class="lineNum">     331 </span>            :                          Bexpression* condition, Bexpression* then_expr,
<span class="lineNum">     332 </span>            :                          Bexpression* else_expr, Location) = 0;
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span>            :   // Return an expression for the unary operation OP EXPR.
<span class="lineNum">     335 </span>            :   // Supported values of OP are (from operators.h):
<span class="lineNum">     336 </span>            :   //    MINUS, NOT, XOR.
<span class="lineNum">     337 </span>            :   virtual Bexpression*
<span class="lineNum">     338 </span>            :   unary_expression(Operator op, Bexpression* expr, Location) = 0;
<span class="lineNum">     339 </span>            : 
<span class="lineNum">     340 </span>            :   // Return an expression for the binary operation LEFT OP RIGHT.
<span class="lineNum">     341 </span>            :   // Supported values of OP are (from operators.h):
<span class="lineNum">     342 </span>            :   //    EQEQ, NOTEQ, LT, LE, GT, GE, PLUS, MINUS, OR, XOR, MULT, DIV, MOD,
<span class="lineNum">     343 </span>            :   //    LSHIFT, RSHIFT, AND, NOT.
<span class="lineNum">     344 </span>            :   virtual Bexpression*
<span class="lineNum">     345 </span>            :   binary_expression(Operator op, Bexpression* left, Bexpression* right,
<span class="lineNum">     346 </span>            :                     Location) = 0;
<span class="lineNum">     347 </span>            : 
<span class="lineNum">     348 </span>            :   // Return an expression that constructs BTYPE with VALS.  BTYPE must be the
<span class="lineNum">     349 </span>            :   // backend representation a of struct.  VALS must be in the same order as the
<span class="lineNum">     350 </span>            :   // corresponding fields in BTYPE.
<span class="lineNum">     351 </span>            :   virtual Bexpression*
<span class="lineNum">     352 </span>            :   constructor_expression(Btype* btype, const std::vector&lt;Bexpression*&gt;&amp; vals,
<span class="lineNum">     353 </span>            :                          Location) = 0;
<span class="lineNum">     354 </span>            : 
<span class="lineNum">     355 </span>            :   // Return an expression that constructs an array of BTYPE with INDEXES and
<span class="lineNum">     356 </span>            :   // VALS.  INDEXES and VALS must have the same amount of elements. Each index
<span class="lineNum">     357 </span>            :   // in INDEXES must be in the same order as the corresponding value in VALS.
<span class="lineNum">     358 </span>            :   virtual Bexpression*
<span class="lineNum">     359 </span>            :   array_constructor_expression(Btype* btype,
<span class="lineNum">     360 </span>            :                                const std::vector&lt;unsigned long&gt;&amp; indexes,
<span class="lineNum">     361 </span>            :                                const std::vector&lt;Bexpression*&gt;&amp; vals,
<span class="lineNum">     362 </span>            :                                Location) = 0;
<span class="lineNum">     363 </span>            : 
<span class="lineNum">     364 </span>            :   // Return an expression for the address of BASE[INDEX].
<span class="lineNum">     365 </span>            :   // BASE has a pointer type.  This is used for slice indexing.
<span class="lineNum">     366 </span>            :   virtual Bexpression*
<span class="lineNum">     367 </span>            :   pointer_offset_expression(Bexpression* base, Bexpression* index,
<span class="lineNum">     368 </span>            :                             Location) = 0;
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span>            :   // Return an expression for ARRAY[INDEX] as an l-value.  ARRAY is a valid
<span class="lineNum">     371 </span>            :   // fixed-length array, not a slice.
<span class="lineNum">     372 </span>            :   virtual Bexpression*
<span class="lineNum">     373 </span>            :   array_index_expression(Bexpression* array, Bexpression* index, Location) = 0;
<span class="lineNum">     374 </span>            : 
<span class="lineNum">     375 </span>            :   // Create an expression for a call to FN with ARGS, taking place within
<span class="lineNum">     376 </span>            :   // caller CALLER.
<span class="lineNum">     377 </span>            :   virtual Bexpression*
<span class="lineNum">     378 </span>            :   call_expression(Bfunction *caller, Bexpression* fn,
<span class="lineNum">     379 </span>            :                   const std::vector&lt;Bexpression*&gt;&amp; args,
<span class="lineNum">     380 </span>            :                   Bexpression* static_chain, Location) = 0;
<span class="lineNum">     381 </span>            : 
<span class="lineNum">     382 </span>            :   // Statements.
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span>            :   // Create an error statement.  This is used for cases which should
<span class="lineNum">     385 </span>            :   // not occur in a correct program, in order to keep the compilation
<span class="lineNum">     386 </span>            :   // going without crashing.
<span class="lineNum">     387 </span>            :   virtual Bstatement*
<span class="lineNum">     388 </span>            :   error_statement() = 0;
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span>            :   // Create an expression statement within the specified function.
<span class="lineNum">     391 </span>            :   virtual Bstatement*
<span class="lineNum">     392 </span>            :   expression_statement(Bfunction*, Bexpression*) = 0;
<span class="lineNum">     393 </span>            : 
<span class="lineNum">     394 </span>            :   // Create a variable initialization statement in the specified
<span class="lineNum">     395 </span>            :   // function.  This initializes a local variable at the point in the
<span class="lineNum">     396 </span>            :   // program flow where it is declared.
<span class="lineNum">     397 </span>            :   virtual Bstatement*
<span class="lineNum">     398 </span>            :   init_statement(Bfunction*, Bvariable* var, Bexpression* init) = 0;
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span>            :   // Create an assignment statement within the specified function.
<span class="lineNum">     401 </span>            :   virtual Bstatement*
<span class="lineNum">     402 </span>            :   assignment_statement(Bfunction*, Bexpression* lhs, Bexpression* rhs,
<span class="lineNum">     403 </span>            :                        Location) = 0;
<span class="lineNum">     404 </span>            : 
<span class="lineNum">     405 </span>            :   // Create a return statement, passing the representation of the
<span class="lineNum">     406 </span>            :   // function and the list of values to return.
<span class="lineNum">     407 </span>            :   virtual Bstatement*
<span class="lineNum">     408 </span>            :   return_statement(Bfunction*, const std::vector&lt;Bexpression*&gt;&amp;,
<span class="lineNum">     409 </span>            :                    Location) = 0;
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span>            :   // Create an if statement within a function.  ELSE_BLOCK may be NULL.
<span class="lineNum">     412 </span>            :   virtual Bstatement*
<span class="lineNum">     413 </span>            :   if_statement(Bfunction*, Bexpression* condition,
<span class="lineNum">     414 </span>            :                Bblock* then_block, Bblock* else_block,
<span class="lineNum">     415 </span>            :                Location) = 0;
<span class="lineNum">     416 </span>            : 
<span class="lineNum">     417 </span>            :   // Create a switch statement where the case values are constants.
<span class="lineNum">     418 </span>            :   // CASES and STATEMENTS must have the same number of entries.  If
<span class="lineNum">     419 </span>            :   // VALUE matches any of the list in CASES[i], which will all be
<span class="lineNum">     420 </span>            :   // integers, then STATEMENTS[i] is executed.  STATEMENTS[i] will
<span class="lineNum">     421 </span>            :   // either end with a goto statement or will fall through into
<span class="lineNum">     422 </span>            :   // STATEMENTS[i + 1].  CASES[i] is empty for the default clause,
<span class="lineNum">     423 </span>            :   // which need not be last.  FUNCTION is the current function.
<span class="lineNum">     424 </span>            :   virtual Bstatement*
<span class="lineNum">     425 </span>            :   switch_statement(Bfunction* function, Bexpression* value,
<span class="lineNum">     426 </span>            :                    const std::vector&lt;std::vector&lt;Bexpression*&gt; &gt;&amp; cases,
<span class="lineNum">     427 </span>            :                    const std::vector&lt;Bstatement*&gt;&amp; statements,
<span class="lineNum">     428 </span>            :                    Location) = 0;
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span>            :   // Create a single statement from two statements.
<span class="lineNum">     431 </span>            :   virtual Bstatement*
<span class="lineNum">     432 </span>            :   compound_statement(Bstatement*, Bstatement*) = 0;
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span>            :   // Create a single statement from a list of statements.
<span class="lineNum">     435 </span>            :   virtual Bstatement*
<span class="lineNum">     436 </span>            :   statement_list(const std::vector&lt;Bstatement*&gt;&amp;) = 0;
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span>            :   // Create a statement that attempts to execute BSTAT and calls EXCEPT_STMT if
<span class="lineNum">     439 </span>            :   // an exception occurs. EXCEPT_STMT may be NULL.  FINALLY_STMT may be NULL and
<span class="lineNum">     440 </span>            :   // if not NULL, it will always be executed.  This is used for handling defers
<span class="lineNum">     441 </span>            :   // in Go functions.  In C++, the resulting code is of this form:
<span class="lineNum">     442 </span>            :   //   try { BSTAT; } catch { EXCEPT_STMT; } finally { FINALLY_STMT; }
<span class="lineNum">     443 </span>            :   virtual Bstatement*
<span class="lineNum">     444 </span>            :   exception_handler_statement(Bstatement* bstat, Bstatement* except_stmt,
<span class="lineNum">     445 </span>            :                               Bstatement* finally_stmt, Location) = 0;
<span class="lineNum">     446 </span>            : 
<span class="lineNum">     447 </span>            :   // Blocks.
<span class="lineNum">     448 </span>            : 
<span class="lineNum">     449 </span>            :   // Create a block.  The frontend will call this function when it
<span class="lineNum">     450 </span>            :   // starts converting a block within a function.  FUNCTION is the
<span class="lineNum">     451 </span>            :   // current function.  ENCLOSING is the enclosing block; it will be
<span class="lineNum">     452 </span>            :   // NULL for the top-level block in a function.  VARS is the list of
<span class="lineNum">     453 </span>            :   // local variables defined within this block; each entry will be
<span class="lineNum">     454 </span>            :   // created by the local_variable function.  START_LOCATION is the
<span class="lineNum">     455 </span>            :   // location of the start of the block, more or less the location of
<span class="lineNum">     456 </span>            :   // the initial curly brace.  END_LOCATION is the location of the end
<span class="lineNum">     457 </span>            :   // of the block, more or less the location of the final curly brace.
<span class="lineNum">     458 </span>            :   // The statements will be added after the block is created.
<span class="lineNum">     459 </span>            :   virtual Bblock*
<span class="lineNum">     460 </span>            :   block(Bfunction* function, Bblock* enclosing,
<span class="lineNum">     461 </span>            :         const std::vector&lt;Bvariable*&gt;&amp; vars,
<span class="lineNum">     462 </span>            :         Location start_location, Location end_location) = 0;
<span class="lineNum">     463 </span>            : 
<span class="lineNum">     464 </span>            :   // Add the statements to a block.  The block is created first.  Then
<span class="lineNum">     465 </span>            :   // the statements are created.  Then the statements are added to the
<span class="lineNum">     466 </span>            :   // block.  This will called exactly once per block.  The vector may
<span class="lineNum">     467 </span>            :   // be empty if there are no statements.
<span class="lineNum">     468 </span>            :   virtual void
<span class="lineNum">     469 </span>            :   block_add_statements(Bblock*, const std::vector&lt;Bstatement*&gt;&amp;) = 0;
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span>            :   // Return the block as a statement.  This is used to include a block
<span class="lineNum">     472 </span>            :   // in a list of statements.
<span class="lineNum">     473 </span>            :   virtual Bstatement*
<span class="lineNum">     474 </span>            :   block_statement(Bblock*) = 0;
<span class="lineNum">     475 </span>            : 
<span class="lineNum">     476 </span>            :   // Variables.
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span>            :   // Create an error variable.  This is used for cases which should
<span class="lineNum">     479 </span>            :   // not occur in a correct program, in order to keep the compilation
<span class="lineNum">     480 </span>            :   // going without crashing.
<span class="lineNum">     481 </span>            :   virtual Bvariable*
<span class="lineNum">     482 </span>            :   error_variable() = 0;
<span class="lineNum">     483 </span>            : 
<span class="lineNum">     484 </span>            :   // Create a global variable. NAME is the package-qualified name of
<span class="lineNum">     485 </span>            :   // the variable.  ASM_NAME is the encoded identifier for the
<span class="lineNum">     486 </span>            :   // variable, incorporating the package, and made safe for the
<span class="lineNum">     487 </span>            :   // assembler.  BTYPE is the type of the variable.  IS_EXTERNAL is
<span class="lineNum">     488 </span>            :   // true if the variable is defined in some other package.  IS_HIDDEN
<span class="lineNum">     489 </span>            :   // is true if the variable is not exported (name begins with a lower
<span class="lineNum">     490 </span>            :   // case letter).  IN_UNIQUE_SECTION is true if the variable should
<span class="lineNum">     491 </span>            :   // be put into a unique section if possible; this is intended to
<span class="lineNum">     492 </span>            :   // permit the linker to garbage collect the variable if it is not
<span class="lineNum">     493 </span>            :   // referenced.  LOCATION is where the variable was defined.
<span class="lineNum">     494 </span>            :   virtual Bvariable*
<span class="lineNum">     495 </span>            :   global_variable(const std::string&amp; name,
<span class="lineNum">     496 </span>            :                   const std::string&amp; asm_name,
<span class="lineNum">     497 </span>            :                   Btype* btype,
<span class="lineNum">     498 </span>            :                   bool is_external,
<span class="lineNum">     499 </span>            :                   bool is_hidden,
<span class="lineNum">     500 </span>            :                   bool in_unique_section,
<span class="lineNum">     501 </span>            :                   Location location) = 0;
<span class="lineNum">     502 </span>            : 
<span class="lineNum">     503 </span>            :   // A global variable will 1) be initialized to zero, or 2) be
<span class="lineNum">     504 </span>            :   // initialized to a constant value, or 3) be initialized in the init
<span class="lineNum">     505 </span>            :   // function.  In case 2, the frontend will call
<span class="lineNum">     506 </span>            :   // global_variable_set_init to set the initial value.  If this is
<span class="lineNum">     507 </span>            :   // not called, the backend should initialize a global variable to 0.
<span class="lineNum">     508 </span>            :   // The init function may then assign a value to it.
<span class="lineNum">     509 </span>            :   virtual void
<span class="lineNum">     510 </span>            :   global_variable_set_init(Bvariable*, Bexpression*) = 0;
<span class="lineNum">     511 </span>            : 
<span class="lineNum">     512 </span>            :   // Create a local variable.  The frontend will create the local
<span class="lineNum">     513 </span>            :   // variables first, and then create the block which contains them.
<span class="lineNum">     514 </span>            :   // FUNCTION is the function in which the variable is defined.  NAME
<span class="lineNum">     515 </span>            :   // is the name of the variable.  TYPE is the type.  DECL_VAR, if not
<span class="lineNum">     516 </span>            :   // null, gives the location at which the value of this variable may
<span class="lineNum">     517 </span>            :   // be found, typically used to create an inner-scope reference to an
<span class="lineNum">     518 </span>            :   // outer-scope variable, to extend the lifetime of the variable beyond
<span class="lineNum">     519 </span>            :   // the inner scope.  IS_ADDRESS_TAKEN is true if the address of this
<span class="lineNum">     520 </span>            :   // variable is taken (this implies that the address does not escape
<span class="lineNum">     521 </span>            :   // the function, as otherwise the variable would be on the heap).
<span class="lineNum">     522 </span>            :   // LOCATION is where the variable is defined.  For each local variable
<span class="lineNum">     523 </span>            :   // the frontend will call init_statement to set the initial value.
<span class="lineNum">     524 </span>            :   virtual Bvariable*
<span class="lineNum">     525 </span>            :   local_variable(Bfunction* function, const std::string&amp; name, Btype* type,
<span class="lineNum">     526 </span>            :                  Bvariable* decl_var, bool is_address_taken, Location location) = 0;
<span class="lineNum">     527 </span>            : 
<span class="lineNum">     528 </span>            :   // Create a function parameter.  This is an incoming parameter, not
<span class="lineNum">     529 </span>            :   // a result parameter (result parameters are treated as local
<span class="lineNum">     530 </span>            :   // variables).  The arguments are as for local_variable.
<span class="lineNum">     531 </span>            :   virtual Bvariable*
<span class="lineNum">     532 </span>            :   parameter_variable(Bfunction* function, const std::string&amp; name,
<span class="lineNum">     533 </span>            :                      Btype* type, bool is_address_taken,
<span class="lineNum">     534 </span>            :                      Location location) = 0;
<span class="lineNum">     535 </span>            : 
<span class="lineNum">     536 </span>            :   // Create a static chain parameter.  This is the closure parameter.
<span class="lineNum">     537 </span>            :   virtual Bvariable*
<span class="lineNum">     538 </span>            :   static_chain_variable(Bfunction* function, const std::string&amp; name,
<span class="lineNum">     539 </span>            :                         Btype* type, Location location) = 0;
<span class="lineNum">     540 </span>            : 
<span class="lineNum">     541 </span>            :   // Create a temporary variable.  A temporary variable has no name,
<span class="lineNum">     542 </span>            :   // just a type.  We pass in FUNCTION and BLOCK in case they are
<span class="lineNum">     543 </span>            :   // needed.  If INIT is not NULL, the variable should be initialized
<span class="lineNum">     544 </span>            :   // to that value.  Otherwise the initial value is irrelevant--the
<span class="lineNum">     545 </span>            :   // backend does not have to explicitly initialize it to zero.
<span class="lineNum">     546 </span>            :   // ADDRESS_IS_TAKEN is true if the programs needs to take the
<span class="lineNum">     547 </span>            :   // address of this temporary variable.  LOCATION is the location of
<span class="lineNum">     548 </span>            :   // the statement or expression which requires creating the temporary
<span class="lineNum">     549 </span>            :   // variable, and may not be very useful.  This function should
<span class="lineNum">     550 </span>            :   // return a variable which can be referenced later and should set
<span class="lineNum">     551 </span>            :   // *PSTATEMENT to a statement which initializes the variable.
<span class="lineNum">     552 </span>            :   virtual Bvariable*
<span class="lineNum">     553 </span>            :   temporary_variable(Bfunction*, Bblock*, Btype*, Bexpression* init,
<span class="lineNum">     554 </span>            :                      bool address_is_taken, Location location,
<span class="lineNum">     555 </span>            :                      Bstatement** pstatement) = 0;
<span class="lineNum">     556 </span>            : 
<span class="lineNum">     557 </span>            :   // Create an implicit variable that is compiler-defined.  This is
<span class="lineNum">     558 </span>            :   // used when generating GC data and roots, when storing the values
<span class="lineNum">     559 </span>            :   // of a slice constructor, and for the zero value of types.  This returns a
<span class="lineNum">     560 </span>            :   // Bvariable because it corresponds to an initialized variable in C.
<span class="lineNum">     561 </span>            :   //
<span class="lineNum">     562 </span>            :   // NAME is the name to use for the initialized variable this will create.
<span class="lineNum">     563 </span>            :   //
<span class="lineNum">     564 </span>            :   // ASM_NAME is encoded assembler-friendly version of the name, or the
<span class="lineNum">     565 </span>            :   // empty string if no encoding is needed.
<span class="lineNum">     566 </span>            :   //
<span class="lineNum">     567 </span>            :   // TYPE is the type of the implicit variable. 
<span class="lineNum">     568 </span>            :   //
<span class="lineNum">     569 </span>            :   // IS_HIDDEN will be true if the descriptor should only be visible
<span class="lineNum">     570 </span>            :   // within the current object.
<span class="lineNum">     571 </span>            :   //
<span class="lineNum">     572 </span>            :   // IS_CONSTANT is true if the implicit variable should be treated like it is
<span class="lineNum">     573 </span>            :   // immutable.  For slice initializers, if the values must be copied to the
<span class="lineNum">     574 </span>            :   // heap, the variable IS_CONSTANT.
<span class="lineNum">     575 </span>            :   //
<span class="lineNum">     576 </span>            :   // IS_COMMON is true if the implicit variable should
<span class="lineNum">     577 </span>            :   // be treated as a common variable (multiple definitions with
<span class="lineNum">     578 </span>            :   // different sizes permitted in different object files, all merged
<span class="lineNum">     579 </span>            :   // into the largest definition at link time); this will be true for
<span class="lineNum">     580 </span>            :   // the zero value.  IS_HIDDEN and IS_COMMON will never both be true.
<span class="lineNum">     581 </span>            :   //
<span class="lineNum">     582 </span>            :   // If ALIGNMENT is not zero, it is the desired alignment of the variable.
<span class="lineNum">     583 </span>            :   virtual Bvariable*
<span class="lineNum">     584 </span>            :   implicit_variable(const std::string&amp; name, const std::string&amp; asm_name,
<span class="lineNum">     585 </span>            :                     Btype* type, bool is_hidden, bool is_constant,
<span class="lineNum">     586 </span>            :                     bool is_common, int64_t alignment) = 0;
<span class="lineNum">     587 </span>            : 
<span class="lineNum">     588 </span>            : 
<span class="lineNum">     589 </span>            :   // Set the initial value of a variable created by implicit_variable.
<span class="lineNum">     590 </span>            :   // This must be called even if there is no initializer, i.e., INIT is NULL.
<span class="lineNum">     591 </span>            :   // The NAME, TYPE, IS_HIDDEN, IS_CONSTANT, and IS_COMMON parameters are
<span class="lineNum">     592 </span>            :   // the same ones passed to implicit_variable.  INIT will be a composite
<span class="lineNum">     593 </span>            :   // literal of type TYPE.  It will not contain any function calls or anything
<span class="lineNum">     594 </span>            :   // else that can not be put into a read-only data section.
<span class="lineNum">     595 </span>            :   // It may contain the address of variables created by implicit_variable.
<span class="lineNum">     596 </span>            :   //
<span class="lineNum">     597 </span>            :   // If IS_COMMON is true, INIT will be NULL, and the
<span class="lineNum">     598 </span>            :   // variable should be initialized to all zeros.
<span class="lineNum">     599 </span>            :   virtual void
<span class="lineNum">     600 </span>            :   implicit_variable_set_init(Bvariable*, const std::string&amp; name, Btype* type,
<span class="lineNum">     601 </span>            :                              bool is_hidden, bool is_constant, bool is_common,
<span class="lineNum">     602 </span>            :                              Bexpression* init) = 0;
<span class="lineNum">     603 </span>            : 
<span class="lineNum">     604 </span>            :   // Create a reference to a named implicit variable defined in some
<span class="lineNum">     605 </span>            :   // other package.  This will be a variable created by a call to
<span class="lineNum">     606 </span>            :   // implicit_variable with the same NAME, ASM_NAME and TYPE and with
<span class="lineNum">     607 </span>            :   // IS_COMMON passed as false.  This corresponds to an extern global
<span class="lineNum">     608 </span>            :   // variable in C.
<span class="lineNum">     609 </span>            :   virtual Bvariable*
<span class="lineNum">     610 </span>            :   implicit_variable_reference(const std::string&amp; name,
<span class="lineNum">     611 </span>            :                               const std::string&amp; asm_name,
<span class="lineNum">     612 </span>            :                               Btype* type) = 0;
<span class="lineNum">     613 </span>            : 
<span class="lineNum">     614 </span>            :   // Create a named immutable initialized data structure.  This is
<span class="lineNum">     615 </span>            :   // used for type descriptors, map descriptors, and function
<span class="lineNum">     616 </span>            :   // descriptors.  This returns a Bvariable because it corresponds to
<span class="lineNum">     617 </span>            :   // an initialized const variable in C.
<span class="lineNum">     618 </span>            :   //
<span class="lineNum">     619 </span>            :   // NAME is the name to use for the initialized global variable which
<span class="lineNum">     620 </span>            :   // this call will create.
<span class="lineNum">     621 </span>            :   //
<span class="lineNum">     622 </span>            :   // ASM_NAME is the encoded, assembler-friendly version of NAME, or
<span class="lineNum">     623 </span>            :   // the empty string if no encoding is needed.
<span class="lineNum">     624 </span>            :   //
<span class="lineNum">     625 </span>            :   // IS_HIDDEN will be true if the descriptor should only be visible
<span class="lineNum">     626 </span>            :   // within the current object.
<span class="lineNum">     627 </span>            :   //
<span class="lineNum">     628 </span>            :   // IS_COMMON is true if NAME may be defined by several packages, and
<span class="lineNum">     629 </span>            :   // the linker should merge all such definitions.  If IS_COMMON is
<span class="lineNum">     630 </span>            :   // false, NAME should be defined in only one file.  In general
<span class="lineNum">     631 </span>            :   // IS_COMMON will be true for the type descriptor of an unnamed type
<span class="lineNum">     632 </span>            :   // or a builtin type.  IS_HIDDEN and IS_COMMON will never both be
<span class="lineNum">     633 </span>            :   // true.
<span class="lineNum">     634 </span>            :   //
<span class="lineNum">     635 </span>            :   // TYPE will be a struct type; the type of the returned expression
<span class="lineNum">     636 </span>            :   // must be a pointer to this struct type.
<span class="lineNum">     637 </span>            :   // 
<span class="lineNum">     638 </span>            :   // We must create the named structure before we know its
<span class="lineNum">     639 </span>            :   // initializer, because the initializer may refer to its own
<span class="lineNum">     640 </span>            :   // address.  After calling this the frontend will call
<span class="lineNum">     641 </span>            :   // immutable_struct_set_init.
<span class="lineNum">     642 </span>            :   virtual Bvariable*
<span class="lineNum">     643 </span>            :   immutable_struct(const std::string&amp; name,
<span class="lineNum">     644 </span>            :                    const std::string&amp; asm_name,
<span class="lineNum">     645 </span>            :                    bool is_hidden, bool is_common,
<span class="lineNum">     646 </span>            :                    Btype* type, Location) = 0;
<span class="lineNum">     647 </span>            : 
<span class="lineNum">     648 </span>            :   // Set the initial value of a variable created by immutable_struct.
<span class="lineNum">     649 </span>            :   // The NAME, IS_HIDDEN, IS_COMMON, TYPE, and location parameters are
<span class="lineNum">     650 </span>            :   // the same ones passed to immutable_struct.  INITIALIZER will be a
<span class="lineNum">     651 </span>            :   // composite literal of type TYPE.  It will not contain any function
<span class="lineNum">     652 </span>            :   // calls or anything else that can not be put into a read-only data
<span class="lineNum">     653 </span>            :   // section.  It may contain the address of variables created by
<span class="lineNum">     654 </span>            :   // immutable_struct.
<span class="lineNum">     655 </span>            :   virtual void
<span class="lineNum">     656 </span>            :   immutable_struct_set_init(Bvariable*, const std::string&amp; name,
<span class="lineNum">     657 </span>            :                             bool is_hidden, bool is_common, Btype* type,
<span class="lineNum">     658 </span>            :                             Location, Bexpression* initializer) = 0;
<span class="lineNum">     659 </span>            : 
<span class="lineNum">     660 </span>            :   // Create a reference to a named immutable initialized data
<span class="lineNum">     661 </span>            :   // structure defined in some other package.  This will be a
<span class="lineNum">     662 </span>            :   // structure created by a call to immutable_struct with the same
<span class="lineNum">     663 </span>            :   // NAME, ASM_NAME and TYPE and with IS_COMMON passed as false.  This
<span class="lineNum">     664 </span>            :   // corresponds to an extern const global variable in C.
<span class="lineNum">     665 </span>            :   virtual Bvariable*
<span class="lineNum">     666 </span>            :   immutable_struct_reference(const std::string&amp; name,
<span class="lineNum">     667 </span>            :                              const std::string&amp; asm_name,
<span class="lineNum">     668 </span>            :                              Btype* type, Location) = 0;
<span class="lineNum">     669 </span>            : 
<span class="lineNum">     670 </span>            :   // Labels.
<span class="lineNum">     671 </span>            :   
<span class="lineNum">     672 </span>            :   // Create a new label.  NAME will be empty if this is a label
<span class="lineNum">     673 </span>            :   // created by the frontend for a loop construct.  The location is
<span class="lineNum">     674 </span>            :   // where the label is defined.
<span class="lineNum">     675 </span>            :   virtual Blabel*
<span class="lineNum">     676 </span>            :   label(Bfunction*, const std::string&amp; name, Location) = 0;
<span class="lineNum">     677 </span>            : 
<span class="lineNum">     678 </span>            :   // Create a statement which defines a label.  This statement will be
<span class="lineNum">     679 </span>            :   // put into the codestream at the point where the label should be
<span class="lineNum">     680 </span>            :   // defined.
<span class="lineNum">     681 </span>            :   virtual Bstatement*
<span class="lineNum">     682 </span>            :   label_definition_statement(Blabel*) = 0;
<span class="lineNum">     683 </span>            : 
<span class="lineNum">     684 </span>            :   // Create a goto statement to a label.
<span class="lineNum">     685 </span>            :   virtual Bstatement*
<span class="lineNum">     686 </span>            :   goto_statement(Blabel*, Location) = 0;
<span class="lineNum">     687 </span>            : 
<span class="lineNum">     688 </span>            :   // Create an expression for the address of a label.  This is used to
<span class="lineNum">     689 </span>            :   // get the return address of a deferred function which may call
<span class="lineNum">     690 </span>            :   // recover.
<span class="lineNum">     691 </span>            :   virtual Bexpression*
<span class="lineNum">     692 </span>            :   label_address(Blabel*, Location) = 0;
<span class="lineNum">     693 </span>            : 
<span class="lineNum">     694 </span>            :   // Functions.
<span class="lineNum">     695 </span>            : 
<span class="lineNum">     696 </span>            :   // Create an error function.  This is used for cases which should
<span class="lineNum">     697 </span>            :   // not occur in a correct program, in order to keep the compilation
<span class="lineNum">     698 </span>            :   // going without crashing.
<span class="lineNum">     699 </span>            :   virtual Bfunction*
<span class="lineNum">     700 </span>            :   error_function() = 0;
<span class="lineNum">     701 </span>            : 
<span class="lineNum">     702 </span>            :   // Declare or define a function of FNTYPE.
<span class="lineNum">     703 </span>            :   // NAME is the Go name of the function. ASM_NAME, if not the empty string, is
<span class="lineNum">     704 </span>            :   // the name that should be used in the symbol table; this will be non-empty if
<span class="lineNum">     705 </span>            :   // a magic extern comment is used.
<span class="lineNum">     706 </span>            :   // IS_VISIBLE is true if this function should be visible outside of the
<span class="lineNum">     707 </span>            :   // current compilation unit. IS_DECLARATION is true if this is a function
<span class="lineNum">     708 </span>            :   // declaration rather than a definition; the function definition will be in
<span class="lineNum">     709 </span>            :   // another compilation unit.
<span class="lineNum">     710 </span>            :   // IS_INLINABLE is true if the function can be inlined.
<span class="lineNum">     711 </span>            :   // DISABLE_SPLIT_STACK is true if this function may not split the stack; this
<span class="lineNum">     712 </span>            :   // is used for the implementation of recover.
<span class="lineNum">     713 </span>            :   // DOES_NOT_RETURN is true for a function that does not return; this is used
<span class="lineNum">     714 </span>            :   // for the implementation of panic.
<span class="lineNum">     715 </span>            :   // IN_UNIQUE_SECTION is true if this function should be put into a unique
<span class="lineNum">     716 </span>            :   // location if possible; this is used for field tracking.
<span class="lineNum">     717 </span>            :   virtual Bfunction*
<span class="lineNum">     718 </span>            :   function(Btype* fntype, const std::string&amp; name, const std::string&amp; asm_name,
<span class="lineNum">     719 </span>            :            bool is_visible, bool is_declaration, bool is_inlinable,
<span class="lineNum">     720 </span>            :            bool disable_split_stack, bool does_not_return,
<span class="lineNum">     721 </span>            :            bool in_unique_section, Location) = 0;
<span class="lineNum">     722 </span>            : 
<span class="lineNum">     723 </span>            :   // Create a statement that runs all deferred calls for FUNCTION.  This should
<span class="lineNum">     724 </span>            :   // be a statement that looks like this in C++:
<span class="lineNum">     725 </span>            :   //   finish:
<span class="lineNum">     726 </span>            :   //     try { DEFER_RETURN; } catch { CHECK_DEFER; goto finish; }
<span class="lineNum">     727 </span>            :   virtual Bstatement*
<span class="lineNum">     728 </span>            :   function_defer_statement(Bfunction* function, Bexpression* undefer,
<span class="lineNum">     729 </span>            :                            Bexpression* check_defer, Location) = 0;
<span class="lineNum">     730 </span>            : 
<span class="lineNum">     731 </span>            :   // Record PARAM_VARS as the variables to use for the parameters of FUNCTION.
<span class="lineNum">     732 </span>            :   // This will only be called for a function definition.  Returns true on
<span class="lineNum">     733 </span>            :   // success, false on failure.
<span class="lineNum">     734 </span>            :   virtual bool
<span class="lineNum">     735 </span>            :   function_set_parameters(Bfunction* function,
<span class="lineNum">     736 </span>            :                          const std::vector&lt;Bvariable*&gt;&amp; param_vars) = 0;
<span class="lineNum">     737 </span>            : 
<span class="lineNum">     738 </span>            :   // Set the function body for FUNCTION using the code in CODE_STMT.  Returns
<span class="lineNum">     739 </span>            :   // true on success, false on failure.
<span class="lineNum">     740 </span>            :   virtual bool
<span class="lineNum">     741 </span>            :   function_set_body(Bfunction* function, Bstatement* code_stmt) = 0;
<span class="lineNum">     742 </span>            : 
<span class="lineNum">     743 </span>            :   // Look up a named built-in function in the current backend implementation.
<span class="lineNum">     744 </span>            :   // Returns NULL if no built-in function by that name exists.
<span class="lineNum">     745 </span>            :   virtual Bfunction*
<span class="lineNum">     746 </span>            :   lookup_builtin(const std::string&amp;) = 0;
<span class="lineNum">     747 </span>            : 
<span class="lineNum">     748 </span>            :   // Utility.
<span class="lineNum">     749 </span>            : 
<span class="lineNum">     750 </span>            :   // Write the definitions for all TYPE_DECLS, CONSTANT_DECLS,
<span class="lineNum">     751 </span>            :   // FUNCTION_DECLS, and VARIABLE_DECLS declared globally.
<span class="lineNum">     752 </span>            :   virtual void
<span class="lineNum">     753 </span>            :   write_global_definitions(const std::vector&lt;Btype*&gt;&amp; type_decls,
<span class="lineNum">     754 </span>            :                            const std::vector&lt;Bexpression*&gt;&amp; constant_decls,
<span class="lineNum">     755 </span>            :                            const std::vector&lt;Bfunction*&gt;&amp; function_decls,
<span class="lineNum">     756 </span>            :                            const std::vector&lt;Bvariable*&gt;&amp; variable_decls) = 0;
<span class="lineNum">     757 </span>            : 
<span class="lineNum">     758 </span>            :   // Write SIZE bytes of export data from BYTES to the proper
<span class="lineNum">     759 </span>            :   // section in the output object file.
<span class="lineNum">     760 </span>            :   virtual void
<span class="lineNum">     761 </span>            :   write_export_data(const char* bytes, unsigned int size) = 0;
<span class="lineNum">     762 </span>            : };
<span class="lineNum">     763 </span>            : 
<span class="lineNum">     764 </span>            : #endif // !defined(GO_BACKEND_H)
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.0</a></td></tr>
  </table>
  <br>
<h3>LCOV profile is generated on x86_64 machine using following configure options: configure --disable-bootstrap --enable-coverage=opt --enable-languages=c,c++,fortran,go,jit,lto --enable-host-shared. GCC test suite is run with the built compiler.</h3></body></html>
