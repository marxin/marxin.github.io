<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - gcc.info - gcc/plugin.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">gcc</a> - plugin.c<span style="font-size: 80%;"> (source / <a href="plugin.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">gcc.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">215</td>
            <td class="headerCovTableEntry">360</td>
            <td class="headerCovTableEntryLo">59.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-09-22 10:58:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">15</td>
            <td class="headerCovTableEntry">28</td>
            <td class="headerCovTableEntryLo">53.6 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Support for GCC plugin mechanism.</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 2009-2018 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            : This file is part of GCC.
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : GCC is free software; you can redistribute it and/or modify
<span class="lineNum">       7 </span>            : it under the terms of the GNU General Public License as published by
<span class="lineNum">       8 </span>            : the Free Software Foundation; either version 3, or (at your option)
<span class="lineNum">       9 </span>            : any later version.
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : GCC is distributed in the hope that it will be useful,
<span class="lineNum">      12 </span>            : but WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      13 </span>            : MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<span class="lineNum">      14 </span>            : GNU General Public License for more details.
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : You should have received a copy of the GNU General Public License
<span class="lineNum">      17 </span>            : along with GCC; see the file COPYING3.  If not see
<span class="lineNum">      18 </span>            : &lt;http://www.gnu.org/licenses/&gt;.  */
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : /* This file contains the support for GCC plugin mechanism based on the
<span class="lineNum">      21 </span>            :    APIs described in doc/plugin.texi.  */
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            : #include &quot;config.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;system.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;coretypes.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;options.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;tree-pass.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;diagnostic-core.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;flags.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;intl.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;plugin.h&quot;
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span>            : #ifdef ENABLE_PLUGIN
<span class="lineNum">      34 </span>            : #include &quot;plugin-version.h&quot;
<span class="lineNum">      35 </span>            : #endif
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : #ifdef __MINGW32__
<span class="lineNum">      38 </span>            : #ifndef WIN32_LEAN_AND_MEAN
<span class="lineNum">      39 </span>            : #define WIN32_LEAN_AND_MEAN
<span class="lineNum">      40 </span>            : #endif
<span class="lineNum">      41 </span>            : #ifndef NOMINMAX
<span class="lineNum">      42 </span>            : #define NOMINMAX
<span class="lineNum">      43 </span>            : #endif
<span class="lineNum">      44 </span>            : #include &lt;windows.h&gt;
<span class="lineNum">      45 </span>            : #endif
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            : #define GCC_PLUGIN_STRINGIFY0(X) #X
<span class="lineNum">      48 </span>            : #define GCC_PLUGIN_STRINGIFY1(X) GCC_PLUGIN_STRINGIFY0 (X)
<span class="lineNum">      49 </span>            : 
<span class="lineNum">      50 </span>            : /* Event names as strings.  Keep in sync with enum plugin_event.  */
<span class="lineNum">      51 </span>            : static const char *plugin_event_name_init[] =
<span class="lineNum">      52 </span>            : {
<span class="lineNum">      53 </span>            : # define DEFEVENT(NAME) GCC_PLUGIN_STRINGIFY1 (NAME),
<span class="lineNum">      54 </span>            : # include &quot;plugin.def&quot;
<span class="lineNum">      55 </span>            : # undef DEFEVENT
<span class="lineNum">      56 </span>            : };
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            : /* A printf format large enough for the largest event above.  */
<span class="lineNum">      59 </span>            : #define FMT_FOR_PLUGIN_EVENT &quot;%-32s&quot;
<span class="lineNum">      60 </span>            : 
<span class="lineNum">      61 </span>            : const char **plugin_event_name = plugin_event_name_init;
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            : /* Event hashtable helpers.  */
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span>            : struct event_hasher : nofree_ptr_hash &lt;const char *&gt;
<span class="lineNum">      66 </span>            : {
<span class="lineNum">      67 </span>            :   static inline hashval_t hash (const char **);
<span class="lineNum">      68 </span>            :   static inline bool equal (const char **, const char **);
<span class="lineNum">      69 </span>            : };
<span class="lineNum">      70 </span>            : 
<span class="lineNum">      71 </span>            : /* Helper function for the event hash table that hashes the entry V.  */
<a name="72"><span class="lineNum">      72 </span>            : </a>
<span class="lineNum">      73 </span>            : inline hashval_t
<span class="lineNum">      74 </span><span class="lineNoCov">          0 : event_hasher::hash (const char **v)</span>
<span class="lineNum">      75 </span>            : {
<span class="lineNum">      76 </span><span class="lineNoCov">          0 :   return htab_hash_string (*v);</span>
<span class="lineNum">      77 </span>            : }
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span>            : /* Helper function for the event hash table that compares the name of an
<span class="lineNum">      80 </span>            :    existing entry (S1) with the given string (S2).  */
<a name="81"><span class="lineNum">      81 </span>            : </a>
<span class="lineNum">      82 </span>            : inline bool
<span class="lineNum">      83 </span><span class="lineNoCov">          0 : event_hasher::equal (const char **s1, const char **s2)</span>
<span class="lineNum">      84 </span>            : {
<span class="lineNum">      85 </span><span class="lineNoCov">          0 :   return !strcmp (*s1, *s2);</span>
<span class="lineNum">      86 </span>            : }
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            : /* A hash table to map event names to the position of the names in the
<span class="lineNum">      89 </span>            :    plugin_event_name table.  */
<span class="lineNum">      90 </span>            : static hash_table&lt;event_hasher&gt; *event_tab;
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span>            : /* Keep track of the limit of allocated events and space ready for
<span class="lineNum">      93 </span>            :    allocating events.  */
<span class="lineNum">      94 </span>            : static int event_last = PLUGIN_EVENT_FIRST_DYNAMIC;
<span class="lineNum">      95 </span>            : static int event_horizon = PLUGIN_EVENT_FIRST_DYNAMIC;
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span>            : /* Hash table for the plugin_name_args objects created during command-line
<span class="lineNum">      98 </span>            :    parsing.  */
<span class="lineNum">      99 </span>            : static htab_t plugin_name_args_tab = NULL;
<span class="lineNum">     100 </span>            : 
<span class="lineNum">     101 </span>            : /* List node for keeping track of plugin-registered callback.  */
<span class="lineNum">     102 </span>            : struct callback_info
<span class="lineNum">     103 </span>            : {
<span class="lineNum">     104 </span>            :   const char *plugin_name;   /* Name of plugin that registers the callback.  */
<span class="lineNum">     105 </span>            :   plugin_callback_func func; /* Callback to be called.  */
<span class="lineNum">     106 </span>            :   void *user_data;           /* plugin-specified data.  */
<span class="lineNum">     107 </span>            :   struct callback_info *next;
<span class="lineNum">     108 </span>            : };
<span class="lineNum">     109 </span>            : 
<span class="lineNum">     110 </span>            : /* An array of lists of 'callback_info' objects indexed by the event id.  */
<span class="lineNum">     111 </span>            : static struct callback_info *plugin_callbacks_init[PLUGIN_EVENT_FIRST_DYNAMIC];
<span class="lineNum">     112 </span>            : static struct callback_info **plugin_callbacks = plugin_callbacks_init;
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span>            : /* For invoke_plugin_callbacks(), see plugin.h.  */
<span class="lineNum">     115 </span>            : bool flag_plugin_added = false;
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span>            : #ifdef ENABLE_PLUGIN
<span class="lineNum">     118 </span>            : /* Each plugin should define an initialization function with exactly
<span class="lineNum">     119 </span>            :    this name.  */
<span class="lineNum">     120 </span>            : static const char *str_plugin_init_func_name = &quot;plugin_init&quot;;
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span>            : /* Each plugin should define this symbol to assert that it is
<span class="lineNum">     123 </span>            :    distributed under a GPL-compatible license.  */
<span class="lineNum">     124 </span>            : static const char *str_license = &quot;plugin_is_GPL_compatible&quot;;
<span class="lineNum">     125 </span>            : #endif
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span>            : /* Helper function for hashing the base_name of the plugin_name_args
<span class="lineNum">     128 </span>            :    structure to be inserted into the hash table.  */
<a name="129"><span class="lineNum">     129 </span>            : </a>
<span class="lineNum">     130 </span>            : static hashval_t
<span class="lineNum">     131 </span><span class="lineNoCov">          0 : htab_hash_plugin (const PTR p)</span>
<span class="lineNum">     132 </span>            : {
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :   const struct plugin_name_args *plugin = (const struct plugin_name_args *) p;</span>
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :   return htab_hash_string (plugin-&gt;base_name);</span>
<span class="lineNum">     135 </span>            :  }
<span class="lineNum">     136 </span>            : 
<span class="lineNum">     137 </span>            : /* Helper function for the hash table that compares the base_name of the
<span class="lineNum">     138 </span>            :    existing entry (S1) with the given string (S2).  */
<a name="139"><span class="lineNum">     139 </span>            : </a>
<span class="lineNum">     140 </span>            : static int
<span class="lineNum">     141 </span><span class="lineCov">          9 : htab_str_eq (const void *s1, const void *s2)</span>
<span class="lineNum">     142 </span>            : {
<span class="lineNum">     143 </span><span class="lineCov">          9 :   const struct plugin_name_args *plugin = (const struct plugin_name_args *) s1;</span>
<span class="lineNum">     144 </span><span class="lineCov">          9 :   return !strcmp (plugin-&gt;base_name, (const char *) s2);</span>
<span class="lineNum">     145 </span>            : }
<span class="lineNum">     146 </span>            : 
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span>            : /* Given a plugin's full-path name FULL_NAME, e.g. /pass/to/NAME.so,
<span class="lineNum">     149 </span>            :    return NAME.  */
<a name="150"><span class="lineNum">     150 </span>            : </a>
<span class="lineNum">     151 </span>            : static char *
<span class="lineNum">     152 </span><span class="lineCov">         52 : get_plugin_base_name (const char *full_name)</span>
<span class="lineNum">     153 </span>            : {
<span class="lineNum">     154 </span>            :   /* First get the base name part of the full-path name, i.e. NAME.so.  */
<span class="lineNum">     155 </span><span class="lineCov">         52 :   char *base_name = xstrdup (lbasename (full_name));</span>
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span>            :   /* Then get rid of the extension in the name, e.g., .so.  */
<span class="lineNum">     158 </span><span class="lineCov">         52 :   strip_off_ending (base_name, strlen (base_name));</span>
<span class="lineNum">     159 </span>            : 
<span class="lineNum">     160 </span><span class="lineCov">         52 :   return base_name;</span>
<span class="lineNum">     161 </span>            : }
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            : /* Create a plugin_name_args object for the given plugin and insert it
<span class="lineNum">     165 </span>            :    to the hash table. This function is called when
<span class="lineNum">     166 </span>            :    -fplugin=/path/to/NAME.so or -fplugin=NAME option is processed.  */
<a name="167"><span class="lineNum">     167 </span>            : </a>
<span class="lineNum">     168 </span>            : void
<span class="lineNum">     169 </span><span class="lineCov">         56 : add_new_plugin (const char* plugin_name)</span>
<span class="lineNum">     170 </span>            : {
<span class="lineNum">     171 </span><span class="lineCov">         56 :   struct plugin_name_args *plugin;</span>
<span class="lineNum">     172 </span><span class="lineCov">         56 :   void **slot;</span>
<span class="lineNum">     173 </span><span class="lineCov">         56 :   char *base_name;</span>
<span class="lineNum">     174 </span><span class="lineCov">         56 :   bool name_is_short;</span>
<span class="lineNum">     175 </span><span class="lineCov">         56 :   const char *pc;</span>
<span class="lineNum">     176 </span>            : 
<span class="lineNum">     177 </span><span class="lineCov">         56 :   flag_plugin_added = true;</span>
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span>            :   /* Replace short names by their full path when relevant.  */
<span class="lineNum">     180 </span><span class="lineCov">         56 :   name_is_short  = !IS_ABSOLUTE_PATH (plugin_name);</span>
<span class="lineNum">     181 </span><span class="lineCov">        120 :   for (pc = plugin_name; name_is_short &amp;&amp; *pc; pc++)</span>
<span class="lineNum">     182 </span><span class="lineCov">         64 :     if (*pc == '.' || IS_DIR_SEPARATOR (*pc))</span>
<span class="lineNum">     183 </span><span class="lineCov">         52 :       name_is_short = false;</span>
<span class="lineNum">     184 </span>            : 
<span class="lineNum">     185 </span><span class="lineCov">         56 :   if (name_is_short)</span>
<span class="lineNum">     186 </span>            :     {
<span class="lineNum">     187 </span><span class="lineCov">          4 :       base_name = CONST_CAST (char*, plugin_name);</span>
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span>            : #if defined(__MINGW32__)
<span class="lineNum">     190 </span>            :       static const char plugin_ext[] = &quot;.dll&quot;;
<span class="lineNum">     191 </span>            : #elif defined(__APPLE__)
<span class="lineNum">     192 </span>            :       /* Mac OS has two types of libraries: dynamic libraries (.dylib) and
<span class="lineNum">     193 </span>            :          plugins (.bundle). Both can be used with dlopen()/dlsym() but the
<span class="lineNum">     194 </span>            :          former cannot be linked at build time (i.e., with the -lfoo linker
<span class="lineNum">     195 </span>            :          option). A GCC plugin is therefore probably a Mac OS plugin but their
<span class="lineNum">     196 </span>            :          use seems to be quite rare and the .bundle extension is more of a
<span class="lineNum">     197 </span>            :          recommendation rather than the rule. This raises the questions of how
<span class="lineNum">     198 </span>            :          well they are supported by tools (e.g., libtool). So to avoid
<span class="lineNum">     199 </span>            :          complications let's use the .dylib extension for now. In the future,
<span class="lineNum">     200 </span>            :          if this proves to be an issue, we can always check for both
<span class="lineNum">     201 </span>            :          extensions.  */
<span class="lineNum">     202 </span>            :       static const char plugin_ext[] = &quot;.dylib&quot;;
<span class="lineNum">     203 </span>            : #else
<span class="lineNum">     204 </span><span class="lineCov">          4 :       static const char plugin_ext[] = &quot;.so&quot;;</span>
<span class="lineNum">     205 </span>            : #endif
<span class="lineNum">     206 </span>            : 
<span class="lineNum">     207 </span><span class="lineCov">          4 :       plugin_name = concat (default_plugin_dir_name (), &quot;/&quot;,</span>
<span class="lineNum">     208 </span>            :                             plugin_name, plugin_ext, NULL);
<span class="lineNum">     209 </span><span class="lineCov">          4 :       if (access (plugin_name, R_OK))</span>
<span class="lineNum">     210 </span><span class="lineCov">          4 :         fatal_error</span>
<span class="lineNum">     211 </span><span class="lineCov">          4 :           (input_location,</span>
<span class="lineNum">     212 </span>            :            &quot;inaccessible plugin file %s expanded from short plugin name %s: %m&quot;,
<span class="lineNum">     213 </span>            :            plugin_name, base_name);
<span class="lineNum">     214 </span>            :     }
<span class="lineNum">     215 </span>            :   else
<span class="lineNum">     216 </span><span class="lineCov">         52 :     base_name = get_plugin_base_name (plugin_name);</span>
<span class="lineNum">     217 </span>            : 
<span class="lineNum">     218 </span>            :   /* If this is the first -fplugin= option we encounter, create
<span class="lineNum">     219 </span>            :      'plugin_name_args_tab' hash table.  */
<span class="lineNum">     220 </span><span class="lineCov">         52 :   if (!plugin_name_args_tab)</span>
<span class="lineNum">     221 </span><span class="lineCov">         52 :     plugin_name_args_tab = htab_create (10, htab_hash_plugin, htab_str_eq,</span>
<span class="lineNum">     222 </span>            :                                         NULL);
<span class="lineNum">     223 </span>            : 
<span class="lineNum">     224 </span><span class="lineCov">         52 :   slot = htab_find_slot_with_hash (plugin_name_args_tab, base_name,</span>
<span class="lineNum">     225 </span>            :                                    htab_hash_string (base_name), INSERT);
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span>            :   /* If the same plugin (name) has been specified earlier, either emit an
<span class="lineNum">     228 </span>            :      error or a warning message depending on if they have identical full
<span class="lineNum">     229 </span>            :      (path) names.  */
<span class="lineNum">     230 </span><span class="lineCov">         52 :   if (*slot)</span>
<span class="lineNum">     231 </span>            :     {
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :       plugin = (struct plugin_name_args *) *slot;</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :       if (strcmp (plugin-&gt;full_name, plugin_name))</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :         error (&quot;plugin %s was specified with different paths:\n%s\n%s&quot;,</span>
<span class="lineNum">     235 </span>            :                plugin-&gt;base_name, plugin-&gt;full_name, plugin_name);
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">     237 </span>            :     }
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span><span class="lineCov">         52 :   plugin = XCNEW (struct plugin_name_args);</span>
<span class="lineNum">     240 </span><span class="lineCov">         52 :   plugin-&gt;base_name = base_name;</span>
<span class="lineNum">     241 </span><span class="lineCov">         52 :   plugin-&gt;full_name = plugin_name;</span>
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span><span class="lineCov">         52 :   *slot = plugin;</span>
<span class="lineNum">     244 </span>            : }
<span class="lineNum">     245 </span>            : 
<span class="lineNum">     246 </span>            : 
<span class="lineNum">     247 </span>            : /* Parse the -fplugin-arg-&lt;name&gt;-&lt;key&gt;[=&lt;value&gt;] option and create a
<span class="lineNum">     248 </span>            :    'plugin_argument' object for the parsed key-value pair. ARG is
<span class="lineNum">     249 </span>            :    the &lt;name&gt;-&lt;key&gt;[=&lt;value&gt;] part of the option.  */
<a name="250"><span class="lineNum">     250 </span>            : </a>
<span class="lineNum">     251 </span>            : void
<span class="lineNum">     252 </span><span class="lineCov">          9 : parse_plugin_arg_opt (const char *arg)</span>
<span class="lineNum">     253 </span>            : {
<span class="lineNum">     254 </span><span class="lineCov">          9 :   size_t len = 0, name_len = 0, key_len = 0, value_len = 0;</span>
<span class="lineNum">     255 </span><span class="lineCov">          9 :   const char *ptr, *name_start = arg, *key_start = NULL, *value_start = NULL;</span>
<span class="lineNum">     256 </span><span class="lineCov">          9 :   char *name, *key, *value;</span>
<span class="lineNum">     257 </span><span class="lineCov">          9 :   void **slot;</span>
<span class="lineNum">     258 </span><span class="lineCov">          9 :   bool name_parsed = false, key_parsed = false;</span>
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span>            :   /* Iterate over the ARG string and identify the starting character position
<span class="lineNum">     261 </span>            :      of 'name', 'key', and 'value' and their lengths.  */
<span class="lineNum">     262 </span><span class="lineCov">        300 :   for (ptr = arg; *ptr; ++ptr)</span>
<span class="lineNum">     263 </span>            :     {
<span class="lineNum">     264 </span>            :       /* Only the first '-' encountered is considered a separator between
<span class="lineNum">     265 </span>            :          'name' and 'key'. All the subsequent '-'s are considered part of
<span class="lineNum">     266 </span>            :          'key'. For example, given -fplugin-arg-foo-bar-primary-key=value,
<span class="lineNum">     267 </span>            :          the plugin name is 'foo' and the key is 'bar-primary-key'.  */
<span class="lineNum">     268 </span><span class="lineCov">        291 :       if (*ptr == '-' &amp;&amp; !name_parsed)</span>
<span class="lineNum">     269 </span>            :         {
<span class="lineNum">     270 </span><span class="lineCov">          9 :           name_len = len;</span>
<span class="lineNum">     271 </span><span class="lineCov">          9 :           len = 0;</span>
<span class="lineNum">     272 </span><span class="lineCov">          9 :           key_start = ptr + 1;</span>
<span class="lineNum">     273 </span><span class="lineCov">          9 :           name_parsed = true;</span>
<span class="lineNum">     274 </span><span class="lineCov">          9 :           continue;</span>
<span class="lineNum">     275 </span>            :         }
<span class="lineNum">     276 </span><span class="lineCov">        282 :       else if (*ptr == '=')</span>
<span class="lineNum">     277 </span>            :         {
<span class="lineNum">     278 </span><span class="lineCov">          4 :           if (!key_parsed) </span>
<span class="lineNum">     279 </span>            :             {
<span class="lineNum">     280 </span><span class="lineCov">          4 :               key_len = len;</span>
<span class="lineNum">     281 </span><span class="lineCov">          4 :               len = 0;</span>
<span class="lineNum">     282 </span><span class="lineCov">          4 :               value_start = ptr + 1;</span>
<span class="lineNum">     283 </span><span class="lineCov">          4 :               key_parsed = true;</span>
<span class="lineNum">     284 </span>            :             }
<span class="lineNum">     285 </span><span class="lineCov">          4 :           continue;</span>
<span class="lineNum">     286 </span>            :         }
<span class="lineNum">     287 </span>            :       else
<span class="lineNum">     288 </span><span class="lineCov">        278 :         ++len;</span>
<span class="lineNum">     289 </span>            :     }
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span><span class="lineCov">          9 :   if (!key_start)</span>
<span class="lineNum">     292 </span>            :     {
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :       error (&quot;malformed option -fplugin-arg-%s (missing -&lt;key&gt;[=&lt;value&gt;])&quot;,</span>
<span class="lineNum">     294 </span>            :              arg);
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">     296 </span>            :     }
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span>            :   /* If the option doesn't contain the 'value' part, LEN is the KEY_LEN.
<span class="lineNum">     299 </span>            :      Otherwise, it is the VALUE_LEN.  */
<span class="lineNum">     300 </span><span class="lineCov">          9 :   if (!value_start)</span>
<span class="lineNum">     301 </span>            :     key_len = len;
<span class="lineNum">     302 </span>            :   else
<span class="lineNum">     303 </span><span class="lineCov">          4 :     value_len = len;</span>
<span class="lineNum">     304 </span>            : 
<span class="lineNum">     305 </span><span class="lineCov">          9 :   name = XNEWVEC (char, name_len + 1);</span>
<span class="lineNum">     306 </span><span class="lineCov">          9 :   strncpy (name, name_start, name_len);</span>
<span class="lineNum">     307 </span><span class="lineCov">          9 :   name[name_len] = '\0';</span>
<span class="lineNum">     308 </span>            : 
<span class="lineNum">     309 </span>            :   /* Check if the named plugin has already been specified earlier in the
<span class="lineNum">     310 </span>            :      command-line.  */
<span class="lineNum">     311 </span><span class="lineCov">          9 :   if (plugin_name_args_tab</span>
<span class="lineNum">     312 </span><span class="lineCov">          9 :       &amp;&amp; ((slot = htab_find_slot_with_hash (plugin_name_args_tab, name,</span>
<span class="lineNum">     313 </span>            :                                             htab_hash_string (name), NO_INSERT))
<span class="lineNum">     314 </span><span class="lineCov">          9 :           != NULL))</span>
<span class="lineNum">     315 </span>            :     {
<span class="lineNum">     316 </span><span class="lineCov">          9 :       struct plugin_name_args *plugin = (struct plugin_name_args *) *slot;</span>
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span><span class="lineCov">          9 :       key = XNEWVEC (char, key_len + 1);</span>
<span class="lineNum">     319 </span><span class="lineCov">          9 :       strncpy (key, key_start, key_len);</span>
<span class="lineNum">     320 </span><span class="lineCov">          9 :       key[key_len] = '\0';</span>
<span class="lineNum">     321 </span><span class="lineCov">          9 :       if (value_start)</span>
<span class="lineNum">     322 </span>            :         {
<span class="lineNum">     323 </span><span class="lineCov">          4 :           value = XNEWVEC (char, value_len + 1);</span>
<span class="lineNum">     324 </span><span class="lineCov">          4 :           strncpy (value, value_start, value_len);</span>
<span class="lineNum">     325 </span><span class="lineCov">          4 :           value[value_len] = '\0';</span>
<span class="lineNum">     326 </span>            :         }
<span class="lineNum">     327 </span>            :       else
<span class="lineNum">     328 </span>            :         value = NULL;
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span>            :       /* Create a plugin_argument object for the parsed key-value pair.
<span class="lineNum">     331 </span>            :          If there are already arguments for this plugin, we will need to
<span class="lineNum">     332 </span>            :          adjust the argument array size by creating a new array and deleting
<span class="lineNum">     333 </span>            :          the old one. If the performance ever becomes an issue, we can
<span class="lineNum">     334 </span>            :          change the code by pre-allocating a larger array first.  */
<span class="lineNum">     335 </span><span class="lineCov">          9 :       if (plugin-&gt;argc &gt; 0)</span>
<span class="lineNum">     336 </span>            :         {
<span class="lineNum">     337 </span><span class="lineCov">          1 :           struct plugin_argument *args = XNEWVEC (struct plugin_argument,</span>
<span class="lineNum">     338 </span>            :                                                   plugin-&gt;argc + 1);
<span class="lineNum">     339 </span><span class="lineCov">          2 :           memcpy (args, plugin-&gt;argv,</span>
<span class="lineNum">     340 </span><span class="lineCov">          1 :                   sizeof (struct plugin_argument) * plugin-&gt;argc);</span>
<span class="lineNum">     341 </span><span class="lineCov">          1 :           XDELETEVEC (plugin-&gt;argv);</span>
<span class="lineNum">     342 </span><span class="lineCov">          1 :           plugin-&gt;argv = args;</span>
<span class="lineNum">     343 </span><span class="lineCov">          1 :           ++plugin-&gt;argc;</span>
<span class="lineNum">     344 </span>            :         }
<span class="lineNum">     345 </span>            :       else
<span class="lineNum">     346 </span>            :         {
<span class="lineNum">     347 </span><span class="lineCov">          8 :           gcc_assert (plugin-&gt;argv == NULL);</span>
<span class="lineNum">     348 </span><span class="lineCov">          8 :           plugin-&gt;argv = XNEWVEC (struct plugin_argument, 1);</span>
<span class="lineNum">     349 </span><span class="lineCov">          8 :           plugin-&gt;argc = 1;</span>
<span class="lineNum">     350 </span>            :         }
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span><span class="lineCov">          9 :       plugin-&gt;argv[plugin-&gt;argc - 1].key = key;</span>
<span class="lineNum">     353 </span><span class="lineCov">          9 :       plugin-&gt;argv[plugin-&gt;argc - 1].value = value;</span>
<span class="lineNum">     354 </span>            :     }
<span class="lineNum">     355 </span>            :   else
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :     error (&quot;plugin %s should be specified before -fplugin-arg-%s &quot;</span>
<span class="lineNum">     357 </span>            :            &quot;in the command line&quot;, name, arg);
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span>            :   /* We don't need the plugin's name anymore. Just release it.  */
<span class="lineNum">     360 </span><span class="lineCov">          9 :   XDELETEVEC (name);</span>
<span class="lineNum">     361 </span>            : }
<span class="lineNum">     362 </span>            : 
<span class="lineNum">     363 </span>            : /* Register additional plugin information. NAME is the name passed to
<span class="lineNum">     364 </span>            :    plugin_init. INFO is the information that should be registered. */
<a name="365"><span class="lineNum">     365 </span>            : </a>
<span class="lineNum">     366 </span>            : static void
<span class="lineNum">     367 </span><span class="lineNoCov">          0 : register_plugin_info (const char* name, struct plugin_info *info)</span>
<span class="lineNum">     368 </span>            : {
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :   void **slot = htab_find_slot_with_hash (plugin_name_args_tab, name,</span>
<span class="lineNum">     370 </span>            :                                           htab_hash_string (name), NO_INSERT);
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :   struct plugin_name_args *plugin;</span>
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :   if (slot == NULL)</span>
<span class="lineNum">     374 </span>            :     {
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :       error (&quot;unable to register info for plugin %qs - plugin name not found&quot;,</span>
<span class="lineNum">     376 </span>            :              name);
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">     378 </span>            :     }
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :   plugin = (struct plugin_name_args *) *slot;</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :   plugin-&gt;version = info-&gt;version;</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :   plugin-&gt;help = info-&gt;help;</span>
<span class="lineNum">     382 </span>            : }
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span>            : /* Look up the event id for NAME.  If the name is not found, return -1
<span class="lineNum">     385 </span>            :    if INSERT is NO_INSERT.  */
<a name="386"><span class="lineNum">     386 </span>            : </a>
<span class="lineNum">     387 </span>            : int
<span class="lineNum">     388 </span><span class="lineNoCov">          0 : get_named_event_id (const char *name, enum insert_option insert)</span>
<span class="lineNum">     389 </span>            : {
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :   const char ***slot;</span>
<span class="lineNum">     391 </span>            : 
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :   if (!event_tab)</span>
<span class="lineNum">     393 </span>            :     {
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :       int i;</span>
<span class="lineNum">     395 </span>            : 
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :       event_tab = new hash_table&lt;event_hasher&gt; (150);</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :       for (i = 0; i &lt; event_last; i++)</span>
<span class="lineNum">     398 </span>            :         {
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :           slot = event_tab-&gt;find_slot (&amp;plugin_event_name[i], INSERT);</span>
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :           gcc_assert (*slot == HTAB_EMPTY_ENTRY);</span>
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :           *slot = &amp;plugin_event_name[i];</span>
<span class="lineNum">     402 </span>            :         }
<span class="lineNum">     403 </span>            :     }
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :   slot = event_tab-&gt;find_slot (&amp;name, insert);</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :   if (slot == NULL)</span>
<span class="lineNum">     406 </span>            :     return -1;
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :   if (*slot != HTAB_EMPTY_ENTRY)</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :     return *slot - &amp;plugin_event_name[0];</span>
<span class="lineNum">     409 </span>            : 
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :   if (event_last &gt;= event_horizon)</span>
<span class="lineNum">     411 </span>            :     {
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :       event_horizon = event_last * 2;</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :       if (plugin_event_name == plugin_event_name_init)</span>
<span class="lineNum">     414 </span>            :         {
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :           plugin_event_name = XNEWVEC (const char *, event_horizon);</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :           memcpy (plugin_event_name, plugin_event_name_init,</span>
<span class="lineNum">     417 </span>            :                   sizeof plugin_event_name_init);
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :           plugin_callbacks = XNEWVEC (struct callback_info *, event_horizon);</span>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :           memcpy (plugin_callbacks, plugin_callbacks_init,</span>
<span class="lineNum">     420 </span>            :                   sizeof plugin_callbacks_init);
<span class="lineNum">     421 </span>            :         }
<span class="lineNum">     422 </span>            :       else
<span class="lineNum">     423 </span>            :         {
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :           plugin_event_name</span>
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :             = XRESIZEVEC (const char *, plugin_event_name, event_horizon);</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :           plugin_callbacks = XRESIZEVEC (struct callback_info *,</span>
<span class="lineNum">     427 </span>            :                                          plugin_callbacks, event_horizon);
<span class="lineNum">     428 </span>            :         }
<span class="lineNum">     429 </span>            :       /* All the pointers in the hash table will need to be updated.  */
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :       delete event_tab;</span>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :       event_tab = NULL;</span>
<span class="lineNum">     432 </span>            :     }
<span class="lineNum">     433 </span>            :   else
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :     *slot = &amp;plugin_event_name[event_last];</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :   plugin_event_name[event_last] = name;</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :   return event_last++;</span>
<span class="lineNum">     437 </span>            : }
<span class="lineNum">     438 </span>            : 
<span class="lineNum">     439 </span>            : /* Called from the plugin's initialization code. Register a single callback.
<span class="lineNum">     440 </span>            :    This function can be called multiple times.
<span class="lineNum">     441 </span>            : 
<span class="lineNum">     442 </span>            :    PLUGIN_NAME - display name for this plugin
<span class="lineNum">     443 </span>            :    EVENT       - which event the callback is for
<span class="lineNum">     444 </span>            :    CALLBACK    - the callback to be called at the event
<span class="lineNum">     445 </span>            :    USER_DATA   - plugin-provided data   */
<a name="446"><span class="lineNum">     446 </span>            : </a>
<span class="lineNum">     447 </span>            : void
<span class="lineNum">     448 </span><span class="lineCov">         42 : register_callback (const char *plugin_name,</span>
<span class="lineNum">     449 </span>            :                    int event,
<span class="lineNum">     450 </span>            :                    plugin_callback_func callback,
<span class="lineNum">     451 </span>            :                    void *user_data)
<span class="lineNum">     452 </span>            : {
<span class="lineNum">     453 </span><span class="lineCov">         42 :   switch (event)</span>
<span class="lineNum">     454 </span>            :     {
<span class="lineNum">     455 </span><span class="lineCov">         22 :       case PLUGIN_PASS_MANAGER_SETUP:</span>
<span class="lineNum">     456 </span><span class="lineCov">         22 :         gcc_assert (!callback);</span>
<span class="lineNum">     457 </span><span class="lineCov">         22 :         register_pass ((struct register_pass_info *) user_data);</span>
<span class="lineNum">     458 </span><span class="lineCov">         22 :         break;</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :       case PLUGIN_INFO:</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :         gcc_assert (!callback);</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :         register_plugin_info (plugin_name, (struct plugin_info *) user_data);</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :       case PLUGIN_REGISTER_GGC_ROOTS:</span>
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :         gcc_assert (!callback);</span>
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :         ggc_register_root_tab ((const struct ggc_root_tab*) user_data);</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :       case PLUGIN_EVENT_FIRST_DYNAMIC:</span>
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :       default:</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :         if (event &lt; PLUGIN_EVENT_FIRST_DYNAMIC || event &gt;= event_last)</span>
<span class="lineNum">     470 </span>            :           {
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :             error (&quot;unknown callback event registered by plugin %s&quot;,</span>
<span class="lineNum">     472 </span>            :                    plugin_name);
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     474 </span>            :           }
<span class="lineNum">     475 </span>            :       /* Fall through.  */
<span class="lineNum">     476 </span><span class="lineCov">         20 :       case PLUGIN_START_PARSE_FUNCTION:</span>
<span class="lineNum">     477 </span><span class="lineCov">         20 :       case PLUGIN_FINISH_PARSE_FUNCTION:</span>
<span class="lineNum">     478 </span><span class="lineCov">         20 :       case PLUGIN_FINISH_TYPE:</span>
<span class="lineNum">     479 </span><span class="lineCov">         20 :       case PLUGIN_FINISH_DECL:</span>
<span class="lineNum">     480 </span><span class="lineCov">         20 :       case PLUGIN_START_UNIT:</span>
<span class="lineNum">     481 </span><span class="lineCov">         20 :       case PLUGIN_FINISH_UNIT:</span>
<span class="lineNum">     482 </span><span class="lineCov">         20 :       case PLUGIN_PRE_GENERICIZE:</span>
<span class="lineNum">     483 </span><span class="lineCov">         20 :       case PLUGIN_GGC_START:</span>
<span class="lineNum">     484 </span><span class="lineCov">         20 :       case PLUGIN_GGC_MARKING:</span>
<span class="lineNum">     485 </span><span class="lineCov">         20 :       case PLUGIN_GGC_END:</span>
<span class="lineNum">     486 </span><span class="lineCov">         20 :       case PLUGIN_ATTRIBUTES:</span>
<span class="lineNum">     487 </span><span class="lineCov">         20 :       case PLUGIN_PRAGMAS:</span>
<span class="lineNum">     488 </span><span class="lineCov">         20 :       case PLUGIN_FINISH:</span>
<span class="lineNum">     489 </span><span class="lineCov">         20 :       case PLUGIN_ALL_PASSES_START:</span>
<span class="lineNum">     490 </span><span class="lineCov">         20 :       case PLUGIN_ALL_PASSES_END:</span>
<span class="lineNum">     491 </span><span class="lineCov">         20 :       case PLUGIN_ALL_IPA_PASSES_START:</span>
<span class="lineNum">     492 </span><span class="lineCov">         20 :       case PLUGIN_ALL_IPA_PASSES_END:</span>
<span class="lineNum">     493 </span><span class="lineCov">         20 :       case PLUGIN_OVERRIDE_GATE:</span>
<span class="lineNum">     494 </span><span class="lineCov">         20 :       case PLUGIN_PASS_EXECUTION:</span>
<span class="lineNum">     495 </span><span class="lineCov">         20 :       case PLUGIN_EARLY_GIMPLE_PASSES_START:</span>
<span class="lineNum">     496 </span><span class="lineCov">         20 :       case PLUGIN_EARLY_GIMPLE_PASSES_END:</span>
<span class="lineNum">     497 </span><span class="lineCov">         20 :       case PLUGIN_NEW_PASS:</span>
<span class="lineNum">     498 </span><span class="lineCov">         20 :       case PLUGIN_INCLUDE_FILE:</span>
<span class="lineNum">     499 </span><span class="lineCov">         20 :         {</span>
<span class="lineNum">     500 </span><span class="lineCov">         20 :           struct callback_info *new_callback;</span>
<span class="lineNum">     501 </span><span class="lineCov">         20 :           if (!callback)</span>
<span class="lineNum">     502 </span>            :             {
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :               error (&quot;plugin %s registered a null callback function &quot;</span>
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :                      &quot;for event %s&quot;, plugin_name, plugin_event_name[event]);</span>
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :               return;</span>
<span class="lineNum">     506 </span>            :             }
<span class="lineNum">     507 </span><span class="lineCov">         20 :           new_callback = XNEW (struct callback_info);</span>
<span class="lineNum">     508 </span><span class="lineCov">         20 :           new_callback-&gt;plugin_name = plugin_name;</span>
<span class="lineNum">     509 </span><span class="lineCov">         20 :           new_callback-&gt;func = callback;</span>
<span class="lineNum">     510 </span><span class="lineCov">         20 :           new_callback-&gt;user_data = user_data;</span>
<span class="lineNum">     511 </span><span class="lineCov">         20 :           new_callback-&gt;next = plugin_callbacks[event];</span>
<span class="lineNum">     512 </span><span class="lineCov">         20 :           plugin_callbacks[event] = new_callback;</span>
<span class="lineNum">     513 </span>            :         }
<span class="lineNum">     514 </span><span class="lineCov">         20 :         break;</span>
<span class="lineNum">     515 </span>            :     }
<span class="lineNum">     516 </span>            : }
<span class="lineNum">     517 </span>            : 
<span class="lineNum">     518 </span>            : /* Remove a callback for EVENT which has been registered with for a plugin
<span class="lineNum">     519 </span>            :    PLUGIN_NAME.  Return PLUGEVT_SUCCESS if a matching callback was
<span class="lineNum">     520 </span>            :    found &amp; removed, PLUGEVT_NO_CALLBACK if the event does not have a matching
<a name="521"><span class="lineNum">     521 </span>            :    callback, and PLUGEVT_NO_SUCH_EVENT if EVENT is invalid.  */</a>
<span class="lineNum">     522 </span>            : int
<span class="lineNum">     523 </span><span class="lineNoCov">          0 : unregister_callback (const char *plugin_name, int event)</span>
<span class="lineNum">     524 </span>            : {
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :   struct callback_info *callback, **cbp;</span>
<span class="lineNum">     526 </span>            : 
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :   if (event &gt;= event_last)</span>
<span class="lineNum">     528 </span>            :     return PLUGEVT_NO_SUCH_EVENT;
<span class="lineNum">     529 </span>            : 
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :   for (cbp = &amp;plugin_callbacks[event]; (callback = *cbp); cbp = &amp;callback-&gt;next)</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :     if (strcmp (callback-&gt;plugin_name, plugin_name) == 0)</span>
<span class="lineNum">     532 </span>            :       {
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :         *cbp = callback-&gt;next;</span>
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :         return PLUGEVT_SUCCESS;</span>
<span class="lineNum">     535 </span>            :       }
<span class="lineNum">     536 </span>            :   return PLUGEVT_NO_CALLBACK;
<span class="lineNum">     537 </span>            : }
<span class="lineNum">     538 </span>            : 
<span class="lineNum">     539 </span>            : /* Invoke all plugin callbacks registered with the specified event,
<span class="lineNum">     540 </span>            :    called from invoke_plugin_callbacks().  */
<a name="541"><span class="lineNum">     541 </span>            : </a>
<span class="lineNum">     542 </span>            : int
<span class="lineNum">     543 </span><span class="lineCov">      41958 : invoke_plugin_callbacks_full (int event, void *gcc_data)</span>
<span class="lineNum">     544 </span>            : {
<span class="lineNum">     545 </span><span class="lineCov">      41958 :   int retval = PLUGEVT_SUCCESS;</span>
<span class="lineNum">     546 </span>            : 
<span class="lineNum">     547 </span><span class="lineCov">      41958 :   timevar_push (TV_PLUGIN_RUN);</span>
<span class="lineNum">     548 </span>            : 
<span class="lineNum">     549 </span><span class="lineCov">      41958 :   switch (event)</span>
<span class="lineNum">     550 </span>            :     {
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :       case PLUGIN_EVENT_FIRST_DYNAMIC:</span>
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :       default:</span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :         gcc_assert (event &gt;= PLUGIN_EVENT_FIRST_DYNAMIC);</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :         gcc_assert (event &lt; event_last);</span>
<span class="lineNum">     555 </span>            :       /* Fall through.  */
<span class="lineNum">     556 </span><span class="lineCov">      41958 :       case PLUGIN_START_PARSE_FUNCTION:</span>
<span class="lineNum">     557 </span><span class="lineCov">      41958 :       case PLUGIN_FINISH_PARSE_FUNCTION:</span>
<span class="lineNum">     558 </span><span class="lineCov">      41958 :       case PLUGIN_FINISH_TYPE:</span>
<span class="lineNum">     559 </span><span class="lineCov">      41958 :       case PLUGIN_FINISH_DECL:</span>
<span class="lineNum">     560 </span><span class="lineCov">      41958 :       case PLUGIN_START_UNIT:</span>
<span class="lineNum">     561 </span><span class="lineCov">      41958 :       case PLUGIN_FINISH_UNIT:</span>
<span class="lineNum">     562 </span><span class="lineCov">      41958 :       case PLUGIN_PRE_GENERICIZE:</span>
<span class="lineNum">     563 </span><span class="lineCov">      41958 :       case PLUGIN_ATTRIBUTES:</span>
<span class="lineNum">     564 </span><span class="lineCov">      41958 :       case PLUGIN_PRAGMAS:</span>
<span class="lineNum">     565 </span><span class="lineCov">      41958 :       case PLUGIN_FINISH:</span>
<span class="lineNum">     566 </span><span class="lineCov">      41958 :       case PLUGIN_GGC_START:</span>
<span class="lineNum">     567 </span><span class="lineCov">      41958 :       case PLUGIN_GGC_MARKING:</span>
<span class="lineNum">     568 </span><span class="lineCov">      41958 :       case PLUGIN_GGC_END:</span>
<span class="lineNum">     569 </span><span class="lineCov">      41958 :       case PLUGIN_ALL_PASSES_START:</span>
<span class="lineNum">     570 </span><span class="lineCov">      41958 :       case PLUGIN_ALL_PASSES_END:</span>
<span class="lineNum">     571 </span><span class="lineCov">      41958 :       case PLUGIN_ALL_IPA_PASSES_START:</span>
<span class="lineNum">     572 </span><span class="lineCov">      41958 :       case PLUGIN_ALL_IPA_PASSES_END:</span>
<span class="lineNum">     573 </span><span class="lineCov">      41958 :       case PLUGIN_OVERRIDE_GATE:</span>
<span class="lineNum">     574 </span><span class="lineCov">      41958 :       case PLUGIN_PASS_EXECUTION:</span>
<span class="lineNum">     575 </span><span class="lineCov">      41958 :       case PLUGIN_EARLY_GIMPLE_PASSES_START:</span>
<span class="lineNum">     576 </span><span class="lineCov">      41958 :       case PLUGIN_EARLY_GIMPLE_PASSES_END:</span>
<span class="lineNum">     577 </span><span class="lineCov">      41958 :       case PLUGIN_NEW_PASS:</span>
<span class="lineNum">     578 </span><span class="lineCov">      41958 :       case PLUGIN_INCLUDE_FILE:</span>
<span class="lineNum">     579 </span><span class="lineCov">      41958 :         {</span>
<span class="lineNum">     580 </span>            :           /* Iterate over every callback registered with this event and
<span class="lineNum">     581 </span>            :              call it.  */
<span class="lineNum">     582 </span><span class="lineCov">      41958 :           struct callback_info *callback = plugin_callbacks[event];</span>
<span class="lineNum">     583 </span>            : 
<span class="lineNum">     584 </span><span class="lineCov">      41958 :           if (!callback)</span>
<span class="lineNum">     585 </span><span class="lineCov">      41814 :             retval = PLUGEVT_NO_CALLBACK;</span>
<span class="lineNum">     586 </span><span class="lineCov">      42102 :           for ( ; callback; callback = callback-&gt;next)</span>
<span class="lineNum">     587 </span><span class="lineCov">      42102 :             (*callback-&gt;func) (gcc_data, callback-&gt;user_data);</span>
<span class="lineNum">     588 </span>            :         }
<span class="lineNum">     589 </span><span class="lineCov">      41958 :         break;</span>
<span class="lineNum">     590 </span>            : 
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :       case PLUGIN_PASS_MANAGER_SETUP:</span>
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :       case PLUGIN_REGISTER_GGC_ROOTS:</span>
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :         gcc_assert (false);</span>
<span class="lineNum">     594 </span>            :     }
<span class="lineNum">     595 </span>            : 
<span class="lineNum">     596 </span><span class="lineCov">      41958 :   timevar_pop (TV_PLUGIN_RUN);</span>
<span class="lineNum">     597 </span><span class="lineCov">      41958 :   return retval;</span>
<span class="lineNum">     598 </span>            : }
<span class="lineNum">     599 </span>            : 
<span class="lineNum">     600 </span>            : #ifdef ENABLE_PLUGIN
<span class="lineNum">     601 </span>            : 
<span class="lineNum">     602 </span>            : /* Try to initialize PLUGIN. Return true if successful. */
<span class="lineNum">     603 </span>            : 
<span class="lineNum">     604 </span>            : #ifdef __MINGW32__
<span class="lineNum">     605 </span>            : 
<span class="lineNum">     606 </span>            : // Return a message string for last error or NULL if unknown. Must be freed
<span class="lineNum">     607 </span>            : // with LocalFree().
<span class="lineNum">     608 </span>            : static inline char *
<span class="lineNum">     609 </span>            : win32_error_msg ()
<span class="lineNum">     610 </span>            : {
<span class="lineNum">     611 </span>            :   char *msg;
<span class="lineNum">     612 </span>            :   return FormatMessageA (FORMAT_MESSAGE_ALLOCATE_BUFFER |
<span class="lineNum">     613 </span>            :                          FORMAT_MESSAGE_FROM_SYSTEM |
<span class="lineNum">     614 </span>            :                          FORMAT_MESSAGE_IGNORE_INSERTS |
<span class="lineNum">     615 </span>            :                          FORMAT_MESSAGE_MAX_WIDTH_MASK,
<span class="lineNum">     616 </span>            :                          0,
<span class="lineNum">     617 </span>            :                          GetLastError (),
<span class="lineNum">     618 </span>            :                          MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT),
<span class="lineNum">     619 </span>            :                          (char*)&amp;msg,
<span class="lineNum">     620 </span>            :                          0,
<span class="lineNum">     621 </span>            :                          0)
<span class="lineNum">     622 </span>            :     ? msg
<span class="lineNum">     623 </span>            :     : NULL;
<span class="lineNum">     624 </span>            : }
<span class="lineNum">     625 </span>            : 
<span class="lineNum">     626 </span>            : static bool
<span class="lineNum">     627 </span>            : try_init_one_plugin (struct plugin_name_args *plugin)
<span class="lineNum">     628 </span>            : {
<span class="lineNum">     629 </span>            :   HMODULE dl_handle;
<span class="lineNum">     630 </span>            :   plugin_init_func plugin_init;
<span class="lineNum">     631 </span>            : 
<span class="lineNum">     632 </span>            :   dl_handle = LoadLibrary (plugin-&gt;full_name);
<span class="lineNum">     633 </span>            :   if (!dl_handle)
<span class="lineNum">     634 </span>            :     {
<span class="lineNum">     635 </span>            :       char *err = win32_error_msg ();
<span class="lineNum">     636 </span>            :       error (&quot;cannot load plugin %s\n%s&quot;, plugin-&gt;full_name, err);
<span class="lineNum">     637 </span>            :       LocalFree (err);
<span class="lineNum">     638 </span>            :       return false;
<span class="lineNum">     639 </span>            :     }
<span class="lineNum">     640 </span>            : 
<span class="lineNum">     641 </span>            :   /* Check the plugin license. Unlike the name suggests, GetProcAddress()
<span class="lineNum">     642 </span>            :      can be used for both functions and variables.  */
<span class="lineNum">     643 </span>            :   if (GetProcAddress (dl_handle, str_license) == NULL)
<span class="lineNum">     644 </span>            :     {
<span class="lineNum">     645 </span>            :       char *err = win32_error_msg ();
<span class="lineNum">     646 </span>            :       fatal_error (input_location,
<span class="lineNum">     647 </span>            :                    &quot;plugin %s is not licensed under a GPL-compatible license\n&quot;
<span class="lineNum">     648 </span>            :                    &quot;%s&quot;, plugin-&gt;full_name, err);
<span class="lineNum">     649 </span>            :     }
<span class="lineNum">     650 </span>            : 
<span class="lineNum">     651 </span>            :   /* Unlike dlsym(), GetProcAddress() returns a pointer to a function so we
<span class="lineNum">     652 </span>            :      can cast directly without union tricks.  */
<span class="lineNum">     653 </span>            :   plugin_init = (plugin_init_func)
<span class="lineNum">     654 </span>            :     GetProcAddress (dl_handle, str_plugin_init_func_name);
<span class="lineNum">     655 </span>            : 
<span class="lineNum">     656 </span>            :   if (plugin_init == NULL)
<span class="lineNum">     657 </span>            :     {
<span class="lineNum">     658 </span>            :       char *err = win32_error_msg ();
<span class="lineNum">     659 </span>            :       FreeLibrary (dl_handle);
<span class="lineNum">     660 </span>            :       error (&quot;cannot find %s in plugin %s\n%s&quot;, str_plugin_init_func_name,
<span class="lineNum">     661 </span>            :              plugin-&gt;full_name, err);
<span class="lineNum">     662 </span>            :       LocalFree (err);
<span class="lineNum">     663 </span>            :       return false;
<span class="lineNum">     664 </span>            :     }
<span class="lineNum">     665 </span>            : 
<span class="lineNum">     666 </span>            :   /* Call the plugin-provided initialization routine with the arguments.  */
<span class="lineNum">     667 </span>            :   if ((*plugin_init) (plugin, &amp;gcc_version))
<span class="lineNum">     668 </span>            :     {
<span class="lineNum">     669 </span>            :       FreeLibrary (dl_handle);
<span class="lineNum">     670 </span>            :       error (&quot;fail to initialize plugin %s&quot;, plugin-&gt;full_name);
<span class="lineNum">     671 </span>            :       return false;
<span class="lineNum">     672 </span>            :     }
<span class="lineNum">     673 </span>            :   /* Leak dl_handle on purpose to ensure the plugin is loaded for the
<span class="lineNum">     674 </span>            :      entire run of the compiler. */
<span class="lineNum">     675 </span>            :   return true;
<span class="lineNum">     676 </span>            : }
<span class="lineNum">     677 </span>            : 
<span class="lineNum">     678 </span>            : #else // POSIX-like with dlopen()/dlsym().
<span class="lineNum">     679 </span>            : 
<span class="lineNum">     680 </span>            : /* We need a union to cast dlsym return value to a function pointer
<span class="lineNum">     681 </span>            :    as ISO C forbids assignment between function pointer and 'void *'.
<span class="lineNum">     682 </span>            :    Use explicit union instead of __extension__(&lt;union_cast&gt;) for
<span class="lineNum">     683 </span>            :    portability.  */
<span class="lineNum">     684 </span>            : #define PTR_UNION_TYPE(TOTYPE) union { void *_q; TOTYPE _nq; }
<span class="lineNum">     685 </span>            : #define PTR_UNION_AS_VOID_PTR(NAME) (NAME._q)
<span class="lineNum">     686 </span>            : #define PTR_UNION_AS_CAST_PTR(NAME) (NAME._nq)
<a name="687"><span class="lineNum">     687 </span>            : </a>
<span class="lineNum">     688 </span>            : static bool
<span class="lineNum">     689 </span><span class="lineCov">         52 : try_init_one_plugin (struct plugin_name_args *plugin)</span>
<span class="lineNum">     690 </span>            : {
<span class="lineNum">     691 </span><span class="lineCov">         52 :   void *dl_handle;</span>
<span class="lineNum">     692 </span><span class="lineCov">         52 :   plugin_init_func plugin_init;</span>
<span class="lineNum">     693 </span><span class="lineCov">         52 :   const char *err;</span>
<span class="lineNum">     694 </span><span class="lineCov">         52 :   PTR_UNION_TYPE (plugin_init_func) plugin_init_union;</span>
<span class="lineNum">     695 </span>            : 
<span class="lineNum">     696 </span>            :   /* We use RTLD_NOW to accelerate binding and detect any mismatch
<span class="lineNum">     697 </span>            :      between the API expected by the plugin and the GCC API; we use
<span class="lineNum">     698 </span>            :      RTLD_GLOBAL which is useful to plugins which themselves call
<span class="lineNum">     699 </span>            :      dlopen.  */
<span class="lineNum">     700 </span><span class="lineCov">         52 :   dl_handle = dlopen (plugin-&gt;full_name, RTLD_NOW | RTLD_GLOBAL);</span>
<span class="lineNum">     701 </span><span class="lineCov">         52 :   if (!dl_handle)</span>
<span class="lineNum">     702 </span>            :     {
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :       error (&quot;cannot load plugin %s\n%s&quot;, plugin-&gt;full_name, dlerror ());</span>
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     705 </span>            :     }
<span class="lineNum">     706 </span>            : 
<span class="lineNum">     707 </span>            :   /* Clear any existing error.  */
<span class="lineNum">     708 </span><span class="lineCov">         52 :   dlerror ();</span>
<span class="lineNum">     709 </span>            : 
<span class="lineNum">     710 </span>            :   /* Check the plugin license.  */
<span class="lineNum">     711 </span><span class="lineCov">         52 :   if (dlsym (dl_handle, str_license) == NULL)</span>
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :     fatal_error (input_location,</span>
<span class="lineNum">     713 </span>            :                  &quot;plugin %s is not licensed under a GPL-compatible license\n&quot;
<span class="lineNum">     714 </span>            :                  &quot;%s&quot;, plugin-&gt;full_name, dlerror ());
<span class="lineNum">     715 </span>            : 
<span class="lineNum">     716 </span><span class="lineCov">        104 :   PTR_UNION_AS_VOID_PTR (plugin_init_union) =</span>
<span class="lineNum">     717 </span><span class="lineCov">         52 :       dlsym (dl_handle, str_plugin_init_func_name);</span>
<span class="lineNum">     718 </span><span class="lineCov">         52 :   plugin_init = PTR_UNION_AS_CAST_PTR (plugin_init_union);</span>
<span class="lineNum">     719 </span>            : 
<span class="lineNum">     720 </span><span class="lineCov">         52 :   if ((err = dlerror ()) != NULL)</span>
<span class="lineNum">     721 </span>            :     {
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :       dlclose(dl_handle);</span>
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :       error (&quot;cannot find %s in plugin %s\n%s&quot;, str_plugin_init_func_name,</span>
<span class="lineNum">     724 </span>            :              plugin-&gt;full_name, err);
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     726 </span>            :     }
<span class="lineNum">     727 </span>            : 
<span class="lineNum">     728 </span>            :   /* Call the plugin-provided initialization routine with the arguments.  */
<span class="lineNum">     729 </span><span class="lineCov">         52 :   if ((*plugin_init) (plugin, &amp;gcc_version))</span>
<span class="lineNum">     730 </span>            :     {
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :       dlclose(dl_handle);</span>
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :       error (&quot;fail to initialize plugin %s&quot;, plugin-&gt;full_name);</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     734 </span>            :     }
<span class="lineNum">     735 </span>            :   /* leak dl_handle on purpose to ensure the plugin is loaded for the
<span class="lineNum">     736 </span>            :      entire run of the compiler. */
<span class="lineNum">     737 </span>            :   return true;
<span class="lineNum">     738 </span>            : }
<span class="lineNum">     739 </span>            : #endif
<span class="lineNum">     740 </span>            : 
<span class="lineNum">     741 </span>            : /* Routine to dlopen and initialize one plugin. This function is passed to
<span class="lineNum">     742 </span>            :    (and called by) the hash table traverse routine. Return 1 for the
<span class="lineNum">     743 </span>            :    htab_traverse to continue scan, 0 to stop.
<span class="lineNum">     744 </span>            : 
<span class="lineNum">     745 </span>            :    SLOT - slot of the hash table element
<span class="lineNum">     746 </span>            :    INFO - auxiliary pointer handed to hash table traverse routine
<span class="lineNum">     747 </span>            :           (unused in this function)  */
<a name="748"><span class="lineNum">     748 </span>            : </a>
<span class="lineNum">     749 </span>            : static int
<span class="lineNum">     750 </span><span class="lineCov">         52 : init_one_plugin (void **slot, void * ARG_UNUSED (info))</span>
<span class="lineNum">     751 </span>            : {
<span class="lineNum">     752 </span><span class="lineCov">         52 :   struct plugin_name_args *plugin = (struct plugin_name_args *) *slot;</span>
<span class="lineNum">     753 </span><span class="lineCov">         52 :   bool ok = try_init_one_plugin (plugin);</span>
<span class="lineNum">     754 </span><span class="lineCov">         52 :   if (!ok)</span>
<span class="lineNum">     755 </span>            :     {
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :       htab_remove_elt_with_hash (plugin_name_args_tab, plugin-&gt;base_name,</span>
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :                                  htab_hash_string (plugin-&gt;base_name));</span>
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :       XDELETE (plugin);</span>
<span class="lineNum">     759 </span>            :     }
<span class="lineNum">     760 </span><span class="lineCov">         52 :   return 1;</span>
<span class="lineNum">     761 </span>            : }
<span class="lineNum">     762 </span>            : 
<span class="lineNum">     763 </span>            : #endif  /* ENABLE_PLUGIN  */
<span class="lineNum">     764 </span>            : 
<span class="lineNum">     765 </span>            : /* Main plugin initialization function.  Called from compile_file() in
<span class="lineNum">     766 </span>            :    toplev.c.  */
<a name="767"><span class="lineNum">     767 </span>            : </a>
<span class="lineNum">     768 </span>            : void
<span class="lineNum">     769 </span><span class="lineCov">     170307 : initialize_plugins (void)</span>
<span class="lineNum">     770 </span>            : {
<span class="lineNum">     771 </span>            :   /* If no plugin was specified in the command-line, simply return.  */
<span class="lineNum">     772 </span><span class="lineCov">     170307 :   if (!plugin_name_args_tab)</span>
<span class="lineNum">     773 </span>            :     return;
<span class="lineNum">     774 </span>            : 
<span class="lineNum">     775 </span><span class="lineCov">         52 :   timevar_push (TV_PLUGIN_INIT);</span>
<span class="lineNum">     776 </span>            : 
<span class="lineNum">     777 </span>            : #ifdef ENABLE_PLUGIN
<span class="lineNum">     778 </span>            :   /* Traverse and initialize each plugin specified in the command-line.  */
<span class="lineNum">     779 </span><span class="lineCov">         52 :   htab_traverse_noresize (plugin_name_args_tab, init_one_plugin, NULL);</span>
<span class="lineNum">     780 </span>            : #endif
<span class="lineNum">     781 </span>            : 
<span class="lineNum">     782 </span><span class="lineCov">         52 :   timevar_pop (TV_PLUGIN_INIT);</span>
<span class="lineNum">     783 </span>            : }
<span class="lineNum">     784 </span>            : 
<span class="lineNum">     785 </span>            : /* Release memory used by one plugin. */
<a name="786"><span class="lineNum">     786 </span>            : </a>
<span class="lineNum">     787 </span>            : static int
<span class="lineNum">     788 </span><span class="lineCov">         52 : finalize_one_plugin (void **slot, void * ARG_UNUSED (info))</span>
<span class="lineNum">     789 </span>            : {
<span class="lineNum">     790 </span><span class="lineCov">         52 :   struct plugin_name_args *plugin = (struct plugin_name_args *) *slot;</span>
<span class="lineNum">     791 </span><span class="lineCov">         52 :   XDELETE (plugin);</span>
<span class="lineNum">     792 </span><span class="lineCov">         52 :   return 1;</span>
<span class="lineNum">     793 </span>            : }
<span class="lineNum">     794 </span>            : 
<span class="lineNum">     795 </span>            : /* Free memory allocated by the plugin system. */
<a name="796"><span class="lineNum">     796 </span>            : </a>
<span class="lineNum">     797 </span>            : void
<span class="lineNum">     798 </span><span class="lineCov">     170013 : finalize_plugins (void)</span>
<span class="lineNum">     799 </span>            : {
<span class="lineNum">     800 </span><span class="lineCov">     170013 :   if (!plugin_name_args_tab)</span>
<span class="lineNum">     801 </span>            :     return;
<span class="lineNum">     802 </span>            : 
<span class="lineNum">     803 </span>            :   /* We can now delete the plugin_name_args object as it will no longer
<span class="lineNum">     804 </span>            :      be used. Note that base_name and argv fields (both of which were also
<span class="lineNum">     805 </span>            :      dynamically allocated) are not freed as they could still be used by
<span class="lineNum">     806 </span>            :      the plugin code.  */
<span class="lineNum">     807 </span>            : 
<span class="lineNum">     808 </span><span class="lineCov">         52 :   htab_traverse_noresize (plugin_name_args_tab, finalize_one_plugin, NULL);</span>
<span class="lineNum">     809 </span>            : 
<span class="lineNum">     810 </span>            :   /* PLUGIN_NAME_ARGS_TAB is no longer needed, just delete it.  */
<span class="lineNum">     811 </span><span class="lineCov">         52 :   htab_delete (plugin_name_args_tab);</span>
<span class="lineNum">     812 </span><span class="lineCov">         52 :   plugin_name_args_tab = NULL;</span>
<span class="lineNum">     813 </span>            : }
<span class="lineNum">     814 </span>            : 
<span class="lineNum">     815 </span>            : /* Used to pass options to htab_traverse callbacks. */
<span class="lineNum">     816 </span>            : 
<span class="lineNum">     817 </span>            : struct print_options
<span class="lineNum">     818 </span>            : {
<span class="lineNum">     819 </span>            :   FILE *file;
<span class="lineNum">     820 </span>            :   const char *indent;
<span class="lineNum">     821 </span>            : };
<span class="lineNum">     822 </span>            : 
<span class="lineNum">     823 </span>            : /* Print the version of one plugin. */
<a name="824"><span class="lineNum">     824 </span>            : </a>
<span class="lineNum">     825 </span>            : static int
<span class="lineNum">     826 </span><span class="lineNoCov">          0 : print_version_one_plugin (void **slot, void *data)</span>
<span class="lineNum">     827 </span>            : {
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :   struct print_options *opt = (struct print_options *) data;</span>
<span class="lineNum">     829 </span><span class="lineNoCov">          0 :   struct plugin_name_args *plugin = (struct plugin_name_args *) *slot;</span>
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :   const char *version = plugin-&gt;version ? plugin-&gt;version : &quot;Unknown version.&quot;;</span>
<span class="lineNum">     831 </span>            : 
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :   fprintf (opt-&gt;file, &quot; %s%s: %s\n&quot;, opt-&gt;indent, plugin-&gt;base_name, version);</span>
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :   return 1;</span>
<span class="lineNum">     834 </span>            : }
<span class="lineNum">     835 </span>            : 
<span class="lineNum">     836 </span>            : /* Print the version of each plugin. */
<a name="837"><span class="lineNum">     837 </span>            : </a>
<span class="lineNum">     838 </span>            : void
<span class="lineNum">     839 </span><span class="lineCov">        223 : print_plugins_versions (FILE *file, const char *indent)</span>
<span class="lineNum">     840 </span>            : {
<span class="lineNum">     841 </span><span class="lineCov">        223 :   struct print_options opt;</span>
<span class="lineNum">     842 </span><span class="lineCov">        223 :   opt.file = file;</span>
<span class="lineNum">     843 </span><span class="lineCov">        223 :   opt.indent = indent;</span>
<span class="lineNum">     844 </span><span class="lineCov">        223 :   if (!plugin_name_args_tab || htab_elements (plugin_name_args_tab) == 0)</span>
<span class="lineNum">     845 </span><span class="lineCov">        223 :     return;</span>
<span class="lineNum">     846 </span>            : 
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :   fprintf (file, &quot;%sVersions of loaded plugins:\n&quot;, indent);</span>
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :   htab_traverse_noresize (plugin_name_args_tab, print_version_one_plugin, &amp;opt);</span>
<span class="lineNum">     849 </span>            : }
<span class="lineNum">     850 </span>            : 
<span class="lineNum">     851 </span>            : /* Print help for one plugin. SLOT is the hash table slot. DATA is the
<span class="lineNum">     852 </span>            :    argument to htab_traverse_noresize. */
<a name="853"><span class="lineNum">     853 </span>            : </a>
<span class="lineNum">     854 </span>            : static int
<span class="lineNum">     855 </span><span class="lineNoCov">          0 : print_help_one_plugin (void **slot, void *data)</span>
<span class="lineNum">     856 </span>            : {
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :   struct print_options *opt = (struct print_options *) data;</span>
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :   struct plugin_name_args *plugin = (struct plugin_name_args *) *slot;</span>
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :   const char *help = plugin-&gt;help ? plugin-&gt;help : &quot;No help available .&quot;;</span>
<span class="lineNum">     860 </span>            : 
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :   char *dup = xstrdup (help);</span>
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :   char *p, *nl;</span>
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :   fprintf (opt-&gt;file, &quot; %s%s:\n&quot;, opt-&gt;indent, plugin-&gt;base_name);</span>
<span class="lineNum">     864 </span>            : 
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :   for (p = nl = dup; nl; p = nl)</span>
<span class="lineNum">     866 </span>            :     {
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :       nl = strchr (nl, '\n');</span>
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :       if (nl)</span>
<span class="lineNum">     869 </span>            :         {
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :           *nl = '\0';</span>
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :           nl++;</span>
<span class="lineNum">     872 </span>            :         }
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :       fprintf (opt-&gt;file, &quot;   %s %s\n&quot;, opt-&gt;indent, p);</span>
<span class="lineNum">     874 </span>            :     }
<span class="lineNum">     875 </span>            : 
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :   free (dup);</span>
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :   return 1;</span>
<span class="lineNum">     878 </span>            : }
<span class="lineNum">     879 </span>            : 
<span class="lineNum">     880 </span>            : /* Print help for each plugin. The output goes to FILE and every line starts
<span class="lineNum">     881 </span>            :    with INDENT. */
<a name="882"><span class="lineNum">     882 </span>            : </a>
<span class="lineNum">     883 </span>            : void
<span class="lineNum">     884 </span><span class="lineCov">          3 : print_plugins_help (FILE *file, const char *indent)</span>
<span class="lineNum">     885 </span>            : {
<span class="lineNum">     886 </span><span class="lineCov">          3 :   struct print_options opt;</span>
<span class="lineNum">     887 </span><span class="lineCov">          3 :   opt.file = file;</span>
<span class="lineNum">     888 </span><span class="lineCov">          3 :   opt.indent = indent;</span>
<span class="lineNum">     889 </span><span class="lineCov">          3 :   if (!plugin_name_args_tab || htab_elements (plugin_name_args_tab) == 0)</span>
<span class="lineNum">     890 </span><span class="lineCov">          3 :     return;</span>
<span class="lineNum">     891 </span>            : 
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :   fprintf (file, &quot;%sHelp for the loaded plugins:\n&quot;, indent);</span>
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :   htab_traverse_noresize (plugin_name_args_tab, print_help_one_plugin, &amp;opt);</span>
<span class="lineNum">     894 </span>            : }
<span class="lineNum">     895 </span>            : 
<span class="lineNum">     896 </span>            : 
<span class="lineNum">     897 </span>            : /* Return true if plugins have been loaded.  */
<a name="898"><span class="lineNum">     898 </span>            : </a>
<span class="lineNum">     899 </span>            : bool
<span class="lineNum">     900 </span><span class="lineNoCov">          0 : plugins_active_p (void)</span>
<span class="lineNum">     901 </span>            : {
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :   int event;</span>
<span class="lineNum">     903 </span>            : 
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :   for (event = PLUGIN_PASS_MANAGER_SETUP; event &lt; event_last; event++)</span>
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :     if (plugin_callbacks[event])</span>
<span class="lineNum">     906 </span>            :       return true;
<span class="lineNum">     907 </span>            : 
<span class="lineNum">     908 </span>            :   return false;
<span class="lineNum">     909 </span>            : }
<span class="lineNum">     910 </span>            : 
<span class="lineNum">     911 </span>            : 
<span class="lineNum">     912 </span>            : /* Dump to FILE the names and associated events for all the active
<span class="lineNum">     913 </span>            :    plugins.  */
<a name="914"><span class="lineNum">     914 </span>            : </a>
<span class="lineNum">     915 </span>            : DEBUG_FUNCTION void
<span class="lineNum">     916 </span><span class="lineNoCov">          0 : dump_active_plugins (FILE *file)</span>
<span class="lineNum">     917 </span>            : {
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :   int event;</span>
<span class="lineNum">     919 </span>            : 
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :   if (!plugins_active_p ())</span>
<span class="lineNum">     921 </span>            :     return;
<span class="lineNum">     922 </span>            : 
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :   fprintf (file, FMT_FOR_PLUGIN_EVENT &quot; | %s\n&quot;, _(&quot;Event&quot;), _(&quot;Plugins&quot;));</span>
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :   for (event = PLUGIN_PASS_MANAGER_SETUP; event &lt; event_last; event++)</span>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :     if (plugin_callbacks[event])</span>
<span class="lineNum">     926 </span>            :       {
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :         struct callback_info *ci;</span>
<span class="lineNum">     928 </span>            : 
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :         fprintf (file, FMT_FOR_PLUGIN_EVENT &quot; |&quot;, plugin_event_name[event]);</span>
<span class="lineNum">     930 </span>            : 
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :         for (ci = plugin_callbacks[event]; ci; ci = ci-&gt;next)</span>
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :           fprintf (file, &quot; %s&quot;, ci-&gt;plugin_name);</span>
<span class="lineNum">     933 </span>            : 
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :         putc ('\n', file);</span>
<span class="lineNum">     935 </span>            :       }
<span class="lineNum">     936 </span>            : }
<span class="lineNum">     937 </span>            : 
<span class="lineNum">     938 </span>            : 
<span class="lineNum">     939 </span>            : /* Dump active plugins to stderr.  */
<a name="940"><span class="lineNum">     940 </span>            : </a>
<span class="lineNum">     941 </span>            : DEBUG_FUNCTION void
<span class="lineNum">     942 </span><span class="lineNoCov">          0 : debug_active_plugins (void)</span>
<span class="lineNum">     943 </span>            : {
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :   dump_active_plugins (stderr);</span>
<span class="lineNum">     945 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     946 </span>            : 
<span class="lineNum">     947 </span>            : /* Give a warning if plugins are present, before an ICE message asking
<span class="lineNum">     948 </span>            :    to submit a bug report.  */
<a name="949"><span class="lineNum">     949 </span>            : </a>
<span class="lineNum">     950 </span>            : void
<span class="lineNum">     951 </span><span class="lineNoCov">          0 : warn_if_plugins (void)</span>
<span class="lineNum">     952 </span>            : {
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :   if (plugins_active_p ())</span>
<span class="lineNum">     954 </span>            :     {
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :       fnotice (stderr, &quot;*** WARNING *** there are active plugins, do not report&quot;</span>
<span class="lineNum">     956 </span>            :                &quot; this as a bug unless you can reproduce it without enabling&quot;
<span class="lineNum">     957 </span>            :                &quot; any plugins.\n&quot;);
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :       dump_active_plugins (stderr);</span>
<span class="lineNum">     959 </span>            :     }
<span class="lineNum">     960 </span>            : 
<span class="lineNum">     961 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     962 </span>            : 
<span class="lineNum">     963 </span>            : /* The default version check. Compares every field in VERSION. */
<a name="964"><span class="lineNum">     964 </span>            : </a>
<span class="lineNum">     965 </span>            : bool
<span class="lineNum">     966 </span><span class="lineCov">         31 : plugin_default_version_check (struct plugin_gcc_version *gcc_version,</span>
<span class="lineNum">     967 </span>            :                               struct plugin_gcc_version *plugin_version)
<span class="lineNum">     968 </span>            : {
<span class="lineNum">     969 </span><span class="lineCov">         31 :   if (!gcc_version || !plugin_version)</span>
<span class="lineNum">     970 </span>            :     return false;
<span class="lineNum">     971 </span>            : 
<span class="lineNum">     972 </span><span class="lineCov">         31 :   if (strcmp (gcc_version-&gt;basever, plugin_version-&gt;basever))</span>
<span class="lineNum">     973 </span>            :     return false;
<span class="lineNum">     974 </span><span class="lineCov">         31 :   if (strcmp (gcc_version-&gt;datestamp, plugin_version-&gt;datestamp))</span>
<span class="lineNum">     975 </span>            :     return false;
<span class="lineNum">     976 </span><span class="lineCov">         31 :   if (strcmp (gcc_version-&gt;devphase, plugin_version-&gt;devphase))</span>
<span class="lineNum">     977 </span>            :     return false;
<span class="lineNum">     978 </span><span class="lineCov">         31 :   if (strcmp (gcc_version-&gt;revision, plugin_version-&gt;revision))</span>
<span class="lineNum">     979 </span>            :     return false;
<span class="lineNum">     980 </span><span class="lineCov">         31 :   if (strcmp (gcc_version-&gt;configuration_arguments,</span>
<span class="lineNum">     981 </span>            :               plugin_version-&gt;configuration_arguments))
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     983 </span>            :   return true;
<span class="lineNum">     984 </span>            : }
<span class="lineNum">     985 </span>            : 
<span class="lineNum">     986 </span>            : 
<span class="lineNum">     987 </span>            : /* Return the current value of event_last, so that plugins which provide
<span class="lineNum">     988 </span>            :    additional functionality for events for the benefit of high-level plugins
<span class="lineNum">     989 </span>            :    know how many valid entries plugin_event_name holds.  */
<a name="990"><span class="lineNum">     990 </span>            : </a>
<span class="lineNum">     991 </span>            : int
<span class="lineNum">     992 </span><span class="lineNoCov">          0 : get_event_last (void)</span>
<span class="lineNum">     993 </span>            : {
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :   return event_last;</span>
<span class="lineNum">     995 </span>            : }
<span class="lineNum">     996 </span>            : 
<span class="lineNum">     997 </span>            : 
<span class="lineNum">     998 </span>            : /* Retrieve the default plugin directory.  The gcc driver should have passed
<span class="lineNum">     999 </span>            :    it as -iplugindir &lt;dir&gt; to the cc1 program, and it is queriable through the
<a name="1000"><span class="lineNum">    1000 </span>            :    -print-file-name=plugin option to gcc.  */</a>
<span class="lineNum">    1001 </span>            : const char*
<span class="lineNum">    1002 </span><span class="lineCov">          4 : default_plugin_dir_name (void)</span>
<span class="lineNum">    1003 </span>            : {
<span class="lineNum">    1004 </span><span class="lineCov">          4 :   if (!plugindir_string)</span>
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :     fatal_error (input_location,</span>
<span class="lineNum">    1006 </span>            :                  &quot;-iplugindir &lt;dir&gt; option not passed from the gcc driver&quot;);
<span class="lineNum">    1007 </span><span class="lineCov">          4 :   return plugindir_string;</span>
<span class="lineNum">    1008 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.0</a></td></tr>
  </table>
  <br>
<h3>LCOV profile is generated on x86_64 machine using following configure options: configure --disable-bootstrap --enable-coverage=opt --enable-languages=c,c++,fortran,go,jit,lto --enable-host-shared. GCC test suite is run with the built compiler.</h3></body></html>
