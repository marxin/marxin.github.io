<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - gcc.info - gcc/wide-int.h</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">gcc</a> - wide-int.h<span style="font-size: 80%;"> (source / <a href="wide-int.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">gcc.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">3609</td>
            <td class="headerCovTableEntry">3956</td>
            <td class="headerCovTableEntryHi">91.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-09-22 10:58:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">454</td>
            <td class="headerCovTableEntry">733</td>
            <td class="headerCovTableEntryLo">61.9 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Operations with very long integers.  -*- C++ -*-</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 2012-2018 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            : This file is part of GCC.
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : GCC is free software; you can redistribute it and/or modify it
<span class="lineNum">       7 </span>            : under the terms of the GNU General Public License as published by the
<span class="lineNum">       8 </span>            : Free Software Foundation; either version 3, or (at your option) any
<span class="lineNum">       9 </span>            : later version.
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : GCC is distributed in the hope that it will be useful, but WITHOUT
<span class="lineNum">      12 </span>            : ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
<span class="lineNum">      13 </span>            : FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
<span class="lineNum">      14 </span>            : for more details.
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : You should have received a copy of the GNU General Public License
<span class="lineNum">      17 </span>            : along with GCC; see the file COPYING3.  If not see
<span class="lineNum">      18 </span>            : &lt;http://www.gnu.org/licenses/&gt;.  */
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : #ifndef WIDE_INT_H
<span class="lineNum">      21 </span>            : #define WIDE_INT_H
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            : /* wide-int.[cc|h] implements a class that efficiently performs
<span class="lineNum">      24 </span>            :    mathematical operations on finite precision integers.  wide_ints
<span class="lineNum">      25 </span>            :    are designed to be transient - they are not for long term storage
<span class="lineNum">      26 </span>            :    of values.  There is tight integration between wide_ints and the
<span class="lineNum">      27 </span>            :    other longer storage GCC representations (rtl and tree).
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            :    The actual precision of a wide_int depends on the flavor.  There
<span class="lineNum">      30 </span>            :    are three predefined flavors:
<span class="lineNum">      31 </span>            : 
<span class="lineNum">      32 </span>            :      1) wide_int (the default).  This flavor does the math in the
<span class="lineNum">      33 </span>            :      precision of its input arguments.  It is assumed (and checked)
<span class="lineNum">      34 </span>            :      that the precisions of the operands and results are consistent.
<span class="lineNum">      35 </span>            :      This is the most efficient flavor.  It is not possible to examine
<span class="lineNum">      36 </span>            :      bits above the precision that has been specified.  Because of
<span class="lineNum">      37 </span>            :      this, the default flavor has semantics that are simple to
<span class="lineNum">      38 </span>            :      understand and in general model the underlying hardware that the
<span class="lineNum">      39 </span>            :      compiler is targetted for.
<span class="lineNum">      40 </span>            : 
<span class="lineNum">      41 </span>            :      This flavor must be used at the RTL level of gcc because there
<span class="lineNum">      42 </span>            :      is, in general, not enough information in the RTL representation
<span class="lineNum">      43 </span>            :      to extend a value beyond the precision specified in the mode.
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            :      This flavor should also be used at the TREE and GIMPLE levels of
<span class="lineNum">      46 </span>            :      the compiler except for the circumstances described in the
<span class="lineNum">      47 </span>            :      descriptions of the other two flavors.
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            :      The default wide_int representation does not contain any
<span class="lineNum">      50 </span>            :      information inherent about signedness of the represented value,
<span class="lineNum">      51 </span>            :      so it can be used to represent both signed and unsigned numbers.
<span class="lineNum">      52 </span>            :      For operations where the results depend on signedness (full width
<span class="lineNum">      53 </span>            :      multiply, division, shifts, comparisons, and operations that need
<span class="lineNum">      54 </span>            :      overflow detected), the signedness must be specified separately.
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            :      2) offset_int.  This is a fixed-precision integer that can hold
<span class="lineNum">      57 </span>            :      any address offset, measured in either bits or bytes, with at
<span class="lineNum">      58 </span>            :      least one extra sign bit.  At the moment the maximum address
<span class="lineNum">      59 </span>            :      size GCC supports is 64 bits.  With 8-bit bytes and an extra
<span class="lineNum">      60 </span>            :      sign bit, offset_int therefore needs to have at least 68 bits
<span class="lineNum">      61 </span>            :      of precision.  We round this up to 128 bits for efficiency.
<span class="lineNum">      62 </span>            :      Values of type T are converted to this precision by sign- or
<span class="lineNum">      63 </span>            :      zero-extending them based on the signedness of T.
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span>            :      The extra sign bit means that offset_int is effectively a signed
<span class="lineNum">      66 </span>            :      128-bit integer, i.e. it behaves like int128_t.
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span>            :      Since the values are logically signed, there is no need to
<span class="lineNum">      69 </span>            :      distinguish between signed and unsigned operations.  Sign-sensitive
<span class="lineNum">      70 </span>            :      comparison operators &lt;, &lt;=, &gt; and &gt;= are therefore supported.
<span class="lineNum">      71 </span>            :      Shift operators &lt;&lt; and &gt;&gt; are also supported, with &gt;&gt; being
<span class="lineNum">      72 </span>            :      an _arithmetic_ right shift.
<span class="lineNum">      73 </span>            : 
<span class="lineNum">      74 </span>            :      [ Note that, even though offset_int is effectively int128_t,
<span class="lineNum">      75 </span>            :        it can still be useful to use unsigned comparisons like
<span class="lineNum">      76 </span>            :        wi::leu_p (a, b) as a more efficient short-hand for
<span class="lineNum">      77 </span>            :        &quot;a &gt;= 0 &amp;&amp; a &lt;= b&quot;. ]
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span>            :      3) widest_int.  This representation is an approximation of
<span class="lineNum">      80 </span>            :      infinite precision math.  However, it is not really infinite
<span class="lineNum">      81 </span>            :      precision math as in the GMP library.  It is really finite
<span class="lineNum">      82 </span>            :      precision math where the precision is 4 times the size of the
<span class="lineNum">      83 </span>            :      largest integer that the target port can represent.
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span>            :      Like offset_int, widest_int is wider than all the values that
<span class="lineNum">      86 </span>            :      it needs to represent, so the integers are logically signed.
<span class="lineNum">      87 </span>            :      Sign-sensitive comparison operators &lt;, &lt;=, &gt; and &gt;= are supported,
<span class="lineNum">      88 </span>            :      as are &lt;&lt; and &gt;&gt;.
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span>            :      There are several places in the GCC where this should/must be used:
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span>            :      * Code that does induction variable optimizations.  This code
<span class="lineNum">      93 </span>            :        works with induction variables of many different types at the
<span class="lineNum">      94 </span>            :        same time.  Because of this, it ends up doing many different
<span class="lineNum">      95 </span>            :        calculations where the operands are not compatible types.  The
<span class="lineNum">      96 </span>            :        widest_int makes this easy, because it provides a field where
<span class="lineNum">      97 </span>            :        nothing is lost when converting from any variable,
<span class="lineNum">      98 </span>            : 
<span class="lineNum">      99 </span>            :      * There are a small number of passes that currently use the
<span class="lineNum">     100 </span>            :        widest_int that should use the default.  These should be
<span class="lineNum">     101 </span>            :        changed.
<span class="lineNum">     102 </span>            : 
<span class="lineNum">     103 </span>            :    There are surprising features of offset_int and widest_int
<span class="lineNum">     104 </span>            :    that the users should be careful about:
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span>            :      1) Shifts and rotations are just weird.  You have to specify a
<span class="lineNum">     107 </span>            :      precision in which the shift or rotate is to happen in.  The bits
<span class="lineNum">     108 </span>            :      above this precision are zeroed.  While this is what you
<span class="lineNum">     109 </span>            :      want, it is clearly non obvious.
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span>            :      2) Larger precision math sometimes does not produce the same
<span class="lineNum">     112 </span>            :      answer as would be expected for doing the math at the proper
<span class="lineNum">     113 </span>            :      precision.  In particular, a multiply followed by a divide will
<span class="lineNum">     114 </span>            :      produce a different answer if the first product is larger than
<span class="lineNum">     115 </span>            :      what can be represented in the input precision.
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span>            :    The offset_int and the widest_int flavors are more expensive
<span class="lineNum">     118 </span>            :    than the default wide int, so in addition to the caveats with these
<span class="lineNum">     119 </span>            :    two, the default is the prefered representation.
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span>            :    All three flavors of wide_int are represented as a vector of
<span class="lineNum">     122 </span>            :    HOST_WIDE_INTs.  The default and widest_int vectors contain enough elements
<span class="lineNum">     123 </span>            :    to hold a value of MAX_BITSIZE_MODE_ANY_INT bits.  offset_int contains only
<span class="lineNum">     124 </span>            :    enough elements to hold ADDR_MAX_PRECISION bits.  The values are stored
<span class="lineNum">     125 </span>            :    in the vector with the least significant HOST_BITS_PER_WIDE_INT bits
<span class="lineNum">     126 </span>            :    in element 0.
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span>            :    The default wide_int contains three fields: the vector (VAL),
<span class="lineNum">     129 </span>            :    the precision and a length (LEN).  The length is the number of HWIs
<span class="lineNum">     130 </span>            :    needed to represent the value.  widest_int and offset_int have a
<span class="lineNum">     131 </span>            :    constant precision that cannot be changed, so they only store the
<span class="lineNum">     132 </span>            :    VAL and LEN fields.
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span>            :    Since most integers used in a compiler are small values, it is
<span class="lineNum">     135 </span>            :    generally profitable to use a representation of the value that is
<span class="lineNum">     136 </span>            :    as small as possible.  LEN is used to indicate the number of
<span class="lineNum">     137 </span>            :    elements of the vector that are in use.  The numbers are stored as
<span class="lineNum">     138 </span>            :    sign extended numbers as a means of compression.  Leading
<span class="lineNum">     139 </span>            :    HOST_WIDE_INTs that contain strings of either -1 or 0 are removed
<span class="lineNum">     140 </span>            :    as long as they can be reconstructed from the top bit that is being
<span class="lineNum">     141 </span>            :    represented.
<span class="lineNum">     142 </span>            : 
<span class="lineNum">     143 </span>            :    The precision and length of a wide_int are always greater than 0.
<span class="lineNum">     144 </span>            :    Any bits in a wide_int above the precision are sign-extended from the
<span class="lineNum">     145 </span>            :    most significant bit.  For example, a 4-bit value 0x8 is represented as
<span class="lineNum">     146 </span>            :    VAL = { 0xf...fff8 }.  However, as an optimization, we allow other integer
<span class="lineNum">     147 </span>            :    constants to be represented with undefined bits above the precision.
<span class="lineNum">     148 </span>            :    This allows INTEGER_CSTs to be pre-extended according to TYPE_SIGN,
<span class="lineNum">     149 </span>            :    so that the INTEGER_CST representation can be used both in TYPE_PRECISION
<span class="lineNum">     150 </span>            :    and in wider precisions.
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span>            :    There are constructors to create the various forms of wide_int from
<span class="lineNum">     153 </span>            :    trees, rtl and constants.  For trees the options are:
<span class="lineNum">     154 </span>            : 
<span class="lineNum">     155 </span>            :              tree t = ...;
<span class="lineNum">     156 </span>            :              wi::to_wide (t)     // Treat T as a wide_int
<span class="lineNum">     157 </span>            :              wi::to_offset (t)   // Treat T as an offset_int
<span class="lineNum">     158 </span>            :              wi::to_widest (t)   // Treat T as a widest_int
<span class="lineNum">     159 </span>            : 
<span class="lineNum">     160 </span>            :    All three are light-weight accessors that should have no overhead
<span class="lineNum">     161 </span>            :    in release builds.  If it is useful for readability reasons to
<span class="lineNum">     162 </span>            :    store the result in a temporary variable, the preferred method is:
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            :              wi::tree_to_wide_ref twide = wi::to_wide (t);
<span class="lineNum">     165 </span>            :              wi::tree_to_offset_ref toffset = wi::to_offset (t);
<span class="lineNum">     166 </span>            :              wi::tree_to_widest_ref twidest = wi::to_widest (t);
<span class="lineNum">     167 </span>            : 
<span class="lineNum">     168 </span>            :    To make an rtx into a wide_int, you have to pair it with a mode.
<span class="lineNum">     169 </span>            :    The canonical way to do this is with rtx_mode_t as in:
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span>            :              rtx r = ...
<span class="lineNum">     172 </span>            :              wide_int x = rtx_mode_t (r, mode);
<span class="lineNum">     173 </span>            : 
<span class="lineNum">     174 </span>            :    Similarly, a wide_int can only be constructed from a host value if
<span class="lineNum">     175 </span>            :    the target precision is given explicitly, such as in:
<span class="lineNum">     176 </span>            : 
<span class="lineNum">     177 </span>            :              wide_int x = wi::shwi (c, prec); // sign-extend C if necessary
<span class="lineNum">     178 </span>            :              wide_int y = wi::uhwi (c, prec); // zero-extend C if necessary
<span class="lineNum">     179 </span>            : 
<span class="lineNum">     180 </span>            :    However, offset_int and widest_int have an inherent precision and so
<span class="lineNum">     181 </span>            :    can be initialized directly from a host value:
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span>            :              offset_int x = (int) c;          // sign-extend C
<span class="lineNum">     184 </span>            :              widest_int x = (unsigned int) c; // zero-extend C
<span class="lineNum">     185 </span>            : 
<span class="lineNum">     186 </span>            :    It is also possible to do arithmetic directly on rtx_mode_ts and
<span class="lineNum">     187 </span>            :    constants.  For example:
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span>            :              wi::add (r1, r2);    // add equal-sized rtx_mode_ts r1 and r2
<span class="lineNum">     190 </span>            :              wi::add (r1, 1);     // add 1 to rtx_mode_t r1
<span class="lineNum">     191 </span>            :              wi::lshift (1, 100); // 1 &lt;&lt; 100 as a widest_int
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            :    Many binary operations place restrictions on the combinations of inputs,
<span class="lineNum">     194 </span>            :    using the following rules:
<span class="lineNum">     195 </span>            : 
<span class="lineNum">     196 </span>            :    - {rtx, wide_int} op {rtx, wide_int} -&gt; wide_int
<span class="lineNum">     197 </span>            :        The inputs must be the same precision.  The result is a wide_int
<span class="lineNum">     198 </span>            :        of the same precision
<span class="lineNum">     199 </span>            : 
<span class="lineNum">     200 </span>            :    - {rtx, wide_int} op (un)signed HOST_WIDE_INT -&gt; wide_int
<span class="lineNum">     201 </span>            :      (un)signed HOST_WIDE_INT op {rtx, wide_int} -&gt; wide_int
<span class="lineNum">     202 </span>            :        The HOST_WIDE_INT is extended or truncated to the precision of
<span class="lineNum">     203 </span>            :        the other input.  The result is a wide_int of the same precision
<span class="lineNum">     204 </span>            :        as that input.
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span>            :    - (un)signed HOST_WIDE_INT op (un)signed HOST_WIDE_INT -&gt; widest_int
<span class="lineNum">     207 </span>            :        The inputs are extended to widest_int precision and produce a
<span class="lineNum">     208 </span>            :        widest_int result.
<span class="lineNum">     209 </span>            : 
<span class="lineNum">     210 </span>            :    - offset_int op offset_int -&gt; offset_int
<span class="lineNum">     211 </span>            :      offset_int op (un)signed HOST_WIDE_INT -&gt; offset_int
<span class="lineNum">     212 </span>            :      (un)signed HOST_WIDE_INT op offset_int -&gt; offset_int
<span class="lineNum">     213 </span>            : 
<span class="lineNum">     214 </span>            :    - widest_int op widest_int -&gt; widest_int
<span class="lineNum">     215 </span>            :      widest_int op (un)signed HOST_WIDE_INT -&gt; widest_int
<span class="lineNum">     216 </span>            :      (un)signed HOST_WIDE_INT op widest_int -&gt; widest_int
<span class="lineNum">     217 </span>            : 
<span class="lineNum">     218 </span>            :    Other combinations like:
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span>            :    - widest_int op offset_int and
<span class="lineNum">     221 </span>            :    - wide_int op offset_int
<span class="lineNum">     222 </span>            : 
<span class="lineNum">     223 </span>            :    are not allowed.  The inputs should instead be extended or truncated
<span class="lineNum">     224 </span>            :    so that they match.
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span>            :    The inputs to comparison functions like wi::eq_p and wi::lts_p
<span class="lineNum">     227 </span>            :    follow the same compatibility rules, although their return types
<span class="lineNum">     228 </span>            :    are different.  Unary functions on X produce the same result as
<span class="lineNum">     229 </span>            :    a binary operation X + X.  Shift functions X op Y also produce
<span class="lineNum">     230 </span>            :    the same result as X + X; the precision of the shift amount Y
<span class="lineNum">     231 </span>            :    can be arbitrarily different from X.  */
<span class="lineNum">     232 </span>            : 
<span class="lineNum">     233 </span>            : /* The MAX_BITSIZE_MODE_ANY_INT is automatically generated by a very
<span class="lineNum">     234 </span>            :    early examination of the target's mode file.  The WIDE_INT_MAX_ELTS
<span class="lineNum">     235 </span>            :    can accomodate at least 1 more bit so that unsigned numbers of that
<span class="lineNum">     236 </span>            :    mode can be represented as a signed value.  Note that it is still
<span class="lineNum">     237 </span>            :    possible to create fixed_wide_ints that have precisions greater than
<span class="lineNum">     238 </span>            :    MAX_BITSIZE_MODE_ANY_INT.  This can be useful when representing a
<span class="lineNum">     239 </span>            :    double-width multiplication result, for example.  */
<span class="lineNum">     240 </span>            : #define WIDE_INT_MAX_ELTS \
<span class="lineNum">     241 </span>            :   ((MAX_BITSIZE_MODE_ANY_INT + HOST_BITS_PER_WIDE_INT) / HOST_BITS_PER_WIDE_INT)
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span>            : #define WIDE_INT_MAX_PRECISION (WIDE_INT_MAX_ELTS * HOST_BITS_PER_WIDE_INT)
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span>            : /* This is the max size of any pointer on any machine.  It does not
<span class="lineNum">     246 </span>            :    seem to be as easy to sniff this out of the machine description as
<span class="lineNum">     247 </span>            :    it is for MAX_BITSIZE_MODE_ANY_INT since targets may support
<span class="lineNum">     248 </span>            :    multiple address sizes and may have different address sizes for
<span class="lineNum">     249 </span>            :    different address spaces.  However, currently the largest pointer
<span class="lineNum">     250 </span>            :    on any platform is 64 bits.  When that changes, then it is likely
<span class="lineNum">     251 </span>            :    that a target hook should be defined so that targets can make this
<span class="lineNum">     252 </span>            :    value larger for those targets.  */
<span class="lineNum">     253 </span>            : #define ADDR_MAX_BITSIZE 64
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span>            : /* This is the internal precision used when doing any address
<span class="lineNum">     256 </span>            :    arithmetic.  The '4' is really 3 + 1.  Three of the bits are for
<span class="lineNum">     257 </span>            :    the number of extra bits needed to do bit addresses and the other bit
<span class="lineNum">     258 </span>            :    is to allow everything to be signed without loosing any precision.
<span class="lineNum">     259 </span>            :    Then everything is rounded up to the next HWI for efficiency.  */
<span class="lineNum">     260 </span>            : #define ADDR_MAX_PRECISION \
<span class="lineNum">     261 </span>            :   ((ADDR_MAX_BITSIZE + 4 + HOST_BITS_PER_WIDE_INT - 1) \
<span class="lineNum">     262 </span>            :    &amp; ~(HOST_BITS_PER_WIDE_INT - 1))
<span class="lineNum">     263 </span>            : 
<span class="lineNum">     264 </span>            : /* The number of HWIs needed to store an offset_int.  */
<span class="lineNum">     265 </span>            : #define OFFSET_INT_ELTS (ADDR_MAX_PRECISION / HOST_BITS_PER_WIDE_INT)
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span>            : /* The type of result produced by a binary operation on types T1 and T2.
<span class="lineNum">     268 </span>            :    Defined purely for brevity.  */
<span class="lineNum">     269 </span>            : #define WI_BINARY_RESULT(T1, T2) \
<span class="lineNum">     270 </span>            :   typename wi::binary_traits &lt;T1, T2&gt;::result_type
<span class="lineNum">     271 </span>            : 
<span class="lineNum">     272 </span>            : /* Likewise for binary operators, which excludes the case in which neither
<span class="lineNum">     273 </span>            :    T1 nor T2 is a wide-int-based type.  */
<span class="lineNum">     274 </span>            : #define WI_BINARY_OPERATOR_RESULT(T1, T2) \
<span class="lineNum">     275 </span>            :   typename wi::binary_traits &lt;T1, T2&gt;::operator_result
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span>            : /* The type of result produced by T1 &lt;&lt; T2.  Leads to substitution failure
<span class="lineNum">     278 </span>            :    if the operation isn't supported.  Defined purely for brevity.  */
<span class="lineNum">     279 </span>            : #define WI_SIGNED_SHIFT_RESULT(T1, T2) \
<span class="lineNum">     280 </span>            :   typename wi::binary_traits &lt;T1, T2&gt;::signed_shift_result_type
<span class="lineNum">     281 </span>            : 
<span class="lineNum">     282 </span>            : /* The type of result produced by a sign-agnostic binary predicate on
<span class="lineNum">     283 </span>            :    types T1 and T2.  This is bool if wide-int operations make sense for
<span class="lineNum">     284 </span>            :    T1 and T2 and leads to substitution failure otherwise.  */
<span class="lineNum">     285 </span>            : #define WI_BINARY_PREDICATE_RESULT(T1, T2) \
<span class="lineNum">     286 </span>            :   typename wi::binary_traits &lt;T1, T2&gt;::predicate_result
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span>            : /* The type of result produced by a signed binary predicate on types T1 and T2.
<span class="lineNum">     289 </span>            :    This is bool if signed comparisons make sense for T1 and T2 and leads to
<span class="lineNum">     290 </span>            :    substitution failure otherwise.  */
<span class="lineNum">     291 </span>            : #define WI_SIGNED_BINARY_PREDICATE_RESULT(T1, T2) \
<span class="lineNum">     292 </span>            :   typename wi::binary_traits &lt;T1, T2&gt;::signed_predicate_result
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span>            : /* The type of result produced by a unary operation on type T.  */
<span class="lineNum">     295 </span>            : #define WI_UNARY_RESULT(T) \
<span class="lineNum">     296 </span>            :   typename wi::binary_traits &lt;T, T&gt;::result_type
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span>            : /* Define a variable RESULT to hold the result of a binary operation on
<span class="lineNum">     299 </span>            :    X and Y, which have types T1 and T2 respectively.  Define VAL to
<span class="lineNum">     300 </span>            :    point to the blocks of RESULT.  Once the user of the macro has
<span class="lineNum">     301 </span>            :    filled in VAL, it should call RESULT.set_len to set the number
<span class="lineNum">     302 </span>            :    of initialized blocks.  */
<span class="lineNum">     303 </span>            : #define WI_BINARY_RESULT_VAR(RESULT, VAL, T1, X, T2, Y) \
<span class="lineNum">     304 </span>            :   WI_BINARY_RESULT (T1, T2) RESULT = \
<span class="lineNum">     305 </span>            :     wi::int_traits &lt;WI_BINARY_RESULT (T1, T2)&gt;::get_binary_result (X, Y); \
<span class="lineNum">     306 </span>            :   HOST_WIDE_INT *VAL = RESULT.write_val ()
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span>            : /* Similar for the result of a unary operation on X, which has type T.  */
<span class="lineNum">     309 </span>            : #define WI_UNARY_RESULT_VAR(RESULT, VAL, T, X) \
<span class="lineNum">     310 </span>            :   WI_UNARY_RESULT (T) RESULT = \
<span class="lineNum">     311 </span>            :     wi::int_traits &lt;WI_UNARY_RESULT (T)&gt;::get_binary_result (X, X); \
<span class="lineNum">     312 </span>            :   HOST_WIDE_INT *VAL = RESULT.write_val ()
<span class="lineNum">     313 </span>            : 
<span class="lineNum">     314 </span>            : template &lt;typename T&gt; class generic_wide_int;
<span class="lineNum">     315 </span>            : template &lt;int N&gt; class fixed_wide_int_storage;
<span class="lineNum">     316 </span>            : class wide_int_storage;
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span>            : /* An N-bit integer.  Until we can use typedef templates, use this instead.  */
<span class="lineNum">     319 </span>            : #define FIXED_WIDE_INT(N) \
<span class="lineNum">     320 </span>            :   generic_wide_int &lt; fixed_wide_int_storage &lt;N&gt; &gt;
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span>            : typedef generic_wide_int &lt;wide_int_storage&gt; wide_int;
<span class="lineNum">     323 </span>            : typedef FIXED_WIDE_INT (ADDR_MAX_PRECISION) offset_int;
<span class="lineNum">     324 </span>            : typedef FIXED_WIDE_INT (WIDE_INT_MAX_PRECISION) widest_int;
<span class="lineNum">     325 </span>            : /* Spelled out explicitly (rather than through FIXED_WIDE_INT)
<span class="lineNum">     326 </span>            :    so as not to confuse gengtype.  */
<span class="lineNum">     327 </span>            : typedef generic_wide_int &lt; fixed_wide_int_storage &lt;WIDE_INT_MAX_PRECISION * 2&gt; &gt; widest2_int;
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span>            : /* wi::storage_ref can be a reference to a primitive type,
<span class="lineNum">     330 </span>            :    so this is the conservatively-correct setting.  */
<span class="lineNum">     331 </span>            : template &lt;bool SE, bool HDP = true&gt;
<span class="lineNum">     332 </span>            : struct wide_int_ref_storage;
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span>            : typedef generic_wide_int &lt;wide_int_ref_storage &lt;false&gt; &gt; wide_int_ref;
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span>            : /* This can be used instead of wide_int_ref if the referenced value is
<span class="lineNum">     337 </span>            :    known to have type T.  It carries across properties of T's representation,
<span class="lineNum">     338 </span>            :    such as whether excess upper bits in a HWI are defined, and can therefore
<span class="lineNum">     339 </span>            :    help avoid redundant work.
<span class="lineNum">     340 </span>            : 
<span class="lineNum">     341 </span>            :    The macro could be replaced with a template typedef, once we're able
<span class="lineNum">     342 </span>            :    to use those.  */
<span class="lineNum">     343 </span>            : #define WIDE_INT_REF_FOR(T) \
<span class="lineNum">     344 </span>            :   generic_wide_int \
<span class="lineNum">     345 </span>            :     &lt;wide_int_ref_storage &lt;wi::int_traits &lt;T&gt;::is_sign_extended, \
<span class="lineNum">     346 </span>            :                            wi::int_traits &lt;T&gt;::host_dependent_precision&gt; &gt;
<span class="lineNum">     347 </span>            : 
<span class="lineNum">     348 </span>            : namespace wi
<span class="lineNum">     349 </span>            : {
<span class="lineNum">     350 </span>            :   /* Operations that calculate overflow do so even for
<span class="lineNum">     351 </span>            :      TYPE_OVERFLOW_WRAPS types.  For example, adding 1 to +MAX_INT in
<span class="lineNum">     352 </span>            :      an unsigned int is 0 and does not overflow in C/C++, but wi::add
<span class="lineNum">     353 </span>            :      will set the overflow argument in case it's needed for further
<span class="lineNum">     354 </span>            :      analysis.
<span class="lineNum">     355 </span>            : 
<span class="lineNum">     356 </span>            :      For operations that require overflow, these are the different
<span class="lineNum">     357 </span>            :      types of overflow.  */
<span class="lineNum">     358 </span>            :   enum overflow_type {
<span class="lineNum">     359 </span>            :     OVF_NONE = 0,
<span class="lineNum">     360 </span>            :     OVF_UNDERFLOW = -1,
<span class="lineNum">     361 </span>            :     OVF_OVERFLOW = 1,
<span class="lineNum">     362 </span>            :     /* There was an overflow, but we are unsure whether it was an
<span class="lineNum">     363 </span>            :        overflow or an underflow.  */
<span class="lineNum">     364 </span>            :     OVF_UNKNOWN = 2
<span class="lineNum">     365 </span>            :   };
<span class="lineNum">     366 </span>            : 
<span class="lineNum">     367 </span>            :   /* Classifies an integer based on its precision.  */
<span class="lineNum">     368 </span>            :   enum precision_type {
<span class="lineNum">     369 </span>            :     /* The integer has both a precision and defined signedness.  This allows
<span class="lineNum">     370 </span>            :        the integer to be converted to any width, since we know whether to fill
<span class="lineNum">     371 </span>            :        any extra bits with zeros or signs.  */
<span class="lineNum">     372 </span>            :     FLEXIBLE_PRECISION,
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span>            :     /* The integer has a variable precision but no defined signedness.  */
<span class="lineNum">     375 </span>            :     VAR_PRECISION,
<span class="lineNum">     376 </span>            : 
<span class="lineNum">     377 </span>            :     /* The integer has a constant precision (known at GCC compile time)
<span class="lineNum">     378 </span>            :        and is signed.  */
<span class="lineNum">     379 </span>            :     CONST_PRECISION
<span class="lineNum">     380 </span>            :   };
<span class="lineNum">     381 </span>            : 
<span class="lineNum">     382 </span>            :   /* This class, which has no default implementation, is expected to
<span class="lineNum">     383 </span>            :      provide the following members:
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span>            :      static const enum precision_type precision_type;
<span class="lineNum">     386 </span>            :        Classifies the type of T.
<span class="lineNum">     387 </span>            : 
<span class="lineNum">     388 </span>            :      static const unsigned int precision;
<span class="lineNum">     389 </span>            :        Only defined if precision_type == CONST_PRECISION.  Specifies the
<span class="lineNum">     390 </span>            :        precision of all integers of type T.
<span class="lineNum">     391 </span>            : 
<span class="lineNum">     392 </span>            :      static const bool host_dependent_precision;
<span class="lineNum">     393 </span>            :        True if the precision of T depends (or can depend) on the host.
<span class="lineNum">     394 </span>            : 
<span class="lineNum">     395 </span>            :      static unsigned int get_precision (const T &amp;x)
<span class="lineNum">     396 </span>            :        Return the number of bits in X.
<span class="lineNum">     397 </span>            : 
<span class="lineNum">     398 </span>            :      static wi::storage_ref *decompose (HOST_WIDE_INT *scratch,
<span class="lineNum">     399 </span>            :                                         unsigned int precision, const T &amp;x)
<span class="lineNum">     400 </span>            :        Decompose X as a PRECISION-bit integer, returning the associated
<span class="lineNum">     401 </span>            :        wi::storage_ref.  SCRATCH is available as scratch space if needed.
<span class="lineNum">     402 </span>            :        The routine should assert that PRECISION is acceptable.  */
<span class="lineNum">     403 </span>            :   template &lt;typename T&gt; struct int_traits;
<span class="lineNum">     404 </span>            : 
<span class="lineNum">     405 </span>            :   /* This class provides a single type, result_type, which specifies the
<span class="lineNum">     406 </span>            :      type of integer produced by a binary operation whose inputs have
<span class="lineNum">     407 </span>            :      types T1 and T2.  The definition should be symmetric.  */
<span class="lineNum">     408 </span>            :   template &lt;typename T1, typename T2,
<span class="lineNum">     409 </span>            :             enum precision_type P1 = int_traits &lt;T1&gt;::precision_type,
<span class="lineNum">     410 </span>            :             enum precision_type P2 = int_traits &lt;T2&gt;::precision_type&gt;
<span class="lineNum">     411 </span>            :   struct binary_traits;
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span>            :   /* Specify the result type for each supported combination of binary
<span class="lineNum">     414 </span>            :      inputs.  Note that CONST_PRECISION and VAR_PRECISION cannot be
<span class="lineNum">     415 </span>            :      mixed, in order to give stronger type checking.  When both inputs
<span class="lineNum">     416 </span>            :      are CONST_PRECISION, they must have the same precision.  */
<span class="lineNum">     417 </span>            :   template &lt;typename T1, typename T2&gt;
<span class="lineNum">     418 </span>            :   struct binary_traits &lt;T1, T2, FLEXIBLE_PRECISION, FLEXIBLE_PRECISION&gt;
<span class="lineNum">     419 </span>            :   {
<span class="lineNum">     420 </span>            :     typedef widest_int result_type;
<span class="lineNum">     421 </span>            :     /* Don't define operators for this combination.  */
<span class="lineNum">     422 </span>            :   };
<span class="lineNum">     423 </span>            : 
<span class="lineNum">     424 </span>            :   template &lt;typename T1, typename T2&gt;
<span class="lineNum">     425 </span>            :   struct binary_traits &lt;T1, T2, FLEXIBLE_PRECISION, VAR_PRECISION&gt;
<span class="lineNum">     426 </span>            :   {
<span class="lineNum">     427 </span>            :     typedef wide_int result_type;
<span class="lineNum">     428 </span>            :     typedef result_type operator_result;
<span class="lineNum">     429 </span>            :     typedef bool predicate_result;
<span class="lineNum">     430 </span>            :   };
<span class="lineNum">     431 </span>            : 
<span class="lineNum">     432 </span>            :   template &lt;typename T1, typename T2&gt;
<span class="lineNum">     433 </span>            :   struct binary_traits &lt;T1, T2, FLEXIBLE_PRECISION, CONST_PRECISION&gt;
<span class="lineNum">     434 </span>            :   {
<span class="lineNum">     435 </span>            :     /* Spelled out explicitly (rather than through FIXED_WIDE_INT)
<span class="lineNum">     436 </span>            :        so as not to confuse gengtype.  */
<span class="lineNum">     437 </span>            :     typedef generic_wide_int &lt; fixed_wide_int_storage
<span class="lineNum">     438 </span>            :                                &lt;int_traits &lt;T2&gt;::precision&gt; &gt; result_type;
<span class="lineNum">     439 </span>            :     typedef result_type operator_result;
<span class="lineNum">     440 </span>            :     typedef bool predicate_result;
<span class="lineNum">     441 </span>            :     typedef result_type signed_shift_result_type;
<span class="lineNum">     442 </span>            :     typedef bool signed_predicate_result;
<span class="lineNum">     443 </span>            :   };
<span class="lineNum">     444 </span>            : 
<span class="lineNum">     445 </span>            :   template &lt;typename T1, typename T2&gt;
<span class="lineNum">     446 </span>            :   struct binary_traits &lt;T1, T2, VAR_PRECISION, FLEXIBLE_PRECISION&gt;
<span class="lineNum">     447 </span>            :   {
<span class="lineNum">     448 </span>            :     typedef wide_int result_type;
<span class="lineNum">     449 </span>            :     typedef result_type operator_result;
<span class="lineNum">     450 </span>            :     typedef bool predicate_result;
<span class="lineNum">     451 </span>            :   };
<span class="lineNum">     452 </span>            : 
<span class="lineNum">     453 </span>            :   template &lt;typename T1, typename T2&gt;
<span class="lineNum">     454 </span>            :   struct binary_traits &lt;T1, T2, CONST_PRECISION, FLEXIBLE_PRECISION&gt;
<span class="lineNum">     455 </span>            :   {
<span class="lineNum">     456 </span>            :     /* Spelled out explicitly (rather than through FIXED_WIDE_INT)
<span class="lineNum">     457 </span>            :        so as not to confuse gengtype.  */
<span class="lineNum">     458 </span>            :     typedef generic_wide_int &lt; fixed_wide_int_storage
<span class="lineNum">     459 </span>            :                                &lt;int_traits &lt;T1&gt;::precision&gt; &gt; result_type;
<span class="lineNum">     460 </span>            :     typedef result_type operator_result;
<span class="lineNum">     461 </span>            :     typedef bool predicate_result;
<span class="lineNum">     462 </span>            :     typedef result_type signed_shift_result_type;
<span class="lineNum">     463 </span>            :     typedef bool signed_predicate_result;
<span class="lineNum">     464 </span>            :   };
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span>            :   template &lt;typename T1, typename T2&gt;
<span class="lineNum">     467 </span>            :   struct binary_traits &lt;T1, T2, CONST_PRECISION, CONST_PRECISION&gt;
<span class="lineNum">     468 </span>            :   {
<span class="lineNum">     469 </span>            :     STATIC_ASSERT (int_traits &lt;T1&gt;::precision == int_traits &lt;T2&gt;::precision);
<span class="lineNum">     470 </span>            :     /* Spelled out explicitly (rather than through FIXED_WIDE_INT)
<span class="lineNum">     471 </span>            :        so as not to confuse gengtype.  */
<span class="lineNum">     472 </span>            :     typedef generic_wide_int &lt; fixed_wide_int_storage
<span class="lineNum">     473 </span>            :                                &lt;int_traits &lt;T1&gt;::precision&gt; &gt; result_type;
<span class="lineNum">     474 </span>            :     typedef result_type operator_result;
<span class="lineNum">     475 </span>            :     typedef bool predicate_result;
<span class="lineNum">     476 </span>            :     typedef result_type signed_shift_result_type;
<span class="lineNum">     477 </span>            :     typedef bool signed_predicate_result;
<span class="lineNum">     478 </span>            :   };
<span class="lineNum">     479 </span>            : 
<span class="lineNum">     480 </span>            :   template &lt;typename T1, typename T2&gt;
<span class="lineNum">     481 </span>            :   struct binary_traits &lt;T1, T2, VAR_PRECISION, VAR_PRECISION&gt;
<span class="lineNum">     482 </span>            :   {
<span class="lineNum">     483 </span>            :     typedef wide_int result_type;
<span class="lineNum">     484 </span>            :     typedef result_type operator_result;
<span class="lineNum">     485 </span>            :     typedef bool predicate_result;
<span class="lineNum">     486 </span>            :   };
<span class="lineNum">     487 </span>            : }
<span class="lineNum">     488 </span>            : 
<span class="lineNum">     489 </span>            : /* Public functions for querying and operating on integers.  */
<span class="lineNum">     490 </span>            : namespace wi
<span class="lineNum">     491 </span>            : {
<span class="lineNum">     492 </span>            :   template &lt;typename T&gt;
<span class="lineNum">     493 </span>            :   unsigned int get_precision (const T &amp;);
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span>            :   template &lt;typename T1, typename T2&gt;
<span class="lineNum">     496 </span>            :   unsigned int get_binary_precision (const T1 &amp;, const T2 &amp;);
<span class="lineNum">     497 </span>            : 
<span class="lineNum">     498 </span>            :   template &lt;typename T1, typename T2&gt;
<span class="lineNum">     499 </span>            :   void copy (T1 &amp;, const T2 &amp;);
<span class="lineNum">     500 </span>            : 
<span class="lineNum">     501 </span>            : #define UNARY_PREDICATE \
<span class="lineNum">     502 </span>            :   template &lt;typename T&gt; bool
<span class="lineNum">     503 </span>            : #define UNARY_FUNCTION \
<span class="lineNum">     504 </span>            :   template &lt;typename T&gt; WI_UNARY_RESULT (T)
<span class="lineNum">     505 </span>            : #define BINARY_PREDICATE \
<span class="lineNum">     506 </span>            :   template &lt;typename T1, typename T2&gt; bool
<span class="lineNum">     507 </span>            : #define BINARY_FUNCTION \
<span class="lineNum">     508 </span>            :   template &lt;typename T1, typename T2&gt; WI_BINARY_RESULT (T1, T2)
<span class="lineNum">     509 </span>            : #define SHIFT_FUNCTION \
<span class="lineNum">     510 </span>            :   template &lt;typename T1, typename T2&gt; WI_UNARY_RESULT (T1)
<span class="lineNum">     511 </span>            : 
<span class="lineNum">     512 </span>            :   UNARY_PREDICATE fits_shwi_p (const T &amp;);
<span class="lineNum">     513 </span>            :   UNARY_PREDICATE fits_uhwi_p (const T &amp;);
<span class="lineNum">     514 </span>            :   UNARY_PREDICATE neg_p (const T &amp;, signop = SIGNED);
<span class="lineNum">     515 </span>            : 
<span class="lineNum">     516 </span>            :   template &lt;typename T&gt;
<span class="lineNum">     517 </span>            :   HOST_WIDE_INT sign_mask (const T &amp;);
<span class="lineNum">     518 </span>            : 
<span class="lineNum">     519 </span>            :   BINARY_PREDICATE eq_p (const T1 &amp;, const T2 &amp;);
<span class="lineNum">     520 </span>            :   BINARY_PREDICATE ne_p (const T1 &amp;, const T2 &amp;);
<span class="lineNum">     521 </span>            :   BINARY_PREDICATE lt_p (const T1 &amp;, const T2 &amp;, signop);
<span class="lineNum">     522 </span>            :   BINARY_PREDICATE lts_p (const T1 &amp;, const T2 &amp;);
<span class="lineNum">     523 </span>            :   BINARY_PREDICATE ltu_p (const T1 &amp;, const T2 &amp;);
<span class="lineNum">     524 </span>            :   BINARY_PREDICATE le_p (const T1 &amp;, const T2 &amp;, signop);
<span class="lineNum">     525 </span>            :   BINARY_PREDICATE les_p (const T1 &amp;, const T2 &amp;);
<span class="lineNum">     526 </span>            :   BINARY_PREDICATE leu_p (const T1 &amp;, const T2 &amp;);
<span class="lineNum">     527 </span>            :   BINARY_PREDICATE gt_p (const T1 &amp;, const T2 &amp;, signop);
<span class="lineNum">     528 </span>            :   BINARY_PREDICATE gts_p (const T1 &amp;, const T2 &amp;);
<span class="lineNum">     529 </span>            :   BINARY_PREDICATE gtu_p (const T1 &amp;, const T2 &amp;);
<span class="lineNum">     530 </span>            :   BINARY_PREDICATE ge_p (const T1 &amp;, const T2 &amp;, signop);
<span class="lineNum">     531 </span>            :   BINARY_PREDICATE ges_p (const T1 &amp;, const T2 &amp;);
<span class="lineNum">     532 </span>            :   BINARY_PREDICATE geu_p (const T1 &amp;, const T2 &amp;);
<span class="lineNum">     533 </span>            : 
<span class="lineNum">     534 </span>            :   template &lt;typename T1, typename T2&gt;
<span class="lineNum">     535 </span>            :   int cmp (const T1 &amp;, const T2 &amp;, signop);
<span class="lineNum">     536 </span>            : 
<span class="lineNum">     537 </span>            :   template &lt;typename T1, typename T2&gt;
<span class="lineNum">     538 </span>            :   int cmps (const T1 &amp;, const T2 &amp;);
<span class="lineNum">     539 </span>            : 
<span class="lineNum">     540 </span>            :   template &lt;typename T1, typename T2&gt;
<span class="lineNum">     541 </span>            :   int cmpu (const T1 &amp;, const T2 &amp;);
<span class="lineNum">     542 </span>            : 
<span class="lineNum">     543 </span>            :   UNARY_FUNCTION bit_not (const T &amp;);
<span class="lineNum">     544 </span>            :   UNARY_FUNCTION neg (const T &amp;);
<span class="lineNum">     545 </span>            :   UNARY_FUNCTION neg (const T &amp;, overflow_type *);
<span class="lineNum">     546 </span>            :   UNARY_FUNCTION abs (const T &amp;);
<span class="lineNum">     547 </span>            :   UNARY_FUNCTION ext (const T &amp;, unsigned int, signop);
<span class="lineNum">     548 </span>            :   UNARY_FUNCTION sext (const T &amp;, unsigned int);
<span class="lineNum">     549 </span>            :   UNARY_FUNCTION zext (const T &amp;, unsigned int);
<span class="lineNum">     550 </span>            :   UNARY_FUNCTION set_bit (const T &amp;, unsigned int);
<span class="lineNum">     551 </span>            : 
<span class="lineNum">     552 </span>            :   BINARY_FUNCTION min (const T1 &amp;, const T2 &amp;, signop);
<span class="lineNum">     553 </span>            :   BINARY_FUNCTION smin (const T1 &amp;, const T2 &amp;);
<span class="lineNum">     554 </span>            :   BINARY_FUNCTION umin (const T1 &amp;, const T2 &amp;);
<span class="lineNum">     555 </span>            :   BINARY_FUNCTION max (const T1 &amp;, const T2 &amp;, signop);
<span class="lineNum">     556 </span>            :   BINARY_FUNCTION smax (const T1 &amp;, const T2 &amp;);
<span class="lineNum">     557 </span>            :   BINARY_FUNCTION umax (const T1 &amp;, const T2 &amp;);
<span class="lineNum">     558 </span>            : 
<span class="lineNum">     559 </span>            :   BINARY_FUNCTION bit_and (const T1 &amp;, const T2 &amp;);
<span class="lineNum">     560 </span>            :   BINARY_FUNCTION bit_and_not (const T1 &amp;, const T2 &amp;);
<span class="lineNum">     561 </span>            :   BINARY_FUNCTION bit_or (const T1 &amp;, const T2 &amp;);
<span class="lineNum">     562 </span>            :   BINARY_FUNCTION bit_or_not (const T1 &amp;, const T2 &amp;);
<span class="lineNum">     563 </span>            :   BINARY_FUNCTION bit_xor (const T1 &amp;, const T2 &amp;);
<span class="lineNum">     564 </span>            :   BINARY_FUNCTION add (const T1 &amp;, const T2 &amp;);
<span class="lineNum">     565 </span>            :   BINARY_FUNCTION add (const T1 &amp;, const T2 &amp;, signop, overflow_type *);
<span class="lineNum">     566 </span>            :   BINARY_FUNCTION sub (const T1 &amp;, const T2 &amp;);
<span class="lineNum">     567 </span>            :   BINARY_FUNCTION sub (const T1 &amp;, const T2 &amp;, signop, overflow_type *);
<span class="lineNum">     568 </span>            :   BINARY_FUNCTION mul (const T1 &amp;, const T2 &amp;);
<span class="lineNum">     569 </span>            :   BINARY_FUNCTION mul (const T1 &amp;, const T2 &amp;, signop, overflow_type *);
<span class="lineNum">     570 </span>            :   BINARY_FUNCTION smul (const T1 &amp;, const T2 &amp;, overflow_type *);
<span class="lineNum">     571 </span>            :   BINARY_FUNCTION umul (const T1 &amp;, const T2 &amp;, overflow_type *);
<span class="lineNum">     572 </span>            :   BINARY_FUNCTION mul_high (const T1 &amp;, const T2 &amp;, signop);
<span class="lineNum">     573 </span>            :   BINARY_FUNCTION div_trunc (const T1 &amp;, const T2 &amp;, signop,
<span class="lineNum">     574 </span>            :                              overflow_type * = 0);
<span class="lineNum">     575 </span>            :   BINARY_FUNCTION sdiv_trunc (const T1 &amp;, const T2 &amp;);
<span class="lineNum">     576 </span>            :   BINARY_FUNCTION udiv_trunc (const T1 &amp;, const T2 &amp;);
<span class="lineNum">     577 </span>            :   BINARY_FUNCTION div_floor (const T1 &amp;, const T2 &amp;, signop,
<span class="lineNum">     578 </span>            :                              overflow_type * = 0);
<span class="lineNum">     579 </span>            :   BINARY_FUNCTION udiv_floor (const T1 &amp;, const T2 &amp;);
<span class="lineNum">     580 </span>            :   BINARY_FUNCTION sdiv_floor (const T1 &amp;, const T2 &amp;);
<span class="lineNum">     581 </span>            :   BINARY_FUNCTION div_ceil (const T1 &amp;, const T2 &amp;, signop,
<span class="lineNum">     582 </span>            :                             overflow_type * = 0);
<span class="lineNum">     583 </span>            :   BINARY_FUNCTION udiv_ceil (const T1 &amp;, const T2 &amp;);
<span class="lineNum">     584 </span>            :   BINARY_FUNCTION div_round (const T1 &amp;, const T2 &amp;, signop,
<span class="lineNum">     585 </span>            :                              overflow_type * = 0);
<span class="lineNum">     586 </span>            :   BINARY_FUNCTION divmod_trunc (const T1 &amp;, const T2 &amp;, signop,
<span class="lineNum">     587 </span>            :                                 WI_BINARY_RESULT (T1, T2) *);
<span class="lineNum">     588 </span>            :   BINARY_FUNCTION gcd (const T1 &amp;, const T2 &amp;, signop = UNSIGNED);
<span class="lineNum">     589 </span>            :   BINARY_FUNCTION mod_trunc (const T1 &amp;, const T2 &amp;, signop,
<span class="lineNum">     590 </span>            :                              overflow_type * = 0);
<span class="lineNum">     591 </span>            :   BINARY_FUNCTION smod_trunc (const T1 &amp;, const T2 &amp;);
<span class="lineNum">     592 </span>            :   BINARY_FUNCTION umod_trunc (const T1 &amp;, const T2 &amp;);
<span class="lineNum">     593 </span>            :   BINARY_FUNCTION mod_floor (const T1 &amp;, const T2 &amp;, signop,
<span class="lineNum">     594 </span>            :                              overflow_type * = 0);
<span class="lineNum">     595 </span>            :   BINARY_FUNCTION umod_floor (const T1 &amp;, const T2 &amp;);
<span class="lineNum">     596 </span>            :   BINARY_FUNCTION mod_ceil (const T1 &amp;, const T2 &amp;, signop,
<span class="lineNum">     597 </span>            :                             overflow_type * = 0);
<span class="lineNum">     598 </span>            :   BINARY_FUNCTION mod_round (const T1 &amp;, const T2 &amp;, signop,
<span class="lineNum">     599 </span>            :                              overflow_type * = 0);
<span class="lineNum">     600 </span>            : 
<span class="lineNum">     601 </span>            :   template &lt;typename T1, typename T2&gt;
<span class="lineNum">     602 </span>            :   bool multiple_of_p (const T1 &amp;, const T2 &amp;, signop);
<span class="lineNum">     603 </span>            : 
<span class="lineNum">     604 </span>            :   template &lt;typename T1, typename T2&gt;
<span class="lineNum">     605 </span>            :   bool multiple_of_p (const T1 &amp;, const T2 &amp;, signop,
<span class="lineNum">     606 </span>            :                       WI_BINARY_RESULT (T1, T2) *);
<span class="lineNum">     607 </span>            : 
<span class="lineNum">     608 </span>            :   SHIFT_FUNCTION lshift (const T1 &amp;, const T2 &amp;);
<span class="lineNum">     609 </span>            :   SHIFT_FUNCTION lrshift (const T1 &amp;, const T2 &amp;);
<span class="lineNum">     610 </span>            :   SHIFT_FUNCTION arshift (const T1 &amp;, const T2 &amp;);
<span class="lineNum">     611 </span>            :   SHIFT_FUNCTION rshift (const T1 &amp;, const T2 &amp;, signop sgn);
<span class="lineNum">     612 </span>            :   SHIFT_FUNCTION lrotate (const T1 &amp;, const T2 &amp;, unsigned int = 0);
<span class="lineNum">     613 </span>            :   SHIFT_FUNCTION rrotate (const T1 &amp;, const T2 &amp;, unsigned int = 0);
<span class="lineNum">     614 </span>            : 
<span class="lineNum">     615 </span>            : #undef SHIFT_FUNCTION
<span class="lineNum">     616 </span>            : #undef BINARY_PREDICATE
<span class="lineNum">     617 </span>            : #undef BINARY_FUNCTION
<span class="lineNum">     618 </span>            : #undef UNARY_PREDICATE
<span class="lineNum">     619 </span>            : #undef UNARY_FUNCTION
<span class="lineNum">     620 </span>            : 
<span class="lineNum">     621 </span>            :   bool only_sign_bit_p (const wide_int_ref &amp;, unsigned int);
<span class="lineNum">     622 </span>            :   bool only_sign_bit_p (const wide_int_ref &amp;);
<span class="lineNum">     623 </span>            :   int clz (const wide_int_ref &amp;);
<span class="lineNum">     624 </span>            :   int clrsb (const wide_int_ref &amp;);
<span class="lineNum">     625 </span>            :   int ctz (const wide_int_ref &amp;);
<span class="lineNum">     626 </span>            :   int exact_log2 (const wide_int_ref &amp;);
<span class="lineNum">     627 </span>            :   int floor_log2 (const wide_int_ref &amp;);
<span class="lineNum">     628 </span>            :   int ffs (const wide_int_ref &amp;);
<span class="lineNum">     629 </span>            :   int popcount (const wide_int_ref &amp;);
<span class="lineNum">     630 </span>            :   int parity (const wide_int_ref &amp;);
<span class="lineNum">     631 </span>            : 
<span class="lineNum">     632 </span>            :   template &lt;typename T&gt;
<span class="lineNum">     633 </span>            :   unsigned HOST_WIDE_INT extract_uhwi (const T &amp;, unsigned int, unsigned int);
<span class="lineNum">     634 </span>            : 
<span class="lineNum">     635 </span>            :   template &lt;typename T&gt;
<span class="lineNum">     636 </span>            :   unsigned int min_precision (const T &amp;, signop);
<span class="lineNum">     637 </span>            : 
<span class="lineNum">     638 </span>            :   static inline void accumulate_overflow (overflow_type &amp;, overflow_type);
<span class="lineNum">     639 </span>            : }
<span class="lineNum">     640 </span>            : 
<span class="lineNum">     641 </span>            : namespace wi
<span class="lineNum">     642 </span>            : {
<span class="lineNum">     643 </span>            :   /* Contains the components of a decomposed integer for easy, direct
<span class="lineNum">     644 </span>            :      access.  */
<span class="lineNum">     645 </span>            :   struct storage_ref
<span class="lineNum">     646 </span>            :   {
<span class="lineNum">     647 </span>            :     storage_ref () {}
<span class="lineNum">     648 </span>            :     storage_ref (const HOST_WIDE_INT *, unsigned int, unsigned int);
<span class="lineNum">     649 </span>            : 
<span class="lineNum">     650 </span>            :     const HOST_WIDE_INT *val;
<span class="lineNum">     651 </span>            :     unsigned int len;
<span class="lineNum">     652 </span>            :     unsigned int precision;
<span class="lineNum">     653 </span>            : 
<span class="lineNum">     654 </span>            :     /* Provide enough trappings for this class to act as storage for
<span class="lineNum">     655 </span>            :        generic_wide_int.  */
<span class="lineNum">     656 </span>            :     unsigned int get_len () const;
<span class="lineNum">     657 </span>            :     unsigned int get_precision () const;
<span class="lineNum">     658 </span>            :     const HOST_WIDE_INT *get_val () const;
<span class="lineNum">     659 </span>            :   };
<span class="lineNum">     660 </span>            : }
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span>            : inline::wi::storage_ref::storage_ref (const HOST_WIDE_INT *val_in,
<span class="lineNum">     663 </span>            :                                       unsigned int len_in,
<span class="lineNum">     664 </span>            :                                       unsigned int precision_in)
<span class="lineNum">     665 </span>            :   : val (val_in), len (len_in), precision (precision_in)
<span class="lineNum">     666 </span>            : {
<span class="lineNum">     667 </span>            : }
<a name="668"><span class="lineNum">     668 </span>            : </a>
<span class="lineNum">     669 </span>            : inline unsigned int
<span class="lineNum">     670 </span><span class="lineNoCov">          0 : wi::storage_ref::get_len () const</span>
<span class="lineNum">     671 </span>            : {
<span class="lineNum">     672 </span><span class="lineCov">12818724846 :   return len;</span>
<span class="lineNum">     673 </span>            : }
<a name="674"><span class="lineNum">     674 </span>            : </a>
<span class="lineNum">     675 </span>            : inline unsigned int
<span class="lineNum">     676 </span><span class="lineNoCov">          0 : wi::storage_ref::get_precision () const</span>
<span class="lineNum">     677 </span>            : {
<span class="lineNum">     678 </span><span class="lineCov"> 8632436441 :   return precision;</span>
<span class="lineNum">     679 </span>            : }
<a name="680"><span class="lineNum">     680 </span>            : </a>
<span class="lineNum">     681 </span>            : inline const HOST_WIDE_INT *
<span class="lineNum">     682 </span><span class="lineNoCov">          0 : wi::storage_ref::get_val () const</span>
<span class="lineNum">     683 </span>            : {
<span class="lineNum">     684 </span><span class="lineCov">34754763513 :   return val;</span>
<span class="lineNum">     685 </span>            : }
<span class="lineNum">     686 </span>            : 
<span class="lineNum">     687 </span>            : /* This class defines an integer type using the storage provided by the
<span class="lineNum">     688 </span>            :    template argument.  The storage class must provide the following
<span class="lineNum">     689 </span>            :    functions:
<span class="lineNum">     690 </span>            : 
<span class="lineNum">     691 </span>            :    unsigned int get_precision () const
<span class="lineNum">     692 </span>            :      Return the number of bits in the integer.
<span class="lineNum">     693 </span>            : 
<span class="lineNum">     694 </span>            :    HOST_WIDE_INT *get_val () const
<span class="lineNum">     695 </span>            :      Return a pointer to the array of blocks that encodes the integer.
<span class="lineNum">     696 </span>            : 
<span class="lineNum">     697 </span>            :    unsigned int get_len () const
<span class="lineNum">     698 </span>            :      Return the number of blocks in get_val ().  If this is smaller
<span class="lineNum">     699 </span>            :      than the number of blocks implied by get_precision (), the
<span class="lineNum">     700 </span>            :      remaining blocks are sign extensions of block get_len () - 1.
<span class="lineNum">     701 </span>            : 
<span class="lineNum">     702 </span>            :    Although not required by generic_wide_int itself, writable storage
<span class="lineNum">     703 </span>            :    classes can also provide the following functions:
<span class="lineNum">     704 </span>            : 
<span class="lineNum">     705 </span>            :    HOST_WIDE_INT *write_val ()
<span class="lineNum">     706 </span>            :      Get a modifiable version of get_val ()
<span class="lineNum">     707 </span>            : 
<span class="lineNum">     708 </span>            :    unsigned int set_len (unsigned int len)
<span class="lineNum">     709 </span>            :      Set the value returned by get_len () to LEN.  */
<span class="lineNum">     710 </span>            : template &lt;typename storage&gt;
<span class="lineNum">     711 </span>            : class GTY(()) generic_wide_int : public storage
<span class="lineNum">     712 </span>            : {
<span class="lineNum">     713 </span>            : public:
<span class="lineNum">     714 </span>            :   generic_wide_int ();
<span class="lineNum">     715 </span>            : 
<span class="lineNum">     716 </span>            :   template &lt;typename T&gt;
<span class="lineNum">     717 </span>            :   generic_wide_int (const T &amp;);
<span class="lineNum">     718 </span>            : 
<span class="lineNum">     719 </span>            :   template &lt;typename T&gt;
<span class="lineNum">     720 </span>            :   generic_wide_int (const T &amp;, unsigned int);
<span class="lineNum">     721 </span>            : 
<span class="lineNum">     722 </span>            :   /* Conversions.  */
<span class="lineNum">     723 </span>            :   HOST_WIDE_INT to_shwi (unsigned int) const;
<span class="lineNum">     724 </span>            :   HOST_WIDE_INT to_shwi () const;
<span class="lineNum">     725 </span>            :   unsigned HOST_WIDE_INT to_uhwi (unsigned int) const;
<span class="lineNum">     726 </span>            :   unsigned HOST_WIDE_INT to_uhwi () const;
<span class="lineNum">     727 </span>            :   HOST_WIDE_INT to_short_addr () const;
<span class="lineNum">     728 </span>            : 
<span class="lineNum">     729 </span>            :   /* Public accessors for the interior of a wide int.  */
<span class="lineNum">     730 </span>            :   HOST_WIDE_INT sign_mask () const;
<span class="lineNum">     731 </span>            :   HOST_WIDE_INT elt (unsigned int) const;
<span class="lineNum">     732 </span>            :   unsigned HOST_WIDE_INT ulow () const;
<span class="lineNum">     733 </span>            :   unsigned HOST_WIDE_INT uhigh () const;
<span class="lineNum">     734 </span>            :   HOST_WIDE_INT slow () const;
<span class="lineNum">     735 </span>            :   HOST_WIDE_INT shigh () const;
<span class="lineNum">     736 </span>            : 
<span class="lineNum">     737 </span>            :   template &lt;typename T&gt;
<span class="lineNum">     738 </span>            :   generic_wide_int &amp;operator = (const T &amp;);
<span class="lineNum">     739 </span>            : 
<span class="lineNum">     740 </span>            : #define ASSIGNMENT_OPERATOR(OP, F) \
<span class="lineNum">     741 </span>            :   template &lt;typename T&gt; \
<span class="lineNum">     742 </span>            :     generic_wide_int &amp;OP (const T &amp;c) { return (*this = wi::F (*this, c)); }
<span class="lineNum">     743 </span>            : 
<span class="lineNum">     744 </span>            : /* Restrict these to cases where the shift operator is defined.  */
<span class="lineNum">     745 </span>            : #define SHIFT_ASSIGNMENT_OPERATOR(OP, OP2) \
<span class="lineNum">     746 </span>            :   template &lt;typename T&gt; \
<span class="lineNum">     747 </span>            :     generic_wide_int &amp;OP (const T &amp;c) { return (*this = *this OP2 c); }
<span class="lineNum">     748 </span>            : 
<span class="lineNum">     749 </span>            : #define INCDEC_OPERATOR(OP, DELTA) \
<span class="lineNum">     750 </span>            :   generic_wide_int &amp;OP () { *this += DELTA; return *this; }
<a name="751"><span class="lineNum">     751 </span>            : </a>
<span class="lineNum">     752 </span><span class="lineCov">    5102602 :   ASSIGNMENT_OPERATOR (operator &amp;=, bit_and)</span>
<a name="753"><span class="lineNum">     753 </span><span class="lineCov">      71085 :   ASSIGNMENT_OPERATOR (operator |=, bit_or)</span></a>
<a name="754"><span class="lineNum">     754 </span>            :   ASSIGNMENT_OPERATOR (operator ^=, bit_xor)</a>
<a name="755"><span class="lineNum">     755 </span><span class="lineCov"> 2422846644 :   ASSIGNMENT_OPERATOR (operator +=, add)</span></a>
<span class="lineNum">     756 </span><span class="lineCov">   20007057 :   ASSIGNMENT_OPERATOR (operator -=, sub)</span>
<span class="lineNum">     757 </span><span class="lineCov">  239725343 :   ASSIGNMENT_OPERATOR (operator *=, mul)</span>
<a name="758"><span class="lineNum">     758 </span><span class="lineCov">  691982728 :   ASSIGNMENT_OPERATOR (operator &lt;&lt;=, lshift)</span></a>
<span class="lineNum">     759 </span>            :   SHIFT_ASSIGNMENT_OPERATOR (operator &gt;&gt;=, &gt;&gt;)
<span class="lineNum">     760 </span><span class="lineCov">      18041 :   INCDEC_OPERATOR (operator ++, 1)</span>
<span class="lineNum">     761 </span><span class="lineCov">      14599 :   INCDEC_OPERATOR (operator --, -1)</span>
<span class="lineNum">     762 </span>            : 
<span class="lineNum">     763 </span>            : #undef SHIFT_ASSIGNMENT_OPERATOR
<span class="lineNum">     764 </span>            : #undef ASSIGNMENT_OPERATOR
<span class="lineNum">     765 </span>            : #undef INCDEC_OPERATOR
<span class="lineNum">     766 </span>            : 
<span class="lineNum">     767 </span>            :   /* Debugging functions.  */
<span class="lineNum">     768 </span>            :   void dump () const;
<span class="lineNum">     769 </span>            : 
<span class="lineNum">     770 </span>            :   static const bool is_sign_extended
<span class="lineNum">     771 </span>            :     = wi::int_traits &lt;generic_wide_int &lt;storage&gt; &gt;::is_sign_extended;
<span class="lineNum">     772 </span>            : };
<span class="lineNum">     773 </span>            : 
<span class="lineNum">     774 </span>            : template &lt;typename storage&gt;
<span class="lineNum">     775 </span><span class="lineCov">33981444753 : inline generic_wide_int &lt;storage&gt;::generic_wide_int () {}</span>
<span class="lineNum">     776 </span>            : 
<a name="777"><span class="lineNum">     777 </span>            : template &lt;typename storage&gt;</a>
<span class="lineNum">     778 </span>            : template &lt;typename T&gt;
<span class="lineNum">     779 </span><span class="lineCov">11584301392 : inline generic_wide_int &lt;storage&gt;::generic_wide_int (const T &amp;x)</span>
<span class="lineNum">     780 </span><span class="lineCov">13094337959 :   : storage (x)</span>
<span class="lineNum">     781 </span>            : {
<span class="lineNum">     782 </span><span class="lineCov">  270149621 : }</span>
<span class="lineNum">     783 </span><span class="lineCov">  262904952 : </span>
<span class="lineNum">     784 </span><span class="lineCov">  262904952 : template &lt;typename storage&gt;</span>
<span class="lineNum">     785 </span>            : template &lt;typename T&gt;
<span class="lineNum">     786 </span><span class="lineCov">  262904952 : inline generic_wide_int &lt;storage&gt;::generic_wide_int (const T &amp;x,</span>
<span class="lineNum">     787 </span><span class="lineCov">        432 :                                                      unsigned int precision)</span>
<span class="lineNum">     788 </span><span class="lineCov">84478224806 :   : storage (x, precision)</span>
<span class="lineNum">     789 </span>            : {
<span class="lineNum">     790 </span><span class="lineCov">        432 : }</span>
<span class="lineNum">     791 </span><span class="lineCov">    2550458 : </span>
<span class="lineNum">     792 </span><span class="lineCov">    2550458 : /* Return THIS as a signed HOST_WIDE_INT, sign-extending from PRECISION.</span>
<span class="lineNum">     793 </span>            :    If THIS does not fit in PRECISION, the information is lost.  */
<span class="lineNum">     794 </span><span class="lineCov">    2550458 : template &lt;typename storage&gt;</span>
<span class="lineNum">     795 </span><span class="lineCov">    4693739 : inline HOST_WIDE_INT</span>
<span class="lineNum">     796 </span><span class="lineCov">    4693739 : generic_wide_int &lt;storage&gt;::to_shwi (unsigned int precision) const</span>
<span class="lineNum">     797 </span>            : {
<span class="lineNum">     798 </span><span class="lineCov">   25575477 :   if (precision &lt; HOST_BITS_PER_WIDE_INT)</span>
<span class="lineNum">     799 </span><span class="lineCov">   14200112 :     return sext_hwi (this-&gt;get_val ()[0], precision);</span>
<span class="lineNum">     800 </span>            :   else
<span class="lineNum">     801 </span><span class="lineCov">   12718930 :     return this-&gt;get_val ()[0];</span>
<span class="lineNum">     802 </span>            : }
<span class="lineNum">     803 </span>            : 
<span class="lineNum">     804 </span><span class="lineCov">   79247468 : /* Return THIS as a signed HOST_WIDE_INT, in its natural precision.  */</span>
<span class="lineNum">     805 </span>            : template &lt;typename storage&gt;
<span class="lineNum">     806 </span>            : inline HOST_WIDE_INT
<span class="lineNum">     807 </span>            : generic_wide_int &lt;storage&gt;::to_shwi () const
<span class="lineNum">     808 </span>            : {
<span class="lineNum">     809 </span>            :   if (is_sign_extended)
<span class="lineNum">     810 </span><span class="lineCov"> 6436002828 :     return this-&gt;get_val ()[0];</span>
<span class="lineNum">     811 </span>            :   else
<span class="lineNum">     812 </span><span class="lineCov">   45940327 :     return to_shwi (this-&gt;get_precision ());</span>
<span class="lineNum">     813 </span>            : }
<span class="lineNum">     814 </span><span class="lineCov">     122564 : </span>
<span class="lineNum">     815 </span><span class="lineCov">     163680 : /* Return THIS as an unsigned HOST_WIDE_INT, zero-extending from</span>
<span class="lineNum">     816 </span>            :    PRECISION.  If THIS does not fit in PRECISION, the information
<span class="lineNum">     817 </span><span class="lineCov">      20362 :    is lost.  */</span>
<span class="lineNum">     818 </span>            : template &lt;typename storage&gt;
<span class="lineNum">     819 </span>            : inline unsigned HOST_WIDE_INT
<span class="lineNum">     820 </span>            : generic_wide_int &lt;storage&gt;::to_uhwi (unsigned int precision) const
<span class="lineNum">     821 </span>            : {
<span class="lineNum">     822 </span><span class="lineCov"> 2024502054 :   if (precision &lt; HOST_BITS_PER_WIDE_INT)</span>
<span class="lineNum">     823 </span><span class="lineCov">  390206082 :     return zext_hwi (this-&gt;get_val ()[0], precision);</span>
<span class="lineNum">     824 </span>            :   else
<span class="lineNum">     825 </span><span class="lineCov">  470935120 :     return this-&gt;get_val ()[0];</span>
<span class="lineNum">     826 </span>            : }
<span class="lineNum">     827 </span>            : 
<span class="lineNum">     828 </span><span class="lineCov">     367692 : /* Return THIS as an signed HOST_WIDE_INT, in its natural precision.  */</span>
<span class="lineNum">     829 </span>            : template &lt;typename storage&gt;
<span class="lineNum">     830 </span>            : inline unsigned HOST_WIDE_INT
<span class="lineNum">     831 </span>            : generic_wide_int &lt;storage&gt;::to_uhwi () const
<span class="lineNum">     832 </span>            : {
<span class="lineNum">     833 </span><span class="lineCov">12622104183 :   return to_uhwi (this-&gt;get_precision ());</span>
<span class="lineNum">     834 </span>            : }
<span class="lineNum">     835 </span>            : 
<span class="lineNum">     836 </span>            : /* TODO: The compiler is half converted from using HOST_WIDE_INT to
<span class="lineNum">     837 </span>            :    represent addresses to using offset_int to represent addresses.
<span class="lineNum">     838 </span><span class="lineCov">    4044209 :    We use to_short_addr at the interface from new code to old,</span>
<span class="lineNum">     839 </span><span class="lineCov">    3658100 :    unconverted code.  */</span>
<span class="lineNum">     840 </span>            : template &lt;typename storage&gt;
<span class="lineNum">     841 </span><span class="lineCov">    2215159 : inline HOST_WIDE_INT</span>
<span class="lineNum">     842 </span>            : generic_wide_int &lt;storage&gt;::to_short_addr () const
<span class="lineNum">     843 </span>            : {
<span class="lineNum">     844 </span><span class="lineCov">    3110092 :   return this-&gt;get_val ()[0];</span>
<span class="lineNum">     845 </span>            : }
<span class="lineNum">     846 </span>            : 
<span class="lineNum">     847 </span>            : /* Return the implicit value of blocks above get_len ().  */
<a name="848"><span class="lineNum">     848 </span>            : template &lt;typename storage&gt;</a>
<span class="lineNum">     849 </span><span class="lineCov">   19905729 : inline HOST_WIDE_INT</span>
<span class="lineNum">     850 </span><span class="lineNoCov">          0 : generic_wide_int &lt;storage&gt;::sign_mask () const</span>
<span class="lineNum">     851 </span>            : {
<span class="lineNum">     852 </span><span class="lineCov"> 3584129710 :   unsigned int len = this-&gt;get_len ();</span>
<span class="lineNum">     853 </span><span class="lineCov"> 3584129710 :   unsigned HOST_WIDE_INT high = this-&gt;get_val ()[len - 1];</span>
<span class="lineNum">     854 </span>            :   if (!is_sign_extended)
<span class="lineNum">     855 </span>            :     {
<span class="lineNum">     856 </span><span class="lineCov">  189185536 :       unsigned int precision = this-&gt;get_precision ();</span>
<span class="lineNum">     857 </span><span class="lineCov">   94592768 :       int excess = len * HOST_BITS_PER_WIDE_INT - precision;</span>
<span class="lineNum">     858 </span><span class="lineCov">   52703478 :       if (excess &gt; 0)</span>
<span class="lineNum">     859 </span><span class="lineCov">   46323346 :         high &lt;&lt;= excess;</span>
<span class="lineNum">     860 </span>            :     }
<span class="lineNum">     861 </span><span class="lineCov">  148180984 :   return (HOST_WIDE_INT) (high) &lt; 0 ? -1 : 0;</span>
<span class="lineNum">     862 </span>            : }
<span class="lineNum">     863 </span>            : 
<span class="lineNum">     864 </span>            : /* Return the signed value of the least-significant explicitly-encoded
<span class="lineNum">     865 </span>            :    block.  */
<span class="lineNum">     866 </span>            : template &lt;typename storage&gt;
<span class="lineNum">     867 </span>            : inline HOST_WIDE_INT
<span class="lineNum">     868 </span><span class="lineCov">     201368 : generic_wide_int &lt;storage&gt;::slow () const</span>
<span class="lineNum">     869 </span><span class="lineCov">     201368 : {</span>
<span class="lineNum">     870 </span><span class="lineCov"> 3750477041 :   return this-&gt;get_val ()[0];</span>
<span class="lineNum">     871 </span>            : }
<span class="lineNum">     872 </span><span class="lineCov">     201368 : </span>
<span class="lineNum">     873 </span><span class="lineCov">     100684 : /* Return the signed value of the most-significant explicitly-encoded</span>
<span class="lineNum">     874 </span><span class="lineCov">     100684 :    block.  */</span>
<span class="lineNum">     875 </span><span class="lineCov">      18939 : template &lt;typename storage&gt;</span>
<span class="lineNum">     876 </span>            : inline HOST_WIDE_INT
<span class="lineNum">     877 </span><span class="lineCov">     100684 : generic_wide_int &lt;storage&gt;::shigh () const</span>
<span class="lineNum">     878 </span>            : {
<span class="lineNum">     879 </span>            :   return this-&gt;get_val ()[this-&gt;get_len () - 1];
<span class="lineNum">     880 </span>            : }
<span class="lineNum">     881 </span>            : 
<span class="lineNum">     882 </span>            : /* Return the unsigned value of the least-significant
<span class="lineNum">     883 </span>            :    explicitly-encoded block.  */
<span class="lineNum">     884 </span>            : template &lt;typename storage&gt;
<span class="lineNum">     885 </span>            : inline unsigned HOST_WIDE_INT
<span class="lineNum">     886 </span>            : generic_wide_int &lt;storage&gt;::ulow () const
<span class="lineNum">     887 </span>            : {
<span class="lineNum">     888 </span><span class="lineCov">19355782153 :   return this-&gt;get_val ()[0];</span>
<span class="lineNum">     889 </span>            : }
<span class="lineNum">     890 </span>            : 
<span class="lineNum">     891 </span>            : /* Return the unsigned value of the most-significant
<span class="lineNum">     892 </span>            :    explicitly-encoded block.  */
<span class="lineNum">     893 </span>            : template &lt;typename storage&gt;
<span class="lineNum">     894 </span>            : inline unsigned HOST_WIDE_INT
<span class="lineNum">     895 </span>            : generic_wide_int &lt;storage&gt;::uhigh () const
<span class="lineNum">     896 </span>            : {
<span class="lineNum">     897 </span><span class="lineCov">   30929779 :   return this-&gt;get_val ()[this-&gt;get_len () - 1];</span>
<span class="lineNum">     898 </span>            : }
<span class="lineNum">     899 </span>            : 
<span class="lineNum">     900 </span>            : /* Return block I, which might be implicitly or explicit encoded.  */
<a name="901"><span class="lineNum">     901 </span>            : template &lt;typename storage&gt;</a>
<span class="lineNum">     902 </span>            : inline HOST_WIDE_INT
<span class="lineNum">     903 </span><span class="lineCov">     825118 : generic_wide_int &lt;storage&gt;::elt (unsigned int i) const</span>
<span class="lineNum">     904 </span><span class="lineCov">   65435208 : {</span>
<span class="lineNum">     905 </span><span class="lineCov">  114930068 :   if (i &gt;= this-&gt;get_len ())</span>
<span class="lineNum">     906 </span><span class="lineCov">     267937 :     return sign_mask ();</span>
<span class="lineNum">     907 </span>            :   else
<span class="lineNum">     908 </span><span class="lineCov">  167243769 :     return this-&gt;get_val ()[i];</span>
<span class="lineNum">     909 </span>            : }
<span class="lineNum">     910 </span>            : 
<span class="lineNum">     911 </span>            : template &lt;typename storage&gt;
<a name="912"><span class="lineNum">     912 </span>            : template &lt;typename T&gt;</a>
<span class="lineNum">     913 </span>            : inline generic_wide_int &lt;storage&gt; &amp;
<span class="lineNum">     914 </span><span class="lineCov">       2753 : generic_wide_int &lt;storage&gt;::operator = (const T &amp;x)</span>
<span class="lineNum">     915 </span>            : {
<span class="lineNum">     916 </span><span class="lineCov"> 2498796750 :   storage::operator = (x);</span>
<span class="lineNum">     917 </span><span class="lineCov">       2753 :   return *this;</span>
<span class="lineNum">     918 </span>            : }
<span class="lineNum">     919 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">     920 </span>            : /* Dump the contents of the integer to stderr, for debugging.  */
<a name="921"><span class="lineNum">     921 </span><span class="lineCov">    2542944 : template &lt;typename storage&gt;</span></a>
<span class="lineNum">     922 </span><span class="lineNoCov">          0 : void</span>
<span class="lineNum">     923 </span><span class="lineNoCov">          0 : generic_wide_int &lt;storage&gt;::dump () const</span>
<span class="lineNum">     924 </span><span class="lineCov">    1271472 : {</span>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :   unsigned int len = this-&gt;get_len ();</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :   const HOST_WIDE_INT *val = this-&gt;get_val ();</span>
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :   unsigned int precision = this-&gt;get_precision ();</span>
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :   fprintf (stderr, &quot;[&quot;);</span>
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :   if (len * HOST_BITS_PER_WIDE_INT &lt; precision)</span>
<span class="lineNum">     930 </span><span class="lineCov">    2769612 :     fprintf (stderr, &quot;...,&quot;);</span>
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :   for (unsigned int i = 0; i &lt; len - 1; ++i)</span>
<span class="lineNum">     932 </span><span class="lineCov">    2769612 :     fprintf (stderr, HOST_WIDE_INT_PRINT_HEX &quot;,&quot;, val[len - 1 - i]);</span>
<span class="lineNum">     933 </span><span class="lineCov">    2769612 :   fprintf (stderr, HOST_WIDE_INT_PRINT_HEX &quot;], precision = %d\n&quot;,</span>
<span class="lineNum">     934 </span>            :            val[0], precision);
<span class="lineNum">     935 </span><span class="lineCov">    2671263 : }</span>
<span class="lineNum">     936 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">     937 </span><span class="lineCov">    2671263 : namespace wi</span>
<span class="lineNum">     938 </span><span class="lineCov">    2671263 : {</span>
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :   template &lt;typename storage&gt;</span>
<span class="lineNum">     940 </span><span class="lineCov">      98349 :   struct int_traits &lt; generic_wide_int &lt;storage&gt; &gt;</span>
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :     : public wi::int_traits &lt;storage&gt;</span>
<span class="lineNum">     942 </span><span class="lineCov">      98349 :   {</span>
<span class="lineNum">     943 </span><span class="lineCov">      98349 :     static unsigned int get_precision (const generic_wide_int &lt;storage&gt; &amp;);</span>
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :     static wi::storage_ref decompose (HOST_WIDE_INT *, unsigned int,</span>
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :                                       const generic_wide_int &lt;storage&gt; &amp;);</span>
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :   };</span>
<span class="lineNum">     947 </span>            : }
<span class="lineNum">     948 </span><span class="lineNoCov">          0 : </span>
<a name="949"><span class="lineNum">     949 </span><span class="lineNoCov">          0 : template &lt;typename storage&gt;</span></a>
<span class="lineNum">     950 </span>            : inline unsigned int
<span class="lineNum">     951 </span><span class="lineNoCov">          0 : wi::int_traits &lt; generic_wide_int &lt;storage&gt; &gt;::</span>
<span class="lineNum">     952 </span><span class="lineNoCov">          0 : get_precision (const generic_wide_int &lt;storage&gt; &amp;x)</span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">     954 </span><span class="lineCov">20803043055 :   return x.get_precision ();</span>
<span class="lineNum">     955 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     956 </span><span class="lineNoCov">          0 : </span>
<a name="957"><span class="lineNum">     957 </span><span class="lineNoCov">          0 : template &lt;typename storage&gt;</span></a>
<span class="lineNum">     958 </span><span class="lineNoCov">          0 : inline wi::storage_ref</span>
<span class="lineNum">     959 </span><span class="lineCov">  927743591 : wi::int_traits &lt; generic_wide_int &lt;storage&gt; &gt;::</span>
<span class="lineNum">     960 </span>            : decompose (HOST_WIDE_INT *, unsigned int precision,
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :            const generic_wide_int &lt;storage&gt; &amp;x)</span>
<span class="lineNum">     962 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">     963 </span><span class="lineCov"> 1122736402 :   gcc_checking_assert (precision == x.get_precision ());</span>
<span class="lineNum">     964 </span><span class="lineCov"> 5370326766 :   return wi::storage_ref (x.get_val (), x.get_len (), precision);</span>
<span class="lineNum">     965 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     966 </span><span class="lineCov">      77612 : </span>
<span class="lineNum">     967 </span><span class="lineNoCov">          0 : /* Provide the storage for a wide_int_ref.  This acts like a read-only</span>
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :    wide_int, with the optimization that VAL is normally a pointer to</span>
<span class="lineNum">     969 </span><span class="lineCov">16021767627 :    another integer's storage, so that no array copy is needed.  */</span>
<span class="lineNum">     970 </span><span class="lineCov">      77612 : template &lt;bool SE, bool HDP&gt;</span>
<span class="lineNum">     971 </span><span class="lineCov">      77612 : struct wide_int_ref_storage : public wi::storage_ref</span>
<span class="lineNum">     972 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">     973 </span><span class="lineCov"> 1915297308 : private:</span>
<span class="lineNum">     974 </span><span class="lineCov">12688798522 :   /* Scratch space that can be used when decomposing the original integer.</span>
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :      It must live as long as this object.  */</span>
<span class="lineNum">     976 </span><span class="lineCov">    3478714 :   HOST_WIDE_INT scratch[2];</span>
<span class="lineNum">     977 </span><span class="lineCov">  191535008 : </span>
<span class="lineNum">     978 </span><span class="lineCov">21579608658 : public:</span>
<span class="lineNum">     979 </span><span class="lineCov">64302021375 :   wide_int_ref_storage () {}</span>
<span class="lineNum">     980 </span><span class="lineCov">  582286962 : </span>
<span class="lineNum">     981 </span><span class="lineCov">    3488105 :   wide_int_ref_storage (const wi::storage_ref &amp;);</span>
<span class="lineNum">     982 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">     983 </span><span class="lineCov">  804270050 :   template &lt;typename T&gt;</span>
<span class="lineNum">     984 </span><span class="lineCov"> 2681498883 :   wide_int_ref_storage (const T &amp;);</span>
<span class="lineNum">     985 </span><span class="lineCov">  528105595 : </span>
<span class="lineNum">     986 </span><span class="lineCov">       9391 :   template &lt;typename T&gt;</span>
<span class="lineNum">     987 </span><span class="lineCov">  322587718 :   wide_int_ref_storage (const T &amp;, unsigned int);</span>
<span class="lineNum">     988 </span><span class="lineCov">  577416494 : };</span>
<span class="lineNum">     989 </span><span class="lineCov"> 5296898451 : </span>
<span class="lineNum">     990 </span><span class="lineCov">  220822424 : /* Create a reference from an existing reference.  */</span>
<span class="lineNum">     991 </span><span class="lineCov">      14369 : template &lt;bool SE, bool HDP&gt;</span>
<span class="lineNum">     992 </span><span class="lineCov">   63465338 : inline wide_int_ref_storage &lt;SE, HDP&gt;::</span>
<span class="lineNum">     993 </span><span class="lineCov">   84230700 : wide_int_ref_storage (const wi::storage_ref &amp;x)</span>
<span class="lineNum">     994 </span><span class="lineCov">  183994305 :   : storage_ref (x)</span>
<span class="lineNum">     995 </span><span class="lineCov"> 3347340708 : {}</span>
<span class="lineNum">     996 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">     997 </span><span class="lineCov">   79067247 : /* Create a reference to integer X in its natural precision.  Note</span>
<span class="lineNum">     998 </span><span class="lineCov">   83328364 :    that the natural precision is host-dependent for primitive</span>
<span class="lineNum">     999 </span><span class="lineCov"> 3220748176 :    types.  */</span>
<a name="1000"><span class="lineNum">    1000 </span><span class="lineCov"> 3339830742 : template &lt;bool SE, bool HDP&gt;</span></a>
<span class="lineNum">    1001 </span><span class="lineCov">     885743 : template &lt;typename T&gt;</span>
<span class="lineNum">    1002 </span><span class="lineCov">  155973530 : inline wide_int_ref_storage &lt;SE, HDP&gt;::wide_int_ref_storage (const T &amp;x)</span>
<span class="lineNum">    1003 </span><span class="lineCov">  283688718 :   : storage_ref (wi::int_traits &lt;T&gt;::decompose (scratch,</span>
<span class="lineNum">    1004 </span><span class="lineCov">  119083512 :                                                 wi::get_precision (x), x))</span>
<span class="lineNum">    1005 </span><span class="lineCov">  119083254 : {</span>
<span class="lineNum">    1006 </span><span class="lineCov">   71793688 : }</span>
<span class="lineNum">    1007 </span><span class="lineCov">   55722570 : </span>
<span class="lineNum">    1008 </span><span class="lineCov">   16046444 : /* Create a reference to integer X in precision PRECISION.  */</span>
<span class="lineNum">    1009 </span><span class="lineCov">  834679573 : template &lt;bool SE, bool HDP&gt;</span>
<span class="lineNum">    1010 </span><span class="lineCov">        688 : template &lt;typename T&gt;</span>
<span class="lineNum">    1011 </span><span class="lineCov">  275129938 : inline wide_int_ref_storage &lt;SE, HDP&gt;::</span>
<span class="lineNum">    1012 </span><span class="lineCov">  243646401 : wide_int_ref_storage (const T &amp;x, unsigned int precision)</span>
<span class="lineNum">    1013 </span><span class="lineCov"> 1805675986 :   : storage_ref (wi::int_traits &lt;T&gt;::decompose (scratch, precision, x))</span>
<span class="lineNum">    1014 </span><span class="lineCov">  842182179 : {</span>
<span class="lineNum">    1015 </span><span class="lineCov">  471253320 : }</span>
<span class="lineNum">    1016 </span><span class="lineCov"> 1514270810 : </span>
<span class="lineNum">    1017 </span><span class="lineCov">  415094146 : namespace wi</span>
<span class="lineNum">    1018 </span><span class="lineCov">    7504240 : {</span>
<span class="lineNum">    1019 </span><span class="lineCov"> 1939068039 :   template &lt;bool SE, bool HDP&gt;</span>
<span class="lineNum">    1020 </span><span class="lineCov"> 1350655087 :   struct int_traits &lt;wide_int_ref_storage &lt;SE, HDP&gt; &gt;</span>
<span class="lineNum">    1021 </span><span class="lineCov"> 1228261996 :   {</span>
<span class="lineNum">    1022 </span><span class="lineCov">  122394781 :     static const enum precision_type precision_type = VAR_PRECISION;</span>
<span class="lineNum">    1023 </span><span class="lineCov"> 3471456993 :     static const bool host_dependent_precision = HDP;</span>
<span class="lineNum">    1024 </span><span class="lineCov">  290774013 :     static const bool is_sign_extended = SE;</span>
<span class="lineNum">    1025 </span><span class="lineCov">   60104463 :   };</span>
<span class="lineNum">    1026 </span><span class="lineCov">    1191166 : }</span>
<span class="lineNum">    1027 </span><span class="lineCov"> 3590302422 : </span>
<span class="lineNum">    1028 </span><span class="lineCov"> 3382085231 : namespace wi</span>
<span class="lineNum">    1029 </span><span class="lineCov">    2658025 : {</span>
<span class="lineNum">    1030 </span><span class="lineCov">  303769713 :   unsigned int force_to_size (HOST_WIDE_INT *, const HOST_WIDE_INT *,</span>
<span class="lineNum">    1031 </span><span class="lineCov">  614704448 :                               unsigned int, unsigned int, unsigned int,</span>
<span class="lineNum">    1032 </span><span class="lineCov">  147874736 :                               signop sgn);</span>
<span class="lineNum">    1033 </span><span class="lineCov">    9377826 :   unsigned int from_array (HOST_WIDE_INT *, const HOST_WIDE_INT *,</span>
<span class="lineNum">    1034 </span><span class="lineCov"> 1003964733 :                            unsigned int, unsigned int, bool = true);</span>
<span class="lineNum">    1035 </span><span class="lineCov">    1187333 : }</span>
<span class="lineNum">    1036 </span>            : 
<span class="lineNum">    1037 </span><span class="lineCov">    9762191 : /* The storage used by wide_int.  */</span>
<span class="lineNum">    1038 </span><span class="lineCov">     294071 : class GTY(()) wide_int_storage</span>
<span class="lineNum">    1039 </span><span class="lineCov"> 3587598302 : {</span>
<span class="lineNum">    1040 </span><span class="lineCov">  186763288 : private:</span>
<span class="lineNum">    1041 </span><span class="lineCov"> 2002581365 :   HOST_WIDE_INT val[WIDE_INT_MAX_ELTS];</span>
<span class="lineNum">    1042 </span><span class="lineCov">  641844827 :   unsigned int len;</span>
<span class="lineNum">    1043 </span><span class="lineCov">  619940774 :   unsigned int precision;</span>
<span class="lineNum">    1044 </span><span class="lineCov"> 2129682086 : </span>
<span class="lineNum">    1045 </span><span class="lineCov"> 1498279652 : public:</span>
<span class="lineNum">    1046 </span><span class="lineCov">19025390228 :   wide_int_storage ();</span>
<span class="lineNum">    1047 </span><span class="lineCov">    7070675 :   template &lt;typename T&gt;</span>
<span class="lineNum">    1048 </span><span class="lineCov">    7891491 :   wide_int_storage (const T &amp;);</span>
<span class="lineNum">    1049 </span><span class="lineCov">  249700069 : </span>
<span class="lineNum">    1050 </span>            :   /* The standard generic_wide_int storage methods.  */
<span class="lineNum">    1051 </span><span class="lineCov"> 3676368298 :   unsigned int get_precision () const;</span>
<span class="lineNum">    1052 </span><span class="lineCov">   21015985 :   const HOST_WIDE_INT *get_val () const;</span>
<span class="lineNum">    1053 </span><span class="lineCov">   72859190 :   unsigned int get_len () const;</span>
<span class="lineNum">    1054 </span><span class="lineCov"> 3167854001 :   HOST_WIDE_INT *write_val ();</span>
<span class="lineNum">    1055 </span><span class="lineCov">   57258441 :   void set_len (unsigned int, bool = false);</span>
<span class="lineNum">    1056 </span><span class="lineCov">32963159759 : </span>
<span class="lineNum">    1057 </span>            :   template &lt;typename T&gt;
<span class="lineNum">    1058 </span><span class="lineCov">  384331517 :   wide_int_storage &amp;operator = (const T &amp;);</span>
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :   static wide_int from (const wide_int_ref &amp;, unsigned int, signop);</span>
<span class="lineNum">    1061 </span><span class="lineCov">   61919700 :   static wide_int from_array (const HOST_WIDE_INT *, unsigned int,</span>
<span class="lineNum">    1062 </span><span class="lineCov">   48608689 :                               unsigned int, bool = true);</span>
<span class="lineNum">    1063 </span><span class="lineCov">  244499439 :   static wide_int create (unsigned int);</span>
<span class="lineNum">    1064 </span><span class="lineCov">  111758278 : </span>
<span class="lineNum">    1065 </span><span class="lineCov">  881770007 :   /* FIXME: target-dependent, so should disappear.  */</span>
<span class="lineNum">    1066 </span><span class="lineCov">  127880585 :   wide_int bswap () const;</span>
<span class="lineNum">    1067 </span><span class="lineCov">  366563196 : };</span>
<span class="lineNum">    1068 </span><span class="lineCov">   32425215 : </span>
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 : namespace wi</span>
<span class="lineNum">    1070 </span><span class="lineCov"> 2883038549 : {</span>
<span class="lineNum">    1071 </span><span class="lineCov">   16163249 :   template &lt;&gt;</span>
<span class="lineNum">    1072 </span><span class="lineCov"> 2894772472 :   struct int_traits &lt;wide_int_storage&gt;</span>
<span class="lineNum">    1073 </span><span class="lineCov">  304157053 :   {</span>
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :     static const enum precision_type precision_type = VAR_PRECISION;</span>
<span class="lineNum">    1075 </span><span class="lineCov">  622160431 :     /* Guaranteed by a static assert in the wide_int_storage constructor.  */</span>
<span class="lineNum">    1076 </span><span class="lineCov">   85773930 :     static const bool host_dependent_precision = false;</span>
<span class="lineNum">    1077 </span><span class="lineCov"> 2469725089 :     static const bool is_sign_extended = true;</span>
<span class="lineNum">    1078 </span><span class="lineCov">  132054552 :     template &lt;typename T1, typename T2&gt;</span>
<span class="lineNum">    1079 </span><span class="lineCov">  611774486 :     static wide_int get_binary_result (const T1 &amp;, const T2 &amp;);</span>
<span class="lineNum">    1080 </span><span class="lineCov"> 7114081938 :   };</span>
<span class="lineNum">    1081 </span><span class="lineCov">  142675977 : }</span>
<span class="lineNum">    1082 </span><span class="lineCov">    1074108 : </span>
<span class="lineNum">    1083 </span><span class="lineCov">   34324342 : inline wide_int_storage::wide_int_storage () {}</span>
<span class="lineNum">    1084 </span><span class="lineCov">  844317073 : </span>
<span class="lineNum">    1085 </span><span class="lineCov">  431270543 : /* Initialize the storage from integer X, in its natural precision.</span>
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :    Note that we do not allow integers with host-dependent precision</span>
<span class="lineNum">    1087 </span><span class="lineCov"> 6675850549 :    to become wide_ints; wide_ints must always be logically independent</span>
<a name="1088"><span class="lineNum">    1088 </span><span class="lineCov">     945138 :    of the host.  */</span></a>
<span class="lineNum">    1089 </span><span class="lineCov"> 4407616268 : template &lt;typename T&gt;</span>
<span class="lineNum">    1090 </span><span class="lineCov">   24186932 : inline wide_int_storage::wide_int_storage (const T &amp;x)</span>
<span class="lineNum">    1091 </span><span class="lineCov">14747374887 : {</span>
<span class="lineNum">    1092 </span><span class="lineCov">     945138 :   { STATIC_ASSERT (!wi::int_traits&lt;T&gt;::host_dependent_precision); }</span>
<span class="lineNum">    1093 </span>            :   { STATIC_ASSERT (wi::int_traits&lt;T&gt;::precision_type != wi::CONST_PRECISION); }
<span class="lineNum">    1094 </span><span class="lineCov">   38242511 :   WIDE_INT_REF_FOR (T) xi (x);</span>
<span class="lineNum">    1095 </span><span class="lineCov">   14081199 :   precision = xi.precision;</span>
<span class="lineNum">    1096 </span><span class="lineCov">   28136778 :   wi::copy (*this, xi);</span>
<span class="lineNum">    1097 </span><span class="lineCov">  143804277 : }</span>
<span class="lineNum">    1098 </span>            : 
<a name="1099"><span class="lineNum">    1099 </span><span class="lineCov"> 2346429342 : template &lt;typename T&gt;</span></a>
<span class="lineNum">    1100 </span>            : inline wide_int_storage&amp;
<span class="lineNum">    1101 </span><span class="lineCov"> 5969999357 : wide_int_storage::operator = (const T &amp;x)</span>
<span class="lineNum">    1102 </span><span class="lineCov"> 1245830290 : {</span>
<span class="lineNum">    1103 </span>            :   { STATIC_ASSERT (!wi::int_traits&lt;T&gt;::host_dependent_precision); }
<span class="lineNum">    1104 </span><span class="lineCov"> 1332509466 :   { STATIC_ASSERT (wi::int_traits&lt;T&gt;::precision_type != wi::CONST_PRECISION); }</span>
<span class="lineNum">    1105 </span><span class="lineCov">       2940 :   WIDE_INT_REF_FOR (T) xi (x);</span>
<span class="lineNum">    1106 </span><span class="lineCov">       1470 :   precision = xi.precision;</span>
<span class="lineNum">    1107 </span><span class="lineCov">       2940 :   wi::copy (*this, xi);</span>
<span class="lineNum">    1108 </span><span class="lineCov">       3038 :   return *this;</span>
<span class="lineNum">    1109 </span><span class="lineCov">       1568 : }</span>
<a name="1110"><span class="lineNum">    1110 </span><span class="lineCov">       1568 : </span></a>
<span class="lineNum">    1111 </span><span class="lineCov">   65802753 : inline unsigned int</span>
<span class="lineNum">    1112 </span><span class="lineCov">  172687736 : wide_int_storage::get_precision () const</span>
<span class="lineNum">    1113 </span><span class="lineCov">  345442280 : {</span>
<span class="lineNum">    1114 </span><span class="lineCov">    1327795 :   return precision;</span>
<span class="lineNum">    1115 </span><span class="lineCov">     341096 : }</span>
<span class="lineNum">    1116 </span><span class="lineCov">     159330 : </span>
<span class="lineNum">    1117 </span><span class="lineCov">     318116 : inline const HOST_WIDE_INT *</span>
<span class="lineNum">    1118 </span><span class="lineCov">  196144225 : wide_int_storage::get_val () const</span>
<span class="lineNum">    1119 </span><span class="lineCov">     180872 : {</span>
<span class="lineNum">    1120 </span><span class="lineCov">   34391091 :   return val;</span>
<span class="lineNum">    1121 </span><span class="lineCov"> 1056997102 : }</span>
<a name="1122"><span class="lineNum">    1122 </span><span class="lineCov">  405833309 : </span></a>
<span class="lineNum">    1123 </span><span class="lineCov"> 4058784879 : inline unsigned int</span>
<span class="lineNum">    1124 </span><span class="lineCov">  391388979 : wide_int_storage::get_len () const</span>
<span class="lineNum">    1125 </span><span class="lineCov">  198600647 : {</span>
<span class="lineNum">    1126 </span><span class="lineCov">  208657372 :   return len;</span>
<span class="lineNum">    1127 </span><span class="lineCov">   25837401 : }</span>
<span class="lineNum">    1128 </span><span class="lineCov">   40168480 : </span>
<span class="lineNum">    1129 </span><span class="lineCov">   18162285 : inline HOST_WIDE_INT *</span>
<span class="lineNum">    1130 </span><span class="lineCov">   68185008 : wide_int_storage::write_val ()</span>
<span class="lineNum">    1131 </span><span class="lineCov">   34092504 : {</span>
<span class="lineNum">    1132 </span><span class="lineCov">  116453439 :   return val;</span>
<span class="lineNum">    1133 </span><span class="lineCov">   63617595 : }</span>
<span class="lineNum">    1134 </span><span class="lineCov">  167184717 : </span>
<span class="lineNum">    1135 </span><span class="lineCov">   26887279 : inline void</span>
<span class="lineNum">    1136 </span><span class="lineCov">    3751707 : wide_int_storage::set_len (unsigned int l, bool is_sign_extended)</span>
<span class="lineNum">    1137 </span><span class="lineCov">     151888 : {</span>
<span class="lineNum">    1138 </span><span class="lineCov">  371290006 :   len = l;</span>
<span class="lineNum">    1139 </span><span class="lineCov">  209779213 :   if (!is_sign_extended &amp;&amp; len * HOST_BITS_PER_WIDE_INT &gt; precision)</span>
<span class="lineNum">    1140 </span><span class="lineCov">  611036359 :     val[len - 1] = sext_hwi (val[len - 1],</span>
<span class="lineNum">    1141 </span><span class="lineCov">  172670493 :                              precision % HOST_BITS_PER_WIDE_INT);</span>
<span class="lineNum">    1142 </span><span class="lineCov">    2444953 : }</span>
<span class="lineNum">    1143 </span><span class="lineCov">   68729366 : </span>
<span class="lineNum">    1144 </span><span class="lineCov">  528513115 : /* Treat X as having signedness SGN and convert it to a PRECISION-bit</span>
<a name="1145"><span class="lineNum">    1145 </span><span class="lineCov">  348855807 :    number.  */</span></a>
<span class="lineNum">    1146 </span><span class="lineCov">  529086648 : inline wide_int</span>
<span class="lineNum">    1147 </span><span class="lineCov">  407173700 : wide_int_storage::from (const wide_int_ref &amp;x, unsigned int precision,</span>
<span class="lineNum">    1148 </span><span class="lineCov">  264070466 :                         signop sgn)</span>
<span class="lineNum">    1149 </span><span class="lineCov">  158068765 : {</span>
<span class="lineNum">    1150 </span><span class="lineCov">   79041289 :   wide_int result = wide_int::create (precision);</span>
<span class="lineNum">    1151 </span><span class="lineCov">  158774227 :   result.set_len (wi::force_to_size (result.write_val (), x.val, x.len,</span>
<span class="lineNum">    1152 </span><span class="lineCov">  728918194 :                                      x.precision, precision, sgn));</span>
<span class="lineNum">    1153 </span><span class="lineCov">  394448597 :   return result;</span>
<span class="lineNum">    1154 </span><span class="lineCov">  663191684 : }</span>
<span class="lineNum">    1155 </span><span class="lineCov">  263049386 : </span>
<span class="lineNum">    1156 </span><span class="lineCov">    2556611 : /* Create a wide_int from the explicit block encoding given by VAL and</span>
<span class="lineNum">    1157 </span><span class="lineCov">   24005556 :    LEN.  PRECISION is the precision of the integer.  NEED_CANON_P is</span>
<a name="1158"><span class="lineNum">    1158 </span><span class="lineCov">  107921328 :    true if the encoding may have redundant trailing blocks.  */</span></a>
<span class="lineNum">    1159 </span><span class="lineCov">  171365617 : inline wide_int</span>
<span class="lineNum">    1160 </span><span class="lineCov">  166310056 : wide_int_storage::from_array (const HOST_WIDE_INT *val, unsigned int len,</span>
<span class="lineNum">    1161 </span><span class="lineCov">   76655553 :                               unsigned int precision, bool need_canon_p)</span>
<span class="lineNum">    1162 </span><span class="lineCov">    2551323 : {</span>
<span class="lineNum">    1163 </span><span class="lineCov">   42786729 :   wide_int result = wide_int::create (precision);</span>
<span class="lineNum">    1164 </span><span class="lineCov">  169462096 :   result.set_len (wi::from_array (result.write_val (), val, len, precision,</span>
<span class="lineNum">    1165 </span><span class="lineCov">    2436617 :                                   need_canon_p));</span>
<span class="lineNum">    1166 </span><span class="lineCov">    8190277 :   return result;</span>
<span class="lineNum">    1167 </span><span class="lineCov">   10475625 : }</span>
<span class="lineNum">    1168 </span><span class="lineCov">   36741825 : </span>
<span class="lineNum">    1169 </span><span class="lineCov">   71172395 : /* Return an uninitialized wide_int with precision PRECISION.  */</span>
<span class="lineNum">    1170 </span><span class="lineCov">  159455242 : inline wide_int</span>
<span class="lineNum">    1171 </span><span class="lineCov">  846024620 : wide_int_storage::create (unsigned int precision)</span>
<span class="lineNum">    1172 </span><span class="lineCov">   35427755 : {</span>
<span class="lineNum">    1173 </span><span class="lineCov">  103548949 :   wide_int x;</span>
<span class="lineNum">    1174 </span><span class="lineCov">   67455738 :   x.precision = precision;</span>
<span class="lineNum">    1175 </span><span class="lineCov">   34513667 :   return x;</span>
<span class="lineNum">    1176 </span><span class="lineCov">  342889299 : }</span>
<span class="lineNum">    1177 </span><span class="lineCov">    1203556 : </span>
<a name="1178"><span class="lineNum">    1178 </span><span class="lineCov">  742024520 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    1179 </span><span class="lineCov">    4325835 : inline wide_int</span>
<span class="lineNum">    1180 </span><span class="lineCov">   34723268 : wi::int_traits &lt;wide_int_storage&gt;::get_binary_result (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    1181 </span><span class="lineCov">    2881080 : {</span>
<span class="lineNum">    1182 </span><span class="lineCov"> 1094496789 :   /* This shouldn't be used for two flexible-precision inputs.  */</span>
<span class="lineNum">    1183 </span><span class="lineCov"> 1083708955 :   STATIC_ASSERT (wi::int_traits &lt;T1&gt;::precision_type != FLEXIBLE_PRECISION</span>
<span class="lineNum">    1184 </span><span class="lineCov"> 1352914111 :                  || wi::int_traits &lt;T2&gt;::precision_type != FLEXIBLE_PRECISION);</span>
<span class="lineNum">    1185 </span><span class="lineCov">   15440654 :   if (wi::int_traits &lt;T1&gt;::precision_type == FLEXIBLE_PRECISION)</span>
<span class="lineNum">    1186 </span><span class="lineCov">   35747969 :     return wide_int::create (wi::get_precision (y));</span>
<span class="lineNum">    1187 </span><span class="lineCov">    5604306 :   else</span>
<span class="lineNum">    1188 </span><span class="lineCov">  100958450 :     return wide_int::create (wi::get_precision (x));</span>
<span class="lineNum">    1189 </span><span class="lineCov">    1274303 : }</span>
<span class="lineNum">    1190 </span><span class="lineCov">  607836621 : </span>
<span class="lineNum">    1191 </span><span class="lineCov">     487991 : /* The storage used by FIXED_WIDE_INT (N).  */</span>
<span class="lineNum">    1192 </span><span class="lineCov"> 3984312643 : template &lt;int N&gt;</span>
<span class="lineNum">    1193 </span><span class="lineCov">  285502574 : class GTY(()) fixed_wide_int_storage</span>
<span class="lineNum">    1194 </span><span class="lineCov">  488040745 : {</span>
<span class="lineNum">    1195 </span><span class="lineCov">  176748457 : private:</span>
<span class="lineNum">    1196 </span><span class="lineCov">  319366793 :   HOST_WIDE_INT val[(N + HOST_BITS_PER_WIDE_INT + 1) / HOST_BITS_PER_WIDE_INT];</span>
<span class="lineNum">    1197 </span><span class="lineCov">     310586 :   unsigned int len;</span>
<span class="lineNum">    1198 </span><span class="lineCov"> 2265836690 : </span>
<span class="lineNum">    1199 </span><span class="lineCov">     366489 : public:</span>
<span class="lineNum">    1200 </span><span class="lineCov">  308238599 :   fixed_wide_int_storage ();</span>
<span class="lineNum">    1201 </span><span class="lineCov">  101417556 :   template &lt;typename T&gt;</span>
<span class="lineNum">    1202 </span><span class="lineCov">  340043603 :   fixed_wide_int_storage (const T &amp;);</span>
<span class="lineNum">    1203 </span><span class="lineCov">  295650811 : </span>
<span class="lineNum">    1204 </span><span class="lineCov"> 3005315871 :   /* The standard generic_wide_int storage methods.  */</span>
<span class="lineNum">    1205 </span><span class="lineCov">  177191737 :   unsigned int get_precision () const;</span>
<span class="lineNum">    1206 </span><span class="lineCov">  404593989 :   const HOST_WIDE_INT *get_val () const;</span>
<span class="lineNum">    1207 </span><span class="lineCov">  174044211 :   unsigned int get_len () const;</span>
<span class="lineNum">    1208 </span><span class="lineCov">       1500 :   HOST_WIDE_INT *write_val ();</span>
<span class="lineNum">    1209 </span><span class="lineCov">  410895992 :   void set_len (unsigned int, bool = false);</span>
<span class="lineNum">    1210 </span><span class="lineCov"> 3250584520 : </span>
<span class="lineNum">    1211 </span><span class="lineCov">  266902522 :   static FIXED_WIDE_INT (N) from (const wide_int_ref &amp;, signop);</span>
<span class="lineNum">    1212 </span><span class="lineCov">  180464881 :   static FIXED_WIDE_INT (N) from_array (const HOST_WIDE_INT *, unsigned int,</span>
<span class="lineNum">    1213 </span><span class="lineCov">  146439893 :                                         bool = true);</span>
<span class="lineNum">    1214 </span><span class="lineCov">   47313113 : };</span>
<span class="lineNum">    1215 </span><span class="lineCov">   15614624 : </span>
<span class="lineNum">    1216 </span><span class="lineCov"> 6290196880 : namespace wi</span>
<span class="lineNum">    1217 </span><span class="lineCov"> 4641607729 : {</span>
<span class="lineNum">    1218 </span><span class="lineCov"> 3176619255 :   template &lt;int N&gt;</span>
<span class="lineNum">    1219 </span><span class="lineCov">  145032275 :   struct int_traits &lt; fixed_wide_int_storage &lt;N&gt; &gt;</span>
<span class="lineNum">    1220 </span><span class="lineCov">    1928873 :   {</span>
<span class="lineNum">    1221 </span><span class="lineCov">    5015088 :     static const enum precision_type precision_type = CONST_PRECISION;</span>
<span class="lineNum">    1222 </span><span class="lineCov">  301426632 :     static const bool host_dependent_precision = false;</span>
<span class="lineNum">    1223 </span><span class="lineCov">  301066887 :     static const bool is_sign_extended = true;</span>
<span class="lineNum">    1224 </span><span class="lineCov">   79288107 :     static const unsigned int precision = N;</span>
<span class="lineNum">    1225 </span><span class="lineCov"> 2339442594 :     template &lt;typename T1, typename T2&gt;</span>
<span class="lineNum">    1226 </span><span class="lineCov">  436612910 :     static FIXED_WIDE_INT (N) get_binary_result (const T1 &amp;, const T2 &amp;);</span>
<span class="lineNum">    1227 </span><span class="lineCov">   33358320 :   };</span>
<span class="lineNum">    1228 </span><span class="lineCov"> 4487195450 : }</span>
<span class="lineNum">    1229 </span><span class="lineCov"> 2243597725 : </span>
<span class="lineNum">    1230 </span><span class="lineCov"> 2243599293 : template &lt;int N&gt;</span>
<span class="lineNum">    1231 </span><span class="lineCov"> 6625741863 : inline fixed_wide_int_storage &lt;N&gt;::fixed_wide_int_storage () {}</span>
<span class="lineNum">    1232 </span><span class="lineCov"> 2505513239 : </span>
<span class="lineNum">    1233 </span><span class="lineCov">   72934933 : /* Initialize the storage from integer X, in precision N.  */</span>
<a name="1234"><span class="lineNum">    1234 </span><span class="lineCov">   22614708 : template &lt;int N&gt;</span></a>
<span class="lineNum">    1235 </span><span class="lineCov">  127697752 : template &lt;typename T&gt;</span>
<span class="lineNum">    1236 </span><span class="lineCov">  133553677 : inline fixed_wide_int_storage &lt;N&gt;::fixed_wide_int_storage (const T &amp;x)</span>
<span class="lineNum">    1237 </span><span class="lineCov"> 1201911578 : {</span>
<span class="lineNum">    1238 </span><span class="lineCov"> 2582048401 :   /* Check for type compatibility.  We don't want to initialize a</span>
<span class="lineNum">    1239 </span><span class="lineCov">   43032078 :      fixed-width integer from something like a wide_int.  */</span>
<span class="lineNum">    1240 </span><span class="lineCov">   87338007 :   WI_BINARY_RESULT (T, FIXED_WIDE_INT (N)) *assertion ATTRIBUTE_UNUSED;</span>
<span class="lineNum">    1241 </span><span class="lineCov">   78461457 :   wi::copy (*this, WIDE_INT_REF_FOR (T) (x, N));</span>
<span class="lineNum">    1242 </span><span class="lineCov">    9285060 : }</span>
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 : </span>
<a name="1244"><span class="lineNum">    1244 </span><span class="lineCov"> 1980487532 : template &lt;int N&gt;</span></a>
<span class="lineNum">    1245 </span><span class="lineCov"> 2023368889 : inline unsigned int</span>
<span class="lineNum">    1246 </span><span class="lineCov">  425734135 : fixed_wide_int_storage &lt;N&gt;::get_precision () const</span>
<span class="lineNum">    1247 </span><span class="lineCov">  261674091 : {</span>
<span class="lineNum">    1248 </span><span class="lineCov">  537973532 :   return N;</span>
<span class="lineNum">    1249 </span><span class="lineCov">   13486197 : }</span>
<span class="lineNum">    1250 </span><span class="lineCov">  353370158 : </span>
<span class="lineNum">    1251 </span><span class="lineCov">11307058786 : template &lt;int N&gt;</span>
<span class="lineNum">    1252 </span><span class="lineCov"> 7335962752 : inline const HOST_WIDE_INT *</span>
<span class="lineNum">    1253 </span><span class="lineCov"> 2605120179 : fixed_wide_int_storage &lt;N&gt;::get_val () const</span>
<span class="lineNum">    1254 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">    1255 </span><span class="lineCov">   75352868 :   return val;</span>
<span class="lineNum">    1256 </span><span class="lineCov">  723448006 : }</span>
<span class="lineNum">    1257 </span><span class="lineCov">  448503121 : </span>
<a name="1258"><span class="lineNum">    1258 </span><span class="lineCov">  396706215 : template &lt;int N&gt;</span></a>
<span class="lineNum">    1259 </span><span class="lineCov">  588598690 : inline unsigned int</span>
<span class="lineNum">    1260 </span><span class="lineCov">  109865886 : fixed_wide_int_storage &lt;N&gt;::get_len () const</span>
<span class="lineNum">    1261 </span><span class="lineCov">   27464074 : {</span>
<span class="lineNum">    1262 </span><span class="lineCov">  373258749 :   return len;</span>
<span class="lineNum">    1263 </span><span class="lineCov">    9648740 : }</span>
<span class="lineNum">    1264 </span><span class="lineCov">     435417 : </span>
<span class="lineNum">    1265 </span><span class="lineNoCov">          0 : template &lt;int N&gt;</span>
<span class="lineNum">    1266 </span><span class="lineCov">10198190084 : inline HOST_WIDE_INT *</span>
<span class="lineNum">    1267 </span><span class="lineCov">    1032570 : fixed_wide_int_storage &lt;N&gt;::write_val ()</span>
<span class="lineNum">    1268 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">    1269 </span><span class="lineCov">  369828717 :   return val;</span>
<span class="lineNum">    1270 </span><span class="lineCov">    3058599 : }</span>
<span class="lineNum">    1271 </span><span class="lineCov">      14369 : </span>
<span class="lineNum">    1272 </span><span class="lineCov">   60944726 : template &lt;int N&gt;</span>
<span class="lineNum">    1273 </span><span class="lineCov">     329495 : inline void</span>
<span class="lineNum">    1274 </span><span class="lineCov"> 4868797782 : fixed_wide_int_storage &lt;N&gt;::set_len (unsigned int l, bool)</span>
<span class="lineNum">    1275 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">    1276 </span><span class="lineCov">   53143299 :   len = l;</span>
<span class="lineNum">    1277 </span><span class="lineCov">      14369 :   /* There are no excess bits in val[len - 1].  */</span>
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :   STATIC_ASSERT (N % HOST_BITS_PER_WIDE_INT == 0);</span>
<span class="lineNum">    1279 </span><span class="lineCov"> 8402146868 : }</span>
<span class="lineNum">    1280 </span><span class="lineCov"> 1739317890 : </span>
<span class="lineNum">    1281 </span><span class="lineCov">  361569993 : /* Treat X as having signedness SGN and convert it to an N-bit number.  */</span>
<a name="1282"><span class="lineNum">    1282 </span><span class="lineCov">   10857250 : template &lt;int N&gt;</span></a>
<span class="lineNum">    1283 </span><span class="lineCov"> 2281189296 : inline FIXED_WIDE_INT (N)</span>
<span class="lineNum">    1284 </span><span class="lineCov"> 1878413334 : fixed_wide_int_storage &lt;N&gt;::from (const wide_int_ref &amp;x, signop sgn)</span>
<span class="lineNum">    1285 </span><span class="lineCov">  740322530 : {</span>
<span class="lineNum">    1286 </span><span class="lineCov">  404906795 :   FIXED_WIDE_INT (N) result;</span>
<span class="lineNum">    1287 </span><span class="lineCov">    3777230 :   result.set_len (wi::force_to_size (result.write_val (), x.val, x.len,</span>
<span class="lineNum">    1288 </span><span class="lineNoCov">          0 :                                      x.precision, N, sgn));</span>
<span class="lineNum">    1289 </span><span class="lineCov">    8239570 :   return result;</span>
<span class="lineNum">    1290 </span><span class="lineCov">   51116846 : }</span>
<span class="lineNum">    1291 </span><span class="lineCov">   13435335 : </span>
<span class="lineNum">    1292 </span><span class="lineCov">   49327272 : /* Create a FIXED_WIDE_INT (N) from the explicit block encoding given by</span>
<span class="lineNum">    1293 </span><span class="lineCov">  141212433 :    VAL and LEN.  NEED_CANON_P is true if the encoding may have redundant</span>
<span class="lineNum">    1294 </span><span class="lineCov"> 4785919734 :    trailing blocks.  */</span>
<span class="lineNum">    1295 </span><span class="lineNoCov">          0 : template &lt;int N&gt;</span>
<span class="lineNum">    1296 </span><span class="lineCov">      21710 : inline FIXED_WIDE_INT (N)</span>
<span class="lineNum">    1297 </span><span class="lineCov">   40751709 : fixed_wide_int_storage &lt;N&gt;::from_array (const HOST_WIDE_INT *val,</span>
<span class="lineNum">    1298 </span><span class="lineCov">14065797147 :                                         unsigned int len,</span>
<span class="lineNum">    1299 </span><span class="lineCov">   20376464 :                                         bool need_canon_p)</span>
<span class="lineNum">    1300 </span><span class="lineCov">   50371374 : {</span>
<span class="lineNum">    1301 </span><span class="lineCov">  466750992 :   FIXED_WIDE_INT (N) result;</span>
<span class="lineNum">    1302 </span><span class="lineCov">     320866 :   result.set_len (wi::from_array (result.write_val (), val, len,</span>
<span class="lineNum">    1303 </span><span class="lineCov">   31489587 :                                   N, need_canon_p));</span>
<span class="lineNum">    1304 </span><span class="lineCov">    3635765 :   return result;</span>
<span class="lineNum">    1305 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1306 </span><span class="lineCov">    9699135 : </span>
<span class="lineNum">    1307 </span><span class="lineCov">   30823211 : template &lt;int N&gt;</span>
<a name="1308"><span class="lineNum">    1308 </span><span class="lineCov">    6373203 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    1309 </span><span class="lineCov">        801 : inline FIXED_WIDE_INT (N)</span>
<span class="lineNum">    1310 </span><span class="lineCov">        801 : wi::int_traits &lt; fixed_wide_int_storage &lt;N&gt; &gt;::</span>
<span class="lineNum">    1311 </span><span class="lineCov">      33563 : get_binary_result (const T1 &amp;, const T2 &amp;)</span>
<span class="lineNum">    1312 </span><span class="lineCov"> 3770427803 : {</span>
<span class="lineNum">    1313 </span><span class="lineCov">  639188842 :   return FIXED_WIDE_INT (N) ();</span>
<span class="lineNum">    1314 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1315 </span><span class="lineCov">   55803830 : </span>
<span class="lineNum">    1316 </span><span class="lineCov">   26191187 : /* A reference to one element of a trailing_wide_ints structure.  */</span>
<span class="lineNum">    1317 </span><span class="lineCov">  230848809 : class trailing_wide_int_storage</span>
<span class="lineNum">    1318 </span><span class="lineCov">       3119 : {</span>
<span class="lineNum">    1319 </span><span class="lineCov"> 8329944474 : private:</span>
<span class="lineNum">    1320 </span><span class="lineCov">    3742243 :   /* The precision of the integer, which is a fixed property of the</span>
<span class="lineNum">    1321 </span><span class="lineNoCov">          0 :      parent trailing_wide_ints.  */</span>
<span class="lineNum">    1322 </span><span class="lineCov">  296787507 :   unsigned int m_precision;</span>
<span class="lineNum">    1323 </span><span class="lineCov">    4711729 : </span>
<span class="lineNum">    1324 </span><span class="lineCov">   25829765 :   /* A pointer to the length field.  */</span>
<span class="lineNum">    1325 </span><span class="lineCov">    1922090 :   unsigned char *m_len;</span>
<span class="lineNum">    1326 </span><span class="lineCov">     644966 : </span>
<span class="lineNum">    1327 </span><span class="lineCov">  179514805 :   /* A pointer to the HWI array.  There are enough elements to hold all</span>
<span class="lineNum">    1328 </span><span class="lineCov">    5916571 :      values of precision M_PRECISION.  */</span>
<span class="lineNum">    1329 </span><span class="lineCov">   97761654 :   HOST_WIDE_INT *m_val;</span>
<span class="lineNum">    1330 </span><span class="lineCov">   48924836 : </span>
<span class="lineNum">    1331 </span><span class="lineCov">   27149771 : public:</span>
<span class="lineNum">    1332 </span><span class="lineCov">        219 :   trailing_wide_int_storage (unsigned int, unsigned char *, HOST_WIDE_INT *);</span>
<span class="lineNum">    1333 </span><span class="lineCov">        132 : </span>
<span class="lineNum">    1334 </span><span class="lineCov">  406080251 :   /* The standard generic_wide_int storage methods.  */</span>
<span class="lineNum">    1335 </span><span class="lineCov">   22426249 :   unsigned int get_len () const;</span>
<span class="lineNum">    1336 </span><span class="lineCov">   61591412 :   unsigned int get_precision () const;</span>
<span class="lineNum">    1337 </span><span class="lineCov">       1017 :   const HOST_WIDE_INT *get_val () const;</span>
<span class="lineNum">    1338 </span><span class="lineCov">  158774965 :   HOST_WIDE_INT *write_val ();</span>
<span class="lineNum">    1339 </span><span class="lineCov">    1069623 :   void set_len (unsigned int, bool = false);</span>
<span class="lineNum">    1340 </span><span class="lineCov">    9695520 : </span>
<span class="lineNum">    1341 </span><span class="lineCov">   41816287 :   template &lt;typename T&gt;</span>
<span class="lineNum">    1342 </span><span class="lineCov">   17938414 :   trailing_wide_int_storage &amp;operator = (const T &amp;);</span>
<span class="lineNum">    1343 </span><span class="lineNoCov">          0 : };</span>
<span class="lineNum">    1344 </span><span class="lineCov">  730681659 : </span>
<span class="lineNum">    1345 </span><span class="lineCov">   24164624 : typedef generic_wide_int &lt;trailing_wide_int_storage&gt; trailing_wide_int;</span>
<span class="lineNum">    1346 </span><span class="lineCov">      56695 : </span>
<span class="lineNum">    1347 </span><span class="lineNoCov">          0 : /* trailing_wide_int behaves like a wide_int.  */</span>
<span class="lineNum">    1348 </span><span class="lineCov">   14715682 : namespace wi</span>
<span class="lineNum">    1349 </span><span class="lineCov">    7343472 : {</span>
<span class="lineNum">    1350 </span><span class="lineCov">    7343472 :   template &lt;&gt;</span>
<span class="lineNum">    1351 </span><span class="lineCov">   59445912 :   struct int_traits &lt;trailing_wide_int_storage&gt;</span>
<span class="lineNum">    1352 </span><span class="lineCov">  469003663 :     : public int_traits &lt;wide_int_storage&gt; {};</span>
<span class="lineNum">    1353 </span><span class="lineCov">    2651201 : }</span>
<span class="lineNum">    1354 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    1355 </span><span class="lineCov">  622500228 : /* An array of N wide_int-like objects that can be put at the end of</span>
<span class="lineNum">    1356 </span><span class="lineCov">11737197960 :    a variable-sized structure.  Use extra_size to calculate how many</span>
<span class="lineNum">    1357 </span><span class="lineCov">   38109970 :    bytes beyond the sizeof need to be allocated.  Use set_precision</span>
<span class="lineNum">    1358 </span><span class="lineNoCov">          0 :    to initialize the structure.  */</span>
<span class="lineNum">    1359 </span><span class="lineCov">  839256259 : template &lt;int N&gt;</span>
<span class="lineNum">    1360 </span><span class="lineCov">  500926044 : class GTY((user)) trailing_wide_ints</span>
<span class="lineNum">    1361 </span><span class="lineCov">   74231057 : {</span>
<span class="lineNum">    1362 </span><span class="lineCov">    5117791 : private:</span>
<span class="lineNum">    1363 </span><span class="lineNoCov">          0 :   /* The shared precision of each number.  */</span>
<span class="lineNum">    1364 </span><span class="lineCov">    7872134 :   unsigned short m_precision;</span>
<span class="lineNum">    1365 </span><span class="lineCov">   93598457 : </span>
<span class="lineNum">    1366 </span><span class="lineCov">  143051275 :   /* The shared maximum length of each number.  */</span>
<span class="lineNum">    1367 </span><span class="lineCov">   32789736 :   unsigned char m_max_len;</span>
<span class="lineNum">    1368 </span><span class="lineCov">    2856304 : </span>
<span class="lineNum">    1369 </span><span class="lineCov">    2506755 :   /* The current length of each number.  */</span>
<span class="lineNum">    1370 </span><span class="lineNoCov">          0 :   unsigned char m_len[N];</span>
<span class="lineNum">    1371 </span><span class="lineCov">  550823338 : </span>
<span class="lineNum">    1372 </span><span class="lineCov">    9470396 :   /* The variable-length part of the structure, which always contains</span>
<span class="lineNum">    1373 </span><span class="lineCov">      41103 :      at least one HWI.  Element I starts at index I * M_MAX_LEN.  */</span>
<span class="lineNum">    1374 </span><span class="lineCov">    6512292 :   HOST_WIDE_INT m_val[1];</span>
<span class="lineNum">    1375 </span><span class="lineCov">  273750880 : </span>
<span class="lineNum">    1376 </span><span class="lineNoCov">          0 : public:</span>
<span class="lineNum">    1377 </span><span class="lineCov">      22105 :   typedef WIDE_INT_REF_FOR (trailing_wide_int_storage) const_reference;</span>
<span class="lineNum">    1378 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    1379 </span><span class="lineCov">    4596630 :   void set_precision (unsigned int);</span>
<span class="lineNum">    1380 </span><span class="lineCov">    3180124 :   unsigned int get_precision () const { return m_precision; }</span>
<span class="lineNum">    1381 </span><span class="lineCov">  495006742 :   trailing_wide_int operator [] (unsigned int);</span>
<span class="lineNum">    1382 </span><span class="lineCov">   73282237 :   const_reference operator [] (unsigned int) const;</span>
<span class="lineNum">    1383 </span><span class="lineCov">   46004717 :   static size_t extra_size (unsigned int);</span>
<span class="lineNum">    1384 </span><span class="lineCov">     127092 :   size_t extra_size () const { return extra_size (m_precision); }</span>
<span class="lineNum">    1385 </span><span class="lineCov">      63546 : };</span>
<span class="lineNum">    1386 </span><span class="lineCov">     847792 : </span>
<span class="lineNum">    1387 </span><span class="lineCov"> 2242007170 : inline trailing_wide_int_storage::</span>
<span class="lineNum">    1388 </span><span class="lineCov">    3293607 : trailing_wide_int_storage (unsigned int precision, unsigned char *len,</span>
<span class="lineNum">    1389 </span><span class="lineCov">       1582 :                            HOST_WIDE_INT *val)</span>
<span class="lineNum">    1390 </span><span class="lineNoCov">          0 :   : m_precision (precision), m_len (len), m_val (val)</span>
<span class="lineNum">    1391 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">    1392 </span><span class="lineCov">      25632 : }</span>
<a name="1393"><span class="lineNum">    1393 </span><span class="lineCov">    2341060 : </span></a>
<span class="lineNum">    1394 </span><span class="lineCov">   89630480 : inline unsigned int</span>
<span class="lineNum">    1395 </span><span class="lineCov">    9617594 : trailing_wide_int_storage::get_len () const</span>
<span class="lineNum">    1396 </span><span class="lineCov">     107560 : {</span>
<span class="lineNum">    1397 </span><span class="lineNoCov">          0 :   return *m_len;</span>
<span class="lineNum">    1398 </span><span class="lineNoCov">          0 : }</span>
<a name="1399"><span class="lineNum">    1399 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">    1400 </span><span class="lineNoCov">          0 : inline unsigned int</span>
<span class="lineNum">    1401 </span><span class="lineCov">         53 : trailing_wide_int_storage::get_precision () const</span>
<span class="lineNum">    1402 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">    1403 </span><span class="lineCov">   76167068 :   return m_precision;</span>
<span class="lineNum">    1404 </span><span class="lineNoCov">          0 : }</span>
<a name="1405"><span class="lineNum">    1405 </span><span class="lineCov">    6746925 : </span></a>
<span class="lineNum">    1406 </span><span class="lineCov">     289786 : inline const HOST_WIDE_INT *</span>
<span class="lineNum">    1407 </span><span class="lineNoCov">          0 : trailing_wide_int_storage::get_val () const</span>
<span class="lineNum">    1408 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">    1409 </span><span class="lineCov"> 1357194513 :   return m_val;</span>
<span class="lineNum">    1410 </span><span class="lineCov">      82206 : }</span>
<a name="1411"><span class="lineNum">    1411 </span><span class="lineCov">    4515790 : </span></a>
<span class="lineNum">    1412 </span><span class="lineCov">   21540071 : inline HOST_WIDE_INT *</span>
<span class="lineNum">    1413 </span><span class="lineNoCov">          0 : trailing_wide_int_storage::write_val ()</span>
<span class="lineNum">    1414 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">    1415 </span><span class="lineCov">      11454 :   return m_val;</span>
<span class="lineNum">    1416 </span><span class="lineCov"> 1283612521 : }</span>
<span class="lineNum">    1417 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    1418 </span><span class="lineNoCov">          0 : inline void</span>
<span class="lineNum">    1419 </span><span class="lineCov">  127715000 : trailing_wide_int_storage::set_len (unsigned int len, bool is_sign_extended)</span>
<span class="lineNum">    1420 </span><span class="lineCov">    2561504 : {</span>
<span class="lineNum">    1421 </span><span class="lineNoCov">          0 :   *m_len = len;</span>
<span class="lineNum">    1422 </span><span class="lineCov">   10346332 :   if (!is_sign_extended &amp;&amp; len * HOST_BITS_PER_WIDE_INT &gt; m_precision)</span>
<span class="lineNum">    1423 </span><span class="lineCov">    5173166 :     m_val[len - 1] = sext_hwi (m_val[len - 1],</span>
<span class="lineNum">    1424 </span><span class="lineNoCov">          0 :                                m_precision % HOST_BITS_PER_WIDE_INT);</span>
<span class="lineNum">    1425 </span><span class="lineCov">     512200 : }</span>
<span class="lineNum">    1426 </span><span class="lineCov">   23875582 : </span>
<a name="1427"><span class="lineNum">    1427 </span><span class="lineCov">   11681691 : template &lt;typename T&gt;</span></a>
<span class="lineNum">    1428 </span><span class="lineNoCov">          0 : inline trailing_wide_int_storage &amp;</span>
<span class="lineNum">    1429 </span><span class="lineNoCov">          0 : trailing_wide_int_storage::operator = (const T &amp;x)</span>
<span class="lineNum">    1430 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">    1431 </span><span class="lineCov">   72591512 :   WIDE_INT_REF_FOR (T) xi (x, m_precision);</span>
<span class="lineNum">    1432 </span><span class="lineCov">   20436648 :   wi::copy (*this, xi);</span>
<span class="lineNum">    1433 </span><span class="lineNoCov">          0 :   return *this;</span>
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1435 </span>            : 
<span class="lineNum">    1436 </span><span class="lineNoCov">          0 : /* Initialize the structure and record that all elements have precision</span>
<span class="lineNum">    1437 </span><span class="lineCov">      75286 :    PRECISION.  */</span>
<a name="1438"><span class="lineNum">    1438 </span><span class="lineCov">  340401890 : template &lt;int N&gt;</span></a>
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 : inline void</span>
<span class="lineNum">    1440 </span><span class="lineNoCov">          0 : trailing_wide_ints &lt;N&gt;::set_precision (unsigned int precision)</span>
<span class="lineNum">    1441 </span><span class="lineCov">   28625049 : {</span>
<span class="lineNum">    1442 </span><span class="lineNoCov">          0 :   m_precision = precision;</span>
<span class="lineNum">    1443 </span>            :   m_max_len = ((precision + HOST_BITS_PER_WIDE_INT - 1)
<span class="lineNum">    1444 </span><span class="lineNoCov">          0 :                / HOST_BITS_PER_WIDE_INT);</span>
<span class="lineNum">    1445 </span><span class="lineCov">    3180124 : }</span>
<span class="lineNum">    1446 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    1447 </span><span class="lineCov">    1653234 : /* Return a reference to element INDEX.  */</span>
<span class="lineNum">    1448 </span><span class="lineNoCov">          0 : template &lt;int N&gt;</span>
<span class="lineNum">    1449 </span><span class="lineCov">   56380262 : inline trailing_wide_int</span>
<span class="lineNum">    1450 </span><span class="lineNoCov">          0 : trailing_wide_ints &lt;N&gt;::operator [] (unsigned int index)</span>
<span class="lineNum">    1451 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">    1452 </span><span class="lineCov">  110504216 :   return trailing_wide_int_storage (m_precision, &amp;m_len[index],</span>
<span class="lineNum">    1453 </span><span class="lineCov"> 3177917062 :                                     &amp;m_val[index * m_max_len]);</span>
<span class="lineNum">    1454 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1455 </span><span class="lineCov">         10 : </span>
<span class="lineNum">    1456 </span><span class="lineNoCov">          0 : template &lt;int N&gt;</span>
<span class="lineNum">    1457 </span><span class="lineNoCov">          0 : inline typename trailing_wide_ints &lt;N&gt;::const_reference</span>
<span class="lineNum">    1458 </span><span class="lineNoCov">          0 : trailing_wide_ints &lt;N&gt;::operator [] (unsigned int index) const</span>
<span class="lineNum">    1459 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">    1460 </span><span class="lineNoCov">          0 :   return wi::storage_ref (&amp;m_val[index * m_max_len],</span>
<span class="lineNum">    1461 </span><span class="lineCov">    2561000 :                           m_len[index], m_precision);</span>
<span class="lineNum">    1462 </span><span class="lineCov">         63 : }</span>
<span class="lineNum">    1463 </span><span class="lineCov">  833742759 : </span>
<span class="lineNum">    1464 </span><span class="lineNoCov">          0 : /* Return how many extra bytes need to be added to the end of the structure</span>
<span class="lineNum">    1465 </span><span class="lineNoCov">          0 :    in order to handle N wide_ints of precision PRECISION.  */</span>
<span class="lineNum">    1466 </span><span class="lineCov">      57191 : template &lt;int N&gt;</span>
<span class="lineNum">    1467 </span>            : inline size_t
<span class="lineNum">    1468 </span><span class="lineCov">    3627115 : trailing_wide_ints &lt;N&gt;::extra_size (unsigned int precision)</span>
<span class="lineNum">    1469 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">    1470 </span><span class="lineCov">  881918200 :   unsigned int max_len = ((precision + HOST_BITS_PER_WIDE_INT - 1)</span>
<span class="lineNum">    1471 </span><span class="lineNoCov">          0 :                           / HOST_BITS_PER_WIDE_INT);</span>
<span class="lineNum">    1472 </span><span class="lineNoCov">          0 :   return (N * max_len - 1) * sizeof (HOST_WIDE_INT);</span>
<span class="lineNum">    1473 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1474 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    1475 </span><span class="lineCov">  544281254 : /* This macro is used in structures that end with a trailing_wide_ints field</span>
<span class="lineNum">    1476 </span><span class="lineNoCov">          0 :    called FIELD.  It declares get_NAME() and set_NAME() methods to access</span>
<span class="lineNum">    1477 </span><span class="lineCov">     339051 :    element I of FIELD.  */</span>
<span class="lineNum">    1478 </span><span class="lineNoCov">          0 : #define TRAILING_WIDE_INT_ACCESSOR(NAME, FIELD, I) \</span>
<span class="lineNum">    1479 </span><span class="lineNoCov">          0 :   trailing_wide_int get_##NAME () { return FIELD[I]; } \</span>
<span class="lineNum">    1480 </span><span class="lineCov"> 1677791916 :   template &lt;typename T&gt; void set_##NAME (const T &amp;x) { FIELD[I] = x; }</span>
<span class="lineNum">    1481 </span><span class="lineCov">  838895958 : </span>
<span class="lineNum">    1482 </span><span class="lineCov">  839843904 : namespace wi</span>
<span class="lineNum">    1483 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">    1484 </span><span class="lineNoCov">          0 :   /* Implementation of int_traits for primitive integer types like &quot;int&quot;.  */</span>
<span class="lineNum">    1485 </span><span class="lineNoCov">          0 :   template &lt;typename T, bool signed_p&gt;</span>
<span class="lineNum">    1486 </span><span class="lineNoCov">          0 :   struct primitive_int_traits</span>
<span class="lineNum">    1487 </span><span class="lineCov">     608895 :   {</span>
<span class="lineNum">    1488 </span><span class="lineCov">     608895 :     static const enum precision_type precision_type = FLEXIBLE_PRECISION;</span>
<span class="lineNum">    1489 </span><span class="lineCov">  216055002 :     static const bool host_dependent_precision = true;</span>
<span class="lineNum">    1490 </span><span class="lineNoCov">          0 :     static const bool is_sign_extended = true;</span>
<span class="lineNum">    1491 </span><span class="lineNoCov">          0 :     static unsigned int get_precision (T);</span>
<span class="lineNum">    1492 </span><span class="lineNoCov">          0 :     static wi::storage_ref decompose (HOST_WIDE_INT *, unsigned int, T);</span>
<span class="lineNum">    1493 </span><span class="lineNoCov">          0 :   };</span>
<span class="lineNum">    1494 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1495 </span><span class="lineNoCov">          0 : </span>
<a name="1496"><span class="lineNum">    1496 </span><span class="lineNoCov">          0 : template &lt;typename T, bool signed_p&gt;</span></a>
<span class="lineNum">    1497 </span><span class="lineNoCov">          0 : inline unsigned int</span>
<span class="lineNum">    1498 </span><span class="lineNoCov">          0 : wi::primitive_int_traits &lt;T, signed_p&gt;::get_precision (T)</span>
<span class="lineNum">    1499 </span><span class="lineCov">        116 : {</span>
<span class="lineNum">    1500 </span><span class="lineNoCov">          0 :   return sizeof (T) * CHAR_BIT;</span>
<span class="lineNum">    1501 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1502 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    1503 </span><span class="lineCov">     263736 : template &lt;typename T, bool signed_p&gt;</span>
<span class="lineNum">    1504 </span><span class="lineNoCov">          0 : inline wi::storage_ref</span>
<span class="lineNum">    1505 </span><span class="lineCov">    2281688 : wi::primitive_int_traits &lt;T, signed_p&gt;::decompose (HOST_WIDE_INT *scratch,</span>
<span class="lineNum">    1506 </span><span class="lineNoCov">          0 :                                                    unsigned int precision, T x)</span>
<span class="lineNum">    1507 </span><span class="lineCov"> 1715934672 : {</span>
<span class="lineNum">    1508 </span><span class="lineCov">   26004211 :   scratch[0] = x;</span>
<span class="lineNum">    1509 </span><span class="lineCov">   86824407 :   if (signed_p || scratch[0] &gt;= 0 || precision &lt;= HOST_BITS_PER_WIDE_INT)</span>
<span class="lineNum">    1510 </span><span class="lineCov">   26004211 :     return wi::storage_ref (scratch, 1, precision);</span>
<span class="lineNum">    1511 </span><span class="lineNoCov">          0 :   scratch[1] = 0;</span>
<span class="lineNum">    1512 </span><span class="lineNoCov">          0 :   return wi::storage_ref (scratch, 2, precision);</span>
<span class="lineNum">    1513 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1514 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    1515 </span><span class="lineNoCov">          0 : /* Allow primitive C types to be used in wi:: routines.  */</span>
<span class="lineNum">    1516 </span><span class="lineCov">       1381 : namespace wi</span>
<span class="lineNum">    1517 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">    1518 </span><span class="lineCov">    1255659 :   template &lt;&gt;</span>
<span class="lineNum">    1519 </span><span class="lineCov">   63095326 :   struct int_traits &lt;unsigned char&gt;</span>
<span class="lineNum">    1520 </span><span class="lineCov">     533035 :     : public primitive_int_traits &lt;unsigned char, false&gt; {};</span>
<span class="lineNum">    1521 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    1522 </span><span class="lineCov">        717 :   template &lt;&gt;</span>
<span class="lineNum">    1523 </span><span class="lineNoCov">          0 :   struct int_traits &lt;unsigned short&gt;</span>
<span class="lineNum">    1524 </span><span class="lineCov">        717 :     : public primitive_int_traits &lt;unsigned short, false&gt; {};</span>
<span class="lineNum">    1525 </span><span class="lineCov">   62851978 : </span>
<span class="lineNum">    1526 </span><span class="lineCov">   62851978 :   template &lt;&gt;</span>
<span class="lineNum">    1527 </span><span class="lineCov">   37255000 :   struct int_traits &lt;int&gt;</span>
<span class="lineNum">    1528 </span><span class="lineCov">   32996011 :     : public primitive_int_traits &lt;int, true&gt; {};</span>
<span class="lineNum">    1529 </span><span class="lineCov">      11270 : </span>
<span class="lineNum">    1530 </span><span class="lineCov">   32984741 :   template &lt;&gt;</span>
<span class="lineNum">    1531 </span><span class="lineCov">     956370 :   struct int_traits &lt;unsigned int&gt;</span>
<span class="lineNum">    1532 </span><span class="lineCov">    3316410 :     : public primitive_int_traits &lt;unsigned int, false&gt; {};</span>
<span class="lineNum">    1533 </span><span class="lineCov">   62851978 : </span>
<span class="lineNum">    1534 </span><span class="lineCov">    3307986 :   template &lt;&gt;</span>
<span class="lineNum">    1535 </span><span class="lineCov">   62851978 :   struct int_traits &lt;long&gt;</span>
<span class="lineNum">    1536 </span><span class="lineCov">   85374262 :     : public primitive_int_traits &lt;long, true&gt; {};</span>
<span class="lineNum">    1537 </span><span class="lineCov">   69582106 : </span>
<span class="lineNum">    1538 </span><span class="lineCov">   32809114 :   template &lt;&gt;</span>
<span class="lineNum">    1539 </span><span class="lineCov">   23257863 :   struct int_traits &lt;unsigned long&gt;</span>
<span class="lineNum">    1540 </span><span class="lineNoCov">          0 :     : public primitive_int_traits &lt;unsigned long, false&gt; {};</span>
<span class="lineNum">    1541 </span><span class="lineCov">   16527739 : </span>
<span class="lineNum">    1542 </span><span class="lineCov">   32915168 : #if defined HAVE_LONG_LONG</span>
<span class="lineNum">    1543 </span><span class="lineCov">   16441304 :   template &lt;&gt;</span>
<span class="lineNum">    1544 </span><span class="lineCov">     200437 :   struct int_traits &lt;long long&gt;</span>
<span class="lineNum">    1545 </span><span class="lineCov">   40329694 :     : public primitive_int_traits &lt;long long, true&gt; {};</span>
<span class="lineNum">    1546 </span><span class="lineCov">     209204 : </span>
<span class="lineNum">    1547 </span><span class="lineCov">   40329702 :   template &lt;&gt;</span>
<span class="lineNum">    1548 </span><span class="lineCov">   40389354 :   struct int_traits &lt;unsigned long long&gt;</span>
<span class="lineNum">    1549 </span><span class="lineCov">   42277568 :     : public primitive_int_traits &lt;unsigned long long, false&gt; {};</span>
<span class="lineNum">    1550 </span><span class="lineCov">      18367 : #endif</span>
<span class="lineNum">    1551 </span><span class="lineCov">    7689182 : }</span>
<span class="lineNum">    1552 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    1553 </span><span class="lineCov">    6130140 : namespace wi</span>
<span class="lineNum">    1554 </span><span class="lineCov">   47643439 : {</span>
<span class="lineNum">    1555 </span><span class="lineCov">    7276114 :   /* Stores HWI-sized integer VAL, treating it as having signedness SGN</span>
<span class="lineNum">    1556 </span><span class="lineCov">   36719509 :      and precision PRECISION.  */</span>
<span class="lineNum">    1557 </span><span class="lineCov">    1236422 :   struct hwi_with_prec</span>
<span class="lineNum">    1558 </span><span class="lineCov">    1246717 :   {</span>
<span class="lineNum">    1559 </span><span class="lineCov">   58496433 :     hwi_with_prec () {}</span>
<span class="lineNum">    1560 </span>            :     hwi_with_prec (HOST_WIDE_INT, unsigned int, signop);
<span class="lineNum">    1561 </span><span class="lineCov">   62812151 :     HOST_WIDE_INT val;</span>
<span class="lineNum">    1562 </span><span class="lineCov">     308982 :     unsigned int precision;</span>
<span class="lineNum">    1563 </span><span class="lineCov">     397833 :     signop sgn;</span>
<span class="lineNum">    1564 </span><span class="lineCov">    7466369 :   };</span>
<span class="lineNum">    1565 </span><span class="lineCov">    6171867 : </span>
<span class="lineNum">    1566 </span><span class="lineCov">    1830172 :   hwi_with_prec shwi (HOST_WIDE_INT, unsigned int);</span>
<span class="lineNum">    1567 </span><span class="lineCov">      31692 :   hwi_with_prec uhwi (unsigned HOST_WIDE_INT, unsigned int);</span>
<span class="lineNum">    1568 </span><span class="lineCov">      51030 : </span>
<span class="lineNum">    1569 </span><span class="lineCov">     160866 :   hwi_with_prec minus_one (unsigned int);</span>
<span class="lineNum">    1570 </span><span class="lineCov">        171 :   hwi_with_prec zero (unsigned int);</span>
<span class="lineNum">    1571 </span><span class="lineCov">     129031 :   hwi_with_prec one (unsigned int);</span>
<span class="lineNum">    1572 </span><span class="lineCov">      10405 :   hwi_with_prec two (unsigned int);</span>
<span class="lineNum">    1573 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1574 </span><span class="lineCov">  470452624 : </span>
<span class="lineNum">    1575 </span><span class="lineCov"> 1043823146 : inline wi::hwi_with_prec::hwi_with_prec (HOST_WIDE_INT v, unsigned int p,</span>
<span class="lineNum">    1576 </span><span class="lineCov">  233752752 :                                          signop s)</span>
<span class="lineNum">    1577 </span><span class="lineCov">    6916521 :   : precision (p), sgn (s)</span>
<span class="lineNum">    1578 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">    1579 </span><span class="lineCov">   20997201 :   if (precision &lt; HOST_BITS_PER_WIDE_INT)</span>
<span class="lineNum">    1580 </span><span class="lineCov">   27993292 :     val = sext_hwi (v, precision);</span>
<span class="lineNum">    1581 </span><span class="lineCov">  526279222 :   else</span>
<span class="lineNum">    1582 </span><span class="lineNoCov">          0 :     val = v;</span>
<span class="lineNum">    1583 </span><span class="lineCov">  526273120 : }</span>
<span class="lineNum">    1584 </span><span class="lineCov"> 6946494901 : </span>
<span class="lineNum">    1585 </span><span class="lineCov">       2671 : /* Return a signed integer that has value VAL and precision PRECISION.  */</span>
<span class="lineNum">    1586 </span><span class="lineCov"> 8406152624 : inline wi::hwi_with_prec</span>
<span class="lineNum">    1587 </span><span class="lineNoCov">          0 : wi::shwi (HOST_WIDE_INT val, unsigned int precision)</span>
<span class="lineNum">    1588 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">    1589 </span><span class="lineCov">   39716726 :   return hwi_with_prec (val, precision, SIGNED);</span>
<span class="lineNum">    1590 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1591 </span><span class="lineCov">   14023006 : </span>
<span class="lineNum">    1592 </span><span class="lineCov">    8306818 : /* Return an unsigned integer that has value VAL and precision PRECISION.  */</span>
<span class="lineNum">    1593 </span><span class="lineCov">       7091 : inline wi::hwi_with_prec</span>
<span class="lineNum">    1594 </span><span class="lineCov">   21006932 : wi::uhwi (unsigned HOST_WIDE_INT val, unsigned int precision)</span>
<span class="lineNum">    1595 </span><span class="lineCov">         32 : {</span>
<span class="lineNum">    1596 </span><span class="lineCov">   12732526 :   return hwi_with_prec (val, precision, UNSIGNED);</span>
<span class="lineNum">    1597 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1598 </span><span class="lineNoCov">          0 : </span>
<a name="1599"><span class="lineNum">    1599 </span><span class="lineCov">   29794054 : /* Return a wide int of -1 with precision PRECISION.  */</span></a>
<span class="lineNum">    1600 </span><span class="lineNoCov">          0 : inline wi::hwi_with_prec</span>
<span class="lineNum">    1601 </span><span class="lineCov">   31143026 : wi::minus_one (unsigned int precision)</span>
<span class="lineNum">    1602 </span><span class="lineCov">  367965493 : {</span>
<span class="lineNum">    1603 </span><span class="lineCov">   46693406 :   return wi::shwi (-1, precision);</span>
<span class="lineNum">    1604 </span><span class="lineCov">  444534515 : }</span>
<span class="lineNum">    1605 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    1606 </span><span class="lineNoCov">          0 : /* Return a wide int of 0 with precision PRECISION.  */</span>
<span class="lineNum">    1607 </span><span class="lineNoCov">          0 : inline wi::hwi_with_prec</span>
<span class="lineNum">    1608 </span><span class="lineCov">       1901 : wi::zero (unsigned int precision)</span>
<span class="lineNum">    1609 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">    1610 </span><span class="lineNoCov">          0 :   return wi::shwi (0, precision);</span>
<span class="lineNum">    1611 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1612 </span><span class="lineNoCov">          0 : </span>
<a name="1613"><span class="lineNum">    1613 </span><span class="lineCov">   29809436 : /* Return a wide int of 1 with precision PRECISION.  */</span></a>
<span class="lineNum">    1614 </span><span class="lineCov">      42049 : inline wi::hwi_with_prec</span>
<span class="lineNum">    1615 </span><span class="lineCov">   48802531 : wi::one (unsigned int precision)</span>
<span class="lineNum">    1616 </span><span class="lineCov">      11232 : {</span>
<span class="lineNum">    1617 </span><span class="lineNoCov">          0 :   return wi::shwi (1, precision);</span>
<span class="lineNum">    1618 </span><span class="lineCov">      19071 : }</span>
<span class="lineNum">    1619 </span><span class="lineCov">       3793 : </span>
<span class="lineNum">    1620 </span><span class="lineCov">       7891 : /* Return a wide int of 2 with precision PRECISION.  */</span>
<span class="lineNum">    1621 </span><span class="lineNoCov">          0 : inline wi::hwi_with_prec</span>
<span class="lineNum">    1622 </span><span class="lineNoCov">          0 : wi::two (unsigned int precision)</span>
<span class="lineNum">    1623 </span><span class="lineCov">   92463963 : {</span>
<span class="lineNum">    1624 </span><span class="lineCov">       8720 :   return wi::shwi (2, precision);</span>
<span class="lineNum">    1625 </span><span class="lineCov">  144392911 : }</span>
<span class="lineNum">    1626 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    1627 </span><span class="lineNoCov">          0 : namespace wi</span>
<span class="lineNum">    1628 </span><span class="lineCov">       6591 : {</span>
<span class="lineNum">    1629 </span><span class="lineCov">     659380 :   /* ints_for&lt;T&gt;::zero (X) returns a zero that, when asssigned to a T,</span>
<span class="lineNum">    1630 </span><span class="lineCov">   27091305 :      gives that T the same precision as X.  */</span>
<span class="lineNum">    1631 </span><span class="lineCov">     647064 :   template&lt;typename T, precision_type = int_traits&lt;T&gt;::precision_type&gt;</span>
<a name="1632"><span class="lineNum">    1632 </span><span class="lineCov">   27091305 :   struct ints_for</span></a>
<span class="lineNum">    1633 </span><span class="lineNoCov">          0 :   {</span>
<span class="lineNum">    1634 </span><span class="lineCov">      22980 :     static int zero (const T &amp;) { return 0; }</span>
<span class="lineNum">    1635 </span><span class="lineNoCov">          0 :   };</span>
<span class="lineNum">    1636 </span><span class="lineCov">    1540506 : </span>
<span class="lineNum">    1637 </span>            :   template&lt;typename T&gt;
<span class="lineNum">    1638 </span><span class="lineCov">    1552170 :   struct ints_for&lt;T, VAR_PRECISION&gt;</span>
<span class="lineNum">    1639 </span><span class="lineNoCov">          0 :   {</span>
<span class="lineNum">    1640 </span>            :     static hwi_with_prec zero (const T &amp;);
<span class="lineNum">    1641 </span><span class="lineNoCov">          0 :   };</span>
<span class="lineNum">    1642 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1643 </span>            : 
<a name="1644"><span class="lineNum">    1644 </span><span class="lineNoCov">          0 : template&lt;typename T&gt;</span></a>
<span class="lineNum">    1645 </span>            : inline wi::hwi_with_prec
<span class="lineNum">    1646 </span>            : wi::ints_for&lt;T, wi::VAR_PRECISION&gt;::zero (const T &amp;x)
<span class="lineNum">    1647 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">    1648 </span><span class="lineCov">       3655 :   return wi::zero (wi::get_precision (x));</span>
<span class="lineNum">    1649 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1650 </span>            : 
<span class="lineNum">    1651 </span>            : namespace wi
<span class="lineNum">    1652 </span>            : {
<span class="lineNum">    1653 </span>            :   template &lt;&gt;
<span class="lineNum">    1654 </span><span class="lineNoCov">          0 :   struct int_traits &lt;wi::hwi_with_prec&gt;</span>
<span class="lineNum">    1655 </span><span class="lineCov">        618 :   {</span>
<span class="lineNum">    1656 </span><span class="lineCov">        194 :     static const enum precision_type precision_type = VAR_PRECISION;</span>
<span class="lineNum">    1657 </span><span class="lineCov">    5334583 :     /* hwi_with_prec has an explicitly-given precision, rather than the</span>
<span class="lineNum">    1658 </span><span class="lineCov">       7310 :        precision of HOST_WIDE_INT.  */</span>
<span class="lineNum">    1659 </span><span class="lineCov">    7013655 :     static const bool host_dependent_precision = false;</span>
<span class="lineNum">    1660 </span>            :     static const bool is_sign_extended = true;
<span class="lineNum">    1661 </span>            :     static unsigned int get_precision (const wi::hwi_with_prec &amp;);
<span class="lineNum">    1662 </span><span class="lineCov">       6862 :     static wi::storage_ref decompose (HOST_WIDE_INT *, unsigned int,</span>
<span class="lineNum">    1663 </span><span class="lineCov">          4 :                                       const wi::hwi_with_prec &amp;);</span>
<span class="lineNum">    1664 </span>            :   };
<span class="lineNum">    1665 </span><span class="lineCov">       1236 : }</span>
<a name="1666"><span class="lineNum">    1666 </span><span class="lineCov">        736 : </span></a>
<span class="lineNum">    1667 </span>            : inline unsigned int
<span class="lineNum">    1668 </span><span class="lineNoCov">          0 : wi::int_traits &lt;wi::hwi_with_prec&gt;::get_precision (const wi::hwi_with_prec &amp;x)</span>
<span class="lineNum">    1669 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">    1670 </span><span class="lineCov">   30065400 :   return x.precision;</span>
<span class="lineNum">    1671 </span><span class="lineCov">   12966666 : }</span>
<a name="1672"><span class="lineNum">    1672 </span><span class="lineCov">        782 : </span></a>
<span class="lineNum">    1673 </span><span class="lineNoCov">          0 : inline wi::storage_ref</span>
<span class="lineNum">    1674 </span><span class="lineCov">   14058406 : wi::int_traits &lt;wi::hwi_with_prec&gt;::</span>
<span class="lineNum">    1675 </span><span class="lineNoCov">          0 : decompose (HOST_WIDE_INT *scratch, unsigned int precision,</span>
<span class="lineNum">    1676 </span>            :            const wi::hwi_with_prec &amp;x)
<span class="lineNum">    1677 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">    1678 </span><span class="lineCov">   14058406 :   gcc_checking_assert (precision == x.precision);</span>
<span class="lineNum">    1679 </span><span class="lineCov">   34898791 :   scratch[0] = x.val;</span>
<span class="lineNum">    1680 </span><span class="lineCov">   43374080 :   if (x.sgn == SIGNED || x.val &gt;= 0 || precision &lt;= HOST_BITS_PER_WIDE_INT)</span>
<span class="lineNum">    1681 </span><span class="lineCov">   34895136 :     return wi::storage_ref (scratch, 1, precision);</span>
<span class="lineNum">    1682 </span><span class="lineCov">    1040552 :   scratch[1] = 0;</span>
<span class="lineNum">    1683 </span><span class="lineNoCov">          0 :   return wi::storage_ref (scratch, 2, precision);</span>
<span class="lineNum">    1684 </span><span class="lineCov">    3863991 : }</span>
<span class="lineNum">    1685 </span><span class="lineCov">     105360 : </span>
<span class="lineNum">    1686 </span><span class="lineCov">        311 : /* Private functions for handling large cases out of line.  They take</span>
<span class="lineNum">    1687 </span><span class="lineCov">    1882086 :    individual length and array parameters because that is cheaper for</span>
<span class="lineNum">    1688 </span><span class="lineNoCov">          0 :    the inline caller than constructing an object on the stack and</span>
<span class="lineNum">    1689 </span><span class="lineNoCov">          0 :    passing a reference to it.  (Although many callers use wide_int_refs,</span>
<span class="lineNum">    1690 </span><span class="lineCov">        185 :    we generally want those to be removed by SRA.)  */</span>
<span class="lineNum">    1691 </span><span class="lineNoCov">          0 : namespace wi</span>
<span class="lineNum">    1692 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">    1693 </span><span class="lineCov">       6076 :   bool eq_p_large (const HOST_WIDE_INT *, unsigned int,</span>
<span class="lineNum">    1694 </span><span class="lineCov">   13097524 :                    const HOST_WIDE_INT *, unsigned int, unsigned int);</span>
<span class="lineNum">    1695 </span><span class="lineNoCov">          0 :   bool lts_p_large (const HOST_WIDE_INT *, unsigned int, unsigned int,</span>
<span class="lineNum">    1696 </span><span class="lineNoCov">          0 :                     const HOST_WIDE_INT *, unsigned int);</span>
<span class="lineNum">    1697 </span><span class="lineCov">       6170 :   bool ltu_p_large (const HOST_WIDE_INT *, unsigned int, unsigned int,</span>
<span class="lineNum">    1698 </span><span class="lineCov">  803986675 :                     const HOST_WIDE_INT *, unsigned int);</span>
<span class="lineNum">    1699 </span><span class="lineCov">       2086 :   int cmps_large (const HOST_WIDE_INT *, unsigned int, unsigned int,</span>
<span class="lineNum">    1700 </span><span class="lineCov">  804956180 :                   const HOST_WIDE_INT *, unsigned int);</span>
<span class="lineNum">    1701 </span><span class="lineCov">  175233796 :   int cmpu_large (const HOST_WIDE_INT *, unsigned int, unsigned int,</span>
<span class="lineNum">    1702 </span><span class="lineCov">  183559808 :                   const HOST_WIDE_INT *, unsigned int);</span>
<span class="lineNum">    1703 </span><span class="lineCov">      25743 :   unsigned int sext_large (HOST_WIDE_INT *, const HOST_WIDE_INT *,</span>
<span class="lineNum">    1704 </span><span class="lineCov">      23842 :                            unsigned int,</span>
<span class="lineNum">    1705 </span><span class="lineCov">      23842 :                            unsigned int, unsigned int);</span>
<span class="lineNum">    1706 </span><span class="lineNoCov">          0 :   unsigned int zext_large (HOST_WIDE_INT *, const HOST_WIDE_INT *,</span>
<span class="lineNum">    1707 </span><span class="lineCov">       6523 :                            unsigned int,</span>
<span class="lineNum">    1708 </span><span class="lineCov">     146158 :                            unsigned int, unsigned int);</span>
<span class="lineNum">    1709 </span><span class="lineCov">       1901 :   unsigned int set_bit_large (HOST_WIDE_INT *, const HOST_WIDE_INT *,</span>
<span class="lineNum">    1710 </span><span class="lineCov">       1901 :                               unsigned int, unsigned int, unsigned int);</span>
<span class="lineNum">    1711 </span><span class="lineCov">  259359756 :   unsigned int lshift_large (HOST_WIDE_INT *, const HOST_WIDE_INT *,</span>
<span class="lineNum">    1712 </span><span class="lineNoCov">          0 :                              unsigned int, unsigned int, unsigned int);</span>
<span class="lineNum">    1713 </span><span class="lineNoCov">          0 :   unsigned int lrshift_large (HOST_WIDE_INT *, const HOST_WIDE_INT *,</span>
<span class="lineNum">    1714 </span><span class="lineNoCov">          0 :                               unsigned int, unsigned int, unsigned int,</span>
<span class="lineNum">    1715 </span><span class="lineCov">        441 :                               unsigned int);</span>
<span class="lineNum">    1716 </span><span class="lineNoCov">          0 :   unsigned int arshift_large (HOST_WIDE_INT *, const HOST_WIDE_INT *,</span>
<span class="lineNum">    1717 </span><span class="lineCov">       9244 :                               unsigned int, unsigned int, unsigned int,</span>
<span class="lineNum">    1718 </span><span class="lineCov">       3085 :                               unsigned int);</span>
<span class="lineNum">    1719 </span><span class="lineCov">       6591 :   unsigned int and_large (HOST_WIDE_INT *, const HOST_WIDE_INT *, unsigned int,</span>
<span class="lineNum">    1720 </span><span class="lineNoCov">          0 :                           const HOST_WIDE_INT *, unsigned int, unsigned int);</span>
<span class="lineNum">    1721 </span><span class="lineNoCov">          0 :   unsigned int and_not_large (HOST_WIDE_INT *, const HOST_WIDE_INT *,</span>
<span class="lineNum">    1722 </span><span class="lineNoCov">          0 :                               unsigned int, const HOST_WIDE_INT *,</span>
<span class="lineNum">    1723 </span><span class="lineCov">  182330105 :                               unsigned int, unsigned int);</span>
<span class="lineNum">    1724 </span><span class="lineNoCov">          0 :   unsigned int or_large (HOST_WIDE_INT *, const HOST_WIDE_INT *, unsigned int,</span>
<span class="lineNum">    1725 </span><span class="lineCov">  182322824 :                          const HOST_WIDE_INT *, unsigned int, unsigned int);</span>
<span class="lineNum">    1726 </span><span class="lineNoCov">          0 :   unsigned int or_not_large (HOST_WIDE_INT *, const HOST_WIDE_INT *,</span>
<span class="lineNum">    1727 </span><span class="lineCov">  160661650 :                              unsigned int, const HOST_WIDE_INT *,</span>
<span class="lineNum">    1728 </span><span class="lineCov">       6591 :                              unsigned int, unsigned int);</span>
<span class="lineNum">    1729 </span><span class="lineCov">  237137613 :   unsigned int xor_large (HOST_WIDE_INT *, const HOST_WIDE_INT *, unsigned int,</span>
<span class="lineNum">    1730 </span><span class="lineCov">       6591 :                           const HOST_WIDE_INT *, unsigned int, unsigned int);</span>
<span class="lineNum">    1731 </span><span class="lineNoCov">          0 :   unsigned int add_large (HOST_WIDE_INT *, const HOST_WIDE_INT *, unsigned int,</span>
<span class="lineNum">    1732 </span><span class="lineNoCov">          0 :                           const HOST_WIDE_INT *, unsigned int, unsigned int,</span>
<span class="lineNum">    1733 </span><span class="lineNoCov">          0 :                           signop, overflow_type *);</span>
<span class="lineNum">    1734 </span><span class="lineNoCov">          0 :   unsigned int sub_large (HOST_WIDE_INT *, const HOST_WIDE_INT *, unsigned int,</span>
<span class="lineNum">    1735 </span><span class="lineNoCov">          0 :                           const HOST_WIDE_INT *, unsigned int, unsigned int,</span>
<span class="lineNum">    1736 </span><span class="lineNoCov">          0 :                           signop, overflow_type *);</span>
<span class="lineNum">    1737 </span><span class="lineCov"> 3248485426 :   unsigned int mul_internal (HOST_WIDE_INT *, const HOST_WIDE_INT *,</span>
<span class="lineNum">    1738 </span><span class="lineCov">       2311 :                              unsigned int, const HOST_WIDE_INT *,</span>
<span class="lineNum">    1739 </span><span class="lineCov"> 3248671243 :                              unsigned int, unsigned int, signop,</span>
<span class="lineNum">    1740 </span><span class="lineCov">   14403928 :                              overflow_type *, bool);</span>
<span class="lineNum">    1741 </span><span class="lineNoCov">          0 :   unsigned int divmod_internal (HOST_WIDE_INT *, unsigned int *,</span>
<span class="lineNum">    1742 </span><span class="lineCov">   15811462 :                                 HOST_WIDE_INT *, const HOST_WIDE_INT *,</span>
<span class="lineNum">    1743 </span><span class="lineCov">       3655 :                                 unsigned int, unsigned int,</span>
<span class="lineNum">    1744 </span><span class="lineNoCov">          0 :                                 const HOST_WIDE_INT *,</span>
<span class="lineNum">    1745 </span><span class="lineCov">       3988 :                                 unsigned int, unsigned int,</span>
<span class="lineNum">    1746 </span><span class="lineCov">        618 :                                 signop, overflow_type *);</span>
<span class="lineNum">    1747 </span><span class="lineCov">       3655 : }</span>
<span class="lineNum">    1748 </span><span class="lineCov">       3655 : </span>
<span class="lineNum">    1749 </span><span class="lineCov">   73851386 : /* Return the number of bits that integer X can hold.  */</span>
<a name="1750"><span class="lineNum">    1750 </span><span class="lineCov">    3903588 : template &lt;typename T&gt;</span></a>
<span class="lineNum">    1751 </span><span class="lineCov">   76801846 : inline unsigned int</span>
<span class="lineNum">    1752 </span><span class="lineNoCov">          0 : wi::get_precision (const T &amp;x)</span>
<span class="lineNum">    1753 </span><span class="lineCov">  264126533 : {</span>
<span class="lineNum">    1754 </span><span class="lineCov">  387863871 :   return wi::int_traits &lt;T&gt;::get_precision (x);</span>
<span class="lineNum">    1755 </span><span class="lineCov">        618 : }</span>
<span class="lineNum">    1756 </span><span class="lineCov">        618 : </span>
<span class="lineNum">    1757 </span><span class="lineCov">    1123332 : /* Return the number of bits that the result of a binary operation can</span>
<span class="lineNum">    1758 </span><span class="lineNoCov">          0 :    hold when the input operands are X and Y.  */</span>
<a name="1759"><span class="lineNum">    1759 </span><span class="lineNoCov">          0 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    1760 </span><span class="lineCov">    7595830 : inline unsigned int</span>
<span class="lineNum">    1761 </span><span class="lineCov">   17127722 : wi::get_binary_precision (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    1762 </span><span class="lineCov">    1124095 : {</span>
<span class="lineNum">    1763 </span><span class="lineCov">  139437596 :   return get_precision (wi::int_traits &lt;WI_BINARY_RESULT (T1, T2)&gt;::</span>
<span class="lineNum">    1764 </span><span class="lineCov">  141198193 :                         get_binary_result (x, y));</span>
<span class="lineNum">    1765 </span><span class="lineCov">   16005008 : }</span>
<span class="lineNum">    1766 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    1767 </span>            : /* Copy the contents of Y to X, but keeping X's current precision.  */
<a name="1768"><span class="lineNum">    1768 </span><span class="lineCov">   42314476 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    1769 </span><span class="lineCov">   16005008 : inline void</span>
<span class="lineNum">    1770 </span><span class="lineCov">   16033044 : wi::copy (T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    1771 </span><span class="lineCov">   16005008 : {</span>
<span class="lineNum">    1772 </span><span class="lineCov">   70130654 :   HOST_WIDE_INT *xval = x.write_val ();</span>
<span class="lineNum">    1773 </span><span class="lineCov">   79985910 :   const HOST_WIDE_INT *yval = y.get_val ();</span>
<span class="lineNum">    1774 </span><span class="lineCov">  118530608 :   unsigned int len = y.get_len ();</span>
<span class="lineNum">    1775 </span><span class="lineCov">   62440455 :   unsigned int i = 0;</span>
<span class="lineNum">    1776 </span><span class="lineNoCov">          0 :   do</span>
<span class="lineNum">    1777 </span><span class="lineCov">   87900096 :     xval[i] = yval[i];</span>
<span class="lineNum">    1778 </span><span class="lineCov">   91634166 :   while (++i &lt; len);</span>
<span class="lineNum">    1779 </span><span class="lineCov">   54281648 :   x.set_len (len, y.is_sign_extended);</span>
<span class="lineNum">    1780 </span><span class="lineCov">      25620 : }</span>
<span class="lineNum">    1781 </span><span class="lineCov">      15300 : </span>
<span class="lineNum">    1782 </span><span class="lineCov">      18385 : /* Return true if X fits in a HOST_WIDE_INT with no loss of precision.  */</span>
<span class="lineNum">    1783 </span><span class="lineCov">    7059384 : template &lt;typename T&gt;</span>
<span class="lineNum">    1784 </span><span class="lineCov">   45407369 : inline bool</span>
<span class="lineNum">    1785 </span><span class="lineCov">   45371978 : wi::fits_shwi_p (const T &amp;x)</span>
<span class="lineNum">    1786 </span><span class="lineCov">     221727 : {</span>
<span class="lineNum">    1787 </span><span class="lineCov">  209628357 :   WIDE_INT_REF_FOR (T) xi (x);</span>
<span class="lineNum">    1788 </span><span class="lineCov">     845600 :   return xi.len == 1;</span>
<span class="lineNum">    1789 </span><span class="lineCov">  240827581 : }</span>
<span class="lineNum">    1790 </span><span class="lineCov">     243640 : </span>
<span class="lineNum">    1791 </span><span class="lineCov">  241276393 : /* Return true if X fits in an unsigned HOST_WIDE_INT with no loss of</span>
<span class="lineNum">    1792 </span><span class="lineCov">  162010142 :    precision.  */</span>
<a name="1793"><span class="lineNum">    1793 </span><span class="lineCov">    1268138 : template &lt;typename T&gt;</span></a>
<span class="lineNum">    1794 </span><span class="lineCov">     512609 : inline bool</span>
<span class="lineNum">    1795 </span><span class="lineCov">    2700126 : wi::fits_uhwi_p (const T &amp;x)</span>
<span class="lineNum">    1796 </span><span class="lineCov">  167835564 : {</span>
<span class="lineNum">    1797 </span><span class="lineCov">     555695 :   WIDE_INT_REF_FOR (T) xi (x);</span>
<span class="lineNum">    1798 </span><span class="lineCov">     218528 :   if (xi.precision &lt;= HOST_BITS_PER_WIDE_INT)</span>
<span class="lineNum">    1799 </span><span class="lineCov">      61743 :     return true;</span>
<span class="lineNum">    1800 </span><span class="lineCov">  186878051 :   if (xi.len == 1)</span>
<span class="lineNum">    1801 </span><span class="lineCov">  183627609 :     return xi.slow () &gt;= 0;</span>
<span class="lineNum">    1802 </span><span class="lineCov">  168670176 :   return xi.len == 2 &amp;&amp; xi.uhigh () == 0;</span>
<span class="lineNum">    1803 </span><span class="lineCov">  188902922 : }</span>
<span class="lineNum">    1804 </span><span class="lineCov">   23102260 : </span>
<span class="lineNum">    1805 </span><span class="lineCov">  115501543 : /* Return true if X is negative based on the interpretation of SGN.</span>
<span class="lineNum">    1806 </span><span class="lineCov">   29233779 :    For UNSIGNED, this is always false.  */</span>
<a name="1807"><span class="lineNum">    1807 </span><span class="lineCov">   23271420 : template &lt;typename T&gt;</span></a>
<span class="lineNum">    1808 </span><span class="lineCov"> 1772919126 : inline bool</span>
<span class="lineNum">    1809 </span><span class="lineCov"> 1081893543 : wi::neg_p (const T &amp;x, signop sgn)</span>
<span class="lineNum">    1810 </span><span class="lineCov">     691691 : {</span>
<span class="lineNum">    1811 </span><span class="lineCov">   35850902 :   WIDE_INT_REF_FOR (T) xi (x);</span>
<span class="lineNum">    1812 </span><span class="lineCov">   17966674 :   if (sgn == UNSIGNED)</span>
<span class="lineNum">    1813 </span><span class="lineCov">    5830571 :     return false;</span>
<span class="lineNum">    1814 </span><span class="lineCov">    5204912 :   return xi.sign_mask () &lt; 0;</span>
<span class="lineNum">    1815 </span><span class="lineCov">    6540363 : }</span>
<span class="lineNum">    1816 </span><span class="lineCov">       1645 : </span>
<span class="lineNum">    1817 </span><span class="lineCov">   20661035 : /* Return -1 if the top bit of X is set and 0 if the top bit is clear.  */</span>
<a name="1818"><span class="lineNum">    1818 </span><span class="lineCov"> 2112294411 : template &lt;typename T&gt;</span></a>
<span class="lineNum">    1819 </span><span class="lineCov">     262366 : inline HOST_WIDE_INT</span>
<span class="lineNum">    1820 </span><span class="lineCov">     152383 : wi::sign_mask (const T &amp;x)</span>
<span class="lineNum">    1821 </span><span class="lineCov">     144475 : {</span>
<span class="lineNum">    1822 </span><span class="lineCov">        382 :   WIDE_INT_REF_FOR (T) xi (x);</span>
<span class="lineNum">    1823 </span><span class="lineCov">   13561381 :   return xi.sign_mask ();</span>
<span class="lineNum">    1824 </span><span class="lineCov">       8821 : }</span>
<span class="lineNum">    1825 </span><span class="lineCov">  298559003 : </span>
<span class="lineNum">    1826 </span><span class="lineCov">  284745523 : /* Return true if X == Y.  X and Y must be binary-compatible.  */</span>
<a name="1827"><span class="lineNum">    1827 </span><span class="lineCov">   64178160 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    1828 </span><span class="lineCov">     675541 : inline bool</span>
<span class="lineNum">    1829 </span><span class="lineCov">  305993559 : wi::eq_p (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    1830 </span><span class="lineCov">  346860968 : {</span>
<span class="lineNum">    1831 </span><span class="lineCov">   12598963 :   unsigned int precision = get_binary_precision (x, y);</span>
<span class="lineNum">    1832 </span><span class="lineCov">    1446330 :   WIDE_INT_REF_FOR (T1) xi (x, precision);</span>
<span class="lineNum">    1833 </span><span class="lineCov">   17353878 :   WIDE_INT_REF_FOR (T2) yi (y, precision);</span>
<span class="lineNum">    1834 </span><span class="lineCov">   16943088 :   if (xi.is_sign_extended &amp;&amp; yi.is_sign_extended)</span>
<span class="lineNum">    1835 </span><span class="lineCov">   19116192 :     {</span>
<span class="lineNum">    1836 </span><span class="lineCov">   97859633 :       /* This case reduces to array equality.  */</span>
<span class="lineNum">    1837 </span><span class="lineCov"> 1018223855 :       if (xi.len != yi.len)</span>
<span class="lineNum">    1838 </span><span class="lineCov">    8559028 :         return false;</span>
<span class="lineNum">    1839 </span><span class="lineCov">  943031729 :       unsigned int i = 0;</span>
<span class="lineNum">    1840 </span><span class="lineCov">   50737496 :       do</span>
<span class="lineNum">    1841 </span><span class="lineCov">   29690277 :         if (xi.val[i] != yi.val[i])</span>
<span class="lineNum">    1842 </span><span class="lineCov">   35508105 :           return false;</span>
<span class="lineNum">    1843 </span><span class="lineCov">   15779120 :       while (++i != xi.len);</span>
<span class="lineNum">    1844 </span><span class="lineCov">  264571880 :       return true;</span>
<span class="lineNum">    1845 </span><span class="lineCov">   66904380 :     }</span>
<span class="lineNum">    1846 </span><span class="lineCov">  323915096 :   if (__builtin_expect (yi.len == 1, true))</span>
<span class="lineNum">    1847 </span><span class="lineCov">  322185305 :     {</span>
<span class="lineNum">    1848 </span><span class="lineCov"> 1292301970 :       /* XI is only equal to YI if it too has a single HWI.  */</span>
<span class="lineNum">    1849 </span><span class="lineCov">    4455799 :       if (xi.len != 1)</span>
<span class="lineNum">    1850 </span><span class="lineCov">    3799117 :         return false;</span>
<span class="lineNum">    1851 </span><span class="lineCov"> 4225403835 :       /* Excess bits in xi.val[0] will be signs or zeros, so comparisons</span>
<span class="lineNum">    1852 </span><span class="lineCov"> 4488360356 :          with 0 are simple.  */</span>
<span class="lineNum">    1853 </span><span class="lineCov">  263064129 :       if (STATIC_CONSTANT_P (yi.val[0] == 0))</span>
<span class="lineNum">    1854 </span><span class="lineCov">  441972120 :         return xi.val[0] == 0;</span>
<span class="lineNum">    1855 </span><span class="lineCov">  437001782 :       /* Otherwise flush out any excess bits first.  */</span>
<span class="lineNum">    1856 </span><span class="lineCov">   19057311 :       unsigned HOST_WIDE_INT diff = xi.val[0] ^ yi.val[0];</span>
<span class="lineNum">    1857 </span><span class="lineCov">   12313721 :       int excess = HOST_BITS_PER_WIDE_INT - precision;</span>
<span class="lineNum">    1858 </span><span class="lineCov">     125128 :       if (excess &gt; 0)</span>
<span class="lineNum">    1859 </span><span class="lineCov">    4853728 :         diff &lt;&lt;= excess;</span>
<span class="lineNum">    1860 </span><span class="lineCov">    5289012 :       return diff == 0;</span>
<span class="lineNum">    1861 </span><span class="lineCov">   12150422 :     }</span>
<span class="lineNum">    1862 </span><span class="lineCov">   11985266 :   return eq_p_large (xi.val, xi.len, yi.val, yi.len, precision);</span>
<span class="lineNum">    1863 </span><span class="lineCov">     910118 : }</span>
<span class="lineNum">    1864 </span><span class="lineCov">  461431067 : </span>
<span class="lineNum">    1865 </span><span class="lineCov">  521225462 : /* Return true if X != Y.  X and Y must be binary-compatible.  */</span>
<a name="1866"><span class="lineNum">    1866 </span><span class="lineCov">  941679126 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    1867 </span><span class="lineCov">  941058464 : inline bool</span>
<span class="lineNum">    1868 </span><span class="lineCov">   35493567 : wi::ne_p (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    1869 </span><span class="lineCov">   10977953 : {</span>
<span class="lineNum">    1870 </span><span class="lineCov">   53550742 :   return !eq_p (x, y);</span>
<span class="lineNum">    1871 </span><span class="lineCov">   35990938 : }</span>
<span class="lineNum">    1872 </span><span class="lineCov">  421693514 : </span>
<span class="lineNum">    1873 </span><span class="lineCov">  364176872 : /* Return true if X &lt; Y when both are treated as signed values.  */</span>
<a name="1874"><span class="lineNum">    1874 </span><span class="lineCov">  362127906 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    1875 </span><span class="lineCov">    6285182 : inline bool</span>
<span class="lineNum">    1876 </span><span class="lineCov">  389645617 : wi::lts_p (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    1877 </span><span class="lineCov">     455831 : {</span>
<span class="lineNum">    1878 </span><span class="lineCov">  194470995 :   unsigned int precision = get_binary_precision (x, y);</span>
<span class="lineNum">    1879 </span><span class="lineCov">   96849382 :   WIDE_INT_REF_FOR (T1) xi (x, precision);</span>
<span class="lineNum">    1880 </span><span class="lineCov"> 8807346987 :   WIDE_INT_REF_FOR (T2) yi (y, precision);</span>
<span class="lineNum">    1881 </span><span class="lineCov"> 9867208535 :   /* We optimize x &lt; y, where y is 64 or fewer bits.  */</span>
<span class="lineNum">    1882 </span><span class="lineCov"> 9935360574 :   if (wi::fits_shwi_p (yi))</span>
<span class="lineNum">    1883 </span><span class="lineCov"> 1345601735 :     {</span>
<span class="lineNum">    1884 </span><span class="lineCov">     105692 :       /* Make lts_p (x, 0) as efficient as wi::neg_p (x).  */</span>
<span class="lineNum">    1885 </span><span class="lineCov"> 3973385287 :       if (STATIC_CONSTANT_P (yi.val[0] == 0))</span>
<span class="lineNum">    1886 </span><span class="lineCov">  874378526 :         return neg_p (xi);</span>
<span class="lineNum">    1887 </span><span class="lineCov"> 4172561390 :       /* If x fits directly into a shwi, we can compare directly.  */</span>
<span class="lineNum">    1888 </span><span class="lineCov">   96381620 :       if (wi::fits_shwi_p (xi))</span>
<span class="lineNum">    1889 </span><span class="lineCov">  100661629 :         return xi.to_shwi () &lt; yi.to_shwi ();</span>
<span class="lineNum">    1890 </span><span class="lineCov">   36002498 :       /* If x doesn't fit and is negative, then it must be more</span>
<span class="lineNum">    1891 </span><span class="lineCov">    7927063 :          negative than any value in y, and hence smaller than y.  */</span>
<span class="lineNum">    1892 </span><span class="lineCov">   10159903 :       if (neg_p (xi))</span>
<span class="lineNum">    1893 </span><span class="lineCov">   18767926 :         return true;</span>
<span class="lineNum">    1894 </span><span class="lineCov">  123863985 :       /* If x is positive, then it must be larger than any value in y,</span>
<span class="lineNum">    1895 </span><span class="lineCov"> 4946655067 :          and hence greater than y.  */</span>
<span class="lineNum">    1896 </span><span class="lineCov">   11766220 :       return false;</span>
<span class="lineNum">    1897 </span><span class="lineCov">    9033177 :     }</span>
<span class="lineNum">    1898 </span><span class="lineCov">   54472940 :   /* Optimize the opposite case, if it can be detected at compile time.  */</span>
<span class="lineNum">    1899 </span><span class="lineCov"> 1580008562 :   if (STATIC_CONSTANT_P (xi.len == 1))</span>
<span class="lineNum">    1900 </span><span class="lineCov">  577926052 :     /* If YI is negative it is lower than the least HWI.</span>
<span class="lineNum">    1901 </span><span class="lineCov">   54851844 :        If YI is positive it is greater than the greatest HWI.  */</span>
<span class="lineNum">    1902 </span><span class="lineCov">   70777238 :     return !neg_p (yi);</span>
<span class="lineNum">    1903 </span><span class="lineCov"> 1556713161 :   return lts_p_large (xi.val, xi.len, precision, yi.val, yi.len);</span>
<span class="lineNum">    1904 </span><span class="lineCov">   55773151 : }</span>
<span class="lineNum">    1905 </span><span class="lineCov">   64568053 : </span>
<span class="lineNum">    1906 </span><span class="lineCov">   36501917 : /* Return true if X &lt; Y when both are treated as unsigned values.  */</span>
<a name="1907"><span class="lineNum">    1907 </span><span class="lineCov"> 1613789697 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    1908 </span><span class="lineCov"> 1550724836 : inline bool</span>
<span class="lineNum">    1909 </span><span class="lineCov"> 1665157882 : wi::ltu_p (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    1910 </span><span class="lineCov"> 1610422271 : {</span>
<span class="lineNum">    1911 </span><span class="lineCov">  131806066 :   unsigned int precision = get_binary_precision (x, y);</span>
<span class="lineNum">    1912 </span><span class="lineCov">  137431036 :   WIDE_INT_REF_FOR (T1) xi (x, precision);</span>
<span class="lineNum">    1913 </span><span class="lineCov">  171094442 :   WIDE_INT_REF_FOR (T2) yi (y, precision);</span>
<span class="lineNum">    1914 </span><span class="lineCov">  681609222 :   /* Optimize comparisons with constants.  */</span>
<span class="lineNum">    1915 </span><span class="lineCov">  711588599 :   if (STATIC_CONSTANT_P (yi.len == 1 &amp;&amp; yi.val[0] &gt;= 0))</span>
<span class="lineNum">    1916 </span><span class="lineCov">  721461190 :     return xi.len == 1 &amp;&amp; xi.to_uhwi () &lt; (unsigned HOST_WIDE_INT) yi.val[0];</span>
<span class="lineNum">    1917 </span><span class="lineCov">  374880151 :   if (STATIC_CONSTANT_P (xi.len == 1 &amp;&amp; xi.val[0] &gt;= 0))</span>
<span class="lineNum">    1918 </span><span class="lineCov">   46151509 :     return yi.len != 1 || yi.to_uhwi () &gt; (unsigned HOST_WIDE_INT) xi.val[0];</span>
<span class="lineNum">    1919 </span><span class="lineCov">  394487884 :   /* Optimize the case of two HWIs.  The HWIs are implicitly sign-extended</span>
<span class="lineNum">    1920 </span><span class="lineCov">  391357369 :      for precisions greater than HOST_BITS_WIDE_INT, but sign-extending both</span>
<span class="lineNum">    1921 </span><span class="lineCov">  635462385 :      values does not change the result.  */</span>
<span class="lineNum">    1922 </span><span class="lineCov">   45704676 :   if (__builtin_expect (xi.len + yi.len == 2, true))</span>
<span class="lineNum">    1923 </span><span class="lineCov">  138410984 :     {</span>
<span class="lineNum">    1924 </span><span class="lineCov">  231214911 :       unsigned HOST_WIDE_INT xl = xi.to_uhwi ();</span>
<span class="lineNum">    1925 </span><span class="lineCov">  440378305 :       unsigned HOST_WIDE_INT yl = yi.to_uhwi ();</span>
<span class="lineNum">    1926 </span><span class="lineCov">  296970174 :       return xl &lt; yl;</span>
<span class="lineNum">    1927 </span><span class="lineCov">  202161700 :     }</span>
<span class="lineNum">    1928 </span><span class="lineCov">  340754949 :   return ltu_p_large (xi.val, xi.len, precision, yi.val, yi.len);</span>
<span class="lineNum">    1929 </span><span class="lineCov">   57665071 : }</span>
<span class="lineNum">    1930 </span><span class="lineCov">  154675662 : </span>
<span class="lineNum">    1931 </span><span class="lineCov">   97720827 : /* Return true if X &lt; Y.  Signedness of X and Y is indicated by SGN.  */</span>
<a name="1932"><span class="lineNum">    1932 </span><span class="lineCov">   43421561 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    1933 </span><span class="lineCov">   43236496 : inline bool</span>
<span class="lineNum">    1934 </span><span class="lineCov">   95824772 : wi::lt_p (const T1 &amp;x, const T2 &amp;y, signop sgn)</span>
<span class="lineNum">    1935 </span><span class="lineCov">    4074139 : {</span>
<span class="lineNum">    1936 </span><span class="lineCov">   80144358 :   if (sgn == SIGNED)</span>
<span class="lineNum">    1937 </span><span class="lineCov">   34772850 :     return lts_p (x, y);</span>
<span class="lineNum">    1938 </span><span class="lineCov">  205601391 :   else</span>
<span class="lineNum">    1939 </span><span class="lineCov"> 2725219602 :     return ltu_p (x, y);</span>
<span class="lineNum">    1940 </span><span class="lineCov"> 2686454113 : }</span>
<span class="lineNum">    1941 </span><span class="lineCov">   12763578 : </span>
<span class="lineNum">    1942 </span><span class="lineCov">    3984680 : /* Return true if X &lt;= Y when both are treated as signed values.  */</span>
<a name="1943"><span class="lineNum">    1943 </span><span class="lineCov">   17625443 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    1944 </span><span class="lineCov">   86691378 : inline bool</span>
<span class="lineNum">    1945 </span><span class="lineCov">   16203300 : wi::les_p (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    1946 </span><span class="lineCov">   23930800 : {</span>
<span class="lineNum">    1947 </span><span class="lineCov">   16161270 :   return !lts_p (y, x);</span>
<span class="lineNum">    1948 </span><span class="lineCov">    3400372 : }</span>
<span class="lineNum">    1949 </span><span class="lineCov"> 1355810694 : </span>
<span class="lineNum">    1950 </span><span class="lineCov">   65826422 : /* Return true if X &lt;= Y when both are treated as unsigned values.  */</span>
<a name="1951"><span class="lineNum">    1951 </span><span class="lineCov">  155952526 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    1952 </span><span class="lineCov">   48315952 : inline bool</span>
<span class="lineNum">    1953 </span><span class="lineCov">  323935223 : wi::leu_p (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    1954 </span><span class="lineCov">    1400972 : {</span>
<span class="lineNum">    1955 </span><span class="lineCov">  590928737 :   return !ltu_p (y, x);</span>
<span class="lineNum">    1956 </span><span class="lineCov">  462235018 : }</span>
<span class="lineNum">    1957 </span><span class="lineCov">  320843815 : </span>
<span class="lineNum">    1958 </span><span class="lineCov">  137579353 : /* Return true if X &lt;= Y.  Signedness of X and Y is indicated by SGN.  */</span>
<a name="1959"><span class="lineNum">    1959 </span><span class="lineCov">  287841510 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    1960 </span><span class="lineCov">     854626 : inline bool</span>
<span class="lineNum">    1961 </span><span class="lineCov">   45897990 : wi::le_p (const T1 &amp;x, const T2 &amp;y, signop sgn)</span>
<span class="lineNum">    1962 </span><span class="lineCov">  278462449 : {</span>
<span class="lineNum">    1963 </span><span class="lineCov">   40940427 :   if (sgn == SIGNED)</span>
<span class="lineNum">    1964 </span><span class="lineCov">    1107368 :     return les_p (x, y);</span>
<span class="lineNum">    1965 </span><span class="lineCov">  878736367 :   else</span>
<span class="lineNum">    1966 </span><span class="lineCov">  884074296 :     return leu_p (x, y);</span>
<span class="lineNum">    1967 </span><span class="lineCov">   46180735 : }</span>
<span class="lineNum">    1968 </span><span class="lineCov">    5416637 : </span>
<span class="lineNum">    1969 </span><span class="lineCov">   33031304 : /* Return true if X &gt; Y when both are treated as signed values.  */</span>
<a name="1970"><span class="lineNum">    1970 </span><span class="lineCov">    1145719 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    1971 </span><span class="lineCov">   17253630 : inline bool</span>
<span class="lineNum">    1972 </span><span class="lineCov">  330933937 : wi::gts_p (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    1973 </span><span class="lineCov">   48494619 : {</span>
<span class="lineNum">    1974 </span><span class="lineCov"> 1157073633 :   return lts_p (y, x);</span>
<span class="lineNum">    1975 </span><span class="lineCov"> 1169497314 : }</span>
<span class="lineNum">    1976 </span><span class="lineCov"> 1160375899 : </span>
<span class="lineNum">    1977 </span><span class="lineCov">  270965241 : /* Return true if X &gt; Y when both are treated as unsigned values.  */</span>
<a name="1978"><span class="lineNum">    1978 </span><span class="lineCov">  548098254 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    1979 </span><span class="lineCov">  284500684 : inline bool</span>
<span class="lineNum">    1980 </span><span class="lineCov">  277184542 : wi::gtu_p (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    1981 </span><span class="lineCov">  311012891 : {</span>
<span class="lineNum">    1982 </span><span class="lineCov">  241678376 :   return ltu_p (y, x);</span>
<span class="lineNum">    1983 </span><span class="lineCov"> 2420000456 : }</span>
<span class="lineNum">    1984 </span><span class="lineCov">  786877634 : </span>
<span class="lineNum">    1985 </span><span class="lineCov">  772701364 : /* Return true if X &gt; Y.  Signedness of X and Y is indicated by SGN.  */</span>
<a name="1986"><span class="lineNum">    1986 </span><span class="lineCov">  313009085 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    1987 </span><span class="lineCov">     421866 : inline bool</span>
<span class="lineNum">    1988 </span><span class="lineCov">  233434809 : wi::gt_p (const T1 &amp;x, const T2 &amp;y, signop sgn)</span>
<span class="lineNum">    1989 </span><span class="lineCov">  251477271 : {</span>
<span class="lineNum">    1990 </span><span class="lineCov">   34662404 :   if (sgn == SIGNED)</span>
<span class="lineNum">    1991 </span><span class="lineCov">  724798825 :     return gts_p (x, y);</span>
<span class="lineNum">    1992 </span><span class="lineCov">  319555711 :   else</span>
<span class="lineNum">    1993 </span><span class="lineCov">  358992984 :     return gtu_p (x, y);</span>
<span class="lineNum">    1994 </span><span class="lineCov">  870260957 : }</span>
<span class="lineNum">    1995 </span><span class="lineCov"> 1211714605 : </span>
<span class="lineNum">    1996 </span><span class="lineCov">  143553439 : /* Return true if X &gt;= Y when both are treated as signed values.  */</span>
<span class="lineNum">    1997 </span><span class="lineCov">  104630579 : template &lt;typename T1, typename T2&gt;</span>
<span class="lineNum">    1998 </span><span class="lineCov">  288500012 : inline bool</span>
<span class="lineNum">    1999 </span><span class="lineCov">  644728283 : wi::ges_p (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    2000 </span><span class="lineCov"> 1005164743 : {</span>
<span class="lineNum">    2001 </span><span class="lineCov"> 1260856683 :   return !lts_p (x, y);</span>
<span class="lineNum">    2002 </span><span class="lineCov">  529407124 : }</span>
<span class="lineNum">    2003 </span><span class="lineCov">  173664110 : </span>
<span class="lineNum">    2004 </span><span class="lineCov">  169498447 : /* Return true if X &gt;= Y when both are treated as unsigned values.  */</span>
<a name="2005"><span class="lineNum">    2005 </span><span class="lineCov">  163892868 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    2006 </span><span class="lineCov">  417385000 : inline bool</span>
<span class="lineNum">    2007 </span><span class="lineCov">   27811775 : wi::geu_p (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    2008 </span><span class="lineCov"> 1950534797 : {</span>
<span class="lineNum">    2009 </span><span class="lineCov"> 1971278558 :   return !ltu_p (x, y);</span>
<span class="lineNum">    2010 </span><span class="lineCov">   63875428 : }</span>
<span class="lineNum">    2011 </span><span class="lineCov">   69708942 : </span>
<span class="lineNum">    2012 </span><span class="lineCov"> 6365731455 : /* Return true if X &gt;= Y.  Signedness of X and Y is indicated by SGN.  */</span>
<a name="2013"><span class="lineNum">    2013 </span><span class="lineCov"> 6353201740 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    2014 </span><span class="lineCov">    3818916 : inline bool</span>
<span class="lineNum">    2015 </span><span class="lineCov">    2455520 : wi::ge_p (const T1 &amp;x, const T2 &amp;y, signop sgn)</span>
<span class="lineNum">    2016 </span><span class="lineCov">   13828089 : {</span>
<span class="lineNum">    2017 </span><span class="lineCov">   50773329 :   if (sgn == SIGNED)</span>
<span class="lineNum">    2018 </span><span class="lineCov">    2233957 :     return ges_p (x, y);</span>
<span class="lineNum">    2019 </span><span class="lineCov"> 2936201934 :   else</span>
<span class="lineNum">    2020 </span><span class="lineCov"> 2969507940 :     return geu_p (x, y);</span>
<span class="lineNum">    2021 </span><span class="lineCov"> 2969532662 : }</span>
<span class="lineNum">    2022 </span><span class="lineCov">   83517613 : </span>
<span class="lineNum">    2023 </span><span class="lineCov">   75553444 : /* Return -1 if X &lt; Y, 0 if X == Y and 1 if X &gt; Y.  Treat both X and Y</span>
<span class="lineNum">    2024 </span><span class="lineCov"> 1580360370 :    as signed values.  */</span>
<a name="2025"><span class="lineNum">    2025 </span><span class="lineCov">   77044554 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    2026 </span><span class="lineCov">  154195943 : inline int</span>
<span class="lineNum">    2027 </span><span class="lineCov">   18424156 : wi::cmps (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    2028 </span><span class="lineCov">  268116372 : {</span>
<span class="lineNum">    2029 </span><span class="lineCov">  257963940 :   unsigned int precision = get_binary_precision (x, y);</span>
<span class="lineNum">    2030 </span><span class="lineCov">  486317465 :   WIDE_INT_REF_FOR (T1) xi (x, precision);</span>
<span class="lineNum">    2031 </span><span class="lineCov">   26832783 :   WIDE_INT_REF_FOR (T2) yi (y, precision);</span>
<span class="lineNum">    2032 </span><span class="lineCov">  633169828 :   if (wi::fits_shwi_p (yi))</span>
<span class="lineNum">    2033 </span><span class="lineCov">  482272213 :     {</span>
<span class="lineNum">    2034 </span><span class="lineCov">  465953990 :       /* Special case for comparisons with 0.  */</span>
<span class="lineNum">    2035 </span><span class="lineCov">  157997522 :       if (STATIC_CONSTANT_P (yi.val[0] == 0))</span>
<span class="lineNum">    2036 </span><span class="lineCov">  474113104 :         return neg_p (xi) ? -1 : !(xi.len == 1 &amp;&amp; xi.val[0] == 0);</span>
<span class="lineNum">    2037 </span><span class="lineCov">   52312021 :       /* If x fits into a signed HWI, we can compare directly.  */</span>
<span class="lineNum">    2038 </span><span class="lineCov">  172705175 :       if (wi::fits_shwi_p (xi))</span>
<span class="lineNum">    2039 </span><span class="lineCov">  383807131 :         {</span>
<span class="lineNum">    2040 </span><span class="lineCov">   14847610 :           HOST_WIDE_INT xl = xi.to_shwi ();</span>
<span class="lineNum">    2041 </span><span class="lineCov">   29372796 :           HOST_WIDE_INT yl = yi.to_shwi ();</span>
<span class="lineNum">    2042 </span><span class="lineCov">  241309107 :           return xl &lt; yl ? -1 : xl &gt; yl;</span>
<span class="lineNum">    2043 </span><span class="lineCov">  295032998 :         }</span>
<span class="lineNum">    2044 </span><span class="lineCov">   60141285 :       /* If x doesn't fit and is negative, then it must be more</span>
<span class="lineNum">    2045 </span><span class="lineCov">   59057428 :          negative than any signed HWI, and hence smaller than y.  */</span>
<span class="lineNum">    2046 </span><span class="lineCov">    2094364 :       if (neg_p (xi))</span>
<span class="lineNum">    2047 </span><span class="lineCov">   10769422 :         return -1;</span>
<span class="lineNum">    2048 </span><span class="lineCov">   40996236 :       /* If x is positive, then it must be larger than any signed HWI,</span>
<span class="lineNum">    2049 </span><span class="lineCov">     116678 :          and hence greater than y.  */</span>
<span class="lineNum">    2050 </span><span class="lineCov">     808565 :       return 1;</span>
<span class="lineNum">    2051 </span><span class="lineCov">  146655208 :     }</span>
<span class="lineNum">    2052 </span><span class="lineCov">  492350656 :   /* Optimize the opposite case, if it can be detected at compile time.  */</span>
<span class="lineNum">    2053 </span><span class="lineCov">  490642621 :   if (STATIC_CONSTANT_P (xi.len == 1))</span>
<span class="lineNum">    2054 </span><span class="lineCov">  346057119 :     /* If YI is negative it is lower than the least HWI.</span>
<span class="lineNum">    2055 </span><span class="lineCov">  255538890 :        If YI is positive it is greater than the greatest HWI.  */</span>
<span class="lineNum">    2056 </span><span class="lineCov">   75143186 :     return neg_p (yi) ? 1 : -1;</span>
<span class="lineNum">    2057 </span><span class="lineCov">  267812699 :   return cmps_large (xi.val, xi.len, precision, yi.val, yi.len);</span>
<span class="lineNum">    2058 </span><span class="lineCov"> 1432676711 : }</span>
<span class="lineNum">    2059 </span><span class="lineCov"> 1141656037 : </span>
<span class="lineNum">    2060 </span><span class="lineCov"> 1093304713 : /* Return -1 if X &lt; Y, 0 if X == Y and 1 if X &gt; Y.  Treat both X and Y</span>
<span class="lineNum">    2061 </span><span class="lineCov">   73400678 :    as unsigned values.  */</span>
<a name="2062"><span class="lineNum">    2062 </span><span class="lineCov">    1584796 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    2063 </span><span class="lineCov">   61541865 : inline int</span>
<span class="lineNum">    2064 </span><span class="lineCov">  690629387 : wi::cmpu (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    2065 </span><span class="lineCov">   35888630 : {</span>
<span class="lineNum">    2066 </span><span class="lineCov">  148018609 :   unsigned int precision = get_binary_precision (x, y);</span>
<span class="lineNum">    2067 </span><span class="lineCov">  129395431 :   WIDE_INT_REF_FOR (T1) xi (x, precision);</span>
<span class="lineNum">    2068 </span><span class="lineCov">  625877126 :   WIDE_INT_REF_FOR (T2) yi (y, precision);</span>
<span class="lineNum">    2069 </span><span class="lineCov">  326260943 :   /* Optimize comparisons with constants.  */</span>
<span class="lineNum">    2070 </span><span class="lineCov">  143575240 :   if (STATIC_CONSTANT_P (yi.len == 1 &amp;&amp; yi.val[0] &gt;= 0))</span>
<span class="lineNum">    2071 </span><span class="lineCov">  634269720 :     {</span>
<span class="lineNum">    2072 </span><span class="lineCov">  700571619 :       /* If XI doesn't fit in a HWI then it must be larger than YI.  */</span>
<span class="lineNum">    2073 </span><span class="lineCov">  642403977 :       if (xi.len != 1)</span>
<span class="lineNum">    2074 </span><span class="lineCov">  366560419 :         return 1;</span>
<span class="lineNum">    2075 </span><span class="lineCov">   57684390 :       /* Otherwise compare directly.  */</span>
<span class="lineNum">    2076 </span><span class="lineCov">  364005560 :       unsigned HOST_WIDE_INT xl = xi.to_uhwi ();</span>
<span class="lineNum">    2077 </span><span class="lineCov"> 1090738663 :       unsigned HOST_WIDE_INT yl = yi.val[0];</span>
<span class="lineNum">    2078 </span><span class="lineCov"> 1045437427 :       return xl &lt; yl ? -1 : xl &gt; yl;</span>
<span class="lineNum">    2079 </span><span class="lineCov">  358455874 :     }</span>
<span class="lineNum">    2080 </span><span class="lineCov">  993674870 :   if (STATIC_CONSTANT_P (xi.len == 1 &amp;&amp; xi.val[0] &gt;= 0))</span>
<span class="lineNum">    2081 </span><span class="lineCov">  699805589 :     {</span>
<span class="lineNum">    2082 </span><span class="lineCov">  670375239 :       /* If YI doesn't fit in a HWI then it must be larger than XI.  */</span>
<span class="lineNum">    2083 </span><span class="lineCov"> 1723656796 :       if (yi.len != 1)</span>
<span class="lineNum">    2084 </span><span class="lineCov">  708289186 :         return -1;</span>
<span class="lineNum">    2085 </span><span class="lineCov">  471923661 :       /* Otherwise compare directly.  */</span>
<span class="lineNum">    2086 </span><span class="lineCov">  190830252 :       unsigned HOST_WIDE_INT xl = xi.val[0];</span>
<span class="lineNum">    2087 </span><span class="lineCov">  513023842 :       unsigned HOST_WIDE_INT yl = yi.to_uhwi ();</span>
<span class="lineNum">    2088 </span><span class="lineCov">  566618661 :       return xl &lt; yl ? -1 : xl &gt; yl;</span>
<span class="lineNum">    2089 </span><span class="lineCov">  384209495 :     }</span>
<span class="lineNum">    2090 </span><span class="lineCov">  620287646 :   /* Optimize the case of two HWIs.  The HWIs are implicitly sign-extended</span>
<span class="lineNum">    2091 </span><span class="lineCov">  293635102 :      for precisions greater than HOST_BITS_WIDE_INT, but sign-extending both</span>
<span class="lineNum">    2092 </span><span class="lineCov">  266499379 :      values does not change the result.  */</span>
<span class="lineNum">    2093 </span><span class="lineCov">  109097255 :   if (__builtin_expect (xi.len + yi.len == 2, true))</span>
<span class="lineNum">    2094 </span><span class="lineCov">  176533798 :     {</span>
<span class="lineNum">    2095 </span><span class="lineCov">   20404700 :       unsigned HOST_WIDE_INT xl = xi.to_uhwi ();</span>
<span class="lineNum">    2096 </span><span class="lineCov">   49130854 :       unsigned HOST_WIDE_INT yl = yi.to_uhwi ();</span>
<span class="lineNum">    2097 </span><span class="lineCov">  530257178 :       return xl &lt; yl ? -1 : xl &gt; yl;</span>
<span class="lineNum">    2098 </span><span class="lineCov">   64241901 :     }</span>
<span class="lineNum">    2099 </span><span class="lineCov">   13213163 :   return cmpu_large (xi.val, xi.len, precision, yi.val, yi.len);</span>
<span class="lineNum">    2100 </span><span class="lineCov">  166863541 : }</span>
<span class="lineNum">    2101 </span><span class="lineCov">  155125139 : </span>
<span class="lineNum">    2102 </span><span class="lineCov">   44838162 : /* Return -1 if X &lt; Y, 0 if X == Y and 1 if X &gt; Y.  Signedness of</span>
<span class="lineNum">    2103 </span><span class="lineCov">     864989 :    X and Y indicated by SGN.  */</span>
<a name="2104"><span class="lineNum">    2104 </span><span class="lineCov">    6658159 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    2105 </span><span class="lineCov">    1762339 : inline int</span>
<span class="lineNum">    2106 </span><span class="lineCov">    1491566 : wi::cmp (const T1 &amp;x, const T2 &amp;y, signop sgn)</span>
<span class="lineNum">    2107 </span><span class="lineCov">    1547033 : {</span>
<span class="lineNum">    2108 </span><span class="lineCov">   11151205 :   if (sgn == SIGNED)</span>
<span class="lineNum">    2109 </span><span class="lineCov">  965520759 :     return cmps (x, y);</span>
<span class="lineNum">    2110 </span><span class="lineCov">   15090985 :   else</span>
<span class="lineNum">    2111 </span><span class="lineCov"> 2165746828 :     return cmpu (x, y);</span>
<span class="lineNum">    2112 </span><span class="lineCov"> 1939713174 : }</span>
<span class="lineNum">    2113 </span><span class="lineCov"> 1955550230 : </span>
<span class="lineNum">    2114 </span><span class="lineCov">      70835 : /* Return ~x.  */</span>
<a name="2115"><span class="lineNum">    2115 </span><span class="lineCov">   87706346 : template &lt;typename T&gt;</span></a>
<span class="lineNum">    2116 </span><span class="lineCov">   52861468 : inline WI_UNARY_RESULT (T)</span>
<span class="lineNum">    2117 </span><span class="lineCov">   47857321 : wi::bit_not (const T &amp;x)</span>
<span class="lineNum">    2118 </span><span class="lineCov">   42168609 : {</span>
<span class="lineNum">    2119 </span><span class="lineCov">  741355542 :   WI_UNARY_RESULT_VAR (result, val, T, x);</span>
<span class="lineNum">    2120 </span><span class="lineCov"> 2524182048 :   WIDE_INT_REF_FOR (T) xi (x, get_precision (result));</span>
<span class="lineNum">    2121 </span><span class="lineCov"> 1598372007 :   for (unsigned int i = 0; i &lt; xi.len; ++i)</span>
<span class="lineNum">    2122 </span><span class="lineCov">  774081049 :     val[i] = ~xi.val[i];</span>
<span class="lineNum">    2123 </span><span class="lineCov">  599755467 :   result.set_len (xi.len);</span>
<span class="lineNum">    2124 </span><span class="lineCov">  401723694 :   return result;</span>
<span class="lineNum">    2125 </span><span class="lineCov">  116553846 : }</span>
<span class="lineNum">    2126 </span><span class="lineCov">   63752768 : </span>
<span class="lineNum">    2127 </span><span class="lineCov"> 1293299063 : /* Return -x.  */</span>
<a name="2128"><span class="lineNum">    2128 </span><span class="lineCov">  116482705 : template &lt;typename T&gt;</span></a>
<span class="lineNum">    2129 </span><span class="lineCov"> 2255010105 : inline WI_UNARY_RESULT (T)</span>
<span class="lineNum">    2130 </span><span class="lineCov"> 1264325012 : wi::neg (const T &amp;x)</span>
<span class="lineNum">    2131 </span><span class="lineCov">   23601291 : {</span>
<span class="lineNum">    2132 </span><span class="lineCov"> 1368787305 :   return sub (0, x);</span>
<span class="lineNum">    2133 </span><span class="lineCov"> 2277222853 : }</span>
<span class="lineNum">    2134 </span><span class="lineCov">  974291937 : </span>
<span class="lineNum">    2135 </span><span class="lineCov">   24582243 : /* Return -x.  Indicate in *OVERFLOW if performing the negation would</span>
<span class="lineNum">    2136 </span><span class="lineCov">   66460931 :    cause an overflow.  */</span>
<a name="2137"><span class="lineNum">    2137 </span><span class="lineCov">  258579975 : template &lt;typename T&gt;</span></a>
<span class="lineNum">    2138 </span><span class="lineCov">   53639262 : inline WI_UNARY_RESULT (T)</span>
<span class="lineNum">    2139 </span><span class="lineCov">   25658239 : wi::neg (const T &amp;x, overflow_type *overflow)</span>
<span class="lineNum">    2140 </span><span class="lineCov">  258399338 : {</span>
<span class="lineNum">    2141 </span><span class="lineCov">   10268144 :   *overflow = only_sign_bit_p (x) ? OVF_OVERFLOW : OVF_NONE;</span>
<span class="lineNum">    2142 </span><span class="lineCov">   10776688 :   return sub (0, x);</span>
<span class="lineNum">    2143 </span><span class="lineCov"> 3297224822 : }</span>
<span class="lineNum">    2144 </span><span class="lineCov">  214770670 : </span>
<span class="lineNum">    2145 </span><span class="lineCov">    9991882 : /* Return the absolute value of x.  */</span>
<a name="2146"><span class="lineNum">    2146 </span><span class="lineCov"> 1707500574 : template &lt;typename T&gt;</span></a>
<span class="lineNum">    2147 </span><span class="lineCov">  206148578 : inline WI_UNARY_RESULT (T)</span>
<span class="lineNum">    2148 </span><span class="lineCov">  226633931 : wi::abs (const T &amp;x)</span>
<span class="lineNum">    2149 </span><span class="lineCov">  204409887 : {</span>
<span class="lineNum">    2150 </span><span class="lineCov">  100007786 :   return neg_p (x) ? neg (x) : WI_UNARY_RESULT (T) (x);</span>
<span class="lineNum">    2151 </span><span class="lineCov">  225654585 : }</span>
<span class="lineNum">    2152 </span><span class="lineCov">      61754 : </span>
<span class="lineNum">    2153 </span><span class="lineCov">    1380898 : /* Return the result of sign-extending the low OFFSET bits of X.  */</span>
<a name="2154"><span class="lineNum">    2154 </span><span class="lineCov">    4583423 : template &lt;typename T&gt;</span></a>
<span class="lineNum">    2155 </span><span class="lineCov">   20520872 : inline WI_UNARY_RESULT (T)</span>
<span class="lineNum">    2156 </span><span class="lineCov">       9427 : wi::sext (const T &amp;x, unsigned int offset)</span>
<span class="lineNum">    2157 </span><span class="lineCov">    1139638 : {</span>
<span class="lineNum">    2158 </span><span class="lineCov">   20512873 :   WI_UNARY_RESULT_VAR (result, val, T, x);</span>
<span class="lineNum">    2159 </span><span class="lineCov">   23461058 :   unsigned int precision = get_precision (result);</span>
<span class="lineNum">    2160 </span><span class="lineCov">   20969357 :   WIDE_INT_REF_FOR (T) xi (x, precision);</span>
<span class="lineNum">    2161 </span><span class="lineCov"> 3523785026 : </span>
<span class="lineNum">    2162 </span><span class="lineCov">   27729662 :   if (offset &lt;= HOST_BITS_PER_WIDE_INT)</span>
<span class="lineNum">    2163 </span><span class="lineCov"> 7021332962 :     {</span>
<span class="lineNum">    2164 </span><span class="lineCov"> 6256389412 :       val[0] = sext_hwi (xi.ulow (), offset);</span>
<span class="lineNum">    2165 </span><span class="lineCov"> 5767739258 :       result.set_len (1, true);</span>
<span class="lineNum">    2166 </span><span class="lineCov">     895205 :     }</span>
<span class="lineNum">    2167 </span><span class="lineCov">     457921 :   else</span>
<span class="lineNum">    2168 </span><span class="lineCov">    2952302 :     result.set_len (sext_large (val, xi.val, xi.len, precision, offset));</span>
<span class="lineNum">    2169 </span><span class="lineCov">  764496498 :   return result;</span>
<span class="lineNum">    2170 </span><span class="lineCov">      72816 : }</span>
<span class="lineNum">    2171 </span><span class="lineCov">        501 : </span>
<span class="lineNum">    2172 </span><span class="lineCov">     938981 : /* Return the result of zero-extending the low OFFSET bits of X.  */</span>
<a name="2173"><span class="lineNum">    2173 </span><span class="lineCov">  700723563 : template &lt;typename T&gt;</span></a>
<span class="lineNum">    2174 </span><span class="lineCov">      62553 : inline WI_UNARY_RESULT (T)</span>
<span class="lineNum">    2175 </span><span class="lineCov">   76642173 : wi::zext (const T &amp;x, unsigned int offset)</span>
<span class="lineNum">    2176 </span><span class="lineCov">      62819 : {</span>
<span class="lineNum">    2177 </span><span class="lineCov">  246361917 :   WI_UNARY_RESULT_VAR (result, val, T, x);</span>
<span class="lineNum">    2178 </span><span class="lineCov">  959852899 :   unsigned int precision = get_precision (result);</span>
<span class="lineNum">    2179 </span><span class="lineCov"> 1211130935 :   WIDE_INT_REF_FOR (T) xi (x, precision);</span>
<span class="lineNum">    2180 </span><span class="lineCov">    2110718 : </span>
<span class="lineNum">    2181 </span><span class="lineCov"> 4674246435 :   /* This is not just an optimization, it is actually required to</span>
<span class="lineNum">    2182 </span><span class="lineCov"> 2053830014 :      maintain canonization.  */</span>
<span class="lineNum">    2183 </span><span class="lineCov"> 1929579810 :   if (offset &gt;= precision)</span>
<span class="lineNum">    2184 </span><span class="lineCov">    1057150 :     {</span>
<span class="lineNum">    2185 </span><span class="lineCov"> 2742253493 :       wi::copy (result, xi);</span>
<span class="lineNum">    2186 </span><span class="lineCov"> 2034321165 :       return result;</span>
<span class="lineNum">    2187 </span><span class="lineCov">    1056349 :     }</span>
<span class="lineNum">    2188 </span><span class="lineCov">  714992888 : </span>
<span class="lineNum">    2189 </span><span class="lineCov">  707935091 :   /* In these cases we know that at least the top bit will be clear,</span>
<span class="lineNum">    2190 </span><span class="lineCov">  723390911 :      so no sign extension is necessary.  */</span>
<span class="lineNum">    2191 </span><span class="lineCov">   99447871 :   if (offset &lt; HOST_BITS_PER_WIDE_INT)</span>
<span class="lineNum">    2192 </span><span class="lineCov">  715565210 :     {</span>
<span class="lineNum">    2193 </span><span class="lineCov">     786527 :       val[0] = zext_hwi (xi.ulow (), offset);</span>
<span class="lineNum">    2194 </span><span class="lineCov">   12774483 :       result.set_len (1, true);</span>
<span class="lineNum">    2195 </span><span class="lineCov">     552422 :     }</span>
<span class="lineNum">    2196 </span><span class="lineCov">  650316594 :   else</span>
<span class="lineNum">    2197 </span><span class="lineCov">    7452055 :     result.set_len (zext_large (val, xi.val, xi.len, precision, offset), true);</span>
<span class="lineNum">    2198 </span><span class="lineCov"> 1300233116 :   return result;</span>
<span class="lineNum">    2199 </span><span class="lineCov"> 2264683880 : }</span>
<span class="lineNum">    2200 </span><span class="lineCov">  656966088 : </span>
<span class="lineNum">    2201 </span><span class="lineCov">   22344969 : /* Return the result of extending the low OFFSET bits of X according to</span>
<span class="lineNum">    2202 </span><span class="lineCov">  761773164 :    signedness SGN.  */</span>
<a name="2203"><span class="lineNum">    2203 </span><span class="lineCov">  961878845 : template &lt;typename T&gt;</span></a>
<span class="lineNum">    2204 </span><span class="lineCov"> 2492796273 : inline WI_UNARY_RESULT (T)</span>
<span class="lineNum">    2205 </span><span class="lineCov"> 1587093070 : wi::ext (const T &amp;x, unsigned int offset, signop sgn)</span>
<span class="lineNum">    2206 </span><span class="lineCov"> 1638805580 : {</span>
<span class="lineNum">    2207 </span><span class="lineCov">  832178412 :   return sgn == SIGNED ? sext (x, offset) : zext (x, offset);</span>
<span class="lineNum">    2208 </span><span class="lineCov">   56338520 : }</span>
<span class="lineNum">    2209 </span><span class="lineCov">  821124098 : </span>
<span class="lineNum">    2210 </span><span class="lineCov">  861794892 : /* Return an integer that represents X | (1 &lt;&lt; bit).  */</span>
<a name="2211"><span class="lineNum">    2211 </span><span class="lineCov">  775341157 : template &lt;typename T&gt;</span></a>
<span class="lineNum">    2212 </span><span class="lineCov">  761769635 : inline WI_UNARY_RESULT (T)</span>
<span class="lineNum">    2213 </span><span class="lineCov">  649845778 : wi::set_bit (const T &amp;x, unsigned int bit)</span>
<span class="lineNum">    2214 </span><span class="lineCov">    2417153 : {</span>
<span class="lineNum">    2215 </span><span class="lineCov">      18530 :   WI_UNARY_RESULT_VAR (result, val, T, x);</span>
<span class="lineNum">    2216 </span><span class="lineCov">  644744175 :   unsigned int precision = get_precision (result);</span>
<span class="lineNum">    2217 </span><span class="lineCov">    3992963 :   WIDE_INT_REF_FOR (T) xi (x, precision);</span>
<span class="lineNum">    2218 </span><span class="lineCov">    2509971 :   if (precision &lt;= HOST_BITS_PER_WIDE_INT)</span>
<span class="lineNum">    2219 </span><span class="lineCov">    3813697 :     {</span>
<span class="lineNum">    2220 </span><span class="lineCov">  647590497 :       val[0] = xi.ulow () | (HOST_WIDE_INT_1U &lt;&lt; bit);</span>
<span class="lineNum">    2221 </span><span class="lineCov">   33040971 :       result.set_len (1);</span>
<span class="lineNum">    2222 </span><span class="lineCov">      32167 :     }</span>
<span class="lineNum">    2223 </span><span class="lineCov">  708340930 :   else</span>
<span class="lineNum">    2224 </span><span class="lineCov">  706752987 :     result.set_len (set_bit_large (val, xi.val, xi.len, precision, bit));</span>
<span class="lineNum">    2225 </span><span class="lineCov">  704697143 :   return result;</span>
<span class="lineNum">    2226 </span><span class="lineCov">   65782620 : }</span>
<span class="lineNum">    2227 </span><span class="lineCov">  686493176 : </span>
<span class="lineNum">    2228 </span><span class="lineCov">   38023798 : /* Return the mininum of X and Y, treating them both as having</span>
<span class="lineNum">    2229 </span><span class="lineCov">   36275110 :    signedness SGN.  */</span>
<a name="2230"><span class="lineNum">    2230 </span><span class="lineCov">    4879654 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    2231 </span><span class="lineCov">    7264821 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2232 </span><span class="lineCov">       6070 : wi::min (const T1 &amp;x, const T2 &amp;y, signop sgn)</span>
<span class="lineNum">    2233 </span><span class="lineCov">   10715282 : {</span>
<span class="lineNum">    2234 </span><span class="lineCov">   23569811 :   WI_BINARY_RESULT_VAR (result, val ATTRIBUTE_UNUSED, T1, x, T2, y);</span>
<span class="lineNum">    2235 </span><span class="lineCov">    6842766 :   unsigned int precision = get_precision (result);</span>
<span class="lineNum">    2236 </span><span class="lineCov">    8117355 :   if (wi::le_p (x, y, sgn))</span>
<span class="lineNum">    2237 </span><span class="lineCov">    7586162 :     wi::copy (result, WIDE_INT_REF_FOR (T1) (x, precision));</span>
<span class="lineNum">    2238 </span><span class="lineCov">   18583048 :   else</span>
<span class="lineNum">    2239 </span><span class="lineCov">    1160939 :     wi::copy (result, WIDE_INT_REF_FOR (T2) (y, precision));</span>
<span class="lineNum">    2240 </span><span class="lineCov">   18392091 :   return result;</span>
<span class="lineNum">    2241 </span><span class="lineCov">   19525692 : }</span>
<span class="lineNum">    2242 </span><span class="lineCov">    6403513 : </span>
<span class="lineNum">    2243 </span><span class="lineCov">  217326518 : /* Return the minimum of X and Y, treating both as signed values.  */</span>
<a name="2244"><span class="lineNum">    2244 </span><span class="lineCov">    3966754 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    2245 </span><span class="lineCov">     380157 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2246 </span><span class="lineCov">   13418487 : wi::smin (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    2247 </span><span class="lineCov">     571113 : {</span>
<span class="lineNum">    2248 </span><span class="lineCov">     325460 :   return wi::min (x, y, SIGNED);</span>
<span class="lineNum">    2249 </span><span class="lineCov">   10236353 : }</span>
<span class="lineNum">    2250 </span><span class="lineCov">    1179711 : </span>
<span class="lineNum">    2251 </span><span class="lineCov">   22223591 : /* Return the minimum of X and Y, treating both as unsigned values.  */</span>
<a name="2252"><span class="lineNum">    2252 </span><span class="lineCov">   18008836 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    2253 </span><span class="lineCov">   11825996 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2254 </span><span class="lineCov">     206475 : wi::umin (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    2255 </span><span class="lineCov">    6433176 : {</span>
<span class="lineNum">    2256 </span><span class="lineCov">    2559722 :   return wi::min (x, y, UNSIGNED);</span>
<span class="lineNum">    2257 </span><span class="lineCov">    3013138 : }</span>
<span class="lineNum">    2258 </span><span class="lineCov">    3982006 : </span>
<span class="lineNum">    2259 </span><span class="lineCov">    1019228 : /* Return the maxinum of X and Y, treating them both as having</span>
<span class="lineNum">    2260 </span><span class="lineCov">  205345482 :    signedness SGN.  */</span>
<a name="2261"><span class="lineNum">    2261 </span><span class="lineCov">    1523352 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    2262 </span><span class="lineCov">  413801266 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2263 </span><span class="lineCov"> 1474452780 : wi::max (const T1 &amp;x, const T2 &amp;y, signop sgn)</span>
<span class="lineNum">    2264 </span><span class="lineCov"> 1511059659 : {</span>
<span class="lineNum">    2265 </span><span class="lineCov"> 1067760070 :   WI_BINARY_RESULT_VAR (result, val ATTRIBUTE_UNUSED, T1, x, T2, y);</span>
<span class="lineNum">    2266 </span><span class="lineCov">  479938536 :   unsigned int precision = get_precision (result);</span>
<span class="lineNum">    2267 </span><span class="lineCov">  480195672 :   if (wi::ge_p (x, y, sgn))</span>
<span class="lineNum">    2268 </span><span class="lineCov">  478063735 :     wi::copy (result, WIDE_INT_REF_FOR (T1) (x, precision));</span>
<span class="lineNum">    2269 </span><span class="lineCov">  532256366 :   else</span>
<span class="lineNum">    2270 </span><span class="lineCov">  239863519 :     wi::copy (result, WIDE_INT_REF_FOR (T2) (y, precision));</span>
<span class="lineNum">    2271 </span><span class="lineCov">    1102661 :   return result;</span>
<span class="lineNum">    2272 </span><span class="lineCov">  239269295 : }</span>
<span class="lineNum">    2273 </span><span class="lineCov">  771610144 : </span>
<span class="lineNum">    2274 </span><span class="lineCov">     538875 : /* Return the maximum of X and Y, treating both as signed values.  */</span>
<a name="2275"><span class="lineNum">    2275 </span><span class="lineCov">    9378616 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    2276 </span><span class="lineCov">    2660916 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2277 </span><span class="lineCov">  597742096 : wi::smax (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    2278 </span><span class="lineCov">  154775471 : {</span>
<span class="lineNum">    2279 </span><span class="lineCov">  152996225 :   return wi::max (x, y, SIGNED);</span>
<span class="lineNum">    2280 </span><span class="lineCov">  204154943 : }</span>
<span class="lineNum">    2281 </span><span class="lineCov">    1171199 : </span>
<span class="lineNum">    2282 </span><span class="lineCov">   76475963 : /* Return the maximum of X and Y, treating both as unsigned values.  */</span>
<a name="2283"><span class="lineNum">    2283 </span><span class="lineCov">    2815049 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    2284 </span><span class="lineCov">  217903522 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2285 </span><span class="lineCov">    1132821 : wi::umax (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    2286 </span><span class="lineCov">   27595160 : {</span>
<span class="lineNum">    2287 </span><span class="lineCov">  231678927 :   return wi::max (x, y, UNSIGNED);</span>
<span class="lineNum">    2288 </span><span class="lineCov">  232843097 : }</span>
<span class="lineNum">    2289 </span><span class="lineCov">  205216564 : </span>
<span class="lineNum">    2290 </span><span class="lineCov">  113137266 : /* Return X &amp; Y.  */</span>
<a name="2291"><span class="lineNum">    2291 </span><span class="lineCov">  232409819 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    2292 </span><span class="lineCov">    1165187 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2293 </span><span class="lineCov">     237845 : wi::bit_and (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    2294 </span><span class="lineCov">      52700 : {</span>
<span class="lineNum">    2295 </span><span class="lineCov">      29175 :   WI_BINARY_RESULT_VAR (result, val, T1, x, T2, y);</span>
<span class="lineNum">    2296 </span><span class="lineCov">      45582 :   unsigned int precision = get_precision (result);</span>
<span class="lineNum">    2297 </span><span class="lineCov">      39448 :   WIDE_INT_REF_FOR (T1) xi (x, precision);</span>
<span class="lineNum">    2298 </span><span class="lineCov">     122621 :   WIDE_INT_REF_FOR (T2) yi (y, precision);</span>
<span class="lineNum">    2299 </span><span class="lineCov">    2099136 :   bool is_sign_extended = xi.is_sign_extended &amp;&amp; yi.is_sign_extended;</span>
<span class="lineNum">    2300 </span><span class="lineCov">      48251 :   if (__builtin_expect (xi.len + yi.len == 2, true))</span>
<span class="lineNum">    2301 </span><span class="lineCov">  544420502 :     {</span>
<span class="lineNum">    2302 </span><span class="lineCov">    4147046 :       val[0] = xi.ulow () &amp; yi.ulow ();</span>
<span class="lineNum">    2303 </span><span class="lineCov"> 1089902333 :       result.set_len (1, is_sign_extended);</span>
<span class="lineNum">    2304 </span><span class="lineCov">  540301873 :     }</span>
<span class="lineNum">    2305 </span><span class="lineCov">  550344366 :   else</span>
<span class="lineNum">    2306 </span><span class="lineCov">      20285 :     result.set_len (and_large (val, xi.val, xi.len, yi.val, yi.len,</span>
<span class="lineNum">    2307 </span><span class="lineCov">  141584705 :                                precision), is_sign_extended);</span>
<span class="lineNum">    2308 </span><span class="lineCov">   15007756 :   return result;</span>
<span class="lineNum">    2309 </span><span class="lineCov">  800899236 : }</span>
<span class="lineNum">    2310 </span><span class="lineCov">  253166966 : </span>
<span class="lineNum">    2311 </span><span class="lineCov">  261821009 : /* Return X &amp; ~Y.  */</span>
<a name="2312"><span class="lineNum">    2312 </span><span class="lineCov">     119270 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    2313 </span><span class="lineCov">  618343418 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2314 </span><span class="lineCov">     119087 : wi::bit_and_not (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    2315 </span><span class="lineCov">  145752013 : {</span>
<span class="lineNum">    2316 </span><span class="lineCov">  126377632 :   WI_BINARY_RESULT_VAR (result, val, T1, x, T2, y);</span>
<span class="lineNum">    2317 </span><span class="lineCov">      33040 :   unsigned int precision = get_precision (result);</span>
<span class="lineNum">    2318 </span><span class="lineCov">    9943591 :   WIDE_INT_REF_FOR (T1) xi (x, precision);</span>
<span class="lineNum">    2319 </span><span class="lineCov">     260141 :   WIDE_INT_REF_FOR (T2) yi (y, precision);</span>
<span class="lineNum">    2320 </span><span class="lineCov">  134119351 :   bool is_sign_extended = xi.is_sign_extended &amp;&amp; yi.is_sign_extended;</span>
<span class="lineNum">    2321 </span><span class="lineCov">    8706788 :   if (__builtin_expect (xi.len + yi.len == 2, true))</span>
<span class="lineNum">    2322 </span><span class="lineCov">    9831237 :     {</span>
<span class="lineNum">    2323 </span><span class="lineCov">    1358713 :       val[0] = xi.ulow () &amp; ~yi.ulow ();</span>
<span class="lineNum">    2324 </span><span class="lineCov">       9078 :       result.set_len (1, is_sign_extended);</span>
<span class="lineNum">    2325 </span><span class="lineCov">     361484 :     }</span>
<span class="lineNum">    2326 </span><span class="lineCov">    8611555 :   else</span>
<span class="lineNum">    2327 </span><span class="lineCov">     166251 :     result.set_len (and_not_large (val, xi.val, xi.len, yi.val, yi.len,</span>
<span class="lineNum">    2328 </span><span class="lineCov">   17245516 :                                    precision), is_sign_extended);</span>
<span class="lineNum">    2329 </span><span class="lineCov">   16972338 :   return result;</span>
<span class="lineNum">    2330 </span><span class="lineCov">   16857372 : }</span>
<span class="lineNum">    2331 </span><span class="lineCov">     468531 : </span>
<span class="lineNum">    2332 </span><span class="lineCov">   12350880 : /* Return X | Y.  */</span>
<a name="2333"><span class="lineNum">    2333 </span><span class="lineCov">    1033499 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    2334 </span><span class="lineCov">   18053973 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2335 </span><span class="lineCov">    4041585 : wi::bit_or (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    2336 </span><span class="lineCov">   62930736 : {</span>
<span class="lineNum">    2337 </span><span class="lineCov">      97462 :   WI_BINARY_RESULT_VAR (result, val, T1, x, T2, y);</span>
<span class="lineNum">    2338 </span><span class="lineCov">  125339387 :   unsigned int precision = get_precision (result);</span>
<span class="lineNum">    2339 </span><span class="lineCov">  130607583 :   WIDE_INT_REF_FOR (T1) xi (x, precision);</span>
<span class="lineNum">    2340 </span><span class="lineCov">   62731481 :   WIDE_INT_REF_FOR (T2) yi (y, precision);</span>
<span class="lineNum">    2341 </span><span class="lineCov">    3396014 :   bool is_sign_extended = xi.is_sign_extended &amp;&amp; yi.is_sign_extended;</span>
<span class="lineNum">    2342 </span><span class="lineCov">     109867 :   if (__builtin_expect (xi.len + yi.len == 2, true))</span>
<span class="lineNum">    2343 </span><span class="lineCov">    3444039 :     {</span>
<span class="lineNum">    2344 </span><span class="lineCov">    1325819 :       val[0] = xi.ulow () | yi.ulow ();</span>
<span class="lineNum">    2345 </span><span class="lineCov">    5804624 :       result.set_len (1, is_sign_extended);</span>
<span class="lineNum">    2346 </span><span class="lineCov">    2071205 :     }</span>
<span class="lineNum">    2347 </span><span class="lineCov">      48910 :   else</span>
<span class="lineNum">    2348 </span><span class="lineCov">     494193 :     result.set_len (or_large (val, xi.val, xi.len,</span>
<span class="lineNum">    2349 </span><span class="lineCov">      25990 :                               yi.val, yi.len, precision), is_sign_extended);</span>
<span class="lineNum">    2350 </span><span class="lineCov">      58727 :   return result;</span>
<span class="lineNum">    2351 </span><span class="lineCov">    5587088 : }</span>
<span class="lineNum">    2352 </span><span class="lineCov">     101414 : </span>
<span class="lineNum">    2353 </span><span class="lineCov">   67801805 : /* Return X | ~Y.  */</span>
<span class="lineNum">    2354 </span><span class="lineCov">    3535788 : template &lt;typename T1, typename T2&gt;</span>
<span class="lineNum">    2355 </span><span class="lineCov">    3732401 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2356 </span><span class="lineCov">   75894364 : wi::bit_or_not (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    2357 </span><span class="lineCov">    1047767 : {</span>
<span class="lineNum">    2358 </span><span class="lineCov">   16872312 :   WI_BINARY_RESULT_VAR (result, val, T1, x, T2, y);</span>
<span class="lineNum">    2359 </span><span class="lineCov">   14724851 :   unsigned int precision = get_precision (result);</span>
<span class="lineNum">    2360 </span><span class="lineCov">   77276904 :   WIDE_INT_REF_FOR (T1) xi (x, precision);</span>
<span class="lineNum">    2361 </span><span class="lineCov">     588182 :   WIDE_INT_REF_FOR (T2) yi (y, precision);</span>
<span class="lineNum">    2362 </span><span class="lineCov">    7638052 :   bool is_sign_extended = xi.is_sign_extended &amp;&amp; yi.is_sign_extended;</span>
<span class="lineNum">    2363 </span><span class="lineCov">   62612087 :   if (__builtin_expect (xi.len + yi.len == 2, true))</span>
<span class="lineNum">    2364 </span><span class="lineCov">   70628390 :     {</span>
<span class="lineNum">    2365 </span><span class="lineCov">   70464991 :       val[0] = xi.ulow () | ~yi.ulow ();</span>
<span class="lineNum">    2366 </span><span class="lineCov">   20018894 :       result.set_len (1, is_sign_extended);</span>
<span class="lineNum">    2367 </span><span class="lineCov">   65536861 :     }</span>
<span class="lineNum">    2368 </span><span class="lineCov">    2788226 :   else</span>
<span class="lineNum">    2369 </span><span class="lineCov">    3385734 :     result.set_len (or_not_large (val, xi.val, xi.len, yi.val, yi.len,</span>
<span class="lineNum">    2370 </span><span class="lineCov">     302516 :                                   precision), is_sign_extended);</span>
<span class="lineNum">    2371 </span><span class="lineCov"> 2034097686 :   return result;</span>
<span class="lineNum">    2372 </span><span class="lineCov">    9628236 : }</span>
<span class="lineNum">    2373 </span><span class="lineCov"> 4066635212 : </span>
<span class="lineNum">    2374 </span><span class="lineCov"> 4066547106 : /* Return X ^ Y.  */</span>
<a name="2375"><span class="lineNum">    2375 </span><span class="lineCov"> 4065463809 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    2376 </span><span class="lineCov">     410843 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2377 </span><span class="lineCov">     197937 : wi::bit_xor (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    2378 </span><span class="lineCov">    8126488 : {</span>
<span class="lineNum">    2379 </span><span class="lineCov">     269406 :   WI_BINARY_RESULT_VAR (result, val, T1, x, T2, y);</span>
<span class="lineNum">    2380 </span><span class="lineCov">    6539046 :   unsigned int precision = get_precision (result);</span>
<span class="lineNum">    2381 </span><span class="lineCov">    2368145 :   WIDE_INT_REF_FOR (T1) xi (x, precision);</span>
<span class="lineNum">    2382 </span><span class="lineCov">     115513 :   WIDE_INT_REF_FOR (T2) yi (y, precision);</span>
<span class="lineNum">    2383 </span><span class="lineCov">    4259533 :   bool is_sign_extended = xi.is_sign_extended &amp;&amp; yi.is_sign_extended;</span>
<span class="lineNum">    2384 </span><span class="lineCov">     268981 :   if (__builtin_expect (xi.len + yi.len == 2, true))</span>
<span class="lineNum">    2385 </span><span class="lineCov">    5881909 :     {</span>
<span class="lineNum">    2386 </span><span class="lineCov">     436926 :       val[0] = xi.ulow () ^ yi.ulow ();</span>
<span class="lineNum">    2387 </span><span class="lineCov">    6084831 :       result.set_len (1, is_sign_extended);</span>
<span class="lineNum">    2388 </span><span class="lineCov">    2362251 :     }</span>
<span class="lineNum">    2389 </span><span class="lineCov">     404892 :   else</span>
<span class="lineNum">    2390 </span><span class="lineCov">    4093993 :     result.set_len (xor_large (val, xi.val, xi.len,</span>
<span class="lineNum">    2391 </span><span class="lineCov"> 2321894368 :                                yi.val, yi.len, precision), is_sign_extended);</span>
<span class="lineNum">    2392 </span><span class="lineCov">     677866 :   return result;</span>
<span class="lineNum">    2393 </span><span class="lineCov">  579355882 : }</span>
<span class="lineNum">    2394 </span><span class="lineCov">  579753550 : </span>
<span class="lineNum">    2395 </span><span class="lineCov"> 2611811103 : /* Return X + Y.  */</span>
<a name="2396"><span class="lineNum">    2396 </span><span class="lineCov"> 2032173887 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    2397 </span><span class="lineCov">  289865119 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2398 </span><span class="lineCov">    7153877 : wi::add (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    2399 </span><span class="lineCov">  289079040 : {</span>
<span class="lineNum">    2400 </span><span class="lineCov">  303176641 :   WI_BINARY_RESULT_VAR (result, val, T1, x, T2, y);</span>
<span class="lineNum">    2401 </span><span class="lineCov">   14252178 :   unsigned int precision = get_precision (result);</span>
<span class="lineNum">    2402 </span><span class="lineCov">   14387411 :   WIDE_INT_REF_FOR (T1) xi (x, precision);</span>
<span class="lineNum">    2403 </span><span class="lineCov">     675548 :   WIDE_INT_REF_FOR (T2) yi (y, precision);</span>
<span class="lineNum">    2404 </span><span class="lineCov">  296706695 :   if (precision &lt;= HOST_BITS_PER_WIDE_INT)</span>
<span class="lineNum">    2405 </span><span class="lineCov">     140133 :     {</span>
<span class="lineNum">    2406 </span><span class="lineCov">    7835922 :       val[0] = xi.ulow () + yi.ulow ();</span>
<span class="lineNum">    2407 </span><span class="lineCov">    6524615 :       result.set_len (1);</span>
<span class="lineNum">    2408 </span><span class="lineCov">        584 :     }</span>
<span class="lineNum">    2409 </span><span class="lineCov">      10394 :   /* If the precision is known at compile time to be greater than</span>
<span class="lineNum">    2410 </span><span class="lineCov">   67005698 :      HOST_BITS_PER_WIDE_INT, we can optimize the single-HWI case</span>
<span class="lineNum">    2411 </span><span class="lineCov">     734188 :      knowing that (a) all bits in those HWIs are significant and</span>
<span class="lineNum">    2412 </span><span class="lineCov">  134030758 :      (b) the result has room for at least two HWIs.  This provides</span>
<span class="lineNum">    2413 </span><span class="lineCov">  140439052 :      a fast path for things like offset_int and widest_int.</span>
<span class="lineNum">    2414 </span><span class="lineCov">  134280658 : </span>
<span class="lineNum">    2415 </span><span class="lineCov">     269847 :      The STATIC_CONSTANT_P test prevents this path from being</span>
<span class="lineNum">    2416 </span><span class="lineCov">     512902 :      used for wide_ints.  wide_ints with precisions greater than</span>
<span class="lineNum">    2417 </span><span class="lineCov">     719604 :      HOST_BITS_PER_WIDE_INT are relatively rare and there's not much</span>
<span class="lineNum">    2418 </span><span class="lineCov">  100554565 :      point handling them inline.  */</span>
<span class="lineNum">    2419 </span><span class="lineCov">   10337043 :   else if (STATIC_CONSTANT_P (precision &gt; HOST_BITS_PER_WIDE_INT)</span>
<span class="lineNum">    2420 </span><span class="lineCov">   33819456 :            &amp;&amp; __builtin_expect (xi.len + yi.len == 2, true))</span>
<span class="lineNum">    2421 </span><span class="lineCov">   76079102 :     {</span>
<span class="lineNum">    2422 </span><span class="lineCov">   36761489 :       unsigned HOST_WIDE_INT xl = xi.ulow ();</span>
<span class="lineNum">    2423 </span><span class="lineCov">   66004742 :       unsigned HOST_WIDE_INT yl = yi.ulow ();</span>
<span class="lineNum">    2424 </span><span class="lineCov">   39147853 :       unsigned HOST_WIDE_INT resultl = xl + yl;</span>
<span class="lineNum">    2425 </span><span class="lineCov">      72591 :       val[0] = resultl;</span>
<span class="lineNum">    2426 </span><span class="lineCov">  166098432 :       val[1] = (HOST_WIDE_INT) resultl &lt; 0 ? 0 : -1;</span>
<span class="lineNum">    2427 </span><span class="lineCov">   32931702 :       result.set_len (1 + (((resultl ^ xl) &amp; (resultl ^ yl))</span>
<span class="lineNum">    2428 </span><span class="lineCov">   23613542 :                            &gt;&gt; (HOST_BITS_PER_WIDE_INT - 1)));</span>
<span class="lineNum">    2429 </span><span class="lineCov">   23603949 :     }</span>
<span class="lineNum">    2430 </span><span class="lineCov">      42077 :   else</span>
<span class="lineNum">    2431 </span><span class="lineCov">     110097 :     result.set_len (add_large (val, xi.val, xi.len,</span>
<span class="lineNum">    2432 </span><span class="lineCov">   44404200 :                                yi.val, yi.len, precision,</span>
<span class="lineNum">    2433 </span><span class="lineCov">    9740134 :                                UNSIGNED, 0));</span>
<span class="lineNum">    2434 </span><span class="lineCov">     886581 :   return result;</span>
<span class="lineNum">    2435 </span><span class="lineCov">    9696519 : }</span>
<span class="lineNum">    2436 </span><span class="lineCov">    4860159 : </span>
<span class="lineNum">    2437 </span><span class="lineCov">    6741252 : /* Return X + Y.  Treat X and Y as having the signednes given by SGN</span>
<span class="lineNum">    2438 </span><span class="lineCov">    6433875 :    and indicate in *OVERFLOW whether the operation overflowed.  */</span>
<a name="2439"><span class="lineNum">    2439 </span><span class="lineCov">   13501945 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    2440 </span><span class="lineCov">  156306349 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2441 </span><span class="lineCov">  232338452 : wi::add (const T1 &amp;x, const T2 &amp;y, signop sgn, overflow_type *overflow)</span>
<span class="lineNum">    2442 </span><span class="lineCov">  156288146 : {</span>
<span class="lineNum">    2443 </span><span class="lineCov">  437704651 :   WI_BINARY_RESULT_VAR (result, val, T1, x, T2, y);</span>
<span class="lineNum">    2444 </span><span class="lineCov">  218895378 :   unsigned int precision = get_precision (result);</span>
<span class="lineNum">    2445 </span><span class="lineCov">  437673837 :   WIDE_INT_REF_FOR (T1) xi (x, precision);</span>
<span class="lineNum">    2446 </span><span class="lineCov">    5016304 :   WIDE_INT_REF_FOR (T2) yi (y, precision);</span>
<span class="lineNum">    2447 </span><span class="lineCov">      34817 :   if (precision &lt;= HOST_BITS_PER_WIDE_INT)</span>
<span class="lineNum">    2448 </span><span class="lineCov">      38133 :     {</span>
<span class="lineNum">    2449 </span><span class="lineCov">  219079304 :       unsigned HOST_WIDE_INT xl = xi.ulow ();</span>
<span class="lineNum">    2450 </span><span class="lineCov">     792230 :       unsigned HOST_WIDE_INT yl = yi.ulow ();</span>
<span class="lineNum">    2451 </span><span class="lineCov">     178890 :       unsigned HOST_WIDE_INT resultl = xl + yl;</span>
<span class="lineNum">    2452 </span><span class="lineCov">    1053868 :       if (sgn == SIGNED)</span>
<span class="lineNum">    2453 </span><span class="lineCov">  221023656 :         {</span>
<span class="lineNum">    2454 </span><span class="lineCov">   36164691 :           if ((((resultl ^ xl) &amp; (resultl ^ yl))</span>
<span class="lineNum">    2455 </span><span class="lineCov">   64916354 :                &gt;&gt; (precision - 1)) &amp; 1)</span>
<span class="lineNum">    2456 </span><span class="lineCov">    6129969 :             {</span>
<span class="lineNum">    2457 </span><span class="lineCov">    4912533 :               if (xl &gt; resultl)</span>
<span class="lineNum">    2458 </span><span class="lineCov">    8506382 :                 *overflow = OVF_UNDERFLOW;</span>
<span class="lineNum">    2459 </span><span class="lineCov">    9303893 :               else if (xl &lt; resultl)</span>
<span class="lineNum">    2460 </span><span class="lineCov">   19310501 :                 *overflow = OVF_OVERFLOW;</span>
<span class="lineNum">    2461 </span><span class="lineCov">   16180096 :               else</span>
<span class="lineNum">    2462 </span><span class="lineCov">   31475299 :                 *overflow = OVF_NONE;</span>
<span class="lineNum">    2463 </span><span class="lineCov">   10207552 :             }</span>
<span class="lineNum">    2464 </span><span class="lineCov">   10479981 :           else</span>
<span class="lineNum">    2465 </span><span class="lineCov">   21386121 :             *overflow = OVF_NONE;</span>
<span class="lineNum">    2466 </span><span class="lineCov">   14316645 :         }</span>
<span class="lineNum">    2467 </span><span class="lineCov">   12682921 :       else</span>
<span class="lineNum">    2468 </span><span class="lineCov">    1749643 :         *overflow = ((resultl &lt;&lt; (HOST_BITS_PER_WIDE_INT - precision))</span>
<span class="lineNum">    2469 </span><span class="lineCov">    8364799 :                      &lt; (xl &lt;&lt; (HOST_BITS_PER_WIDE_INT - precision)))</span>
<span class="lineNum">    2470 </span><span class="lineCov">    4889474 :           ? OVF_OVERFLOW : OVF_NONE;</span>
<span class="lineNum">    2471 </span><span class="lineCov">   12166374 :       val[0] = resultl;</span>
<span class="lineNum">    2472 </span><span class="lineCov">    5071689 :       result.set_len (1);</span>
<span class="lineNum">    2473 </span><span class="lineCov">   25558890 :     }</span>
<span class="lineNum">    2474 </span><span class="lineCov">   30580860 :   else</span>
<span class="lineNum">    2475 </span><span class="lineCov">   16300714 :     result.set_len (add_large (val, xi.val, xi.len,</span>
<span class="lineNum">    2476 </span><span class="lineCov">   29306305 :                                yi.val, yi.len, precision,</span>
<span class="lineNum">    2477 </span><span class="lineCov">    6724287 :                                sgn, overflow));</span>
<span class="lineNum">    2478 </span><span class="lineCov">    4821068 :   return result;</span>
<span class="lineNum">    2479 </span><span class="lineCov">   12411139 : }</span>
<span class="lineNum">    2480 </span><span class="lineCov">    2625331 : </span>
<span class="lineNum">    2481 </span><span class="lineCov">    2514844 : /* Return X - Y.  */</span>
<a name="2482"><span class="lineNum">    2482 </span><span class="lineCov">  676793689 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    2483 </span><span class="lineCov">    2406528 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2484 </span><span class="lineCov">      47335 : wi::sub (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    2485 </span><span class="lineCov">      61529 : {</span>
<span class="lineNum">    2486 </span><span class="lineCov">     149465 :   WI_BINARY_RESULT_VAR (result, val, T1, x, T2, y);</span>
<span class="lineNum">    2487 </span><span class="lineCov">     159341 :   unsigned int precision = get_precision (result);</span>
<span class="lineNum">    2488 </span><span class="lineCov">   57393007 :   WIDE_INT_REF_FOR (T1) xi (x, precision);</span>
<span class="lineNum">    2489 </span><span class="lineCov">    3248072 :   WIDE_INT_REF_FOR (T2) yi (y, precision);</span>
<span class="lineNum">    2490 </span><span class="lineCov">  114630470 :   if (precision &lt;= HOST_BITS_PER_WIDE_INT)</span>
<span class="lineNum">    2491 </span><span class="lineCov">   60696772 :     {</span>
<span class="lineNum">    2492 </span><span class="lineCov">   61401223 :       val[0] = xi.ulow () - yi.ulow ();</span>
<span class="lineNum">    2493 </span><span class="lineCov">   14714356 :       result.set_len (1);</span>
<span class="lineNum">    2494 </span><span class="lineCov">   61783649 :     }</span>
<span class="lineNum">    2495 </span><span class="lineCov">   24942817 :   /* If the precision is known at compile time to be greater than</span>
<span class="lineNum">    2496 </span><span class="lineCov">   24050756 :      HOST_BITS_PER_WIDE_INT, we can optimize the single-HWI case</span>
<span class="lineNum">    2497 </span><span class="lineCov">   66050604 :      knowing that (a) all bits in those HWIs are significant and</span>
<span class="lineNum">    2498 </span><span class="lineCov">   11390925 :      (b) the result has room for at least two HWIs.  This provides</span>
<span class="lineNum">    2499 </span><span class="lineCov">   11870137 :      a fast path for things like offset_int and widest_int.</span>
<span class="lineNum">    2500 </span><span class="lineCov">   75899258 : </span>
<span class="lineNum">    2501 </span><span class="lineCov">   61271880 :      The STATIC_CONSTANT_P test prevents this path from being</span>
<span class="lineNum">    2502 </span><span class="lineCov">    7130225 :      used for wide_ints.  wide_ints with precisions greater than</span>
<span class="lineNum">    2503 </span><span class="lineCov">    2031982 :      HOST_BITS_PER_WIDE_INT are relatively rare and there's not much</span>
<span class="lineNum">    2504 </span><span class="lineCov">   16667575 :      point handling them inline.  */</span>
<span class="lineNum">    2505 </span><span class="lineCov">   13085961 :   else if (STATIC_CONSTANT_P (precision &gt; HOST_BITS_PER_WIDE_INT)</span>
<span class="lineNum">    2506 </span><span class="lineCov"> 2301874592 :            &amp;&amp; __builtin_expect (xi.len + yi.len == 2, true))</span>
<span class="lineNum">    2507 </span><span class="lineCov">   22183616 :     {</span>
<span class="lineNum">    2508 </span><span class="lineCov"> 4590601272 :       unsigned HOST_WIDE_INT xl = xi.ulow ();</span>
<span class="lineNum">    2509 </span><span class="lineCov"> 4589511355 :       unsigned HOST_WIDE_INT yl = yi.ulow ();</span>
<span class="lineNum">    2510 </span><span class="lineCov"> 4584564340 :       unsigned HOST_WIDE_INT resultl = xl - yl;</span>
<span class="lineNum">    2511 </span><span class="lineCov"> 3766174635 :       val[0] = resultl;</span>
<span class="lineNum">    2512 </span><span class="lineCov">    8780592 :       val[1] = (HOST_WIDE_INT) resultl &lt; 0 ? 0 : -1;</span>
<span class="lineNum">    2513 </span><span class="lineCov">    9979377 :       result.set_len (1 + (((resultl ^ xl) &amp; (xl ^ yl))</span>
<span class="lineNum">    2514 </span><span class="lineCov">    8908041 :                            &gt;&gt; (HOST_BITS_PER_WIDE_INT - 1)));</span>
<span class="lineNum">    2515 </span><span class="lineCov">    2707541 :     }</span>
<span class="lineNum">    2516 </span><span class="lineCov">    2677163 :   else</span>
<span class="lineNum">    2517 </span><span class="lineCov">    1519785 :     result.set_len (sub_large (val, xi.val, xi.len,</span>
<span class="lineNum">    2518 </span><span class="lineCov">    2323111 :                                yi.val, yi.len, precision,</span>
<span class="lineNum">    2519 </span><span class="lineCov">    1206309 :                                UNSIGNED, 0));</span>
<span class="lineNum">    2520 </span><span class="lineCov">    4358046 :   return result;</span>
<span class="lineNum">    2521 </span><span class="lineCov">    3125669 : }</span>
<span class="lineNum">    2522 </span><span class="lineCov">    1001910 : </span>
<span class="lineNum">    2523 </span><span class="lineCov">     984709 : /* Return X - Y.  Treat X and Y as having the signednes given by SGN</span>
<span class="lineNum">    2524 </span><span class="lineCov">    1152185 :    and indicate in *OVERFLOW whether the operation overflowed.  */</span>
<a name="2525"><span class="lineNum">    2525 </span><span class="lineCov">    1954020 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    2526 </span><span class="lineCov">    1447798 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2527 </span><span class="lineCov">    2236279 : wi::sub (const T1 &amp;x, const T2 &amp;y, signop sgn, overflow_type *overflow)</span>
<span class="lineNum">    2528 </span><span class="lineCov"> 2309119829 : {</span>
<span class="lineNum">    2529 </span><span class="lineCov">    3271097 :   WI_BINARY_RESULT_VAR (result, val, T1, x, T2, y);</span>
<span class="lineNum">    2530 </span><span class="lineCov"> 4641617802 :   unsigned int precision = get_precision (result);</span>
<span class="lineNum">    2531 </span><span class="lineCov"> 4624319315 :   WIDE_INT_REF_FOR (T1) xi (x, precision);</span>
<span class="lineNum">    2532 </span><span class="lineCov"> 2367936245 :   WIDE_INT_REF_FOR (T2) yi (y, precision);</span>
<span class="lineNum">    2533 </span><span class="lineCov"> 2371965547 :   if (precision &lt;= HOST_BITS_PER_WIDE_INT)</span>
<span class="lineNum">    2534 </span><span class="lineCov"> 2359173557 :     {</span>
<span class="lineNum">    2535 </span><span class="lineCov"> 4624791870 :       unsigned HOST_WIDE_INT xl = xi.ulow ();</span>
<span class="lineNum">    2536 </span><span class="lineCov"> 2302139270 :       unsigned HOST_WIDE_INT yl = yi.ulow ();</span>
<span class="lineNum">    2537 </span><span class="lineCov">   49409950 :       unsigned HOST_WIDE_INT resultl = xl - yl;</span>
<span class="lineNum">    2538 </span><span class="lineCov">   25126434 :       if (sgn == SIGNED)</span>
<span class="lineNum">    2539 </span><span class="lineCov">   10083888 :         {</span>
<span class="lineNum">    2540 </span><span class="lineCov">    2090532 :           if ((((xl ^ yl) &amp; (resultl ^ xl)) &gt;&gt; (precision - 1)) &amp; 1)</span>
<span class="lineNum">    2541 </span><span class="lineCov">    4150335 :             {</span>
<span class="lineNum">    2542 </span><span class="lineCov"> 2293149926 :               if (xl &gt; yl)</span>
<span class="lineNum">    2543 </span><span class="lineCov">   17570592 :                 *overflow = OVF_UNDERFLOW;</span>
<span class="lineNum">    2544 </span><span class="lineCov">   26324573 :               else if (xl &lt; yl)</span>
<span class="lineNum">    2545 </span><span class="lineCov">    8300862 :                 *overflow = OVF_OVERFLOW;</span>
<span class="lineNum">    2546 </span><span class="lineCov">  102432934 :               else</span>
<span class="lineNum">    2547 </span><span class="lineCov">   70814536 :                 *overflow = OVF_NONE;</span>
<span class="lineNum">    2548 </span><span class="lineCov">  155636149 :             }</span>
<span class="lineNum">    2549 </span><span class="lineCov">  142297594 :           else</span>
<span class="lineNum">    2550 </span><span class="lineCov">   64734837 :             *overflow = OVF_NONE;</span>
<span class="lineNum">    2551 </span><span class="lineCov">   67551431 :         }</span>
<span class="lineNum">    2552 </span><span class="lineCov">  145554974 :       else</span>
<span class="lineNum">    2553 </span><span class="lineCov">   66266610 :         *overflow = ((resultl &lt;&lt; (HOST_BITS_PER_WIDE_INT - precision))</span>
<span class="lineNum">    2554 </span><span class="lineCov">  102500039 :                      &gt; (xl &lt;&lt; (HOST_BITS_PER_WIDE_INT - precision)))</span>
<span class="lineNum">    2555 </span><span class="lineCov">  100509279 :           ? OVF_UNDERFLOW : OVF_NONE;</span>
<span class="lineNum">    2556 </span><span class="lineCov">   23910403 :       val[0] = resultl;</span>
<span class="lineNum">    2557 </span><span class="lineCov">   26313830 :       result.set_len (1);</span>
<span class="lineNum">    2558 </span><span class="lineCov">   81538813 :     }</span>
<span class="lineNum">    2559 </span><span class="lineCov">   95163098 :   else</span>
<span class="lineNum">    2560 </span><span class="lineCov">   23664772 :     result.set_len (sub_large (val, xi.val, xi.len,</span>
<span class="lineNum">    2561 </span><span class="lineCov">   31905920 :                                yi.val, yi.len, precision,</span>
<span class="lineNum">    2562 </span><span class="lineCov">   40666687 :                                sgn, overflow));</span>
<span class="lineNum">    2563 </span><span class="lineCov">   65769314 :   return result;</span>
<span class="lineNum">    2564 </span><span class="lineCov">  113546186 : }</span>
<span class="lineNum">    2565 </span><span class="lineCov">   91706401 : </span>
<span class="lineNum">    2566 </span><span class="lineCov">   91189994 : /* Return X * Y.  */</span>
<a name="2567"><span class="lineNum">    2567 </span><span class="lineCov">   74352008 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    2568 </span><span class="lineCov">   78100490 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2569 </span><span class="lineCov">   82167696 : wi::mul (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    2570 </span><span class="lineCov">   53144172 : {</span>
<span class="lineNum">    2571 </span><span class="lineCov">  143819915 :   WI_BINARY_RESULT_VAR (result, val, T1, x, T2, y);</span>
<span class="lineNum">    2572 </span><span class="lineCov">   59097993 :   unsigned int precision = get_precision (result);</span>
<span class="lineNum">    2573 </span><span class="lineCov">  141328887 :   WIDE_INT_REF_FOR (T1) xi (x, precision);</span>
<span class="lineNum">    2574 </span><span class="lineCov">  123589938 :   WIDE_INT_REF_FOR (T2) yi (y, precision);</span>
<span class="lineNum">    2575 </span><span class="lineCov">   39664676 :   if (precision &lt;= HOST_BITS_PER_WIDE_INT)</span>
<span class="lineNum">    2576 </span><span class="lineCov">   49298276 :     {</span>
<span class="lineNum">    2577 </span><span class="lineCov">   73782180 :       val[0] = xi.ulow () * yi.ulow ();</span>
<span class="lineNum">    2578 </span><span class="lineCov">   74334125 :       result.set_len (1);</span>
<span class="lineNum">    2579 </span><span class="lineCov">   47497115 :     }</span>
<span class="lineNum">    2580 </span><span class="lineCov">   29789435 :   else</span>
<span class="lineNum">    2581 </span><span class="lineCov">   17428424 :     result.set_len (mul_internal (val, xi.val, xi.len, yi.val, yi.len,</span>
<span class="lineNum">    2582 </span><span class="lineCov"> 1458208337 :                                   precision, UNSIGNED, 0, false));</span>
<span class="lineNum">    2583 </span><span class="lineCov">   16807329 :   return result;</span>
<span class="lineNum">    2584 </span><span class="lineCov"> 2898302888 : }</span>
<span class="lineNum">    2585 </span><span class="lineCov"> 2996328981 : </span>
<span class="lineNum">    2586 </span><span class="lineCov"> 2893558562 : /* Return X * Y.  Treat X and Y as having the signednes given by SGN</span>
<span class="lineNum">    2587 </span><span class="lineCov"> 3028149987 :    and indicate in *OVERFLOW whether the operation overflowed.  */</span>
<a name="2588"><span class="lineNum">    2588 </span><span class="lineCov">  154017594 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    2589 </span><span class="lineCov">   74931724 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2590 </span><span class="lineCov">    4214868 : wi::mul (const T1 &amp;x, const T2 &amp;y, signop sgn, overflow_type *overflow)</span>
<span class="lineNum">    2591 </span><span class="lineCov">   72028112 : {</span>
<span class="lineNum">    2592 </span><span class="lineCov">    8498148 :   WI_BINARY_RESULT_VAR (result, val, T1, x, T2, y);</span>
<span class="lineNum">    2593 </span><span class="lineCov">   78979102 :   unsigned int precision = get_precision (result);</span>
<span class="lineNum">    2594 </span><span class="lineCov">   79963848 :   WIDE_INT_REF_FOR (T1) xi (x, precision);</span>
<span class="lineNum">    2595 </span><span class="lineCov">     680046 :   WIDE_INT_REF_FOR (T2) yi (y, precision);</span>
<span class="lineNum">    2596 </span><span class="lineCov">   10648205 :   result.set_len (mul_internal (val, xi.val, xi.len,</span>
<span class="lineNum">    2597 </span><span class="lineCov">    2142521 :                                 yi.val, yi.len, precision,</span>
<span class="lineNum">    2598 </span><span class="lineCov">   76932809 :                                 sgn, overflow, false));</span>
<span class="lineNum">    2599 </span><span class="lineCov">   10794819 :   return result;</span>
<span class="lineNum">    2600 </span><span class="lineCov">  254843432 : }</span>
<span class="lineNum">    2601 </span><span class="lineCov">    4701157 : </span>
<span class="lineNum">    2602 </span><span class="lineCov">  520365515 : /* Return X * Y, treating both X and Y as signed values.  Indicate in</span>
<span class="lineNum">    2603 </span><span class="lineCov">  511503449 :    *OVERFLOW whether the operation overflowed.  */</span>
<span class="lineNum">    2604 </span><span class="lineCov"> 1814902966 : template &lt;typename T1, typename T2&gt;</span>
<span class="lineNum">    2605 </span><span class="lineCov">  491382951 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2606 </span><span class="lineCov"> 3187663599 : wi::smul (const T1 &amp;x, const T2 &amp;y, overflow_type *overflow)</span>
<span class="lineNum">    2607 </span><span class="lineCov"> 3227442658 : {</span>
<span class="lineNum">    2608 </span><span class="lineCov"> 1461229516 :   return mul (x, y, SIGNED, overflow);</span>
<span class="lineNum">    2609 </span><span class="lineCov"> 2245122613 : }</span>
<span class="lineNum">    2610 </span><span class="lineCov"> 1799814290 : </span>
<span class="lineNum">    2611 </span><span class="lineCov"> 2966687636 : /* Return X * Y, treating both X and Y as unsigned values.  Indicate in</span>
<span class="lineNum">    2612 </span><span class="lineCov"> 1556383838 :   *OVERFLOW if the result overflows.  */</span>
<span class="lineNum">    2613 </span><span class="lineCov">   77513902 : template &lt;typename T1, typename T2&gt;</span>
<span class="lineNum">    2614 </span><span class="lineCov">   17783154 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2615 </span><span class="lineCov">  251520666 : wi::umul (const T1 &amp;x, const T2 &amp;y, overflow_type *overflow)</span>
<span class="lineNum">    2616 </span><span class="lineCov">       4126 : {</span>
<span class="lineNum">    2617 </span><span class="lineCov">   10961809 :   return mul (x, y, UNSIGNED, overflow);</span>
<span class="lineNum">    2618 </span><span class="lineCov"> 1443654452 : }</span>
<span class="lineNum">    2619 </span><span class="lineCov">   75057324 : </span>
<span class="lineNum">    2620 </span><span class="lineCov">  847305228 : /* Perform a widening multiplication of X and Y, extending the values</span>
<span class="lineNum">    2621 </span><span class="lineCov">   74833934 :    according to SGN, and return the high part of the result.  */</span>
<a name="2622"><span class="lineNum">    2622 </span><span class="lineCov"> 1689328171 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    2623 </span><span class="lineCov"> 1689625341 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2624 </span><span class="lineCov"> 1662906274 : wi::mul_high (const T1 &amp;x, const T2 &amp;y, signop sgn)</span>
<span class="lineNum">    2625 </span><span class="lineCov">  852762927 : {</span>
<span class="lineNum">    2626 </span><span class="lineCov">   32003135 :   WI_BINARY_RESULT_VAR (result, val, T1, x, T2, y);</span>
<span class="lineNum">    2627 </span><span class="lineCov">   12428036 :   unsigned int precision = get_precision (result);</span>
<span class="lineNum">    2628 </span><span class="lineCov">   26557868 :   WIDE_INT_REF_FOR (T1) xi (x, precision);</span>
<span class="lineNum">    2629 </span><span class="lineCov">   67261215 :   WIDE_INT_REF_FOR (T2) yi (y, precision);</span>
<span class="lineNum">    2630 </span><span class="lineCov">    3634860 :   result.set_len (mul_internal (val, xi.val, xi.len,</span>
<span class="lineNum">    2631 </span><span class="lineCov">  155971914 :                                 yi.val, yi.len, precision,</span>
<span class="lineNum">    2632 </span><span class="lineCov">  163963903 :                                 sgn, 0, true));</span>
<span class="lineNum">    2633 </span><span class="lineCov">   73742809 :   return result;</span>
<span class="lineNum">    2634 </span><span class="lineCov">  159955651 : }</span>
<span class="lineNum">    2635 </span><span class="lineCov">   58751458 : </span>
<span class="lineNum">    2636 </span><span class="lineCov">  288259003 : /* Return X / Y, rouding towards 0.  Treat X and Y as having the</span>
<span class="lineNum">    2637 </span><span class="lineCov">  235032554 :    signedness given by SGN.  Indicate in *OVERFLOW if the result</span>
<span class="lineNum">    2638 </span><span class="lineCov">  179265353 :    overflows.  */</span>
<a name="2639"><span class="lineNum">    2639 </span><span class="lineCov">  179589218 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    2640 </span><span class="lineCov">   90968979 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2641 </span><span class="lineCov">   87948429 : wi::div_trunc (const T1 &amp;x, const T2 &amp;y, signop sgn, overflow_type *overflow)</span>
<span class="lineNum">    2642 </span><span class="lineCov">  829258032 : {</span>
<span class="lineNum">    2643 </span><span class="lineCov">  294455098 :   WI_BINARY_RESULT_VAR (quotient, quotient_val, T1, x, T2, y);</span>
<span class="lineNum">    2644 </span><span class="lineCov"> 1731137996 :   unsigned int precision = get_precision (quotient);</span>
<span class="lineNum">    2645 </span><span class="lineCov"> 1652607394 :   WIDE_INT_REF_FOR (T1) xi (x, precision);</span>
<span class="lineNum">    2646 </span><span class="lineCov">  843629318 :   WIDE_INT_REF_FOR (T2) yi (y);</span>
<span class="lineNum">    2647 </span><span class="lineCov">  835754161 : </span>
<span class="lineNum">    2648 </span><span class="lineCov">  875939986 :   quotient.set_len (divmod_internal (quotient_val, 0, 0, xi.val, xi.len,</span>
<span class="lineNum">    2649 </span><span class="lineCov"> 1773274536 :                                      precision,</span>
<span class="lineNum">    2650 </span><span class="lineCov">  842856419 :                                      yi.val, yi.len, yi.precision,</span>
<span class="lineNum">    2651 </span><span class="lineCov">   26465389 :                                      sgn, overflow));</span>
<span class="lineNum">    2652 </span><span class="lineCov">   16987173 :   return quotient;</span>
<span class="lineNum">    2653 </span><span class="lineCov">   39562343 : }</span>
<span class="lineNum">    2654 </span><span class="lineCov">   34450511 : </span>
<span class="lineNum">    2655 </span><span class="lineCov">   81669565 : /* Return X / Y, rouding towards 0.  Treat X and Y as signed values.  */</span>
<a name="2656"><span class="lineNum">    2656 </span><span class="lineCov">  878038069 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    2657 </span><span class="lineCov">   14371625 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2658 </span><span class="lineCov">   25264955 : wi::sdiv_trunc (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    2659 </span><span class="lineCov">   26058308 : {</span>
<span class="lineNum">    2660 </span><span class="lineCov">    9913702 :   return div_trunc (x, y, SIGNED);</span>
<span class="lineNum">    2661 </span><span class="lineCov">   20928533 : }</span>
<span class="lineNum">    2662 </span><span class="lineCov">   16265077 : </span>
<span class="lineNum">    2663 </span><span class="lineCov">   11345884 : /* Return X / Y, rouding towards 0.  Treat X and Y as unsigned values.  */</span>
<a name="2664"><span class="lineNum">    2664 </span><span class="lineCov">  126853724 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    2665 </span><span class="lineCov">   13893197 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2666 </span><span class="lineCov">  231267759 : wi::udiv_trunc (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    2667 </span><span class="lineCov">  224284503 : {</span>
<span class="lineNum">    2668 </span><span class="lineCov">  388572969 :   return div_trunc (x, y, UNSIGNED);</span>
<span class="lineNum">    2669 </span><span class="lineCov">  228906851 : }</span>
<span class="lineNum">    2670 </span><span class="lineCov">  301601270 : </span>
<span class="lineNum">    2671 </span><span class="lineCov">  301628743 : /* Return X / Y, rouding towards -inf.  Treat X and Y as having the</span>
<span class="lineNum">    2672 </span><span class="lineCov">  151590978 :    signedness given by SGN.  Indicate in *OVERFLOW if the result</span>
<span class="lineNum">    2673 </span><span class="lineCov">  301909179 :    overflows.  */</span>
<a name="2674"><span class="lineNum">    2674 </span><span class="lineCov">  150557980 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    2675 </span><span class="lineCov">  158522570 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2676 </span><span class="lineCov">    2847354 : wi::div_floor (const T1 &amp;x, const T2 &amp;y, signop sgn, overflow_type *overflow)</span>
<span class="lineNum">    2677 </span><span class="lineCov">  411999993 : {</span>
<span class="lineNum">    2678 </span><span class="lineCov">  142889897 :   WI_BINARY_RESULT_VAR (quotient, quotient_val, T1, x, T2, y);</span>
<span class="lineNum">    2679 </span><span class="lineCov">    2817349 :   WI_BINARY_RESULT_VAR (remainder, remainder_val, T1, x, T2, y);</span>
<span class="lineNum">    2680 </span><span class="lineCov">    3245718 :   unsigned int precision = get_precision (quotient);</span>
<span class="lineNum">    2681 </span><span class="lineCov">   18518643 :   WIDE_INT_REF_FOR (T1) xi (x, precision);</span>
<span class="lineNum">    2682 </span><span class="lineCov">   10500995 :   WIDE_INT_REF_FOR (T2) yi (y);</span>
<span class="lineNum">    2683 </span><span class="lineCov">  157181539 : </span>
<span class="lineNum">    2684 </span><span class="lineCov">   10070382 :   unsigned int remainder_len;</span>
<span class="lineNum">    2685 </span><span class="lineCov">   18308142 :   quotient.set_len (divmod_internal (quotient_val,</span>
<span class="lineNum">    2686 </span><span class="lineCov">  126766383 :                                      &amp;remainder_len, remainder_val,</span>
<span class="lineNum">    2687 </span><span class="lineCov">   13370255 :                                      xi.val, xi.len, precision,</span>
<span class="lineNum">    2688 </span><span class="lineCov">  232417165 :                                      yi.val, yi.len, yi.precision, sgn,</span>
<span class="lineNum">    2689 </span><span class="lineCov">  570700364 :                                      overflow));</span>
<span class="lineNum">    2690 </span><span class="lineCov">  116879618 :   remainder.set_len (remainder_len);</span>
<span class="lineNum">    2691 </span><span class="lineCov">  809635697 :   if (wi::neg_p (x, sgn) != wi::neg_p (y, sgn) &amp;&amp; remainder != 0)</span>
<span class="lineNum">    2692 </span><span class="lineCov">  799565448 :     return quotient - 1;</span>
<span class="lineNum">    2693 </span><span class="lineCov">  935344930 :   return quotient;</span>
<span class="lineNum">    2694 </span><span class="lineCov">  807357902 : }</span>
<span class="lineNum">    2695 </span><span class="lineCov">  361392432 : </span>
<span class="lineNum">    2696 </span><span class="lineCov">  368044045 : /* Return X / Y, rouding towards -inf.  Treat X and Y as signed values.  */</span>
<span class="lineNum">    2697 </span><span class="lineCov">   10206004 : template &lt;typename T1, typename T2&gt;</span>
<span class="lineNum">    2698 </span><span class="lineCov">  980735192 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2699 </span><span class="lineCov">  336157768 : wi::sdiv_floor (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    2700 </span><span class="lineCov">  117797996 : {</span>
<span class="lineNum">    2701 </span><span class="lineCov">    1469282 :   return div_floor (x, y, SIGNED);</span>
<span class="lineNum">    2702 </span><span class="lineCov">   23218186 : }</span>
<span class="lineNum">    2703 </span><span class="lineCov">    1919335 : </span>
<span class="lineNum">    2704 </span><span class="lineCov">  344940548 : /* Return X / Y, rouding towards -inf.  Treat X and Y as unsigned values.  */</span>
<span class="lineNum">    2705 </span><span class="lineCov">    5203259 : /* ??? Why do we have both this and udiv_trunc.  Aren't they the same?  */</span>
<span class="lineNum">    2706 </span><span class="lineCov">  321295447 : template &lt;typename T1, typename T2&gt;</span>
<span class="lineNum">    2707 </span><span class="lineCov">    8362737 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2708 </span><span class="lineCov">  651413958 : wi::udiv_floor (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    2709 </span><span class="lineCov">  649356608 : {</span>
<span class="lineNum">    2710 </span><span class="lineCov">  385266883 :   return div_floor (x, y, UNSIGNED);</span>
<span class="lineNum">    2711 </span><span class="lineCov">  425670337 : }</span>
<span class="lineNum">    2712 </span><span class="lineCov">    8377113 : </span>
<span class="lineNum">    2713 </span><span class="lineCov">    4350570 : /* Return X / Y, rouding towards +inf.  Treat X and Y as having the</span>
<span class="lineNum">    2714 </span><span class="lineCov">    1664577 :    signedness given by SGN.  Indicate in *OVERFLOW if the result</span>
<span class="lineNum">    2715 </span><span class="lineCov">     320299 :    overflows.  */</span>
<a name="2716"><span class="lineNum">    2716 </span><span class="lineCov">    3664182 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    2717 </span><span class="lineCov">    4560866 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2718 </span><span class="lineCov">    2003199 : wi::div_ceil (const T1 &amp;x, const T2 &amp;y, signop sgn, overflow_type *overflow)</span>
<span class="lineNum">    2719 </span><span class="lineCov">   10628746 : {</span>
<span class="lineNum">    2720 </span><span class="lineCov">    1920135 :   WI_BINARY_RESULT_VAR (quotient, quotient_val, T1, x, T2, y);</span>
<span class="lineNum">    2721 </span><span class="lineCov">   54599394 :   WI_BINARY_RESULT_VAR (remainder, remainder_val, T1, x, T2, y);</span>
<span class="lineNum">    2722 </span><span class="lineCov">    9219017 :   unsigned int precision = get_precision (quotient);</span>
<span class="lineNum">    2723 </span><span class="lineCov">  441932852 :   WIDE_INT_REF_FOR (T1) xi (x, precision);</span>
<span class="lineNum">    2724 </span><span class="lineCov">  119919917 :   WIDE_INT_REF_FOR (T2) yi (y);</span>
<span class="lineNum">    2725 </span><span class="lineCov">  742731172 : </span>
<span class="lineNum">    2726 </span><span class="lineCov">  785688516 :   unsigned int remainder_len;</span>
<span class="lineNum">    2727 </span><span class="lineCov">  692484921 :   quotient.set_len (divmod_internal (quotient_val,</span>
<span class="lineNum">    2728 </span><span class="lineCov"> 1004217581 :                                      &amp;remainder_len, remainder_val,</span>
<span class="lineNum">    2729 </span><span class="lineCov">  356832790 :                                      xi.val, xi.len, precision,</span>
<span class="lineNum">    2730 </span><span class="lineCov">  993404294 :                                      yi.val, yi.len, yi.precision, sgn,</span>
<span class="lineNum">    2731 </span><span class="lineCov">  649635361 :                                      overflow));</span>
<span class="lineNum">    2732 </span><span class="lineCov"> 1285270201 :   remainder.set_len (remainder_len);</span>
<span class="lineNum">    2733 </span><span class="lineCov">  644570953 :   if (wi::neg_p (x, sgn) == wi::neg_p (y, sgn) &amp;&amp; remainder != 0)</span>
<span class="lineNum">    2734 </span><span class="lineCov">  334677929 :     return quotient + 1;</span>
<span class="lineNum">    2735 </span><span class="lineCov">  641325088 :   return quotient;</span>
<span class="lineNum">    2736 </span><span class="lineCov">  359275648 : }</span>
<span class="lineNum">    2737 </span><span class="lineCov">   28626221 : </span>
<span class="lineNum">    2738 </span><span class="lineCov">  357451523 : /* Return X / Y, rouding towards +inf.  Treat X and Y as unsigned values.  */</span>
<span class="lineNum">    2739 </span><span class="lineCov">   15100033 : template &lt;typename T1, typename T2&gt;</span>
<span class="lineNum">    2740 </span><span class="lineCov">   24565159 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2741 </span><span class="lineCov">    5857588 : wi::udiv_ceil (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    2742 </span><span class="lineCov">  382083186 : {</span>
<span class="lineNum">    2743 </span><span class="lineCov">   76040857 :   return div_ceil (x, y, UNSIGNED);</span>
<span class="lineNum">    2744 </span><span class="lineCov">   50885227 : }</span>
<span class="lineNum">    2745 </span><span class="lineCov">  105565104 : </span>
<span class="lineNum">    2746 </span><span class="lineCov">  192444610 : /* Return X / Y, rouding towards nearest with ties away from zero.</span>
<span class="lineNum">    2747 </span><span class="lineCov">  139864029 :    Treat X and Y as having the signedness given by SGN.  Indicate</span>
<span class="lineNum">    2748 </span><span class="lineCov">   98805621 :    in *OVERFLOW if the result overflows.  */</span>
<a name="2749"><span class="lineNum">    2749 </span><span class="lineCov">  153135964 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    2750 </span><span class="lineCov">  109718387 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2751 </span><span class="lineCov">   56296262 : wi::div_round (const T1 &amp;x, const T2 &amp;y, signop sgn, overflow_type *overflow)</span>
<span class="lineNum">    2752 </span><span class="lineCov">   18395844 : {</span>
<span class="lineNum">    2753 </span><span class="lineCov">    3908683 :   WI_BINARY_RESULT_VAR (quotient, quotient_val, T1, x, T2, y);</span>
<span class="lineNum">    2754 </span><span class="lineCov">   38777979 :   WI_BINARY_RESULT_VAR (remainder, remainder_val, T1, x, T2, y);</span>
<span class="lineNum">    2755 </span><span class="lineCov">   28033629 :   unsigned int precision = get_precision (quotient);</span>
<span class="lineNum">    2756 </span><span class="lineCov">   23420121 :   WIDE_INT_REF_FOR (T1) xi (x, precision);</span>
<span class="lineNum">    2757 </span><span class="lineCov">   64549353 :   WIDE_INT_REF_FOR (T2) yi (y);</span>
<span class="lineNum">    2758 </span><span class="lineCov">   12550105 : </span>
<span class="lineNum">    2759 </span><span class="lineCov">   16061276 :   unsigned int remainder_len;</span>
<span class="lineNum">    2760 </span><span class="lineCov">    2172032 :   quotient.set_len (divmod_internal (quotient_val,</span>
<span class="lineNum">    2761 </span><span class="lineCov">   39005381 :                                      &amp;remainder_len, remainder_val,</span>
<span class="lineNum">    2762 </span><span class="lineCov">   14396932 :                                      xi.val, xi.len, precision,</span>
<span class="lineNum">    2763 </span><span class="lineCov">    2928601 :                                      yi.val, yi.len, yi.precision, sgn,</span>
<span class="lineNum">    2764 </span><span class="lineCov">    1231829 :                                      overflow));</span>
<span class="lineNum">    2765 </span><span class="lineCov">      60473 :   remainder.set_len (remainder_len);</span>
<span class="lineNum">    2766 </span><span class="lineCov">   42490649 : </span>
<span class="lineNum">    2767 </span><span class="lineCov">   11766604 :   if (remainder != 0)</span>
<span class="lineNum">    2768 </span><span class="lineCov">   84965078 :     {</span>
<span class="lineNum">    2769 </span><span class="lineCov">   85128812 :       if (sgn == SIGNED)</span>
<span class="lineNum">    2770 </span><span class="lineCov">   56678795 :         {</span>
<span class="lineNum">    2771 </span><span class="lineCov">   44800224 :           WI_BINARY_RESULT (T1, T2) abs_remainder = wi::abs (remainder);</span>
<span class="lineNum">    2772 </span><span class="lineCov">   43023923 :           if (wi::geu_p (abs_remainder, wi::sub (wi::abs (y), abs_remainder)))</span>
<span class="lineNum">    2773 </span><span class="lineCov">   93863365 :             {</span>
<span class="lineNum">    2774 </span><span class="lineCov">   47970982 :               if (wi::neg_p (x, sgn) != wi::neg_p (y, sgn))</span>
<span class="lineNum">    2775 </span><span class="lineCov">   18190085 :                 return quotient - 1;</span>
<span class="lineNum">    2776 </span><span class="lineCov">   13123987 :               else</span>
<span class="lineNum">    2777 </span><span class="lineCov">   12571450 :                 return quotient + 1;</span>
<span class="lineNum">    2778 </span><span class="lineCov">  122765650 :             }</span>
<span class="lineNum">    2779 </span><span class="lineCov">    6978625 :         }</span>
<span class="lineNum">    2780 </span><span class="lineCov">  275769988 :       else</span>
<span class="lineNum">    2781 </span><span class="lineCov">  228417168 :         {</span>
<span class="lineNum">    2782 </span><span class="lineCov">  422364976 :           if (wi::geu_p (remainder, wi::sub (y, remainder)))</span>
<span class="lineNum">    2783 </span><span class="lineCov">  232696266 :             return quotient + 1;</span>
<span class="lineNum">    2784 </span><span class="lineCov">  363526932 :         }</span>
<span class="lineNum">    2785 </span><span class="lineCov">  364412342 :     }</span>
<span class="lineNum">    2786 </span><span class="lineCov">  272169172 :   return quotient;</span>
<span class="lineNum">    2787 </span><span class="lineCov">  269880122 : }</span>
<span class="lineNum">    2788 </span><span class="lineCov">  131327521 : </span>
<span class="lineNum">    2789 </span><span class="lineCov">  127758527 : /* Return X / Y, rouding towards 0.  Treat X and Y as having the</span>
<span class="lineNum">    2790 </span><span class="lineCov">     415808 :    signedness given by SGN.  Store the remainder in *REMAINDER_PTR.  */</span>
<a name="2791"><span class="lineNum">    2791 </span><span class="lineCov">  368700157 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    2792 </span><span class="lineCov">  123259065 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2793 </span><span class="lineCov">    1619431 : wi::divmod_trunc (const T1 &amp;x, const T2 &amp;y, signop sgn,</span>
<span class="lineNum">    2794 </span><span class="lineCov">   65280555 :                   WI_BINARY_RESULT (T1, T2) *remainder_ptr)</span>
<span class="lineNum">    2795 </span><span class="lineCov">    2546282 : {</span>
<span class="lineNum">    2796 </span><span class="lineCov">   43410193 :   WI_BINARY_RESULT_VAR (quotient, quotient_val, T1, x, T2, y);</span>
<span class="lineNum">    2797 </span><span class="lineCov">  152030853 :   WI_BINARY_RESULT_VAR (remainder, remainder_val, T1, x, T2, y);</span>
<span class="lineNum">    2798 </span><span class="lineCov">   83422599 :   unsigned int precision = get_precision (quotient);</span>
<span class="lineNum">    2799 </span><span class="lineCov">   99474435 :   WIDE_INT_REF_FOR (T1) xi (x, precision);</span>
<span class="lineNum">    2800 </span><span class="lineCov">  180884227 :   WIDE_INT_REF_FOR (T2) yi (y);</span>
<span class="lineNum">    2801 </span><span class="lineCov">  129996808 : </span>
<span class="lineNum">    2802 </span><span class="lineCov">  285340771 :   unsigned int remainder_len;</span>
<span class="lineNum">    2803 </span><span class="lineCov">  328308148 :   quotient.set_len (divmod_internal (quotient_val,</span>
<span class="lineNum">    2804 </span><span class="lineCov">  245010302 :                                      &amp;remainder_len, remainder_val,</span>
<span class="lineNum">    2805 </span><span class="lineCov">  142553339 :                                      xi.val, xi.len, precision,</span>
<span class="lineNum">    2806 </span><span class="lineCov">  255976524 :                                      yi.val, yi.len, yi.precision, sgn, 0));</span>
<span class="lineNum">    2807 </span><span class="lineCov">  337474543 :   remainder.set_len (remainder_len);</span>
<span class="lineNum">    2808 </span><span class="lineCov">  329983660 : </span>
<span class="lineNum">    2809 </span><span class="lineCov">  101444921 :   *remainder_ptr = remainder;</span>
<span class="lineNum">    2810 </span><span class="lineCov">   89262553 :   return quotient;</span>
<span class="lineNum">    2811 </span><span class="lineCov">  115610446 : }</span>
<span class="lineNum">    2812 </span><span class="lineCov">   74487567 : </span>
<span class="lineNum">    2813 </span><span class="lineCov">   48213061 : /* Compute the greatest common divisor of two numbers A and B using</span>
<span class="lineNum">    2814 </span><span class="lineCov">  158415610 :    Euclid's algorithm.  */</span>
<a name="2815"><span class="lineNum">    2815 </span><span class="lineCov">   14902095 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    2816 </span><span class="lineCov">  106202852 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2817 </span><span class="lineCov">        698 : wi::gcd (const T1 &amp;a, const T2 &amp;b, signop sgn)</span>
<span class="lineNum">    2818 </span><span class="lineCov">  284022858 : {</span>
<span class="lineNum">    2819 </span><span class="lineCov">  198794837 :   T1 x, y, z;</span>
<span class="lineNum">    2820 </span><span class="lineCov">  670033357 : </span>
<span class="lineNum">    2821 </span><span class="lineCov">   93018632 :   x = wi::abs (a);</span>
<span class="lineNum">    2822 </span><span class="lineCov"> 1247513252 :   y = wi::abs (b);</span>
<span class="lineNum">    2823 </span><span class="lineCov">  891771402 : </span>
<span class="lineNum">    2824 </span><span class="lineCov">  577966676 :   while (gt_p (x, 0, sgn))</span>
<span class="lineNum">    2825 </span><span class="lineCov">  855573789 :     {</span>
<span class="lineNum">    2826 </span><span class="lineCov">  199075228 :       z = mod_trunc (y, x, sgn);</span>
<span class="lineNum">    2827 </span><span class="lineCov">     332758 :       y = x;</span>
<span class="lineNum">    2828 </span><span class="lineCov">  646940308 :       x = z;</span>
<span class="lineNum">    2829 </span><span class="lineCov">  213206941 :     }</span>
<span class="lineNum">    2830 </span><span class="lineCov">  213240799 : </span>
<span class="lineNum">    2831 </span><span class="lineCov">  420798980 :   return y;</span>
<span class="lineNum">    2832 </span><span class="lineCov">  106550423 : }</span>
<span class="lineNum">    2833 </span><span class="lineCov">  651526842 : </span>
<span class="lineNum">    2834 </span><span class="lineCov">  757328510 : /* Compute X / Y, rouding towards 0, and return the remainder.</span>
<span class="lineNum">    2835 </span><span class="lineCov">  431901501 :    Treat X and Y as having the signedness given by SGN.  Indicate</span>
<span class="lineNum">    2836 </span><span class="lineCov">    5863020 :    in *OVERFLOW if the division overflows.  */</span>
<a name="2837"><span class="lineNum">    2837 </span><span class="lineCov">   62694329 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    2838 </span><span class="lineCov">   16896714 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2839 </span><span class="lineCov">  244010801 : wi::mod_trunc (const T1 &amp;x, const T2 &amp;y, signop sgn, overflow_type *overflow)</span>
<span class="lineNum">    2840 </span><span class="lineCov">  133431660 : {</span>
<span class="lineNum">    2841 </span><span class="lineCov">  234995072 :   WI_BINARY_RESULT_VAR (remainder, remainder_val, T1, x, T2, y);</span>
<span class="lineNum">    2842 </span><span class="lineCov">  348932330 :   unsigned int precision = get_precision (remainder);</span>
<span class="lineNum">    2843 </span><span class="lineCov">  324936001 :   WIDE_INT_REF_FOR (T1) xi (x, precision);</span>
<span class="lineNum">    2844 </span><span class="lineCov">  656197197 :   WIDE_INT_REF_FOR (T2) yi (y);</span>
<span class="lineNum">    2845 </span><span class="lineCov">  670901359 : </span>
<span class="lineNum">    2846 </span><span class="lineCov">  271531283 :   unsigned int remainder_len;</span>
<span class="lineNum">    2847 </span><span class="lineCov">  329000218 :   divmod_internal (0, &amp;remainder_len, remainder_val,</span>
<span class="lineNum">    2848 </span><span class="lineCov">  221290159 :                    xi.val, xi.len, precision,</span>
<span class="lineNum">    2849 </span><span class="lineCov">  549819839 :                    yi.val, yi.len, yi.precision, sgn, overflow);</span>
<span class="lineNum">    2850 </span><span class="lineCov">  357139148 :   remainder.set_len (remainder_len);</span>
<span class="lineNum">    2851 </span><span class="lineCov">    5766732 : </span>
<span class="lineNum">    2852 </span><span class="lineCov">    1335015 :   return remainder;</span>
<span class="lineNum">    2853 </span><span class="lineCov">     873345 : }</span>
<span class="lineNum">    2854 </span><span class="lineCov">  106816121 : </span>
<span class="lineNum">    2855 </span><span class="lineCov">      16911 : /* Compute X / Y, rouding towards 0, and return the remainder.</span>
<span class="lineNum">    2856 </span><span class="lineCov">  222656531 :    Treat X and Y as signed values.  */</span>
<a name="2857"><span class="lineNum">    2857 </span><span class="lineCov">   33553378 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    2858 </span><span class="lineCov">     317926 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2859 </span><span class="lineCov">  127312731 : wi::smod_trunc (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    2860 </span><span class="lineCov">   66310821 : {</span>
<span class="lineNum">    2861 </span><span class="lineCov">  184040536 :   return mod_trunc (x, y, SIGNED);</span>
<span class="lineNum">    2862 </span><span class="lineCov">  134888785 : }</span>
<span class="lineNum">    2863 </span><span class="lineCov">   83898025 : </span>
<span class="lineNum">    2864 </span><span class="lineCov">  105916379 : /* Compute X / Y, rouding towards 0, and return the remainder.</span>
<span class="lineNum">    2865 </span><span class="lineCov">   59542598 :    Treat X and Y as unsigned values.  */</span>
<span class="lineNum">    2866 </span><span class="lineCov">  212355850 : template &lt;typename T1, typename T2&gt;</span>
<span class="lineNum">    2867 </span><span class="lineCov">  155837607 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2868 </span><span class="lineCov">   94765231 : wi::umod_trunc (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    2869 </span><span class="lineCov">   98649886 : {</span>
<span class="lineNum">    2870 </span><span class="lineCov">    6922283 :   return mod_trunc (x, y, UNSIGNED);</span>
<span class="lineNum">    2871 </span><span class="lineCov">    7190686 : }</span>
<span class="lineNum">    2872 </span><span class="lineCov">    4759974 : </span>
<span class="lineNum">    2873 </span><span class="lineCov">   90601400 : /* Compute X / Y, rouding towards -inf, and return the remainder.</span>
<span class="lineNum">    2874 </span><span class="lineCov">    4935371 :    Treat X and Y as having the signedness given by SGN.  Indicate</span>
<span class="lineNum">    2875 </span><span class="lineCov">    4940207 :    in *OVERFLOW if the division overflows.  */</span>
<a name="2876"><span class="lineNum">    2876 </span><span class="lineCov">   29477531 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    2877 </span><span class="lineCov">     200034 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2878 </span><span class="lineCov">  120983191 : wi::mod_floor (const T1 &amp;x, const T2 &amp;y, signop sgn, overflow_type *overflow)</span>
<span class="lineNum">    2879 </span><span class="lineCov">   48479028 : {</span>
<span class="lineNum">    2880 </span><span class="lineCov">  291302589 :   WI_BINARY_RESULT_VAR (quotient, quotient_val, T1, x, T2, y);</span>
<span class="lineNum">    2881 </span><span class="lineCov">  305201298 :   WI_BINARY_RESULT_VAR (remainder, remainder_val, T1, x, T2, y);</span>
<span class="lineNum">    2882 </span><span class="lineCov">  278178547 :   unsigned int precision = get_precision (quotient);</span>
<span class="lineNum">    2883 </span><span class="lineCov">  215715751 :   WIDE_INT_REF_FOR (T1) xi (x, precision);</span>
<span class="lineNum">    2884 </span><span class="lineCov">    5172367 :   WIDE_INT_REF_FOR (T2) yi (y);</span>
<span class="lineNum">    2885 </span><span class="lineCov">   22410863 : </span>
<span class="lineNum">    2886 </span><span class="lineCov">   57259972 :   unsigned int remainder_len;</span>
<span class="lineNum">    2887 </span><span class="lineCov">    5859620 :   quotient.set_len (divmod_internal (quotient_val,</span>
<span class="lineNum">    2888 </span><span class="lineCov">   94699474 :                                      &amp;remainder_len, remainder_val,</span>
<span class="lineNum">    2889 </span><span class="lineCov">   94327070 :                                      xi.val, xi.len, precision,</span>
<span class="lineNum">    2890 </span><span class="lineCov">  594047283 :                                      yi.val, yi.len, yi.precision, sgn,</span>
<span class="lineNum">    2891 </span><span class="lineCov">   47341017 :                                      overflow));</span>
<span class="lineNum">    2892 </span><span class="lineCov"> 1678011318 :   remainder.set_len (remainder_len);</span>
<span class="lineNum">    2893 </span><span class="lineCov"> 1191986759 : </span>
<span class="lineNum">    2894 </span><span class="lineCov"> 1134682945 :   if (wi::neg_p (x, sgn) != wi::neg_p (y, sgn) &amp;&amp; remainder != 0)</span>
<span class="lineNum">    2895 </span><span class="lineCov">   27862017 :     return remainder + y;</span>
<span class="lineNum">    2896 </span><span class="lineCov">    7874085 :   return remainder;</span>
<span class="lineNum">    2897 </span><span class="lineCov">   15329661 : }</span>
<span class="lineNum">    2898 </span><span class="lineCov">  560380314 : </span>
<span class="lineNum">    2899 </span><span class="lineCov">   17333791 : /* Compute X / Y, rouding towards -inf, and return the remainder.</span>
<span class="lineNum">    2900 </span><span class="lineCov">  502628170 :    Treat X and Y as unsigned values.  */</span>
<span class="lineNum">    2901 </span><span class="lineCov">  321991641 : /* ??? Why do we have both this and umod_trunc.  Aren't they the same?  */</span>
<span class="lineNum">    2902 </span><span class="lineCov">  243094823 : template &lt;typename T1, typename T2&gt;</span>
<span class="lineNum">    2903 </span><span class="lineCov">  245003128 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2904 </span><span class="lineCov">  127754231 : wi::umod_floor (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    2905 </span><span class="lineCov">  383286761 : {</span>
<span class="lineNum">    2906 </span><span class="lineCov">  350386200 :   return mod_floor (x, y, UNSIGNED);</span>
<span class="lineNum">    2907 </span><span class="lineCov">  760216171 : }</span>
<span class="lineNum">    2908 </span><span class="lineCov">  685643320 : </span>
<span class="lineNum">    2909 </span><span class="lineCov">  553243902 : /* Compute X / Y, rouding towards +inf, and return the remainder.</span>
<span class="lineNum">    2910 </span><span class="lineCov">  273668743 :    Treat X and Y as having the signedness given by SGN.  Indicate</span>
<span class="lineNum">    2911 </span><span class="lineCov">   17800667 :    in *OVERFLOW if the division overflows.  */</span>
<a name="2912"><span class="lineNum">    2912 </span><span class="lineCov">  217750306 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    2913 </span><span class="lineCov">   73709978 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2914 </span><span class="lineCov">  131061674 : wi::mod_ceil (const T1 &amp;x, const T2 &amp;y, signop sgn, overflow_type *overflow)</span>
<span class="lineNum">    2915 </span><span class="lineCov">  667947943 : {</span>
<span class="lineNum">    2916 </span><span class="lineCov">  214001952 :   WI_BINARY_RESULT_VAR (quotient, quotient_val, T1, x, T2, y);</span>
<span class="lineNum">    2917 </span><span class="lineCov"> 2018323738 :   WI_BINARY_RESULT_VAR (remainder, remainder_val, T1, x, T2, y);</span>
<span class="lineNum">    2918 </span><span class="lineCov"> 1387728946 :   unsigned int precision = get_precision (quotient);</span>
<span class="lineNum">    2919 </span><span class="lineCov"> 1535503940 :   WIDE_INT_REF_FOR (T1) xi (x, precision);</span>
<span class="lineNum">    2920 </span><span class="lineCov">  174965227 :   WIDE_INT_REF_FOR (T2) yi (y);</span>
<span class="lineNum">    2921 </span><span class="lineCov">  165509488 : </span>
<span class="lineNum">    2922 </span><span class="lineCov">   29397285 :   unsigned int remainder_len;</span>
<span class="lineNum">    2923 </span><span class="lineCov">  554976389 :   quotient.set_len (divmod_internal (quotient_val,</span>
<span class="lineNum">    2924 </span><span class="lineCov">   11802261 :                                      &amp;remainder_len, remainder_val,</span>
<span class="lineNum">    2925 </span><span class="lineCov">  327056047 :                                      xi.val, xi.len, precision,</span>
<span class="lineNum">    2926 </span><span class="lineCov">  323374671 :                                      yi.val, yi.len, yi.precision, sgn,</span>
<span class="lineNum">    2927 </span><span class="lineCov">    1581737 :                                      overflow));</span>
<span class="lineNum">    2928 </span><span class="lineCov">    4255757 :   remainder.set_len (remainder_len);</span>
<span class="lineNum">    2929 </span><span class="lineCov">    3199009 : </span>
<span class="lineNum">    2930 </span><span class="lineCov">    4780677 :   if (wi::neg_p (x, sgn) == wi::neg_p (y, sgn) &amp;&amp; remainder != 0)</span>
<span class="lineNum">    2931 </span><span class="lineCov">  237162600 :     return remainder - y;</span>
<span class="lineNum">    2932 </span><span class="lineCov">   18787533 :   return remainder;</span>
<span class="lineNum">    2933 </span><span class="lineCov">   42539618 : }</span>
<span class="lineNum">    2934 </span><span class="lineCov">   39863699 : </span>
<span class="lineNum">    2935 </span><span class="lineCov">   69024766 : /* Compute X / Y, rouding towards nearest with ties away from zero,</span>
<span class="lineNum">    2936 </span><span class="lineCov">    8634496 :    and return the remainder.  Treat X and Y as having the signedness</span>
<span class="lineNum">    2937 </span><span class="lineCov">  319626404 :    given by SGN.  Indicate in *OVERFLOW if the division overflows.  */</span>
<a name="2938"><span class="lineNum">    2938 </span><span class="lineCov">  246280726 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    2939 </span><span class="lineCov">   63889647 : inline WI_BINARY_RESULT (T1, T2)</span>
<span class="lineNum">    2940 </span><span class="lineCov">  320575964 : wi::mod_round (const T1 &amp;x, const T2 &amp;y, signop sgn, overflow_type *overflow)</span>
<span class="lineNum">    2941 </span><span class="lineCov">  297408918 : {</span>
<span class="lineNum">    2942 </span><span class="lineCov">  349060168 :   WI_BINARY_RESULT_VAR (quotient, quotient_val, T1, x, T2, y);</span>
<span class="lineNum">    2943 </span><span class="lineCov">  289899046 :   WI_BINARY_RESULT_VAR (remainder, remainder_val, T1, x, T2, y);</span>
<span class="lineNum">    2944 </span><span class="lineCov">  157562489 :   unsigned int precision = get_precision (quotient);</span>
<span class="lineNum">    2945 </span><span class="lineCov">  244941560 :   WIDE_INT_REF_FOR (T1) xi (x, precision);</span>
<span class="lineNum">    2946 </span><span class="lineCov">   80994465 :   WIDE_INT_REF_FOR (T2) yi (y);</span>
<span class="lineNum">    2947 </span><span class="lineCov">   13079471 : </span>
<span class="lineNum">    2948 </span><span class="lineCov">   16876996 :   unsigned int remainder_len;</span>
<span class="lineNum">    2949 </span><span class="lineCov">   73991061 :   quotient.set_len (divmod_internal (quotient_val,</span>
<span class="lineNum">    2950 </span><span class="lineCov">   12557477 :                                      &amp;remainder_len, remainder_val,</span>
<span class="lineNum">    2951 </span><span class="lineCov">      77100 :                                      xi.val, xi.len, precision,</span>
<span class="lineNum">    2952 </span><span class="lineCov">   94196065 :                                      yi.val, yi.len, yi.precision, sgn,</span>
<span class="lineNum">    2953 </span><span class="lineCov">   10134386 :                                      overflow));</span>
<span class="lineNum">    2954 </span><span class="lineCov">    3922902 :   remainder.set_len (remainder_len);</span>
<span class="lineNum">    2955 </span><span class="lineCov">   16787116 : </span>
<span class="lineNum">    2956 </span><span class="lineCov">     191558 :   if (remainder != 0)</span>
<span class="lineNum">    2957 </span><span class="lineCov">   11650903 :     {</span>
<span class="lineNum">    2958 </span><span class="lineCov">   11558101 :       if (sgn == SIGNED)</span>
<span class="lineNum">    2959 </span><span class="lineCov">     815458 :         {</span>
<span class="lineNum">    2960 </span><span class="lineCov">   37358467 :           WI_BINARY_RESULT (T1, T2) abs_remainder = wi::abs (remainder);</span>
<span class="lineNum">    2961 </span><span class="lineCov">     645096 :           if (wi::geu_p (abs_remainder, wi::sub (wi::abs (y), abs_remainder)))</span>
<span class="lineNum">    2962 </span><span class="lineCov">  108982698 :             {</span>
<span class="lineNum">    2963 </span><span class="lineCov">   73916227 :               if (wi::neg_p (x, sgn) != wi::neg_p (y, sgn))</span>
<span class="lineNum">    2964 </span><span class="lineCov">  105504644 :                 return remainder + y;</span>
<span class="lineNum">    2965 </span><span class="lineCov">  105483056 :               else</span>
<span class="lineNum">    2966 </span><span class="lineCov">   75599802 :                 return remainder - y;</span>
<span class="lineNum">    2967 </span><span class="lineCov">  107702618 :             }</span>
<span class="lineNum">    2968 </span><span class="lineCov">   71058291 :         }</span>
<span class="lineNum">    2969 </span><span class="lineCov">   71825036 :       else</span>
<span class="lineNum">    2970 </span><span class="lineCov">   34597645 :         {</span>
<span class="lineNum">    2971 </span><span class="lineCov">     298961 :           if (wi::geu_p (remainder, wi::sub (y, remainder)))</span>
<span class="lineNum">    2972 </span><span class="lineCov">      21007 :             return remainder - y;</span>
<span class="lineNum">    2973 </span><span class="lineCov">          6 :         }</span>
<span class="lineNum">    2974 </span><span class="lineCov">   36758946 :     }</span>
<span class="lineNum">    2975 </span><span class="lineCov">      82663 :   return remainder;</span>
<span class="lineNum">    2976 </span><span class="lineCov">   70435490 : }</span>
<span class="lineNum">    2977 </span><span class="lineCov">     240669 : </span>
<span class="lineNum">    2978 </span><span class="lineCov">   84606369 : /* Return true if X is a multiple of Y.  Treat X and Y as having the</span>
<span class="lineNum">    2979 </span><span class="lineCov">   72253458 :    signedness given by SGN.  */</span>
<a name="2980"><span class="lineNum">    2980 </span><span class="lineCov">   97130168 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    2981 </span><span class="lineCov">   97088174 : inline bool</span>
<span class="lineNum">    2982 </span><span class="lineCov">   25209989 : wi::multiple_of_p (const T1 &amp;x, const T2 &amp;y, signop sgn)</span>
<span class="lineNum">    2983 </span><span class="lineCov">   25302782 : {</span>
<span class="lineNum">    2984 </span><span class="lineCov">     133454 :   return wi::mod_trunc (x, y, sgn) == 0;</span>
<span class="lineNum">    2985 </span><span class="lineCov">    1049948 : }</span>
<span class="lineNum">    2986 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    2987 </span><span class="lineCov">    2144363 : /* Return true if X is a multiple of Y, storing X / Y in *RES if so.</span>
<span class="lineNum">    2988 </span><span class="lineCov">    2099896 :    Treat X and Y as having the signedness given by SGN.  */</span>
<a name="2989"><span class="lineNum">    2989 </span><span class="lineCov">    1920004 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    2990 </span><span class="lineCov">     198382 : inline bool</span>
<span class="lineNum">    2991 </span><span class="lineCov">   11229028 : wi::multiple_of_p (const T1 &amp;x, const T2 &amp;y, signop sgn,</span>
<span class="lineNum">    2992 </span><span class="lineCov">     114296 :                    WI_BINARY_RESULT (T1, T2) *res)</span>
<span class="lineNum">    2993 </span><span class="lineCov">   21266585 : {</span>
<span class="lineNum">    2994 </span><span class="lineCov">   21264190 :   WI_BINARY_RESULT (T1, T2) remainder;</span>
<span class="lineNum">    2995 </span><span class="lineCov">   20215522 :   WI_BINARY_RESULT (T1, T2) quotient</span>
<span class="lineNum">    2996 </span><span class="lineCov">   20222134 :     = divmod_trunc (x, y, sgn, &amp;remainder);</span>
<span class="lineNum">    2997 </span><span class="lineCov">       8700 :   if (remainder == 0)</span>
<span class="lineNum">    2998 </span><span class="lineCov">   36942405 :     {</span>
<span class="lineNum">    2999 </span><span class="lineCov">      82292 :       *res = quotient;</span>
<span class="lineNum">    3000 </span><span class="lineCov">   84750117 :       return true;</span>
<span class="lineNum">    3001 </span><span class="lineCov">   71924631 :     }</span>
<span class="lineNum">    3002 </span><span class="lineCov">   61986388 :   return false;</span>
<span class="lineNum">    3003 </span><span class="lineCov">   61990289 : }</span>
<span class="lineNum">    3004 </span><span class="lineCov">   49427921 : </span>
<span class="lineNum">    3005 </span><span class="lineCov">   84325681 : /* Return X &lt;&lt; Y.  Return 0 if Y is greater than or equal to</span>
<span class="lineNum">    3006 </span><span class="lineCov">   73420569 :    the precision of X.  */</span>
<a name="3007"><span class="lineNum">    3007 </span><span class="lineCov">   25244344 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    3008 </span><span class="lineCov">   62121744 : inline WI_UNARY_RESULT (T1)</span>
<span class="lineNum">    3009 </span><span class="lineCov">   49863582 : wi::lshift (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    3010 </span><span class="lineCov">   48953829 : {</span>
<span class="lineNum">    3011 </span><span class="lineCov">   38398400 :   WI_UNARY_RESULT_VAR (result, val, T1, x);</span>
<span class="lineNum">    3012 </span><span class="lineCov">   37019231 :   unsigned int precision = get_precision (result);</span>
<span class="lineNum">    3013 </span><span class="lineCov">   12208459 :   WIDE_INT_REF_FOR (T1) xi (x, precision);</span>
<span class="lineNum">    3014 </span><span class="lineCov">   14245092 :   WIDE_INT_REF_FOR (T2) yi (y);</span>
<span class="lineNum">    3015 </span><span class="lineCov">   19849762 :   /* Handle the simple cases quickly.   */</span>
<span class="lineNum">    3016 </span><span class="lineCov">   19581696 :   if (geu_p (yi, precision))</span>
<span class="lineNum">    3017 </span><span class="lineCov">    9978720 :     {</span>
<span class="lineNum">    3018 </span><span class="lineCov">   36961676 :       val[0] = 0;</span>
<span class="lineNum">    3019 </span><span class="lineCov">   16723510 :       result.set_len (1);</span>
<span class="lineNum">    3020 </span><span class="lineCov">   43249075 :     }</span>
<span class="lineNum">    3021 </span><span class="lineCov">   23599240 :   else</span>
<span class="lineNum">    3022 </span><span class="lineCov">   13166747 :     {</span>
<span class="lineNum">    3023 </span><span class="lineCov">   12417337 :       unsigned int shift = yi.to_uhwi ();</span>
<span class="lineNum">    3024 </span><span class="lineCov">   14281406 :       /* For fixed-precision integers like offset_int and widest_int,</span>
<span class="lineNum">    3025 </span><span class="lineCov">    4533050 :          handle the case where the shift value is constant and the</span>
<span class="lineNum">    3026 </span><span class="lineCov">    2563904 :          result is a single nonnegative HWI (meaning that we don't</span>
<span class="lineNum">    3027 </span><span class="lineCov">   18404750 :          need to worry about val[1]).  This is particularly common</span>
<span class="lineNum">    3028 </span><span class="lineCov">    2389386 :          for converting a byte count to a bit count.</span>
<span class="lineNum">    3029 </span><span class="lineCov">     243737 : </span>
<span class="lineNum">    3030 </span><span class="lineCov">   44735457 :          For variable-precision integers like wide_int, handle HWI</span>
<span class="lineNum">    3031 </span><span class="lineCov">     236900 :          and sub-HWI integers inline.  */</span>
<span class="lineNum">    3032 </span><span class="lineCov">   89655388 :       if (STATIC_CONSTANT_P (xi.precision &gt; HOST_BITS_PER_WIDE_INT)</span>
<span class="lineNum">    3033 </span><span class="lineCov">   89546295 :           ? (STATIC_CONSTANT_P (shift &lt; HOST_BITS_PER_WIDE_INT - 1)</span>
<span class="lineNum">    3034 </span><span class="lineCov">   90465232 :              &amp;&amp; xi.len == 1</span>
<span class="lineNum">    3035 </span><span class="lineCov">   44561102 :              &amp;&amp; xi.val[0] &lt;= (HOST_WIDE_INT) ((unsigned HOST_WIDE_INT)</span>
<span class="lineNum">    3036 </span><span class="lineCov">    1792083 :                                               HOST_WIDE_INT_MAX &gt;&gt; shift))</span>
<span class="lineNum">    3037 </span><span class="lineCov">     165177 :           : precision &lt;= HOST_BITS_PER_WIDE_INT)</span>
<span class="lineNum">    3038 </span><span class="lineCov">   11379264 :         {</span>
<span class="lineNum">    3039 </span><span class="lineCov">     462418 :           val[0] = xi.ulow () &lt;&lt; shift;</span>
<span class="lineNum">    3040 </span><span class="lineCov">   22223949 :           result.set_len (1);</span>
<span class="lineNum">    3041 </span><span class="lineCov">   26255515 :         }</span>
<span class="lineNum">    3042 </span><span class="lineCov">   22195128 :       else</span>
<span class="lineNum">    3043 </span><span class="lineCov">   26604678 :         result.set_len (lshift_large (val, xi.val, xi.len,</span>
<span class="lineNum">    3044 </span><span class="lineCov">    4069904 :                                       precision, shift));</span>
<span class="lineNum">    3045 </span><span class="lineCov">    2034942 :     }</span>
<span class="lineNum">    3046 </span><span class="lineCov">    2860616 :   return result;</span>
<span class="lineNum">    3047 </span><span class="lineCov">    2050000 : }</span>
<span class="lineNum">    3048 </span><span class="lineCov">    4283975 : </span>
<span class="lineNum">    3049 </span><span class="lineCov">   30143822 : /* Return X &gt;&gt; Y, using a logical shift.  Return 0 if Y is greater than</span>
<span class="lineNum">    3050 </span><span class="lineCov">   11283139 :    or equal to the precision of X.  */</span>
<a name="3051"><span class="lineNum">    3051 </span><span class="lineCov">   67418800 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    3052 </span><span class="lineCov">  113877632 : inline WI_UNARY_RESULT (T1)</span>
<span class="lineNum">    3053 </span><span class="lineCov">   56408693 : wi::lrshift (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    3054 </span><span class="lineCov">  100156117 : {</span>
<span class="lineNum">    3055 </span><span class="lineCov">   94839467 :   WI_UNARY_RESULT_VAR (result, val, T1, x);</span>
<span class="lineNum">    3056 </span><span class="lineCov">   67218351 :   /* Do things in the precision of the input rather than the output,</span>
<span class="lineNum">    3057 </span><span class="lineCov">   95010030 :      since the result can be no larger than that.  */</span>
<span class="lineNum">    3058 </span><span class="lineCov">   66470411 :   WIDE_INT_REF_FOR (T1) xi (x);</span>
<span class="lineNum">    3059 </span><span class="lineCov">  100455995 :   WIDE_INT_REF_FOR (T2) yi (y);</span>
<span class="lineNum">    3060 </span><span class="lineCov">   44774951 :   /* Handle the simple cases quickly.   */</span>
<span class="lineNum">    3061 </span><span class="lineCov">     535924 :   if (geu_p (yi, xi.precision))</span>
<span class="lineNum">    3062 </span><span class="lineCov">     520994 :     {</span>
<span class="lineNum">    3063 </span><span class="lineCov">     261000 :       val[0] = 0;</span>
<span class="lineNum">    3064 </span><span class="lineCov">      58256 :       result.set_len (1);</span>
<span class="lineNum">    3065 </span><span class="lineCov">   17945364 :     }</span>
<span class="lineNum">    3066 </span><span class="lineCov">   55728373 :   else</span>
<span class="lineNum">    3067 </span><span class="lineCov">    5592838 :     {</span>
<span class="lineNum">    3068 </span><span class="lineCov">   13498046 :       unsigned int shift = yi.to_uhwi ();</span>
<span class="lineNum">    3069 </span><span class="lineCov">   24069635 :       /* For fixed-precision integers like offset_int and widest_int,</span>
<span class="lineNum">    3070 </span><span class="lineCov">    7425199 :          handle the case where the shift value is constant and the</span>
<span class="lineNum">    3071 </span><span class="lineCov">   38894336 :          shifted value is a single nonnegative HWI (meaning that all</span>
<span class="lineNum">    3072 </span><span class="lineCov">   13515010 :          bits above the HWI are zero).  This is particularly common</span>
<span class="lineNum">    3073 </span><span class="lineCov">    2544202 :          for converting a bit count to a byte count.</span>
<span class="lineNum">    3074 </span><span class="lineCov">   19486800 : </span>
<span class="lineNum">    3075 </span><span class="lineCov">    2505674 :          For variable-precision integers like wide_int, handle HWI</span>
<span class="lineNum">    3076 </span><span class="lineCov">   25087820 :          and sub-HWI integers inline.  */</span>
<span class="lineNum">    3077 </span><span class="lineCov">   10467520 :       if (STATIC_CONSTANT_P (xi.precision &gt; HOST_BITS_PER_WIDE_INT)</span>
<span class="lineNum">    3078 </span><span class="lineCov">   25072381 :           ? (shift &lt; HOST_BITS_PER_WIDE_INT</span>
<span class="lineNum">    3079 </span><span class="lineCov">    1736700 :              &amp;&amp; xi.len == 1</span>
<span class="lineNum">    3080 </span><span class="lineCov">      95191 :              &amp;&amp; xi.val[0] &gt;= 0)</span>
<span class="lineNum">    3081 </span><span class="lineCov">   13143003 :           : xi.precision &lt;= HOST_BITS_PER_WIDE_INT)</span>
<span class="lineNum">    3082 </span><span class="lineCov">    6453868 :         {</span>
<span class="lineNum">    3083 </span><span class="lineCov">    1376250 :           val[0] = xi.to_uhwi () &gt;&gt; shift;</span>
<span class="lineNum">    3084 </span><span class="lineCov">    1457930 :           result.set_len (1);</span>
<span class="lineNum">    3085 </span><span class="lineCov">    1385044 :         }</span>
<span class="lineNum">    3086 </span><span class="lineCov">    1383825 :       else</span>
<span class="lineNum">    3087 </span><span class="lineCov">      15778 :         result.set_len (lrshift_large (val, xi.val, xi.len, xi.precision,</span>
<span class="lineNum">    3088 </span><span class="lineCov">      75112 :                                        get_precision (result), shift));</span>
<span class="lineNum">    3089 </span><span class="lineCov">    3093252 :     }</span>
<span class="lineNum">    3090 </span><span class="lineCov">    6607549 :   return result;</span>
<span class="lineNum">    3091 </span><span class="lineCov">    5635120 : }</span>
<span class="lineNum">    3092 </span><span class="lineCov">    9569838 : </span>
<span class="lineNum">    3093 </span><span class="lineCov">    6949406 : /* Return X &gt;&gt; Y, using an arithmetic shift.  Return a sign mask if</span>
<span class="lineNum">    3094 </span><span class="lineCov">    2884177 :    Y is greater than or equal to the precision of X.  */</span>
<a name="3095"><span class="lineNum">    3095 </span><span class="lineCov">    3355833 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    3096 </span><span class="lineCov">    8364126 : inline WI_UNARY_RESULT (T1)</span>
<span class="lineNum">    3097 </span><span class="lineCov">    4512938 : wi::arshift (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    3098 </span><span class="lineCov">     805510 : {</span>
<span class="lineNum">    3099 </span><span class="lineCov">   13439726 :   WI_UNARY_RESULT_VAR (result, val, T1, x);</span>
<span class="lineNum">    3100 </span><span class="lineCov">    1585487 :   /* Do things in the precision of the input rather than the output,</span>
<span class="lineNum">    3101 </span><span class="lineCov">   24680692 :      since the result can be no larger than that.  */</span>
<span class="lineNum">    3102 </span><span class="lineCov">   24257700 :   WIDE_INT_REF_FOR (T1) xi (x);</span>
<span class="lineNum">    3103 </span><span class="lineCov">   28584674 :   WIDE_INT_REF_FOR (T2) yi (y);</span>
<span class="lineNum">    3104 </span><span class="lineCov">     480544 :   /* Handle the simple cases quickly.   */</span>
<span class="lineNum">    3105 </span><span class="lineCov">    7069934 :   if (geu_p (yi, xi.precision))</span>
<span class="lineNum">    3106 </span><span class="lineCov">      40474 :     {</span>
<span class="lineNum">    3107 </span><span class="lineCov">   26137925 :       val[0] = sign_mask (x);</span>
<span class="lineNum">    3108 </span><span class="lineCov">   15182039 :       result.set_len (1);</span>
<span class="lineNum">    3109 </span><span class="lineCov">   14019044 :     }</span>
<span class="lineNum">    3110 </span><span class="lineCov">   17508029 :   else</span>
<span class="lineNum">    3111 </span><span class="lineCov">    3508923 :     {</span>
<span class="lineNum">    3112 </span><span class="lineCov">    2395463 :       unsigned int shift = yi.to_uhwi ();</span>
<span class="lineNum">    3113 </span><span class="lineCov">    1163567 :       if (xi.precision &lt;= HOST_BITS_PER_WIDE_INT)</span>
<span class="lineNum">    3114 </span><span class="lineCov">    1300797 :         {</span>
<span class="lineNum">    3115 </span><span class="lineCov">   13419678 :           val[0] = sext_hwi (xi.ulow () &gt;&gt; shift, xi.precision - shift);</span>
<span class="lineNum">    3116 </span><span class="lineCov">    5512512 :           result.set_len (1, true);</span>
<span class="lineNum">    3117 </span><span class="lineCov">     550776 :         }</span>
<span class="lineNum">    3118 </span><span class="lineCov">   16427224 :       else</span>
<span class="lineNum">    3119 </span><span class="lineCov">   12391468 :         result.set_len (arshift_large (val, xi.val, xi.len, xi.precision,</span>
<span class="lineNum">    3120 </span><span class="lineCov">   12315799 :                                        get_precision (result), shift));</span>
<span class="lineNum">    3121 </span><span class="lineCov">   24845773 :     }</span>
<span class="lineNum">    3122 </span><span class="lineCov">    5902900 :   return result;</span>
<span class="lineNum">    3123 </span><span class="lineCov">    3249817 : }</span>
<span class="lineNum">    3124 </span><span class="lineCov">   29446842 : </span>
<span class="lineNum">    3125 </span><span class="lineCov">    7389102 : /* Return X &gt;&gt; Y, using an arithmetic shift if SGN is SIGNED and a</span>
<span class="lineNum">    3126 </span><span class="lineCov">   34470045 :    logical shift otherwise.  */</span>
<a name="3127"><span class="lineNum">    3127 </span><span class="lineCov">   29489217 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    3128 </span><span class="lineCov">   25352946 : inline WI_UNARY_RESULT (T1)</span>
<span class="lineNum">    3129 </span><span class="lineCov">   15480273 : wi::rshift (const T1 &amp;x, const T2 &amp;y, signop sgn)</span>
<span class="lineNum">    3130 </span><span class="lineCov">   17964190 : {</span>
<span class="lineNum">    3131 </span><span class="lineCov">    9362864 :   if (sgn == UNSIGNED)</span>
<span class="lineNum">    3132 </span><span class="lineCov">   18712665 :     return lrshift (x, y);</span>
<span class="lineNum">    3133 </span><span class="lineCov">   12072237 :   else</span>
<span class="lineNum">    3134 </span><span class="lineCov">   13139107 :     return arshift (x, y);</span>
<span class="lineNum">    3135 </span><span class="lineCov">   14649435 : }</span>
<span class="lineNum">    3136 </span><span class="lineCov">    9097093 : </span>
<span class="lineNum">    3137 </span><span class="lineCov">    8259279 : /* Return the result of rotating the low WIDTH bits of X left by Y</span>
<span class="lineNum">    3138 </span><span class="lineCov">    8653600 :    bits and zero-extending the result.  Use a full-width rotate if</span>
<span class="lineNum">    3139 </span><span class="lineCov">     223966 :    WIDTH is zero.  */</span>
<a name="3140"><span class="lineNum">    3140 </span><span class="lineCov">      98977 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    3141 </span><span class="lineCov">   26453131 : WI_UNARY_RESULT (T1)</span>
<span class="lineNum">    3142 </span><span class="lineCov">     196171 : wi::lrotate (const T1 &amp;x, const T2 &amp;y, unsigned int width)</span>
<span class="lineNum">    3143 </span><span class="lineCov">   38220638 : {</span>
<span class="lineNum">    3144 </span><span class="lineCov">   38102373 :   unsigned int precision = get_binary_precision (x, x);</span>
<span class="lineNum">    3145 </span><span class="lineCov">   19318721 :   if (width == 0)</span>
<span class="lineNum">    3146 </span><span class="lineCov">   38340580 :     width = precision;</span>
<span class="lineNum">    3147 </span><span class="lineCov">     225274 :   WI_UNARY_RESULT (T2) ymod = umod_trunc (y, width);</span>
<span class="lineNum">    3148 </span><span class="lineCov">   19266971 :   WI_UNARY_RESULT (T1) left = wi::lshift (x, ymod);</span>
<span class="lineNum">    3149 </span><span class="lineCov">     109789 :   WI_UNARY_RESULT (T1) right = wi::lrshift (x, wi::sub (width, ymod));</span>
<span class="lineNum">    3150 </span><span class="lineCov">     927961 :   if (width != precision)</span>
<span class="lineNum">    3151 </span><span class="lineCov">     204343 :     return wi::zext (left, width) | wi::zext (right, width);</span>
<span class="lineNum">    3152 </span><span class="lineCov">    6121763 :   return left | right;</span>
<span class="lineNum">    3153 </span><span class="lineCov">    1789268 : }</span>
<span class="lineNum">    3154 </span><span class="lineCov">   13342869 : </span>
<span class="lineNum">    3155 </span><span class="lineCov">   25060744 : /* Return the result of rotating the low WIDTH bits of X right by Y</span>
<span class="lineNum">    3156 </span><span class="lineCov">   14413511 :    bits and zero-extending the result.  Use a full-width rotate if</span>
<span class="lineNum">    3157 </span><span class="lineCov">    6128597 :    WIDTH is zero.  */</span>
<a name="3158"><span class="lineNum">    3158 </span><span class="lineCov">    5405674 : template &lt;typename T1, typename T2&gt;</span></a>
<span class="lineNum">    3159 </span><span class="lineCov">    2528743 : WI_UNARY_RESULT (T1)</span>
<span class="lineNum">    3160 </span><span class="lineCov">    2882431 : wi::rrotate (const T1 &amp;x, const T2 &amp;y, unsigned int width)</span>
<span class="lineNum">    3161 </span><span class="lineCov">    2014254 : {</span>
<span class="lineNum">    3162 </span><span class="lineCov">    4005029 :   unsigned int precision = get_binary_precision (x, x);</span>
<span class="lineNum">    3163 </span><span class="lineCov">   16572890 :   if (width == 0)</span>
<span class="lineNum">    3164 </span><span class="lineCov">     927068 :     width = precision;</span>
<span class="lineNum">    3165 </span><span class="lineCov">   29242977 :   WI_UNARY_RESULT (T2) ymod = umod_trunc (y, width);</span>
<span class="lineNum">    3166 </span><span class="lineCov">   31455917 :   WI_UNARY_RESULT (T1) right = wi::lrshift (x, ymod);</span>
<span class="lineNum">    3167 </span><span class="lineCov">   29911032 :   WI_UNARY_RESULT (T1) left = wi::lshift (x, wi::sub (width, ymod));</span>
<span class="lineNum">    3168 </span><span class="lineCov">   28932800 :   if (width != precision)</span>
<span class="lineNum">    3169 </span><span class="lineCov">    4290815 :     return wi::zext (left, width) | wi::zext (right, width);</span>
<span class="lineNum">    3170 </span><span class="lineCov">     170187 :   return left | right;</span>
<span class="lineNum">    3171 </span><span class="lineCov">    1872671 : }</span>
<span class="lineNum">    3172 </span><span class="lineCov">     146587 : </span>
<span class="lineNum">    3173 </span><span class="lineCov">    4047501 : /* Return 0 if the number of 1s in X is even and 1 if the number of 1s</span>
<a name="3174"><span class="lineNum">    3174 </span><span class="lineCov">    2702703 :    is odd.  */</span></a>
<span class="lineNum">    3175 </span><span class="lineCov">   21743135 : inline int</span>
<span class="lineNum">    3176 </span><span class="lineCov">    1352154 : wi::parity (const wide_int_ref &amp;x)</span>
<span class="lineNum">    3177 </span><span class="lineCov">    1369797 : {</span>
<span class="lineNum">    3178 </span><span class="lineCov">   19045762 :   return popcount (x) &amp; 1;</span>
<span class="lineNum">    3179 </span><span class="lineCov">    3914803 : }</span>
<span class="lineNum">    3180 </span><span class="lineCov">    1306353 : </span>
<span class="lineNum">    3181 </span><span class="lineCov">     310906 : /* Extract WIDTH bits from X, starting at BITPOS.  */</span>
<a name="3182"><span class="lineNum">    3182 </span><span class="lineCov">       4292 : template &lt;typename T&gt;</span></a>
<span class="lineNum">    3183 </span><span class="lineCov">     909165 : inline unsigned HOST_WIDE_INT</span>
<span class="lineNum">    3184 </span><span class="lineCov">     662715 : wi::extract_uhwi (const T &amp;x, unsigned int bitpos, unsigned int width)</span>
<span class="lineNum">    3185 </span><span class="lineCov">   14701434 : {</span>
<span class="lineNum">    3186 </span><span class="lineCov">     582858 :   unsigned precision = get_precision (x);</span>
<span class="lineNum">    3187 </span><span class="lineCov">   29401250 :   if (precision &lt; bitpos + width)</span>
<span class="lineNum">    3188 </span><span class="lineCov">   29003439 :     precision = bitpos + width;</span>
<span class="lineNum">    3189 </span><span class="lineCov">   14807416 :   WIDE_INT_REF_FOR (T) xi (x, precision);</span>
<span class="lineNum">    3190 </span><span class="lineCov">   15082623 : </span>
<span class="lineNum">    3191 </span><span class="lineCov">   14765987 :   /* Handle this rare case after the above, so that we assert about</span>
<span class="lineNum">    3192 </span><span class="lineCov">   28955467 :      bogus BITPOS values.  */</span>
<span class="lineNum">    3193 </span><span class="lineCov">   14868604 :   if (width == 0)</span>
<span class="lineNum">    3194 </span><span class="lineCov">     311573 :     return 0;</span>
<span class="lineNum">    3195 </span><span class="lineCov">     455904 : </span>
<span class="lineNum">    3196 </span><span class="lineCov">     424534 :   unsigned int start = bitpos / HOST_BITS_PER_WIDE_INT;</span>
<span class="lineNum">    3197 </span><span class="lineCov">     117890 :   unsigned int shift = bitpos % HOST_BITS_PER_WIDE_INT;</span>
<span class="lineNum">    3198 </span><span class="lineCov">     220572 :   unsigned HOST_WIDE_INT res = xi.elt (start);</span>
<span class="lineNum">    3199 </span><span class="lineCov">   14734284 :   res &gt;&gt;= shift;</span>
<span class="lineNum">    3200 </span><span class="lineCov">     156578 :   if (shift + width &gt; HOST_BITS_PER_WIDE_INT)</span>
<span class="lineNum">    3201 </span><span class="lineCov">   14272769 :     {</span>
<span class="lineNum">    3202 </span><span class="lineCov">      68949 :       unsigned HOST_WIDE_INT upper = xi.elt (start + 1);</span>
<span class="lineNum">    3203 </span><span class="lineCov">   28455712 :       res |= upper &lt;&lt; (-shift % HOST_BITS_PER_WIDE_INT);</span>
<span class="lineNum">    3204 </span><span class="lineCov">   28518879 :     }</span>
<span class="lineNum">    3205 </span><span class="lineCov">   28509487 :   return zext_hwi (res, width);</span>
<span class="lineNum">    3206 </span><span class="lineCov">   29283977 : }</span>
<span class="lineNum">    3207 </span><span class="lineCov">    1381529 : </span>
<span class="lineNum">    3208 </span><span class="lineCov">    3132179 : /* Return the minimum precision needed to store X with sign SGN.  */</span>
<a name="3209"><span class="lineNum">    3209 </span><span class="lineCov">    2314208 : template &lt;typename T&gt;</span></a>
<span class="lineNum">    3210 </span><span class="lineCov">   33958701 : inline unsigned int</span>
<span class="lineNum">    3211 </span><span class="lineCov">    1496189 : wi::min_precision (const T &amp;x, signop sgn)</span>
<span class="lineNum">    3212 </span><span class="lineCov">  114138837 : {</span>
<span class="lineNum">    3213 </span><span class="lineCov">   64190686 :   if (sgn == SIGNED)</span>
<span class="lineNum">    3214 </span><span class="lineCov">  118399098 :     return get_precision (x) - clrsb (x);</span>
<span class="lineNum">    3215 </span><span class="lineCov">   70933417 :   else</span>
<span class="lineNum">    3216 </span><span class="lineCov">   50973016 :     return get_precision (x) - clz (x);</span>
<span class="lineNum">    3217 </span><span class="lineCov">   52829947 : }</span>
<span class="lineNum">    3218 </span><span class="lineCov">     425536 : </span>
<span class="lineNum">    3219 </span><span class="lineCov">  118649390 : #define SIGNED_BINARY_PREDICATE(OP, F)                  \</span>
<span class="lineNum">    3220 </span><span class="lineCov">   55518004 :   template &lt;typename T1, typename T2&gt;                     \</span>
<span class="lineNum">    3221 </span><span class="lineCov">    4527598 :     inline WI_SIGNED_BINARY_PREDICATE_RESULT (T1, T2)   \</span>
<span class="lineNum">    3222 </span><span class="lineCov">    5381472 :     OP (const T1 &amp;x, const T2 &amp;y)                       \</span>
<span class="lineNum">    3223 </span><span class="lineCov">   16183671 :     {                                                   \</span>
<span class="lineNum">    3224 </span><span class="lineCov">    4617851 :       return wi::F (x, y);                              \</span>
<a name="3225"><span class="lineNum">    3225 </span><span class="lineCov">   62035140 :     }</span></a>
<a name="3226"><span class="lineNum">    3226 </span><span class="lineCov">   30392924 : </span></a>
<a name="3227"><span class="lineNum">    3227 </span><span class="lineCov">  174541736 : SIGNED_BINARY_PREDICATE (operator &lt;, lts_p)</span></a>
<span class="lineNum">    3228 </span><span class="lineCov">   15221163 : SIGNED_BINARY_PREDICATE (operator &lt;=, les_p)</span>
<span class="lineNum">    3229 </span><span class="lineCov">  204201169 : SIGNED_BINARY_PREDICATE (operator &gt;, gts_p)</span>
<span class="lineNum">    3230 </span><span class="lineCov">  155512047 : SIGNED_BINARY_PREDICATE (operator &gt;=, ges_p)</span>
<span class="lineNum">    3231 </span><span class="lineCov">  143359453 : </span>
<span class="lineNum">    3232 </span><span class="lineCov">   64157254 : #undef SIGNED_BINARY_PREDICATE</span>
<span class="lineNum">    3233 </span><span class="lineCov">   63552516 : </span>
<span class="lineNum">    3234 </span><span class="lineCov">   62919000 : #define UNARY_OPERATOR(OP, F) \</span>
<span class="lineNum">    3235 </span><span class="lineCov">    1021797 :   template&lt;typename T&gt; \</span>
<span class="lineNum">    3236 </span><span class="lineCov">  188915040 :   WI_UNARY_RESULT (generic_wide_int&lt;T&gt;) \</span>
<span class="lineNum">    3237 </span><span class="lineCov">   77112125 :   OP (const generic_wide_int&lt;T&gt; &amp;x) \</span>
<span class="lineNum">    3238 </span><span class="lineCov">     116463 :   { \</span>
<span class="lineNum">    3239 </span><span class="lineCov">     258529 :     return wi::F (x); \</span>
<span class="lineNum">    3240 </span><span class="lineCov">     264516 :   }</span>
<span class="lineNum">    3241 </span><span class="lineCov">     563189 : </span>
<span class="lineNum">    3242 </span><span class="lineCov">  442291294 : #define BINARY_PREDICATE(OP, F) \</span>
<span class="lineNum">    3243 </span><span class="lineCov">     290278 :   template&lt;typename T1, typename T2&gt; \</span>
<span class="lineNum">    3244 </span><span class="lineCov"> 1172709601 :   WI_BINARY_PREDICATE_RESULT (T1, T2) \</span>
<span class="lineNum">    3245 </span><span class="lineCov">  758343963 :   OP (const T1 &amp;x, const T2 &amp;y) \</span>
<span class="lineNum">    3246 </span><span class="lineCov">  869044700 :   { \</span>
<span class="lineNum">    3247 </span><span class="lineCov">  820157055 :     return wi::F (x, y); \</span>
<span class="lineNum">    3248 </span><span class="lineCov">  458715445 :   }</span>
<span class="lineNum">    3249 </span><span class="lineCov">  414453079 : </span>
<span class="lineNum">    3250 </span><span class="lineCov">   35481950 : #define BINARY_OPERATOR(OP, F) \</span>
<span class="lineNum">    3251 </span><span class="lineCov"> 1179104853 :   template&lt;typename T1, typename T2&gt; \</span>
<span class="lineNum">    3252 </span><span class="lineCov">  387562170 :   WI_BINARY_OPERATOR_RESULT (T1, T2) \</span>
<span class="lineNum">    3253 </span><span class="lineCov">  106379636 :   OP (const T1 &amp;x, const T2 &amp;y) \</span>
<span class="lineNum">    3254 </span><span class="lineCov">   42490676 :   { \</span>
<span class="lineNum">    3255 </span><span class="lineCov">     995021 :     return wi::F (x, y); \</span>
<span class="lineNum">    3256 </span><span class="lineCov">    2704363 :   }</span>
<span class="lineNum">    3257 </span><span class="lineCov">  378874875 : </span>
<span class="lineNum">    3258 </span><span class="lineCov">   74273945 : #define SHIFT_OPERATOR(OP, F) \</span>
<span class="lineNum">    3259 </span><span class="lineCov">   64254493 :   template&lt;typename T1, typename T2&gt; \</span>
<span class="lineNum">    3260 </span><span class="lineCov">   26882424 :   WI_BINARY_OPERATOR_RESULT (T1, T1) \</span>
<span class="lineNum">    3261 </span><span class="lineCov">   34241473 :   OP (const T1 &amp;x, const T2 &amp;y) \</span>
<span class="lineNum">    3262 </span><span class="lineCov">    8119293 :   { \</span>
<span class="lineNum">    3263 </span><span class="lineCov">    6037891 :     return wi::F (x, y); \</span>
<span class="lineNum">    3264 </span><span class="lineCov">    3094878 :   }</span>
<a name="3265"><span class="lineNum">    3265 </span><span class="lineCov">    2750026 : </span></a>
<a name="3266"><span class="lineNum">    3266 </span><span class="lineCov">     956228 : UNARY_OPERATOR (operator ~, bit_not)</span></a>
<a name="3267"><span class="lineNum">    3267 </span><span class="lineCov">    1322306 : UNARY_OPERATOR (operator -, neg)</span></a>
<span class="lineNum">    3268 </span><span class="lineCov">   34563892 : BINARY_PREDICATE (operator ==, eq_p)</span>
<span class="lineNum">    3269 </span><span class="lineCov">    1475620 : BINARY_PREDICATE (operator !=, ne_p)</span>
<span class="lineNum">    3270 </span><span class="lineCov">   19276222 : BINARY_OPERATOR (operator &amp;, bit_and)</span>
<a name="3271"><span class="lineNum">    3271 </span><span class="lineCov">   15710774 : BINARY_OPERATOR (operator |, bit_or)</span></a>
<span class="lineNum">    3272 </span><span class="lineCov">   11607795 : BINARY_OPERATOR (operator ^, bit_xor)</span>
<span class="lineNum">    3273 </span><span class="lineCov">   11330467 : BINARY_OPERATOR (operator +, add)</span>
<span class="lineNum">    3274 </span><span class="lineCov">    7304964 : BINARY_OPERATOR (operator -, sub)</span>
<span class="lineNum">    3275 </span><span class="lineCov">     658350 : BINARY_OPERATOR (operator *, mul)</span>
<span class="lineNum">    3276 </span><span class="lineCov">  385551704 : SHIFT_OPERATOR (operator &lt;&lt;, lshift)</span>
<span class="lineNum">    3277 </span><span class="lineCov">    5415028 : </span>
<span class="lineNum">    3278 </span><span class="lineCov"> 1165918313 : #undef UNARY_OPERATOR</span>
<span class="lineNum">    3279 </span><span class="lineCov">  737716801 : #undef BINARY_PREDICATE</span>
<span class="lineNum">    3280 </span><span class="lineCov">  917312775 : #undef BINARY_OPERATOR</span>
<span class="lineNum">    3281 </span><span class="lineCov">  856326004 : #undef SHIFT_OPERATOR</span>
<span class="lineNum">    3282 </span><span class="lineCov">  487019885 : </span>
<span class="lineNum">    3283 </span><span class="lineCov">  427941022 : template &lt;typename T1, typename T2&gt;</span>
<span class="lineNum">    3284 </span><span class="lineCov">   59419594 : inline WI_SIGNED_SHIFT_RESULT (T1, T2)</span>
<span class="lineNum">    3285 </span><span class="lineCov"> 1178567032 : operator &gt;&gt; (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    3286 </span><span class="lineCov">  368853772 : {</span>
<span class="lineNum">    3287 </span><span class="lineCov">  176862070 :   return wi::arshift (x, y);</span>
<span class="lineNum">    3288 </span><span class="lineCov">   60874604 : }</span>
<span class="lineNum">    3289 </span><span class="lineCov">      30219 : </span>
<span class="lineNum">    3290 </span><span class="lineCov">    2715455 : template &lt;typename T1, typename T2&gt;</span>
<span class="lineNum">    3291 </span><span class="lineCov">  369284439 : inline WI_SIGNED_SHIFT_RESULT (T1, T2)</span>
<span class="lineNum">    3292 </span><span class="lineCov">      90988 : operator / (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    3293 </span><span class="lineCov">   62043845 : {</span>
<span class="lineNum">    3294 </span><span class="lineCov">    3407588 :   return wi::sdiv_trunc (x, y);</span>
<span class="lineNum">    3295 </span><span class="lineCov">     600077 : }</span>
<span class="lineNum">    3296 </span><span class="lineCov">     443305 : </span>
<span class="lineNum">    3297 </span><span class="lineCov">    1303308 : template &lt;typename T1, typename T2&gt;</span>
<span class="lineNum">    3298 </span><span class="lineCov">     200897 : inline WI_SIGNED_SHIFT_RESULT (T1, T2)</span>
<span class="lineNum">    3299 </span><span class="lineCov">     279854 : operator % (const T1 &amp;x, const T2 &amp;y)</span>
<span class="lineNum">    3300 </span><span class="lineCov">     198823 : {</span>
<span class="lineNum">    3301 </span><span class="lineCov">     333150 :   return wi::smod_trunc (x, y);</span>
<span class="lineNum">    3302 </span><span class="lineCov">    5777607 : }</span>
<span class="lineNum">    3303 </span><span class="lineCov">     929885 : </span>
<a name="3304"><span class="lineNum">    3304 </span><span class="lineCov">   16902057 : template&lt;typename T&gt;</span></a>
<span class="lineNum">    3305 </span><span class="lineCov">    9161201 : void</span>
<span class="lineNum">    3306 </span><span class="lineCov">    6994532 : gt_ggc_mx (generic_wide_int &lt;T&gt; *)</span>
<span class="lineNum">    3307 </span><span class="lineCov">    6940644 : {</span>
<span class="lineNum">    3308 </span><span class="lineCov">    2340893 : }</span>
<span class="lineNum">    3309 </span><span class="lineCov">    2225750 : </span>
<a name="3310"><span class="lineNum">    3310 </span><span class="lineCov">    3018127 : template&lt;typename T&gt;</span></a>
<span class="lineNum">    3311 </span><span class="lineCov">    6398811 : void</span>
<span class="lineNum">    3312 </span><span class="lineCov">    3585077 : gt_pch_nx (generic_wide_int &lt;T&gt; *)</span>
<span class="lineNum">    3313 </span><span class="lineCov">    6017214 : {</span>
<span class="lineNum">    3314 </span><span class="lineCov">    1099806 : }</span>
<span class="lineNum">    3315 </span><span class="lineCov">    3172398 : </span>
<a name="3316"><span class="lineNum">    3316 </span><span class="lineCov">     603741 : template&lt;typename T&gt;</span></a>
<span class="lineNum">    3317 </span><span class="lineCov">    3067624 : void</span>
<span class="lineNum">    3318 </span><span class="lineCov">     339048 : gt_pch_nx (generic_wide_int &lt;T&gt; *, void (*) (void *, void *), void *)</span>
<span class="lineNum">    3319 </span><span class="lineCov">    1878169 : {</span>
<span class="lineNum">    3320 </span><span class="lineCov">     761905 : }</span>
<span class="lineNum">    3321 </span><span class="lineCov">      37529 : </span>
<span class="lineNum">    3322 </span><span class="lineCov">     200653 : template&lt;int N&gt;</span>
<span class="lineNum">    3323 </span><span class="lineCov">     302326 : void</span>
<span class="lineNum">    3324 </span><span class="lineCov">       9353 : gt_ggc_mx (trailing_wide_ints &lt;N&gt; *)</span>
<span class="lineNum">    3325 </span><span class="lineCov">     480267 : {</span>
<span class="lineNum">    3326 </span><span class="lineCov">     769469 : }</span>
<span class="lineNum">    3327 </span><span class="lineCov">    2290739 : </span>
<span class="lineNum">    3328 </span><span class="lineCov">   56930345 : template&lt;int N&gt;</span>
<span class="lineNum">    3329 </span><span class="lineCov">    7270459 : void</span>
<span class="lineNum">    3330 </span><span class="lineCov">  147409600 : gt_pch_nx (trailing_wide_ints &lt;N&gt; *)</span>
<span class="lineNum">    3331 </span><span class="lineCov">  119633075 : {</span>
<span class="lineNum">    3332 </span><span class="lineCov">   84833096 : }</span>
<span class="lineNum">    3333 </span><span class="lineCov">   87327954 : </span>
<span class="lineNum">    3334 </span><span class="lineCov">   27546158 : template&lt;int N&gt;</span>
<span class="lineNum">    3335 </span><span class="lineNoCov">          0 : void</span>
<span class="lineNum">    3336 </span><span class="lineCov">   85428053 : gt_pch_nx (trailing_wide_ints &lt;N&gt; *, void (*) (void *, void *), void *)</span>
<span class="lineNum">    3337 </span><span class="lineCov">   27645309 : {</span>
<span class="lineNum">    3338 </span><span class="lineCov">    7453521 : }</span>
<span class="lineNum">    3339 </span><span class="lineCov">    4570474 : </span>
<span class="lineNum">    3340 </span><span class="lineCov">    4921572 : namespace wi</span>
<span class="lineNum">    3341 </span><span class="lineCov">    3227888 : {</span>
<span class="lineNum">    3342 </span><span class="lineCov">    4576009 :   /* Used for overloaded functions in which the only other acceptable</span>
<span class="lineNum">    3343 </span><span class="lineCov">    2506492 :      scalar type is a pointer.  It stops a plain 0 from being treated</span>
<span class="lineNum">    3344 </span><span class="lineCov">    6865402 :      as a null pointer.  */</span>
<span class="lineNum">    3345 </span><span class="lineCov"> 1465207830 :   struct never_used1 {};</span>
<span class="lineNum">    3346 </span><span class="lineCov">   21583658 :   struct never_used2 {};</span>
<span class="lineNum">    3347 </span><span class="lineCov"> 2930354770 : </span>
<span class="lineNum">    3348 </span><span class="lineCov"> 2930636750 :   wide_int min_value (unsigned int, signop);</span>
<span class="lineNum">    3349 </span><span class="lineCov"> 2098533568 :   wide_int min_value (never_used1 *);</span>
<span class="lineNum">    3350 </span><span class="lineCov"> 2955578815 :   wide_int min_value (never_used2 *);</span>
<span class="lineNum">    3351 </span><span class="lineCov">   11651796 :   wide_int max_value (unsigned int, signop);</span>
<span class="lineNum">    3352 </span><span class="lineCov"> 1521865946 :   wide_int max_value (never_used1 *);</span>
<span class="lineNum">    3353 </span><span class="lineCov">   91449528 :   wide_int max_value (never_used2 *);</span>
<span class="lineNum">    3354 </span><span class="lineCov">   38703209 : </span>
<span class="lineNum">    3355 </span><span class="lineCov">   33562802 :   /* FIXME: this is target dependent, so should be elsewhere.</span>
<span class="lineNum">    3356 </span><span class="lineCov">   36448486 :      It also seems to assume that CHAR_BIT == BITS_PER_UNIT.  */</span>
<span class="lineNum">    3357 </span><span class="lineCov">   68381827 :   wide_int from_buffer (const unsigned char *, unsigned int);</span>
<span class="lineNum">    3358 </span><span class="lineCov">   31581991 : </span>
<span class="lineNum">    3359 </span><span class="lineCov"> 1468533937 : #ifndef GENERATOR_FILE</span>
<span class="lineNum">    3360 </span><span class="lineCov">     697468 :   void to_mpz (const wide_int_ref &amp;, mpz_t, signop);</span>
<span class="lineNum">    3361 </span><span class="lineCov">     829883 : #endif</span>
<span class="lineNum">    3362 </span><span class="lineCov">   15848482 : </span>
<span class="lineNum">    3363 </span><span class="lineCov">     370929 :   wide_int mask (unsigned int, bool, unsigned int);</span>
<span class="lineNum">    3364 </span><span class="lineCov">  103741000 :   wide_int shifted_mask (unsigned int, unsigned int, bool, unsigned int);</span>
<span class="lineNum">    3365 </span><span class="lineCov">   41816499 :   wide_int set_bit_in_zero (unsigned int, unsigned int);</span>
<span class="lineNum">    3366 </span><span class="lineCov">   65585571 :   wide_int insert (const wide_int &amp;x, const wide_int &amp;y, unsigned int,</span>
<span class="lineNum">    3367 </span><span class="lineCov">   63801726 :                    unsigned int);</span>
<span class="lineNum">    3368 </span><span class="lineCov">   99586038 :   wide_int round_down_for_mask (const wide_int &amp;, const wide_int &amp;);</span>
<span class="lineNum">    3369 </span><span class="lineCov">   84094120 :   wide_int round_up_for_mask (const wide_int &amp;, const wide_int &amp;);</span>
<span class="lineNum">    3370 </span><span class="lineCov">   88460636 : </span>
<span class="lineNum">    3371 </span><span class="lineCov">   57514305 :   template &lt;typename T&gt;</span>
<span class="lineNum">    3372 </span><span class="lineCov">   11171648 :   T mask (unsigned int, bool);</span>
<span class="lineNum">    3373 </span><span class="lineCov">        520 : </span>
<span class="lineNum">    3374 </span><span class="lineCov">   32443130 :   template &lt;typename T&gt;</span>
<span class="lineNum">    3375 </span><span class="lineCov">   10814282 :   T shifted_mask (unsigned int, unsigned int, bool);</span>
<span class="lineNum">    3376 </span><span class="lineCov">   45756169 : </span>
<span class="lineNum">    3377 </span><span class="lineCov">        124 :   template &lt;typename T&gt;</span>
<span class="lineNum">    3378 </span><span class="lineCov">        701 :   T set_bit_in_zero (unsigned int);</span>
<span class="lineNum">    3379 </span><span class="lineCov"> 1458696367 : </span>
<span class="lineNum">    3380 </span><span class="lineCov">   10817796 :   unsigned int mask (HOST_WIDE_INT *, unsigned int, bool, unsigned int);</span>
<span class="lineNum">    3381 </span><span class="lineCov">      48370 :   unsigned int shifted_mask (HOST_WIDE_INT *, unsigned int, unsigned int,</span>
<span class="lineNum">    3382 </span><span class="lineCov"> 1458687754 :                              bool, unsigned int);</span>
<span class="lineNum">    3383 </span><span class="lineCov">      96767 :   unsigned int from_array (HOST_WIDE_INT *, const HOST_WIDE_INT *,</span>
<span class="lineNum">    3384 </span><span class="lineCov">   19640307 :                            unsigned int, unsigned int, bool);</span>
<span class="lineNum">    3385 </span><span class="lineCov">    2450578 : }</span>
<span class="lineNum">    3386 </span><span class="lineCov">   40711210 : </span>
<span class="lineNum">    3387 </span><span class="lineCov">   39051910 : /* Return a PRECISION-bit integer in which the low WIDTH bits are set</span>
<a name="3388"><span class="lineNum">    3388 </span><span class="lineCov">   77273601 :    and the other bits are clear, or the inverse if NEGATE_P.  */</span></a>
<span class="lineNum">    3389 </span><span class="lineCov">   42167783 : inline wide_int</span>
<span class="lineNum">    3390 </span><span class="lineCov">   66038984 : wi::mask (unsigned int width, bool negate_p, unsigned int precision)</span>
<span class="lineNum">    3391 </span><span class="lineCov">  314212973 : {</span>
<span class="lineNum">    3392 </span><span class="lineCov">  263990878 :   wide_int result = wide_int::create (precision);</span>
<span class="lineNum">    3393 </span><span class="lineCov">   34284460 :   result.set_len (mask (result.write_val (), width, negate_p, precision));</span>
<span class="lineNum">    3394 </span><span class="lineCov">   32550492 :   return result;</span>
<span class="lineNum">    3395 </span><span class="lineCov">   67863184 : }</span>
<span class="lineNum">    3396 </span><span class="lineCov">   33141687 : </span>
<span class="lineNum">    3397 </span><span class="lineCov">     353271 : /* Return a PRECISION-bit integer in which the low START bits are clear,</span>
<span class="lineNum">    3398 </span><span class="lineCov">   35363077 :    the next WIDTH bits are set, and the other bits are clear,</span>
<a name="3399"><span class="lineNum">    3399 </span><span class="lineCov">      11491 :    or the inverse if NEGATE_P.  */</span></a>
<span class="lineNum">    3400 </span><span class="lineCov">    1055686 : inline wide_int</span>
<span class="lineNum">    3401 </span><span class="lineCov">   16345552 : wi::shifted_mask (unsigned int start, unsigned int width, bool negate_p,</span>
<span class="lineNum">    3402 </span><span class="lineCov">   31242336 :                   unsigned int precision)</span>
<span class="lineNum">    3403 </span><span class="lineCov">  181881573 : {</span>
<span class="lineNum">    3404 </span><span class="lineCov">   28889920 :   wide_int result = wide_int::create (precision);</span>
<span class="lineNum">    3405 </span><span class="lineCov">   33725428 :   result.set_len (shifted_mask (result.write_val (), start, width, negate_p,</span>
<span class="lineNum">    3406 </span><span class="lineCov">   29179091 :                                 precision));</span>
<span class="lineNum">    3407 </span><span class="lineCov">     343678 :   return result;</span>
<span class="lineNum">    3408 </span><span class="lineCov">   19211419 : }</span>
<span class="lineNum">    3409 </span><span class="lineCov">     560746 : </span>
<span class="lineNum">    3410 </span><span class="lineCov">     498072 : /* Return a PRECISION-bit integer in which bit BIT is set and all the</span>
<a name="3411"><span class="lineNum">    3411 </span><span class="lineCov">    3888281 :    others are clear.  */</span></a>
<span class="lineNum">    3412 </span><span class="lineCov">    7806658 : inline wide_int</span>
<span class="lineNum">    3413 </span><span class="lineCov">    9868172 : wi::set_bit_in_zero (unsigned int bit, unsigned int precision)</span>
<span class="lineNum">    3414 </span><span class="lineCov">   11442500 : {</span>
<span class="lineNum">    3415 </span><span class="lineCov">      34332 :   return shifted_mask (bit, 1, false, precision);</span>
<span class="lineNum">    3416 </span><span class="lineCov">      61652 : }</span>
<span class="lineNum">    3417 </span><span class="lineCov">     608541 : </span>
<span class="lineNum">    3418 </span><span class="lineCov">   19554379 : /* Return an integer of type T in which the low WIDTH bits are set</span>
<span class="lineNum">    3419 </span><span class="lineCov">     164457 :    and the other bits are clear, or the inverse if NEGATE_P.  */</span>
<span class="lineNum">    3420 </span><span class="lineCov">     587340 : template &lt;typename T&gt;</span>
<span class="lineNum">    3421 </span><span class="lineCov">   19609287 : inline T</span>
<span class="lineNum">    3422 </span><span class="lineCov">    4404872 : wi::mask (unsigned int width, bool negate_p)</span>
<span class="lineNum">    3423 </span><span class="lineCov">  628105466 : {</span>
<span class="lineNum">    3424 </span><span class="lineCov">       1568 :   STATIC_ASSERT (wi::int_traits&lt;T&gt;::precision);</span>
<span class="lineNum">    3425 </span><span class="lineCov"> 1256147904 :   T result;</span>
<span class="lineNum">    3426 </span><span class="lineCov"> 1256186069 :   result.set_len (mask (result.write_val (), width, negate_p,</span>
<span class="lineNum">    3427 </span><span class="lineCov"> 1241917704 :                         wi::int_traits &lt;T&gt;::precision));</span>
<span class="lineNum">    3428 </span><span class="lineCov"> 1242031769 :   return result;</span>
<span class="lineNum">    3429 </span><span class="lineCov">   14362254 : }</span>
<span class="lineNum">    3430 </span><span class="lineCov">  642539025 : </span>
<span class="lineNum">    3431 </span><span class="lineCov">   14504322 : /* Return an integer of type T in which the low START bits are clear,</span>
<span class="lineNum">    3432 </span><span class="lineCov">    8181933 :    the next WIDTH bits are set, and the other bits are clear, or the</span>
<span class="lineNum">    3433 </span><span class="lineCov">     244912 :    inverse if NEGATE_P.  */</span>
<span class="lineNum">    3434 </span><span class="lineCov">     196345 : template &lt;typename T&gt;</span>
<span class="lineNum">    3435 </span><span class="lineCov">     110727 : inline T</span>
<span class="lineNum">    3436 </span><span class="lineCov">    4380794 : wi::shifted_mask (unsigned int start, unsigned int width, bool negate_p)</span>
<span class="lineNum">    3437 </span><span class="lineCov">  628401003 : {</span>
<span class="lineNum">    3438 </span><span class="lineCov">     109834 :   STATIC_ASSERT (wi::int_traits&lt;T&gt;::precision);</span>
<span class="lineNum">    3439 </span><span class="lineCov">   14237277 :   T result;</span>
<span class="lineNum">    3440 </span><span class="lineCov">      42391 :   result.set_len (shifted_mask (result.write_val (), start, width,</span>
<span class="lineNum">    3441 </span><span class="lineCov">   28523463 :                                 negate_p,</span>
<span class="lineNum">    3442 </span><span class="lineCov">   28526347 :                                 wi::int_traits &lt;T&gt;::precision));</span>
<span class="lineNum">    3443 </span><span class="lineCov">   17101990 :   return result;</span>
<span class="lineNum">    3444 </span><span class="lineCov">   31416951 : }</span>
<span class="lineNum">    3445 </span><span class="lineCov">     180848 : </span>
<span class="lineNum">    3446 </span><span class="lineCov">     121438 : /* Return an integer of type T in which bit BIT is set and all the</span>
<span class="lineNum">    3447 </span><span class="lineCov">     181434 :    others are clear.  */</span>
<span class="lineNum">    3448 </span><span class="lineCov">      93506 : template &lt;typename T&gt;</span>
<span class="lineNum">    3449 </span><span class="lineCov">   19064866 : inline T</span>
<span class="lineNum">    3450 </span><span class="lineCov">     184508 : wi::set_bit_in_zero (unsigned int bit)</span>
<span class="lineNum">    3451 </span><span class="lineCov">   45039075 : {</span>
<span class="lineNum">    3452 </span><span class="lineCov">   38040650 :   return shifted_mask &lt;T&gt; (bit, 1, false);</span>
<span class="lineNum">    3453 </span><span class="lineCov">   38037838 : }</span>
<span class="lineNum">    3454 </span><span class="lineCov">   38664308 : </span>
<span class="lineNum">    3455 </span><span class="lineCov">   14504363 : /* Accumulate a set of overflows into OVERFLOW.  */</span>
<span class="lineNum">    3456 </span><span class="lineCov">     112944 : </span>
<span class="lineNum">    3457 </span><span class="lineCov">  633503510 : static inline void</span>
<span class="lineNum">    3458 </span><span class="lineCov">    6546706 : wi::accumulate_overflow (wi::overflow_type &amp;overflow,</span>
<span class="lineNum">    3459 </span><span class="lineCov">     135053 :                          wi::overflow_type suboverflow)</span>
<span class="lineNum">    3460 </span><span class="lineCov">  613949850 : {</span>
<span class="lineNum">    3461 </span><span class="lineCov">   14251389 :   if (!suboverflow)</span>
<span class="lineNum">    3462 </span><span class="lineCov">  825394829 :     return;</span>
<span class="lineNum">    3463 </span><span class="lineCov">   28473577 :   if (!overflow)</span>
<span class="lineNum">    3464 </span><span class="lineCov"> 1679177193 :     overflow = suboverflow;</span>
<span class="lineNum">    3465 </span><span class="lineCov"> 1664931775 :   else if (overflow != suboverflow)</span>
<span class="lineNum">    3466 </span><span class="lineCov">  839620557 :     overflow = wi::OVF_UNKNOWN;</span>
<span class="lineNum">    3467 </span><span class="lineCov"> 1664961371 : }</span>
<span class="lineNum">    3468 </span><span class="lineCov">   28488920 : </span>
<span class="lineNum">    3469 </span><span class="lineCov">  839660801 : #endif /* WIDE_INT_H */</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.0</a></td></tr>
  </table>
  <br>
<h3>LCOV profile is generated on x86_64 machine using following configure options: configure --disable-bootstrap --enable-coverage=opt --enable-languages=c,c++,fortran,go,jit,lto --enable-host-shared. GCC test suite is run with the built compiler.</h3></body></html>
