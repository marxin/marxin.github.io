<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - gcc.info - gcc/dwarf2out.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">gcc</a> - dwarf2out.c<span style="font-size: 80%;"> (source / <a href="dwarf2out.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">gcc.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">11238</td>
            <td class="headerCovTableEntry">14180</td>
            <td class="headerCovTableEntryMed">79.3 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-09-22 10:58:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">469</td>
            <td class="headerCovTableEntry">564</td>
            <td class="headerCovTableEntryMed">83.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Output Dwarf2 format symbol table information from GCC.</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 1992-2018 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            :    Contributed by Gary Funck (gary@intrepid.com).
<span class="lineNum">       4 </span>            :    Derived from DWARF 1 implementation of Ron Guilmette (rfg@monkeys.com).
<span class="lineNum">       5 </span>            :    Extensively modified by Jason Merrill (jason@cygnus.com).
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : This file is part of GCC.
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : GCC is free software; you can redistribute it and/or modify it under
<span class="lineNum">      10 </span>            : the terms of the GNU General Public License as published by the Free
<span class="lineNum">      11 </span>            : Software Foundation; either version 3, or (at your option) any later
<span class="lineNum">      12 </span>            : version.
<span class="lineNum">      13 </span>            : 
<span class="lineNum">      14 </span>            : GCC is distributed in the hope that it will be useful, but WITHOUT ANY
<span class="lineNum">      15 </span>            : WARRANTY; without even the implied warranty of MERCHANTABILITY or
<span class="lineNum">      16 </span>            : FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
<span class="lineNum">      17 </span>            : for more details.
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : You should have received a copy of the GNU General Public License
<span class="lineNum">      20 </span>            : along with GCC; see the file COPYING3.  If not see
<span class="lineNum">      21 </span>            : &lt;http://www.gnu.org/licenses/&gt;.  */
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            : /* TODO: Emit .debug_line header even when there are no functions, since
<span class="lineNum">      24 </span>            :            the file numbers are used by .debug_info.  Alternately, leave
<span class="lineNum">      25 </span>            :            out locations for types and decls.
<span class="lineNum">      26 </span>            :          Avoid talking about ctors and op= for PODs.
<span class="lineNum">      27 </span>            :          Factor out common prologue sequences into multiple CIEs.  */
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            : /* The first part of this file deals with the DWARF 2 frame unwind
<span class="lineNum">      30 </span>            :    information, which is also used by the GCC efficient exception handling
<span class="lineNum">      31 </span>            :    mechanism.  The second part, controlled only by an #ifdef
<span class="lineNum">      32 </span>            :    DWARF2_DEBUGGING_INFO, deals with the other DWARF 2 debugging
<span class="lineNum">      33 </span>            :    information.  */
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : /* DWARF2 Abbreviation Glossary:
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            :    CFA = Canonical Frame Address
<span class="lineNum">      38 </span>            :            a fixed address on the stack which identifies a call frame.
<span class="lineNum">      39 </span>            :            We define it to be the value of SP just before the call insn.
<span class="lineNum">      40 </span>            :            The CFA register and offset, which may change during the course
<span class="lineNum">      41 </span>            :            of the function, are used to calculate its value at runtime.
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            :    CFI = Call Frame Instruction
<span class="lineNum">      44 </span>            :            an instruction for the DWARF2 abstract machine
<span class="lineNum">      45 </span>            : 
<span class="lineNum">      46 </span>            :    CIE = Common Information Entry
<span class="lineNum">      47 </span>            :            information describing information common to one or more FDEs
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            :    DIE = Debugging Information Entry
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            :    FDE = Frame Description Entry
<span class="lineNum">      52 </span>            :            information describing the stack call frame, in particular,
<span class="lineNum">      53 </span>            :            how to restore registers
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            :    DW_CFA_... = DWARF2 CFA call frame instruction
<span class="lineNum">      56 </span>            :    DW_TAG_... = DWARF2 DIE tag */
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            : #include &quot;config.h&quot;
<span class="lineNum">      59 </span>            : #include &quot;system.h&quot;
<span class="lineNum">      60 </span>            : #include &quot;coretypes.h&quot;
<span class="lineNum">      61 </span>            : #include &quot;target.h&quot;
<span class="lineNum">      62 </span>            : #include &quot;function.h&quot;
<span class="lineNum">      63 </span>            : #include &quot;rtl.h&quot;
<span class="lineNum">      64 </span>            : #include &quot;tree.h&quot;
<span class="lineNum">      65 </span>            : #include &quot;memmodel.h&quot;
<span class="lineNum">      66 </span>            : #include &quot;tm_p.h&quot;
<span class="lineNum">      67 </span>            : #include &quot;stringpool.h&quot;
<span class="lineNum">      68 </span>            : #include &quot;insn-config.h&quot;
<span class="lineNum">      69 </span>            : #include &quot;ira.h&quot;
<span class="lineNum">      70 </span>            : #include &quot;cgraph.h&quot;
<span class="lineNum">      71 </span>            : #include &quot;diagnostic.h&quot;
<span class="lineNum">      72 </span>            : #include &quot;fold-const.h&quot;
<span class="lineNum">      73 </span>            : #include &quot;stor-layout.h&quot;
<span class="lineNum">      74 </span>            : #include &quot;varasm.h&quot;
<span class="lineNum">      75 </span>            : #include &quot;version.h&quot;
<span class="lineNum">      76 </span>            : #include &quot;flags.h&quot;
<span class="lineNum">      77 </span>            : #include &quot;rtlhash.h&quot;
<span class="lineNum">      78 </span>            : #include &quot;reload.h&quot;
<span class="lineNum">      79 </span>            : #include &quot;output.h&quot;
<span class="lineNum">      80 </span>            : #include &quot;expr.h&quot;
<span class="lineNum">      81 </span>            : #include &quot;dwarf2out.h&quot;
<span class="lineNum">      82 </span>            : #include &quot;dwarf2asm.h&quot;
<span class="lineNum">      83 </span>            : #include &quot;toplev.h&quot;
<span class="lineNum">      84 </span>            : #include &quot;md5.h&quot;
<span class="lineNum">      85 </span>            : #include &quot;tree-pretty-print.h&quot;
<span class="lineNum">      86 </span>            : #include &quot;print-rtl.h&quot;
<span class="lineNum">      87 </span>            : #include &quot;debug.h&quot;
<span class="lineNum">      88 </span>            : #include &quot;common/common-target.h&quot;
<span class="lineNum">      89 </span>            : #include &quot;langhooks.h&quot;
<span class="lineNum">      90 </span>            : #include &quot;lra.h&quot;
<span class="lineNum">      91 </span>            : #include &quot;dumpfile.h&quot;
<span class="lineNum">      92 </span>            : #include &quot;opts.h&quot;
<span class="lineNum">      93 </span>            : #include &quot;tree-dfa.h&quot;
<span class="lineNum">      94 </span>            : #include &quot;gdb/gdb-index.h&quot;
<span class="lineNum">      95 </span>            : #include &quot;rtl-iter.h&quot;
<span class="lineNum">      96 </span>            : #include &quot;stringpool.h&quot;
<span class="lineNum">      97 </span>            : #include &quot;attribs.h&quot;
<span class="lineNum">      98 </span>            : #include &quot;file-prefix-map.h&quot; /* remap_debug_filename()  */
<span class="lineNum">      99 </span>            : 
<span class="lineNum">     100 </span>            : static void dwarf2out_source_line (unsigned int, unsigned int, const char *,
<span class="lineNum">     101 </span>            :                                    int, bool);
<span class="lineNum">     102 </span>            : static rtx_insn *last_var_location_insn;
<span class="lineNum">     103 </span>            : static rtx_insn *cached_next_real_insn;
<span class="lineNum">     104 </span>            : static void dwarf2out_decl (tree);
<span class="lineNum">     105 </span>            : static bool is_redundant_typedef (const_tree);
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span>            : #ifndef XCOFF_DEBUGGING_INFO
<span class="lineNum">     108 </span>            : #define XCOFF_DEBUGGING_INFO 0
<span class="lineNum">     109 </span>            : #endif
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span>            : #ifndef HAVE_XCOFF_DWARF_EXTRAS
<span class="lineNum">     112 </span>            : #define HAVE_XCOFF_DWARF_EXTRAS 0
<span class="lineNum">     113 </span>            : #endif
<span class="lineNum">     114 </span>            : 
<span class="lineNum">     115 </span>            : #ifdef VMS_DEBUGGING_INFO
<span class="lineNum">     116 </span>            : int vms_file_stats_name (const char *, long long *, long *, char *, int *);
<span class="lineNum">     117 </span>            : 
<span class="lineNum">     118 </span>            : /* Define this macro to be a nonzero value if the directory specifications
<span class="lineNum">     119 </span>            :     which are output in the debug info should end with a separator.  */
<span class="lineNum">     120 </span>            : #define DWARF2_DIR_SHOULD_END_WITH_SEPARATOR 1
<span class="lineNum">     121 </span>            : /* Define this macro to evaluate to a nonzero value if GCC should refrain
<span class="lineNum">     122 </span>            :    from generating indirect strings in DWARF2 debug information, for instance
<span class="lineNum">     123 </span>            :    if your target is stuck with an old version of GDB that is unable to
<span class="lineNum">     124 </span>            :    process them properly or uses VMS Debug.  */
<span class="lineNum">     125 </span>            : #define DWARF2_INDIRECT_STRING_SUPPORT_MISSING_ON_TARGET 1
<span class="lineNum">     126 </span>            : #else
<span class="lineNum">     127 </span>            : #define DWARF2_DIR_SHOULD_END_WITH_SEPARATOR 0
<span class="lineNum">     128 </span>            : #define DWARF2_INDIRECT_STRING_SUPPORT_MISSING_ON_TARGET 0
<span class="lineNum">     129 </span>            : #endif
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span>            : /* ??? Poison these here until it can be done generically.  They've been
<span class="lineNum">     132 </span>            :    totally replaced in this file; make sure it stays that way.  */
<span class="lineNum">     133 </span>            : #undef DWARF2_UNWIND_INFO
<span class="lineNum">     134 </span>            : #undef DWARF2_FRAME_INFO
<span class="lineNum">     135 </span>            : #if (GCC_VERSION &gt;= 3000)
<span class="lineNum">     136 </span>            :  #pragma GCC poison DWARF2_UNWIND_INFO DWARF2_FRAME_INFO
<span class="lineNum">     137 </span>            : #endif
<span class="lineNum">     138 </span>            : 
<span class="lineNum">     139 </span>            : /* The size of the target's pointer type.  */
<span class="lineNum">     140 </span>            : #ifndef PTR_SIZE
<span class="lineNum">     141 </span>            : #define PTR_SIZE (POINTER_SIZE / BITS_PER_UNIT)
<span class="lineNum">     142 </span>            : #endif
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span>            : /* Array of RTXes referenced by the debugging information, which therefore
<span class="lineNum">     145 </span>            :    must be kept around forever.  */
<span class="lineNum">     146 </span>            : static GTY(()) vec&lt;rtx, va_gc&gt; *used_rtx_array;
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span>            : /* A pointer to the base of a list of incomplete types which might be
<span class="lineNum">     149 </span>            :    completed at some later time.  incomplete_types_list needs to be a
<span class="lineNum">     150 </span>            :    vec&lt;tree, va_gc&gt; *because we want to tell the garbage collector about
<span class="lineNum">     151 </span>            :    it.  */
<span class="lineNum">     152 </span>            : static GTY(()) vec&lt;tree, va_gc&gt; *incomplete_types;
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span>            : /* Pointers to various DWARF2 sections.  */
<span class="lineNum">     155 </span>            : static GTY(()) section *debug_info_section;
<span class="lineNum">     156 </span>            : static GTY(()) section *debug_skeleton_info_section;
<span class="lineNum">     157 </span>            : static GTY(()) section *debug_abbrev_section;
<span class="lineNum">     158 </span>            : static GTY(()) section *debug_skeleton_abbrev_section;
<span class="lineNum">     159 </span>            : static GTY(()) section *debug_aranges_section;
<span class="lineNum">     160 </span>            : static GTY(()) section *debug_addr_section;
<span class="lineNum">     161 </span>            : static GTY(()) section *debug_macinfo_section;
<span class="lineNum">     162 </span>            : static const char *debug_macinfo_section_name;
<span class="lineNum">     163 </span>            : static unsigned macinfo_label_base = 1;
<span class="lineNum">     164 </span>            : static GTY(()) section *debug_line_section;
<span class="lineNum">     165 </span>            : static GTY(()) section *debug_skeleton_line_section;
<span class="lineNum">     166 </span>            : static GTY(()) section *debug_loc_section;
<span class="lineNum">     167 </span>            : static GTY(()) section *debug_pubnames_section;
<span class="lineNum">     168 </span>            : static GTY(()) section *debug_pubtypes_section;
<span class="lineNum">     169 </span>            : static GTY(()) section *debug_str_section;
<span class="lineNum">     170 </span>            : static GTY(()) section *debug_line_str_section;
<span class="lineNum">     171 </span>            : static GTY(()) section *debug_str_dwo_section;
<span class="lineNum">     172 </span>            : static GTY(()) section *debug_str_offsets_section;
<span class="lineNum">     173 </span>            : static GTY(()) section *debug_ranges_section;
<span class="lineNum">     174 </span>            : static GTY(()) section *debug_frame_section;
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span>            : /* Maximum size (in bytes) of an artificially generated label.  */
<span class="lineNum">     177 </span>            : #define MAX_ARTIFICIAL_LABEL_BYTES      40
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span>            : /* According to the (draft) DWARF 3 specification, the initial length
<span class="lineNum">     180 </span>            :    should either be 4 or 12 bytes.  When it's 12 bytes, the first 4
<span class="lineNum">     181 </span>            :    bytes are 0xffffffff, followed by the length stored in the next 8
<span class="lineNum">     182 </span>            :    bytes.
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span>            :    However, the SGI/MIPS ABI uses an initial length which is equal to
<span class="lineNum">     185 </span>            :    DWARF_OFFSET_SIZE.  It is defined (elsewhere) accordingly.  */
<span class="lineNum">     186 </span>            : 
<span class="lineNum">     187 </span>            : #ifndef DWARF_INITIAL_LENGTH_SIZE
<span class="lineNum">     188 </span>            : #define DWARF_INITIAL_LENGTH_SIZE (DWARF_OFFSET_SIZE == 4 ? 4 : 12)
<span class="lineNum">     189 </span>            : #endif
<span class="lineNum">     190 </span>            : 
<span class="lineNum">     191 </span>            : #ifndef DWARF_INITIAL_LENGTH_SIZE_STR
<span class="lineNum">     192 </span>            : #define DWARF_INITIAL_LENGTH_SIZE_STR (DWARF_OFFSET_SIZE == 4 ? &quot;-4&quot; : &quot;-12&quot;)
<span class="lineNum">     193 </span>            : #endif
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span>            : /* Round SIZE up to the nearest BOUNDARY.  */
<span class="lineNum">     196 </span>            : #define DWARF_ROUND(SIZE,BOUNDARY) \
<span class="lineNum">     197 </span>            :   ((((SIZE) + (BOUNDARY) - 1) / (BOUNDARY)) * (BOUNDARY))
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span>            : /* CIE identifier.  */
<span class="lineNum">     200 </span>            : #if HOST_BITS_PER_WIDE_INT &gt;= 64
<span class="lineNum">     201 </span>            : #define DWARF_CIE_ID \
<span class="lineNum">     202 </span>            :   (unsigned HOST_WIDE_INT) (DWARF_OFFSET_SIZE == 4 ? DW_CIE_ID : DW64_CIE_ID)
<span class="lineNum">     203 </span>            : #else
<span class="lineNum">     204 </span>            : #define DWARF_CIE_ID DW_CIE_ID
<span class="lineNum">     205 </span>            : #endif
<span class="lineNum">     206 </span>            : 
<span class="lineNum">     207 </span>            : 
<span class="lineNum">     208 </span>            : /* A vector for a table that contains frame description
<span class="lineNum">     209 </span>            :    information for each routine.  */
<span class="lineNum">     210 </span>            : #define NOT_INDEXED (-1U)
<span class="lineNum">     211 </span>            : #define NO_INDEX_ASSIGNED (-2U)
<span class="lineNum">     212 </span>            : 
<span class="lineNum">     213 </span>            : static GTY(()) vec&lt;dw_fde_ref, va_gc&gt; *fde_vec;
<span class="lineNum">     214 </span>            : 
<span class="lineNum">     215 </span>            : struct GTY((for_user)) indirect_string_node {
<span class="lineNum">     216 </span>            :   const char *str;
<span class="lineNum">     217 </span>            :   unsigned int refcount;
<span class="lineNum">     218 </span>            :   enum dwarf_form form;
<span class="lineNum">     219 </span>            :   char *label;
<span class="lineNum">     220 </span>            :   unsigned int index;
<span class="lineNum">     221 </span>            : };
<span class="lineNum">     222 </span>            : 
<span class="lineNum">     223 </span>            : struct indirect_string_hasher : ggc_ptr_hash&lt;indirect_string_node&gt;
<span class="lineNum">     224 </span>            : {
<span class="lineNum">     225 </span>            :   typedef const char *compare_type;
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span>            :   static hashval_t hash (indirect_string_node *);
<span class="lineNum">     228 </span>            :   static bool equal (indirect_string_node *, const char *);
<span class="lineNum">     229 </span>            : };
<span class="lineNum">     230 </span>            : 
<span class="lineNum">     231 </span>            : static GTY (()) hash_table&lt;indirect_string_hasher&gt; *debug_str_hash;
<span class="lineNum">     232 </span>            : 
<span class="lineNum">     233 </span>            : static GTY (()) hash_table&lt;indirect_string_hasher&gt; *debug_line_str_hash;
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span>            : /* With split_debug_info, both the comp_dir and dwo_name go in the
<span class="lineNum">     236 </span>            :    main object file, rather than the dwo, similar to the force_direct
<span class="lineNum">     237 </span>            :    parameter elsewhere but with additional complications:
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span>            :    1) The string is needed in both the main object file and the dwo.
<span class="lineNum">     240 </span>            :    That is, the comp_dir and dwo_name will appear in both places.
<span class="lineNum">     241 </span>            : 
<span class="lineNum">     242 </span>            :    2) Strings can use four forms: DW_FORM_string, DW_FORM_strp,
<span class="lineNum">     243 </span>            :    DW_FORM_line_strp or DW_FORM_strx/GNU_str_index.
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span>            :    3) GCC chooses the form to use late, depending on the size and
<span class="lineNum">     246 </span>            :    reference count.
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span>            :    Rather than forcing the all debug string handling functions and
<span class="lineNum">     249 </span>            :    callers to deal with these complications, simply use a separate,
<span class="lineNum">     250 </span>            :    special-cased string table for any attribute that should go in the
<span class="lineNum">     251 </span>            :    main object file.  This limits the complexity to just the places
<span class="lineNum">     252 </span>            :    that need it.  */
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span>            : static GTY (()) hash_table&lt;indirect_string_hasher&gt; *skeleton_debug_str_hash;
<span class="lineNum">     255 </span>            : 
<span class="lineNum">     256 </span>            : static GTY(()) int dw2_string_counter;
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span>            : /* True if the compilation unit places functions in more than one section.  */
<span class="lineNum">     259 </span>            : static GTY(()) bool have_multiple_function_sections = false;
<span class="lineNum">     260 </span>            : 
<span class="lineNum">     261 </span>            : /* Whether the default text and cold text sections have been used at all.  */
<span class="lineNum">     262 </span>            : static GTY(()) bool text_section_used = false;
<span class="lineNum">     263 </span>            : static GTY(()) bool cold_text_section_used = false;
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span>            : /* The default cold text section.  */
<span class="lineNum">     266 </span>            : static GTY(()) section *cold_text_section;
<span class="lineNum">     267 </span>            : 
<span class="lineNum">     268 </span>            : /* The DIE for C++14 'auto' in a function return type.  */
<span class="lineNum">     269 </span>            : static GTY(()) dw_die_ref auto_die;
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span>            : /* The DIE for C++14 'decltype(auto)' in a function return type.  */
<span class="lineNum">     272 </span>            : static GTY(()) dw_die_ref decltype_auto_die;
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span>            : /* Forward declarations for functions defined in this file.  */
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span>            : static void output_call_frame_info (int);
<span class="lineNum">     277 </span>            : static void dwarf2out_note_section_used (void);
<span class="lineNum">     278 </span>            : 
<span class="lineNum">     279 </span>            : /* Personality decl of current unit.  Used only when assembler does not support
<span class="lineNum">     280 </span>            :    personality CFI.  */
<span class="lineNum">     281 </span>            : static GTY(()) rtx current_unit_personality;
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span>            : /* Whether an eh_frame section is required.  */
<span class="lineNum">     284 </span>            : static GTY(()) bool do_eh_frame = false;
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span>            : /* .debug_rnglists next index.  */
<span class="lineNum">     287 </span>            : static unsigned int rnglist_idx;
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span>            : /* Data and reference forms for relocatable data.  */
<span class="lineNum">     290 </span>            : #define DW_FORM_data (DWARF_OFFSET_SIZE == 8 ? DW_FORM_data8 : DW_FORM_data4)
<span class="lineNum">     291 </span>            : #define DW_FORM_ref (DWARF_OFFSET_SIZE == 8 ? DW_FORM_ref8 : DW_FORM_ref4)
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span>            : #ifndef DEBUG_FRAME_SECTION
<span class="lineNum">     294 </span>            : #define DEBUG_FRAME_SECTION     &quot;.debug_frame&quot;
<span class="lineNum">     295 </span>            : #endif
<span class="lineNum">     296 </span>            : 
<span class="lineNum">     297 </span>            : #ifndef FUNC_BEGIN_LABEL
<span class="lineNum">     298 </span>            : #define FUNC_BEGIN_LABEL        &quot;LFB&quot;
<span class="lineNum">     299 </span>            : #endif
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span>            : #ifndef FUNC_SECOND_SECT_LABEL
<span class="lineNum">     302 </span>            : #define FUNC_SECOND_SECT_LABEL  &quot;LFSB&quot;
<span class="lineNum">     303 </span>            : #endif
<span class="lineNum">     304 </span>            : 
<span class="lineNum">     305 </span>            : #ifndef FUNC_END_LABEL
<span class="lineNum">     306 </span>            : #define FUNC_END_LABEL          &quot;LFE&quot;
<span class="lineNum">     307 </span>            : #endif
<span class="lineNum">     308 </span>            : 
<span class="lineNum">     309 </span>            : #ifndef PROLOGUE_END_LABEL
<span class="lineNum">     310 </span>            : #define PROLOGUE_END_LABEL      &quot;LPE&quot;
<span class="lineNum">     311 </span>            : #endif
<span class="lineNum">     312 </span>            : 
<span class="lineNum">     313 </span>            : #ifndef EPILOGUE_BEGIN_LABEL
<span class="lineNum">     314 </span>            : #define EPILOGUE_BEGIN_LABEL    &quot;LEB&quot;
<span class="lineNum">     315 </span>            : #endif
<span class="lineNum">     316 </span>            : 
<span class="lineNum">     317 </span>            : #ifndef FRAME_BEGIN_LABEL
<span class="lineNum">     318 </span>            : #define FRAME_BEGIN_LABEL       &quot;Lframe&quot;
<span class="lineNum">     319 </span>            : #endif
<span class="lineNum">     320 </span>            : #define CIE_AFTER_SIZE_LABEL    &quot;LSCIE&quot;
<span class="lineNum">     321 </span>            : #define CIE_END_LABEL           &quot;LECIE&quot;
<span class="lineNum">     322 </span>            : #define FDE_LABEL               &quot;LSFDE&quot;
<span class="lineNum">     323 </span>            : #define FDE_AFTER_SIZE_LABEL    &quot;LASFDE&quot;
<span class="lineNum">     324 </span>            : #define FDE_END_LABEL           &quot;LEFDE&quot;
<span class="lineNum">     325 </span>            : #define LINE_NUMBER_BEGIN_LABEL &quot;LSLT&quot;
<span class="lineNum">     326 </span>            : #define LINE_NUMBER_END_LABEL   &quot;LELT&quot;
<span class="lineNum">     327 </span>            : #define LN_PROLOG_AS_LABEL      &quot;LASLTP&quot;
<span class="lineNum">     328 </span>            : #define LN_PROLOG_END_LABEL     &quot;LELTP&quot;
<span class="lineNum">     329 </span>            : #define DIE_LABEL_PREFIX        &quot;DW&quot;
<span class="lineNum">     330 </span>            : 
<span class="lineNum">     331 </span>            : /* Match the base name of a file to the base name of a compilation unit. */
<a name="332"><span class="lineNum">     332 </span>            : </a>
<span class="lineNum">     333 </span>            : static int
<span class="lineNum">     334 </span><span class="lineCov">        620 : matches_main_base (const char *path)</span>
<span class="lineNum">     335 </span>            : {
<span class="lineNum">     336 </span>            :   /* Cache the last query. */
<span class="lineNum">     337 </span><span class="lineCov">        620 :   static const char *last_path = NULL;</span>
<span class="lineNum">     338 </span><span class="lineCov">        620 :   static int last_match = 0;</span>
<span class="lineNum">     339 </span><span class="lineCov">        620 :   if (path != last_path)</span>
<span class="lineNum">     340 </span>            :     {
<span class="lineNum">     341 </span><span class="lineCov">        113 :       const char *base;</span>
<span class="lineNum">     342 </span><span class="lineCov">        113 :       int length = base_of_path (path, &amp;base);</span>
<span class="lineNum">     343 </span><span class="lineCov">        113 :       last_path = path;</span>
<span class="lineNum">     344 </span><span class="lineCov">        226 :       last_match = (length == main_input_baselength</span>
<span class="lineNum">     345 </span><span class="lineCov">        180 :                     &amp;&amp; memcmp (base, main_input_basename, length) == 0);</span>
<span class="lineNum">     346 </span>            :     }
<span class="lineNum">     347 </span><span class="lineCov">        620 :   return last_match;</span>
<span class="lineNum">     348 </span>            : }
<span class="lineNum">     349 </span>            : 
<span class="lineNum">     350 </span>            : #ifdef DEBUG_DEBUG_STRUCT
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span>            : static int
<span class="lineNum">     353 </span>            : dump_struct_debug (tree type, enum debug_info_usage usage,
<span class="lineNum">     354 </span>            :                    enum debug_struct_file criterion, int generic,
<span class="lineNum">     355 </span>            :                    int matches, int result)
<span class="lineNum">     356 </span>            : {
<span class="lineNum">     357 </span>            :   /* Find the type name. */
<span class="lineNum">     358 </span>            :   tree type_decl = TYPE_STUB_DECL (type);
<span class="lineNum">     359 </span>            :   tree t = type_decl;
<span class="lineNum">     360 </span>            :   const char *name = 0;
<span class="lineNum">     361 </span>            :   if (TREE_CODE (t) == TYPE_DECL)
<span class="lineNum">     362 </span>            :     t = DECL_NAME (t);
<span class="lineNum">     363 </span>            :   if (t)
<span class="lineNum">     364 </span>            :     name = IDENTIFIER_POINTER (t);
<span class="lineNum">     365 </span>            : 
<span class="lineNum">     366 </span>            :   fprintf (stderr, &quot;       struct %d %s %s %s %s %d %p %s\n&quot;,
<span class="lineNum">     367 </span>            :            criterion,
<span class="lineNum">     368 </span>            :            DECL_IN_SYSTEM_HEADER (type_decl) ? &quot;sys&quot; : &quot;usr&quot;,
<span class="lineNum">     369 </span>            :            matches ? &quot;bas&quot; : &quot;hdr&quot;,
<span class="lineNum">     370 </span>            :            generic ? &quot;gen&quot; : &quot;ord&quot;,
<span class="lineNum">     371 </span>            :            usage == DINFO_USAGE_DFN ? &quot;;&quot; :
<span class="lineNum">     372 </span>            :              usage == DINFO_USAGE_DIR_USE ? &quot;.&quot; : &quot;*&quot;,
<span class="lineNum">     373 </span>            :            result,
<span class="lineNum">     374 </span>            :            (void*) type_decl, name);
<span class="lineNum">     375 </span>            :   return result;
<span class="lineNum">     376 </span>            : }
<span class="lineNum">     377 </span>            : #define DUMP_GSTRUCT(type, usage, criterion, generic, matches, result) \
<span class="lineNum">     378 </span>            :   dump_struct_debug (type, usage, criterion, generic, matches, result)
<span class="lineNum">     379 </span>            : 
<span class="lineNum">     380 </span>            : #else
<span class="lineNum">     381 </span>            : 
<span class="lineNum">     382 </span>            : #define DUMP_GSTRUCT(type, usage, criterion, generic, matches, result) \
<span class="lineNum">     383 </span>            :   (result)
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span>            : #endif
<span class="lineNum">     386 </span>            : 
<span class="lineNum">     387 </span>            : /* Get the number of HOST_WIDE_INTs needed to represent the precision
<span class="lineNum">     388 </span>            :    of the number.  Some constants have a large uniform precision, so
<span class="lineNum">     389 </span>            :    we get the precision needed for the actual value of the number.  */
<a name="390"><span class="lineNum">     390 </span>            : </a>
<span class="lineNum">     391 </span>            : static unsigned int
<span class="lineNum">     392 </span><span class="lineNoCov">          0 : get_full_len (const wide_int &amp;op)</span>
<span class="lineNum">     393 </span>            : {
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :   int prec = wi::min_precision (op, UNSIGNED);</span>
<span class="lineNum">     395 </span><span class="lineCov">        513 :   return ((prec + HOST_BITS_PER_WIDE_INT - 1)</span>
<span class="lineNum">     396 </span><span class="lineCov">        513 :           / HOST_BITS_PER_WIDE_INT);</span>
<span class="lineNum">     397 </span>            : }
<a name="398"><span class="lineNum">     398 </span>            : </a>
<span class="lineNum">     399 </span>            : static bool
<span class="lineNum">     400 </span><span class="lineCov">   42940344 : should_emit_struct_debug (tree type, enum debug_info_usage usage)</span>
<span class="lineNum">     401 </span>            : {
<span class="lineNum">     402 </span><span class="lineCov">   42940344 :   enum debug_struct_file criterion;</span>
<span class="lineNum">     403 </span><span class="lineCov">   42940344 :   tree type_decl;</span>
<span class="lineNum">     404 </span><span class="lineCov">   42940344 :   bool generic = lang_hooks.types.generic_p (type);</span>
<span class="lineNum">     405 </span>            : 
<span class="lineNum">     406 </span><span class="lineCov">   42940344 :   if (generic)</span>
<span class="lineNum">     407 </span><span class="lineCov">   38242523 :     criterion = debug_struct_generic[usage];</span>
<span class="lineNum">     408 </span>            :   else
<span class="lineNum">     409 </span><span class="lineCov">    4697821 :     criterion = debug_struct_ordinary[usage];</span>
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span><span class="lineCov">   42940344 :   if (criterion == DINFO_STRUCT_FILE_NONE)</span>
<span class="lineNum">     412 </span>            :     return DUMP_GSTRUCT (type, usage, criterion, generic, false, false);
<span class="lineNum">     413 </span><span class="lineCov">   42940133 :   if (criterion == DINFO_STRUCT_FILE_ANY)</span>
<span class="lineNum">     414 </span>            :     return DUMP_GSTRUCT (type, usage, criterion, generic, false, true);
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span><span class="lineCov">        640 :   type_decl = TYPE_STUB_DECL (TYPE_MAIN_VARIANT (type));</span>
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span><span class="lineCov">        640 :   if (type_decl != NULL)</span>
<span class="lineNum">     419 </span>            :     {
<span class="lineNum">     420 </span><span class="lineCov">        636 :      if (criterion == DINFO_STRUCT_FILE_SYS &amp;&amp; DECL_IN_SYSTEM_HEADER (type_decl))</span>
<span class="lineNum">     421 </span>            :         return DUMP_GSTRUCT (type, usage, criterion, generic, false, true);
<span class="lineNum">     422 </span>            : 
<span class="lineNum">     423 </span><span class="lineCov">        620 :       if (matches_main_base (DECL_SOURCE_FILE (type_decl)))</span>
<span class="lineNum">     424 </span><span class="lineCov">        136 :         return DUMP_GSTRUCT (type, usage, criterion, generic, true, true);</span>
<span class="lineNum">     425 </span>            :     }
<span class="lineNum">     426 </span>            : 
<span class="lineNum">     427 </span>            :   return DUMP_GSTRUCT (type, usage, criterion, generic, false, false);
<span class="lineNum">     428 </span>            : }
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span>            : /* Switch [BACK] to eh_frame_section.  If we don't have an eh_frame_section,
<span class="lineNum">     431 </span>            :    switch to the data section instead, and write out a synthetic start label
<span class="lineNum">     432 </span>            :    for collect2 the first time around.  */
<a name="433"><span class="lineNum">     433 </span>            : </a>
<span class="lineNum">     434 </span>            : static void
<span class="lineNum">     435 </span><span class="lineCov">         29 : switch_to_eh_frame_section (bool back ATTRIBUTE_UNUSED)</span>
<span class="lineNum">     436 </span>            : {
<span class="lineNum">     437 </span><span class="lineCov">         29 :   if (eh_frame_section == 0)</span>
<span class="lineNum">     438 </span>            :     {
<span class="lineNum">     439 </span><span class="lineCov">         29 :       int flags;</span>
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span><span class="lineCov">         29 :       if (EH_TABLES_CAN_BE_READ_ONLY)</span>
<span class="lineNum">     442 </span>            :         {
<span class="lineNum">     443 </span><span class="lineCov">         29 :           int fde_encoding;</span>
<span class="lineNum">     444 </span><span class="lineCov">         29 :           int per_encoding;</span>
<span class="lineNum">     445 </span><span class="lineCov">         29 :           int lsda_encoding;</span>
<span class="lineNum">     446 </span>            : 
<span class="lineNum">     447 </span><span class="lineCov">         29 :           fde_encoding = ASM_PREFERRED_EH_DATA_FORMAT (/*code=*/1,</span>
<span class="lineNum">     448 </span>            :                                                        /*global=*/0);
<span class="lineNum">     449 </span><span class="lineCov">         29 :           per_encoding = ASM_PREFERRED_EH_DATA_FORMAT (/*code=*/2,</span>
<span class="lineNum">     450 </span>            :                                                        /*global=*/1);
<span class="lineNum">     451 </span><span class="lineCov">         29 :           lsda_encoding = ASM_PREFERRED_EH_DATA_FORMAT (/*code=*/0,</span>
<span class="lineNum">     452 </span>            :                                                         /*global=*/0);
<span class="lineNum">     453 </span><span class="lineCov">         58 :           flags = ((! flag_pic</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :                     || ((fde_encoding &amp; 0x70) != DW_EH_PE_absptr</span>
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :                         &amp;&amp; (fde_encoding &amp; 0x70) != DW_EH_PE_aligned</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :                         &amp;&amp; (per_encoding &amp; 0x70) != DW_EH_PE_absptr</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :                         &amp;&amp; (per_encoding &amp; 0x70) != DW_EH_PE_aligned</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :                         &amp;&amp; (lsda_encoding &amp; 0x70) != DW_EH_PE_absptr</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :                         &amp;&amp; (lsda_encoding &amp; 0x70) != DW_EH_PE_aligned))</span>
<span class="lineNum">     460 </span><span class="lineCov">         29 :                    ? 0 : SECTION_WRITE);</span>
<span class="lineNum">     461 </span>            :         }
<span class="lineNum">     462 </span>            :       else
<span class="lineNum">     463 </span>            :         flags = SECTION_WRITE;
<span class="lineNum">     464 </span>            : 
<span class="lineNum">     465 </span>            : #ifdef EH_FRAME_SECTION_NAME
<span class="lineNum">     466 </span><span class="lineCov">         29 :       eh_frame_section = get_section (EH_FRAME_SECTION_NAME, flags, NULL);</span>
<span class="lineNum">     467 </span>            : #else
<span class="lineNum">     468 </span>            :       eh_frame_section = ((flags == SECTION_WRITE)
<span class="lineNum">     469 </span>            :                           ? data_section : readonly_data_section);
<span class="lineNum">     470 </span>            : #endif /* EH_FRAME_SECTION_NAME */
<span class="lineNum">     471 </span>            :     }
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span><span class="lineCov">         29 :   switch_to_section (eh_frame_section);</span>
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span>            : #ifdef EH_FRAME_THROUGH_COLLECT2
<span class="lineNum">     476 </span>            :   /* We have no special eh_frame section.  Emit special labels to guide
<span class="lineNum">     477 </span>            :      collect2.  */
<span class="lineNum">     478 </span>            :   if (!back)
<span class="lineNum">     479 </span>            :     {
<span class="lineNum">     480 </span>            :       tree label = get_file_function_name (&quot;F&quot;);
<span class="lineNum">     481 </span>            :       ASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (PTR_SIZE));
<span class="lineNum">     482 </span>            :       targetm.asm_out.globalize_label (asm_out_file,
<span class="lineNum">     483 </span>            :                                         IDENTIFIER_POINTER (label));
<span class="lineNum">     484 </span>            :       ASM_OUTPUT_LABEL (asm_out_file, IDENTIFIER_POINTER (label));
<span class="lineNum">     485 </span>            :     }
<span class="lineNum">     486 </span>            : #endif
<span class="lineNum">     487 </span><span class="lineCov">         29 : }</span>
<span class="lineNum">     488 </span>            : 
<span class="lineNum">     489 </span>            : /* Switch [BACK] to the eh or debug frame table section, depending on
<span class="lineNum">     490 </span>            :    FOR_EH.  */
<a name="491"><span class="lineNum">     491 </span>            : </a>
<span class="lineNum">     492 </span>            : static void
<span class="lineNum">     493 </span><span class="lineCov">         38 : switch_to_frame_table_section (int for_eh, bool back)</span>
<span class="lineNum">     494 </span>            : {
<span class="lineNum">     495 </span><span class="lineCov">         38 :   if (for_eh)</span>
<span class="lineNum">     496 </span><span class="lineCov">         29 :     switch_to_eh_frame_section (back);</span>
<span class="lineNum">     497 </span>            :   else
<span class="lineNum">     498 </span>            :     {
<span class="lineNum">     499 </span><span class="lineCov">          9 :       if (!debug_frame_section)</span>
<span class="lineNum">     500 </span><span class="lineCov">          9 :         debug_frame_section = get_section (DEBUG_FRAME_SECTION,</span>
<span class="lineNum">     501 </span>            :                                            SECTION_DEBUG, NULL);
<span class="lineNum">     502 </span><span class="lineCov">          9 :       switch_to_section (debug_frame_section);</span>
<span class="lineNum">     503 </span>            :     }
<span class="lineNum">     504 </span><span class="lineCov">         38 : }</span>
<span class="lineNum">     505 </span>            : 
<span class="lineNum">     506 </span>            : /* Describe for the GTY machinery what parts of dw_cfi_oprnd1 are used.  */
<a name="507"><span class="lineNum">     507 </span>            : </a>
<span class="lineNum">     508 </span>            : enum dw_cfi_oprnd_type
<span class="lineNum">     509 </span><span class="lineCov">   28377090 : dw_cfi_oprnd1_desc (enum dwarf_call_frame_info cfi)</span>
<span class="lineNum">     510 </span>            : {
<span class="lineNum">     511 </span><span class="lineCov">   28377090 :   switch (cfi)</span>
<span class="lineNum">     512 </span>            :     {
<span class="lineNum">     513 </span>            :     case DW_CFA_nop:
<span class="lineNum">     514 </span>            :     case DW_CFA_GNU_window_save:
<span class="lineNum">     515 </span>            :     case DW_CFA_remember_state:
<span class="lineNum">     516 </span>            :     case DW_CFA_restore_state:
<span class="lineNum">     517 </span>            :       return dw_cfi_oprnd_unused;
<span class="lineNum">     518 </span>            : 
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :     case DW_CFA_set_loc:</span>
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :     case DW_CFA_advance_loc1:</span>
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :     case DW_CFA_advance_loc2:</span>
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :     case DW_CFA_advance_loc4:</span>
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :     case DW_CFA_MIPS_advance_loc8:</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :       return dw_cfi_oprnd_addr;</span>
<span class="lineNum">     525 </span>            : 
<span class="lineNum">     526 </span><span class="lineCov">    8693273 :     case DW_CFA_offset:</span>
<span class="lineNum">     527 </span><span class="lineCov">    8693273 :     case DW_CFA_offset_extended:</span>
<span class="lineNum">     528 </span><span class="lineCov">    8693273 :     case DW_CFA_def_cfa:</span>
<span class="lineNum">     529 </span><span class="lineCov">    8693273 :     case DW_CFA_offset_extended_sf:</span>
<span class="lineNum">     530 </span><span class="lineCov">    8693273 :     case DW_CFA_def_cfa_sf:</span>
<span class="lineNum">     531 </span><span class="lineCov">    8693273 :     case DW_CFA_restore:</span>
<span class="lineNum">     532 </span><span class="lineCov">    8693273 :     case DW_CFA_restore_extended:</span>
<span class="lineNum">     533 </span><span class="lineCov">    8693273 :     case DW_CFA_undefined:</span>
<span class="lineNum">     534 </span><span class="lineCov">    8693273 :     case DW_CFA_same_value:</span>
<span class="lineNum">     535 </span><span class="lineCov">    8693273 :     case DW_CFA_def_cfa_register:</span>
<span class="lineNum">     536 </span><span class="lineCov">    8693273 :     case DW_CFA_register:</span>
<span class="lineNum">     537 </span><span class="lineCov">    8693273 :     case DW_CFA_expression:</span>
<span class="lineNum">     538 </span><span class="lineCov">    8693273 :     case DW_CFA_val_expression:</span>
<span class="lineNum">     539 </span><span class="lineCov">    8693273 :       return dw_cfi_oprnd_reg_num;</span>
<span class="lineNum">     540 </span>            : 
<span class="lineNum">     541 </span><span class="lineCov">   18528059 :     case DW_CFA_def_cfa_offset:</span>
<span class="lineNum">     542 </span><span class="lineCov">   18528059 :     case DW_CFA_GNU_args_size:</span>
<span class="lineNum">     543 </span><span class="lineCov">   18528059 :     case DW_CFA_def_cfa_offset_sf:</span>
<span class="lineNum">     544 </span><span class="lineCov">   18528059 :       return dw_cfi_oprnd_offset;</span>
<span class="lineNum">     545 </span>            : 
<span class="lineNum">     546 </span><span class="lineCov">      15106 :     case DW_CFA_def_cfa_expression:</span>
<span class="lineNum">     547 </span><span class="lineCov">      15106 :       return dw_cfi_oprnd_loc;</span>
<span class="lineNum">     548 </span>            : 
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">     551 </span>            :     }
<span class="lineNum">     552 </span>            : }
<span class="lineNum">     553 </span>            : 
<span class="lineNum">     554 </span>            : /* Describe for the GTY machinery what parts of dw_cfi_oprnd2 are used.  */
<a name="555"><span class="lineNum">     555 </span>            : </a>
<span class="lineNum">     556 </span>            : enum dw_cfi_oprnd_type
<span class="lineNum">     557 </span><span class="lineCov">   28377090 : dw_cfi_oprnd2_desc (enum dwarf_call_frame_info cfi)</span>
<span class="lineNum">     558 </span>            : {
<span class="lineNum">     559 </span><span class="lineCov">   28377090 :   switch (cfi)</span>
<span class="lineNum">     560 </span>            :     {
<span class="lineNum">     561 </span>            :     case DW_CFA_def_cfa:
<span class="lineNum">     562 </span>            :     case DW_CFA_def_cfa_sf:
<span class="lineNum">     563 </span>            :     case DW_CFA_offset:
<span class="lineNum">     564 </span>            :     case DW_CFA_offset_extended_sf:
<span class="lineNum">     565 </span>            :     case DW_CFA_offset_extended:
<span class="lineNum">     566 </span>            :       return dw_cfi_oprnd_offset;
<span class="lineNum">     567 </span>            : 
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :     case DW_CFA_register:</span>
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :       return dw_cfi_oprnd_reg_num;</span>
<span class="lineNum">     570 </span>            : 
<span class="lineNum">     571 </span><span class="lineCov">     212230 :     case DW_CFA_expression:</span>
<span class="lineNum">     572 </span><span class="lineCov">     212230 :     case DW_CFA_val_expression:</span>
<span class="lineNum">     573 </span><span class="lineCov">     212230 :       return dw_cfi_oprnd_loc;</span>
<span class="lineNum">     574 </span>            : 
<span class="lineNum">     575 </span><span class="lineCov">      15106 :     case DW_CFA_def_cfa_expression:</span>
<span class="lineNum">     576 </span><span class="lineCov">      15106 :       return dw_cfi_oprnd_cfa_loc;</span>
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span><span class="lineCov">   23830007 :     default:</span>
<span class="lineNum">     579 </span><span class="lineCov">   23830007 :       return dw_cfi_oprnd_unused;</span>
<span class="lineNum">     580 </span>            :     }
<span class="lineNum">     581 </span>            : }
<span class="lineNum">     582 </span>            : 
<span class="lineNum">     583 </span>            : /* Output one FDE.  */
<a name="584"><span class="lineNum">     584 </span>            : </a>
<span class="lineNum">     585 </span>            : static void
<span class="lineNum">     586 </span><span class="lineCov">        104 : output_fde (dw_fde_ref fde, bool for_eh, bool second,</span>
<span class="lineNum">     587 </span>            :             char *section_start_label, int fde_encoding, char *augmentation,
<span class="lineNum">     588 </span>            :             bool any_lsda_needed, int lsda_encoding)
<span class="lineNum">     589 </span>            : {
<span class="lineNum">     590 </span><span class="lineCov">        104 :   const char *begin, *end;</span>
<span class="lineNum">     591 </span><span class="lineCov">        104 :   static unsigned int j;</span>
<span class="lineNum">     592 </span><span class="lineCov">        104 :   char l1[MAX_ARTIFICIAL_LABEL_BYTES], l2[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">     593 </span>            : 
<span class="lineNum">     594 </span><span class="lineCov">        104 :   targetm.asm_out.emit_unwind_label (asm_out_file, fde-&gt;decl, for_eh,</span>
<span class="lineNum">     595 </span>            :                                      /* empty */ 0);
<span class="lineNum">     596 </span><span class="lineCov">        208 :   targetm.asm_out.internal_label (asm_out_file, FDE_LABEL,</span>
<span class="lineNum">     597 </span><span class="lineCov">        104 :                                   for_eh + j);</span>
<span class="lineNum">     598 </span><span class="lineCov">        104 :   ASM_GENERATE_INTERNAL_LABEL (l1, FDE_AFTER_SIZE_LABEL, for_eh + j);</span>
<span class="lineNum">     599 </span><span class="lineCov">        104 :   ASM_GENERATE_INTERNAL_LABEL (l2, FDE_END_LABEL, for_eh + j);</span>
<span class="lineNum">     600 </span><span class="lineCov">        104 :   if (!XCOFF_DEBUGGING_INFO || for_eh)</span>
<span class="lineNum">     601 </span>            :     {
<span class="lineNum">     602 </span><span class="lineCov">        104 :       if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4 &amp;&amp; !for_eh)</span>
<span class="lineNum">     603 </span>            :         dw2_asm_output_data (4, 0xffffffff, &quot;Initial length escape value&quot;
<span class="lineNum">     604 </span>            :                              &quot; indicating 64-bit DWARF extension&quot;);
<span class="lineNum">     605 </span><span class="lineCov">        104 :       dw2_asm_output_delta (for_eh ? 4 : DWARF_OFFSET_SIZE, l2, l1,</span>
<span class="lineNum">     606 </span>            :                             &quot;FDE Length&quot;);
<span class="lineNum">     607 </span>            :     }
<span class="lineNum">     608 </span><span class="lineCov">        104 :   ASM_OUTPUT_LABEL (asm_out_file, l1);</span>
<span class="lineNum">     609 </span>            : 
<span class="lineNum">     610 </span><span class="lineCov">        104 :   if (for_eh)</span>
<span class="lineNum">     611 </span><span class="lineCov">         80 :     dw2_asm_output_delta (4, l1, section_start_label, &quot;FDE CIE offset&quot;);</span>
<span class="lineNum">     612 </span>            :   else
<span class="lineNum">     613 </span><span class="lineCov">         24 :     dw2_asm_output_offset (DWARF_OFFSET_SIZE, section_start_label,</span>
<span class="lineNum">     614 </span>            :                            debug_frame_section, &quot;FDE CIE offset&quot;);
<span class="lineNum">     615 </span>            : 
<span class="lineNum">     616 </span><span class="lineCov">        104 :   begin = second ? fde-&gt;dw_fde_second_begin : fde-&gt;dw_fde_begin;</span>
<span class="lineNum">     617 </span><span class="lineCov">        104 :   end = second ? fde-&gt;dw_fde_second_end : fde-&gt;dw_fde_end;</span>
<span class="lineNum">     618 </span>            : 
<span class="lineNum">     619 </span><span class="lineCov">        104 :   if (for_eh)</span>
<span class="lineNum">     620 </span>            :     {
<span class="lineNum">     621 </span><span class="lineCov">         80 :       rtx sym_ref = gen_rtx_SYMBOL_REF (Pmode, begin);</span>
<span class="lineNum">     622 </span><span class="lineCov">         80 :       SYMBOL_REF_FLAGS (sym_ref) |= SYMBOL_FLAG_LOCAL;</span>
<span class="lineNum">     623 </span><span class="lineCov">         80 :       dw2_asm_output_encoded_addr_rtx (fde_encoding, sym_ref, false,</span>
<span class="lineNum">     624 </span>            :                                        &quot;FDE initial location&quot;);
<span class="lineNum">     625 </span><span class="lineCov">         80 :       dw2_asm_output_delta (size_of_encoded_value (fde_encoding),</span>
<span class="lineNum">     626 </span>            :                             end, begin, &quot;FDE address range&quot;);
<span class="lineNum">     627 </span>            :     }
<span class="lineNum">     628 </span>            :   else
<span class="lineNum">     629 </span>            :     {
<span class="lineNum">     630 </span><span class="lineCov">         24 :       dw2_asm_output_addr (DWARF2_ADDR_SIZE, begin, &quot;FDE initial location&quot;);</span>
<span class="lineNum">     631 </span><span class="lineCov">         24 :       dw2_asm_output_delta (DWARF2_ADDR_SIZE, end, begin, &quot;FDE address range&quot;);</span>
<span class="lineNum">     632 </span>            :     }
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span><span class="lineCov">        104 :   if (augmentation[0])</span>
<span class="lineNum">     635 </span>            :     {
<span class="lineNum">     636 </span><span class="lineCov">         80 :       if (any_lsda_needed)</span>
<span class="lineNum">     637 </span>            :         {
<span class="lineNum">     638 </span><span class="lineCov">         80 :           int size = size_of_encoded_value (lsda_encoding);</span>
<span class="lineNum">     639 </span>            : 
<span class="lineNum">     640 </span><span class="lineCov">         80 :           if (lsda_encoding == DW_EH_PE_aligned)</span>
<span class="lineNum">     641 </span>            :             {
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :               int offset = (  4         /* Length */</span>
<span class="lineNum">     643 </span>            :                             + 4         /* CIE offset */
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :                             + 2 * size_of_encoded_value (fde_encoding)</span>
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :                             + 1         /* Augmentation size */ );</span>
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :               int pad = -offset &amp; (PTR_SIZE - 1);</span>
<span class="lineNum">     647 </span>            : 
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :               size += pad;</span>
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :               gcc_assert (size_of_uleb128 (size) == 1);</span>
<span class="lineNum">     650 </span>            :             }
<span class="lineNum">     651 </span>            : 
<span class="lineNum">     652 </span><span class="lineCov">         80 :           dw2_asm_output_data_uleb128 (size, &quot;Augmentation size&quot;);</span>
<span class="lineNum">     653 </span>            : 
<span class="lineNum">     654 </span><span class="lineCov">         80 :           if (fde-&gt;uses_eh_lsda)</span>
<span class="lineNum">     655 </span>            :             {
<span class="lineNum">     656 </span><span class="lineCov">         80 :               ASM_GENERATE_INTERNAL_LABEL (l1, second ? &quot;LLSDAC&quot; : &quot;LLSDA&quot;,</span>
<span class="lineNum">     657 </span>            :                                            fde-&gt;funcdef_number);
<span class="lineNum">     658 </span><span class="lineCov">         98 :               dw2_asm_output_encoded_addr_rtx (lsda_encoding,</span>
<span class="lineNum">     659 </span><span class="lineCov">         49 :                                                gen_rtx_SYMBOL_REF (Pmode, l1),</span>
<span class="lineNum">     660 </span>            :                                                false,
<span class="lineNum">     661 </span>            :                                                &quot;Language Specific Data Area&quot;);
<span class="lineNum">     662 </span>            :             }
<span class="lineNum">     663 </span>            :           else
<span class="lineNum">     664 </span>            :             {
<span class="lineNum">     665 </span><span class="lineCov">         31 :               if (lsda_encoding == DW_EH_PE_aligned)</span>
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :                 ASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (PTR_SIZE));</span>
<span class="lineNum">     667 </span><span class="lineCov">         31 :               dw2_asm_output_data (size_of_encoded_value (lsda_encoding), 0,</span>
<span class="lineNum">     668 </span>            :                                    &quot;Language Specific Data Area (none)&quot;);
<span class="lineNum">     669 </span>            :             }
<span class="lineNum">     670 </span>            :         }
<span class="lineNum">     671 </span>            :       else
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :         dw2_asm_output_data_uleb128 (0, &quot;Augmentation size&quot;);</span>
<span class="lineNum">     673 </span>            :     }
<span class="lineNum">     674 </span>            : 
<span class="lineNum">     675 </span>            :   /* Loop through the Call Frame Instructions associated with this FDE.  */
<span class="lineNum">     676 </span><span class="lineCov">        104 :   fde-&gt;dw_fde_current_label = begin;</span>
<span class="lineNum">     677 </span><span class="lineCov">        104 :   {</span>
<span class="lineNum">     678 </span><span class="lineCov">        104 :     size_t from, until, i;</span>
<span class="lineNum">     679 </span>            : 
<span class="lineNum">     680 </span><span class="lineCov">        104 :     from = 0;</span>
<span class="lineNum">     681 </span><span class="lineCov">        104 :     until = vec_safe_length (fde-&gt;dw_fde_cfi);</span>
<span class="lineNum">     682 </span>            : 
<span class="lineNum">     683 </span><span class="lineCov">        104 :     if (fde-&gt;dw_fde_second_begin == NULL)</span>
<span class="lineNum">     684 </span>            :       ;
<span class="lineNum">     685 </span><span class="lineCov">         48 :     else if (!second)</span>
<span class="lineNum">     686 </span><span class="lineCov">         24 :       until = fde-&gt;dw_fde_switch_cfi_index;</span>
<span class="lineNum">     687 </span>            :     else
<span class="lineNum">     688 </span><span class="lineCov">         24 :       from = fde-&gt;dw_fde_switch_cfi_index;</span>
<span class="lineNum">     689 </span>            : 
<span class="lineNum">     690 </span><span class="lineCov">        560 :     for (i = from; i &lt; until; i++)</span>
<span class="lineNum">     691 </span><span class="lineCov">        456 :       output_cfi ((*fde-&gt;dw_fde_cfi)[i], fde, for_eh);</span>
<span class="lineNum">     692 </span>            :   }
<span class="lineNum">     693 </span>            : 
<span class="lineNum">     694 </span>            :   /* If we are to emit a ref/link from function bodies to their frame tables,
<span class="lineNum">     695 </span>            :      do it now.  This is typically performed to make sure that tables
<span class="lineNum">     696 </span>            :      associated with functions are dragged with them and not discarded in
<span class="lineNum">     697 </span>            :      garbage collecting links. We need to do this on a per function basis to
<span class="lineNum">     698 </span>            :      cope with -ffunction-sections.  */
<span class="lineNum">     699 </span>            : 
<span class="lineNum">     700 </span>            : #ifdef ASM_OUTPUT_DWARF_TABLE_REF
<span class="lineNum">     701 </span>            :   /* Switch to the function section, emit the ref to the tables, and
<span class="lineNum">     702 </span>            :      switch *back* into the table section.  */
<span class="lineNum">     703 </span>            :   switch_to_section (function_section (fde-&gt;decl));
<span class="lineNum">     704 </span>            :   ASM_OUTPUT_DWARF_TABLE_REF (section_start_label);
<span class="lineNum">     705 </span>            :   switch_to_frame_table_section (for_eh, true);
<span class="lineNum">     706 </span>            : #endif
<span class="lineNum">     707 </span>            : 
<span class="lineNum">     708 </span>            :   /* Pad the FDE out to an address sized boundary.  */
<span class="lineNum">     709 </span><span class="lineCov">        208 :   ASM_OUTPUT_ALIGN (asm_out_file,</span>
<span class="lineNum">     710 </span>            :                     floor_log2 ((for_eh ? PTR_SIZE : DWARF2_ADDR_SIZE)));
<span class="lineNum">     711 </span><span class="lineCov">        104 :   ASM_OUTPUT_LABEL (asm_out_file, l2);</span>
<span class="lineNum">     712 </span>            : 
<span class="lineNum">     713 </span><span class="lineCov">        104 :   j += 2;</span>
<span class="lineNum">     714 </span><span class="lineCov">        104 : }</span>
<span class="lineNum">     715 </span>            : 
<span class="lineNum">     716 </span>            : /* Return true if frame description entry FDE is needed for EH.  */
<a name="717"><span class="lineNum">     717 </span>            : </a>
<span class="lineNum">     718 </span>            : static bool
<span class="lineNum">     719 </span><span class="lineNoCov">          0 : fde_needed_for_eh_p (dw_fde_ref fde)</span>
<span class="lineNum">     720 </span>            : {
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :   if (flag_asynchronous_unwind_tables)</span>
<span class="lineNum">     722 </span>            :     return true;
<span class="lineNum">     723 </span>            : 
<span class="lineNum">     724 </span><span class="lineCov">         16 :   if (TARGET_USES_WEAK_UNWIND_INFO &amp;&amp; DECL_WEAK (fde-&gt;decl))</span>
<span class="lineNum">     725 </span>            :     return true;
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span><span class="lineCov">         10 :   if (fde-&gt;uses_eh_lsda)</span>
<span class="lineNum">     728 </span>            :     return true;
<span class="lineNum">     729 </span>            : 
<span class="lineNum">     730 </span>            :   /* If exceptions are enabled, we have collected nothrow info.  */
<span class="lineNum">     731 </span><span class="lineCov">         12 :   if (flag_exceptions &amp;&amp; (fde-&gt;all_throwers_are_sibcalls || fde-&gt;nothrow))</span>
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     733 </span>            : 
<span class="lineNum">     734 </span>            :   return true;
<span class="lineNum">     735 </span>            : }
<span class="lineNum">     736 </span>            : 
<span class="lineNum">     737 </span>            : /* Output the call frame information used to record information
<span class="lineNum">     738 </span>            :    that relates to calculating the frame pointer, and records the
<span class="lineNum">     739 </span>            :    location of saved registers.  */
<a name="740"><span class="lineNum">     740 </span>            : </a>
<span class="lineNum">     741 </span>            : static void
<span class="lineNum">     742 </span><span class="lineCov">     162844 : output_call_frame_info (int for_eh)</span>
<span class="lineNum">     743 </span>            : {
<span class="lineNum">     744 </span><span class="lineCov">     162844 :   unsigned int i;</span>
<span class="lineNum">     745 </span><span class="lineCov">     162844 :   dw_fde_ref fde;</span>
<span class="lineNum">     746 </span><span class="lineCov">     162844 :   dw_cfi_ref cfi;</span>
<span class="lineNum">     747 </span><span class="lineCov">     162844 :   char l1[MAX_ARTIFICIAL_LABEL_BYTES], l2[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">     748 </span><span class="lineCov">     162844 :   char section_start_label[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">     749 </span><span class="lineCov">     162844 :   bool any_lsda_needed = false;</span>
<span class="lineNum">     750 </span><span class="lineCov">     162844 :   char augmentation[6];</span>
<span class="lineNum">     751 </span><span class="lineCov">     162844 :   int augmentation_size;</span>
<span class="lineNum">     752 </span><span class="lineCov">     162844 :   int fde_encoding = DW_EH_PE_absptr;</span>
<span class="lineNum">     753 </span><span class="lineCov">     162844 :   int per_encoding = DW_EH_PE_absptr;</span>
<span class="lineNum">     754 </span><span class="lineCov">     162844 :   int lsda_encoding = DW_EH_PE_absptr;</span>
<span class="lineNum">     755 </span><span class="lineCov">     162844 :   int return_reg;</span>
<span class="lineNum">     756 </span><span class="lineCov">     162844 :   rtx personality = NULL;</span>
<span class="lineNum">     757 </span><span class="lineCov">     162844 :   int dw_cie_version;</span>
<span class="lineNum">     758 </span>            : 
<span class="lineNum">     759 </span>            :   /* Don't emit a CIE if there won't be any FDEs.  */
<span class="lineNum">     760 </span><span class="lineCov">     162844 :   if (!fde_vec)</span>
<span class="lineNum">     761 </span><span class="lineCov">     162806 :     return;</span>
<span class="lineNum">     762 </span>            : 
<span class="lineNum">     763 </span>            :   /* Nothing to do if the assembler's doing it all.  */
<span class="lineNum">     764 </span><span class="lineCov">     160712 :   if (dwarf2out_do_cfi_asm ())</span>
<span class="lineNum">     765 </span>            :     return;
<span class="lineNum">     766 </span>            : 
<span class="lineNum">     767 </span>            :   /* If we don't have any functions we'll want to unwind out of, don't emit
<span class="lineNum">     768 </span>            :      any EH unwind information.  If we make FDEs linkonce, we may have to
<span class="lineNum">     769 </span>            :      emit an empty label for an FDE that wouldn't otherwise be emitted.  We
<span class="lineNum">     770 </span>            :      want to avoid having an FDE kept around when the function it refers to
<span class="lineNum">     771 </span>            :      is discarded.  Example where this matters: a primary function template
<span class="lineNum">     772 </span>            :      in C++ requires EH information, an explicit specialization doesn't.  */
<span class="lineNum">     773 </span><span class="lineCov">         38 :   if (for_eh)</span>
<span class="lineNum">     774 </span>            :     {
<span class="lineNum">     775 </span>            :       bool any_eh_needed = false;
<span class="lineNum">     776 </span>            : 
<span class="lineNum">     777 </span><span class="lineCov">         93 :       FOR_EACH_VEC_ELT (*fde_vec, i, fde)</span>
<span class="lineNum">     778 </span>            :         {
<span class="lineNum">     779 </span><span class="lineCov">         64 :           if (fde-&gt;uses_eh_lsda)</span>
<span class="lineNum">     780 </span>            :             any_eh_needed = any_lsda_needed = true;
<span class="lineNum">     781 </span><span class="lineCov">         37 :           else if (fde_needed_for_eh_p (fde))</span>
<span class="lineNum">     782 </span>            :             any_eh_needed = true;
<span class="lineNum">     783 </span>            :           else if (TARGET_USES_WEAK_UNWIND_INFO)
<span class="lineNum">     784 </span>            :             targetm.asm_out.emit_unwind_label (asm_out_file, fde-&gt;decl, 1, 1);
<span class="lineNum">     785 </span>            :         }
<span class="lineNum">     786 </span>            : 
<span class="lineNum">     787 </span><span class="lineCov">         29 :       if (!any_eh_needed)</span>
<span class="lineNum">     788 </span>            :         return;
<span class="lineNum">     789 </span>            :     }
<span class="lineNum">     790 </span>            : 
<span class="lineNum">     791 </span>            :   /* We're going to be generating comments, so turn on app.  */
<span class="lineNum">     792 </span><span class="lineCov">         38 :   if (flag_debug_asm)</span>
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :     app_enable ();</span>
<span class="lineNum">     794 </span>            : 
<span class="lineNum">     795 </span>            :   /* Switch to the proper frame section, first time.  */
<span class="lineNum">     796 </span><span class="lineCov">         38 :   switch_to_frame_table_section (for_eh, false);</span>
<span class="lineNum">     797 </span>            : 
<span class="lineNum">     798 </span><span class="lineCov">         38 :   ASM_GENERATE_INTERNAL_LABEL (section_start_label, FRAME_BEGIN_LABEL, for_eh);</span>
<span class="lineNum">     799 </span><span class="lineCov">         38 :   ASM_OUTPUT_LABEL (asm_out_file, section_start_label);</span>
<span class="lineNum">     800 </span>            : 
<span class="lineNum">     801 </span>            :   /* Output the CIE.  */
<span class="lineNum">     802 </span><span class="lineCov">         38 :   ASM_GENERATE_INTERNAL_LABEL (l1, CIE_AFTER_SIZE_LABEL, for_eh);</span>
<span class="lineNum">     803 </span><span class="lineCov">         38 :   ASM_GENERATE_INTERNAL_LABEL (l2, CIE_END_LABEL, for_eh);</span>
<span class="lineNum">     804 </span><span class="lineCov">         38 :   if (!XCOFF_DEBUGGING_INFO || for_eh)</span>
<span class="lineNum">     805 </span>            :     {
<span class="lineNum">     806 </span><span class="lineCov">         38 :       if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4 &amp;&amp; !for_eh)</span>
<span class="lineNum">     807 </span>            :         dw2_asm_output_data (4, 0xffffffff,
<span class="lineNum">     808 </span>            :           &quot;Initial length escape value indicating 64-bit DWARF extension&quot;);
<span class="lineNum">     809 </span><span class="lineCov">         38 :       dw2_asm_output_delta (for_eh ? 4 : DWARF_OFFSET_SIZE, l2, l1,</span>
<span class="lineNum">     810 </span>            :                             &quot;Length of Common Information Entry&quot;);
<span class="lineNum">     811 </span>            :     }
<span class="lineNum">     812 </span><span class="lineCov">         38 :   ASM_OUTPUT_LABEL (asm_out_file, l1);</span>
<span class="lineNum">     813 </span>            : 
<span class="lineNum">     814 </span>            :   /* Now that the CIE pointer is PC-relative for EH,
<span class="lineNum">     815 </span>            :      use 0 to identify the CIE.  */
<span class="lineNum">     816 </span><span class="lineCov">         47 :   dw2_asm_output_data ((for_eh ? 4 : DWARF_OFFSET_SIZE),</span>
<span class="lineNum">     817 </span>            :                        (for_eh ? 0 : DWARF_CIE_ID),
<span class="lineNum">     818 </span>            :                        &quot;CIE Identifier Tag&quot;);
<span class="lineNum">     819 </span>            : 
<span class="lineNum">     820 </span>            :   /* Use the CIE version 3 for DWARF3; allow DWARF2 to continue to
<span class="lineNum">     821 </span>            :      use CIE version 1, unless that would produce incorrect results
<span class="lineNum">     822 </span>            :      due to overflowing the return register column.  */
<span class="lineNum">     823 </span><span class="lineCov">         38 :   return_reg = DWARF2_FRAME_REG_OUT (DWARF_FRAME_RETURN_COLUMN, for_eh);</span>
<span class="lineNum">     824 </span><span class="lineCov">         38 :   dw_cie_version = 1;</span>
<span class="lineNum">     825 </span><span class="lineCov">         38 :   if (return_reg &gt;= 256 || dwarf_version &gt; 2)</span>
<span class="lineNum">     826 </span><span class="lineCov">         20 :     dw_cie_version = 3;</span>
<span class="lineNum">     827 </span><span class="lineCov">         38 :   dw2_asm_output_data (1, dw_cie_version, &quot;CIE Version&quot;);</span>
<span class="lineNum">     828 </span>            : 
<span class="lineNum">     829 </span><span class="lineCov">         38 :   augmentation[0] = 0;</span>
<span class="lineNum">     830 </span><span class="lineCov">         38 :   augmentation_size = 0;</span>
<span class="lineNum">     831 </span>            : 
<span class="lineNum">     832 </span><span class="lineCov">         38 :   personality = current_unit_personality;</span>
<span class="lineNum">     833 </span><span class="lineCov">         38 :   if (for_eh)</span>
<span class="lineNum">     834 </span>            :     {
<span class="lineNum">     835 </span><span class="lineCov">         29 :       char *p;</span>
<span class="lineNum">     836 </span>            : 
<span class="lineNum">     837 </span>            :       /* Augmentation:
<span class="lineNum">     838 </span>            :          z      Indicates that a uleb128 is present to size the
<span class="lineNum">     839 </span>            :                 augmentation section.
<span class="lineNum">     840 </span>            :          L      Indicates the encoding (and thus presence) of
<span class="lineNum">     841 </span>            :                 an LSDA pointer in the FDE augmentation.
<span class="lineNum">     842 </span>            :          R      Indicates a non-default pointer encoding for
<span class="lineNum">     843 </span>            :                 FDE code pointers.
<span class="lineNum">     844 </span>            :          P      Indicates the presence of an encoding + language
<span class="lineNum">     845 </span>            :                 personality routine in the CIE augmentation.  */
<span class="lineNum">     846 </span>            : 
<span class="lineNum">     847 </span><span class="lineCov">         29 :       fde_encoding = ASM_PREFERRED_EH_DATA_FORMAT (/*code=*/1, /*global=*/0);</span>
<span class="lineNum">     848 </span><span class="lineCov">         29 :       per_encoding = ASM_PREFERRED_EH_DATA_FORMAT (/*code=*/2, /*global=*/1);</span>
<span class="lineNum">     849 </span><span class="lineCov">         29 :       lsda_encoding = ASM_PREFERRED_EH_DATA_FORMAT (/*code=*/0, /*global=*/0);</span>
<span class="lineNum">     850 </span>            : 
<span class="lineNum">     851 </span><span class="lineCov">         29 :       p = augmentation + 1;</span>
<span class="lineNum">     852 </span><span class="lineCov">         29 :       if (personality)</span>
<span class="lineNum">     853 </span>            :         {
<span class="lineNum">     854 </span><span class="lineCov">         29 :           *p++ = 'P';</span>
<span class="lineNum">     855 </span><span class="lineCov">         29 :           augmentation_size += 1 + size_of_encoded_value (per_encoding);</span>
<span class="lineNum">     856 </span><span class="lineCov">         29 :           assemble_external_libcall (personality);</span>
<span class="lineNum">     857 </span>            :         }
<span class="lineNum">     858 </span><span class="lineCov">         29 :       if (any_lsda_needed)</span>
<span class="lineNum">     859 </span>            :         {
<span class="lineNum">     860 </span><span class="lineCov">         29 :           *p++ = 'L';</span>
<span class="lineNum">     861 </span><span class="lineCov">         29 :           augmentation_size += 1;</span>
<span class="lineNum">     862 </span>            :         }
<span class="lineNum">     863 </span><span class="lineCov">         29 :       if (fde_encoding != DW_EH_PE_absptr)</span>
<span class="lineNum">     864 </span>            :         {
<span class="lineNum">     865 </span><span class="lineCov">         29 :           *p++ = 'R';</span>
<span class="lineNum">     866 </span><span class="lineCov">         29 :           augmentation_size += 1;</span>
<span class="lineNum">     867 </span>            :         }
<span class="lineNum">     868 </span><span class="lineCov">         29 :       if (p &gt; augmentation + 1)</span>
<span class="lineNum">     869 </span>            :         {
<span class="lineNum">     870 </span><span class="lineCov">         29 :           augmentation[0] = 'z';</span>
<span class="lineNum">     871 </span><span class="lineCov">         29 :           *p = '\0';</span>
<span class="lineNum">     872 </span>            :         }
<span class="lineNum">     873 </span>            : 
<span class="lineNum">     874 </span>            :       /* Ug.  Some platforms can't do unaligned dynamic relocations at all.  */
<span class="lineNum">     875 </span><span class="lineCov">         29 :       if (personality &amp;&amp; per_encoding == DW_EH_PE_aligned)</span>
<span class="lineNum">     876 </span>            :         {
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :           int offset = (  4             /* Length */</span>
<span class="lineNum">     878 </span>            :                         + 4             /* CIE Id */
<span class="lineNum">     879 </span>            :                         + 1             /* CIE version */
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :                         + strlen (augmentation) + 1     /* Augmentation */</span>
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :                         + size_of_uleb128 (1)           /* Code alignment */</span>
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :                         + size_of_sleb128 (DWARF_CIE_DATA_ALIGNMENT)</span>
<span class="lineNum">     883 </span>            :                         + 1             /* RA column */
<span class="lineNum">     884 </span>            :                         + 1             /* Augmentation size */
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :                         + 1             /* Personality encoding */ );</span>
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :           int pad = -offset &amp; (PTR_SIZE - 1);</span>
<span class="lineNum">     887 </span>            : 
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :           augmentation_size += pad;</span>
<span class="lineNum">     889 </span>            : 
<span class="lineNum">     890 </span>            :           /* Augmentations should be small, so there's scarce need to
<span class="lineNum">     891 </span>            :              iterate for a solution.  Die if we exceed one uleb128 byte.  */
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :           gcc_assert (size_of_uleb128 (augmentation_size) == 1);</span>
<span class="lineNum">     893 </span>            :         }
<span class="lineNum">     894 </span>            :     }
<span class="lineNum">     895 </span>            : 
<span class="lineNum">     896 </span><span class="lineCov">         38 :   dw2_asm_output_nstring (augmentation, -1, &quot;CIE Augmentation&quot;);</span>
<span class="lineNum">     897 </span><span class="lineCov">         38 :   if (dw_cie_version &gt;= 4)</span>
<span class="lineNum">     898 </span>            :     {
<span class="lineNum">     899 </span>            :       dw2_asm_output_data (1, DWARF2_ADDR_SIZE, &quot;CIE Address Size&quot;);
<span class="lineNum">     900 </span>            :       dw2_asm_output_data (1, 0, &quot;CIE Segment Size&quot;);
<span class="lineNum">     901 </span>            :     }
<span class="lineNum">     902 </span><span class="lineCov">         38 :   dw2_asm_output_data_uleb128 (1, &quot;CIE Code Alignment Factor&quot;);</span>
<span class="lineNum">     903 </span><span class="lineCov">         38 :   dw2_asm_output_data_sleb128 (DWARF_CIE_DATA_ALIGNMENT,</span>
<span class="lineNum">     904 </span>            :                                &quot;CIE Data Alignment Factor&quot;);
<span class="lineNum">     905 </span>            : 
<span class="lineNum">     906 </span><span class="lineCov">         38 :   if (dw_cie_version == 1)</span>
<span class="lineNum">     907 </span><span class="lineCov">         18 :     dw2_asm_output_data (1, return_reg, &quot;CIE RA Column&quot;);</span>
<span class="lineNum">     908 </span>            :   else
<span class="lineNum">     909 </span><span class="lineCov">         20 :     dw2_asm_output_data_uleb128 (return_reg, &quot;CIE RA Column&quot;);</span>
<span class="lineNum">     910 </span>            : 
<span class="lineNum">     911 </span><span class="lineCov">         38 :   if (augmentation[0])</span>
<span class="lineNum">     912 </span>            :     {
<span class="lineNum">     913 </span><span class="lineCov">         29 :       dw2_asm_output_data_uleb128 (augmentation_size, &quot;Augmentation size&quot;);</span>
<span class="lineNum">     914 </span><span class="lineCov">         29 :       if (personality)</span>
<span class="lineNum">     915 </span>            :         {
<span class="lineNum">     916 </span><span class="lineCov">         29 :           dw2_asm_output_data (1, per_encoding, &quot;Personality (%s)&quot;,</span>
<span class="lineNum">     917 </span>            :                                eh_data_format_name (per_encoding));
<span class="lineNum">     918 </span><span class="lineCov">         29 :           dw2_asm_output_encoded_addr_rtx (per_encoding,</span>
<span class="lineNum">     919 </span>            :                                            personality,
<span class="lineNum">     920 </span>            :                                            true, NULL);
<span class="lineNum">     921 </span>            :         }
<span class="lineNum">     922 </span>            : 
<span class="lineNum">     923 </span><span class="lineCov">         29 :       if (any_lsda_needed)</span>
<span class="lineNum">     924 </span><span class="lineCov">         29 :         dw2_asm_output_data (1, lsda_encoding, &quot;LSDA Encoding (%s)&quot;,</span>
<span class="lineNum">     925 </span>            :                              eh_data_format_name (lsda_encoding));
<span class="lineNum">     926 </span>            : 
<span class="lineNum">     927 </span><span class="lineCov">         29 :       if (fde_encoding != DW_EH_PE_absptr)</span>
<span class="lineNum">     928 </span><span class="lineCov">         29 :         dw2_asm_output_data (1, fde_encoding, &quot;FDE Encoding (%s)&quot;,</span>
<span class="lineNum">     929 </span>            :                              eh_data_format_name (fde_encoding));
<span class="lineNum">     930 </span>            :     }
<span class="lineNum">     931 </span>            : 
<span class="lineNum">     932 </span><span class="lineCov">        114 :   FOR_EACH_VEC_ELT (*cie_cfi_vec, i, cfi)</span>
<span class="lineNum">     933 </span><span class="lineCov">         76 :     output_cfi (cfi, NULL, for_eh);</span>
<span class="lineNum">     934 </span>            : 
<span class="lineNum">     935 </span>            :   /* Pad the CIE out to an address sized boundary.  */
<span class="lineNum">     936 </span><span class="lineCov">         76 :   ASM_OUTPUT_ALIGN (asm_out_file,</span>
<span class="lineNum">     937 </span>            :                     floor_log2 (for_eh ? PTR_SIZE : DWARF2_ADDR_SIZE));
<span class="lineNum">     938 </span><span class="lineCov">         38 :   ASM_OUTPUT_LABEL (asm_out_file, l2);</span>
<span class="lineNum">     939 </span>            : 
<span class="lineNum">     940 </span>            :   /* Loop through all of the FDE's.  */
<span class="lineNum">     941 </span><span class="lineCov">        120 :   FOR_EACH_VEC_ELT (*fde_vec, i, fde)</span>
<span class="lineNum">     942 </span>            :     {
<span class="lineNum">     943 </span><span class="lineCov">         82 :       unsigned int k;</span>
<span class="lineNum">     944 </span>            : 
<span class="lineNum">     945 </span>            :       /* Don't emit EH unwind info for leaf functions that don't need it.  */
<span class="lineNum">     946 </span><span class="lineCov">         82 :       if (for_eh &amp;&amp; !fde_needed_for_eh_p (fde))</span>
<span class="lineNum">     947 </span>            :         continue;
<span class="lineNum">     948 </span>            : 
<span class="lineNum">     949 </span><span class="lineCov">        296 :       for (k = 0; k &lt; (fde-&gt;dw_fde_second_begin ? 2 : 1); k++)</span>
<span class="lineNum">     950 </span><span class="lineCov">        104 :         output_fde (fde, for_eh, k, section_start_label, fde_encoding,</span>
<span class="lineNum">     951 </span>            :                     augmentation, any_lsda_needed, lsda_encoding);
<span class="lineNum">     952 </span>            :     }
<span class="lineNum">     953 </span>            : 
<span class="lineNum">     954 </span><span class="lineCov">         38 :   if (for_eh &amp;&amp; targetm.terminate_dw2_eh_frame_info)</span>
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :     dw2_asm_output_data (4, 0, &quot;End of Table&quot;);</span>
<span class="lineNum">     956 </span>            : 
<span class="lineNum">     957 </span>            :   /* Turn off app to make assembly quicker.  */
<span class="lineNum">     958 </span><span class="lineCov">         38 :   if (flag_debug_asm)</span>
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :     app_disable ();</span>
<span class="lineNum">     960 </span>            : }
<span class="lineNum">     961 </span>            : 
<span class="lineNum">     962 </span>            : /* Emit .cfi_startproc and .cfi_personality/.cfi_lsda if needed.  */
<a name="963"><span class="lineNum">     963 </span>            : </a>
<span class="lineNum">     964 </span>            : static void
<span class="lineNum">     965 </span><span class="lineCov">     874360 : dwarf2out_do_cfi_startproc (bool second)</span>
<span class="lineNum">     966 </span>            : {
<span class="lineNum">     967 </span><span class="lineCov">     874360 :   int enc;</span>
<span class="lineNum">     968 </span><span class="lineCov">     874360 :   rtx ref;</span>
<span class="lineNum">     969 </span>            : 
<span class="lineNum">     970 </span><span class="lineCov">     874360 :   fprintf (asm_out_file, &quot;\t.cfi_startproc\n&quot;);</span>
<span class="lineNum">     971 </span>            : 
<span class="lineNum">     972 </span>            :   /* .cfi_personality and .cfi_lsda are only relevant to DWARF2
<span class="lineNum">     973 </span>            :      eh unwinders.  */
<span class="lineNum">     974 </span><span class="lineCov">     874360 :   if (targetm_common.except_unwind_info (&amp;global_options) != UI_DWARF2)</span>
<span class="lineNum">     975 </span>            :     return;
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span><span class="lineCov">     874360 :   rtx personality = get_personality_function (current_function_decl);</span>
<span class="lineNum">     978 </span>            : 
<span class="lineNum">     979 </span><span class="lineCov">     874360 :   if (personality)</span>
<span class="lineNum">     980 </span>            :     {
<span class="lineNum">     981 </span><span class="lineCov">      45265 :       enc = ASM_PREFERRED_EH_DATA_FORMAT (/*code=*/2, /*global=*/1);</span>
<span class="lineNum">     982 </span><span class="lineCov">      45265 :       ref = personality;</span>
<span class="lineNum">     983 </span>            : 
<span class="lineNum">     984 </span>            :       /* ??? The GAS support isn't entirely consistent.  We have to
<span class="lineNum">     985 </span>            :          handle indirect support ourselves, but PC-relative is done
<span class="lineNum">     986 </span>            :          in the assembler.  Further, the assembler can't handle any
<span class="lineNum">     987 </span>            :          of the weirder relocation types.  */
<span class="lineNum">     988 </span><span class="lineCov">      45265 :       if (enc &amp; DW_EH_PE_indirect)</span>
<span class="lineNum">     989 </span><span class="lineCov">       5098 :         ref = dw2_force_const_mem (ref, true);</span>
<span class="lineNum">     990 </span>            : 
<span class="lineNum">     991 </span><span class="lineCov">      45265 :       fprintf (asm_out_file, &quot;\t.cfi_personality %#x,&quot;, enc);</span>
<span class="lineNum">     992 </span><span class="lineCov">      45265 :       output_addr_const (asm_out_file, ref);</span>
<span class="lineNum">     993 </span><span class="lineCov">      45265 :       fputc ('\n', asm_out_file);</span>
<span class="lineNum">     994 </span>            :     }
<span class="lineNum">     995 </span>            : 
<span class="lineNum">     996 </span><span class="lineCov">     874360 :   if (crtl-&gt;uses_eh_lsda)</span>
<span class="lineNum">     997 </span>            :     {
<span class="lineNum">     998 </span><span class="lineCov">      45251 :       char lab[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">     999 </span>            : 
<span class="lineNum">    1000 </span><span class="lineCov">      45251 :       enc = ASM_PREFERRED_EH_DATA_FORMAT (/*code=*/0, /*global=*/0);</span>
<span class="lineNum">    1001 </span><span class="lineCov">      82975 :       ASM_GENERATE_INTERNAL_LABEL (lab, second ? &quot;LLSDAC&quot; : &quot;LLSDA&quot;,</span>
<span class="lineNum">    1002 </span>            :                                    current_function_funcdef_no);
<span class="lineNum">    1003 </span><span class="lineCov">      45251 :       ref = gen_rtx_SYMBOL_REF (Pmode, lab);</span>
<span class="lineNum">    1004 </span><span class="lineCov">      45251 :       SYMBOL_REF_FLAGS (ref) = SYMBOL_FLAG_LOCAL;</span>
<span class="lineNum">    1005 </span>            : 
<span class="lineNum">    1006 </span><span class="lineCov">      45251 :       if (enc &amp; DW_EH_PE_indirect)</span>
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :         ref = dw2_force_const_mem (ref, true);</span>
<span class="lineNum">    1008 </span>            : 
<span class="lineNum">    1009 </span><span class="lineCov">      45251 :       fprintf (asm_out_file, &quot;\t.cfi_lsda %#x,&quot;, enc);</span>
<span class="lineNum">    1010 </span><span class="lineCov">      45251 :       output_addr_const (asm_out_file, ref);</span>
<span class="lineNum">    1011 </span><span class="lineCov">      45251 :       fputc ('\n', asm_out_file);</span>
<span class="lineNum">    1012 </span>            :     }
<span class="lineNum">    1013 </span>            : }
<span class="lineNum">    1014 </span>            : 
<span class="lineNum">    1015 </span>            : /* Allocate CURRENT_FDE.  Immediately initialize all we can, noting that
<span class="lineNum">    1016 </span>            :    this allocation may be done before pass_final.  */
<a name="1017"><span class="lineNum">    1017 </span>            : </a>
<span class="lineNum">    1018 </span>            : dw_fde_ref
<span class="lineNum">    1019 </span><span class="lineCov">     837002 : dwarf2out_alloc_current_fde (void)</span>
<span class="lineNum">    1020 </span>            : {
<span class="lineNum">    1021 </span><span class="lineCov">     837002 :   dw_fde_ref fde;</span>
<span class="lineNum">    1022 </span>            : 
<span class="lineNum">    1023 </span><span class="lineCov">     837002 :   fde = ggc_cleared_alloc&lt;dw_fde_node&gt; ();</span>
<span class="lineNum">    1024 </span><span class="lineCov">     837002 :   fde-&gt;decl = current_function_decl;</span>
<span class="lineNum">    1025 </span><span class="lineCov">     837002 :   fde-&gt;funcdef_number = current_function_funcdef_no;</span>
<span class="lineNum">    1026 </span><span class="lineCov">     837002 :   fde-&gt;fde_index = vec_safe_length (fde_vec);</span>
<span class="lineNum">    1027 </span><span class="lineCov">     837002 :   fde-&gt;all_throwers_are_sibcalls = crtl-&gt;all_throwers_are_sibcalls;</span>
<span class="lineNum">    1028 </span><span class="lineCov">     837002 :   fde-&gt;uses_eh_lsda = crtl-&gt;uses_eh_lsda;</span>
<span class="lineNum">    1029 </span><span class="lineCov">     837002 :   fde-&gt;nothrow = crtl-&gt;nothrow;</span>
<span class="lineNum">    1030 </span><span class="lineCov">     837002 :   fde-&gt;drap_reg = INVALID_REGNUM;</span>
<span class="lineNum">    1031 </span><span class="lineCov">     837002 :   fde-&gt;vdrap_reg = INVALID_REGNUM;</span>
<span class="lineNum">    1032 </span>            : 
<span class="lineNum">    1033 </span>            :   /* Record the FDE associated with this function.  */
<span class="lineNum">    1034 </span><span class="lineCov">     837002 :   cfun-&gt;fde = fde;</span>
<span class="lineNum">    1035 </span><span class="lineCov">     837002 :   vec_safe_push (fde_vec, fde);</span>
<span class="lineNum">    1036 </span>            : 
<span class="lineNum">    1037 </span><span class="lineCov">     837002 :   return fde;</span>
<span class="lineNum">    1038 </span>            : }
<span class="lineNum">    1039 </span>            : 
<span class="lineNum">    1040 </span>            : /* Output a marker (i.e. a label) for the beginning of a function, before
<span class="lineNum">    1041 </span>            :    the prologue.  */
<a name="1042"><span class="lineNum">    1042 </span>            : </a>
<span class="lineNum">    1043 </span>            : void
<span class="lineNum">    1044 </span><span class="lineCov">     837067 : dwarf2out_begin_prologue (unsigned int line ATTRIBUTE_UNUSED,</span>
<span class="lineNum">    1045 </span>            :                           unsigned int column ATTRIBUTE_UNUSED,
<span class="lineNum">    1046 </span>            :                           const char *file ATTRIBUTE_UNUSED)
<span class="lineNum">    1047 </span>            : {
<span class="lineNum">    1048 </span><span class="lineCov">     837067 :   char label[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">    1049 </span><span class="lineCov">     837067 :   char * dup_label;</span>
<span class="lineNum">    1050 </span><span class="lineCov">     837067 :   dw_fde_ref fde;</span>
<span class="lineNum">    1051 </span><span class="lineCov">     837067 :   section *fnsec;</span>
<span class="lineNum">    1052 </span><span class="lineCov">     837067 :   bool do_frame;</span>
<span class="lineNum">    1053 </span>            : 
<span class="lineNum">    1054 </span><span class="lineCov">     837067 :   current_function_func_begin_label = NULL;</span>
<span class="lineNum">    1055 </span>            : 
<span class="lineNum">    1056 </span><span class="lineCov">     837067 :   do_frame = dwarf2out_do_frame ();</span>
<span class="lineNum">    1057 </span>            : 
<span class="lineNum">    1058 </span>            :   /* ??? current_function_func_begin_label is also used by except.c for
<span class="lineNum">    1059 </span>            :      call-site information.  We must emit this label if it might be used.  */
<span class="lineNum">    1060 </span><span class="lineCov">     837067 :   if (!do_frame</span>
<span class="lineNum">    1061 </span><span class="lineCov">     837067 :       &amp;&amp; (!flag_exceptions</span>
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :           || targetm_common.except_unwind_info (&amp;global_options) == UI_SJLJ))</span>
<span class="lineNum">    1063 </span><span class="lineCov">         65 :     return;</span>
<span class="lineNum">    1064 </span>            : 
<span class="lineNum">    1065 </span><span class="lineCov">     837002 :   fnsec = function_section (current_function_decl);</span>
<span class="lineNum">    1066 </span><span class="lineCov">     837002 :   switch_to_section (fnsec);</span>
<span class="lineNum">    1067 </span><span class="lineCov">     837002 :   ASM_GENERATE_INTERNAL_LABEL (label, FUNC_BEGIN_LABEL,</span>
<span class="lineNum">    1068 </span>            :                                current_function_funcdef_no);
<span class="lineNum">    1069 </span><span class="lineCov">     837002 :   ASM_OUTPUT_DEBUG_LABEL (asm_out_file, FUNC_BEGIN_LABEL,</span>
<span class="lineNum">    1070 </span>            :                           current_function_funcdef_no);
<span class="lineNum">    1071 </span><span class="lineCov">     837002 :   dup_label = xstrdup (label);</span>
<span class="lineNum">    1072 </span><span class="lineCov">     837002 :   current_function_func_begin_label = dup_label;</span>
<span class="lineNum">    1073 </span>            : 
<span class="lineNum">    1074 </span>            :   /* We can elide FDE allocation if we're not emitting frame unwind info.  */
<span class="lineNum">    1075 </span><span class="lineCov">     837002 :   if (!do_frame)</span>
<span class="lineNum">    1076 </span>            :     return;
<span class="lineNum">    1077 </span>            : 
<span class="lineNum">    1078 </span>            :   /* Unlike the debug version, the EH version of frame unwind info is a per-
<span class="lineNum">    1079 </span>            :      function setting so we need to record whether we need it for the unit.  */
<span class="lineNum">    1080 </span><span class="lineCov">     837002 :   do_eh_frame |= dwarf2out_do_eh_frame ();</span>
<span class="lineNum">    1081 </span>            : 
<span class="lineNum">    1082 </span>            :   /* Cater to the various TARGET_ASM_OUTPUT_MI_THUNK implementations that
<span class="lineNum">    1083 </span>            :      emit insns as rtx but bypass the bulk of rest_of_compilation, which
<span class="lineNum">    1084 </span>            :      would include pass_dwarf2_frame.  If we've not created the FDE yet,
<span class="lineNum">    1085 </span>            :      do so now.  */
<span class="lineNum">    1086 </span><span class="lineCov">     837002 :   fde = cfun-&gt;fde;</span>
<span class="lineNum">    1087 </span><span class="lineCov">     837002 :   if (fde == NULL)</span>
<span class="lineNum">    1088 </span><span class="lineCov">       4470 :     fde = dwarf2out_alloc_current_fde ();</span>
<span class="lineNum">    1089 </span>            : 
<span class="lineNum">    1090 </span>            :   /* Initialize the bits of CURRENT_FDE that were not available earlier.  */
<span class="lineNum">    1091 </span><span class="lineCov">     837002 :   fde-&gt;dw_fde_begin = dup_label;</span>
<span class="lineNum">    1092 </span><span class="lineCov">     837002 :   fde-&gt;dw_fde_current_label = dup_label;</span>
<span class="lineNum">    1093 </span><span class="lineCov">    1674004 :   fde-&gt;in_std_section = (fnsec == text_section</span>
<span class="lineNum">    1094 </span><span class="lineCov">     837002 :                          || (cold_text_section &amp;&amp; fnsec == cold_text_section));</span>
<span class="lineNum">    1095 </span>            : 
<span class="lineNum">    1096 </span>            :   /* We only want to output line number information for the genuine dwarf2
<span class="lineNum">    1097 </span>            :      prologue case, not the eh frame case.  */
<span class="lineNum">    1098 </span>            : #ifdef DWARF2_DEBUGGING_INFO
<span class="lineNum">    1099 </span><span class="lineCov">     837002 :   if (file)</span>
<span class="lineNum">    1100 </span><span class="lineCov">     298495 :     dwarf2out_source_line (line, column, file, 0, true);</span>
<span class="lineNum">    1101 </span>            : #endif
<span class="lineNum">    1102 </span>            : 
<span class="lineNum">    1103 </span><span class="lineCov">     837002 :   if (dwarf2out_do_cfi_asm ())</span>
<span class="lineNum">    1104 </span><span class="lineCov">     836938 :     dwarf2out_do_cfi_startproc (false);</span>
<span class="lineNum">    1105 </span>            :   else
<span class="lineNum">    1106 </span>            :     {
<span class="lineNum">    1107 </span><span class="lineCov">         64 :       rtx personality = get_personality_function (current_function_decl);</span>
<span class="lineNum">    1108 </span><span class="lineCov">         64 :       if (!current_unit_personality)</span>
<span class="lineNum">    1109 </span><span class="lineCov">         35 :         current_unit_personality = personality;</span>
<span class="lineNum">    1110 </span>            : 
<span class="lineNum">    1111 </span>            :       /* We cannot keep a current personality per function as without CFI
<span class="lineNum">    1112 </span>            :          asm, at the point where we emit the CFI data, there is no current
<span class="lineNum">    1113 </span>            :          function anymore.  */
<span class="lineNum">    1114 </span><span class="lineCov">         64 :       if (personality &amp;&amp; current_unit_personality != personality)</span>
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :         sorry (&quot;multiple EH personalities are supported only with assemblers &quot;</span>
<span class="lineNum">    1116 </span>            :                &quot;supporting .cfi_personality directive&quot;);
<span class="lineNum">    1117 </span>            :     }
<span class="lineNum">    1118 </span>            : }
<span class="lineNum">    1119 </span>            : 
<span class="lineNum">    1120 </span>            : /* Output a marker (i.e. a label) for the end of the generated code
<span class="lineNum">    1121 </span>            :    for a function prologue.  This gets called *after* the prologue code has
<span class="lineNum">    1122 </span>            :    been generated.  */
<a name="1123"><span class="lineNum">    1123 </span>            : </a>
<span class="lineNum">    1124 </span>            : void
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 : dwarf2out_vms_end_prologue (unsigned int line ATTRIBUTE_UNUSED,</span>
<span class="lineNum">    1126 </span>            :                             const char *file ATTRIBUTE_UNUSED)
<span class="lineNum">    1127 </span>            : {
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :   char label[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">    1129 </span>            : 
<span class="lineNum">    1130 </span>            :   /* Output a label to mark the endpoint of the code generated for this
<span class="lineNum">    1131 </span>            :      function.  */
<span class="lineNum">    1132 </span><span class="lineNoCov">          0 :   ASM_GENERATE_INTERNAL_LABEL (label, PROLOGUE_END_LABEL,</span>
<span class="lineNum">    1133 </span>            :                                current_function_funcdef_no);
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :   ASM_OUTPUT_DEBUG_LABEL (asm_out_file, PROLOGUE_END_LABEL,</span>
<span class="lineNum">    1135 </span>            :                           current_function_funcdef_no);
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :   cfun-&gt;fde-&gt;dw_fde_vms_end_prologue = xstrdup (label);</span>
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1138 </span>            : 
<span class="lineNum">    1139 </span>            : /* Output a marker (i.e. a label) for the beginning of the generated code
<span class="lineNum">    1140 </span>            :    for a function epilogue.  This gets called *before* the prologue code has
<span class="lineNum">    1141 </span>            :    been generated.  */
<a name="1142"><span class="lineNum">    1142 </span>            : </a>
<span class="lineNum">    1143 </span>            : void
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 : dwarf2out_vms_begin_epilogue (unsigned int line ATTRIBUTE_UNUSED,</span>
<span class="lineNum">    1145 </span>            :                           const char *file ATTRIBUTE_UNUSED)
<span class="lineNum">    1146 </span>            : {
<span class="lineNum">    1147 </span><span class="lineNoCov">          0 :   dw_fde_ref fde = cfun-&gt;fde;</span>
<span class="lineNum">    1148 </span><span class="lineNoCov">          0 :   char label[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">    1149 </span>            : 
<span class="lineNum">    1150 </span><span class="lineNoCov">          0 :   if (fde-&gt;dw_fde_vms_begin_epilogue)</span>
<span class="lineNum">    1151 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1152 </span>            : 
<span class="lineNum">    1153 </span>            :   /* Output a label to mark the endpoint of the code generated for this
<span class="lineNum">    1154 </span>            :      function.  */
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :   ASM_GENERATE_INTERNAL_LABEL (label, EPILOGUE_BEGIN_LABEL,</span>
<span class="lineNum">    1156 </span>            :                                current_function_funcdef_no);
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :   ASM_OUTPUT_DEBUG_LABEL (asm_out_file, EPILOGUE_BEGIN_LABEL,</span>
<span class="lineNum">    1158 </span>            :                           current_function_funcdef_no);
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 :   fde-&gt;dw_fde_vms_begin_epilogue = xstrdup (label);</span>
<span class="lineNum">    1160 </span>            : }
<span class="lineNum">    1161 </span>            : 
<span class="lineNum">    1162 </span>            : /* Output a marker (i.e. a label) for the absolute end of the generated code
<span class="lineNum">    1163 </span>            :    for a function definition.  This gets called *after* the epilogue code has
<span class="lineNum">    1164 </span>            :    been generated.  */
<a name="1165"><span class="lineNum">    1165 </span>            : </a>
<span class="lineNum">    1166 </span>            : void
<span class="lineNum">    1167 </span><span class="lineCov">     837002 : dwarf2out_end_epilogue (unsigned int line ATTRIBUTE_UNUSED,</span>
<span class="lineNum">    1168 </span>            :                         const char *file ATTRIBUTE_UNUSED)
<span class="lineNum">    1169 </span>            : {
<span class="lineNum">    1170 </span><span class="lineCov">     837002 :   dw_fde_ref fde;</span>
<span class="lineNum">    1171 </span><span class="lineCov">     837002 :   char label[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">    1172 </span>            : 
<span class="lineNum">    1173 </span><span class="lineCov">     837002 :   last_var_location_insn = NULL;</span>
<span class="lineNum">    1174 </span><span class="lineCov">     837002 :   cached_next_real_insn = NULL;</span>
<span class="lineNum">    1175 </span>            : 
<span class="lineNum">    1176 </span><span class="lineCov">     837002 :   if (dwarf2out_do_cfi_asm ())</span>
<span class="lineNum">    1177 </span><span class="lineCov">     836938 :     fprintf (asm_out_file, &quot;\t.cfi_endproc\n&quot;);</span>
<span class="lineNum">    1178 </span>            : 
<span class="lineNum">    1179 </span>            :   /* Output a label to mark the endpoint of the code generated for this
<span class="lineNum">    1180 </span>            :      function.  */
<span class="lineNum">    1181 </span><span class="lineCov">     837002 :   ASM_GENERATE_INTERNAL_LABEL (label, FUNC_END_LABEL,</span>
<span class="lineNum">    1182 </span>            :                                current_function_funcdef_no);
<span class="lineNum">    1183 </span><span class="lineCov">     837002 :   ASM_OUTPUT_LABEL (asm_out_file, label);</span>
<span class="lineNum">    1184 </span><span class="lineCov">     837002 :   fde = cfun-&gt;fde;</span>
<span class="lineNum">    1185 </span><span class="lineCov">     837002 :   gcc_assert (fde != NULL);</span>
<span class="lineNum">    1186 </span><span class="lineCov">     837002 :   if (fde-&gt;dw_fde_second_begin == NULL)</span>
<span class="lineNum">    1187 </span><span class="lineCov">     799562 :     fde-&gt;dw_fde_end = xstrdup (label);</span>
<span class="lineNum">    1188 </span><span class="lineCov">     837002 : }</span>
<a name="1189"><span class="lineNum">    1189 </span>            : </a>
<span class="lineNum">    1190 </span>            : void
<span class="lineNum">    1191 </span><span class="lineCov">     139750 : dwarf2out_frame_finish (void)</span>
<span class="lineNum">    1192 </span>            : {
<span class="lineNum">    1193 </span>            :   /* Output call frame information.  */
<span class="lineNum">    1194 </span><span class="lineCov">     139750 :   if (targetm.debug_unwind_info () == UI_DWARF2)</span>
<span class="lineNum">    1195 </span><span class="lineCov">      33687 :     output_call_frame_info (0);</span>
<span class="lineNum">    1196 </span>            : 
<span class="lineNum">    1197 </span>            :   /* Output another copy for the unwinder.  */
<span class="lineNum">    1198 </span><span class="lineCov">     139750 :   if (do_eh_frame)</span>
<span class="lineNum">    1199 </span><span class="lineCov">     129157 :     output_call_frame_info (1);</span>
<span class="lineNum">    1200 </span><span class="lineCov">     139750 : }</span>
<span class="lineNum">    1201 </span>            : 
<span class="lineNum">    1202 </span>            : /* Note that the current function section is being used for code.  */
<a name="1203"><span class="lineNum">    1203 </span>            : </a>
<span class="lineNum">    1204 </span>            : static void
<span class="lineNum">    1205 </span><span class="lineCov">     349403 : dwarf2out_note_section_used (void)</span>
<span class="lineNum">    1206 </span>            : {
<span class="lineNum">    1207 </span><span class="lineCov">     349403 :   section *sec = current_function_section ();</span>
<span class="lineNum">    1208 </span><span class="lineCov">     349403 :   if (sec == text_section)</span>
<span class="lineNum">    1209 </span><span class="lineCov">     215034 :     text_section_used = true;</span>
<span class="lineNum">    1210 </span><span class="lineCov">     134369 :   else if (sec == cold_text_section)</span>
<span class="lineNum">    1211 </span><span class="lineCov">       6638 :     cold_text_section_used = true;</span>
<span class="lineNum">    1212 </span><span class="lineCov">     349403 : }</span>
<span class="lineNum">    1213 </span>            : 
<span class="lineNum">    1214 </span>            : static void var_location_switch_text_section (void);
<span class="lineNum">    1215 </span>            : static void set_cur_line_info_table (section *);
<a name="1216"><span class="lineNum">    1216 </span>            : </a>
<span class="lineNum">    1217 </span>            : void
<span class="lineNum">    1218 </span><span class="lineCov">      37440 : dwarf2out_switch_text_section (void)</span>
<span class="lineNum">    1219 </span>            : {
<span class="lineNum">    1220 </span><span class="lineCov">      37440 :   char label[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">    1221 </span><span class="lineCov">      37440 :   section *sect;</span>
<span class="lineNum">    1222 </span><span class="lineCov">      37440 :   dw_fde_ref fde = cfun-&gt;fde;</span>
<span class="lineNum">    1223 </span>            : 
<span class="lineNum">    1224 </span><span class="lineCov">      37440 :   gcc_assert (cfun &amp;&amp; fde &amp;&amp; fde-&gt;dw_fde_second_begin == NULL);</span>
<span class="lineNum">    1225 </span>            : 
<span class="lineNum">    1226 </span><span class="lineCov">      37440 :   ASM_GENERATE_INTERNAL_LABEL (label, FUNC_SECOND_SECT_LABEL,</span>
<span class="lineNum">    1227 </span>            :                                current_function_funcdef_no);
<span class="lineNum">    1228 </span>            : 
<span class="lineNum">    1229 </span><span class="lineCov">      37440 :   fde-&gt;dw_fde_second_begin = ggc_strdup (label);</span>
<span class="lineNum">    1230 </span><span class="lineCov">      37440 :   if (!in_cold_section_p)</span>
<span class="lineNum">    1231 </span>            :     {
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :       fde-&gt;dw_fde_end = crtl-&gt;subsections.cold_section_end_label;</span>
<span class="lineNum">    1233 </span><span class="lineNoCov">          0 :       fde-&gt;dw_fde_second_end = crtl-&gt;subsections.hot_section_end_label;</span>
<span class="lineNum">    1234 </span>            :     }
<span class="lineNum">    1235 </span>            :   else
<span class="lineNum">    1236 </span>            :     {
<span class="lineNum">    1237 </span><span class="lineCov">      37440 :       fde-&gt;dw_fde_end = crtl-&gt;subsections.hot_section_end_label;</span>
<span class="lineNum">    1238 </span><span class="lineCov">      37440 :       fde-&gt;dw_fde_second_end = crtl-&gt;subsections.cold_section_end_label;</span>
<span class="lineNum">    1239 </span>            :     }
<span class="lineNum">    1240 </span><span class="lineCov">      37440 :   have_multiple_function_sections = true;</span>
<span class="lineNum">    1241 </span>            : 
<span class="lineNum">    1242 </span>            :   /* There is no need to mark used sections when not debugging.  */
<span class="lineNum">    1243 </span><span class="lineCov">      37440 :   if (cold_text_section != NULL)</span>
<span class="lineNum">    1244 </span><span class="lineCov">       9449 :     dwarf2out_note_section_used ();</span>
<span class="lineNum">    1245 </span>            : 
<span class="lineNum">    1246 </span><span class="lineCov">      37440 :   if (dwarf2out_do_cfi_asm ())</span>
<span class="lineNum">    1247 </span><span class="lineCov">      37422 :     fprintf (asm_out_file, &quot;\t.cfi_endproc\n&quot;);</span>
<span class="lineNum">    1248 </span>            : 
<span class="lineNum">    1249 </span>            :   /* Now do the real section switch.  */
<span class="lineNum">    1250 </span><span class="lineCov">      37440 :   sect = current_function_section ();</span>
<span class="lineNum">    1251 </span><span class="lineCov">      37440 :   switch_to_section (sect);</span>
<span class="lineNum">    1252 </span>            : 
<span class="lineNum">    1253 </span><span class="lineCov">      37440 :   fde-&gt;second_in_std_section</span>
<span class="lineNum">    1254 </span><span class="lineCov">      74880 :     = (sect == text_section</span>
<span class="lineNum">    1255 </span><span class="lineCov">      37440 :        || (cold_text_section &amp;&amp; sect == cold_text_section));</span>
<span class="lineNum">    1256 </span>            : 
<span class="lineNum">    1257 </span><span class="lineCov">      37440 :   if (dwarf2out_do_cfi_asm ())</span>
<span class="lineNum">    1258 </span><span class="lineCov">      37422 :     dwarf2out_do_cfi_startproc (true);</span>
<span class="lineNum">    1259 </span>            : 
<span class="lineNum">    1260 </span><span class="lineCov">      37440 :   var_location_switch_text_section ();</span>
<span class="lineNum">    1261 </span>            : 
<span class="lineNum">    1262 </span><span class="lineCov">      37440 :   if (cold_text_section != NULL)</span>
<span class="lineNum">    1263 </span><span class="lineCov">       9449 :     set_cur_line_info_table (sect);</span>
<span class="lineNum">    1264 </span><span class="lineCov">      37440 : }</span>
<span class="lineNum">    1265 </span>            : 
<span class="lineNum">    1266 </span>            : /* And now, the subset of the debugging information support code necessary
<span class="lineNum">    1267 </span>            :    for emitting location expressions.  */
<span class="lineNum">    1268 </span>            : 
<span class="lineNum">    1269 </span>            : /* Data about a single source file.  */
<span class="lineNum">    1270 </span>            : struct GTY((for_user)) dwarf_file_data {
<span class="lineNum">    1271 </span>            :   const char * filename;
<span class="lineNum">    1272 </span>            :   int emitted_number;
<span class="lineNum">    1273 </span>            : };
<span class="lineNum">    1274 </span>            : 
<span class="lineNum">    1275 </span>            : /* Describe an entry into the .debug_addr section.  */
<span class="lineNum">    1276 </span>            : 
<span class="lineNum">    1277 </span>            : enum ate_kind {
<span class="lineNum">    1278 </span>            :   ate_kind_rtx,
<span class="lineNum">    1279 </span>            :   ate_kind_rtx_dtprel,
<span class="lineNum">    1280 </span>            :   ate_kind_label
<span class="lineNum">    1281 </span>            : };
<span class="lineNum">    1282 </span>            : 
<span class="lineNum">    1283 </span>            : struct GTY((for_user)) addr_table_entry {
<span class="lineNum">    1284 </span>            :   enum ate_kind kind;
<span class="lineNum">    1285 </span>            :   unsigned int refcount;
<span class="lineNum">    1286 </span>            :   unsigned int index;
<span class="lineNum">    1287 </span>            :   union addr_table_entry_struct_union
<span class="lineNum">    1288 </span>            :     {
<span class="lineNum">    1289 </span>            :       rtx GTY ((tag (&quot;0&quot;))) rtl;
<span class="lineNum">    1290 </span>            :       char * GTY ((tag (&quot;1&quot;))) label;
<span class="lineNum">    1291 </span>            :     }
<span class="lineNum">    1292 </span>            :   GTY ((desc (&quot;%1.kind&quot;))) addr;
<span class="lineNum">    1293 </span>            : };
<span class="lineNum">    1294 </span>            : 
<span class="lineNum">    1295 </span>            : typedef unsigned int var_loc_view;
<span class="lineNum">    1296 </span>            : 
<span class="lineNum">    1297 </span>            : /* Location lists are ranges + location descriptions for that range,
<span class="lineNum">    1298 </span>            :    so you can track variables that are in different places over
<span class="lineNum">    1299 </span>            :    their entire life.  */
<span class="lineNum">    1300 </span>            : typedef struct GTY(()) dw_loc_list_struct {
<span class="lineNum">    1301 </span>            :   dw_loc_list_ref dw_loc_next;
<span class="lineNum">    1302 </span>            :   const char *begin; /* Label and addr_entry for start of range */
<span class="lineNum">    1303 </span>            :   addr_table_entry *begin_entry;
<span class="lineNum">    1304 </span>            :   const char *end;  /* Label for end of range */
<span class="lineNum">    1305 </span>            :   char *ll_symbol; /* Label for beginning of location list.
<span class="lineNum">    1306 </span>            :                       Only on head of list.  */
<span class="lineNum">    1307 </span>            :   char *vl_symbol; /* Label for beginning of view list.  Ditto.  */
<span class="lineNum">    1308 </span>            :   const char *section; /* Section this loclist is relative to */
<span class="lineNum">    1309 </span>            :   dw_loc_descr_ref expr;
<span class="lineNum">    1310 </span>            :   var_loc_view vbegin, vend;
<span class="lineNum">    1311 </span>            :   hashval_t hash;
<span class="lineNum">    1312 </span>            :   /* True if all addresses in this and subsequent lists are known to be
<span class="lineNum">    1313 </span>            :      resolved.  */
<span class="lineNum">    1314 </span>            :   bool resolved_addr;
<span class="lineNum">    1315 </span>            :   /* True if this list has been replaced by dw_loc_next.  */
<span class="lineNum">    1316 </span>            :   bool replaced;
<span class="lineNum">    1317 </span>            :   /* True if it has been emitted into .debug_loc* / .debug_loclists*
<span class="lineNum">    1318 </span>            :      section.  */
<span class="lineNum">    1319 </span>            :   unsigned char emitted : 1;
<span class="lineNum">    1320 </span>            :   /* True if hash field is index rather than hash value.  */
<span class="lineNum">    1321 </span>            :   unsigned char num_assigned : 1;
<span class="lineNum">    1322 </span>            :   /* True if .debug_loclists.dwo offset has been emitted for it already.  */
<span class="lineNum">    1323 </span>            :   unsigned char offset_emitted : 1;
<span class="lineNum">    1324 </span>            :   /* True if note_variable_value_in_expr has been called on it.  */
<span class="lineNum">    1325 </span>            :   unsigned char noted_variable_value : 1;
<span class="lineNum">    1326 </span>            :   /* True if the range should be emitted even if begin and end
<span class="lineNum">    1327 </span>            :      are the same.  */
<span class="lineNum">    1328 </span>            :   bool force;
<span class="lineNum">    1329 </span>            : } dw_loc_list_node;
<span class="lineNum">    1330 </span>            : 
<span class="lineNum">    1331 </span>            : static dw_loc_descr_ref int_loc_descriptor (poly_int64);
<span class="lineNum">    1332 </span>            : static dw_loc_descr_ref uint_loc_descriptor (unsigned HOST_WIDE_INT);
<span class="lineNum">    1333 </span>            : 
<span class="lineNum">    1334 </span>            : /* Convert a DWARF stack opcode into its string name.  */
<a name="1335"><span class="lineNum">    1335 </span>            : </a>
<span class="lineNum">    1336 </span>            : static const char *
<span class="lineNum">    1337 </span><span class="lineNoCov">          0 : dwarf_stack_op_name (unsigned int op)</span>
<span class="lineNum">    1338 </span>            : {
<span class="lineNum">    1339 </span><span class="lineNoCov">          0 :   const char *name = get_DW_OP_name (op);</span>
<span class="lineNum">    1340 </span>            : 
<span class="lineNum">    1341 </span><span class="lineCov">   35250763 :   if (name != NULL)</span>
<span class="lineNum">    1342 </span><span class="lineCov">   35250763 :     return name;</span>
<span class="lineNum">    1343 </span>            : 
<span class="lineNum">    1344 </span>            :   return &quot;OP_&lt;unknown&gt;&quot;;
<span class="lineNum">    1345 </span>            : }
<span class="lineNum">    1346 </span>            : 
<span class="lineNum">    1347 </span>            : /* Return TRUE iff we're to output location view lists as a separate
<span class="lineNum">    1348 </span>            :    attribute next to the location lists, as an extension compatible
<span class="lineNum">    1349 </span>            :    with DWARF 2 and above.  */
<span class="lineNum">    1350 </span>            : 
<span class="lineNum">    1351 </span>            : static inline bool
<span class="lineNum">    1352 </span>            : dwarf2out_locviews_in_attribute ()
<span class="lineNum">    1353 </span>            : {
<span class="lineNum">    1354 </span><span class="lineCov">   29361471 :   return debug_variable_location_views == 1;</span>
<span class="lineNum">    1355 </span>            : }
<span class="lineNum">    1356 </span>            : 
<span class="lineNum">    1357 </span>            : /* Return TRUE iff we're to output location view lists as part of the
<span class="lineNum">    1358 </span>            :    location lists, as proposed for standardization after DWARF 5.  */
<span class="lineNum">    1359 </span>            : 
<span class="lineNum">    1360 </span>            : static inline bool
<span class="lineNum">    1361 </span>            : dwarf2out_locviews_in_loclist ()
<span class="lineNum">    1362 </span>            : {
<span class="lineNum">    1363 </span>            : #ifndef DW_LLE_view_pair
<span class="lineNum">    1364 </span>            :   return false;
<span class="lineNum">    1365 </span>            : #else
<span class="lineNum">    1366 </span><span class="lineCov">         27 :   return debug_variable_location_views == -1;</span>
<span class="lineNum">    1367 </span>            : #endif
<span class="lineNum">    1368 </span>            : }
<span class="lineNum">    1369 </span>            : 
<span class="lineNum">    1370 </span>            : /* Return a pointer to a newly allocated location description.  Location
<span class="lineNum">    1371 </span>            :    descriptions are simple expression terms that can be strung
<span class="lineNum">    1372 </span>            :    together to form more complicated location (address) descriptions.  */
<a name="1373"><span class="lineNum">    1373 </span>            : </a>
<span class="lineNum">    1374 </span>            : static inline dw_loc_descr_ref
<span class="lineNum">    1375 </span><span class="lineCov">   38477653 : new_loc_descr (enum dwarf_location_atom op, unsigned HOST_WIDE_INT oprnd1,</span>
<span class="lineNum">    1376 </span>            :                unsigned HOST_WIDE_INT oprnd2)
<span class="lineNum">    1377 </span>            : {
<span class="lineNum">    1378 </span><span class="lineCov">   38477653 :   dw_loc_descr_ref descr = ggc_cleared_alloc&lt;dw_loc_descr_node&gt; ();</span>
<span class="lineNum">    1379 </span>            : 
<span class="lineNum">    1380 </span><span class="lineCov">   38477653 :   descr-&gt;dw_loc_opc = op;</span>
<span class="lineNum">    1381 </span><span class="lineCov">   38477653 :   descr-&gt;dw_loc_oprnd1.val_class = dw_val_class_unsigned_const;</span>
<span class="lineNum">    1382 </span><span class="lineCov">   38477653 :   descr-&gt;dw_loc_oprnd1.val_entry = NULL;</span>
<span class="lineNum">    1383 </span><span class="lineCov">   38477653 :   descr-&gt;dw_loc_oprnd1.v.val_unsigned = oprnd1;</span>
<span class="lineNum">    1384 </span><span class="lineCov">   38477653 :   descr-&gt;dw_loc_oprnd2.val_class = dw_val_class_unsigned_const;</span>
<span class="lineNum">    1385 </span><span class="lineCov">   38477653 :   descr-&gt;dw_loc_oprnd2.val_entry = NULL;</span>
<span class="lineNum">    1386 </span><span class="lineCov">   38477653 :   descr-&gt;dw_loc_oprnd2.v.val_unsigned = oprnd2;</span>
<span class="lineNum">    1387 </span>            : 
<span class="lineNum">    1388 </span><span class="lineCov">   38477653 :   return descr;</span>
<span class="lineNum">    1389 </span>            : }
<span class="lineNum">    1390 </span>            : 
<span class="lineNum">    1391 </span>            : /* Add a location description term to a location description expression.  */
<a name="1392"><span class="lineNum">    1392 </span>            : </a>
<span class="lineNum">    1393 </span>            : static inline void
<span class="lineNum">    1394 </span><span class="lineCov">    9387098 : add_loc_descr (dw_loc_descr_ref *list_head, dw_loc_descr_ref descr)</span>
<span class="lineNum">    1395 </span>            : {
<span class="lineNum">    1396 </span><span class="lineCov">    9810388 :   dw_loc_descr_ref *d;</span>
<span class="lineNum">    1397 </span>            : 
<span class="lineNum">    1398 </span>            :   /* Find the end of the chain.  */
<span class="lineNum">    1399 </span><span class="lineCov">   42463190 :   for (d = list_head; (*d) != NULL; d = &amp;(*d)-&gt;dw_loc_next)</span>
<span class="lineNum">    1400 </span>            :     ;
<span class="lineNum">    1401 </span>            : 
<span class="lineNum">    1402 </span><span class="lineCov">      90961 :   *d = descr;</span>
<span class="lineNum">    1403 </span><span class="lineCov">    9387098 : }</span>
<span class="lineNum">    1404 </span>            : 
<span class="lineNum">    1405 </span>            : /* Compare two location operands for exact equality.  */
<a name="1406"><span class="lineNum">    1406 </span>            : </a>
<span class="lineNum">    1407 </span>            : static bool
<span class="lineNum">    1408 </span><span class="lineCov">        106 : dw_val_equal_p (dw_val_node *a, dw_val_node *b)</span>
<span class="lineNum">    1409 </span>            : {
<span class="lineNum">    1410 </span><span class="lineCov">        106 :   if (a-&gt;val_class != b-&gt;val_class)</span>
<span class="lineNum">    1411 </span>            :     return false;
<span class="lineNum">    1412 </span><span class="lineCov">        106 :   switch (a-&gt;val_class)</span>
<span class="lineNum">    1413 </span>            :     {
<span class="lineNum">    1414 </span>            :     case dw_val_class_none:
<span class="lineNum">    1415 </span>            :       return true;
<span class="lineNum">    1416 </span><span class="lineNoCov">          0 :     case dw_val_class_addr:</span>
<span class="lineNum">    1417 </span><span class="lineNoCov">          0 :       return rtx_equal_p (a-&gt;v.val_addr, b-&gt;v.val_addr);</span>
<span class="lineNum">    1418 </span>            : 
<span class="lineNum">    1419 </span><span class="lineCov">         64 :     case dw_val_class_offset:</span>
<span class="lineNum">    1420 </span><span class="lineCov">         64 :     case dw_val_class_unsigned_const:</span>
<span class="lineNum">    1421 </span><span class="lineCov">         64 :     case dw_val_class_const:</span>
<span class="lineNum">    1422 </span><span class="lineCov">         64 :     case dw_val_class_unsigned_const_implicit:</span>
<span class="lineNum">    1423 </span><span class="lineCov">         64 :     case dw_val_class_const_implicit:</span>
<span class="lineNum">    1424 </span><span class="lineCov">         64 :     case dw_val_class_range_list:</span>
<span class="lineNum">    1425 </span>            :       /* These are all HOST_WIDE_INT, signed or unsigned.  */
<span class="lineNum">    1426 </span><span class="lineCov">         64 :       return a-&gt;v.val_unsigned == b-&gt;v.val_unsigned;</span>
<span class="lineNum">    1427 </span>            : 
<span class="lineNum">    1428 </span><span class="lineNoCov">          0 :     case dw_val_class_loc:</span>
<span class="lineNum">    1429 </span><span class="lineNoCov">          0 :       return a-&gt;v.val_loc == b-&gt;v.val_loc;</span>
<span class="lineNum">    1430 </span><span class="lineNoCov">          0 :     case dw_val_class_loc_list:</span>
<span class="lineNum">    1431 </span><span class="lineNoCov">          0 :       return a-&gt;v.val_loc_list == b-&gt;v.val_loc_list;</span>
<span class="lineNum">    1432 </span><span class="lineNoCov">          0 :     case dw_val_class_view_list:</span>
<span class="lineNum">    1433 </span><span class="lineNoCov">          0 :       return a-&gt;v.val_view_list == b-&gt;v.val_view_list;</span>
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 :     case dw_val_class_die_ref:</span>
<span class="lineNum">    1435 </span><span class="lineNoCov">          0 :       return a-&gt;v.val_die_ref.die == b-&gt;v.val_die_ref.die;</span>
<span class="lineNum">    1436 </span><span class="lineNoCov">          0 :     case dw_val_class_fde_ref:</span>
<span class="lineNum">    1437 </span><span class="lineNoCov">          0 :       return a-&gt;v.val_fde_index == b-&gt;v.val_fde_index;</span>
<span class="lineNum">    1438 </span><span class="lineNoCov">          0 :     case dw_val_class_symview:</span>
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 :       return strcmp (a-&gt;v.val_symbolic_view, b-&gt;v.val_symbolic_view) == 0;</span>
<span class="lineNum">    1440 </span><span class="lineNoCov">          0 :     case dw_val_class_lbl_id:</span>
<span class="lineNum">    1441 </span><span class="lineNoCov">          0 :     case dw_val_class_lineptr:</span>
<span class="lineNum">    1442 </span><span class="lineNoCov">          0 :     case dw_val_class_macptr:</span>
<span class="lineNum">    1443 </span><span class="lineNoCov">          0 :     case dw_val_class_loclistsptr:</span>
<span class="lineNum">    1444 </span><span class="lineNoCov">          0 :     case dw_val_class_high_pc:</span>
<span class="lineNum">    1445 </span><span class="lineNoCov">          0 :       return strcmp (a-&gt;v.val_lbl_id, b-&gt;v.val_lbl_id) == 0;</span>
<span class="lineNum">    1446 </span><span class="lineNoCov">          0 :     case dw_val_class_str:</span>
<span class="lineNum">    1447 </span><span class="lineNoCov">          0 :       return a-&gt;v.val_str == b-&gt;v.val_str;</span>
<span class="lineNum">    1448 </span><span class="lineNoCov">          0 :     case dw_val_class_flag:</span>
<span class="lineNum">    1449 </span><span class="lineNoCov">          0 :       return a-&gt;v.val_flag == b-&gt;v.val_flag;</span>
<span class="lineNum">    1450 </span><span class="lineCov">         42 :     case dw_val_class_file:</span>
<span class="lineNum">    1451 </span><span class="lineCov">         42 :     case dw_val_class_file_implicit:</span>
<span class="lineNum">    1452 </span><span class="lineCov">         42 :       return a-&gt;v.val_file == b-&gt;v.val_file;</span>
<span class="lineNum">    1453 </span><span class="lineNoCov">          0 :     case dw_val_class_decl_ref:</span>
<span class="lineNum">    1454 </span><span class="lineNoCov">          0 :       return a-&gt;v.val_decl_ref == b-&gt;v.val_decl_ref;</span>
<span class="lineNum">    1455 </span>            :     
<span class="lineNum">    1456 </span><span class="lineNoCov">          0 :     case dw_val_class_const_double:</span>
<span class="lineNum">    1457 </span><span class="lineNoCov">          0 :       return (a-&gt;v.val_double.high == b-&gt;v.val_double.high</span>
<span class="lineNum">    1458 </span><span class="lineNoCov">          0 :               &amp;&amp; a-&gt;v.val_double.low == b-&gt;v.val_double.low);</span>
<span class="lineNum">    1459 </span>            : 
<span class="lineNum">    1460 </span><span class="lineNoCov">          0 :     case dw_val_class_wide_int:</span>
<span class="lineNum">    1461 </span><span class="lineNoCov">          0 :       return *a-&gt;v.val_wide == *b-&gt;v.val_wide;</span>
<span class="lineNum">    1462 </span>            : 
<span class="lineNum">    1463 </span><span class="lineNoCov">          0 :     case dw_val_class_vec:</span>
<span class="lineNum">    1464 </span><span class="lineNoCov">          0 :       {</span>
<span class="lineNum">    1465 </span><span class="lineNoCov">          0 :         size_t a_len = a-&gt;v.val_vec.elt_size * a-&gt;v.val_vec.length;</span>
<span class="lineNum">    1466 </span><span class="lineNoCov">          0 :         size_t b_len = b-&gt;v.val_vec.elt_size * b-&gt;v.val_vec.length;</span>
<span class="lineNum">    1467 </span>            : 
<span class="lineNum">    1468 </span><span class="lineNoCov">          0 :         return (a_len == b_len</span>
<span class="lineNum">    1469 </span><span class="lineNoCov">          0 :                 &amp;&amp; !memcmp (a-&gt;v.val_vec.array, b-&gt;v.val_vec.array, a_len));</span>
<span class="lineNum">    1470 </span>            :       }
<span class="lineNum">    1471 </span>            : 
<span class="lineNum">    1472 </span><span class="lineNoCov">          0 :     case dw_val_class_data8:</span>
<span class="lineNum">    1473 </span><span class="lineNoCov">          0 :       return memcmp (a-&gt;v.val_data8, b-&gt;v.val_data8, 8) == 0;</span>
<span class="lineNum">    1474 </span>            : 
<span class="lineNum">    1475 </span><span class="lineNoCov">          0 :     case dw_val_class_vms_delta:</span>
<span class="lineNum">    1476 </span><span class="lineNoCov">          0 :       return (!strcmp (a-&gt;v.val_vms_delta.lbl1, b-&gt;v.val_vms_delta.lbl1)</span>
<span class="lineNum">    1477 </span><span class="lineNoCov">          0 :               &amp;&amp; !strcmp (a-&gt;v.val_vms_delta.lbl1, b-&gt;v.val_vms_delta.lbl1));</span>
<span class="lineNum">    1478 </span>            : 
<span class="lineNum">    1479 </span><span class="lineNoCov">          0 :     case dw_val_class_discr_value:</span>
<span class="lineNum">    1480 </span><span class="lineNoCov">          0 :       return (a-&gt;v.val_discr_value.pos == b-&gt;v.val_discr_value.pos</span>
<span class="lineNum">    1481 </span><span class="lineNoCov">          0 :               &amp;&amp; a-&gt;v.val_discr_value.v.uval == b-&gt;v.val_discr_value.v.uval);</span>
<span class="lineNum">    1482 </span><span class="lineNoCov">          0 :     case dw_val_class_discr_list:</span>
<span class="lineNum">    1483 </span>            :       /* It makes no sense comparing two discriminant value lists.  */
<span class="lineNum">    1484 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    1485 </span>            :     }
<span class="lineNum">    1486 </span><span class="lineNoCov">          0 :   gcc_unreachable ();</span>
<span class="lineNum">    1487 </span>            : }
<span class="lineNum">    1488 </span>            : 
<span class="lineNum">    1489 </span>            : /* Compare two location atoms for exact equality.  */
<a name="1490"><span class="lineNum">    1490 </span>            : </a>
<span class="lineNum">    1491 </span>            : static bool
<span class="lineNum">    1492 </span><span class="lineNoCov">          0 : loc_descr_equal_p_1 (dw_loc_descr_ref a, dw_loc_descr_ref b)</span>
<span class="lineNum">    1493 </span>            : {
<span class="lineNum">    1494 </span><span class="lineNoCov">          0 :   if (a-&gt;dw_loc_opc != b-&gt;dw_loc_opc)</span>
<span class="lineNum">    1495 </span>            :     return false;
<span class="lineNum">    1496 </span>            : 
<span class="lineNum">    1497 </span>            :   /* ??? This is only ever set for DW_OP_constNu, for N equal to the
<span class="lineNum">    1498 </span>            :      address size, but since we always allocate cleared storage it
<span class="lineNum">    1499 </span>            :      should be zero for other types of locations.  */
<span class="lineNum">    1500 </span><span class="lineNoCov">          0 :   if (a-&gt;dtprel != b-&gt;dtprel)</span>
<span class="lineNum">    1501 </span>            :     return false;
<span class="lineNum">    1502 </span>            : 
<span class="lineNum">    1503 </span><span class="lineNoCov">          0 :   return (dw_val_equal_p (&amp;a-&gt;dw_loc_oprnd1, &amp;b-&gt;dw_loc_oprnd1)</span>
<span class="lineNum">    1504 </span><span class="lineNoCov">          0 :           &amp;&amp; dw_val_equal_p (&amp;a-&gt;dw_loc_oprnd2, &amp;b-&gt;dw_loc_oprnd2));</span>
<span class="lineNum">    1505 </span>            : }
<span class="lineNum">    1506 </span>            : 
<span class="lineNum">    1507 </span>            : /* Compare two complete location expressions for exact equality.  */
<a name="1508"><span class="lineNum">    1508 </span>            : </a>
<span class="lineNum">    1509 </span>            : bool
<span class="lineNum">    1510 </span><span class="lineNoCov">          0 : loc_descr_equal_p (dw_loc_descr_ref a, dw_loc_descr_ref b)</span>
<span class="lineNum">    1511 </span>            : {
<span class="lineNum">    1512 </span><span class="lineNoCov">          0 :   while (1)</span>
<span class="lineNum">    1513 </span>            :     {
<span class="lineNum">    1514 </span><span class="lineNoCov">          0 :       if (a == b)</span>
<span class="lineNum">    1515 </span>            :         return true;
<span class="lineNum">    1516 </span><span class="lineNoCov">          0 :       if (a == NULL || b == NULL)</span>
<span class="lineNum">    1517 </span>            :         return false;
<span class="lineNum">    1518 </span><span class="lineNoCov">          0 :       if (!loc_descr_equal_p_1 (a, b))</span>
<span class="lineNum">    1519 </span>            :         return false;
<span class="lineNum">    1520 </span>            : 
<span class="lineNum">    1521 </span><span class="lineNoCov">          0 :       a = a-&gt;dw_loc_next;</span>
<span class="lineNum">    1522 </span><span class="lineNoCov">          0 :       b = b-&gt;dw_loc_next;</span>
<span class="lineNum">    1523 </span>            :     }
<span class="lineNum">    1524 </span>            : }
<span class="lineNum">    1525 </span>            : 
<span class="lineNum">    1526 </span>            : 
<span class="lineNum">    1527 </span>            : /* Add a constant POLY_OFFSET to a location expression.  */
<a name="1528"><span class="lineNum">    1528 </span>            : </a>
<span class="lineNum">    1529 </span>            : static void
<span class="lineNum">    1530 </span><span class="lineCov">     503917 : loc_descr_plus_const (dw_loc_descr_ref *list_head, poly_int64 poly_offset)</span>
<span class="lineNum">    1531 </span>            : {
<span class="lineNum">    1532 </span><span class="lineCov">     503917 :   dw_loc_descr_ref loc;</span>
<span class="lineNum">    1533 </span><span class="lineCov">     503917 :   HOST_WIDE_INT *p;</span>
<span class="lineNum">    1534 </span>            : 
<span class="lineNum">    1535 </span><span class="lineCov">     503917 :   gcc_assert (*list_head != NULL);</span>
<span class="lineNum">    1536 </span>            : 
<span class="lineNum">    1537 </span><span class="lineCov">     503917 :   if (known_eq (poly_offset, 0))</span>
<span class="lineNum">    1538 </span>            :     return;
<span class="lineNum">    1539 </span>            : 
<span class="lineNum">    1540 </span>            :   /* Find the end of the chain.  */
<span class="lineNum">    1541 </span><span class="lineCov">    1426773 :   for (loc = *list_head; loc-&gt;dw_loc_next != NULL; loc = loc-&gt;dw_loc_next)</span>
<span class="lineNum">    1542 </span>            :     ;
<span class="lineNum">    1543 </span>            : 
<span class="lineNum">    1544 </span><span class="lineCov">     498313 :   HOST_WIDE_INT offset;</span>
<span class="lineNum">    1545 </span><span class="lineCov">     498313 :   if (!poly_offset.is_constant (&amp;offset))</span>
<span class="lineNum">    1546 </span>            :     {
<span class="lineNum">    1547 </span>            :       loc-&gt;dw_loc_next = int_loc_descriptor (poly_offset);
<span class="lineNum">    1548 </span>            :       add_loc_descr (&amp;loc-&gt;dw_loc_next, new_loc_descr (DW_OP_plus, 0, 0));
<span class="lineNum">    1549 </span>            :       return;
<span class="lineNum">    1550 </span>            :     }
<span class="lineNum">    1551 </span>            : 
<span class="lineNum">    1552 </span><span class="lineCov">     498313 :   p = NULL;</span>
<span class="lineNum">    1553 </span><span class="lineCov">     498313 :   if (loc-&gt;dw_loc_opc == DW_OP_fbreg</span>
<span class="lineNum">    1554 </span><span class="lineCov">     498313 :       || (loc-&gt;dw_loc_opc &gt;= DW_OP_breg0 &amp;&amp; loc-&gt;dw_loc_opc &lt;= DW_OP_breg31))</span>
<span class="lineNum">    1555 </span><span class="lineNoCov">          0 :     p = &amp;loc-&gt;dw_loc_oprnd1.v.val_int;</span>
<span class="lineNum">    1556 </span><span class="lineCov">     498313 :   else if (loc-&gt;dw_loc_opc == DW_OP_bregx)</span>
<span class="lineNum">    1557 </span><span class="lineNoCov">          0 :     p = &amp;loc-&gt;dw_loc_oprnd2.v.val_int;</span>
<span class="lineNum">    1558 </span>            : 
<span class="lineNum">    1559 </span>            :   /* If the last operation is fbreg, breg{0..31,x}, optimize by adjusting its
<span class="lineNum">    1560 </span>            :      offset.  Don't optimize if an signed integer overflow would happen.  */
<span class="lineNum">    1561 </span><span class="lineNoCov">          0 :   if (p != NULL</span>
<span class="lineNum">    1562 </span><span class="lineNoCov">          0 :       &amp;&amp; ((offset &gt; 0 &amp;&amp; *p &lt;= INTTYPE_MAXIMUM (HOST_WIDE_INT) - offset)</span>
<span class="lineNum">    1563 </span><span class="lineNoCov">          0 :           || (offset &lt; 0 &amp;&amp; *p &gt;= INTTYPE_MINIMUM (HOST_WIDE_INT) - offset)))</span>
<span class="lineNum">    1564 </span><span class="lineNoCov">          0 :     *p += offset;</span>
<span class="lineNum">    1565 </span>            : 
<span class="lineNum">    1566 </span><span class="lineCov">     498313 :   else if (offset &gt; 0)</span>
<span class="lineNum">    1567 </span><span class="lineCov">     423806 :     loc-&gt;dw_loc_next = new_loc_descr (DW_OP_plus_uconst, offset, 0);</span>
<span class="lineNum">    1568 </span>            : 
<span class="lineNum">    1569 </span>            :   else
<span class="lineNum">    1570 </span>            :     {
<span class="lineNum">    1571 </span><span class="lineCov">      74507 :       loc-&gt;dw_loc_next</span>
<span class="lineNum">    1572 </span><span class="lineCov">      74507 :         = uint_loc_descriptor (-(unsigned HOST_WIDE_INT) offset);</span>
<span class="lineNum">    1573 </span><span class="lineCov">      74507 :       add_loc_descr (&amp;loc-&gt;dw_loc_next, new_loc_descr (DW_OP_minus, 0, 0));</span>
<span class="lineNum">    1574 </span>            :     }
<span class="lineNum">    1575 </span>            : }
<span class="lineNum">    1576 </span>            : 
<span class="lineNum">    1577 </span>            : /* Return a pointer to a newly allocated location description for
<span class="lineNum">    1578 </span>            :    REG and OFFSET.  */
<a name="1579"><span class="lineNum">    1579 </span>            : </a>
<span class="lineNum">    1580 </span>            : static inline dw_loc_descr_ref
<span class="lineNum">    1581 </span><span class="lineCov">    3996639 : new_reg_loc_descr (unsigned int reg, poly_int64 offset)</span>
<span class="lineNum">    1582 </span>            : {
<span class="lineNum">    1583 </span><span class="lineCov">    3996639 :   HOST_WIDE_INT const_offset;</span>
<span class="lineNum">    1584 </span><span class="lineCov">    3996639 :   if (offset.is_constant (&amp;const_offset))</span>
<span class="lineNum">    1585 </span>            :     {
<span class="lineNum">    1586 </span><span class="lineCov">    3996639 :       if (reg &lt;= 31)</span>
<span class="lineNum">    1587 </span><span class="lineCov">    3996639 :         return new_loc_descr ((enum dwarf_location_atom) (DW_OP_breg0 + reg),</span>
<span class="lineNum">    1588 </span><span class="lineCov">    3996639 :                               const_offset, 0);</span>
<span class="lineNum">    1589 </span>            :       else
<span class="lineNum">    1590 </span><span class="lineNoCov">          0 :         return new_loc_descr (DW_OP_bregx, reg, const_offset);</span>
<span class="lineNum">    1591 </span>            :     }
<span class="lineNum">    1592 </span>            :   else
<span class="lineNum">    1593 </span>            :     {
<span class="lineNum">    1594 </span>            :       dw_loc_descr_ref ret = new_reg_loc_descr (reg, 0);
<span class="lineNum">    1595 </span>            :       loc_descr_plus_const (&amp;ret, offset);
<span class="lineNum">    1596 </span>            :       return ret;
<span class="lineNum">    1597 </span>            :     }
<span class="lineNum">    1598 </span>            : }
<span class="lineNum">    1599 </span>            : 
<span class="lineNum">    1600 </span>            : /* Add a constant OFFSET to a location list.  */
<a name="1601"><span class="lineNum">    1601 </span>            : </a>
<span class="lineNum">    1602 </span>            : static void
<span class="lineNum">    1603 </span><span class="lineNoCov">          0 : loc_list_plus_const (dw_loc_list_ref list_head, poly_int64 offset)</span>
<span class="lineNum">    1604 </span>            : {
<span class="lineNum">    1605 </span><span class="lineNoCov">          0 :   dw_loc_list_ref d;</span>
<span class="lineNum">    1606 </span><span class="lineCov">     122004 :   for (d = list_head; d != NULL; d = d-&gt;dw_loc_next)</span>
<span class="lineNum">    1607 </span><span class="lineCov">      61002 :     loc_descr_plus_const (&amp;d-&gt;expr, offset);</span>
<span class="lineNum">    1608 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1609 </span>            : 
<span class="lineNum">    1610 </span>            : #define DWARF_REF_SIZE  \
<span class="lineNum">    1611 </span>            :   (dwarf_version == 2 ? DWARF2_ADDR_SIZE : DWARF_OFFSET_SIZE)
<span class="lineNum">    1612 </span>            : 
<span class="lineNum">    1613 </span>            : /* The number of bits that can be encoded by largest DW_FORM_dataN.
<span class="lineNum">    1614 </span>            :    In DWARF4 and earlier it is DW_FORM_data8 with 64 bits, in DWARF5
<span class="lineNum">    1615 </span>            :    DW_FORM_data16 with 128 bits.  */
<span class="lineNum">    1616 </span>            : #define DWARF_LARGEST_DATA_FORM_BITS \
<span class="lineNum">    1617 </span>            :   (dwarf_version &gt;= 5 ? 128 : 64)
<span class="lineNum">    1618 </span>            : 
<span class="lineNum">    1619 </span>            : /* Utility inline function for construction of ops that were GNU extension
<a name="1620"><span class="lineNum">    1620 </span>            :    before DWARF 5.  */</a>
<span class="lineNum">    1621 </span>            : static inline enum dwarf_location_atom
<span class="lineNum">    1622 </span><span class="lineCov">    1085929 : dwarf_OP (enum dwarf_location_atom op)</span>
<span class="lineNum">    1623 </span>            : {
<span class="lineNum">    1624 </span><span class="lineCov">    1085929 :   switch (op)</span>
<span class="lineNum">    1625 </span>            :     {
<span class="lineNum">    1626 </span><span class="lineCov">    2429776 :     case DW_OP_implicit_pointer:</span>
<span class="lineNum">    1627 </span><span class="lineNoCov">          0 :       if (dwarf_version &lt; 5)</span>
<span class="lineNum">    1628 </span><span class="lineCov">    2429776 :         return DW_OP_GNU_implicit_pointer;</span>
<span class="lineNum">    1629 </span>            :       break;
<span class="lineNum">    1630 </span>            : 
<span class="lineNum">    1631 </span><span class="lineCov">     864061 :     case DW_OP_entry_value:</span>
<span class="lineNum">    1632 </span><span class="lineCov">     864061 :       if (dwarf_version &lt; 5)</span>
<span class="lineNum">    1633 </span><span class="lineCov">     864058 :         return DW_OP_GNU_entry_value;</span>
<span class="lineNum">    1634 </span>            :       break;
<span class="lineNum">    1635 </span>            : 
<span class="lineNum">    1636 </span><span class="lineCov">      49292 :     case DW_OP_const_type:</span>
<span class="lineNum">    1637 </span><span class="lineCov">      49292 :       if (dwarf_version &lt; 5)</span>
<span class="lineNum">    1638 </span><span class="lineCov">      49292 :         return DW_OP_GNU_const_type;</span>
<span class="lineNum">    1639 </span>            :       break;
<span class="lineNum">    1640 </span>            : 
<span class="lineNum">    1641 </span><span class="lineCov">      45016 :     case DW_OP_regval_type:</span>
<span class="lineNum">    1642 </span><span class="lineCov">      45016 :       if (dwarf_version &lt; 5)</span>
<span class="lineNum">    1643 </span><span class="lineCov">      45016 :         return DW_OP_GNU_regval_type;</span>
<span class="lineNum">    1644 </span>            :       break;
<span class="lineNum">    1645 </span>            : 
<span class="lineNum">    1646 </span><span class="lineCov">      53640 :     case DW_OP_deref_type:</span>
<span class="lineNum">    1647 </span><span class="lineCov">      53640 :       if (dwarf_version &lt; 5)</span>
<span class="lineNum">    1648 </span><span class="lineCov">      53640 :         return DW_OP_GNU_deref_type;</span>
<span class="lineNum">    1649 </span>            :       break;
<span class="lineNum">    1650 </span>            : 
<span class="lineNum">    1651 </span><span class="lineCov">      82353 :     case DW_OP_convert:</span>
<span class="lineNum">    1652 </span><span class="lineCov">      73049 :       if (dwarf_version &lt; 5)</span>
<span class="lineNum">    1653 </span><span class="lineCov">      78589 :         return DW_OP_GNU_convert;</span>
<span class="lineNum">    1654 </span>            :       break;
<span class="lineNum">    1655 </span>            : 
<span class="lineNum">    1656 </span><span class="lineCov">        871 :     case DW_OP_reinterpret:</span>
<span class="lineNum">    1657 </span><span class="lineCov">        871 :       if (dwarf_version &lt; 5)</span>
<span class="lineNum">    1658 </span><span class="lineCov">        871 :         return DW_OP_GNU_reinterpret;</span>
<span class="lineNum">    1659 </span>            :       break;
<span class="lineNum">    1660 </span>            : 
<span class="lineNum">    1661 </span><span class="lineCov">         14 :     case DW_OP_addrx:</span>
<span class="lineNum">    1662 </span><span class="lineNoCov">          0 :       if (dwarf_version &lt; 5)</span>
<span class="lineNum">    1663 </span><span class="lineCov">          7 :         return DW_OP_GNU_addr_index;</span>
<span class="lineNum">    1664 </span>            :       break;
<span class="lineNum">    1665 </span>            : 
<span class="lineNum">    1666 </span><span class="lineNoCov">          0 :     case DW_OP_constx:</span>
<span class="lineNum">    1667 </span><span class="lineNoCov">          0 :       if (dwarf_version &lt; 5)</span>
<span class="lineNum">    1668 </span><span class="lineNoCov">          0 :         return DW_OP_GNU_const_index;</span>
<span class="lineNum">    1669 </span>            :       break;
<span class="lineNum">    1670 </span>            : 
<span class="lineNum">    1671 </span>            :     default:
<span class="lineNum">    1672 </span>            :       break;
<span class="lineNum">    1673 </span>            :     }
<span class="lineNum">    1674 </span>            :   return op;
<span class="lineNum">    1675 </span>            : }
<span class="lineNum">    1676 </span>            : 
<span class="lineNum">    1677 </span>            : /* Similarly for attributes.  */
<span class="lineNum">    1678 </span>            : static inline enum dwarf_attribute
<span class="lineNum">    1679 </span>            : dwarf_AT (enum dwarf_attribute at)
<span class="lineNum">    1680 </span>            : {
<span class="lineNum">    1681 </span><span class="lineCov">    6115460 :   switch (at)</span>
<span class="lineNum">    1682 </span>            :     {
<span class="lineNum">    1683 </span><span class="lineCov">    1914914 :     case DW_AT_call_return_pc:</span>
<span class="lineNum">    1684 </span><span class="lineCov">    1914914 :       if (dwarf_version &lt; 5)</span>
<span class="lineNum">    1685 </span><span class="lineCov">    1914911 :         return DW_AT_low_pc;</span>
<span class="lineNum">    1686 </span>            :       break;
<span class="lineNum">    1687 </span>            : 
<span class="lineNum">    1688 </span><span class="lineCov">      67482 :     case DW_AT_call_tail_call:</span>
<span class="lineNum">    1689 </span><span class="lineCov">      33741 :       if (dwarf_version &lt; 5)</span>
<span class="lineNum">    1690 </span><span class="lineCov">      33741 :         return DW_AT_GNU_tail_call;</span>
<span class="lineNum">    1691 </span>            :       break;
<span class="lineNum">    1692 </span>            : 
<span class="lineNum">    1693 </span><span class="lineCov">    2317872 :     case DW_AT_call_origin:</span>
<span class="lineNum">    1694 </span><span class="lineCov">    1865447 :       if (dwarf_version &lt; 5)</span>
<span class="lineNum">    1695 </span><span class="lineCov">    1865444 :         return DW_AT_abstract_origin;</span>
<span class="lineNum">    1696 </span>            :       break;
<span class="lineNum">    1697 </span>            : 
<span class="lineNum">    1698 </span><span class="lineCov">       8598 :     case DW_AT_call_target:</span>
<span class="lineNum">    1699 </span><span class="lineCov">       4299 :       if (dwarf_version &lt; 5)</span>
<span class="lineNum">    1700 </span><span class="lineCov">       4299 :         return DW_AT_GNU_call_site_target;</span>
<span class="lineNum">    1701 </span>            :       break;
<span class="lineNum">    1702 </span>            : 
<span class="lineNum">    1703 </span><span class="lineNoCov">          0 :     case DW_AT_call_target_clobbered:</span>
<span class="lineNum">    1704 </span><span class="lineNoCov">          0 :       if (dwarf_version &lt; 5)</span>
<span class="lineNum">    1705 </span><span class="lineNoCov">          0 :         return DW_AT_GNU_call_site_target_clobbered;</span>
<span class="lineNum">    1706 </span>            :       break;
<span class="lineNum">    1707 </span>            : 
<span class="lineNum">    1708 </span><span class="lineCov">      21328 :     case DW_AT_call_parameter:</span>
<span class="lineNum">    1709 </span><span class="lineCov">      10664 :       if (dwarf_version &lt; 5)</span>
<span class="lineNum">    1710 </span><span class="lineCov">      10664 :         return DW_AT_abstract_origin;</span>
<span class="lineNum">    1711 </span>            :       break;
<span class="lineNum">    1712 </span>            : 
<span class="lineNum">    1713 </span><span class="lineCov">    1943200 :     case DW_AT_call_value:</span>
<span class="lineNum">    1714 </span><span class="lineCov">    1943200 :       if (dwarf_version &lt; 5)</span>
<span class="lineNum">    1715 </span><span class="lineCov">    1943196 :         return DW_AT_GNU_call_site_value;</span>
<span class="lineNum">    1716 </span>            :       break;
<span class="lineNum">    1717 </span>            : 
<span class="lineNum">    1718 </span><span class="lineCov">       9450 :     case DW_AT_call_data_value:</span>
<span class="lineNum">    1719 </span><span class="lineCov">       4725 :       if (dwarf_version &lt; 5)</span>
<span class="lineNum">    1720 </span><span class="lineCov">       4725 :         return DW_AT_GNU_call_site_data_value;</span>
<span class="lineNum">    1721 </span>            :       break;
<span class="lineNum">    1722 </span>            : 
<span class="lineNum">    1723 </span><span class="lineCov">     313170 :     case DW_AT_call_all_calls:</span>
<span class="lineNum">    1724 </span><span class="lineCov">     156585 :       if (dwarf_version &lt; 5)</span>
<span class="lineNum">    1725 </span><span class="lineCov">     156579 :         return DW_AT_GNU_all_call_sites;</span>
<span class="lineNum">    1726 </span>            :       break;
<span class="lineNum">    1727 </span>            : 
<span class="lineNum">    1728 </span><span class="lineCov">     363754 :     case DW_AT_call_all_tail_calls:</span>
<span class="lineNum">    1729 </span><span class="lineCov">     181877 :       if (dwarf_version &lt; 5)</span>
<span class="lineNum">    1730 </span><span class="lineCov">     181876 :         return DW_AT_GNU_all_tail_call_sites;</span>
<span class="lineNum">    1731 </span>            :       break;
<span class="lineNum">    1732 </span>            : 
<span class="lineNum">    1733 </span><span class="lineCov">          4 :     case DW_AT_dwo_name:</span>
<span class="lineNum">    1734 </span><span class="lineCov">          4 :       if (dwarf_version &lt; 5)</span>
<span class="lineNum">    1735 </span><span class="lineCov">          4 :         return DW_AT_GNU_dwo_name;</span>
<span class="lineNum">    1736 </span>            :       break;
<span class="lineNum">    1737 </span>            : 
<span class="lineNum">    1738 </span><span class="lineCov">          4 :     case DW_AT_addr_base:</span>
<span class="lineNum">    1739 </span><span class="lineCov">          4 :       if (dwarf_version &lt; 5)</span>
<span class="lineNum">    1740 </span><span class="lineCov">          4 :         return DW_AT_GNU_addr_base;</span>
<span class="lineNum">    1741 </span>            :       break;
<span class="lineNum">    1742 </span>            : 
<span class="lineNum">    1743 </span>            :     default:
<span class="lineNum">    1744 </span>            :       break;
<span class="lineNum">    1745 </span>            :     }
<span class="lineNum">    1746 </span>            :   return at;
<span class="lineNum">    1747 </span>            : }
<span class="lineNum">    1748 </span>            : 
<span class="lineNum">    1749 </span>            : /* And similarly for tags.  */
<span class="lineNum">    1750 </span>            : static inline enum dwarf_tag
<span class="lineNum">    1751 </span>            : dwarf_TAG (enum dwarf_tag tag)
<span class="lineNum">    1752 </span>            : {
<span class="lineNum">    1753 </span><span class="lineCov">    3858114 :   switch (tag)</span>
<span class="lineNum">    1754 </span>            :     {
<span class="lineNum">    1755 </span><span class="lineCov">    1914914 :     case DW_TAG_call_site:</span>
<span class="lineNum">    1756 </span><span class="lineCov">    1914914 :       if (dwarf_version &lt; 5)</span>
<span class="lineNum">    1757 </span><span class="lineCov">    1914911 :         return DW_TAG_GNU_call_site;</span>
<span class="lineNum">    1758 </span>            :       break;
<span class="lineNum">    1759 </span>            : 
<span class="lineNum">    1760 </span><span class="lineCov">    1943200 :     case DW_TAG_call_site_parameter:</span>
<span class="lineNum">    1761 </span><span class="lineCov">    1943200 :       if (dwarf_version &lt; 5)</span>
<span class="lineNum">    1762 </span><span class="lineCov">    1943196 :         return DW_TAG_GNU_call_site_parameter;</span>
<span class="lineNum">    1763 </span>            :       break;
<span class="lineNum">    1764 </span>            : 
<span class="lineNum">    1765 </span>            :     default:
<span class="lineNum">    1766 </span>            :       break;
<span class="lineNum">    1767 </span>            :     }
<span class="lineNum">    1768 </span>            :   return tag;
<span class="lineNum">    1769 </span>            : }
<span class="lineNum">    1770 </span>            : 
<span class="lineNum">    1771 </span>            : /* And similarly for forms.  */
<span class="lineNum">    1772 </span>            : static inline enum dwarf_form
<span class="lineNum">    1773 </span>            : dwarf_FORM (enum dwarf_form form)
<span class="lineNum">    1774 </span>            : {
<span class="lineNum">    1775 </span><span class="lineCov">   18037852 :   switch (form)</span>
<span class="lineNum">    1776 </span>            :     {
<span class="lineNum">    1777 </span><span class="lineCov">         56 :     case DW_FORM_addrx:</span>
<span class="lineNum">    1778 </span><span class="lineCov">         28 :       if (dwarf_version &lt; 5)</span>
<span class="lineNum">    1779 </span><span class="lineCov">         28 :         return DW_FORM_GNU_addr_index;</span>
<span class="lineNum">    1780 </span>            :       break;
<span class="lineNum">    1781 </span>            : 
<span class="lineNum">    1782 </span><span class="lineCov">   20426982 :     case DW_FORM_strx:</span>
<span class="lineNum">    1783 </span><span class="lineCov">   18037824 :       if (dwarf_version &lt; 5)</span>
<span class="lineNum">    1784 </span><span class="lineCov">   18037459 :         return DW_FORM_GNU_str_index;</span>
<span class="lineNum">    1785 </span>            :       break;
<span class="lineNum">    1786 </span>            : 
<span class="lineNum">    1787 </span>            :     default:
<span class="lineNum">    1788 </span>            :       break;
<span class="lineNum">    1789 </span>            :     }
<span class="lineNum">    1790 </span>            :   return form;
<span class="lineNum">    1791 </span>            : }
<span class="lineNum">    1792 </span>            : 
<span class="lineNum">    1793 </span>            : static unsigned long int get_base_type_offset (dw_die_ref);
<span class="lineNum">    1794 </span>            : 
<span class="lineNum">    1795 </span>            : /* Return the size of a location descriptor.  */
<a name="1796"><span class="lineNum">    1796 </span>            : </a>
<span class="lineNum">    1797 </span>            : static unsigned long
<span class="lineNum">    1798 </span><span class="lineCov">  103081277 : size_of_loc_descr (dw_loc_descr_ref loc)</span>
<span class="lineNum">    1799 </span>            : {
<span class="lineNum">    1800 </span><span class="lineCov">  103081277 :   unsigned long size = 1;</span>
<span class="lineNum">    1801 </span>            : 
<span class="lineNum">    1802 </span><span class="lineCov">  103081277 :   switch (loc-&gt;dw_loc_opc)</span>
<span class="lineNum">    1803 </span>            :     {
<span class="lineNum">    1804 </span><span class="lineCov">    2666632 :     case DW_OP_addr:</span>
<span class="lineNum">    1805 </span><span class="lineCov">    2666632 :       size += DWARF2_ADDR_SIZE;</span>
<span class="lineNum">    1806 </span><span class="lineCov">    2666632 :       break;</span>
<span class="lineNum">    1807 </span><span class="lineCov">         15 :     case DW_OP_GNU_addr_index:</span>
<span class="lineNum">    1808 </span><span class="lineCov">         15 :     case DW_OP_addrx:</span>
<span class="lineNum">    1809 </span><span class="lineCov">         15 :     case DW_OP_GNU_const_index:</span>
<span class="lineNum">    1810 </span><span class="lineCov">         15 :     case DW_OP_constx:</span>
<span class="lineNum">    1811 </span><span class="lineCov">         15 :       gcc_assert (loc-&gt;dw_loc_oprnd1.val_entry-&gt;index != NO_INDEX_ASSIGNED);</span>
<span class="lineNum">    1812 </span><span class="lineCov">         15 :       size += size_of_uleb128 (loc-&gt;dw_loc_oprnd1.val_entry-&gt;index);</span>
<span class="lineNum">    1813 </span><span class="lineCov">         15 :       break;</span>
<span class="lineNum">    1814 </span><span class="lineCov">    1087806 :     case DW_OP_const1u:</span>
<span class="lineNum">    1815 </span><span class="lineCov">    1087806 :     case DW_OP_const1s:</span>
<span class="lineNum">    1816 </span><span class="lineCov">    1087806 :       size += 1;</span>
<span class="lineNum">    1817 </span><span class="lineCov">    1087806 :       break;</span>
<span class="lineNum">    1818 </span><span class="lineCov">     254572 :     case DW_OP_const2u:</span>
<span class="lineNum">    1819 </span><span class="lineCov">     254572 :     case DW_OP_const2s:</span>
<span class="lineNum">    1820 </span><span class="lineCov">     254572 :       size += 2;</span>
<span class="lineNum">    1821 </span><span class="lineCov">     254572 :       break;</span>
<span class="lineNum">    1822 </span><span class="lineCov">     191232 :     case DW_OP_const4u:</span>
<span class="lineNum">    1823 </span><span class="lineCov">     191232 :     case DW_OP_const4s:</span>
<span class="lineNum">    1824 </span><span class="lineCov">     191232 :       size += 4;</span>
<span class="lineNum">    1825 </span><span class="lineCov">     191232 :       break;</span>
<span class="lineNum">    1826 </span><span class="lineCov">       4679 :     case DW_OP_const8u:</span>
<span class="lineNum">    1827 </span><span class="lineCov">       4679 :     case DW_OP_const8s:</span>
<span class="lineNum">    1828 </span><span class="lineCov">       4679 :       size += 8;</span>
<span class="lineNum">    1829 </span><span class="lineCov">       4679 :       break;</span>
<span class="lineNum">    1830 </span><span class="lineCov">      66747 :     case DW_OP_constu:</span>
<span class="lineNum">    1831 </span><span class="lineCov">      66747 :       size += size_of_uleb128 (loc-&gt;dw_loc_oprnd1.v.val_unsigned);</span>
<span class="lineNum">    1832 </span><span class="lineCov">      66747 :       break;</span>
<span class="lineNum">    1833 </span><span class="lineCov">      95614 :     case DW_OP_consts:</span>
<span class="lineNum">    1834 </span><span class="lineCov">      95614 :       size += size_of_sleb128 (loc-&gt;dw_loc_oprnd1.v.val_int);</span>
<span class="lineNum">    1835 </span><span class="lineCov">      95614 :       break;</span>
<span class="lineNum">    1836 </span><span class="lineCov">       1608 :     case DW_OP_pick:</span>
<span class="lineNum">    1837 </span><span class="lineCov">       1608 :       size += 1;</span>
<span class="lineNum">    1838 </span><span class="lineCov">       1608 :       break;</span>
<span class="lineNum">    1839 </span><span class="lineCov">    1647384 :     case DW_OP_plus_uconst:</span>
<span class="lineNum">    1840 </span><span class="lineCov">    1647384 :       size += size_of_uleb128 (loc-&gt;dw_loc_oprnd1.v.val_unsigned);</span>
<span class="lineNum">    1841 </span><span class="lineCov">    1647384 :       break;</span>
<span class="lineNum">    1842 </span><span class="lineCov">      83574 :     case DW_OP_skip:</span>
<span class="lineNum">    1843 </span><span class="lineCov">      83574 :     case DW_OP_bra:</span>
<span class="lineNum">    1844 </span><span class="lineCov">      83574 :       size += 2;</span>
<span class="lineNum">    1845 </span><span class="lineCov">      83574 :       break;</span>
<span class="lineNum">    1846 </span><span class="lineCov">   11102702 :     case DW_OP_breg0:</span>
<span class="lineNum">    1847 </span><span class="lineCov">   11102702 :     case DW_OP_breg1:</span>
<span class="lineNum">    1848 </span><span class="lineCov">   11102702 :     case DW_OP_breg2:</span>
<span class="lineNum">    1849 </span><span class="lineCov">   11102702 :     case DW_OP_breg3:</span>
<span class="lineNum">    1850 </span><span class="lineCov">   11102702 :     case DW_OP_breg4:</span>
<span class="lineNum">    1851 </span><span class="lineCov">   11102702 :     case DW_OP_breg5:</span>
<span class="lineNum">    1852 </span><span class="lineCov">   11102702 :     case DW_OP_breg6:</span>
<span class="lineNum">    1853 </span><span class="lineCov">   11102702 :     case DW_OP_breg7:</span>
<span class="lineNum">    1854 </span><span class="lineCov">   11102702 :     case DW_OP_breg8:</span>
<span class="lineNum">    1855 </span><span class="lineCov">   11102702 :     case DW_OP_breg9:</span>
<span class="lineNum">    1856 </span><span class="lineCov">   11102702 :     case DW_OP_breg10:</span>
<span class="lineNum">    1857 </span><span class="lineCov">   11102702 :     case DW_OP_breg11:</span>
<span class="lineNum">    1858 </span><span class="lineCov">   11102702 :     case DW_OP_breg12:</span>
<span class="lineNum">    1859 </span><span class="lineCov">   11102702 :     case DW_OP_breg13:</span>
<span class="lineNum">    1860 </span><span class="lineCov">   11102702 :     case DW_OP_breg14:</span>
<span class="lineNum">    1861 </span><span class="lineCov">   11102702 :     case DW_OP_breg15:</span>
<span class="lineNum">    1862 </span><span class="lineCov">   11102702 :     case DW_OP_breg16:</span>
<span class="lineNum">    1863 </span><span class="lineCov">   11102702 :     case DW_OP_breg17:</span>
<span class="lineNum">    1864 </span><span class="lineCov">   11102702 :     case DW_OP_breg18:</span>
<span class="lineNum">    1865 </span><span class="lineCov">   11102702 :     case DW_OP_breg19:</span>
<span class="lineNum">    1866 </span><span class="lineCov">   11102702 :     case DW_OP_breg20:</span>
<span class="lineNum">    1867 </span><span class="lineCov">   11102702 :     case DW_OP_breg21:</span>
<span class="lineNum">    1868 </span><span class="lineCov">   11102702 :     case DW_OP_breg22:</span>
<span class="lineNum">    1869 </span><span class="lineCov">   11102702 :     case DW_OP_breg23:</span>
<span class="lineNum">    1870 </span><span class="lineCov">   11102702 :     case DW_OP_breg24:</span>
<span class="lineNum">    1871 </span><span class="lineCov">   11102702 :     case DW_OP_breg25:</span>
<span class="lineNum">    1872 </span><span class="lineCov">   11102702 :     case DW_OP_breg26:</span>
<span class="lineNum">    1873 </span><span class="lineCov">   11102702 :     case DW_OP_breg27:</span>
<span class="lineNum">    1874 </span><span class="lineCov">   11102702 :     case DW_OP_breg28:</span>
<span class="lineNum">    1875 </span><span class="lineCov">   11102702 :     case DW_OP_breg29:</span>
<span class="lineNum">    1876 </span><span class="lineCov">   11102702 :     case DW_OP_breg30:</span>
<span class="lineNum">    1877 </span><span class="lineCov">   11102702 :     case DW_OP_breg31:</span>
<span class="lineNum">    1878 </span><span class="lineCov">   11102702 :       size += size_of_sleb128 (loc-&gt;dw_loc_oprnd1.v.val_int);</span>
<span class="lineNum">    1879 </span><span class="lineCov">   11102702 :       break;</span>
<span class="lineNum">    1880 </span><span class="lineCov">      53954 :     case DW_OP_regx:</span>
<span class="lineNum">    1881 </span><span class="lineCov">      53954 :       size += size_of_uleb128 (loc-&gt;dw_loc_oprnd1.v.val_unsigned);</span>
<span class="lineNum">    1882 </span><span class="lineCov">      53954 :       break;</span>
<span class="lineNum">    1883 </span><span class="lineCov">   12908942 :     case DW_OP_fbreg:</span>
<span class="lineNum">    1884 </span><span class="lineCov">   12908942 :       size += size_of_sleb128 (loc-&gt;dw_loc_oprnd1.v.val_int);</span>
<span class="lineNum">    1885 </span><span class="lineCov">   12908942 :       break;</span>
<span class="lineNum">    1886 </span><span class="lineNoCov">          0 :     case DW_OP_bregx:</span>
<span class="lineNum">    1887 </span><span class="lineNoCov">          0 :       size += size_of_uleb128 (loc-&gt;dw_loc_oprnd1.v.val_unsigned);</span>
<span class="lineNum">    1888 </span><span class="lineNoCov">          0 :       size += size_of_sleb128 (loc-&gt;dw_loc_oprnd2.v.val_int);</span>
<span class="lineNum">    1889 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1890 </span><span class="lineCov">    7493640 :     case DW_OP_piece:</span>
<span class="lineNum">    1891 </span><span class="lineCov">    7493640 :       size += size_of_uleb128 (loc-&gt;dw_loc_oprnd1.v.val_unsigned);</span>
<span class="lineNum">    1892 </span><span class="lineCov">    7493640 :       break;</span>
<span class="lineNum">    1893 </span><span class="lineCov">       6687 :     case DW_OP_bit_piece:</span>
<span class="lineNum">    1894 </span><span class="lineCov">       6687 :       size += size_of_uleb128 (loc-&gt;dw_loc_oprnd1.v.val_unsigned);</span>
<span class="lineNum">    1895 </span><span class="lineCov">       6687 :       size += size_of_uleb128 (loc-&gt;dw_loc_oprnd2.v.val_unsigned);</span>
<span class="lineNum">    1896 </span><span class="lineCov">       6687 :       break;</span>
<span class="lineNum">    1897 </span><span class="lineCov">     172179 :     case DW_OP_deref_size:</span>
<span class="lineNum">    1898 </span><span class="lineCov">     172179 :     case DW_OP_xderef_size:</span>
<span class="lineNum">    1899 </span><span class="lineCov">     172179 :       size += 1;</span>
<span class="lineNum">    1900 </span><span class="lineCov">     172179 :       break;</span>
<span class="lineNum">    1901 </span><span class="lineNoCov">          0 :     case DW_OP_call2:</span>
<span class="lineNum">    1902 </span><span class="lineNoCov">          0 :       size += 2;</span>
<span class="lineNum">    1903 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1904 </span><span class="lineCov">        164 :     case DW_OP_call4:</span>
<span class="lineNum">    1905 </span><span class="lineCov">        164 :       size += 4;</span>
<span class="lineNum">    1906 </span><span class="lineCov">        164 :       break;</span>
<span class="lineNum">    1907 </span><span class="lineCov">        992 :     case DW_OP_call_ref:</span>
<span class="lineNum">    1908 </span><span class="lineCov">        992 :     case DW_OP_GNU_variable_value:</span>
<span class="lineNum">    1909 </span><span class="lineCov">        992 :       size += DWARF_REF_SIZE;</span>
<span class="lineNum">    1910 </span><span class="lineCov">        992 :       break;</span>
<span class="lineNum">    1911 </span><span class="lineCov">     204851 :     case DW_OP_implicit_value:</span>
<span class="lineNum">    1912 </span><span class="lineCov">     204851 :       size += size_of_uleb128 (loc-&gt;dw_loc_oprnd1.v.val_unsigned)</span>
<span class="lineNum">    1913 </span><span class="lineCov">     204851 :               + loc-&gt;dw_loc_oprnd1.v.val_unsigned;</span>
<span class="lineNum">    1914 </span><span class="lineCov">     204851 :       break;</span>
<span class="lineNum">    1915 </span><span class="lineCov">    1667811 :     case DW_OP_implicit_pointer:</span>
<span class="lineNum">    1916 </span><span class="lineCov">    1667811 :     case DW_OP_GNU_implicit_pointer:</span>
<span class="lineNum">    1917 </span><span class="lineCov">    1667811 :       size += DWARF_REF_SIZE + size_of_sleb128 (loc-&gt;dw_loc_oprnd2.v.val_int);</span>
<span class="lineNum">    1918 </span><span class="lineCov">    1667811 :       break;</span>
<span class="lineNum">    1919 </span><span class="lineCov">    2487862 :     case DW_OP_entry_value:</span>
<span class="lineNum">    1920 </span><span class="lineCov">    2487862 :     case DW_OP_GNU_entry_value:</span>
<span class="lineNum">    1921 </span><span class="lineCov">    2487862 :       {</span>
<span class="lineNum">    1922 </span><span class="lineCov">    2487862 :         unsigned long op_size = size_of_locs (loc-&gt;dw_loc_oprnd1.v.val_loc);</span>
<span class="lineNum">    1923 </span><span class="lineCov">    2487862 :         size += size_of_uleb128 (op_size) + op_size;</span>
<span class="lineNum">    1924 </span><span class="lineCov">    2487862 :         break;</span>
<span class="lineNum">    1925 </span>            :       }
<span class="lineNum">    1926 </span><span class="lineCov">     138749 :     case DW_OP_const_type:</span>
<span class="lineNum">    1927 </span><span class="lineCov">     138749 :     case DW_OP_GNU_const_type:</span>
<span class="lineNum">    1928 </span><span class="lineCov">     138749 :       {</span>
<span class="lineNum">    1929 </span><span class="lineCov">     138749 :         unsigned long o</span>
<span class="lineNum">    1930 </span><span class="lineCov">     138749 :           = get_base_type_offset (loc-&gt;dw_loc_oprnd1.v.val_die_ref.die);</span>
<span class="lineNum">    1931 </span><span class="lineCov">     138749 :         size += size_of_uleb128 (o) + 1;</span>
<span class="lineNum">    1932 </span><span class="lineCov">     138749 :         switch (loc-&gt;dw_loc_oprnd2.val_class)</span>
<span class="lineNum">    1933 </span>            :           {
<span class="lineNum">    1934 </span><span class="lineCov">     127128 :           case dw_val_class_vec:</span>
<span class="lineNum">    1935 </span><span class="lineCov">     254256 :             size += loc-&gt;dw_loc_oprnd2.v.val_vec.length</span>
<span class="lineNum">    1936 </span><span class="lineCov">     127128 :                     * loc-&gt;dw_loc_oprnd2.v.val_vec.elt_size;</span>
<span class="lineNum">    1937 </span><span class="lineCov">     127128 :             break;</span>
<span class="lineNum">    1938 </span><span class="lineCov">      11394 :           case dw_val_class_const:</span>
<span class="lineNum">    1939 </span><span class="lineCov">      11394 :             size += HOST_BITS_PER_WIDE_INT / BITS_PER_UNIT;</span>
<span class="lineNum">    1940 </span><span class="lineCov">      11394 :             break;</span>
<span class="lineNum">    1941 </span><span class="lineCov">         39 :           case dw_val_class_const_double:</span>
<span class="lineNum">    1942 </span><span class="lineCov">         39 :             size += HOST_BITS_PER_DOUBLE_INT / BITS_PER_UNIT;</span>
<span class="lineNum">    1943 </span><span class="lineCov">         39 :             break;</span>
<span class="lineNum">    1944 </span><span class="lineCov">        188 :           case dw_val_class_wide_int:</span>
<span class="lineNum">    1945 </span><span class="lineCov">        188 :             size += (get_full_len (*loc-&gt;dw_loc_oprnd2.v.val_wide)</span>
<span class="lineNum">    1946 </span><span class="lineCov">        188 :                      * HOST_BITS_PER_WIDE_INT / BITS_PER_UNIT);</span>
<span class="lineNum">    1947 </span><span class="lineCov">        188 :             break;</span>
<span class="lineNum">    1948 </span><span class="lineNoCov">          0 :           default:</span>
<span class="lineNum">    1949 </span><span class="lineNoCov">          0 :             gcc_unreachable ();</span>
<span class="lineNum">    1950 </span>            :           }
<span class="lineNum">    1951 </span>            :         break;
<span class="lineNum">    1952 </span>            :       }
<span class="lineNum">    1953 </span><span class="lineCov">     143106 :     case DW_OP_regval_type:</span>
<span class="lineNum">    1954 </span><span class="lineCov">     143106 :     case DW_OP_GNU_regval_type:</span>
<span class="lineNum">    1955 </span><span class="lineCov">     143106 :       {</span>
<span class="lineNum">    1956 </span><span class="lineCov">     143106 :         unsigned long o</span>
<span class="lineNum">    1957 </span><span class="lineCov">     143106 :           = get_base_type_offset (loc-&gt;dw_loc_oprnd2.v.val_die_ref.die);</span>
<span class="lineNum">    1958 </span><span class="lineCov">     143106 :         size += size_of_uleb128 (loc-&gt;dw_loc_oprnd1.v.val_unsigned)</span>
<span class="lineNum">    1959 </span><span class="lineCov">     143106 :                 + size_of_uleb128 (o);</span>
<span class="lineNum">    1960 </span>            :       }
<span class="lineNum">    1961 </span><span class="lineCov">     143106 :       break;</span>
<span class="lineNum">    1962 </span><span class="lineCov">     152162 :     case DW_OP_deref_type:</span>
<span class="lineNum">    1963 </span><span class="lineCov">     152162 :     case DW_OP_GNU_deref_type:</span>
<span class="lineNum">    1964 </span><span class="lineCov">     152162 :       {</span>
<span class="lineNum">    1965 </span><span class="lineCov">     152162 :         unsigned long o</span>
<span class="lineNum">    1966 </span><span class="lineCov">     152162 :           = get_base_type_offset (loc-&gt;dw_loc_oprnd2.v.val_die_ref.die);</span>
<span class="lineNum">    1967 </span><span class="lineCov">     152162 :         size += 1 + size_of_uleb128 (o);</span>
<span class="lineNum">    1968 </span>            :       }
<span class="lineNum">    1969 </span><span class="lineCov">     152162 :       break;</span>
<span class="lineNum">    1970 </span><span class="lineCov">     226162 :     case DW_OP_convert:</span>
<span class="lineNum">    1971 </span><span class="lineCov">     226162 :     case DW_OP_reinterpret:</span>
<span class="lineNum">    1972 </span><span class="lineCov">     226162 :     case DW_OP_GNU_convert:</span>
<span class="lineNum">    1973 </span><span class="lineCov">     226162 :     case DW_OP_GNU_reinterpret:</span>
<span class="lineNum">    1974 </span><span class="lineCov">     226162 :       if (loc-&gt;dw_loc_oprnd1.val_class == dw_val_class_unsigned_const)</span>
<span class="lineNum">    1975 </span><span class="lineCov">      11411 :         size += size_of_uleb128 (loc-&gt;dw_loc_oprnd1.v.val_unsigned);</span>
<span class="lineNum">    1976 </span>            :       else
<span class="lineNum">    1977 </span>            :         {
<span class="lineNum">    1978 </span><span class="lineCov">     214751 :           unsigned long o</span>
<span class="lineNum">    1979 </span><span class="lineCov">     214751 :             = get_base_type_offset (loc-&gt;dw_loc_oprnd1.v.val_die_ref.die);</span>
<span class="lineNum">    1980 </span><span class="lineCov">     214751 :           size += size_of_uleb128 (o);</span>
<span class="lineNum">    1981 </span>            :         }
<span class="lineNum">    1982 </span>            :       break;
<span class="lineNum">    1983 </span><span class="lineCov">      14589 :     case DW_OP_GNU_parameter_ref:</span>
<span class="lineNum">    1984 </span><span class="lineCov">      14589 :       size += 4;</span>
<span class="lineNum">    1985 </span><span class="lineCov">      14589 :       break;</span>
<span class="lineNum">    1986 </span>            :     default:
<span class="lineNum">    1987 </span>            :       break;
<span class="lineNum">    1988 </span>            :     }
<span class="lineNum">    1989 </span>            : 
<span class="lineNum">    1990 </span><span class="lineCov">  103081277 :   return size;</span>
<span class="lineNum">    1991 </span>            : }
<span class="lineNum">    1992 </span>            : 
<span class="lineNum">    1993 </span>            : /* Return the size of a series of location descriptors.  */
<a name="1994"><span class="lineNum">    1994 </span>            : </a>
<span class="lineNum">    1995 </span>            : unsigned long
<span class="lineNum">    1996 </span><span class="lineCov">   57573862 : size_of_locs (dw_loc_descr_ref loc)</span>
<span class="lineNum">    1997 </span>            : {
<span class="lineNum">    1998 </span><span class="lineCov">   57573862 :   dw_loc_descr_ref l;</span>
<span class="lineNum">    1999 </span><span class="lineCov">   57573862 :   unsigned long size;</span>
<span class="lineNum">    2000 </span>            : 
<span class="lineNum">    2001 </span>            :   /* If there are no skip or bra opcodes, don't fill in the dw_loc_addr
<span class="lineNum">    2002 </span>            :      field, to avoid writing to a PCH file.  */
<span class="lineNum">    2003 </span><span class="lineCov">  158878904 :   for (size = 0, l = loc; l != NULL; l = l-&gt;dw_loc_next)</span>
<span class="lineNum">    2004 </span>            :     {
<span class="lineNum">    2005 </span><span class="lineCov">  101363818 :       if (l-&gt;dw_loc_opc == DW_OP_skip || l-&gt;dw_loc_opc == DW_OP_bra)</span>
<span class="lineNum">    2006 </span>            :         break;
<span class="lineNum">    2007 </span><span class="lineCov">  101305042 :       size += size_of_loc_descr (l);</span>
<span class="lineNum">    2008 </span>            :     }
<span class="lineNum">    2009 </span><span class="lineCov">   57573862 :   if (! l)</span>
<span class="lineNum">    2010 </span>            :     return size;
<span class="lineNum">    2011 </span>            : 
<span class="lineNum">    2012 </span><span class="lineCov">    1357194 :   for (size = 0, l = loc; l != NULL; l = l-&gt;dw_loc_next)</span>
<span class="lineNum">    2013 </span>            :     {
<span class="lineNum">    2014 </span><span class="lineCov">    1298418 :       l-&gt;dw_loc_addr = size;</span>
<span class="lineNum">    2015 </span><span class="lineCov">    1298418 :       size += size_of_loc_descr (l);</span>
<span class="lineNum">    2016 </span>            :     }
<span class="lineNum">    2017 </span>            : 
<span class="lineNum">    2018 </span>            :   return size;
<span class="lineNum">    2019 </span>            : }
<span class="lineNum">    2020 </span>            : 
<span class="lineNum">    2021 </span>            : /* Return the size of the value in a DW_AT_discr_value attribute.  */
<a name="2022"><span class="lineNum">    2022 </span>            : </a>
<span class="lineNum">    2023 </span>            : static int
<span class="lineNum">    2024 </span><span class="lineNoCov">          0 : size_of_discr_value (dw_discr_value *discr_value)</span>
<span class="lineNum">    2025 </span>            : {
<span class="lineNum">    2026 </span><span class="lineNoCov">          0 :   if (discr_value-&gt;pos)</span>
<span class="lineNum">    2027 </span><span class="lineNoCov">          0 :     return size_of_uleb128 (discr_value-&gt;v.uval);</span>
<span class="lineNum">    2028 </span>            :   else
<span class="lineNum">    2029 </span><span class="lineNoCov">          0 :     return size_of_sleb128 (discr_value-&gt;v.sval);</span>
<span class="lineNum">    2030 </span>            : }
<span class="lineNum">    2031 </span>            : 
<span class="lineNum">    2032 </span>            : /* Return the size of the value in a DW_AT_discr_list attribute.  */
<a name="2033"><span class="lineNum">    2033 </span>            : </a>
<span class="lineNum">    2034 </span>            : static int
<span class="lineNum">    2035 </span><span class="lineNoCov">          0 : size_of_discr_list (dw_discr_list_ref discr_list)</span>
<span class="lineNum">    2036 </span>            : {
<span class="lineNum">    2037 </span><span class="lineNoCov">          0 :   int size = 0;</span>
<span class="lineNum">    2038 </span>            : 
<span class="lineNum">    2039 </span><span class="lineNoCov">          0 :   for (dw_discr_list_ref list = discr_list;</span>
<span class="lineNum">    2040 </span><span class="lineNoCov">          0 :        list != NULL;</span>
<span class="lineNum">    2041 </span><span class="lineNoCov">          0 :        list = list-&gt;dw_discr_next)</span>
<span class="lineNum">    2042 </span>            :     {
<span class="lineNum">    2043 </span>            :       /* One byte for the discriminant value descriptor, and then one or two
<span class="lineNum">    2044 </span>            :          LEB128 numbers, depending on whether it's a single case label or a
<span class="lineNum">    2045 </span>            :          range label.  */
<span class="lineNum">    2046 </span><span class="lineNoCov">          0 :       size += 1;</span>
<span class="lineNum">    2047 </span><span class="lineNoCov">          0 :       size += size_of_discr_value (&amp;list-&gt;dw_discr_lower_bound);</span>
<span class="lineNum">    2048 </span><span class="lineNoCov">          0 :       if (list-&gt;dw_discr_range != 0)</span>
<span class="lineNum">    2049 </span><span class="lineNoCov">          0 :         size += size_of_discr_value (&amp;list-&gt;dw_discr_upper_bound);</span>
<span class="lineNum">    2050 </span>            :     }
<span class="lineNum">    2051 </span><span class="lineNoCov">          0 :   return size;</span>
<span class="lineNum">    2052 </span>            : }
<span class="lineNum">    2053 </span>            : 
<span class="lineNum">    2054 </span>            : static HOST_WIDE_INT extract_int (const unsigned char *, unsigned);
<span class="lineNum">    2055 </span>            : static void get_ref_die_offset_label (char *, dw_die_ref);
<span class="lineNum">    2056 </span>            : static unsigned long int get_ref_die_offset (dw_die_ref);
<span class="lineNum">    2057 </span>            : 
<span class="lineNum">    2058 </span>            : /* Output location description stack opcode's operands (if any).
<span class="lineNum">    2059 </span>            :    The for_eh_or_skip parameter controls whether register numbers are
<span class="lineNum">    2060 </span>            :    converted using DWARF2_FRAME_REG_OUT, which is needed in the case that
<span class="lineNum">    2061 </span>            :    hard reg numbers have been processed via DWARF_FRAME_REGNUM (i.e. for unwind
<span class="lineNum">    2062 </span>            :    info).  This should be suppressed for the cases that have not been converted
<span class="lineNum">    2063 </span>            :    (i.e. symbolic debug info), by setting the parameter &lt; 0.  See PR47324.  */
<a name="2064"><span class="lineNum">    2064 </span>            : </a>
<span class="lineNum">    2065 </span>            : static void
<span class="lineNum">    2066 </span><span class="lineCov">   35250735 : output_loc_operands (dw_loc_descr_ref loc, int for_eh_or_skip)</span>
<span class="lineNum">    2067 </span>            : {
<span class="lineNum">    2068 </span><span class="lineCov">   35250735 :   dw_val_ref val1 = &amp;loc-&gt;dw_loc_oprnd1;</span>
<span class="lineNum">    2069 </span><span class="lineCov">   35250735 :   dw_val_ref val2 = &amp;loc-&gt;dw_loc_oprnd2;</span>
<span class="lineNum">    2070 </span>            : 
<span class="lineNum">    2071 </span><span class="lineCov">   35250735 :   switch (loc-&gt;dw_loc_opc)</span>
<span class="lineNum">    2072 </span>            :     {
<span class="lineNum">    2073 </span>            : #ifdef DWARF2_DEBUGGING_INFO
<span class="lineNum">    2074 </span><span class="lineCov">      80796 :     case DW_OP_const2u:</span>
<span class="lineNum">    2075 </span><span class="lineCov">      80796 :     case DW_OP_const2s:</span>
<span class="lineNum">    2076 </span><span class="lineCov">      80796 :       dw2_asm_output_data (2, val1-&gt;v.val_int, NULL);</span>
<span class="lineNum">    2077 </span><span class="lineCov">      80796 :       break;</span>
<span class="lineNum">    2078 </span><span class="lineCov">      63218 :     case DW_OP_const4u:</span>
<span class="lineNum">    2079 </span><span class="lineCov">      63218 :       if (loc-&gt;dtprel)</span>
<span class="lineNum">    2080 </span>            :         {
<span class="lineNum">    2081 </span><span class="lineCov">        115 :           gcc_assert (targetm.asm_out.output_dwarf_dtprel);</span>
<span class="lineNum">    2082 </span><span class="lineCov">        115 :           targetm.asm_out.output_dwarf_dtprel (asm_out_file, 4,</span>
<span class="lineNum">    2083 </span>            :                                                val1-&gt;v.val_addr);
<span class="lineNum">    2084 </span><span class="lineCov">        115 :           fputc ('\n', asm_out_file);</span>
<span class="lineNum">    2085 </span><span class="lineCov">        115 :           break;</span>
<span class="lineNum">    2086 </span>            :         }
<span class="lineNum">    2087 </span>            :       /* FALLTHRU */
<span class="lineNum">    2088 </span><span class="lineCov">      63103 :     case DW_OP_const4s:</span>
<span class="lineNum">    2089 </span><span class="lineCov">      63103 :       dw2_asm_output_data (4, val1-&gt;v.val_int, NULL);</span>
<span class="lineNum">    2090 </span><span class="lineCov">      63103 :       break;</span>
<span class="lineNum">    2091 </span><span class="lineCov">       1557 :     case DW_OP_const8u:</span>
<span class="lineNum">    2092 </span><span class="lineCov">       1557 :       if (loc-&gt;dtprel)</span>
<span class="lineNum">    2093 </span>            :         {
<span class="lineNum">    2094 </span><span class="lineCov">        564 :           gcc_assert (targetm.asm_out.output_dwarf_dtprel);</span>
<span class="lineNum">    2095 </span><span class="lineCov">        564 :           targetm.asm_out.output_dwarf_dtprel (asm_out_file, 8,</span>
<span class="lineNum">    2096 </span>            :                                                val1-&gt;v.val_addr);
<span class="lineNum">    2097 </span><span class="lineCov">        564 :           fputc ('\n', asm_out_file);</span>
<span class="lineNum">    2098 </span><span class="lineCov">        564 :           break;</span>
<span class="lineNum">    2099 </span>            :         }
<span class="lineNum">    2100 </span>            :       /* FALLTHRU */
<span class="lineNum">    2101 </span><span class="lineCov">        993 :     case DW_OP_const8s:</span>
<span class="lineNum">    2102 </span><span class="lineCov">        993 :       gcc_assert (HOST_BITS_PER_WIDE_INT &gt;= 64);</span>
<span class="lineNum">    2103 </span><span class="lineCov">        993 :       dw2_asm_output_data (8, val1-&gt;v.val_int, NULL);</span>
<span class="lineNum">    2104 </span><span class="lineCov">        993 :       break;</span>
<span class="lineNum">    2105 </span><span class="lineCov">      23235 :     case DW_OP_skip:</span>
<span class="lineNum">    2106 </span><span class="lineCov">      23235 :     case DW_OP_bra:</span>
<span class="lineNum">    2107 </span><span class="lineCov">      23235 :       {</span>
<span class="lineNum">    2108 </span><span class="lineCov">      23235 :         int offset;</span>
<span class="lineNum">    2109 </span>            : 
<span class="lineNum">    2110 </span><span class="lineCov">      23235 :         gcc_assert (val1-&gt;val_class == dw_val_class_loc);</span>
<span class="lineNum">    2111 </span><span class="lineCov">      23235 :         offset = val1-&gt;v.val_loc-&gt;dw_loc_addr - (loc-&gt;dw_loc_addr + 3);</span>
<span class="lineNum">    2112 </span>            : 
<span class="lineNum">    2113 </span><span class="lineCov">      23235 :         dw2_asm_output_data (2, offset, NULL);</span>
<span class="lineNum">    2114 </span>            :       }
<span class="lineNum">    2115 </span><span class="lineCov">      23235 :       break;</span>
<span class="lineNum">    2116 </span><span class="lineCov">      68759 :     case DW_OP_implicit_value:</span>
<span class="lineNum">    2117 </span><span class="lineCov">      68759 :       dw2_asm_output_data_uleb128 (val1-&gt;v.val_unsigned, NULL);</span>
<span class="lineNum">    2118 </span><span class="lineCov">      68759 :       switch (val2-&gt;val_class)</span>
<span class="lineNum">    2119 </span>            :         {
<span class="lineNum">    2120 </span><span class="lineCov">      18211 :         case dw_val_class_const:</span>
<span class="lineNum">    2121 </span><span class="lineCov">      18211 :           dw2_asm_output_data (val1-&gt;v.val_unsigned, val2-&gt;v.val_int, NULL);</span>
<span class="lineNum">    2122 </span><span class="lineCov">      18211 :           break;</span>
<span class="lineNum">    2123 </span><span class="lineCov">      50470 :         case dw_val_class_vec:</span>
<span class="lineNum">    2124 </span><span class="lineCov">      50470 :           {</span>
<span class="lineNum">    2125 </span><span class="lineCov">      50470 :             unsigned int elt_size = val2-&gt;v.val_vec.elt_size;</span>
<span class="lineNum">    2126 </span><span class="lineCov">      50470 :             unsigned int len = val2-&gt;v.val_vec.length;</span>
<span class="lineNum">    2127 </span><span class="lineCov">      50470 :             unsigned int i;</span>
<span class="lineNum">    2128 </span><span class="lineCov">      50470 :             unsigned char *p;</span>
<span class="lineNum">    2129 </span>            : 
<span class="lineNum">    2130 </span><span class="lineCov">      50470 :             if (elt_size &gt; sizeof (HOST_WIDE_INT))</span>
<span class="lineNum">    2131 </span>            :               {
<span class="lineNum">    2132 </span><span class="lineCov">          1 :                 elt_size /= 2;</span>
<span class="lineNum">    2133 </span><span class="lineCov">          1 :                 len *= 2;</span>
<span class="lineNum">    2134 </span>            :               }
<span class="lineNum">    2135 </span><span class="lineCov">      50470 :             for (i = 0, p = (unsigned char *) val2-&gt;v.val_vec.array;</span>
<span class="lineNum">    2136 </span><span class="lineCov">     312245 :                  i &lt; len;</span>
<span class="lineNum">    2137 </span><span class="lineCov">     261775 :                  i++, p += elt_size)</span>
<span class="lineNum">    2138 </span><span class="lineCov">     523550 :               dw2_asm_output_data (elt_size, extract_int (p, elt_size),</span>
<span class="lineNum">    2139 </span><span class="lineCov">      50470 :                                    &quot;fp or vector constant word %u&quot;, i);</span>
<span class="lineNum">    2140 </span>            :           }
<span class="lineNum">    2141 </span>            :           break;
<span class="lineNum">    2142 </span><span class="lineNoCov">          0 :         case dw_val_class_const_double:</span>
<span class="lineNum">    2143 </span><span class="lineNoCov">          0 :           {</span>
<span class="lineNum">    2144 </span><span class="lineNoCov">          0 :             unsigned HOST_WIDE_INT first, second;</span>
<span class="lineNum">    2145 </span>            : 
<span class="lineNum">    2146 </span><span class="lineNoCov">          0 :             if (WORDS_BIG_ENDIAN)</span>
<span class="lineNum">    2147 </span>            :               {
<span class="lineNum">    2148 </span>            :                 first = val2-&gt;v.val_double.high;
<span class="lineNum">    2149 </span>            :                 second = val2-&gt;v.val_double.low;
<span class="lineNum">    2150 </span>            :               }
<span class="lineNum">    2151 </span>            :             else
<span class="lineNum">    2152 </span>            :               {
<span class="lineNum">    2153 </span><span class="lineNoCov">          0 :                 first = val2-&gt;v.val_double.low;</span>
<span class="lineNum">    2154 </span><span class="lineNoCov">          0 :                 second = val2-&gt;v.val_double.high;</span>
<span class="lineNum">    2155 </span>            :               }
<span class="lineNum">    2156 </span><span class="lineNoCov">          0 :             dw2_asm_output_data (HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR,</span>
<span class="lineNum">    2157 </span>            :                                  first, NULL);
<span class="lineNum">    2158 </span><span class="lineNoCov">          0 :             dw2_asm_output_data (HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR,</span>
<span class="lineNum">    2159 </span>            :                                  second, NULL);
<span class="lineNum">    2160 </span>            :           }
<span class="lineNum">    2161 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2162 </span><span class="lineCov">         78 :         case dw_val_class_wide_int:</span>
<span class="lineNum">    2163 </span><span class="lineCov">         78 :           {</span>
<span class="lineNum">    2164 </span><span class="lineCov">         78 :             int i;</span>
<span class="lineNum">    2165 </span><span class="lineCov">         78 :             int len = get_full_len (*val2-&gt;v.val_wide);</span>
<span class="lineNum">    2166 </span><span class="lineCov">         78 :             if (WORDS_BIG_ENDIAN)</span>
<span class="lineNum">    2167 </span>            :               for (i = len - 1; i &gt;= 0; --i)
<span class="lineNum">    2168 </span>            :                 dw2_asm_output_data (HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR,
<span class="lineNum">    2169 </span>            :                                      val2-&gt;v.val_wide-&gt;elt (i), NULL);
<span class="lineNum">    2170 </span>            :             else
<span class="lineNum">    2171 </span><span class="lineCov">        225 :               for (i = 0; i &lt; len; ++i)</span>
<span class="lineNum">    2172 </span><span class="lineCov">        294 :                 dw2_asm_output_data (HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR,</span>
<span class="lineNum">    2173 </span><span class="lineCov">        294 :                                      val2-&gt;v.val_wide-&gt;elt (i), NULL);</span>
<span class="lineNum">    2174 </span>            :           }
<span class="lineNum">    2175 </span>            :           break;
<span class="lineNum">    2176 </span><span class="lineNoCov">          0 :         case dw_val_class_addr:</span>
<span class="lineNum">    2177 </span><span class="lineNoCov">          0 :           gcc_assert (val1-&gt;v.val_unsigned == DWARF2_ADDR_SIZE);</span>
<span class="lineNum">    2178 </span><span class="lineNoCov">          0 :           dw2_asm_output_addr_rtx (DWARF2_ADDR_SIZE, val2-&gt;v.val_addr, NULL);</span>
<span class="lineNum">    2179 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2180 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">    2181 </span><span class="lineNoCov">          0 :           gcc_unreachable ();</span>
<span class="lineNum">    2182 </span>            :         }
<span class="lineNum">    2183 </span>            :       break;
<span class="lineNum">    2184 </span>            : #else
<span class="lineNum">    2185 </span>            :     case DW_OP_const2u:
<span class="lineNum">    2186 </span>            :     case DW_OP_const2s:
<span class="lineNum">    2187 </span>            :     case DW_OP_const4u:
<span class="lineNum">    2188 </span>            :     case DW_OP_const4s:
<span class="lineNum">    2189 </span>            :     case DW_OP_const8u:
<span class="lineNum">    2190 </span>            :     case DW_OP_const8s:
<span class="lineNum">    2191 </span>            :     case DW_OP_skip:
<span class="lineNum">    2192 </span>            :     case DW_OP_bra:
<span class="lineNum">    2193 </span>            :     case DW_OP_implicit_value:
<span class="lineNum">    2194 </span>            :       /* We currently don't make any attempt to make sure these are
<span class="lineNum">    2195 </span>            :          aligned properly like we do for the main unwind info, so
<span class="lineNum">    2196 </span>            :          don't support emitting things larger than a byte if we're
<span class="lineNum">    2197 </span>            :          only doing unwinding.  */
<span class="lineNum">    2198 </span>            :       gcc_unreachable ();
<span class="lineNum">    2199 </span>            : #endif
<span class="lineNum">    2200 </span><span class="lineCov">     364921 :     case DW_OP_const1u:</span>
<span class="lineNum">    2201 </span><span class="lineCov">     364921 :     case DW_OP_const1s:</span>
<span class="lineNum">    2202 </span><span class="lineCov">     364921 :       dw2_asm_output_data (1, val1-&gt;v.val_int, NULL);</span>
<span class="lineNum">    2203 </span><span class="lineCov">     364921 :       break;</span>
<span class="lineNum">    2204 </span><span class="lineCov">      30209 :     case DW_OP_constu:</span>
<span class="lineNum">    2205 </span><span class="lineCov">      30209 :       dw2_asm_output_data_uleb128 (val1-&gt;v.val_unsigned, NULL);</span>
<span class="lineNum">    2206 </span><span class="lineCov">      30209 :       break;</span>
<span class="lineNum">    2207 </span><span class="lineCov">      32163 :     case DW_OP_consts:</span>
<span class="lineNum">    2208 </span><span class="lineCov">      32163 :       dw2_asm_output_data_sleb128 (val1-&gt;v.val_int, NULL);</span>
<span class="lineNum">    2209 </span><span class="lineCov">      32163 :       break;</span>
<span class="lineNum">    2210 </span><span class="lineCov">        207 :     case DW_OP_pick:</span>
<span class="lineNum">    2211 </span><span class="lineCov">        207 :       dw2_asm_output_data (1, val1-&gt;v.val_int, NULL);</span>
<span class="lineNum">    2212 </span><span class="lineCov">        207 :       break;</span>
<span class="lineNum">    2213 </span><span class="lineCov">     400402 :     case DW_OP_plus_uconst:</span>
<span class="lineNum">    2214 </span><span class="lineCov">     400402 :       dw2_asm_output_data_uleb128 (val1-&gt;v.val_unsigned, NULL);</span>
<span class="lineNum">    2215 </span><span class="lineCov">     400402 :       break;</span>
<span class="lineNum">    2216 </span><span class="lineCov">    3870643 :     case DW_OP_breg0:</span>
<span class="lineNum">    2217 </span><span class="lineCov">    3870643 :     case DW_OP_breg1:</span>
<span class="lineNum">    2218 </span><span class="lineCov">    3870643 :     case DW_OP_breg2:</span>
<span class="lineNum">    2219 </span><span class="lineCov">    3870643 :     case DW_OP_breg3:</span>
<span class="lineNum">    2220 </span><span class="lineCov">    3870643 :     case DW_OP_breg4:</span>
<span class="lineNum">    2221 </span><span class="lineCov">    3870643 :     case DW_OP_breg5:</span>
<span class="lineNum">    2222 </span><span class="lineCov">    3870643 :     case DW_OP_breg6:</span>
<span class="lineNum">    2223 </span><span class="lineCov">    3870643 :     case DW_OP_breg7:</span>
<span class="lineNum">    2224 </span><span class="lineCov">    3870643 :     case DW_OP_breg8:</span>
<span class="lineNum">    2225 </span><span class="lineCov">    3870643 :     case DW_OP_breg9:</span>
<span class="lineNum">    2226 </span><span class="lineCov">    3870643 :     case DW_OP_breg10:</span>
<span class="lineNum">    2227 </span><span class="lineCov">    3870643 :     case DW_OP_breg11:</span>
<span class="lineNum">    2228 </span><span class="lineCov">    3870643 :     case DW_OP_breg12:</span>
<span class="lineNum">    2229 </span><span class="lineCov">    3870643 :     case DW_OP_breg13:</span>
<span class="lineNum">    2230 </span><span class="lineCov">    3870643 :     case DW_OP_breg14:</span>
<span class="lineNum">    2231 </span><span class="lineCov">    3870643 :     case DW_OP_breg15:</span>
<span class="lineNum">    2232 </span><span class="lineCov">    3870643 :     case DW_OP_breg16:</span>
<span class="lineNum">    2233 </span><span class="lineCov">    3870643 :     case DW_OP_breg17:</span>
<span class="lineNum">    2234 </span><span class="lineCov">    3870643 :     case DW_OP_breg18:</span>
<span class="lineNum">    2235 </span><span class="lineCov">    3870643 :     case DW_OP_breg19:</span>
<span class="lineNum">    2236 </span><span class="lineCov">    3870643 :     case DW_OP_breg20:</span>
<span class="lineNum">    2237 </span><span class="lineCov">    3870643 :     case DW_OP_breg21:</span>
<span class="lineNum">    2238 </span><span class="lineCov">    3870643 :     case DW_OP_breg22:</span>
<span class="lineNum">    2239 </span><span class="lineCov">    3870643 :     case DW_OP_breg23:</span>
<span class="lineNum">    2240 </span><span class="lineCov">    3870643 :     case DW_OP_breg24:</span>
<span class="lineNum">    2241 </span><span class="lineCov">    3870643 :     case DW_OP_breg25:</span>
<span class="lineNum">    2242 </span><span class="lineCov">    3870643 :     case DW_OP_breg26:</span>
<span class="lineNum">    2243 </span><span class="lineCov">    3870643 :     case DW_OP_breg27:</span>
<span class="lineNum">    2244 </span><span class="lineCov">    3870643 :     case DW_OP_breg28:</span>
<span class="lineNum">    2245 </span><span class="lineCov">    3870643 :     case DW_OP_breg29:</span>
<span class="lineNum">    2246 </span><span class="lineCov">    3870643 :     case DW_OP_breg30:</span>
<span class="lineNum">    2247 </span><span class="lineCov">    3870643 :     case DW_OP_breg31:</span>
<span class="lineNum">    2248 </span><span class="lineCov">    3870643 :       dw2_asm_output_data_sleb128 (val1-&gt;v.val_int, NULL);</span>
<span class="lineNum">    2249 </span><span class="lineCov">    3870643 :       break;</span>
<span class="lineNum">    2250 </span><span class="lineCov">      17991 :     case DW_OP_regx:</span>
<span class="lineNum">    2251 </span><span class="lineCov">      17991 :       {</span>
<span class="lineNum">    2252 </span><span class="lineCov">      17991 :         unsigned r = val1-&gt;v.val_unsigned;</span>
<span class="lineNum">    2253 </span><span class="lineCov">      17991 :         if (for_eh_or_skip &gt;= 0)</span>
<span class="lineNum">    2254 </span>            :           r = DWARF2_FRAME_REG_OUT (r, for_eh_or_skip);
<span class="lineNum">    2255 </span><span class="lineCov">      17991 :         gcc_assert (size_of_uleb128 (r) </span>
<span class="lineNum">    2256 </span>            :                     == size_of_uleb128 (val1-&gt;v.val_unsigned));
<span class="lineNum">    2257 </span><span class="lineCov">      17991 :         dw2_asm_output_data_uleb128 (r, NULL);  </span>
<span class="lineNum">    2258 </span>            :       }
<span class="lineNum">    2259 </span><span class="lineCov">      17991 :       break;</span>
<span class="lineNum">    2260 </span><span class="lineCov">    4500641 :     case DW_OP_fbreg:</span>
<span class="lineNum">    2261 </span><span class="lineCov">    4500641 :       dw2_asm_output_data_sleb128 (val1-&gt;v.val_int, NULL);</span>
<span class="lineNum">    2262 </span><span class="lineCov">    4500641 :       break;</span>
<span class="lineNum">    2263 </span><span class="lineNoCov">          0 :     case DW_OP_bregx:</span>
<span class="lineNum">    2264 </span><span class="lineNoCov">          0 :       {</span>
<span class="lineNum">    2265 </span><span class="lineNoCov">          0 :         unsigned r = val1-&gt;v.val_unsigned;</span>
<span class="lineNum">    2266 </span><span class="lineNoCov">          0 :         if (for_eh_or_skip &gt;= 0)</span>
<span class="lineNum">    2267 </span>            :           r = DWARF2_FRAME_REG_OUT (r, for_eh_or_skip);
<span class="lineNum">    2268 </span><span class="lineNoCov">          0 :         gcc_assert (size_of_uleb128 (r) </span>
<span class="lineNum">    2269 </span>            :                     == size_of_uleb128 (val1-&gt;v.val_unsigned));
<span class="lineNum">    2270 </span><span class="lineNoCov">          0 :         dw2_asm_output_data_uleb128 (r, NULL);  </span>
<span class="lineNum">    2271 </span><span class="lineNoCov">          0 :         dw2_asm_output_data_sleb128 (val2-&gt;v.val_int, NULL);</span>
<span class="lineNum">    2272 </span>            :       }
<span class="lineNum">    2273 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2274 </span><span class="lineCov">    2497753 :     case DW_OP_piece:</span>
<span class="lineNum">    2275 </span><span class="lineCov">    2497753 :       dw2_asm_output_data_uleb128 (val1-&gt;v.val_unsigned, NULL);</span>
<span class="lineNum">    2276 </span><span class="lineCov">    2497753 :       break;</span>
<span class="lineNum">    2277 </span><span class="lineCov">       2229 :     case DW_OP_bit_piece:</span>
<span class="lineNum">    2278 </span><span class="lineCov">       2229 :       dw2_asm_output_data_uleb128 (val1-&gt;v.val_unsigned, NULL);</span>
<span class="lineNum">    2279 </span><span class="lineCov">       2229 :       dw2_asm_output_data_uleb128 (val2-&gt;v.val_unsigned, NULL);</span>
<span class="lineNum">    2280 </span><span class="lineCov">       2229 :       break;</span>
<span class="lineNum">    2281 </span><span class="lineCov">      56173 :     case DW_OP_deref_size:</span>
<span class="lineNum">    2282 </span><span class="lineCov">      56173 :     case DW_OP_xderef_size:</span>
<span class="lineNum">    2283 </span><span class="lineCov">      56173 :       dw2_asm_output_data (1, val1-&gt;v.val_int, NULL);</span>
<span class="lineNum">    2284 </span><span class="lineCov">      56173 :       break;</span>
<span class="lineNum">    2285 </span>            : 
<span class="lineNum">    2286 </span><span class="lineCov">    1116053 :     case DW_OP_addr:</span>
<span class="lineNum">    2287 </span><span class="lineCov">    1116053 :       if (loc-&gt;dtprel)</span>
<span class="lineNum">    2288 </span>            :         {
<span class="lineNum">    2289 </span><span class="lineNoCov">          0 :           if (targetm.asm_out.output_dwarf_dtprel)</span>
<span class="lineNum">    2290 </span>            :             {
<span class="lineNum">    2291 </span><span class="lineNoCov">          0 :               targetm.asm_out.output_dwarf_dtprel (asm_out_file,</span>
<span class="lineNum">    2292 </span><span class="lineNoCov">          0 :                                                    DWARF2_ADDR_SIZE,</span>
<span class="lineNum">    2293 </span>            :                                                    val1-&gt;v.val_addr);
<span class="lineNum">    2294 </span><span class="lineNoCov">          0 :               fputc ('\n', asm_out_file);</span>
<span class="lineNum">    2295 </span>            :             }
<span class="lineNum">    2296 </span>            :           else
<span class="lineNum">    2297 </span><span class="lineNoCov">          0 :             gcc_unreachable ();</span>
<span class="lineNum">    2298 </span>            :         }
<span class="lineNum">    2299 </span>            :       else
<span class="lineNum">    2300 </span>            :         {
<span class="lineNum">    2301 </span>            : #ifdef DWARF2_DEBUGGING_INFO
<span class="lineNum">    2302 </span><span class="lineCov">    1168429 :           dw2_asm_output_addr_rtx (DWARF2_ADDR_SIZE, val1-&gt;v.val_addr, NULL);</span>
<span class="lineNum">    2303 </span>            : #else
<span class="lineNum">    2304 </span>            :           gcc_unreachable ();
<span class="lineNum">    2305 </span>            : #endif
<span class="lineNum">    2306 </span>            :         }
<span class="lineNum">    2307 </span>            :       break;
<span class="lineNum">    2308 </span>            : 
<span class="lineNum">    2309 </span><span class="lineCov">          7 :     case DW_OP_GNU_addr_index:</span>
<span class="lineNum">    2310 </span><span class="lineCov">          7 :     case DW_OP_addrx:</span>
<span class="lineNum">    2311 </span><span class="lineCov">          7 :     case DW_OP_GNU_const_index:</span>
<span class="lineNum">    2312 </span><span class="lineCov">          7 :     case DW_OP_constx:</span>
<span class="lineNum">    2313 </span><span class="lineCov">          7 :       gcc_assert (loc-&gt;dw_loc_oprnd1.val_entry-&gt;index != NO_INDEX_ASSIGNED);</span>
<span class="lineNum">    2314 </span><span class="lineCov">          7 :       dw2_asm_output_data_uleb128 (loc-&gt;dw_loc_oprnd1.val_entry-&gt;index,</span>
<span class="lineNum">    2315 </span>            :                                    &quot;(index into .debug_addr)&quot;);
<span class="lineNum">    2316 </span><span class="lineCov">          7 :       break;</span>
<span class="lineNum">    2317 </span>            : 
<span class="lineNum">    2318 </span><span class="lineCov">         82 :     case DW_OP_call2:</span>
<span class="lineNum">    2319 </span><span class="lineCov">         82 :     case DW_OP_call4:</span>
<span class="lineNum">    2320 </span><span class="lineCov">         82 :       {</span>
<span class="lineNum">    2321 </span><span class="lineCov">         82 :         unsigned long die_offset</span>
<span class="lineNum">    2322 </span><span class="lineCov">        164 :           = get_ref_die_offset (val1-&gt;v.val_die_ref.die);</span>
<span class="lineNum">    2323 </span>            :         /* Make sure the offset has been computed and that we can encode it as
<span class="lineNum">    2324 </span>            :            an operand.  */
<span class="lineNum">    2325 </span><span class="lineCov">         82 :         gcc_assert (die_offset &gt; 0</span>
<span class="lineNum">    2326 </span>            :                     &amp;&amp; die_offset &lt;= (loc-&gt;dw_loc_opc == DW_OP_call2
<span class="lineNum">    2327 </span>            :                                      ? 0xffff
<span class="lineNum">    2328 </span>            :                                      : 0xffffffff));
<span class="lineNum">    2329 </span><span class="lineCov">         82 :         dw2_asm_output_data ((loc-&gt;dw_loc_opc == DW_OP_call2) ? 2 : 4,</span>
<span class="lineNum">    2330 </span>            :                              die_offset, NULL);
<span class="lineNum">    2331 </span>            :       }
<span class="lineNum">    2332 </span><span class="lineCov">         82 :       break;</span>
<span class="lineNum">    2333 </span>            : 
<span class="lineNum">    2334 </span><span class="lineCov">        496 :     case DW_OP_call_ref:</span>
<span class="lineNum">    2335 </span><span class="lineCov">        496 :     case DW_OP_GNU_variable_value:</span>
<span class="lineNum">    2336 </span><span class="lineCov">        496 :       {</span>
<span class="lineNum">    2337 </span><span class="lineCov">        496 :         char label[MAX_ARTIFICIAL_LABEL_BYTES</span>
<span class="lineNum">    2338 </span>            :                    + HOST_BITS_PER_WIDE_INT / 2 + 2];
<span class="lineNum">    2339 </span><span class="lineCov">        496 :         gcc_assert (val1-&gt;val_class == dw_val_class_die_ref);</span>
<span class="lineNum">    2340 </span><span class="lineCov">        992 :         get_ref_die_offset_label (label, val1-&gt;v.val_die_ref.die);</span>
<span class="lineNum">    2341 </span><span class="lineCov">        496 :         dw2_asm_output_offset (DWARF_REF_SIZE, label, debug_info_section, NULL);</span>
<span class="lineNum">    2342 </span>            :       }
<span class="lineNum">    2343 </span><span class="lineCov">        496 :       break;</span>
<span class="lineNum">    2344 </span>            : 
<span class="lineNum">    2345 </span><span class="lineCov">     527705 :     case DW_OP_implicit_pointer:</span>
<span class="lineNum">    2346 </span><span class="lineCov">     527705 :     case DW_OP_GNU_implicit_pointer:</span>
<span class="lineNum">    2347 </span><span class="lineCov">     527705 :       {</span>
<span class="lineNum">    2348 </span><span class="lineCov">     527705 :         char label[MAX_ARTIFICIAL_LABEL_BYTES</span>
<span class="lineNum">    2349 </span>            :                    + HOST_BITS_PER_WIDE_INT / 2 + 2];
<span class="lineNum">    2350 </span><span class="lineCov">     527705 :         gcc_assert (val1-&gt;val_class == dw_val_class_die_ref);</span>
<span class="lineNum">    2351 </span><span class="lineCov">    1055410 :         get_ref_die_offset_label (label, val1-&gt;v.val_die_ref.die);</span>
<span class="lineNum">    2352 </span><span class="lineCov">     527705 :         dw2_asm_output_offset (DWARF_REF_SIZE, label, debug_info_section, NULL);</span>
<span class="lineNum">    2353 </span><span class="lineCov">     527705 :         dw2_asm_output_data_sleb128 (val2-&gt;v.val_int, NULL);</span>
<span class="lineNum">    2354 </span>            :       }
<span class="lineNum">    2355 </span><span class="lineCov">     527705 :       break;</span>
<span class="lineNum">    2356 </span>            : 
<span class="lineNum">    2357 </span><span class="lineCov">     863804 :     case DW_OP_entry_value:</span>
<span class="lineNum">    2358 </span><span class="lineCov">     863804 :     case DW_OP_GNU_entry_value:</span>
<span class="lineNum">    2359 </span><span class="lineCov">     863804 :       dw2_asm_output_data_uleb128 (size_of_locs (val1-&gt;v.val_loc), NULL);</span>
<span class="lineNum">    2360 </span><span class="lineCov">     863804 :       output_loc_sequence (val1-&gt;v.val_loc, for_eh_or_skip);</span>
<span class="lineNum">    2361 </span><span class="lineCov">     863804 :       break;</span>
<span class="lineNum">    2362 </span>            : 
<span class="lineNum">    2363 </span><span class="lineCov">      48535 :     case DW_OP_const_type:</span>
<span class="lineNum">    2364 </span><span class="lineCov">      48535 :     case DW_OP_GNU_const_type:</span>
<span class="lineNum">    2365 </span><span class="lineCov">      48535 :       {</span>
<span class="lineNum">    2366 </span><span class="lineCov">      48535 :         unsigned long o = get_base_type_offset (val1-&gt;v.val_die_ref.die), l;</span>
<span class="lineNum">    2367 </span><span class="lineCov">      48535 :         gcc_assert (o);</span>
<span class="lineNum">    2368 </span><span class="lineCov">      48535 :         dw2_asm_output_data_uleb128 (o, NULL);</span>
<span class="lineNum">    2369 </span><span class="lineCov">      48535 :         switch (val2-&gt;val_class)</span>
<span class="lineNum">    2370 </span>            :           {
<span class="lineNum">    2371 </span><span class="lineCov">       3782 :           case dw_val_class_const:</span>
<span class="lineNum">    2372 </span><span class="lineCov">       3782 :             l = HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR;</span>
<span class="lineNum">    2373 </span><span class="lineCov">       3782 :             dw2_asm_output_data (1, l, NULL);</span>
<span class="lineNum">    2374 </span><span class="lineCov">       3782 :             dw2_asm_output_data (l, val2-&gt;v.val_int, NULL);</span>
<span class="lineNum">    2375 </span><span class="lineCov">       3782 :             break;</span>
<span class="lineNum">    2376 </span><span class="lineCov">      44672 :           case dw_val_class_vec:</span>
<span class="lineNum">    2377 </span><span class="lineCov">      44672 :             {</span>
<span class="lineNum">    2378 </span><span class="lineCov">      44672 :               unsigned int elt_size = val2-&gt;v.val_vec.elt_size;</span>
<span class="lineNum">    2379 </span><span class="lineCov">      44672 :               unsigned int len = val2-&gt;v.val_vec.length;</span>
<span class="lineNum">    2380 </span><span class="lineCov">      44672 :               unsigned int i;</span>
<span class="lineNum">    2381 </span><span class="lineCov">      44672 :               unsigned char *p;</span>
<span class="lineNum">    2382 </span>            : 
<span class="lineNum">    2383 </span><span class="lineCov">      44672 :               l = len * elt_size;</span>
<span class="lineNum">    2384 </span><span class="lineCov">      44672 :               dw2_asm_output_data (1, l, NULL);</span>
<span class="lineNum">    2385 </span><span class="lineCov">      44672 :               if (elt_size &gt; sizeof (HOST_WIDE_INT))</span>
<span class="lineNum">    2386 </span>            :                 {
<span class="lineNum">    2387 </span><span class="lineNoCov">          0 :                   elt_size /= 2;</span>
<span class="lineNum">    2388 </span><span class="lineNoCov">          0 :                   len *= 2;</span>
<span class="lineNum">    2389 </span>            :                 }
<span class="lineNum">    2390 </span><span class="lineCov">      44672 :               for (i = 0, p = (unsigned char *) val2-&gt;v.val_vec.array;</span>
<span class="lineNum">    2391 </span><span class="lineCov">     180197 :                    i &lt; len;</span>
<span class="lineNum">    2392 </span><span class="lineCov">     135525 :                    i++, p += elt_size)</span>
<span class="lineNum">    2393 </span><span class="lineCov">     271050 :                 dw2_asm_output_data (elt_size, extract_int (p, elt_size),</span>
<span class="lineNum">    2394 </span><span class="lineCov">      44672 :                                      &quot;fp or vector constant word %u&quot;, i);</span>
<span class="lineNum">    2395 </span>            :             }
<span class="lineNum">    2396 </span>            :             break;
<span class="lineNum">    2397 </span><span class="lineCov">         16 :           case dw_val_class_const_double:</span>
<span class="lineNum">    2398 </span><span class="lineCov">         16 :             {</span>
<span class="lineNum">    2399 </span><span class="lineCov">         16 :               unsigned HOST_WIDE_INT first, second;</span>
<span class="lineNum">    2400 </span><span class="lineCov">         16 :               l = HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR;</span>
<span class="lineNum">    2401 </span>            : 
<span class="lineNum">    2402 </span><span class="lineCov">         16 :               dw2_asm_output_data (1, 2 * l, NULL);</span>
<span class="lineNum">    2403 </span><span class="lineCov">         16 :               if (WORDS_BIG_ENDIAN)</span>
<span class="lineNum">    2404 </span>            :                 {
<span class="lineNum">    2405 </span>            :                   first = val2-&gt;v.val_double.high;
<span class="lineNum">    2406 </span>            :                   second = val2-&gt;v.val_double.low;
<span class="lineNum">    2407 </span>            :                 }
<span class="lineNum">    2408 </span>            :               else
<span class="lineNum">    2409 </span>            :                 {
<span class="lineNum">    2410 </span><span class="lineCov">         16 :                   first = val2-&gt;v.val_double.low;</span>
<span class="lineNum">    2411 </span><span class="lineCov">         16 :                   second = val2-&gt;v.val_double.high;</span>
<span class="lineNum">    2412 </span>            :                 }
<span class="lineNum">    2413 </span><span class="lineCov">         16 :               dw2_asm_output_data (l, first, NULL);</span>
<span class="lineNum">    2414 </span><span class="lineCov">         16 :               dw2_asm_output_data (l, second, NULL);</span>
<span class="lineNum">    2415 </span>            :             }
<span class="lineNum">    2416 </span><span class="lineCov">         16 :             break;</span>
<span class="lineNum">    2417 </span><span class="lineCov">         65 :           case dw_val_class_wide_int:</span>
<span class="lineNum">    2418 </span><span class="lineCov">         65 :             {</span>
<span class="lineNum">    2419 </span><span class="lineCov">         65 :               int i;</span>
<span class="lineNum">    2420 </span><span class="lineCov">         65 :               int len = get_full_len (*val2-&gt;v.val_wide);</span>
<span class="lineNum">    2421 </span><span class="lineCov">         65 :               l = HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR;</span>
<span class="lineNum">    2422 </span>            : 
<span class="lineNum">    2423 </span><span class="lineCov">         65 :               dw2_asm_output_data (1, len * l, NULL);</span>
<span class="lineNum">    2424 </span><span class="lineCov">         65 :               if (WORDS_BIG_ENDIAN)</span>
<span class="lineNum">    2425 </span>            :                 for (i = len - 1; i &gt;= 0; --i)
<span class="lineNum">    2426 </span>            :                   dw2_asm_output_data (l, val2-&gt;v.val_wide-&gt;elt (i), NULL);
<span class="lineNum">    2427 </span>            :               else
<span class="lineNum">    2428 </span><span class="lineCov">        145 :                 for (i = 0; i &lt; len; ++i)</span>
<span class="lineNum">    2429 </span><span class="lineCov">        160 :                   dw2_asm_output_data (l, val2-&gt;v.val_wide-&gt;elt (i), NULL);</span>
<span class="lineNum">    2430 </span>            :             }
<span class="lineNum">    2431 </span>            :             break;
<span class="lineNum">    2432 </span><span class="lineNoCov">          0 :           default:</span>
<span class="lineNum">    2433 </span><span class="lineNoCov">          0 :             gcc_unreachable ();</span>
<span class="lineNum">    2434 </span>            :           }
<span class="lineNum">    2435 </span>            :       }
<span class="lineNum">    2436 </span>            :       break;
<span class="lineNum">    2437 </span><span class="lineCov">      44422 :     case DW_OP_regval_type:</span>
<span class="lineNum">    2438 </span><span class="lineCov">      44422 :     case DW_OP_GNU_regval_type:</span>
<span class="lineNum">    2439 </span><span class="lineCov">      44422 :       {</span>
<span class="lineNum">    2440 </span><span class="lineCov">      44422 :         unsigned r = val1-&gt;v.val_unsigned;</span>
<span class="lineNum">    2441 </span><span class="lineCov">      44422 :         unsigned long o = get_base_type_offset (val2-&gt;v.val_die_ref.die);</span>
<span class="lineNum">    2442 </span><span class="lineCov">      44422 :         gcc_assert (o);</span>
<span class="lineNum">    2443 </span><span class="lineCov">      44422 :         if (for_eh_or_skip &gt;= 0)</span>
<span class="lineNum">    2444 </span>            :           {
<span class="lineNum">    2445 </span><span class="lineNoCov">          0 :             r = DWARF2_FRAME_REG_OUT (r, for_eh_or_skip);</span>
<span class="lineNum">    2446 </span><span class="lineNoCov">          0 :             gcc_assert (size_of_uleb128 (r)</span>
<span class="lineNum">    2447 </span>            :                         == size_of_uleb128 (val1-&gt;v.val_unsigned));
<span class="lineNum">    2448 </span>            :           }
<span class="lineNum">    2449 </span><span class="lineCov">      44422 :         dw2_asm_output_data_uleb128 (r, NULL);</span>
<span class="lineNum">    2450 </span><span class="lineCov">      44422 :         dw2_asm_output_data_uleb128 (o, NULL);</span>
<span class="lineNum">    2451 </span>            :       }
<span class="lineNum">    2452 </span><span class="lineCov">      44422 :       break;</span>
<span class="lineNum">    2453 </span><span class="lineCov">      52582 :     case DW_OP_deref_type:</span>
<span class="lineNum">    2454 </span><span class="lineCov">      52582 :     case DW_OP_GNU_deref_type:</span>
<span class="lineNum">    2455 </span><span class="lineCov">      52582 :       {</span>
<span class="lineNum">    2456 </span><span class="lineCov">      52582 :         unsigned long o = get_base_type_offset (val2-&gt;v.val_die_ref.die);</span>
<span class="lineNum">    2457 </span><span class="lineCov">      52582 :         gcc_assert (o);</span>
<span class="lineNum">    2458 </span><span class="lineCov">      52582 :         dw2_asm_output_data (1, val1-&gt;v.val_int, NULL);</span>
<span class="lineNum">    2459 </span><span class="lineCov">      52582 :         dw2_asm_output_data_uleb128 (o, NULL);</span>
<span class="lineNum">    2460 </span>            :       }
<span class="lineNum">    2461 </span><span class="lineCov">      52582 :       break;</span>
<span class="lineNum">    2462 </span><span class="lineCov">      73691 :     case DW_OP_convert:</span>
<span class="lineNum">    2463 </span><span class="lineCov">      73691 :     case DW_OP_reinterpret:</span>
<span class="lineNum">    2464 </span><span class="lineCov">      73691 :     case DW_OP_GNU_convert:</span>
<span class="lineNum">    2465 </span><span class="lineCov">      73691 :     case DW_OP_GNU_reinterpret:</span>
<span class="lineNum">    2466 </span><span class="lineCov">      73691 :       if (loc-&gt;dw_loc_oprnd1.val_class == dw_val_class_unsigned_const)</span>
<span class="lineNum">    2467 </span><span class="lineCov">       3472 :         dw2_asm_output_data_uleb128 (val1-&gt;v.val_unsigned, NULL);</span>
<span class="lineNum">    2468 </span>            :       else
<span class="lineNum">    2469 </span>            :         {
<span class="lineNum">    2470 </span><span class="lineCov">      70219 :           unsigned long o = get_base_type_offset (val1-&gt;v.val_die_ref.die);</span>
<span class="lineNum">    2471 </span><span class="lineCov">      70219 :           gcc_assert (o);</span>
<span class="lineNum">    2472 </span><span class="lineCov">      70219 :           dw2_asm_output_data_uleb128 (o, NULL);</span>
<span class="lineNum">    2473 </span>            :         }
<span class="lineNum">    2474 </span>            :       break;
<span class="lineNum">    2475 </span>            : 
<span class="lineNum">    2476 </span><span class="lineCov">       4912 :     case DW_OP_GNU_parameter_ref:</span>
<span class="lineNum">    2477 </span><span class="lineCov">       4912 :       {</span>
<span class="lineNum">    2478 </span><span class="lineCov">       4912 :         unsigned long o;</span>
<span class="lineNum">    2479 </span><span class="lineCov">       4912 :         gcc_assert (val1-&gt;val_class == dw_val_class_die_ref);</span>
<span class="lineNum">    2480 </span><span class="lineCov">       9824 :         o = get_ref_die_offset (val1-&gt;v.val_die_ref.die);</span>
<span class="lineNum">    2481 </span><span class="lineCov">       4912 :         dw2_asm_output_data (4, o, NULL);</span>
<span class="lineNum">    2482 </span>            :       }
<span class="lineNum">    2483 </span><span class="lineCov">       4912 :       break;</span>
<span class="lineNum">    2484 </span>            : 
<span class="lineNum">    2485 </span>            :     default:
<span class="lineNum">    2486 </span>            :       /* Other codes have no operands.  */
<span class="lineNum">    2487 </span>            :       break;
<span class="lineNum">    2488 </span>            :     }
<span class="lineNum">    2489 </span><span class="lineCov">   35250735 : }</span>
<span class="lineNum">    2490 </span>            : 
<span class="lineNum">    2491 </span>            : /* Output a sequence of location operations.  
<span class="lineNum">    2492 </span>            :    The for_eh_or_skip parameter controls whether register numbers are
<span class="lineNum">    2493 </span>            :    converted using DWARF2_FRAME_REG_OUT, which is needed in the case that
<span class="lineNum">    2494 </span>            :    hard reg numbers have been processed via DWARF_FRAME_REGNUM (i.e. for unwind
<span class="lineNum">    2495 </span>            :    info).  This should be suppressed for the cases that have not been converted
<span class="lineNum">    2496 </span>            :    (i.e. symbolic debug info), by setting the parameter &lt; 0.  See PR47324.  */
<a name="2497"><span class="lineNum">    2497 </span>            : </a>
<span class="lineNum">    2498 </span>            : void
<span class="lineNum">    2499 </span><span class="lineCov">   20516981 : output_loc_sequence (dw_loc_descr_ref loc, int for_eh_or_skip)</span>
<span class="lineNum">    2500 </span>            : {
<span class="lineNum">    2501 </span><span class="lineCov">   55767716 :   for (; loc != NULL; loc = loc-&gt;dw_loc_next)</span>
<span class="lineNum">    2502 </span>            :     {
<span class="lineNum">    2503 </span><span class="lineCov">   35250735 :       enum dwarf_location_atom opc = loc-&gt;dw_loc_opc;</span>
<span class="lineNum">    2504 </span>            :       /* Output the opcode.  */
<span class="lineNum">    2505 </span><span class="lineCov">   70501470 :       if (for_eh_or_skip &gt;= 0 </span>
<span class="lineNum">    2506 </span><span class="lineCov">   35250735 :           &amp;&amp; opc &gt;= DW_OP_breg0 &amp;&amp; opc &lt;= DW_OP_breg31)</span>
<span class="lineNum">    2507 </span>            :         {
<span class="lineNum">    2508 </span><span class="lineNoCov">          0 :           unsigned r = (opc - DW_OP_breg0);</span>
<span class="lineNum">    2509 </span><span class="lineNoCov">          0 :           r = DWARF2_FRAME_REG_OUT (r, for_eh_or_skip);</span>
<span class="lineNum">    2510 </span><span class="lineNoCov">          0 :           gcc_assert (r &lt;= 31);</span>
<span class="lineNum">    2511 </span>            :           opc = (enum dwarf_location_atom) (DW_OP_breg0 + r);
<span class="lineNum">    2512 </span>            :         }
<span class="lineNum">    2513 </span><span class="lineCov">   70501470 :       else if (for_eh_or_skip &gt;= 0 </span>
<span class="lineNum">    2514 </span><span class="lineCov">   35250735 :                &amp;&amp; opc &gt;= DW_OP_reg0 &amp;&amp; opc &lt;= DW_OP_reg31)</span>
<span class="lineNum">    2515 </span>            :         {
<span class="lineNum">    2516 </span><span class="lineNoCov">          0 :           unsigned r = (opc - DW_OP_reg0);</span>
<span class="lineNum">    2517 </span><span class="lineNoCov">          0 :           r = DWARF2_FRAME_REG_OUT (r, for_eh_or_skip);</span>
<span class="lineNum">    2518 </span><span class="lineNoCov">          0 :           gcc_assert (r &lt;= 31);</span>
<span class="lineNum">    2519 </span>            :           opc = (enum dwarf_location_atom) (DW_OP_reg0 + r);
<span class="lineNum">    2520 </span>            :         }
<span class="lineNum">    2521 </span>            : 
<span class="lineNum">    2522 </span><span class="lineCov">   70501470 :       dw2_asm_output_data (1, opc,</span>
<span class="lineNum">    2523 </span>            :                              &quot;%s&quot;, dwarf_stack_op_name (opc));
<span class="lineNum">    2524 </span>            : 
<span class="lineNum">    2525 </span>            :       /* Output the operand(s) (if any).  */
<span class="lineNum">    2526 </span><span class="lineCov">   35250735 :       output_loc_operands (loc, for_eh_or_skip);</span>
<span class="lineNum">    2527 </span>            :     }
<span class="lineNum">    2528 </span><span class="lineCov">   20516981 : }</span>
<span class="lineNum">    2529 </span>            : 
<span class="lineNum">    2530 </span>            : /* Output location description stack opcode's operands (if any).
<span class="lineNum">    2531 </span>            :    The output is single bytes on a line, suitable for .cfi_escape.  */
<a name="2532"><span class="lineNum">    2532 </span>            : </a>
<span class="lineNum">    2533 </span>            : static void
<span class="lineNum">    2534 </span><span class="lineCov">      56548 : output_loc_operands_raw (dw_loc_descr_ref loc)</span>
<span class="lineNum">    2535 </span>            : {
<span class="lineNum">    2536 </span><span class="lineCov">      56548 :   dw_val_ref val1 = &amp;loc-&gt;dw_loc_oprnd1;</span>
<span class="lineNum">    2537 </span><span class="lineCov">      56548 :   dw_val_ref val2 = &amp;loc-&gt;dw_loc_oprnd2;</span>
<span class="lineNum">    2538 </span>            : 
<span class="lineNum">    2539 </span><span class="lineCov">      56548 :   switch (loc-&gt;dw_loc_opc)</span>
<span class="lineNum">    2540 </span>            :     {
<span class="lineNum">    2541 </span><span class="lineNoCov">          0 :     case DW_OP_addr:</span>
<span class="lineNum">    2542 </span><span class="lineNoCov">          0 :     case DW_OP_GNU_addr_index:</span>
<span class="lineNum">    2543 </span><span class="lineNoCov">          0 :     case DW_OP_addrx:</span>
<span class="lineNum">    2544 </span><span class="lineNoCov">          0 :     case DW_OP_GNU_const_index:</span>
<span class="lineNum">    2545 </span><span class="lineNoCov">          0 :     case DW_OP_constx:</span>
<span class="lineNum">    2546 </span><span class="lineNoCov">          0 :     case DW_OP_implicit_value:</span>
<span class="lineNum">    2547 </span>            :       /* We cannot output addresses in .cfi_escape, only bytes.  */
<span class="lineNum">    2548 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">    2549 </span>            : 
<span class="lineNum">    2550 </span><span class="lineNoCov">          0 :     case DW_OP_const1u:</span>
<span class="lineNum">    2551 </span><span class="lineNoCov">          0 :     case DW_OP_const1s:</span>
<span class="lineNum">    2552 </span><span class="lineNoCov">          0 :     case DW_OP_pick:</span>
<span class="lineNum">    2553 </span><span class="lineNoCov">          0 :     case DW_OP_deref_size:</span>
<span class="lineNum">    2554 </span><span class="lineNoCov">          0 :     case DW_OP_xderef_size:</span>
<span class="lineNum">    2555 </span><span class="lineNoCov">          0 :       fputc (',', asm_out_file);</span>
<span class="lineNum">    2556 </span><span class="lineNoCov">          0 :       dw2_asm_output_data_raw (1, val1-&gt;v.val_int);</span>
<span class="lineNum">    2557 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2558 </span>            : 
<span class="lineNum">    2559 </span><span class="lineNoCov">          0 :     case DW_OP_const2u:</span>
<span class="lineNum">    2560 </span><span class="lineNoCov">          0 :     case DW_OP_const2s:</span>
<span class="lineNum">    2561 </span><span class="lineNoCov">          0 :       fputc (',', asm_out_file);</span>
<span class="lineNum">    2562 </span><span class="lineNoCov">          0 :       dw2_asm_output_data_raw (2, val1-&gt;v.val_int);</span>
<span class="lineNum">    2563 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2564 </span>            : 
<span class="lineNum">    2565 </span><span class="lineNoCov">          0 :     case DW_OP_const4u:</span>
<span class="lineNum">    2566 </span><span class="lineNoCov">          0 :     case DW_OP_const4s:</span>
<span class="lineNum">    2567 </span><span class="lineNoCov">          0 :       fputc (',', asm_out_file);</span>
<span class="lineNum">    2568 </span><span class="lineNoCov">          0 :       dw2_asm_output_data_raw (4, val1-&gt;v.val_int);</span>
<span class="lineNum">    2569 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2570 </span>            : 
<span class="lineNum">    2571 </span><span class="lineNoCov">          0 :     case DW_OP_const8u:</span>
<span class="lineNum">    2572 </span><span class="lineNoCov">          0 :     case DW_OP_const8s:</span>
<span class="lineNum">    2573 </span><span class="lineNoCov">          0 :       gcc_assert (HOST_BITS_PER_WIDE_INT &gt;= 64);</span>
<span class="lineNum">    2574 </span><span class="lineNoCov">          0 :       fputc (',', asm_out_file);</span>
<span class="lineNum">    2575 </span><span class="lineNoCov">          0 :       dw2_asm_output_data_raw (8, val1-&gt;v.val_int);</span>
<span class="lineNum">    2576 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2577 </span>            : 
<span class="lineNum">    2578 </span><span class="lineNoCov">          0 :     case DW_OP_skip:</span>
<span class="lineNum">    2579 </span><span class="lineNoCov">          0 :     case DW_OP_bra:</span>
<span class="lineNum">    2580 </span><span class="lineNoCov">          0 :       {</span>
<span class="lineNum">    2581 </span><span class="lineNoCov">          0 :         int offset;</span>
<span class="lineNum">    2582 </span>            : 
<span class="lineNum">    2583 </span><span class="lineNoCov">          0 :         gcc_assert (val1-&gt;val_class == dw_val_class_loc);</span>
<span class="lineNum">    2584 </span><span class="lineNoCov">          0 :         offset = val1-&gt;v.val_loc-&gt;dw_loc_addr - (loc-&gt;dw_loc_addr + 3);</span>
<span class="lineNum">    2585 </span>            : 
<span class="lineNum">    2586 </span><span class="lineNoCov">          0 :         fputc (',', asm_out_file);</span>
<span class="lineNum">    2587 </span><span class="lineNoCov">          0 :         dw2_asm_output_data_raw (2, offset);</span>
<span class="lineNum">    2588 </span>            :       }
<span class="lineNum">    2589 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2590 </span>            : 
<span class="lineNum">    2591 </span><span class="lineNoCov">          0 :     case DW_OP_regx:</span>
<span class="lineNum">    2592 </span><span class="lineNoCov">          0 :       {</span>
<span class="lineNum">    2593 </span><span class="lineNoCov">          0 :         unsigned r = DWARF2_FRAME_REG_OUT (val1-&gt;v.val_unsigned, 1);</span>
<span class="lineNum">    2594 </span><span class="lineNoCov">          0 :         gcc_assert (size_of_uleb128 (r) </span>
<span class="lineNum">    2595 </span>            :                     == size_of_uleb128 (val1-&gt;v.val_unsigned));
<span class="lineNum">    2596 </span><span class="lineNoCov">          0 :         fputc (',', asm_out_file);</span>
<span class="lineNum">    2597 </span><span class="lineNoCov">          0 :         dw2_asm_output_data_uleb128_raw (r);</span>
<span class="lineNum">    2598 </span>            :       }
<span class="lineNum">    2599 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2600 </span>            :       
<span class="lineNum">    2601 </span><span class="lineNoCov">          0 :     case DW_OP_constu:</span>
<span class="lineNum">    2602 </span><span class="lineNoCov">          0 :     case DW_OP_plus_uconst:</span>
<span class="lineNum">    2603 </span><span class="lineNoCov">          0 :     case DW_OP_piece:</span>
<span class="lineNum">    2604 </span><span class="lineNoCov">          0 :       fputc (',', asm_out_file);</span>
<span class="lineNum">    2605 </span><span class="lineNoCov">          0 :       dw2_asm_output_data_uleb128_raw (val1-&gt;v.val_unsigned);</span>
<span class="lineNum">    2606 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2607 </span>            : 
<span class="lineNum">    2608 </span><span class="lineNoCov">          0 :     case DW_OP_bit_piece:</span>
<span class="lineNum">    2609 </span><span class="lineNoCov">          0 :       fputc (',', asm_out_file);</span>
<span class="lineNum">    2610 </span><span class="lineNoCov">          0 :       dw2_asm_output_data_uleb128_raw (val1-&gt;v.val_unsigned);</span>
<span class="lineNum">    2611 </span><span class="lineNoCov">          0 :       dw2_asm_output_data_uleb128_raw (val2-&gt;v.val_unsigned);</span>
<span class="lineNum">    2612 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2613 </span>            : 
<span class="lineNum">    2614 </span><span class="lineCov">      49661 :     case DW_OP_consts:</span>
<span class="lineNum">    2615 </span><span class="lineCov">      49661 :     case DW_OP_breg0:</span>
<span class="lineNum">    2616 </span><span class="lineCov">      49661 :     case DW_OP_breg1:</span>
<span class="lineNum">    2617 </span><span class="lineCov">      49661 :     case DW_OP_breg2:</span>
<span class="lineNum">    2618 </span><span class="lineCov">      49661 :     case DW_OP_breg3:</span>
<span class="lineNum">    2619 </span><span class="lineCov">      49661 :     case DW_OP_breg4:</span>
<span class="lineNum">    2620 </span><span class="lineCov">      49661 :     case DW_OP_breg5:</span>
<span class="lineNum">    2621 </span><span class="lineCov">      49661 :     case DW_OP_breg6:</span>
<span class="lineNum">    2622 </span><span class="lineCov">      49661 :     case DW_OP_breg7:</span>
<span class="lineNum">    2623 </span><span class="lineCov">      49661 :     case DW_OP_breg8:</span>
<span class="lineNum">    2624 </span><span class="lineCov">      49661 :     case DW_OP_breg9:</span>
<span class="lineNum">    2625 </span><span class="lineCov">      49661 :     case DW_OP_breg10:</span>
<span class="lineNum">    2626 </span><span class="lineCov">      49661 :     case DW_OP_breg11:</span>
<span class="lineNum">    2627 </span><span class="lineCov">      49661 :     case DW_OP_breg12:</span>
<span class="lineNum">    2628 </span><span class="lineCov">      49661 :     case DW_OP_breg13:</span>
<span class="lineNum">    2629 </span><span class="lineCov">      49661 :     case DW_OP_breg14:</span>
<span class="lineNum">    2630 </span><span class="lineCov">      49661 :     case DW_OP_breg15:</span>
<span class="lineNum">    2631 </span><span class="lineCov">      49661 :     case DW_OP_breg16:</span>
<span class="lineNum">    2632 </span><span class="lineCov">      49661 :     case DW_OP_breg17:</span>
<span class="lineNum">    2633 </span><span class="lineCov">      49661 :     case DW_OP_breg18:</span>
<span class="lineNum">    2634 </span><span class="lineCov">      49661 :     case DW_OP_breg19:</span>
<span class="lineNum">    2635 </span><span class="lineCov">      49661 :     case DW_OP_breg20:</span>
<span class="lineNum">    2636 </span><span class="lineCov">      49661 :     case DW_OP_breg21:</span>
<span class="lineNum">    2637 </span><span class="lineCov">      49661 :     case DW_OP_breg22:</span>
<span class="lineNum">    2638 </span><span class="lineCov">      49661 :     case DW_OP_breg23:</span>
<span class="lineNum">    2639 </span><span class="lineCov">      49661 :     case DW_OP_breg24:</span>
<span class="lineNum">    2640 </span><span class="lineCov">      49661 :     case DW_OP_breg25:</span>
<span class="lineNum">    2641 </span><span class="lineCov">      49661 :     case DW_OP_breg26:</span>
<span class="lineNum">    2642 </span><span class="lineCov">      49661 :     case DW_OP_breg27:</span>
<span class="lineNum">    2643 </span><span class="lineCov">      49661 :     case DW_OP_breg28:</span>
<span class="lineNum">    2644 </span><span class="lineCov">      49661 :     case DW_OP_breg29:</span>
<span class="lineNum">    2645 </span><span class="lineCov">      49661 :     case DW_OP_breg30:</span>
<span class="lineNum">    2646 </span><span class="lineCov">      49661 :     case DW_OP_breg31:</span>
<span class="lineNum">    2647 </span><span class="lineCov">      49661 :     case DW_OP_fbreg:</span>
<span class="lineNum">    2648 </span><span class="lineCov">      49661 :       fputc (',', asm_out_file);</span>
<span class="lineNum">    2649 </span><span class="lineCov">      49661 :       dw2_asm_output_data_sleb128_raw (val1-&gt;v.val_int);</span>
<span class="lineNum">    2650 </span><span class="lineCov">      49661 :       break;</span>
<span class="lineNum">    2651 </span>            : 
<span class="lineNum">    2652 </span><span class="lineNoCov">          0 :     case DW_OP_bregx:</span>
<span class="lineNum">    2653 </span><span class="lineNoCov">          0 :       {</span>
<span class="lineNum">    2654 </span><span class="lineNoCov">          0 :         unsigned r = DWARF2_FRAME_REG_OUT (val1-&gt;v.val_unsigned, 1);</span>
<span class="lineNum">    2655 </span><span class="lineNoCov">          0 :         gcc_assert (size_of_uleb128 (r) </span>
<span class="lineNum">    2656 </span>            :                     == size_of_uleb128 (val1-&gt;v.val_unsigned));
<span class="lineNum">    2657 </span><span class="lineNoCov">          0 :         fputc (',', asm_out_file);</span>
<span class="lineNum">    2658 </span><span class="lineNoCov">          0 :         dw2_asm_output_data_uleb128_raw (r);</span>
<span class="lineNum">    2659 </span><span class="lineNoCov">          0 :         fputc (',', asm_out_file);</span>
<span class="lineNum">    2660 </span><span class="lineNoCov">          0 :         dw2_asm_output_data_sleb128_raw (val2-&gt;v.val_int);</span>
<span class="lineNum">    2661 </span>            :       }
<span class="lineNum">    2662 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2663 </span>            : 
<span class="lineNum">    2664 </span><span class="lineNoCov">          0 :     case DW_OP_implicit_pointer:</span>
<span class="lineNum">    2665 </span><span class="lineNoCov">          0 :     case DW_OP_entry_value:</span>
<span class="lineNum">    2666 </span><span class="lineNoCov">          0 :     case DW_OP_const_type:</span>
<span class="lineNum">    2667 </span><span class="lineNoCov">          0 :     case DW_OP_regval_type:</span>
<span class="lineNum">    2668 </span><span class="lineNoCov">          0 :     case DW_OP_deref_type:</span>
<span class="lineNum">    2669 </span><span class="lineNoCov">          0 :     case DW_OP_convert:</span>
<span class="lineNum">    2670 </span><span class="lineNoCov">          0 :     case DW_OP_reinterpret:</span>
<span class="lineNum">    2671 </span><span class="lineNoCov">          0 :     case DW_OP_GNU_implicit_pointer:</span>
<span class="lineNum">    2672 </span><span class="lineNoCov">          0 :     case DW_OP_GNU_entry_value:</span>
<span class="lineNum">    2673 </span><span class="lineNoCov">          0 :     case DW_OP_GNU_const_type:</span>
<span class="lineNum">    2674 </span><span class="lineNoCov">          0 :     case DW_OP_GNU_regval_type:</span>
<span class="lineNum">    2675 </span><span class="lineNoCov">          0 :     case DW_OP_GNU_deref_type:</span>
<span class="lineNum">    2676 </span><span class="lineNoCov">          0 :     case DW_OP_GNU_convert:</span>
<span class="lineNum">    2677 </span><span class="lineNoCov">          0 :     case DW_OP_GNU_reinterpret:</span>
<span class="lineNum">    2678 </span><span class="lineNoCov">          0 :     case DW_OP_GNU_parameter_ref:</span>
<span class="lineNum">    2679 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">    2680 </span>            :       break;
<span class="lineNum">    2681 </span>            : 
<span class="lineNum">    2682 </span>            :     default:
<span class="lineNum">    2683 </span>            :       /* Other codes have no operands.  */
<span class="lineNum">    2684 </span>            :       break;
<span class="lineNum">    2685 </span>            :     }
<span class="lineNum">    2686 </span><span class="lineCov">      56548 : }</span>
<a name="2687"><span class="lineNum">    2687 </span>            : </a>
<span class="lineNum">    2688 </span>            : void
<span class="lineNum">    2689 </span><span class="lineCov">      49661 : output_loc_sequence_raw (dw_loc_descr_ref loc)</span>
<span class="lineNum">    2690 </span>            : {
<span class="lineNum">    2691 </span><span class="lineCov">      56548 :   while (1)</span>
<span class="lineNum">    2692 </span>            :     {
<span class="lineNum">    2693 </span><span class="lineCov">      56548 :       enum dwarf_location_atom opc = loc-&gt;dw_loc_opc;</span>
<span class="lineNum">    2694 </span>            :       /* Output the opcode.  */
<span class="lineNum">    2695 </span><span class="lineCov">      56548 :       if (opc &gt;= DW_OP_breg0 &amp;&amp; opc &lt;= DW_OP_breg31)</span>
<span class="lineNum">    2696 </span>            :         {
<span class="lineNum">    2697 </span><span class="lineCov">      49661 :           unsigned r = (opc - DW_OP_breg0);</span>
<span class="lineNum">    2698 </span><span class="lineCov">      49661 :           r = DWARF2_FRAME_REG_OUT (r, 1);</span>
<span class="lineNum">    2699 </span><span class="lineCov">      49661 :           gcc_assert (r &lt;= 31);</span>
<span class="lineNum">    2700 </span>            :           opc = (enum dwarf_location_atom) (DW_OP_breg0 + r);
<span class="lineNum">    2701 </span>            :         }
<span class="lineNum">    2702 </span><span class="lineCov">       6887 :       else if (opc &gt;= DW_OP_reg0 &amp;&amp; opc &lt;= DW_OP_reg31)</span>
<span class="lineNum">    2703 </span>            :         {
<span class="lineNum">    2704 </span><span class="lineNoCov">          0 :           unsigned r = (opc - DW_OP_reg0);</span>
<span class="lineNum">    2705 </span><span class="lineNoCov">          0 :           r = DWARF2_FRAME_REG_OUT (r, 1);</span>
<span class="lineNum">    2706 </span><span class="lineNoCov">          0 :           gcc_assert (r &lt;= 31);</span>
<span class="lineNum">    2707 </span>            :           opc = (enum dwarf_location_atom) (DW_OP_reg0 + r);
<span class="lineNum">    2708 </span>            :         }
<span class="lineNum">    2709 </span>            :       /* Output the opcode.  */
<span class="lineNum">    2710 </span><span class="lineCov">      56548 :       fprintf (asm_out_file, &quot;%#x&quot;, opc);</span>
<span class="lineNum">    2711 </span><span class="lineCov">      56548 :       output_loc_operands_raw (loc);</span>
<span class="lineNum">    2712 </span>            : 
<span class="lineNum">    2713 </span><span class="lineCov">      56548 :       if (!loc-&gt;dw_loc_next)</span>
<span class="lineNum">    2714 </span>            :         break;
<span class="lineNum">    2715 </span><span class="lineCov">       6887 :       loc = loc-&gt;dw_loc_next;</span>
<span class="lineNum">    2716 </span>            : 
<span class="lineNum">    2717 </span><span class="lineCov">       6887 :       fputc (',', asm_out_file);</span>
<span class="lineNum">    2718 </span><span class="lineCov">       6887 :     }</span>
<span class="lineNum">    2719 </span><span class="lineCov">      49661 : }</span>
<span class="lineNum">    2720 </span>            : 
<span class="lineNum">    2721 </span>            : /* This function builds a dwarf location descriptor sequence from a
<span class="lineNum">    2722 </span>            :    dw_cfa_location, adding the given OFFSET to the result of the
<span class="lineNum">    2723 </span>            :    expression.  */
<a name="2724"><span class="lineNum">    2724 </span>            : </a>
<span class="lineNum">    2725 </span>            : struct dw_loc_descr_node *
<span class="lineNum">    2726 </span><span class="lineCov">      13195 : build_cfa_loc (dw_cfa_location *cfa, poly_int64 offset)</span>
<span class="lineNum">    2727 </span>            : {
<span class="lineNum">    2728 </span><span class="lineCov">      13195 :   struct dw_loc_descr_node *head, *tmp;</span>
<span class="lineNum">    2729 </span>            : 
<span class="lineNum">    2730 </span><span class="lineCov">      13195 :   offset += cfa-&gt;offset;</span>
<span class="lineNum">    2731 </span>            : 
<span class="lineNum">    2732 </span><span class="lineCov">      13195 :   if (cfa-&gt;indirect)</span>
<span class="lineNum">    2733 </span>            :     {
<span class="lineNum">    2734 </span><span class="lineCov">      11208 :       head = new_reg_loc_descr (cfa-&gt;reg, cfa-&gt;base_offset);</span>
<span class="lineNum">    2735 </span><span class="lineCov">       5604 :       head-&gt;dw_loc_oprnd1.val_class = dw_val_class_const;</span>
<span class="lineNum">    2736 </span><span class="lineCov">       5604 :       head-&gt;dw_loc_oprnd1.val_entry = NULL;</span>
<span class="lineNum">    2737 </span><span class="lineCov">       5604 :       tmp = new_loc_descr (DW_OP_deref, 0, 0);</span>
<span class="lineNum">    2738 </span><span class="lineCov">       5604 :       add_loc_descr (&amp;head, tmp);</span>
<span class="lineNum">    2739 </span><span class="lineCov">       5604 :       loc_descr_plus_const (&amp;head, offset);</span>
<span class="lineNum">    2740 </span>            :     }
<span class="lineNum">    2741 </span>            :   else
<span class="lineNum">    2742 </span><span class="lineCov">       7591 :     head = new_reg_loc_descr (cfa-&gt;reg, offset);</span>
<span class="lineNum">    2743 </span>            : 
<span class="lineNum">    2744 </span><span class="lineCov">      13195 :   return head;</span>
<span class="lineNum">    2745 </span>            : }
<span class="lineNum">    2746 </span>            : 
<span class="lineNum">    2747 </span>            : /* This function builds a dwarf location descriptor sequence for
<span class="lineNum">    2748 </span>            :    the address at OFFSET from the CFA when stack is aligned to
<span class="lineNum">    2749 </span>            :    ALIGNMENT byte.  */
<a name="2750"><span class="lineNum">    2750 </span>            : </a>
<span class="lineNum">    2751 </span>            : struct dw_loc_descr_node *
<span class="lineNum">    2752 </span><span class="lineCov">      15541 : build_cfa_aligned_loc (dw_cfa_location *cfa,</span>
<span class="lineNum">    2753 </span>            :                        poly_int64 offset, HOST_WIDE_INT alignment)
<span class="lineNum">    2754 </span>            : {
<span class="lineNum">    2755 </span><span class="lineCov">      15541 :   struct dw_loc_descr_node *head;</span>
<span class="lineNum">    2756 </span><span class="lineCov">      31082 :   unsigned int dwarf_fp</span>
<span class="lineNum">    2757 </span><span class="lineCov">      15541 :     = DWARF_FRAME_REGNUM (HARD_FRAME_POINTER_REGNUM);</span>
<span class="lineNum">    2758 </span>            : 
<span class="lineNum">    2759 </span>            :   /* When CFA is defined as FP+OFFSET, emulate stack alignment.  */
<span class="lineNum">    2760 </span><span class="lineCov">      15541 :   if (cfa-&gt;reg == HARD_FRAME_POINTER_REGNUM &amp;&amp; cfa-&gt;indirect == 0)</span>
<span class="lineNum">    2761 </span>            :     {
<span class="lineNum">    2762 </span><span class="lineNoCov">          0 :       head = new_reg_loc_descr (dwarf_fp, 0);</span>
<span class="lineNum">    2763 </span><span class="lineNoCov">          0 :       add_loc_descr (&amp;head, int_loc_descriptor (alignment));</span>
<span class="lineNum">    2764 </span><span class="lineNoCov">          0 :       add_loc_descr (&amp;head, new_loc_descr (DW_OP_and, 0, 0));</span>
<span class="lineNum">    2765 </span><span class="lineNoCov">          0 :       loc_descr_plus_const (&amp;head, offset);</span>
<span class="lineNum">    2766 </span>            :     }
<span class="lineNum">    2767 </span>            :   else
<span class="lineNum">    2768 </span><span class="lineCov">      15541 :     head = new_reg_loc_descr (dwarf_fp, offset);</span>
<span class="lineNum">    2769 </span><span class="lineCov">      15541 :   return head;</span>
<span class="lineNum">    2770 </span>            : }
<span class="lineNum">    2771 </span>            : 
<span class="lineNum">    2772 </span>            : /* And now, the support for symbolic debugging information.  */
<span class="lineNum">    2773 </span>            : 
<span class="lineNum">    2774 </span>            : /* .debug_str support.  */
<span class="lineNum">    2775 </span>            : 
<span class="lineNum">    2776 </span>            : static void dwarf2out_init (const char *);
<span class="lineNum">    2777 </span>            : static void dwarf2out_finish (const char *);
<span class="lineNum">    2778 </span>            : static void dwarf2out_early_finish (const char *);
<span class="lineNum">    2779 </span>            : static void dwarf2out_assembly_start (void);
<span class="lineNum">    2780 </span>            : static void dwarf2out_define (unsigned int, const char *);
<span class="lineNum">    2781 </span>            : static void dwarf2out_undef (unsigned int, const char *);
<span class="lineNum">    2782 </span>            : static void dwarf2out_start_source_file (unsigned, const char *);
<span class="lineNum">    2783 </span>            : static void dwarf2out_end_source_file (unsigned);
<span class="lineNum">    2784 </span>            : static void dwarf2out_function_decl (tree);
<span class="lineNum">    2785 </span>            : static void dwarf2out_begin_block (unsigned, unsigned);
<span class="lineNum">    2786 </span>            : static void dwarf2out_end_block (unsigned, unsigned);
<span class="lineNum">    2787 </span>            : static bool dwarf2out_ignore_block (const_tree);
<span class="lineNum">    2788 </span>            : static void dwarf2out_early_global_decl (tree);
<span class="lineNum">    2789 </span>            : static void dwarf2out_late_global_decl (tree);
<span class="lineNum">    2790 </span>            : static void dwarf2out_type_decl (tree, int);
<span class="lineNum">    2791 </span>            : static void dwarf2out_imported_module_or_decl (tree, tree, tree, bool, bool);
<span class="lineNum">    2792 </span>            : static void dwarf2out_imported_module_or_decl_1 (tree, tree, tree,
<span class="lineNum">    2793 </span>            :                                                  dw_die_ref);
<span class="lineNum">    2794 </span>            : static void dwarf2out_abstract_function (tree);
<span class="lineNum">    2795 </span>            : static void dwarf2out_var_location (rtx_insn *);
<span class="lineNum">    2796 </span>            : static void dwarf2out_inline_entry (tree);
<span class="lineNum">    2797 </span>            : static void dwarf2out_size_function (tree);
<span class="lineNum">    2798 </span>            : static void dwarf2out_begin_function (tree);
<span class="lineNum">    2799 </span>            : static void dwarf2out_end_function (unsigned int);
<span class="lineNum">    2800 </span>            : static void dwarf2out_register_main_translation_unit (tree unit);
<span class="lineNum">    2801 </span>            : static void dwarf2out_set_name (tree, tree);
<span class="lineNum">    2802 </span>            : static void dwarf2out_register_external_die (tree decl, const char *sym,
<span class="lineNum">    2803 </span>            :                                              unsigned HOST_WIDE_INT off);
<span class="lineNum">    2804 </span>            : static bool dwarf2out_die_ref_for_decl (tree decl, const char **sym,
<span class="lineNum">    2805 </span>            :                                         unsigned HOST_WIDE_INT *off);
<span class="lineNum">    2806 </span>            : 
<span class="lineNum">    2807 </span>            : /* The debug hooks structure.  */
<span class="lineNum">    2808 </span>            : 
<span class="lineNum">    2809 </span>            : const struct gcc_debug_hooks dwarf2_debug_hooks =
<span class="lineNum">    2810 </span>            : {
<span class="lineNum">    2811 </span>            :   dwarf2out_init,
<span class="lineNum">    2812 </span>            :   dwarf2out_finish,
<span class="lineNum">    2813 </span>            :   dwarf2out_early_finish,
<span class="lineNum">    2814 </span>            :   dwarf2out_assembly_start,
<span class="lineNum">    2815 </span>            :   dwarf2out_define,
<span class="lineNum">    2816 </span>            :   dwarf2out_undef,
<span class="lineNum">    2817 </span>            :   dwarf2out_start_source_file,
<span class="lineNum">    2818 </span>            :   dwarf2out_end_source_file,
<span class="lineNum">    2819 </span>            :   dwarf2out_begin_block,
<span class="lineNum">    2820 </span>            :   dwarf2out_end_block,
<span class="lineNum">    2821 </span>            :   dwarf2out_ignore_block,
<span class="lineNum">    2822 </span>            :   dwarf2out_source_line,
<span class="lineNum">    2823 </span>            :   dwarf2out_begin_prologue,
<span class="lineNum">    2824 </span>            : #if VMS_DEBUGGING_INFO
<span class="lineNum">    2825 </span>            :   dwarf2out_vms_end_prologue,
<span class="lineNum">    2826 </span>            :   dwarf2out_vms_begin_epilogue,
<span class="lineNum">    2827 </span>            : #else
<span class="lineNum">    2828 </span>            :   debug_nothing_int_charstar,
<span class="lineNum">    2829 </span>            :   debug_nothing_int_charstar,
<span class="lineNum">    2830 </span>            : #endif
<span class="lineNum">    2831 </span>            :   dwarf2out_end_epilogue,
<span class="lineNum">    2832 </span>            :   dwarf2out_begin_function,
<span class="lineNum">    2833 </span>            :   dwarf2out_end_function,       /* end_function */
<span class="lineNum">    2834 </span>            :   dwarf2out_register_main_translation_unit,
<span class="lineNum">    2835 </span>            :   dwarf2out_function_decl,      /* function_decl */
<span class="lineNum">    2836 </span>            :   dwarf2out_early_global_decl,
<span class="lineNum">    2837 </span>            :   dwarf2out_late_global_decl,
<span class="lineNum">    2838 </span>            :   dwarf2out_type_decl,          /* type_decl */
<span class="lineNum">    2839 </span>            :   dwarf2out_imported_module_or_decl,
<span class="lineNum">    2840 </span>            :   dwarf2out_die_ref_for_decl,
<span class="lineNum">    2841 </span>            :   dwarf2out_register_external_die,
<span class="lineNum">    2842 </span>            :   debug_nothing_tree,           /* deferred_inline_function */
<span class="lineNum">    2843 </span>            :   /* The DWARF 2 backend tries to reduce debugging bloat by not
<span class="lineNum">    2844 </span>            :      emitting the abstract description of inline functions until
<span class="lineNum">    2845 </span>            :      something tries to reference them.  */
<span class="lineNum">    2846 </span>            :   dwarf2out_abstract_function,  /* outlining_inline_function */
<span class="lineNum">    2847 </span>            :   debug_nothing_rtx_code_label, /* label */
<span class="lineNum">    2848 </span>            :   debug_nothing_int,            /* handle_pch */
<span class="lineNum">    2849 </span>            :   dwarf2out_var_location,
<span class="lineNum">    2850 </span>            :   dwarf2out_inline_entry,       /* inline_entry */
<span class="lineNum">    2851 </span>            :   dwarf2out_size_function,      /* size_function */
<span class="lineNum">    2852 </span>            :   dwarf2out_switch_text_section,
<span class="lineNum">    2853 </span>            :   dwarf2out_set_name,
<span class="lineNum">    2854 </span>            :   1,                            /* start_end_main_source_file */
<span class="lineNum">    2855 </span>            :   TYPE_SYMTAB_IS_DIE            /* tree_type_symtab_field */
<span class="lineNum">    2856 </span>            : };
<span class="lineNum">    2857 </span>            : 
<span class="lineNum">    2858 </span>            : const struct gcc_debug_hooks dwarf2_lineno_debug_hooks =
<span class="lineNum">    2859 </span>            : {
<span class="lineNum">    2860 </span>            :   dwarf2out_init,
<span class="lineNum">    2861 </span>            :   debug_nothing_charstar,
<span class="lineNum">    2862 </span>            :   debug_nothing_charstar,
<span class="lineNum">    2863 </span>            :   dwarf2out_assembly_start,
<span class="lineNum">    2864 </span>            :   debug_nothing_int_charstar,
<span class="lineNum">    2865 </span>            :   debug_nothing_int_charstar,
<span class="lineNum">    2866 </span>            :   debug_nothing_int_charstar,
<span class="lineNum">    2867 </span>            :   debug_nothing_int,
<span class="lineNum">    2868 </span>            :   debug_nothing_int_int,                 /* begin_block */
<span class="lineNum">    2869 </span>            :   debug_nothing_int_int,                 /* end_block */
<span class="lineNum">    2870 </span>            :   debug_true_const_tree,                 /* ignore_block */
<span class="lineNum">    2871 </span>            :   dwarf2out_source_line,                 /* source_line */
<span class="lineNum">    2872 </span>            :   debug_nothing_int_int_charstar,        /* begin_prologue */
<span class="lineNum">    2873 </span>            :   debug_nothing_int_charstar,            /* end_prologue */
<span class="lineNum">    2874 </span>            :   debug_nothing_int_charstar,            /* begin_epilogue */
<span class="lineNum">    2875 </span>            :   debug_nothing_int_charstar,            /* end_epilogue */
<span class="lineNum">    2876 </span>            :   debug_nothing_tree,                    /* begin_function */
<span class="lineNum">    2877 </span>            :   debug_nothing_int,                     /* end_function */
<span class="lineNum">    2878 </span>            :   debug_nothing_tree,                    /* register_main_translation_unit */
<span class="lineNum">    2879 </span>            :   debug_nothing_tree,                    /* function_decl */
<span class="lineNum">    2880 </span>            :   debug_nothing_tree,                    /* early_global_decl */
<span class="lineNum">    2881 </span>            :   debug_nothing_tree,                    /* late_global_decl */
<span class="lineNum">    2882 </span>            :   debug_nothing_tree_int,                /* type_decl */
<span class="lineNum">    2883 </span>            :   debug_nothing_tree_tree_tree_bool_bool,/* imported_module_or_decl */
<span class="lineNum">    2884 </span>            :   debug_false_tree_charstarstar_uhwistar,/* die_ref_for_decl */
<span class="lineNum">    2885 </span>            :   debug_nothing_tree_charstar_uhwi,      /* register_external_die */
<span class="lineNum">    2886 </span>            :   debug_nothing_tree,                    /* deferred_inline_function */
<span class="lineNum">    2887 </span>            :   debug_nothing_tree,                    /* outlining_inline_function */
<span class="lineNum">    2888 </span>            :   debug_nothing_rtx_code_label,          /* label */
<span class="lineNum">    2889 </span>            :   debug_nothing_int,                     /* handle_pch */
<span class="lineNum">    2890 </span>            :   debug_nothing_rtx_insn,                /* var_location */
<span class="lineNum">    2891 </span>            :   debug_nothing_tree,                    /* inline_entry */
<span class="lineNum">    2892 </span>            :   debug_nothing_tree,                    /* size_function */
<span class="lineNum">    2893 </span>            :   debug_nothing_void,                    /* switch_text_section */
<span class="lineNum">    2894 </span>            :   debug_nothing_tree_tree,               /* set_name */
<span class="lineNum">    2895 </span>            :   0,                                     /* start_end_main_source_file */
<span class="lineNum">    2896 </span>            :   TYPE_SYMTAB_IS_ADDRESS                 /* tree_type_symtab_field */
<span class="lineNum">    2897 </span>            : };
<span class="lineNum">    2898 </span>            : 
<span class="lineNum">    2899 </span>            : /* NOTE: In the comments in this file, many references are made to
<span class="lineNum">    2900 </span>            :    &quot;Debugging Information Entries&quot;.  This term is abbreviated as `DIE'
<span class="lineNum">    2901 </span>            :    throughout the remainder of this file.  */
<span class="lineNum">    2902 </span>            : 
<span class="lineNum">    2903 </span>            : /* An internal representation of the DWARF output is built, and then
<span class="lineNum">    2904 </span>            :    walked to generate the DWARF debugging info.  The walk of the internal
<span class="lineNum">    2905 </span>            :    representation is done after the entire program has been compiled.
<span class="lineNum">    2906 </span>            :    The types below are used to describe the internal representation.  */
<span class="lineNum">    2907 </span>            : 
<span class="lineNum">    2908 </span>            : /* Whether to put type DIEs into their own section .debug_types instead
<span class="lineNum">    2909 </span>            :    of making them part of the .debug_info section.  Only supported for
<span class="lineNum">    2910 </span>            :    Dwarf V4 or higher and the user didn't disable them through
<span class="lineNum">    2911 </span>            :    -fno-debug-types-section.  It is more efficient to put them in a
<span class="lineNum">    2912 </span>            :    separate comdat sections since the linker will then be able to
<span class="lineNum">    2913 </span>            :    remove duplicates.  But not all tools support .debug_types sections
<span class="lineNum">    2914 </span>            :    yet.  For Dwarf V5 or higher .debug_types doesn't exist any more,
<span class="lineNum">    2915 </span>            :    it is DW_UT_type unit type in .debug_info section.  */
<span class="lineNum">    2916 </span>            : 
<span class="lineNum">    2917 </span>            : #define use_debug_types (dwarf_version &gt;= 4 &amp;&amp; flag_debug_types_section)
<span class="lineNum">    2918 </span>            : 
<span class="lineNum">    2919 </span>            : /* Various DIE's use offsets relative to the beginning of the
<span class="lineNum">    2920 </span>            :    .debug_info section to refer to each other.  */
<span class="lineNum">    2921 </span>            : 
<span class="lineNum">    2922 </span>            : typedef long int dw_offset;
<span class="lineNum">    2923 </span>            : 
<span class="lineNum">    2924 </span>            : struct comdat_type_node;
<span class="lineNum">    2925 </span>            : 
<span class="lineNum">    2926 </span>            : /* The entries in the line_info table more-or-less mirror the opcodes
<span class="lineNum">    2927 </span>            :    that are used in the real dwarf line table.  Arrays of these entries
<span class="lineNum">    2928 </span>            :    are collected per section when DWARF2_ASM_LINE_DEBUG_INFO is not
<span class="lineNum">    2929 </span>            :    supported.  */
<span class="lineNum">    2930 </span>            : 
<span class="lineNum">    2931 </span>            : enum dw_line_info_opcode {
<span class="lineNum">    2932 </span>            :   /* Emit DW_LNE_set_address; the operand is the label index.  */
<span class="lineNum">    2933 </span>            :   LI_set_address,
<span class="lineNum">    2934 </span>            : 
<span class="lineNum">    2935 </span>            :   /* Emit a row to the matrix with the given line.  This may be done
<span class="lineNum">    2936 </span>            :      via any combination of DW_LNS_copy, DW_LNS_advance_line, and
<span class="lineNum">    2937 </span>            :      special opcodes.  */
<span class="lineNum">    2938 </span>            :   LI_set_line,
<span class="lineNum">    2939 </span>            : 
<span class="lineNum">    2940 </span>            :   /* Emit a DW_LNS_set_file.  */
<span class="lineNum">    2941 </span>            :   LI_set_file,
<span class="lineNum">    2942 </span>            : 
<span class="lineNum">    2943 </span>            :   /* Emit a DW_LNS_set_column.  */
<span class="lineNum">    2944 </span>            :   LI_set_column,
<span class="lineNum">    2945 </span>            : 
<span class="lineNum">    2946 </span>            :   /* Emit a DW_LNS_negate_stmt; the operand is ignored.  */
<span class="lineNum">    2947 </span>            :   LI_negate_stmt,
<span class="lineNum">    2948 </span>            : 
<span class="lineNum">    2949 </span>            :   /* Emit a DW_LNS_set_prologue_end/epilogue_begin; the operand is ignored.  */
<span class="lineNum">    2950 </span>            :   LI_set_prologue_end,
<span class="lineNum">    2951 </span>            :   LI_set_epilogue_begin,
<span class="lineNum">    2952 </span>            : 
<span class="lineNum">    2953 </span>            :   /* Emit a DW_LNE_set_discriminator.  */
<span class="lineNum">    2954 </span>            :   LI_set_discriminator,
<span class="lineNum">    2955 </span>            : 
<span class="lineNum">    2956 </span>            :   /* Output a Fixed Advance PC; the target PC is the label index; the
<span class="lineNum">    2957 </span>            :      base PC is the previous LI_adv_address or LI_set_address entry.
<span class="lineNum">    2958 </span>            :      We only use this when emitting debug views without assembler
<span class="lineNum">    2959 </span>            :      support, at explicit user request.  Ideally, we should only use
<span class="lineNum">    2960 </span>            :      it when the offset might be zero but we can't tell: it's the only
<span class="lineNum">    2961 </span>            :      way to maybe change the PC without resetting the view number.  */
<span class="lineNum">    2962 </span>            :   LI_adv_address
<span class="lineNum">    2963 </span>            : };
<span class="lineNum">    2964 </span>            : 
<span class="lineNum">    2965 </span>            : typedef struct GTY(()) dw_line_info_struct {
<span class="lineNum">    2966 </span>            :   enum dw_line_info_opcode opcode;
<span class="lineNum">    2967 </span>            :   unsigned int val;
<span class="lineNum">    2968 </span>            : } dw_line_info_entry;
<span class="lineNum">    2969 </span>            : 
<span class="lineNum">    2970 </span>            : 
<span class="lineNum">    2971 </span>            : struct GTY(()) dw_line_info_table {
<span class="lineNum">    2972 </span>            :   /* The label that marks the end of this section.  */
<span class="lineNum">    2973 </span>            :   const char *end_label;
<span class="lineNum">    2974 </span>            : 
<span class="lineNum">    2975 </span>            :   /* The values for the last row of the matrix, as collected in the table.
<span class="lineNum">    2976 </span>            :      These are used to minimize the changes to the next row.  */
<span class="lineNum">    2977 </span>            :   unsigned int file_num;
<span class="lineNum">    2978 </span>            :   unsigned int line_num;
<span class="lineNum">    2979 </span>            :   unsigned int column_num;
<span class="lineNum">    2980 </span>            :   int discrim_num;
<span class="lineNum">    2981 </span>            :   bool is_stmt;
<span class="lineNum">    2982 </span>            :   bool in_use;
<span class="lineNum">    2983 </span>            : 
<span class="lineNum">    2984 </span>            :   /* This denotes the NEXT view number.
<span class="lineNum">    2985 </span>            : 
<span class="lineNum">    2986 </span>            :      If it is 0, it is known that the NEXT view will be the first view
<span class="lineNum">    2987 </span>            :      at the given PC.
<span class="lineNum">    2988 </span>            : 
<span class="lineNum">    2989 </span>            :      If it is -1, we're forcing the view number to be reset, e.g. at a
<span class="lineNum">    2990 </span>            :      function entry.
<span class="lineNum">    2991 </span>            : 
<span class="lineNum">    2992 </span>            :      The meaning of other nonzero values depends on whether we're
<span class="lineNum">    2993 </span>            :      computing views internally or leaving it for the assembler to do
<span class="lineNum">    2994 </span>            :      so.  If we're emitting them internally, view denotes the view
<span class="lineNum">    2995 </span>            :      number since the last known advance of PC.  If we're leaving it
<span class="lineNum">    2996 </span>            :      for the assembler, it denotes the LVU label number that we're
<span class="lineNum">    2997 </span>            :      going to ask the assembler to assign.  */
<span class="lineNum">    2998 </span>            :   var_loc_view view;
<span class="lineNum">    2999 </span>            : 
<span class="lineNum">    3000 </span>            :   /* This counts the number of symbolic views emitted in this table
<span class="lineNum">    3001 </span>            :      since the latest view reset.  Its max value, over all tables,
<span class="lineNum">    3002 </span>            :      sets symview_upper_bound.  */
<span class="lineNum">    3003 </span>            :   var_loc_view symviews_since_reset;
<span class="lineNum">    3004 </span>            : 
<span class="lineNum">    3005 </span>            : #define FORCE_RESET_NEXT_VIEW(x) ((x) = (var_loc_view)-1)
<span class="lineNum">    3006 </span>            : #define RESET_NEXT_VIEW(x) ((x) = (var_loc_view)0)
<span class="lineNum">    3007 </span>            : #define FORCE_RESETTING_VIEW_P(x) ((x) == (var_loc_view)-1)
<span class="lineNum">    3008 </span>            : #define RESETTING_VIEW_P(x) ((x) == (var_loc_view)0 || FORCE_RESETTING_VIEW_P (x))
<span class="lineNum">    3009 </span>            : 
<span class="lineNum">    3010 </span>            :   vec&lt;dw_line_info_entry, va_gc&gt; *entries;
<span class="lineNum">    3011 </span>            : };
<span class="lineNum">    3012 </span>            : 
<span class="lineNum">    3013 </span>            : /* This is an upper bound for view numbers that the assembler may
<span class="lineNum">    3014 </span>            :    assign to symbolic views output in this translation.  It is used to
<span class="lineNum">    3015 </span>            :    decide how big a field to use to represent view numbers in
<span class="lineNum">    3016 </span>            :    symview-classed attributes.  */
<span class="lineNum">    3017 </span>            : 
<span class="lineNum">    3018 </span>            : static var_loc_view symview_upper_bound;
<span class="lineNum">    3019 </span>            : 
<span class="lineNum">    3020 </span>            : /* If we're keep track of location views and their reset points, and
<span class="lineNum">    3021 </span>            :    INSN is a reset point (i.e., it necessarily advances the PC), mark
<span class="lineNum">    3022 </span>            :    the next view in TABLE as reset.  */
<a name="3023"><span class="lineNum">    3023 </span>            : </a>
<span class="lineNum">    3024 </span>            : static void
<span class="lineNum">    3025 </span><span class="lineCov">   25165520 : maybe_reset_location_view (rtx_insn *insn, dw_line_info_table *table)</span>
<span class="lineNum">    3026 </span>            : {
<span class="lineNum">    3027 </span><span class="lineCov">   25165520 :   if (!debug_internal_reset_location_views)</span>
<span class="lineNum">    3028 </span>            :     return;
<span class="lineNum">    3029 </span>            : 
<span class="lineNum">    3030 </span>            :   /* Maybe turn (part of?) this test into a default target hook.  */
<span class="lineNum">    3031 </span><span class="lineNoCov">          0 :   int reset = 0;</span>
<span class="lineNum">    3032 </span>            : 
<span class="lineNum">    3033 </span><span class="lineNoCov">          0 :   if (targetm.reset_location_view)</span>
<span class="lineNum">    3034 </span><span class="lineNoCov">          0 :     reset = targetm.reset_location_view (insn);</span>
<span class="lineNum">    3035 </span>            : 
<span class="lineNum">    3036 </span><span class="lineNoCov">          0 :   if (reset)</span>
<span class="lineNum">    3037 </span>            :     ;
<span class="lineNum">    3038 </span><span class="lineNoCov">          0 :   else if (JUMP_TABLE_DATA_P (insn))</span>
<span class="lineNum">    3039 </span>            :     reset = 1;
<span class="lineNum">    3040 </span><span class="lineNoCov">          0 :   else if (GET_CODE (insn) == USE</span>
<span class="lineNum">    3041 </span>            :            || GET_CODE (insn) == CLOBBER
<span class="lineNum">    3042 </span><span class="lineNoCov">          0 :            || GET_CODE (insn) == ASM_INPUT</span>
<span class="lineNum">    3043 </span><span class="lineNoCov">          0 :            || asm_noperands (insn) &gt;= 0)</span>
<span class="lineNum">    3044 </span>            :     ;
<span class="lineNum">    3045 </span><span class="lineNoCov">          0 :   else if (get_attr_min_length (insn) &gt; 0)</span>
<span class="lineNum">    3046 </span>            :     reset = 1;
<span class="lineNum">    3047 </span>            : 
<span class="lineNum">    3048 </span><span class="lineNoCov">          0 :   if (reset &gt; 0 &amp;&amp; !RESETTING_VIEW_P (table-&gt;view))</span>
<span class="lineNum">    3049 </span><span class="lineNoCov">          0 :     RESET_NEXT_VIEW (table-&gt;view);</span>
<span class="lineNum">    3050 </span>            : }
<span class="lineNum">    3051 </span>            : 
<span class="lineNum">    3052 </span>            : /* Each DIE attribute has a field specifying the attribute kind,
<span class="lineNum">    3053 </span>            :    a link to the next attribute in the chain, and an attribute value.
<span class="lineNum">    3054 </span>            :    Attributes are typically linked below the DIE they modify.  */
<span class="lineNum">    3055 </span>            : 
<span class="lineNum">    3056 </span>            : typedef struct GTY(()) dw_attr_struct {
<span class="lineNum">    3057 </span>            :   enum dwarf_attribute dw_attr;
<span class="lineNum">    3058 </span>            :   dw_val_node dw_attr_val;
<span class="lineNum">    3059 </span>            : }
<span class="lineNum">    3060 </span>            : dw_attr_node;
<span class="lineNum">    3061 </span>            : 
<span class="lineNum">    3062 </span>            : 
<span class="lineNum">    3063 </span>            : /* The Debugging Information Entry (DIE) structure.  DIEs form a tree.
<span class="lineNum">    3064 </span>            :    The children of each node form a circular list linked by
<span class="lineNum">    3065 </span>            :    die_sib.  die_child points to the node *before* the &quot;first&quot; child node.  */
<span class="lineNum">    3066 </span>            : 
<span class="lineNum">    3067 </span>            : typedef struct GTY((chain_circular (&quot;%h.die_sib&quot;), for_user)) die_struct {
<span class="lineNum">    3068 </span>            :   union die_symbol_or_type_node
<span class="lineNum">    3069 </span>            :     {
<span class="lineNum">    3070 </span>            :       const char * GTY ((tag (&quot;0&quot;))) die_symbol;
<span class="lineNum">    3071 </span>            :       comdat_type_node *GTY ((tag (&quot;1&quot;))) die_type_node;
<span class="lineNum">    3072 </span>            :     }
<span class="lineNum">    3073 </span>            :   GTY ((desc (&quot;%0.comdat_type_p&quot;))) die_id;
<span class="lineNum">    3074 </span>            :   vec&lt;dw_attr_node, va_gc&gt; *die_attr;
<span class="lineNum">    3075 </span>            :   dw_die_ref die_parent;
<span class="lineNum">    3076 </span>            :   dw_die_ref die_child;
<span class="lineNum">    3077 </span>            :   dw_die_ref die_sib;
<span class="lineNum">    3078 </span>            :   dw_die_ref die_definition; /* ref from a specification to its definition */
<span class="lineNum">    3079 </span>            :   dw_offset die_offset;
<span class="lineNum">    3080 </span>            :   unsigned long die_abbrev;
<span class="lineNum">    3081 </span>            :   int die_mark;
<span class="lineNum">    3082 </span>            :   unsigned int decl_id;
<span class="lineNum">    3083 </span>            :   enum dwarf_tag die_tag;
<span class="lineNum">    3084 </span>            :   /* Die is used and must not be pruned as unused.  */
<span class="lineNum">    3085 </span>            :   BOOL_BITFIELD die_perennial_p : 1;
<span class="lineNum">    3086 </span>            :   BOOL_BITFIELD comdat_type_p : 1; /* DIE has a type signature */
<span class="lineNum">    3087 </span>            :   /* For an external ref to die_symbol if die_offset contains an extra
<span class="lineNum">    3088 </span>            :      offset to that symbol.  */
<span class="lineNum">    3089 </span>            :   BOOL_BITFIELD with_offset : 1;
<span class="lineNum">    3090 </span>            :   /* Whether this DIE was removed from the DIE tree, for example via
<span class="lineNum">    3091 </span>            :      prune_unused_types.  We don't consider those present from the
<span class="lineNum">    3092 </span>            :      DIE lookup routines.  */
<span class="lineNum">    3093 </span>            :   BOOL_BITFIELD removed : 1;
<span class="lineNum">    3094 </span>            :   /* Lots of spare bits.  */
<span class="lineNum">    3095 </span>            : }
<span class="lineNum">    3096 </span>            : die_node;
<span class="lineNum">    3097 </span>            : 
<span class="lineNum">    3098 </span>            : /* Set to TRUE while dwarf2out_early_global_decl is running.  */
<span class="lineNum">    3099 </span>            : static bool early_dwarf;
<span class="lineNum">    3100 </span>            : static bool early_dwarf_finished;
<a name="3101"><span class="lineNum">    3101 </span>            : struct set_early_dwarf {</a>
<span class="lineNum">    3102 </span>            :   bool saved;
<span class="lineNum">    3103 </span><span class="lineCov">   15701539 :   set_early_dwarf () : saved(early_dwarf)</span>
<span class="lineNum">    3104 </span>            :     {
<span class="lineNum">    3105 </span><span class="lineCov">   15701539 :       gcc_assert (! early_dwarf_finished);</span>
<span class="lineNum">    3106 </span><span class="lineCov">   15701539 :       early_dwarf = true;</span>
<span class="lineNum">    3107 </span><span class="lineCov">   15701539 :     }</span>
<span class="lineNum">    3108 </span><span class="lineCov">   15701539 :   ~set_early_dwarf () { early_dwarf = saved; }</span>
<span class="lineNum">    3109 </span>            : };
<span class="lineNum">    3110 </span>            : 
<span class="lineNum">    3111 </span>            : /* Evaluate 'expr' while 'c' is set to each child of DIE in order.  */
<span class="lineNum">    3112 </span>            : #define FOR_EACH_CHILD(die, c, expr) do {       \
<span class="lineNum">    3113 </span>            :   c = die-&gt;die_child;                                \
<span class="lineNum">    3114 </span>            :   if (c) do {                                   \
<span class="lineNum">    3115 </span>            :     c = c-&gt;die_sib;                          \
<span class="lineNum">    3116 </span>            :     expr;                                       \
<span class="lineNum">    3117 </span>            :   } while (c != die-&gt;die_child);             \
<span class="lineNum">    3118 </span>            : } while (0)
<span class="lineNum">    3119 </span>            : 
<span class="lineNum">    3120 </span>            : /* The pubname structure */
<span class="lineNum">    3121 </span>            : 
<span class="lineNum">    3122 </span>            : typedef struct GTY(()) pubname_struct {
<span class="lineNum">    3123 </span>            :   dw_die_ref die;
<span class="lineNum">    3124 </span>            :   const char *name;
<span class="lineNum">    3125 </span>            : }
<span class="lineNum">    3126 </span>            : pubname_entry;
<span class="lineNum">    3127 </span>            : 
<span class="lineNum">    3128 </span>            : 
<span class="lineNum">    3129 </span>            : struct GTY(()) dw_ranges {
<span class="lineNum">    3130 </span>            :   const char *label;
<span class="lineNum">    3131 </span>            :   /* If this is positive, it's a block number, otherwise it's a
<span class="lineNum">    3132 </span>            :      bitwise-negated index into dw_ranges_by_label.  */
<span class="lineNum">    3133 </span>            :   int num;
<span class="lineNum">    3134 </span>            :   /* Index for the range list for DW_FORM_rnglistx.  */
<span class="lineNum">    3135 </span>            :   unsigned int idx : 31;
<span class="lineNum">    3136 </span>            :   /* True if this range might be possibly in a different section
<span class="lineNum">    3137 </span>            :      from previous entry.  */
<span class="lineNum">    3138 </span>            :   unsigned int maybe_new_sec : 1;
<span class="lineNum">    3139 </span>            : };
<span class="lineNum">    3140 </span>            : 
<span class="lineNum">    3141 </span>            : /* A structure to hold a macinfo entry.  */
<span class="lineNum">    3142 </span>            : 
<span class="lineNum">    3143 </span>            : typedef struct GTY(()) macinfo_struct {
<span class="lineNum">    3144 </span>            :   unsigned char code;
<span class="lineNum">    3145 </span>            :   unsigned HOST_WIDE_INT lineno;
<span class="lineNum">    3146 </span>            :   const char *info;
<span class="lineNum">    3147 </span>            : }
<span class="lineNum">    3148 </span>            : macinfo_entry;
<span class="lineNum">    3149 </span>            : 
<span class="lineNum">    3150 </span>            : 
<span class="lineNum">    3151 </span>            : struct GTY(()) dw_ranges_by_label {
<span class="lineNum">    3152 </span>            :   const char *begin;
<span class="lineNum">    3153 </span>            :   const char *end;
<span class="lineNum">    3154 </span>            : };
<span class="lineNum">    3155 </span>            : 
<span class="lineNum">    3156 </span>            : /* The comdat type node structure.  */
<span class="lineNum">    3157 </span>            : struct GTY(()) comdat_type_node
<span class="lineNum">    3158 </span>            : {
<span class="lineNum">    3159 </span>            :   dw_die_ref root_die;
<span class="lineNum">    3160 </span>            :   dw_die_ref type_die;
<span class="lineNum">    3161 </span>            :   dw_die_ref skeleton_die;
<span class="lineNum">    3162 </span>            :   char signature[DWARF_TYPE_SIGNATURE_SIZE];
<span class="lineNum">    3163 </span>            :   comdat_type_node *next;
<span class="lineNum">    3164 </span>            : };
<span class="lineNum">    3165 </span>            : 
<span class="lineNum">    3166 </span>            : /* A list of DIEs for which we can't determine ancestry (parent_die
<span class="lineNum">    3167 </span>            :    field) just yet.  Later in dwarf2out_finish we will fill in the
<span class="lineNum">    3168 </span>            :    missing bits.  */
<span class="lineNum">    3169 </span>            : typedef struct GTY(()) limbo_die_struct {
<span class="lineNum">    3170 </span>            :   dw_die_ref die;
<span class="lineNum">    3171 </span>            :   /* The tree for which this DIE was created.  We use this to
<span class="lineNum">    3172 </span>            :      determine ancestry later.  */
<span class="lineNum">    3173 </span>            :   tree created_for;
<span class="lineNum">    3174 </span>            :   struct limbo_die_struct *next;
<span class="lineNum">    3175 </span>            : }
<span class="lineNum">    3176 </span>            : limbo_die_node;
<span class="lineNum">    3177 </span>            : 
<span class="lineNum">    3178 </span>            : typedef struct skeleton_chain_struct
<span class="lineNum">    3179 </span>            : {
<span class="lineNum">    3180 </span>            :   dw_die_ref old_die;
<span class="lineNum">    3181 </span>            :   dw_die_ref new_die;
<span class="lineNum">    3182 </span>            :   struct skeleton_chain_struct *parent;
<span class="lineNum">    3183 </span>            : }
<span class="lineNum">    3184 </span>            : skeleton_chain_node;
<span class="lineNum">    3185 </span>            : 
<span class="lineNum">    3186 </span>            : /* Define a macro which returns nonzero for a TYPE_DECL which was
<span class="lineNum">    3187 </span>            :    implicitly generated for a type.
<span class="lineNum">    3188 </span>            : 
<span class="lineNum">    3189 </span>            :    Note that, unlike the C front-end (which generates a NULL named
<span class="lineNum">    3190 </span>            :    TYPE_DECL node for each complete tagged type, each array type,
<span class="lineNum">    3191 </span>            :    and each function type node created) the C++ front-end generates
<span class="lineNum">    3192 </span>            :    a _named_ TYPE_DECL node for each tagged type node created.
<span class="lineNum">    3193 </span>            :    These TYPE_DECLs have DECL_ARTIFICIAL set, so we know not to
<span class="lineNum">    3194 </span>            :    generate a DW_TAG_typedef DIE for them.  Likewise with the Ada
<span class="lineNum">    3195 </span>            :    front-end, but for each type, tagged or not.  */
<span class="lineNum">    3196 </span>            : 
<span class="lineNum">    3197 </span>            : #define TYPE_DECL_IS_STUB(decl)                         \
<span class="lineNum">    3198 </span>            :   (DECL_NAME (decl) == NULL_TREE                        \
<span class="lineNum">    3199 </span>            :    || (DECL_ARTIFICIAL (decl)                           \
<span class="lineNum">    3200 </span>            :        &amp;&amp; ((decl == TYPE_STUB_DECL (TREE_TYPE (decl)))  \
<span class="lineNum">    3201 </span>            :            /* This is necessary for stub decls that     \
<span class="lineNum">    3202 </span>            :               appear in nested inline functions.  */    \
<span class="lineNum">    3203 </span>            :            || (DECL_ABSTRACT_ORIGIN (decl) != NULL_TREE \
<span class="lineNum">    3204 </span>            :                &amp;&amp; (decl_ultimate_origin (decl)          \
<span class="lineNum">    3205 </span>            :                    == TYPE_STUB_DECL (TREE_TYPE (decl)))))))
<span class="lineNum">    3206 </span>            : 
<span class="lineNum">    3207 </span>            : /* Information concerning the compilation unit's programming
<span class="lineNum">    3208 </span>            :    language, and compiler version.  */
<span class="lineNum">    3209 </span>            : 
<span class="lineNum">    3210 </span>            : /* Fixed size portion of the DWARF compilation unit header.  */
<span class="lineNum">    3211 </span>            : #define DWARF_COMPILE_UNIT_HEADER_SIZE \
<span class="lineNum">    3212 </span>            :   (DWARF_INITIAL_LENGTH_SIZE + DWARF_OFFSET_SIZE                        \
<span class="lineNum">    3213 </span>            :    + (dwarf_version &gt;= 5 ? 4 : 3))
<span class="lineNum">    3214 </span>            : 
<span class="lineNum">    3215 </span>            : /* Fixed size portion of the DWARF comdat type unit header.  */
<span class="lineNum">    3216 </span>            : #define DWARF_COMDAT_TYPE_UNIT_HEADER_SIZE \
<span class="lineNum">    3217 </span>            :   (DWARF_COMPILE_UNIT_HEADER_SIZE                                       \
<span class="lineNum">    3218 </span>            :    + DWARF_TYPE_SIGNATURE_SIZE + DWARF_OFFSET_SIZE)
<span class="lineNum">    3219 </span>            : 
<span class="lineNum">    3220 </span>            : /* Fixed size portion of the DWARF skeleton compilation unit header.  */
<span class="lineNum">    3221 </span>            : #define DWARF_COMPILE_UNIT_SKELETON_HEADER_SIZE \
<span class="lineNum">    3222 </span>            :   (DWARF_COMPILE_UNIT_HEADER_SIZE + (dwarf_version &gt;= 5 ? 8 : 0))
<span class="lineNum">    3223 </span>            : 
<span class="lineNum">    3224 </span>            : /* Fixed size portion of public names info.  */
<span class="lineNum">    3225 </span>            : #define DWARF_PUBNAMES_HEADER_SIZE (2 * DWARF_OFFSET_SIZE + 2)
<span class="lineNum">    3226 </span>            : 
<span class="lineNum">    3227 </span>            : /* Fixed size portion of the address range info.  */
<span class="lineNum">    3228 </span>            : #define DWARF_ARANGES_HEADER_SIZE                                       \
<span class="lineNum">    3229 </span>            :   (DWARF_ROUND (DWARF_INITIAL_LENGTH_SIZE + DWARF_OFFSET_SIZE + 4,      \
<span class="lineNum">    3230 </span>            :                 DWARF2_ADDR_SIZE * 2)                                   \
<span class="lineNum">    3231 </span>            :    - DWARF_INITIAL_LENGTH_SIZE)
<span class="lineNum">    3232 </span>            : 
<span class="lineNum">    3233 </span>            : /* Size of padding portion in the address range info.  It must be
<span class="lineNum">    3234 </span>            :    aligned to twice the pointer size.  */
<span class="lineNum">    3235 </span>            : #define DWARF_ARANGES_PAD_SIZE \
<span class="lineNum">    3236 </span>            :   (DWARF_ROUND (DWARF_INITIAL_LENGTH_SIZE + DWARF_OFFSET_SIZE + 4, \
<span class="lineNum">    3237 </span>            :                 DWARF2_ADDR_SIZE * 2)                              \
<span class="lineNum">    3238 </span>            :    - (DWARF_INITIAL_LENGTH_SIZE + DWARF_OFFSET_SIZE + 4))
<span class="lineNum">    3239 </span>            : 
<span class="lineNum">    3240 </span>            : /* Use assembler line directives if available.  */
<span class="lineNum">    3241 </span>            : #ifndef DWARF2_ASM_LINE_DEBUG_INFO
<span class="lineNum">    3242 </span>            : #ifdef HAVE_AS_DWARF2_DEBUG_LINE
<span class="lineNum">    3243 </span>            : #define DWARF2_ASM_LINE_DEBUG_INFO 1
<span class="lineNum">    3244 </span>            : #else
<span class="lineNum">    3245 </span>            : #define DWARF2_ASM_LINE_DEBUG_INFO 0
<span class="lineNum">    3246 </span>            : #endif
<span class="lineNum">    3247 </span>            : #endif
<span class="lineNum">    3248 </span>            : 
<span class="lineNum">    3249 </span>            : /* Use assembler views in line directives if available.  */
<span class="lineNum">    3250 </span>            : #ifndef DWARF2_ASM_VIEW_DEBUG_INFO
<span class="lineNum">    3251 </span>            : #ifdef HAVE_AS_DWARF2_DEBUG_VIEW
<span class="lineNum">    3252 </span>            : #define DWARF2_ASM_VIEW_DEBUG_INFO 1
<span class="lineNum">    3253 </span>            : #else
<span class="lineNum">    3254 </span>            : #define DWARF2_ASM_VIEW_DEBUG_INFO 0
<span class="lineNum">    3255 </span>            : #endif
<span class="lineNum">    3256 </span>            : #endif
<span class="lineNum">    3257 </span>            : 
<span class="lineNum">    3258 </span>            : /* Return true if GCC configure detected assembler support for .loc.  */
<a name="3259"><span class="lineNum">    3259 </span>            : </a>
<span class="lineNum">    3260 </span>            : bool
<span class="lineNum">    3261 </span><span class="lineCov">     170271 : dwarf2out_default_as_loc_support (void)</span>
<span class="lineNum">    3262 </span>            : {
<span class="lineNum">    3263 </span><span class="lineCov">     170271 :   return DWARF2_ASM_LINE_DEBUG_INFO;</span>
<span class="lineNum">    3264 </span>            : #if (GCC_VERSION &gt;= 3000)
<span class="lineNum">    3265 </span>            : # undef DWARF2_ASM_LINE_DEBUG_INFO
<span class="lineNum">    3266 </span>            : # pragma GCC poison DWARF2_ASM_LINE_DEBUG_INFO
<span class="lineNum">    3267 </span>            : #endif
<span class="lineNum">    3268 </span>            : }
<span class="lineNum">    3269 </span>            : 
<span class="lineNum">    3270 </span>            : /* Return true if GCC configure detected assembler support for views
<span class="lineNum">    3271 </span>            :    in .loc directives.  */
<a name="3272"><span class="lineNum">    3272 </span>            : </a>
<span class="lineNum">    3273 </span>            : bool
<span class="lineNum">    3274 </span><span class="lineCov">     170271 : dwarf2out_default_as_locview_support (void)</span>
<span class="lineNum">    3275 </span>            : {
<span class="lineNum">    3276 </span><span class="lineCov">     170271 :   return DWARF2_ASM_VIEW_DEBUG_INFO;</span>
<span class="lineNum">    3277 </span>            : #if (GCC_VERSION &gt;= 3000)
<span class="lineNum">    3278 </span>            : # undef DWARF2_ASM_VIEW_DEBUG_INFO
<span class="lineNum">    3279 </span>            : # pragma GCC poison DWARF2_ASM_VIEW_DEBUG_INFO
<span class="lineNum">    3280 </span>            : #endif
<span class="lineNum">    3281 </span>            : }
<span class="lineNum">    3282 </span>            : 
<span class="lineNum">    3283 </span>            : /* A bit is set in ZERO_VIEW_P if we are using the assembler-supported
<span class="lineNum">    3284 </span>            :    view computation, and it refers to a view identifier for which we
<span class="lineNum">    3285 </span>            :    will not emit a label because it is known to map to a view number
<span class="lineNum">    3286 </span>            :    zero.  We won't allocate the bitmap if we're not using assembler
<span class="lineNum">    3287 </span>            :    support for location views, but we have to make the variable
<span class="lineNum">    3288 </span>            :    visible for GGC and for code that will be optimized out for lack of
<span class="lineNum">    3289 </span>            :    support but that's still parsed and compiled.  We could abstract it
<span class="lineNum">    3290 </span>            :    out with macros, but it's not worth it.  */
<span class="lineNum">    3291 </span>            : static GTY(()) bitmap zero_view_p;
<span class="lineNum">    3292 </span>            : 
<span class="lineNum">    3293 </span>            : /* Evaluate to TRUE iff N is known to identify the first location view
<span class="lineNum">    3294 </span>            :    at its PC.  When not using assembler location view computation,
<span class="lineNum">    3295 </span>            :    that must be view number zero.  Otherwise, ZERO_VIEW_P is allocated
<span class="lineNum">    3296 </span>            :    and views label numbers recorded in it are the ones known to be
<span class="lineNum">    3297 </span>            :    zero.  */
<span class="lineNum">    3298 </span>            : #define ZERO_VIEW_P(N) ((N) == (var_loc_view)0                          \
<span class="lineNum">    3299 </span>            :                         || (N) == (var_loc_view)-1                      \
<span class="lineNum">    3300 </span>            :                         || (zero_view_p                                 \
<span class="lineNum">    3301 </span>            :                             &amp;&amp; bitmap_bit_p (zero_view_p, (N))))
<span class="lineNum">    3302 </span>            : 
<span class="lineNum">    3303 </span>            : /* Return true iff we're to emit .loc directives for the assembler to
<span class="lineNum">    3304 </span>            :    generate line number sections.
<span class="lineNum">    3305 </span>            : 
<span class="lineNum">    3306 </span>            :    When we're not emitting views, all we need from the assembler is
<span class="lineNum">    3307 </span>            :    support for .loc directives.
<span class="lineNum">    3308 </span>            : 
<span class="lineNum">    3309 </span>            :    If we are emitting views, we can only use the assembler's .loc
<span class="lineNum">    3310 </span>            :    support if it also supports views.
<span class="lineNum">    3311 </span>            : 
<span class="lineNum">    3312 </span>            :    When the compiler is emitting the line number programs and
<span class="lineNum">    3313 </span>            :    computing view numbers itself, it resets view numbers at known PC
<span class="lineNum">    3314 </span>            :    changes and counts from that, and then it emits view numbers as
<span class="lineNum">    3315 </span>            :    literal constants in locviewlists.  There are cases in which the
<span class="lineNum">    3316 </span>            :    compiler is not sure about PC changes, e.g. when extra alignment is
<span class="lineNum">    3317 </span>            :    requested for a label.  In these cases, the compiler may not reset
<span class="lineNum">    3318 </span>            :    the view counter, and the potential PC advance in the line number
<span class="lineNum">    3319 </span>            :    program will use an opcode that does not reset the view counter
<span class="lineNum">    3320 </span>            :    even if the PC actually changes, so that compiler and debug info
<span class="lineNum">    3321 </span>            :    consumer can keep view numbers in sync.
<span class="lineNum">    3322 </span>            : 
<span class="lineNum">    3323 </span>            :    When the compiler defers view computation to the assembler, it
<span class="lineNum">    3324 </span>            :    emits symbolic view numbers in locviewlists, with the exception of
<span class="lineNum">    3325 </span>            :    views known to be zero (forced resets, or reset after
<span class="lineNum">    3326 </span>            :    compiler-visible PC changes): instead of emitting symbols for
<span class="lineNum">    3327 </span>            :    these, we emit literal zero and assert the assembler agrees with
<span class="lineNum">    3328 </span>            :    the compiler's assessment.  We could use symbolic views everywhere,
<span class="lineNum">    3329 </span>            :    instead of special-casing zero views, but then we'd be unable to
<span class="lineNum">    3330 </span>            :    optimize out locviewlists that contain only zeros.  */
<a name="3331"><span class="lineNum">    3331 </span>            : </a>
<span class="lineNum">    3332 </span>            : static bool
<span class="lineNum">    3333 </span><span class="lineNoCov">          0 : output_asm_line_debug_info (void)</span>
<span class="lineNum">    3334 </span>            : {
<span class="lineNum">    3335 </span><span class="lineCov">   22383781 :   return (dwarf2out_as_loc_support</span>
<span class="lineNum">    3336 </span><span class="lineCov">   22383781 :           &amp;&amp; (dwarf2out_as_locview_support</span>
<span class="lineNum">    3337 </span><span class="lineNoCov">          0 :               || !debug_variable_location_views));</span>
<span class="lineNum">    3338 </span>            : }
<span class="lineNum">    3339 </span>            : 
<span class="lineNum">    3340 </span>            : /* Minimum line offset in a special line info. opcode.
<span class="lineNum">    3341 </span>            :    This value was chosen to give a reasonable range of values.  */
<span class="lineNum">    3342 </span>            : #define DWARF_LINE_BASE  -10
<span class="lineNum">    3343 </span>            : 
<span class="lineNum">    3344 </span>            : /* First special line opcode - leave room for the standard opcodes.  */
<span class="lineNum">    3345 </span>            : #define DWARF_LINE_OPCODE_BASE  ((int)DW_LNS_set_isa + 1)
<span class="lineNum">    3346 </span>            : 
<span class="lineNum">    3347 </span>            : /* Range of line offsets in a special line info. opcode.  */
<span class="lineNum">    3348 </span>            : #define DWARF_LINE_RANGE  (254-DWARF_LINE_OPCODE_BASE+1)
<span class="lineNum">    3349 </span>            : 
<span class="lineNum">    3350 </span>            : /* Flag that indicates the initial value of the is_stmt_start flag.
<span class="lineNum">    3351 </span>            :    In the present implementation, we do not mark any lines as
<span class="lineNum">    3352 </span>            :    the beginning of a source statement, because that information
<span class="lineNum">    3353 </span>            :    is not made available by the GCC front-end.  */
<span class="lineNum">    3354 </span>            : #define DWARF_LINE_DEFAULT_IS_STMT_START 1
<span class="lineNum">    3355 </span>            : 
<span class="lineNum">    3356 </span>            : /* Maximum number of operations per instruction bundle.  */
<span class="lineNum">    3357 </span>            : #ifndef DWARF_LINE_DEFAULT_MAX_OPS_PER_INSN
<span class="lineNum">    3358 </span>            : #define DWARF_LINE_DEFAULT_MAX_OPS_PER_INSN 1
<span class="lineNum">    3359 </span>            : #endif
<span class="lineNum">    3360 </span>            : 
<span class="lineNum">    3361 </span>            : /* This location is used by calc_die_sizes() to keep track
<span class="lineNum">    3362 </span>            :    the offset of each DIE within the .debug_info section.  */
<span class="lineNum">    3363 </span>            : static unsigned long next_die_offset;
<span class="lineNum">    3364 </span>            : 
<span class="lineNum">    3365 </span>            : /* Record the root of the DIE's built for the current compilation unit.  */
<span class="lineNum">    3366 </span>            : static GTY(()) dw_die_ref single_comp_unit_die;
<span class="lineNum">    3367 </span>            : 
<span class="lineNum">    3368 </span>            : /* A list of type DIEs that have been separated into comdat sections.  */
<span class="lineNum">    3369 </span>            : static GTY(()) comdat_type_node *comdat_type_list;
<span class="lineNum">    3370 </span>            : 
<span class="lineNum">    3371 </span>            : /* A list of CU DIEs that have been separated.  */
<span class="lineNum">    3372 </span>            : static GTY(()) limbo_die_node *cu_die_list;
<span class="lineNum">    3373 </span>            : 
<span class="lineNum">    3374 </span>            : /* A list of DIEs with a NULL parent waiting to be relocated.  */
<span class="lineNum">    3375 </span>            : static GTY(()) limbo_die_node *limbo_die_list;
<span class="lineNum">    3376 </span>            : 
<span class="lineNum">    3377 </span>            : /* A list of DIEs for which we may have to generate
<span class="lineNum">    3378 </span>            :    DW_AT_{,MIPS_}linkage_name once their DECL_ASSEMBLER_NAMEs are set.  */
<span class="lineNum">    3379 </span>            : static GTY(()) limbo_die_node *deferred_asm_name;
<span class="lineNum">    3380 </span>            : 
<span class="lineNum">    3381 </span>            : struct dwarf_file_hasher : ggc_ptr_hash&lt;dwarf_file_data&gt;
<span class="lineNum">    3382 </span>            : {
<span class="lineNum">    3383 </span>            :   typedef const char *compare_type;
<span class="lineNum">    3384 </span>            : 
<span class="lineNum">    3385 </span>            :   static hashval_t hash (dwarf_file_data *);
<span class="lineNum">    3386 </span>            :   static bool equal (dwarf_file_data *, const char *);
<span class="lineNum">    3387 </span>            : };
<span class="lineNum">    3388 </span>            : 
<span class="lineNum">    3389 </span>            : /* Filenames referenced by this compilation unit.  */
<span class="lineNum">    3390 </span>            : static GTY(()) hash_table&lt;dwarf_file_hasher&gt; *file_table;
<span class="lineNum">    3391 </span>            : 
<span class="lineNum">    3392 </span>            : struct decl_die_hasher : ggc_ptr_hash&lt;die_node&gt;
<span class="lineNum">    3393 </span>            : {
<span class="lineNum">    3394 </span>            :   typedef tree compare_type;
<span class="lineNum">    3395 </span>            : 
<span class="lineNum">    3396 </span>            :   static hashval_t hash (die_node *);
<span class="lineNum">    3397 </span>            :   static bool equal (die_node *, tree);
<span class="lineNum">    3398 </span>            : };
<span class="lineNum">    3399 </span>            : /* A hash table of references to DIE's that describe declarations.
<span class="lineNum">    3400 </span>            :    The key is a DECL_UID() which is a unique number identifying each decl.  */
<span class="lineNum">    3401 </span>            : static GTY (()) hash_table&lt;decl_die_hasher&gt; *decl_die_table;
<span class="lineNum">    3402 </span>            : 
<span class="lineNum">    3403 </span>            : struct GTY ((for_user)) variable_value_struct {
<span class="lineNum">    3404 </span>            :   unsigned int decl_id;
<span class="lineNum">    3405 </span>            :   vec&lt;dw_die_ref, va_gc&gt; *dies;
<span class="lineNum">    3406 </span>            : };
<span class="lineNum">    3407 </span>            : 
<span class="lineNum">    3408 </span>            : struct variable_value_hasher : ggc_ptr_hash&lt;variable_value_struct&gt;
<span class="lineNum">    3409 </span>            : {
<span class="lineNum">    3410 </span>            :   typedef tree compare_type;
<span class="lineNum">    3411 </span>            : 
<span class="lineNum">    3412 </span>            :   static hashval_t hash (variable_value_struct *);
<span class="lineNum">    3413 </span>            :   static bool equal (variable_value_struct *, tree);
<span class="lineNum">    3414 </span>            : };
<span class="lineNum">    3415 </span>            : /* A hash table of DIEs that contain DW_OP_GNU_variable_value with
<span class="lineNum">    3416 </span>            :    dw_val_class_decl_ref class, indexed by FUNCTION_DECLs which is
<span class="lineNum">    3417 </span>            :    DECL_CONTEXT of the referenced VAR_DECLs.  */
<span class="lineNum">    3418 </span>            : static GTY (()) hash_table&lt;variable_value_hasher&gt; *variable_value_hash;
<span class="lineNum">    3419 </span>            : 
<span class="lineNum">    3420 </span>            : struct block_die_hasher : ggc_ptr_hash&lt;die_struct&gt;
<span class="lineNum">    3421 </span>            : {
<span class="lineNum">    3422 </span>            :   static hashval_t hash (die_struct *);
<span class="lineNum">    3423 </span>            :   static bool equal (die_struct *, die_struct *);
<span class="lineNum">    3424 </span>            : };
<span class="lineNum">    3425 </span>            : 
<span class="lineNum">    3426 </span>            : /* A hash table of references to DIE's that describe COMMON blocks.
<span class="lineNum">    3427 </span>            :    The key is DECL_UID() ^ die_parent.  */
<span class="lineNum">    3428 </span>            : static GTY (()) hash_table&lt;block_die_hasher&gt; *common_block_die_table;
<span class="lineNum">    3429 </span>            : 
<span class="lineNum">    3430 </span>            : typedef struct GTY(()) die_arg_entry_struct {
<span class="lineNum">    3431 </span>            :     dw_die_ref die;
<span class="lineNum">    3432 </span>            :     tree arg;
<span class="lineNum">    3433 </span>            : } die_arg_entry;
<span class="lineNum">    3434 </span>            : 
<span class="lineNum">    3435 </span>            : 
<span class="lineNum">    3436 </span>            : /* Node of the variable location list.  */
<span class="lineNum">    3437 </span>            : struct GTY ((chain_next (&quot;%h.next&quot;))) var_loc_node {
<span class="lineNum">    3438 </span>            :   /* Either NOTE_INSN_VAR_LOCATION, or, for SRA optimized variables,
<span class="lineNum">    3439 </span>            :      EXPR_LIST chain.  For small bitsizes, bitsize is encoded
<span class="lineNum">    3440 </span>            :      in mode of the EXPR_LIST node and first EXPR_LIST operand
<span class="lineNum">    3441 </span>            :      is either NOTE_INSN_VAR_LOCATION for a piece with a known
<span class="lineNum">    3442 </span>            :      location or NULL for padding.  For larger bitsizes,
<span class="lineNum">    3443 </span>            :      mode is 0 and first operand is a CONCAT with bitsize
<span class="lineNum">    3444 </span>            :      as first CONCAT operand and NOTE_INSN_VAR_LOCATION resp.
<span class="lineNum">    3445 </span>            :      NULL as second operand.  */
<span class="lineNum">    3446 </span>            :   rtx GTY (()) loc;
<span class="lineNum">    3447 </span>            :   const char * GTY (()) label;
<span class="lineNum">    3448 </span>            :   struct var_loc_node * GTY (()) next;
<span class="lineNum">    3449 </span>            :   var_loc_view view;
<span class="lineNum">    3450 </span>            : };
<span class="lineNum">    3451 </span>            : 
<span class="lineNum">    3452 </span>            : /* Variable location list.  */
<span class="lineNum">    3453 </span>            : struct GTY ((for_user)) var_loc_list_def {
<span class="lineNum">    3454 </span>            :   struct var_loc_node * GTY (()) first;
<span class="lineNum">    3455 </span>            : 
<span class="lineNum">    3456 </span>            :   /* Pointer to the last but one or last element of the
<span class="lineNum">    3457 </span>            :      chained list.  If the list is empty, both first and
<span class="lineNum">    3458 </span>            :      last are NULL, if the list contains just one node
<span class="lineNum">    3459 </span>            :      or the last node certainly is not redundant, it points
<span class="lineNum">    3460 </span>            :      to the last node, otherwise points to the last but one.
<span class="lineNum">    3461 </span>            :      Do not mark it for GC because it is marked through the chain.  */
<span class="lineNum">    3462 </span>            :   struct var_loc_node * GTY ((skip (&quot;%h&quot;))) last;
<span class="lineNum">    3463 </span>            : 
<span class="lineNum">    3464 </span>            :   /* Pointer to the last element before section switch,
<span class="lineNum">    3465 </span>            :      if NULL, either sections weren't switched or first
<span class="lineNum">    3466 </span>            :      is after section switch.  */
<span class="lineNum">    3467 </span>            :   struct var_loc_node * GTY ((skip (&quot;%h&quot;))) last_before_switch;
<span class="lineNum">    3468 </span>            : 
<span class="lineNum">    3469 </span>            :   /* DECL_UID of the variable decl.  */
<span class="lineNum">    3470 </span>            :   unsigned int decl_id;
<span class="lineNum">    3471 </span>            : };
<span class="lineNum">    3472 </span>            : typedef struct var_loc_list_def var_loc_list;
<span class="lineNum">    3473 </span>            : 
<span class="lineNum">    3474 </span>            : /* Call argument location list.  */
<span class="lineNum">    3475 </span>            : struct GTY ((chain_next (&quot;%h.next&quot;))) call_arg_loc_node {
<span class="lineNum">    3476 </span>            :   rtx GTY (()) call_arg_loc_note;
<span class="lineNum">    3477 </span>            :   const char * GTY (()) label;
<span class="lineNum">    3478 </span>            :   tree GTY (()) block;
<span class="lineNum">    3479 </span>            :   bool tail_call_p;
<span class="lineNum">    3480 </span>            :   rtx GTY (()) symbol_ref;
<span class="lineNum">    3481 </span>            :   struct call_arg_loc_node * GTY (()) next;
<span class="lineNum">    3482 </span>            : };
<span class="lineNum">    3483 </span>            : 
<span class="lineNum">    3484 </span>            : 
<span class="lineNum">    3485 </span>            : struct decl_loc_hasher : ggc_ptr_hash&lt;var_loc_list&gt;
<span class="lineNum">    3486 </span>            : {
<span class="lineNum">    3487 </span>            :   typedef const_tree compare_type;
<span class="lineNum">    3488 </span>            : 
<span class="lineNum">    3489 </span>            :   static hashval_t hash (var_loc_list *);
<span class="lineNum">    3490 </span>            :   static bool equal (var_loc_list *, const_tree);
<span class="lineNum">    3491 </span>            : };
<span class="lineNum">    3492 </span>            : 
<span class="lineNum">    3493 </span>            : /* Table of decl location linked lists.  */
<span class="lineNum">    3494 </span>            : static GTY (()) hash_table&lt;decl_loc_hasher&gt; *decl_loc_table;
<span class="lineNum">    3495 </span>            : 
<span class="lineNum">    3496 </span>            : /* Head and tail of call_arg_loc chain.  */
<span class="lineNum">    3497 </span>            : static GTY (()) struct call_arg_loc_node *call_arg_locations;
<span class="lineNum">    3498 </span>            : static struct call_arg_loc_node *call_arg_loc_last;
<span class="lineNum">    3499 </span>            : 
<span class="lineNum">    3500 </span>            : /* Number of call sites in the current function.  */
<span class="lineNum">    3501 </span>            : static int call_site_count = -1;
<span class="lineNum">    3502 </span>            : /* Number of tail call sites in the current function.  */
<span class="lineNum">    3503 </span>            : static int tail_call_site_count = -1;
<span class="lineNum">    3504 </span>            : 
<span class="lineNum">    3505 </span>            : /* A cached location list.  */
<span class="lineNum">    3506 </span>            : struct GTY ((for_user)) cached_dw_loc_list_def {
<span class="lineNum">    3507 </span>            :   /* The DECL_UID of the decl that this entry describes.  */
<span class="lineNum">    3508 </span>            :   unsigned int decl_id;
<span class="lineNum">    3509 </span>            : 
<span class="lineNum">    3510 </span>            :   /* The cached location list.  */
<span class="lineNum">    3511 </span>            :   dw_loc_list_ref loc_list;
<span class="lineNum">    3512 </span>            : };
<span class="lineNum">    3513 </span>            : typedef struct cached_dw_loc_list_def cached_dw_loc_list;
<span class="lineNum">    3514 </span>            : 
<span class="lineNum">    3515 </span>            : struct dw_loc_list_hasher : ggc_ptr_hash&lt;cached_dw_loc_list&gt;
<span class="lineNum">    3516 </span>            : {
<span class="lineNum">    3517 </span>            : 
<span class="lineNum">    3518 </span>            :   typedef const_tree compare_type;
<span class="lineNum">    3519 </span>            :   
<span class="lineNum">    3520 </span>            :   static hashval_t hash (cached_dw_loc_list *);
<span class="lineNum">    3521 </span>            :   static bool equal (cached_dw_loc_list *, const_tree);
<span class="lineNum">    3522 </span>            : };
<span class="lineNum">    3523 </span>            : 
<span class="lineNum">    3524 </span>            : /* Table of cached location lists.  */
<span class="lineNum">    3525 </span>            : static GTY (()) hash_table&lt;dw_loc_list_hasher&gt; *cached_dw_loc_list_table;
<span class="lineNum">    3526 </span>            : 
<span class="lineNum">    3527 </span>            : /* A vector of references to DIE's that are uniquely identified by their tag,
<span class="lineNum">    3528 </span>            :    presence/absence of children DIE's, and list of attribute/value pairs.  */
<span class="lineNum">    3529 </span>            : static GTY(()) vec&lt;dw_die_ref, va_gc&gt; *abbrev_die_table;
<span class="lineNum">    3530 </span>            : 
<span class="lineNum">    3531 </span>            : /* A hash map to remember the stack usage for DWARF procedures.  The value
<span class="lineNum">    3532 </span>            :    stored is the stack size difference between before the DWARF procedure
<span class="lineNum">    3533 </span>            :    invokation and after it returned.  In other words, for a DWARF procedure
<span class="lineNum">    3534 </span>            :    that consumes N stack slots and that pushes M ones, this stores M - N.  */
<span class="lineNum">    3535 </span>            : static hash_map&lt;dw_die_ref, int&gt; *dwarf_proc_stack_usage_map;
<span class="lineNum">    3536 </span>            : 
<span class="lineNum">    3537 </span>            : /* A global counter for generating labels for line number data.  */
<span class="lineNum">    3538 </span>            : static unsigned int line_info_label_num;
<span class="lineNum">    3539 </span>            : 
<span class="lineNum">    3540 </span>            : /* The current table to which we should emit line number information
<span class="lineNum">    3541 </span>            :    for the current function.  This will be set up at the beginning of
<span class="lineNum">    3542 </span>            :    assembly for the function.  */
<span class="lineNum">    3543 </span>            : static GTY(()) dw_line_info_table *cur_line_info_table;
<span class="lineNum">    3544 </span>            : 
<span class="lineNum">    3545 </span>            : /* The two default tables of line number info.  */
<span class="lineNum">    3546 </span>            : static GTY(()) dw_line_info_table *text_section_line_info;
<span class="lineNum">    3547 </span>            : static GTY(()) dw_line_info_table *cold_text_section_line_info;
<span class="lineNum">    3548 </span>            : 
<span class="lineNum">    3549 </span>            : /* The set of all non-default tables of line number info.  */
<span class="lineNum">    3550 </span>            : static GTY(()) vec&lt;dw_line_info_table *, va_gc&gt; *separate_line_info;
<span class="lineNum">    3551 </span>            : 
<span class="lineNum">    3552 </span>            : /* A flag to tell pubnames/types export if there is an info section to
<span class="lineNum">    3553 </span>            :    refer to.  */
<span class="lineNum">    3554 </span>            : static bool info_section_emitted;
<span class="lineNum">    3555 </span>            : 
<span class="lineNum">    3556 </span>            : /* A pointer to the base of a table that contains a list of publicly
<span class="lineNum">    3557 </span>            :    accessible names.  */
<span class="lineNum">    3558 </span>            : static GTY (()) vec&lt;pubname_entry, va_gc&gt; *pubname_table;
<span class="lineNum">    3559 </span>            : 
<span class="lineNum">    3560 </span>            : /* A pointer to the base of a table that contains a list of publicly
<span class="lineNum">    3561 </span>            :    accessible types.  */
<span class="lineNum">    3562 </span>            : static GTY (()) vec&lt;pubname_entry, va_gc&gt; *pubtype_table;
<span class="lineNum">    3563 </span>            : 
<span class="lineNum">    3564 </span>            : /* A pointer to the base of a table that contains a list of macro
<span class="lineNum">    3565 </span>            :    defines/undefines (and file start/end markers).  */
<span class="lineNum">    3566 </span>            : static GTY (()) vec&lt;macinfo_entry, va_gc&gt; *macinfo_table;
<span class="lineNum">    3567 </span>            : 
<span class="lineNum">    3568 </span>            : /* True if .debug_macinfo or .debug_macros section is going to be
<span class="lineNum">    3569 </span>            :    emitted.  */
<span class="lineNum">    3570 </span>            : #define have_macinfo \
<span class="lineNum">    3571 </span>            :   ((!XCOFF_DEBUGGING_INFO || HAVE_XCOFF_DWARF_EXTRAS) \
<span class="lineNum">    3572 </span>            :    &amp;&amp; debug_info_level &gt;= DINFO_LEVEL_VERBOSE \
<span class="lineNum">    3573 </span>            :    &amp;&amp; !macinfo_table-&gt;is_empty ())
<span class="lineNum">    3574 </span>            : 
<span class="lineNum">    3575 </span>            : /* Vector of dies for which we should generate .debug_ranges info.  */
<span class="lineNum">    3576 </span>            : static GTY (()) vec&lt;dw_ranges, va_gc&gt; *ranges_table;
<span class="lineNum">    3577 </span>            : 
<span class="lineNum">    3578 </span>            : /* Vector of pairs of labels referenced in ranges_table.  */
<span class="lineNum">    3579 </span>            : static GTY (()) vec&lt;dw_ranges_by_label, va_gc&gt; *ranges_by_label;
<span class="lineNum">    3580 </span>            : 
<span class="lineNum">    3581 </span>            : /* Whether we have location lists that need outputting */
<span class="lineNum">    3582 </span>            : static GTY(()) bool have_location_lists;
<span class="lineNum">    3583 </span>            : 
<span class="lineNum">    3584 </span>            : /* Unique label counter.  */
<span class="lineNum">    3585 </span>            : static GTY(()) unsigned int loclabel_num;
<span class="lineNum">    3586 </span>            : 
<span class="lineNum">    3587 </span>            : /* Unique label counter for point-of-call tables.  */
<span class="lineNum">    3588 </span>            : static GTY(()) unsigned int poc_label_num;
<span class="lineNum">    3589 </span>            : 
<span class="lineNum">    3590 </span>            : /* The last file entry emitted by maybe_emit_file().  */
<span class="lineNum">    3591 </span>            : static GTY(()) struct dwarf_file_data * last_emitted_file;
<span class="lineNum">    3592 </span>            : 
<span class="lineNum">    3593 </span>            : /* Number of internal labels generated by gen_internal_sym().  */
<span class="lineNum">    3594 </span>            : static GTY(()) int label_num;
<span class="lineNum">    3595 </span>            : 
<span class="lineNum">    3596 </span>            : static GTY(()) vec&lt;die_arg_entry, va_gc&gt; *tmpl_value_parm_die_table;
<span class="lineNum">    3597 </span>            : 
<span class="lineNum">    3598 </span>            : /* Instances of generic types for which we need to generate debug
<span class="lineNum">    3599 </span>            :    info that describe their generic parameters and arguments. That
<span class="lineNum">    3600 </span>            :    generation needs to happen once all types are properly laid out so
<span class="lineNum">    3601 </span>            :    we do it at the end of compilation.  */
<span class="lineNum">    3602 </span>            : static GTY(()) vec&lt;tree, va_gc&gt; *generic_type_instances;
<span class="lineNum">    3603 </span>            : 
<span class="lineNum">    3604 </span>            : /* Offset from the &quot;steady-state frame pointer&quot; to the frame base,
<span class="lineNum">    3605 </span>            :    within the current function.  */
<span class="lineNum">    3606 </span>            : static poly_int64 frame_pointer_fb_offset;
<span class="lineNum">    3607 </span>            : static bool frame_pointer_fb_offset_valid;
<span class="lineNum">    3608 </span>            : 
<span class="lineNum">    3609 </span>            : static vec&lt;dw_die_ref&gt; base_types;
<span class="lineNum">    3610 </span>            : 
<span class="lineNum">    3611 </span>            : /* Flags to represent a set of attribute classes for attributes that represent
<span class="lineNum">    3612 </span>            :    a scalar value (bounds, pointers, ...).  */
<span class="lineNum">    3613 </span>            : enum dw_scalar_form
<span class="lineNum">    3614 </span>            : {
<span class="lineNum">    3615 </span>            :   dw_scalar_form_constant = 0x01,
<span class="lineNum">    3616 </span>            :   dw_scalar_form_exprloc = 0x02,
<span class="lineNum">    3617 </span>            :   dw_scalar_form_reference = 0x04
<span class="lineNum">    3618 </span>            : };
<span class="lineNum">    3619 </span>            : 
<span class="lineNum">    3620 </span>            : /* Forward declarations for functions defined in this file.  */
<span class="lineNum">    3621 </span>            : 
<span class="lineNum">    3622 </span>            : static int is_pseudo_reg (const_rtx);
<span class="lineNum">    3623 </span>            : static tree type_main_variant (tree);
<span class="lineNum">    3624 </span>            : static int is_tagged_type (const_tree);
<span class="lineNum">    3625 </span>            : static const char *dwarf_tag_name (unsigned);
<span class="lineNum">    3626 </span>            : static const char *dwarf_attr_name (unsigned);
<span class="lineNum">    3627 </span>            : static const char *dwarf_form_name (unsigned);
<span class="lineNum">    3628 </span>            : static tree decl_ultimate_origin (const_tree);
<span class="lineNum">    3629 </span>            : static tree decl_class_context (tree);
<span class="lineNum">    3630 </span>            : static void add_dwarf_attr (dw_die_ref, dw_attr_node *);
<span class="lineNum">    3631 </span>            : static inline enum dw_val_class AT_class (dw_attr_node *);
<span class="lineNum">    3632 </span>            : static inline unsigned int AT_index (dw_attr_node *);
<span class="lineNum">    3633 </span>            : static void add_AT_flag (dw_die_ref, enum dwarf_attribute, unsigned);
<span class="lineNum">    3634 </span>            : static inline unsigned AT_flag (dw_attr_node *);
<span class="lineNum">    3635 </span>            : static void add_AT_int (dw_die_ref, enum dwarf_attribute, HOST_WIDE_INT);
<span class="lineNum">    3636 </span>            : static inline HOST_WIDE_INT AT_int (dw_attr_node *);
<span class="lineNum">    3637 </span>            : static void add_AT_unsigned (dw_die_ref, enum dwarf_attribute, unsigned HOST_WIDE_INT);
<span class="lineNum">    3638 </span>            : static inline unsigned HOST_WIDE_INT AT_unsigned (dw_attr_node *);
<span class="lineNum">    3639 </span>            : static void add_AT_double (dw_die_ref, enum dwarf_attribute,
<span class="lineNum">    3640 </span>            :                            HOST_WIDE_INT, unsigned HOST_WIDE_INT);
<span class="lineNum">    3641 </span>            : static inline void add_AT_vec (dw_die_ref, enum dwarf_attribute, unsigned int,
<span class="lineNum">    3642 </span>            :                                unsigned int, unsigned char *);
<span class="lineNum">    3643 </span>            : static void add_AT_data8 (dw_die_ref, enum dwarf_attribute, unsigned char *);
<span class="lineNum">    3644 </span>            : static void add_AT_string (dw_die_ref, enum dwarf_attribute, const char *);
<span class="lineNum">    3645 </span>            : static inline const char *AT_string (dw_attr_node *);
<span class="lineNum">    3646 </span>            : static enum dwarf_form AT_string_form (dw_attr_node *);
<span class="lineNum">    3647 </span>            : static void add_AT_die_ref (dw_die_ref, enum dwarf_attribute, dw_die_ref);
<span class="lineNum">    3648 </span>            : static void add_AT_specification (dw_die_ref, dw_die_ref);
<span class="lineNum">    3649 </span>            : static inline dw_die_ref AT_ref (dw_attr_node *);
<span class="lineNum">    3650 </span>            : static inline int AT_ref_external (dw_attr_node *);
<span class="lineNum">    3651 </span>            : static inline void set_AT_ref_external (dw_attr_node *, int);
<span class="lineNum">    3652 </span>            : static void add_AT_fde_ref (dw_die_ref, enum dwarf_attribute, unsigned);
<span class="lineNum">    3653 </span>            : static void add_AT_loc (dw_die_ref, enum dwarf_attribute, dw_loc_descr_ref);
<span class="lineNum">    3654 </span>            : static inline dw_loc_descr_ref AT_loc (dw_attr_node *);
<span class="lineNum">    3655 </span>            : static void add_AT_loc_list (dw_die_ref, enum dwarf_attribute,
<span class="lineNum">    3656 </span>            :                              dw_loc_list_ref);
<span class="lineNum">    3657 </span>            : static inline dw_loc_list_ref AT_loc_list (dw_attr_node *);
<span class="lineNum">    3658 </span>            : static void add_AT_view_list (dw_die_ref, enum dwarf_attribute);
<span class="lineNum">    3659 </span>            : static inline dw_loc_list_ref AT_loc_list (dw_attr_node *);
<span class="lineNum">    3660 </span>            : static addr_table_entry *add_addr_table_entry (void *, enum ate_kind);
<span class="lineNum">    3661 </span>            : static void remove_addr_table_entry (addr_table_entry *);
<span class="lineNum">    3662 </span>            : static void add_AT_addr (dw_die_ref, enum dwarf_attribute, rtx, bool);
<span class="lineNum">    3663 </span>            : static inline rtx AT_addr (dw_attr_node *);
<span class="lineNum">    3664 </span>            : static void add_AT_symview (dw_die_ref, enum dwarf_attribute, const char *);
<span class="lineNum">    3665 </span>            : static void add_AT_lbl_id (dw_die_ref, enum dwarf_attribute, const char *);
<span class="lineNum">    3666 </span>            : static void add_AT_lineptr (dw_die_ref, enum dwarf_attribute, const char *);
<span class="lineNum">    3667 </span>            : static void add_AT_macptr (dw_die_ref, enum dwarf_attribute, const char *);
<span class="lineNum">    3668 </span>            : static void add_AT_loclistsptr (dw_die_ref, enum dwarf_attribute,
<span class="lineNum">    3669 </span>            :                                 const char *);
<span class="lineNum">    3670 </span>            : static void add_AT_offset (dw_die_ref, enum dwarf_attribute,
<span class="lineNum">    3671 </span>            :                            unsigned HOST_WIDE_INT);
<span class="lineNum">    3672 </span>            : static void add_AT_range_list (dw_die_ref, enum dwarf_attribute,
<span class="lineNum">    3673 </span>            :                                unsigned long, bool);
<span class="lineNum">    3674 </span>            : static inline const char *AT_lbl (dw_attr_node *);
<span class="lineNum">    3675 </span>            : static dw_attr_node *get_AT (dw_die_ref, enum dwarf_attribute);
<span class="lineNum">    3676 </span>            : static const char *get_AT_low_pc (dw_die_ref);
<span class="lineNum">    3677 </span>            : static const char *get_AT_hi_pc (dw_die_ref);
<span class="lineNum">    3678 </span>            : static const char *get_AT_string (dw_die_ref, enum dwarf_attribute);
<span class="lineNum">    3679 </span>            : static int get_AT_flag (dw_die_ref, enum dwarf_attribute);
<span class="lineNum">    3680 </span>            : static unsigned get_AT_unsigned (dw_die_ref, enum dwarf_attribute);
<span class="lineNum">    3681 </span>            : static inline dw_die_ref get_AT_ref (dw_die_ref, enum dwarf_attribute);
<span class="lineNum">    3682 </span>            : static bool is_c (void);
<span class="lineNum">    3683 </span>            : static bool is_cxx (void);
<span class="lineNum">    3684 </span>            : static bool is_cxx (const_tree);
<span class="lineNum">    3685 </span>            : static bool is_fortran (void);
<span class="lineNum">    3686 </span>            : static bool is_ada (void);
<span class="lineNum">    3687 </span>            : static bool remove_AT (dw_die_ref, enum dwarf_attribute);
<span class="lineNum">    3688 </span>            : static void remove_child_TAG (dw_die_ref, enum dwarf_tag);
<span class="lineNum">    3689 </span>            : static void add_child_die (dw_die_ref, dw_die_ref);
<span class="lineNum">    3690 </span>            : static dw_die_ref new_die (enum dwarf_tag, dw_die_ref, tree);
<span class="lineNum">    3691 </span>            : static dw_die_ref lookup_type_die (tree);
<span class="lineNum">    3692 </span>            : static dw_die_ref strip_naming_typedef (tree, dw_die_ref);
<span class="lineNum">    3693 </span>            : static dw_die_ref lookup_type_die_strip_naming_typedef (tree);
<span class="lineNum">    3694 </span>            : static void equate_type_number_to_die (tree, dw_die_ref);
<span class="lineNum">    3695 </span>            : static dw_die_ref lookup_decl_die (tree);
<span class="lineNum">    3696 </span>            : static var_loc_list *lookup_decl_loc (const_tree);
<span class="lineNum">    3697 </span>            : static void equate_decl_number_to_die (tree, dw_die_ref);
<span class="lineNum">    3698 </span>            : static struct var_loc_node *add_var_loc_to_decl (tree, rtx, const char *, var_loc_view);
<span class="lineNum">    3699 </span>            : static void print_spaces (FILE *);
<span class="lineNum">    3700 </span>            : static void print_die (dw_die_ref, FILE *);
<span class="lineNum">    3701 </span>            : static void loc_checksum (dw_loc_descr_ref, struct md5_ctx *);
<span class="lineNum">    3702 </span>            : static void attr_checksum (dw_attr_node *, struct md5_ctx *, int *);
<span class="lineNum">    3703 </span>            : static void die_checksum (dw_die_ref, struct md5_ctx *, int *);
<span class="lineNum">    3704 </span>            : static void checksum_sleb128 (HOST_WIDE_INT, struct md5_ctx *);
<span class="lineNum">    3705 </span>            : static void checksum_uleb128 (unsigned HOST_WIDE_INT, struct md5_ctx *);
<span class="lineNum">    3706 </span>            : static void loc_checksum_ordered (dw_loc_descr_ref, struct md5_ctx *);
<span class="lineNum">    3707 </span>            : static void attr_checksum_ordered (enum dwarf_tag, dw_attr_node *,
<span class="lineNum">    3708 </span>            :                                    struct md5_ctx *, int *);
<span class="lineNum">    3709 </span>            : struct checksum_attributes;
<span class="lineNum">    3710 </span>            : static void collect_checksum_attributes (struct checksum_attributes *, dw_die_ref);
<span class="lineNum">    3711 </span>            : static void die_checksum_ordered (dw_die_ref, struct md5_ctx *, int *);
<span class="lineNum">    3712 </span>            : static void checksum_die_context (dw_die_ref, struct md5_ctx *);
<span class="lineNum">    3713 </span>            : static void generate_type_signature (dw_die_ref, comdat_type_node *);
<span class="lineNum">    3714 </span>            : static int same_loc_p (dw_loc_descr_ref, dw_loc_descr_ref, int *);
<span class="lineNum">    3715 </span>            : static int same_dw_val_p (const dw_val_node *, const dw_val_node *, int *);
<span class="lineNum">    3716 </span>            : static int same_attr_p (dw_attr_node *, dw_attr_node *, int *);
<span class="lineNum">    3717 </span>            : static int same_die_p (dw_die_ref, dw_die_ref, int *);
<span class="lineNum">    3718 </span>            : static int is_type_die (dw_die_ref);
<span class="lineNum">    3719 </span>            : static int is_comdat_die (dw_die_ref);
<span class="lineNum">    3720 </span>            : static inline bool is_template_instantiation (dw_die_ref);
<span class="lineNum">    3721 </span>            : static int is_declaration_die (dw_die_ref);
<span class="lineNum">    3722 </span>            : static int should_move_die_to_comdat (dw_die_ref);
<span class="lineNum">    3723 </span>            : static dw_die_ref clone_as_declaration (dw_die_ref);
<span class="lineNum">    3724 </span>            : static dw_die_ref clone_die (dw_die_ref);
<span class="lineNum">    3725 </span>            : static dw_die_ref clone_tree (dw_die_ref);
<span class="lineNum">    3726 </span>            : static dw_die_ref copy_declaration_context (dw_die_ref, dw_die_ref);
<span class="lineNum">    3727 </span>            : static void generate_skeleton_ancestor_tree (skeleton_chain_node *);
<span class="lineNum">    3728 </span>            : static void generate_skeleton_bottom_up (skeleton_chain_node *);
<span class="lineNum">    3729 </span>            : static dw_die_ref generate_skeleton (dw_die_ref);
<span class="lineNum">    3730 </span>            : static dw_die_ref remove_child_or_replace_with_skeleton (dw_die_ref,
<span class="lineNum">    3731 </span>            :                                                          dw_die_ref,
<span class="lineNum">    3732 </span>            :                                                          dw_die_ref);
<span class="lineNum">    3733 </span>            : static void break_out_comdat_types (dw_die_ref);
<span class="lineNum">    3734 </span>            : static void copy_decls_for_unworthy_types (dw_die_ref);
<span class="lineNum">    3735 </span>            : 
<span class="lineNum">    3736 </span>            : static void add_sibling_attributes (dw_die_ref);
<span class="lineNum">    3737 </span>            : static void output_location_lists (dw_die_ref);
<span class="lineNum">    3738 </span>            : static int constant_size (unsigned HOST_WIDE_INT);
<span class="lineNum">    3739 </span>            : static unsigned long size_of_die (dw_die_ref);
<span class="lineNum">    3740 </span>            : static void calc_die_sizes (dw_die_ref);
<span class="lineNum">    3741 </span>            : static void calc_base_type_die_sizes (void);
<span class="lineNum">    3742 </span>            : static void mark_dies (dw_die_ref);
<span class="lineNum">    3743 </span>            : static void unmark_dies (dw_die_ref);
<span class="lineNum">    3744 </span>            : static void unmark_all_dies (dw_die_ref);
<span class="lineNum">    3745 </span>            : static unsigned long size_of_pubnames (vec&lt;pubname_entry, va_gc&gt; *);
<span class="lineNum">    3746 </span>            : static unsigned long size_of_aranges (void);
<span class="lineNum">    3747 </span>            : static enum dwarf_form value_format (dw_attr_node *);
<span class="lineNum">    3748 </span>            : static void output_value_format (dw_attr_node *);
<span class="lineNum">    3749 </span>            : static void output_abbrev_section (void);
<span class="lineNum">    3750 </span>            : static void output_die_abbrevs (unsigned long, dw_die_ref);
<span class="lineNum">    3751 </span>            : static void output_die (dw_die_ref);
<span class="lineNum">    3752 </span>            : static void output_compilation_unit_header (enum dwarf_unit_type);
<span class="lineNum">    3753 </span>            : static void output_comp_unit (dw_die_ref, int, const unsigned char *);
<span class="lineNum">    3754 </span>            : static void output_comdat_type_unit (comdat_type_node *);
<span class="lineNum">    3755 </span>            : static const char *dwarf2_name (tree, int);
<span class="lineNum">    3756 </span>            : static void add_pubname (tree, dw_die_ref);
<span class="lineNum">    3757 </span>            : static void add_enumerator_pubname (const char *, dw_die_ref);
<span class="lineNum">    3758 </span>            : static void add_pubname_string (const char *, dw_die_ref);
<span class="lineNum">    3759 </span>            : static void add_pubtype (tree, dw_die_ref);
<span class="lineNum">    3760 </span>            : static void output_pubnames (vec&lt;pubname_entry, va_gc&gt; *);
<span class="lineNum">    3761 </span>            : static void output_aranges (void);
<span class="lineNum">    3762 </span>            : static unsigned int add_ranges (const_tree, bool = false);
<span class="lineNum">    3763 </span>            : static void add_ranges_by_labels (dw_die_ref, const char *, const char *,
<span class="lineNum">    3764 </span>            :                                   bool *, bool);
<span class="lineNum">    3765 </span>            : static void output_ranges (void);
<span class="lineNum">    3766 </span>            : static dw_line_info_table *new_line_info_table (void);
<span class="lineNum">    3767 </span>            : static void output_line_info (bool);
<span class="lineNum">    3768 </span>            : static void output_file_names (void);
<span class="lineNum">    3769 </span>            : static dw_die_ref base_type_die (tree, bool);
<span class="lineNum">    3770 </span>            : static int is_base_type (tree);
<span class="lineNum">    3771 </span>            : static dw_die_ref subrange_type_die (tree, tree, tree, tree, dw_die_ref);
<span class="lineNum">    3772 </span>            : static int decl_quals (const_tree);
<span class="lineNum">    3773 </span>            : static dw_die_ref modified_type_die (tree, int, bool, dw_die_ref);
<span class="lineNum">    3774 </span>            : static dw_die_ref generic_parameter_die (tree, tree, bool, dw_die_ref);
<span class="lineNum">    3775 </span>            : static dw_die_ref template_parameter_pack_die (tree, tree, dw_die_ref);
<span class="lineNum">    3776 </span>            : static int type_is_enum (const_tree);
<span class="lineNum">    3777 </span>            : static unsigned int dbx_reg_number (const_rtx);
<span class="lineNum">    3778 </span>            : static void add_loc_descr_op_piece (dw_loc_descr_ref *, int);
<span class="lineNum">    3779 </span>            : static dw_loc_descr_ref reg_loc_descriptor (rtx, enum var_init_status);
<span class="lineNum">    3780 </span>            : static dw_loc_descr_ref one_reg_loc_descriptor (unsigned int,
<span class="lineNum">    3781 </span>            :                                                 enum var_init_status);
<span class="lineNum">    3782 </span>            : static dw_loc_descr_ref multiple_reg_loc_descriptor (rtx, rtx,
<span class="lineNum">    3783 </span>            :                                                      enum var_init_status);
<span class="lineNum">    3784 </span>            : static dw_loc_descr_ref based_loc_descr (rtx, poly_int64,
<span class="lineNum">    3785 </span>            :                                          enum var_init_status);
<span class="lineNum">    3786 </span>            : static int is_based_loc (const_rtx);
<span class="lineNum">    3787 </span>            : static bool resolve_one_addr (rtx *);
<span class="lineNum">    3788 </span>            : static dw_loc_descr_ref concat_loc_descriptor (rtx, rtx,
<span class="lineNum">    3789 </span>            :                                                enum var_init_status);
<span class="lineNum">    3790 </span>            : static dw_loc_descr_ref loc_descriptor (rtx, machine_mode mode,
<span class="lineNum">    3791 </span>            :                                         enum var_init_status);
<span class="lineNum">    3792 </span>            : struct loc_descr_context;
<span class="lineNum">    3793 </span>            : static void add_loc_descr_to_each (dw_loc_list_ref list, dw_loc_descr_ref ref);
<span class="lineNum">    3794 </span>            : static void add_loc_list (dw_loc_list_ref *ret, dw_loc_list_ref list);
<span class="lineNum">    3795 </span>            : static dw_loc_list_ref loc_list_from_tree (tree, int,
<span class="lineNum">    3796 </span>            :                                            struct loc_descr_context *);
<span class="lineNum">    3797 </span>            : static dw_loc_descr_ref loc_descriptor_from_tree (tree, int,
<span class="lineNum">    3798 </span>            :                                                   struct loc_descr_context *);
<span class="lineNum">    3799 </span>            : static HOST_WIDE_INT ceiling (HOST_WIDE_INT, unsigned int);
<span class="lineNum">    3800 </span>            : static tree field_type (const_tree);
<span class="lineNum">    3801 </span>            : static unsigned int simple_type_align_in_bits (const_tree);
<span class="lineNum">    3802 </span>            : static unsigned int simple_decl_align_in_bits (const_tree);
<span class="lineNum">    3803 </span>            : static unsigned HOST_WIDE_INT simple_type_size_in_bits (const_tree);
<span class="lineNum">    3804 </span>            : struct vlr_context;
<span class="lineNum">    3805 </span>            : static dw_loc_descr_ref field_byte_offset (const_tree, struct vlr_context *,
<span class="lineNum">    3806 </span>            :                                            HOST_WIDE_INT *);
<span class="lineNum">    3807 </span>            : static void add_AT_location_description (dw_die_ref, enum dwarf_attribute,
<span class="lineNum">    3808 </span>            :                                          dw_loc_list_ref);
<span class="lineNum">    3809 </span>            : static void add_data_member_location_attribute (dw_die_ref, tree,
<span class="lineNum">    3810 </span>            :                                                 struct vlr_context *);
<span class="lineNum">    3811 </span>            : static bool add_const_value_attribute (dw_die_ref, rtx);
<span class="lineNum">    3812 </span>            : static void insert_int (HOST_WIDE_INT, unsigned, unsigned char *);
<span class="lineNum">    3813 </span>            : static void insert_wide_int (const wide_int &amp;, unsigned char *, int);
<span class="lineNum">    3814 </span>            : static void insert_float (const_rtx, unsigned char *);
<span class="lineNum">    3815 </span>            : static rtx rtl_for_decl_location (tree);
<span class="lineNum">    3816 </span>            : static bool add_location_or_const_value_attribute (dw_die_ref, tree, bool);
<span class="lineNum">    3817 </span>            : static bool tree_add_const_value_attribute (dw_die_ref, tree);
<span class="lineNum">    3818 </span>            : static bool tree_add_const_value_attribute_for_decl (dw_die_ref, tree);
<span class="lineNum">    3819 </span>            : static void add_name_attribute (dw_die_ref, const char *);
<span class="lineNum">    3820 </span>            : static void add_desc_attribute (dw_die_ref, tree);
<span class="lineNum">    3821 </span>            : static void add_gnat_descriptive_type_attribute (dw_die_ref, tree, dw_die_ref);
<span class="lineNum">    3822 </span>            : static void add_comp_dir_attribute (dw_die_ref);
<span class="lineNum">    3823 </span>            : static void add_scalar_info (dw_die_ref, enum dwarf_attribute, tree, int,
<span class="lineNum">    3824 </span>            :                              struct loc_descr_context *);
<span class="lineNum">    3825 </span>            : static void add_bound_info (dw_die_ref, enum dwarf_attribute, tree,
<span class="lineNum">    3826 </span>            :                             struct loc_descr_context *);
<span class="lineNum">    3827 </span>            : static void add_subscript_info (dw_die_ref, tree, bool);
<span class="lineNum">    3828 </span>            : static void add_byte_size_attribute (dw_die_ref, tree);
<span class="lineNum">    3829 </span>            : static void add_alignment_attribute (dw_die_ref, tree);
<span class="lineNum">    3830 </span>            : static inline void add_bit_offset_attribute (dw_die_ref, tree,
<span class="lineNum">    3831 </span>            :                                              struct vlr_context *);
<span class="lineNum">    3832 </span>            : static void add_bit_size_attribute (dw_die_ref, tree);
<span class="lineNum">    3833 </span>            : static void add_prototyped_attribute (dw_die_ref, tree);
<span class="lineNum">    3834 </span>            : static dw_die_ref add_abstract_origin_attribute (dw_die_ref, tree);
<span class="lineNum">    3835 </span>            : static void add_pure_or_virtual_attribute (dw_die_ref, tree);
<span class="lineNum">    3836 </span>            : static void add_src_coords_attributes (dw_die_ref, tree);
<span class="lineNum">    3837 </span>            : static void add_name_and_src_coords_attributes (dw_die_ref, tree, bool = false);
<span class="lineNum">    3838 </span>            : static void add_discr_value (dw_die_ref, dw_discr_value *);
<span class="lineNum">    3839 </span>            : static void add_discr_list (dw_die_ref, dw_discr_list_ref);
<span class="lineNum">    3840 </span>            : static inline dw_discr_list_ref AT_discr_list (dw_attr_node *);
<span class="lineNum">    3841 </span>            : static dw_die_ref scope_die_for (tree, dw_die_ref);
<span class="lineNum">    3842 </span>            : static inline int local_scope_p (dw_die_ref);
<span class="lineNum">    3843 </span>            : static inline int class_scope_p (dw_die_ref);
<span class="lineNum">    3844 </span>            : static inline int class_or_namespace_scope_p (dw_die_ref);
<span class="lineNum">    3845 </span>            : static void add_type_attribute (dw_die_ref, tree, int, bool, dw_die_ref);
<span class="lineNum">    3846 </span>            : static void add_calling_convention_attribute (dw_die_ref, tree);
<span class="lineNum">    3847 </span>            : static const char *type_tag (const_tree);
<span class="lineNum">    3848 </span>            : static tree member_declared_type (const_tree);
<span class="lineNum">    3849 </span>            : #if 0
<span class="lineNum">    3850 </span>            : static const char *decl_start_label (tree);
<span class="lineNum">    3851 </span>            : #endif
<span class="lineNum">    3852 </span>            : static void gen_array_type_die (tree, dw_die_ref);
<span class="lineNum">    3853 </span>            : static void gen_descr_array_type_die (tree, struct array_descr_info *, dw_die_ref);
<span class="lineNum">    3854 </span>            : #if 0
<span class="lineNum">    3855 </span>            : static void gen_entry_point_die (tree, dw_die_ref);
<span class="lineNum">    3856 </span>            : #endif
<span class="lineNum">    3857 </span>            : static dw_die_ref gen_enumeration_type_die (tree, dw_die_ref);
<span class="lineNum">    3858 </span>            : static dw_die_ref gen_formal_parameter_die (tree, tree, bool, dw_die_ref);
<span class="lineNum">    3859 </span>            : static dw_die_ref gen_formal_parameter_pack_die  (tree, tree, dw_die_ref, tree*);
<span class="lineNum">    3860 </span>            : static void gen_unspecified_parameters_die (tree, dw_die_ref);
<span class="lineNum">    3861 </span>            : static void gen_formal_types_die (tree, dw_die_ref);
<span class="lineNum">    3862 </span>            : static void gen_subprogram_die (tree, dw_die_ref);
<span class="lineNum">    3863 </span>            : static void gen_variable_die (tree, tree, dw_die_ref);
<span class="lineNum">    3864 </span>            : static void gen_const_die (tree, dw_die_ref);
<span class="lineNum">    3865 </span>            : static void gen_label_die (tree, dw_die_ref);
<span class="lineNum">    3866 </span>            : static void gen_lexical_block_die (tree, dw_die_ref);
<span class="lineNum">    3867 </span>            : static void gen_inlined_subroutine_die (tree, dw_die_ref);
<span class="lineNum">    3868 </span>            : static void gen_field_die (tree, struct vlr_context *, dw_die_ref);
<span class="lineNum">    3869 </span>            : static void gen_ptr_to_mbr_type_die (tree, dw_die_ref);
<span class="lineNum">    3870 </span>            : static dw_die_ref gen_compile_unit_die (const char *);
<span class="lineNum">    3871 </span>            : static void gen_inheritance_die (tree, tree, tree, dw_die_ref);
<span class="lineNum">    3872 </span>            : static void gen_member_die (tree, dw_die_ref);
<span class="lineNum">    3873 </span>            : static void gen_struct_or_union_type_die (tree, dw_die_ref,
<span class="lineNum">    3874 </span>            :                                                 enum debug_info_usage);
<span class="lineNum">    3875 </span>            : static void gen_subroutine_type_die (tree, dw_die_ref);
<span class="lineNum">    3876 </span>            : static void gen_typedef_die (tree, dw_die_ref);
<span class="lineNum">    3877 </span>            : static void gen_type_die (tree, dw_die_ref);
<span class="lineNum">    3878 </span>            : static void gen_block_die (tree, dw_die_ref);
<span class="lineNum">    3879 </span>            : static void decls_for_scope (tree, dw_die_ref);
<span class="lineNum">    3880 </span>            : static bool is_naming_typedef_decl (const_tree);
<span class="lineNum">    3881 </span>            : static inline dw_die_ref get_context_die (tree);
<span class="lineNum">    3882 </span>            : static void gen_namespace_die (tree, dw_die_ref);
<span class="lineNum">    3883 </span>            : static dw_die_ref gen_namelist_decl (tree, dw_die_ref, tree);
<span class="lineNum">    3884 </span>            : static dw_die_ref gen_decl_die (tree, tree, struct vlr_context *, dw_die_ref);
<span class="lineNum">    3885 </span>            : static dw_die_ref force_decl_die (tree);
<span class="lineNum">    3886 </span>            : static dw_die_ref force_type_die (tree);
<span class="lineNum">    3887 </span>            : static dw_die_ref setup_namespace_context (tree, dw_die_ref);
<span class="lineNum">    3888 </span>            : static dw_die_ref declare_in_namespace (tree, dw_die_ref);
<span class="lineNum">    3889 </span>            : static struct dwarf_file_data * lookup_filename (const char *);
<span class="lineNum">    3890 </span>            : static void retry_incomplete_types (void);
<span class="lineNum">    3891 </span>            : static void gen_type_die_for_member (tree, tree, dw_die_ref);
<span class="lineNum">    3892 </span>            : static void gen_generic_params_dies (tree);
<span class="lineNum">    3893 </span>            : static void gen_tagged_type_die (tree, dw_die_ref, enum debug_info_usage);
<span class="lineNum">    3894 </span>            : static void gen_type_die_with_usage (tree, dw_die_ref, enum debug_info_usage);
<span class="lineNum">    3895 </span>            : static void splice_child_die (dw_die_ref, dw_die_ref);
<span class="lineNum">    3896 </span>            : static int file_info_cmp (const void *, const void *);
<span class="lineNum">    3897 </span>            : static dw_loc_list_ref new_loc_list (dw_loc_descr_ref, const char *, var_loc_view,
<span class="lineNum">    3898 </span>            :                                      const char *, var_loc_view, const char *);
<span class="lineNum">    3899 </span>            : static void output_loc_list (dw_loc_list_ref);
<span class="lineNum">    3900 </span>            : static char *gen_internal_sym (const char *);
<span class="lineNum">    3901 </span>            : static bool want_pubnames (void);
<span class="lineNum">    3902 </span>            : 
<span class="lineNum">    3903 </span>            : static void prune_unmark_dies (dw_die_ref);
<span class="lineNum">    3904 </span>            : static void prune_unused_types_mark_generic_parms_dies (dw_die_ref);
<span class="lineNum">    3905 </span>            : static void prune_unused_types_mark (dw_die_ref, int);
<span class="lineNum">    3906 </span>            : static void prune_unused_types_walk (dw_die_ref);
<span class="lineNum">    3907 </span>            : static void prune_unused_types_walk_attribs (dw_die_ref);
<span class="lineNum">    3908 </span>            : static void prune_unused_types_prune (dw_die_ref);
<span class="lineNum">    3909 </span>            : static void prune_unused_types (void);
<span class="lineNum">    3910 </span>            : static int maybe_emit_file (struct dwarf_file_data *fd);
<span class="lineNum">    3911 </span>            : static inline const char *AT_vms_delta1 (dw_attr_node *);
<span class="lineNum">    3912 </span>            : static inline const char *AT_vms_delta2 (dw_attr_node *);
<span class="lineNum">    3913 </span>            : static inline void add_AT_vms_delta (dw_die_ref, enum dwarf_attribute,
<span class="lineNum">    3914 </span>            :                                      const char *, const char *);
<span class="lineNum">    3915 </span>            : static void append_entry_to_tmpl_value_parm_die_table (dw_die_ref, tree);
<span class="lineNum">    3916 </span>            : static void gen_remaining_tmpl_value_param_die_attribute (void);
<span class="lineNum">    3917 </span>            : static bool generic_type_p (tree);
<span class="lineNum">    3918 </span>            : static void schedule_generic_params_dies_gen (tree t);
<span class="lineNum">    3919 </span>            : static void gen_scheduled_generic_parms_dies (void);
<span class="lineNum">    3920 </span>            : static void resolve_variable_values (void);
<span class="lineNum">    3921 </span>            : 
<span class="lineNum">    3922 </span>            : static const char *comp_dir_string (void);
<span class="lineNum">    3923 </span>            : 
<span class="lineNum">    3924 </span>            : static void hash_loc_operands (dw_loc_descr_ref, inchash::hash &amp;);
<span class="lineNum">    3925 </span>            : 
<span class="lineNum">    3926 </span>            : /* enum for tracking thread-local variables whose address is really an offset
<span class="lineNum">    3927 </span>            :    relative to the TLS pointer, which will need link-time relocation, but will
<span class="lineNum">    3928 </span>            :    not need relocation by the DWARF consumer.  */
<span class="lineNum">    3929 </span>            : 
<span class="lineNum">    3930 </span>            : enum dtprel_bool
<span class="lineNum">    3931 </span>            : {
<span class="lineNum">    3932 </span>            :   dtprel_false = 0,
<span class="lineNum">    3933 </span>            :   dtprel_true = 1
<span class="lineNum">    3934 </span>            : };
<span class="lineNum">    3935 </span>            : 
<span class="lineNum">    3936 </span>            : /* Return the operator to use for an address of a variable.  For dtprel_true, we
<span class="lineNum">    3937 </span>            :    use DW_OP_const*.  For regular variables, which need both link-time
<span class="lineNum">    3938 </span>            :    relocation and consumer-level relocation (e.g., to account for shared objects
<span class="lineNum">    3939 </span>            :    loaded at a random address), we use DW_OP_addr*.  */
<a name="3940"><span class="lineNum">    3940 </span>            : </a>
<span class="lineNum">    3941 </span>            : static inline enum dwarf_location_atom
<span class="lineNum">    3942 </span><span class="lineCov">    1210295 : dw_addr_op (enum dtprel_bool dtprel)</span>
<span class="lineNum">    3943 </span>            : {
<span class="lineNum">    3944 </span><span class="lineCov">    1210295 :   if (dtprel == dtprel_true)</span>
<span class="lineNum">    3945 </span><span class="lineCov">       4180 :     return (dwarf_split_debug_info ? dwarf_OP (DW_OP_constx)</span>
<span class="lineNum">    3946 </span><span class="lineCov">       4180 :             : (DWARF2_ADDR_SIZE == 4 ? DW_OP_const4u : DW_OP_const8u));</span>
<span class="lineNum">    3947 </span>            :   else
<span class="lineNum">    3948 </span><span class="lineCov">    1206115 :     return dwarf_split_debug_info ? dwarf_OP (DW_OP_addrx) : DW_OP_addr;</span>
<span class="lineNum">    3949 </span>            : }
<span class="lineNum">    3950 </span>            : 
<span class="lineNum">    3951 </span>            : /* Return a pointer to a newly allocated address location description.  If
<span class="lineNum">    3952 </span>            :    dwarf_split_debug_info is true, then record the address with the appropriate
<a name="3953"><span class="lineNum">    3953 </span>            :    relocation.  */</a>
<span class="lineNum">    3954 </span>            : static inline dw_loc_descr_ref
<span class="lineNum">    3955 </span><span class="lineCov">    1210295 : new_addr_loc_descr (rtx addr, enum dtprel_bool dtprel)</span>
<span class="lineNum">    3956 </span>            : {
<span class="lineNum">    3957 </span><span class="lineCov">    1210295 :   dw_loc_descr_ref ref = new_loc_descr (dw_addr_op (dtprel), 0, 0);</span>
<span class="lineNum">    3958 </span>            : 
<span class="lineNum">    3959 </span><span class="lineCov">    1210295 :   ref-&gt;dw_loc_oprnd1.val_class = dw_val_class_addr;</span>
<span class="lineNum">    3960 </span><span class="lineCov">    1210295 :   ref-&gt;dw_loc_oprnd1.v.val_addr = addr;</span>
<span class="lineNum">    3961 </span><span class="lineCov">    1210295 :   ref-&gt;dtprel = dtprel;</span>
<span class="lineNum">    3962 </span><span class="lineCov">    1210295 :   if (dwarf_split_debug_info)</span>
<span class="lineNum">    3963 </span><span class="lineCov">          7 :     ref-&gt;dw_loc_oprnd1.val_entry</span>
<span class="lineNum">    3964 </span><span class="lineCov">         14 :       = add_addr_table_entry (addr,</span>
<span class="lineNum">    3965 </span>            :                               dtprel ? ate_kind_rtx_dtprel : ate_kind_rtx);
<span class="lineNum">    3966 </span>            :   else
<span class="lineNum">    3967 </span><span class="lineCov">    1210288 :     ref-&gt;dw_loc_oprnd1.val_entry = NULL;</span>
<span class="lineNum">    3968 </span>            : 
<span class="lineNum">    3969 </span><span class="lineCov">    1210295 :   return ref;</span>
<span class="lineNum">    3970 </span>            : }
<span class="lineNum">    3971 </span>            : 
<span class="lineNum">    3972 </span>            : /* Section names used to hold DWARF debugging information.  */
<span class="lineNum">    3973 </span>            : 
<span class="lineNum">    3974 </span>            : #ifndef DEBUG_INFO_SECTION
<span class="lineNum">    3975 </span>            : #define DEBUG_INFO_SECTION      &quot;.debug_info&quot;
<span class="lineNum">    3976 </span>            : #endif
<span class="lineNum">    3977 </span>            : #ifndef DEBUG_DWO_INFO_SECTION
<span class="lineNum">    3978 </span>            : #define DEBUG_DWO_INFO_SECTION &quot;.debug_info.dwo&quot;
<span class="lineNum">    3979 </span>            : #endif
<span class="lineNum">    3980 </span>            : #ifndef DEBUG_LTO_INFO_SECTION
<span class="lineNum">    3981 </span>            : #define DEBUG_LTO_INFO_SECTION  &quot;.gnu.debuglto_.debug_info&quot;
<span class="lineNum">    3982 </span>            : #endif
<span class="lineNum">    3983 </span>            : #ifndef DEBUG_LTO_DWO_INFO_SECTION
<span class="lineNum">    3984 </span>            : #define DEBUG_LTO_DWO_INFO_SECTION &quot;.gnu.debuglto_.debug_info.dwo&quot;
<span class="lineNum">    3985 </span>            : #endif
<span class="lineNum">    3986 </span>            : #ifndef DEBUG_ABBREV_SECTION
<span class="lineNum">    3987 </span>            : #define DEBUG_ABBREV_SECTION    &quot;.debug_abbrev&quot;
<span class="lineNum">    3988 </span>            : #endif
<span class="lineNum">    3989 </span>            : #ifndef DEBUG_LTO_ABBREV_SECTION
<span class="lineNum">    3990 </span>            : #define DEBUG_LTO_ABBREV_SECTION &quot;.gnu.debuglto_.debug_abbrev&quot;
<span class="lineNum">    3991 </span>            : #endif
<span class="lineNum">    3992 </span>            : #ifndef DEBUG_DWO_ABBREV_SECTION
<span class="lineNum">    3993 </span>            : #define DEBUG_DWO_ABBREV_SECTION &quot;.debug_abbrev.dwo&quot;
<span class="lineNum">    3994 </span>            : #endif
<span class="lineNum">    3995 </span>            : #ifndef DEBUG_LTO_DWO_ABBREV_SECTION
<span class="lineNum">    3996 </span>            : #define DEBUG_LTO_DWO_ABBREV_SECTION &quot;.gnu.debuglto_.debug_abbrev.dwo&quot;
<span class="lineNum">    3997 </span>            : #endif
<span class="lineNum">    3998 </span>            : #ifndef DEBUG_ARANGES_SECTION
<span class="lineNum">    3999 </span>            : #define DEBUG_ARANGES_SECTION   &quot;.debug_aranges&quot;
<span class="lineNum">    4000 </span>            : #endif
<span class="lineNum">    4001 </span>            : #ifndef DEBUG_ADDR_SECTION
<span class="lineNum">    4002 </span>            : #define DEBUG_ADDR_SECTION     &quot;.debug_addr&quot;
<span class="lineNum">    4003 </span>            : #endif
<span class="lineNum">    4004 </span>            : #ifndef DEBUG_MACINFO_SECTION
<span class="lineNum">    4005 </span>            : #define DEBUG_MACINFO_SECTION     &quot;.debug_macinfo&quot;
<span class="lineNum">    4006 </span>            : #endif
<span class="lineNum">    4007 </span>            : #ifndef DEBUG_LTO_MACINFO_SECTION
<span class="lineNum">    4008 </span>            : #define DEBUG_LTO_MACINFO_SECTION      &quot;.gnu.debuglto_.debug_macinfo&quot;
<span class="lineNum">    4009 </span>            : #endif
<span class="lineNum">    4010 </span>            : #ifndef DEBUG_DWO_MACINFO_SECTION
<span class="lineNum">    4011 </span>            : #define DEBUG_DWO_MACINFO_SECTION      &quot;.debug_macinfo.dwo&quot;
<span class="lineNum">    4012 </span>            : #endif
<span class="lineNum">    4013 </span>            : #ifndef DEBUG_LTO_DWO_MACINFO_SECTION
<span class="lineNum">    4014 </span>            : #define DEBUG_LTO_DWO_MACINFO_SECTION  &quot;.gnu.debuglto_.debug_macinfo.dwo&quot;
<span class="lineNum">    4015 </span>            : #endif
<span class="lineNum">    4016 </span>            : #ifndef DEBUG_MACRO_SECTION
<span class="lineNum">    4017 </span>            : #define DEBUG_MACRO_SECTION     &quot;.debug_macro&quot;
<span class="lineNum">    4018 </span>            : #endif
<span class="lineNum">    4019 </span>            : #ifndef DEBUG_LTO_MACRO_SECTION
<span class="lineNum">    4020 </span>            : #define DEBUG_LTO_MACRO_SECTION &quot;.gnu.debuglto_.debug_macro&quot;
<span class="lineNum">    4021 </span>            : #endif
<span class="lineNum">    4022 </span>            : #ifndef DEBUG_DWO_MACRO_SECTION
<span class="lineNum">    4023 </span>            : #define DEBUG_DWO_MACRO_SECTION        &quot;.debug_macro.dwo&quot;
<span class="lineNum">    4024 </span>            : #endif
<span class="lineNum">    4025 </span>            : #ifndef DEBUG_LTO_DWO_MACRO_SECTION
<span class="lineNum">    4026 </span>            : #define DEBUG_LTO_DWO_MACRO_SECTION    &quot;.gnu.debuglto_.debug_macro.dwo&quot;
<span class="lineNum">    4027 </span>            : #endif
<span class="lineNum">    4028 </span>            : #ifndef DEBUG_LINE_SECTION
<span class="lineNum">    4029 </span>            : #define DEBUG_LINE_SECTION      &quot;.debug_line&quot;
<span class="lineNum">    4030 </span>            : #endif
<span class="lineNum">    4031 </span>            : #ifndef DEBUG_LTO_LINE_SECTION
<span class="lineNum">    4032 </span>            : #define DEBUG_LTO_LINE_SECTION &quot;.gnu.debuglto_.debug_line&quot;
<span class="lineNum">    4033 </span>            : #endif
<span class="lineNum">    4034 </span>            : #ifndef DEBUG_DWO_LINE_SECTION
<span class="lineNum">    4035 </span>            : #define DEBUG_DWO_LINE_SECTION &quot;.debug_line.dwo&quot;
<span class="lineNum">    4036 </span>            : #endif
<span class="lineNum">    4037 </span>            : #ifndef DEBUG_LTO_DWO_LINE_SECTION
<span class="lineNum">    4038 </span>            : #define DEBUG_LTO_DWO_LINE_SECTION &quot;.gnu.debuglto_.debug_line.dwo&quot;
<span class="lineNum">    4039 </span>            : #endif
<span class="lineNum">    4040 </span>            : #ifndef DEBUG_LOC_SECTION
<span class="lineNum">    4041 </span>            : #define DEBUG_LOC_SECTION       &quot;.debug_loc&quot;
<span class="lineNum">    4042 </span>            : #endif
<span class="lineNum">    4043 </span>            : #ifndef DEBUG_DWO_LOC_SECTION
<span class="lineNum">    4044 </span>            : #define DEBUG_DWO_LOC_SECTION  &quot;.debug_loc.dwo&quot;
<span class="lineNum">    4045 </span>            : #endif
<span class="lineNum">    4046 </span>            : #ifndef DEBUG_LOCLISTS_SECTION
<span class="lineNum">    4047 </span>            : #define DEBUG_LOCLISTS_SECTION  &quot;.debug_loclists&quot;
<span class="lineNum">    4048 </span>            : #endif
<span class="lineNum">    4049 </span>            : #ifndef DEBUG_DWO_LOCLISTS_SECTION
<span class="lineNum">    4050 </span>            : #define DEBUG_DWO_LOCLISTS_SECTION  &quot;.debug_loclists.dwo&quot;
<span class="lineNum">    4051 </span>            : #endif
<span class="lineNum">    4052 </span>            : #ifndef DEBUG_PUBNAMES_SECTION
<span class="lineNum">    4053 </span>            : #define DEBUG_PUBNAMES_SECTION  \
<span class="lineNum">    4054 </span>            :   ((debug_generate_pub_sections == 2) \
<span class="lineNum">    4055 </span>            :    ? &quot;.debug_gnu_pubnames&quot; : &quot;.debug_pubnames&quot;)
<span class="lineNum">    4056 </span>            : #endif
<span class="lineNum">    4057 </span>            : #ifndef DEBUG_PUBTYPES_SECTION
<span class="lineNum">    4058 </span>            : #define DEBUG_PUBTYPES_SECTION  \
<span class="lineNum">    4059 </span>            :   ((debug_generate_pub_sections == 2) \
<span class="lineNum">    4060 </span>            :    ? &quot;.debug_gnu_pubtypes&quot; : &quot;.debug_pubtypes&quot;)
<span class="lineNum">    4061 </span>            : #endif
<span class="lineNum">    4062 </span>            : #ifndef DEBUG_STR_OFFSETS_SECTION
<span class="lineNum">    4063 </span>            : #define DEBUG_STR_OFFSETS_SECTION &quot;.debug_str_offsets&quot;
<span class="lineNum">    4064 </span>            : #endif
<span class="lineNum">    4065 </span>            : #ifndef DEBUG_DWO_STR_OFFSETS_SECTION
<span class="lineNum">    4066 </span>            : #define DEBUG_DWO_STR_OFFSETS_SECTION &quot;.debug_str_offsets.dwo&quot;
<span class="lineNum">    4067 </span>            : #endif
<span class="lineNum">    4068 </span>            : #ifndef DEBUG_LTO_DWO_STR_OFFSETS_SECTION
<span class="lineNum">    4069 </span>            : #define DEBUG_LTO_DWO_STR_OFFSETS_SECTION &quot;.gnu.debuglto_.debug_str_offsets.dwo&quot;
<span class="lineNum">    4070 </span>            : #endif
<span class="lineNum">    4071 </span>            : #ifndef DEBUG_STR_SECTION
<span class="lineNum">    4072 </span>            : #define DEBUG_STR_SECTION  &quot;.debug_str&quot;
<span class="lineNum">    4073 </span>            : #endif
<span class="lineNum">    4074 </span>            : #ifndef DEBUG_LTO_STR_SECTION
<span class="lineNum">    4075 </span>            : #define DEBUG_LTO_STR_SECTION &quot;.gnu.debuglto_.debug_str&quot;
<span class="lineNum">    4076 </span>            : #endif
<span class="lineNum">    4077 </span>            : #ifndef DEBUG_STR_DWO_SECTION
<span class="lineNum">    4078 </span>            : #define DEBUG_STR_DWO_SECTION   &quot;.debug_str.dwo&quot;
<span class="lineNum">    4079 </span>            : #endif
<span class="lineNum">    4080 </span>            : #ifndef DEBUG_LTO_STR_DWO_SECTION
<span class="lineNum">    4081 </span>            : #define DEBUG_LTO_STR_DWO_SECTION &quot;.gnu.debuglto_.debug_str.dwo&quot;
<span class="lineNum">    4082 </span>            : #endif
<span class="lineNum">    4083 </span>            : #ifndef DEBUG_RANGES_SECTION
<span class="lineNum">    4084 </span>            : #define DEBUG_RANGES_SECTION    &quot;.debug_ranges&quot;
<span class="lineNum">    4085 </span>            : #endif
<span class="lineNum">    4086 </span>            : #ifndef DEBUG_RNGLISTS_SECTION
<span class="lineNum">    4087 </span>            : #define DEBUG_RNGLISTS_SECTION  &quot;.debug_rnglists&quot;
<span class="lineNum">    4088 </span>            : #endif
<span class="lineNum">    4089 </span>            : #ifndef DEBUG_LINE_STR_SECTION
<span class="lineNum">    4090 </span>            : #define DEBUG_LINE_STR_SECTION  &quot;.debug_line_str&quot;
<span class="lineNum">    4091 </span>            : #endif
<span class="lineNum">    4092 </span>            : #ifndef DEBUG_LTO_LINE_STR_SECTION
<span class="lineNum">    4093 </span>            : #define DEBUG_LTO_LINE_STR_SECTION  &quot;.gnu.debuglto_.debug_line_str&quot;
<span class="lineNum">    4094 </span>            : #endif
<span class="lineNum">    4095 </span>            : 
<span class="lineNum">    4096 </span>            : /* Standard ELF section names for compiled code and data.  */
<span class="lineNum">    4097 </span>            : #ifndef TEXT_SECTION_NAME
<span class="lineNum">    4098 </span>            : #define TEXT_SECTION_NAME       &quot;.text&quot;
<span class="lineNum">    4099 </span>            : #endif
<span class="lineNum">    4100 </span>            : 
<span class="lineNum">    4101 </span>            : /* Section flags for .debug_str section.  */
<span class="lineNum">    4102 </span>            : #define DEBUG_STR_SECTION_FLAGS                                 \
<span class="lineNum">    4103 </span>            :   (HAVE_GAS_SHF_MERGE &amp;&amp; flag_merge_debug_strings               \
<span class="lineNum">    4104 </span>            :    ? SECTION_DEBUG | SECTION_MERGE | SECTION_STRINGS | 1        \
<span class="lineNum">    4105 </span>            :    : SECTION_DEBUG)
<span class="lineNum">    4106 </span>            : 
<span class="lineNum">    4107 </span>            : /* Section flags for .debug_str.dwo section.  */
<span class="lineNum">    4108 </span>            : #define DEBUG_STR_DWO_SECTION_FLAGS (SECTION_DEBUG | SECTION_EXCLUDE)
<span class="lineNum">    4109 </span>            : 
<span class="lineNum">    4110 </span>            : /* Attribute used to refer to the macro section.  */
<span class="lineNum">    4111 </span>            : #define DEBUG_MACRO_ATTRIBUTE (dwarf_version &gt;= 5 ? DW_AT_macros \
<span class="lineNum">    4112 </span>            :                    : dwarf_strict ? DW_AT_macro_info : DW_AT_GNU_macros)
<span class="lineNum">    4113 </span>            : 
<span class="lineNum">    4114 </span>            : /* Labels we insert at beginning sections we can reference instead of
<span class="lineNum">    4115 </span>            :    the section names themselves.  */
<span class="lineNum">    4116 </span>            : 
<span class="lineNum">    4117 </span>            : #ifndef TEXT_SECTION_LABEL
<span class="lineNum">    4118 </span>            : #define TEXT_SECTION_LABEL                 &quot;Ltext&quot;
<span class="lineNum">    4119 </span>            : #endif
<span class="lineNum">    4120 </span>            : #ifndef COLD_TEXT_SECTION_LABEL
<span class="lineNum">    4121 </span>            : #define COLD_TEXT_SECTION_LABEL             &quot;Ltext_cold&quot;
<span class="lineNum">    4122 </span>            : #endif
<span class="lineNum">    4123 </span>            : #ifndef DEBUG_LINE_SECTION_LABEL
<span class="lineNum">    4124 </span>            : #define DEBUG_LINE_SECTION_LABEL           &quot;Ldebug_line&quot;
<span class="lineNum">    4125 </span>            : #endif
<span class="lineNum">    4126 </span>            : #ifndef DEBUG_SKELETON_LINE_SECTION_LABEL
<span class="lineNum">    4127 </span>            : #define DEBUG_SKELETON_LINE_SECTION_LABEL   &quot;Lskeleton_debug_line&quot;
<span class="lineNum">    4128 </span>            : #endif
<span class="lineNum">    4129 </span>            : #ifndef DEBUG_INFO_SECTION_LABEL
<span class="lineNum">    4130 </span>            : #define DEBUG_INFO_SECTION_LABEL           &quot;Ldebug_info&quot;
<span class="lineNum">    4131 </span>            : #endif
<span class="lineNum">    4132 </span>            : #ifndef DEBUG_SKELETON_INFO_SECTION_LABEL
<span class="lineNum">    4133 </span>            : #define DEBUG_SKELETON_INFO_SECTION_LABEL   &quot;Lskeleton_debug_info&quot;
<span class="lineNum">    4134 </span>            : #endif
<span class="lineNum">    4135 </span>            : #ifndef DEBUG_ABBREV_SECTION_LABEL
<span class="lineNum">    4136 </span>            : #define DEBUG_ABBREV_SECTION_LABEL         &quot;Ldebug_abbrev&quot;
<span class="lineNum">    4137 </span>            : #endif
<span class="lineNum">    4138 </span>            : #ifndef DEBUG_SKELETON_ABBREV_SECTION_LABEL
<span class="lineNum">    4139 </span>            : #define DEBUG_SKELETON_ABBREV_SECTION_LABEL &quot;Lskeleton_debug_abbrev&quot;
<span class="lineNum">    4140 </span>            : #endif
<span class="lineNum">    4141 </span>            : #ifndef DEBUG_ADDR_SECTION_LABEL
<span class="lineNum">    4142 </span>            : #define DEBUG_ADDR_SECTION_LABEL           &quot;Ldebug_addr&quot;
<span class="lineNum">    4143 </span>            : #endif
<span class="lineNum">    4144 </span>            : #ifndef DEBUG_LOC_SECTION_LABEL
<span class="lineNum">    4145 </span>            : #define DEBUG_LOC_SECTION_LABEL                    &quot;Ldebug_loc&quot;
<span class="lineNum">    4146 </span>            : #endif
<span class="lineNum">    4147 </span>            : #ifndef DEBUG_RANGES_SECTION_LABEL
<span class="lineNum">    4148 </span>            : #define DEBUG_RANGES_SECTION_LABEL         &quot;Ldebug_ranges&quot;
<span class="lineNum">    4149 </span>            : #endif
<span class="lineNum">    4150 </span>            : #ifndef DEBUG_MACINFO_SECTION_LABEL
<span class="lineNum">    4151 </span>            : #define DEBUG_MACINFO_SECTION_LABEL         &quot;Ldebug_macinfo&quot;
<span class="lineNum">    4152 </span>            : #endif
<span class="lineNum">    4153 </span>            : #ifndef DEBUG_MACRO_SECTION_LABEL
<span class="lineNum">    4154 </span>            : #define DEBUG_MACRO_SECTION_LABEL          &quot;Ldebug_macro&quot;
<span class="lineNum">    4155 </span>            : #endif
<span class="lineNum">    4156 </span>            : #define SKELETON_COMP_DIE_ABBREV 1
<span class="lineNum">    4157 </span>            : #define SKELETON_TYPE_DIE_ABBREV 2
<span class="lineNum">    4158 </span>            : 
<span class="lineNum">    4159 </span>            : /* Definitions of defaults for formats and names of various special
<span class="lineNum">    4160 </span>            :    (artificial) labels which may be generated within this file (when the -g
<span class="lineNum">    4161 </span>            :    options is used and DWARF2_DEBUGGING_INFO is in effect.
<span class="lineNum">    4162 </span>            :    If necessary, these may be overridden from within the tm.h file, but
<span class="lineNum">    4163 </span>            :    typically, overriding these defaults is unnecessary.  */
<span class="lineNum">    4164 </span>            : 
<span class="lineNum">    4165 </span>            : static char text_end_label[MAX_ARTIFICIAL_LABEL_BYTES];
<span class="lineNum">    4166 </span>            : static char text_section_label[MAX_ARTIFICIAL_LABEL_BYTES];
<span class="lineNum">    4167 </span>            : static char cold_text_section_label[MAX_ARTIFICIAL_LABEL_BYTES];
<span class="lineNum">    4168 </span>            : static char cold_end_label[MAX_ARTIFICIAL_LABEL_BYTES];
<span class="lineNum">    4169 </span>            : static char abbrev_section_label[MAX_ARTIFICIAL_LABEL_BYTES];
<span class="lineNum">    4170 </span>            : static char debug_info_section_label[MAX_ARTIFICIAL_LABEL_BYTES];
<span class="lineNum">    4171 </span>            : static char debug_skeleton_info_section_label[MAX_ARTIFICIAL_LABEL_BYTES];
<span class="lineNum">    4172 </span>            : static char debug_skeleton_abbrev_section_label[MAX_ARTIFICIAL_LABEL_BYTES];
<span class="lineNum">    4173 </span>            : static char debug_line_section_label[MAX_ARTIFICIAL_LABEL_BYTES];
<span class="lineNum">    4174 </span>            : static char debug_addr_section_label[MAX_ARTIFICIAL_LABEL_BYTES];
<span class="lineNum">    4175 </span>            : static char debug_skeleton_line_section_label[MAX_ARTIFICIAL_LABEL_BYTES];
<span class="lineNum">    4176 </span>            : static char macinfo_section_label[MAX_ARTIFICIAL_LABEL_BYTES];
<span class="lineNum">    4177 </span>            : static char loc_section_label[MAX_ARTIFICIAL_LABEL_BYTES];
<span class="lineNum">    4178 </span>            : static char ranges_section_label[2 * MAX_ARTIFICIAL_LABEL_BYTES];
<span class="lineNum">    4179 </span>            : static char ranges_base_label[2 * MAX_ARTIFICIAL_LABEL_BYTES];
<span class="lineNum">    4180 </span>            : 
<span class="lineNum">    4181 </span>            : #ifndef TEXT_END_LABEL
<span class="lineNum">    4182 </span>            : #define TEXT_END_LABEL          &quot;Letext&quot;
<span class="lineNum">    4183 </span>            : #endif
<span class="lineNum">    4184 </span>            : #ifndef COLD_END_LABEL
<span class="lineNum">    4185 </span>            : #define COLD_END_LABEL          &quot;Letext_cold&quot;
<span class="lineNum">    4186 </span>            : #endif
<span class="lineNum">    4187 </span>            : #ifndef BLOCK_BEGIN_LABEL
<span class="lineNum">    4188 </span>            : #define BLOCK_BEGIN_LABEL       &quot;LBB&quot;
<span class="lineNum">    4189 </span>            : #endif
<span class="lineNum">    4190 </span>            : #ifndef BLOCK_INLINE_ENTRY_LABEL
<span class="lineNum">    4191 </span>            : #define BLOCK_INLINE_ENTRY_LABEL &quot;LBI&quot;
<span class="lineNum">    4192 </span>            : #endif
<span class="lineNum">    4193 </span>            : #ifndef BLOCK_END_LABEL
<span class="lineNum">    4194 </span>            : #define BLOCK_END_LABEL         &quot;LBE&quot;
<span class="lineNum">    4195 </span>            : #endif
<span class="lineNum">    4196 </span>            : #ifndef LINE_CODE_LABEL
<span class="lineNum">    4197 </span>            : #define LINE_CODE_LABEL         &quot;LM&quot;
<span class="lineNum">    4198 </span>            : #endif
<span class="lineNum">    4199 </span>            : 
<span class="lineNum">    4200 </span>            : 
<a name="4201"><span class="lineNum">    4201 </span>            : /* Return the root of the DIE's built for the current compilation unit.  */</a>
<span class="lineNum">    4202 </span>            : static dw_die_ref
<span class="lineNum">    4203 </span><span class="lineNoCov">          0 : comp_unit_die (void)</span>
<span class="lineNum">    4204 </span>            : {
<span class="lineNum">    4205 </span><span class="lineNoCov">          0 :   if (!single_comp_unit_die)</span>
<span class="lineNum">    4206 </span><span class="lineCov">      37179 :     single_comp_unit_die = gen_compile_unit_die (NULL);</span>
<span class="lineNum">    4207 </span><span class="lineCov">   78522378 :   return single_comp_unit_die;</span>
<span class="lineNum">    4208 </span>            : }
<span class="lineNum">    4209 </span>            : 
<span class="lineNum">    4210 </span>            : /* We allow a language front-end to designate a function that is to be
<span class="lineNum">    4211 </span>            :    called to &quot;demangle&quot; any name before it is put into a DIE.  */
<span class="lineNum">    4212 </span>            : 
<span class="lineNum">    4213 </span>            : static const char *(*demangle_name_func) (const char *);
<a name="4214"><span class="lineNum">    4214 </span>            : </a>
<span class="lineNum">    4215 </span>            : void
<span class="lineNum">    4216 </span><span class="lineNoCov">          0 : dwarf2out_set_demangle_name_func (const char *(*func) (const char *))</span>
<span class="lineNum">    4217 </span>            : {
<span class="lineNum">    4218 </span><span class="lineNoCov">          0 :   demangle_name_func = func;</span>
<span class="lineNum">    4219 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4220 </span>            : 
<span class="lineNum">    4221 </span>            : /* Test if rtl node points to a pseudo register.  */
<span class="lineNum">    4222 </span>            : 
<span class="lineNum">    4223 </span>            : static inline int
<span class="lineNum">    4224 </span>            : is_pseudo_reg (const_rtx rtl)
<span class="lineNum">    4225 </span>            : {
<span class="lineNum">    4226 </span><span class="lineCov">    1231146 :   return ((REG_P (rtl) &amp;&amp; REGNO (rtl) &gt;= FIRST_PSEUDO_REGISTER)</span>
<span class="lineNum">    4227 </span><span class="lineCov">     642606 :           || (GET_CODE (rtl) == SUBREG</span>
<span class="lineNum">    4228 </span><span class="lineCov">        148 :               &amp;&amp; REGNO (SUBREG_REG (rtl)) &gt;= FIRST_PSEUDO_REGISTER));</span>
<span class="lineNum">    4229 </span>            : }
<span class="lineNum">    4230 </span>            : 
<span class="lineNum">    4231 </span>            : /* Return a reference to a type, with its const and volatile qualifiers
<span class="lineNum">    4232 </span>            :    removed.  */
<a name="4233"><span class="lineNum">    4233 </span>            : </a>
<span class="lineNum">    4234 </span>            : static inline tree
<span class="lineNum">    4235 </span><span class="lineCov">   99953278 : type_main_variant (tree type)</span>
<span class="lineNum">    4236 </span>            : {
<span class="lineNum">    4237 </span><span class="lineCov">   99953278 :   type = TYPE_MAIN_VARIANT (type);</span>
<span class="lineNum">    4238 </span>            : 
<span class="lineNum">    4239 </span>            :   /* ??? There really should be only one main variant among any group of
<span class="lineNum">    4240 </span>            :      variants of a given type (and all of the MAIN_VARIANT values for all
<span class="lineNum">    4241 </span>            :      members of the group should point to that one type) but sometimes the C
<span class="lineNum">    4242 </span>            :      front-end messes this up for array types, so we work around that bug
<span class="lineNum">    4243 </span>            :      here.  */
<span class="lineNum">    4244 </span><span class="lineCov">   99953278 :   if (TREE_CODE (type) == ARRAY_TYPE)</span>
<span class="lineNum">    4245 </span><span class="lineNoCov">          0 :     while (type != TYPE_MAIN_VARIANT (type))</span>
<span class="lineNum">    4246 </span>            :       type = TYPE_MAIN_VARIANT (type);
<span class="lineNum">    4247 </span>            : 
<span class="lineNum">    4248 </span><span class="lineCov">   99953278 :   return type;</span>
<span class="lineNum">    4249 </span>            : }
<span class="lineNum">    4250 </span>            : 
<span class="lineNum">    4251 </span>            : /* Return nonzero if the given type node represents a tagged type.  */
<span class="lineNum">    4252 </span>            : 
<span class="lineNum">    4253 </span>            : static inline int
<span class="lineNum">    4254 </span>            : is_tagged_type (const_tree type)
<span class="lineNum">    4255 </span>            : {
<span class="lineNum">    4256 </span><span class="lineCov">  129747521 :   enum tree_code code = TREE_CODE (type);</span>
<span class="lineNum">    4257 </span>            : 
<span class="lineNum">    4258 </span><span class="lineCov">  129747521 :   return (code == RECORD_TYPE || code == UNION_TYPE</span>
<span class="lineNum">    4259 </span><span class="lineCov">  129747521 :           || code == QUAL_UNION_TYPE || code == ENUMERAL_TYPE);</span>
<span class="lineNum">    4260 </span>            : }
<span class="lineNum">    4261 </span>            : 
<span class="lineNum">    4262 </span>            : /* Set label to debug_info_section_label + die_offset of a DIE reference.  */
<a name="4263"><span class="lineNum">    4263 </span>            : </a>
<span class="lineNum">    4264 </span>            : static void
<span class="lineNum">    4265 </span><span class="lineNoCov">          0 : get_ref_die_offset_label (char *label, dw_die_ref ref)</span>
<span class="lineNum">    4266 </span>            : {
<span class="lineNum">    4267 </span><span class="lineCov">     528201 :   sprintf (label, &quot;%s+%ld&quot;, debug_info_section_label, ref-&gt;die_offset);</span>
<span class="lineNum">    4268 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4269 </span>            : 
<span class="lineNum">    4270 </span>            : /* Return die_offset of a DIE reference to a base type.  */
<a name="4271"><span class="lineNum">    4271 </span>            : </a>
<span class="lineNum">    4272 </span>            : static unsigned long int
<span class="lineNum">    4273 </span><span class="lineCov">     864526 : get_base_type_offset (dw_die_ref ref)</span>
<span class="lineNum">    4274 </span>            : {
<span class="lineNum">    4275 </span><span class="lineCov">     864526 :   if (ref-&gt;die_offset)</span>
<span class="lineNum">    4276 </span><span class="lineCov">     659013 :     return ref-&gt;die_offset;</span>
<span class="lineNum">    4277 </span><span class="lineCov">     205513 :   if (comp_unit_die ()-&gt;die_abbrev)</span>
<span class="lineNum">    4278 </span>            :     {
<span class="lineNum">    4279 </span><span class="lineNoCov">          0 :       calc_base_type_die_sizes ();</span>
<span class="lineNum">    4280 </span><span class="lineNoCov">          0 :       gcc_assert (ref-&gt;die_offset);</span>
<span class="lineNum">    4281 </span>            :     }
<span class="lineNum">    4282 </span><span class="lineCov">     205513 :   return ref-&gt;die_offset;</span>
<span class="lineNum">    4283 </span>            : }
<span class="lineNum">    4284 </span>            : 
<span class="lineNum">    4285 </span>            : /* Return die_offset of a DIE reference other than base type.  */
<a name="4286"><span class="lineNum">    4286 </span>            : </a>
<span class="lineNum">    4287 </span>            : static unsigned long int
<span class="lineNum">    4288 </span><span class="lineNoCov">          0 : get_ref_die_offset (dw_die_ref ref)</span>
<span class="lineNum">    4289 </span>            : {
<span class="lineNum">    4290 </span><span class="lineCov">       4994 :   gcc_assert (ref-&gt;die_offset);</span>
<span class="lineNum">    4291 </span><span class="lineCov">       4994 :   return ref-&gt;die_offset;</span>
<span class="lineNum">    4292 </span>            : }
<span class="lineNum">    4293 </span>            : 
<span class="lineNum">    4294 </span>            : /* Convert a DIE tag into its string name.  */
<a name="4295"><span class="lineNum">    4295 </span>            : </a>
<span class="lineNum">    4296 </span>            : static const char *
<span class="lineNum">    4297 </span><span class="lineNoCov">          0 : dwarf_tag_name (unsigned int tag)</span>
<span class="lineNum">    4298 </span>            : {
<span class="lineNum">    4299 </span><span class="lineNoCov">          0 :   const char *name = get_DW_TAG_name (tag);</span>
<span class="lineNum">    4300 </span>            : 
<span class="lineNum">    4301 </span><span class="lineCov">   48441747 :   if (name != NULL)</span>
<span class="lineNum">    4302 </span><span class="lineCov">   48441747 :     return name;</span>
<span class="lineNum">    4303 </span>            : 
<span class="lineNum">    4304 </span>            :   return &quot;DW_TAG_&lt;unknown&gt;&quot;;
<span class="lineNum">    4305 </span>            : }
<span class="lineNum">    4306 </span>            : 
<span class="lineNum">    4307 </span>            : /* Convert a DWARF attribute code into its string name.  */
<a name="4308"><span class="lineNum">    4308 </span>            : </a>
<span class="lineNum">    4309 </span>            : static const char *
<span class="lineNum">    4310 </span><span class="lineCov">  219208574 : dwarf_attr_name (unsigned int attr)</span>
<span class="lineNum">    4311 </span>            : {
<span class="lineNum">    4312 </span><span class="lineCov">  219208574 :   const char *name;</span>
<span class="lineNum">    4313 </span>            : 
<span class="lineNum">    4314 </span><span class="lineCov">  219208574 :   switch (attr)</span>
<span class="lineNum">    4315 </span>            :     {
<span class="lineNum">    4316 </span>            : #if VMS_DEBUGGING_INFO
<span class="lineNum">    4317 </span>            :     case DW_AT_HP_prologue:
<span class="lineNum">    4318 </span>            :       return &quot;DW_AT_HP_prologue&quot;;
<span class="lineNum">    4319 </span>            : #else
<span class="lineNum">    4320 </span>            :     case DW_AT_MIPS_loop_unroll_factor:
<span class="lineNum">    4321 </span>            :       return &quot;DW_AT_MIPS_loop_unroll_factor&quot;;
<span class="lineNum">    4322 </span>            : #endif
<span class="lineNum">    4323 </span>            : 
<span class="lineNum">    4324 </span>            : #if VMS_DEBUGGING_INFO
<span class="lineNum">    4325 </span>            :     case DW_AT_HP_epilogue:
<span class="lineNum">    4326 </span>            :       return &quot;DW_AT_HP_epilogue&quot;;
<span class="lineNum">    4327 </span>            : #else
<span class="lineNum">    4328 </span><span class="lineNoCov">          0 :     case DW_AT_MIPS_stride:</span>
<span class="lineNum">    4329 </span><span class="lineNoCov">          0 :       return &quot;DW_AT_MIPS_stride&quot;;</span>
<span class="lineNum">    4330 </span>            : #endif
<span class="lineNum">    4331 </span>            :     }
<span class="lineNum">    4332 </span>            : 
<span class="lineNum">    4333 </span><span class="lineCov">  219208574 :   name = get_DW_AT_name (attr);</span>
<span class="lineNum">    4334 </span>            : 
<span class="lineNum">    4335 </span><span class="lineCov">  219208574 :   if (name != NULL)</span>
<span class="lineNum">    4336 </span><span class="lineCov">  219208574 :     return name;</span>
<span class="lineNum">    4337 </span>            : 
<span class="lineNum">    4338 </span>            :   return &quot;DW_AT_&lt;unknown&gt;&quot;;
<span class="lineNum">    4339 </span>            : }
<span class="lineNum">    4340 </span>            : 
<span class="lineNum">    4341 </span>            : /* Convert a DWARF value form code into its string name.  */
<a name="4342"><span class="lineNum">    4342 </span>            : </a>
<span class="lineNum">    4343 </span>            : static const char *
<span class="lineNum">    4344 </span><span class="lineNoCov">          0 : dwarf_form_name (unsigned int form)</span>
<span class="lineNum">    4345 </span>            : {
<span class="lineNum">    4346 </span><span class="lineNoCov">          0 :   const char *name = get_DW_FORM_name (form);</span>
<span class="lineNum">    4347 </span>            : 
<span class="lineNum">    4348 </span><span class="lineCov">   11444014 :   if (name != NULL)</span>
<span class="lineNum">    4349 </span><span class="lineCov">   11444014 :     return name;</span>
<span class="lineNum">    4350 </span>            : 
<span class="lineNum">    4351 </span>            :   return &quot;DW_FORM_&lt;unknown&gt;&quot;;
<span class="lineNum">    4352 </span>            : }
<span class="lineNum">    4353 </span>            : 
<span class="lineNum">    4354 </span>            : /* Determine the &quot;ultimate origin&quot; of a decl.  The decl may be an inlined
<span class="lineNum">    4355 </span>            :    instance of an inlined instance of a decl which is local to an inline
<span class="lineNum">    4356 </span>            :    function, so we have to trace all of the way back through the origin chain
<span class="lineNum">    4357 </span>            :    to find out what sort of node actually served as the original seed for the
<span class="lineNum">    4358 </span>            :    given block.  */
<a name="4359"><span class="lineNum">    4359 </span>            : </a>
<span class="lineNum">    4360 </span>            : static tree
<span class="lineNum">    4361 </span><span class="lineCov">   58206590 : decl_ultimate_origin (const_tree decl)</span>
<span class="lineNum">    4362 </span>            : {
<span class="lineNum">    4363 </span><span class="lineCov">   58206590 :   if (!CODE_CONTAINS_STRUCT (TREE_CODE (decl), TS_DECL_COMMON))</span>
<span class="lineNum">    4364 </span>            :     return NULL_TREE;
<span class="lineNum">    4365 </span>            : 
<span class="lineNum">    4366 </span>            :   /* DECL_ABSTRACT_ORIGIN can point to itself; ignore that if
<span class="lineNum">    4367 </span>            :      we're trying to output the abstract instance of this function.  */
<span class="lineNum">    4368 </span><span class="lineCov">  116413180 :   if (DECL_ABSTRACT_P (decl) &amp;&amp; DECL_ABSTRACT_ORIGIN (decl) == decl)</span>
<span class="lineNum">    4369 </span>            :     return NULL_TREE;
<span class="lineNum">    4370 </span>            : 
<span class="lineNum">    4371 </span>            :   /* Since the DECL_ABSTRACT_ORIGIN for a DECL is supposed to be the
<span class="lineNum">    4372 </span>            :      most distant ancestor, this should never happen.  */
<span class="lineNum">    4373 </span><span class="lineCov">  116413180 :   gcc_assert (!DECL_FROM_INLINE (DECL_ORIGIN (decl)));</span>
<span class="lineNum">    4374 </span>            : 
<span class="lineNum">    4375 </span>            :   return DECL_ABSTRACT_ORIGIN (decl);
<span class="lineNum">    4376 </span>            : }
<span class="lineNum">    4377 </span>            : 
<span class="lineNum">    4378 </span>            : /* Get the class to which DECL belongs, if any.  In g++, the DECL_CONTEXT
<span class="lineNum">    4379 </span>            :    of a virtual function may refer to a base class, so we check the 'this'
<span class="lineNum">    4380 </span>            :    parameter.  */
<a name="4381"><span class="lineNum">    4381 </span>            : </a>
<span class="lineNum">    4382 </span>            : static tree
<span class="lineNum">    4383 </span><span class="lineCov">   10207367 : decl_class_context (tree decl)</span>
<span class="lineNum">    4384 </span>            : {
<span class="lineNum">    4385 </span><span class="lineCov">   10207367 :   tree context = NULL_TREE;</span>
<span class="lineNum">    4386 </span>            : 
<span class="lineNum">    4387 </span><span class="lineCov">   10207367 :   if (TREE_CODE (decl) != FUNCTION_DECL || ! DECL_VINDEX (decl))</span>
<span class="lineNum">    4388 </span><span class="lineCov">    9859150 :     context = DECL_CONTEXT (decl);</span>
<span class="lineNum">    4389 </span>            :   else
<span class="lineNum">    4390 </span><span class="lineCov">     696434 :     context = TYPE_MAIN_VARIANT</span>
<span class="lineNum">    4391 </span>            :       (TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (decl)))));
<span class="lineNum">    4392 </span>            : 
<span class="lineNum">    4393 </span><span class="lineCov">   10207367 :   if (context &amp;&amp; !TYPE_P (context))</span>
<span class="lineNum">    4394 </span><span class="lineCov">    2078180 :     context = NULL_TREE;</span>
<span class="lineNum">    4395 </span>            : 
<span class="lineNum">    4396 </span><span class="lineCov">   10207367 :   return context;</span>
<span class="lineNum">    4397 </span>            : }
<span class="lineNum">    4398 </span>            : 
<span class="lineNum">    4399 </span>            : /* Add an attribute/value pair to a DIE.  */
<a name="4400"><span class="lineNum">    4400 </span>            : </a>
<span class="lineNum">    4401 </span>            : static inline void
<span class="lineNum">    4402 </span><span class="lineCov">  366297375 : add_dwarf_attr (dw_die_ref die, dw_attr_node *attr)</span>
<span class="lineNum">    4403 </span>            : {
<span class="lineNum">    4404 </span>            :   /* Maybe this should be an assert?  */
<span class="lineNum">    4405 </span><span class="lineCov">  366297375 :   if (die == NULL)</span>
<span class="lineNum">    4406 </span>            :     return;
<span class="lineNum">    4407 </span>            : 
<span class="lineNum">    4408 </span><span class="lineCov">  366223027 :   if (flag_checking)</span>
<span class="lineNum">    4409 </span>            :     {
<span class="lineNum">    4410 </span>            :       /* Check we do not add duplicate attrs.  Can't use get_AT here
<span class="lineNum">    4411 </span>            :          because that recurses to the specification/abstract origin DIE.  */
<span class="lineNum">    4412 </span>            :       dw_attr_node *a;
<span class="lineNum">    4413 </span>            :       unsigned ix;
<span class="lineNum">    4414 </span><span class="lineCov"> 1331474811 :       FOR_EACH_VEC_SAFE_ELT (die-&gt;die_attr, ix, a)</span>
<span class="lineNum">    4415 </span><span class="lineCov">  965251845 :         gcc_assert (a-&gt;dw_attr != attr-&gt;dw_attr);</span>
<span class="lineNum">    4416 </span>            :     }
<span class="lineNum">    4417 </span>            : 
<span class="lineNum">    4418 </span><span class="lineCov">  366223027 :   vec_safe_reserve (die-&gt;die_attr, 1);</span>
<span class="lineNum">    4419 </span><span class="lineCov">  366223027 :   vec_safe_push (die-&gt;die_attr, *attr);</span>
<span class="lineNum">    4420 </span>            : }
<a name="4421"><span class="lineNum">    4421 </span>            : </a>
<span class="lineNum">    4422 </span>            : static inline enum dw_val_class
<span class="lineNum">    4423 </span><span class="lineNoCov">          0 : AT_class (dw_attr_node *a)</span>
<span class="lineNum">    4424 </span>            : {
<span class="lineNum">    4425 </span><span class="lineCov"> 3416327808 :   return a-&gt;dw_attr_val.val_class;</span>
<span class="lineNum">    4426 </span>            : }
<span class="lineNum">    4427 </span>            : 
<span class="lineNum">    4428 </span>            : /* Return the index for any attribute that will be referenced with a
<span class="lineNum">    4429 </span>            :    DW_FORM_addrx/GNU_addr_index or DW_FORM_strx/GNU_str_index.  String
<span class="lineNum">    4430 </span>            :    indices are stored in dw_attr_val.v.val_str for reference counting
<span class="lineNum">    4431 </span>            :    pruning.  */
<span class="lineNum">    4432 </span>            : 
<span class="lineNum">    4433 </span>            : static inline unsigned int
<span class="lineNum">    4434 </span>            : AT_index (dw_attr_node *a)
<span class="lineNum">    4435 </span>            : {
<span class="lineNum">    4436 </span><span class="lineCov">   49005359 :   if (AT_class (a) == dw_val_class_str)</span>
<span class="lineNum">    4437 </span><span class="lineCov">         21 :     return a-&gt;dw_attr_val.v.val_str-&gt;index;</span>
<span class="lineNum">    4438 </span><span class="lineCov">   24502648 :   else if (a-&gt;dw_attr_val.val_entry != NULL)</span>
<span class="lineNum">    4439 </span><span class="lineCov">         84 :     return a-&gt;dw_attr_val.val_entry-&gt;index;</span>
<span class="lineNum">    4440 </span>            :   return NOT_INDEXED;
<span class="lineNum">    4441 </span>            : }
<span class="lineNum">    4442 </span>            : 
<span class="lineNum">    4443 </span>            : /* Add a flag value attribute to a DIE.  */
<span class="lineNum">    4444 </span>            : 
<span class="lineNum">    4445 </span>            : static inline void
<span class="lineNum">    4446 </span>            : add_AT_flag (dw_die_ref die, enum dwarf_attribute attr_kind, unsigned int flag)
<span class="lineNum">    4447 </span>            : {
<span class="lineNum">    4448 </span><span class="lineCov">   32281024 :   dw_attr_node attr;</span>
<span class="lineNum">    4449 </span>            : 
<span class="lineNum">    4450 </span><span class="lineCov">   32281024 :   attr.dw_attr = attr_kind;</span>
<span class="lineNum">    4451 </span><span class="lineCov">   32281024 :   attr.dw_attr_val.val_class = dw_val_class_flag;</span>
<span class="lineNum">    4452 </span><span class="lineCov">   32281024 :   attr.dw_attr_val.val_entry = NULL;</span>
<span class="lineNum">    4453 </span><span class="lineCov">   32281024 :   attr.dw_attr_val.v.val_flag = flag;</span>
<span class="lineNum">    4454 </span><span class="lineCov">   32281024 :   add_dwarf_attr (die, &amp;attr);</span>
<span class="lineNum">    4455 </span>            : }
<span class="lineNum">    4456 </span>            : 
<span class="lineNum">    4457 </span>            : static inline unsigned
<span class="lineNum">    4458 </span>            : AT_flag (dw_attr_node *a)
<span class="lineNum">    4459 </span>            : {
<span class="lineNum">    4460 </span><span class="lineNoCov">          0 :   gcc_assert (a &amp;&amp; AT_class (a) == dw_val_class_flag);</span>
<span class="lineNum">    4461 </span><span class="lineCov">   21726592 :   return a-&gt;dw_attr_val.v.val_flag;</span>
<span class="lineNum">    4462 </span>            : }
<span class="lineNum">    4463 </span>            : 
<span class="lineNum">    4464 </span>            : /* Add a signed integer attribute value to a DIE.  */
<span class="lineNum">    4465 </span>            : 
<span class="lineNum">    4466 </span>            : static inline void
<span class="lineNum">    4467 </span>            : add_AT_int (dw_die_ref die, enum dwarf_attribute attr_kind, HOST_WIDE_INT int_val)
<span class="lineNum">    4468 </span>            : {
<span class="lineNum">    4469 </span><span class="lineCov">      51469 :   dw_attr_node attr;</span>
<span class="lineNum">    4470 </span>            : 
<span class="lineNum">    4471 </span><span class="lineCov">      51469 :   attr.dw_attr = attr_kind;</span>
<span class="lineNum">    4472 </span><span class="lineCov">      51469 :   attr.dw_attr_val.val_class = dw_val_class_const;</span>
<span class="lineNum">    4473 </span><span class="lineCov">      51469 :   attr.dw_attr_val.val_entry = NULL;</span>
<span class="lineNum">    4474 </span><span class="lineCov">      51469 :   attr.dw_attr_val.v.val_int = int_val;</span>
<span class="lineNum">    4475 </span><span class="lineCov">      51469 :   add_dwarf_attr (die, &amp;attr);</span>
<span class="lineNum">    4476 </span>            : }
<a name="4477"><span class="lineNum">    4477 </span>            : </a>
<span class="lineNum">    4478 </span>            : static inline HOST_WIDE_INT
<span class="lineNum">    4479 </span><span class="lineCov">      73926 : AT_int (dw_attr_node *a)</span>
<span class="lineNum">    4480 </span>            : {
<span class="lineNum">    4481 </span><span class="lineCov">      73926 :   gcc_assert (a &amp;&amp; (AT_class (a) == dw_val_class_const</span>
<span class="lineNum">    4482 </span>            :                     || AT_class (a) == dw_val_class_const_implicit));
<span class="lineNum">    4483 </span><span class="lineCov">      73926 :   return a-&gt;dw_attr_val.v.val_int;</span>
<span class="lineNum">    4484 </span>            : }
<span class="lineNum">    4485 </span>            : 
<span class="lineNum">    4486 </span>            : /* Add an unsigned integer attribute value to a DIE.  */
<span class="lineNum">    4487 </span>            : 
<span class="lineNum">    4488 </span>            : static inline void
<span class="lineNum">    4489 </span>            : add_AT_unsigned (dw_die_ref die, enum dwarf_attribute attr_kind,
<span class="lineNum">    4490 </span>            :                  unsigned HOST_WIDE_INT unsigned_val)
<span class="lineNum">    4491 </span>            : {
<span class="lineNum">    4492 </span><span class="lineCov">   97261185 :   dw_attr_node attr;</span>
<span class="lineNum">    4493 </span>            : 
<span class="lineNum">    4494 </span><span class="lineCov">   97261185 :   attr.dw_attr = attr_kind;</span>
<span class="lineNum">    4495 </span><span class="lineCov">   97261185 :   attr.dw_attr_val.val_class = dw_val_class_unsigned_const;</span>
<span class="lineNum">    4496 </span><span class="lineCov">   97261185 :   attr.dw_attr_val.val_entry = NULL;</span>
<span class="lineNum">    4497 </span><span class="lineCov">   97261185 :   attr.dw_attr_val.v.val_unsigned = unsigned_val;</span>
<span class="lineNum">    4498 </span><span class="lineCov">   97261185 :   add_dwarf_attr (die, &amp;attr);</span>
<span class="lineNum">    4499 </span>            : }
<a name="4500"><span class="lineNum">    4500 </span>            : </a>
<span class="lineNum">    4501 </span>            : static inline unsigned HOST_WIDE_INT
<span class="lineNum">    4502 </span><span class="lineCov">  266458241 : AT_unsigned (dw_attr_node *a)</span>
<span class="lineNum">    4503 </span>            : {
<span class="lineNum">    4504 </span><span class="lineCov">  266458241 :   gcc_assert (a &amp;&amp; (AT_class (a) == dw_val_class_unsigned_const</span>
<span class="lineNum">    4505 </span>            :                     || AT_class (a) == dw_val_class_unsigned_const_implicit));
<span class="lineNum">    4506 </span><span class="lineCov">  266458241 :   return a-&gt;dw_attr_val.v.val_unsigned;</span>
<span class="lineNum">    4507 </span>            : }
<span class="lineNum">    4508 </span>            : 
<span class="lineNum">    4509 </span>            : /* Add an unsigned wide integer attribute value to a DIE.  */
<a name="4510"><span class="lineNum">    4510 </span>            : </a>
<span class="lineNum">    4511 </span>            : static inline void
<span class="lineNum">    4512 </span><span class="lineCov">          8 : add_AT_wide (dw_die_ref die, enum dwarf_attribute attr_kind,</span>
<span class="lineNum">    4513 </span>            :              const wide_int&amp; w)
<span class="lineNum">    4514 </span>            : {
<span class="lineNum">    4515 </span><span class="lineCov">          8 :   dw_attr_node attr;</span>
<span class="lineNum">    4516 </span>            : 
<span class="lineNum">    4517 </span><span class="lineCov">          8 :   attr.dw_attr = attr_kind;</span>
<span class="lineNum">    4518 </span><span class="lineCov">          8 :   attr.dw_attr_val.val_class = dw_val_class_wide_int;</span>
<span class="lineNum">    4519 </span><span class="lineCov">          8 :   attr.dw_attr_val.val_entry = NULL;</span>
<span class="lineNum">    4520 </span><span class="lineCov">          8 :   attr.dw_attr_val.v.val_wide = ggc_alloc&lt;wide_int&gt; ();</span>
<span class="lineNum">    4521 </span><span class="lineCov">          8 :   *attr.dw_attr_val.v.val_wide = w;</span>
<span class="lineNum">    4522 </span><span class="lineCov">          8 :   add_dwarf_attr (die, &amp;attr);</span>
<span class="lineNum">    4523 </span><span class="lineCov">          8 : }</span>
<span class="lineNum">    4524 </span>            : 
<span class="lineNum">    4525 </span>            : /* Add an unsigned double integer attribute value to a DIE.  */
<span class="lineNum">    4526 </span>            : 
<span class="lineNum">    4527 </span>            : static inline void
<span class="lineNum">    4528 </span>            : add_AT_double (dw_die_ref die, enum dwarf_attribute attr_kind,
<span class="lineNum">    4529 </span>            :                HOST_WIDE_INT high, unsigned HOST_WIDE_INT low)
<span class="lineNum">    4530 </span>            : {
<span class="lineNum">    4531 </span>            :   dw_attr_node attr;
<span class="lineNum">    4532 </span>            : 
<span class="lineNum">    4533 </span>            :   attr.dw_attr = attr_kind;
<span class="lineNum">    4534 </span>            :   attr.dw_attr_val.val_class = dw_val_class_const_double;
<span class="lineNum">    4535 </span>            :   attr.dw_attr_val.val_entry = NULL;
<span class="lineNum">    4536 </span>            :   attr.dw_attr_val.v.val_double.high = high;
<span class="lineNum">    4537 </span>            :   attr.dw_attr_val.v.val_double.low = low;
<span class="lineNum">    4538 </span>            :   add_dwarf_attr (die, &amp;attr);
<span class="lineNum">    4539 </span>            : }
<span class="lineNum">    4540 </span>            : 
<span class="lineNum">    4541 </span>            : /* Add a floating point attribute value to a DIE and return it.  */
<span class="lineNum">    4542 </span>            : 
<span class="lineNum">    4543 </span>            : static inline void
<span class="lineNum">    4544 </span>            : add_AT_vec (dw_die_ref die, enum dwarf_attribute attr_kind,
<span class="lineNum">    4545 </span>            :             unsigned int length, unsigned int elt_size, unsigned char *array)
<span class="lineNum">    4546 </span>            : {
<span class="lineNum">    4547 </span><span class="lineCov">      12504 :   dw_attr_node attr;</span>
<span class="lineNum">    4548 </span>            : 
<span class="lineNum">    4549 </span><span class="lineCov">      12504 :   attr.dw_attr = attr_kind;</span>
<span class="lineNum">    4550 </span><span class="lineCov">      12504 :   attr.dw_attr_val.val_class = dw_val_class_vec;</span>
<span class="lineNum">    4551 </span><span class="lineCov">      12504 :   attr.dw_attr_val.val_entry = NULL;</span>
<span class="lineNum">    4552 </span><span class="lineCov">      12504 :   attr.dw_attr_val.v.val_vec.length = length;</span>
<span class="lineNum">    4553 </span><span class="lineCov">      12504 :   attr.dw_attr_val.v.val_vec.elt_size = elt_size;</span>
<span class="lineNum">    4554 </span><span class="lineCov">      12504 :   attr.dw_attr_val.v.val_vec.array = array;</span>
<span class="lineNum">    4555 </span><span class="lineCov">      12504 :   add_dwarf_attr (die, &amp;attr);</span>
<span class="lineNum">    4556 </span>            : }
<span class="lineNum">    4557 </span>            : 
<span class="lineNum">    4558 </span>            : /* Add an 8-byte data attribute value to a DIE.  */
<span class="lineNum">    4559 </span>            : 
<span class="lineNum">    4560 </span>            : static inline void
<span class="lineNum">    4561 </span>            : add_AT_data8 (dw_die_ref die, enum dwarf_attribute attr_kind,
<span class="lineNum">    4562 </span>            :               unsigned char data8[8])
<span class="lineNum">    4563 </span>            : {
<span class="lineNum">    4564 </span><span class="lineCov">         54 :   dw_attr_node attr;</span>
<span class="lineNum">    4565 </span>            : 
<span class="lineNum">    4566 </span><span class="lineCov">         54 :   attr.dw_attr = attr_kind;</span>
<span class="lineNum">    4567 </span><span class="lineCov">         54 :   attr.dw_attr_val.val_class = dw_val_class_data8;</span>
<span class="lineNum">    4568 </span><span class="lineCov">         54 :   attr.dw_attr_val.val_entry = NULL;</span>
<span class="lineNum">    4569 </span><span class="lineCov">         54 :   memcpy (attr.dw_attr_val.v.val_data8, data8, 8);</span>
<span class="lineNum">    4570 </span><span class="lineCov">         54 :   add_dwarf_attr (die, &amp;attr);</span>
<span class="lineNum">    4571 </span>            : }
<span class="lineNum">    4572 </span>            : 
<span class="lineNum">    4573 </span>            : /* Add DW_AT_low_pc and DW_AT_high_pc to a DIE.  When using
<span class="lineNum">    4574 </span>            :    dwarf_split_debug_info, address attributes in dies destined for the
<span class="lineNum">    4575 </span>            :    final executable have force_direct set to avoid using indexed
<span class="lineNum">    4576 </span>            :    references.  */
<a name="4577"><span class="lineNum">    4577 </span>            : </a>
<span class="lineNum">    4578 </span>            : static inline void
<span class="lineNum">    4579 </span><span class="lineCov">    2726904 : add_AT_low_high_pc (dw_die_ref die, const char *lbl_low, const char *lbl_high,</span>
<span class="lineNum">    4580 </span>            :                     bool force_direct)
<span class="lineNum">    4581 </span>            : {
<span class="lineNum">    4582 </span><span class="lineCov">    2726904 :   dw_attr_node attr;</span>
<span class="lineNum">    4583 </span><span class="lineCov">    2726904 :   char * lbl_id;</span>
<span class="lineNum">    4584 </span>            : 
<span class="lineNum">    4585 </span><span class="lineCov">    2726904 :   lbl_id = xstrdup (lbl_low);</span>
<span class="lineNum">    4586 </span><span class="lineCov">    2726904 :   attr.dw_attr = DW_AT_low_pc;</span>
<span class="lineNum">    4587 </span><span class="lineCov">    2726904 :   attr.dw_attr_val.val_class = dw_val_class_lbl_id;</span>
<span class="lineNum">    4588 </span><span class="lineCov">    2726904 :   attr.dw_attr_val.v.val_lbl_id = lbl_id;</span>
<span class="lineNum">    4589 </span><span class="lineCov">    2726904 :   if (dwarf_split_debug_info &amp;&amp; !force_direct)</span>
<span class="lineNum">    4590 </span><span class="lineCov">          3 :     attr.dw_attr_val.val_entry</span>
<span class="lineNum">    4591 </span><span class="lineCov">          3 :       = add_addr_table_entry (lbl_id, ate_kind_label);</span>
<span class="lineNum">    4592 </span>            :   else
<span class="lineNum">    4593 </span><span class="lineCov">    2726901 :     attr.dw_attr_val.val_entry = NULL;</span>
<span class="lineNum">    4594 </span><span class="lineCov">    2726904 :   add_dwarf_attr (die, &amp;attr);</span>
<span class="lineNum">    4595 </span>            : 
<span class="lineNum">    4596 </span><span class="lineCov">    2726904 :   attr.dw_attr = DW_AT_high_pc;</span>
<span class="lineNum">    4597 </span><span class="lineCov">    2726904 :   if (dwarf_version &lt; 4)</span>
<span class="lineNum">    4598 </span><span class="lineCov">       4134 :     attr.dw_attr_val.val_class = dw_val_class_lbl_id;</span>
<span class="lineNum">    4599 </span>            :   else
<span class="lineNum">    4600 </span><span class="lineCov">    2722770 :     attr.dw_attr_val.val_class = dw_val_class_high_pc;</span>
<span class="lineNum">    4601 </span><span class="lineCov">    2726904 :   lbl_id = xstrdup (lbl_high);</span>
<span class="lineNum">    4602 </span><span class="lineCov">    2726904 :   attr.dw_attr_val.v.val_lbl_id = lbl_id;</span>
<span class="lineNum">    4603 </span><span class="lineCov">    2726904 :   if (attr.dw_attr_val.val_class == dw_val_class_lbl_id</span>
<span class="lineNum">    4604 </span><span class="lineCov">       4134 :       &amp;&amp; dwarf_split_debug_info &amp;&amp; !force_direct)</span>
<span class="lineNum">    4605 </span><span class="lineNoCov">          0 :     attr.dw_attr_val.val_entry</span>
<span class="lineNum">    4606 </span><span class="lineNoCov">          0 :       = add_addr_table_entry (lbl_id, ate_kind_label);</span>
<span class="lineNum">    4607 </span>            :   else
<span class="lineNum">    4608 </span><span class="lineCov">    2726904 :     attr.dw_attr_val.val_entry = NULL;</span>
<span class="lineNum">    4609 </span><span class="lineCov">    2726904 :   add_dwarf_attr (die, &amp;attr);</span>
<span class="lineNum">    4610 </span><span class="lineCov">    2726904 : }</span>
<span class="lineNum">    4611 </span>            : 
<span class="lineNum">    4612 </span>            : /* Hash and equality functions for debug_str_hash.  */
<a name="4613"><span class="lineNum">    4613 </span>            : </a>
<span class="lineNum">    4614 </span>            : hashval_t
<span class="lineNum">    4615 </span><span class="lineCov">   72986194 : indirect_string_hasher::hash (indirect_string_node *x)</span>
<span class="lineNum">    4616 </span>            : {
<span class="lineNum">    4617 </span><span class="lineCov">   72986194 :   return htab_hash_string (x-&gt;str);</span>
<span class="lineNum">    4618 </span>            : }
<a name="4619"><span class="lineNum">    4619 </span>            : </a>
<span class="lineNum">    4620 </span>            : bool
<span class="lineNum">    4621 </span><span class="lineCov">  123544315 : indirect_string_hasher::equal (indirect_string_node *x1, const char *x2)</span>
<span class="lineNum">    4622 </span>            : {
<span class="lineNum">    4623 </span><span class="lineCov">  123544315 :   return strcmp (x1-&gt;str, x2) == 0;</span>
<span class="lineNum">    4624 </span>            : }
<span class="lineNum">    4625 </span>            : 
<span class="lineNum">    4626 </span>            : /* Add STR to the given string hash table.  */
<a name="4627"><span class="lineNum">    4627 </span>            : </a>
<span class="lineNum">    4628 </span>            : static struct indirect_string_node *
<span class="lineNum">    4629 </span><span class="lineCov">   85510670 : find_AT_string_in_table (const char *str,</span>
<span class="lineNum">    4630 </span>            :                          hash_table&lt;indirect_string_hasher&gt; *table)
<span class="lineNum">    4631 </span>            : {
<span class="lineNum">    4632 </span><span class="lineCov">   85510670 :   struct indirect_string_node *node;</span>
<span class="lineNum">    4633 </span>            : 
<span class="lineNum">    4634 </span><span class="lineCov">   85510670 :   indirect_string_node **slot</span>
<span class="lineNum">    4635 </span><span class="lineCov">   85510670 :     = table-&gt;find_slot_with_hash (str, htab_hash_string (str), INSERT);</span>
<span class="lineNum">    4636 </span><span class="lineCov">   85510670 :   if (*slot == NULL)</span>
<span class="lineNum">    4637 </span>            :     {
<span class="lineNum">    4638 </span><span class="lineCov">   53133707 :       node = ggc_cleared_alloc&lt;indirect_string_node&gt; ();</span>
<span class="lineNum">    4639 </span><span class="lineCov">   53133707 :       node-&gt;str = ggc_strdup (str);</span>
<span class="lineNum">    4640 </span><span class="lineCov">   53133707 :       *slot = node;</span>
<span class="lineNum">    4641 </span>            :     }
<span class="lineNum">    4642 </span>            :   else
<span class="lineNum">    4643 </span>            :     node = *slot;
<span class="lineNum">    4644 </span>            : 
<span class="lineNum">    4645 </span><span class="lineCov">   85510670 :   node-&gt;refcount++;</span>
<span class="lineNum">    4646 </span><span class="lineCov">   85510670 :   return node;</span>
<span class="lineNum">    4647 </span>            : }
<span class="lineNum">    4648 </span>            : 
<span class="lineNum">    4649 </span>            : /* Add STR to the indirect string hash table.  */
<a name="4650"><span class="lineNum">    4650 </span>            : </a>
<span class="lineNum">    4651 </span>            : static struct indirect_string_node *
<span class="lineNum">    4652 </span><span class="lineCov">   85510650 : find_AT_string (const char *str)</span>
<span class="lineNum">    4653 </span>            : {
<span class="lineNum">    4654 </span><span class="lineCov">   85510650 :   if (! debug_str_hash)</span>
<span class="lineNum">    4655 </span><span class="lineCov">      37179 :     debug_str_hash = hash_table&lt;indirect_string_hasher&gt;::create_ggc (10);</span>
<span class="lineNum">    4656 </span>            : 
<span class="lineNum">    4657 </span><span class="lineCov">   85510650 :   return find_AT_string_in_table (str, debug_str_hash);</span>
<span class="lineNum">    4658 </span>            : }
<span class="lineNum">    4659 </span>            : 
<span class="lineNum">    4660 </span>            : /* Add a string attribute value to a DIE.  */
<a name="4661"><span class="lineNum">    4661 </span>            : </a>
<span class="lineNum">    4662 </span>            : static inline void
<span class="lineNum">    4663 </span><span class="lineCov">   85142176 : add_AT_string (dw_die_ref die, enum dwarf_attribute attr_kind, const char *str)</span>
<span class="lineNum">    4664 </span>            : {
<span class="lineNum">    4665 </span><span class="lineCov">   85142176 :   dw_attr_node attr;</span>
<span class="lineNum">    4666 </span><span class="lineCov">   85142176 :   struct indirect_string_node *node;</span>
<span class="lineNum">    4667 </span>            : 
<span class="lineNum">    4668 </span><span class="lineCov">   85142176 :   node = find_AT_string (str);</span>
<span class="lineNum">    4669 </span>            : 
<span class="lineNum">    4670 </span><span class="lineCov">   85142176 :   attr.dw_attr = attr_kind;</span>
<span class="lineNum">    4671 </span><span class="lineCov">   85142176 :   attr.dw_attr_val.val_class = dw_val_class_str;</span>
<span class="lineNum">    4672 </span><span class="lineCov">   85142176 :   attr.dw_attr_val.val_entry = NULL;</span>
<span class="lineNum">    4673 </span><span class="lineCov">   85142176 :   attr.dw_attr_val.v.val_str = node;</span>
<span class="lineNum">    4674 </span><span class="lineCov">   85142176 :   add_dwarf_attr (die, &amp;attr);</span>
<span class="lineNum">    4675 </span><span class="lineCov">   85142176 : }</span>
<span class="lineNum">    4676 </span>            : 
<span class="lineNum">    4677 </span>            : static inline const char *
<span class="lineNum">    4678 </span>            : AT_string (dw_attr_node *a)
<span class="lineNum">    4679 </span>            : {
<span class="lineNum">    4680 </span><span class="lineNoCov">          0 :   gcc_assert (a &amp;&amp; AT_class (a) == dw_val_class_str);</span>
<span class="lineNum">    4681 </span><span class="lineCov">   21527019 :   return a-&gt;dw_attr_val.v.val_str-&gt;str;</span>
<span class="lineNum">    4682 </span>            : }
<span class="lineNum">    4683 </span>            : 
<span class="lineNum">    4684 </span>            : /* Call this function directly to bypass AT_string_form's logic to put
<span class="lineNum">    4685 </span>            :    the string inline in the die. */
<a name="4686"><span class="lineNum">    4686 </span>            : </a>
<span class="lineNum">    4687 </span>            : static void
<span class="lineNum">    4688 </span><span class="lineCov">   13255506 : set_indirect_string (struct indirect_string_node *node)</span>
<span class="lineNum">    4689 </span>            : {
<span class="lineNum">    4690 </span><span class="lineCov">   13255506 :   char label[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">    4691 </span>            :   /* Already indirect is a no op.  */
<span class="lineNum">    4692 </span><span class="lineCov">   13255506 :   if (node-&gt;form == DW_FORM_strp</span>
<span class="lineNum">    4693 </span><span class="lineCov">   13254893 :       || node-&gt;form == DW_FORM_line_strp</span>
<span class="lineNum">    4694 </span><span class="lineCov">   39765167 :       || node-&gt;form == dwarf_FORM (DW_FORM_strx))</span>
<span class="lineNum">    4695 </span>            :     {
<span class="lineNum">    4696 </span><span class="lineCov">        613 :       gcc_assert (node-&gt;label);</span>
<span class="lineNum">    4697 </span><span class="lineCov">        613 :       return;</span>
<span class="lineNum">    4698 </span>            :     }
<span class="lineNum">    4699 </span><span class="lineCov">   13254893 :   ASM_GENERATE_INTERNAL_LABEL (label, &quot;LASF&quot;, dw2_string_counter);</span>
<span class="lineNum">    4700 </span><span class="lineCov">   13254893 :   ++dw2_string_counter;</span>
<span class="lineNum">    4701 </span><span class="lineCov">   13254893 :   node-&gt;label = xstrdup (label);</span>
<span class="lineNum">    4702 </span>            : 
<span class="lineNum">    4703 </span><span class="lineCov">   13254893 :   if (!dwarf_split_debug_info)</span>
<span class="lineNum">    4704 </span>            :     {
<span class="lineNum">    4705 </span><span class="lineCov">   13254142 :       node-&gt;form = DW_FORM_strp;</span>
<span class="lineNum">    4706 </span><span class="lineCov">   13254142 :       node-&gt;index = NOT_INDEXED;</span>
<span class="lineNum">    4707 </span>            :     }
<span class="lineNum">    4708 </span>            :   else
<span class="lineNum">    4709 </span>            :     {
<span class="lineNum">    4710 </span><span class="lineCov">        751 :       node-&gt;form = dwarf_FORM (DW_FORM_strx);</span>
<span class="lineNum">    4711 </span><span class="lineCov">        751 :       node-&gt;index = NO_INDEX_ASSIGNED;</span>
<span class="lineNum">    4712 </span>            :     }
<span class="lineNum">    4713 </span>            : }
<span class="lineNum">    4714 </span>            : 
<span class="lineNum">    4715 </span>            : /* A helper function for dwarf2out_finish, called to reset indirect
<span class="lineNum">    4716 </span>            :    string decisions done for early LTO dwarf output before fat object
<span class="lineNum">    4717 </span>            :    dwarf output.  */
<a name="4718"><span class="lineNum">    4718 </span>            : </a>
<span class="lineNum">    4719 </span>            : int
<span class="lineNum">    4720 </span><span class="lineCov">      12604 : reset_indirect_string (indirect_string_node **h, void *)</span>
<span class="lineNum">    4721 </span>            : {
<span class="lineNum">    4722 </span><span class="lineCov">      12604 :   struct indirect_string_node *node = *h;</span>
<span class="lineNum">    4723 </span><span class="lineCov">      14911 :   if (node-&gt;form == DW_FORM_strp || node-&gt;form == dwarf_FORM (DW_FORM_strx))</span>
<span class="lineNum">    4724 </span>            :     {
<span class="lineNum">    4725 </span><span class="lineCov">      10279 :       free (node-&gt;label);</span>
<span class="lineNum">    4726 </span><span class="lineCov">      10279 :       node-&gt;label = NULL;</span>
<span class="lineNum">    4727 </span><span class="lineCov">      10279 :       node-&gt;form = (dwarf_form) 0;</span>
<span class="lineNum">    4728 </span><span class="lineCov">      10279 :       node-&gt;index = 0;</span>
<span class="lineNum">    4729 </span>            :     }
<span class="lineNum">    4730 </span><span class="lineCov">      12604 :   return 1;</span>
<span class="lineNum">    4731 </span>            : }
<span class="lineNum">    4732 </span>            : 
<span class="lineNum">    4733 </span>            : /* Find out whether a string should be output inline in DIE
<span class="lineNum">    4734 </span>            :    or out-of-line in .debug_str section.  */
<a name="4735"><span class="lineNum">    4735 </span>            : </a>
<span class="lineNum">    4736 </span>            : static enum dwarf_form
<span class="lineNum">    4737 </span><span class="lineCov">  132201421 : find_string_form (struct indirect_string_node *node)</span>
<span class="lineNum">    4738 </span>            : {
<span class="lineNum">    4739 </span><span class="lineCov">  132201421 :   unsigned int len;</span>
<span class="lineNum">    4740 </span>            : 
<span class="lineNum">    4741 </span><span class="lineCov">  132201421 :   if (node-&gt;form)</span>
<span class="lineNum">    4742 </span>            :     return node-&gt;form;
<span class="lineNum">    4743 </span>            : 
<span class="lineNum">    4744 </span><span class="lineCov">   13748113 :   len = strlen (node-&gt;str) + 1;</span>
<span class="lineNum">    4745 </span>            : 
<span class="lineNum">    4746 </span>            :   /* If the string is shorter or equal to the size of the reference, it is
<span class="lineNum">    4747 </span>            :      always better to put it inline.  */
<span class="lineNum">    4748 </span><span class="lineCov">   13748113 :   if (len &lt;= DWARF_OFFSET_SIZE || node-&gt;refcount == 0)</span>
<span class="lineNum">    4749 </span><span class="lineCov">     659240 :     return node-&gt;form = DW_FORM_string;</span>
<span class="lineNum">    4750 </span>            : 
<span class="lineNum">    4751 </span>            :   /* If we cannot expect the linker to merge strings in .debug_str
<span class="lineNum">    4752 </span>            :      section, only put it into .debug_str if it is worth even in this
<span class="lineNum">    4753 </span>            :      single module.  */
<span class="lineNum">    4754 </span><span class="lineCov">   26177746 :   if (DWARF2_INDIRECT_STRING_SUPPORT_MISSING_ON_TARGET</span>
<span class="lineNum">    4755 </span><span class="lineCov">   13088873 :       || ((debug_str_section-&gt;common.flags &amp; SECTION_MERGE) == 0</span>
<span class="lineNum">    4756 </span><span class="lineCov">        745 :           &amp;&amp; (len - DWARF_OFFSET_SIZE) * node-&gt;refcount &lt;= len))</span>
<span class="lineNum">    4757 </span><span class="lineCov">        722 :     return node-&gt;form = DW_FORM_string;</span>
<span class="lineNum">    4758 </span>            : 
<span class="lineNum">    4759 </span><span class="lineCov">   13088151 :   set_indirect_string (node);</span>
<span class="lineNum">    4760 </span>            : 
<span class="lineNum">    4761 </span><span class="lineCov">   13088151 :   return node-&gt;form;</span>
<span class="lineNum">    4762 </span>            : }
<span class="lineNum">    4763 </span>            : 
<span class="lineNum">    4764 </span>            : /* Find out whether the string referenced from the attribute should be
<span class="lineNum">    4765 </span>            :    output inline in DIE or out-of-line in .debug_str section.  */
<a name="4766"><span class="lineNum">    4766 </span>            : </a>
<span class="lineNum">    4767 </span>            : static enum dwarf_form
<span class="lineNum">    4768 </span><span class="lineCov">  118285250 : AT_string_form (dw_attr_node *a)</span>
<span class="lineNum">    4769 </span>            : {
<span class="lineNum">    4770 </span><span class="lineCov">  118285250 :   gcc_assert (a &amp;&amp; AT_class (a) == dw_val_class_str);</span>
<span class="lineNum">    4771 </span><span class="lineCov">  118285250 :   return find_string_form (a-&gt;dw_attr_val.v.val_str);</span>
<span class="lineNum">    4772 </span>            : }
<span class="lineNum">    4773 </span>            : 
<span class="lineNum">    4774 </span>            : /* Add a DIE reference attribute value to a DIE.  */
<a name="4775"><span class="lineNum">    4775 </span>            : </a>
<span class="lineNum">    4776 </span>            : static inline void
<span class="lineNum">    4777 </span><span class="lineCov">   85159903 : add_AT_die_ref (dw_die_ref die, enum dwarf_attribute attr_kind, dw_die_ref targ_die)</span>
<span class="lineNum">    4778 </span>            : {
<span class="lineNum">    4779 </span><span class="lineCov">   85159903 :   dw_attr_node attr;</span>
<span class="lineNum">    4780 </span><span class="lineCov">   85159903 :   gcc_checking_assert (targ_die != NULL);</span>
<span class="lineNum">    4781 </span>            : 
<span class="lineNum">    4782 </span>            :   /* With LTO we can end up trying to reference something we didn't create
<span class="lineNum">    4783 </span>            :      a DIE for.  Avoid crashing later on a NULL referenced DIE.  */
<span class="lineNum">    4784 </span><span class="lineCov">   85159903 :   if (targ_die == NULL)</span>
<span class="lineNum">    4785 </span>            :     return;
<span class="lineNum">    4786 </span>            : 
<span class="lineNum">    4787 </span><span class="lineCov">   85159903 :   attr.dw_attr = attr_kind;</span>
<span class="lineNum">    4788 </span><span class="lineCov">   85159903 :   attr.dw_attr_val.val_class = dw_val_class_die_ref;</span>
<span class="lineNum">    4789 </span><span class="lineCov">   85159903 :   attr.dw_attr_val.val_entry = NULL;</span>
<span class="lineNum">    4790 </span><span class="lineCov">   85159903 :   attr.dw_attr_val.v.val_die_ref.die = targ_die;</span>
<span class="lineNum">    4791 </span><span class="lineCov">   85159903 :   attr.dw_attr_val.v.val_die_ref.external = 0;</span>
<span class="lineNum">    4792 </span><span class="lineCov">   85159903 :   add_dwarf_attr (die, &amp;attr);</span>
<span class="lineNum">    4793 </span>            : }
<span class="lineNum">    4794 </span>            : 
<span class="lineNum">    4795 </span>            : /* Change DIE reference REF to point to NEW_DIE instead.  */
<span class="lineNum">    4796 </span>            : 
<span class="lineNum">    4797 </span>            : static inline void
<span class="lineNum">    4798 </span>            : change_AT_die_ref (dw_attr_node *ref, dw_die_ref new_die)
<span class="lineNum">    4799 </span>            : {
<span class="lineNum">    4800 </span><span class="lineNoCov">          0 :   gcc_assert (ref-&gt;dw_attr_val.val_class == dw_val_class_die_ref);</span>
<span class="lineNum">    4801 </span><span class="lineCov">         90 :   ref-&gt;dw_attr_val.v.val_die_ref.die = new_die;</span>
<span class="lineNum">    4802 </span><span class="lineCov">         90 :   ref-&gt;dw_attr_val.v.val_die_ref.external = 0;</span>
<span class="lineNum">    4803 </span>            : }
<span class="lineNum">    4804 </span>            : 
<span class="lineNum">    4805 </span>            : /* Add an AT_specification attribute to a DIE, and also make the back
<span class="lineNum">    4806 </span>            :    pointer from the specification to the definition.  */
<a name="4807"><span class="lineNum">    4807 </span>            : </a>
<span class="lineNum">    4808 </span>            : static inline void
<span class="lineNum">    4809 </span><span class="lineCov">    1351414 : add_AT_specification (dw_die_ref die, dw_die_ref targ_die)</span>
<span class="lineNum">    4810 </span>            : {
<span class="lineNum">    4811 </span><span class="lineCov">    1351414 :   add_AT_die_ref (die, DW_AT_specification, targ_die);</span>
<span class="lineNum">    4812 </span><span class="lineCov">    1351414 :   gcc_assert (!targ_die-&gt;die_definition);</span>
<span class="lineNum">    4813 </span><span class="lineCov">    1351414 :   targ_die-&gt;die_definition = die;</span>
<span class="lineNum">    4814 </span><span class="lineCov">    1351414 : }</span>
<span class="lineNum">    4815 </span>            : 
<span class="lineNum">    4816 </span>            : static inline dw_die_ref
<span class="lineNum">    4817 </span>            : AT_ref (dw_attr_node *a)
<span class="lineNum">    4818 </span>            : {
<span class="lineNum">    4819 </span><span class="lineNoCov">          0 :   gcc_assert (a &amp;&amp; AT_class (a) == dw_val_class_die_ref);</span>
<span class="lineNum">    4820 </span><span class="lineCov">  278830135 :   return a-&gt;dw_attr_val.v.val_die_ref.die;</span>
<span class="lineNum">    4821 </span>            : }
<span class="lineNum">    4822 </span>            : 
<span class="lineNum">    4823 </span>            : static inline int
<span class="lineNum">    4824 </span>            : AT_ref_external (dw_attr_node *a)
<span class="lineNum">    4825 </span>            : {
<span class="lineNum">    4826 </span><span class="lineCov">  437181732 :   if (a &amp;&amp; AT_class (a) == dw_val_class_die_ref)</span>
<span class="lineNum">    4827 </span><span class="lineCov">  218590866 :     return a-&gt;dw_attr_val.v.val_die_ref.external;</span>
<span class="lineNum">    4828 </span>            : 
<span class="lineNum">    4829 </span>            :   return 0;
<span class="lineNum">    4830 </span>            : }
<span class="lineNum">    4831 </span>            : 
<span class="lineNum">    4832 </span>            : static inline void
<span class="lineNum">    4833 </span>            : set_AT_ref_external (dw_attr_node *a, int i)
<span class="lineNum">    4834 </span>            : {
<span class="lineNum">    4835 </span><span class="lineNoCov">          0 :   gcc_assert (a &amp;&amp; AT_class (a) == dw_val_class_die_ref);</span>
<span class="lineNum">    4836 </span><span class="lineCov">      26170 :   a-&gt;dw_attr_val.v.val_die_ref.external = i;</span>
<span class="lineNum">    4837 </span>            : }
<span class="lineNum">    4838 </span>            : 
<span class="lineNum">    4839 </span>            : /* Add an FDE reference attribute value to a DIE.  */
<span class="lineNum">    4840 </span>            : 
<span class="lineNum">    4841 </span>            : static inline void
<span class="lineNum">    4842 </span>            : add_AT_fde_ref (dw_die_ref die, enum dwarf_attribute attr_kind, unsigned int targ_fde)
<span class="lineNum">    4843 </span>            : {
<span class="lineNum">    4844 </span>            :   dw_attr_node attr;
<span class="lineNum">    4845 </span>            : 
<span class="lineNum">    4846 </span>            :   attr.dw_attr = attr_kind;
<span class="lineNum">    4847 </span>            :   attr.dw_attr_val.val_class = dw_val_class_fde_ref;
<span class="lineNum">    4848 </span>            :   attr.dw_attr_val.val_entry = NULL;
<span class="lineNum">    4849 </span>            :   attr.dw_attr_val.v.val_fde_index = targ_fde;
<span class="lineNum">    4850 </span>            :   add_dwarf_attr (die, &amp;attr);
<span class="lineNum">    4851 </span>            : }
<span class="lineNum">    4852 </span>            : 
<span class="lineNum">    4853 </span>            : /* Add a location description attribute value to a DIE.  */
<span class="lineNum">    4854 </span>            : 
<span class="lineNum">    4855 </span>            : static inline void
<span class="lineNum">    4856 </span>            : add_AT_loc (dw_die_ref die, enum dwarf_attribute attr_kind, dw_loc_descr_ref loc)
<span class="lineNum">    4857 </span>            : {
<span class="lineNum">    4858 </span><span class="lineCov">    5213807 :   dw_attr_node attr;</span>
<span class="lineNum">    4859 </span>            : 
<span class="lineNum">    4860 </span><span class="lineCov">    5213807 :   attr.dw_attr = attr_kind;</span>
<span class="lineNum">    4861 </span><span class="lineCov">    5213807 :   attr.dw_attr_val.val_class = dw_val_class_loc;</span>
<span class="lineNum">    4862 </span><span class="lineCov">    5213807 :   attr.dw_attr_val.val_entry = NULL;</span>
<span class="lineNum">    4863 </span><span class="lineCov">    5213807 :   attr.dw_attr_val.v.val_loc = loc;</span>
<span class="lineNum">    4864 </span><span class="lineCov">    5213807 :   add_dwarf_attr (die, &amp;attr);</span>
<span class="lineNum">    4865 </span>            : }
<span class="lineNum">    4866 </span>            : 
<span class="lineNum">    4867 </span>            : static inline dw_loc_descr_ref
<span class="lineNum">    4868 </span>            : AT_loc (dw_attr_node *a)
<span class="lineNum">    4869 </span>            : {
<span class="lineNum">    4870 </span><span class="lineCov">        837 :   gcc_assert (a &amp;&amp; AT_class (a) == dw_val_class_loc);</span>
<span class="lineNum">    4871 </span><span class="lineCov">   20042777 :   return a-&gt;dw_attr_val.v.val_loc;</span>
<span class="lineNum">    4872 </span>            : }
<span class="lineNum">    4873 </span>            : 
<span class="lineNum">    4874 </span>            : static inline void
<span class="lineNum">    4875 </span>            : add_AT_loc_list (dw_die_ref die, enum dwarf_attribute attr_kind, dw_loc_list_ref loc_list)
<span class="lineNum">    4876 </span>            : {
<span class="lineNum">    4877 </span><span class="lineCov">    6135931 :   dw_attr_node attr;</span>
<span class="lineNum">    4878 </span>            : 
<span class="lineNum">    4879 </span><span class="lineCov">    6135931 :   if (XCOFF_DEBUGGING_INFO &amp;&amp; !HAVE_XCOFF_DWARF_EXTRAS)</span>
<span class="lineNum">    4880 </span>            :     return;
<span class="lineNum">    4881 </span>            : 
<span class="lineNum">    4882 </span><span class="lineCov">    6135931 :   attr.dw_attr = attr_kind;</span>
<span class="lineNum">    4883 </span><span class="lineCov">    6135931 :   attr.dw_attr_val.val_class = dw_val_class_loc_list;</span>
<span class="lineNum">    4884 </span><span class="lineCov">    6135931 :   attr.dw_attr_val.val_entry = NULL;</span>
<span class="lineNum">    4885 </span><span class="lineCov">    6135931 :   attr.dw_attr_val.v.val_loc_list = loc_list;</span>
<span class="lineNum">    4886 </span><span class="lineCov">    6135931 :   add_dwarf_attr (die, &amp;attr);</span>
<span class="lineNum">    4887 </span><span class="lineCov">       1569 :   have_location_lists = true;</span>
<span class="lineNum">    4888 </span>            : }
<span class="lineNum">    4889 </span>            : 
<span class="lineNum">    4890 </span>            : static inline dw_loc_list_ref
<span class="lineNum">    4891 </span>            : AT_loc_list (dw_attr_node *a)
<span class="lineNum">    4892 </span>            : {
<span class="lineNum">    4893 </span><span class="lineCov">    5791298 :   gcc_assert (a &amp;&amp; AT_class (a) == dw_val_class_loc_list);</span>
<span class="lineNum">    4894 </span><span class="lineCov">   17374222 :   return a-&gt;dw_attr_val.v.val_loc_list;</span>
<span class="lineNum">    4895 </span>            : }
<span class="lineNum">    4896 </span>            : 
<span class="lineNum">    4897 </span>            : /* Add a view list attribute to DIE.  It must have a DW_AT_location
<span class="lineNum">    4898 </span>            :    attribute, because the view list complements the location list.  */
<a name="4899"><span class="lineNum">    4899 </span>            : </a>
<span class="lineNum">    4900 </span>            : static inline void
<span class="lineNum">    4901 </span><span class="lineCov">    6050836 : add_AT_view_list (dw_die_ref die, enum dwarf_attribute attr_kind)</span>
<span class="lineNum">    4902 </span>            : {
<span class="lineNum">    4903 </span><span class="lineCov">    6050836 :   dw_attr_node attr;</span>
<span class="lineNum">    4904 </span>            : 
<span class="lineNum">    4905 </span><span class="lineCov">    6050836 :   if (XCOFF_DEBUGGING_INFO &amp;&amp; !HAVE_XCOFF_DWARF_EXTRAS)</span>
<span class="lineNum">    4906 </span>            :     return;
<span class="lineNum">    4907 </span>            : 
<span class="lineNum">    4908 </span><span class="lineCov">    6050836 :   attr.dw_attr = attr_kind;</span>
<span class="lineNum">    4909 </span><span class="lineCov">    6050836 :   attr.dw_attr_val.val_class = dw_val_class_view_list;</span>
<span class="lineNum">    4910 </span><span class="lineCov">    6050836 :   attr.dw_attr_val.val_entry = NULL;</span>
<span class="lineNum">    4911 </span><span class="lineCov">    6050836 :   attr.dw_attr_val.v.val_view_list = die;</span>
<span class="lineNum">    4912 </span><span class="lineCov">    6050836 :   add_dwarf_attr (die, &amp;attr);</span>
<span class="lineNum">    4913 </span><span class="lineCov">    6050836 :   gcc_checking_assert (get_AT (die, DW_AT_location));</span>
<span class="lineNum">    4914 </span><span class="lineCov">    6050836 :   gcc_assert (have_location_lists);</span>
<span class="lineNum">    4915 </span>            : }
<span class="lineNum">    4916 </span>            : 
<span class="lineNum">    4917 </span>            : /* Return a pointer to the location list referenced by the attribute.
<span class="lineNum">    4918 </span>            :    If the named attribute is a view list, look up the corresponding
<span class="lineNum">    4919 </span>            :    DW_AT_location attribute and return its location list.  */
<a name="4920"><span class="lineNum">    4920 </span>            : </a>
<span class="lineNum">    4921 </span>            : static inline dw_loc_list_ref *
<span class="lineNum">    4922 </span><span class="lineCov">   11842139 : AT_loc_list_ptr (dw_attr_node *a)</span>
<span class="lineNum">    4923 </span>            : {
<span class="lineNum">    4924 </span><span class="lineCov">   17548024 :   gcc_assert (a);</span>
<span class="lineNum">    4925 </span><span class="lineCov">   17548024 :   switch (AT_class (a))</span>
<span class="lineNum">    4926 </span>            :     {
<span class="lineNum">    4927 </span><span class="lineCov">   11842139 :     case dw_val_class_loc_list:</span>
<span class="lineNum">    4928 </span><span class="lineCov">   11842139 :       return &amp;a-&gt;dw_attr_val.v.val_loc_list;</span>
<span class="lineNum">    4929 </span><span class="lineCov">    5705885 :     case dw_val_class_view_list:</span>
<span class="lineNum">    4930 </span><span class="lineCov">    5705885 :       {</span>
<span class="lineNum">    4931 </span><span class="lineCov">    5705885 :         dw_attr_node *l;</span>
<span class="lineNum">    4932 </span><span class="lineCov">    5705885 :         l = get_AT (a-&gt;dw_attr_val.v.val_view_list, DW_AT_location);</span>
<span class="lineNum">    4933 </span><span class="lineCov">    5705885 :         if (!l)</span>
<span class="lineNum">    4934 </span>            :           return NULL;
<span class="lineNum">    4935 </span><span class="lineCov">    5705885 :         gcc_checking_assert (l + 1 == a);</span>
<span class="lineNum">    4936 </span>            :         return AT_loc_list_ptr (l);
<span class="lineNum">    4937 </span>            :       }
<span class="lineNum">    4938 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">    4939 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">    4940 </span>            :     }
<span class="lineNum">    4941 </span>            : }
<span class="lineNum">    4942 </span>            : 
<span class="lineNum">    4943 </span>            : /* Return the location attribute value associated with a view list
<span class="lineNum">    4944 </span>            :    attribute value.  */
<a name="4945"><span class="lineNum">    4945 </span>            : </a>
<span class="lineNum">    4946 </span>            : static inline dw_val_node *
<span class="lineNum">    4947 </span><span class="lineCov">    6050872 : view_list_to_loc_list_val_node (dw_val_node *val)</span>
<span class="lineNum">    4948 </span>            : {
<span class="lineNum">    4949 </span><span class="lineCov">    6050872 :   gcc_assert (val-&gt;val_class == dw_val_class_view_list);</span>
<span class="lineNum">    4950 </span><span class="lineCov">    6050872 :   dw_attr_node *loc = get_AT (val-&gt;v.val_view_list, DW_AT_location);</span>
<span class="lineNum">    4951 </span><span class="lineCov">    6050872 :   if (!loc)</span>
<span class="lineNum">    4952 </span>            :     return NULL;
<span class="lineNum">    4953 </span><span class="lineCov">    5705921 :   gcc_checking_assert (&amp;(loc + 1)-&gt;dw_attr_val == val);</span>
<span class="lineNum">    4954 </span><span class="lineCov">    5705921 :   gcc_assert (AT_class (loc) == dw_val_class_loc_list);</span>
<span class="lineNum">    4955 </span><span class="lineCov">    5705921 :   return &amp;loc-&gt;dw_attr_val;</span>
<span class="lineNum">    4956 </span>            : }
<span class="lineNum">    4957 </span>            : 
<span class="lineNum">    4958 </span>            : struct addr_hasher : ggc_ptr_hash&lt;addr_table_entry&gt;
<span class="lineNum">    4959 </span>            : {
<span class="lineNum">    4960 </span>            :   static hashval_t hash (addr_table_entry *);
<span class="lineNum">    4961 </span>            :   static bool equal (addr_table_entry *, addr_table_entry *);
<span class="lineNum">    4962 </span>            : };
<span class="lineNum">    4963 </span>            : 
<span class="lineNum">    4964 </span>            : /* Table of entries into the .debug_addr section.  */
<span class="lineNum">    4965 </span>            : 
<span class="lineNum">    4966 </span>            : static GTY (()) hash_table&lt;addr_hasher&gt; *addr_index_table;
<span class="lineNum">    4967 </span>            : 
<span class="lineNum">    4968 </span>            : /* Hash an address_table_entry.  */
<a name="4969"><span class="lineNum">    4969 </span>            : </a>
<span class="lineNum">    4970 </span>            : hashval_t
<span class="lineNum">    4971 </span><span class="lineCov">         42 : addr_hasher::hash (addr_table_entry *a)</span>
<span class="lineNum">    4972 </span>            : {
<span class="lineNum">    4973 </span><span class="lineCov">         42 :   inchash::hash hstate;</span>
<span class="lineNum">    4974 </span><span class="lineCov">         42 :   switch (a-&gt;kind)</span>
<span class="lineNum">    4975 </span>            :     {
<span class="lineNum">    4976 </span><span class="lineCov">         23 :       case ate_kind_rtx:</span>
<span class="lineNum">    4977 </span><span class="lineCov">         23 :         hstate.add_int (0);</span>
<span class="lineNum">    4978 </span>            :         break;
<span class="lineNum">    4979 </span><span class="lineNoCov">          0 :       case ate_kind_rtx_dtprel:</span>
<span class="lineNum">    4980 </span><span class="lineNoCov">          0 :         hstate.add_int (1);</span>
<span class="lineNum">    4981 </span>            :         break;
<span class="lineNum">    4982 </span><span class="lineCov">         19 :       case ate_kind_label:</span>
<span class="lineNum">    4983 </span><span class="lineCov">         19 :         return htab_hash_string (a-&gt;addr.label);</span>
<span class="lineNum">    4984 </span><span class="lineNoCov">          0 :       default:</span>
<span class="lineNum">    4985 </span><span class="lineNoCov">          0 :         gcc_unreachable ();</span>
<span class="lineNum">    4986 </span>            :     }
<span class="lineNum">    4987 </span><span class="lineCov">         23 :   inchash::add_rtx (a-&gt;addr.rtl, hstate);</span>
<span class="lineNum">    4988 </span><span class="lineCov">         46 :   return hstate.end ();</span>
<span class="lineNum">    4989 </span>            : }
<span class="lineNum">    4990 </span>            : 
<span class="lineNum">    4991 </span>            : /* Determine equality for two address_table_entries.  */
<a name="4992"><span class="lineNum">    4992 </span>            : </a>
<span class="lineNum">    4993 </span>            : bool
<span class="lineNum">    4994 </span><span class="lineCov">         20 : addr_hasher::equal (addr_table_entry *a1, addr_table_entry *a2)</span>
<span class="lineNum">    4995 </span>            : {
<span class="lineNum">    4996 </span><span class="lineCov">         20 :   if (a1-&gt;kind != a2-&gt;kind)</span>
<span class="lineNum">    4997 </span>            :     return 0;
<span class="lineNum">    4998 </span><span class="lineCov">         19 :   switch (a1-&gt;kind)</span>
<span class="lineNum">    4999 </span>            :     {
<span class="lineNum">    5000 </span><span class="lineCov">         15 :       case ate_kind_rtx:</span>
<span class="lineNum">    5001 </span><span class="lineCov">         15 :       case ate_kind_rtx_dtprel:</span>
<span class="lineNum">    5002 </span><span class="lineCov">         15 :         return rtx_equal_p (a1-&gt;addr.rtl, a2-&gt;addr.rtl);</span>
<span class="lineNum">    5003 </span><span class="lineCov">          4 :       case ate_kind_label:</span>
<span class="lineNum">    5004 </span><span class="lineCov">          4 :         return strcmp (a1-&gt;addr.label, a2-&gt;addr.label) == 0;</span>
<span class="lineNum">    5005 </span><span class="lineNoCov">          0 :       default:</span>
<span class="lineNum">    5006 </span><span class="lineNoCov">          0 :         gcc_unreachable ();</span>
<span class="lineNum">    5007 </span>            :     }
<span class="lineNum">    5008 </span>            : }
<span class="lineNum">    5009 </span>            : 
<span class="lineNum">    5010 </span>            : /* Initialize an addr_table_entry.  */
<a name="5011"><span class="lineNum">    5011 </span>            : </a>
<span class="lineNum">    5012 </span>            : void
<span class="lineNum">    5013 </span><span class="lineCov">         73 : init_addr_table_entry (addr_table_entry *e, enum ate_kind kind, void *addr)</span>
<span class="lineNum">    5014 </span>            : {
<span class="lineNum">    5015 </span><span class="lineCov">         73 :   e-&gt;kind = kind;</span>
<span class="lineNum">    5016 </span><span class="lineCov">         73 :   switch (kind)</span>
<span class="lineNum">    5017 </span>            :     {
<span class="lineNum">    5018 </span><span class="lineCov">         37 :       case ate_kind_rtx:</span>
<span class="lineNum">    5019 </span><span class="lineCov">         37 :       case ate_kind_rtx_dtprel:</span>
<span class="lineNum">    5020 </span><span class="lineCov">         37 :         e-&gt;addr.rtl = (rtx) addr;</span>
<span class="lineNum">    5021 </span><span class="lineCov">         37 :         break;</span>
<span class="lineNum">    5022 </span><span class="lineCov">         36 :       case ate_kind_label:</span>
<span class="lineNum">    5023 </span><span class="lineCov">         36 :         e-&gt;addr.label = (char *) addr;</span>
<span class="lineNum">    5024 </span><span class="lineCov">         36 :         break;</span>
<span class="lineNum">    5025 </span>            :     }
<span class="lineNum">    5026 </span><span class="lineCov">         73 :   e-&gt;refcount = 0;</span>
<span class="lineNum">    5027 </span><span class="lineCov">         73 :   e-&gt;index = NO_INDEX_ASSIGNED;</span>
<span class="lineNum">    5028 </span><span class="lineCov">         73 : }</span>
<span class="lineNum">    5029 </span>            : 
<span class="lineNum">    5030 </span>            : /* Add attr to the address table entry to the table.  Defer setting an
<span class="lineNum">    5031 </span>            :    index until output time.  */
<a name="5032"><span class="lineNum">    5032 </span>            : </a>
<span class="lineNum">    5033 </span>            : static addr_table_entry *
<span class="lineNum">    5034 </span><span class="lineCov">         42 : add_addr_table_entry (void *addr, enum ate_kind kind)</span>
<span class="lineNum">    5035 </span>            : {
<span class="lineNum">    5036 </span><span class="lineCov">         42 :   addr_table_entry *node;</span>
<span class="lineNum">    5037 </span><span class="lineCov">         42 :   addr_table_entry finder;</span>
<span class="lineNum">    5038 </span>            : 
<span class="lineNum">    5039 </span><span class="lineCov">         42 :   gcc_assert (dwarf_split_debug_info);</span>
<span class="lineNum">    5040 </span><span class="lineCov">         42 :   if (! addr_index_table)</span>
<span class="lineNum">    5041 </span><span class="lineCov">          4 :     addr_index_table = hash_table&lt;addr_hasher&gt;::create_ggc (10);</span>
<span class="lineNum">    5042 </span><span class="lineCov">         42 :   init_addr_table_entry (&amp;finder, kind, addr);</span>
<span class="lineNum">    5043 </span><span class="lineCov">         42 :   addr_table_entry **slot = addr_index_table-&gt;find_slot (&amp;finder, INSERT);</span>
<span class="lineNum">    5044 </span>            : 
<span class="lineNum">    5045 </span><span class="lineCov">         42 :   if (*slot == HTAB_EMPTY_ENTRY)</span>
<span class="lineNum">    5046 </span>            :     {
<span class="lineNum">    5047 </span><span class="lineCov">         31 :       node = ggc_cleared_alloc&lt;addr_table_entry&gt; ();</span>
<span class="lineNum">    5048 </span><span class="lineCov">         31 :       init_addr_table_entry (node, kind, addr);</span>
<span class="lineNum">    5049 </span><span class="lineCov">         31 :       *slot = node;</span>
<span class="lineNum">    5050 </span>            :     }
<span class="lineNum">    5051 </span>            :   else
<span class="lineNum">    5052 </span>            :     node = *slot;
<span class="lineNum">    5053 </span>            : 
<span class="lineNum">    5054 </span><span class="lineCov">         42 :   node-&gt;refcount++;</span>
<span class="lineNum">    5055 </span><span class="lineCov">         42 :   return node;</span>
<span class="lineNum">    5056 </span>            : }
<span class="lineNum">    5057 </span>            : 
<span class="lineNum">    5058 </span>            : /* Remove an entry from the addr table by decrementing its refcount.
<span class="lineNum">    5059 </span>            :    Strictly, decrementing the refcount would be enough, but the
<span class="lineNum">    5060 </span>            :    assertion that the entry is actually in the table has found
<span class="lineNum">    5061 </span>            :    bugs.  */
<a name="5062"><span class="lineNum">    5062 </span>            : </a>
<span class="lineNum">    5063 </span>            : static void
<span class="lineNum">    5064 </span><span class="lineCov">          7 : remove_addr_table_entry (addr_table_entry *entry)</span>
<span class="lineNum">    5065 </span>            : {
<span class="lineNum">    5066 </span><span class="lineCov">          7 :   gcc_assert (dwarf_split_debug_info &amp;&amp; addr_index_table);</span>
<span class="lineNum">    5067 </span>            :   /* After an index is assigned, the table is frozen.  */
<span class="lineNum">    5068 </span><span class="lineCov">          7 :   gcc_assert (entry-&gt;refcount &gt; 0 &amp;&amp; entry-&gt;index == NO_INDEX_ASSIGNED);</span>
<span class="lineNum">    5069 </span><span class="lineCov">          7 :   entry-&gt;refcount--;</span>
<span class="lineNum">    5070 </span><span class="lineCov">          7 : }</span>
<span class="lineNum">    5071 </span>            : 
<span class="lineNum">    5072 </span>            : /* Given a location list, remove all addresses it refers to from the
<span class="lineNum">    5073 </span>            :    address_table.  */
<a name="5074"><span class="lineNum">    5074 </span>            : </a>
<span class="lineNum">    5075 </span>            : static void
<span class="lineNum">    5076 </span><span class="lineCov">        334 : remove_loc_list_addr_table_entries (dw_loc_descr_ref descr)</span>
<span class="lineNum">    5077 </span>            : {
<span class="lineNum">    5078 </span><span class="lineCov">       3226 :   for (; descr; descr = descr-&gt;dw_loc_next)</span>
<span class="lineNum">    5079 </span><span class="lineCov">       2892 :     if (descr-&gt;dw_loc_oprnd1.val_entry != NULL)</span>
<span class="lineNum">    5080 </span>            :       {
<span class="lineNum">    5081 </span><span class="lineNoCov">          0 :         gcc_assert (descr-&gt;dw_loc_oprnd1.val_entry-&gt;index == NO_INDEX_ASSIGNED);</span>
<span class="lineNum">    5082 </span><span class="lineNoCov">          0 :         remove_addr_table_entry (descr-&gt;dw_loc_oprnd1.val_entry);</span>
<span class="lineNum">    5083 </span>            :       }
<span class="lineNum">    5084 </span><span class="lineCov">        334 : }</span>
<span class="lineNum">    5085 </span>            : 
<span class="lineNum">    5086 </span>            : /* A helper function for dwarf2out_finish called through
<span class="lineNum">    5087 </span>            :    htab_traverse.  Assign an addr_table_entry its index.  All entries
<span class="lineNum">    5088 </span>            :    must be collected into the table when this function is called,
<span class="lineNum">    5089 </span>            :    because the indexing code relies on htab_traverse to traverse nodes
<span class="lineNum">    5090 </span>            :    in the same order for each run. */
<a name="5091"><span class="lineNum">    5091 </span>            : </a>
<span class="lineNum">    5092 </span>            : int
<span class="lineNum">    5093 </span><span class="lineCov">         31 : index_addr_table_entry (addr_table_entry **h, unsigned int *index)</span>
<span class="lineNum">    5094 </span>            : {
<span class="lineNum">    5095 </span><span class="lineCov">         31 :   addr_table_entry *node = *h;</span>
<span class="lineNum">    5096 </span>            : 
<span class="lineNum">    5097 </span>            :   /* Don't index unreferenced nodes.  */
<span class="lineNum">    5098 </span><span class="lineCov">         31 :   if (node-&gt;refcount == 0)</span>
<span class="lineNum">    5099 </span>            :     return 1;
<span class="lineNum">    5100 </span>            : 
<span class="lineNum">    5101 </span><span class="lineCov">         31 :   gcc_assert (node-&gt;index == NO_INDEX_ASSIGNED);</span>
<span class="lineNum">    5102 </span><span class="lineCov">         31 :   node-&gt;index = *index;</span>
<span class="lineNum">    5103 </span><span class="lineCov">         31 :   *index += 1;</span>
<span class="lineNum">    5104 </span>            : 
<span class="lineNum">    5105 </span><span class="lineCov">         31 :   return 1;</span>
<span class="lineNum">    5106 </span>            : }
<span class="lineNum">    5107 </span>            : 
<span class="lineNum">    5108 </span>            : /* Add an address constant attribute value to a DIE.  When using
<span class="lineNum">    5109 </span>            :    dwarf_split_debug_info, address attributes in dies destined for the
<span class="lineNum">    5110 </span>            :    final executable should be direct references--setting the parameter
<span class="lineNum">    5111 </span>            :    force_direct ensures this behavior.  */
<a name="5112"><span class="lineNum">    5112 </span>            : </a>
<span class="lineNum">    5113 </span>            : static inline void
<span class="lineNum">    5114 </span><span class="lineCov">    1433687 : add_AT_addr (dw_die_ref die, enum dwarf_attribute attr_kind, rtx addr,</span>
<span class="lineNum">    5115 </span>            :              bool force_direct)
<span class="lineNum">    5116 </span>            : {
<span class="lineNum">    5117 </span><span class="lineCov">    1433687 :   dw_attr_node attr;</span>
<span class="lineNum">    5118 </span>            : 
<span class="lineNum">    5119 </span><span class="lineCov">    1433687 :   attr.dw_attr = attr_kind;</span>
<span class="lineNum">    5120 </span><span class="lineCov">    1433687 :   attr.dw_attr_val.val_class = dw_val_class_addr;</span>
<span class="lineNum">    5121 </span><span class="lineCov">    1433687 :   attr.dw_attr_val.v.val_addr = addr;</span>
<span class="lineNum">    5122 </span><span class="lineCov">    1433687 :   if (dwarf_split_debug_info &amp;&amp; !force_direct)</span>
<span class="lineNum">    5123 </span><span class="lineCov">          9 :     attr.dw_attr_val.val_entry = add_addr_table_entry (addr, ate_kind_rtx);</span>
<span class="lineNum">    5124 </span>            :   else
<span class="lineNum">    5125 </span><span class="lineCov">    1433678 :     attr.dw_attr_val.val_entry = NULL;</span>
<span class="lineNum">    5126 </span><span class="lineCov">    1433687 :   add_dwarf_attr (die, &amp;attr);</span>
<span class="lineNum">    5127 </span><span class="lineCov">    1433687 : }</span>
<span class="lineNum">    5128 </span>            : 
<span class="lineNum">    5129 </span>            : /* Get the RTX from to an address DIE attribute.  */
<span class="lineNum">    5130 </span>            : 
<span class="lineNum">    5131 </span>            : static inline rtx
<span class="lineNum">    5132 </span>            : AT_addr (dw_attr_node *a)
<span class="lineNum">    5133 </span>            : {
<span class="lineNum">    5134 </span><span class="lineNoCov">          0 :   gcc_assert (a &amp;&amp; AT_class (a) == dw_val_class_addr);</span>
<span class="lineNum">    5135 </span><span class="lineCov">      20665 :   return a-&gt;dw_attr_val.v.val_addr;</span>
<span class="lineNum">    5136 </span>            : }
<span class="lineNum">    5137 </span>            : 
<span class="lineNum">    5138 </span>            : /* Add a file attribute value to a DIE.  */
<span class="lineNum">    5139 </span>            : 
<span class="lineNum">    5140 </span>            : static inline void
<span class="lineNum">    5141 </span>            : add_AT_file (dw_die_ref die, enum dwarf_attribute attr_kind,
<span class="lineNum">    5142 </span>            :              struct dwarf_file_data *fd)
<span class="lineNum">    5143 </span>            : {
<span class="lineNum">    5144 </span><span class="lineCov">   32303198 :   dw_attr_node attr;</span>
<span class="lineNum">    5145 </span>            : 
<span class="lineNum">    5146 </span><span class="lineCov">   32303198 :   attr.dw_attr = attr_kind;</span>
<span class="lineNum">    5147 </span><span class="lineCov">   32303198 :   attr.dw_attr_val.val_class = dw_val_class_file;</span>
<span class="lineNum">    5148 </span><span class="lineCov">   32303198 :   attr.dw_attr_val.val_entry = NULL;</span>
<span class="lineNum">    5149 </span><span class="lineCov">   32303198 :   attr.dw_attr_val.v.val_file = fd;</span>
<span class="lineNum">    5150 </span><span class="lineCov">   32303198 :   add_dwarf_attr (die, &amp;attr);</span>
<span class="lineNum">    5151 </span>            : }
<span class="lineNum">    5152 </span>            : 
<span class="lineNum">    5153 </span>            : /* Get the dwarf_file_data from a file DIE attribute.  */
<a name="5154"><span class="lineNum">    5154 </span>            : </a>
<span class="lineNum">    5155 </span>            : static inline struct dwarf_file_data *
<span class="lineNum">    5156 </span><span class="lineCov">    1669220 : AT_file (dw_attr_node *a)</span>
<span class="lineNum">    5157 </span>            : {
<span class="lineNum">    5158 </span><span class="lineCov">    1669220 :   gcc_assert (a &amp;&amp; (AT_class (a) == dw_val_class_file</span>
<span class="lineNum">    5159 </span>            :                     || AT_class (a) == dw_val_class_file_implicit));
<span class="lineNum">    5160 </span><span class="lineCov">    1669220 :   return a-&gt;dw_attr_val.v.val_file;</span>
<span class="lineNum">    5161 </span>            : }
<span class="lineNum">    5162 </span>            : 
<span class="lineNum">    5163 </span>            : /* Add a vms delta attribute value to a DIE.  */
<span class="lineNum">    5164 </span>            : 
<span class="lineNum">    5165 </span>            : static inline void
<span class="lineNum">    5166 </span>            : add_AT_vms_delta (dw_die_ref die, enum dwarf_attribute attr_kind,
<span class="lineNum">    5167 </span>            :                   const char *lbl1, const char *lbl2)
<span class="lineNum">    5168 </span>            : {
<span class="lineNum">    5169 </span>            :   dw_attr_node attr;
<span class="lineNum">    5170 </span>            : 
<span class="lineNum">    5171 </span>            :   attr.dw_attr = attr_kind;
<span class="lineNum">    5172 </span>            :   attr.dw_attr_val.val_class = dw_val_class_vms_delta;
<span class="lineNum">    5173 </span>            :   attr.dw_attr_val.val_entry = NULL;
<span class="lineNum">    5174 </span>            :   attr.dw_attr_val.v.val_vms_delta.lbl1 = xstrdup (lbl1);
<span class="lineNum">    5175 </span>            :   attr.dw_attr_val.v.val_vms_delta.lbl2 = xstrdup (lbl2);
<span class="lineNum">    5176 </span>            :   add_dwarf_attr (die, &amp;attr);
<span class="lineNum">    5177 </span>            : }
<span class="lineNum">    5178 </span>            : 
<span class="lineNum">    5179 </span>            : /* Add a symbolic view identifier attribute value to a DIE.  */
<a name="5180"><span class="lineNum">    5180 </span>            : </a>
<span class="lineNum">    5181 </span>            : static inline void
<span class="lineNum">    5182 </span><span class="lineCov">    3149821 : add_AT_symview (dw_die_ref die, enum dwarf_attribute attr_kind,</span>
<span class="lineNum">    5183 </span>            :                const char *view_label)
<span class="lineNum">    5184 </span>            : {
<span class="lineNum">    5185 </span><span class="lineCov">    3149821 :   dw_attr_node attr;</span>
<span class="lineNum">    5186 </span>            : 
<span class="lineNum">    5187 </span><span class="lineCov">    3149821 :   attr.dw_attr = attr_kind;</span>
<span class="lineNum">    5188 </span><span class="lineCov">    3149821 :   attr.dw_attr_val.val_class = dw_val_class_symview;</span>
<span class="lineNum">    5189 </span><span class="lineCov">    3149821 :   attr.dw_attr_val.val_entry = NULL;</span>
<span class="lineNum">    5190 </span><span class="lineCov">    3149821 :   attr.dw_attr_val.v.val_symbolic_view = xstrdup (view_label);</span>
<span class="lineNum">    5191 </span><span class="lineCov">    3149821 :   add_dwarf_attr (die, &amp;attr);</span>
<span class="lineNum">    5192 </span><span class="lineCov">    3149821 : }</span>
<span class="lineNum">    5193 </span>            : 
<span class="lineNum">    5194 </span>            : /* Add a label identifier attribute value to a DIE.  */
<a name="5195"><span class="lineNum">    5195 </span>            : </a>
<span class="lineNum">    5196 </span>            : static inline void
<span class="lineNum">    5197 </span><span class="lineCov">    5066549 : add_AT_lbl_id (dw_die_ref die, enum dwarf_attribute attr_kind,</span>
<span class="lineNum">    5198 </span>            :                const char *lbl_id)
<span class="lineNum">    5199 </span>            : {
<span class="lineNum">    5200 </span><span class="lineCov">    5066549 :   dw_attr_node attr;</span>
<span class="lineNum">    5201 </span>            : 
<span class="lineNum">    5202 </span><span class="lineCov">    5066549 :   attr.dw_attr = attr_kind;</span>
<span class="lineNum">    5203 </span><span class="lineCov">    5066549 :   attr.dw_attr_val.val_class = dw_val_class_lbl_id;</span>
<span class="lineNum">    5204 </span><span class="lineCov">    5066549 :   attr.dw_attr_val.val_entry = NULL;</span>
<span class="lineNum">    5205 </span><span class="lineCov">    5066549 :   attr.dw_attr_val.v.val_lbl_id = xstrdup (lbl_id);</span>
<span class="lineNum">    5206 </span><span class="lineCov">    5066549 :   if (dwarf_split_debug_info)</span>
<span class="lineNum">    5207 </span><span class="lineCov">         11 :     attr.dw_attr_val.val_entry</span>
<span class="lineNum">    5208 </span><span class="lineCov">         11 :         = add_addr_table_entry (attr.dw_attr_val.v.val_lbl_id,</span>
<span class="lineNum">    5209 </span>            :                                 ate_kind_label);
<span class="lineNum">    5210 </span><span class="lineCov">    5066549 :   add_dwarf_attr (die, &amp;attr);</span>
<span class="lineNum">    5211 </span><span class="lineCov">    5066549 : }</span>
<span class="lineNum">    5212 </span>            : 
<span class="lineNum">    5213 </span>            : /* Add a section offset attribute value to a DIE, an offset into the
<span class="lineNum">    5214 </span>            :    debug_line section.  */
<a name="5215"><span class="lineNum">    5215 </span>            : </a>
<span class="lineNum">    5216 </span>            : static inline void
<span class="lineNum">    5217 </span><span class="lineCov">      34549 : add_AT_lineptr (dw_die_ref die, enum dwarf_attribute attr_kind,</span>
<span class="lineNum">    5218 </span>            :                 const char *label)
<span class="lineNum">    5219 </span>            : {
<span class="lineNum">    5220 </span><span class="lineCov">      34549 :   dw_attr_node attr;</span>
<span class="lineNum">    5221 </span>            : 
<span class="lineNum">    5222 </span><span class="lineCov">      34549 :   attr.dw_attr = attr_kind;</span>
<span class="lineNum">    5223 </span><span class="lineCov">      34549 :   attr.dw_attr_val.val_class = dw_val_class_lineptr;</span>
<span class="lineNum">    5224 </span><span class="lineCov">      34549 :   attr.dw_attr_val.val_entry = NULL;</span>
<span class="lineNum">    5225 </span><span class="lineCov">      34549 :   attr.dw_attr_val.v.val_lbl_id = xstrdup (label);</span>
<span class="lineNum">    5226 </span><span class="lineCov">      34549 :   add_dwarf_attr (die, &amp;attr);</span>
<span class="lineNum">    5227 </span><span class="lineCov">      34549 : }</span>
<span class="lineNum">    5228 </span>            : 
<span class="lineNum">    5229 </span>            : /* Add a section offset attribute value to a DIE, an offset into the
<span class="lineNum">    5230 </span>            :    debug_loclists section.  */
<span class="lineNum">    5231 </span>            : 
<span class="lineNum">    5232 </span>            : static inline void
<span class="lineNum">    5233 </span>            : add_AT_loclistsptr (dw_die_ref die, enum dwarf_attribute attr_kind,
<span class="lineNum">    5234 </span>            :                     const char *label)
<span class="lineNum">    5235 </span>            : {
<span class="lineNum">    5236 </span>            :   dw_attr_node attr;
<span class="lineNum">    5237 </span>            : 
<span class="lineNum">    5238 </span>            :   attr.dw_attr = attr_kind;
<span class="lineNum">    5239 </span>            :   attr.dw_attr_val.val_class = dw_val_class_loclistsptr;
<span class="lineNum">    5240 </span>            :   attr.dw_attr_val.val_entry = NULL;
<span class="lineNum">    5241 </span>            :   attr.dw_attr_val.v.val_lbl_id = xstrdup (label);
<span class="lineNum">    5242 </span>            :   add_dwarf_attr (die, &amp;attr);
<span class="lineNum">    5243 </span>            : }
<span class="lineNum">    5244 </span>            : 
<span class="lineNum">    5245 </span>            : /* Add a section offset attribute value to a DIE, an offset into the
<span class="lineNum">    5246 </span>            :    debug_macinfo section.  */
<a name="5247"><span class="lineNum">    5247 </span>            : </a>
<span class="lineNum">    5248 </span>            : static inline void
<span class="lineNum">    5249 </span><span class="lineCov">        444 : add_AT_macptr (dw_die_ref die, enum dwarf_attribute attr_kind,</span>
<span class="lineNum">    5250 </span>            :                const char *label)
<span class="lineNum">    5251 </span>            : {
<span class="lineNum">    5252 </span><span class="lineCov">        444 :   dw_attr_node attr;</span>
<span class="lineNum">    5253 </span>            : 
<span class="lineNum">    5254 </span><span class="lineCov">        444 :   attr.dw_attr = attr_kind;</span>
<span class="lineNum">    5255 </span><span class="lineCov">        444 :   attr.dw_attr_val.val_class = dw_val_class_macptr;</span>
<span class="lineNum">    5256 </span><span class="lineCov">        444 :   attr.dw_attr_val.val_entry = NULL;</span>
<span class="lineNum">    5257 </span><span class="lineCov">        444 :   attr.dw_attr_val.v.val_lbl_id = xstrdup (label);</span>
<span class="lineNum">    5258 </span><span class="lineCov">        444 :   add_dwarf_attr (die, &amp;attr);</span>
<span class="lineNum">    5259 </span><span class="lineCov">        444 : }</span>
<span class="lineNum">    5260 </span>            : 
<span class="lineNum">    5261 </span>            : /* Add an offset attribute value to a DIE.  */
<span class="lineNum">    5262 </span>            : 
<span class="lineNum">    5263 </span>            : static inline void
<span class="lineNum">    5264 </span>            : add_AT_offset (dw_die_ref die, enum dwarf_attribute attr_kind,
<span class="lineNum">    5265 </span>            :                unsigned HOST_WIDE_INT offset)
<span class="lineNum">    5266 </span>            : {
<span class="lineNum">    5267 </span>            :   dw_attr_node attr;
<span class="lineNum">    5268 </span>            : 
<span class="lineNum">    5269 </span>            :   attr.dw_attr = attr_kind;
<span class="lineNum">    5270 </span>            :   attr.dw_attr_val.val_class = dw_val_class_offset;
<span class="lineNum">    5271 </span>            :   attr.dw_attr_val.val_entry = NULL;
<span class="lineNum">    5272 </span>            :   attr.dw_attr_val.v.val_offset = offset;
<span class="lineNum">    5273 </span>            :   add_dwarf_attr (die, &amp;attr);
<span class="lineNum">    5274 </span>            : }
<span class="lineNum">    5275 </span>            : 
<span class="lineNum">    5276 </span>            : /* Add a range_list attribute value to a DIE.  When using
<span class="lineNum">    5277 </span>            :    dwarf_split_debug_info, address attributes in dies destined for the
<span class="lineNum">    5278 </span>            :    final executable should be direct references--setting the parameter
<span class="lineNum">    5279 </span>            :    force_direct ensures this behavior.  */
<span class="lineNum">    5280 </span>            : 
<span class="lineNum">    5281 </span>            : #define UNRELOCATED_OFFSET ((addr_table_entry *) 1)
<span class="lineNum">    5282 </span>            : #define RELOCATED_OFFSET (NULL)
<a name="5283"><span class="lineNum">    5283 </span>            : </a>
<span class="lineNum">    5284 </span>            : static void
<span class="lineNum">    5285 </span><span class="lineCov">      29753 : add_AT_range_list (dw_die_ref die, enum dwarf_attribute attr_kind,</span>
<span class="lineNum">    5286 </span>            :                    long unsigned int offset, bool force_direct)
<span class="lineNum">    5287 </span>            : {
<span class="lineNum">    5288 </span><span class="lineCov">    1545590 :   dw_attr_node attr;</span>
<span class="lineNum">    5289 </span>            : 
<span class="lineNum">    5290 </span><span class="lineCov">    1545590 :   attr.dw_attr = attr_kind;</span>
<span class="lineNum">    5291 </span><span class="lineCov">    1545590 :   attr.dw_attr_val.val_class = dw_val_class_range_list;</span>
<span class="lineNum">    5292 </span>            :   /* For the range_list attribute, use val_entry to store whether the
<span class="lineNum">    5293 </span>            :      offset should follow split-debug-info or normal semantics.  This
<span class="lineNum">    5294 </span>            :      value is read in output_range_list_offset.  */
<span class="lineNum">    5295 </span><span class="lineCov">      29753 :   if (dwarf_split_debug_info &amp;&amp; !force_direct)</span>
<span class="lineNum">    5296 </span><span class="lineCov">          2 :     attr.dw_attr_val.val_entry = UNRELOCATED_OFFSET;</span>
<span class="lineNum">    5297 </span>            :   else
<span class="lineNum">    5298 </span><span class="lineCov">    1545588 :     attr.dw_attr_val.val_entry = RELOCATED_OFFSET;</span>
<span class="lineNum">    5299 </span><span class="lineCov">    1545590 :   attr.dw_attr_val.v.val_offset = offset;</span>
<span class="lineNum">    5300 </span><span class="lineCov">    1545590 :   add_dwarf_attr (die, &amp;attr);</span>
<span class="lineNum">    5301 </span><span class="lineCov">      29753 : }</span>
<span class="lineNum">    5302 </span>            : 
<span class="lineNum">    5303 </span>            : /* Return the start label of a delta attribute.  */
<span class="lineNum">    5304 </span>            : 
<span class="lineNum">    5305 </span>            : static inline const char *
<span class="lineNum">    5306 </span>            : AT_vms_delta1 (dw_attr_node *a)
<span class="lineNum">    5307 </span>            : {
<span class="lineNum">    5308 </span><span class="lineNoCov">          0 :   gcc_assert (a &amp;&amp; (AT_class (a) == dw_val_class_vms_delta));</span>
<span class="lineNum">    5309 </span><span class="lineNoCov">          0 :   return a-&gt;dw_attr_val.v.val_vms_delta.lbl1;</span>
<span class="lineNum">    5310 </span>            : }
<span class="lineNum">    5311 </span>            : 
<span class="lineNum">    5312 </span>            : /* Return the end label of a delta attribute.  */
<span class="lineNum">    5313 </span>            : 
<span class="lineNum">    5314 </span>            : static inline const char *
<span class="lineNum">    5315 </span>            : AT_vms_delta2 (dw_attr_node *a)
<span class="lineNum">    5316 </span>            : {
<span class="lineNum">    5317 </span><span class="lineNoCov">          0 :   gcc_assert (a &amp;&amp; (AT_class (a) == dw_val_class_vms_delta));</span>
<span class="lineNum">    5318 </span><span class="lineNoCov">          0 :   return a-&gt;dw_attr_val.v.val_vms_delta.lbl2;</span>
<span class="lineNum">    5319 </span>            : }
<a name="5320"><span class="lineNum">    5320 </span>            : </a>
<span class="lineNum">    5321 </span>            : static inline const char *
<span class="lineNum">    5322 </span><span class="lineCov">   13277713 : AT_lbl (dw_attr_node *a)</span>
<span class="lineNum">    5323 </span>            : {
<span class="lineNum">    5324 </span><span class="lineCov">   13277713 :   gcc_assert (a &amp;&amp; (AT_class (a) == dw_val_class_lbl_id</span>
<span class="lineNum">    5325 </span>            :                     || AT_class (a) == dw_val_class_lineptr
<span class="lineNum">    5326 </span>            :                     || AT_class (a) == dw_val_class_macptr
<span class="lineNum">    5327 </span>            :                     || AT_class (a) == dw_val_class_loclistsptr
<span class="lineNum">    5328 </span>            :                     || AT_class (a) == dw_val_class_high_pc));
<span class="lineNum">    5329 </span><span class="lineCov">   13277713 :   return a-&gt;dw_attr_val.v.val_lbl_id;</span>
<span class="lineNum">    5330 </span>            : }
<span class="lineNum">    5331 </span>            : 
<span class="lineNum">    5332 </span>            : /* Get the attribute of type attr_kind.  */
<a name="5333"><span class="lineNum">    5333 </span>            : </a>
<span class="lineNum">    5334 </span>            : static dw_attr_node *
<span class="lineNum">    5335 </span><span class="lineCov">  131606639 : get_AT (dw_die_ref die, enum dwarf_attribute attr_kind)</span>
<span class="lineNum">    5336 </span>            : {
<span class="lineNum">    5337 </span><span class="lineCov">  149035346 :   dw_attr_node *a;</span>
<span class="lineNum">    5338 </span><span class="lineCov">  149035346 :   unsigned ix;</span>
<span class="lineNum">    5339 </span><span class="lineCov">  149035346 :   dw_die_ref spec = NULL;</span>
<span class="lineNum">    5340 </span>            : 
<span class="lineNum">    5341 </span><span class="lineCov">  149035346 :   if (! die)</span>
<span class="lineNum">    5342 </span>            :     return NULL;
<span class="lineNum">    5343 </span>            : 
<span class="lineNum">    5344 </span><span class="lineCov">  480412736 :   FOR_EACH_VEC_SAFE_ELT (die-&gt;die_attr, ix, a)</span>
<span class="lineNum">    5345 </span><span class="lineCov">  423167859 :     if (a-&gt;dw_attr == attr_kind)</span>
<span class="lineNum">    5346 </span><span class="lineCov">   91790469 :       return a;</span>
<span class="lineNum">    5347 </span><span class="lineCov">  331377390 :     else if (a-&gt;dw_attr == DW_AT_specification</span>
<span class="lineNum">    5348 </span><span class="lineCov">  325781090 :              || a-&gt;dw_attr == DW_AT_abstract_origin)</span>
<span class="lineNum">    5349 </span><span class="lineCov">   37265539 :       spec = AT_ref (a);</span>
<span class="lineNum">    5350 </span>            : 
<span class="lineNum">    5351 </span><span class="lineCov">   57244877 :   if (spec)</span>
<span class="lineNum">    5352 </span>            :     return get_AT (spec, attr_kind);
<span class="lineNum">    5353 </span>            : 
<span class="lineNum">    5354 </span>            :   return NULL;
<span class="lineNum">    5355 </span>            : }
<span class="lineNum">    5356 </span>            : 
<span class="lineNum">    5357 </span>            : /* Returns the parent of the declaration of DIE.  */
<a name="5358"><span class="lineNum">    5358 </span>            : </a>
<span class="lineNum">    5359 </span>            : static dw_die_ref
<span class="lineNum">    5360 </span><span class="lineCov">         48 : get_die_parent (dw_die_ref die)</span>
<span class="lineNum">    5361 </span>            : {
<span class="lineNum">    5362 </span><span class="lineCov">         48 :   dw_die_ref t;</span>
<span class="lineNum">    5363 </span>            : 
<span class="lineNum">    5364 </span><span class="lineCov">         48 :   if (!die)</span>
<span class="lineNum">    5365 </span>            :     return NULL;
<span class="lineNum">    5366 </span>            : 
<span class="lineNum">    5367 </span><span class="lineCov">         48 :   if ((t = get_AT_ref (die, DW_AT_abstract_origin))</span>
<span class="lineNum">    5368 </span><span class="lineCov">         48 :       || (t = get_AT_ref (die, DW_AT_specification)))</span>
<span class="lineNum">    5369 </span>            :     die = t;
<span class="lineNum">    5370 </span>            : 
<span class="lineNum">    5371 </span><span class="lineCov">         48 :   return die-&gt;die_parent;</span>
<span class="lineNum">    5372 </span>            : }
<span class="lineNum">    5373 </span>            : 
<span class="lineNum">    5374 </span>            : /* Return the &quot;low pc&quot; attribute value, typically associated with a subprogram
<span class="lineNum">    5375 </span>            :    DIE.  Return null if the &quot;low pc&quot; attribute is either not present, or if it
<span class="lineNum">    5376 </span>            :    cannot be represented as an assembler label identifier.  */
<a name="5377"><span class="lineNum">    5377 </span>            : </a>
<span class="lineNum">    5378 </span>            : static inline const char *
<span class="lineNum">    5379 </span><span class="lineCov">    2722768 : get_AT_low_pc (dw_die_ref die)</span>
<span class="lineNum">    5380 </span>            : {
<span class="lineNum">    5381 </span><span class="lineCov">    2722768 :   dw_attr_node *a = get_AT (die, DW_AT_low_pc);</span>
<span class="lineNum">    5382 </span>            : 
<span class="lineNum">    5383 </span><span class="lineCov">    2722768 :   return a ? AT_lbl (a) : NULL;</span>
<span class="lineNum">    5384 </span>            : }
<span class="lineNum">    5385 </span>            : 
<span class="lineNum">    5386 </span>            : /* Return the &quot;high pc&quot; attribute value, typically associated with a subprogram
<span class="lineNum">    5387 </span>            :    DIE.  Return null if the &quot;high pc&quot; attribute is either not present, or if it
<span class="lineNum">    5388 </span>            :    cannot be represented as an assembler label identifier.  */
<span class="lineNum">    5389 </span>            : 
<span class="lineNum">    5390 </span>            : static inline const char *
<span class="lineNum">    5391 </span>            : get_AT_hi_pc (dw_die_ref die)
<span class="lineNum">    5392 </span>            : {
<span class="lineNum">    5393 </span>            :   dw_attr_node *a = get_AT (die, DW_AT_high_pc);
<span class="lineNum">    5394 </span>            : 
<span class="lineNum">    5395 </span>            :   return a ? AT_lbl (a) : NULL;
<span class="lineNum">    5396 </span>            : }
<span class="lineNum">    5397 </span>            : 
<span class="lineNum">    5398 </span>            : /* Return the value of the string attribute designated by ATTR_KIND, or
<span class="lineNum">    5399 </span>            :    NULL if it is not present.  */
<a name="5400"><span class="lineNum">    5400 </span>            : </a>
<span class="lineNum">    5401 </span>            : static inline const char *
<span class="lineNum">    5402 </span><span class="lineCov">        954 : get_AT_string (dw_die_ref die, enum dwarf_attribute attr_kind)</span>
<span class="lineNum">    5403 </span>            : {
<span class="lineNum">    5404 </span><span class="lineCov">        954 :   dw_attr_node *a = get_AT (die, attr_kind);</span>
<span class="lineNum">    5405 </span>            : 
<span class="lineNum">    5406 </span><span class="lineCov">        954 :   return a ? AT_string (a) : NULL;</span>
<span class="lineNum">    5407 </span>            : }
<span class="lineNum">    5408 </span>            : 
<span class="lineNum">    5409 </span>            : /* Return the value of the flag attribute designated by ATTR_KIND, or -1
<span class="lineNum">    5410 </span>            :    if it is not present.  */
<a name="5411"><span class="lineNum">    5411 </span>            : </a>
<span class="lineNum">    5412 </span>            : static inline int
<span class="lineNum">    5413 </span><span class="lineCov">   12801520 : get_AT_flag (dw_die_ref die, enum dwarf_attribute attr_kind)</span>
<span class="lineNum">    5414 </span>            : {
<span class="lineNum">    5415 </span><span class="lineCov">   12801520 :   dw_attr_node *a = get_AT (die, attr_kind);</span>
<span class="lineNum">    5416 </span>            : 
<span class="lineNum">    5417 </span><span class="lineCov">   12801520 :   return a ? AT_flag (a) : 0;</span>
<span class="lineNum">    5418 </span>            : }
<span class="lineNum">    5419 </span>            : 
<span class="lineNum">    5420 </span>            : /* Return the value of the unsigned attribute designated by ATTR_KIND, or 0
<span class="lineNum">    5421 </span>            :    if it is not present.  */
<a name="5422"><span class="lineNum">    5422 </span>            : </a>
<span class="lineNum">    5423 </span>            : static inline unsigned
<span class="lineNum">    5424 </span><span class="lineCov">   34095385 : get_AT_unsigned (dw_die_ref die, enum dwarf_attribute attr_kind)</span>
<span class="lineNum">    5425 </span>            : {
<span class="lineNum">    5426 </span><span class="lineCov">   34095385 :   dw_attr_node *a = get_AT (die, attr_kind);</span>
<span class="lineNum">    5427 </span>            : 
<span class="lineNum">    5428 </span><span class="lineCov">   34095385 :   return a ? AT_unsigned (a) : 0;</span>
<span class="lineNum">    5429 </span>            : }
<a name="5430"><span class="lineNum">    5430 </span>            : </a>
<span class="lineNum">    5431 </span>            : static inline dw_die_ref
<span class="lineNum">    5432 </span><span class="lineCov">    6773120 : get_AT_ref (dw_die_ref die, enum dwarf_attribute attr_kind)</span>
<span class="lineNum">    5433 </span>            : {
<span class="lineNum">    5434 </span><span class="lineCov">    6773120 :   dw_attr_node *a = get_AT (die, attr_kind);</span>
<span class="lineNum">    5435 </span>            : 
<span class="lineNum">    5436 </span><span class="lineCov">    6773120 :   return a ? AT_ref (a) : NULL;</span>
<span class="lineNum">    5437 </span>            : }
<a name="5438"><span class="lineNum">    5438 </span>            : </a>
<span class="lineNum">    5439 </span>            : static inline struct dwarf_file_data *
<span class="lineNum">    5440 </span><span class="lineCov">    1620223 : get_AT_file (dw_die_ref die, enum dwarf_attribute attr_kind)</span>
<span class="lineNum">    5441 </span>            : {
<span class="lineNum">    5442 </span><span class="lineCov">    1620223 :   dw_attr_node *a = get_AT (die, attr_kind);</span>
<span class="lineNum">    5443 </span>            : 
<span class="lineNum">    5444 </span><span class="lineCov">    1620223 :   return a ? AT_file (a) : NULL;</span>
<span class="lineNum">    5445 </span>            : }
<span class="lineNum">    5446 </span>            : 
<span class="lineNum">    5447 </span>            : /* Return TRUE if the language is C.  */
<a name="5448"><span class="lineNum">    5448 </span>            : </a>
<span class="lineNum">    5449 </span>            : static inline bool
<span class="lineNum">    5450 </span><span class="lineCov">       4047 : is_c (void)</span>
<span class="lineNum">    5451 </span>            : {
<span class="lineNum">    5452 </span><span class="lineCov">       4047 :   unsigned int lang = get_AT_unsigned (comp_unit_die (), DW_AT_language);</span>
<span class="lineNum">    5453 </span>            : 
<span class="lineNum">    5454 </span><span class="lineCov">       4047 :   return (lang == DW_LANG_C || lang == DW_LANG_C89 || lang == DW_LANG_C99</span>
<span class="lineNum">    5455 </span><span class="lineCov">       4047 :           || lang == DW_LANG_C11 || lang == DW_LANG_ObjC);</span>
<span class="lineNum">    5456 </span>            : 
<span class="lineNum">    5457 </span>            : 
<span class="lineNum">    5458 </span>            : }
<span class="lineNum">    5459 </span>            : 
<span class="lineNum">    5460 </span>            : /* Return TRUE if the language is C++.  */
<a name="5461"><span class="lineNum">    5461 </span>            : </a>
<span class="lineNum">    5462 </span>            : static inline bool
<span class="lineNum">    5463 </span><span class="lineCov">    4315240 : is_cxx (void)</span>
<span class="lineNum">    5464 </span>            : {
<span class="lineNum">    5465 </span><span class="lineCov">    4315240 :   unsigned int lang = get_AT_unsigned (comp_unit_die (), DW_AT_language);</span>
<span class="lineNum">    5466 </span>            : 
<span class="lineNum">    5467 </span><span class="lineCov">    4315240 :   return (lang == DW_LANG_C_plus_plus || lang == DW_LANG_ObjC_plus_plus</span>
<span class="lineNum">    5468 </span><span class="lineCov">    4315240 :           || lang == DW_LANG_C_plus_plus_11 || lang == DW_LANG_C_plus_plus_14);</span>
<span class="lineNum">    5469 </span>            : }
<span class="lineNum">    5470 </span>            : 
<span class="lineNum">    5471 </span>            : /* Return TRUE if DECL was created by the C++ frontend.  */
<a name="5472"><span class="lineNum">    5472 </span>            : </a>
<span class="lineNum">    5473 </span>            : static bool
<span class="lineNum">    5474 </span><span class="lineCov">    3534207 : is_cxx (const_tree decl)</span>
<span class="lineNum">    5475 </span>            : {
<span class="lineNum">    5476 </span><span class="lineCov">    3534207 :   if (in_lto_p)</span>
<span class="lineNum">    5477 </span>            :     {
<span class="lineNum">    5478 </span><span class="lineCov">         45 :       const_tree context = get_ultimate_context (decl);</span>
<span class="lineNum">    5479 </span><span class="lineCov">         45 :       if (context &amp;&amp; TRANSLATION_UNIT_LANGUAGE (context))</span>
<span class="lineNum">    5480 </span><span class="lineCov">         90 :         return strncmp (TRANSLATION_UNIT_LANGUAGE (context), &quot;GNU C++&quot;, 7) == 0;</span>
<span class="lineNum">    5481 </span>            :     }
<span class="lineNum">    5482 </span><span class="lineCov">    3534162 :   return is_cxx ();</span>
<span class="lineNum">    5483 </span>            : }
<span class="lineNum">    5484 </span>            : 
<span class="lineNum">    5485 </span>            : /* Return TRUE if the language is Fortran.  */
<a name="5486"><span class="lineNum">    5486 </span>            : </a>
<span class="lineNum">    5487 </span>            : static inline bool
<span class="lineNum">    5488 </span><span class="lineCov">   18417173 : is_fortran (void)</span>
<span class="lineNum">    5489 </span>            : {
<span class="lineNum">    5490 </span><span class="lineCov">   18417173 :   unsigned int lang = get_AT_unsigned (comp_unit_die (), DW_AT_language);</span>
<span class="lineNum">    5491 </span>            : 
<span class="lineNum">    5492 </span><span class="lineCov">   18417173 :   return (lang == DW_LANG_Fortran77</span>
<span class="lineNum">    5493 </span><span class="lineCov">   18417173 :           || lang == DW_LANG_Fortran90</span>
<span class="lineNum">    5494 </span><span class="lineCov">   18417173 :           || lang == DW_LANG_Fortran95</span>
<span class="lineNum">    5495 </span>            :           || lang == DW_LANG_Fortran03
<span class="lineNum">    5496 </span><span class="lineCov">   18417173 :           || lang == DW_LANG_Fortran08);</span>
<span class="lineNum">    5497 </span>            : }
<a name="5498"><span class="lineNum">    5498 </span>            : </a>
<span class="lineNum">    5499 </span>            : static inline bool
<span class="lineNum">    5500 </span><span class="lineCov">        172 : is_fortran (const_tree decl)</span>
<span class="lineNum">    5501 </span>            : {
<span class="lineNum">    5502 </span><span class="lineCov">        172 :   if (in_lto_p)</span>
<span class="lineNum">    5503 </span>            :     {
<span class="lineNum">    5504 </span><span class="lineCov">        172 :       const_tree context = get_ultimate_context (decl);</span>
<span class="lineNum">    5505 </span><span class="lineCov">        172 :       if (context &amp;&amp; TRANSLATION_UNIT_LANGUAGE (context))</span>
<span class="lineNum">    5506 </span><span class="lineCov">        172 :         return (strncmp (TRANSLATION_UNIT_LANGUAGE (context),</span>
<span class="lineNum">    5507 </span>            :                          &quot;GNU Fortran&quot;, 11) == 0
<span class="lineNum">    5508 </span><span class="lineCov">        172 :                 || strcmp (TRANSLATION_UNIT_LANGUAGE (context),</span>
<span class="lineNum">    5509 </span>            :                            &quot;GNU F77&quot;) == 0);
<span class="lineNum">    5510 </span>            :     }
<span class="lineNum">    5511 </span><span class="lineNoCov">          0 :   return is_fortran ();</span>
<span class="lineNum">    5512 </span>            : }
<span class="lineNum">    5513 </span>            : 
<span class="lineNum">    5514 </span>            : /* Return TRUE if the language is Ada.  */
<a name="5515"><span class="lineNum">    5515 </span>            : </a>
<span class="lineNum">    5516 </span>            : static inline bool
<span class="lineNum">    5517 </span><span class="lineCov">     645962 : is_ada (void)</span>
<span class="lineNum">    5518 </span>            : {
<span class="lineNum">    5519 </span><span class="lineCov">     645962 :   unsigned int lang = get_AT_unsigned (comp_unit_die (), DW_AT_language);</span>
<span class="lineNum">    5520 </span>            : 
<span class="lineNum">    5521 </span><span class="lineCov">     645962 :   return lang == DW_LANG_Ada95 || lang == DW_LANG_Ada83;</span>
<span class="lineNum">    5522 </span>            : }
<span class="lineNum">    5523 </span>            : 
<span class="lineNum">    5524 </span>            : /* Remove the specified attribute if present.  Return TRUE if removal
<span class="lineNum">    5525 </span>            :    was successful.  */
<a name="5526"><span class="lineNum">    5526 </span>            : </a>
<span class="lineNum">    5527 </span>            : static bool
<span class="lineNum">    5528 </span><span class="lineCov">    9766747 : remove_AT (dw_die_ref die, enum dwarf_attribute attr_kind)</span>
<span class="lineNum">    5529 </span>            : {
<span class="lineNum">    5530 </span><span class="lineCov">    9766747 :   dw_attr_node *a;</span>
<span class="lineNum">    5531 </span><span class="lineCov">    9766747 :   unsigned ix;</span>
<span class="lineNum">    5532 </span>            : 
<span class="lineNum">    5533 </span><span class="lineCov">    9766747 :   if (! die)</span>
<span class="lineNum">    5534 </span>            :     return false;
<span class="lineNum">    5535 </span>            : 
<span class="lineNum">    5536 </span><span class="lineCov">   20688332 :   FOR_EACH_VEC_SAFE_ELT (die-&gt;die_attr, ix, a)</span>
<span class="lineNum">    5537 </span><span class="lineCov">   20380037 :     if (a-&gt;dw_attr == attr_kind)</span>
<span class="lineNum">    5538 </span>            :       {
<span class="lineNum">    5539 </span><span class="lineCov">    9458452 :         if (AT_class (a) == dw_val_class_str)</span>
<span class="lineNum">    5540 </span><span class="lineCov">          4 :           if (a-&gt;dw_attr_val.v.val_str-&gt;refcount)</span>
<span class="lineNum">    5541 </span><span class="lineCov">          4 :             a-&gt;dw_attr_val.v.val_str-&gt;refcount--;</span>
<span class="lineNum">    5542 </span>            : 
<span class="lineNum">    5543 </span>            :         /* vec::ordered_remove should help reduce the number of abbrevs
<span class="lineNum">    5544 </span>            :            that are needed.  */
<span class="lineNum">    5545 </span><span class="lineCov">    9458452 :         die-&gt;die_attr-&gt;ordered_remove (ix);</span>
<span class="lineNum">    5546 </span><span class="lineCov">    9458452 :         return true;</span>
<span class="lineNum">    5547 </span>            :       }
<span class="lineNum">    5548 </span>            :   return false;
<span class="lineNum">    5549 </span>            : }
<span class="lineNum">    5550 </span>            : 
<span class="lineNum">    5551 </span>            : /* Remove CHILD from its parent.  PREV must have the property that
<span class="lineNum">    5552 </span>            :    PREV-&gt;DIE_SIB == CHILD.  Does not alter CHILD.  */
<a name="5553"><span class="lineNum">    5553 </span>            : </a>
<span class="lineNum">    5554 </span>            : static void
<span class="lineNum">    5555 </span><span class="lineCov">     247322 : remove_child_with_prev (dw_die_ref child, dw_die_ref prev)</span>
<span class="lineNum">    5556 </span>            : {
<span class="lineNum">    5557 </span><span class="lineCov">     247322 :   gcc_assert (child-&gt;die_parent == prev-&gt;die_parent);</span>
<span class="lineNum">    5558 </span><span class="lineCov">     247322 :   gcc_assert (prev-&gt;die_sib == child);</span>
<span class="lineNum">    5559 </span><span class="lineCov">     247322 :   if (prev == child)</span>
<span class="lineNum">    5560 </span>            :     {
<span class="lineNum">    5561 </span><span class="lineCov">       2435 :       gcc_assert (child-&gt;die_parent-&gt;die_child == child);</span>
<span class="lineNum">    5562 </span>            :       prev = NULL;
<span class="lineNum">    5563 </span>            :     }
<span class="lineNum">    5564 </span>            :   else
<span class="lineNum">    5565 </span><span class="lineCov">     244887 :     prev-&gt;die_sib = child-&gt;die_sib;</span>
<span class="lineNum">    5566 </span><span class="lineCov">     247322 :   if (child-&gt;die_parent-&gt;die_child == child)</span>
<span class="lineNum">    5567 </span><span class="lineCov">       3593 :     child-&gt;die_parent-&gt;die_child = prev;</span>
<span class="lineNum">    5568 </span><span class="lineCov">     247322 :   child-&gt;die_sib = NULL;</span>
<span class="lineNum">    5569 </span><span class="lineCov">     247322 : }</span>
<span class="lineNum">    5570 </span>            : 
<span class="lineNum">    5571 </span>            : /* Replace OLD_CHILD with NEW_CHILD.  PREV must have the property that
<span class="lineNum">    5572 </span>            :    PREV-&gt;DIE_SIB == OLD_CHILD.  Does not alter OLD_CHILD.  */
<a name="5573"><span class="lineNum">    5573 </span>            : </a>
<span class="lineNum">    5574 </span>            : static void
<span class="lineNum">    5575 </span><span class="lineCov">         98 : replace_child (dw_die_ref old_child, dw_die_ref new_child, dw_die_ref prev)</span>
<span class="lineNum">    5576 </span>            : {
<span class="lineNum">    5577 </span><span class="lineCov">         98 :   dw_die_ref parent = old_child-&gt;die_parent;</span>
<span class="lineNum">    5578 </span>            : 
<span class="lineNum">    5579 </span><span class="lineCov">         98 :   gcc_assert (parent == prev-&gt;die_parent);</span>
<span class="lineNum">    5580 </span><span class="lineCov">         98 :   gcc_assert (prev-&gt;die_sib == old_child);</span>
<span class="lineNum">    5581 </span>            : 
<span class="lineNum">    5582 </span><span class="lineCov">         98 :   new_child-&gt;die_parent = parent;</span>
<span class="lineNum">    5583 </span><span class="lineCov">         98 :   if (prev == old_child)</span>
<span class="lineNum">    5584 </span>            :     {
<span class="lineNum">    5585 </span><span class="lineCov">         12 :       gcc_assert (parent-&gt;die_child == old_child);</span>
<span class="lineNum">    5586 </span><span class="lineCov">         12 :       new_child-&gt;die_sib = new_child;</span>
<span class="lineNum">    5587 </span>            :     }
<span class="lineNum">    5588 </span>            :   else
<span class="lineNum">    5589 </span>            :     {
<span class="lineNum">    5590 </span><span class="lineCov">         86 :       prev-&gt;die_sib = new_child;</span>
<span class="lineNum">    5591 </span><span class="lineCov">         86 :       new_child-&gt;die_sib = old_child-&gt;die_sib;</span>
<span class="lineNum">    5592 </span>            :     }
<span class="lineNum">    5593 </span><span class="lineCov">         98 :   if (old_child-&gt;die_parent-&gt;die_child == old_child)</span>
<span class="lineNum">    5594 </span><span class="lineCov">         17 :     old_child-&gt;die_parent-&gt;die_child = new_child;</span>
<span class="lineNum">    5595 </span><span class="lineCov">         98 :   old_child-&gt;die_sib = NULL;</span>
<span class="lineNum">    5596 </span><span class="lineCov">         98 : }</span>
<span class="lineNum">    5597 </span>            : 
<span class="lineNum">    5598 </span>            : /* Move all children from OLD_PARENT to NEW_PARENT.  */
<a name="5599"><span class="lineNum">    5599 </span>            : </a>
<span class="lineNum">    5600 </span>            : static void
<span class="lineNum">    5601 </span><span class="lineNoCov">          0 : move_all_children (dw_die_ref old_parent, dw_die_ref new_parent)</span>
<span class="lineNum">    5602 </span>            : {
<span class="lineNum">    5603 </span><span class="lineCov">         55 :   dw_die_ref c;</span>
<span class="lineNum">    5604 </span><span class="lineCov">         55 :   new_parent-&gt;die_child = old_parent-&gt;die_child;</span>
<span class="lineNum">    5605 </span><span class="lineCov">         55 :   old_parent-&gt;die_child = NULL;</span>
<span class="lineNum">    5606 </span><span class="lineCov">         81 :   FOR_EACH_CHILD (new_parent, c, c-&gt;die_parent = new_parent);</span>
<span class="lineNum">    5607 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    5608 </span>            : 
<span class="lineNum">    5609 </span>            : /* Remove child DIE whose die_tag is TAG.  Do nothing if no child
<span class="lineNum">    5610 </span>            :    matches TAG.  */
<a name="5611"><span class="lineNum">    5611 </span>            : </a>
<span class="lineNum">    5612 </span>            : static void
<span class="lineNum">    5613 </span><span class="lineCov">       6252 : remove_child_TAG (dw_die_ref die, enum dwarf_tag tag)</span>
<span class="lineNum">    5614 </span>            : {
<span class="lineNum">    5615 </span><span class="lineCov">       6252 :   dw_die_ref c;</span>
<span class="lineNum">    5616 </span>            : 
<span class="lineNum">    5617 </span><span class="lineCov">       6252 :   c = die-&gt;die_child;</span>
<span class="lineNum">    5618 </span><span class="lineCov">       6252 :   if (c) do {</span>
<span class="lineNum">    5619 </span><span class="lineCov">       7378 :     dw_die_ref prev = c;</span>
<span class="lineNum">    5620 </span><span class="lineCov">       7378 :     c = c-&gt;die_sib;</span>
<span class="lineNum">    5621 </span><span class="lineCov">      13434 :     while (c-&gt;die_tag == tag)</span>
<span class="lineNum">    5622 </span>            :       {
<span class="lineNum">    5623 </span><span class="lineCov">       8490 :         remove_child_with_prev (c, prev);</span>
<span class="lineNum">    5624 </span><span class="lineCov">       8490 :         c-&gt;die_parent = NULL;</span>
<span class="lineNum">    5625 </span>            :         /* Might have removed every child.  */
<span class="lineNum">    5626 </span><span class="lineCov">       8490 :         if (die-&gt;die_child == NULL)</span>
<span class="lineNum">    5627 </span>            :           return;
<span class="lineNum">    5628 </span><span class="lineCov">       6056 :         c = prev-&gt;die_sib;</span>
<span class="lineNum">    5629 </span>            :       }
<span class="lineNum">    5630 </span><span class="lineCov">       4944 :   } while (c != die-&gt;die_child);</span>
<span class="lineNum">    5631 </span>            : }
<span class="lineNum">    5632 </span>            : 
<span class="lineNum">    5633 </span>            : /* Add a CHILD_DIE as the last child of DIE.  */
<a name="5634"><span class="lineNum">    5634 </span>            : </a>
<span class="lineNum">    5635 </span>            : static void
<span class="lineNum">    5636 </span><span class="lineCov">   93071169 : add_child_die (dw_die_ref die, dw_die_ref child_die)</span>
<span class="lineNum">    5637 </span>            : {
<span class="lineNum">    5638 </span>            :   /* FIXME this should probably be an assert.  */
<span class="lineNum">    5639 </span><span class="lineCov">   93071169 :   if (! die || ! child_die)</span>
<span class="lineNum">    5640 </span>            :     return;
<span class="lineNum">    5641 </span><span class="lineCov">   93070345 :   gcc_assert (die != child_die);</span>
<span class="lineNum">    5642 </span>            : 
<span class="lineNum">    5643 </span><span class="lineCov">   93070345 :   child_die-&gt;die_parent = die;</span>
<span class="lineNum">    5644 </span><span class="lineCov">   93070345 :   if (die-&gt;die_child)</span>
<span class="lineNum">    5645 </span>            :     {
<span class="lineNum">    5646 </span><span class="lineCov">   70758158 :       child_die-&gt;die_sib = die-&gt;die_child-&gt;die_sib;</span>
<span class="lineNum">    5647 </span><span class="lineCov">   70758158 :       die-&gt;die_child-&gt;die_sib = child_die;</span>
<span class="lineNum">    5648 </span>            :     }
<span class="lineNum">    5649 </span>            :   else
<span class="lineNum">    5650 </span><span class="lineCov">   22312187 :     child_die-&gt;die_sib = child_die;</span>
<span class="lineNum">    5651 </span><span class="lineCov">   93070345 :   die-&gt;die_child = child_die;</span>
<span class="lineNum">    5652 </span>            : }
<span class="lineNum">    5653 </span>            : 
<span class="lineNum">    5654 </span>            : /* Like add_child_die, but put CHILD_DIE after AFTER_DIE.  */
<a name="5655"><span class="lineNum">    5655 </span>            : </a>
<span class="lineNum">    5656 </span>            : static void
<span class="lineNum">    5657 </span><span class="lineCov">     974220 : add_child_die_after (dw_die_ref die, dw_die_ref child_die,</span>
<span class="lineNum">    5658 </span>            :                      dw_die_ref after_die)
<span class="lineNum">    5659 </span>            : {
<span class="lineNum">    5660 </span><span class="lineCov">     974220 :   gcc_assert (die</span>
<span class="lineNum">    5661 </span>            :               &amp;&amp; child_die
<span class="lineNum">    5662 </span>            :               &amp;&amp; after_die
<span class="lineNum">    5663 </span>            :               &amp;&amp; die-&gt;die_child
<span class="lineNum">    5664 </span>            :               &amp;&amp; die != child_die);
<span class="lineNum">    5665 </span>            : 
<span class="lineNum">    5666 </span><span class="lineCov">     974220 :   child_die-&gt;die_parent = die;</span>
<span class="lineNum">    5667 </span><span class="lineCov">     974220 :   child_die-&gt;die_sib = after_die-&gt;die_sib;</span>
<span class="lineNum">    5668 </span><span class="lineCov">     974220 :   after_die-&gt;die_sib = child_die;</span>
<span class="lineNum">    5669 </span><span class="lineCov">     974220 :   if (die-&gt;die_child == after_die)</span>
<span class="lineNum">    5670 </span><span class="lineCov">     433224 :     die-&gt;die_child = child_die;</span>
<span class="lineNum">    5671 </span><span class="lineCov">     974220 : }</span>
<span class="lineNum">    5672 </span>            : 
<span class="lineNum">    5673 </span>            : /* Unassociate CHILD from its parent, and make its parent be
<span class="lineNum">    5674 </span>            :    NEW_PARENT.  */
<a name="5675"><span class="lineNum">    5675 </span>            : </a>
<span class="lineNum">    5676 </span>            : static void
<span class="lineNum">    5677 </span><span class="lineCov">     233977 : reparent_child (dw_die_ref child, dw_die_ref new_parent)</span>
<span class="lineNum">    5678 </span>            : {
<span class="lineNum">    5679 </span><span class="lineCov">     233977 :   for (dw_die_ref p = child-&gt;die_parent-&gt;die_child; ; p = p-&gt;die_sib)</span>
<span class="lineNum">    5680 </span><span class="lineCov">  125121524 :     if (p-&gt;die_sib == child)</span>
<span class="lineNum">    5681 </span>            :       {
<span class="lineNum">    5682 </span><span class="lineCov">     233977 :         remove_child_with_prev (child, p);</span>
<span class="lineNum">    5683 </span><span class="lineCov">     233977 :         break;</span>
<span class="lineNum">    5684 </span>            :       }
<span class="lineNum">    5685 </span><span class="lineCov">     233977 :   add_child_die (new_parent, child);</span>
<span class="lineNum">    5686 </span><span class="lineCov">     233977 : }</span>
<span class="lineNum">    5687 </span>            : 
<span class="lineNum">    5688 </span>            : /* Move CHILD, which must be a child of PARENT or the DIE for which PARENT
<span class="lineNum">    5689 </span>            :    is the specification, to the end of PARENT's list of children.
<span class="lineNum">    5690 </span>            :    This is done by removing and re-adding it.  */
<a name="5691"><span class="lineNum">    5691 </span>            : </a>
<span class="lineNum">    5692 </span>            : static void
<span class="lineNum">    5693 </span><span class="lineCov">        427 : splice_child_die (dw_die_ref parent, dw_die_ref child)</span>
<span class="lineNum">    5694 </span>            : {
<span class="lineNum">    5695 </span>            :   /* We want the declaration DIE from inside the class, not the
<span class="lineNum">    5696 </span>            :      specification DIE at toplevel.  */
<span class="lineNum">    5697 </span><span class="lineCov">        427 :   if (child-&gt;die_parent != parent)</span>
<span class="lineNum">    5698 </span>            :     {
<span class="lineNum">    5699 </span><span class="lineCov">        231 :       dw_die_ref tmp = get_AT_ref (child, DW_AT_specification);</span>
<span class="lineNum">    5700 </span>            : 
<span class="lineNum">    5701 </span><span class="lineCov">        231 :       if (tmp)</span>
<span class="lineNum">    5702 </span><span class="lineCov">        231 :         child = tmp;</span>
<span class="lineNum">    5703 </span>            :     }
<span class="lineNum">    5704 </span>            : 
<span class="lineNum">    5705 </span><span class="lineCov">        427 :   gcc_assert (child-&gt;die_parent == parent</span>
<span class="lineNum">    5706 </span>            :               || (child-&gt;die_parent
<span class="lineNum">    5707 </span>            :                   == get_AT_ref (parent, DW_AT_specification)));
<span class="lineNum">    5708 </span>            : 
<span class="lineNum">    5709 </span><span class="lineCov">        427 :   reparent_child (child, parent);</span>
<span class="lineNum">    5710 </span><span class="lineCov">        427 : }</span>
<span class="lineNum">    5711 </span>            : 
<span class="lineNum">    5712 </span>            : /* Create and return a new die with TAG_VALUE as tag.  */
<span class="lineNum">    5713 </span>            :  
<span class="lineNum">    5714 </span>            : static inline dw_die_ref
<span class="lineNum">    5715 </span>            : new_die_raw (enum dwarf_tag tag_value)
<span class="lineNum">    5716 </span>            : {
<span class="lineNum">    5717 </span><span class="lineCov">  187759564 :   dw_die_ref die = ggc_cleared_alloc&lt;die_node&gt; ();</span>
<span class="lineNum">    5718 </span><span class="lineCov">   93879782 :   die-&gt;die_tag = tag_value;</span>
<span class="lineNum">    5719 </span><span class="lineCov">   93879782 :   return die;</span>
<span class="lineNum">    5720 </span>            : }
<span class="lineNum">    5721 </span>            : 
<span class="lineNum">    5722 </span>            : /* Create and return a new die with a parent of PARENT_DIE.  If
<span class="lineNum">    5723 </span>            :    PARENT_DIE is NULL, the new DIE is placed in limbo and an
<span class="lineNum">    5724 </span>            :    associated tree T must be supplied to determine parenthood
<span class="lineNum">    5725 </span>            :    later.  */
<a name="5726"><span class="lineNum">    5726 </span>            : </a>
<span class="lineNum">    5727 </span>            : static inline dw_die_ref
<span class="lineNum">    5728 </span><span class="lineCov">   92679328 : new_die (enum dwarf_tag tag_value, dw_die_ref parent_die, tree t)</span>
<span class="lineNum">    5729 </span>            : {
<span class="lineNum">    5730 </span><span class="lineCov">   92679328 :   dw_die_ref die = new_die_raw (tag_value);</span>
<span class="lineNum">    5731 </span>            : 
<span class="lineNum">    5732 </span><span class="lineCov">   92679328 :   if (parent_die != NULL)</span>
<span class="lineNum">    5733 </span><span class="lineCov">   92636203 :     add_child_die (parent_die, die);</span>
<span class="lineNum">    5734 </span>            :   else
<span class="lineNum">    5735 </span>            :     {
<span class="lineNum">    5736 </span><span class="lineCov">      43125 :       limbo_die_node *limbo_node;</span>
<span class="lineNum">    5737 </span>            : 
<span class="lineNum">    5738 </span>            :       /* No DIEs created after early dwarf should end up in limbo,
<span class="lineNum">    5739 </span>            :          because the limbo list should not persist past LTO
<span class="lineNum">    5740 </span>            :          streaming.  */
<span class="lineNum">    5741 </span><span class="lineCov">      43125 :       if (tag_value != DW_TAG_compile_unit</span>
<span class="lineNum">    5742 </span>            :           /* These are allowed because they're generated while
<span class="lineNum">    5743 </span>            :              breaking out COMDAT units late.  */
<span class="lineNum">    5744 </span><span class="lineCov">      43125 :           &amp;&amp; tag_value != DW_TAG_type_unit</span>
<span class="lineNum">    5745 </span><span class="lineCov">       5568 :           &amp;&amp; tag_value != DW_TAG_skeleton_unit</span>
<span class="lineNum">    5746 </span><span class="lineCov">       5568 :           &amp;&amp; !early_dwarf</span>
<span class="lineNum">    5747 </span>            :           /* Allow nested functions to live in limbo because they will
<span class="lineNum">    5748 </span>            :              only temporarily live there, as decls_for_scope will fix
<span class="lineNum">    5749 </span>            :              them up.  */
<span class="lineNum">    5750 </span><span class="lineCov">       2765 :           &amp;&amp; (TREE_CODE (t) != FUNCTION_DECL</span>
<span class="lineNum">    5751 </span><span class="lineNoCov">          0 :               || !decl_function_context (t))</span>
<span class="lineNum">    5752 </span>            :           /* Same as nested functions above but for types.  Types that
<span class="lineNum">    5753 </span>            :              are local to a function will be fixed in
<span class="lineNum">    5754 </span>            :              decls_for_scope.  */
<span class="lineNum">    5755 </span><span class="lineCov">       2765 :           &amp;&amp; (!RECORD_OR_UNION_TYPE_P (t)</span>
<span class="lineNum">    5756 </span><span class="lineNoCov">          0 :               || !TYPE_CONTEXT (t)</span>
<span class="lineNum">    5757 </span><span class="lineNoCov">          0 :               || TREE_CODE (TYPE_CONTEXT (t)) != FUNCTION_DECL)</span>
<span class="lineNum">    5758 </span>            :           /* FIXME debug-early: Allow late limbo DIE creation for LTO,
<span class="lineNum">    5759 </span>            :              especially in the ltrans stage, but once we implement LTO
<span class="lineNum">    5760 </span>            :              dwarf streaming, we should remove this exception.  */
<span class="lineNum">    5761 </span><span class="lineCov">      45890 :           &amp;&amp; !in_lto_p)</span>
<span class="lineNum">    5762 </span>            :         {
<span class="lineNum">    5763 </span><span class="lineNoCov">          0 :           fprintf (stderr, &quot;symbol ended up in limbo too late:&quot;);</span>
<span class="lineNum">    5764 </span><span class="lineNoCov">          0 :           debug_generic_stmt (t);</span>
<span class="lineNum">    5765 </span><span class="lineNoCov">          0 :           gcc_unreachable ();</span>
<span class="lineNum">    5766 </span>            :         }
<span class="lineNum">    5767 </span>            : 
<span class="lineNum">    5768 </span><span class="lineCov">      43125 :       limbo_node = ggc_cleared_alloc&lt;limbo_die_node&gt; ();</span>
<span class="lineNum">    5769 </span><span class="lineCov">      43125 :       limbo_node-&gt;die = die;</span>
<span class="lineNum">    5770 </span><span class="lineCov">      43125 :       limbo_node-&gt;created_for = t;</span>
<span class="lineNum">    5771 </span><span class="lineCov">      43125 :       limbo_node-&gt;next = limbo_die_list;</span>
<span class="lineNum">    5772 </span><span class="lineCov">      43125 :       limbo_die_list = limbo_node;</span>
<span class="lineNum">    5773 </span>            :     }
<span class="lineNum">    5774 </span>            : 
<span class="lineNum">    5775 </span><span class="lineCov">   92679328 :   return die;</span>
<span class="lineNum">    5776 </span>            : }
<span class="lineNum">    5777 </span>            : 
<span class="lineNum">    5778 </span>            : /* Return the DIE associated with the given type specifier.  */
<a name="5779"><span class="lineNum">    5779 </span>            : </a>
<span class="lineNum">    5780 </span>            : static inline dw_die_ref
<span class="lineNum">    5781 </span><span class="lineCov">  211727080 : lookup_type_die (tree type)</span>
<span class="lineNum">    5782 </span>            : {
<span class="lineNum">    5783 </span><span class="lineCov">  211727080 :   dw_die_ref die = TYPE_SYMTAB_DIE (type);</span>
<span class="lineNum">    5784 </span><span class="lineCov">  211727080 :   if (die &amp;&amp; die-&gt;removed)</span>
<span class="lineNum">    5785 </span>            :     {
<span class="lineNum">    5786 </span><span class="lineCov">        567 :       TYPE_SYMTAB_DIE (type) = NULL;</span>
<span class="lineNum">    5787 </span><span class="lineCov">        567 :       return NULL;</span>
<span class="lineNum">    5788 </span>            :     }
<span class="lineNum">    5789 </span>            :   return die;
<span class="lineNum">    5790 </span>            : }
<span class="lineNum">    5791 </span>            : 
<span class="lineNum">    5792 </span>            : /* Given a TYPE_DIE representing the type TYPE, if TYPE is an
<span class="lineNum">    5793 </span>            :    anonymous type named by the typedef TYPE_DIE, return the DIE of the
<span class="lineNum">    5794 </span>            :    anonymous type instead the one of the naming typedef.  */
<a name="5795"><span class="lineNum">    5795 </span>            : </a>
<span class="lineNum">    5796 </span>            : static inline dw_die_ref
<span class="lineNum">    5797 </span><span class="lineCov">    1923322 : strip_naming_typedef (tree type, dw_die_ref type_die)</span>
<span class="lineNum">    5798 </span>            : {
<span class="lineNum">    5799 </span><span class="lineCov">    1923322 :   if (type</span>
<span class="lineNum">    5800 </span><span class="lineCov">    1923322 :       &amp;&amp; TREE_CODE (type) == RECORD_TYPE</span>
<span class="lineNum">    5801 </span><span class="lineCov">    1897800 :       &amp;&amp; type_die</span>
<span class="lineNum">    5802 </span><span class="lineCov">    1897800 :       &amp;&amp; type_die-&gt;die_tag == DW_TAG_typedef</span>
<span class="lineNum">    5803 </span><span class="lineCov">    1923338 :       &amp;&amp; is_naming_typedef_decl (TYPE_NAME (type)))</span>
<span class="lineNum">    5804 </span><span class="lineCov">         16 :     type_die = get_AT_ref (type_die, DW_AT_type);</span>
<span class="lineNum">    5805 </span><span class="lineCov">    1923322 :   return type_die;</span>
<span class="lineNum">    5806 </span>            : }
<span class="lineNum">    5807 </span>            : 
<span class="lineNum">    5808 </span>            : /* Like lookup_type_die, but if type is an anonymous type named by a
<span class="lineNum">    5809 </span>            :    typedef[1], return the DIE of the anonymous type instead the one of
<span class="lineNum">    5810 </span>            :    the naming typedef.  This is because in gen_typedef_die, we did
<span class="lineNum">    5811 </span>            :    equate the anonymous struct named by the typedef with the DIE of
<span class="lineNum">    5812 </span>            :    the naming typedef. So by default, lookup_type_die on an anonymous
<span class="lineNum">    5813 </span>            :    struct yields the DIE of the naming typedef.
<span class="lineNum">    5814 </span>            : 
<span class="lineNum">    5815 </span>            :    [1]: Read the comment of is_naming_typedef_decl to learn about what
<span class="lineNum">    5816 </span>            :    a naming typedef is.  */
<span class="lineNum">    5817 </span>            : 
<span class="lineNum">    5818 </span>            : static inline dw_die_ref
<span class="lineNum">    5819 </span>            : lookup_type_die_strip_naming_typedef (tree type)
<span class="lineNum">    5820 </span>            : {
<span class="lineNum">    5821 </span><span class="lineCov">      92650 :   dw_die_ref die = lookup_type_die (type);</span>
<span class="lineNum">    5822 </span><span class="lineCov">      46325 :   return strip_naming_typedef (type, die);</span>
<span class="lineNum">    5823 </span>            : }
<span class="lineNum">    5824 </span>            : 
<span class="lineNum">    5825 </span>            : /* Equate a DIE to a given type specifier.  */
<span class="lineNum">    5826 </span>            : 
<span class="lineNum">    5827 </span>            : static inline void
<span class="lineNum">    5828 </span>            : equate_type_number_to_die (tree type, dw_die_ref type_die)
<span class="lineNum">    5829 </span>            : {
<span class="lineNum">    5830 </span><span class="lineCov">   11334299 :   TYPE_SYMTAB_DIE (type) = type_die;</span>
<span class="lineNum">    5831 </span>            : }
<span class="lineNum">    5832 </span>            : 
<span class="lineNum">    5833 </span>            : /* Returns a hash value for X (which really is a die_struct).  */
<a name="5834"><span class="lineNum">    5834 </span>            : </a>
<span class="lineNum">    5835 </span>            : inline hashval_t
<span class="lineNum">    5836 </span><span class="lineNoCov">          0 : decl_die_hasher::hash (die_node *x)</span>
<span class="lineNum">    5837 </span>            : {
<span class="lineNum">    5838 </span><span class="lineCov">   20780422 :   return (hashval_t) x-&gt;decl_id;</span>
<span class="lineNum">    5839 </span>            : }
<span class="lineNum">    5840 </span>            : 
<span class="lineNum">    5841 </span>            : /* Return nonzero if decl_id of die_struct X is the same as UID of decl *Y.  */
<a name="5842"><span class="lineNum">    5842 </span>            : </a>
<span class="lineNum">    5843 </span>            : inline bool
<span class="lineNum">    5844 </span><span class="lineNoCov">          0 : decl_die_hasher::equal (die_node *x, tree y)</span>
<span class="lineNum">    5845 </span>            : {
<span class="lineNum">    5846 </span><span class="lineCov">  208814854 :   return (x-&gt;decl_id == DECL_UID (y));</span>
<span class="lineNum">    5847 </span>            : }
<span class="lineNum">    5848 </span>            : 
<span class="lineNum">    5849 </span>            : /* Return the DIE associated with a given declaration.  */
<a name="5850"><span class="lineNum">    5850 </span>            : </a>
<span class="lineNum">    5851 </span>            : static inline dw_die_ref
<span class="lineNum">    5852 </span><span class="lineCov">  157268168 : lookup_decl_die (tree decl)</span>
<span class="lineNum">    5853 </span>            : {
<span class="lineNum">    5854 </span><span class="lineCov">  157268168 :   dw_die_ref *die = decl_die_table-&gt;find_slot_with_hash (decl, DECL_UID (decl),</span>
<span class="lineNum">    5855 </span>            :                                                          NO_INSERT);
<span class="lineNum">    5856 </span><span class="lineCov">  157268168 :   if (!die)</span>
<span class="lineNum">    5857 </span>            :     return NULL;
<span class="lineNum">    5858 </span><span class="lineCov">   85569293 :   if ((*die)-&gt;removed)</span>
<span class="lineNum">    5859 </span>            :     {
<span class="lineNum">    5860 </span><span class="lineCov">        109 :       decl_die_table-&gt;clear_slot (die);</span>
<span class="lineNum">    5861 </span><span class="lineCov">        109 :       return NULL;</span>
<span class="lineNum">    5862 </span>            :     }
<span class="lineNum">    5863 </span>            :   return *die;
<span class="lineNum">    5864 </span>            : }
<span class="lineNum">    5865 </span>            : 
<span class="lineNum">    5866 </span>            : 
<span class="lineNum">    5867 </span>            : /* For DECL which might have early dwarf output query a SYMBOL + OFFSET
<span class="lineNum">    5868 </span>            :    style reference.  Return true if we found one refering to a DIE for
<span class="lineNum">    5869 </span>            :    DECL, otherwise return false.  */
<a name="5870"><span class="lineNum">    5870 </span>            : </a>
<span class="lineNum">    5871 </span>            : static bool
<span class="lineNum">    5872 </span><span class="lineCov">      75267 : dwarf2out_die_ref_for_decl (tree decl, const char **sym,</span>
<span class="lineNum">    5873 </span>            :                             unsigned HOST_WIDE_INT *off)
<span class="lineNum">    5874 </span>            : {
<span class="lineNum">    5875 </span><span class="lineCov">      75267 :   dw_die_ref die;</span>
<span class="lineNum">    5876 </span>            : 
<span class="lineNum">    5877 </span><span class="lineCov">      75267 :   if (in_lto_p &amp;&amp; !decl_die_table)</span>
<span class="lineNum">    5878 </span>            :     return false;
<span class="lineNum">    5879 </span>            : 
<span class="lineNum">    5880 </span><span class="lineCov">      75212 :   if (TREE_CODE (decl) == BLOCK)</span>
<span class="lineNum">    5881 </span><span class="lineCov">      28524 :     die = BLOCK_DIE (decl);</span>
<span class="lineNum">    5882 </span>            :   else
<span class="lineNum">    5883 </span><span class="lineCov">      60950 :     die = lookup_decl_die (decl);</span>
<span class="lineNum">    5884 </span><span class="lineCov">      75212 :   if (!die)</span>
<span class="lineNum">    5885 </span>            :     return false;
<span class="lineNum">    5886 </span>            : 
<span class="lineNum">    5887 </span>            :   /* During WPA stage and incremental linking we currently use DIEs
<span class="lineNum">    5888 </span>            :      to store the decl &lt;-&gt; label + offset map.  That's quite inefficient
<span class="lineNum">    5889 </span>            :      but it works for now.  */
<span class="lineNum">    5890 </span><span class="lineCov">      33686 :   if (in_lto_p)</span>
<span class="lineNum">    5891 </span>            :     {
<span class="lineNum">    5892 </span><span class="lineCov">       7704 :       dw_die_ref ref = get_AT_ref (die, DW_AT_abstract_origin);</span>
<span class="lineNum">    5893 </span><span class="lineCov">       7704 :       if (!ref)</span>
<span class="lineNum">    5894 </span>            :         {
<span class="lineNum">    5895 </span><span class="lineNoCov">          0 :           gcc_assert (die == comp_unit_die ());</span>
<span class="lineNum">    5896 </span>            :           return false;
<span class="lineNum">    5897 </span>            :         }
<span class="lineNum">    5898 </span><span class="lineCov">       7704 :       *off = ref-&gt;die_offset;</span>
<span class="lineNum">    5899 </span><span class="lineCov">       7704 :       *sym = ref-&gt;die_id.die_symbol;</span>
<span class="lineNum">    5900 </span><span class="lineCov">       7704 :       return true;</span>
<span class="lineNum">    5901 </span>            :     }
<span class="lineNum">    5902 </span>            : 
<span class="lineNum">    5903 </span>            :   /* Similar to get_ref_die_offset_label, but using the &quot;correct&quot;
<span class="lineNum">    5904 </span>            :      label.  */
<span class="lineNum">    5905 </span><span class="lineCov">      25982 :   *off = die-&gt;die_offset;</span>
<span class="lineNum">    5906 </span><span class="lineCov">      68534 :   while (die-&gt;die_parent)</span>
<span class="lineNum">    5907 </span>            :     die = die-&gt;die_parent;
<span class="lineNum">    5908 </span>            :   /* For the containing CU DIE we compute a die_symbol in
<span class="lineNum">    5909 </span>            :      compute_comp_unit_symbol.  */
<span class="lineNum">    5910 </span><span class="lineCov">      25982 :   gcc_assert (die-&gt;die_tag == DW_TAG_compile_unit</span>
<span class="lineNum">    5911 </span>            :               &amp;&amp; die-&gt;die_id.die_symbol != NULL);
<span class="lineNum">    5912 </span><span class="lineCov">      25982 :   *sym = die-&gt;die_id.die_symbol;</span>
<span class="lineNum">    5913 </span><span class="lineCov">      25982 :   return true;</span>
<span class="lineNum">    5914 </span>            : }
<span class="lineNum">    5915 </span>            : 
<span class="lineNum">    5916 </span>            : /* Add a reference of kind ATTR_KIND to a DIE at SYMBOL + OFFSET to DIE.  */
<a name="5917"><span class="lineNum">    5917 </span>            : </a>
<span class="lineNum">    5918 </span>            : static void
<span class="lineNum">    5919 </span><span class="lineCov">      31524 : add_AT_external_die_ref (dw_die_ref die, enum dwarf_attribute attr_kind,</span>
<span class="lineNum">    5920 </span>            :                          const char *symbol, HOST_WIDE_INT offset)
<span class="lineNum">    5921 </span>            : {
<span class="lineNum">    5922 </span>            :   /* Create a fake DIE that contains the reference.  Don't use
<span class="lineNum">    5923 </span>            :      new_die because we don't want to end up in the limbo list.  */
<span class="lineNum">    5924 </span><span class="lineCov">      31524 :   dw_die_ref ref = new_die_raw (die-&gt;die_tag);</span>
<span class="lineNum">    5925 </span><span class="lineCov">      31524 :   ref-&gt;die_id.die_symbol = IDENTIFIER_POINTER (get_identifier (symbol));</span>
<span class="lineNum">    5926 </span><span class="lineCov">      31524 :   ref-&gt;die_offset = offset;</span>
<span class="lineNum">    5927 </span><span class="lineCov">      31524 :   ref-&gt;with_offset = 1;</span>
<span class="lineNum">    5928 </span><span class="lineCov">      31524 :   add_AT_die_ref (die, attr_kind, ref);</span>
<span class="lineNum">    5929 </span><span class="lineCov">      31524 : }</span>
<span class="lineNum">    5930 </span>            : 
<span class="lineNum">    5931 </span>            : /* Create a DIE for DECL if required and add a reference to a DIE
<span class="lineNum">    5932 </span>            :    at SYMBOL + OFFSET which contains attributes dumped early.  */
<a name="5933"><span class="lineNum">    5933 </span>            : </a>
<span class="lineNum">    5934 </span>            : static void
<span class="lineNum">    5935 </span><span class="lineCov">      31524 : dwarf2out_register_external_die (tree decl, const char *sym,</span>
<span class="lineNum">    5936 </span>            :                                  unsigned HOST_WIDE_INT off)
<span class="lineNum">    5937 </span>            : {
<span class="lineNum">    5938 </span><span class="lineCov">      31524 :   if (debug_info_level == DINFO_LEVEL_NONE)</span>
<span class="lineNum">    5939 </span>            :     return;
<span class="lineNum">    5940 </span>            : 
<span class="lineNum">    5941 </span><span class="lineCov">      31524 :   if ((flag_wpa</span>
<span class="lineNum">    5942 </span><span class="lineCov">      31524 :        || flag_incremental_link == INCREMENTAL_LINK_LTO) &amp;&amp; !decl_die_table)</span>
<span class="lineNum">    5943 </span><span class="lineCov">        295 :     decl_die_table = hash_table&lt;decl_die_hasher&gt;::create_ggc (1000);</span>
<span class="lineNum">    5944 </span>            : 
<span class="lineNum">    5945 </span><span class="lineCov">      31524 :   dw_die_ref die</span>
<span class="lineNum">    5946 </span><span class="lineCov">      31524 :     = TREE_CODE (decl) == BLOCK ? BLOCK_DIE (decl) : lookup_decl_die (decl);</span>
<span class="lineNum">    5947 </span><span class="lineCov">      31524 :   gcc_assert (!die);</span>
<span class="lineNum">    5948 </span>            : 
<span class="lineNum">    5949 </span><span class="lineCov">      31524 :   tree ctx;</span>
<span class="lineNum">    5950 </span><span class="lineCov">      31524 :   dw_die_ref parent = NULL;</span>
<span class="lineNum">    5951 </span>            :   /* Need to lookup a DIE for the decls context - the containing
<span class="lineNum">    5952 </span>            :      function or translation unit.  */
<span class="lineNum">    5953 </span><span class="lineCov">      31524 :   if (TREE_CODE (decl) == BLOCK)</span>
<span class="lineNum">    5954 </span>            :     {
<span class="lineNum">    5955 </span><span class="lineCov">        798 :       ctx = BLOCK_SUPERCONTEXT (decl);</span>
<span class="lineNum">    5956 </span>            :       /* ???  We do not output DIEs for all scopes thus skip as
<span class="lineNum">    5957 </span>            :          many DIEs as needed.  */
<span class="lineNum">    5958 </span><span class="lineCov">       1391 :       while (TREE_CODE (ctx) == BLOCK</span>
<span class="lineNum">    5959 </span><span class="lineCov">        895 :              &amp;&amp; !BLOCK_DIE (ctx))</span>
<span class="lineNum">    5960 </span><span class="lineCov">        992 :         ctx = BLOCK_SUPERCONTEXT (ctx);</span>
<span class="lineNum">    5961 </span>            :     }
<span class="lineNum">    5962 </span>            :   else
<span class="lineNum">    5963 </span><span class="lineCov">      31125 :     ctx = DECL_CONTEXT (decl);</span>
<span class="lineNum">    5964 </span>            :   /* Peel types in the context stack.  */
<span class="lineNum">    5965 </span><span class="lineCov">      31599 :   while (ctx &amp;&amp; TYPE_P (ctx))</span>
<span class="lineNum">    5966 </span><span class="lineCov">        150 :     ctx = TYPE_CONTEXT (ctx);</span>
<span class="lineNum">    5967 </span>            :   /* Likewise namespaces in case we do not want to emit DIEs for them.  */
<span class="lineNum">    5968 </span><span class="lineCov">      31524 :   if (debug_info_level &lt;= DINFO_LEVEL_TERSE)</span>
<span class="lineNum">    5969 </span><span class="lineCov">         28 :     while (ctx &amp;&amp; TREE_CODE (ctx) == NAMESPACE_DECL)</span>
<span class="lineNum">    5970 </span><span class="lineCov">          1 :       ctx = DECL_CONTEXT (ctx);</span>
<span class="lineNum">    5971 </span><span class="lineCov">      31524 :   if (ctx)</span>
<span class="lineNum">    5972 </span>            :     {
<span class="lineNum">    5973 </span><span class="lineCov">      30660 :       if (TREE_CODE (ctx) == BLOCK)</span>
<span class="lineNum">    5974 </span><span class="lineCov">        116 :         parent = BLOCK_DIE (ctx);</span>
<span class="lineNum">    5975 </span><span class="lineCov">      30602 :       else if (TREE_CODE (ctx) == TRANSLATION_UNIT_DECL</span>
<span class="lineNum">    5976 </span>            :                /* Keep the 1:1 association during WPA.  */
<span class="lineNum">    5977 </span><span class="lineCov">       3693 :                &amp;&amp; !flag_wpa</span>
<span class="lineNum">    5978 </span><span class="lineCov">       2273 :                &amp;&amp; flag_incremental_link != INCREMENTAL_LINK_LTO)</span>
<span class="lineNum">    5979 </span>            :         /* Otherwise all late annotations go to the main CU which
<span class="lineNum">    5980 </span>            :            imports the original CUs.  */
<span class="lineNum">    5981 </span><span class="lineCov">       2240 :         parent = comp_unit_die ();</span>
<span class="lineNum">    5982 </span><span class="lineCov">      28362 :       else if (TREE_CODE (ctx) == FUNCTION_DECL</span>
<span class="lineNum">    5983 </span><span class="lineCov">      15069 :                &amp;&amp; TREE_CODE (decl) != FUNCTION_DECL</span>
<span class="lineNum">    5984 </span><span class="lineCov">      15019 :                &amp;&amp; TREE_CODE (decl) != PARM_DECL</span>
<span class="lineNum">    5985 </span><span class="lineCov">       3106 :                &amp;&amp; TREE_CODE (decl) != RESULT_DECL</span>
<span class="lineNum">    5986 </span><span class="lineCov">       3106 :                &amp;&amp; TREE_CODE (decl) != BLOCK)</span>
<span class="lineNum">    5987 </span>            :         /* Leave function local entities parent determination to when
<span class="lineNum">    5988 </span>            :            we process scope vars.  */
<span class="lineNum">    5989 </span>            :         ;
<span class="lineNum">    5990 </span>            :       else
<span class="lineNum">    5991 </span><span class="lineCov">      25597 :         parent = lookup_decl_die (ctx);</span>
<span class="lineNum">    5992 </span>            :     }
<span class="lineNum">    5993 </span>            :   else
<span class="lineNum">    5994 </span>            :     /* In some cases the FEs fail to set DECL_CONTEXT properly.
<span class="lineNum">    5995 </span>            :        Handle this case gracefully by globalizing stuff.  */
<span class="lineNum">    5996 </span><span class="lineCov">       1688 :     parent = comp_unit_die ();</span>
<span class="lineNum">    5997 </span>            :   /* Create a DIE &quot;stub&quot;.  */
<span class="lineNum">    5998 </span><span class="lineCov">      31524 :   switch (TREE_CODE (decl))</span>
<span class="lineNum">    5999 </span>            :     {
<span class="lineNum">    6000 </span><span class="lineCov">        864 :     case TRANSLATION_UNIT_DECL:</span>
<span class="lineNum">    6001 </span><span class="lineCov">        864 :       if (! flag_wpa &amp;&amp; flag_incremental_link != INCREMENTAL_LINK_LTO)</span>
<span class="lineNum">    6002 </span>            :         {
<span class="lineNum">    6003 </span><span class="lineCov">        538 :           die = comp_unit_die ();</span>
<span class="lineNum">    6004 </span><span class="lineCov">        538 :           dw_die_ref import = new_die (DW_TAG_imported_unit, die, NULL_TREE);</span>
<span class="lineNum">    6005 </span><span class="lineCov">        538 :           add_AT_external_die_ref (import, DW_AT_import, sym, off);</span>
<span class="lineNum">    6006 </span>            :           /* We re-target all CU decls to the LTRANS CU DIE, so no need
<span class="lineNum">    6007 </span>            :              to create a DIE for the original CUs.  */
<span class="lineNum">    6008 </span><span class="lineCov">        538 :           return;</span>
<span class="lineNum">    6009 </span>            :         }
<span class="lineNum">    6010 </span>            :       /* Keep the 1:1 association during WPA.  */
<span class="lineNum">    6011 </span><span class="lineCov">        326 :       die = new_die (DW_TAG_compile_unit, NULL, decl);</span>
<span class="lineNum">    6012 </span><span class="lineCov">        326 :       break;</span>
<span class="lineNum">    6013 </span><span class="lineCov">        172 :     case NAMESPACE_DECL:</span>
<span class="lineNum">    6014 </span><span class="lineCov">        172 :       if (is_fortran (decl))</span>
<span class="lineNum">    6015 </span><span class="lineCov">         14 :         die = new_die (DW_TAG_module, parent, decl);</span>
<span class="lineNum">    6016 </span>            :       else
<span class="lineNum">    6017 </span><span class="lineCov">        158 :         die = new_die (DW_TAG_namespace, parent, decl);</span>
<span class="lineNum">    6018 </span>            :       break;
<span class="lineNum">    6019 </span><span class="lineCov">      14118 :     case FUNCTION_DECL:</span>
<span class="lineNum">    6020 </span><span class="lineCov">      14118 :       die = new_die (DW_TAG_subprogram, parent, decl);</span>
<span class="lineNum">    6021 </span><span class="lineCov">      14118 :       break;</span>
<span class="lineNum">    6022 </span><span class="lineCov">       4028 :     case VAR_DECL:</span>
<span class="lineNum">    6023 </span><span class="lineCov">       4028 :       die = new_die (DW_TAG_variable, parent, decl);</span>
<span class="lineNum">    6024 </span><span class="lineCov">       4028 :       break;</span>
<span class="lineNum">    6025 </span><span class="lineNoCov">          0 :     case RESULT_DECL:</span>
<span class="lineNum">    6026 </span><span class="lineNoCov">          0 :       die = new_die (DW_TAG_variable, parent, decl);</span>
<span class="lineNum">    6027 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    6028 </span><span class="lineCov">      11913 :     case PARM_DECL:</span>
<span class="lineNum">    6029 </span><span class="lineCov">      11913 :       die = new_die (DW_TAG_formal_parameter, parent, decl);</span>
<span class="lineNum">    6030 </span><span class="lineCov">      11913 :       break;</span>
<span class="lineNum">    6031 </span><span class="lineCov">         24 :     case CONST_DECL:</span>
<span class="lineNum">    6032 </span><span class="lineCov">         24 :       die = new_die (DW_TAG_constant, parent, decl);</span>
<span class="lineNum">    6033 </span><span class="lineCov">         24 :       break;</span>
<span class="lineNum">    6034 </span><span class="lineCov">          6 :     case LABEL_DECL:</span>
<span class="lineNum">    6035 </span><span class="lineCov">          6 :       die = new_die (DW_TAG_label, parent, decl);</span>
<span class="lineNum">    6036 </span><span class="lineCov">          6 :       break;</span>
<span class="lineNum">    6037 </span><span class="lineCov">        399 :     case BLOCK:</span>
<span class="lineNum">    6038 </span><span class="lineCov">        399 :       die = new_die (DW_TAG_lexical_block, parent, decl);</span>
<span class="lineNum">    6039 </span><span class="lineCov">        399 :       break;</span>
<span class="lineNum">    6040 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">    6041 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">    6042 </span>            :     }
<span class="lineNum">    6043 </span><span class="lineCov">      30986 :   if (TREE_CODE (decl) == BLOCK)</span>
<span class="lineNum">    6044 </span><span class="lineCov">        798 :     BLOCK_DIE (decl) = die;</span>
<span class="lineNum">    6045 </span>            :   else
<span class="lineNum">    6046 </span><span class="lineCov">      30587 :     equate_decl_number_to_die (decl, die);</span>
<span class="lineNum">    6047 </span>            : 
<span class="lineNum">    6048 </span><span class="lineCov">      30986 :   add_desc_attribute (die, decl);</span>
<span class="lineNum">    6049 </span>            : 
<span class="lineNum">    6050 </span>            :   /* Add a reference to the DIE providing early debug at $sym + off.  */
<span class="lineNum">    6051 </span><span class="lineCov">      30986 :   add_AT_external_die_ref (die, DW_AT_abstract_origin, sym, off);</span>
<span class="lineNum">    6052 </span>            : }
<span class="lineNum">    6053 </span>            : 
<span class="lineNum">    6054 </span>            : /* Returns a hash value for X (which really is a var_loc_list).  */
<a name="6055"><span class="lineNum">    6055 </span>            : </a>
<span class="lineNum">    6056 </span>            : inline hashval_t
<span class="lineNum">    6057 </span><span class="lineNoCov">          0 : decl_loc_hasher::hash (var_loc_list *x)</span>
<span class="lineNum">    6058 </span>            : {
<span class="lineNum">    6059 </span><span class="lineCov">    4365973 :   return (hashval_t) x-&gt;decl_id;</span>
<span class="lineNum">    6060 </span>            : }
<span class="lineNum">    6061 </span>            : 
<span class="lineNum">    6062 </span>            : /* Return nonzero if decl_id of var_loc_list X is the same as
<span class="lineNum">    6063 </span>            :    UID of decl *Y.  */
<a name="6064"><span class="lineNum">    6064 </span>            : </a>
<span class="lineNum">    6065 </span>            : inline bool
<span class="lineNum">    6066 </span><span class="lineNoCov">          0 : decl_loc_hasher::equal (var_loc_list *x, const_tree y)</span>
<span class="lineNum">    6067 </span>            : {
<span class="lineNum">    6068 </span><span class="lineCov">   64382879 :   return (x-&gt;decl_id == DECL_UID (y));</span>
<span class="lineNum">    6069 </span>            : }
<span class="lineNum">    6070 </span>            : 
<span class="lineNum">    6071 </span>            : /* Return the var_loc list associated with a given declaration.  */
<a name="6072"><span class="lineNum">    6072 </span>            : </a>
<span class="lineNum">    6073 </span>            : static inline var_loc_list *
<span class="lineNum">    6074 </span><span class="lineCov">   15771855 : lookup_decl_loc (const_tree decl)</span>
<span class="lineNum">    6075 </span>            : {
<span class="lineNum">    6076 </span><span class="lineCov">   15771855 :   if (!decl_loc_table)</span>
<span class="lineNum">    6077 </span>            :     return NULL;
<span class="lineNum">    6078 </span><span class="lineCov">   15771855 :   return decl_loc_table-&gt;find_with_hash (decl, DECL_UID (decl));</span>
<span class="lineNum">    6079 </span>            : }
<span class="lineNum">    6080 </span>            : 
<span class="lineNum">    6081 </span>            : /* Returns a hash value for X (which really is a cached_dw_loc_list_list).  */
<a name="6082"><span class="lineNum">    6082 </span>            : </a>
<span class="lineNum">    6083 </span>            : inline hashval_t
<span class="lineNum">    6084 </span><span class="lineNoCov">          0 : dw_loc_list_hasher::hash (cached_dw_loc_list *x)</span>
<span class="lineNum">    6085 </span>            : {
<span class="lineNum">    6086 </span><span class="lineNoCov">          0 :   return (hashval_t) x-&gt;decl_id;</span>
<span class="lineNum">    6087 </span>            : }
<span class="lineNum">    6088 </span>            : 
<span class="lineNum">    6089 </span>            : /* Return nonzero if decl_id of cached_dw_loc_list X is the same as
<span class="lineNum">    6090 </span>            :    UID of decl *Y.  */
<a name="6091"><span class="lineNum">    6091 </span>            : </a>
<span class="lineNum">    6092 </span>            : inline bool
<span class="lineNum">    6093 </span><span class="lineNoCov">          0 : dw_loc_list_hasher::equal (cached_dw_loc_list *x, const_tree y)</span>
<span class="lineNum">    6094 </span>            : {
<span class="lineNum">    6095 </span><span class="lineNoCov">          0 :   return (x-&gt;decl_id == DECL_UID (y));</span>
<span class="lineNum">    6096 </span>            : }
<span class="lineNum">    6097 </span>            : 
<span class="lineNum">    6098 </span>            : /* Equate a DIE to a particular declaration.  */
<a name="6099"><span class="lineNum">    6099 </span>            : </a>
<span class="lineNum">    6100 </span>            : static void
<span class="lineNum">    6101 </span><span class="lineCov">   22574949 : equate_decl_number_to_die (tree decl, dw_die_ref decl_die)</span>
<span class="lineNum">    6102 </span>            : {
<span class="lineNum">    6103 </span><span class="lineCov">   22574949 :   unsigned int decl_id = DECL_UID (decl);</span>
<span class="lineNum">    6104 </span>            : 
<span class="lineNum">    6105 </span><span class="lineCov">   22574949 :   *decl_die_table-&gt;find_slot_with_hash (decl, decl_id, INSERT) = decl_die;</span>
<span class="lineNum">    6106 </span><span class="lineCov">   22574949 :   decl_die-&gt;decl_id = decl_id;</span>
<span class="lineNum">    6107 </span><span class="lineCov">   22574949 : }</span>
<span class="lineNum">    6108 </span>            : 
<span class="lineNum">    6109 </span>            : /* Return how many bits covers PIECE EXPR_LIST.  */
<a name="6110"><span class="lineNum">    6110 </span>            : </a>
<span class="lineNum">    6111 </span>            : static HOST_WIDE_INT
<span class="lineNum">    6112 </span><span class="lineCov">   16220807 : decl_piece_bitsize (rtx piece)</span>
<span class="lineNum">    6113 </span>            : {
<span class="lineNum">    6114 </span><span class="lineCov">   16220807 :   int ret = (int) GET_MODE (piece);</span>
<span class="lineNum">    6115 </span><span class="lineCov">   16220807 :   if (ret)</span>
<span class="lineNum">    6116 </span><span class="lineCov">   16163748 :     return ret;</span>
<span class="lineNum">    6117 </span><span class="lineCov">      57059 :   gcc_assert (GET_CODE (XEXP (piece, 0)) == CONCAT</span>
<span class="lineNum">    6118 </span>            :               &amp;&amp; CONST_INT_P (XEXP (XEXP (piece, 0), 0)));
<span class="lineNum">    6119 </span><span class="lineCov">      57059 :   return INTVAL (XEXP (XEXP (piece, 0), 0));</span>
<span class="lineNum">    6120 </span>            : }
<span class="lineNum">    6121 </span>            : 
<span class="lineNum">    6122 </span>            : /* Return pointer to the location of location note in PIECE EXPR_LIST.  */
<a name="6123"><span class="lineNum">    6123 </span>            : </a>
<span class="lineNum">    6124 </span>            : static rtx *
<span class="lineNum">    6125 </span><span class="lineNoCov">          0 : decl_piece_varloc_ptr (rtx piece)</span>
<span class="lineNum">    6126 </span>            : {
<span class="lineNum">    6127 </span><span class="lineNoCov">          0 :   if ((int) GET_MODE (piece))</span>
<span class="lineNum">    6128 </span><span class="lineCov">    8195580 :     return &amp;XEXP (piece, 0);</span>
<span class="lineNum">    6129 </span>            :   else
<span class="lineNum">    6130 </span><span class="lineCov">      27924 :     return &amp;XEXP (XEXP (piece, 0), 1);</span>
<span class="lineNum">    6131 </span>            : }
<span class="lineNum">    6132 </span>            : 
<span class="lineNum">    6133 </span>            : /* Create an EXPR_LIST for location note LOC_NOTE covering BITSIZE bits.
<span class="lineNum">    6134 </span>            :    Next is the chain of following piece nodes.  */
<a name="6135"><span class="lineNum">    6135 </span>            : </a>
<span class="lineNum">    6136 </span>            : static rtx_expr_list *
<span class="lineNum">    6137 </span><span class="lineCov">    3344469 : decl_piece_node (rtx loc_note, HOST_WIDE_INT bitsize, rtx next)</span>
<span class="lineNum">    6138 </span>            : {
<span class="lineNum">    6139 </span><span class="lineCov">    3344469 :   if (bitsize &gt; 0 &amp;&amp; bitsize &lt;= (int) MAX_MACHINE_MODE)</span>
<span class="lineNum">    6140 </span><span class="lineCov">    3324997 :     return alloc_EXPR_LIST (bitsize, loc_note, next);</span>
<span class="lineNum">    6141 </span>            :   else
<span class="lineNum">    6142 </span><span class="lineCov">      19472 :     return alloc_EXPR_LIST (0, gen_rtx_CONCAT (VOIDmode,</span>
<span class="lineNum">    6143 </span>            :                                                GEN_INT (bitsize),
<span class="lineNum">    6144 </span><span class="lineCov">      19472 :                                                loc_note), next);</span>
<span class="lineNum">    6145 </span>            : }
<span class="lineNum">    6146 </span>            : 
<span class="lineNum">    6147 </span>            : /* Return rtx that should be stored into loc field for
<span class="lineNum">    6148 </span>            :    LOC_NOTE and BITPOS/BITSIZE.  */
<a name="6149"><span class="lineNum">    6149 </span>            : </a>
<span class="lineNum">    6150 </span>            : static rtx
<span class="lineNum">    6151 </span><span class="lineCov">   30574101 : construct_piece_list (rtx loc_note, HOST_WIDE_INT bitpos,</span>
<span class="lineNum">    6152 </span>            :                       HOST_WIDE_INT bitsize)
<span class="lineNum">    6153 </span>            : {
<span class="lineNum">    6154 </span><span class="lineCov">   30574101 :   if (bitsize != -1)</span>
<span class="lineNum">    6155 </span>            :     {
<span class="lineNum">    6156 </span><span class="lineCov">     320753 :       loc_note = decl_piece_node (loc_note, bitsize, NULL_RTX);</span>
<span class="lineNum">    6157 </span><span class="lineCov">     320753 :       if (bitpos != 0)</span>
<span class="lineNum">    6158 </span><span class="lineCov">      34969 :         loc_note = decl_piece_node (NULL_RTX, bitpos, loc_note);</span>
<span class="lineNum">    6159 </span>            :     }
<span class="lineNum">    6160 </span><span class="lineCov">   30574101 :   return loc_note;</span>
<span class="lineNum">    6161 </span>            : }
<span class="lineNum">    6162 </span>            : 
<span class="lineNum">    6163 </span>            : /* This function either modifies location piece list *DEST in
<span class="lineNum">    6164 </span>            :    place (if SRC and INNER is NULL), or copies location piece list
<span class="lineNum">    6165 </span>            :    *SRC to *DEST while modifying it.  Location BITPOS is modified
<span class="lineNum">    6166 </span>            :    to contain LOC_NOTE, any pieces overlapping it are removed resp.
<span class="lineNum">    6167 </span>            :    not copied and if needed some padding around it is added.
<span class="lineNum">    6168 </span>            :    When modifying in place, DEST should point to EXPR_LIST where
<span class="lineNum">    6169 </span>            :    earlier pieces cover PIECE_BITPOS bits, when copying SRC points
<span class="lineNum">    6170 </span>            :    to the start of the whole list and INNER points to the EXPR_LIST
<span class="lineNum">    6171 </span>            :    where earlier pieces cover PIECE_BITPOS bits.  */
<a name="6172"><span class="lineNum">    6172 </span>            : </a>
<span class="lineNum">    6173 </span>            : static void
<span class="lineNum">    6174 </span><span class="lineCov">    2721631 : adjust_piece_list (rtx *dest, rtx *src, rtx *inner,</span>
<span class="lineNum">    6175 </span>            :                    HOST_WIDE_INT bitpos, HOST_WIDE_INT piece_bitpos,
<span class="lineNum">    6176 </span>            :                    HOST_WIDE_INT bitsize, rtx loc_note)
<span class="lineNum">    6177 </span>            : {
<span class="lineNum">    6178 </span><span class="lineCov">    2721631 :   HOST_WIDE_INT diff;</span>
<span class="lineNum">    6179 </span><span class="lineCov">    2721631 :   bool copy = inner != NULL;</span>
<span class="lineNum">    6180 </span>            : 
<span class="lineNum">    6181 </span><span class="lineCov">    2721631 :   if (copy)</span>
<span class="lineNum">    6182 </span>            :     {
<span class="lineNum">    6183 </span>            :       /* First copy all nodes preceding the current bitpos.  */
<span class="lineNum">    6184 </span><span class="lineCov">    1802934 :       while (src != inner)</span>
<span class="lineNum">    6185 </span>            :         {
<span class="lineNum">    6186 </span><span class="lineCov">    1080690 :           *dest = decl_piece_node (*decl_piece_varloc_ptr (*src),</span>
<span class="lineNum">    6187 </span>            :                                    decl_piece_bitsize (*src), NULL_RTX);
<span class="lineNum">    6188 </span><span class="lineCov">     540345 :           dest = &amp;XEXP (*dest, 1);</span>
<span class="lineNum">    6189 </span><span class="lineCov">     540345 :           src = &amp;XEXP (*src, 1);</span>
<span class="lineNum">    6190 </span>            :         }
<span class="lineNum">    6191 </span>            :     }
<span class="lineNum">    6192 </span>            :   /* Add padding if needed.  */
<span class="lineNum">    6193 </span><span class="lineCov">    2721631 :   if (bitpos != piece_bitpos)</span>
<span class="lineNum">    6194 </span>            :     {
<span class="lineNum">    6195 </span><span class="lineCov">       7613 :       *dest = decl_piece_node (NULL_RTX, bitpos - piece_bitpos,</span>
<span class="lineNum">    6196 </span>            :                                copy ? NULL_RTX : *dest);
<span class="lineNum">    6197 </span><span class="lineCov">       7613 :       dest = &amp;XEXP (*dest, 1);</span>
<span class="lineNum">    6198 </span>            :     }
<span class="lineNum">    6199 </span><span class="lineCov">    2714018 :   else if (*dest &amp;&amp; decl_piece_bitsize (*dest) == bitsize)</span>
<span class="lineNum">    6200 </span>            :     {
<span class="lineNum">    6201 </span><span class="lineCov">    1268310 :       gcc_assert (!copy);</span>
<span class="lineNum">    6202 </span>            :       /* A piece with correct bitpos and bitsize already exist,
<span class="lineNum">    6203 </span>            :          just update the location for it and return.  */
<span class="lineNum">    6204 </span><span class="lineCov">    1268310 :       *decl_piece_varloc_ptr (*dest) = loc_note;</span>
<span class="lineNum">    6205 </span><span class="lineCov">    1268310 :       return;</span>
<span class="lineNum">    6206 </span>            :     }
<span class="lineNum">    6207 </span>            :   /* Add the piece that changed.  */
<span class="lineNum">    6208 </span><span class="lineCov">    1453321 :   *dest = decl_piece_node (loc_note, bitsize, copy ? NULL_RTX : *dest);</span>
<span class="lineNum">    6209 </span><span class="lineCov">    1453321 :   dest = &amp;XEXP (*dest, 1);</span>
<span class="lineNum">    6210 </span>            :   /* Skip over pieces that overlap it.  */
<span class="lineNum">    6211 </span><span class="lineCov">    1453321 :   diff = bitpos - piece_bitpos + bitsize;</span>
<span class="lineNum">    6212 </span><span class="lineCov">    1453321 :   if (!copy)</span>
<span class="lineNum">    6213 </span><span class="lineCov">     190732 :     src = dest;</span>
<span class="lineNum">    6214 </span><span class="lineCov">    2699028 :   while (diff &gt; 0 &amp;&amp; *src)</span>
<span class="lineNum">    6215 </span>            :     {
<span class="lineNum">    6216 </span><span class="lineCov">    1245707 :       rtx piece = *src;</span>
<span class="lineNum">    6217 </span><span class="lineCov">    1245707 :       diff -= decl_piece_bitsize (piece);</span>
<span class="lineNum">    6218 </span><span class="lineCov">    1245707 :       if (copy)</span>
<span class="lineNum">    6219 </span><span class="lineCov">    1244100 :         src = &amp;XEXP (piece, 1);</span>
<span class="lineNum">    6220 </span>            :       else
<span class="lineNum">    6221 </span>            :         {
<span class="lineNum">    6222 </span><span class="lineCov">       1607 :           *src = XEXP (piece, 1);</span>
<span class="lineNum">    6223 </span><span class="lineCov">       1607 :           free_EXPR_LIST_node (piece);</span>
<span class="lineNum">    6224 </span>            :         }
<span class="lineNum">    6225 </span>            :     }
<span class="lineNum">    6226 </span>            :   /* Add padding if needed.  */
<span class="lineNum">    6227 </span><span class="lineCov">    1453321 :   if (diff &lt; 0 &amp;&amp; *src)</span>
<span class="lineNum">    6228 </span>            :     {
<span class="lineNum">    6229 </span><span class="lineCov">       1029 :       if (!copy)</span>
<span class="lineNum">    6230 </span><span class="lineCov">        745 :         dest = src;</span>
<span class="lineNum">    6231 </span><span class="lineCov">       1029 :       *dest = decl_piece_node (NULL_RTX, -diff, copy ? NULL_RTX : *dest);</span>
<span class="lineNum">    6232 </span><span class="lineCov">       1029 :       dest = &amp;XEXP (*dest, 1);</span>
<span class="lineNum">    6233 </span>            :     }
<span class="lineNum">    6234 </span><span class="lineCov">    1453321 :   if (!copy)</span>
<span class="lineNum">    6235 </span>            :     return;
<span class="lineNum">    6236 </span>            :   /* Finally copy all nodes following it.  */
<span class="lineNum">    6237 </span><span class="lineCov">    2249028 :   while (*src)</span>
<span class="lineNum">    6238 </span>            :     {
<span class="lineNum">    6239 </span><span class="lineCov">    1972878 :       *dest = decl_piece_node (*decl_piece_varloc_ptr (*src),</span>
<span class="lineNum">    6240 </span>            :                                decl_piece_bitsize (*src), NULL_RTX);
<span class="lineNum">    6241 </span><span class="lineCov">     986439 :       dest = &amp;XEXP (*dest, 1);</span>
<span class="lineNum">    6242 </span><span class="lineCov">     986439 :       src = &amp;XEXP (*src, 1);</span>
<span class="lineNum">    6243 </span>            :     }
<span class="lineNum">    6244 </span>            : }
<span class="lineNum">    6245 </span>            : 
<span class="lineNum">    6246 </span>            : /* Add a variable location node to the linked list for DECL.  */
<a name="6247"><span class="lineNum">    6247 </span>            : </a>
<span class="lineNum">    6248 </span>            : static struct var_loc_node *
<span class="lineNum">    6249 </span><span class="lineCov">   43221866 : add_var_loc_to_decl (tree decl, rtx loc_note, const char *label, var_loc_view view)</span>
<span class="lineNum">    6250 </span>            : {
<span class="lineNum">    6251 </span><span class="lineCov">   43221866 :   unsigned int decl_id;</span>
<span class="lineNum">    6252 </span><span class="lineCov">   43221866 :   var_loc_list *temp;</span>
<span class="lineNum">    6253 </span><span class="lineCov">   43221866 :   struct var_loc_node *loc = NULL;</span>
<span class="lineNum">    6254 </span><span class="lineCov">   43221866 :   HOST_WIDE_INT bitsize = -1, bitpos = -1;</span>
<span class="lineNum">    6255 </span>            : 
<span class="lineNum">    6256 </span><span class="lineCov">   43221866 :   if (VAR_P (decl) &amp;&amp; DECL_HAS_DEBUG_EXPR_P (decl))</span>
<span class="lineNum">    6257 </span>            :     {
<span class="lineNum">    6258 </span><span class="lineCov">    8540250 :       tree realdecl = DECL_DEBUG_EXPR (decl);</span>
<span class="lineNum">    6259 </span><span class="lineCov">    4270125 :       if (handled_component_p (realdecl)</span>
<span class="lineNum">    6260 </span><span class="lineCov">    1112960 :           || (TREE_CODE (realdecl) == MEM_REF</span>
<span class="lineNum">    6261 </span><span class="lineCov">    1112960 :               &amp;&amp; TREE_CODE (TREE_OPERAND (realdecl, 0)) == ADDR_EXPR))</span>
<span class="lineNum">    6262 </span>            :         {
<span class="lineNum">    6263 </span><span class="lineCov">    4270125 :           bool reverse;</span>
<span class="lineNum">    6264 </span><span class="lineCov">    4270125 :           tree innerdecl = get_ref_base_and_extent_hwi (realdecl, &amp;bitpos,</span>
<span class="lineNum">    6265 </span><span class="lineCov">    4270125 :                                                         &amp;bitsize, &amp;reverse);</span>
<span class="lineNum">    6266 </span><span class="lineCov">    4270125 :           if (!innerdecl</span>
<span class="lineNum">    6267 </span><span class="lineCov">    4270125 :               || !DECL_P (innerdecl)</span>
<span class="lineNum">    6268 </span><span class="lineCov">    4270125 :               || DECL_IGNORED_P (innerdecl)</span>
<span class="lineNum">    6269 </span><span class="lineCov">    4270125 :               || TREE_STATIC (innerdecl)</span>
<span class="lineNum">    6270 </span><span class="lineCov">    4270125 :               || bitsize == 0</span>
<span class="lineNum">    6271 </span><span class="lineCov">    8540250 :               || bitpos + bitsize &gt; 256)</span>
<span class="lineNum">    6272 </span><span class="lineNoCov">          0 :             return NULL;</span>
<span class="lineNum">    6273 </span><span class="lineCov">    4270125 :           decl = innerdecl;</span>
<span class="lineNum">    6274 </span>            :         }
<span class="lineNum">    6275 </span>            :     }
<span class="lineNum">    6276 </span>            : 
<span class="lineNum">    6277 </span><span class="lineCov">   43221866 :   decl_id = DECL_UID (decl);</span>
<span class="lineNum">    6278 </span><span class="lineCov">   43221866 :   var_loc_list **slot</span>
<span class="lineNum">    6279 </span><span class="lineCov">   43221866 :     = decl_loc_table-&gt;find_slot_with_hash (decl, decl_id, INSERT);</span>
<span class="lineNum">    6280 </span><span class="lineCov">   43221866 :   if (*slot == NULL)</span>
<span class="lineNum">    6281 </span>            :     {
<span class="lineNum">    6282 </span><span class="lineCov">    7419728 :       temp = ggc_cleared_alloc&lt;var_loc_list&gt; ();</span>
<span class="lineNum">    6283 </span><span class="lineCov">    7419728 :       temp-&gt;decl_id = decl_id;</span>
<span class="lineNum">    6284 </span><span class="lineCov">    7419728 :       *slot = temp;</span>
<span class="lineNum">    6285 </span>            :     }
<span class="lineNum">    6286 </span>            :   else
<span class="lineNum">    6287 </span>            :     temp = *slot;
<span class="lineNum">    6288 </span>            : 
<span class="lineNum">    6289 </span>            :   /* For PARM_DECLs try to keep around the original incoming value,
<span class="lineNum">    6290 </span>            :      even if that means we'll emit a zero-range .debug_loc entry.  */
<span class="lineNum">    6291 </span><span class="lineCov">   43221866 :   if (temp-&gt;last</span>
<span class="lineNum">    6292 </span><span class="lineCov">   35802138 :       &amp;&amp; temp-&gt;first == temp-&gt;last</span>
<span class="lineNum">    6293 </span><span class="lineCov">   13784877 :       &amp;&amp; TREE_CODE (decl) == PARM_DECL</span>
<span class="lineNum">    6294 </span><span class="lineCov">     654264 :       &amp;&amp; NOTE_P (temp-&gt;first-&gt;loc)</span>
<span class="lineNum">    6295 </span><span class="lineCov">     625726 :       &amp;&amp; NOTE_VAR_LOCATION_DECL (temp-&gt;first-&gt;loc) == decl</span>
<span class="lineNum">    6296 </span><span class="lineCov">    1251452 :       &amp;&amp; DECL_INCOMING_RTL (decl)</span>
<span class="lineNum">    6297 </span><span class="lineCov">     625724 :       &amp;&amp; NOTE_VAR_LOCATION_LOC (temp-&gt;first-&gt;loc)</span>
<span class="lineNum">    6298 </span><span class="lineCov">    1243928 :       &amp;&amp; GET_CODE (NOTE_VAR_LOCATION_LOC (temp-&gt;first-&gt;loc))</span>
<span class="lineNum">    6299 </span><span class="lineCov">    1243928 :          == GET_CODE (DECL_INCOMING_RTL (decl))</span>
<span class="lineNum">    6300 </span><span class="lineCov">     621942 :       &amp;&amp; prev_real_insn (as_a&lt;rtx_insn *&gt; (temp-&gt;first-&gt;loc)) == NULL_RTX</span>
<span class="lineNum">    6301 </span><span class="lineCov">   43843808 :       &amp;&amp; (bitsize != -1</span>
<span class="lineNum">    6302 </span><span class="lineCov">     621856 :           || !rtx_equal_p (NOTE_VAR_LOCATION_LOC (temp-&gt;first-&gt;loc),</span>
<span class="lineNum">    6303 </span><span class="lineCov">     621856 :                            NOTE_VAR_LOCATION_LOC (loc_note))</span>
<span class="lineNum">    6304 </span><span class="lineCov">     288372 :           || (NOTE_VAR_LOCATION_STATUS (temp-&gt;first-&gt;loc)</span>
<span class="lineNum">    6305 </span><span class="lineCov">     288372 :               != NOTE_VAR_LOCATION_STATUS (loc_note))))</span>
<span class="lineNum">    6306 </span>            :     {
<span class="lineNum">    6307 </span><span class="lineCov">     333570 :       loc = ggc_cleared_alloc&lt;var_loc_node&gt; ();</span>
<span class="lineNum">    6308 </span><span class="lineCov">     333570 :       temp-&gt;first-&gt;next = loc;</span>
<span class="lineNum">    6309 </span><span class="lineCov">     333570 :       temp-&gt;last = loc;</span>
<span class="lineNum">    6310 </span><span class="lineCov">     333570 :       loc-&gt;loc = construct_piece_list (loc_note, bitpos, bitsize);</span>
<span class="lineNum">    6311 </span>            :     }
<span class="lineNum">    6312 </span><span class="lineCov">   42888296 :   else if (temp-&gt;last)</span>
<span class="lineNum">    6313 </span>            :     {
<span class="lineNum">    6314 </span><span class="lineCov">   35468568 :       struct var_loc_node *last = temp-&gt;last, *unused = NULL;</span>
<span class="lineNum">    6315 </span><span class="lineCov">   35468568 :       rtx *piece_loc = NULL, last_loc_note;</span>
<span class="lineNum">    6316 </span><span class="lineCov">   35468568 :       HOST_WIDE_INT piece_bitpos = 0;</span>
<span class="lineNum">    6317 </span><span class="lineCov">   35468568 :       if (last-&gt;next)</span>
<span class="lineNum">    6318 </span>            :         {
<span class="lineNum">    6319 </span><span class="lineCov">   25811369 :           last = last-&gt;next;</span>
<span class="lineNum">    6320 </span><span class="lineCov">   25811369 :           gcc_assert (last-&gt;next == NULL);</span>
<span class="lineNum">    6321 </span>            :         }
<span class="lineNum">    6322 </span><span class="lineCov">   35468568 :       if (bitsize != -1 &amp;&amp; GET_CODE (last-&gt;loc) == EXPR_LIST)</span>
<span class="lineNum">    6323 </span>            :         {
<span class="lineNum">    6324 </span><span class="lineCov">    3949372 :           piece_loc = &amp;last-&gt;loc;</span>
<span class="lineNum">    6325 </span><span class="lineCov">    6750639 :           do</span>
<span class="lineNum">    6326 </span>            :             {
<span class="lineNum">    6327 </span><span class="lineCov">    6750639 :               HOST_WIDE_INT cur_bitsize = decl_piece_bitsize (*piece_loc);</span>
<span class="lineNum">    6328 </span><span class="lineCov">    6750639 :               if (piece_bitpos + cur_bitsize &gt; bitpos)</span>
<span class="lineNum">    6329 </span>            :                 break;
<span class="lineNum">    6330 </span><span class="lineCov">    3008881 :               piece_bitpos += cur_bitsize;</span>
<span class="lineNum">    6331 </span><span class="lineCov">    3008881 :               piece_loc = &amp;XEXP (*piece_loc, 1);</span>
<span class="lineNum">    6332 </span>            :             }
<span class="lineNum">    6333 </span><span class="lineCov">    3008881 :           while (*piece_loc);</span>
<span class="lineNum">    6334 </span>            :         }
<span class="lineNum">    6335 </span>            :       /* TEMP-&gt;LAST here is either pointer to the last but one or
<span class="lineNum">    6336 </span>            :          last element in the chained list, LAST is pointer to the
<span class="lineNum">    6337 </span>            :          last element.  */
<span class="lineNum">    6338 </span><span class="lineCov">   35468568 :       if (label &amp;&amp; strcmp (last-&gt;label, label) == 0 &amp;&amp; last-&gt;view == view)</span>
<span class="lineNum">    6339 </span>            :         {
<span class="lineNum">    6340 </span>            :           /* For SRA optimized variables if there weren't any real
<span class="lineNum">    6341 </span>            :              insns since last note, just modify the last node.  */
<span class="lineNum">    6342 </span><span class="lineCov">    2493022 :           if (piece_loc != NULL)</span>
<span class="lineNum">    6343 </span>            :             {
<span class="lineNum">    6344 </span><span class="lineCov">    1459042 :               adjust_piece_list (piece_loc, NULL, NULL,</span>
<span class="lineNum">    6345 </span>            :                                  bitpos, piece_bitpos, bitsize, loc_note);
<span class="lineNum">    6346 </span><span class="lineCov">    1459042 :               return NULL;</span>
<span class="lineNum">    6347 </span>            :             }
<span class="lineNum">    6348 </span>            :           /* If the last note doesn't cover any instructions, remove it.  */
<span class="lineNum">    6349 </span><span class="lineCov">    1033980 :           if (temp-&gt;last != last)</span>
<span class="lineNum">    6350 </span>            :             {
<span class="lineNum">    6351 </span><span class="lineCov">     972761 :               temp-&gt;last-&gt;next = NULL;</span>
<span class="lineNum">    6352 </span><span class="lineCov">     972761 :               unused = last;</span>
<span class="lineNum">    6353 </span><span class="lineCov">     972761 :               last = temp-&gt;last;</span>
<span class="lineNum">    6354 </span><span class="lineCov">     972761 :               gcc_assert (strcmp (last-&gt;label, label) != 0 || last-&gt;view != view);</span>
<span class="lineNum">    6355 </span>            :             }
<span class="lineNum">    6356 </span>            :           else
<span class="lineNum">    6357 </span>            :             {
<span class="lineNum">    6358 </span><span class="lineCov">      61219 :               gcc_assert (temp-&gt;first == temp-&gt;last</span>
<span class="lineNum">    6359 </span>            :                           || (temp-&gt;first-&gt;next == temp-&gt;last
<span class="lineNum">    6360 </span>            :                               &amp;&amp; TREE_CODE (decl) == PARM_DECL));
<span class="lineNum">    6361 </span><span class="lineCov">      61219 :               memset (temp-&gt;last, '\0', sizeof (*temp-&gt;last));</span>
<span class="lineNum">    6362 </span><span class="lineCov">      61219 :               temp-&gt;last-&gt;loc = construct_piece_list (loc_note, bitpos, bitsize);</span>
<span class="lineNum">    6363 </span><span class="lineCov">      61219 :               return temp-&gt;last;</span>
<span class="lineNum">    6364 </span>            :             }
<span class="lineNum">    6365 </span>            :         }
<span class="lineNum">    6366 </span><span class="lineCov">   33948307 :       if (bitsize == -1 &amp;&amp; NOTE_P (last-&gt;loc))</span>
<span class="lineNum">    6367 </span>            :         last_loc_note = last-&gt;loc;
<span class="lineNum">    6368 </span><span class="lineCov">    2605808 :       else if (piece_loc != NULL</span>
<span class="lineNum">    6369 </span><span class="lineCov">    2490330 :                &amp;&amp; *piece_loc != NULL_RTX</span>
<span class="lineNum">    6370 </span><span class="lineCov">    2471841 :                &amp;&amp; piece_bitpos == bitpos</span>
<span class="lineNum">    6371 </span><span class="lineCov">    5077384 :                &amp;&amp; decl_piece_bitsize (*piece_loc) == bitsize)</span>
<span class="lineNum">    6372 </span><span class="lineCov">    4942622 :         last_loc_note = *decl_piece_varloc_ptr (*piece_loc);</span>
<span class="lineNum">    6373 </span>            :       else
<span class="lineNum">    6374 </span>            :         last_loc_note = NULL_RTX;
<span class="lineNum">    6375 </span>            :       /* If the current location is the same as the end of the list,
<span class="lineNum">    6376 </span>            :          and either both or neither of the locations is uninitialized,
<span class="lineNum">    6377 </span>            :          we have nothing to do.  */
<span class="lineNum">    6378 </span><span class="lineCov">   33813810 :       if (last_loc_note == NULL_RTX</span>
<span class="lineNum">    6379 </span><span class="lineCov">   33807989 :           || (!rtx_equal_p (NOTE_VAR_LOCATION_LOC (last_loc_note),</span>
<span class="lineNum">    6380 </span><span class="lineCov">   33807989 :                             NOTE_VAR_LOCATION_LOC (loc_note)))</span>
<span class="lineNum">    6381 </span><span class="lineCov">   43739944 :           || ((NOTE_VAR_LOCATION_STATUS (last_loc_note)</span>
<span class="lineNum">    6382 </span><span class="lineCov">    9926134 :                != NOTE_VAR_LOCATION_STATUS (loc_note))</span>
<span class="lineNum">    6383 </span><span class="lineNoCov">          0 :               &amp;&amp; ((NOTE_VAR_LOCATION_STATUS (last_loc_note)</span>
<span class="lineNum">    6384 </span>            :                    == VAR_INIT_STATUS_UNINITIALIZED)
<span class="lineNum">    6385 </span><span class="lineNoCov">          0 :                   || (NOTE_VAR_LOCATION_STATUS (loc_note)</span>
<span class="lineNum">    6386 </span>            :                       == VAR_INIT_STATUS_UNINITIALIZED))))
<span class="lineNum">    6387 </span>            :         {
<span class="lineNum">    6388 </span>            :           /* Add LOC to the end of list and update LAST.  If the last
<span class="lineNum">    6389 </span>            :              element of the list has been removed above, reuse its
<span class="lineNum">    6390 </span>            :              memory for the new node, otherwise allocate a new one.  */
<span class="lineNum">    6391 </span><span class="lineCov">   24022173 :           if (unused)</span>
<span class="lineNum">    6392 </span>            :             {
<span class="lineNum">    6393 </span><span class="lineCov">     754601 :               loc = unused;</span>
<span class="lineNum">    6394 </span><span class="lineCov">     754601 :               memset (loc, '\0', sizeof (*loc));</span>
<span class="lineNum">    6395 </span>            :             }
<span class="lineNum">    6396 </span>            :           else
<span class="lineNum">    6397 </span><span class="lineCov">   46535144 :             loc = ggc_cleared_alloc&lt;var_loc_node&gt; ();</span>
<span class="lineNum">    6398 </span><span class="lineCov">   24022173 :           if (bitsize == -1 || piece_loc == NULL)</span>
<span class="lineNum">    6399 </span><span class="lineCov">   22759584 :             loc-&gt;loc = construct_piece_list (loc_note, bitpos, bitsize);</span>
<span class="lineNum">    6400 </span>            :           else
<span class="lineNum">    6401 </span><span class="lineCov">    1262589 :             adjust_piece_list (&amp;loc-&gt;loc, &amp;last-&gt;loc, piece_loc,</span>
<span class="lineNum">    6402 </span>            :                                bitpos, piece_bitpos, bitsize, loc_note);
<span class="lineNum">    6403 </span><span class="lineCov">   24022173 :           last-&gt;next = loc;</span>
<span class="lineNum">    6404 </span>            :           /* Ensure TEMP-&gt;LAST will point either to the new last but one
<span class="lineNum">    6405 </span>            :              element of the chain, or to the last element in it.  */
<span class="lineNum">    6406 </span><span class="lineCov">   24022173 :           if (last != temp-&gt;last)</span>
<span class="lineNum">    6407 </span><span class="lineCov">   16489751 :             temp-&gt;last = last;</span>
<span class="lineNum">    6408 </span>            :         }
<span class="lineNum">    6409 </span><span class="lineCov">    9926134 :       else if (unused)</span>
<span class="lineNum">    6410 </span><span class="lineCov">     218160 :         ggc_free (unused);</span>
<span class="lineNum">    6411 </span>            :     }
<span class="lineNum">    6412 </span>            :   else
<span class="lineNum">    6413 </span>            :     {
<span class="lineNum">    6414 </span><span class="lineCov">    7419728 :       loc = ggc_cleared_alloc&lt;var_loc_node&gt; ();</span>
<span class="lineNum">    6415 </span><span class="lineCov">    7419728 :       temp-&gt;first = loc;</span>
<span class="lineNum">    6416 </span><span class="lineCov">    7419728 :       temp-&gt;last = loc;</span>
<span class="lineNum">    6417 </span><span class="lineCov">    7419728 :       loc-&gt;loc = construct_piece_list (loc_note, bitpos, bitsize);</span>
<span class="lineNum">    6418 </span>            :     }
<span class="lineNum">    6419 </span>            :   return loc;
<span class="lineNum">    6420 </span>            : }
<span class="lineNum">    6421 </span>            : 
<span class="lineNum">    6422 </span>            : /* Keep track of the number of spaces used to indent the
<span class="lineNum">    6423 </span>            :    output of the debugging routines that print the structure of
<span class="lineNum">    6424 </span>            :    the DIE internal representation.  */
<span class="lineNum">    6425 </span>            : static int print_indent;
<span class="lineNum">    6426 </span>            : 
<span class="lineNum">    6427 </span>            : /* Indent the line the number of spaces given by print_indent.  */
<span class="lineNum">    6428 </span>            : 
<span class="lineNum">    6429 </span>            : static inline void
<span class="lineNum">    6430 </span>            : print_spaces (FILE *outfile)
<span class="lineNum">    6431 </span>            : {
<span class="lineNum">    6432 </span><span class="lineCov">       1692 :   fprintf (outfile, &quot;%*s&quot;, print_indent, &quot;&quot;);</span>
<span class="lineNum">    6433 </span>            : }
<span class="lineNum">    6434 </span>            : 
<span class="lineNum">    6435 </span>            : /* Print a type signature in hex.  */
<span class="lineNum">    6436 </span>            : 
<span class="lineNum">    6437 </span>            : static inline void
<span class="lineNum">    6438 </span>            : print_signature (FILE *outfile, char *sig)
<span class="lineNum">    6439 </span>            : {
<span class="lineNum">    6440 </span><span class="lineNoCov">          0 :   int i;</span>
<span class="lineNum">    6441 </span>            : 
<span class="lineNum">    6442 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; DWARF_TYPE_SIGNATURE_SIZE; i++)</span>
<span class="lineNum">    6443 </span><span class="lineNoCov">          0 :     fprintf (outfile, &quot;%02x&quot;, sig[i] &amp; 0xff);</span>
<span class="lineNum">    6444 </span>            : }
<a name="6445"><span class="lineNum">    6445 </span>            : </a>
<span class="lineNum">    6446 </span>            : static inline void
<span class="lineNum">    6447 </span><span class="lineNoCov">          0 : print_discr_value (FILE *outfile, dw_discr_value *discr_value)</span>
<span class="lineNum">    6448 </span>            : {
<span class="lineNum">    6449 </span><span class="lineNoCov">          0 :   if (discr_value-&gt;pos)</span>
<span class="lineNum">    6450 </span><span class="lineNoCov">          0 :     fprintf (outfile, HOST_WIDE_INT_PRINT_UNSIGNED, discr_value-&gt;v.sval);</span>
<span class="lineNum">    6451 </span>            :   else
<span class="lineNum">    6452 </span><span class="lineNoCov">          0 :     fprintf (outfile, HOST_WIDE_INT_PRINT_DEC, discr_value-&gt;v.uval);</span>
<span class="lineNum">    6453 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    6454 </span>            : 
<span class="lineNum">    6455 </span>            : static void print_loc_descr (dw_loc_descr_ref, FILE *);
<span class="lineNum">    6456 </span>            : 
<span class="lineNum">    6457 </span>            : /* Print the value associated to the VAL DWARF value node to OUTFILE.  If
<span class="lineNum">    6458 </span>            :    RECURSE, output location descriptor operations.  */
<a name="6459"><span class="lineNum">    6459 </span>            : </a>
<span class="lineNum">    6460 </span>            : static void
<span class="lineNum">    6461 </span><span class="lineCov">       1184 : print_dw_val (dw_val_node *val, bool recurse, FILE *outfile)</span>
<span class="lineNum">    6462 </span>            : {
<span class="lineNum">    6463 </span><span class="lineCov">       1184 :   switch (val-&gt;val_class)</span>
<span class="lineNum">    6464 </span>            :     {
<span class="lineNum">    6465 </span><span class="lineCov">         12 :     case dw_val_class_addr:</span>
<span class="lineNum">    6466 </span><span class="lineCov">         12 :       fprintf (outfile, &quot;address&quot;);</span>
<span class="lineNum">    6467 </span><span class="lineCov">         12 :       break;</span>
<span class="lineNum">    6468 </span><span class="lineNoCov">          0 :     case dw_val_class_offset:</span>
<span class="lineNum">    6469 </span><span class="lineNoCov">          0 :       fprintf (outfile, &quot;offset&quot;);</span>
<span class="lineNum">    6470 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    6471 </span><span class="lineCov">         28 :     case dw_val_class_loc:</span>
<span class="lineNum">    6472 </span><span class="lineCov">         28 :       fprintf (outfile, &quot;location descriptor&quot;);</span>
<span class="lineNum">    6473 </span><span class="lineCov">         28 :       if (val-&gt;v.val_loc == NULL)</span>
<span class="lineNum">    6474 </span><span class="lineNoCov">          0 :         fprintf (outfile, &quot; -&gt; &lt;null&gt;\n&quot;);</span>
<span class="lineNum">    6475 </span><span class="lineCov">         28 :       else if (recurse)</span>
<span class="lineNum">    6476 </span>            :         {
<span class="lineNum">    6477 </span><span class="lineCov">         28 :           fprintf (outfile, &quot;:\n&quot;);</span>
<span class="lineNum">    6478 </span><span class="lineCov">         28 :           print_indent += 4;</span>
<span class="lineNum">    6479 </span><span class="lineCov">         28 :           print_loc_descr (val-&gt;v.val_loc, outfile);</span>
<span class="lineNum">    6480 </span><span class="lineCov">         28 :           print_indent -= 4;</span>
<span class="lineNum">    6481 </span>            :         }
<span class="lineNum">    6482 </span>            :       else
<span class="lineNum">    6483 </span>            :         {
<span class="lineNum">    6484 </span><span class="lineNoCov">          0 :           if (flag_dump_noaddr || flag_dump_unnumbered)</span>
<span class="lineNum">    6485 </span><span class="lineNoCov">          0 :             fprintf (outfile, &quot; #\n&quot;);</span>
<span class="lineNum">    6486 </span>            :           else
<span class="lineNum">    6487 </span><span class="lineNoCov">          0 :             fprintf (outfile, &quot; (%p)\n&quot;, (void *) val-&gt;v.val_loc);</span>
<span class="lineNum">    6488 </span>            :         }
<span class="lineNum">    6489 </span>            :       break;
<span class="lineNum">    6490 </span><span class="lineCov">         36 :     case dw_val_class_loc_list:</span>
<span class="lineNum">    6491 </span><span class="lineCov">         72 :       fprintf (outfile, &quot;location list -&gt; label:%s&quot;,</span>
<span class="lineNum">    6492 </span><span class="lineCov">         36 :                val-&gt;v.val_loc_list-&gt;ll_symbol);</span>
<span class="lineNum">    6493 </span><span class="lineCov">         36 :       break;</span>
<span class="lineNum">    6494 </span><span class="lineCov">         36 :     case dw_val_class_view_list:</span>
<span class="lineNum">    6495 </span><span class="lineCov">         36 :       val = view_list_to_loc_list_val_node (val);</span>
<span class="lineNum">    6496 </span><span class="lineCov">         72 :       fprintf (outfile, &quot;location list with views -&gt; labels:%s and %s&quot;,</span>
<span class="lineNum">    6497 </span>            :                val-&gt;v.val_loc_list-&gt;ll_symbol,
<span class="lineNum">    6498 </span><span class="lineCov">         36 :                val-&gt;v.val_loc_list-&gt;vl_symbol);</span>
<span class="lineNum">    6499 </span><span class="lineCov">         36 :       break;</span>
<span class="lineNum">    6500 </span><span class="lineNoCov">          0 :     case dw_val_class_range_list:</span>
<span class="lineNum">    6501 </span><span class="lineNoCov">          0 :       fprintf (outfile, &quot;range list&quot;);</span>
<span class="lineNum">    6502 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    6503 </span><span class="lineNoCov">          0 :     case dw_val_class_const:</span>
<span class="lineNum">    6504 </span><span class="lineNoCov">          0 :     case dw_val_class_const_implicit:</span>
<span class="lineNum">    6505 </span><span class="lineNoCov">          0 :       fprintf (outfile, HOST_WIDE_INT_PRINT_DEC, val-&gt;v.val_int);</span>
<span class="lineNum">    6506 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    6507 </span><span class="lineCov">        452 :     case dw_val_class_unsigned_const:</span>
<span class="lineNum">    6508 </span><span class="lineCov">        452 :     case dw_val_class_unsigned_const_implicit:</span>
<span class="lineNum">    6509 </span><span class="lineCov">        452 :       fprintf (outfile, HOST_WIDE_INT_PRINT_UNSIGNED, val-&gt;v.val_unsigned);</span>
<span class="lineNum">    6510 </span><span class="lineCov">        452 :       break;</span>
<span class="lineNum">    6511 </span><span class="lineNoCov">          0 :     case dw_val_class_const_double:</span>
<span class="lineNum">    6512 </span><span class="lineNoCov">          0 :       fprintf (outfile, &quot;constant (&quot; HOST_WIDE_INT_PRINT_DEC&quot;,&quot;\</span>
<span class="lineNum">    6513 </span>            :                         HOST_WIDE_INT_PRINT_UNSIGNED&quot;)&quot;,
<span class="lineNum">    6514 </span>            :                val-&gt;v.val_double.high,
<span class="lineNum">    6515 </span>            :                val-&gt;v.val_double.low);
<span class="lineNum">    6516 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    6517 </span><span class="lineNoCov">          0 :     case dw_val_class_wide_int:</span>
<span class="lineNum">    6518 </span><span class="lineNoCov">          0 :       {</span>
<span class="lineNum">    6519 </span><span class="lineNoCov">          0 :         int i = val-&gt;v.val_wide-&gt;get_len ();</span>
<span class="lineNum">    6520 </span><span class="lineNoCov">          0 :         fprintf (outfile, &quot;constant (&quot;);</span>
<span class="lineNum">    6521 </span><span class="lineNoCov">          0 :         gcc_assert (i &gt; 0);</span>
<span class="lineNum">    6522 </span><span class="lineNoCov">          0 :         if (val-&gt;v.val_wide-&gt;elt (i - 1) == 0)</span>
<span class="lineNum">    6523 </span><span class="lineNoCov">          0 :           fprintf (outfile, &quot;0x&quot;);</span>
<span class="lineNum">    6524 </span><span class="lineNoCov">          0 :         fprintf (outfile, HOST_WIDE_INT_PRINT_HEX,</span>
<span class="lineNum">    6525 </span><span class="lineNoCov">          0 :                  val-&gt;v.val_wide-&gt;elt (--i));</span>
<span class="lineNum">    6526 </span><span class="lineNoCov">          0 :         while (--i &gt;= 0)</span>
<span class="lineNum">    6527 </span><span class="lineNoCov">          0 :           fprintf (outfile, HOST_WIDE_INT_PRINT_PADDED_HEX,</span>
<span class="lineNum">    6528 </span><span class="lineNoCov">          0 :                    val-&gt;v.val_wide-&gt;elt (i));</span>
<span class="lineNum">    6529 </span><span class="lineNoCov">          0 :         fprintf (outfile, &quot;)&quot;);</span>
<span class="lineNum">    6530 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    6531 </span>            :       }
<span class="lineNum">    6532 </span><span class="lineNoCov">          0 :     case dw_val_class_vec:</span>
<span class="lineNum">    6533 </span><span class="lineNoCov">          0 :       fprintf (outfile, &quot;floating-point or vector constant&quot;);</span>
<span class="lineNum">    6534 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    6535 </span><span class="lineCov">         56 :     case dw_val_class_flag:</span>
<span class="lineNum">    6536 </span><span class="lineCov">         56 :       fprintf (outfile, &quot;%u&quot;, val-&gt;v.val_flag);</span>
<span class="lineNum">    6537 </span><span class="lineCov">         56 :       break;</span>
<span class="lineNum">    6538 </span><span class="lineCov">        216 :     case dw_val_class_die_ref:</span>
<span class="lineNum">    6539 </span><span class="lineCov">        216 :       if (val-&gt;v.val_die_ref.die != NULL)</span>
<span class="lineNum">    6540 </span>            :         {
<span class="lineNum">    6541 </span><span class="lineCov">        216 :           dw_die_ref die = val-&gt;v.val_die_ref.die;</span>
<span class="lineNum">    6542 </span>            : 
<span class="lineNum">    6543 </span><span class="lineCov">        216 :           if (die-&gt;comdat_type_p)</span>
<span class="lineNum">    6544 </span>            :             {
<span class="lineNum">    6545 </span><span class="lineNoCov">          0 :               fprintf (outfile, &quot;die -&gt; signature: &quot;);</span>
<span class="lineNum">    6546 </span><span class="lineNoCov">          0 :               print_signature (outfile,</span>
<span class="lineNum">    6547 </span><span class="lineNoCov">          0 :                                die-&gt;die_id.die_type_node-&gt;signature);</span>
<span class="lineNum">    6548 </span>            :             }
<span class="lineNum">    6549 </span><span class="lineCov">        216 :           else if (die-&gt;die_id.die_symbol)</span>
<span class="lineNum">    6550 </span>            :             {
<span class="lineNum">    6551 </span><span class="lineNoCov">          0 :               fprintf (outfile, &quot;die -&gt; label: %s&quot;, die-&gt;die_id.die_symbol);</span>
<span class="lineNum">    6552 </span><span class="lineNoCov">          0 :               if (die-&gt;with_offset)</span>
<span class="lineNum">    6553 </span><span class="lineNoCov">          0 :                 fprintf (outfile, &quot; + %ld&quot;, die-&gt;die_offset);</span>
<span class="lineNum">    6554 </span>            :             }
<span class="lineNum">    6555 </span>            :           else
<span class="lineNum">    6556 </span><span class="lineCov">        216 :             fprintf (outfile, &quot;die -&gt; %ld&quot;, die-&gt;die_offset);</span>
<span class="lineNum">    6557 </span><span class="lineCov">        216 :           if (flag_dump_noaddr || flag_dump_unnumbered)</span>
<span class="lineNum">    6558 </span><span class="lineCov">        216 :             fprintf (outfile, &quot; #&quot;);</span>
<span class="lineNum">    6559 </span>            :           else
<span class="lineNum">    6560 </span><span class="lineNoCov">          0 :             fprintf (outfile, &quot; (%p)&quot;, (void *) die);</span>
<span class="lineNum">    6561 </span>            :         }
<span class="lineNum">    6562 </span>            :       else
<span class="lineNum">    6563 </span><span class="lineNoCov">          0 :         fprintf (outfile, &quot;die -&gt; &lt;null&gt;&quot;);</span>
<span class="lineNum">    6564 </span>            :       break;
<span class="lineNum">    6565 </span><span class="lineNoCov">          0 :     case dw_val_class_vms_delta:</span>
<span class="lineNum">    6566 </span><span class="lineNoCov">          0 :       fprintf (outfile, &quot;delta: @slotcount(%s-%s)&quot;,</span>
<span class="lineNum">    6567 </span>            :                val-&gt;v.val_vms_delta.lbl2, val-&gt;v.val_vms_delta.lbl1);
<span class="lineNum">    6568 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    6569 </span><span class="lineNoCov">          0 :     case dw_val_class_symview:</span>
<span class="lineNum">    6570 </span><span class="lineNoCov">          0 :       fprintf (outfile, &quot;view: %s&quot;, val-&gt;v.val_symbolic_view);</span>
<span class="lineNum">    6571 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    6572 </span><span class="lineCov">         20 :     case dw_val_class_lbl_id:</span>
<span class="lineNum">    6573 </span><span class="lineCov">         20 :     case dw_val_class_lineptr:</span>
<span class="lineNum">    6574 </span><span class="lineCov">         20 :     case dw_val_class_macptr:</span>
<span class="lineNum">    6575 </span><span class="lineCov">         20 :     case dw_val_class_loclistsptr:</span>
<span class="lineNum">    6576 </span><span class="lineCov">         20 :     case dw_val_class_high_pc:</span>
<span class="lineNum">    6577 </span><span class="lineCov">         20 :       fprintf (outfile, &quot;label: %s&quot;, val-&gt;v.val_lbl_id);</span>
<span class="lineNum">    6578 </span><span class="lineCov">         20 :       break;</span>
<span class="lineNum">    6579 </span><span class="lineCov">        184 :     case dw_val_class_str:</span>
<span class="lineNum">    6580 </span><span class="lineCov">        184 :       if (val-&gt;v.val_str-&gt;str != NULL)</span>
<span class="lineNum">    6581 </span><span class="lineCov">        184 :         fprintf (outfile, &quot;\&quot;%s\&quot;&quot;, val-&gt;v.val_str-&gt;str);</span>
<span class="lineNum">    6582 </span>            :       else
<span class="lineNum">    6583 </span><span class="lineNoCov">          0 :         fprintf (outfile, &quot;&lt;null&gt;&quot;);</span>
<span class="lineNum">    6584 </span>            :       break;
<span class="lineNum">    6585 </span><span class="lineCov">        144 :     case dw_val_class_file:</span>
<span class="lineNum">    6586 </span><span class="lineCov">        144 :     case dw_val_class_file_implicit:</span>
<span class="lineNum">    6587 </span><span class="lineCov">        288 :       fprintf (outfile, &quot;\&quot;%s\&quot; (%d)&quot;, val-&gt;v.val_file-&gt;filename,</span>
<span class="lineNum">    6588 </span><span class="lineCov">        144 :                val-&gt;v.val_file-&gt;emitted_number);</span>
<span class="lineNum">    6589 </span><span class="lineCov">        144 :       break;</span>
<span class="lineNum">    6590 </span>            :     case dw_val_class_data8:
<span class="lineNum">    6591 </span>            :       {
<span class="lineNum">    6592 </span>            :         int i;
<span class="lineNum">    6593 </span>            : 
<span class="lineNum">    6594 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; 8; i++)</span>
<span class="lineNum">    6595 </span><span class="lineNoCov">          0 :           fprintf (outfile, &quot;%02x&quot;, val-&gt;v.val_data8[i]);</span>
<span class="lineNum">    6596 </span>            :         break;
<span class="lineNum">    6597 </span>            :       }
<span class="lineNum">    6598 </span><span class="lineNoCov">          0 :     case dw_val_class_discr_value:</span>
<span class="lineNum">    6599 </span><span class="lineNoCov">          0 :       print_discr_value (outfile, &amp;val-&gt;v.val_discr_value);</span>
<span class="lineNum">    6600 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    6601 </span><span class="lineNoCov">          0 :     case dw_val_class_discr_list:</span>
<span class="lineNum">    6602 </span><span class="lineNoCov">          0 :       for (dw_discr_list_ref node = val-&gt;v.val_discr_list;</span>
<span class="lineNum">    6603 </span><span class="lineNoCov">          0 :            node != NULL;</span>
<span class="lineNum">    6604 </span><span class="lineNoCov">          0 :            node = node-&gt;dw_discr_next)</span>
<span class="lineNum">    6605 </span>            :         {
<span class="lineNum">    6606 </span><span class="lineNoCov">          0 :           if (node-&gt;dw_discr_range)</span>
<span class="lineNum">    6607 </span>            :             {
<span class="lineNum">    6608 </span><span class="lineNoCov">          0 :               fprintf (outfile, &quot; .. &quot;);</span>
<span class="lineNum">    6609 </span><span class="lineNoCov">          0 :               print_discr_value (outfile, &amp;node-&gt;dw_discr_lower_bound);</span>
<span class="lineNum">    6610 </span><span class="lineNoCov">          0 :               print_discr_value (outfile, &amp;node-&gt;dw_discr_upper_bound);</span>
<span class="lineNum">    6611 </span>            :             }
<span class="lineNum">    6612 </span>            :           else
<span class="lineNum">    6613 </span><span class="lineNoCov">          0 :             print_discr_value (outfile, &amp;node-&gt;dw_discr_lower_bound);</span>
<span class="lineNum">    6614 </span>            : 
<span class="lineNum">    6615 </span><span class="lineNoCov">          0 :           if (node-&gt;dw_discr_next != NULL)</span>
<span class="lineNum">    6616 </span><span class="lineNoCov">          0 :             fprintf (outfile, &quot; | &quot;);</span>
<span class="lineNum">    6617 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    6618 </span>            :     default:
<span class="lineNum">    6619 </span>            :       break;
<span class="lineNum">    6620 </span>            :     }
<span class="lineNum">    6621 </span><span class="lineCov">       1184 : }</span>
<span class="lineNum">    6622 </span>            : 
<span class="lineNum">    6623 </span>            : /* Likewise, for a DIE attribute.  */
<a name="6624"><span class="lineNum">    6624 </span>            : </a>
<span class="lineNum">    6625 </span>            : static void
<span class="lineNum">    6626 </span><span class="lineNoCov">          0 : print_attribute (dw_attr_node *a, bool recurse, FILE *outfile)</span>
<span class="lineNum">    6627 </span>            : {
<span class="lineNum">    6628 </span><span class="lineNoCov">          0 :   print_dw_val (&amp;a-&gt;dw_attr_val, recurse, outfile);</span>
<span class="lineNum">    6629 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    6630 </span>            : 
<span class="lineNum">    6631 </span>            : 
<span class="lineNum">    6632 </span>            : /* Print the list of operands in the LOC location description to OUTFILE.  This
<span class="lineNum">    6633 </span>            :    routine is a debugging aid only.  */
<a name="6634"><span class="lineNum">    6634 </span>            : </a>
<span class="lineNum">    6635 </span>            : static void
<span class="lineNum">    6636 </span><span class="lineCov">         28 : print_loc_descr (dw_loc_descr_ref loc, FILE *outfile)</span>
<span class="lineNum">    6637 </span>            : {
<span class="lineNum">    6638 </span><span class="lineCov">         28 :   dw_loc_descr_ref l = loc;</span>
<span class="lineNum">    6639 </span>            : 
<span class="lineNum">    6640 </span><span class="lineCov">         28 :   if (loc == NULL)</span>
<span class="lineNum">    6641 </span>            :     {
<span class="lineNum">    6642 </span><span class="lineNoCov">          0 :       print_spaces (outfile);</span>
<span class="lineNum">    6643 </span><span class="lineNoCov">          0 :       fprintf (outfile, &quot;&lt;null&gt;\n&quot;);</span>
<span class="lineNum">    6644 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    6645 </span>            :     }
<span class="lineNum">    6646 </span>            : 
<span class="lineNum">    6647 </span><span class="lineCov">         56 :   for (l = loc; l != NULL; l = l-&gt;dw_loc_next)</span>
<span class="lineNum">    6648 </span>            :     {
<span class="lineNum">    6649 </span><span class="lineCov">         28 :       print_spaces (outfile);</span>
<span class="lineNum">    6650 </span><span class="lineCov">         28 :       if (flag_dump_noaddr || flag_dump_unnumbered)</span>
<span class="lineNum">    6651 </span><span class="lineCov">         28 :         fprintf (outfile, &quot;#&quot;);</span>
<span class="lineNum">    6652 </span>            :       else
<span class="lineNum">    6653 </span><span class="lineNoCov">          0 :         fprintf (outfile, &quot;(%p)&quot;, (void *) l);</span>
<span class="lineNum">    6654 </span><span class="lineCov">         28 :       fprintf (outfile, &quot; %s&quot;,</span>
<span class="lineNum">    6655 </span><span class="lineCov">         28 :                dwarf_stack_op_name (l-&gt;dw_loc_opc));</span>
<span class="lineNum">    6656 </span><span class="lineCov">         28 :       if (l-&gt;dw_loc_oprnd1.val_class != dw_val_class_none)</span>
<span class="lineNum">    6657 </span>            :         {
<span class="lineNum">    6658 </span><span class="lineCov">         28 :           fprintf (outfile, &quot; &quot;);</span>
<span class="lineNum">    6659 </span><span class="lineCov">         28 :           print_dw_val (&amp;l-&gt;dw_loc_oprnd1, false, outfile);</span>
<span class="lineNum">    6660 </span>            :         }
<span class="lineNum">    6661 </span><span class="lineCov">         28 :       if (l-&gt;dw_loc_oprnd2.val_class != dw_val_class_none)</span>
<span class="lineNum">    6662 </span>            :         {
<span class="lineNum">    6663 </span><span class="lineCov">         28 :           fprintf (outfile, &quot;, &quot;);</span>
<span class="lineNum">    6664 </span><span class="lineCov">         28 :           print_dw_val (&amp;l-&gt;dw_loc_oprnd2, false, outfile);</span>
<span class="lineNum">    6665 </span>            :         }
<span class="lineNum">    6666 </span><span class="lineCov">         28 :       fprintf (outfile, &quot;\n&quot;);</span>
<span class="lineNum">    6667 </span>            :     }
<span class="lineNum">    6668 </span>            : }
<span class="lineNum">    6669 </span>            : 
<span class="lineNum">    6670 </span>            : /* Print the information associated with a given DIE, and its children.
<span class="lineNum">    6671 </span>            :    This routine is a debugging aid only.  */
<a name="6672"><span class="lineNum">    6672 </span>            : </a>
<span class="lineNum">    6673 </span>            : static void
<span class="lineNum">    6674 </span><span class="lineCov">        268 : print_die (dw_die_ref die, FILE *outfile)</span>
<span class="lineNum">    6675 </span>            : {
<span class="lineNum">    6676 </span><span class="lineCov">        268 :   dw_attr_node *a;</span>
<span class="lineNum">    6677 </span><span class="lineCov">        268 :   dw_die_ref c;</span>
<span class="lineNum">    6678 </span><span class="lineCov">        268 :   unsigned ix;</span>
<span class="lineNum">    6679 </span>            : 
<span class="lineNum">    6680 </span><span class="lineCov">        268 :   print_spaces (outfile);</span>
<span class="lineNum">    6681 </span><span class="lineCov">        268 :   fprintf (outfile, &quot;DIE %4ld: %s &quot;,</span>
<span class="lineNum">    6682 </span><span class="lineCov">        268 :            die-&gt;die_offset, dwarf_tag_name (die-&gt;die_tag));</span>
<span class="lineNum">    6683 </span><span class="lineCov">        268 :   if (flag_dump_noaddr || flag_dump_unnumbered)</span>
<span class="lineNum">    6684 </span><span class="lineCov">        268 :     fprintf (outfile, &quot;#\n&quot;);</span>
<span class="lineNum">    6685 </span>            :   else
<span class="lineNum">    6686 </span><span class="lineNoCov">          0 :     fprintf (outfile, &quot;(%p)\n&quot;, (void*) die);</span>
<span class="lineNum">    6687 </span><span class="lineCov">        268 :   print_spaces (outfile);</span>
<span class="lineNum">    6688 </span><span class="lineCov">        268 :   fprintf (outfile, &quot;  abbrev id: %lu&quot;, die-&gt;die_abbrev);</span>
<span class="lineNum">    6689 </span><span class="lineCov">        268 :   fprintf (outfile, &quot; offset: %ld&quot;, die-&gt;die_offset);</span>
<span class="lineNum">    6690 </span><span class="lineCov">        268 :   fprintf (outfile, &quot; mark: %d\n&quot;, die-&gt;die_mark);</span>
<span class="lineNum">    6691 </span>            : 
<span class="lineNum">    6692 </span><span class="lineCov">        268 :   if (die-&gt;comdat_type_p)</span>
<span class="lineNum">    6693 </span>            :     {
<span class="lineNum">    6694 </span><span class="lineNoCov">          0 :       print_spaces (outfile);</span>
<span class="lineNum">    6695 </span><span class="lineNoCov">          0 :       fprintf (outfile, &quot;  signature: &quot;);</span>
<span class="lineNum">    6696 </span><span class="lineNoCov">          0 :       print_signature (outfile, die-&gt;die_id.die_type_node-&gt;signature);</span>
<span class="lineNum">    6697 </span><span class="lineNoCov">          0 :       fprintf (outfile, &quot;\n&quot;);</span>
<span class="lineNum">    6698 </span>            :     }
<span class="lineNum">    6699 </span>            : 
<span class="lineNum">    6700 </span><span class="lineCov">       1396 :   FOR_EACH_VEC_SAFE_ELT (die-&gt;die_attr, ix, a)</span>
<span class="lineNum">    6701 </span>            :     {
<span class="lineNum">    6702 </span><span class="lineCov">       1128 :       print_spaces (outfile);</span>
<span class="lineNum">    6703 </span><span class="lineCov">       1128 :       fprintf (outfile, &quot;  %s: &quot;, dwarf_attr_name (a-&gt;dw_attr));</span>
<span class="lineNum">    6704 </span>            : 
<span class="lineNum">    6705 </span><span class="lineCov">       1128 :       print_attribute (a, true, outfile);</span>
<span class="lineNum">    6706 </span><span class="lineCov">       1128 :       fprintf (outfile, &quot;\n&quot;);</span>
<span class="lineNum">    6707 </span>            :     }
<span class="lineNum">    6708 </span>            : 
<span class="lineNum">    6709 </span><span class="lineCov">        268 :   if (die-&gt;die_child != NULL)</span>
<span class="lineNum">    6710 </span>            :     {
<span class="lineNum">    6711 </span><span class="lineCov">         44 :       print_indent += 4;</span>
<span class="lineNum">    6712 </span><span class="lineCov">        260 :       FOR_EACH_CHILD (die, c, print_die (c, outfile));</span>
<span class="lineNum">    6713 </span><span class="lineCov">         44 :       print_indent -= 4;</span>
<span class="lineNum">    6714 </span>            :     }
<span class="lineNum">    6715 </span><span class="lineCov">        268 :   if (print_indent == 0)</span>
<span class="lineNum">    6716 </span><span class="lineCov">          8 :     fprintf (outfile, &quot;\n&quot;);</span>
<span class="lineNum">    6717 </span><span class="lineCov">        268 : }</span>
<span class="lineNum">    6718 </span>            : 
<span class="lineNum">    6719 </span>            : /* Print the list of operations in the LOC location description.  */
<a name="6720"><span class="lineNum">    6720 </span>            : </a>
<span class="lineNum">    6721 </span>            : DEBUG_FUNCTION void
<span class="lineNum">    6722 </span><span class="lineNoCov">          0 : debug_dwarf_loc_descr (dw_loc_descr_ref loc)</span>
<span class="lineNum">    6723 </span>            : {
<span class="lineNum">    6724 </span><span class="lineNoCov">          0 :   print_loc_descr (loc, stderr);</span>
<span class="lineNum">    6725 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    6726 </span>            : 
<span class="lineNum">    6727 </span>            : /* Print the information collected for a given DIE.  */
<a name="6728"><span class="lineNum">    6728 </span>            : </a>
<span class="lineNum">    6729 </span>            : DEBUG_FUNCTION void
<span class="lineNum">    6730 </span><span class="lineNoCov">          0 : debug_dwarf_die (dw_die_ref die)</span>
<span class="lineNum">    6731 </span>            : {
<span class="lineNum">    6732 </span><span class="lineNoCov">          0 :   print_die (die, stderr);</span>
<span class="lineNum">    6733 </span><span class="lineNoCov">          0 : }</span>
<a name="6734"><span class="lineNum">    6734 </span>            : </a>
<span class="lineNum">    6735 </span>            : DEBUG_FUNCTION void
<span class="lineNum">    6736 </span><span class="lineNoCov">          0 : debug (die_struct &amp;ref)</span>
<span class="lineNum">    6737 </span>            : {
<span class="lineNum">    6738 </span><span class="lineNoCov">          0 :   print_die (&amp;ref, stderr);</span>
<span class="lineNum">    6739 </span><span class="lineNoCov">          0 : }</span>
<a name="6740"><span class="lineNum">    6740 </span>            : </a>
<span class="lineNum">    6741 </span>            : DEBUG_FUNCTION void
<span class="lineNum">    6742 </span><span class="lineNoCov">          0 : debug (die_struct *ptr)</span>
<span class="lineNum">    6743 </span>            : {
<span class="lineNum">    6744 </span><span class="lineNoCov">          0 :   if (ptr)</span>
<span class="lineNum">    6745 </span><span class="lineNoCov">          0 :     debug (*ptr);</span>
<span class="lineNum">    6746 </span>            :   else
<span class="lineNum">    6747 </span><span class="lineNoCov">          0 :     fprintf (stderr, &quot;&lt;nil&gt;\n&quot;);</span>
<span class="lineNum">    6748 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    6749 </span>            : 
<span class="lineNum">    6750 </span>            : 
<span class="lineNum">    6751 </span>            : /* Print all DWARF information collected for the compilation unit.
<span class="lineNum">    6752 </span>            :    This routine is a debugging aid only.  */
<a name="6753"><span class="lineNum">    6753 </span>            : </a>
<span class="lineNum">    6754 </span>            : DEBUG_FUNCTION void
<span class="lineNum">    6755 </span><span class="lineNoCov">          0 : debug_dwarf (void)</span>
<span class="lineNum">    6756 </span>            : {
<span class="lineNum">    6757 </span><span class="lineNoCov">          0 :   print_indent = 0;</span>
<span class="lineNum">    6758 </span><span class="lineNoCov">          0 :   print_die (comp_unit_die (), stderr);</span>
<span class="lineNum">    6759 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    6760 </span>            : 
<span class="lineNum">    6761 </span>            : /* Verify the DIE tree structure.  */
<a name="6762"><span class="lineNum">    6762 </span>            : </a>
<span class="lineNum">    6763 </span>            : DEBUG_FUNCTION void
<span class="lineNum">    6764 </span><span class="lineCov">      33686 : verify_die (dw_die_ref die)</span>
<span class="lineNum">    6765 </span>            : {
<span class="lineNum">    6766 </span><span class="lineCov">      33686 :   gcc_assert (!die-&gt;die_mark);</span>
<span class="lineNum">    6767 </span><span class="lineCov">      33686 :   if (die-&gt;die_parent == NULL</span>
<span class="lineNum">    6768 </span><span class="lineCov">      33686 :       &amp;&amp; die-&gt;die_sib == NULL)</span>
<span class="lineNum">    6769 </span>            :     return;
<span class="lineNum">    6770 </span>            :   /* Verify the die_sib list is cyclic.  */
<span class="lineNum">    6771 </span>            :   dw_die_ref x = die;
<span class="lineNum">    6772 </span><span class="lineNoCov">          0 :   do</span>
<span class="lineNum">    6773 </span>            :     {
<span class="lineNum">    6774 </span><span class="lineNoCov">          0 :       x-&gt;die_mark = 1;</span>
<span class="lineNum">    6775 </span><span class="lineNoCov">          0 :       x = x-&gt;die_sib;</span>
<span class="lineNum">    6776 </span>            :     }
<span class="lineNum">    6777 </span><span class="lineNoCov">          0 :   while (x &amp;&amp; !x-&gt;die_mark);</span>
<span class="lineNum">    6778 </span><span class="lineNoCov">          0 :   gcc_assert (x == die);</span>
<span class="lineNum">    6779 </span>            :   x = die;
<span class="lineNum">    6780 </span><span class="lineNoCov">          0 :   do</span>
<span class="lineNum">    6781 </span>            :     {
<span class="lineNum">    6782 </span>            :       /* Verify all dies have the same parent.  */
<span class="lineNum">    6783 </span><span class="lineNoCov">          0 :       gcc_assert (x-&gt;die_parent == die-&gt;die_parent);</span>
<span class="lineNum">    6784 </span><span class="lineNoCov">          0 :       if (x-&gt;die_child)</span>
<span class="lineNum">    6785 </span>            :         {
<span class="lineNum">    6786 </span>            :           /* Verify the child has the proper parent and recurse.  */
<span class="lineNum">    6787 </span><span class="lineNoCov">          0 :           gcc_assert (x-&gt;die_child-&gt;die_parent == x);</span>
<span class="lineNum">    6788 </span><span class="lineNoCov">          0 :           verify_die (x-&gt;die_child);</span>
<span class="lineNum">    6789 </span>            :         }
<span class="lineNum">    6790 </span><span class="lineNoCov">          0 :       x-&gt;die_mark = 0;</span>
<span class="lineNum">    6791 </span><span class="lineNoCov">          0 :       x = x-&gt;die_sib;</span>
<span class="lineNum">    6792 </span>            :     }
<span class="lineNum">    6793 </span><span class="lineNoCov">          0 :   while (x &amp;&amp; x-&gt;die_mark);</span>
<span class="lineNum">    6794 </span>            : }
<span class="lineNum">    6795 </span>            : 
<span class="lineNum">    6796 </span>            : /* Sanity checks on DIEs.  */
<a name="6797"><span class="lineNum">    6797 </span>            : </a>
<span class="lineNum">    6798 </span>            : static void
<span class="lineNum">    6799 </span><span class="lineCov">   88732179 : check_die (dw_die_ref die)</span>
<span class="lineNum">    6800 </span>            : {
<span class="lineNum">    6801 </span><span class="lineCov">   88732179 :   unsigned ix;</span>
<span class="lineNum">    6802 </span><span class="lineCov">   88732179 :   dw_attr_node *a;</span>
<span class="lineNum">    6803 </span><span class="lineCov">   88732179 :   bool inline_found = false;</span>
<span class="lineNum">    6804 </span><span class="lineCov">   88732179 :   int n_location = 0, n_low_pc = 0, n_high_pc = 0, n_artificial = 0;</span>
<span class="lineNum">    6805 </span><span class="lineCov">   88732179 :   int n_decl_line = 0, n_decl_column = 0, n_decl_file = 0;</span>
<span class="lineNum">    6806 </span><span class="lineCov">  449178796 :   FOR_EACH_VEC_SAFE_ELT (die-&gt;die_attr, ix, a)</span>
<span class="lineNum">    6807 </span>            :     {
<span class="lineNum">    6808 </span><span class="lineCov">  360446617 :       switch (a-&gt;dw_attr)</span>
<span class="lineNum">    6809 </span>            :         {
<span class="lineNum">    6810 </span><span class="lineCov">     269281 :         case DW_AT_inline:</span>
<span class="lineNum">    6811 </span><span class="lineCov">     269281 :           if (a-&gt;dw_attr_val.v.val_unsigned)</span>
<span class="lineNum">    6812 </span><span class="lineCov">     269279 :             inline_found = true;</span>
<span class="lineNum">    6813 </span>            :           break;
<span class="lineNum">    6814 </span><span class="lineNoCov">          0 :         case DW_AT_location:</span>
<span class="lineNum">    6815 </span><span class="lineNoCov">          0 :           ++n_location;</span>
<span class="lineNum">    6816 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    6817 </span><span class="lineCov">     295515 :         case DW_AT_low_pc:</span>
<span class="lineNum">    6818 </span><span class="lineCov">     295515 :           ++n_low_pc;</span>
<span class="lineNum">    6819 </span><span class="lineCov">     295515 :           break;</span>
<span class="lineNum">    6820 </span><span class="lineCov">     295515 :         case DW_AT_high_pc:</span>
<span class="lineNum">    6821 </span><span class="lineCov">     295515 :           ++n_high_pc;</span>
<span class="lineNum">    6822 </span><span class="lineCov">     295515 :           break;</span>
<span class="lineNum">    6823 </span><span class="lineCov">      59160 :         case DW_AT_artificial:</span>
<span class="lineNum">    6824 </span><span class="lineCov">      59160 :           ++n_artificial;</span>
<span class="lineNum">    6825 </span><span class="lineCov">      59160 :           break;</span>
<span class="lineNum">    6826 </span><span class="lineCov">   57361338 :         case DW_AT_decl_column:</span>
<span class="lineNum">    6827 </span><span class="lineCov">   57361338 :           ++n_decl_column;</span>
<span class="lineNum">    6828 </span><span class="lineCov">   57361338 :           break;</span>
<span class="lineNum">    6829 </span><span class="lineCov">   57664820 :         case DW_AT_decl_line:</span>
<span class="lineNum">    6830 </span><span class="lineCov">   57664820 :           ++n_decl_line;</span>
<span class="lineNum">    6831 </span><span class="lineCov">   57664820 :           break;</span>
<span class="lineNum">    6832 </span><span class="lineCov">   57660000 :         case DW_AT_decl_file:</span>
<span class="lineNum">    6833 </span><span class="lineCov">   57660000 :           ++n_decl_file;</span>
<span class="lineNum">    6834 </span><span class="lineCov">   57660000 :           break;</span>
<span class="lineNum">    6835 </span>            :         default:
<span class="lineNum">    6836 </span>            :           break;
<span class="lineNum">    6837 </span>            :         }
<span class="lineNum">    6838 </span>            :     }
<span class="lineNum">    6839 </span><span class="lineCov">   88732179 :   if (n_location &gt; 1 || n_low_pc &gt; 1 || n_high_pc &gt; 1 || n_artificial &gt; 1</span>
<span class="lineNum">    6840 </span><span class="lineCov">   88732179 :       || n_decl_column &gt; 1 || n_decl_line &gt; 1 || n_decl_file &gt; 1)</span>
<span class="lineNum">    6841 </span>            :     {
<span class="lineNum">    6842 </span><span class="lineNoCov">          0 :       fprintf (stderr, &quot;Duplicate attributes in DIE:\n&quot;);</span>
<span class="lineNum">    6843 </span><span class="lineNoCov">          0 :       debug_dwarf_die (die);</span>
<span class="lineNum">    6844 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">    6845 </span>            :     }
<span class="lineNum">    6846 </span><span class="lineCov">   88732179 :   if (inline_found)</span>
<span class="lineNum">    6847 </span>            :     {
<span class="lineNum">    6848 </span>            :       /* A debugging information entry that is a member of an abstract
<span class="lineNum">    6849 </span>            :          instance tree [that has DW_AT_inline] should not contain any
<span class="lineNum">    6850 </span>            :          attributes which describe aspects of the subroutine which vary
<span class="lineNum">    6851 </span>            :          between distinct inlined expansions or distinct out-of-line
<span class="lineNum">    6852 </span>            :          expansions.  */
<span class="lineNum">    6853 </span><span class="lineCov">    2814846 :       FOR_EACH_VEC_SAFE_ELT (die-&gt;die_attr, ix, a)</span>
<span class="lineNum">    6854 </span><span class="lineCov">    2545567 :         gcc_assert (a-&gt;dw_attr != DW_AT_low_pc</span>
<span class="lineNum">    6855 </span>            :                     &amp;&amp; a-&gt;dw_attr != DW_AT_high_pc
<span class="lineNum">    6856 </span>            :                     &amp;&amp; a-&gt;dw_attr != DW_AT_location
<span class="lineNum">    6857 </span>            :                     &amp;&amp; a-&gt;dw_attr != DW_AT_frame_base
<span class="lineNum">    6858 </span>            :                     &amp;&amp; a-&gt;dw_attr != DW_AT_call_all_calls
<span class="lineNum">    6859 </span>            :                     &amp;&amp; a-&gt;dw_attr != DW_AT_GNU_all_call_sites);
<span class="lineNum">    6860 </span>            :     }
<span class="lineNum">    6861 </span><span class="lineCov">   88732179 : }</span>
<span class="lineNum">    6862 </span>            : 
<span class="lineNum">    6863 </span>            : #define CHECKSUM(FOO) md5_process_bytes (&amp;(FOO), sizeof (FOO), ctx)
<span class="lineNum">    6864 </span>            : #define CHECKSUM_BLOCK(FOO, SIZE) md5_process_bytes ((FOO), (SIZE), ctx)
<span class="lineNum">    6865 </span>            : #define CHECKSUM_STRING(FOO) md5_process_bytes ((FOO), strlen (FOO), ctx)
<span class="lineNum">    6866 </span>            : 
<span class="lineNum">    6867 </span>            : /* Calculate the checksum of a location expression.  */
<a name="6868"><span class="lineNum">    6868 </span>            : </a>
<span class="lineNum">    6869 </span>            : static inline void
<span class="lineNum">    6870 </span><span class="lineCov">        560 : loc_checksum (dw_loc_descr_ref loc, struct md5_ctx *ctx)</span>
<span class="lineNum">    6871 </span>            : {
<span class="lineNum">    6872 </span><span class="lineCov">        560 :   int tem;</span>
<span class="lineNum">    6873 </span><span class="lineCov">        560 :   inchash::hash hstate;</span>
<span class="lineNum">    6874 </span><span class="lineCov">        560 :   hashval_t hash;</span>
<span class="lineNum">    6875 </span>            : 
<span class="lineNum">    6876 </span><span class="lineCov">        560 :   tem = (loc-&gt;dtprel &lt;&lt; 8) | ((unsigned int) loc-&gt;dw_loc_opc);</span>
<span class="lineNum">    6877 </span><span class="lineCov">        560 :   CHECKSUM (tem);</span>
<span class="lineNum">    6878 </span><span class="lineCov">        560 :   hash_loc_operands (loc, hstate);</span>
<span class="lineNum">    6879 </span><span class="lineCov">        560 :   hash = hstate.end();</span>
<span class="lineNum">    6880 </span><span class="lineCov">        560 :   CHECKSUM (hash);</span>
<span class="lineNum">    6881 </span><span class="lineCov">        560 : }</span>
<span class="lineNum">    6882 </span>            : 
<span class="lineNum">    6883 </span>            : /* Calculate the checksum of an attribute.  */
<a name="6884"><span class="lineNum">    6884 </span>            : </a>
<span class="lineNum">    6885 </span>            : static void
<span class="lineNum">    6886 </span><span class="lineCov">     730233 : attr_checksum (dw_attr_node *at, struct md5_ctx *ctx, int *mark)</span>
<span class="lineNum">    6887 </span>            : {
<span class="lineNum">    6888 </span><span class="lineCov">     730233 :   dw_loc_descr_ref loc;</span>
<span class="lineNum">    6889 </span><span class="lineCov">     730233 :   rtx r;</span>
<span class="lineNum">    6890 </span>            : 
<span class="lineNum">    6891 </span><span class="lineCov">     730233 :   CHECKSUM (at-&gt;dw_attr);</span>
<span class="lineNum">    6892 </span>            : 
<span class="lineNum">    6893 </span>            :   /* We don't care that this was compiled with a different compiler
<span class="lineNum">    6894 </span>            :      snapshot; if the output is the same, that's what matters.  */
<span class="lineNum">    6895 </span><span class="lineCov">     730233 :   if (at-&gt;dw_attr == DW_AT_producer)</span>
<span class="lineNum">    6896 </span>            :     return;
<span class="lineNum">    6897 </span>            : 
<span class="lineNum">    6898 </span><span class="lineCov">     729421 :   switch (AT_class (at))</span>
<span class="lineNum">    6899 </span>            :     {
<span class="lineNum">    6900 </span><span class="lineCov">         79 :     case dw_val_class_const:</span>
<span class="lineNum">    6901 </span><span class="lineCov">         79 :     case dw_val_class_const_implicit:</span>
<span class="lineNum">    6902 </span><span class="lineCov">         79 :       CHECKSUM (at-&gt;dw_attr_val.v.val_int);</span>
<span class="lineNum">    6903 </span><span class="lineCov">         79 :       break;</span>
<span class="lineNum">    6904 </span><span class="lineCov">     204189 :     case dw_val_class_unsigned_const:</span>
<span class="lineNum">    6905 </span><span class="lineCov">     204189 :     case dw_val_class_unsigned_const_implicit:</span>
<span class="lineNum">    6906 </span><span class="lineCov">     204189 :       CHECKSUM (at-&gt;dw_attr_val.v.val_unsigned);</span>
<span class="lineNum">    6907 </span><span class="lineCov">     204189 :       break;</span>
<span class="lineNum">    6908 </span><span class="lineNoCov">          0 :     case dw_val_class_const_double:</span>
<span class="lineNum">    6909 </span><span class="lineNoCov">          0 :       CHECKSUM (at-&gt;dw_attr_val.v.val_double);</span>
<span class="lineNum">    6910 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    6911 </span><span class="lineNoCov">          0 :     case dw_val_class_wide_int:</span>
<span class="lineNum">    6912 </span><span class="lineNoCov">          0 :       CHECKSUM_BLOCK (at-&gt;dw_attr_val.v.val_wide-&gt;get_val (),</span>
<span class="lineNum">    6913 </span>            :                       get_full_len (*at-&gt;dw_attr_val.v.val_wide)
<span class="lineNum">    6914 </span>            :                       * HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR);
<span class="lineNum">    6915 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    6916 </span><span class="lineCov">         57 :     case dw_val_class_vec:</span>
<span class="lineNum">    6917 </span><span class="lineCov">         57 :       CHECKSUM_BLOCK (at-&gt;dw_attr_val.v.val_vec.array,</span>
<span class="lineNum">    6918 </span>            :                       (at-&gt;dw_attr_val.v.val_vec.length
<span class="lineNum">    6919 </span>            :                        * at-&gt;dw_attr_val.v.val_vec.elt_size));
<span class="lineNum">    6920 </span><span class="lineCov">         57 :       break;</span>
<span class="lineNum">    6921 </span><span class="lineCov">     104066 :     case dw_val_class_flag:</span>
<span class="lineNum">    6922 </span><span class="lineCov">     104066 :       CHECKSUM (at-&gt;dw_attr_val.v.val_flag);</span>
<span class="lineNum">    6923 </span><span class="lineCov">     104066 :       break;</span>
<span class="lineNum">    6924 </span><span class="lineCov">     116001 :     case dw_val_class_str:</span>
<span class="lineNum">    6925 </span><span class="lineCov">     116001 :       CHECKSUM_STRING (AT_string (at));</span>
<span class="lineNum">    6926 </span><span class="lineCov">     116001 :       break;</span>
<span class="lineNum">    6927 </span>            : 
<span class="lineNum">    6928 </span><span class="lineNoCov">          0 :     case dw_val_class_addr:</span>
<span class="lineNum">    6929 </span><span class="lineNoCov">          0 :       r = AT_addr (at);</span>
<span class="lineNum">    6930 </span><span class="lineNoCov">          0 :       gcc_assert (GET_CODE (r) == SYMBOL_REF);</span>
<span class="lineNum">    6931 </span><span class="lineNoCov">          0 :       CHECKSUM_STRING (XSTR (r, 0));</span>
<span class="lineNum">    6932 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    6933 </span>            : 
<span class="lineNum">    6934 </span><span class="lineNoCov">          0 :     case dw_val_class_offset:</span>
<span class="lineNum">    6935 </span><span class="lineNoCov">          0 :       CHECKSUM (at-&gt;dw_attr_val.v.val_offset);</span>
<span class="lineNum">    6936 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    6937 </span>            : 
<span class="lineNum">    6938 </span><span class="lineCov">        251 :     case dw_val_class_loc:</span>
<span class="lineNum">    6939 </span><span class="lineCov">        811 :       for (loc = AT_loc (at); loc; loc = loc-&gt;dw_loc_next)</span>
<span class="lineNum">    6940 </span><span class="lineCov">        560 :         loc_checksum (loc, ctx);</span>
<span class="lineNum">    6941 </span>            :       break;
<span class="lineNum">    6942 </span>            : 
<span class="lineNum">    6943 </span><span class="lineCov">     231656 :     case dw_val_class_die_ref:</span>
<span class="lineNum">    6944 </span><span class="lineCov">     231656 :       die_checksum (AT_ref (at), ctx, mark);</span>
<span class="lineNum">    6945 </span><span class="lineCov">     231656 :       break;</span>
<span class="lineNum">    6946 </span>            : 
<span class="lineNum">    6947 </span>            :     case dw_val_class_fde_ref:
<span class="lineNum">    6948 </span>            :     case dw_val_class_vms_delta:
<span class="lineNum">    6949 </span>            :     case dw_val_class_symview:
<span class="lineNum">    6950 </span>            :     case dw_val_class_lbl_id:
<span class="lineNum">    6951 </span>            :     case dw_val_class_lineptr:
<span class="lineNum">    6952 </span>            :     case dw_val_class_macptr:
<span class="lineNum">    6953 </span>            :     case dw_val_class_loclistsptr:
<span class="lineNum">    6954 </span>            :     case dw_val_class_high_pc:
<span class="lineNum">    6955 </span>            :       break;
<span class="lineNum">    6956 </span>            : 
<span class="lineNum">    6957 </span><span class="lineCov">      72277 :     case dw_val_class_file:</span>
<span class="lineNum">    6958 </span><span class="lineCov">      72277 :     case dw_val_class_file_implicit:</span>
<span class="lineNum">    6959 </span><span class="lineCov">      72277 :       CHECKSUM_STRING (AT_file (at)-&gt;filename);</span>
<span class="lineNum">    6960 </span><span class="lineCov">      72277 :       break;</span>
<span class="lineNum">    6961 </span>            : 
<span class="lineNum">    6962 </span><span class="lineNoCov">          0 :     case dw_val_class_data8:</span>
<span class="lineNum">    6963 </span><span class="lineNoCov">          0 :       CHECKSUM (at-&gt;dw_attr_val.v.val_data8);</span>
<span class="lineNum">    6964 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    6965 </span>            : 
<span class="lineNum">    6966 </span>            :     default:
<span class="lineNum">    6967 </span>            :       break;
<span class="lineNum">    6968 </span>            :     }
<span class="lineNum">    6969 </span>            : }
<span class="lineNum">    6970 </span>            : 
<span class="lineNum">    6971 </span>            : /* Calculate the checksum of a DIE.  */
<a name="6972"><span class="lineNum">    6972 </span>            : </a>
<span class="lineNum">    6973 </span>            : static void
<span class="lineNum">    6974 </span><span class="lineCov">     416805 : die_checksum (dw_die_ref die, struct md5_ctx *ctx, int *mark)</span>
<span class="lineNum">    6975 </span>            : {
<span class="lineNum">    6976 </span><span class="lineCov">     416805 :   dw_die_ref c;</span>
<span class="lineNum">    6977 </span><span class="lineCov">     416805 :   dw_attr_node *a;</span>
<span class="lineNum">    6978 </span><span class="lineCov">     416805 :   unsigned ix;</span>
<span class="lineNum">    6979 </span>            : 
<span class="lineNum">    6980 </span>            :   /* To avoid infinite recursion.  */
<span class="lineNum">    6981 </span><span class="lineCov">     416805 :   if (die-&gt;die_mark)</span>
<span class="lineNum">    6982 </span>            :     {
<span class="lineNum">    6983 </span><span class="lineCov">     231656 :       CHECKSUM (die-&gt;die_mark);</span>
<span class="lineNum">    6984 </span><span class="lineCov">     231656 :       return;</span>
<span class="lineNum">    6985 </span>            :     }
<span class="lineNum">    6986 </span><span class="lineCov">     185149 :   die-&gt;die_mark = ++(*mark);</span>
<span class="lineNum">    6987 </span>            : 
<span class="lineNum">    6988 </span><span class="lineCov">     185149 :   CHECKSUM (die-&gt;die_tag);</span>
<span class="lineNum">    6989 </span>            : 
<span class="lineNum">    6990 </span><span class="lineCov">     915382 :   FOR_EACH_VEC_SAFE_ELT (die-&gt;die_attr, ix, a)</span>
<span class="lineNum">    6991 </span><span class="lineCov">     730233 :     attr_checksum (a, ctx, mark);</span>
<span class="lineNum">    6992 </span>            : 
<span class="lineNum">    6993 </span><span class="lineCov">     323873 :   FOR_EACH_CHILD (die, c, die_checksum (c, ctx, mark));</span>
<span class="lineNum">    6994 </span>            : }
<span class="lineNum">    6995 </span>            : 
<span class="lineNum">    6996 </span>            : #undef CHECKSUM
<span class="lineNum">    6997 </span>            : #undef CHECKSUM_BLOCK
<span class="lineNum">    6998 </span>            : #undef CHECKSUM_STRING
<span class="lineNum">    6999 </span>            : 
<span class="lineNum">    7000 </span>            : /* For DWARF-4 types, include the trailing NULL when checksumming strings.  */
<span class="lineNum">    7001 </span>            : #define CHECKSUM(FOO) md5_process_bytes (&amp;(FOO), sizeof (FOO), ctx)
<span class="lineNum">    7002 </span>            : #define CHECKSUM_BLOCK(FOO, SIZE) md5_process_bytes ((FOO), (SIZE), ctx)
<span class="lineNum">    7003 </span>            : #define CHECKSUM_STRING(FOO) md5_process_bytes ((FOO), strlen (FOO) + 1, ctx)
<span class="lineNum">    7004 </span>            : #define CHECKSUM_SLEB128(FOO) checksum_sleb128 ((FOO), ctx)
<span class="lineNum">    7005 </span>            : #define CHECKSUM_ULEB128(FOO) checksum_uleb128 ((FOO), ctx)
<span class="lineNum">    7006 </span>            : #define CHECKSUM_ATTR(FOO) \
<span class="lineNum">    7007 </span>            :   if (FOO) attr_checksum_ordered (die-&gt;die_tag, (FOO), ctx, mark)
<span class="lineNum">    7008 </span>            : 
<span class="lineNum">    7009 </span>            : /* Calculate the checksum of a number in signed LEB128 format.  */
<a name="7010"><span class="lineNum">    7010 </span>            : </a>
<span class="lineNum">    7011 </span>            : static void
<span class="lineNum">    7012 </span><span class="lineCov">        163 : checksum_sleb128 (HOST_WIDE_INT value, struct md5_ctx *ctx)</span>
<span class="lineNum">    7013 </span>            : {
<span class="lineNum">    7014 </span><span class="lineCov">        163 :   unsigned char byte;</span>
<span class="lineNum">    7015 </span><span class="lineCov">        163 :   bool more;</span>
<span class="lineNum">    7016 </span>            : 
<span class="lineNum">    7017 </span><span class="lineCov">        163 :   while (1)</span>
<span class="lineNum">    7018 </span>            :     {
<span class="lineNum">    7019 </span><span class="lineCov">        163 :       byte = (value &amp; 0x7f);</span>
<span class="lineNum">    7020 </span><span class="lineCov">        163 :       value &gt;&gt;= 7;</span>
<span class="lineNum">    7021 </span><span class="lineCov">        163 :       more = !((value == 0 &amp;&amp; (byte &amp; 0x40) == 0)</span>
<span class="lineNum">    7022 </span><span class="lineNoCov">          0 :                 || (value == -1 &amp;&amp; (byte &amp; 0x40) != 0));</span>
<span class="lineNum">    7023 </span>            :       if (more)
<span class="lineNum">    7024 </span><span class="lineNoCov">          0 :         byte |= 0x80;</span>
<span class="lineNum">    7025 </span><span class="lineCov">        163 :       CHECKSUM (byte);</span>
<span class="lineNum">    7026 </span><span class="lineCov">        163 :       if (!more)</span>
<span class="lineNum">    7027 </span>            :         break;
<span class="lineNum">    7028 </span>            :     }
<span class="lineNum">    7029 </span><span class="lineCov">        163 : }</span>
<span class="lineNum">    7030 </span>            : 
<span class="lineNum">    7031 </span>            : /* Calculate the checksum of a number in unsigned LEB128 format.  */
<a name="7032"><span class="lineNum">    7032 </span>            : </a>
<span class="lineNum">    7033 </span>            : static void
<span class="lineNum">    7034 </span><span class="lineCov">     168714 : checksum_uleb128 (unsigned HOST_WIDE_INT value, struct md5_ctx *ctx)</span>
<span class="lineNum">    7035 </span>            : {
<span class="lineNum">    7036 </span><span class="lineCov">     172656 :   while (1)</span>
<span class="lineNum">    7037 </span>            :     {
<span class="lineNum">    7038 </span><span class="lineCov">     172656 :       unsigned char byte = (value &amp; 0x7f);</span>
<span class="lineNum">    7039 </span><span class="lineCov">     172656 :       value &gt;&gt;= 7;</span>
<span class="lineNum">    7040 </span><span class="lineCov">     172656 :       if (value != 0)</span>
<span class="lineNum">    7041 </span>            :         /* More bytes to follow.  */
<span class="lineNum">    7042 </span><span class="lineCov">       3942 :         byte |= 0x80;</span>
<span class="lineNum">    7043 </span><span class="lineCov">     172656 :       CHECKSUM (byte);</span>
<span class="lineNum">    7044 </span><span class="lineCov">     172656 :       if (value == 0)</span>
<span class="lineNum">    7045 </span>            :         break;
<span class="lineNum">    7046 </span><span class="lineCov">       3942 :     }</span>
<span class="lineNum">    7047 </span><span class="lineCov">     168714 : }</span>
<span class="lineNum">    7048 </span>            : 
<span class="lineNum">    7049 </span>            : /* Checksum the context of the DIE.  This adds the names of any
<span class="lineNum">    7050 </span>            :    surrounding namespaces or structures to the checksum.  */
<a name="7051"><span class="lineNum">    7051 </span>            : </a>
<span class="lineNum">    7052 </span>            : static void
<span class="lineNum">    7053 </span><span class="lineCov">        206 : checksum_die_context (dw_die_ref die, struct md5_ctx *ctx)</span>
<span class="lineNum">    7054 </span>            : {
<span class="lineNum">    7055 </span><span class="lineCov">        206 :   const char *name;</span>
<span class="lineNum">    7056 </span><span class="lineCov">        206 :   dw_die_ref spec;</span>
<span class="lineNum">    7057 </span><span class="lineCov">        206 :   int tag = die-&gt;die_tag;</span>
<span class="lineNum">    7058 </span>            : 
<span class="lineNum">    7059 </span><span class="lineCov">        412 :   if (tag != DW_TAG_namespace</span>
<span class="lineNum">    7060 </span><span class="lineCov">        206 :       &amp;&amp; tag != DW_TAG_structure_type</span>
<span class="lineNum">    7061 </span><span class="lineCov">        139 :       &amp;&amp; tag != DW_TAG_class_type)</span>
<span class="lineNum">    7062 </span>            :     return;
<span class="lineNum">    7063 </span>            : 
<span class="lineNum">    7064 </span><span class="lineCov">         71 :   name = get_AT_string (die, DW_AT_name);</span>
<span class="lineNum">    7065 </span>            : 
<span class="lineNum">    7066 </span><span class="lineCov">         71 :   spec = get_AT_ref (die, DW_AT_specification);</span>
<span class="lineNum">    7067 </span><span class="lineCov">         71 :   if (spec != NULL)</span>
<span class="lineNum">    7068 </span><span class="lineNoCov">          0 :     die = spec;</span>
<span class="lineNum">    7069 </span>            : 
<span class="lineNum">    7070 </span><span class="lineCov">         71 :   if (die-&gt;die_parent != NULL)</span>
<span class="lineNum">    7071 </span><span class="lineCov">         71 :     checksum_die_context (die-&gt;die_parent, ctx);</span>
<span class="lineNum">    7072 </span>            : 
<span class="lineNum">    7073 </span><span class="lineCov">         71 :   CHECKSUM_ULEB128 ('C');</span>
<span class="lineNum">    7074 </span><span class="lineCov">         71 :   CHECKSUM_ULEB128 (tag);</span>
<span class="lineNum">    7075 </span><span class="lineCov">         71 :   if (name != NULL)</span>
<span class="lineNum">    7076 </span><span class="lineCov">         56 :     CHECKSUM_STRING (name);</span>
<span class="lineNum">    7077 </span>            : }
<span class="lineNum">    7078 </span>            : 
<span class="lineNum">    7079 </span>            : /* Calculate the checksum of a location expression.  */
<a name="7080"><span class="lineNum">    7080 </span>            : </a>
<span class="lineNum">    7081 </span>            : static inline void
<span class="lineNum">    7082 </span><span class="lineNoCov">          0 : loc_checksum_ordered (dw_loc_descr_ref loc, struct md5_ctx *ctx)</span>
<span class="lineNum">    7083 </span>            : {
<span class="lineNum">    7084 </span>            :   /* Special case for lone DW_OP_plus_uconst: checksum as if the location
<span class="lineNum">    7085 </span>            :      were emitted as a DW_FORM_sdata instead of a location expression.  */
<span class="lineNum">    7086 </span><span class="lineNoCov">          0 :   if (loc-&gt;dw_loc_opc == DW_OP_plus_uconst &amp;&amp; loc-&gt;dw_loc_next == NULL)</span>
<span class="lineNum">    7087 </span>            :     {
<span class="lineNum">    7088 </span><span class="lineNoCov">          0 :       CHECKSUM_ULEB128 (DW_FORM_sdata);</span>
<span class="lineNum">    7089 </span><span class="lineNoCov">          0 :       CHECKSUM_SLEB128 ((HOST_WIDE_INT) loc-&gt;dw_loc_oprnd1.v.val_unsigned);</span>
<span class="lineNum">    7090 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    7091 </span>            :     }
<span class="lineNum">    7092 </span>            : 
<span class="lineNum">    7093 </span>            :   /* Otherwise, just checksum the raw location expression.  */
<span class="lineNum">    7094 </span><span class="lineNoCov">          0 :   while (loc != NULL)</span>
<span class="lineNum">    7095 </span>            :     {
<span class="lineNum">    7096 </span><span class="lineNoCov">          0 :       inchash::hash hstate;</span>
<span class="lineNum">    7097 </span><span class="lineNoCov">          0 :       hashval_t hash;</span>
<span class="lineNum">    7098 </span>            : 
<span class="lineNum">    7099 </span><span class="lineNoCov">          0 :       CHECKSUM_ULEB128 (loc-&gt;dtprel);</span>
<span class="lineNum">    7100 </span><span class="lineNoCov">          0 :       CHECKSUM_ULEB128 (loc-&gt;dw_loc_opc);</span>
<span class="lineNum">    7101 </span><span class="lineNoCov">          0 :       hash_loc_operands (loc, hstate);</span>
<span class="lineNum">    7102 </span><span class="lineNoCov">          0 :       hash = hstate.end ();</span>
<span class="lineNum">    7103 </span><span class="lineNoCov">          0 :       CHECKSUM (hash);</span>
<span class="lineNum">    7104 </span><span class="lineNoCov">          0 :       loc = loc-&gt;dw_loc_next;</span>
<span class="lineNum">    7105 </span>            :     }
<span class="lineNum">    7106 </span>            : }
<span class="lineNum">    7107 </span>            : 
<span class="lineNum">    7108 </span>            : /* Calculate the checksum of an attribute.  */
<a name="7109"><span class="lineNum">    7109 </span>            : </a>
<span class="lineNum">    7110 </span>            : static void
<span class="lineNum">    7111 </span><span class="lineCov">        343 : attr_checksum_ordered (enum dwarf_tag tag, dw_attr_node *at,</span>
<span class="lineNum">    7112 </span>            :                        struct md5_ctx *ctx, int *mark)
<span class="lineNum">    7113 </span>            : {
<span class="lineNum">    7114 </span><span class="lineCov">        343 :   dw_loc_descr_ref loc;</span>
<span class="lineNum">    7115 </span><span class="lineCov">        343 :   rtx r;</span>
<span class="lineNum">    7116 </span>            : 
<span class="lineNum">    7117 </span><span class="lineCov">        343 :   if (AT_class (at) == dw_val_class_die_ref)</span>
<span class="lineNum">    7118 </span>            :     {
<span class="lineNum">    7119 </span><span class="lineCov">        106 :       dw_die_ref target_die = AT_ref (at);</span>
<span class="lineNum">    7120 </span>            : 
<span class="lineNum">    7121 </span>            :       /* For pointer and reference types, we checksum only the (qualified)
<span class="lineNum">    7122 </span>            :          name of the target type (if there is a name).  For friend entries,
<span class="lineNum">    7123 </span>            :          we checksum only the (qualified) name of the target type or function.
<span class="lineNum">    7124 </span>            :          This allows the checksum to remain the same whether the target type
<span class="lineNum">    7125 </span>            :          is complete or not.  */
<span class="lineNum">    7126 </span><span class="lineCov">         53 :       if ((at-&gt;dw_attr == DW_AT_type</span>
<span class="lineNum">    7127 </span><span class="lineCov">         50 :            &amp;&amp; (tag == DW_TAG_pointer_type</span>
<span class="lineNum">    7128 </span><span class="lineCov">         50 :                || tag == DW_TAG_reference_type</span>
<span class="lineNum">    7129 </span><span class="lineCov">         50 :                || tag == DW_TAG_rvalue_reference_type</span>
<span class="lineNum">    7130 </span><span class="lineCov">         48 :                || tag == DW_TAG_ptr_to_member_type))</span>
<span class="lineNum">    7131 </span><span class="lineCov">         51 :           || (at-&gt;dw_attr == DW_AT_friend</span>
<span class="lineNum">    7132 </span><span class="lineNoCov">          0 :               &amp;&amp; tag == DW_TAG_friend))</span>
<span class="lineNum">    7133 </span>            :         {
<span class="lineNum">    7134 </span><span class="lineCov">          2 :           dw_attr_node *name_attr = get_AT (target_die, DW_AT_name);</span>
<span class="lineNum">    7135 </span>            : 
<span class="lineNum">    7136 </span><span class="lineCov">          2 :           if (name_attr != NULL)</span>
<span class="lineNum">    7137 </span>            :             {
<span class="lineNum">    7138 </span><span class="lineNoCov">          0 :               dw_die_ref decl = get_AT_ref (target_die, DW_AT_specification);</span>
<span class="lineNum">    7139 </span>            : 
<span class="lineNum">    7140 </span><span class="lineNoCov">          0 :               if (decl == NULL)</span>
<span class="lineNum">    7141 </span><span class="lineNoCov">          0 :                 decl = target_die;</span>
<span class="lineNum">    7142 </span><span class="lineNoCov">          0 :               CHECKSUM_ULEB128 ('N');</span>
<span class="lineNum">    7143 </span><span class="lineNoCov">          0 :               CHECKSUM_ULEB128 (at-&gt;dw_attr);</span>
<span class="lineNum">    7144 </span><span class="lineNoCov">          0 :               if (decl-&gt;die_parent != NULL)</span>
<span class="lineNum">    7145 </span><span class="lineNoCov">          0 :                 checksum_die_context (decl-&gt;die_parent, ctx);</span>
<span class="lineNum">    7146 </span><span class="lineNoCov">          0 :               CHECKSUM_ULEB128 ('E');</span>
<span class="lineNum">    7147 </span><span class="lineNoCov">          0 :               CHECKSUM_STRING (AT_string (name_attr));</span>
<span class="lineNum">    7148 </span><span class="lineNoCov">          0 :               return;</span>
<span class="lineNum">    7149 </span>            :             }
<span class="lineNum">    7150 </span>            :         }
<span class="lineNum">    7151 </span>            : 
<span class="lineNum">    7152 </span>            :       /* For all other references to another DIE, we check to see if the
<span class="lineNum">    7153 </span>            :          target DIE has already been visited.  If it has, we emit a
<span class="lineNum">    7154 </span>            :          backward reference; if not, we descend recursively.  */
<span class="lineNum">    7155 </span><span class="lineCov">         53 :       if (target_die-&gt;die_mark &gt; 0)</span>
<span class="lineNum">    7156 </span>            :         {
<span class="lineNum">    7157 </span><span class="lineCov">         12 :           CHECKSUM_ULEB128 ('R');</span>
<span class="lineNum">    7158 </span><span class="lineCov">         12 :           CHECKSUM_ULEB128 (at-&gt;dw_attr);</span>
<span class="lineNum">    7159 </span><span class="lineCov">         12 :           CHECKSUM_ULEB128 (target_die-&gt;die_mark);</span>
<span class="lineNum">    7160 </span>            :         }
<span class="lineNum">    7161 </span>            :       else
<span class="lineNum">    7162 </span>            :         {
<span class="lineNum">    7163 </span><span class="lineCov">         41 :           dw_die_ref decl = get_AT_ref (target_die, DW_AT_specification);</span>
<span class="lineNum">    7164 </span>            : 
<span class="lineNum">    7165 </span><span class="lineCov">         41 :           if (decl == NULL)</span>
<span class="lineNum">    7166 </span><span class="lineCov">         39 :             decl = target_die;</span>
<span class="lineNum">    7167 </span><span class="lineCov">         41 :           target_die-&gt;die_mark = ++(*mark);</span>
<span class="lineNum">    7168 </span><span class="lineCov">         41 :           CHECKSUM_ULEB128 ('T');</span>
<span class="lineNum">    7169 </span><span class="lineCov">         41 :           CHECKSUM_ULEB128 (at-&gt;dw_attr);</span>
<span class="lineNum">    7170 </span><span class="lineCov">         41 :           if (decl-&gt;die_parent != NULL)</span>
<span class="lineNum">    7171 </span><span class="lineCov">         41 :             checksum_die_context (decl-&gt;die_parent, ctx);</span>
<span class="lineNum">    7172 </span><span class="lineCov">         41 :           die_checksum_ordered (target_die, ctx, mark);</span>
<span class="lineNum">    7173 </span>            :         }
<span class="lineNum">    7174 </span><span class="lineCov">         53 :       return;</span>
<span class="lineNum">    7175 </span>            :     }
<span class="lineNum">    7176 </span>            : 
<span class="lineNum">    7177 </span><span class="lineCov">        290 :   CHECKSUM_ULEB128 ('A');</span>
<span class="lineNum">    7178 </span><span class="lineCov">        290 :   CHECKSUM_ULEB128 (at-&gt;dw_attr);</span>
<span class="lineNum">    7179 </span>            : 
<span class="lineNum">    7180 </span><span class="lineCov">        290 :   switch (AT_class (at))</span>
<span class="lineNum">    7181 </span>            :     {
<span class="lineNum">    7182 </span><span class="lineNoCov">          0 :     case dw_val_class_const:</span>
<span class="lineNum">    7183 </span><span class="lineNoCov">          0 :     case dw_val_class_const_implicit:</span>
<span class="lineNum">    7184 </span><span class="lineNoCov">          0 :       CHECKSUM_ULEB128 (DW_FORM_sdata);</span>
<span class="lineNum">    7185 </span><span class="lineNoCov">          0 :       CHECKSUM_SLEB128 (at-&gt;dw_attr_val.v.val_int);</span>
<span class="lineNum">    7186 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    7187 </span>            : 
<span class="lineNum">    7188 </span><span class="lineCov">        163 :     case dw_val_class_unsigned_const:</span>
<span class="lineNum">    7189 </span><span class="lineCov">        163 :     case dw_val_class_unsigned_const_implicit:</span>
<span class="lineNum">    7190 </span><span class="lineCov">        163 :       CHECKSUM_ULEB128 (DW_FORM_sdata);</span>
<span class="lineNum">    7191 </span><span class="lineCov">        163 :       CHECKSUM_SLEB128 ((int) at-&gt;dw_attr_val.v.val_unsigned);</span>
<span class="lineNum">    7192 </span><span class="lineCov">        163 :       break;</span>
<span class="lineNum">    7193 </span>            : 
<span class="lineNum">    7194 </span><span class="lineNoCov">          0 :     case dw_val_class_const_double:</span>
<span class="lineNum">    7195 </span><span class="lineNoCov">          0 :       CHECKSUM_ULEB128 (DW_FORM_block);</span>
<span class="lineNum">    7196 </span><span class="lineNoCov">          0 :       CHECKSUM_ULEB128 (sizeof (at-&gt;dw_attr_val.v.val_double));</span>
<span class="lineNum">    7197 </span><span class="lineNoCov">          0 :       CHECKSUM (at-&gt;dw_attr_val.v.val_double);</span>
<span class="lineNum">    7198 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    7199 </span>            : 
<span class="lineNum">    7200 </span><span class="lineNoCov">          0 :     case dw_val_class_wide_int:</span>
<span class="lineNum">    7201 </span><span class="lineNoCov">          0 :       CHECKSUM_ULEB128 (DW_FORM_block);</span>
<span class="lineNum">    7202 </span><span class="lineNoCov">          0 :       CHECKSUM_ULEB128 (get_full_len (*at-&gt;dw_attr_val.v.val_wide)</span>
<span class="lineNum">    7203 </span>            :                         * HOST_BITS_PER_WIDE_INT / BITS_PER_UNIT);
<span class="lineNum">    7204 </span><span class="lineNoCov">          0 :       CHECKSUM_BLOCK (at-&gt;dw_attr_val.v.val_wide-&gt;get_val (),</span>
<span class="lineNum">    7205 </span>            :                       get_full_len (*at-&gt;dw_attr_val.v.val_wide)
<span class="lineNum">    7206 </span>            :                       * HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR);
<span class="lineNum">    7207 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    7208 </span>            : 
<span class="lineNum">    7209 </span><span class="lineNoCov">          0 :     case dw_val_class_vec:</span>
<span class="lineNum">    7210 </span><span class="lineNoCov">          0 :       CHECKSUM_ULEB128 (DW_FORM_block);</span>
<span class="lineNum">    7211 </span><span class="lineNoCov">          0 :       CHECKSUM_ULEB128 (at-&gt;dw_attr_val.v.val_vec.length</span>
<span class="lineNum">    7212 </span>            :                         * at-&gt;dw_attr_val.v.val_vec.elt_size);
<span class="lineNum">    7213 </span><span class="lineNoCov">          0 :       CHECKSUM_BLOCK (at-&gt;dw_attr_val.v.val_vec.array,</span>
<span class="lineNum">    7214 </span>            :                       (at-&gt;dw_attr_val.v.val_vec.length
<span class="lineNum">    7215 </span>            :                        * at-&gt;dw_attr_val.v.val_vec.elt_size));
<span class="lineNum">    7216 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    7217 </span>            : 
<span class="lineNum">    7218 </span><span class="lineNoCov">          0 :     case dw_val_class_flag:</span>
<span class="lineNum">    7219 </span><span class="lineNoCov">          0 :       CHECKSUM_ULEB128 (DW_FORM_flag);</span>
<span class="lineNum">    7220 </span><span class="lineNoCov">          0 :       CHECKSUM_ULEB128 (at-&gt;dw_attr_val.v.val_flag ? 1 : 0);</span>
<span class="lineNum">    7221 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    7222 </span>            : 
<span class="lineNum">    7223 </span><span class="lineCov">        127 :     case dw_val_class_str:</span>
<span class="lineNum">    7224 </span><span class="lineCov">        127 :       CHECKSUM_ULEB128 (DW_FORM_string);</span>
<span class="lineNum">    7225 </span><span class="lineCov">        127 :       CHECKSUM_STRING (AT_string (at));</span>
<span class="lineNum">    7226 </span><span class="lineCov">        127 :       break;</span>
<span class="lineNum">    7227 </span>            : 
<span class="lineNum">    7228 </span><span class="lineNoCov">          0 :     case dw_val_class_addr:</span>
<span class="lineNum">    7229 </span><span class="lineNoCov">          0 :       r = AT_addr (at);</span>
<span class="lineNum">    7230 </span><span class="lineNoCov">          0 :       gcc_assert (GET_CODE (r) == SYMBOL_REF);</span>
<span class="lineNum">    7231 </span><span class="lineNoCov">          0 :       CHECKSUM_ULEB128 (DW_FORM_string);</span>
<span class="lineNum">    7232 </span><span class="lineNoCov">          0 :       CHECKSUM_STRING (XSTR (r, 0));</span>
<span class="lineNum">    7233 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    7234 </span>            : 
<span class="lineNum">    7235 </span><span class="lineNoCov">          0 :     case dw_val_class_offset:</span>
<span class="lineNum">    7236 </span><span class="lineNoCov">          0 :       CHECKSUM_ULEB128 (DW_FORM_sdata);</span>
<span class="lineNum">    7237 </span><span class="lineNoCov">          0 :       CHECKSUM_ULEB128 (at-&gt;dw_attr_val.v.val_offset);</span>
<span class="lineNum">    7238 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    7239 </span>            : 
<span class="lineNum">    7240 </span><span class="lineNoCov">          0 :     case dw_val_class_loc:</span>
<span class="lineNum">    7241 </span><span class="lineNoCov">          0 :       for (loc = AT_loc (at); loc; loc = loc-&gt;dw_loc_next)</span>
<span class="lineNum">    7242 </span><span class="lineNoCov">          0 :         loc_checksum_ordered (loc, ctx);</span>
<span class="lineNum">    7243 </span>            :       break;
<span class="lineNum">    7244 </span>            : 
<span class="lineNum">    7245 </span>            :     case dw_val_class_fde_ref:
<span class="lineNum">    7246 </span>            :     case dw_val_class_symview:
<span class="lineNum">    7247 </span>            :     case dw_val_class_lbl_id:
<span class="lineNum">    7248 </span>            :     case dw_val_class_lineptr:
<span class="lineNum">    7249 </span>            :     case dw_val_class_macptr:
<span class="lineNum">    7250 </span>            :     case dw_val_class_loclistsptr:
<span class="lineNum">    7251 </span>            :     case dw_val_class_high_pc:
<span class="lineNum">    7252 </span>            :       break;
<span class="lineNum">    7253 </span>            : 
<span class="lineNum">    7254 </span><span class="lineNoCov">          0 :     case dw_val_class_file:</span>
<span class="lineNum">    7255 </span><span class="lineNoCov">          0 :     case dw_val_class_file_implicit:</span>
<span class="lineNum">    7256 </span><span class="lineNoCov">          0 :       CHECKSUM_ULEB128 (DW_FORM_string);</span>
<span class="lineNum">    7257 </span><span class="lineNoCov">          0 :       CHECKSUM_STRING (AT_file (at)-&gt;filename);</span>
<span class="lineNum">    7258 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    7259 </span>            : 
<span class="lineNum">    7260 </span><span class="lineNoCov">          0 :     case dw_val_class_data8:</span>
<span class="lineNum">    7261 </span><span class="lineNoCov">          0 :       CHECKSUM (at-&gt;dw_attr_val.v.val_data8);</span>
<span class="lineNum">    7262 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    7263 </span>            : 
<span class="lineNum">    7264 </span>            :     default:
<span class="lineNum">    7265 </span>            :       break;
<span class="lineNum">    7266 </span>            :     }
<span class="lineNum">    7267 </span>            : }
<span class="lineNum">    7268 </span>            : 
<span class="lineNum">    7269 </span>            : struct checksum_attributes
<span class="lineNum">    7270 </span>            : {
<span class="lineNum">    7271 </span>            :   dw_attr_node *at_name;
<span class="lineNum">    7272 </span>            :   dw_attr_node *at_type;
<span class="lineNum">    7273 </span>            :   dw_attr_node *at_friend;
<span class="lineNum">    7274 </span>            :   dw_attr_node *at_accessibility;
<span class="lineNum">    7275 </span>            :   dw_attr_node *at_address_class;
<span class="lineNum">    7276 </span>            :   dw_attr_node *at_alignment;
<span class="lineNum">    7277 </span>            :   dw_attr_node *at_allocated;
<span class="lineNum">    7278 </span>            :   dw_attr_node *at_artificial;
<span class="lineNum">    7279 </span>            :   dw_attr_node *at_associated;
<span class="lineNum">    7280 </span>            :   dw_attr_node *at_binary_scale;
<span class="lineNum">    7281 </span>            :   dw_attr_node *at_bit_offset;
<span class="lineNum">    7282 </span>            :   dw_attr_node *at_bit_size;
<span class="lineNum">    7283 </span>            :   dw_attr_node *at_bit_stride;
<span class="lineNum">    7284 </span>            :   dw_attr_node *at_byte_size;
<span class="lineNum">    7285 </span>            :   dw_attr_node *at_byte_stride;
<span class="lineNum">    7286 </span>            :   dw_attr_node *at_const_value;
<span class="lineNum">    7287 </span>            :   dw_attr_node *at_containing_type;
<span class="lineNum">    7288 </span>            :   dw_attr_node *at_count;
<span class="lineNum">    7289 </span>            :   dw_attr_node *at_data_location;
<span class="lineNum">    7290 </span>            :   dw_attr_node *at_data_member_location;
<span class="lineNum">    7291 </span>            :   dw_attr_node *at_decimal_scale;
<span class="lineNum">    7292 </span>            :   dw_attr_node *at_decimal_sign;
<span class="lineNum">    7293 </span>            :   dw_attr_node *at_default_value;
<span class="lineNum">    7294 </span>            :   dw_attr_node *at_digit_count;
<span class="lineNum">    7295 </span>            :   dw_attr_node *at_discr;
<span class="lineNum">    7296 </span>            :   dw_attr_node *at_discr_list;
<span class="lineNum">    7297 </span>            :   dw_attr_node *at_discr_value;
<span class="lineNum">    7298 </span>            :   dw_attr_node *at_encoding;
<span class="lineNum">    7299 </span>            :   dw_attr_node *at_endianity;
<span class="lineNum">    7300 </span>            :   dw_attr_node *at_explicit;
<span class="lineNum">    7301 </span>            :   dw_attr_node *at_is_optional;
<span class="lineNum">    7302 </span>            :   dw_attr_node *at_location;
<span class="lineNum">    7303 </span>            :   dw_attr_node *at_lower_bound;
<span class="lineNum">    7304 </span>            :   dw_attr_node *at_mutable;
<span class="lineNum">    7305 </span>            :   dw_attr_node *at_ordering;
<span class="lineNum">    7306 </span>            :   dw_attr_node *at_picture_string;
<span class="lineNum">    7307 </span>            :   dw_attr_node *at_prototyped;
<span class="lineNum">    7308 </span>            :   dw_attr_node *at_small;
<span class="lineNum">    7309 </span>            :   dw_attr_node *at_segment;
<span class="lineNum">    7310 </span>            :   dw_attr_node *at_string_length;
<span class="lineNum">    7311 </span>            :   dw_attr_node *at_string_length_bit_size;
<span class="lineNum">    7312 </span>            :   dw_attr_node *at_string_length_byte_size;
<span class="lineNum">    7313 </span>            :   dw_attr_node *at_threads_scaled;
<span class="lineNum">    7314 </span>            :   dw_attr_node *at_upper_bound;
<span class="lineNum">    7315 </span>            :   dw_attr_node *at_use_location;
<span class="lineNum">    7316 </span>            :   dw_attr_node *at_use_UTF8;
<span class="lineNum">    7317 </span>            :   dw_attr_node *at_variable_parameter;
<span class="lineNum">    7318 </span>            :   dw_attr_node *at_virtuality;
<span class="lineNum">    7319 </span>            :   dw_attr_node *at_visibility;
<span class="lineNum">    7320 </span>            :   dw_attr_node *at_vtable_elem_location;
<span class="lineNum">    7321 </span>            : };
<span class="lineNum">    7322 </span>            : 
<span class="lineNum">    7323 </span>            : /* Collect the attributes that we will want to use for the checksum.  */
<a name="7324"><span class="lineNum">    7324 </span>            : </a>
<span class="lineNum">    7325 </span>            : static void
<span class="lineNum">    7326 </span><span class="lineCov">        148 : collect_checksum_attributes (struct checksum_attributes *attrs, dw_die_ref die)</span>
<span class="lineNum">    7327 </span>            : {
<span class="lineNum">    7328 </span><span class="lineCov">        148 :   dw_attr_node *a;</span>
<span class="lineNum">    7329 </span><span class="lineCov">        148 :   unsigned ix;</span>
<span class="lineNum">    7330 </span>            : 
<span class="lineNum">    7331 </span><span class="lineCov">        731 :   FOR_EACH_VEC_SAFE_ELT (die-&gt;die_attr, ix, a)</span>
<span class="lineNum">    7332 </span>            :     {
<span class="lineNum">    7333 </span><span class="lineCov">        583 :       switch (a-&gt;dw_attr)</span>
<span class="lineNum">    7334 </span>            :         {
<span class="lineNum">    7335 </span><span class="lineCov">        127 :         case DW_AT_name:</span>
<span class="lineNum">    7336 </span><span class="lineCov">        127 :           attrs-&gt;at_name = a;</span>
<span class="lineNum">    7337 </span><span class="lineCov">        127 :           break;</span>
<span class="lineNum">    7338 </span><span class="lineCov">         50 :         case DW_AT_type:</span>
<span class="lineNum">    7339 </span><span class="lineCov">         50 :           attrs-&gt;at_type = a;</span>
<span class="lineNum">    7340 </span><span class="lineCov">         50 :           break;</span>
<span class="lineNum">    7341 </span><span class="lineNoCov">          0 :         case DW_AT_friend:</span>
<span class="lineNum">    7342 </span><span class="lineNoCov">          0 :           attrs-&gt;at_friend = a;</span>
<span class="lineNum">    7343 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7344 </span><span class="lineCov">         10 :         case DW_AT_accessibility:</span>
<span class="lineNum">    7345 </span><span class="lineCov">         10 :           attrs-&gt;at_accessibility = a;</span>
<span class="lineNum">    7346 </span><span class="lineCov">         10 :           break;</span>
<span class="lineNum">    7347 </span><span class="lineNoCov">          0 :         case DW_AT_address_class:</span>
<span class="lineNum">    7348 </span><span class="lineNoCov">          0 :           attrs-&gt;at_address_class = a;</span>
<span class="lineNum">    7349 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7350 </span><span class="lineNoCov">          0 :         case DW_AT_alignment:</span>
<span class="lineNum">    7351 </span><span class="lineNoCov">          0 :           attrs-&gt;at_alignment = a;</span>
<span class="lineNum">    7352 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7353 </span><span class="lineNoCov">          0 :         case DW_AT_allocated:</span>
<span class="lineNum">    7354 </span><span class="lineNoCov">          0 :           attrs-&gt;at_allocated = a;</span>
<span class="lineNum">    7355 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7356 </span><span class="lineNoCov">          0 :         case DW_AT_artificial:</span>
<span class="lineNum">    7357 </span><span class="lineNoCov">          0 :           attrs-&gt;at_artificial = a;</span>
<span class="lineNum">    7358 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7359 </span><span class="lineNoCov">          0 :         case DW_AT_associated:</span>
<span class="lineNum">    7360 </span><span class="lineNoCov">          0 :           attrs-&gt;at_associated = a;</span>
<span class="lineNum">    7361 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7362 </span><span class="lineNoCov">          0 :         case DW_AT_binary_scale:</span>
<span class="lineNum">    7363 </span><span class="lineNoCov">          0 :           attrs-&gt;at_binary_scale = a;</span>
<span class="lineNum">    7364 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7365 </span><span class="lineNoCov">          0 :         case DW_AT_bit_offset:</span>
<span class="lineNum">    7366 </span><span class="lineNoCov">          0 :           attrs-&gt;at_bit_offset = a;</span>
<span class="lineNum">    7367 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7368 </span><span class="lineNoCov">          0 :         case DW_AT_bit_size:</span>
<span class="lineNum">    7369 </span><span class="lineNoCov">          0 :           attrs-&gt;at_bit_size = a;</span>
<span class="lineNum">    7370 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7371 </span><span class="lineNoCov">          0 :         case DW_AT_bit_stride:</span>
<span class="lineNum">    7372 </span><span class="lineNoCov">          0 :           attrs-&gt;at_bit_stride = a;</span>
<span class="lineNum">    7373 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7374 </span><span class="lineCov">         81 :         case DW_AT_byte_size:</span>
<span class="lineNum">    7375 </span><span class="lineCov">         81 :           attrs-&gt;at_byte_size = a;</span>
<span class="lineNum">    7376 </span><span class="lineCov">         81 :           break;</span>
<span class="lineNum">    7377 </span><span class="lineNoCov">          0 :         case DW_AT_byte_stride:</span>
<span class="lineNum">    7378 </span><span class="lineNoCov">          0 :           attrs-&gt;at_byte_stride = a;</span>
<span class="lineNum">    7379 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7380 </span><span class="lineCov">         18 :         case DW_AT_const_value:</span>
<span class="lineNum">    7381 </span><span class="lineCov">         18 :           attrs-&gt;at_const_value = a;</span>
<span class="lineNum">    7382 </span><span class="lineCov">         18 :           break;</span>
<span class="lineNum">    7383 </span><span class="lineCov">          3 :         case DW_AT_containing_type:</span>
<span class="lineNum">    7384 </span><span class="lineCov">          3 :           attrs-&gt;at_containing_type = a;</span>
<span class="lineNum">    7385 </span><span class="lineCov">          3 :           break;</span>
<span class="lineNum">    7386 </span><span class="lineNoCov">          0 :         case DW_AT_count:</span>
<span class="lineNum">    7387 </span><span class="lineNoCov">          0 :           attrs-&gt;at_count = a;</span>
<span class="lineNum">    7388 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7389 </span><span class="lineNoCov">          0 :         case DW_AT_data_location:</span>
<span class="lineNum">    7390 </span><span class="lineNoCov">          0 :           attrs-&gt;at_data_location = a;</span>
<span class="lineNum">    7391 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7392 </span><span class="lineCov">         19 :         case DW_AT_data_member_location:</span>
<span class="lineNum">    7393 </span><span class="lineCov">         19 :           attrs-&gt;at_data_member_location = a;</span>
<span class="lineNum">    7394 </span><span class="lineCov">         19 :           break;</span>
<span class="lineNum">    7395 </span><span class="lineNoCov">          0 :         case DW_AT_decimal_scale:</span>
<span class="lineNum">    7396 </span><span class="lineNoCov">          0 :           attrs-&gt;at_decimal_scale = a;</span>
<span class="lineNum">    7397 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7398 </span><span class="lineNoCov">          0 :         case DW_AT_decimal_sign:</span>
<span class="lineNum">    7399 </span><span class="lineNoCov">          0 :           attrs-&gt;at_decimal_sign = a;</span>
<span class="lineNum">    7400 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7401 </span><span class="lineNoCov">          0 :         case DW_AT_default_value:</span>
<span class="lineNum">    7402 </span><span class="lineNoCov">          0 :           attrs-&gt;at_default_value = a;</span>
<span class="lineNum">    7403 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7404 </span><span class="lineNoCov">          0 :         case DW_AT_digit_count:</span>
<span class="lineNum">    7405 </span><span class="lineNoCov">          0 :           attrs-&gt;at_digit_count = a;</span>
<span class="lineNum">    7406 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7407 </span><span class="lineNoCov">          0 :         case DW_AT_discr:</span>
<span class="lineNum">    7408 </span><span class="lineNoCov">          0 :           attrs-&gt;at_discr = a;</span>
<span class="lineNum">    7409 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7410 </span><span class="lineNoCov">          0 :         case DW_AT_discr_list:</span>
<span class="lineNum">    7411 </span><span class="lineNoCov">          0 :           attrs-&gt;at_discr_list = a;</span>
<span class="lineNum">    7412 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7413 </span><span class="lineNoCov">          0 :         case DW_AT_discr_value:</span>
<span class="lineNum">    7414 </span><span class="lineNoCov">          0 :           attrs-&gt;at_discr_value = a;</span>
<span class="lineNum">    7415 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7416 </span><span class="lineCov">         32 :         case DW_AT_encoding:</span>
<span class="lineNum">    7417 </span><span class="lineCov">         32 :           attrs-&gt;at_encoding = a;</span>
<span class="lineNum">    7418 </span><span class="lineCov">         32 :           break;</span>
<span class="lineNum">    7419 </span><span class="lineNoCov">          0 :         case DW_AT_endianity:</span>
<span class="lineNum">    7420 </span><span class="lineNoCov">          0 :           attrs-&gt;at_endianity = a;</span>
<span class="lineNum">    7421 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7422 </span><span class="lineNoCov">          0 :         case DW_AT_explicit:</span>
<span class="lineNum">    7423 </span><span class="lineNoCov">          0 :           attrs-&gt;at_explicit = a;</span>
<span class="lineNum">    7424 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7425 </span><span class="lineNoCov">          0 :         case DW_AT_is_optional:</span>
<span class="lineNum">    7426 </span><span class="lineNoCov">          0 :           attrs-&gt;at_is_optional = a;</span>
<span class="lineNum">    7427 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7428 </span><span class="lineNoCov">          0 :         case DW_AT_location:</span>
<span class="lineNum">    7429 </span><span class="lineNoCov">          0 :           attrs-&gt;at_location = a;</span>
<span class="lineNum">    7430 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7431 </span><span class="lineNoCov">          0 :         case DW_AT_lower_bound:</span>
<span class="lineNum">    7432 </span><span class="lineNoCov">          0 :           attrs-&gt;at_lower_bound = a;</span>
<span class="lineNum">    7433 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7434 </span><span class="lineNoCov">          0 :         case DW_AT_mutable:</span>
<span class="lineNum">    7435 </span><span class="lineNoCov">          0 :           attrs-&gt;at_mutable = a;</span>
<span class="lineNum">    7436 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7437 </span><span class="lineNoCov">          0 :         case DW_AT_ordering:</span>
<span class="lineNum">    7438 </span><span class="lineNoCov">          0 :           attrs-&gt;at_ordering = a;</span>
<span class="lineNum">    7439 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7440 </span><span class="lineNoCov">          0 :         case DW_AT_picture_string:</span>
<span class="lineNum">    7441 </span><span class="lineNoCov">          0 :           attrs-&gt;at_picture_string = a;</span>
<span class="lineNum">    7442 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7443 </span><span class="lineNoCov">          0 :         case DW_AT_prototyped:</span>
<span class="lineNum">    7444 </span><span class="lineNoCov">          0 :           attrs-&gt;at_prototyped = a;</span>
<span class="lineNum">    7445 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7446 </span><span class="lineNoCov">          0 :         case DW_AT_small:</span>
<span class="lineNum">    7447 </span><span class="lineNoCov">          0 :           attrs-&gt;at_small = a;</span>
<span class="lineNum">    7448 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7449 </span><span class="lineNoCov">          0 :         case DW_AT_segment:</span>
<span class="lineNum">    7450 </span><span class="lineNoCov">          0 :           attrs-&gt;at_segment = a;</span>
<span class="lineNum">    7451 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7452 </span><span class="lineNoCov">          0 :         case DW_AT_string_length:</span>
<span class="lineNum">    7453 </span><span class="lineNoCov">          0 :           attrs-&gt;at_string_length = a;</span>
<span class="lineNum">    7454 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7455 </span><span class="lineNoCov">          0 :         case DW_AT_string_length_bit_size:</span>
<span class="lineNum">    7456 </span><span class="lineNoCov">          0 :           attrs-&gt;at_string_length_bit_size = a;</span>
<span class="lineNum">    7457 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7458 </span><span class="lineNoCov">          0 :         case DW_AT_string_length_byte_size:</span>
<span class="lineNum">    7459 </span><span class="lineNoCov">          0 :           attrs-&gt;at_string_length_byte_size = a;</span>
<span class="lineNum">    7460 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7461 </span><span class="lineNoCov">          0 :         case DW_AT_threads_scaled:</span>
<span class="lineNum">    7462 </span><span class="lineNoCov">          0 :           attrs-&gt;at_threads_scaled = a;</span>
<span class="lineNum">    7463 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7464 </span><span class="lineCov">          3 :         case DW_AT_upper_bound:</span>
<span class="lineNum">    7465 </span><span class="lineCov">          3 :           attrs-&gt;at_upper_bound = a;</span>
<span class="lineNum">    7466 </span><span class="lineCov">          3 :           break;</span>
<span class="lineNum">    7467 </span><span class="lineNoCov">          0 :         case DW_AT_use_location:</span>
<span class="lineNum">    7468 </span><span class="lineNoCov">          0 :           attrs-&gt;at_use_location = a;</span>
<span class="lineNum">    7469 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7470 </span><span class="lineNoCov">          0 :         case DW_AT_use_UTF8:</span>
<span class="lineNum">    7471 </span><span class="lineNoCov">          0 :           attrs-&gt;at_use_UTF8 = a;</span>
<span class="lineNum">    7472 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7473 </span><span class="lineNoCov">          0 :         case DW_AT_variable_parameter:</span>
<span class="lineNum">    7474 </span><span class="lineNoCov">          0 :           attrs-&gt;at_variable_parameter = a;</span>
<span class="lineNum">    7475 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7476 </span><span class="lineNoCov">          0 :         case DW_AT_virtuality:</span>
<span class="lineNum">    7477 </span><span class="lineNoCov">          0 :           attrs-&gt;at_virtuality = a;</span>
<span class="lineNum">    7478 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7479 </span><span class="lineNoCov">          0 :         case DW_AT_visibility:</span>
<span class="lineNum">    7480 </span><span class="lineNoCov">          0 :           attrs-&gt;at_visibility = a;</span>
<span class="lineNum">    7481 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7482 </span><span class="lineNoCov">          0 :         case DW_AT_vtable_elem_location:</span>
<span class="lineNum">    7483 </span><span class="lineNoCov">          0 :           attrs-&gt;at_vtable_elem_location = a;</span>
<span class="lineNum">    7484 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    7485 </span>            :         default:
<span class="lineNum">    7486 </span>            :           break;
<span class="lineNum">    7487 </span>            :         }
<span class="lineNum">    7488 </span>            :     }
<span class="lineNum">    7489 </span><span class="lineCov">        148 : }</span>
<span class="lineNum">    7490 </span>            : 
<span class="lineNum">    7491 </span>            : /* Calculate the checksum of a DIE, using an ordered subset of attributes.  */
<a name="7492"><span class="lineNum">    7492 </span>            : </a>
<span class="lineNum">    7493 </span>            : static void
<span class="lineNum">    7494 </span><span class="lineCov">        146 : die_checksum_ordered (dw_die_ref die, struct md5_ctx *ctx, int *mark)</span>
<span class="lineNum">    7495 </span>            : {
<span class="lineNum">    7496 </span><span class="lineCov">        146 :   dw_die_ref c;</span>
<span class="lineNum">    7497 </span><span class="lineCov">        146 :   dw_die_ref decl;</span>
<span class="lineNum">    7498 </span><span class="lineCov">        146 :   struct checksum_attributes attrs;</span>
<span class="lineNum">    7499 </span>            : 
<span class="lineNum">    7500 </span><span class="lineCov">        146 :   CHECKSUM_ULEB128 ('D');</span>
<span class="lineNum">    7501 </span><span class="lineCov">        146 :   CHECKSUM_ULEB128 (die-&gt;die_tag);</span>
<span class="lineNum">    7502 </span>            : 
<span class="lineNum">    7503 </span><span class="lineCov">        146 :   memset (&amp;attrs, 0, sizeof (attrs));</span>
<span class="lineNum">    7504 </span>            : 
<span class="lineNum">    7505 </span><span class="lineCov">        146 :   decl = get_AT_ref (die, DW_AT_specification);</span>
<span class="lineNum">    7506 </span><span class="lineCov">        146 :   if (decl != NULL)</span>
<span class="lineNum">    7507 </span><span class="lineCov">          2 :     collect_checksum_attributes (&amp;attrs, decl);</span>
<span class="lineNum">    7508 </span><span class="lineCov">        146 :   collect_checksum_attributes (&amp;attrs, die);</span>
<span class="lineNum">    7509 </span>            : 
<span class="lineNum">    7510 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_name);</span>
<span class="lineNum">    7511 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_accessibility);</span>
<span class="lineNum">    7512 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_address_class);</span>
<span class="lineNum">    7513 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_allocated);</span>
<span class="lineNum">    7514 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_artificial);</span>
<span class="lineNum">    7515 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_associated);</span>
<span class="lineNum">    7516 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_binary_scale);</span>
<span class="lineNum">    7517 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_bit_offset);</span>
<span class="lineNum">    7518 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_bit_size);</span>
<span class="lineNum">    7519 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_bit_stride);</span>
<span class="lineNum">    7520 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_byte_size);</span>
<span class="lineNum">    7521 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_byte_stride);</span>
<span class="lineNum">    7522 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_const_value);</span>
<span class="lineNum">    7523 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_containing_type);</span>
<span class="lineNum">    7524 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_count);</span>
<span class="lineNum">    7525 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_data_location);</span>
<span class="lineNum">    7526 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_data_member_location);</span>
<span class="lineNum">    7527 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_decimal_scale);</span>
<span class="lineNum">    7528 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_decimal_sign);</span>
<span class="lineNum">    7529 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_default_value);</span>
<span class="lineNum">    7530 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_digit_count);</span>
<span class="lineNum">    7531 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_discr);</span>
<span class="lineNum">    7532 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_discr_list);</span>
<span class="lineNum">    7533 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_discr_value);</span>
<span class="lineNum">    7534 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_encoding);</span>
<span class="lineNum">    7535 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_endianity);</span>
<span class="lineNum">    7536 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_explicit);</span>
<span class="lineNum">    7537 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_is_optional);</span>
<span class="lineNum">    7538 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_location);</span>
<span class="lineNum">    7539 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_lower_bound);</span>
<span class="lineNum">    7540 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_mutable);</span>
<span class="lineNum">    7541 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_ordering);</span>
<span class="lineNum">    7542 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_picture_string);</span>
<span class="lineNum">    7543 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_prototyped);</span>
<span class="lineNum">    7544 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_small);</span>
<span class="lineNum">    7545 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_segment);</span>
<span class="lineNum">    7546 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_string_length);</span>
<span class="lineNum">    7547 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_string_length_bit_size);</span>
<span class="lineNum">    7548 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_string_length_byte_size);</span>
<span class="lineNum">    7549 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_threads_scaled);</span>
<span class="lineNum">    7550 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_upper_bound);</span>
<span class="lineNum">    7551 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_use_location);</span>
<span class="lineNum">    7552 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_use_UTF8);</span>
<span class="lineNum">    7553 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_variable_parameter);</span>
<span class="lineNum">    7554 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_virtuality);</span>
<span class="lineNum">    7555 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_visibility);</span>
<span class="lineNum">    7556 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_vtable_elem_location);</span>
<span class="lineNum">    7557 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_type);</span>
<span class="lineNum">    7558 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_friend);</span>
<span class="lineNum">    7559 </span><span class="lineCov">        146 :   CHECKSUM_ATTR (attrs.at_alignment);</span>
<span class="lineNum">    7560 </span>            : 
<span class="lineNum">    7561 </span>            :   /* Checksum the child DIEs.  */
<span class="lineNum">    7562 </span><span class="lineCov">        146 :   c = die-&gt;die_child;</span>
<span class="lineNum">    7563 </span><span class="lineCov">        146 :   if (c) do {</span>
<span class="lineNum">    7564 </span><span class="lineCov">        135 :     dw_attr_node *name_attr;</span>
<span class="lineNum">    7565 </span>            : 
<span class="lineNum">    7566 </span><span class="lineCov">        135 :     c = c-&gt;die_sib;</span>
<span class="lineNum">    7567 </span><span class="lineCov">        135 :     name_attr = get_AT (c, DW_AT_name);</span>
<span class="lineNum">    7568 </span><span class="lineCov">        135 :     if (is_template_instantiation (c))</span>
<span class="lineNum">    7569 </span>            :       {
<span class="lineNum">    7570 </span>            :         /* Ignore instantiations of member type and function templates.  */
<span class="lineNum">    7571 </span>            :       }
<span class="lineNum">    7572 </span><span class="lineCov">        131 :     else if (name_attr != NULL</span>
<span class="lineNum">    7573 </span><span class="lineCov">        131 :              &amp;&amp; (is_type_die (c) || c-&gt;die_tag == DW_TAG_subprogram))</span>
<span class="lineNum">    7574 </span>            :       {
<span class="lineNum">    7575 </span>            :         /* Use a shallow checksum for named nested types and member
<span class="lineNum">    7576 </span>            :            functions.  */
<span class="lineNum">    7577 </span><span class="lineCov">         74 :         CHECKSUM_ULEB128 ('S');</span>
<span class="lineNum">    7578 </span><span class="lineCov">         74 :         CHECKSUM_ULEB128 (c-&gt;die_tag);</span>
<span class="lineNum">    7579 </span><span class="lineCov">         74 :         CHECKSUM_STRING (AT_string (name_attr));</span>
<span class="lineNum">    7580 </span>            :       }
<span class="lineNum">    7581 </span>            :     else
<span class="lineNum">    7582 </span>            :       {
<span class="lineNum">    7583 </span>            :         /* Use a deep checksum for other children.  */
<span class="lineNum">    7584 </span>            :         /* Mark this DIE so it gets processed when unmarking.  */
<span class="lineNum">    7585 </span><span class="lineCov">         57 :         if (c-&gt;die_mark == 0)</span>
<span class="lineNum">    7586 </span><span class="lineCov">         57 :           c-&gt;die_mark = -1;</span>
<span class="lineNum">    7587 </span><span class="lineCov">         57 :         die_checksum_ordered (c, ctx, mark);</span>
<span class="lineNum">    7588 </span>            :       }
<span class="lineNum">    7589 </span><span class="lineCov">        135 :   } while (c != die-&gt;die_child);</span>
<span class="lineNum">    7590 </span>            : 
<span class="lineNum">    7591 </span><span class="lineCov">        146 :   CHECKSUM_ULEB128 (0);</span>
<span class="lineNum">    7592 </span><span class="lineCov">        146 : }</span>
<span class="lineNum">    7593 </span>            : 
<a name="7594"><span class="lineNum">    7594 </span>            : /* Add a type name and tag to a hash.  */</a>
<span class="lineNum">    7595 </span>            : static void
<span class="lineNum">    7596 </span><span class="lineCov">         46 : die_odr_checksum (int tag, const char *name, md5_ctx *ctx)</span>
<span class="lineNum">    7597 </span>            : {
<span class="lineNum">    7598 </span><span class="lineCov">         46 :   CHECKSUM_ULEB128 (tag);</span>
<span class="lineNum">    7599 </span><span class="lineCov">         46 :   CHECKSUM_STRING (name);</span>
<span class="lineNum">    7600 </span><span class="lineCov">         46 : }</span>
<span class="lineNum">    7601 </span>            : 
<span class="lineNum">    7602 </span>            : #undef CHECKSUM
<span class="lineNum">    7603 </span>            : #undef CHECKSUM_STRING
<span class="lineNum">    7604 </span>            : #undef CHECKSUM_ATTR
<span class="lineNum">    7605 </span>            : #undef CHECKSUM_LEB128
<span class="lineNum">    7606 </span>            : #undef CHECKSUM_ULEB128
<span class="lineNum">    7607 </span>            : 
<span class="lineNum">    7608 </span>            : /* Generate the type signature for DIE.  This is computed by generating an
<span class="lineNum">    7609 </span>            :    MD5 checksum over the DIE's tag, its relevant attributes, and its
<span class="lineNum">    7610 </span>            :    children.  Attributes that are references to other DIEs are processed
<span class="lineNum">    7611 </span>            :    by recursion, using the MARK field to prevent infinite recursion.
<span class="lineNum">    7612 </span>            :    If the DIE is nested inside a namespace or another type, we also
<span class="lineNum">    7613 </span>            :    need to include that context in the signature.  The lower 64 bits
<span class="lineNum">    7614 </span>            :    of the resulting MD5 checksum comprise the signature.  */
<a name="7615"><span class="lineNum">    7615 </span>            : </a>
<span class="lineNum">    7616 </span>            : static void
<span class="lineNum">    7617 </span><span class="lineCov">         48 : generate_type_signature (dw_die_ref die, comdat_type_node *type_node)</span>
<span class="lineNum">    7618 </span>            : {
<span class="lineNum">    7619 </span><span class="lineCov">         48 :   int mark;</span>
<span class="lineNum">    7620 </span><span class="lineCov">         48 :   const char *name;</span>
<span class="lineNum">    7621 </span><span class="lineCov">         48 :   unsigned char checksum[16];</span>
<span class="lineNum">    7622 </span><span class="lineCov">         48 :   struct md5_ctx ctx;</span>
<span class="lineNum">    7623 </span><span class="lineCov">         48 :   dw_die_ref decl;</span>
<span class="lineNum">    7624 </span><span class="lineCov">         48 :   dw_die_ref parent;</span>
<span class="lineNum">    7625 </span>            : 
<span class="lineNum">    7626 </span><span class="lineCov">         48 :   name = get_AT_string (die, DW_AT_name);</span>
<span class="lineNum">    7627 </span><span class="lineCov">         48 :   decl = get_AT_ref (die, DW_AT_specification);</span>
<span class="lineNum">    7628 </span><span class="lineCov">         48 :   parent = get_die_parent (die);</span>
<span class="lineNum">    7629 </span>            : 
<span class="lineNum">    7630 </span>            :   /* First, compute a signature for just the type name (and its surrounding
<span class="lineNum">    7631 </span>            :      context, if any.  This is stored in the type unit DIE for link-time
<span class="lineNum">    7632 </span>            :      ODR (one-definition rule) checking.  */
<span class="lineNum">    7633 </span>            : 
<span class="lineNum">    7634 </span><span class="lineCov">         48 :   if (is_cxx () &amp;&amp; name != NULL)</span>
<span class="lineNum">    7635 </span>            :     {
<span class="lineNum">    7636 </span><span class="lineCov">         46 :       md5_init_ctx (&amp;ctx);</span>
<span class="lineNum">    7637 </span>            : 
<span class="lineNum">    7638 </span>            :       /* Checksum the names of surrounding namespaces and structures.  */
<span class="lineNum">    7639 </span><span class="lineCov">         46 :       if (parent != NULL)</span>
<span class="lineNum">    7640 </span><span class="lineCov">         46 :         checksum_die_context (parent, &amp;ctx);</span>
<span class="lineNum">    7641 </span>            : 
<span class="lineNum">    7642 </span>            :       /* Checksum the current DIE. */
<span class="lineNum">    7643 </span><span class="lineCov">         46 :       die_odr_checksum (die-&gt;die_tag, name, &amp;ctx);</span>
<span class="lineNum">    7644 </span><span class="lineCov">         46 :       md5_finish_ctx (&amp;ctx, checksum);</span>
<span class="lineNum">    7645 </span>            : 
<span class="lineNum">    7646 </span><span class="lineCov">         46 :       add_AT_data8 (type_node-&gt;root_die, DW_AT_GNU_odr_signature, &amp;checksum[8]);</span>
<span class="lineNum">    7647 </span>            :     }
<span class="lineNum">    7648 </span>            : 
<span class="lineNum">    7649 </span>            :   /* Next, compute the complete type signature.  */
<span class="lineNum">    7650 </span>            : 
<span class="lineNum">    7651 </span><span class="lineCov">         48 :   md5_init_ctx (&amp;ctx);</span>
<span class="lineNum">    7652 </span><span class="lineCov">         48 :   mark = 1;</span>
<span class="lineNum">    7653 </span><span class="lineCov">         48 :   die-&gt;die_mark = mark;</span>
<span class="lineNum">    7654 </span>            : 
<span class="lineNum">    7655 </span>            :   /* Checksum the names of surrounding namespaces and structures.  */
<span class="lineNum">    7656 </span><span class="lineCov">         48 :   if (parent != NULL)</span>
<span class="lineNum">    7657 </span><span class="lineCov">         48 :     checksum_die_context (parent, &amp;ctx);</span>
<span class="lineNum">    7658 </span>            : 
<span class="lineNum">    7659 </span>            :   /* Checksum the DIE and its children.  */
<span class="lineNum">    7660 </span><span class="lineCov">         48 :   die_checksum_ordered (die, &amp;ctx, &amp;mark);</span>
<span class="lineNum">    7661 </span><span class="lineCov">         48 :   unmark_all_dies (die);</span>
<span class="lineNum">    7662 </span><span class="lineCov">         48 :   md5_finish_ctx (&amp;ctx, checksum);</span>
<span class="lineNum">    7663 </span>            : 
<span class="lineNum">    7664 </span>            :   /* Store the signature in the type node and link the type DIE and the
<span class="lineNum">    7665 </span>            :      type node together.  */
<span class="lineNum">    7666 </span><span class="lineCov">         48 :   memcpy (type_node-&gt;signature, &amp;checksum[16 - DWARF_TYPE_SIGNATURE_SIZE],</span>
<span class="lineNum">    7667 </span>            :           DWARF_TYPE_SIGNATURE_SIZE);
<span class="lineNum">    7668 </span><span class="lineCov">         48 :   die-&gt;comdat_type_p = true;</span>
<span class="lineNum">    7669 </span><span class="lineCov">         48 :   die-&gt;die_id.die_type_node = type_node;</span>
<span class="lineNum">    7670 </span><span class="lineCov">         48 :   type_node-&gt;type_die = die;</span>
<span class="lineNum">    7671 </span>            : 
<span class="lineNum">    7672 </span>            :   /* If the DIE is a specification, link its declaration to the type node
<span class="lineNum">    7673 </span>            :      as well.  */
<span class="lineNum">    7674 </span><span class="lineCov">         48 :   if (decl != NULL)</span>
<span class="lineNum">    7675 </span>            :     {
<span class="lineNum">    7676 </span><span class="lineNoCov">          0 :       decl-&gt;comdat_type_p = true;</span>
<span class="lineNum">    7677 </span><span class="lineNoCov">          0 :       decl-&gt;die_id.die_type_node = type_node;</span>
<span class="lineNum">    7678 </span>            :     }
<span class="lineNum">    7679 </span><span class="lineCov">         48 : }</span>
<span class="lineNum">    7680 </span>            : 
<a name="7681"><span class="lineNum">    7681 </span>            : /* Do the location expressions look same?  */</a>
<span class="lineNum">    7682 </span>            : static inline int
<span class="lineNum">    7683 </span><span class="lineNoCov">          0 : same_loc_p (dw_loc_descr_ref loc1, dw_loc_descr_ref loc2, int *mark)</span>
<span class="lineNum">    7684 </span>            : {
<span class="lineNum">    7685 </span><span class="lineNoCov">          0 :   return loc1-&gt;dw_loc_opc == loc2-&gt;dw_loc_opc</span>
<span class="lineNum">    7686 </span><span class="lineNoCov">          0 :          &amp;&amp; same_dw_val_p (&amp;loc1-&gt;dw_loc_oprnd1, &amp;loc2-&gt;dw_loc_oprnd1, mark)</span>
<span class="lineNum">    7687 </span><span class="lineNoCov">          0 :          &amp;&amp; same_dw_val_p (&amp;loc1-&gt;dw_loc_oprnd2, &amp;loc2-&gt;dw_loc_oprnd2, mark);</span>
<span class="lineNum">    7688 </span>            : }
<span class="lineNum">    7689 </span>            : 
<a name="7690"><span class="lineNum">    7690 </span>            : /* Do the values look the same?  */</a>
<span class="lineNum">    7691 </span>            : static int
<span class="lineNum">    7692 </span><span class="lineNoCov">          0 : same_dw_val_p (const dw_val_node *v1, const dw_val_node *v2, int *mark)</span>
<span class="lineNum">    7693 </span>            : {
<span class="lineNum">    7694 </span><span class="lineNoCov">          0 :   dw_loc_descr_ref loc1, loc2;</span>
<span class="lineNum">    7695 </span><span class="lineNoCov">          0 :   rtx r1, r2;</span>
<span class="lineNum">    7696 </span>            : 
<span class="lineNum">    7697 </span><span class="lineNoCov">          0 :   if (v1-&gt;val_class != v2-&gt;val_class)</span>
<span class="lineNum">    7698 </span>            :     return 0;
<span class="lineNum">    7699 </span>            : 
<span class="lineNum">    7700 </span><span class="lineNoCov">          0 :   switch (v1-&gt;val_class)</span>
<span class="lineNum">    7701 </span>            :     {
<span class="lineNum">    7702 </span><span class="lineNoCov">          0 :     case dw_val_class_const:</span>
<span class="lineNum">    7703 </span><span class="lineNoCov">          0 :     case dw_val_class_const_implicit:</span>
<span class="lineNum">    7704 </span><span class="lineNoCov">          0 :       return v1-&gt;v.val_int == v2-&gt;v.val_int;</span>
<span class="lineNum">    7705 </span><span class="lineNoCov">          0 :     case dw_val_class_unsigned_const:</span>
<span class="lineNum">    7706 </span><span class="lineNoCov">          0 :     case dw_val_class_unsigned_const_implicit:</span>
<span class="lineNum">    7707 </span><span class="lineNoCov">          0 :       return v1-&gt;v.val_unsigned == v2-&gt;v.val_unsigned;</span>
<span class="lineNum">    7708 </span><span class="lineNoCov">          0 :     case dw_val_class_const_double:</span>
<span class="lineNum">    7709 </span><span class="lineNoCov">          0 :       return v1-&gt;v.val_double.high == v2-&gt;v.val_double.high</span>
<span class="lineNum">    7710 </span><span class="lineNoCov">          0 :              &amp;&amp; v1-&gt;v.val_double.low == v2-&gt;v.val_double.low;</span>
<span class="lineNum">    7711 </span><span class="lineNoCov">          0 :     case dw_val_class_wide_int:</span>
<span class="lineNum">    7712 </span><span class="lineNoCov">          0 :       return *v1-&gt;v.val_wide == *v2-&gt;v.val_wide;</span>
<span class="lineNum">    7713 </span><span class="lineNoCov">          0 :     case dw_val_class_vec:</span>
<span class="lineNum">    7714 </span><span class="lineNoCov">          0 :       if (v1-&gt;v.val_vec.length != v2-&gt;v.val_vec.length</span>
<span class="lineNum">    7715 </span><span class="lineNoCov">          0 :           || v1-&gt;v.val_vec.elt_size != v2-&gt;v.val_vec.elt_size)</span>
<span class="lineNum">    7716 </span>            :         return 0;
<span class="lineNum">    7717 </span><span class="lineNoCov">          0 :       if (memcmp (v1-&gt;v.val_vec.array, v2-&gt;v.val_vec.array,</span>
<span class="lineNum">    7718 </span><span class="lineNoCov">          0 :                   v1-&gt;v.val_vec.length * v1-&gt;v.val_vec.elt_size))</span>
<span class="lineNum">    7719 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    7720 </span>            :       return 1;
<span class="lineNum">    7721 </span><span class="lineNoCov">          0 :     case dw_val_class_flag:</span>
<span class="lineNum">    7722 </span><span class="lineNoCov">          0 :       return v1-&gt;v.val_flag == v2-&gt;v.val_flag;</span>
<span class="lineNum">    7723 </span><span class="lineNoCov">          0 :     case dw_val_class_str:</span>
<span class="lineNum">    7724 </span><span class="lineNoCov">          0 :       return !strcmp (v1-&gt;v.val_str-&gt;str, v2-&gt;v.val_str-&gt;str);</span>
<span class="lineNum">    7725 </span>            : 
<span class="lineNum">    7726 </span><span class="lineNoCov">          0 :     case dw_val_class_addr:</span>
<span class="lineNum">    7727 </span><span class="lineNoCov">          0 :       r1 = v1-&gt;v.val_addr;</span>
<span class="lineNum">    7728 </span><span class="lineNoCov">          0 :       r2 = v2-&gt;v.val_addr;</span>
<span class="lineNum">    7729 </span><span class="lineNoCov">          0 :       if (GET_CODE (r1) != GET_CODE (r2))</span>
<span class="lineNum">    7730 </span>            :         return 0;
<span class="lineNum">    7731 </span><span class="lineNoCov">          0 :       return !rtx_equal_p (r1, r2);</span>
<span class="lineNum">    7732 </span>            : 
<span class="lineNum">    7733 </span><span class="lineNoCov">          0 :     case dw_val_class_offset:</span>
<span class="lineNum">    7734 </span><span class="lineNoCov">          0 :       return v1-&gt;v.val_offset == v2-&gt;v.val_offset;</span>
<span class="lineNum">    7735 </span>            : 
<span class="lineNum">    7736 </span><span class="lineNoCov">          0 :     case dw_val_class_loc:</span>
<span class="lineNum">    7737 </span><span class="lineNoCov">          0 :       for (loc1 = v1-&gt;v.val_loc, loc2 = v2-&gt;v.val_loc;</span>
<span class="lineNum">    7738 </span><span class="lineNoCov">          0 :            loc1 &amp;&amp; loc2;</span>
<span class="lineNum">    7739 </span><span class="lineNoCov">          0 :            loc1 = loc1-&gt;dw_loc_next, loc2 = loc2-&gt;dw_loc_next)</span>
<span class="lineNum">    7740 </span><span class="lineNoCov">          0 :         if (!same_loc_p (loc1, loc2, mark))</span>
<span class="lineNum">    7741 </span>            :           return 0;
<span class="lineNum">    7742 </span><span class="lineNoCov">          0 :       return !loc1 &amp;&amp; !loc2;</span>
<span class="lineNum">    7743 </span>            : 
<span class="lineNum">    7744 </span><span class="lineNoCov">          0 :     case dw_val_class_die_ref:</span>
<span class="lineNum">    7745 </span><span class="lineNoCov">          0 :       return same_die_p (v1-&gt;v.val_die_ref.die, v2-&gt;v.val_die_ref.die, mark);</span>
<span class="lineNum">    7746 </span>            : 
<span class="lineNum">    7747 </span><span class="lineNoCov">          0 :     case dw_val_class_symview:</span>
<span class="lineNum">    7748 </span><span class="lineNoCov">          0 :       return strcmp (v1-&gt;v.val_symbolic_view, v2-&gt;v.val_symbolic_view) == 0;</span>
<span class="lineNum">    7749 </span>            : 
<span class="lineNum">    7750 </span>            :     case dw_val_class_fde_ref:
<span class="lineNum">    7751 </span>            :     case dw_val_class_vms_delta:
<span class="lineNum">    7752 </span>            :     case dw_val_class_lbl_id:
<span class="lineNum">    7753 </span>            :     case dw_val_class_lineptr:
<span class="lineNum">    7754 </span>            :     case dw_val_class_macptr:
<span class="lineNum">    7755 </span>            :     case dw_val_class_loclistsptr:
<span class="lineNum">    7756 </span>            :     case dw_val_class_high_pc:
<span class="lineNum">    7757 </span>            :       return 1;
<span class="lineNum">    7758 </span>            : 
<span class="lineNum">    7759 </span><span class="lineNoCov">          0 :     case dw_val_class_file:</span>
<span class="lineNum">    7760 </span><span class="lineNoCov">          0 :     case dw_val_class_file_implicit:</span>
<span class="lineNum">    7761 </span><span class="lineNoCov">          0 :       return v1-&gt;v.val_file == v2-&gt;v.val_file;</span>
<span class="lineNum">    7762 </span>            : 
<span class="lineNum">    7763 </span><span class="lineNoCov">          0 :     case dw_val_class_data8:</span>
<span class="lineNum">    7764 </span><span class="lineNoCov">          0 :       return !memcmp (v1-&gt;v.val_data8, v2-&gt;v.val_data8, 8);</span>
<span class="lineNum">    7765 </span>            : 
<span class="lineNum">    7766 </span>            :     default:
<span class="lineNum">    7767 </span>            :       return 1;
<span class="lineNum">    7768 </span>            :     }
<span class="lineNum">    7769 </span>            : }
<span class="lineNum">    7770 </span>            : 
<span class="lineNum">    7771 </span>            : /* Do the attributes look the same?  */
<a name="7772"><span class="lineNum">    7772 </span>            : </a>
<span class="lineNum">    7773 </span>            : static int
<span class="lineNum">    7774 </span><span class="lineNoCov">          0 : same_attr_p (dw_attr_node *at1, dw_attr_node *at2, int *mark)</span>
<span class="lineNum">    7775 </span>            : {
<span class="lineNum">    7776 </span><span class="lineNoCov">          0 :   if (at1-&gt;dw_attr != at2-&gt;dw_attr)</span>
<span class="lineNum">    7777 </span>            :     return 0;
<span class="lineNum">    7778 </span>            : 
<span class="lineNum">    7779 </span>            :   /* We don't care that this was compiled with a different compiler
<span class="lineNum">    7780 </span>            :      snapshot; if the output is the same, that's what matters. */
<span class="lineNum">    7781 </span><span class="lineNoCov">          0 :   if (at1-&gt;dw_attr == DW_AT_producer)</span>
<span class="lineNum">    7782 </span>            :     return 1;
<span class="lineNum">    7783 </span>            : 
<span class="lineNum">    7784 </span><span class="lineNoCov">          0 :   return same_dw_val_p (&amp;at1-&gt;dw_attr_val, &amp;at2-&gt;dw_attr_val, mark);</span>
<span class="lineNum">    7785 </span>            : }
<span class="lineNum">    7786 </span>            : 
<span class="lineNum">    7787 </span>            : /* Do the dies look the same?  */
<a name="7788"><span class="lineNum">    7788 </span>            : </a>
<span class="lineNum">    7789 </span>            : static int
<span class="lineNum">    7790 </span><span class="lineNoCov">          0 : same_die_p (dw_die_ref die1, dw_die_ref die2, int *mark)</span>
<span class="lineNum">    7791 </span>            : {
<span class="lineNum">    7792 </span><span class="lineNoCov">          0 :   dw_die_ref c1, c2;</span>
<span class="lineNum">    7793 </span><span class="lineNoCov">          0 :   dw_attr_node *a1;</span>
<span class="lineNum">    7794 </span><span class="lineNoCov">          0 :   unsigned ix;</span>
<span class="lineNum">    7795 </span>            : 
<span class="lineNum">    7796 </span>            :   /* To avoid infinite recursion.  */
<span class="lineNum">    7797 </span><span class="lineNoCov">          0 :   if (die1-&gt;die_mark)</span>
<span class="lineNum">    7798 </span><span class="lineNoCov">          0 :     return die1-&gt;die_mark == die2-&gt;die_mark;</span>
<span class="lineNum">    7799 </span><span class="lineNoCov">          0 :   die1-&gt;die_mark = die2-&gt;die_mark = ++(*mark);</span>
<span class="lineNum">    7800 </span>            : 
<span class="lineNum">    7801 </span><span class="lineNoCov">          0 :   if (die1-&gt;die_tag != die2-&gt;die_tag)</span>
<span class="lineNum">    7802 </span>            :     return 0;
<span class="lineNum">    7803 </span>            : 
<span class="lineNum">    7804 </span><span class="lineNoCov">          0 :   if (vec_safe_length (die1-&gt;die_attr) != vec_safe_length (die2-&gt;die_attr))</span>
<span class="lineNum">    7805 </span>            :     return 0;
<span class="lineNum">    7806 </span>            : 
<span class="lineNum">    7807 </span><span class="lineNoCov">          0 :   FOR_EACH_VEC_SAFE_ELT (die1-&gt;die_attr, ix, a1)</span>
<span class="lineNum">    7808 </span><span class="lineNoCov">          0 :     if (!same_attr_p (a1, &amp;(*die2-&gt;die_attr)[ix], mark))</span>
<span class="lineNum">    7809 </span><span class="lineNoCov">          0 :       return 0;</span>
<span class="lineNum">    7810 </span>            : 
<span class="lineNum">    7811 </span><span class="lineNoCov">          0 :   c1 = die1-&gt;die_child;</span>
<span class="lineNum">    7812 </span><span class="lineNoCov">          0 :   c2 = die2-&gt;die_child;</span>
<span class="lineNum">    7813 </span><span class="lineNoCov">          0 :   if (! c1)</span>
<span class="lineNum">    7814 </span>            :     {
<span class="lineNum">    7815 </span><span class="lineNoCov">          0 :       if (c2)</span>
<span class="lineNum">    7816 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    7817 </span>            :     }
<span class="lineNum">    7818 </span>            :   else
<span class="lineNum">    7819 </span><span class="lineNoCov">          0 :     for (;;)</span>
<span class="lineNum">    7820 </span>            :       {
<span class="lineNum">    7821 </span><span class="lineNoCov">          0 :         if (!same_die_p (c1, c2, mark))</span>
<span class="lineNum">    7822 </span>            :           return 0;
<span class="lineNum">    7823 </span><span class="lineNoCov">          0 :         c1 = c1-&gt;die_sib;</span>
<span class="lineNum">    7824 </span><span class="lineNoCov">          0 :         c2 = c2-&gt;die_sib;</span>
<span class="lineNum">    7825 </span><span class="lineNoCov">          0 :         if (c1 == die1-&gt;die_child)</span>
<span class="lineNum">    7826 </span>            :           {
<span class="lineNum">    7827 </span><span class="lineNoCov">          0 :             if (c2 == die2-&gt;die_child)</span>
<span class="lineNum">    7828 </span>            :               break;
<span class="lineNum">    7829 </span>            :             else
<span class="lineNum">    7830 </span><span class="lineNoCov">          0 :               return 0;</span>
<span class="lineNum">    7831 </span>            :           }
<span class="lineNum">    7832 </span>            :     }
<span class="lineNum">    7833 </span>            : 
<span class="lineNum">    7834 </span>            :   return 1;
<span class="lineNum">    7835 </span>            : }
<span class="lineNum">    7836 </span>            : 
<span class="lineNum">    7837 </span>            : /* Calculate the MD5 checksum of the compilation unit DIE UNIT_DIE and its
<span class="lineNum">    7838 </span>            :    children, and set die_symbol.  */
<a name="7839"><span class="lineNum">    7839 </span>            : </a>
<span class="lineNum">    7840 </span>            : static void
<span class="lineNum">    7841 </span><span class="lineCov">        808 : compute_comp_unit_symbol (dw_die_ref unit_die)</span>
<span class="lineNum">    7842 </span>            : {
<span class="lineNum">    7843 </span><span class="lineCov">        808 :   const char *die_name = get_AT_string (unit_die, DW_AT_name);</span>
<span class="lineNum">    7844 </span><span class="lineCov">        808 :   const char *base = die_name ? lbasename (die_name) : &quot;anonymous&quot;;</span>
<span class="lineNum">    7845 </span><span class="lineCov">        808 :   char *name = XALLOCAVEC (char, strlen (base) + 64);</span>
<span class="lineNum">    7846 </span><span class="lineCov">        808 :   char *p;</span>
<span class="lineNum">    7847 </span><span class="lineCov">        808 :   int i, mark;</span>
<span class="lineNum">    7848 </span><span class="lineCov">        808 :   unsigned char checksum[16];</span>
<span class="lineNum">    7849 </span><span class="lineCov">        808 :   struct md5_ctx ctx;</span>
<span class="lineNum">    7850 </span>            : 
<span class="lineNum">    7851 </span>            :   /* Compute the checksum of the DIE, then append part of it as hex digits to
<span class="lineNum">    7852 </span>            :      the name filename of the unit.  */
<span class="lineNum">    7853 </span>            : 
<span class="lineNum">    7854 </span><span class="lineCov">        808 :   md5_init_ctx (&amp;ctx);</span>
<span class="lineNum">    7855 </span><span class="lineCov">        808 :   mark = 0;</span>
<span class="lineNum">    7856 </span><span class="lineCov">        808 :   die_checksum (unit_die, &amp;ctx, &amp;mark);</span>
<span class="lineNum">    7857 </span><span class="lineCov">        808 :   unmark_all_dies (unit_die);</span>
<span class="lineNum">    7858 </span><span class="lineCov">        808 :   md5_finish_ctx (&amp;ctx, checksum);</span>
<span class="lineNum">    7859 </span>            : 
<span class="lineNum">    7860 </span>            :   /* When we this for comp_unit_die () we have a DW_AT_name that might
<span class="lineNum">    7861 </span>            :      not start with a letter but with anything valid for filenames and
<span class="lineNum">    7862 </span>            :      clean_symbol_name doesn't fix that up.  Prepend 'g' if the first
<span class="lineNum">    7863 </span>            :      character is not a letter.  */
<span class="lineNum">    7864 </span><span class="lineCov">        808 :   sprintf (name, &quot;%s%s.&quot;, ISALPHA (*base) ? &quot;&quot; : &quot;g&quot;, base);</span>
<span class="lineNum">    7865 </span><span class="lineCov">        808 :   clean_symbol_name (name);</span>
<span class="lineNum">    7866 </span>            : 
<span class="lineNum">    7867 </span><span class="lineCov">        808 :   p = name + strlen (name);</span>
<span class="lineNum">    7868 </span><span class="lineCov">       4040 :   for (i = 0; i &lt; 4; i++)</span>
<span class="lineNum">    7869 </span>            :     {
<span class="lineNum">    7870 </span><span class="lineCov">       3232 :       sprintf (p, &quot;%.2x&quot;, checksum[i]);</span>
<span class="lineNum">    7871 </span><span class="lineCov">       3232 :       p += 2;</span>
<span class="lineNum">    7872 </span>            :     }
<span class="lineNum">    7873 </span>            : 
<span class="lineNum">    7874 </span><span class="lineCov">        808 :   unit_die-&gt;die_id.die_symbol = xstrdup (name);</span>
<span class="lineNum">    7875 </span><span class="lineCov">        808 : }</span>
<span class="lineNum">    7876 </span>            : 
<span class="lineNum">    7877 </span>            : /* Returns nonzero if DIE represents a type, in the sense of TYPE_P.  */
<a name="7878"><span class="lineNum">    7878 </span>            : </a>
<span class="lineNum">    7879 </span>            : static int
<span class="lineNum">    7880 </span><span class="lineCov">   46361789 : is_type_die (dw_die_ref die)</span>
<span class="lineNum">    7881 </span>            : {
<span class="lineNum">    7882 </span><span class="lineCov">   46361789 :   switch (die-&gt;die_tag)</span>
<span class="lineNum">    7883 </span>            :     {
<span class="lineNum">    7884 </span>            :     case DW_TAG_array_type:
<span class="lineNum">    7885 </span>            :     case DW_TAG_class_type:
<span class="lineNum">    7886 </span>            :     case DW_TAG_interface_type:
<span class="lineNum">    7887 </span>            :     case DW_TAG_enumeration_type:
<span class="lineNum">    7888 </span>            :     case DW_TAG_pointer_type:
<span class="lineNum">    7889 </span>            :     case DW_TAG_reference_type:
<span class="lineNum">    7890 </span>            :     case DW_TAG_rvalue_reference_type:
<span class="lineNum">    7891 </span>            :     case DW_TAG_string_type:
<span class="lineNum">    7892 </span>            :     case DW_TAG_structure_type:
<span class="lineNum">    7893 </span>            :     case DW_TAG_subroutine_type:
<span class="lineNum">    7894 </span>            :     case DW_TAG_union_type:
<span class="lineNum">    7895 </span>            :     case DW_TAG_ptr_to_member_type:
<span class="lineNum">    7896 </span>            :     case DW_TAG_set_type:
<span class="lineNum">    7897 </span>            :     case DW_TAG_subrange_type:
<span class="lineNum">    7898 </span>            :     case DW_TAG_base_type:
<span class="lineNum">    7899 </span>            :     case DW_TAG_const_type:
<span class="lineNum">    7900 </span>            :     case DW_TAG_file_type:
<span class="lineNum">    7901 </span>            :     case DW_TAG_packed_type:
<span class="lineNum">    7902 </span>            :     case DW_TAG_volatile_type:
<span class="lineNum">    7903 </span>            :     case DW_TAG_typedef:
<span class="lineNum">    7904 </span>            :       return 1;
<span class="lineNum">    7905 </span><span class="lineCov">   40826336 :     default:</span>
<span class="lineNum">    7906 </span><span class="lineCov">   40826336 :       return 0;</span>
<span class="lineNum">    7907 </span>            :     }
<span class="lineNum">    7908 </span>            : }
<span class="lineNum">    7909 </span>            : 
<span class="lineNum">    7910 </span>            : /* Returns 1 iff C is the sort of DIE that should go into a COMDAT CU.
<span class="lineNum">    7911 </span>            :    Basically, we want to choose the bits that are likely to be shared between
<span class="lineNum">    7912 </span>            :    compilations (types) and leave out the bits that are specific to individual
<span class="lineNum">    7913 </span>            :    compilations (functions).  */
<a name="7914"><span class="lineNum">    7914 </span>            : </a>
<span class="lineNum">    7915 </span>            : static int
<span class="lineNum">    7916 </span><span class="lineNoCov">          0 : is_comdat_die (dw_die_ref c)</span>
<span class="lineNum">    7917 </span>            : {
<span class="lineNum">    7918 </span>            :   /* I think we want to leave base types and __vtbl_ptr_type in the main CU, as
<span class="lineNum">    7919 </span>            :      we do for stabs.  The advantage is a greater likelihood of sharing between
<span class="lineNum">    7920 </span>            :      objects that don't include headers in the same order (and therefore would
<span class="lineNum">    7921 </span>            :      put the base types in a different comdat).  jason 8/28/00 */
<span class="lineNum">    7922 </span>            : 
<span class="lineNum">    7923 </span><span class="lineNoCov">          0 :   if (c-&gt;die_tag == DW_TAG_base_type)</span>
<span class="lineNum">    7924 </span>            :     return 0;
<span class="lineNum">    7925 </span>            : 
<span class="lineNum">    7926 </span><span class="lineNoCov">          0 :   if (c-&gt;die_tag == DW_TAG_pointer_type</span>
<span class="lineNum">    7927 </span><span class="lineNoCov">          0 :       || c-&gt;die_tag == DW_TAG_reference_type</span>
<span class="lineNum">    7928 </span><span class="lineNoCov">          0 :       || c-&gt;die_tag == DW_TAG_rvalue_reference_type</span>
<span class="lineNum">    7929 </span><span class="lineNoCov">          0 :       || c-&gt;die_tag == DW_TAG_const_type</span>
<span class="lineNum">    7930 </span><span class="lineNoCov">          0 :       || c-&gt;die_tag == DW_TAG_volatile_type)</span>
<span class="lineNum">    7931 </span>            :     {
<span class="lineNum">    7932 </span><span class="lineNoCov">          0 :       dw_die_ref t = get_AT_ref (c, DW_AT_type);</span>
<span class="lineNum">    7933 </span>            : 
<span class="lineNum">    7934 </span><span class="lineNoCov">          0 :       return t ? is_comdat_die (t) : 0;</span>
<span class="lineNum">    7935 </span>            :     }
<span class="lineNum">    7936 </span>            : 
<span class="lineNum">    7937 </span><span class="lineNoCov">          0 :   return is_type_die (c);</span>
<span class="lineNum">    7938 </span>            : }
<span class="lineNum">    7939 </span>            : 
<span class="lineNum">    7940 </span>            : /* Returns true iff C is a compile-unit DIE.  */
<span class="lineNum">    7941 </span>            : 
<span class="lineNum">    7942 </span>            : static inline bool
<span class="lineNum">    7943 </span>            : is_cu_die (dw_die_ref c)
<span class="lineNum">    7944 </span>            : {
<span class="lineNum">    7945 </span><span class="lineCov">   25969936 :   return c &amp;&amp; (c-&gt;die_tag == DW_TAG_compile_unit</span>
<span class="lineNum">    7946 </span><span class="lineCov">    8632504 :                || c-&gt;die_tag == DW_TAG_skeleton_unit);</span>
<span class="lineNum">    7947 </span>            : }
<span class="lineNum">    7948 </span>            : 
<span class="lineNum">    7949 </span>            : /* Returns true iff C is a unit DIE of some sort.  */
<span class="lineNum">    7950 </span>            : 
<span class="lineNum">    7951 </span>            : static inline bool
<span class="lineNum">    7952 </span>            : is_unit_die (dw_die_ref c)
<span class="lineNum">    7953 </span>            : {
<span class="lineNum">    7954 </span><span class="lineCov">    3193495 :   return c &amp;&amp; (c-&gt;die_tag == DW_TAG_compile_unit</span>
<span class="lineNum">    7955 </span><span class="lineCov">    1064405 :                || c-&gt;die_tag == DW_TAG_partial_unit</span>
<span class="lineNum">    7956 </span><span class="lineCov">     791176 :                || c-&gt;die_tag == DW_TAG_type_unit</span>
<span class="lineNum">    7957 </span><span class="lineCov">     791175 :                || c-&gt;die_tag == DW_TAG_skeleton_unit);</span>
<span class="lineNum">    7958 </span>            : }
<span class="lineNum">    7959 </span>            : 
<span class="lineNum">    7960 </span>            : /* Returns true iff C is a namespace DIE.  */
<span class="lineNum">    7961 </span>            : 
<span class="lineNum">    7962 </span>            : static inline bool
<span class="lineNum">    7963 </span>            : is_namespace_die (dw_die_ref c)
<span class="lineNum">    7964 </span>            : {
<span class="lineNum">    7965 </span><span class="lineCov">        109 :   return c &amp;&amp; c-&gt;die_tag == DW_TAG_namespace;</span>
<span class="lineNum">    7966 </span>            : }
<span class="lineNum">    7967 </span>            : 
<span class="lineNum">    7968 </span>            : /* Returns true iff C is a class or structure DIE.  */
<span class="lineNum">    7969 </span>            : 
<span class="lineNum">    7970 </span>            : static inline bool
<span class="lineNum">    7971 </span>            : is_class_die (dw_die_ref c)
<span class="lineNum">    7972 </span>            : {
<span class="lineNum">    7973 </span>            :   return c &amp;&amp; (c-&gt;die_tag == DW_TAG_class_type
<span class="lineNum">    7974 </span>            :                || c-&gt;die_tag == DW_TAG_structure_type);
<span class="lineNum">    7975 </span>            : }
<span class="lineNum">    7976 </span>            : 
<span class="lineNum">    7977 </span>            : /* Return non-zero if this DIE is a template parameter.  */
<a name="7978"><span class="lineNum">    7978 </span>            : </a>
<span class="lineNum">    7979 </span>            : static inline bool
<span class="lineNum">    7980 </span><span class="lineNoCov">          0 : is_template_parameter (dw_die_ref die)</span>
<span class="lineNum">    7981 </span>            : {
<span class="lineNum">    7982 </span><span class="lineNoCov">          0 :   switch (die-&gt;die_tag)</span>
<span class="lineNum">    7983 </span>            :     {
<span class="lineNum">    7984 </span>            :     case DW_TAG_template_type_param:
<span class="lineNum">    7985 </span>            :     case DW_TAG_template_value_param:
<span class="lineNum">    7986 </span>            :     case DW_TAG_GNU_template_template_param:
<span class="lineNum">    7987 </span>            :     case DW_TAG_GNU_template_parameter_pack:
<span class="lineNum">    7988 </span>            :       return true;
<span class="lineNum">    7989 </span><span class="lineCov">        197 :     default:</span>
<span class="lineNum">    7990 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    7991 </span>            :     }
<span class="lineNum">    7992 </span>            : }
<span class="lineNum">    7993 </span>            : 
<span class="lineNum">    7994 </span>            : /* Return non-zero if this DIE represents a template instantiation.  */
<a name="7995"><span class="lineNum">    7995 </span>            : </a>
<span class="lineNum">    7996 </span>            : static inline bool
<span class="lineNum">    7997 </span><span class="lineCov">        212 : is_template_instantiation (dw_die_ref die)</span>
<span class="lineNum">    7998 </span>            : {
<span class="lineNum">    7999 </span><span class="lineCov">        212 :   dw_die_ref c;</span>
<span class="lineNum">    8000 </span>            : 
<span class="lineNum">    8001 </span><span class="lineCov">        212 :   if (!is_type_die (die) &amp;&amp; die-&gt;die_tag != DW_TAG_subprogram)</span>
<span class="lineNum">    8002 </span>            :     return false;
<span class="lineNum">    8003 </span><span class="lineCov">        229 :   FOR_EACH_CHILD (die, c, if (is_template_parameter (c)) return true);</span>
<span class="lineNum">    8004 </span>            :   return false;
<span class="lineNum">    8005 </span>            : }
<a name="8006"><span class="lineNum">    8006 </span>            : </a>
<span class="lineNum">    8007 </span>            : static char *
<span class="lineNum">    8008 </span><span class="lineCov">   12187982 : gen_internal_sym (const char *prefix)</span>
<span class="lineNum">    8009 </span>            : {
<span class="lineNum">    8010 </span><span class="lineCov">   12187982 :   char buf[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">    8011 </span>            : 
<span class="lineNum">    8012 </span><span class="lineCov">   12187982 :   ASM_GENERATE_INTERNAL_LABEL (buf, prefix, label_num++);</span>
<span class="lineNum">    8013 </span><span class="lineCov">   12187982 :   return xstrdup (buf);</span>
<span class="lineNum">    8014 </span>            : }
<span class="lineNum">    8015 </span>            : 
<span class="lineNum">    8016 </span>            : /* Return non-zero if this DIE is a declaration.  */
<a name="8017"><span class="lineNum">    8017 </span>            : </a>
<span class="lineNum">    8018 </span>            : static int
<span class="lineNum">    8019 </span><span class="lineNoCov">          0 : is_declaration_die (dw_die_ref die)</span>
<span class="lineNum">    8020 </span>            : {
<span class="lineNum">    8021 </span><span class="lineCov">        447 :   dw_attr_node *a;</span>
<span class="lineNum">    8022 </span><span class="lineCov">        447 :   unsigned ix;</span>
<span class="lineNum">    8023 </span>            : 
<span class="lineNum">    8024 </span><span class="lineCov">   15445406 :   FOR_EACH_VEC_SAFE_ELT (die-&gt;die_attr, ix, a)</span>
<span class="lineNum">    8025 </span><span class="lineCov">   15048724 :     if (a-&gt;dw_attr == DW_AT_declaration)</span>
<span class="lineNum">    8026 </span>            :       return 1;
<span class="lineNum">    8027 </span>            : 
<span class="lineNum">    8028 </span>            :   return 0;
<span class="lineNum">    8029 </span>            : }
<span class="lineNum">    8030 </span>            : 
<span class="lineNum">    8031 </span>            : /* Return non-zero if this DIE is nested inside a subprogram.  */
<a name="8032"><span class="lineNum">    8032 </span>            : </a>
<span class="lineNum">    8033 </span>            : static int
<span class="lineNum">    8034 </span><span class="lineCov">         48 : is_nested_in_subprogram (dw_die_ref die)</span>
<span class="lineNum">    8035 </span>            : {
<span class="lineNum">    8036 </span><span class="lineCov">         48 :   dw_die_ref decl = get_AT_ref (die, DW_AT_specification);</span>
<span class="lineNum">    8037 </span>            : 
<span class="lineNum">    8038 </span><span class="lineCov">         48 :   if (decl == NULL)</span>
<span class="lineNum">    8039 </span><span class="lineCov">         48 :     decl = die;</span>
<span class="lineNum">    8040 </span><span class="lineCov">         48 :   return local_scope_p (decl);</span>
<span class="lineNum">    8041 </span>            : }
<span class="lineNum">    8042 </span>            : 
<span class="lineNum">    8043 </span>            : /* Return non-zero if this DIE contains a defining declaration of a
<span class="lineNum">    8044 </span>            :    subprogram.  */
<a name="8045"><span class="lineNum">    8045 </span>            : </a>
<span class="lineNum">    8046 </span>            : static int
<span class="lineNum">    8047 </span><span class="lineCov">        280 : contains_subprogram_definition (dw_die_ref die)</span>
<span class="lineNum">    8048 </span>            : {
<span class="lineNum">    8049 </span><span class="lineCov">        280 :   dw_die_ref c;</span>
<span class="lineNum">    8050 </span>            : 
<span class="lineNum">    8051 </span><span class="lineCov">        340 :   if (die-&gt;die_tag == DW_TAG_subprogram &amp;&amp; ! is_declaration_die (die))</span>
<span class="lineNum">    8052 </span>            :     return 1;
<span class="lineNum">    8053 </span><span class="lineCov">        402 :   FOR_EACH_CHILD (die, c, if (contains_subprogram_definition (c)) return 1);</span>
<span class="lineNum">    8054 </span>            :   return 0;
<span class="lineNum">    8055 </span>            : }
<span class="lineNum">    8056 </span>            : 
<span class="lineNum">    8057 </span>            : /* Return non-zero if this is a type DIE that should be moved to a
<span class="lineNum">    8058 </span>            :    COMDAT .debug_types section or .debug_info section with DW_UT_*type
<span class="lineNum">    8059 </span>            :    unit type.  */
<a name="8060"><span class="lineNum">    8060 </span>            : </a>
<span class="lineNum">    8061 </span>            : static int
<span class="lineNum">    8062 </span><span class="lineCov">        477 : should_move_die_to_comdat (dw_die_ref die)</span>
<span class="lineNum">    8063 </span>            : {
<span class="lineNum">    8064 </span><span class="lineCov">        477 :   switch (die-&gt;die_tag)</span>
<span class="lineNum">    8065 </span>            :     {
<span class="lineNum">    8066 </span>            :     case DW_TAG_class_type:
<span class="lineNum">    8067 </span>            :     case DW_TAG_structure_type:
<span class="lineNum">    8068 </span>            :     case DW_TAG_enumeration_type:
<span class="lineNum">    8069 </span>            :     case DW_TAG_union_type:
<span class="lineNum">    8070 </span>            :       /* Don't move declarations, inlined instances, types nested in a
<span class="lineNum">    8071 </span>            :          subprogram, or types that contain subprogram definitions.  */
<span class="lineNum">    8072 </span><span class="lineCov">         53 :       if (is_declaration_die (die)</span>
<span class="lineNum">    8073 </span><span class="lineCov">         48 :           || get_AT (die, DW_AT_abstract_origin)</span>
<span class="lineNum">    8074 </span><span class="lineCov">         48 :           || is_nested_in_subprogram (die)</span>
<span class="lineNum">    8075 </span><span class="lineCov">        101 :           || contains_subprogram_definition (die))</span>
<span class="lineNum">    8076 </span><span class="lineCov">          5 :         return 0;</span>
<span class="lineNum">    8077 </span>            :       return 1;
<span class="lineNum">    8078 </span>            :     case DW_TAG_array_type:
<span class="lineNum">    8079 </span>            :     case DW_TAG_interface_type:
<span class="lineNum">    8080 </span>            :     case DW_TAG_pointer_type:
<span class="lineNum">    8081 </span>            :     case DW_TAG_reference_type:
<span class="lineNum">    8082 </span>            :     case DW_TAG_rvalue_reference_type:
<span class="lineNum">    8083 </span>            :     case DW_TAG_string_type:
<span class="lineNum">    8084 </span>            :     case DW_TAG_subroutine_type:
<span class="lineNum">    8085 </span>            :     case DW_TAG_ptr_to_member_type:
<span class="lineNum">    8086 </span>            :     case DW_TAG_set_type:
<span class="lineNum">    8087 </span>            :     case DW_TAG_subrange_type:
<span class="lineNum">    8088 </span>            :     case DW_TAG_base_type:
<span class="lineNum">    8089 </span>            :     case DW_TAG_const_type:
<span class="lineNum">    8090 </span>            :     case DW_TAG_file_type:
<span class="lineNum">    8091 </span>            :     case DW_TAG_packed_type:
<span class="lineNum">    8092 </span>            :     case DW_TAG_volatile_type:
<span class="lineNum">    8093 </span>            :     case DW_TAG_typedef:
<span class="lineNum">    8094 </span>            :     default:
<span class="lineNum">    8095 </span>            :       return 0;
<span class="lineNum">    8096 </span>            :     }
<span class="lineNum">    8097 </span>            : }
<span class="lineNum">    8098 </span>            : 
<span class="lineNum">    8099 </span>            : /* Make a clone of DIE.  */
<a name="8100"><span class="lineNum">    8100 </span>            : </a>
<span class="lineNum">    8101 </span>            : static dw_die_ref
<span class="lineNum">    8102 </span><span class="lineCov">        182 : clone_die (dw_die_ref die)</span>
<span class="lineNum">    8103 </span>            : {
<span class="lineNum">    8104 </span><span class="lineCov">        182 :   dw_die_ref clone = new_die_raw (die-&gt;die_tag);</span>
<span class="lineNum">    8105 </span><span class="lineCov">        182 :   dw_attr_node *a;</span>
<span class="lineNum">    8106 </span><span class="lineCov">        182 :   unsigned ix;</span>
<span class="lineNum">    8107 </span>            : 
<span class="lineNum">    8108 </span><span class="lineCov">        925 :   FOR_EACH_VEC_SAFE_ELT (die-&gt;die_attr, ix, a)</span>
<span class="lineNum">    8109 </span><span class="lineCov">        743 :     add_dwarf_attr (clone, a);</span>
<span class="lineNum">    8110 </span>            : 
<span class="lineNum">    8111 </span><span class="lineCov">        182 :   return clone;</span>
<span class="lineNum">    8112 </span>            : }
<span class="lineNum">    8113 </span>            : 
<span class="lineNum">    8114 </span>            : /* Make a clone of the tree rooted at DIE.  */
<a name="8115"><span class="lineNum">    8115 </span>            : </a>
<span class="lineNum">    8116 </span>            : static dw_die_ref
<span class="lineNum">    8117 </span><span class="lineNoCov">          0 : clone_tree (dw_die_ref die)</span>
<span class="lineNum">    8118 </span>            : {
<span class="lineNum">    8119 </span><span class="lineNoCov">          0 :   dw_die_ref c;</span>
<span class="lineNum">    8120 </span><span class="lineNoCov">          0 :   dw_die_ref clone = clone_die (die);</span>
<span class="lineNum">    8121 </span>            : 
<span class="lineNum">    8122 </span><span class="lineNoCov">          0 :   FOR_EACH_CHILD (die, c, add_child_die (clone, clone_tree (c)));</span>
<span class="lineNum">    8123 </span>            : 
<span class="lineNum">    8124 </span><span class="lineNoCov">          0 :   return clone;</span>
<span class="lineNum">    8125 </span>            : }
<span class="lineNum">    8126 </span>            : 
<span class="lineNum">    8127 </span>            : /* Make a clone of DIE as a declaration.  */
<a name="8128"><span class="lineNum">    8128 </span>            : </a>
<span class="lineNum">    8129 </span>            : static dw_die_ref
<span class="lineNum">    8130 </span><span class="lineCov">        110 : clone_as_declaration (dw_die_ref die)</span>
<span class="lineNum">    8131 </span>            : {
<span class="lineNum">    8132 </span><span class="lineCov">        110 :   dw_die_ref clone;</span>
<span class="lineNum">    8133 </span><span class="lineCov">        110 :   dw_die_ref decl;</span>
<span class="lineNum">    8134 </span><span class="lineCov">        110 :   dw_attr_node *a;</span>
<span class="lineNum">    8135 </span><span class="lineCov">        110 :   unsigned ix;</span>
<span class="lineNum">    8136 </span>            : 
<span class="lineNum">    8137 </span>            :   /* If the DIE is already a declaration, just clone it.  */
<span class="lineNum">    8138 </span><span class="lineCov">        220 :   if (is_declaration_die (die))</span>
<span class="lineNum">    8139 </span><span class="lineNoCov">          0 :     return clone_die (die);</span>
<span class="lineNum">    8140 </span>            : 
<span class="lineNum">    8141 </span>            :   /* If the DIE is a specification, just clone its declaration DIE.  */
<span class="lineNum">    8142 </span><span class="lineCov">        110 :   decl = get_AT_ref (die, DW_AT_specification);</span>
<span class="lineNum">    8143 </span><span class="lineCov">        110 :   if (decl != NULL)</span>
<span class="lineNum">    8144 </span>            :     {
<span class="lineNum">    8145 </span><span class="lineCov">         23 :       clone = clone_die (decl);</span>
<span class="lineNum">    8146 </span><span class="lineCov">         23 :       if (die-&gt;comdat_type_p)</span>
<span class="lineNum">    8147 </span><span class="lineCov">         23 :         add_AT_die_ref (clone, DW_AT_signature, die);</span>
<span class="lineNum">    8148 </span><span class="lineCov">         23 :       return clone;</span>
<span class="lineNum">    8149 </span>            :     }
<span class="lineNum">    8150 </span>            : 
<span class="lineNum">    8151 </span><span class="lineCov">         87 :   clone = new_die_raw (die-&gt;die_tag);</span>
<span class="lineNum">    8152 </span>            : 
<span class="lineNum">    8153 </span><span class="lineCov">        465 :   FOR_EACH_VEC_SAFE_ELT (die-&gt;die_attr, ix, a)</span>
<span class="lineNum">    8154 </span>            :     {
<span class="lineNum">    8155 </span>            :       /* We don't want to copy over all attributes.
<span class="lineNum">    8156 </span>            :          For example we don't want DW_AT_byte_size because otherwise we will no
<span class="lineNum">    8157 </span>            :          longer have a declaration and GDB will treat it as a definition.  */
<span class="lineNum">    8158 </span>            : 
<span class="lineNum">    8159 </span><span class="lineCov">        378 :       switch (a-&gt;dw_attr)</span>
<span class="lineNum">    8160 </span>            :         {
<span class="lineNum">    8161 </span><span class="lineCov">         81 :         case DW_AT_abstract_origin:</span>
<span class="lineNum">    8162 </span><span class="lineCov">         81 :         case DW_AT_artificial:</span>
<span class="lineNum">    8163 </span><span class="lineCov">         81 :         case DW_AT_containing_type:</span>
<span class="lineNum">    8164 </span><span class="lineCov">         81 :         case DW_AT_external:</span>
<span class="lineNum">    8165 </span><span class="lineCov">         81 :         case DW_AT_name:</span>
<span class="lineNum">    8166 </span><span class="lineCov">         81 :         case DW_AT_type:</span>
<span class="lineNum">    8167 </span><span class="lineCov">         81 :         case DW_AT_virtuality:</span>
<span class="lineNum">    8168 </span><span class="lineCov">         81 :         case DW_AT_linkage_name:</span>
<span class="lineNum">    8169 </span><span class="lineCov">         81 :         case DW_AT_MIPS_linkage_name:</span>
<span class="lineNum">    8170 </span><span class="lineCov">         81 :           add_dwarf_attr (clone, a);</span>
<span class="lineNum">    8171 </span><span class="lineCov">         81 :           break;</span>
<span class="lineNum">    8172 </span>            :         case DW_AT_byte_size:
<span class="lineNum">    8173 </span>            :         case DW_AT_alignment:
<span class="lineNum">    8174 </span>            :         default:
<span class="lineNum">    8175 </span>            :           break;
<span class="lineNum">    8176 </span>            :         }
<span class="lineNum">    8177 </span>            :     }
<span class="lineNum">    8178 </span>            : 
<span class="lineNum">    8179 </span><span class="lineCov">         87 :   if (die-&gt;comdat_type_p)</span>
<span class="lineNum">    8180 </span><span class="lineCov">         46 :     add_AT_die_ref (clone, DW_AT_signature, die);</span>
<span class="lineNum">    8181 </span>            : 
<span class="lineNum">    8182 </span><span class="lineCov">         87 :   add_AT_flag (clone, DW_AT_declaration, 1);</span>
<span class="lineNum">    8183 </span><span class="lineCov">         87 :   return clone;</span>
<span class="lineNum">    8184 </span>            : }
<span class="lineNum">    8185 </span>            : 
<span class="lineNum">    8186 </span>            : 
<span class="lineNum">    8187 </span>            : /* Structure to map a DIE in one CU to its copy in a comdat type unit.  */
<span class="lineNum">    8188 </span>            : 
<span class="lineNum">    8189 </span>            : struct decl_table_entry
<span class="lineNum">    8190 </span>            : {
<span class="lineNum">    8191 </span>            :   dw_die_ref orig;
<span class="lineNum">    8192 </span>            :   dw_die_ref copy;
<span class="lineNum">    8193 </span>            : };
<span class="lineNum">    8194 </span>            : 
<span class="lineNum">    8195 </span>            : /* Helpers to manipulate hash table of copied declarations.  */
<span class="lineNum">    8196 </span>            : 
<span class="lineNum">    8197 </span>            : /* Hashtable helpers.  */
<span class="lineNum">    8198 </span>            : 
<span class="lineNum">    8199 </span>            : struct decl_table_entry_hasher : free_ptr_hash &lt;decl_table_entry&gt;
<span class="lineNum">    8200 </span>            : {
<span class="lineNum">    8201 </span>            :   typedef die_struct *compare_type;
<span class="lineNum">    8202 </span>            :   static inline hashval_t hash (const decl_table_entry *);
<span class="lineNum">    8203 </span>            :   static inline bool equal (const decl_table_entry *, const die_struct *);
<span class="lineNum">    8204 </span>            : };
<a name="8205"><span class="lineNum">    8205 </span>            : </a>
<span class="lineNum">    8206 </span>            : inline hashval_t
<span class="lineNum">    8207 </span><span class="lineNoCov">          0 : decl_table_entry_hasher::hash (const decl_table_entry *entry)</span>
<span class="lineNum">    8208 </span>            : {
<span class="lineNum">    8209 </span><span class="lineNoCov">          0 :   return htab_hash_pointer (entry-&gt;orig);</span>
<span class="lineNum">    8210 </span>            : }
<a name="8211"><span class="lineNum">    8211 </span>            : </a>
<span class="lineNum">    8212 </span>            : inline bool
<span class="lineNum">    8213 </span><span class="lineNoCov">          0 : decl_table_entry_hasher::equal (const decl_table_entry *entry1,</span>
<span class="lineNum">    8214 </span>            :                                 const die_struct *entry2)
<span class="lineNum">    8215 </span>            : {
<span class="lineNum">    8216 </span><span class="lineCov">         82 :   return entry1-&gt;orig == entry2;</span>
<span class="lineNum">    8217 </span>            : }
<span class="lineNum">    8218 </span>            : 
<span class="lineNum">    8219 </span>            : typedef hash_table&lt;decl_table_entry_hasher&gt; decl_hash_type;
<span class="lineNum">    8220 </span>            : 
<span class="lineNum">    8221 </span>            : /* Copy DIE and its ancestors, up to, but not including, the compile unit
<span class="lineNum">    8222 </span>            :    or type unit entry, to a new tree.  Adds the new tree to UNIT and returns
<span class="lineNum">    8223 </span>            :    a pointer to the copy of DIE.  If DECL_TABLE is provided, it is used
<span class="lineNum">    8224 </span>            :    to check if the ancestor has already been copied into UNIT.  */
<a name="8225"><span class="lineNum">    8225 </span>            : </a>
<span class="lineNum">    8226 </span>            : static dw_die_ref
<span class="lineNum">    8227 </span><span class="lineCov">         80 : copy_ancestor_tree (dw_die_ref unit, dw_die_ref die,</span>
<span class="lineNum">    8228 </span>            :                     decl_hash_type *decl_table)
<span class="lineNum">    8229 </span>            : {
<span class="lineNum">    8230 </span><span class="lineCov">         80 :   dw_die_ref parent = die-&gt;die_parent;</span>
<span class="lineNum">    8231 </span><span class="lineCov">         80 :   dw_die_ref new_parent = unit;</span>
<span class="lineNum">    8232 </span><span class="lineCov">         80 :   dw_die_ref copy;</span>
<span class="lineNum">    8233 </span><span class="lineCov">         80 :   decl_table_entry **slot = NULL;</span>
<span class="lineNum">    8234 </span><span class="lineCov">         80 :   struct decl_table_entry *entry = NULL;</span>
<span class="lineNum">    8235 </span>            : 
<span class="lineNum">    8236 </span><span class="lineCov">         80 :   if (decl_table)</span>
<span class="lineNum">    8237 </span>            :     {
<span class="lineNum">    8238 </span>            :       /* Check if the entry has already been copied to UNIT.  */
<span class="lineNum">    8239 </span><span class="lineCov">          8 :       slot = decl_table-&gt;find_slot_with_hash (die, htab_hash_pointer (die),</span>
<span class="lineNum">    8240 </span>            :                                               INSERT);
<span class="lineNum">    8241 </span><span class="lineCov">          8 :       if (*slot != HTAB_EMPTY_ENTRY)</span>
<span class="lineNum">    8242 </span>            :         {
<span class="lineNum">    8243 </span><span class="lineCov">          4 :           entry = *slot;</span>
<span class="lineNum">    8244 </span><span class="lineCov">          4 :           return entry-&gt;copy;</span>
<span class="lineNum">    8245 </span>            :         }
<span class="lineNum">    8246 </span>            : 
<span class="lineNum">    8247 </span>            :       /* Record in DECL_TABLE that DIE has been copied to UNIT.  */
<span class="lineNum">    8248 </span><span class="lineCov">          4 :       entry = XCNEW (struct decl_table_entry);</span>
<span class="lineNum">    8249 </span><span class="lineCov">          4 :       entry-&gt;orig = die;</span>
<span class="lineNum">    8250 </span><span class="lineCov">          4 :       entry-&gt;copy = NULL;</span>
<span class="lineNum">    8251 </span><span class="lineCov">          4 :       *slot = entry;</span>
<span class="lineNum">    8252 </span>            :     }
<span class="lineNum">    8253 </span>            : 
<span class="lineNum">    8254 </span><span class="lineCov">         76 :   if (parent != NULL)</span>
<span class="lineNum">    8255 </span>            :     {
<span class="lineNum">    8256 </span><span class="lineCov">         76 :       dw_die_ref spec = get_AT_ref (parent, DW_AT_specification);</span>
<span class="lineNum">    8257 </span><span class="lineCov">         76 :       if (spec != NULL)</span>
<span class="lineNum">    8258 </span><span class="lineNoCov">          0 :         parent = spec;</span>
<span class="lineNum">    8259 </span><span class="lineCov">         76 :       if (!is_unit_die (parent))</span>
<span class="lineNum">    8260 </span><span class="lineCov">         38 :         new_parent = copy_ancestor_tree (unit, parent, decl_table);</span>
<span class="lineNum">    8261 </span>            :     }
<span class="lineNum">    8262 </span>            : 
<span class="lineNum">    8263 </span><span class="lineCov">         76 :   copy = clone_as_declaration (die);</span>
<span class="lineNum">    8264 </span><span class="lineCov">         76 :   add_child_die (new_parent, copy);</span>
<span class="lineNum">    8265 </span>            : 
<span class="lineNum">    8266 </span><span class="lineCov">         76 :   if (decl_table)</span>
<span class="lineNum">    8267 </span>            :     {
<span class="lineNum">    8268 </span>            :       /* Record the pointer to the copy.  */
<span class="lineNum">    8269 </span><span class="lineCov">          4 :       entry-&gt;copy = copy;</span>
<span class="lineNum">    8270 </span>            :     }
<span class="lineNum">    8271 </span>            : 
<span class="lineNum">    8272 </span>            :   return copy;
<span class="lineNum">    8273 </span>            : }
<span class="lineNum">    8274 </span>            : /* Copy the declaration context to the new type unit DIE.  This includes
<span class="lineNum">    8275 </span>            :    any surrounding namespace or type declarations.  If the DIE has an
<span class="lineNum">    8276 </span>            :    AT_specification attribute, it also includes attributes and children
<span class="lineNum">    8277 </span>            :    attached to the specification, and returns a pointer to the original
<span class="lineNum">    8278 </span>            :    parent of the declaration DIE.  Returns NULL otherwise.  */
<a name="8279"><span class="lineNum">    8279 </span>            : </a>
<span class="lineNum">    8280 </span>            : static dw_die_ref
<span class="lineNum">    8281 </span><span class="lineCov">         48 : copy_declaration_context (dw_die_ref unit, dw_die_ref die)</span>
<span class="lineNum">    8282 </span>            : {
<span class="lineNum">    8283 </span><span class="lineCov">         48 :   dw_die_ref decl;</span>
<span class="lineNum">    8284 </span><span class="lineCov">         48 :   dw_die_ref new_decl;</span>
<span class="lineNum">    8285 </span><span class="lineCov">         48 :   dw_die_ref orig_parent = NULL;</span>
<span class="lineNum">    8286 </span>            : 
<span class="lineNum">    8287 </span><span class="lineCov">         48 :   decl = get_AT_ref (die, DW_AT_specification);</span>
<span class="lineNum">    8288 </span><span class="lineCov">         48 :   if (decl == NULL)</span>
<span class="lineNum">    8289 </span>            :     decl = die;
<span class="lineNum">    8290 </span>            :   else
<span class="lineNum">    8291 </span>            :     {
<span class="lineNum">    8292 </span><span class="lineNoCov">          0 :       unsigned ix;</span>
<span class="lineNum">    8293 </span><span class="lineNoCov">          0 :       dw_die_ref c;</span>
<span class="lineNum">    8294 </span><span class="lineNoCov">          0 :       dw_attr_node *a;</span>
<span class="lineNum">    8295 </span>            : 
<span class="lineNum">    8296 </span>            :       /* The original DIE will be changed to a declaration, and must
<span class="lineNum">    8297 </span>            :          be moved to be a child of the original declaration DIE.  */
<span class="lineNum">    8298 </span><span class="lineNoCov">          0 :       orig_parent = decl-&gt;die_parent;</span>
<span class="lineNum">    8299 </span>            : 
<span class="lineNum">    8300 </span>            :       /* Copy the type node pointer from the new DIE to the original
<span class="lineNum">    8301 </span>            :          declaration DIE so we can forward references later.  */
<span class="lineNum">    8302 </span><span class="lineNoCov">          0 :       decl-&gt;comdat_type_p = true;</span>
<span class="lineNum">    8303 </span><span class="lineNoCov">          0 :       decl-&gt;die_id.die_type_node = die-&gt;die_id.die_type_node;</span>
<span class="lineNum">    8304 </span>            : 
<span class="lineNum">    8305 </span><span class="lineNoCov">          0 :       remove_AT (die, DW_AT_specification);</span>
<span class="lineNum">    8306 </span>            : 
<span class="lineNum">    8307 </span><span class="lineNoCov">          0 :       FOR_EACH_VEC_SAFE_ELT (decl-&gt;die_attr, ix, a)</span>
<span class="lineNum">    8308 </span>            :         {
<span class="lineNum">    8309 </span><span class="lineNoCov">          0 :           if (a-&gt;dw_attr != DW_AT_name</span>
<span class="lineNum">    8310 </span><span class="lineNoCov">          0 :               &amp;&amp; a-&gt;dw_attr != DW_AT_declaration</span>
<span class="lineNum">    8311 </span><span class="lineNoCov">          0 :               &amp;&amp; a-&gt;dw_attr != DW_AT_external)</span>
<span class="lineNum">    8312 </span><span class="lineNoCov">          0 :             add_dwarf_attr (die, a);</span>
<span class="lineNum">    8313 </span>            :         }
<span class="lineNum">    8314 </span>            : 
<span class="lineNum">    8315 </span><span class="lineNoCov">          0 :       FOR_EACH_CHILD (decl, c, add_child_die (die, clone_tree (c)));</span>
<span class="lineNum">    8316 </span>            :     }
<span class="lineNum">    8317 </span>            : 
<span class="lineNum">    8318 </span><span class="lineCov">         48 :   if (decl-&gt;die_parent != NULL</span>
<span class="lineNum">    8319 </span><span class="lineCov">         48 :       &amp;&amp; !is_unit_die (decl-&gt;die_parent))</span>
<span class="lineNum">    8320 </span>            :     {
<span class="lineNum">    8321 </span><span class="lineCov">         34 :       new_decl = copy_ancestor_tree (unit, decl, NULL);</span>
<span class="lineNum">    8322 </span><span class="lineCov">         34 :       if (new_decl != NULL)</span>
<span class="lineNum">    8323 </span>            :         {
<span class="lineNum">    8324 </span><span class="lineCov">         34 :           remove_AT (new_decl, DW_AT_signature);</span>
<span class="lineNum">    8325 </span><span class="lineCov">         34 :           add_AT_specification (die, new_decl);</span>
<span class="lineNum">    8326 </span>            :         }
<span class="lineNum">    8327 </span>            :     }
<span class="lineNum">    8328 </span>            : 
<span class="lineNum">    8329 </span><span class="lineCov">         48 :   return orig_parent;</span>
<span class="lineNum">    8330 </span>            : }
<span class="lineNum">    8331 </span>            : 
<span class="lineNum">    8332 </span>            : /* Generate the skeleton ancestor tree for the given NODE, then clone
<span class="lineNum">    8333 </span>            :    the DIE and add the clone into the tree.  */
<a name="8334"><span class="lineNum">    8334 </span>            : </a>
<span class="lineNum">    8335 </span>            : static void
<span class="lineNum">    8336 </span><span class="lineCov">         64 : generate_skeleton_ancestor_tree (skeleton_chain_node *node)</span>
<span class="lineNum">    8337 </span>            : {
<span class="lineNum">    8338 </span><span class="lineCov">         64 :   if (node-&gt;new_die != NULL)</span>
<span class="lineNum">    8339 </span>            :     return;
<span class="lineNum">    8340 </span>            : 
<span class="lineNum">    8341 </span><span class="lineCov">         25 :   node-&gt;new_die = clone_as_declaration (node-&gt;old_die);</span>
<span class="lineNum">    8342 </span>            : 
<span class="lineNum">    8343 </span><span class="lineCov">         25 :   if (node-&gt;parent != NULL)</span>
<span class="lineNum">    8344 </span>            :     {
<span class="lineNum">    8345 </span><span class="lineNoCov">          0 :       generate_skeleton_ancestor_tree (node-&gt;parent);</span>
<span class="lineNum">    8346 </span><span class="lineNoCov">          0 :       add_child_die (node-&gt;parent-&gt;new_die, node-&gt;new_die);</span>
<span class="lineNum">    8347 </span>            :     }
<span class="lineNum">    8348 </span>            : }
<span class="lineNum">    8349 </span>            : 
<span class="lineNum">    8350 </span>            : /* Generate a skeleton tree of DIEs containing any declarations that are
<span class="lineNum">    8351 </span>            :    found in the original tree.  We traverse the tree looking for declaration
<span class="lineNum">    8352 </span>            :    DIEs, and construct the skeleton from the bottom up whenever we find one.  */
<a name="8353"><span class="lineNum">    8353 </span>            : </a>
<span class="lineNum">    8354 </span>            : static void
<span class="lineNum">    8355 </span><span class="lineCov">        248 : generate_skeleton_bottom_up (skeleton_chain_node *parent)</span>
<span class="lineNum">    8356 </span>            : {
<span class="lineNum">    8357 </span><span class="lineCov">        248 :   skeleton_chain_node node;</span>
<span class="lineNum">    8358 </span><span class="lineCov">        248 :   dw_die_ref c;</span>
<span class="lineNum">    8359 </span><span class="lineCov">        248 :   dw_die_ref first;</span>
<span class="lineNum">    8360 </span><span class="lineCov">        248 :   dw_die_ref prev = NULL;</span>
<span class="lineNum">    8361 </span><span class="lineCov">        248 :   dw_die_ref next = NULL;</span>
<span class="lineNum">    8362 </span>            : 
<span class="lineNum">    8363 </span><span class="lineCov">        248 :   node.parent = parent;</span>
<span class="lineNum">    8364 </span>            : 
<span class="lineNum">    8365 </span><span class="lineCov">        248 :   first = c = parent-&gt;old_die-&gt;die_child;</span>
<span class="lineNum">    8366 </span><span class="lineCov">        248 :   if (c)</span>
<span class="lineNum">    8367 </span><span class="lineCov">         96 :     next = c-&gt;die_sib;</span>
<span class="lineNum">    8368 </span><span class="lineCov">        248 :   if (c) do {</span>
<span class="lineNum">    8369 </span><span class="lineCov">        209 :     if (prev == NULL || prev-&gt;die_sib == c)</span>
<span class="lineNum">    8370 </span><span class="lineCov">        209 :       prev = c;</span>
<span class="lineNum">    8371 </span><span class="lineCov">        209 :     c = next;</span>
<span class="lineNum">    8372 </span><span class="lineCov">        209 :     next = (c == first ? NULL : c-&gt;die_sib);</span>
<span class="lineNum">    8373 </span><span class="lineCov">        209 :     node.old_die = c;</span>
<span class="lineNum">    8374 </span><span class="lineCov">        209 :     node.new_die = NULL;</span>
<span class="lineNum">    8375 </span><span class="lineCov">        418 :     if (is_declaration_die (c))</span>
<span class="lineNum">    8376 </span>            :       {
<span class="lineNum">    8377 </span><span class="lineCov">         68 :         if (is_template_instantiation (c))</span>
<span class="lineNum">    8378 </span>            :           {
<span class="lineNum">    8379 </span>            :             /* Instantiated templates do not need to be cloned into the
<span class="lineNum">    8380 </span>            :                type unit.  Just move the DIE and its children back to
<span class="lineNum">    8381 </span>            :                the skeleton tree (in the main CU).  */
<span class="lineNum">    8382 </span><span class="lineCov">          4 :             remove_child_with_prev (c, prev);</span>
<span class="lineNum">    8383 </span><span class="lineCov">          4 :             add_child_die (parent-&gt;new_die, c);</span>
<span class="lineNum">    8384 </span><span class="lineCov">          4 :             c = prev;</span>
<span class="lineNum">    8385 </span>            :           }
<span class="lineNum">    8386 </span><span class="lineCov">         64 :         else if (c-&gt;comdat_type_p)</span>
<span class="lineNum">    8387 </span>            :           {
<span class="lineNum">    8388 </span>            :             /* This is the skeleton of earlier break_out_comdat_types
<span class="lineNum">    8389 </span>            :                type.  Clone the existing DIE, but keep the children
<span class="lineNum">    8390 </span>            :                under the original (which is in the main CU).  */
<span class="lineNum">    8391 </span><span class="lineCov">          9 :             dw_die_ref clone = clone_die (c);</span>
<span class="lineNum">    8392 </span>            : 
<span class="lineNum">    8393 </span><span class="lineCov">          9 :             replace_child (c, clone, prev);</span>
<span class="lineNum">    8394 </span><span class="lineCov">          9 :             generate_skeleton_ancestor_tree (parent);</span>
<span class="lineNum">    8395 </span><span class="lineCov">          9 :             add_child_die (parent-&gt;new_die, c);</span>
<span class="lineNum">    8396 </span><span class="lineCov">          9 :             c = clone;</span>
<span class="lineNum">    8397 </span><span class="lineCov">          9 :             continue;</span>
<span class="lineNum">    8398 </span>            :           }
<span class="lineNum">    8399 </span>            :         else
<span class="lineNum">    8400 </span>            :           {
<span class="lineNum">    8401 </span>            :             /* Clone the existing DIE, move the original to the skeleton
<span class="lineNum">    8402 </span>            :                tree (which is in the main CU), and put the clone, with
<span class="lineNum">    8403 </span>            :                all the original's children, where the original came from
<span class="lineNum">    8404 </span>            :                (which is about to be moved to the type unit).  */
<span class="lineNum">    8405 </span><span class="lineCov">         55 :             dw_die_ref clone = clone_die (c);</span>
<span class="lineNum">    8406 </span><span class="lineCov">         55 :             move_all_children (c, clone);</span>
<span class="lineNum">    8407 </span>            : 
<span class="lineNum">    8408 </span>            :             /* If the original has a DW_AT_object_pointer attribute,
<span class="lineNum">    8409 </span>            :                it would now point to a child DIE just moved to the
<span class="lineNum">    8410 </span>            :                cloned tree, so we need to remove that attribute from
<span class="lineNum">    8411 </span>            :                the original.  */
<span class="lineNum">    8412 </span><span class="lineCov">         55 :             remove_AT (c, DW_AT_object_pointer);</span>
<span class="lineNum">    8413 </span>            : 
<span class="lineNum">    8414 </span><span class="lineCov">         55 :             replace_child (c, clone, prev);</span>
<span class="lineNum">    8415 </span><span class="lineCov">         55 :             generate_skeleton_ancestor_tree (parent);</span>
<span class="lineNum">    8416 </span><span class="lineCov">         55 :             add_child_die (parent-&gt;new_die, c);</span>
<span class="lineNum">    8417 </span><span class="lineCov">         55 :             node.old_die = clone;</span>
<span class="lineNum">    8418 </span><span class="lineCov">         55 :             node.new_die = c;</span>
<span class="lineNum">    8419 </span><span class="lineCov">         55 :             c = clone;</span>
<span class="lineNum">    8420 </span>            :           }
<span class="lineNum">    8421 </span>            :       }
<span class="lineNum">    8422 </span><span class="lineCov">        200 :     generate_skeleton_bottom_up (&amp;node);</span>
<span class="lineNum">    8423 </span><span class="lineCov">        209 :   } while (next != NULL);</span>
<span class="lineNum">    8424 </span><span class="lineCov">        248 : }</span>
<span class="lineNum">    8425 </span>            : 
<span class="lineNum">    8426 </span>            : /* Wrapper function for generate_skeleton_bottom_up.  */
<a name="8427"><span class="lineNum">    8427 </span>            : </a>
<span class="lineNum">    8428 </span>            : static dw_die_ref
<span class="lineNum">    8429 </span><span class="lineCov">         48 : generate_skeleton (dw_die_ref die)</span>
<span class="lineNum">    8430 </span>            : {
<span class="lineNum">    8431 </span><span class="lineCov">         48 :   skeleton_chain_node node;</span>
<span class="lineNum">    8432 </span>            : 
<span class="lineNum">    8433 </span><span class="lineCov">         48 :   node.old_die = die;</span>
<span class="lineNum">    8434 </span><span class="lineCov">         48 :   node.new_die = NULL;</span>
<span class="lineNum">    8435 </span><span class="lineCov">         48 :   node.parent = NULL;</span>
<span class="lineNum">    8436 </span>            : 
<span class="lineNum">    8437 </span>            :   /* If this type definition is nested inside another type,
<span class="lineNum">    8438 </span>            :      and is not an instantiation of a template, always leave
<span class="lineNum">    8439 </span>            :      at least a declaration in its place.  */
<span class="lineNum">    8440 </span><span class="lineCov">         48 :   if (die-&gt;die_parent != NULL</span>
<span class="lineNum">    8441 </span><span class="lineCov">         48 :       &amp;&amp; is_type_die (die-&gt;die_parent)</span>
<span class="lineNum">    8442 </span><span class="lineCov">         57 :       &amp;&amp; !is_template_instantiation (die))</span>
<span class="lineNum">    8443 </span><span class="lineCov">          9 :     node.new_die = clone_as_declaration (die);</span>
<span class="lineNum">    8444 </span>            : 
<span class="lineNum">    8445 </span><span class="lineCov">         48 :   generate_skeleton_bottom_up (&amp;node);</span>
<span class="lineNum">    8446 </span><span class="lineCov">         48 :   return node.new_die;</span>
<span class="lineNum">    8447 </span>            : }
<span class="lineNum">    8448 </span>            : 
<span class="lineNum">    8449 </span>            : /* Remove the CHILD DIE from its parent, possibly replacing it with a cloned
<span class="lineNum">    8450 </span>            :    declaration.  The original DIE is moved to a new compile unit so that
<span class="lineNum">    8451 </span>            :    existing references to it follow it to the new location.  If any of the
<span class="lineNum">    8452 </span>            :    original DIE's descendants is a declaration, we need to replace the
<span class="lineNum">    8453 </span>            :    original DIE with a skeleton tree and move the declarations back into the
<span class="lineNum">    8454 </span>            :    skeleton tree.  */
<a name="8455"><span class="lineNum">    8455 </span>            : </a>
<span class="lineNum">    8456 </span>            : static dw_die_ref
<span class="lineNum">    8457 </span><span class="lineCov">         48 : remove_child_or_replace_with_skeleton (dw_die_ref unit, dw_die_ref child,</span>
<span class="lineNum">    8458 </span>            :                                        dw_die_ref prev)
<span class="lineNum">    8459 </span>            : {
<span class="lineNum">    8460 </span><span class="lineCov">         48 :   dw_die_ref skeleton, orig_parent;</span>
<span class="lineNum">    8461 </span>            : 
<span class="lineNum">    8462 </span>            :   /* Copy the declaration context to the type unit DIE.  If the returned
<span class="lineNum">    8463 </span>            :      ORIG_PARENT is not NULL, the skeleton needs to be added as a child of
<span class="lineNum">    8464 </span>            :      that DIE.  */
<span class="lineNum">    8465 </span><span class="lineCov">         48 :   orig_parent = copy_declaration_context (unit, child);</span>
<span class="lineNum">    8466 </span>            : 
<span class="lineNum">    8467 </span><span class="lineCov">         48 :   skeleton = generate_skeleton (child);</span>
<span class="lineNum">    8468 </span><span class="lineCov">         48 :   if (skeleton == NULL)</span>
<span class="lineNum">    8469 </span><span class="lineCov">         14 :     remove_child_with_prev (child, prev);</span>
<span class="lineNum">    8470 </span>            :   else
<span class="lineNum">    8471 </span>            :     {
<span class="lineNum">    8472 </span><span class="lineCov">         34 :       skeleton-&gt;comdat_type_p = true;</span>
<span class="lineNum">    8473 </span><span class="lineCov">         34 :       skeleton-&gt;die_id.die_type_node = child-&gt;die_id.die_type_node;</span>
<span class="lineNum">    8474 </span>            : 
<span class="lineNum">    8475 </span>            :       /* If the original DIE was a specification, we need to put
<span class="lineNum">    8476 </span>            :          the skeleton under the parent DIE of the declaration.
<span class="lineNum">    8477 </span>            :          This leaves the original declaration in the tree, but
<span class="lineNum">    8478 </span>            :          it will be pruned later since there are no longer any
<span class="lineNum">    8479 </span>            :          references to it.  */
<span class="lineNum">    8480 </span><span class="lineCov">         34 :       if (orig_parent != NULL)</span>
<span class="lineNum">    8481 </span>            :         {
<span class="lineNum">    8482 </span><span class="lineNoCov">          0 :           remove_child_with_prev (child, prev);</span>
<span class="lineNum">    8483 </span><span class="lineNoCov">          0 :           add_child_die (orig_parent, skeleton);</span>
<span class="lineNum">    8484 </span>            :         }
<span class="lineNum">    8485 </span>            :       else
<span class="lineNum">    8486 </span><span class="lineCov">         34 :         replace_child (child, skeleton, prev);</span>
<span class="lineNum">    8487 </span>            :     }
<span class="lineNum">    8488 </span>            : 
<span class="lineNum">    8489 </span><span class="lineCov">         48 :   return skeleton;</span>
<span class="lineNum">    8490 </span>            : }
<span class="lineNum">    8491 </span>            : 
<span class="lineNum">    8492 </span>            : static void
<span class="lineNum">    8493 </span>            : copy_dwarf_procs_ref_in_attrs (dw_die_ref die,
<span class="lineNum">    8494 </span>            :                                comdat_type_node *type_node,
<span class="lineNum">    8495 </span>            :                                hash_map&lt;dw_die_ref, dw_die_ref&gt; &amp;copied_dwarf_procs);
<span class="lineNum">    8496 </span>            : 
<span class="lineNum">    8497 </span>            : /* Helper for copy_dwarf_procs_ref_in_dies.  Make a copy of the DIE DWARF
<span class="lineNum">    8498 </span>            :    procedure, put it under TYPE_NODE and return the copy.  Continue looking for
<span class="lineNum">    8499 </span>            :    DWARF procedure references in the DW_AT_location attribute.  */
<a name="8500"><span class="lineNum">    8500 </span>            : </a>
<span class="lineNum">    8501 </span>            : static dw_die_ref
<span class="lineNum">    8502 </span><span class="lineNoCov">          0 : copy_dwarf_procedure (dw_die_ref die,</span>
<span class="lineNum">    8503 </span>            :                       comdat_type_node *type_node,
<span class="lineNum">    8504 </span>            :                       hash_map&lt;dw_die_ref, dw_die_ref&gt; &amp;copied_dwarf_procs)
<span class="lineNum">    8505 </span>            : {
<span class="lineNum">    8506 </span><span class="lineNoCov">          0 :   gcc_assert (die-&gt;die_tag == DW_TAG_dwarf_procedure);</span>
<span class="lineNum">    8507 </span>            : 
<span class="lineNum">    8508 </span>            :   /* DWARF procedures are not supposed to have children...  */
<span class="lineNum">    8509 </span><span class="lineNoCov">          0 :   gcc_assert (die-&gt;die_child == NULL);</span>
<span class="lineNum">    8510 </span>            : 
<span class="lineNum">    8511 </span>            :   /* ... and they are supposed to have only one attribute: DW_AT_location.  */
<span class="lineNum">    8512 </span><span class="lineNoCov">          0 :   gcc_assert (vec_safe_length (die-&gt;die_attr) == 1</span>
<span class="lineNum">    8513 </span>            :               &amp;&amp; ((*die-&gt;die_attr)[0].dw_attr == DW_AT_location));
<span class="lineNum">    8514 </span>            : 
<span class="lineNum">    8515 </span>            :   /* Do not copy more than once DWARF procedures.  */
<span class="lineNum">    8516 </span><span class="lineNoCov">          0 :   bool existed;</span>
<span class="lineNum">    8517 </span><span class="lineNoCov">          0 :   dw_die_ref &amp;die_copy = copied_dwarf_procs.get_or_insert (die, &amp;existed);</span>
<span class="lineNum">    8518 </span><span class="lineNoCov">          0 :   if (existed)</span>
<span class="lineNum">    8519 </span><span class="lineNoCov">          0 :     return die_copy;</span>
<span class="lineNum">    8520 </span>            : 
<span class="lineNum">    8521 </span><span class="lineNoCov">          0 :   die_copy = clone_die (die);</span>
<span class="lineNum">    8522 </span><span class="lineNoCov">          0 :   add_child_die (type_node-&gt;root_die, die_copy);</span>
<span class="lineNum">    8523 </span><span class="lineNoCov">          0 :   copy_dwarf_procs_ref_in_attrs (die_copy, type_node, copied_dwarf_procs);</span>
<span class="lineNum">    8524 </span><span class="lineNoCov">          0 :   return die_copy;</span>
<span class="lineNum">    8525 </span>            : }
<span class="lineNum">    8526 </span>            : 
<span class="lineNum">    8527 </span>            : /* Helper for copy_dwarf_procs_ref_in_dies.  Look for references to DWARF
<span class="lineNum">    8528 </span>            :    procedures in DIE's attributes.  */
<a name="8529"><span class="lineNum">    8529 </span>            : </a>
<span class="lineNum">    8530 </span>            : static void
<span class="lineNum">    8531 </span><span class="lineCov">        241 : copy_dwarf_procs_ref_in_attrs (dw_die_ref die,</span>
<span class="lineNum">    8532 </span>            :                                comdat_type_node *type_node,
<span class="lineNum">    8533 </span>            :                                hash_map&lt;dw_die_ref, dw_die_ref&gt; &amp;copied_dwarf_procs)
<span class="lineNum">    8534 </span>            : {
<span class="lineNum">    8535 </span><span class="lineCov">        241 :   dw_attr_node *a;</span>
<span class="lineNum">    8536 </span><span class="lineCov">        241 :   unsigned i;</span>
<span class="lineNum">    8537 </span>            : 
<span class="lineNum">    8538 </span><span class="lineCov">       1317 :   FOR_EACH_VEC_SAFE_ELT (die-&gt;die_attr, i, a)</span>
<span class="lineNum">    8539 </span>            :     {
<span class="lineNum">    8540 </span><span class="lineCov">       1076 :       dw_loc_descr_ref loc;</span>
<span class="lineNum">    8541 </span>            : 
<span class="lineNum">    8542 </span><span class="lineCov">       1076 :       if (a-&gt;dw_attr_val.val_class != dw_val_class_loc)</span>
<span class="lineNum">    8543 </span>            :         continue;
<span class="lineNum">    8544 </span>            : 
<span class="lineNum">    8545 </span><span class="lineNoCov">          0 :       for (loc = a-&gt;dw_attr_val.v.val_loc; loc != NULL; loc = loc-&gt;dw_loc_next)</span>
<span class="lineNum">    8546 </span>            :         {
<span class="lineNum">    8547 </span><span class="lineNoCov">          0 :           switch (loc-&gt;dw_loc_opc)</span>
<span class="lineNum">    8548 </span>            :             {
<span class="lineNum">    8549 </span><span class="lineNoCov">          0 :             case DW_OP_call2:</span>
<span class="lineNum">    8550 </span><span class="lineNoCov">          0 :             case DW_OP_call4:</span>
<span class="lineNum">    8551 </span><span class="lineNoCov">          0 :             case DW_OP_call_ref:</span>
<span class="lineNum">    8552 </span><span class="lineNoCov">          0 :               gcc_assert (loc-&gt;dw_loc_oprnd1.val_class</span>
<span class="lineNum">    8553 </span>            :                           == dw_val_class_die_ref);
<span class="lineNum">    8554 </span><span class="lineNoCov">          0 :               loc-&gt;dw_loc_oprnd1.v.val_die_ref.die</span>
<span class="lineNum">    8555 </span><span class="lineNoCov">          0 :                 = copy_dwarf_procedure (loc-&gt;dw_loc_oprnd1.v.val_die_ref.die,</span>
<span class="lineNum">    8556 </span>            :                                         type_node,
<span class="lineNum">    8557 </span>            :                                         copied_dwarf_procs);
<span class="lineNum">    8558 </span>            : 
<span class="lineNum">    8559 </span><span class="lineNoCov">          0 :             default:</span>
<span class="lineNum">    8560 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">    8561 </span>            :             }
<span class="lineNum">    8562 </span>            :         }
<span class="lineNum">    8563 </span>            :     }
<span class="lineNum">    8564 </span><span class="lineCov">        241 : }</span>
<span class="lineNum">    8565 </span>            : 
<span class="lineNum">    8566 </span>            : /* Copy DWARF procedures that are referenced by the DIE tree to TREE_NODE and
<span class="lineNum">    8567 </span>            :    rewrite references to point to the copies.
<span class="lineNum">    8568 </span>            : 
<span class="lineNum">    8569 </span>            :    References are looked for in DIE's attributes and recursively in all its
<span class="lineNum">    8570 </span>            :    children attributes that are location descriptions. COPIED_DWARF_PROCS is a
<span class="lineNum">    8571 </span>            :    mapping from old DWARF procedures to their copy. It is used not to copy
<span class="lineNum">    8572 </span>            :    twice the same DWARF procedure under TYPE_NODE.  */
<a name="8573"><span class="lineNum">    8573 </span>            : </a>
<span class="lineNum">    8574 </span>            : static void
<span class="lineNum">    8575 </span><span class="lineCov">        241 : copy_dwarf_procs_ref_in_dies (dw_die_ref die,</span>
<span class="lineNum">    8576 </span>            :                               comdat_type_node *type_node,
<span class="lineNum">    8577 </span>            :                               hash_map&lt;dw_die_ref, dw_die_ref&gt; &amp;copied_dwarf_procs)
<span class="lineNum">    8578 </span>            : {
<span class="lineNum">    8579 </span><span class="lineCov">        241 :   dw_die_ref c;</span>
<span class="lineNum">    8580 </span>            : 
<span class="lineNum">    8581 </span><span class="lineCov">        241 :   copy_dwarf_procs_ref_in_attrs (die, type_node, copied_dwarf_procs);</span>
<span class="lineNum">    8582 </span><span class="lineCov">        434 :   FOR_EACH_CHILD (die, c, copy_dwarf_procs_ref_in_dies (c,</span>
<span class="lineNum">    8583 </span>            :                                                         type_node,
<span class="lineNum">    8584 </span>            :                                                         copied_dwarf_procs));
<span class="lineNum">    8585 </span><span class="lineCov">        241 : }</span>
<span class="lineNum">    8586 </span>            : 
<span class="lineNum">    8587 </span>            : /* Traverse the DIE and set up additional .debug_types or .debug_info
<span class="lineNum">    8588 </span>            :    DW_UT_*type sections for each type worthy of being placed in a COMDAT
<span class="lineNum">    8589 </span>            :    section.  */
<a name="8590"><span class="lineNum">    8590 </span>            : </a>
<span class="lineNum">    8591 </span>            : static void
<span class="lineNum">    8592 </span><span class="lineCov">         93 : break_out_comdat_types (dw_die_ref die)</span>
<span class="lineNum">    8593 </span>            : {
<span class="lineNum">    8594 </span><span class="lineCov">         93 :   dw_die_ref c;</span>
<span class="lineNum">    8595 </span><span class="lineCov">         93 :   dw_die_ref first;</span>
<span class="lineNum">    8596 </span><span class="lineCov">         93 :   dw_die_ref prev = NULL;</span>
<span class="lineNum">    8597 </span><span class="lineCov">         93 :   dw_die_ref next = NULL;</span>
<span class="lineNum">    8598 </span><span class="lineCov">         93 :   dw_die_ref unit = NULL;</span>
<span class="lineNum">    8599 </span>            : 
<span class="lineNum">    8600 </span><span class="lineCov">         93 :   first = c = die-&gt;die_child;</span>
<span class="lineNum">    8601 </span><span class="lineCov">         93 :   if (c)</span>
<span class="lineNum">    8602 </span><span class="lineCov">         83 :     next = c-&gt;die_sib;</span>
<span class="lineNum">    8603 </span><span class="lineCov">         93 :   if (c) do {</span>
<span class="lineNum">    8604 </span><span class="lineCov">        477 :     if (prev == NULL || prev-&gt;die_sib == c)</span>
<span class="lineNum">    8605 </span><span class="lineCov">        463 :       prev = c;</span>
<span class="lineNum">    8606 </span><span class="lineCov">        477 :     c = next;</span>
<span class="lineNum">    8607 </span><span class="lineCov">        477 :     next = (c == first ? NULL : c-&gt;die_sib);</span>
<span class="lineNum">    8608 </span><span class="lineCov">        477 :     if (should_move_die_to_comdat (c))</span>
<span class="lineNum">    8609 </span>            :       {
<span class="lineNum">    8610 </span><span class="lineCov">         48 :         dw_die_ref replacement;</span>
<span class="lineNum">    8611 </span><span class="lineCov">         48 :         comdat_type_node *type_node;</span>
<span class="lineNum">    8612 </span>            : 
<span class="lineNum">    8613 </span>            :         /* Break out nested types into their own type units.  */
<span class="lineNum">    8614 </span><span class="lineCov">         48 :         break_out_comdat_types (c);</span>
<span class="lineNum">    8615 </span>            : 
<span class="lineNum">    8616 </span>            :         /* Create a new type unit DIE as the root for the new tree, and
<span class="lineNum">    8617 </span>            :            add it to the list of comdat types.  */
<span class="lineNum">    8618 </span><span class="lineCov">         48 :         unit = new_die (DW_TAG_type_unit, NULL, NULL);</span>
<span class="lineNum">    8619 </span><span class="lineCov">         48 :         add_AT_unsigned (unit, DW_AT_language,</span>
<span class="lineNum">    8620 </span><span class="lineCov">         48 :                          get_AT_unsigned (comp_unit_die (), DW_AT_language));</span>
<span class="lineNum">    8621 </span><span class="lineCov">         48 :         type_node = ggc_cleared_alloc&lt;comdat_type_node&gt; ();</span>
<span class="lineNum">    8622 </span><span class="lineCov">         48 :         type_node-&gt;root_die = unit;</span>
<span class="lineNum">    8623 </span><span class="lineCov">         48 :         type_node-&gt;next = comdat_type_list;</span>
<span class="lineNum">    8624 </span><span class="lineCov">         48 :         comdat_type_list = type_node;</span>
<span class="lineNum">    8625 </span>            : 
<span class="lineNum">    8626 </span>            :         /* Generate the type signature.  */
<span class="lineNum">    8627 </span><span class="lineCov">         48 :         generate_type_signature (c, type_node);</span>
<span class="lineNum">    8628 </span>            : 
<span class="lineNum">    8629 </span>            :         /* Copy the declaration context, attributes, and children of the
<span class="lineNum">    8630 </span>            :            declaration into the new type unit DIE, then remove this DIE
<span class="lineNum">    8631 </span>            :            from the main CU (or replace it with a skeleton if necessary).  */
<span class="lineNum">    8632 </span><span class="lineCov">         48 :         replacement = remove_child_or_replace_with_skeleton (unit, c, prev);</span>
<span class="lineNum">    8633 </span><span class="lineCov">         48 :         type_node-&gt;skeleton_die = replacement;</span>
<span class="lineNum">    8634 </span>            : 
<span class="lineNum">    8635 </span>            :         /* Add the DIE to the new compunit.  */
<span class="lineNum">    8636 </span><span class="lineCov">         48 :         add_child_die (unit, c);</span>
<span class="lineNum">    8637 </span>            : 
<span class="lineNum">    8638 </span>            :         /* Types can reference DWARF procedures for type size or data location
<span class="lineNum">    8639 </span>            :            expressions.  Calls in DWARF expressions cannot target procedures
<span class="lineNum">    8640 </span>            :            that are not in the same section.  So we must copy DWARF procedures
<span class="lineNum">    8641 </span>            :            along with this type and then rewrite references to them.  */
<span class="lineNum">    8642 </span><span class="lineCov">         96 :         hash_map&lt;dw_die_ref, dw_die_ref&gt; copied_dwarf_procs;</span>
<span class="lineNum">    8643 </span><span class="lineCov">         48 :         copy_dwarf_procs_ref_in_dies (c, type_node, copied_dwarf_procs);</span>
<span class="lineNum">    8644 </span>            : 
<span class="lineNum">    8645 </span><span class="lineCov">         48 :         if (replacement != NULL)</span>
<span class="lineNum">    8646 </span><span class="lineCov">         34 :           c = replacement;</span>
<span class="lineNum">    8647 </span>            :       }
<span class="lineNum">    8648 </span><span class="lineCov">        858 :     else if (c-&gt;die_tag == DW_TAG_namespace</span>
<span class="lineNum">    8649 </span><span class="lineCov">        429 :              || c-&gt;die_tag == DW_TAG_class_type</span>
<span class="lineNum">    8650 </span><span class="lineCov">        407 :              || c-&gt;die_tag == DW_TAG_structure_type</span>
<span class="lineNum">    8651 </span><span class="lineCov">        402 :              || c-&gt;die_tag == DW_TAG_union_type)</span>
<span class="lineNum">    8652 </span>            :       {
<span class="lineNum">    8653 </span>            :         /* Look for nested types that can be broken out.  */
<span class="lineNum">    8654 </span><span class="lineCov">         27 :         break_out_comdat_types (c);</span>
<span class="lineNum">    8655 </span>            :       }
<span class="lineNum">    8656 </span><span class="lineCov">        477 :   } while (next != NULL);</span>
<span class="lineNum">    8657 </span><span class="lineCov">         93 : }</span>
<span class="lineNum">    8658 </span>            : 
<span class="lineNum">    8659 </span>            : /* Like clone_tree, but copy DW_TAG_subprogram DIEs as declarations.
<span class="lineNum">    8660 </span>            :    Enter all the cloned children into the hash table decl_table.  */
<a name="8661"><span class="lineNum">    8661 </span>            : </a>
<span class="lineNum">    8662 </span>            : static dw_die_ref
<span class="lineNum">    8663 </span><span class="lineCov">          3 : clone_tree_partial (dw_die_ref die, decl_hash_type *decl_table)</span>
<span class="lineNum">    8664 </span>            : {
<span class="lineNum">    8665 </span><span class="lineCov">          3 :   dw_die_ref c;</span>
<span class="lineNum">    8666 </span><span class="lineCov">          3 :   dw_die_ref clone;</span>
<span class="lineNum">    8667 </span><span class="lineCov">          3 :   struct decl_table_entry *entry;</span>
<span class="lineNum">    8668 </span><span class="lineCov">          3 :   decl_table_entry **slot;</span>
<span class="lineNum">    8669 </span>            : 
<span class="lineNum">    8670 </span><span class="lineCov">          3 :   if (die-&gt;die_tag == DW_TAG_subprogram)</span>
<span class="lineNum">    8671 </span><span class="lineNoCov">          0 :     clone = clone_as_declaration (die);</span>
<span class="lineNum">    8672 </span>            :   else
<span class="lineNum">    8673 </span><span class="lineCov">          3 :     clone = clone_die (die);</span>
<span class="lineNum">    8674 </span>            : 
<span class="lineNum">    8675 </span><span class="lineCov">          3 :   slot = decl_table-&gt;find_slot_with_hash (die,</span>
<span class="lineNum">    8676 </span>            :                                           htab_hash_pointer (die), INSERT);
<span class="lineNum">    8677 </span>            : 
<span class="lineNum">    8678 </span>            :   /* Assert that DIE isn't in the hash table yet.  If it would be there
<span class="lineNum">    8679 </span>            :      before, the ancestors would be necessarily there as well, therefore
<span class="lineNum">    8680 </span>            :      clone_tree_partial wouldn't be called.  */
<span class="lineNum">    8681 </span><span class="lineCov">          3 :   gcc_assert (*slot == HTAB_EMPTY_ENTRY);</span>
<span class="lineNum">    8682 </span>            : 
<span class="lineNum">    8683 </span><span class="lineCov">          3 :   entry = XCNEW (struct decl_table_entry);</span>
<span class="lineNum">    8684 </span><span class="lineCov">          3 :   entry-&gt;orig = die;</span>
<span class="lineNum">    8685 </span><span class="lineCov">          3 :   entry-&gt;copy = clone;</span>
<span class="lineNum">    8686 </span><span class="lineCov">          3 :   *slot = entry;</span>
<span class="lineNum">    8687 </span>            : 
<span class="lineNum">    8688 </span><span class="lineCov">          3 :   if (die-&gt;die_tag != DW_TAG_subprogram)</span>
<span class="lineNum">    8689 </span><span class="lineCov">          3 :     FOR_EACH_CHILD (die, c,</span>
<span class="lineNum">    8690 </span>            :                     add_child_die (clone, clone_tree_partial (c, decl_table)));
<span class="lineNum">    8691 </span>            : 
<span class="lineNum">    8692 </span><span class="lineCov">          3 :   return clone;</span>
<span class="lineNum">    8693 </span>            : }
<span class="lineNum">    8694 </span>            : 
<span class="lineNum">    8695 </span>            : /* Walk the DIE and its children, looking for references to incomplete
<span class="lineNum">    8696 </span>            :    or trivial types that are unmarked (i.e., that are not in the current
<span class="lineNum">    8697 </span>            :    type_unit).  */
<a name="8698"><span class="lineNum">    8698 </span>            : </a>
<span class="lineNum">    8699 </span>            : static void
<span class="lineNum">    8700 </span><span class="lineCov">       1135 : copy_decls_walk (dw_die_ref unit, dw_die_ref die, decl_hash_type *decl_table)</span>
<span class="lineNum">    8701 </span>            : {
<span class="lineNum">    8702 </span><span class="lineCov">       1135 :   dw_die_ref c;</span>
<span class="lineNum">    8703 </span><span class="lineCov">       1135 :   dw_attr_node *a;</span>
<span class="lineNum">    8704 </span><span class="lineCov">       1135 :   unsigned ix;</span>
<span class="lineNum">    8705 </span>            : 
<span class="lineNum">    8706 </span><span class="lineCov">       4928 :   FOR_EACH_VEC_SAFE_ELT (die-&gt;die_attr, ix, a)</span>
<span class="lineNum">    8707 </span>            :     {
<span class="lineNum">    8708 </span><span class="lineCov">       3793 :       if (AT_class (a) == dw_val_class_die_ref)</span>
<span class="lineNum">    8709 </span>            :         {
<span class="lineNum">    8710 </span><span class="lineCov">       1820 :           dw_die_ref targ = AT_ref (a);</span>
<span class="lineNum">    8711 </span><span class="lineCov">        910 :           decl_table_entry **slot;</span>
<span class="lineNum">    8712 </span><span class="lineCov">        910 :           struct decl_table_entry *entry;</span>
<span class="lineNum">    8713 </span>            : 
<span class="lineNum">    8714 </span><span class="lineCov">        910 :           if (targ-&gt;die_mark != 0 || targ-&gt;comdat_type_p)</span>
<span class="lineNum">    8715 </span><span class="lineCov">        752 :             continue;</span>
<span class="lineNum">    8716 </span>            : 
<span class="lineNum">    8717 </span><span class="lineCov">        158 :           slot = decl_table-&gt;find_slot_with_hash (targ,</span>
<span class="lineNum">    8718 </span>            :                                                   htab_hash_pointer (targ),
<span class="lineNum">    8719 </span>            :                                                   INSERT);
<span class="lineNum">    8720 </span>            : 
<span class="lineNum">    8721 </span><span class="lineCov">        158 :           if (*slot != HTAB_EMPTY_ENTRY)</span>
<span class="lineNum">    8722 </span>            :             {
<span class="lineNum">    8723 </span>            :               /* TARG has already been copied, so we just need to
<span class="lineNum">    8724 </span>            :                  modify the reference to point to the copy.  */
<span class="lineNum">    8725 </span><span class="lineCov">         66 :               entry = *slot;</span>
<span class="lineNum">    8726 </span><span class="lineCov">         66 :               a-&gt;dw_attr_val.v.val_die_ref.die = entry-&gt;copy;</span>
<span class="lineNum">    8727 </span>            :             }
<span class="lineNum">    8728 </span>            :           else
<span class="lineNum">    8729 </span>            :             {
<span class="lineNum">    8730 </span><span class="lineCov">         92 :               dw_die_ref parent = unit;</span>
<span class="lineNum">    8731 </span><span class="lineCov">         92 :               dw_die_ref copy = clone_die (targ);</span>
<span class="lineNum">    8732 </span>            : 
<span class="lineNum">    8733 </span>            :               /* Record in DECL_TABLE that TARG has been copied.
<span class="lineNum">    8734 </span>            :                  Need to do this now, before the recursive call,
<span class="lineNum">    8735 </span>            :                  because DECL_TABLE may be expanded and SLOT
<span class="lineNum">    8736 </span>            :                  would no longer be a valid pointer.  */
<span class="lineNum">    8737 </span><span class="lineCov">         92 :               entry = XCNEW (struct decl_table_entry);</span>
<span class="lineNum">    8738 </span><span class="lineCov">         92 :               entry-&gt;orig = targ;</span>
<span class="lineNum">    8739 </span><span class="lineCov">         92 :               entry-&gt;copy = copy;</span>
<span class="lineNum">    8740 </span><span class="lineCov">         92 :               *slot = entry;</span>
<span class="lineNum">    8741 </span>            : 
<span class="lineNum">    8742 </span>            :               /* If TARG is not a declaration DIE, we need to copy its
<span class="lineNum">    8743 </span>            :                  children.  */
<span class="lineNum">    8744 </span><span class="lineCov">        184 :               if (!is_declaration_die (targ))</span>
<span class="lineNum">    8745 </span>            :                 {
<span class="lineNum">    8746 </span><span class="lineCov">         88 :                   FOR_EACH_CHILD (</span>
<span class="lineNum">    8747 </span>            :                       targ, c,
<span class="lineNum">    8748 </span>            :                       add_child_die (copy,
<span class="lineNum">    8749 </span>            :                                      clone_tree_partial (c, decl_table)));
<span class="lineNum">    8750 </span>            :                 }
<span class="lineNum">    8751 </span>            : 
<span class="lineNum">    8752 </span>            :               /* Make sure the cloned tree is marked as part of the
<span class="lineNum">    8753 </span>            :                  type unit.  */
<span class="lineNum">    8754 </span><span class="lineCov">         92 :               mark_dies (copy);</span>
<span class="lineNum">    8755 </span>            : 
<span class="lineNum">    8756 </span>            :               /* If TARG has surrounding context, copy its ancestor tree
<span class="lineNum">    8757 </span>            :                  into the new type unit.  */
<span class="lineNum">    8758 </span><span class="lineCov">         92 :               if (targ-&gt;die_parent != NULL</span>
<span class="lineNum">    8759 </span><span class="lineCov">         92 :                   &amp;&amp; !is_unit_die (targ-&gt;die_parent))</span>
<span class="lineNum">    8760 </span><span class="lineCov">          8 :                 parent = copy_ancestor_tree (unit, targ-&gt;die_parent,</span>
<span class="lineNum">    8761 </span>            :                                              decl_table);
<span class="lineNum">    8762 </span>            : 
<span class="lineNum">    8763 </span><span class="lineCov">         92 :               add_child_die (parent, copy);</span>
<span class="lineNum">    8764 </span><span class="lineCov">         92 :               a-&gt;dw_attr_val.v.val_die_ref.die = copy;</span>
<span class="lineNum">    8765 </span>            : 
<span class="lineNum">    8766 </span>            :               /* Make sure the newly-copied DIE is walked.  If it was
<span class="lineNum">    8767 </span>            :                  installed in a previously-added context, it won't
<span class="lineNum">    8768 </span>            :                  get visited otherwise.  */
<span class="lineNum">    8769 </span><span class="lineCov">         92 :               if (parent != unit)</span>
<span class="lineNum">    8770 </span>            :                 {
<span class="lineNum">    8771 </span>            :                   /* Find the highest point of the newly-added tree,
<span class="lineNum">    8772 </span>            :                      mark each node along the way, and walk from there.  */
<span class="lineNum">    8773 </span><span class="lineCov">          8 :                   parent-&gt;die_mark = 1;</span>
<span class="lineNum">    8774 </span><span class="lineCov">          8 :                   while (parent-&gt;die_parent</span>
<span class="lineNum">    8775 </span><span class="lineCov">          8 :                          &amp;&amp; parent-&gt;die_parent-&gt;die_mark == 0)</span>
<span class="lineNum">    8776 </span>            :                     {
<span class="lineNum">    8777 </span><span class="lineNoCov">          0 :                       parent = parent-&gt;die_parent;</span>
<span class="lineNum">    8778 </span><span class="lineNoCov">          0 :                       parent-&gt;die_mark = 1;</span>
<span class="lineNum">    8779 </span>            :                     }
<span class="lineNum">    8780 </span><span class="lineCov">          8 :                   copy_decls_walk (unit, parent, decl_table);</span>
<span class="lineNum">    8781 </span>            :                 }
<span class="lineNum">    8782 </span>            :             }
<span class="lineNum">    8783 </span>            :         }
<span class="lineNum">    8784 </span>            :     }
<span class="lineNum">    8785 </span>            : 
<span class="lineNum">    8786 </span><span class="lineCov">       1796 :   FOR_EACH_CHILD (die, c, copy_decls_walk (unit, c, decl_table));</span>
<span class="lineNum">    8787 </span><span class="lineCov">       1135 : }</span>
<span class="lineNum">    8788 </span>            : 
<span class="lineNum">    8789 </span>            : /* Copy declarations for &quot;unworthy&quot; types into the new comdat section.
<span class="lineNum">    8790 </span>            :    Incomplete types, modified types, and certain other types aren't broken
<span class="lineNum">    8791 </span>            :    out into comdat sections of their own, so they don't have a signature,
<span class="lineNum">    8792 </span>            :    and we need to copy the declaration into the same section so that we
<span class="lineNum">    8793 </span>            :    don't have an external reference.  */
<a name="8794"><span class="lineNum">    8794 </span>            : </a>
<span class="lineNum">    8795 </span>            : static void
<span class="lineNum">    8796 </span><span class="lineCov">         66 : copy_decls_for_unworthy_types (dw_die_ref unit)</span>
<span class="lineNum">    8797 </span>            : {
<span class="lineNum">    8798 </span><span class="lineCov">         66 :   mark_dies (unit);</span>
<span class="lineNum">    8799 </span><span class="lineCov">        132 :   decl_hash_type decl_table (10);</span>
<span class="lineNum">    8800 </span><span class="lineCov">         66 :   copy_decls_walk (unit, unit, &amp;decl_table);</span>
<span class="lineNum">    8801 </span><span class="lineCov">         66 :   unmark_dies (unit);</span>
<span class="lineNum">    8802 </span><span class="lineCov">         66 : }</span>
<span class="lineNum">    8803 </span>            : 
<span class="lineNum">    8804 </span>            : /* Traverse the DIE and add a sibling attribute if it may have the
<span class="lineNum">    8805 </span>            :    effect of speeding up access to siblings.  To save some space,
<span class="lineNum">    8806 </span>            :    avoid generating sibling attributes for DIE's without children.  */
<a name="8807"><span class="lineNum">    8807 </span>            : </a>
<span class="lineNum">    8808 </span>            : static void
<span class="lineNum">    8809 </span><span class="lineCov">   46334581 : add_sibling_attributes (dw_die_ref die)</span>
<span class="lineNum">    8810 </span>            : {
<span class="lineNum">    8811 </span><span class="lineCov">   46334581 :   dw_die_ref c;</span>
<span class="lineNum">    8812 </span>            : 
<span class="lineNum">    8813 </span><span class="lineCov">   46334581 :   if (! die-&gt;die_child)</span>
<span class="lineNum">    8814 </span>            :     return;
<span class="lineNum">    8815 </span>            : 
<span class="lineNum">    8816 </span><span class="lineCov">   11800055 :   if (die-&gt;die_parent &amp;&amp; die != die-&gt;die_parent-&gt;die_child)</span>
<span class="lineNum">    8817 </span><span class="lineCov">    8956780 :     add_AT_die_ref (die, DW_AT_sibling, die-&gt;die_sib);</span>
<span class="lineNum">    8818 </span>            : 
<span class="lineNum">    8819 </span><span class="lineCov">   46300038 :   FOR_EACH_CHILD (die, c, add_sibling_attributes (c));</span>
<span class="lineNum">    8820 </span>            : }
<span class="lineNum">    8821 </span>            : 
<span class="lineNum">    8822 </span>            : /* Output all location lists for the DIE and its children.  */
<a name="8823"><span class="lineNum">    8823 </span>            : </a>
<span class="lineNum">    8824 </span>            : static void
<span class="lineNum">    8825 </span><span class="lineCov">   41796677 : output_location_lists (dw_die_ref die)</span>
<span class="lineNum">    8826 </span>            : {
<span class="lineNum">    8827 </span><span class="lineCov">   41796677 :   dw_die_ref c;</span>
<span class="lineNum">    8828 </span><span class="lineCov">   41796677 :   dw_attr_node *a;</span>
<span class="lineNum">    8829 </span><span class="lineCov">   41796677 :   unsigned ix;</span>
<span class="lineNum">    8830 </span>            : 
<span class="lineNum">    8831 </span><span class="lineCov">  209124934 :   FOR_EACH_VEC_SAFE_ELT (die-&gt;die_attr, ix, a)</span>
<span class="lineNum">    8832 </span><span class="lineCov">  167328257 :     if (AT_class (a) == dw_val_class_loc_list)</span>
<span class="lineNum">    8833 </span><span class="lineCov">    5791298 :       output_loc_list (AT_loc_list (a));</span>
<span class="lineNum">    8834 </span>            : 
<span class="lineNum">    8835 </span><span class="lineCov">   83570641 :   FOR_EACH_CHILD (die, c, output_location_lists (c));</span>
<span class="lineNum">    8836 </span><span class="lineCov">   41796677 : }</span>
<span class="lineNum">    8837 </span>            : 
<span class="lineNum">    8838 </span>            : /* During assign_location_list_indexes and output_loclists_offset the
<span class="lineNum">    8839 </span>            :    current index, after it the number of assigned indexes (i.e. how
<span class="lineNum">    8840 </span>            :    large the .debug_loclists* offset table should be).  */
<span class="lineNum">    8841 </span>            : static unsigned int loc_list_idx;
<span class="lineNum">    8842 </span>            : 
<span class="lineNum">    8843 </span>            : /* Output all location list offsets for the DIE and its children.  */
<a name="8844"><span class="lineNum">    8844 </span>            : </a>
<span class="lineNum">    8845 </span>            : static void
<span class="lineNum">    8846 </span><span class="lineNoCov">          0 : output_loclists_offsets (dw_die_ref die)</span>
<span class="lineNum">    8847 </span>            : {
<span class="lineNum">    8848 </span><span class="lineNoCov">          0 :   dw_die_ref c;</span>
<span class="lineNum">    8849 </span><span class="lineNoCov">          0 :   dw_attr_node *a;</span>
<span class="lineNum">    8850 </span><span class="lineNoCov">          0 :   unsigned ix;</span>
<span class="lineNum">    8851 </span>            : 
<span class="lineNum">    8852 </span><span class="lineNoCov">          0 :   FOR_EACH_VEC_SAFE_ELT (die-&gt;die_attr, ix, a)</span>
<span class="lineNum">    8853 </span><span class="lineNoCov">          0 :     if (AT_class (a) == dw_val_class_loc_list)</span>
<span class="lineNum">    8854 </span>            :       {
<span class="lineNum">    8855 </span><span class="lineNoCov">          0 :         dw_loc_list_ref l = AT_loc_list (a);</span>
<span class="lineNum">    8856 </span><span class="lineNoCov">          0 :         if (l-&gt;offset_emitted)</span>
<span class="lineNum">    8857 </span>            :           continue;
<span class="lineNum">    8858 </span><span class="lineNoCov">          0 :         dw2_asm_output_delta (DWARF_OFFSET_SIZE, l-&gt;ll_symbol,</span>
<span class="lineNum">    8859 </span>            :                               loc_section_label, NULL);
<span class="lineNum">    8860 </span><span class="lineNoCov">          0 :         gcc_assert (l-&gt;hash == loc_list_idx);</span>
<span class="lineNum">    8861 </span><span class="lineNoCov">          0 :         loc_list_idx++;</span>
<span class="lineNum">    8862 </span><span class="lineNoCov">          0 :         l-&gt;offset_emitted = true;</span>
<span class="lineNum">    8863 </span>            :       }
<span class="lineNum">    8864 </span>            : 
<span class="lineNum">    8865 </span><span class="lineNoCov">          0 :   FOR_EACH_CHILD (die, c, output_loclists_offsets (c));</span>
<span class="lineNum">    8866 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    8867 </span>            : 
<span class="lineNum">    8868 </span>            : /* Recursively set indexes of location lists.  */
<a name="8869"><span class="lineNum">    8869 </span>            : </a>
<span class="lineNum">    8870 </span>            : static void
<span class="lineNum">    8871 </span><span class="lineNoCov">          0 : assign_location_list_indexes (dw_die_ref die)</span>
<span class="lineNum">    8872 </span>            : {
<span class="lineNum">    8873 </span><span class="lineNoCov">          0 :   dw_die_ref c;</span>
<span class="lineNum">    8874 </span><span class="lineNoCov">          0 :   dw_attr_node *a;</span>
<span class="lineNum">    8875 </span><span class="lineNoCov">          0 :   unsigned ix;</span>
<span class="lineNum">    8876 </span>            : 
<span class="lineNum">    8877 </span><span class="lineNoCov">          0 :   FOR_EACH_VEC_SAFE_ELT (die-&gt;die_attr, ix, a)</span>
<span class="lineNum">    8878 </span><span class="lineNoCov">          0 :     if (AT_class (a) == dw_val_class_loc_list)</span>
<span class="lineNum">    8879 </span>            :       {
<span class="lineNum">    8880 </span><span class="lineNoCov">          0 :         dw_loc_list_ref list = AT_loc_list (a);</span>
<span class="lineNum">    8881 </span><span class="lineNoCov">          0 :         if (!list-&gt;num_assigned)</span>
<span class="lineNum">    8882 </span>            :           {
<span class="lineNum">    8883 </span><span class="lineNoCov">          0 :             list-&gt;num_assigned = true;</span>
<span class="lineNum">    8884 </span><span class="lineNoCov">          0 :             list-&gt;hash = loc_list_idx++;</span>
<span class="lineNum">    8885 </span>            :           }
<span class="lineNum">    8886 </span>            :       }
<span class="lineNum">    8887 </span>            : 
<span class="lineNum">    8888 </span><span class="lineNoCov">          0 :   FOR_EACH_CHILD (die, c, assign_location_list_indexes (c));</span>
<span class="lineNum">    8889 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    8890 </span>            : 
<span class="lineNum">    8891 </span>            : /* We want to limit the number of external references, because they are
<span class="lineNum">    8892 </span>            :    larger than local references: a relocation takes multiple words, and
<span class="lineNum">    8893 </span>            :    even a sig8 reference is always eight bytes, whereas a local reference
<span class="lineNum">    8894 </span>            :    can be as small as one byte (though DW_FORM_ref is usually 4 in GCC).
<span class="lineNum">    8895 </span>            :    So if we encounter multiple external references to the same type DIE, we
<span class="lineNum">    8896 </span>            :    make a local typedef stub for it and redirect all references there.
<span class="lineNum">    8897 </span>            : 
<span class="lineNum">    8898 </span>            :    This is the element of the hash table for keeping track of these
<span class="lineNum">    8899 </span>            :    references.  */
<span class="lineNum">    8900 </span>            : 
<span class="lineNum">    8901 </span>            : struct external_ref
<span class="lineNum">    8902 </span>            : {
<span class="lineNum">    8903 </span>            :   dw_die_ref type;
<span class="lineNum">    8904 </span>            :   dw_die_ref stub;
<span class="lineNum">    8905 </span>            :   unsigned n_refs;
<span class="lineNum">    8906 </span>            : };
<span class="lineNum">    8907 </span>            : 
<span class="lineNum">    8908 </span>            : /* Hashtable helpers.  */
<span class="lineNum">    8909 </span>            : 
<span class="lineNum">    8910 </span>            : struct external_ref_hasher : free_ptr_hash &lt;external_ref&gt;
<span class="lineNum">    8911 </span>            : {
<span class="lineNum">    8912 </span>            :   static inline hashval_t hash (const external_ref *);
<span class="lineNum">    8913 </span>            :   static inline bool equal (const external_ref *, const external_ref *);
<span class="lineNum">    8914 </span>            : };
<a name="8915"><span class="lineNum">    8915 </span>            : </a>
<span class="lineNum">    8916 </span>            : inline hashval_t
<span class="lineNum">    8917 </span><span class="lineNoCov">          0 : external_ref_hasher::hash (const external_ref *r)</span>
<span class="lineNum">    8918 </span>            : {
<span class="lineNum">    8919 </span><span class="lineCov">      54116 :   dw_die_ref die = r-&gt;type;</span>
<span class="lineNum">    8920 </span><span class="lineCov">      54116 :   hashval_t h = 0;</span>
<span class="lineNum">    8921 </span>            : 
<span class="lineNum">    8922 </span>            :   /* We can't use the address of the DIE for hashing, because
<span class="lineNum">    8923 </span>            :      that will make the order of the stub DIEs non-deterministic.  */
<span class="lineNum">    8924 </span><span class="lineCov">      54116 :   if (! die-&gt;comdat_type_p)</span>
<span class="lineNum">    8925 </span>            :     /* We have a symbol; use it to compute a hash.  */
<span class="lineNum">    8926 </span><span class="lineCov">      53801 :     h = htab_hash_string (die-&gt;die_id.die_symbol);</span>
<span class="lineNum">    8927 </span>            :   else
<span class="lineNum">    8928 </span>            :     {
<span class="lineNum">    8929 </span>            :       /* We have a type signature; use a subset of the bits as the hash.
<span class="lineNum">    8930 </span>            :          The 8-byte signature is at least as large as hashval_t.  */
<span class="lineNum">    8931 </span><span class="lineCov">        315 :       comdat_type_node *type_node = die-&gt;die_id.die_type_node;</span>
<span class="lineNum">    8932 </span><span class="lineCov">        315 :       memcpy (&amp;h, type_node-&gt;signature, sizeof (h));</span>
<span class="lineNum">    8933 </span>            :     }
<span class="lineNum">    8934 </span><span class="lineCov">      54116 :   return h;</span>
<span class="lineNum">    8935 </span>            : }
<a name="8936"><span class="lineNum">    8936 </span>            : </a>
<span class="lineNum">    8937 </span>            : inline bool
<span class="lineNum">    8938 </span><span class="lineNoCov">          0 : external_ref_hasher::equal (const external_ref *r1, const external_ref *r2)</span>
<span class="lineNum">    8939 </span>            : {
<span class="lineNum">    8940 </span><span class="lineCov">   15667794 :   return r1-&gt;type == r2-&gt;type;</span>
<span class="lineNum">    8941 </span>            : }
<span class="lineNum">    8942 </span>            : 
<span class="lineNum">    8943 </span>            : typedef hash_table&lt;external_ref_hasher&gt; external_ref_hash_type;
<span class="lineNum">    8944 </span>            : 
<span class="lineNum">    8945 </span>            : /* Return a pointer to the external_ref for references to DIE.  */
<a name="8946"><span class="lineNum">    8946 </span>            : </a>
<span class="lineNum">    8947 </span>            : static struct external_ref *
<span class="lineNum">    8948 </span><span class="lineCov">      26431 : lookup_external_ref (external_ref_hash_type *map, dw_die_ref die)</span>
<span class="lineNum">    8949 </span>            : {
<span class="lineNum">    8950 </span><span class="lineCov">      26431 :   struct external_ref ref, *ref_p;</span>
<span class="lineNum">    8951 </span><span class="lineCov">      26431 :   external_ref **slot;</span>
<span class="lineNum">    8952 </span>            : 
<span class="lineNum">    8953 </span><span class="lineCov">      26431 :   ref.type = die;</span>
<span class="lineNum">    8954 </span><span class="lineCov">      26431 :   slot = map-&gt;find_slot (&amp;ref, INSERT);</span>
<span class="lineNum">    8955 </span><span class="lineCov">      26431 :   if (*slot != HTAB_EMPTY_ENTRY)</span>
<span class="lineNum">    8956 </span>            :     return *slot;
<span class="lineNum">    8957 </span>            : 
<span class="lineNum">    8958 </span><span class="lineCov">      23767 :   ref_p = XCNEW (struct external_ref);</span>
<span class="lineNum">    8959 </span><span class="lineCov">      23767 :   ref_p-&gt;type = die;</span>
<span class="lineNum">    8960 </span><span class="lineCov">      23767 :   *slot = ref_p;</span>
<span class="lineNum">    8961 </span><span class="lineCov">      23767 :   return ref_p;</span>
<span class="lineNum">    8962 </span>            : }
<span class="lineNum">    8963 </span>            : 
<span class="lineNum">    8964 </span>            : /* Subroutine of optimize_external_refs, below.
<span class="lineNum">    8965 </span>            : 
<span class="lineNum">    8966 </span>            :    If we see a type skeleton, record it as our stub.  If we see external
<span class="lineNum">    8967 </span>            :    references, remember how many we've seen.  */
<a name="8968"><span class="lineNum">    8968 </span>            : </a>
<span class="lineNum">    8969 </span>            : static void
<span class="lineNum">    8970 </span><span class="lineCov">   46334196 : optimize_external_refs_1 (dw_die_ref die, external_ref_hash_type *map)</span>
<span class="lineNum">    8971 </span>            : {
<span class="lineNum">    8972 </span><span class="lineCov">   46334196 :   dw_die_ref c;</span>
<span class="lineNum">    8973 </span><span class="lineCov">   46334196 :   dw_attr_node *a;</span>
<span class="lineNum">    8974 </span><span class="lineCov">   46334196 :   unsigned ix;</span>
<span class="lineNum">    8975 </span><span class="lineCov">   46334196 :   struct external_ref *ref_p;</span>
<span class="lineNum">    8976 </span>            : 
<span class="lineNum">    8977 </span><span class="lineCov">   46334196 :   if (is_type_die (die)</span>
<span class="lineNum">    8978 </span><span class="lineCov">   46334196 :       &amp;&amp; (c = get_AT_ref (die, DW_AT_signature)))</span>
<span class="lineNum">    8979 </span>            :     {
<span class="lineNum">    8980 </span>            :       /* This is a local skeleton; use it for local references.  */
<span class="lineNum">    8981 </span><span class="lineCov">         36 :       ref_p = lookup_external_ref (map, c);</span>
<span class="lineNum">    8982 </span><span class="lineCov">         36 :       ref_p-&gt;stub = die;</span>
<span class="lineNum">    8983 </span>            :     }
<span class="lineNum">    8984 </span>            : 
<span class="lineNum">    8985 </span>            :   /* Scan the DIE references, and remember any that refer to DIEs from
<span class="lineNum">    8986 </span>            :      other CUs (i.e. those which are not marked).  */
<span class="lineNum">    8987 </span><span class="lineCov">  233236564 :   FOR_EACH_VEC_SAFE_ELT (die-&gt;die_attr, ix, a)</span>
<span class="lineNum">    8988 </span><span class="lineCov">  186902368 :     if (AT_class (a) == dw_val_class_die_ref</span>
<span class="lineNum">    8989 </span><span class="lineCov">   52191095 :         &amp;&amp; (c = AT_ref (a))-&gt;die_mark == 0</span>
<span class="lineNum">    8990 </span><span class="lineCov">  186928619 :         &amp;&amp; is_type_die (c))</span>
<span class="lineNum">    8991 </span>            :       {
<span class="lineNum">    8992 </span><span class="lineCov">        135 :         ref_p = lookup_external_ref (map, c);</span>
<span class="lineNum">    8993 </span><span class="lineCov">        135 :         ref_p-&gt;n_refs++;</span>
<span class="lineNum">    8994 </span>            :       }
<span class="lineNum">    8995 </span>            : 
<span class="lineNum">    8996 </span><span class="lineCov">   80834179 :   FOR_EACH_CHILD (die, c, optimize_external_refs_1 (c, map));</span>
<span class="lineNum">    8997 </span><span class="lineCov">   46334196 : }</span>
<span class="lineNum">    8998 </span>            : 
<span class="lineNum">    8999 </span>            : /* htab_traverse callback function for optimize_external_refs, below.  SLOT
<span class="lineNum">    9000 </span>            :    points to an external_ref, DATA is the CU we're processing.  If we don't
<span class="lineNum">    9001 </span>            :    already have a local stub, and we have multiple refs, build a stub.  */
<a name="9002"><span class="lineNum">    9002 </span>            : </a>
<span class="lineNum">    9003 </span>            : int
<span class="lineNum">    9004 </span><span class="lineCov">         54 : dwarf2_build_local_stub (external_ref **slot, dw_die_ref data)</span>
<span class="lineNum">    9005 </span>            : {
<span class="lineNum">    9006 </span><span class="lineCov">         54 :   struct external_ref *ref_p = *slot;</span>
<span class="lineNum">    9007 </span>            : 
<span class="lineNum">    9008 </span><span class="lineCov">         54 :   if (ref_p-&gt;stub == NULL &amp;&amp; ref_p-&gt;n_refs &gt; 1 &amp;&amp; !dwarf_strict)</span>
<span class="lineNum">    9009 </span>            :     {
<span class="lineNum">    9010 </span>            :       /* We have multiple references to this type, so build a small stub.
<span class="lineNum">    9011 </span>            :          Both of these forms are a bit dodgy from the perspective of the
<span class="lineNum">    9012 </span>            :          DWARF standard, since technically they should have names.  */
<span class="lineNum">    9013 </span><span class="lineCov">          9 :       dw_die_ref cu = data;</span>
<span class="lineNum">    9014 </span><span class="lineCov">          9 :       dw_die_ref type = ref_p-&gt;type;</span>
<span class="lineNum">    9015 </span><span class="lineCov">          9 :       dw_die_ref stub = NULL;</span>
<span class="lineNum">    9016 </span>            : 
<span class="lineNum">    9017 </span><span class="lineCov">          9 :       if (type-&gt;comdat_type_p)</span>
<span class="lineNum">    9018 </span>            :         {
<span class="lineNum">    9019 </span>            :           /* If we refer to this type via sig8, use AT_signature.  */
<span class="lineNum">    9020 </span><span class="lineCov">          9 :           stub = new_die (type-&gt;die_tag, cu, NULL_TREE);</span>
<span class="lineNum">    9021 </span><span class="lineCov">          9 :           add_AT_die_ref (stub, DW_AT_signature, type);</span>
<span class="lineNum">    9022 </span>            :         }
<span class="lineNum">    9023 </span>            :       else
<span class="lineNum">    9024 </span>            :         {
<span class="lineNum">    9025 </span>            :           /* Otherwise, use a typedef with no name.  */
<span class="lineNum">    9026 </span><span class="lineNoCov">          0 :           stub = new_die (DW_TAG_typedef, cu, NULL_TREE);</span>
<span class="lineNum">    9027 </span><span class="lineNoCov">          0 :           add_AT_die_ref (stub, DW_AT_type, type);</span>
<span class="lineNum">    9028 </span>            :         }
<span class="lineNum">    9029 </span>            : 
<span class="lineNum">    9030 </span><span class="lineCov">          9 :       stub-&gt;die_mark++;</span>
<span class="lineNum">    9031 </span><span class="lineCov">          9 :       ref_p-&gt;stub = stub;</span>
<span class="lineNum">    9032 </span>            :     }
<span class="lineNum">    9033 </span><span class="lineCov">         54 :   return 1;</span>
<span class="lineNum">    9034 </span>            : }
<span class="lineNum">    9035 </span>            : 
<span class="lineNum">    9036 </span>            : /* DIE is a unit; look through all the DIE references to see if there are
<span class="lineNum">    9037 </span>            :    any external references to types, and if so, create local stubs for
<span class="lineNum">    9038 </span>            :    them which will be applied in build_abbrev_table.  This is useful because
<span class="lineNum">    9039 </span>            :    references to local DIEs are smaller.  */
<a name="9040"><span class="lineNum">    9040 </span>            : </a>
<span class="lineNum">    9041 </span>            : static external_ref_hash_type *
<span class="lineNum">    9042 </span><span class="lineCov">      34158 : optimize_external_refs (dw_die_ref die)</span>
<span class="lineNum">    9043 </span>            : {
<span class="lineNum">    9044 </span><span class="lineCov">      34158 :   external_ref_hash_type *map = new external_ref_hash_type (10);</span>
<span class="lineNum">    9045 </span><span class="lineCov">      34158 :   optimize_external_refs_1 (die, map);</span>
<span class="lineNum">    9046 </span><span class="lineCov">      34158 :   map-&gt;traverse &lt;dw_die_ref, dwarf2_build_local_stub&gt; (die);</span>
<span class="lineNum">    9047 </span><span class="lineCov">      34158 :   return map;</span>
<span class="lineNum">    9048 </span>            : }
<span class="lineNum">    9049 </span>            : 
<span class="lineNum">    9050 </span>            : /* The following 3 variables are temporaries that are computed only during the
<span class="lineNum">    9051 </span>            :    build_abbrev_table call and used and released during the following
<span class="lineNum">    9052 </span>            :    optimize_abbrev_table call.  */
<span class="lineNum">    9053 </span>            : 
<span class="lineNum">    9054 </span>            : /* First abbrev_id that can be optimized based on usage.  */
<span class="lineNum">    9055 </span>            : static unsigned int abbrev_opt_start;
<span class="lineNum">    9056 </span>            : 
<span class="lineNum">    9057 </span>            : /* Maximum abbrev_id of a base type plus one (we can't optimize DIEs with
<span class="lineNum">    9058 </span>            :    abbrev_id smaller than this, because they must be already sized
<span class="lineNum">    9059 </span>            :    during build_abbrev_table).  */
<span class="lineNum">    9060 </span>            : static unsigned int abbrev_opt_base_type_end;
<span class="lineNum">    9061 </span>            : 
<span class="lineNum">    9062 </span>            : /* Vector of usage counts during build_abbrev_table.  Indexed by
<span class="lineNum">    9063 </span>            :    abbrev_id - abbrev_opt_start.  */
<span class="lineNum">    9064 </span>            : static vec&lt;unsigned int&gt; abbrev_usage_count;
<span class="lineNum">    9065 </span>            : 
<span class="lineNum">    9066 </span>            : /* Vector of all DIEs added with die_abbrev &gt;= abbrev_opt_start.  */
<span class="lineNum">    9067 </span>            : static vec&lt;dw_die_ref&gt; sorted_abbrev_dies;
<span class="lineNum">    9068 </span>            : 
<span class="lineNum">    9069 </span>            : /* The format of each DIE (and its attribute value pairs) is encoded in an
<span class="lineNum">    9070 </span>            :    abbreviation table.  This routine builds the abbreviation table and assigns
<span class="lineNum">    9071 </span>            :    a unique abbreviation id for each abbreviation entry.  The children of each
<span class="lineNum">    9072 </span>            :    die are visited recursively.  */
<a name="9073"><span class="lineNum">    9073 </span>            : </a>
<span class="lineNum">    9074 </span>            : static void
<span class="lineNum">    9075 </span><span class="lineCov">   46334205 : build_abbrev_table (dw_die_ref die, external_ref_hash_type *extern_map)</span>
<span class="lineNum">    9076 </span>            : {
<span class="lineNum">    9077 </span><span class="lineCov">   46334205 :   unsigned int abbrev_id = 0;</span>
<span class="lineNum">    9078 </span><span class="lineCov">   46334205 :   dw_die_ref c;</span>
<span class="lineNum">    9079 </span><span class="lineCov">   46334205 :   dw_attr_node *a;</span>
<span class="lineNum">    9080 </span><span class="lineCov">   46334205 :   unsigned ix;</span>
<span class="lineNum">    9081 </span><span class="lineCov">   46334205 :   dw_die_ref abbrev;</span>
<span class="lineNum">    9082 </span>            : 
<span class="lineNum">    9083 </span>            :   /* Scan the DIE references, and replace any that refer to
<span class="lineNum">    9084 </span>            :      DIEs from other CUs (i.e. those which are not marked) with
<span class="lineNum">    9085 </span>            :      the local stubs we built in optimize_external_refs.  */
<span class="lineNum">    9086 </span><span class="lineCov">  233236582 :   FOR_EACH_VEC_SAFE_ELT (die-&gt;die_attr, ix, a)</span>
<span class="lineNum">    9087 </span><span class="lineCov">  186902377 :     if (AT_class (a) == dw_val_class_die_ref</span>
<span class="lineNum">    9088 </span><span class="lineCov">  186902377 :         &amp;&amp; (c = AT_ref (a))-&gt;die_mark == 0)</span>
<span class="lineNum">    9089 </span>            :       {
<span class="lineNum">    9090 </span><span class="lineCov">      26260 :         struct external_ref *ref_p;</span>
<span class="lineNum">    9091 </span><span class="lineCov">      26260 :         gcc_assert (AT_ref (a)-&gt;comdat_type_p || AT_ref (a)-&gt;die_id.die_symbol);</span>
<span class="lineNum">    9092 </span>            : 
<span class="lineNum">    9093 </span><span class="lineCov">      26260 :         ref_p = lookup_external_ref (extern_map, c);</span>
<span class="lineNum">    9094 </span><span class="lineCov">      26260 :         if (ref_p-&gt;stub &amp;&amp; ref_p-&gt;stub != die)</span>
<span class="lineNum">    9095 </span><span class="lineCov">         90 :           change_AT_die_ref (a, ref_p-&gt;stub);</span>
<span class="lineNum">    9096 </span>            :         else
<span class="lineNum">    9097 </span>            :           /* We aren't changing this reference, so mark it external.  */
<span class="lineNum">    9098 </span><span class="lineCov">      26170 :           set_AT_ref_external (a, 1);</span>
<span class="lineNum">    9099 </span>            :       }
<span class="lineNum">    9100 </span>            : 
<span class="lineNum">    9101 </span><span class="lineCov"> 4835120487 :   FOR_EACH_VEC_SAFE_ELT (abbrev_die_table, abbrev_id, abbrev)</span>
<span class="lineNum">    9102 </span>            :     {
<span class="lineNum">    9103 </span><span class="lineCov"> 4833018422 :       dw_attr_node *die_a, *abbrev_a;</span>
<span class="lineNum">    9104 </span><span class="lineCov"> 4833018422 :       unsigned ix;</span>
<span class="lineNum">    9105 </span><span class="lineCov"> 4833018422 :       bool ok = true;</span>
<span class="lineNum">    9106 </span>            : 
<span class="lineNum">    9107 </span><span class="lineCov"> 4833018422 :       if (abbrev_id == 0)</span>
<span class="lineNum">    9108 </span>            :         continue;
<span class="lineNum">    9109 </span><span class="lineCov"> 4786684217 :       if (abbrev-&gt;die_tag != die-&gt;die_tag)</span>
<span class="lineNum">    9110 </span>            :         continue;
<span class="lineNum">    9111 </span><span class="lineCov">  357401997 :       if ((abbrev-&gt;die_child != NULL) != (die-&gt;die_child != NULL))</span>
<span class="lineNum">    9112 </span>            :         continue;
<span class="lineNum">    9113 </span>            : 
<span class="lineNum">    9114 </span><span class="lineCov">  986090555 :       if (vec_safe_length (abbrev-&gt;die_attr) != vec_safe_length (die-&gt;die_attr))</span>
<span class="lineNum">    9115 </span>            :         continue;
<span class="lineNum">    9116 </span>            : 
<span class="lineNum">    9117 </span><span class="lineCov">  334620164 :       FOR_EACH_VEC_SAFE_ELT (die-&gt;die_attr, ix, die_a)</span>
<span class="lineNum">    9118 </span>            :         {
<span class="lineNum">    9119 </span><span class="lineCov">  290388024 :           abbrev_a = &amp;(*abbrev-&gt;die_attr)[ix];</span>
<span class="lineNum">    9120 </span><span class="lineCov">  290388024 :           if ((abbrev_a-&gt;dw_attr != die_a-&gt;dw_attr)</span>
<span class="lineNum">    9121 </span><span class="lineCov">  290388024 :               || (value_format (abbrev_a) != value_format (die_a)))</span>
<span class="lineNum">    9122 </span>            :             {
<span class="lineNum">    9123 </span>            :               ok = false;
<span class="lineNum">    9124 </span>            :               break;
<span class="lineNum">    9125 </span>            :             }
<span class="lineNum">    9126 </span>            :         }
<span class="lineNum">    9127 </span><span class="lineCov">   79942790 :       if (ok)</span>
<span class="lineNum">    9128 </span>            :         break;
<span class="lineNum">    9129 </span>            :     }
<span class="lineNum">    9130 </span>            : 
<span class="lineNum">    9131 </span><span class="lineCov">   92668410 :   if (abbrev_id &gt;= vec_safe_length (abbrev_die_table))</span>
<span class="lineNum">    9132 </span>            :     {
<span class="lineNum">    9133 </span><span class="lineCov">    2102065 :       vec_safe_push (abbrev_die_table, die);</span>
<span class="lineNum">    9134 </span><span class="lineCov">    2102065 :       if (abbrev_opt_start)</span>
<span class="lineNum">    9135 </span><span class="lineCov">    2101834 :         abbrev_usage_count.safe_push (0);</span>
<span class="lineNum">    9136 </span>            :     }
<span class="lineNum">    9137 </span><span class="lineCov">   46334205 :   if (abbrev_opt_start &amp;&amp; abbrev_id &gt;= abbrev_opt_start)</span>
<span class="lineNum">    9138 </span>            :     {
<span class="lineNum">    9139 </span><span class="lineCov">   46311116 :       abbrev_usage_count[abbrev_id - abbrev_opt_start]++;</span>
<span class="lineNum">    9140 </span><span class="lineCov">   46311116 :       sorted_abbrev_dies.safe_push (die);</span>
<span class="lineNum">    9141 </span>            :     }
<span class="lineNum">    9142 </span>            : 
<span class="lineNum">    9143 </span><span class="lineCov">   46334205 :   die-&gt;die_abbrev = abbrev_id;</span>
<span class="lineNum">    9144 </span><span class="lineCov">   80834197 :   FOR_EACH_CHILD (die, c, build_abbrev_table (c, extern_map));</span>
<span class="lineNum">    9145 </span><span class="lineCov">   46334205 : }</span>
<span class="lineNum">    9146 </span>            : 
<span class="lineNum">    9147 </span>            : /* Callback function for sorted_abbrev_dies vector sorting.  We sort
<span class="lineNum">    9148 </span>            :    by die_abbrev's usage count, from the most commonly used
<span class="lineNum">    9149 </span>            :    abbreviation to the least.  */
<a name="9150"><span class="lineNum">    9150 </span>            : </a>
<span class="lineNum">    9151 </span>            : static int
<span class="lineNum">    9152 </span><span class="lineCov"> 2518617781 : die_abbrev_cmp (const void *p1, const void *p2)</span>
<span class="lineNum">    9153 </span>            : {
<span class="lineNum">    9154 </span><span class="lineCov"> 2518617781 :   dw_die_ref die1 = *(const dw_die_ref *) p1;</span>
<span class="lineNum">    9155 </span><span class="lineCov"> 2518617781 :   dw_die_ref die2 = *(const dw_die_ref *) p2;</span>
<span class="lineNum">    9156 </span>            : 
<span class="lineNum">    9157 </span><span class="lineCov"> 2518617781 :   gcc_checking_assert (die1-&gt;die_abbrev &gt;= abbrev_opt_start);</span>
<span class="lineNum">    9158 </span><span class="lineCov"> 2518617781 :   gcc_checking_assert (die2-&gt;die_abbrev &gt;= abbrev_opt_start);</span>
<span class="lineNum">    9159 </span>            : 
<span class="lineNum">    9160 </span><span class="lineCov"> 2518617781 :   if (die1-&gt;die_abbrev &gt;= abbrev_opt_base_type_end</span>
<span class="lineNum">    9161 </span><span class="lineCov"> 2518617781 :       &amp;&amp; die2-&gt;die_abbrev &gt;= abbrev_opt_base_type_end)</span>
<span class="lineNum">    9162 </span>            :     {
<span class="lineNum">    9163 </span><span class="lineCov"> 2518617781 :       if (abbrev_usage_count[die1-&gt;die_abbrev - abbrev_opt_start]</span>
<span class="lineNum">    9164 </span><span class="lineCov"> 2518617781 :           &gt; abbrev_usage_count[die2-&gt;die_abbrev - abbrev_opt_start])</span>
<span class="lineNum">    9165 </span>            :         return -1;
<span class="lineNum">    9166 </span><span class="lineCov"> 1454004988 :       if (abbrev_usage_count[die1-&gt;die_abbrev - abbrev_opt_start]</span>
<span class="lineNum">    9167 </span><span class="lineCov"> 2908009976 :           &lt; abbrev_usage_count[die2-&gt;die_abbrev - abbrev_opt_start])</span>
<span class="lineNum">    9168 </span>            :         return 1;
<span class="lineNum">    9169 </span>            :     }
<span class="lineNum">    9170 </span>            : 
<span class="lineNum">    9171 </span>            :   /* Stabilize the sort.  */
<span class="lineNum">    9172 </span><span class="lineCov">  566225256 :   if (die1-&gt;die_abbrev &lt; die2-&gt;die_abbrev)</span>
<span class="lineNum">    9173 </span>            :     return -1;
<span class="lineNum">    9174 </span><span class="lineCov">  461466354 :   if (die1-&gt;die_abbrev &gt; die2-&gt;die_abbrev)</span>
<span class="lineNum">    9175 </span><span class="lineCov">  107941591 :     return 1;</span>
<span class="lineNum">    9176 </span>            : 
<span class="lineNum">    9177 </span>            :   return 0;
<span class="lineNum">    9178 </span>            : }
<span class="lineNum">    9179 </span>            : 
<span class="lineNum">    9180 </span>            : /* Convert dw_val_class_const and dw_val_class_unsigned_const class attributes
<span class="lineNum">    9181 </span>            :    of DIEs in between sorted_abbrev_dies[first_id] and abbrev_dies[end_id - 1]
<span class="lineNum">    9182 </span>            :    into dw_val_class_const_implicit or
<span class="lineNum">    9183 </span>            :    dw_val_class_unsigned_const_implicit.  */
<a name="9184"><span class="lineNum">    9184 </span>            : </a>
<span class="lineNum">    9185 </span>            : static void
<span class="lineNum">    9186 </span><span class="lineCov">        154 : optimize_implicit_const (unsigned int first_id, unsigned int end,</span>
<span class="lineNum">    9187 </span>            :                          vec&lt;bool&gt; &amp;implicit_consts)
<span class="lineNum">    9188 </span>            : {
<span class="lineNum">    9189 </span>            :   /* It never makes sense if there is just one DIE using the abbreviation.  */
<span class="lineNum">    9190 </span><span class="lineCov">        154 :   if (end &lt; first_id + 2)</span>
<span class="lineNum">    9191 </span>            :     return;
<span class="lineNum">    9192 </span>            : 
<span class="lineNum">    9193 </span><span class="lineCov">         45 :   dw_attr_node *a;</span>
<span class="lineNum">    9194 </span><span class="lineCov">         45 :   unsigned ix, i;</span>
<span class="lineNum">    9195 </span><span class="lineCov">         45 :   dw_die_ref die = sorted_abbrev_dies[first_id];</span>
<span class="lineNum">    9196 </span><span class="lineCov">        243 :   FOR_EACH_VEC_SAFE_ELT (die-&gt;die_attr, ix, a)</span>
<span class="lineNum">    9197 </span><span class="lineCov">        198 :     if (implicit_consts[ix])</span>
<span class="lineNum">    9198 </span>            :       {
<span class="lineNum">    9199 </span><span class="lineCov">         36 :         enum dw_val_class new_class = dw_val_class_none;</span>
<span class="lineNum">    9200 </span><span class="lineCov">         36 :         switch (AT_class (a))</span>
<span class="lineNum">    9201 </span>            :           {
<span class="lineNum">    9202 </span><span class="lineCov">         15 :           case dw_val_class_unsigned_const:</span>
<span class="lineNum">    9203 </span><span class="lineCov">         15 :             if ((HOST_WIDE_INT) AT_unsigned (a) &lt; 0)</span>
<span class="lineNum">    9204 </span>            :               continue;
<span class="lineNum">    9205 </span>            : 
<span class="lineNum">    9206 </span>            :             /* The .debug_abbrev section will grow by
<span class="lineNum">    9207 </span>            :                size_of_sleb128 (AT_unsigned (a)) and we avoid the constants
<span class="lineNum">    9208 </span>            :                in all the DIEs using that abbreviation.  */
<span class="lineNum">    9209 </span><span class="lineCov">         45 :             if (constant_size (AT_unsigned (a)) * (end - first_id)</span>
<span class="lineNum">    9210 </span><span class="lineCov">         15 :                 &lt;= (unsigned) size_of_sleb128 (AT_unsigned (a)))</span>
<span class="lineNum">    9211 </span>            :               continue;
<span class="lineNum">    9212 </span>            : 
<span class="lineNum">    9213 </span>            :             new_class = dw_val_class_unsigned_const_implicit;
<span class="lineNum">    9214 </span>            :             break;
<span class="lineNum">    9215 </span>            : 
<span class="lineNum">    9216 </span>            :           case dw_val_class_const:
<span class="lineNum">    9217 </span>            :             new_class = dw_val_class_const_implicit;
<span class="lineNum">    9218 </span>            :             break;
<span class="lineNum">    9219 </span>            : 
<span class="lineNum">    9220 </span><span class="lineCov">         21 :           case dw_val_class_file:</span>
<span class="lineNum">    9221 </span><span class="lineCov">         21 :             new_class = dw_val_class_file_implicit;</span>
<span class="lineNum">    9222 </span><span class="lineCov">         21 :             break;</span>
<span class="lineNum">    9223 </span>            : 
<span class="lineNum">    9224 </span>            :           default:
<span class="lineNum">    9225 </span>            :             continue;
<span class="lineNum">    9226 </span>            :           }
<span class="lineNum">    9227 </span><span class="lineCov">        135 :         for (i = first_id; i &lt; end; i++)</span>
<span class="lineNum">    9228 </span><span class="lineCov">         99 :           (*sorted_abbrev_dies[i]-&gt;die_attr)[ix].dw_attr_val.val_class</span>
<span class="lineNum">    9229 </span><span class="lineCov">         99 :             = new_class;</span>
<span class="lineNum">    9230 </span>            :       }
<span class="lineNum">    9231 </span>            : }
<span class="lineNum">    9232 </span>            : 
<span class="lineNum">    9233 </span>            : /* Attempt to optimize abbreviation table from abbrev_opt_start
<span class="lineNum">    9234 </span>            :    abbreviation above.  */
<a name="9235"><span class="lineNum">    9235 </span>            : </a>
<span class="lineNum">    9236 </span>            : static void
<span class="lineNum">    9237 </span><span class="lineCov">      34110 : optimize_abbrev_table (void)</span>
<span class="lineNum">    9238 </span>            : {
<span class="lineNum">    9239 </span><span class="lineCov">      34110 :   if (abbrev_opt_start</span>
<span class="lineNum">    9240 </span><span class="lineCov">      68220 :       &amp;&amp; vec_safe_length (abbrev_die_table) &gt; abbrev_opt_start</span>
<span class="lineNum">    9241 </span><span class="lineCov">      68171 :       &amp;&amp; (dwarf_version &gt;= 5 || vec_safe_length (abbrev_die_table) &gt; 127))</span>
<span class="lineNum">    9242 </span>            :     {
<span class="lineNum">    9243 </span><span class="lineCov">      21336 :       auto_vec&lt;bool, 32&gt; implicit_consts;</span>
<span class="lineNum">    9244 </span><span class="lineCov">       7112 :       sorted_abbrev_dies.qsort (die_abbrev_cmp);</span>
<span class="lineNum">    9245 </span>            : 
<span class="lineNum">    9246 </span><span class="lineCov">       7112 :       unsigned int abbrev_id = abbrev_opt_start - 1;</span>
<span class="lineNum">    9247 </span><span class="lineCov">       7112 :       unsigned int first_id = ~0U;</span>
<span class="lineNum">    9248 </span><span class="lineCov">       7112 :       unsigned int last_abbrev_id = 0;</span>
<span class="lineNum">    9249 </span><span class="lineCov">       7112 :       unsigned int i;</span>
<span class="lineNum">    9250 </span><span class="lineCov">       7112 :       dw_die_ref die;</span>
<span class="lineNum">    9251 </span><span class="lineCov">       7112 :       if (abbrev_opt_base_type_end &gt; abbrev_opt_start)</span>
<span class="lineNum">    9252 </span><span class="lineNoCov">          0 :         abbrev_id = abbrev_opt_base_type_end - 1;</span>
<span class="lineNum">    9253 </span>            :       /* Reassign abbreviation ids from abbrev_opt_start above, so that
<span class="lineNum">    9254 </span>            :          most commonly used abbreviations come first.  */
<span class="lineNum">    9255 </span><span class="lineCov">   40071056 :       FOR_EACH_VEC_ELT (sorted_abbrev_dies, i, die)</span>
<span class="lineNum">    9256 </span>            :         {
<span class="lineNum">    9257 </span><span class="lineCov">   40063944 :           dw_attr_node *a;</span>
<span class="lineNum">    9258 </span><span class="lineCov">   40063944 :           unsigned ix;</span>
<span class="lineNum">    9259 </span>            : 
<span class="lineNum">    9260 </span>            :           /* If calc_base_type_die_sizes has been called, the CU and
<span class="lineNum">    9261 </span>            :              base types after it can't be optimized, because we've already
<span class="lineNum">    9262 </span>            :              calculated their DIE offsets.  We've sorted them first.  */
<span class="lineNum">    9263 </span><span class="lineCov">   40063944 :           if (die-&gt;die_abbrev &lt; abbrev_opt_base_type_end)</span>
<span class="lineNum">    9264 </span>            :             continue;
<span class="lineNum">    9265 </span><span class="lineCov">   40063944 :           if (die-&gt;die_abbrev != last_abbrev_id)</span>
<span class="lineNum">    9266 </span>            :             {
<span class="lineNum">    9267 </span><span class="lineCov">    1465043 :               last_abbrev_id = die-&gt;die_abbrev;</span>
<span class="lineNum">    9268 </span><span class="lineCov">    1465043 :               if (dwarf_version &gt;= 5 &amp;&amp; first_id != ~0U)</span>
<span class="lineNum">    9269 </span><span class="lineCov">        139 :                 optimize_implicit_const (first_id, i, implicit_consts);</span>
<span class="lineNum">    9270 </span><span class="lineCov">    1465043 :               abbrev_id++;</span>
<span class="lineNum">    9271 </span><span class="lineCov">    1465043 :               (*abbrev_die_table)[abbrev_id] = die;</span>
<span class="lineNum">    9272 </span><span class="lineCov">    1465043 :               if (dwarf_version &gt;= 5)</span>
<span class="lineNum">    9273 </span>            :                 {
<span class="lineNum">    9274 </span><span class="lineCov">        154 :                   first_id = i;</span>
<span class="lineNum">    9275 </span><span class="lineCov">        154 :                   implicit_consts.truncate (0);</span>
<span class="lineNum">    9276 </span>            : 
<span class="lineNum">    9277 </span><span class="lineCov">        872 :                   FOR_EACH_VEC_SAFE_ELT (die-&gt;die_attr, ix, a)</span>
<span class="lineNum">    9278 </span><span class="lineCov">        718 :                     switch (AT_class (a))</span>
<span class="lineNum">    9279 </span>            :                       {
<span class="lineNum">    9280 </span><span class="lineCov">        279 :                       case dw_val_class_const:</span>
<span class="lineNum">    9281 </span><span class="lineCov">        279 :                       case dw_val_class_unsigned_const:</span>
<span class="lineNum">    9282 </span><span class="lineCov">        279 :                       case dw_val_class_file:</span>
<span class="lineNum">    9283 </span><span class="lineCov">        279 :                         implicit_consts.safe_push (true);</span>
<span class="lineNum">    9284 </span><span class="lineCov">        279 :                         break;</span>
<span class="lineNum">    9285 </span><span class="lineCov">        439 :                       default:</span>
<span class="lineNum">    9286 </span><span class="lineCov">        439 :                         implicit_consts.safe_push (false);</span>
<span class="lineNum">    9287 </span><span class="lineCov">        439 :                         break;</span>
<span class="lineNum">    9288 </span>            :                       }
<span class="lineNum">    9289 </span>            :                 }
<span class="lineNum">    9290 </span>            :             }
<span class="lineNum">    9291 </span><span class="lineCov">   38598901 :           else if (dwarf_version &gt;= 5)</span>
<span class="lineNum">    9292 </span>            :             {
<span class="lineNum">    9293 </span><span class="lineCov">        456 :               FOR_EACH_VEC_SAFE_ELT (die-&gt;die_attr, ix, a)</span>
<span class="lineNum">    9294 </span><span class="lineCov">        374 :                 if (!implicit_consts[ix])</span>
<span class="lineNum">    9295 </span>            :                   continue;
<span class="lineNum">    9296 </span>            :                 else
<span class="lineNum">    9297 </span>            :                   {
<span class="lineNum">    9298 </span><span class="lineCov">        106 :                     dw_attr_node *other_a</span>
<span class="lineNum">    9299 </span><span class="lineCov">        106 :                       = &amp;(*(*abbrev_die_table)[abbrev_id]-&gt;die_attr)[ix];</span>
<span class="lineNum">    9300 </span><span class="lineCov">        106 :                     if (!dw_val_equal_p (&amp;a-&gt;dw_attr_val,</span>
<span class="lineNum">    9301 </span>            :                                          &amp;other_a-&gt;dw_attr_val))
<span class="lineNum">    9302 </span><span class="lineCov">         43 :                       implicit_consts[ix] = false;</span>
<span class="lineNum">    9303 </span>            :                   }
<span class="lineNum">    9304 </span>            :             }
<span class="lineNum">    9305 </span><span class="lineCov">   40063944 :           die-&gt;die_abbrev = abbrev_id;</span>
<span class="lineNum">    9306 </span>            :         }
<span class="lineNum">    9307 </span><span class="lineCov">      14224 :       gcc_assert (abbrev_id == vec_safe_length (abbrev_die_table) - 1);</span>
<span class="lineNum">    9308 </span><span class="lineCov">       7112 :       if (dwarf_version &gt;= 5 &amp;&amp; first_id != ~0U)</span>
<span class="lineNum">    9309 </span><span class="lineCov">         15 :         optimize_implicit_const (first_id, i, implicit_consts);</span>
<span class="lineNum">    9310 </span>            :     }
<span class="lineNum">    9311 </span>            : 
<span class="lineNum">    9312 </span><span class="lineCov">      34110 :   abbrev_opt_start = 0;</span>
<span class="lineNum">    9313 </span><span class="lineCov">      34110 :   abbrev_opt_base_type_end = 0;</span>
<span class="lineNum">    9314 </span><span class="lineCov">      34110 :   abbrev_usage_count.release ();</span>
<span class="lineNum">    9315 </span><span class="lineCov">      34110 :   sorted_abbrev_dies.release ();</span>
<span class="lineNum">    9316 </span><span class="lineCov">      34110 : }</span>
<span class="lineNum">    9317 </span>            : 
<span class="lineNum">    9318 </span>            : /* Return the power-of-two number of bytes necessary to represent VALUE.  */
<a name="9319"><span class="lineNum">    9319 </span>            : </a>
<span class="lineNum">    9320 </span>            : static int
<span class="lineNum">    9321 </span><span class="lineNoCov">          0 : constant_size (unsigned HOST_WIDE_INT value)</span>
<span class="lineNum">    9322 </span>            : {
<span class="lineNum">    9323 </span><span class="lineCov">  340894415 :   int log;</span>
<span class="lineNum">    9324 </span>            : 
<span class="lineNum">    9325 </span><span class="lineCov">         15 :   if (value == 0)</span>
<span class="lineNum">    9326 </span>            :     log = 0;
<span class="lineNum">    9327 </span>            :   else
<span class="lineNum">    9328 </span><span class="lineCov">  670319574 :     log = floor_log2 (value);</span>
<span class="lineNum">    9329 </span>            : 
<span class="lineNum">    9330 </span><span class="lineCov">  340894415 :   log = log / 8;</span>
<span class="lineNum">    9331 </span><span class="lineCov">  340894415 :   log = 1 &lt;&lt; (floor_log2 (log) + 1);</span>
<span class="lineNum">    9332 </span>            : 
<span class="lineNum">    9333 </span><span class="lineCov">         15 :   return log;</span>
<span class="lineNum">    9334 </span>            : }
<span class="lineNum">    9335 </span>            : 
<span class="lineNum">    9336 </span>            : /* Return the size of a DIE as it is represented in the
<span class="lineNum">    9337 </span>            :    .debug_info section.  */
<a name="9338"><span class="lineNum">    9338 </span>            : </a>
<span class="lineNum">    9339 </span>            : static unsigned long
<span class="lineNum">    9340 </span><span class="lineCov">   46334209 : size_of_die (dw_die_ref die)</span>
<span class="lineNum">    9341 </span>            : {
<span class="lineNum">    9342 </span><span class="lineCov">   46334209 :   unsigned long size = 0;</span>
<span class="lineNum">    9343 </span><span class="lineCov">   46334209 :   dw_attr_node *a;</span>
<span class="lineNum">    9344 </span><span class="lineCov">   46334209 :   unsigned ix;</span>
<span class="lineNum">    9345 </span><span class="lineCov">   46334209 :   enum dwarf_form form;</span>
<span class="lineNum">    9346 </span>            : 
<span class="lineNum">    9347 </span><span class="lineCov">   46334209 :   size += size_of_uleb128 (die-&gt;die_abbrev);</span>
<span class="lineNum">    9348 </span><span class="lineCov">  233236620 :   FOR_EACH_VEC_SAFE_ELT (die-&gt;die_attr, ix, a)</span>
<span class="lineNum">    9349 </span>            :     {
<span class="lineNum">    9350 </span><span class="lineCov">  186902411 :       switch (AT_class (a))</span>
<span class="lineNum">    9351 </span>            :         {
<span class="lineNum">    9352 </span><span class="lineCov">      20665 :         case dw_val_class_addr:</span>
<span class="lineNum">    9353 </span><span class="lineCov">      20665 :           if (dwarf_split_debug_info &amp;&amp; AT_index (a) != NOT_INDEXED)</span>
<span class="lineNum">    9354 </span>            :             {
<span class="lineNum">    9355 </span><span class="lineNoCov">          0 :               gcc_assert (AT_index (a) != NO_INDEX_ASSIGNED);</span>
<span class="lineNum">    9356 </span><span class="lineNoCov">          0 :               size += size_of_uleb128 (AT_index (a));</span>
<span class="lineNum">    9357 </span>            :             }
<span class="lineNum">    9358 </span>            :           else
<span class="lineNum">    9359 </span><span class="lineCov">      22797 :             size += DWARF2_ADDR_SIZE;</span>
<span class="lineNum">    9360 </span>            :           break;
<span class="lineNum">    9361 </span><span class="lineNoCov">          0 :         case dw_val_class_offset:</span>
<span class="lineNum">    9362 </span><span class="lineNoCov">          0 :           size += DWARF_OFFSET_SIZE;</span>
<span class="lineNum">    9363 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    9364 </span><span class="lineCov">    4972584 :         case dw_val_class_loc:</span>
<span class="lineNum">    9365 </span><span class="lineCov">    4972584 :           {</span>
<span class="lineNum">    9366 </span><span class="lineCov">    4972584 :             unsigned long lsize = size_of_locs (AT_loc (a));</span>
<span class="lineNum">    9367 </span>            : 
<span class="lineNum">    9368 </span>            :             /* Block length.  */
<span class="lineNum">    9369 </span><span class="lineCov">    4972584 :             if (dwarf_version &gt;= 4)</span>
<span class="lineNum">    9370 </span><span class="lineCov">    4964478 :               size += size_of_uleb128 (lsize);</span>
<span class="lineNum">    9371 </span>            :             else
<span class="lineNum">    9372 </span><span class="lineCov">      16212 :               size += constant_size (lsize);</span>
<span class="lineNum">    9373 </span><span class="lineCov">    4972584 :             size += lsize;</span>
<span class="lineNum">    9374 </span>            :           }
<span class="lineNum">    9375 </span><span class="lineCov">    4972584 :           break;</span>
<span class="lineNum">    9376 </span><span class="lineCov">   11497183 :         case dw_val_class_loc_list:</span>
<span class="lineNum">    9377 </span><span class="lineCov">   11497183 :         case dw_val_class_view_list:</span>
<span class="lineNum">    9378 </span><span class="lineCov">   11497183 :           if (dwarf_split_debug_info &amp;&amp; dwarf_version &gt;= 5)</span>
<span class="lineNum">    9379 </span>            :             {
<span class="lineNum">    9380 </span><span class="lineNoCov">          0 :               gcc_assert (AT_loc_list (a)-&gt;num_assigned);</span>
<span class="lineNum">    9381 </span><span class="lineNoCov">          0 :               size += size_of_uleb128 (AT_loc_list (a)-&gt;hash);</span>
<span class="lineNum">    9382 </span>            :             }
<span class="lineNum">    9383 </span>            :           else
<span class="lineNum">    9384 </span><span class="lineCov">   11497183 :             size += DWARF_OFFSET_SIZE;</span>
<span class="lineNum">    9385 </span>            :           break;
<span class="lineNum">    9386 </span><span class="lineCov">    1545590 :         case dw_val_class_range_list:</span>
<span class="lineNum">    9387 </span><span class="lineCov">    1545590 :           if (value_format (a) == DW_FORM_rnglistx)</span>
<span class="lineNum">    9388 </span>            :             {
<span class="lineNum">    9389 </span><span class="lineNoCov">          0 :               gcc_assert (rnglist_idx);</span>
<span class="lineNum">    9390 </span><span class="lineNoCov">          0 :               dw_ranges *r = &amp;(*ranges_table)[a-&gt;dw_attr_val.v.val_offset];</span>
<span class="lineNum">    9391 </span><span class="lineNoCov">          0 :               size += size_of_uleb128 (r-&gt;idx);</span>
<span class="lineNum">    9392 </span>            :             }
<span class="lineNum">    9393 </span>            :           else
<span class="lineNum">    9394 </span><span class="lineCov">    1545590 :             size += DWARF_OFFSET_SIZE;</span>
<span class="lineNum">    9395 </span>            :           break;
<span class="lineNum">    9396 </span><span class="lineCov">      36963 :         case dw_val_class_const:</span>
<span class="lineNum">    9397 </span><span class="lineCov">      36963 :           size += size_of_sleb128 (AT_int (a));</span>
<span class="lineNum">    9398 </span><span class="lineCov">      36963 :           break;</span>
<span class="lineNum">    9399 </span><span class="lineCov">   45505252 :         case dw_val_class_unsigned_const:</span>
<span class="lineNum">    9400 </span><span class="lineCov">   45505252 :           {</span>
<span class="lineNum">    9401 </span><span class="lineCov">   45505252 :             int csize = constant_size (AT_unsigned (a));</span>
<span class="lineNum">    9402 </span><span class="lineCov">   45505252 :             if (dwarf_version == 3</span>
<span class="lineNum">    9403 </span><span class="lineCov">        675 :                 &amp;&amp; a-&gt;dw_attr == DW_AT_data_member_location</span>
<span class="lineNum">    9404 </span><span class="lineCov">         15 :                 &amp;&amp; csize &gt;= 4)</span>
<span class="lineNum">    9405 </span><span class="lineCov">          1 :               size += size_of_uleb128 (AT_unsigned (a));</span>
<span class="lineNum">    9406 </span>            :             else
<span class="lineNum">    9407 </span><span class="lineCov">   45505251 :               size += csize;</span>
<span class="lineNum">    9408 </span>            :           }
<span class="lineNum">    9409 </span>            :           break;
<span class="lineNum">    9410 </span><span class="lineCov">    3149821 :         case dw_val_class_symview:</span>
<span class="lineNum">    9411 </span><span class="lineCov">    3149821 :           if (symview_upper_bound &lt;= 0xff)</span>
<span class="lineNum">    9412 </span><span class="lineCov">     304871 :             size += 1;</span>
<span class="lineNum">    9413 </span><span class="lineCov">    2844950 :           else if (symview_upper_bound &lt;= 0xffff)</span>
<span class="lineNum">    9414 </span><span class="lineCov">    2844950 :             size += 2;</span>
<span class="lineNum">    9415 </span><span class="lineNoCov">          0 :           else if (symview_upper_bound &lt;= 0xffffffff)</span>
<span class="lineNum">    9416 </span><span class="lineNoCov">          0 :             size += 4;</span>
<span class="lineNum">    9417 </span>            :           else
<span class="lineNum">    9418 </span>            :             size += 8;
<span class="lineNum">    9419 </span>            :           break;
<span class="lineNum">    9420 </span>            :         case dw_val_class_const_implicit:
<span class="lineNum">    9421 </span>            :         case dw_val_class_unsigned_const_implicit:
<span class="lineNum">    9422 </span>            :         case dw_val_class_file_implicit:
<span class="lineNum">    9423 </span>            :           /* These occupy no size in the DIE, just an extra sleb128 in
<span class="lineNum">    9424 </span>            :              .debug_abbrev.  */
<span class="lineNum">    9425 </span>            :           break;
<span class="lineNum">    9426 </span><span class="lineNoCov">          0 :         case dw_val_class_const_double:</span>
<span class="lineNum">    9427 </span><span class="lineNoCov">          0 :           size += HOST_BITS_PER_DOUBLE_INT / HOST_BITS_PER_CHAR;</span>
<span class="lineNum">    9428 </span><span class="lineNoCov">          0 :           if (HOST_BITS_PER_WIDE_INT &gt;= DWARF_LARGEST_DATA_FORM_BITS)</span>
<span class="lineNum">    9429 </span><span class="lineNoCov">          0 :             size++; /* block */</span>
<span class="lineNum">    9430 </span>            :           break;
<span class="lineNum">    9431 </span><span class="lineCov">          8 :         case dw_val_class_wide_int:</span>
<span class="lineNum">    9432 </span><span class="lineCov">          8 :           size += (get_full_len (*a-&gt;dw_attr_val.v.val_wide)</span>
<span class="lineNum">    9433 </span><span class="lineCov">          8 :                    * HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR);</span>
<span class="lineNum">    9434 </span><span class="lineCov">         16 :           if (get_full_len (*a-&gt;dw_attr_val.v.val_wide)</span>
<span class="lineNum">    9435 </span><span class="lineCov">          8 :               * HOST_BITS_PER_WIDE_INT &gt; DWARF_LARGEST_DATA_FORM_BITS)</span>
<span class="lineNum">    9436 </span><span class="lineCov">          4 :             size++; /* block */</span>
<span class="lineNum">    9437 </span>            :           break;
<span class="lineNum">    9438 </span><span class="lineCov">      47110 :         case dw_val_class_vec:</span>
<span class="lineNum">    9439 </span><span class="lineCov">     188440 :           size += constant_size (a-&gt;dw_attr_val.v.val_vec.length</span>
<span class="lineNum">    9440 </span><span class="lineCov">      47110 :                                  * a-&gt;dw_attr_val.v.val_vec.elt_size)</span>
<span class="lineNum">    9441 </span><span class="lineCov">      47110 :                   + a-&gt;dw_attr_val.v.val_vec.length</span>
<span class="lineNum">    9442 </span>            :                     * a-&gt;dw_attr_val.v.val_vec.elt_size; /* block */
<span class="lineNum">    9443 </span><span class="lineCov">      47110 :           break;</span>
<span class="lineNum">    9444 </span><span class="lineCov">   18073949 :         case dw_val_class_flag:</span>
<span class="lineNum">    9445 </span><span class="lineCov">   18073949 :           if (dwarf_version &gt;= 4)</span>
<span class="lineNum">    9446 </span>            :             /* Currently all add_AT_flag calls pass in 1 as last argument,
<span class="lineNum">    9447 </span>            :                so DW_FORM_flag_present can be used.  If that ever changes,
<span class="lineNum">    9448 </span>            :                we'll need to use DW_FORM_flag and have some optimization
<span class="lineNum">    9449 </span>            :                in build_abbrev_table that will change those to
<span class="lineNum">    9450 </span>            :                DW_FORM_flag_present if it is set to 1 in all DIEs using
<span class="lineNum">    9451 </span>            :                the same abbrev entry.  */
<span class="lineNum">    9452 </span><span class="lineCov">   18059323 :             gcc_assert (a-&gt;dw_attr_val.v.val_flag == 1);</span>
<span class="lineNum">    9453 </span>            :           else
<span class="lineNum">    9454 </span><span class="lineCov">      14626 :             size += 1;</span>
<span class="lineNum">    9455 </span>            :           break;
<span class="lineNum">    9456 </span><span class="lineCov">   52191104 :         case dw_val_class_die_ref:</span>
<span class="lineNum">    9457 </span><span class="lineCov">   52191104 :           if (AT_ref_external (a))</span>
<span class="lineNum">    9458 </span>            :             {
<span class="lineNum">    9459 </span>            :               /* In DWARF4, we use DW_FORM_ref_sig8; for earlier versions
<span class="lineNum">    9460 </span>            :                  we use DW_FORM_ref_addr.  In DWARF2, DW_FORM_ref_addr
<span class="lineNum">    9461 </span>            :                  is sized by target address length, whereas in DWARF3
<span class="lineNum">    9462 </span>            :                  it's always sized as an offset.  */
<span class="lineNum">    9463 </span><span class="lineCov">      26170 :               if (use_debug_types)</span>
<span class="lineNum">    9464 </span><span class="lineCov">         54 :                 size += DWARF_TYPE_SIGNATURE_SIZE;</span>
<span class="lineNum">    9465 </span><span class="lineCov">      26116 :               else if (dwarf_version == 2)</span>
<span class="lineNum">    9466 </span><span class="lineCov">         39 :                 size += DWARF2_ADDR_SIZE;</span>
<span class="lineNum">    9467 </span>            :               else
<span class="lineNum">    9468 </span><span class="lineCov">      26077 :                 size += DWARF_OFFSET_SIZE;</span>
<span class="lineNum">    9469 </span>            :             }
<span class="lineNum">    9470 </span>            :           else
<span class="lineNum">    9471 </span><span class="lineCov">   52164934 :             size += DWARF_OFFSET_SIZE;</span>
<span class="lineNum">    9472 </span>            :           break;
<span class="lineNum">    9473 </span><span class="lineNoCov">          0 :         case dw_val_class_fde_ref:</span>
<span class="lineNum">    9474 </span><span class="lineNoCov">          0 :           size += DWARF_OFFSET_SIZE;</span>
<span class="lineNum">    9475 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    9476 </span><span class="lineCov">    7797583 :         case dw_val_class_lbl_id:</span>
<span class="lineNum">    9477 </span><span class="lineCov">    7797597 :           if (dwarf_split_debug_info &amp;&amp; AT_index (a) != NOT_INDEXED)</span>
<span class="lineNum">    9478 </span>            :             {
<span class="lineNum">    9479 </span><span class="lineCov">         28 :               gcc_assert (AT_index (a) != NO_INDEX_ASSIGNED);</span>
<span class="lineNum">    9480 </span><span class="lineCov">         28 :               size += size_of_uleb128 (AT_index (a));</span>
<span class="lineNum">    9481 </span>            :             }
<span class="lineNum">    9482 </span>            :           else
<span class="lineNum">    9483 </span><span class="lineCov">    8680716 :             size += DWARF2_ADDR_SIZE;</span>
<span class="lineNum">    9484 </span>            :           break;
<span class="lineNum">    9485 </span><span class="lineCov">      34608 :         case dw_val_class_lineptr:</span>
<span class="lineNum">    9486 </span><span class="lineCov">      34608 :         case dw_val_class_macptr:</span>
<span class="lineNum">    9487 </span><span class="lineCov">      34608 :         case dw_val_class_loclistsptr:</span>
<span class="lineNum">    9488 </span><span class="lineCov">      34608 :           size += DWARF_OFFSET_SIZE;</span>
<span class="lineNum">    9489 </span><span class="lineCov">      34608 :           break;</span>
<span class="lineNum">    9490 </span><span class="lineCov">   21293678 :         case dw_val_class_str:</span>
<span class="lineNum">    9491 </span><span class="lineCov">   21293678 :           form = AT_string_form (a);</span>
<span class="lineNum">    9492 </span><span class="lineCov">   21293678 :           if (form == DW_FORM_strp || form == DW_FORM_line_strp)</span>
<span class="lineNum">    9493 </span><span class="lineCov">   18905271 :             size += DWARF_OFFSET_SIZE;</span>
<span class="lineNum">    9494 </span><span class="lineCov">    4776703 :           else if (form == dwarf_FORM (DW_FORM_strx))</span>
<span class="lineNum">    9495 </span><span class="lineCov">         42 :             size += size_of_uleb128 (AT_index (a));</span>
<span class="lineNum">    9496 </span>            :           else
<span class="lineNum">    9497 </span><span class="lineCov">    2388386 :             size += strlen (a-&gt;dw_attr_val.v.val_str-&gt;str) + 1;</span>
<span class="lineNum">    9498 </span>            :           break;
<span class="lineNum">    9499 </span><span class="lineCov">   18013392 :         case dw_val_class_file:</span>
<span class="lineNum">    9500 </span><span class="lineCov">   18013392 :           size += constant_size (maybe_emit_file (a-&gt;dw_attr_val.v.val_file));</span>
<span class="lineNum">    9501 </span><span class="lineCov">   18013392 :           break;</span>
<span class="lineNum">    9502 </span><span class="lineCov">         54 :         case dw_val_class_data8:</span>
<span class="lineNum">    9503 </span><span class="lineCov">         54 :           size += 8;</span>
<span class="lineNum">    9504 </span><span class="lineCov">         54 :           break;</span>
<span class="lineNum">    9505 </span><span class="lineNoCov">          0 :         case dw_val_class_vms_delta:</span>
<span class="lineNum">    9506 </span><span class="lineNoCov">          0 :           size += DWARF_OFFSET_SIZE;</span>
<span class="lineNum">    9507 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    9508 </span><span class="lineCov">    2722768 :         case dw_val_class_high_pc:</span>
<span class="lineNum">    9509 </span><span class="lineCov">    2722768 :           size += DWARF2_ADDR_SIZE;</span>
<span class="lineNum">    9510 </span><span class="lineCov">    2722768 :           break;</span>
<span class="lineNum">    9511 </span><span class="lineNoCov">          0 :         case dw_val_class_discr_value:</span>
<span class="lineNum">    9512 </span><span class="lineNoCov">          0 :           size += size_of_discr_value (&amp;a-&gt;dw_attr_val.v.val_discr_value);</span>
<span class="lineNum">    9513 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    9514 </span><span class="lineNoCov">          0 :         case dw_val_class_discr_list:</span>
<span class="lineNum">    9515 </span><span class="lineNoCov">          0 :             {</span>
<span class="lineNum">    9516 </span><span class="lineNoCov">          0 :               unsigned block_size = size_of_discr_list (AT_discr_list (a));</span>
<span class="lineNum">    9517 </span>            : 
<span class="lineNum">    9518 </span>            :               /* This is a block, so we have the block length and then its
<span class="lineNum">    9519 </span>            :                  data.  */
<span class="lineNum">    9520 </span><span class="lineNoCov">          0 :               size += constant_size (block_size) + block_size;</span>
<span class="lineNum">    9521 </span>            :             }
<span class="lineNum">    9522 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    9523 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">    9524 </span><span class="lineNoCov">          0 :           gcc_unreachable ();</span>
<span class="lineNum">    9525 </span>            :         }
<span class="lineNum">    9526 </span>            :     }
<span class="lineNum">    9527 </span>            : 
<span class="lineNum">    9528 </span><span class="lineCov">   46334209 :   return size;</span>
<span class="lineNum">    9529 </span>            : }
<span class="lineNum">    9530 </span>            : 
<span class="lineNum">    9531 </span>            : /* Size the debugging information associated with a given DIE.  Visits the
<span class="lineNum">    9532 </span>            :    DIE's children recursively.  Updates the global variable next_die_offset, on
<span class="lineNum">    9533 </span>            :    each time through.  Uses the current value of next_die_offset to update the
<span class="lineNum">    9534 </span>            :    die_offset field in each DIE.  */
<a name="9535"><span class="lineNum">    9535 </span>            : </a>
<span class="lineNum">    9536 </span>            : static void
<span class="lineNum">    9537 </span><span class="lineCov">   46334205 : calc_die_sizes (dw_die_ref die)</span>
<span class="lineNum">    9538 </span>            : {
<span class="lineNum">    9539 </span><span class="lineCov">   46334205 :   dw_die_ref c;</span>
<span class="lineNum">    9540 </span>            : 
<span class="lineNum">    9541 </span><span class="lineCov">   46334205 :   gcc_assert (die-&gt;die_offset == 0</span>
<span class="lineNum">    9542 </span>            :               || (unsigned long int) die-&gt;die_offset == next_die_offset);
<span class="lineNum">    9543 </span><span class="lineCov">   46334205 :   die-&gt;die_offset = next_die_offset;</span>
<span class="lineNum">    9544 </span><span class="lineCov">   46334205 :   next_die_offset += size_of_die (die);</span>
<span class="lineNum">    9545 </span>            : 
<span class="lineNum">    9546 </span><span class="lineCov">   92634252 :   FOR_EACH_CHILD (die, c, calc_die_sizes (c));</span>
<span class="lineNum">    9547 </span>            : 
<span class="lineNum">    9548 </span><span class="lineCov">   46334205 :   if (die-&gt;die_child != NULL)</span>
<span class="lineNum">    9549 </span>            :     /* Count the null byte used to terminate sibling lists.  */
<span class="lineNum">    9550 </span><span class="lineCov">   11800055 :     next_die_offset += 1;</span>
<span class="lineNum">    9551 </span><span class="lineCov">   46334205 : }</span>
<span class="lineNum">    9552 </span>            : 
<span class="lineNum">    9553 </span>            : /* Size just the base type children at the start of the CU.
<span class="lineNum">    9554 </span>            :    This is needed because build_abbrev needs to size locs
<span class="lineNum">    9555 </span>            :    and sizing of type based stack ops needs to know die_offset
<span class="lineNum">    9556 </span>            :    values for the base types.  */
<a name="9557"><span class="lineNum">    9557 </span>            : </a>
<span class="lineNum">    9558 </span>            : static void
<span class="lineNum">    9559 </span><span class="lineNoCov">          0 : calc_base_type_die_sizes (void)</span>
<span class="lineNum">    9560 </span>            : {
<span class="lineNum">    9561 </span><span class="lineNoCov">          0 :   unsigned long die_offset = (dwarf_split_debug_info</span>
<span class="lineNum">    9562 </span><span class="lineNoCov">          0 :                               ? DWARF_COMPILE_UNIT_SKELETON_HEADER_SIZE</span>
<span class="lineNum">    9563 </span><span class="lineNoCov">          0 :                               : DWARF_COMPILE_UNIT_HEADER_SIZE);</span>
<span class="lineNum">    9564 </span><span class="lineNoCov">          0 :   unsigned int i;</span>
<span class="lineNum">    9565 </span><span class="lineNoCov">          0 :   dw_die_ref base_type;</span>
<span class="lineNum">    9566 </span>            : #if ENABLE_ASSERT_CHECKING
<span class="lineNum">    9567 </span><span class="lineNoCov">          0 :   dw_die_ref prev = comp_unit_die ()-&gt;die_child;</span>
<span class="lineNum">    9568 </span>            : #endif
<span class="lineNum">    9569 </span>            : 
<span class="lineNum">    9570 </span><span class="lineNoCov">          0 :   die_offset += size_of_die (comp_unit_die ());</span>
<span class="lineNum">    9571 </span><span class="lineNoCov">          0 :   for (i = 0; base_types.iterate (i, &amp;base_type); i++)</span>
<span class="lineNum">    9572 </span>            :     {
<span class="lineNum">    9573 </span>            : #if ENABLE_ASSERT_CHECKING
<span class="lineNum">    9574 </span><span class="lineNoCov">          0 :       gcc_assert (base_type-&gt;die_offset == 0</span>
<span class="lineNum">    9575 </span>            :                   &amp;&amp; prev-&gt;die_sib == base_type
<span class="lineNum">    9576 </span>            :                   &amp;&amp; base_type-&gt;die_child == NULL
<span class="lineNum">    9577 </span>            :                   &amp;&amp; base_type-&gt;die_abbrev);
<span class="lineNum">    9578 </span><span class="lineNoCov">          0 :       prev = base_type;</span>
<span class="lineNum">    9579 </span>            : #endif
<span class="lineNum">    9580 </span><span class="lineNoCov">          0 :       if (abbrev_opt_start</span>
<span class="lineNum">    9581 </span><span class="lineNoCov">          0 :           &amp;&amp; base_type-&gt;die_abbrev &gt;= abbrev_opt_base_type_end)</span>
<span class="lineNum">    9582 </span><span class="lineNoCov">          0 :         abbrev_opt_base_type_end = base_type-&gt;die_abbrev + 1;</span>
<span class="lineNum">    9583 </span><span class="lineNoCov">          0 :       base_type-&gt;die_offset = die_offset;</span>
<span class="lineNum">    9584 </span><span class="lineNoCov">          0 :       die_offset += size_of_die (base_type);</span>
<span class="lineNum">    9585 </span>            :     }
<span class="lineNum">    9586 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    9587 </span>            : 
<span class="lineNum">    9588 </span>            : /* Set the marks for a die and its children.  We do this so
<span class="lineNum">    9589 </span>            :    that we know whether or not a reference needs to use FORM_ref_addr; only
<span class="lineNum">    9590 </span>            :    DIEs in the same CU will be marked.  We used to clear out the offset
<span class="lineNum">    9591 </span>            :    and use that as the flag, but ran into ordering problems.  */
<a name="9592"><span class="lineNum">    9592 </span>            : </a>
<span class="lineNum">    9593 </span>            : static void
<span class="lineNum">    9594 </span><span class="lineCov">   46335310 : mark_dies (dw_die_ref die)</span>
<span class="lineNum">    9595 </span>            : {
<span class="lineNum">    9596 </span><span class="lineCov">   46335310 :   dw_die_ref c;</span>
<span class="lineNum">    9597 </span>            : 
<span class="lineNum">    9598 </span><span class="lineCov">   46335310 :   gcc_assert (!die-&gt;die_mark);</span>
<span class="lineNum">    9599 </span>            : 
<span class="lineNum">    9600 </span><span class="lineCov">   46335310 :   die-&gt;die_mark = 1;</span>
<span class="lineNum">    9601 </span><span class="lineCov">   92636304 :   FOR_EACH_CHILD (die, c, mark_dies (c));</span>
<span class="lineNum">    9602 </span><span class="lineCov">   46335310 : }</span>
<span class="lineNum">    9603 </span>            : 
<span class="lineNum">    9604 </span>            : /* Clear the marks for a die and its children.  */
<a name="9605"><span class="lineNum">    9605 </span>            : </a>
<span class="lineNum">    9606 </span>            : static void
<span class="lineNum">    9607 </span><span class="lineCov">     186660 : unmark_dies (dw_die_ref die)</span>
<span class="lineNum">    9608 </span>            : {
<span class="lineNum">    9609 </span><span class="lineCov">     186660 :   dw_die_ref c;</span>
<span class="lineNum">    9610 </span>            : 
<span class="lineNum">    9611 </span><span class="lineCov">     186660 :   if (! use_debug_types)</span>
<span class="lineNum">    9612 </span><span class="lineCov">     185085 :     gcc_assert (die-&gt;die_mark);</span>
<span class="lineNum">    9613 </span>            : 
<span class="lineNum">    9614 </span><span class="lineCov">     186660 :   die-&gt;die_mark = 0;</span>
<span class="lineNum">    9615 </span><span class="lineCov">     372398 :   FOR_EACH_CHILD (die, c, unmark_dies (c));</span>
<span class="lineNum">    9616 </span><span class="lineCov">     186660 : }</span>
<span class="lineNum">    9617 </span>            : 
<span class="lineNum">    9618 </span>            : /* Clear the marks for a die, its children and referred dies.  */
<a name="9619"><span class="lineNum">    9619 </span>            : </a>
<span class="lineNum">    9620 </span>            : static void
<span class="lineNum">    9621 </span><span class="lineCov">     417045 : unmark_all_dies (dw_die_ref die)</span>
<span class="lineNum">    9622 </span>            : {
<span class="lineNum">    9623 </span><span class="lineCov">     417045 :   dw_die_ref c;</span>
<span class="lineNum">    9624 </span><span class="lineCov">     417045 :   dw_attr_node *a;</span>
<span class="lineNum">    9625 </span><span class="lineCov">     417045 :   unsigned ix;</span>
<span class="lineNum">    9626 </span>            : 
<span class="lineNum">    9627 </span><span class="lineCov">     417045 :   if (!die-&gt;die_mark)</span>
<span class="lineNum">    9628 </span>            :     return;
<span class="lineNum">    9629 </span><span class="lineCov">     185295 :   die-&gt;die_mark = 0;</span>
<span class="lineNum">    9630 </span>            : 
<span class="lineNum">    9631 </span><span class="lineCov">     324101 :   FOR_EACH_CHILD (die, c, unmark_all_dies (c));</span>
<span class="lineNum">    9632 </span>            : 
<span class="lineNum">    9633 </span><span class="lineCov">     916109 :   FOR_EACH_VEC_SAFE_ELT (die-&gt;die_attr, ix, a)</span>
<span class="lineNum">    9634 </span><span class="lineCov">     730814 :     if (AT_class (a) == dw_val_class_die_ref)</span>
<span class="lineNum">    9635 </span><span class="lineCov">     231713 :       unmark_all_dies (AT_ref (a));</span>
<span class="lineNum">    9636 </span>            : }
<span class="lineNum">    9637 </span>            : 
<span class="lineNum">    9638 </span>            : /* Calculate if the entry should appear in the final output file.  It may be
<span class="lineNum">    9639 </span>            :    from a pruned a type.  */
<a name="9640"><span class="lineNum">    9640 </span>            : </a>
<span class="lineNum">    9641 </span>            : static bool
<span class="lineNum">    9642 </span><span class="lineCov">        492 : include_pubname_in_output (vec&lt;pubname_entry, va_gc&gt; *table, pubname_entry *p)</span>
<span class="lineNum">    9643 </span>            : {
<span class="lineNum">    9644 </span>            :   /* By limiting gnu pubnames to definitions only, gold can generate a
<span class="lineNum">    9645 </span>            :      gdb index without entries for declarations, which don't include
<span class="lineNum">    9646 </span>            :      enough information to be useful.  */
<span class="lineNum">    9647 </span><span class="lineCov">        528 :   if (debug_generate_pub_sections == 2 &amp;&amp; is_declaration_die (p-&gt;die))</span>
<span class="lineNum">    9648 </span>            :     return false;
<span class="lineNum">    9649 </span>            : 
<span class="lineNum">    9650 </span><span class="lineCov">        492 :   if (table == pubname_table)</span>
<span class="lineNum">    9651 </span>            :     {
<span class="lineNum">    9652 </span>            :       /* Enumerator names are part of the pubname table, but the
<span class="lineNum">    9653 </span>            :          parent DW_TAG_enumeration_type die may have been pruned.
<span class="lineNum">    9654 </span>            :          Don't output them if that is the case.  */
<span class="lineNum">    9655 </span><span class="lineCov">        360 :       if (p-&gt;die-&gt;die_tag == DW_TAG_enumerator &amp;&amp;</span>
<span class="lineNum">    9656 </span><span class="lineCov">         48 :           (p-&gt;die-&gt;die_parent == NULL</span>
<span class="lineNum">    9657 </span><span class="lineCov">         48 :            || !p-&gt;die-&gt;die_parent-&gt;die_perennial_p))</span>
<span class="lineNum">    9658 </span>            :         return false;
<span class="lineNum">    9659 </span>            : 
<span class="lineNum">    9660 </span>            :       /* Everything else in the pubname table is included.  */
<span class="lineNum">    9661 </span><span class="lineCov">        360 :       return true;</span>
<span class="lineNum">    9662 </span>            :     }
<span class="lineNum">    9663 </span>            : 
<span class="lineNum">    9664 </span>            :   /* The pubtypes table shouldn't include types that have been
<span class="lineNum">    9665 </span>            :      pruned.  */
<span class="lineNum">    9666 </span><span class="lineCov">        132 :   return (p-&gt;die-&gt;die_offset != 0</span>
<span class="lineNum">    9667 </span><span class="lineCov">        132 :           || !flag_eliminate_unused_debug_types);</span>
<span class="lineNum">    9668 </span>            : }
<span class="lineNum">    9669 </span>            : 
<span class="lineNum">    9670 </span>            : /* Return the size of the .debug_pubnames or .debug_pubtypes table
<span class="lineNum">    9671 </span>            :    generated for the compilation unit.  */
<a name="9672"><span class="lineNum">    9672 </span>            : </a>
<span class="lineNum">    9673 </span>            : static unsigned long
<span class="lineNum">    9674 </span><span class="lineCov">         16 : size_of_pubnames (vec&lt;pubname_entry, va_gc&gt; *names)</span>
<span class="lineNum">    9675 </span>            : {
<span class="lineNum">    9676 </span><span class="lineCov">         16 :   unsigned long size;</span>
<span class="lineNum">    9677 </span><span class="lineCov">         16 :   unsigned i;</span>
<span class="lineNum">    9678 </span><span class="lineCov">         16 :   pubname_entry *p;</span>
<span class="lineNum">    9679 </span><span class="lineCov">         16 :   int space_for_flags = (debug_generate_pub_sections == 2) ? 1 : 0;</span>
<span class="lineNum">    9680 </span>            : 
<span class="lineNum">    9681 </span><span class="lineCov">         16 :   size = DWARF_PUBNAMES_HEADER_SIZE;</span>
<span class="lineNum">    9682 </span><span class="lineCov">        262 :   FOR_EACH_VEC_ELT (*names, i, p)</span>
<span class="lineNum">    9683 </span><span class="lineCov">        246 :     if (include_pubname_in_output (names, p))</span>
<span class="lineNum">    9684 </span><span class="lineCov">        246 :       size += strlen (p-&gt;name) + DWARF_OFFSET_SIZE + 1 + space_for_flags;</span>
<span class="lineNum">    9685 </span>            : 
<span class="lineNum">    9686 </span><span class="lineCov">         16 :   size += DWARF_OFFSET_SIZE;</span>
<span class="lineNum">    9687 </span><span class="lineCov">         16 :   return size;</span>
<span class="lineNum">    9688 </span>            : }
<span class="lineNum">    9689 </span>            : 
<span class="lineNum">    9690 </span>            : /* Return the size of the information in the .debug_aranges section.  */
<a name="9691"><span class="lineNum">    9691 </span>            : </a>
<span class="lineNum">    9692 </span>            : static unsigned long
<span class="lineNum">    9693 </span><span class="lineCov">      33302 : size_of_aranges (void)</span>
<span class="lineNum">    9694 </span>            : {
<span class="lineNum">    9695 </span><span class="lineCov">      33302 :   unsigned long size;</span>
<span class="lineNum">    9696 </span>            : 
<span class="lineNum">    9697 </span><span class="lineCov">      38065 :   size = DWARF_ARANGES_HEADER_SIZE;</span>
<span class="lineNum">    9698 </span>            : 
<span class="lineNum">    9699 </span>            :   /* Count the address/length pair for this compilation unit.  */
<span class="lineNum">    9700 </span><span class="lineCov">      33302 :   if (text_section_used)</span>
<span class="lineNum">    9701 </span><span class="lineCov">      20256 :     size += 2 * DWARF2_ADDR_SIZE;</span>
<span class="lineNum">    9702 </span><span class="lineCov">      33302 :   if (cold_text_section_used)</span>
<span class="lineNum">    9703 </span><span class="lineCov">       5592 :     size += 2 * DWARF2_ADDR_SIZE;</span>
<span class="lineNum">    9704 </span><span class="lineCov">      33302 :   if (have_multiple_function_sections)</span>
<span class="lineNum">    9705 </span>            :     {
<span class="lineNum">    9706 </span>            :       unsigned fde_idx;
<span class="lineNum">    9707 </span>            :       dw_fde_ref fde;
<span class="lineNum">    9708 </span>            : 
<span class="lineNum">    9709 </span><span class="lineCov">     180067 :       FOR_EACH_VEC_ELT (*fde_vec, fde_idx, fde)</span>
<span class="lineNum">    9710 </span>            :         {
<span class="lineNum">    9711 </span><span class="lineCov">     159737 :           if (DECL_IGNORED_P (fde-&gt;decl))</span>
<span class="lineNum">    9712 </span>            :             continue;
<span class="lineNum">    9713 </span><span class="lineCov">     154133 :           if (!fde-&gt;in_std_section)</span>
<span class="lineNum">    9714 </span><span class="lineCov">     133935 :             size += 2 * DWARF2_ADDR_SIZE;</span>
<span class="lineNum">    9715 </span><span class="lineCov">     154133 :           if (fde-&gt;dw_fde_second_begin &amp;&amp; !fde-&gt;second_in_std_section)</span>
<span class="lineNum">    9716 </span><span class="lineCov">       3259 :             size += 2 * DWARF2_ADDR_SIZE;</span>
<span class="lineNum">    9717 </span>            :         }
<span class="lineNum">    9718 </span>            :     }
<span class="lineNum">    9719 </span>            : 
<span class="lineNum">    9720 </span>            :   /* Count the two zero words used to terminated the address range table.  */
<span class="lineNum">    9721 </span><span class="lineCov">      33302 :   size += 2 * DWARF2_ADDR_SIZE;</span>
<span class="lineNum">    9722 </span><span class="lineCov">      33302 :   return size;</span>
<span class="lineNum">    9723 </span>            : }
<span class="lineNum">    9724 </span>            : 
<span class="lineNum">    9725 </span>            : /* Select the encoding of an attribute value.  */
<a name="9726"><span class="lineNum">    9726 </span>            : </a>
<span class="lineNum">    9727 </span>            : static enum dwarf_form
<span class="lineNum">    9728 </span><span class="lineCov">  571777752 : value_format (dw_attr_node *a)</span>
<span class="lineNum">    9729 </span>            : {
<span class="lineNum">    9730 </span><span class="lineCov">  571777752 :   switch (AT_class (a))</span>
<span class="lineNum">    9731 </span>            :     {
<span class="lineNum">    9732 </span><span class="lineCov">      41894 :     case dw_val_class_addr:</span>
<span class="lineNum">    9733 </span>            :       /* Only very few attributes allow DW_FORM_addr.  */
<span class="lineNum">    9734 </span><span class="lineCov">      41894 :       switch (a-&gt;dw_attr)</span>
<span class="lineNum">    9735 </span>            :         {
<span class="lineNum">    9736 </span><span class="lineCov">      41894 :         case DW_AT_low_pc:</span>
<span class="lineNum">    9737 </span><span class="lineCov">      41894 :         case DW_AT_high_pc:</span>
<span class="lineNum">    9738 </span><span class="lineCov">      41894 :         case DW_AT_entry_pc:</span>
<span class="lineNum">    9739 </span><span class="lineCov">      41894 :         case DW_AT_trampoline:</span>
<span class="lineNum">    9740 </span><span class="lineCov">      41894 :           return (AT_index (a) == NOT_INDEXED</span>
<span class="lineNum">    9741 </span><span class="lineNoCov">          0 :                   ? DW_FORM_addr : dwarf_FORM (DW_FORM_addrx));</span>
<span class="lineNum">    9742 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">    9743 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    9744 </span>            :         }
<span class="lineNum">    9745 </span><span class="lineNoCov">          0 :       switch (DWARF2_ADDR_SIZE)</span>
<span class="lineNum">    9746 </span>            :         {
<span class="lineNum">    9747 </span>            :         case 1:
<span class="lineNum">    9748 </span>            :           return DW_FORM_data1;
<span class="lineNum">    9749 </span>            :         case 2:
<span class="lineNum">    9750 </span>            :           return DW_FORM_data2;
<span class="lineNum">    9751 </span>            :         case 4:
<span class="lineNum">    9752 </span>            :           return DW_FORM_data4;
<span class="lineNum">    9753 </span>            :         case 8:
<span class="lineNum">    9754 </span>            :           return DW_FORM_data8;
<span class="lineNum">    9755 </span>            :         default:
<span class="lineNum">    9756 </span>            :           gcc_unreachable ();
<span class="lineNum">    9757 </span>            :         }
<span class="lineNum">    9758 </span><span class="lineCov">   23009816 :     case dw_val_class_loc_list:</span>
<span class="lineNum">    9759 </span><span class="lineCov">   23009816 :     case dw_val_class_view_list:</span>
<span class="lineNum">    9760 </span><span class="lineCov">   23009816 :       if (dwarf_split_debug_info</span>
<span class="lineNum">    9761 </span><span class="lineCov">         12 :           &amp;&amp; dwarf_version &gt;= 5</span>
<span class="lineNum">    9762 </span><span class="lineCov">   23009816 :           &amp;&amp; AT_loc_list (a)-&gt;num_assigned)</span>
<span class="lineNum">    9763 </span>            :         return DW_FORM_loclistx;
<span class="lineNum">    9764 </span>            :       /* FALLTHRU */
<span class="lineNum">    9765 </span><span class="lineCov">   28708108 :     case dw_val_class_range_list:</span>
<span class="lineNum">    9766 </span>            :       /* For range lists in DWARF 5, use DW_FORM_rnglistx from .debug_info.dwo
<span class="lineNum">    9767 </span>            :          but in .debug_info use DW_FORM_sec_offset, which is shorter if we
<span class="lineNum">    9768 </span>            :          care about sizes of .debug* sections in shared libraries and
<span class="lineNum">    9769 </span>            :          executables and don't take into account relocations that affect just
<span class="lineNum">    9770 </span>            :          relocatable objects - for DW_FORM_rnglistx we'd have to emit offset
<span class="lineNum">    9771 </span>            :          table in the .debug_rnglists section.  */
<span class="lineNum">    9772 </span><span class="lineCov">   28708108 :       if (dwarf_split_debug_info</span>
<span class="lineNum">    9773 </span><span class="lineCov">         24 :           &amp;&amp; dwarf_version &gt;= 5</span>
<span class="lineNum">    9774 </span><span class="lineNoCov">          0 :           &amp;&amp; AT_class (a) == dw_val_class_range_list</span>
<span class="lineNum">    9775 </span><span class="lineNoCov">          0 :           &amp;&amp; rnglist_idx</span>
<span class="lineNum">    9776 </span><span class="lineCov">   28708108 :           &amp;&amp; a-&gt;dw_attr_val.val_entry != RELOCATED_OFFSET)</span>
<span class="lineNum">    9777 </span>            :         return DW_FORM_rnglistx;
<span class="lineNum">    9778 </span><span class="lineCov">   28708108 :       if (dwarf_version &gt;= 4)</span>
<span class="lineNum">    9779 </span><span class="lineCov">   28697996 :         return DW_FORM_sec_offset;</span>
<span class="lineNum">    9780 </span>            :       /* FALLTHRU */
<span class="lineNum">    9781 </span>            :     case dw_val_class_vms_delta:
<span class="lineNum">    9782 </span>            :     case dw_val_class_offset:
<span class="lineNum">    9783 </span>            :       switch (DWARF_OFFSET_SIZE)
<span class="lineNum">    9784 </span>            :         {
<span class="lineNum">    9785 </span>            :         case 4:
<span class="lineNum">    9786 </span>            :           return DW_FORM_data4;
<span class="lineNum">    9787 </span>            :         case 8:
<span class="lineNum">    9788 </span>            :           return DW_FORM_data8;
<span class="lineNum">    9789 </span>            :         default:
<span class="lineNum">    9790 </span>            :           gcc_unreachable ();
<span class="lineNum">    9791 </span>            :         }
<span class="lineNum">    9792 </span><span class="lineCov">    9982457 :     case dw_val_class_loc:</span>
<span class="lineNum">    9793 </span><span class="lineCov">    9982457 :       if (dwarf_version &gt;= 4)</span>
<span class="lineNum">    9794 </span>            :         return DW_FORM_exprloc;
<span class="lineNum">    9795 </span><span class="lineCov">      32556 :       switch (constant_size (size_of_locs (AT_loc (a))))</span>
<span class="lineNum">    9796 </span>            :         {
<span class="lineNum">    9797 </span>            :         case 1:
<span class="lineNum">    9798 </span>            :           return DW_FORM_block1;
<span class="lineNum">    9799 </span><span class="lineNoCov">          0 :         case 2:</span>
<span class="lineNum">    9800 </span><span class="lineNoCov">          0 :           return DW_FORM_block2;</span>
<span class="lineNum">    9801 </span><span class="lineNoCov">          0 :         case 4:</span>
<span class="lineNum">    9802 </span><span class="lineNoCov">          0 :           return DW_FORM_block4;</span>
<span class="lineNum">    9803 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">    9804 </span><span class="lineNoCov">          0 :           gcc_unreachable ();</span>
<span class="lineNum">    9805 </span>            :         }
<span class="lineNum">    9806 </span>            :     case dw_val_class_const:
<span class="lineNum">    9807 </span>            :       return DW_FORM_sdata;
<span class="lineNum">    9808 </span><span class="lineCov">  141411363 :     case dw_val_class_unsigned_const:</span>
<span class="lineNum">    9809 </span><span class="lineCov">  282822726 :       switch (constant_size (AT_unsigned (a)))</span>
<span class="lineNum">    9810 </span>            :         {
<span class="lineNum">    9811 </span>            :         case 1:
<span class="lineNum">    9812 </span>            :           return DW_FORM_data1;
<span class="lineNum">    9813 </span><span class="lineCov">   35320146 :         case 2:</span>
<span class="lineNum">    9814 </span><span class="lineCov">   35320146 :           return DW_FORM_data2;</span>
<span class="lineNum">    9815 </span><span class="lineCov">     566724 :         case 4:</span>
<span class="lineNum">    9816 </span>            :           /* In DWARF3 DW_AT_data_member_location with
<span class="lineNum">    9817 </span>            :              DW_FORM_data4 or DW_FORM_data8 is a loclistptr, not
<span class="lineNum">    9818 </span>            :              constant, so we need to use DW_FORM_udata if we need
<span class="lineNum">    9819 </span>            :              a large constant.  */
<span class="lineNum">    9820 </span><span class="lineCov">     566724 :           if (dwarf_version == 3 &amp;&amp; a-&gt;dw_attr == DW_AT_data_member_location)</span>
<span class="lineNum">    9821 </span><span class="lineCov">          3 :             return DW_FORM_udata;</span>
<span class="lineNum">    9822 </span>            :           return DW_FORM_data4;
<span class="lineNum">    9823 </span><span class="lineCov">      73789 :         case 8:</span>
<span class="lineNum">    9824 </span><span class="lineCov">      73789 :           if (dwarf_version == 3 &amp;&amp; a-&gt;dw_attr == DW_AT_data_member_location)</span>
<span class="lineNum">    9825 </span><span class="lineNoCov">          0 :             return DW_FORM_udata;</span>
<span class="lineNum">    9826 </span>            :           return DW_FORM_data8;
<span class="lineNum">    9827 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">    9828 </span><span class="lineNoCov">          0 :           gcc_unreachable ();</span>
<span class="lineNum">    9829 </span>            :         }
<span class="lineNum">    9830 </span><span class="lineCov">         72 :     case dw_val_class_const_implicit:</span>
<span class="lineNum">    9831 </span><span class="lineCov">         72 :     case dw_val_class_unsigned_const_implicit:</span>
<span class="lineNum">    9832 </span><span class="lineCov">         72 :     case dw_val_class_file_implicit:</span>
<span class="lineNum">    9833 </span><span class="lineCov">         72 :       return DW_FORM_implicit_const;</span>
<span class="lineNum">    9834 </span><span class="lineNoCov">          0 :     case dw_val_class_const_double:</span>
<span class="lineNum">    9835 </span><span class="lineNoCov">          0 :       switch (HOST_BITS_PER_WIDE_INT)</span>
<span class="lineNum">    9836 </span>            :         {
<span class="lineNum">    9837 </span>            :         case 8:
<span class="lineNum">    9838 </span>            :           return DW_FORM_data2;
<span class="lineNum">    9839 </span>            :         case 16:
<span class="lineNum">    9840 </span>            :           return DW_FORM_data4;
<span class="lineNum">    9841 </span>            :         case 32:
<span class="lineNum">    9842 </span>            :           return DW_FORM_data8;
<span class="lineNum">    9843 </span><span class="lineNoCov">          0 :         case 64:</span>
<span class="lineNum">    9844 </span><span class="lineNoCov">          0 :           if (dwarf_version &gt;= 5)</span>
<span class="lineNum">    9845 </span><span class="lineNoCov">          0 :             return DW_FORM_data16;</span>
<span class="lineNum">    9846 </span>            :           /* FALLTHRU */
<span class="lineNum">    9847 </span>            :         default:
<span class="lineNum">    9848 </span>            :           return DW_FORM_block1;
<span class="lineNum">    9849 </span>            :         }
<span class="lineNum">    9850 </span><span class="lineCov">         18 :     case dw_val_class_wide_int:</span>
<span class="lineNum">    9851 </span><span class="lineCov">         18 :       switch (get_full_len (*a-&gt;dw_attr_val.v.val_wide) * HOST_BITS_PER_WIDE_INT)</span>
<span class="lineNum">    9852 </span>            :         {
<span class="lineNum">    9853 </span>            :         case 8:
<span class="lineNum">    9854 </span>            :           return DW_FORM_data1;
<span class="lineNum">    9855 </span><span class="lineNoCov">          0 :         case 16:</span>
<span class="lineNum">    9856 </span><span class="lineNoCov">          0 :           return DW_FORM_data2;</span>
<span class="lineNum">    9857 </span><span class="lineNoCov">          0 :         case 32:</span>
<span class="lineNum">    9858 </span><span class="lineNoCov">          0 :           return DW_FORM_data4;</span>
<span class="lineNum">    9859 </span><span class="lineCov">          8 :         case 64:</span>
<span class="lineNum">    9860 </span><span class="lineCov">          8 :           return DW_FORM_data8;</span>
<span class="lineNum">    9861 </span><span class="lineCov">         10 :         case 128:</span>
<span class="lineNum">    9862 </span><span class="lineCov">         10 :           if (dwarf_version &gt;= 5)</span>
<span class="lineNum">    9863 </span>            :             return DW_FORM_data16;
<span class="lineNum">    9864 </span>            :           /* FALLTHRU */
<span class="lineNum">    9865 </span><span class="lineCov">         10 :         default:</span>
<span class="lineNum">    9866 </span><span class="lineCov">         10 :           return DW_FORM_block1;</span>
<span class="lineNum">    9867 </span>            :         }
<span class="lineNum">    9868 </span><span class="lineCov">   12598520 :     case dw_val_class_symview:</span>
<span class="lineNum">    9869 </span>            :       /* ??? We might use uleb128, but then we'd have to compute
<span class="lineNum">    9870 </span>            :          .debug_info offsets in the assembler.  */
<span class="lineNum">    9871 </span><span class="lineCov">   12598520 :       if (symview_upper_bound &lt;= 0xff)</span>
<span class="lineNum">    9872 </span>            :         return DW_FORM_data1;
<span class="lineNum">    9873 </span><span class="lineCov">   11502268 :       else if (symview_upper_bound &lt;= 0xffff)</span>
<span class="lineNum">    9874 </span>            :         return DW_FORM_data2;
<span class="lineNum">    9875 </span><span class="lineNoCov">          0 :       else if (symview_upper_bound &lt;= 0xffffffff)</span>
<span class="lineNum">    9876 </span><span class="lineNoCov">          0 :         return DW_FORM_data4;</span>
<span class="lineNum">    9877 </span>            :       else
<span class="lineNum">    9878 </span>            :         return DW_FORM_data8;
<span class="lineNum">    9879 </span><span class="lineCov">     313059 :     case dw_val_class_vec:</span>
<span class="lineNum">    9880 </span><span class="lineCov">     313059 :       switch (constant_size (a-&gt;dw_attr_val.v.val_vec.length</span>
<span class="lineNum">    9881 </span><span class="lineCov">     313059 :                              * a-&gt;dw_attr_val.v.val_vec.elt_size))</span>
<span class="lineNum">    9882 </span>            :         {
<span class="lineNum">    9883 </span>            :         case 1:
<span class="lineNum">    9884 </span>            :           return DW_FORM_block1;
<span class="lineNum">    9885 </span><span class="lineCov">        513 :         case 2:</span>
<span class="lineNum">    9886 </span><span class="lineCov">        513 :           return DW_FORM_block2;</span>
<span class="lineNum">    9887 </span><span class="lineNoCov">          0 :         case 4:</span>
<span class="lineNum">    9888 </span><span class="lineNoCov">          0 :           return DW_FORM_block4;</span>
<span class="lineNum">    9889 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">    9890 </span><span class="lineNoCov">          0 :           gcc_unreachable ();</span>
<span class="lineNum">    9891 </span>            :         }
<span class="lineNum">    9892 </span><span class="lineCov">   63690410 :     case dw_val_class_flag:</span>
<span class="lineNum">    9893 </span><span class="lineCov">   63690410 :       if (dwarf_version &gt;= 4)</span>
<span class="lineNum">    9894 </span>            :         {
<span class="lineNum">    9895 </span>            :           /* Currently all add_AT_flag calls pass in 1 as last argument,
<span class="lineNum">    9896 </span>            :              so DW_FORM_flag_present can be used.  If that ever changes,
<span class="lineNum">    9897 </span>            :              we'll need to use DW_FORM_flag and have some optimization
<span class="lineNum">    9898 </span>            :              in build_abbrev_table that will change those to
<span class="lineNum">    9899 </span>            :              DW_FORM_flag_present if it is set to 1 in all DIEs using
<span class="lineNum">    9900 </span>            :              the same abbrev entry.  */
<span class="lineNum">    9901 </span><span class="lineCov">   63659208 :           gcc_assert (a-&gt;dw_attr_val.v.val_flag == 1);</span>
<span class="lineNum">    9902 </span>            :           return DW_FORM_flag_present;
<span class="lineNum">    9903 </span>            :         }
<span class="lineNum">    9904 </span>            :       return DW_FORM_flag;
<span class="lineNum">    9905 </span><span class="lineCov">  114208658 :     case dw_val_class_die_ref:</span>
<span class="lineNum">    9906 </span><span class="lineCov">  114208658 :       if (AT_ref_external (a))</span>
<span class="lineNum">    9907 </span><span class="lineCov">     112968 :         return use_debug_types ? DW_FORM_ref_sig8 : DW_FORM_ref_addr;</span>
<span class="lineNum">    9908 </span>            :       else
<span class="lineNum">    9909 </span>            :         return DW_FORM_ref;
<span class="lineNum">    9910 </span><span class="lineNoCov">          0 :     case dw_val_class_fde_ref:</span>
<span class="lineNum">    9911 </span><span class="lineNoCov">          0 :       return DW_FORM_data;</span>
<span class="lineNum">    9912 </span><span class="lineCov">   24374856 :     case dw_val_class_lbl_id:</span>
<span class="lineNum">    9913 </span><span class="lineCov">   24374856 :       return (AT_index (a) == NOT_INDEXED</span>
<span class="lineNum">    9914 </span><span class="lineCov">         28 :               ? DW_FORM_addr : dwarf_FORM (DW_FORM_addrx));</span>
<span class="lineNum">    9915 </span><span class="lineCov">      69966 :     case dw_val_class_lineptr:</span>
<span class="lineNum">    9916 </span><span class="lineCov">      69966 :     case dw_val_class_macptr:</span>
<span class="lineNum">    9917 </span><span class="lineCov">      69966 :     case dw_val_class_loclistsptr:</span>
<span class="lineNum">    9918 </span><span class="lineCov">      69966 :       return dwarf_version &gt;= 4 ? DW_FORM_sec_offset : DW_FORM_data;</span>
<span class="lineNum">    9919 </span><span class="lineCov">   96991572 :     case dw_val_class_str:</span>
<span class="lineNum">    9920 </span><span class="lineCov">   96991572 :       return AT_string_form (a);</span>
<span class="lineNum">    9921 </span><span class="lineCov">   72005980 :     case dw_val_class_file:</span>
<span class="lineNum">    9922 </span><span class="lineCov">  144011960 :       switch (constant_size (maybe_emit_file (a-&gt;dw_attr_val.v.val_file)))</span>
<span class="lineNum">    9923 </span>            :         {
<span class="lineNum">    9924 </span>            :         case 1:
<span class="lineNum">    9925 </span>            :           return DW_FORM_data1;
<span class="lineNum">    9926 </span><span class="lineNoCov">          0 :         case 2:</span>
<span class="lineNum">    9927 </span><span class="lineNoCov">          0 :           return DW_FORM_data2;</span>
<span class="lineNum">    9928 </span><span class="lineNoCov">          0 :         case 4:</span>
<span class="lineNum">    9929 </span><span class="lineNoCov">          0 :           return DW_FORM_data4;</span>
<span class="lineNum">    9930 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">    9931 </span><span class="lineNoCov">          0 :           gcc_unreachable ();</span>
<span class="lineNum">    9932 </span>            :         }
<span class="lineNum">    9933 </span>            : 
<span class="lineNum">    9934 </span><span class="lineCov">        108 :     case dw_val_class_data8:</span>
<span class="lineNum">    9935 </span><span class="lineCov">        108 :       return DW_FORM_data8;</span>
<span class="lineNum">    9936 </span>            : 
<span class="lineNum">    9937 </span><span class="lineCov">    7194058 :     case dw_val_class_high_pc:</span>
<span class="lineNum">    9938 </span><span class="lineCov">    7194058 :       switch (DWARF2_ADDR_SIZE)</span>
<span class="lineNum">    9939 </span>            :         {
<span class="lineNum">    9940 </span>            :         case 1:
<span class="lineNum">    9941 </span>            :           return DW_FORM_data1;
<span class="lineNum">    9942 </span>            :         case 2:
<span class="lineNum">    9943 </span>            :           return DW_FORM_data2;
<span class="lineNum">    9944 </span>            :         case 4:
<span class="lineNum">    9945 </span>            :           return DW_FORM_data4;
<span class="lineNum">    9946 </span>            :         case 8:
<span class="lineNum">    9947 </span>            :           return DW_FORM_data8;
<span class="lineNum">    9948 </span>            :         default:
<span class="lineNum">    9949 </span>            :           gcc_unreachable ();
<span class="lineNum">    9950 </span>            :         }
<span class="lineNum">    9951 </span>            : 
<span class="lineNum">    9952 </span><span class="lineNoCov">          0 :     case dw_val_class_discr_value:</span>
<span class="lineNum">    9953 </span><span class="lineNoCov">          0 :       return (a-&gt;dw_attr_val.v.val_discr_value.pos</span>
<span class="lineNum">    9954 </span><span class="lineNoCov">          0 :               ? DW_FORM_udata</span>
<span class="lineNum">    9955 </span>            :               : DW_FORM_sdata);
<span class="lineNum">    9956 </span><span class="lineNoCov">          0 :     case dw_val_class_discr_list:</span>
<span class="lineNum">    9957 </span><span class="lineNoCov">          0 :       switch (constant_size (size_of_discr_list (AT_discr_list (a))))</span>
<span class="lineNum">    9958 </span>            :         {
<span class="lineNum">    9959 </span>            :         case 1:
<span class="lineNum">    9960 </span>            :           return DW_FORM_block1;
<span class="lineNum">    9961 </span><span class="lineNoCov">          0 :         case 2:</span>
<span class="lineNum">    9962 </span><span class="lineNoCov">          0 :           return DW_FORM_block2;</span>
<span class="lineNum">    9963 </span><span class="lineNoCov">          0 :         case 4:</span>
<span class="lineNum">    9964 </span><span class="lineNoCov">          0 :           return DW_FORM_block4;</span>
<span class="lineNum">    9965 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">    9966 </span><span class="lineNoCov">          0 :           gcc_unreachable ();</span>
<span class="lineNum">    9967 </span>            :         }
<span class="lineNum">    9968 </span>            : 
<span class="lineNum">    9969 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">    9970 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">    9971 </span>            :     }
<span class="lineNum">    9972 </span>            : }
<span class="lineNum">    9973 </span>            : 
<span class="lineNum">    9974 </span>            : /* Output the encoding of an attribute value.  */
<a name="9975"><span class="lineNum">    9975 </span>            : </a>
<span class="lineNum">    9976 </span>            : static void
<span class="lineNum">    9977 </span><span class="lineCov">   11444014 : output_value_format (dw_attr_node *a)</span>
<span class="lineNum">    9978 </span>            : {
<span class="lineNum">    9979 </span><span class="lineCov">   11444014 :   enum dwarf_form form = value_format (a);</span>
<span class="lineNum">    9980 </span>            : 
<span class="lineNum">    9981 </span><span class="lineCov">   22888028 :   dw2_asm_output_data_uleb128 (form, &quot;(%s)&quot;, dwarf_form_name (form));</span>
<span class="lineNum">    9982 </span><span class="lineCov">   11444014 : }</span>
<span class="lineNum">    9983 </span>            : 
<span class="lineNum">    9984 </span>            : /* Given a die and id, produce the appropriate abbreviations.  */
<a name="9985"><span class="lineNum">    9985 </span>            : </a>
<span class="lineNum">    9986 </span>            : static void
<span class="lineNum">    9987 </span><span class="lineCov">    2107270 : output_die_abbrevs (unsigned long abbrev_id, dw_die_ref abbrev)</span>
<span class="lineNum">    9988 </span>            : {
<span class="lineNum">    9989 </span><span class="lineCov">    2107270 :   unsigned ix;</span>
<span class="lineNum">    9990 </span><span class="lineCov">    2107270 :   dw_attr_node *a_attr;</span>
<span class="lineNum">    9991 </span>            : 
<span class="lineNum">    9992 </span><span class="lineCov">    2107270 :   dw2_asm_output_data_uleb128 (abbrev_id, &quot;(abbrev code)&quot;);</span>
<span class="lineNum">    9993 </span><span class="lineCov">    2107270 :   dw2_asm_output_data_uleb128 (abbrev-&gt;die_tag, &quot;(TAG: %s)&quot;,</span>
<span class="lineNum">    9994 </span><span class="lineCov">    2107270 :                                dwarf_tag_name (abbrev-&gt;die_tag));</span>
<span class="lineNum">    9995 </span>            : 
<span class="lineNum">    9996 </span><span class="lineCov">    2107270 :   if (abbrev-&gt;die_child != NULL)</span>
<span class="lineNum">    9997 </span><span class="lineCov">     853118 :     dw2_asm_output_data (1, DW_children_yes, &quot;DW_children_yes&quot;);</span>
<span class="lineNum">    9998 </span>            :   else
<span class="lineNum">    9999 </span><span class="lineCov">    1254152 :     dw2_asm_output_data (1, DW_children_no, &quot;DW_children_no&quot;);</span>
<span class="lineNum">   10000 </span>            : 
<span class="lineNum">   10001 </span><span class="lineCov">   13551284 :   for (ix = 0; vec_safe_iterate (abbrev-&gt;die_attr, ix, &amp;a_attr); ix++)</span>
<span class="lineNum">   10002 </span>            :     {
<span class="lineNum">   10003 </span><span class="lineCov">   11444014 :       dw2_asm_output_data_uleb128 (a_attr-&gt;dw_attr, &quot;(%s)&quot;,</span>
<span class="lineNum">   10004 </span><span class="lineCov">   11444014 :                                    dwarf_attr_name (a_attr-&gt;dw_attr));</span>
<span class="lineNum">   10005 </span><span class="lineCov">   11444014 :       output_value_format (a_attr);</span>
<span class="lineNum">   10006 </span><span class="lineCov">   11444014 :       if (value_format (a_attr) == DW_FORM_implicit_const)</span>
<span class="lineNum">   10007 </span>            :         {
<span class="lineNum">   10008 </span><span class="lineCov">         36 :           if (AT_class (a_attr) == dw_val_class_file_implicit)</span>
<span class="lineNum">   10009 </span>            :             {
<span class="lineNum">   10010 </span><span class="lineCov">         21 :               int f = maybe_emit_file (a_attr-&gt;dw_attr_val.v.val_file);</span>
<span class="lineNum">   10011 </span><span class="lineCov">         21 :               const char *filename = a_attr-&gt;dw_attr_val.v.val_file-&gt;filename;</span>
<span class="lineNum">   10012 </span><span class="lineCov">         21 :               dw2_asm_output_data_sleb128 (f, &quot;(%s)&quot;, filename);</span>
<span class="lineNum">   10013 </span>            :             }
<span class="lineNum">   10014 </span>            :           else
<span class="lineNum">   10015 </span><span class="lineCov">         15 :             dw2_asm_output_data_sleb128 (a_attr-&gt;dw_attr_val.v.val_int, NULL);</span>
<span class="lineNum">   10016 </span>            :         }
<span class="lineNum">   10017 </span>            :     }
<span class="lineNum">   10018 </span>            : 
<span class="lineNum">   10019 </span><span class="lineCov">    2107270 :   dw2_asm_output_data (1, 0, NULL);</span>
<span class="lineNum">   10020 </span><span class="lineCov">    2107270 :   dw2_asm_output_data (1, 0, NULL);</span>
<span class="lineNum">   10021 </span><span class="lineCov">    2107270 : }</span>
<span class="lineNum">   10022 </span>            : 
<span class="lineNum">   10023 </span>            : 
<span class="lineNum">   10024 </span>            : /* Output the .debug_abbrev section which defines the DIE abbreviation
<span class="lineNum">   10025 </span>            :    table.  */
<a name="10026"><span class="lineNum">   10026 </span>            : </a>
<span class="lineNum">   10027 </span>            : static void
<span class="lineNum">   10028 </span><span class="lineCov">      34110 : output_abbrev_section (void)</span>
<span class="lineNum">   10029 </span>            : {
<span class="lineNum">   10030 </span><span class="lineCov">      34110 :   unsigned int abbrev_id;</span>
<span class="lineNum">   10031 </span><span class="lineCov">      34110 :   dw_die_ref abbrev;</span>
<span class="lineNum">   10032 </span>            : 
<span class="lineNum">   10033 </span><span class="lineCov">    2175486 :   FOR_EACH_VEC_SAFE_ELT (abbrev_die_table, abbrev_id, abbrev)</span>
<span class="lineNum">   10034 </span><span class="lineCov">    2141376 :     if (abbrev_id != 0)</span>
<span class="lineNum">   10035 </span><span class="lineCov">    2107266 :       output_die_abbrevs (abbrev_id, abbrev);</span>
<span class="lineNum">   10036 </span>            : 
<span class="lineNum">   10037 </span>            :   /* Terminate the table.  */
<span class="lineNum">   10038 </span><span class="lineCov">      34110 :   dw2_asm_output_data (1, 0, NULL);</span>
<span class="lineNum">   10039 </span><span class="lineCov">      34110 : }</span>
<span class="lineNum">   10040 </span>            : 
<span class="lineNum">   10041 </span>            : /* Return a new location list, given the begin and end range, and the
<span class="lineNum">   10042 </span>            :    expression.  */
<span class="lineNum">   10043 </span>            : 
<span class="lineNum">   10044 </span>            : static inline dw_loc_list_ref
<span class="lineNum">   10045 </span>            : new_loc_list (dw_loc_descr_ref expr, const char *begin, var_loc_view vbegin,
<span class="lineNum">   10046 </span>            :               const char *end, var_loc_view vend,
<span class="lineNum">   10047 </span>            :               const char *section)
<span class="lineNum">   10048 </span>            : {
<span class="lineNum">   10049 </span><span class="lineCov">   35392936 :   dw_loc_list_ref retlist = ggc_cleared_alloc&lt;dw_loc_list_node&gt; ();</span>
<span class="lineNum">   10050 </span>            : 
<span class="lineNum">   10051 </span><span class="lineCov">   17696468 :   retlist-&gt;begin = begin;</span>
<span class="lineNum">   10052 </span><span class="lineCov">   17696468 :   retlist-&gt;begin_entry = NULL;</span>
<span class="lineNum">   10053 </span><span class="lineCov">   17696468 :   retlist-&gt;end = end;</span>
<span class="lineNum">   10054 </span><span class="lineCov">   17696468 :   retlist-&gt;expr = expr;</span>
<span class="lineNum">   10055 </span><span class="lineCov">   17696468 :   retlist-&gt;section = section;</span>
<span class="lineNum">   10056 </span><span class="lineCov">   17696468 :   retlist-&gt;vbegin = vbegin;</span>
<span class="lineNum">   10057 </span><span class="lineCov">   17696468 :   retlist-&gt;vend = vend;</span>
<span class="lineNum">   10058 </span>            : 
<span class="lineNum">   10059 </span><span class="lineCov">   17696468 :   return retlist;</span>
<span class="lineNum">   10060 </span>            : }
<span class="lineNum">   10061 </span>            : 
<span class="lineNum">   10062 </span>            : /* Return true iff there's any nonzero view number in the loc list.
<span class="lineNum">   10063 </span>            : 
<span class="lineNum">   10064 </span>            :    ??? When views are not enabled, we'll often extend a single range
<span class="lineNum">   10065 </span>            :    to the entire function, so that we emit a single location
<span class="lineNum">   10066 </span>            :    expression rather than a location list.  With views, even with a
<span class="lineNum">   10067 </span>            :    single range, we'll output a list if start or end have a nonzero
<span class="lineNum">   10068 </span>            :    view.  If we change this, we may want to stop splitting a single
<span class="lineNum">   10069 </span>            :    range in dw_loc_list just because of a nonzero view, even if it
<span class="lineNum">   10070 </span>            :    straddles across hot/cold partitions.  */
<a name="10071"><span class="lineNum">   10071 </span>            : </a>
<span class="lineNum">   10072 </span>            : static bool
<span class="lineNum">   10073 </span><span class="lineCov">   12151328 : loc_list_has_views (dw_loc_list_ref list)</span>
<span class="lineNum">   10074 </span>            : {
<span class="lineNum">   10075 </span><span class="lineCov">   12151328 :   if (!debug_variable_location_views)</span>
<span class="lineNum">   10076 </span>            :     return false;
<span class="lineNum">   10077 </span>            : 
<span class="lineNum">   10078 </span><span class="lineCov">     726698 :   for (dw_loc_list_ref loc = list;</span>
<span class="lineNum">   10079 </span><span class="lineCov">   12874906 :        loc != NULL; loc = loc-&gt;dw_loc_next)</span>
<span class="lineNum">   10080 </span><span class="lineCov">   12439773 :     if (!ZERO_VIEW_P (loc-&gt;vbegin) || !ZERO_VIEW_P (loc-&gt;vend))</span>
<span class="lineNum">   10081 </span><span class="lineCov">   11713075 :       return true;</span>
<span class="lineNum">   10082 </span>            : 
<span class="lineNum">   10083 </span>            :   return false;
<span class="lineNum">   10084 </span>            : }
<span class="lineNum">   10085 </span>            : 
<span class="lineNum">   10086 </span>            : /* Generate a new internal symbol for this location list node, if it
<span class="lineNum">   10087 </span>            :    hasn't got one yet.  */
<a name="10088"><span class="lineNum">   10088 </span>            : </a>
<span class="lineNum">   10089 </span>            : static inline void
<span class="lineNum">   10090 </span><span class="lineCov">    6136233 : gen_llsym (dw_loc_list_ref list)</span>
<span class="lineNum">   10091 </span>            : {
<span class="lineNum">   10092 </span><span class="lineCov">    6136233 :   gcc_assert (!list-&gt;ll_symbol);</span>
<span class="lineNum">   10093 </span><span class="lineCov">    6136233 :   list-&gt;ll_symbol = gen_internal_sym (&quot;LLST&quot;);</span>
<span class="lineNum">   10094 </span>            : 
<span class="lineNum">   10095 </span><span class="lineCov">    6136233 :   if (!loc_list_has_views (list))</span>
<span class="lineNum">   10096 </span>            :     return;
<span class="lineNum">   10097 </span>            : 
<span class="lineNum">   10098 </span><span class="lineCov">    6051741 :   if (dwarf2out_locviews_in_attribute ())</span>
<span class="lineNum">   10099 </span>            :     {
<span class="lineNum">   10100 </span>            :       /* Use the same label_num for the view list.  */
<span class="lineNum">   10101 </span><span class="lineCov">    6051741 :       label_num--;</span>
<span class="lineNum">   10102 </span><span class="lineCov">    6051741 :       list-&gt;vl_symbol = gen_internal_sym (&quot;LVUS&quot;);</span>
<span class="lineNum">   10103 </span>            :     }
<span class="lineNum">   10104 </span>            :   else
<span class="lineNum">   10105 </span><span class="lineNoCov">          0 :     list-&gt;vl_symbol = list-&gt;ll_symbol;</span>
<span class="lineNum">   10106 </span>            : }
<span class="lineNum">   10107 </span>            : 
<span class="lineNum">   10108 </span>            : /* Generate a symbol for the list, but only if we really want to emit
<span class="lineNum">   10109 </span>            :    it as a list.  */
<a name="10110"><span class="lineNum">   10110 </span>            : </a>
<span class="lineNum">   10111 </span>            : static inline void
<span class="lineNum">   10112 </span><span class="lineCov">     668085 : maybe_gen_llsym (dw_loc_list_ref list)</span>
<span class="lineNum">   10113 </span>            : {
<span class="lineNum">   10114 </span><span class="lineCov">     668085 :   if (!list || (!list-&gt;dw_loc_next &amp;&amp; !loc_list_has_views (list)))</span>
<span class="lineNum">   10115 </span><span class="lineCov">     605324 :     return;</span>
<span class="lineNum">   10116 </span>            : 
<span class="lineNum">   10117 </span><span class="lineCov">      62761 :   gen_llsym (list);</span>
<span class="lineNum">   10118 </span>            : }
<span class="lineNum">   10119 </span>            : 
<span class="lineNum">   10120 </span>            : /* Determine whether or not to skip loc_list entry CURR.  If SIZEP is
<span class="lineNum">   10121 </span>            :    NULL, don't consider size of the location expression.  If we're not
<span class="lineNum">   10122 </span>            :    to skip it, and SIZEP is non-null, store the size of CURR-&gt;expr's
<span class="lineNum">   10123 </span>            :    representation in *SIZEP.  */
<a name="10124"><span class="lineNum">   10124 </span>            : </a>
<span class="lineNum">   10125 </span>            : static bool
<span class="lineNum">   10126 </span><span class="lineCov">   29128492 : skip_loc_list_entry (dw_loc_list_ref curr, unsigned long *sizep = NULL)</span>
<span class="lineNum">   10127 </span>            : {
<span class="lineNum">   10128 </span>            :   /* Don't output an entry that starts and ends at the same address.  */
<span class="lineNum">   10129 </span><span class="lineCov">   29128492 :   if (strcmp (curr-&gt;begin, curr-&gt;end) == 0</span>
<span class="lineNum">   10130 </span><span class="lineCov">    2518229 :       &amp;&amp; curr-&gt;vbegin == curr-&gt;vend &amp;&amp; !curr-&gt;force)</span>
<span class="lineNum">   10131 </span>            :     return true;
<span class="lineNum">   10132 </span>            : 
<span class="lineNum">   10133 </span><span class="lineCov">   29128472 :   if (!sizep)</span>
<span class="lineNum">   10134 </span>            :     return false;
<span class="lineNum">   10135 </span>            : 
<span class="lineNum">   10136 </span><span class="lineCov">   29128467 :   unsigned long size = size_of_locs (curr-&gt;expr);</span>
<span class="lineNum">   10137 </span>            : 
<span class="lineNum">   10138 </span>            :   /* If the expression is too large, drop it on the floor.  We could
<span class="lineNum">   10139 </span>            :      perhaps put it into DW_TAG_dwarf_procedure and refer to that
<span class="lineNum">   10140 </span>            :      in the expression, but &gt;= 64KB expressions for a single value
<span class="lineNum">   10141 </span>            :      in a single range are unlikely very useful.  */
<span class="lineNum">   10142 </span><span class="lineCov">   29128467 :   if (dwarf_version &lt; 5 &amp;&amp; size &gt; 0xffff)</span>
<span class="lineNum">   10143 </span>            :     return true;
<span class="lineNum">   10144 </span>            : 
<span class="lineNum">   10145 </span><span class="lineCov">   29128467 :   *sizep = size;</span>
<span class="lineNum">   10146 </span>            : 
<span class="lineNum">   10147 </span><span class="lineCov">   29128467 :   return false;</span>
<span class="lineNum">   10148 </span>            : }
<span class="lineNum">   10149 </span>            : 
<span class="lineNum">   10150 </span>            : /* Output a view pair loclist entry for CURR, if it requires one.  */
<a name="10151"><span class="lineNum">   10151 </span>            : </a>
<span class="lineNum">   10152 </span>            : static void
<span class="lineNum">   10153 </span><span class="lineCov">         27 : dwarf2out_maybe_output_loclist_view_pair (dw_loc_list_ref curr)</span>
<span class="lineNum">   10154 </span>            : {
<span class="lineNum">   10155 </span><span class="lineCov">         27 :   if (!dwarf2out_locviews_in_loclist ())</span>
<span class="lineNum">   10156 </span>            :     return;
<span class="lineNum">   10157 </span>            : 
<span class="lineNum">   10158 </span><span class="lineNoCov">          0 :   if (ZERO_VIEW_P (curr-&gt;vbegin) &amp;&amp; ZERO_VIEW_P (curr-&gt;vend))</span>
<span class="lineNum">   10159 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">   10160 </span>            : 
<span class="lineNum">   10161 </span>            : #ifdef DW_LLE_view_pair
<span class="lineNum">   10162 </span><span class="lineNoCov">          0 :   dw2_asm_output_data (1, DW_LLE_view_pair, &quot;DW_LLE_view_pair&quot;);</span>
<span class="lineNum">   10163 </span>            : 
<span class="lineNum">   10164 </span><span class="lineNoCov">          0 :   if (dwarf2out_as_locview_support)</span>
<span class="lineNum">   10165 </span>            :     {
<span class="lineNum">   10166 </span><span class="lineNoCov">          0 :       if (ZERO_VIEW_P (curr-&gt;vbegin))</span>
<span class="lineNum">   10167 </span><span class="lineNoCov">          0 :         dw2_asm_output_data_uleb128 (0, &quot;Location view begin&quot;);</span>
<span class="lineNum">   10168 </span>            :       else
<span class="lineNum">   10169 </span>            :         {
<span class="lineNum">   10170 </span><span class="lineNoCov">          0 :           char label[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">   10171 </span><span class="lineNoCov">          0 :           ASM_GENERATE_INTERNAL_LABEL (label, &quot;LVU&quot;, curr-&gt;vbegin);</span>
<span class="lineNum">   10172 </span><span class="lineNoCov">          0 :           dw2_asm_output_symname_uleb128 (label, &quot;Location view begin&quot;);</span>
<span class="lineNum">   10173 </span>            :         }
<span class="lineNum">   10174 </span>            : 
<span class="lineNum">   10175 </span><span class="lineNoCov">          0 :       if (ZERO_VIEW_P (curr-&gt;vend))</span>
<span class="lineNum">   10176 </span><span class="lineNoCov">          0 :         dw2_asm_output_data_uleb128 (0, &quot;Location view end&quot;);</span>
<span class="lineNum">   10177 </span>            :       else
<span class="lineNum">   10178 </span>            :         {
<span class="lineNum">   10179 </span><span class="lineNoCov">          0 :           char label[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">   10180 </span><span class="lineNoCov">          0 :           ASM_GENERATE_INTERNAL_LABEL (label, &quot;LVU&quot;, curr-&gt;vend);</span>
<span class="lineNum">   10181 </span><span class="lineNoCov">          0 :           dw2_asm_output_symname_uleb128 (label, &quot;Location view end&quot;);</span>
<span class="lineNum">   10182 </span>            :         }
<span class="lineNum">   10183 </span>            :     }
<span class="lineNum">   10184 </span>            :   else
<span class="lineNum">   10185 </span>            :     {
<span class="lineNum">   10186 </span><span class="lineNoCov">          0 :       dw2_asm_output_data_uleb128 (curr-&gt;vbegin, &quot;Location view begin&quot;);</span>
<span class="lineNum">   10187 </span><span class="lineNoCov">          0 :       dw2_asm_output_data_uleb128 (curr-&gt;vend, &quot;Location view end&quot;);</span>
<span class="lineNum">   10188 </span>            :     }
<span class="lineNum">   10189 </span>            : #endif /* DW_LLE_view_pair */
<span class="lineNum">   10190 </span>            : 
<span class="lineNum">   10191 </span>            :   return;
<span class="lineNum">   10192 </span>            : }
<span class="lineNum">   10193 </span>            : 
<span class="lineNum">   10194 </span>            : /* Output the location list given to us.  */
<a name="10195"><span class="lineNum">   10195 </span>            : </a>
<span class="lineNum">   10196 </span>            : static void
<span class="lineNum">   10197 </span><span class="lineCov">    5791298 : output_loc_list (dw_loc_list_ref list_head)</span>
<span class="lineNum">   10198 </span>            : {
<span class="lineNum">   10199 </span><span class="lineCov">    5791298 :   int vcount = 0, lcount = 0;</span>
<span class="lineNum">   10200 </span>            : 
<span class="lineNum">   10201 </span><span class="lineCov">    5791298 :   if (list_head-&gt;emitted)</span>
<span class="lineNum">   10202 </span>            :     return;
<span class="lineNum">   10203 </span><span class="lineCov">    5688514 :   list_head-&gt;emitted = true;</span>
<span class="lineNum">   10204 </span>            : 
<span class="lineNum">   10205 </span><span class="lineCov">    5688514 :   if (list_head-&gt;vl_symbol &amp;&amp; dwarf2out_locviews_in_attribute ())</span>
<span class="lineNum">   10206 </span>            :     {
<span class="lineNum">   10207 </span><span class="lineCov">    5604029 :       ASM_OUTPUT_LABEL (asm_out_file, list_head-&gt;vl_symbol);</span>
<span class="lineNum">   10208 </span>            : 
<span class="lineNum">   10209 </span><span class="lineCov">   20051903 :       for (dw_loc_list_ref curr = list_head; curr != NULL;</span>
<span class="lineNum">   10210 </span><span class="lineCov">   14447874 :            curr = curr-&gt;dw_loc_next)</span>
<span class="lineNum">   10211 </span>            :         {
<span class="lineNum">   10212 </span><span class="lineCov">   14447874 :           unsigned long size;</span>
<span class="lineNum">   10213 </span>            : 
<span class="lineNum">   10214 </span><span class="lineCov">   14447874 :           if (skip_loc_list_entry (curr, &amp;size))</span>
<span class="lineNum">   10215 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">   10216 </span>            : 
<span class="lineNum">   10217 </span><span class="lineCov">   14447874 :           vcount++;</span>
<span class="lineNum">   10218 </span>            : 
<span class="lineNum">   10219 </span>            :           /* ?? dwarf_split_debug_info?  */
<span class="lineNum">   10220 </span><span class="lineCov">   14447874 :           if (dwarf2out_as_locview_support)</span>
<span class="lineNum">   10221 </span>            :             {
<span class="lineNum">   10222 </span><span class="lineCov">   14447874 :               char label[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">   10223 </span>            : 
<span class="lineNum">   10224 </span><span class="lineCov">   14447874 :               if (!ZERO_VIEW_P (curr-&gt;vbegin))</span>
<span class="lineNum">   10225 </span>            :                 {
<span class="lineNum">   10226 </span><span class="lineCov">   14094008 :                   ASM_GENERATE_INTERNAL_LABEL (label, &quot;LVU&quot;, curr-&gt;vbegin);</span>
<span class="lineNum">   10227 </span><span class="lineCov">   14094008 :                   dw2_asm_output_symname_uleb128 (label,</span>
<span class="lineNum">   10228 </span>            :                                                   &quot;View list begin (%s)&quot;,
<span class="lineNum">   10229 </span>            :                                                   list_head-&gt;vl_symbol);
<span class="lineNum">   10230 </span>            :                 }
<span class="lineNum">   10231 </span>            :               else
<span class="lineNum">   10232 </span><span class="lineCov">     353866 :                 dw2_asm_output_data_uleb128 (0,</span>
<span class="lineNum">   10233 </span>            :                                              &quot;View list begin (%s)&quot;,
<span class="lineNum">   10234 </span>            :                                              list_head-&gt;vl_symbol);
<span class="lineNum">   10235 </span>            : 
<span class="lineNum">   10236 </span><span class="lineCov">   14447874 :               if (!ZERO_VIEW_P (curr-&gt;vend))</span>
<span class="lineNum">   10237 </span>            :                 {
<span class="lineNum">   10238 </span><span class="lineCov">   13691294 :                   ASM_GENERATE_INTERNAL_LABEL (label, &quot;LVU&quot;, curr-&gt;vend);</span>
<span class="lineNum">   10239 </span><span class="lineCov">   13691294 :                   dw2_asm_output_symname_uleb128 (label,</span>
<span class="lineNum">   10240 </span>            :                                                   &quot;View list end (%s)&quot;,
<span class="lineNum">   10241 </span>            :                                                   list_head-&gt;vl_symbol);
<span class="lineNum">   10242 </span>            :                 }
<span class="lineNum">   10243 </span>            :               else
<span class="lineNum">   10244 </span><span class="lineCov">     756580 :                 dw2_asm_output_data_uleb128 (0,</span>
<span class="lineNum">   10245 </span>            :                                              &quot;View list end (%s)&quot;,
<span class="lineNum">   10246 </span>            :                                              list_head-&gt;vl_symbol);
<span class="lineNum">   10247 </span>            :             }
<span class="lineNum">   10248 </span>            :           else
<span class="lineNum">   10249 </span>            :             {
<span class="lineNum">   10250 </span><span class="lineNoCov">          0 :               dw2_asm_output_data_uleb128 (curr-&gt;vbegin,</span>
<span class="lineNum">   10251 </span>            :                                            &quot;View list begin (%s)&quot;,
<span class="lineNum">   10252 </span>            :                                            list_head-&gt;vl_symbol);
<span class="lineNum">   10253 </span><span class="lineNoCov">          0 :               dw2_asm_output_data_uleb128 (curr-&gt;vend,</span>
<span class="lineNum">   10254 </span>            :                                            &quot;View list end (%s)&quot;,
<span class="lineNum">   10255 </span>            :                                            list_head-&gt;vl_symbol);
<span class="lineNum">   10256 </span>            :             }
<span class="lineNum">   10257 </span>            :         }
<span class="lineNum">   10258 </span>            :     }
<span class="lineNum">   10259 </span>            : 
<span class="lineNum">   10260 </span><span class="lineCov">    5688514 :   ASM_OUTPUT_LABEL (asm_out_file, list_head-&gt;ll_symbol);</span>
<span class="lineNum">   10261 </span>            : 
<span class="lineNum">   10262 </span><span class="lineCov">    5688514 :   const char *last_section = NULL;</span>
<span class="lineNum">   10263 </span><span class="lineCov">    5688514 :   const char *base_label = NULL;</span>
<span class="lineNum">   10264 </span>            : 
<span class="lineNum">   10265 </span>            :   /* Walk the location list, and output each range + expression.  */
<span class="lineNum">   10266 </span><span class="lineCov">   20369127 :   for (dw_loc_list_ref curr = list_head; curr != NULL;</span>
<span class="lineNum">   10267 </span><span class="lineCov">   14680613 :        curr = curr-&gt;dw_loc_next)</span>
<span class="lineNum">   10268 </span>            :     {
<span class="lineNum">   10269 </span><span class="lineCov">   14680613 :       unsigned long size;</span>
<span class="lineNum">   10270 </span>            : 
<span class="lineNum">   10271 </span>            :       /* Skip this entry?  If we skip it here, we must skip it in the
<span class="lineNum">   10272 </span>            :          view list above as well. */
<span class="lineNum">   10273 </span><span class="lineCov">   14680613 :       if (skip_loc_list_entry (curr, &amp;size))</span>
<span class="lineNum">   10274 </span><span class="lineCov">         20 :         continue;</span>
<span class="lineNum">   10275 </span>            : 
<span class="lineNum">   10276 </span><span class="lineCov">   14680593 :       lcount++;</span>
<span class="lineNum">   10277 </span>            : 
<span class="lineNum">   10278 </span><span class="lineCov">   14680593 :       if (dwarf_version &gt;= 5)</span>
<span class="lineNum">   10279 </span>            :         {
<span class="lineNum">   10280 </span><span class="lineCov">         27 :           if (dwarf_split_debug_info)</span>
<span class="lineNum">   10281 </span>            :             {
<span class="lineNum">   10282 </span><span class="lineNoCov">          0 :               dwarf2out_maybe_output_loclist_view_pair (curr);</span>
<span class="lineNum">   10283 </span>            :               /* For -gsplit-dwarf, emit DW_LLE_starx_length, which has
<span class="lineNum">   10284 </span>            :                  uleb128 index into .debug_addr and uleb128 length.  */
<span class="lineNum">   10285 </span><span class="lineNoCov">          0 :               dw2_asm_output_data (1, DW_LLE_startx_length,</span>
<span class="lineNum">   10286 </span>            :                                    &quot;DW_LLE_startx_length (%s)&quot;,
<span class="lineNum">   10287 </span>            :                                    list_head-&gt;ll_symbol);
<span class="lineNum">   10288 </span><span class="lineNoCov">          0 :               dw2_asm_output_data_uleb128 (curr-&gt;begin_entry-&gt;index,</span>
<span class="lineNum">   10289 </span>            :                                            &quot;Location list range start index &quot;
<span class="lineNum">   10290 </span>            :                                            &quot;(%s)&quot;, curr-&gt;begin);
<span class="lineNum">   10291 </span>            :               /* FIXME: This will ICE ifndef HAVE_AS_LEB128.
<span class="lineNum">   10292 </span>            :                  For that case we probably need to emit DW_LLE_startx_endx,
<span class="lineNum">   10293 </span>            :                  but we'd need 2 .debug_addr entries rather than just one.  */
<span class="lineNum">   10294 </span><span class="lineNoCov">          0 :               dw2_asm_output_delta_uleb128 (curr-&gt;end, curr-&gt;begin,</span>
<span class="lineNum">   10295 </span>            :                                             &quot;Location list length (%s)&quot;,
<span class="lineNum">   10296 </span>            :                                             list_head-&gt;ll_symbol);
<span class="lineNum">   10297 </span>            :             }
<span class="lineNum">   10298 </span><span class="lineCov">         27 :           else if (!have_multiple_function_sections &amp;&amp; HAVE_AS_LEB128)</span>
<span class="lineNum">   10299 </span>            :             {
<span class="lineNum">   10300 </span><span class="lineCov">         18 :               dwarf2out_maybe_output_loclist_view_pair (curr);</span>
<span class="lineNum">   10301 </span>            :               /* If all code is in .text section, the base address is
<span class="lineNum">   10302 </span>            :                  already provided by the CU attributes.  Use
<span class="lineNum">   10303 </span>            :                  DW_LLE_offset_pair where both addresses are uleb128 encoded
<span class="lineNum">   10304 </span>            :                  offsets against that base.  */
<span class="lineNum">   10305 </span><span class="lineCov">         18 :               dw2_asm_output_data (1, DW_LLE_offset_pair,</span>
<span class="lineNum">   10306 </span>            :                                    &quot;DW_LLE_offset_pair (%s)&quot;,
<span class="lineNum">   10307 </span>            :                                    list_head-&gt;ll_symbol);
<span class="lineNum">   10308 </span><span class="lineCov">         18 :               dw2_asm_output_delta_uleb128 (curr-&gt;begin, curr-&gt;section,</span>
<span class="lineNum">   10309 </span>            :                                             &quot;Location list begin address (%s)&quot;,
<span class="lineNum">   10310 </span>            :                                             list_head-&gt;ll_symbol);
<span class="lineNum">   10311 </span><span class="lineCov">         18 :               dw2_asm_output_delta_uleb128 (curr-&gt;end, curr-&gt;section,</span>
<span class="lineNum">   10312 </span>            :                                             &quot;Location list end address (%s)&quot;,
<span class="lineNum">   10313 </span>            :                                             list_head-&gt;ll_symbol);
<span class="lineNum">   10314 </span>            :             }
<span class="lineNum">   10315 </span><span class="lineCov">          9 :           else if (HAVE_AS_LEB128)</span>
<span class="lineNum">   10316 </span>            :             {
<span class="lineNum">   10317 </span>            :               /* Otherwise, find out how many consecutive entries could share
<span class="lineNum">   10318 </span>            :                  the same base entry.  If just one, emit DW_LLE_start_length,
<span class="lineNum">   10319 </span>            :                  otherwise emit DW_LLE_base_address for the base address
<span class="lineNum">   10320 </span>            :                  followed by a series of DW_LLE_offset_pair.  */
<span class="lineNum">   10321 </span><span class="lineCov">          9 :               if (last_section == NULL || curr-&gt;section != last_section)</span>
<span class="lineNum">   10322 </span>            :                 {
<span class="lineNum">   10323 </span><span class="lineCov">          8 :                   dw_loc_list_ref curr2;</span>
<span class="lineNum">   10324 </span><span class="lineCov">          8 :                   for (curr2 = curr-&gt;dw_loc_next; curr2 != NULL;</span>
<span class="lineNum">   10325 </span><span class="lineNoCov">          0 :                        curr2 = curr2-&gt;dw_loc_next)</span>
<span class="lineNum">   10326 </span>            :                     {
<span class="lineNum">   10327 </span><span class="lineCov">          1 :                       if (strcmp (curr2-&gt;begin, curr2-&gt;end) == 0</span>
<span class="lineNum">   10328 </span><span class="lineNoCov">          0 :                           &amp;&amp; !curr2-&gt;force)</span>
<span class="lineNum">   10329 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">   10330 </span>            :                       break;
<span class="lineNum">   10331 </span>            :                     }
<span class="lineNum">   10332 </span><span class="lineCov">          8 :                   if (curr2 == NULL || curr-&gt;section != curr2-&gt;section)</span>
<span class="lineNum">   10333 </span>            :                     last_section = NULL;
<span class="lineNum">   10334 </span>            :                   else
<span class="lineNum">   10335 </span>            :                     {
<span class="lineNum">   10336 </span><span class="lineCov">          1 :                       last_section = curr-&gt;section;</span>
<span class="lineNum">   10337 </span><span class="lineCov">          1 :                       base_label = curr-&gt;begin;</span>
<span class="lineNum">   10338 </span><span class="lineCov">          1 :                       dw2_asm_output_data (1, DW_LLE_base_address,</span>
<span class="lineNum">   10339 </span>            :                                            &quot;DW_LLE_base_address (%s)&quot;,
<span class="lineNum">   10340 </span>            :                                            list_head-&gt;ll_symbol);
<span class="lineNum">   10341 </span><span class="lineCov">          1 :                       dw2_asm_output_addr (DWARF2_ADDR_SIZE, base_label,</span>
<span class="lineNum">   10342 </span>            :                                            &quot;Base address (%s)&quot;,
<span class="lineNum">   10343 </span>            :                                            list_head-&gt;ll_symbol);
<span class="lineNum">   10344 </span>            :                     }
<span class="lineNum">   10345 </span>            :                 }
<span class="lineNum">   10346 </span>            :               /* Only one entry with the same base address.  Use
<span class="lineNum">   10347 </span>            :                  DW_LLE_start_length with absolute address and uleb128
<span class="lineNum">   10348 </span>            :                  length.  */
<span class="lineNum">   10349 </span><span class="lineCov">          2 :               if (last_section == NULL)</span>
<span class="lineNum">   10350 </span>            :                 {
<span class="lineNum">   10351 </span><span class="lineCov">          7 :                   dwarf2out_maybe_output_loclist_view_pair (curr);</span>
<span class="lineNum">   10352 </span><span class="lineCov">          7 :                   dw2_asm_output_data (1, DW_LLE_start_length,</span>
<span class="lineNum">   10353 </span>            :                                        &quot;DW_LLE_start_length (%s)&quot;,
<span class="lineNum">   10354 </span>            :                                        list_head-&gt;ll_symbol);
<span class="lineNum">   10355 </span><span class="lineCov">          7 :                   dw2_asm_output_addr (DWARF2_ADDR_SIZE, curr-&gt;begin,</span>
<span class="lineNum">   10356 </span>            :                                        &quot;Location list begin address (%s)&quot;,
<span class="lineNum">   10357 </span>            :                                        list_head-&gt;ll_symbol);
<span class="lineNum">   10358 </span><span class="lineCov">          7 :                   dw2_asm_output_delta_uleb128 (curr-&gt;end, curr-&gt;begin,</span>
<span class="lineNum">   10359 </span>            :                                                 &quot;Location list length &quot;
<span class="lineNum">   10360 </span>            :                                                 &quot;(%s)&quot;, list_head-&gt;ll_symbol);
<span class="lineNum">   10361 </span>            :                 }
<span class="lineNum">   10362 </span>            :               /* Otherwise emit DW_LLE_offset_pair, relative to above emitted
<span class="lineNum">   10363 </span>            :                  DW_LLE_base_address.  */
<span class="lineNum">   10364 </span>            :               else
<span class="lineNum">   10365 </span>            :                 {
<span class="lineNum">   10366 </span><span class="lineCov">          2 :                   dwarf2out_maybe_output_loclist_view_pair (curr);</span>
<span class="lineNum">   10367 </span><span class="lineCov">          2 :                   dw2_asm_output_data (1, DW_LLE_offset_pair,</span>
<span class="lineNum">   10368 </span>            :                                        &quot;DW_LLE_offset_pair (%s)&quot;,
<span class="lineNum">   10369 </span>            :                                        list_head-&gt;ll_symbol);
<span class="lineNum">   10370 </span><span class="lineCov">          2 :                   dw2_asm_output_delta_uleb128 (curr-&gt;begin, base_label,</span>
<span class="lineNum">   10371 </span>            :                                                 &quot;Location list begin address &quot;
<span class="lineNum">   10372 </span>            :                                                 &quot;(%s)&quot;, list_head-&gt;ll_symbol);
<span class="lineNum">   10373 </span><span class="lineCov">          2 :                   dw2_asm_output_delta_uleb128 (curr-&gt;end, base_label,</span>
<span class="lineNum">   10374 </span>            :                                                 &quot;Location list end address &quot;
<span class="lineNum">   10375 </span>            :                                                 &quot;(%s)&quot;, list_head-&gt;ll_symbol);
<span class="lineNum">   10376 </span>            :                 }
<span class="lineNum">   10377 </span>            :             }
<span class="lineNum">   10378 </span>            :           /* The assembler does not support .uleb128 directive.  Emit
<span class="lineNum">   10379 </span>            :              DW_LLE_start_end with a pair of absolute addresses.  */
<span class="lineNum">   10380 </span>            :           else
<span class="lineNum">   10381 </span>            :             {
<span class="lineNum">   10382 </span>            :               dwarf2out_maybe_output_loclist_view_pair (curr);
<span class="lineNum">   10383 </span>            :               dw2_asm_output_data (1, DW_LLE_start_end,
<span class="lineNum">   10384 </span>            :                                    &quot;DW_LLE_start_end (%s)&quot;,
<span class="lineNum">   10385 </span>            :                                    list_head-&gt;ll_symbol);
<span class="lineNum">   10386 </span>            :               dw2_asm_output_addr (DWARF2_ADDR_SIZE, curr-&gt;begin,
<span class="lineNum">   10387 </span>            :                                    &quot;Location list begin address (%s)&quot;,
<span class="lineNum">   10388 </span>            :                                    list_head-&gt;ll_symbol);
<span class="lineNum">   10389 </span>            :               dw2_asm_output_addr (DWARF2_ADDR_SIZE, curr-&gt;end,
<span class="lineNum">   10390 </span>            :                                    &quot;Location list end address (%s)&quot;,
<span class="lineNum">   10391 </span>            :                                    list_head-&gt;ll_symbol);
<span class="lineNum">   10392 </span>            :             }
<span class="lineNum">   10393 </span>            :         }
<span class="lineNum">   10394 </span><span class="lineCov">   14680566 :       else if (dwarf_split_debug_info)</span>
<span class="lineNum">   10395 </span>            :         {
<span class="lineNum">   10396 </span>            :           /* For -gsplit-dwarf -gdwarf-{2,3,4} emit index into .debug_addr
<span class="lineNum">   10397 </span>            :              and 4 byte length.  */
<span class="lineNum">   10398 </span><span class="lineCov">          5 :           dw2_asm_output_data (1, DW_LLE_GNU_start_length_entry,</span>
<span class="lineNum">   10399 </span>            :                                &quot;Location list start/length entry (%s)&quot;,
<span class="lineNum">   10400 </span>            :                                list_head-&gt;ll_symbol);
<span class="lineNum">   10401 </span><span class="lineCov">          5 :           dw2_asm_output_data_uleb128 (curr-&gt;begin_entry-&gt;index,</span>
<span class="lineNum">   10402 </span>            :                                        &quot;Location list range start index (%s)&quot;,
<span class="lineNum">   10403 </span>            :                                        curr-&gt;begin);
<span class="lineNum">   10404 </span>            :           /* The length field is 4 bytes.  If we ever need to support
<span class="lineNum">   10405 </span>            :              an 8-byte length, we can add a new DW_LLE code or fall back
<span class="lineNum">   10406 </span>            :              to DW_LLE_GNU_start_end_entry.  */
<span class="lineNum">   10407 </span><span class="lineCov">          5 :           dw2_asm_output_delta (4, curr-&gt;end, curr-&gt;begin,</span>
<span class="lineNum">   10408 </span>            :                                 &quot;Location list range length (%s)&quot;,
<span class="lineNum">   10409 </span>            :                                 list_head-&gt;ll_symbol);
<span class="lineNum">   10410 </span>            :         }
<span class="lineNum">   10411 </span><span class="lineCov">   14680561 :       else if (!have_multiple_function_sections)</span>
<span class="lineNum">   10412 </span>            :         {
<span class="lineNum">   10413 </span>            :           /* Pair of relative addresses against start of text section.  */
<span class="lineNum">   10414 </span><span class="lineCov">    3319177 :           dw2_asm_output_delta (DWARF2_ADDR_SIZE, curr-&gt;begin, curr-&gt;section,</span>
<span class="lineNum">   10415 </span>            :                                 &quot;Location list begin address (%s)&quot;,
<span class="lineNum">   10416 </span>            :                                 list_head-&gt;ll_symbol);
<span class="lineNum">   10417 </span><span class="lineCov">    3319177 :           dw2_asm_output_delta (DWARF2_ADDR_SIZE, curr-&gt;end, curr-&gt;section,</span>
<span class="lineNum">   10418 </span>            :                                 &quot;Location list end address (%s)&quot;,
<span class="lineNum">   10419 </span>            :                                 list_head-&gt;ll_symbol);
<span class="lineNum">   10420 </span>            :         }
<span class="lineNum">   10421 </span>            :       else
<span class="lineNum">   10422 </span>            :         {
<span class="lineNum">   10423 </span>            :           /* Pair of absolute addresses.  */
<span class="lineNum">   10424 </span><span class="lineCov">   13164357 :           dw2_asm_output_addr (DWARF2_ADDR_SIZE, curr-&gt;begin,</span>
<span class="lineNum">   10425 </span>            :                                &quot;Location list begin address (%s)&quot;,
<span class="lineNum">   10426 </span>            :                                list_head-&gt;ll_symbol);
<span class="lineNum">   10427 </span><span class="lineCov">   13164357 :           dw2_asm_output_addr (DWARF2_ADDR_SIZE, curr-&gt;end,</span>
<span class="lineNum">   10428 </span>            :                                &quot;Location list end address (%s)&quot;,
<span class="lineNum">   10429 </span>            :                                list_head-&gt;ll_symbol);
<span class="lineNum">   10430 </span>            :         }
<span class="lineNum">   10431 </span>            : 
<span class="lineNum">   10432 </span>            :       /* Output the block length for this list of location operations.  */
<span class="lineNum">   10433 </span><span class="lineCov">   14680593 :       if (dwarf_version &gt;= 5)</span>
<span class="lineNum">   10434 </span><span class="lineCov">         27 :         dw2_asm_output_data_uleb128 (size, &quot;Location expression size&quot;);</span>
<span class="lineNum">   10435 </span>            :       else
<span class="lineNum">   10436 </span>            :         {
<span class="lineNum">   10437 </span><span class="lineCov">   14680566 :           gcc_assert (size &lt;= 0xffff);</span>
<span class="lineNum">   10438 </span><span class="lineCov">   14680566 :           dw2_asm_output_data (2, size, &quot;Location expression size&quot;);</span>
<span class="lineNum">   10439 </span>            :         }
<span class="lineNum">   10440 </span>            : 
<span class="lineNum">   10441 </span><span class="lineCov">   14680593 :       output_loc_sequence (curr-&gt;expr, -1);</span>
<span class="lineNum">   10442 </span>            :     }
<span class="lineNum">   10443 </span>            : 
<span class="lineNum">   10444 </span>            :   /* And finally list termination.  */
<span class="lineNum">   10445 </span><span class="lineCov">    5688514 :   if (dwarf_version &gt;= 5)</span>
<span class="lineNum">   10446 </span><span class="lineCov">         14 :     dw2_asm_output_data (1, DW_LLE_end_of_list,</span>
<span class="lineNum">   10447 </span>            :                          &quot;DW_LLE_end_of_list (%s)&quot;, list_head-&gt;ll_symbol);
<span class="lineNum">   10448 </span><span class="lineCov">    5688500 :   else if (dwarf_split_debug_info)</span>
<span class="lineNum">   10449 </span><span class="lineCov">          3 :     dw2_asm_output_data (1, DW_LLE_GNU_end_of_list_entry,</span>
<span class="lineNum">   10450 </span>            :                          &quot;Location list terminator (%s)&quot;,
<span class="lineNum">   10451 </span>            :                          list_head-&gt;ll_symbol);
<span class="lineNum">   10452 </span>            :   else
<span class="lineNum">   10453 </span>            :     {
<span class="lineNum">   10454 </span><span class="lineCov">    6246567 :       dw2_asm_output_data (DWARF2_ADDR_SIZE, 0,</span>
<span class="lineNum">   10455 </span>            :                            &quot;Location list terminator begin (%s)&quot;,
<span class="lineNum">   10456 </span>            :                            list_head-&gt;ll_symbol);
<span class="lineNum">   10457 </span><span class="lineCov">    6246567 :       dw2_asm_output_data (DWARF2_ADDR_SIZE, 0,</span>
<span class="lineNum">   10458 </span>            :                            &quot;Location list terminator end (%s)&quot;,
<span class="lineNum">   10459 </span>            :                            list_head-&gt;ll_symbol);
<span class="lineNum">   10460 </span>            :     }
<span class="lineNum">   10461 </span>            : 
<span class="lineNum">   10462 </span><span class="lineCov">    5688514 :   gcc_assert (!list_head-&gt;vl_symbol</span>
<span class="lineNum">   10463 </span>            :               || vcount == lcount * (dwarf2out_locviews_in_attribute () ? 1 : 0));
<span class="lineNum">   10464 </span>            : }
<span class="lineNum">   10465 </span>            : 
<span class="lineNum">   10466 </span>            : /* Output a range_list offset into the .debug_ranges or .debug_rnglists
<span class="lineNum">   10467 </span>            :    section.  Emit a relocated reference if val_entry is NULL, otherwise,
<span class="lineNum">   10468 </span>            :    emit an indirect reference.  */
<a name="10469"><span class="lineNum">   10469 </span>            : </a>
<span class="lineNum">   10470 </span>            : static void
<span class="lineNum">   10471 </span><span class="lineCov">    1545590 : output_range_list_offset (dw_attr_node *a)</span>
<span class="lineNum">   10472 </span>            : {
<span class="lineNum">   10473 </span><span class="lineCov">    1545590 :   const char *name = dwarf_attr_name (a-&gt;dw_attr);</span>
<span class="lineNum">   10474 </span>            : 
<span class="lineNum">   10475 </span><span class="lineCov">    1545590 :   if (a-&gt;dw_attr_val.val_entry == RELOCATED_OFFSET)</span>
<span class="lineNum">   10476 </span>            :     {
<span class="lineNum">   10477 </span><span class="lineCov">    1545588 :       if (dwarf_version &gt;= 5)</span>
<span class="lineNum">   10478 </span>            :         {
<span class="lineNum">   10479 </span><span class="lineCov">          8 :           dw_ranges *r = &amp;(*ranges_table)[a-&gt;dw_attr_val.v.val_offset];</span>
<span class="lineNum">   10480 </span><span class="lineCov">          8 :           dw2_asm_output_offset (DWARF_OFFSET_SIZE, r-&gt;label,</span>
<span class="lineNum">   10481 </span>            :                                  debug_ranges_section, &quot;%s&quot;, name);
<span class="lineNum">   10482 </span>            :         }
<span class="lineNum">   10483 </span>            :       else
<span class="lineNum">   10484 </span>            :         {
<span class="lineNum">   10485 </span><span class="lineCov">    1545580 :           char *p = strchr (ranges_section_label, '\0');</span>
<span class="lineNum">   10486 </span><span class="lineCov">    3091160 :           sprintf (p, &quot;+&quot; HOST_WIDE_INT_PRINT_HEX,</span>
<span class="lineNum">   10487 </span><span class="lineCov">    1545580 :                    a-&gt;dw_attr_val.v.val_offset * 2 * DWARF2_ADDR_SIZE);</span>
<span class="lineNum">   10488 </span><span class="lineCov">    1545580 :           dw2_asm_output_offset (DWARF_OFFSET_SIZE, ranges_section_label,</span>
<span class="lineNum">   10489 </span>            :                                  debug_ranges_section, &quot;%s&quot;, name);
<span class="lineNum">   10490 </span><span class="lineCov">    1545580 :           *p = '\0';</span>
<span class="lineNum">   10491 </span>            :         }
<span class="lineNum">   10492 </span>            :     }
<span class="lineNum">   10493 </span><span class="lineCov">          2 :   else if (dwarf_version &gt;= 5)</span>
<span class="lineNum">   10494 </span>            :     {
<span class="lineNum">   10495 </span><span class="lineNoCov">          0 :       dw_ranges *r = &amp;(*ranges_table)[a-&gt;dw_attr_val.v.val_offset];</span>
<span class="lineNum">   10496 </span><span class="lineNoCov">          0 :       gcc_assert (rnglist_idx);</span>
<span class="lineNum">   10497 </span><span class="lineNoCov">          0 :       dw2_asm_output_data_uleb128 (r-&gt;idx, &quot;%s&quot;, name);</span>
<span class="lineNum">   10498 </span>            :     }
<span class="lineNum">   10499 </span>            :   else
<span class="lineNum">   10500 </span><span class="lineCov">          4 :     dw2_asm_output_data (DWARF_OFFSET_SIZE,</span>
<span class="lineNum">   10501 </span><span class="lineCov">          2 :                          a-&gt;dw_attr_val.v.val_offset * 2 * DWARF2_ADDR_SIZE,</span>
<span class="lineNum">   10502 </span>            :                          &quot;%s (offset from %s)&quot;, name, ranges_section_label);
<span class="lineNum">   10503 </span><span class="lineCov">    1545590 : }</span>
<span class="lineNum">   10504 </span>            : 
<span class="lineNum">   10505 </span>            : /* Output the offset into the debug_loc section.  */
<a name="10506"><span class="lineNum">   10506 </span>            : </a>
<span class="lineNum">   10507 </span>            : static void
<span class="lineNum">   10508 </span><span class="lineCov">    5791298 : output_loc_list_offset (dw_attr_node *a)</span>
<span class="lineNum">   10509 </span>            : {
<span class="lineNum">   10510 </span><span class="lineCov">    5791298 :   char *sym = AT_loc_list (a)-&gt;ll_symbol;</span>
<span class="lineNum">   10511 </span>            : 
<span class="lineNum">   10512 </span><span class="lineCov">    5791298 :   gcc_assert (sym);</span>
<span class="lineNum">   10513 </span><span class="lineCov">    5791298 :   if (!dwarf_split_debug_info)</span>
<span class="lineNum">   10514 </span><span class="lineCov">    5791295 :     dw2_asm_output_offset (DWARF_OFFSET_SIZE, sym, debug_loc_section,</span>
<span class="lineNum">   10515 </span><span class="lineCov">    5791295 :                            &quot;%s&quot;, dwarf_attr_name (a-&gt;dw_attr));</span>
<span class="lineNum">   10516 </span><span class="lineCov">          3 :   else if (dwarf_version &gt;= 5)</span>
<span class="lineNum">   10517 </span>            :     {
<span class="lineNum">   10518 </span><span class="lineNoCov">          0 :       gcc_assert (AT_loc_list (a)-&gt;num_assigned);</span>
<span class="lineNum">   10519 </span><span class="lineNoCov">          0 :       dw2_asm_output_data_uleb128 (AT_loc_list (a)-&gt;hash, &quot;%s (%s)&quot;,</span>
<span class="lineNum">   10520 </span><span class="lineNoCov">          0 :                                    dwarf_attr_name (a-&gt;dw_attr),</span>
<span class="lineNum">   10521 </span>            :                                    sym);
<span class="lineNum">   10522 </span>            :     }
<span class="lineNum">   10523 </span>            :   else
<span class="lineNum">   10524 </span><span class="lineCov">          3 :     dw2_asm_output_delta (DWARF_OFFSET_SIZE, sym, loc_section_label,</span>
<span class="lineNum">   10525 </span><span class="lineCov">          3 :                           &quot;%s&quot;, dwarf_attr_name (a-&gt;dw_attr));</span>
<span class="lineNum">   10526 </span><span class="lineCov">    5791298 : }</span>
<span class="lineNum">   10527 </span>            : 
<span class="lineNum">   10528 </span>            : /* Output the offset into the debug_loc section.  */
<a name="10529"><span class="lineNum">   10529 </span>            : </a>
<span class="lineNum">   10530 </span>            : static void
<span class="lineNum">   10531 </span><span class="lineCov">    5705885 : output_view_list_offset (dw_attr_node *a)</span>
<span class="lineNum">   10532 </span>            : {
<span class="lineNum">   10533 </span><span class="lineCov">    5705885 :   char *sym = (*AT_loc_list_ptr (a))-&gt;vl_symbol;</span>
<span class="lineNum">   10534 </span>            : 
<span class="lineNum">   10535 </span><span class="lineCov">    5705885 :   gcc_assert (sym);</span>
<span class="lineNum">   10536 </span><span class="lineCov">    5705885 :   if (dwarf_split_debug_info)</span>
<span class="lineNum">   10537 </span><span class="lineCov">          3 :     dw2_asm_output_delta (DWARF_OFFSET_SIZE, sym, loc_section_label,</span>
<span class="lineNum">   10538 </span><span class="lineCov">          3 :                           &quot;%s&quot;, dwarf_attr_name (a-&gt;dw_attr));</span>
<span class="lineNum">   10539 </span>            :   else
<span class="lineNum">   10540 </span><span class="lineCov">    5705882 :     dw2_asm_output_offset (DWARF_OFFSET_SIZE, sym, debug_loc_section,</span>
<span class="lineNum">   10541 </span><span class="lineCov">    5705882 :                            &quot;%s&quot;, dwarf_attr_name (a-&gt;dw_attr));</span>
<span class="lineNum">   10542 </span><span class="lineCov">    5705885 : }</span>
<span class="lineNum">   10543 </span>            : 
<span class="lineNum">   10544 </span>            : /* Output an attribute's index or value appropriately.  */
<a name="10545"><span class="lineNum">   10545 </span>            : </a>
<span class="lineNum">   10546 </span>            : static void
<span class="lineNum">   10547 </span><span class="lineCov">    7818248 : output_attr_index_or_value (dw_attr_node *a)</span>
<span class="lineNum">   10548 </span>            : {
<span class="lineNum">   10549 </span><span class="lineCov">    7818248 :   const char *name = dwarf_attr_name (a-&gt;dw_attr);</span>
<span class="lineNum">   10550 </span>            : 
<span class="lineNum">   10551 </span><span class="lineCov">    7818262 :   if (dwarf_split_debug_info &amp;&amp; AT_index (a) != NOT_INDEXED)</span>
<span class="lineNum">   10552 </span>            :     {
<span class="lineNum">   10553 </span><span class="lineCov">         14 :       dw2_asm_output_data_uleb128 (AT_index (a), &quot;%s&quot;, name);</span>
<span class="lineNum">   10554 </span><span class="lineCov">         14 :       return;</span>
<span class="lineNum">   10555 </span>            :     }
<span class="lineNum">   10556 </span><span class="lineCov">    7818234 :   switch (AT_class (a))</span>
<span class="lineNum">   10557 </span>            :     {
<span class="lineNum">   10558 </span><span class="lineCov">      20665 :     case dw_val_class_addr:</span>
<span class="lineNum">   10559 </span><span class="lineCov">      20665 :       dw2_asm_output_addr_rtx (DWARF2_ADDR_SIZE, AT_addr (a), &quot;%s&quot;, name);</span>
<span class="lineNum">   10560 </span><span class="lineCov">      20665 :       break;</span>
<span class="lineNum">   10561 </span><span class="lineCov">    7797569 :     case dw_val_class_high_pc:</span>
<span class="lineNum">   10562 </span><span class="lineCov">    7797569 :     case dw_val_class_lbl_id:</span>
<span class="lineNum">   10563 </span><span class="lineCov">    7797569 :       dw2_asm_output_addr (DWARF2_ADDR_SIZE, AT_lbl (a), &quot;%s&quot;, name);</span>
<span class="lineNum">   10564 </span><span class="lineCov">    7797569 :       break;</span>
<span class="lineNum">   10565 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">   10566 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">   10567 </span>            :     }
<span class="lineNum">   10568 </span>            : }
<span class="lineNum">   10569 </span>            : 
<span class="lineNum">   10570 </span>            : /* Output a type signature.  */
<a name="10571"><span class="lineNum">   10571 </span>            : </a>
<span class="lineNum">   10572 </span>            : static inline void
<span class="lineNum">   10573 </span><span class="lineCov">        102 : output_signature (const char *sig, const char *name)</span>
<span class="lineNum">   10574 </span>            : {
<span class="lineNum">   10575 </span><span class="lineCov">        102 :   int i;</span>
<span class="lineNum">   10576 </span>            : 
<span class="lineNum">   10577 </span><span class="lineCov">        918 :   for (i = 0; i &lt; DWARF_TYPE_SIGNATURE_SIZE; i++)</span>
<span class="lineNum">   10578 </span><span class="lineCov">       1530 :     dw2_asm_output_data (1, sig[i], i == 0 ? &quot;%s&quot; : NULL, name);</span>
<span class="lineNum">   10579 </span><span class="lineCov">        102 : }</span>
<span class="lineNum">   10580 </span>            : 
<span class="lineNum">   10581 </span>            : /* Output a discriminant value.  */
<a name="10582"><span class="lineNum">   10582 </span>            : </a>
<span class="lineNum">   10583 </span>            : static inline void
<span class="lineNum">   10584 </span><span class="lineNoCov">          0 : output_discr_value (dw_discr_value *discr_value, const char *name)</span>
<span class="lineNum">   10585 </span>            : {
<span class="lineNum">   10586 </span><span class="lineNoCov">          0 :   if (discr_value-&gt;pos)</span>
<span class="lineNum">   10587 </span><span class="lineNoCov">          0 :     dw2_asm_output_data_uleb128 (discr_value-&gt;v.uval, &quot;%s&quot;, name);</span>
<span class="lineNum">   10588 </span>            :   else
<span class="lineNum">   10589 </span><span class="lineNoCov">          0 :     dw2_asm_output_data_sleb128 (discr_value-&gt;v.sval, &quot;%s&quot;, name);</span>
<span class="lineNum">   10590 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   10591 </span>            : 
<span class="lineNum">   10592 </span>            : /* Output the DIE and its attributes.  Called recursively to generate
<span class="lineNum">   10593 </span>            :    the definitions of each child DIE.  */
<a name="10594"><span class="lineNum">   10594 </span>            : </a>
<span class="lineNum">   10595 </span>            : static void
<span class="lineNum">   10596 </span><span class="lineCov">   46334209 : output_die (dw_die_ref die)</span>
<span class="lineNum">   10597 </span>            : {
<span class="lineNum">   10598 </span><span class="lineCov">   46334209 :   dw_attr_node *a;</span>
<span class="lineNum">   10599 </span><span class="lineCov">   46334209 :   dw_die_ref c;</span>
<span class="lineNum">   10600 </span><span class="lineCov">   46334209 :   unsigned long size;</span>
<span class="lineNum">   10601 </span><span class="lineCov">   46334209 :   unsigned ix;</span>
<span class="lineNum">   10602 </span>            : 
<span class="lineNum">   10603 </span><span class="lineCov">  185336836 :   dw2_asm_output_data_uleb128 (die-&gt;die_abbrev, &quot;(DIE (%#lx) %s)&quot;,</span>
<span class="lineNum">   10604 </span><span class="lineCov">   46334209 :                                (unsigned long)die-&gt;die_offset,</span>
<span class="lineNum">   10605 </span><span class="lineCov">   46334209 :                                dwarf_tag_name (die-&gt;die_tag));</span>
<span class="lineNum">   10606 </span>            : 
<span class="lineNum">   10607 </span><span class="lineCov">  233236620 :   FOR_EACH_VEC_SAFE_ELT (die-&gt;die_attr, ix, a)</span>
<span class="lineNum">   10608 </span>            :     {
<span class="lineNum">   10609 </span><span class="lineCov">  186902411 :       const char *name = dwarf_attr_name (a-&gt;dw_attr);</span>
<span class="lineNum">   10610 </span>            : 
<span class="lineNum">   10611 </span><span class="lineCov">  186902411 :       switch (AT_class (a))</span>
<span class="lineNum">   10612 </span>            :         {
<span class="lineNum">   10613 </span><span class="lineCov">      20665 :         case dw_val_class_addr:</span>
<span class="lineNum">   10614 </span><span class="lineCov">      20665 :           output_attr_index_or_value (a);</span>
<span class="lineNum">   10615 </span><span class="lineCov">      20665 :           break;</span>
<span class="lineNum">   10616 </span>            : 
<span class="lineNum">   10617 </span><span class="lineNoCov">          0 :         case dw_val_class_offset:</span>
<span class="lineNum">   10618 </span><span class="lineNoCov">          0 :           dw2_asm_output_data (DWARF_OFFSET_SIZE, a-&gt;dw_attr_val.v.val_offset,</span>
<span class="lineNum">   10619 </span>            :                                &quot;%s&quot;, name);
<span class="lineNum">   10620 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   10621 </span>            : 
<span class="lineNum">   10622 </span><span class="lineCov">    1545590 :         case dw_val_class_range_list:</span>
<span class="lineNum">   10623 </span><span class="lineCov">    1545590 :           output_range_list_offset (a);</span>
<span class="lineNum">   10624 </span><span class="lineCov">    1545590 :           break;</span>
<span class="lineNum">   10625 </span>            : 
<span class="lineNum">   10626 </span><span class="lineCov">    4972584 :         case dw_val_class_loc:</span>
<span class="lineNum">   10627 </span><span class="lineCov">    4972584 :           size = size_of_locs (AT_loc (a));</span>
<span class="lineNum">   10628 </span>            : 
<span class="lineNum">   10629 </span>            :           /* Output the block length for this list of location operations.  */
<span class="lineNum">   10630 </span><span class="lineCov">    4972584 :           if (dwarf_version &gt;= 4)</span>
<span class="lineNum">   10631 </span><span class="lineCov">    4964478 :             dw2_asm_output_data_uleb128 (size, &quot;%s&quot;, name);</span>
<span class="lineNum">   10632 </span>            :           else
<span class="lineNum">   10633 </span><span class="lineCov">      16212 :             dw2_asm_output_data (constant_size (size), size, &quot;%s&quot;, name);</span>
<span class="lineNum">   10634 </span>            : 
<span class="lineNum">   10635 </span><span class="lineCov">    4972584 :           output_loc_sequence (AT_loc (a), -1);</span>
<span class="lineNum">   10636 </span><span class="lineCov">    4972584 :           break;</span>
<span class="lineNum">   10637 </span>            : 
<span class="lineNum">   10638 </span><span class="lineCov">      36963 :         case dw_val_class_const:</span>
<span class="lineNum">   10639 </span>            :           /* ??? It would be slightly more efficient to use a scheme like is
<span class="lineNum">   10640 </span>            :              used for unsigned constants below, but gdb 4.x does not sign
<span class="lineNum">   10641 </span>            :              extend.  Gdb 5.x does sign extend.  */
<span class="lineNum">   10642 </span><span class="lineCov">      36963 :           dw2_asm_output_data_sleb128 (AT_int (a), &quot;%s&quot;, name);</span>
<span class="lineNum">   10643 </span><span class="lineCov">      36963 :           break;</span>
<span class="lineNum">   10644 </span>            : 
<span class="lineNum">   10645 </span><span class="lineCov">   45505252 :         case dw_val_class_unsigned_const:</span>
<span class="lineNum">   10646 </span><span class="lineCov">   45505252 :           {</span>
<span class="lineNum">   10647 </span><span class="lineCov">   45505252 :             int csize = constant_size (AT_unsigned (a));</span>
<span class="lineNum">   10648 </span><span class="lineCov">   45505252 :             if (dwarf_version == 3</span>
<span class="lineNum">   10649 </span><span class="lineCov">        675 :                 &amp;&amp; a-&gt;dw_attr == DW_AT_data_member_location</span>
<span class="lineNum">   10650 </span><span class="lineCov">         15 :                 &amp;&amp; csize &gt;= 4)</span>
<span class="lineNum">   10651 </span><span class="lineCov">          1 :               dw2_asm_output_data_uleb128 (AT_unsigned (a), &quot;%s&quot;, name);</span>
<span class="lineNum">   10652 </span>            :             else
<span class="lineNum">   10653 </span><span class="lineCov">   45505251 :               dw2_asm_output_data (csize, AT_unsigned (a), &quot;%s&quot;, name);</span>
<span class="lineNum">   10654 </span>            :           }
<span class="lineNum">   10655 </span>            :           break;
<span class="lineNum">   10656 </span>            : 
<span class="lineNum">   10657 </span><span class="lineCov">    3149821 :         case dw_val_class_symview:</span>
<span class="lineNum">   10658 </span><span class="lineCov">    3149821 :           {</span>
<span class="lineNum">   10659 </span><span class="lineCov">    3149821 :             int vsize;</span>
<span class="lineNum">   10660 </span><span class="lineCov">    3149821 :             if (symview_upper_bound &lt;= 0xff)</span>
<span class="lineNum">   10661 </span>            :               vsize = 1;
<span class="lineNum">   10662 </span><span class="lineCov">    2844950 :             else if (symview_upper_bound &lt;= 0xffff)</span>
<span class="lineNum">   10663 </span>            :               vsize = 2;
<span class="lineNum">   10664 </span><span class="lineNoCov">          0 :             else if (symview_upper_bound &lt;= 0xffffffff)</span>
<span class="lineNum">   10665 </span><span class="lineNoCov">          0 :               vsize = 4;</span>
<span class="lineNum">   10666 </span>            :             else
<span class="lineNum">   10667 </span>            :               vsize = 8;
<span class="lineNum">   10668 </span><span class="lineCov">    3149821 :             dw2_asm_output_addr (vsize, a-&gt;dw_attr_val.v.val_symbolic_view,</span>
<span class="lineNum">   10669 </span>            :                                  &quot;%s&quot;, name);
<span class="lineNum">   10670 </span>            :           }
<span class="lineNum">   10671 </span><span class="lineCov">    3149821 :           break;</span>
<span class="lineNum">   10672 </span>            : 
<span class="lineNum">   10673 </span><span class="lineNoCov">          0 :         case dw_val_class_const_implicit:</span>
<span class="lineNum">   10674 </span><span class="lineNoCov">          0 :           if (flag_debug_asm)</span>
<span class="lineNum">   10675 </span><span class="lineNoCov">          0 :             fprintf (asm_out_file, &quot;\t\t\t%s %s (&quot;</span>
<span class="lineNum">   10676 </span>            :                                    HOST_WIDE_INT_PRINT_DEC &quot;)\n&quot;,
<span class="lineNum">   10677 </span>            :                      ASM_COMMENT_START, name, AT_int (a));
<span class="lineNum">   10678 </span>            :           break;
<span class="lineNum">   10679 </span>            : 
<span class="lineNum">   10680 </span><span class="lineCov">         36 :         case dw_val_class_unsigned_const_implicit:</span>
<span class="lineNum">   10681 </span><span class="lineCov">         36 :           if (flag_debug_asm)</span>
<span class="lineNum">   10682 </span><span class="lineCov">         27 :             fprintf (asm_out_file, &quot;\t\t\t%s %s (&quot;</span>
<span class="lineNum">   10683 </span>            :                                    HOST_WIDE_INT_PRINT_HEX &quot;)\n&quot;,
<span class="lineNum">   10684 </span>            :                      ASM_COMMENT_START, name, AT_unsigned (a));
<span class="lineNum">   10685 </span>            :           break;
<span class="lineNum">   10686 </span>            : 
<span class="lineNum">   10687 </span><span class="lineNoCov">          0 :         case dw_val_class_const_double:</span>
<span class="lineNum">   10688 </span><span class="lineNoCov">          0 :           {</span>
<span class="lineNum">   10689 </span><span class="lineNoCov">          0 :             unsigned HOST_WIDE_INT first, second;</span>
<span class="lineNum">   10690 </span>            : 
<span class="lineNum">   10691 </span><span class="lineNoCov">          0 :             if (HOST_BITS_PER_WIDE_INT &gt;= DWARF_LARGEST_DATA_FORM_BITS)</span>
<span class="lineNum">   10692 </span><span class="lineNoCov">          0 :               dw2_asm_output_data (1,</span>
<span class="lineNum">   10693 </span>            :                                    HOST_BITS_PER_DOUBLE_INT
<span class="lineNum">   10694 </span>            :                                    / HOST_BITS_PER_CHAR,
<span class="lineNum">   10695 </span>            :                                    NULL);
<span class="lineNum">   10696 </span>            : 
<span class="lineNum">   10697 </span><span class="lineNoCov">          0 :             if (WORDS_BIG_ENDIAN)</span>
<span class="lineNum">   10698 </span>            :               {
<span class="lineNum">   10699 </span>            :                 first = a-&gt;dw_attr_val.v.val_double.high;
<span class="lineNum">   10700 </span>            :                 second = a-&gt;dw_attr_val.v.val_double.low;
<span class="lineNum">   10701 </span>            :               }
<span class="lineNum">   10702 </span>            :             else
<span class="lineNum">   10703 </span>            :               {
<span class="lineNum">   10704 </span><span class="lineNoCov">          0 :                 first = a-&gt;dw_attr_val.v.val_double.low;</span>
<span class="lineNum">   10705 </span><span class="lineNoCov">          0 :                 second = a-&gt;dw_attr_val.v.val_double.high;</span>
<span class="lineNum">   10706 </span>            :               }
<span class="lineNum">   10707 </span>            : 
<span class="lineNum">   10708 </span><span class="lineNoCov">          0 :             dw2_asm_output_data (HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR,</span>
<span class="lineNum">   10709 </span>            :                                  first, &quot;%s&quot;, name);
<span class="lineNum">   10710 </span><span class="lineNoCov">          0 :             dw2_asm_output_data (HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR,</span>
<span class="lineNum">   10711 </span>            :                                  second, NULL);
<span class="lineNum">   10712 </span>            :           }
<span class="lineNum">   10713 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   10714 </span>            : 
<span class="lineNum">   10715 </span><span class="lineCov">          8 :         case dw_val_class_wide_int:</span>
<span class="lineNum">   10716 </span><span class="lineCov">          8 :           {</span>
<span class="lineNum">   10717 </span><span class="lineCov">          8 :             int i;</span>
<span class="lineNum">   10718 </span><span class="lineCov">          8 :             int len = get_full_len (*a-&gt;dw_attr_val.v.val_wide);</span>
<span class="lineNum">   10719 </span><span class="lineCov">          8 :             int l = HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR;</span>
<span class="lineNum">   10720 </span><span class="lineCov">         16 :             if (len * HOST_BITS_PER_WIDE_INT &gt; DWARF_LARGEST_DATA_FORM_BITS)</span>
<span class="lineNum">   10721 </span><span class="lineCov">          4 :               dw2_asm_output_data (1, get_full_len (*a-&gt;dw_attr_val.v.val_wide)</span>
<span class="lineNum">   10722 </span><span class="lineCov">          4 :                                       * l, NULL);</span>
<span class="lineNum">   10723 </span>            : 
<span class="lineNum">   10724 </span>            :             if (WORDS_BIG_ENDIAN)
<span class="lineNum">   10725 </span>            :               for (i = len - 1; i &gt;= 0; --i)
<span class="lineNum">   10726 </span>            :                 {
<span class="lineNum">   10727 </span>            :                   dw2_asm_output_data (l, a-&gt;dw_attr_val.v.val_wide-&gt;elt (i),
<span class="lineNum">   10728 </span>            :                                        &quot;%s&quot;, name);
<span class="lineNum">   10729 </span>            :                   name = &quot;&quot;;
<span class="lineNum">   10730 </span>            :                 }
<span class="lineNum">   10731 </span>            :             else
<span class="lineNum">   10732 </span><span class="lineCov">         20 :               for (i = 0; i &lt; len; ++i)</span>
<span class="lineNum">   10733 </span>            :                 {
<span class="lineNum">   10734 </span><span class="lineCov">         24 :                   dw2_asm_output_data (l, a-&gt;dw_attr_val.v.val_wide-&gt;elt (i),</span>
<span class="lineNum">   10735 </span>            :                                        &quot;%s&quot;, name);
<span class="lineNum">   10736 </span><span class="lineCov">         12 :                   name = &quot;&quot;;</span>
<span class="lineNum">   10737 </span>            :                 }
<span class="lineNum">   10738 </span>            :           }
<span class="lineNum">   10739 </span>            :           break;
<span class="lineNum">   10740 </span>            : 
<span class="lineNum">   10741 </span><span class="lineCov">      47110 :         case dw_val_class_vec:</span>
<span class="lineNum">   10742 </span><span class="lineCov">      47110 :           {</span>
<span class="lineNum">   10743 </span><span class="lineCov">      47110 :             unsigned int elt_size = a-&gt;dw_attr_val.v.val_vec.elt_size;</span>
<span class="lineNum">   10744 </span><span class="lineCov">      47110 :             unsigned int len = a-&gt;dw_attr_val.v.val_vec.length;</span>
<span class="lineNum">   10745 </span><span class="lineCov">      47110 :             unsigned int i;</span>
<span class="lineNum">   10746 </span><span class="lineCov">      47110 :             unsigned char *p;</span>
<span class="lineNum">   10747 </span>            : 
<span class="lineNum">   10748 </span><span class="lineCov">      47110 :             dw2_asm_output_data (constant_size (len * elt_size),</span>
<span class="lineNum">   10749 </span><span class="lineCov">      47110 :                                  len * elt_size, &quot;%s&quot;, name);</span>
<span class="lineNum">   10750 </span><span class="lineCov">      47110 :             if (elt_size &gt; sizeof (HOST_WIDE_INT))</span>
<span class="lineNum">   10751 </span>            :               {
<span class="lineNum">   10752 </span><span class="lineNoCov">          0 :                 elt_size /= 2;</span>
<span class="lineNum">   10753 </span><span class="lineNoCov">          0 :                 len *= 2;</span>
<span class="lineNum">   10754 </span>            :               }
<span class="lineNum">   10755 </span><span class="lineCov">      47110 :             for (i = 0, p = (unsigned char *) a-&gt;dw_attr_val.v.val_vec.array;</span>
<span class="lineNum">   10756 </span><span class="lineCov">     285575 :                  i &lt; len;</span>
<span class="lineNum">   10757 </span><span class="lineCov">     238465 :                  i++, p += elt_size)</span>
<span class="lineNum">   10758 </span><span class="lineCov">     476930 :               dw2_asm_output_data (elt_size, extract_int (p, elt_size),</span>
<span class="lineNum">   10759 </span>            :                                    &quot;fp or vector constant word %u&quot;, i);
<span class="lineNum">   10760 </span>            :             break;
<span class="lineNum">   10761 </span>            :           }
<span class="lineNum">   10762 </span>            : 
<span class="lineNum">   10763 </span><span class="lineCov">   18073949 :         case dw_val_class_flag:</span>
<span class="lineNum">   10764 </span><span class="lineCov">   18073949 :           if (dwarf_version &gt;= 4)</span>
<span class="lineNum">   10765 </span>            :             {
<span class="lineNum">   10766 </span>            :               /* Currently all add_AT_flag calls pass in 1 as last argument,
<span class="lineNum">   10767 </span>            :                  so DW_FORM_flag_present can be used.  If that ever changes,
<span class="lineNum">   10768 </span>            :                  we'll need to use DW_FORM_flag and have some optimization
<span class="lineNum">   10769 </span>            :                  in build_abbrev_table that will change those to
<span class="lineNum">   10770 </span>            :                  DW_FORM_flag_present if it is set to 1 in all DIEs using
<span class="lineNum">   10771 </span>            :                  the same abbrev entry.  */
<span class="lineNum">   10772 </span><span class="lineCov">   18059323 :               gcc_assert (AT_flag (a) == 1);</span>
<span class="lineNum">   10773 </span><span class="lineCov">   18059323 :               if (flag_debug_asm)</span>
<span class="lineNum">   10774 </span><span class="lineCov">       1497 :                 fprintf (asm_out_file, &quot;\t\t\t%s %s\n&quot;,</span>
<span class="lineNum">   10775 </span>            :                          ASM_COMMENT_START, name);
<span class="lineNum">   10776 </span>            :               break;
<span class="lineNum">   10777 </span>            :             }
<span class="lineNum">   10778 </span><span class="lineCov">      14626 :           dw2_asm_output_data (1, AT_flag (a), &quot;%s&quot;, name);</span>
<span class="lineNum">   10779 </span><span class="lineCov">      14626 :           break;</span>
<span class="lineNum">   10780 </span>            : 
<span class="lineNum">   10781 </span><span class="lineCov">    5791298 :         case dw_val_class_loc_list:</span>
<span class="lineNum">   10782 </span><span class="lineCov">    5791298 :           output_loc_list_offset (a);</span>
<span class="lineNum">   10783 </span><span class="lineCov">    5791298 :           break;</span>
<span class="lineNum">   10784 </span>            : 
<span class="lineNum">   10785 </span><span class="lineCov">    5705885 :         case dw_val_class_view_list:</span>
<span class="lineNum">   10786 </span><span class="lineCov">    5705885 :           output_view_list_offset (a);</span>
<span class="lineNum">   10787 </span><span class="lineCov">    5705885 :           break;</span>
<span class="lineNum">   10788 </span>            : 
<span class="lineNum">   10789 </span><span class="lineCov">   52191104 :         case dw_val_class_die_ref:</span>
<span class="lineNum">   10790 </span><span class="lineCov">   52191104 :           if (AT_ref_external (a))</span>
<span class="lineNum">   10791 </span>            :             {
<span class="lineNum">   10792 </span><span class="lineCov">      26170 :               if (AT_ref (a)-&gt;comdat_type_p)</span>
<span class="lineNum">   10793 </span>            :                 {
<span class="lineNum">   10794 </span><span class="lineCov">         54 :                   comdat_type_node *type_node</span>
<span class="lineNum">   10795 </span><span class="lineCov">        108 :                     = AT_ref (a)-&gt;die_id.die_type_node;</span>
<span class="lineNum">   10796 </span>            : 
<span class="lineNum">   10797 </span><span class="lineCov">         54 :                   gcc_assert (type_node);</span>
<span class="lineNum">   10798 </span><span class="lineCov">         54 :                   output_signature (type_node-&gt;signature, name);</span>
<span class="lineNum">   10799 </span>            :                 }
<span class="lineNum">   10800 </span>            :               else
<span class="lineNum">   10801 </span>            :                 {
<span class="lineNum">   10802 </span><span class="lineCov">      52232 :                   const char *sym = AT_ref (a)-&gt;die_id.die_symbol;</span>
<span class="lineNum">   10803 </span><span class="lineCov">      26116 :                   int size;</span>
<span class="lineNum">   10804 </span>            : 
<span class="lineNum">   10805 </span><span class="lineCov">      26116 :                   gcc_assert (sym);</span>
<span class="lineNum">   10806 </span>            :                   /* In DWARF2, DW_FORM_ref_addr is sized by target address
<span class="lineNum">   10807 </span>            :                      length, whereas in DWARF3 it's always sized as an
<span class="lineNum">   10808 </span>            :                      offset.  */
<span class="lineNum">   10809 </span><span class="lineCov">      26116 :                   if (dwarf_version == 2)</span>
<span class="lineNum">   10810 </span><span class="lineCov">         39 :                     size = DWARF2_ADDR_SIZE;</span>
<span class="lineNum">   10811 </span>            :                   else
<span class="lineNum">   10812 </span>            :                     size = DWARF_OFFSET_SIZE;
<span class="lineNum">   10813 </span>            :                   /* ???  We cannot unconditionally output die_offset if
<span class="lineNum">   10814 </span>            :                      non-zero - others might create references to those
<span class="lineNum">   10815 </span>            :                      DIEs via symbols.
<span class="lineNum">   10816 </span>            :                      And we do not clear its DIE offset after outputting it
<span class="lineNum">   10817 </span>            :                      (and the label refers to the actual DIEs, not the
<span class="lineNum">   10818 </span>            :                      DWARF CU unit header which is when using label + offset
<span class="lineNum">   10819 </span>            :                      would be the correct thing to do).
<span class="lineNum">   10820 </span>            :                      ???  This is the reason for the with_offset flag.  */
<span class="lineNum">   10821 </span><span class="lineCov">      26116 :                   if (AT_ref (a)-&gt;with_offset)</span>
<span class="lineNum">   10822 </span><span class="lineCov">      26116 :                     dw2_asm_output_offset (size, sym, AT_ref (a)-&gt;die_offset,</span>
<span class="lineNum">   10823 </span>            :                                            debug_info_section, &quot;%s&quot;, name);
<span class="lineNum">   10824 </span>            :                   else
<span class="lineNum">   10825 </span><span class="lineNoCov">          0 :                     dw2_asm_output_offset (size, sym, debug_info_section, &quot;%s&quot;,</span>
<span class="lineNum">   10826 </span>            :                                            name);
<span class="lineNum">   10827 </span>            :                 }
<span class="lineNum">   10828 </span>            :             }
<span class="lineNum">   10829 </span>            :           else
<span class="lineNum">   10830 </span>            :             {
<span class="lineNum">   10831 </span><span class="lineCov">   52164934 :               gcc_assert (AT_ref (a)-&gt;die_offset);</span>
<span class="lineNum">   10832 </span><span class="lineCov">   52164934 :               dw2_asm_output_data (DWARF_OFFSET_SIZE, AT_ref (a)-&gt;die_offset,</span>
<span class="lineNum">   10833 </span>            :                                    &quot;%s&quot;, name);
<span class="lineNum">   10834 </span>            :             }
<span class="lineNum">   10835 </span>            :           break;
<span class="lineNum">   10836 </span>            : 
<span class="lineNum">   10837 </span><span class="lineNoCov">          0 :         case dw_val_class_fde_ref:</span>
<span class="lineNum">   10838 </span><span class="lineNoCov">          0 :           {</span>
<span class="lineNum">   10839 </span><span class="lineNoCov">          0 :             char l1[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">   10840 </span>            : 
<span class="lineNum">   10841 </span><span class="lineNoCov">          0 :             ASM_GENERATE_INTERNAL_LABEL (l1, FDE_LABEL,</span>
<span class="lineNum">   10842 </span>            :                                          a-&gt;dw_attr_val.v.val_fde_index * 2);
<span class="lineNum">   10843 </span><span class="lineNoCov">          0 :             dw2_asm_output_offset (DWARF_OFFSET_SIZE, l1, debug_frame_section,</span>
<span class="lineNum">   10844 </span><span class="lineNoCov">          0 :                                    &quot;%s&quot;, name);</span>
<span class="lineNum">   10845 </span>            :           }
<span class="lineNum">   10846 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   10847 </span>            : 
<span class="lineNum">   10848 </span><span class="lineNoCov">          0 :         case dw_val_class_vms_delta:</span>
<span class="lineNum">   10849 </span>            : #ifdef ASM_OUTPUT_DWARF_VMS_DELTA
<span class="lineNum">   10850 </span>            :           dw2_asm_output_vms_delta (DWARF_OFFSET_SIZE,
<span class="lineNum">   10851 </span>            :                                     AT_vms_delta2 (a), AT_vms_delta1 (a),
<span class="lineNum">   10852 </span>            :                                     &quot;%s&quot;, name);
<span class="lineNum">   10853 </span>            : #else
<span class="lineNum">   10854 </span><span class="lineNoCov">          0 :           dw2_asm_output_delta (DWARF_OFFSET_SIZE,</span>
<span class="lineNum">   10855 </span>            :                                 AT_vms_delta2 (a), AT_vms_delta1 (a),
<span class="lineNum">   10856 </span>            :                                 &quot;%s&quot;, name);
<span class="lineNum">   10857 </span>            : #endif
<span class="lineNum">   10858 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   10859 </span>            : 
<span class="lineNum">   10860 </span><span class="lineCov">    7797583 :         case dw_val_class_lbl_id:</span>
<span class="lineNum">   10861 </span><span class="lineCov">    7797583 :           output_attr_index_or_value (a);</span>
<span class="lineNum">   10862 </span><span class="lineCov">    7797583 :           break;</span>
<span class="lineNum">   10863 </span>            : 
<span class="lineNum">   10864 </span><span class="lineCov">      34164 :         case dw_val_class_lineptr:</span>
<span class="lineNum">   10865 </span><span class="lineCov">      34164 :           dw2_asm_output_offset (DWARF_OFFSET_SIZE, AT_lbl (a),</span>
<span class="lineNum">   10866 </span>            :                                  debug_line_section, &quot;%s&quot;, name);
<span class="lineNum">   10867 </span><span class="lineCov">      34164 :           break;</span>
<span class="lineNum">   10868 </span>            : 
<span class="lineNum">   10869 </span><span class="lineCov">        444 :         case dw_val_class_macptr:</span>
<span class="lineNum">   10870 </span><span class="lineCov">        444 :           dw2_asm_output_offset (DWARF_OFFSET_SIZE, AT_lbl (a),</span>
<span class="lineNum">   10871 </span>            :                                  debug_macinfo_section, &quot;%s&quot;, name);
<span class="lineNum">   10872 </span><span class="lineCov">        444 :           break;</span>
<span class="lineNum">   10873 </span>            : 
<span class="lineNum">   10874 </span><span class="lineNoCov">          0 :         case dw_val_class_loclistsptr:</span>
<span class="lineNum">   10875 </span><span class="lineNoCov">          0 :           dw2_asm_output_offset (DWARF_OFFSET_SIZE, AT_lbl (a),</span>
<span class="lineNum">   10876 </span>            :                                  debug_loc_section, &quot;%s&quot;, name);
<span class="lineNum">   10877 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   10878 </span>            : 
<span class="lineNum">   10879 </span><span class="lineCov">   21293678 :         case dw_val_class_str:</span>
<span class="lineNum">   10880 </span><span class="lineCov">   21293678 :           if (a-&gt;dw_attr_val.v.val_str-&gt;form == DW_FORM_strp)</span>
<span class="lineNum">   10881 </span><span class="lineCov">   18905271 :             dw2_asm_output_offset (DWARF_OFFSET_SIZE,</span>
<span class="lineNum">   10882 </span><span class="lineCov">   18905271 :                                    a-&gt;dw_attr_val.v.val_str-&gt;label,</span>
<span class="lineNum">   10883 </span>            :                                    debug_str_section,
<span class="lineNum">   10884 </span>            :                                    &quot;%s: \&quot;%s\&quot;&quot;, name, AT_string (a));
<span class="lineNum">   10885 </span><span class="lineCov">    2388407 :           else if (a-&gt;dw_attr_val.v.val_str-&gt;form == DW_FORM_line_strp)</span>
<span class="lineNum">   10886 </span><span class="lineNoCov">          0 :             dw2_asm_output_offset (DWARF_OFFSET_SIZE,</span>
<span class="lineNum">   10887 </span><span class="lineNoCov">          0 :                                    a-&gt;dw_attr_val.v.val_str-&gt;label,</span>
<span class="lineNum">   10888 </span>            :                                    debug_line_str_section,
<span class="lineNum">   10889 </span>            :                                    &quot;%s: \&quot;%s\&quot;&quot;, name, AT_string (a));
<span class="lineNum">   10890 </span><span class="lineCov">    4776703 :           else if (a-&gt;dw_attr_val.v.val_str-&gt;form == dwarf_FORM (DW_FORM_strx))</span>
<span class="lineNum">   10891 </span><span class="lineCov">         21 :             dw2_asm_output_data_uleb128 (AT_index (a),</span>
<span class="lineNum">   10892 </span>            :                                          &quot;%s: \&quot;%s\&quot;&quot;, name, AT_string (a));
<span class="lineNum">   10893 </span>            :           else
<span class="lineNum">   10894 </span><span class="lineCov">    2388386 :             dw2_asm_output_nstring (AT_string (a), -1, &quot;%s&quot;, name);</span>
<span class="lineNum">   10895 </span>            :           break;
<span class="lineNum">   10896 </span>            : 
<span class="lineNum">   10897 </span><span class="lineCov">   18013392 :         case dw_val_class_file:</span>
<span class="lineNum">   10898 </span><span class="lineCov">   18013392 :           {</span>
<span class="lineNum">   10899 </span><span class="lineCov">   18013392 :             int f = maybe_emit_file (a-&gt;dw_attr_val.v.val_file);</span>
<span class="lineNum">   10900 </span>            : 
<span class="lineNum">   10901 </span><span class="lineCov">   54040176 :             dw2_asm_output_data (constant_size (f), f, &quot;%s (%s)&quot;, name,</span>
<span class="lineNum">   10902 </span><span class="lineCov">   18013392 :                                  a-&gt;dw_attr_val.v.val_file-&gt;filename);</span>
<span class="lineNum">   10903 </span><span class="lineCov">   18013392 :             break;</span>
<span class="lineNum">   10904 </span>            :           }
<span class="lineNum">   10905 </span>            : 
<span class="lineNum">   10906 </span><span class="lineCov">         63 :         case dw_val_class_file_implicit:</span>
<span class="lineNum">   10907 </span><span class="lineCov">         63 :           if (flag_debug_asm)</span>
<span class="lineNum">   10908 </span><span class="lineCov">         52 :             fprintf (asm_out_file, &quot;\t\t\t%s %s (%d, %s)\n&quot;,</span>
<span class="lineNum">   10909 </span>            :                      ASM_COMMENT_START, name,
<span class="lineNum">   10910 </span>            :                      maybe_emit_file (a-&gt;dw_attr_val.v.val_file),
<span class="lineNum">   10911 </span><span class="lineCov">         52 :                      a-&gt;dw_attr_val.v.val_file-&gt;filename);</span>
<span class="lineNum">   10912 </span>            :           break;
<span class="lineNum">   10913 </span>            : 
<span class="lineNum">   10914 </span>            :         case dw_val_class_data8:
<span class="lineNum">   10915 </span>            :           {
<span class="lineNum">   10916 </span>            :             int i;
<span class="lineNum">   10917 </span>            : 
<span class="lineNum">   10918 </span><span class="lineCov">        486 :             for (i = 0; i &lt; 8; i++)</span>
<span class="lineNum">   10919 </span><span class="lineCov">        810 :               dw2_asm_output_data (1, a-&gt;dw_attr_val.v.val_data8[i],</span>
<span class="lineNum">   10920 </span>            :                                    i == 0 ? &quot;%s&quot; : NULL, name);
<span class="lineNum">   10921 </span>            :             break;
<span class="lineNum">   10922 </span>            :           }
<span class="lineNum">   10923 </span>            : 
<span class="lineNum">   10924 </span><span class="lineCov">    2722768 :         case dw_val_class_high_pc:</span>
<span class="lineNum">   10925 </span><span class="lineCov">    2722768 :           dw2_asm_output_delta (DWARF2_ADDR_SIZE, AT_lbl (a),</span>
<span class="lineNum">   10926 </span>            :                                 get_AT_low_pc (die), &quot;DW_AT_high_pc&quot;);
<span class="lineNum">   10927 </span><span class="lineCov">    2722768 :           break;</span>
<span class="lineNum">   10928 </span>            : 
<span class="lineNum">   10929 </span><span class="lineNoCov">          0 :         case dw_val_class_discr_value:</span>
<span class="lineNum">   10930 </span><span class="lineNoCov">          0 :           output_discr_value (&amp;a-&gt;dw_attr_val.v.val_discr_value, name);</span>
<span class="lineNum">   10931 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   10932 </span>            : 
<span class="lineNum">   10933 </span><span class="lineNoCov">          0 :         case dw_val_class_discr_list:</span>
<span class="lineNum">   10934 </span><span class="lineNoCov">          0 :           {</span>
<span class="lineNum">   10935 </span><span class="lineNoCov">          0 :             dw_discr_list_ref list = AT_discr_list (a);</span>
<span class="lineNum">   10936 </span><span class="lineNoCov">          0 :             const int size = size_of_discr_list (list);</span>
<span class="lineNum">   10937 </span>            : 
<span class="lineNum">   10938 </span>            :             /* This is a block, so output its length first.  */
<span class="lineNum">   10939 </span><span class="lineNoCov">          0 :             dw2_asm_output_data (constant_size (size), size,</span>
<span class="lineNum">   10940 </span>            :                                  &quot;%s: block size&quot;, name);
<span class="lineNum">   10941 </span>            : 
<span class="lineNum">   10942 </span><span class="lineNoCov">          0 :             for (; list != NULL; list = list-&gt;dw_discr_next)</span>
<span class="lineNum">   10943 </span>            :               {
<span class="lineNum">   10944 </span>            :                 /* One byte for the discriminant value descriptor, and then as
<span class="lineNum">   10945 </span>            :                    many LEB128 numbers as required.  */
<span class="lineNum">   10946 </span><span class="lineNoCov">          0 :                 if (list-&gt;dw_discr_range)</span>
<span class="lineNum">   10947 </span><span class="lineNoCov">          0 :                   dw2_asm_output_data (1, DW_DSC_range,</span>
<span class="lineNum">   10948 </span>            :                                        &quot;%s: DW_DSC_range&quot;, name);
<span class="lineNum">   10949 </span>            :                 else
<span class="lineNum">   10950 </span><span class="lineNoCov">          0 :                   dw2_asm_output_data (1, DW_DSC_label,</span>
<span class="lineNum">   10951 </span>            :                                        &quot;%s: DW_DSC_label&quot;, name);
<span class="lineNum">   10952 </span>            : 
<span class="lineNum">   10953 </span><span class="lineNoCov">          0 :                 output_discr_value (&amp;list-&gt;dw_discr_lower_bound, name);</span>
<span class="lineNum">   10954 </span><span class="lineNoCov">          0 :                 if (list-&gt;dw_discr_range)</span>
<span class="lineNum">   10955 </span><span class="lineNoCov">          0 :                   output_discr_value (&amp;list-&gt;dw_discr_upper_bound, name);</span>
<span class="lineNum">   10956 </span>            :               }
<span class="lineNum">   10957 </span>            :             break;
<span class="lineNum">   10958 </span>            :           }
<span class="lineNum">   10959 </span>            : 
<span class="lineNum">   10960 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">   10961 </span><span class="lineNoCov">          0 :           gcc_unreachable ();</span>
<span class="lineNum">   10962 </span>            :         }
<span class="lineNum">   10963 </span>            :     }
<span class="lineNum">   10964 </span>            : 
<span class="lineNum">   10965 </span><span class="lineCov">   80834201 :   FOR_EACH_CHILD (die, c, output_die (c));</span>
<span class="lineNum">   10966 </span>            : 
<span class="lineNum">   10967 </span>            :   /* Add null byte to terminate sibling list.  */
<span class="lineNum">   10968 </span><span class="lineCov">   46334209 :   if (die-&gt;die_child != NULL)</span>
<span class="lineNum">   10969 </span><span class="lineCov">   23600110 :     dw2_asm_output_data (1, 0, &quot;end of children of DIE %#lx&quot;,</span>
<span class="lineNum">   10970 </span><span class="lineCov">   11800055 :                          (unsigned long) die-&gt;die_offset);</span>
<span class="lineNum">   10971 </span><span class="lineCov">   46334209 : }</span>
<span class="lineNum">   10972 </span>            : 
<span class="lineNum">   10973 </span>            : /* Output the dwarf version number.  */
<a name="10974"><span class="lineNum">   10974 </span>            : </a>
<span class="lineNum">   10975 </span>            : static void
<span class="lineNum">   10976 </span><span class="lineCov">      34984 : output_dwarf_version ()</span>
<span class="lineNum">   10977 </span>            : {
<span class="lineNum">   10978 </span>            :   /* ??? For now, if -gdwarf-6 is specified, we output version 5 with
<span class="lineNum">   10979 </span>            :      views in loclist.  That will change eventually.  */
<span class="lineNum">   10980 </span><span class="lineCov">      34984 :   if (dwarf_version == 6)</span>
<span class="lineNum">   10981 </span>            :     {
<span class="lineNum">   10982 </span><span class="lineNoCov">          0 :       static bool once;</span>
<span class="lineNum">   10983 </span><span class="lineNoCov">          0 :       if (!once)</span>
<span class="lineNum">   10984 </span>            :         {
<span class="lineNum">   10985 </span><span class="lineNoCov">          0 :           warning (0,</span>
<span class="lineNum">   10986 </span>            :                    &quot;-gdwarf-6 is output as version 5 with incompatibilities&quot;);
<span class="lineNum">   10987 </span><span class="lineNoCov">          0 :           once = true;</span>
<span class="lineNum">   10988 </span>            :         }
<span class="lineNum">   10989 </span><span class="lineNoCov">          0 :       dw2_asm_output_data (2, 5, &quot;DWARF version number&quot;);</span>
<span class="lineNum">   10990 </span>            :     }
<span class="lineNum">   10991 </span>            :   else
<span class="lineNum">   10992 </span><span class="lineCov">      34984 :     dw2_asm_output_data (2, dwarf_version, &quot;DWARF version number&quot;);</span>
<span class="lineNum">   10993 </span><span class="lineCov">      34984 : }</span>
<span class="lineNum">   10994 </span>            : 
<span class="lineNum">   10995 </span>            : /* Output the compilation unit that appears at the beginning of the
<span class="lineNum">   10996 </span>            :    .debug_info section, and precedes the DIE descriptions.  */
<a name="10997"><span class="lineNum">   10997 </span>            : </a>
<span class="lineNum">   10998 </span>            : static void
<span class="lineNum">   10999 </span><span class="lineCov">      34158 : output_compilation_unit_header (enum dwarf_unit_type ut)</span>
<span class="lineNum">   11000 </span>            : {
<span class="lineNum">   11001 </span><span class="lineCov">      34158 :   if (!XCOFF_DEBUGGING_INFO)</span>
<span class="lineNum">   11002 </span>            :     {
<span class="lineNum">   11003 </span><span class="lineCov">      34158 :       if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)</span>
<span class="lineNum">   11004 </span>            :         dw2_asm_output_data (4, 0xffffffff,
<span class="lineNum">   11005 </span>            :           &quot;Initial length escape value indicating 64-bit DWARF extension&quot;);
<span class="lineNum">   11006 </span><span class="lineCov">      34158 :       dw2_asm_output_data (DWARF_OFFSET_SIZE,</span>
<span class="lineNum">   11007 </span>            :                            next_die_offset - DWARF_INITIAL_LENGTH_SIZE,
<span class="lineNum">   11008 </span>            :                            &quot;Length of Compilation Unit Info&quot;);
<span class="lineNum">   11009 </span>            :     }
<span class="lineNum">   11010 </span>            : 
<span class="lineNum">   11011 </span><span class="lineCov">      34158 :   output_dwarf_version ();</span>
<span class="lineNum">   11012 </span><span class="lineCov">      34158 :   if (dwarf_version &gt;= 5)</span>
<span class="lineNum">   11013 </span>            :     {
<span class="lineNum">   11014 </span><span class="lineCov">         18 :       const char *name;</span>
<span class="lineNum">   11015 </span><span class="lineCov">         18 :       switch (ut)</span>
<span class="lineNum">   11016 </span>            :         {
<span class="lineNum">   11017 </span>            :         case DW_UT_compile: name = &quot;DW_UT_compile&quot;; break;
<span class="lineNum">   11018 </span><span class="lineNoCov">          0 :         case DW_UT_type: name = &quot;DW_UT_type&quot;; break;</span>
<span class="lineNum">   11019 </span><span class="lineNoCov">          0 :         case DW_UT_split_compile: name = &quot;DW_UT_split_compile&quot;; break;</span>
<span class="lineNum">   11020 </span><span class="lineNoCov">          0 :         case DW_UT_split_type: name = &quot;DW_UT_split_type&quot;; break;</span>
<span class="lineNum">   11021 </span><span class="lineNoCov">          0 :         default: gcc_unreachable ();</span>
<span class="lineNum">   11022 </span>            :         }
<span class="lineNum">   11023 </span><span class="lineCov">         18 :       dw2_asm_output_data (1, ut, &quot;%s&quot;, name);</span>
<span class="lineNum">   11024 </span><span class="lineCov">         18 :       dw2_asm_output_data (1, DWARF2_ADDR_SIZE, &quot;Pointer Size (in bytes)&quot;);</span>
<span class="lineNum">   11025 </span>            :     }
<span class="lineNum">   11026 </span><span class="lineCov">      34158 :   dw2_asm_output_offset (DWARF_OFFSET_SIZE, abbrev_section_label,</span>
<span class="lineNum">   11027 </span>            :                          debug_abbrev_section,
<span class="lineNum">   11028 </span>            :                          &quot;Offset Into Abbrev. Section&quot;);
<span class="lineNum">   11029 </span><span class="lineCov">      34158 :   if (dwarf_version &lt; 5)</span>
<span class="lineNum">   11030 </span><span class="lineCov">      38903 :     dw2_asm_output_data (1, DWARF2_ADDR_SIZE, &quot;Pointer Size (in bytes)&quot;);</span>
<span class="lineNum">   11031 </span><span class="lineCov">      34158 : }</span>
<span class="lineNum">   11032 </span>            : 
<span class="lineNum">   11033 </span>            : /* Output the compilation unit DIE and its children.  */
<a name="11034"><span class="lineNum">   11034 </span>            : </a>
<span class="lineNum">   11035 </span>            : static void
<span class="lineNum">   11036 </span><span class="lineCov">      34499 : output_comp_unit (dw_die_ref die, int output_if_empty,</span>
<span class="lineNum">   11037 </span>            :                   const unsigned char *dwo_id)
<span class="lineNum">   11038 </span>            : {
<span class="lineNum">   11039 </span><span class="lineCov">      34499 :   const char *secname, *oldsym;</span>
<span class="lineNum">   11040 </span><span class="lineCov">      34499 :   char *tmp;</span>
<span class="lineNum">   11041 </span>            : 
<span class="lineNum">   11042 </span>            :   /* Unless we are outputting main CU, we may throw away empty ones.  */
<span class="lineNum">   11043 </span><span class="lineCov">      34499 :   if (!output_if_empty &amp;&amp; die-&gt;die_child == NULL)</span>
<span class="lineNum">   11044 </span>            :     return;
<span class="lineNum">   11045 </span>            : 
<span class="lineNum">   11046 </span>            :   /* Even if there are no children of this DIE, we must output the information
<span class="lineNum">   11047 </span>            :      about the compilation unit.  Otherwise, on an empty translation unit, we
<span class="lineNum">   11048 </span>            :      will generate a present, but empty, .debug_info section.  IRIX 6.5 `nm'
<span class="lineNum">   11049 </span>            :      will then complain when examining the file.  First mark all the DIEs in
<span class="lineNum">   11050 </span>            :      this CU so we know which get local refs.  */
<span class="lineNum">   11051 </span><span class="lineCov">      34110 :   mark_dies (die);</span>
<span class="lineNum">   11052 </span>            : 
<span class="lineNum">   11053 </span><span class="lineCov">      34110 :   external_ref_hash_type *extern_map = optimize_external_refs (die);</span>
<span class="lineNum">   11054 </span>            : 
<span class="lineNum">   11055 </span>            :   /* For now, optimize only the main CU, in order to optimize the rest
<span class="lineNum">   11056 </span>            :      we'd need to see all of them earlier.  Leave the rest for post-linking
<span class="lineNum">   11057 </span>            :      tools like DWZ.  */
<span class="lineNum">   11058 </span><span class="lineCov">      34110 :   if (die == comp_unit_die ())</span>
<span class="lineNum">   11059 </span><span class="lineCov">      68220 :     abbrev_opt_start = vec_safe_length (abbrev_die_table);</span>
<span class="lineNum">   11060 </span>            : 
<span class="lineNum">   11061 </span><span class="lineCov">      34110 :   build_abbrev_table (die, extern_map);</span>
<span class="lineNum">   11062 </span>            : 
<span class="lineNum">   11063 </span><span class="lineCov">      34110 :   optimize_abbrev_table ();</span>
<span class="lineNum">   11064 </span>            : 
<span class="lineNum">   11065 </span><span class="lineCov">      34110 :   delete extern_map;</span>
<span class="lineNum">   11066 </span>            : 
<span class="lineNum">   11067 </span>            :   /* Initialize the beginning DIE offset - and calculate sizes/offsets.  */
<span class="lineNum">   11068 </span><span class="lineCov">      68220 :   next_die_offset = (dwo_id</span>
<span class="lineNum">   11069 </span><span class="lineCov">      34118 :                      ? DWARF_COMPILE_UNIT_SKELETON_HEADER_SIZE</span>
<span class="lineNum">   11070 </span><span class="lineCov">      34106 :                      : DWARF_COMPILE_UNIT_HEADER_SIZE);</span>
<span class="lineNum">   11071 </span><span class="lineCov">      34110 :   calc_die_sizes (die);</span>
<span class="lineNum">   11072 </span>            : 
<span class="lineNum">   11073 </span><span class="lineCov">      34110 :   oldsym = die-&gt;die_id.die_symbol;</span>
<span class="lineNum">   11074 </span><span class="lineCov">      34110 :   if (oldsym &amp;&amp; die-&gt;comdat_type_p)</span>
<span class="lineNum">   11075 </span>            :     {
<span class="lineNum">   11076 </span><span class="lineNoCov">          0 :       tmp = XALLOCAVEC (char, strlen (oldsym) + 24);</span>
<span class="lineNum">   11077 </span>            : 
<span class="lineNum">   11078 </span><span class="lineNoCov">          0 :       sprintf (tmp, &quot;.gnu.linkonce.wi.%s&quot;, oldsym);</span>
<span class="lineNum">   11079 </span><span class="lineNoCov">          0 :       secname = tmp;</span>
<span class="lineNum">   11080 </span><span class="lineNoCov">          0 :       die-&gt;die_id.die_symbol = NULL;</span>
<span class="lineNum">   11081 </span><span class="lineNoCov">          0 :       switch_to_section (get_section (secname, SECTION_DEBUG, NULL));</span>
<span class="lineNum">   11082 </span>            :     }
<span class="lineNum">   11083 </span>            :   else
<span class="lineNum">   11084 </span>            :     {
<span class="lineNum">   11085 </span><span class="lineCov">      34110 :       switch_to_section (debug_info_section);</span>
<span class="lineNum">   11086 </span><span class="lineCov">      34110 :       ASM_OUTPUT_LABEL (asm_out_file, debug_info_section_label);</span>
<span class="lineNum">   11087 </span><span class="lineCov">      34110 :       info_section_emitted = true;</span>
<span class="lineNum">   11088 </span>            :     }
<span class="lineNum">   11089 </span>            : 
<span class="lineNum">   11090 </span>            :   /* For LTO cross unit DIE refs we want a symbol on the start of the
<span class="lineNum">   11091 </span>            :      debuginfo section, not on the CU DIE.  */
<span class="lineNum">   11092 </span><span class="lineCov">      34110 :   if ((flag_generate_lto || flag_generate_offload) &amp;&amp; oldsym)</span>
<span class="lineNum">   11093 </span>            :     {
<span class="lineNum">   11094 </span>            :       /* ???  No way to get visibility assembled without a decl.  */
<span class="lineNum">   11095 </span><span class="lineCov">        808 :       tree decl = build_decl (UNKNOWN_LOCATION, VAR_DECL,</span>
<span class="lineNum">   11096 </span><span class="lineCov">        808 :                               get_identifier (oldsym), char_type_node);</span>
<span class="lineNum">   11097 </span><span class="lineCov">        808 :       TREE_PUBLIC (decl) = true;</span>
<span class="lineNum">   11098 </span><span class="lineCov">        808 :       TREE_STATIC (decl) = true;</span>
<span class="lineNum">   11099 </span><span class="lineCov">        808 :       DECL_ARTIFICIAL (decl) = true;</span>
<span class="lineNum">   11100 </span><span class="lineCov">        808 :       DECL_VISIBILITY (decl) = VISIBILITY_HIDDEN;</span>
<span class="lineNum">   11101 </span><span class="lineCov">        808 :       DECL_VISIBILITY_SPECIFIED (decl) = true;</span>
<span class="lineNum">   11102 </span><span class="lineCov">        808 :       targetm.asm_out.assemble_visibility (decl, VISIBILITY_HIDDEN);</span>
<span class="lineNum">   11103 </span>            : #ifdef ASM_WEAKEN_LABEL
<span class="lineNum">   11104 </span>            :       /* We prefer a .weak because that handles duplicates from duplicate
<span class="lineNum">   11105 </span>            :          archive members in a graceful way.  */
<span class="lineNum">   11106 </span><span class="lineCov">        808 :       ASM_WEAKEN_LABEL (asm_out_file, oldsym);</span>
<span class="lineNum">   11107 </span>            : #else
<span class="lineNum">   11108 </span>            :       targetm.asm_out.globalize_label (asm_out_file, oldsym);
<span class="lineNum">   11109 </span>            : #endif
<span class="lineNum">   11110 </span><span class="lineCov">        808 :       ASM_OUTPUT_LABEL (asm_out_file, oldsym);</span>
<span class="lineNum">   11111 </span>            :     }
<span class="lineNum">   11112 </span>            : 
<span class="lineNum">   11113 </span>            :   /* Output debugging information.  */
<span class="lineNum">   11114 </span><span class="lineCov">      68216 :   output_compilation_unit_header (dwo_id</span>
<span class="lineNum">   11115 </span>            :                                   ? DW_UT_split_compile : DW_UT_compile);
<span class="lineNum">   11116 </span><span class="lineCov">      34110 :   if (dwarf_version &gt;= 5)</span>
<span class="lineNum">   11117 </span>            :     {
<span class="lineNum">   11118 </span><span class="lineCov">         18 :       if (dwo_id != NULL)</span>
<span class="lineNum">   11119 </span><span class="lineNoCov">          0 :         for (int i = 0; i &lt; 8; i++)</span>
<span class="lineNum">   11120 </span><span class="lineNoCov">          0 :           dw2_asm_output_data (1, dwo_id[i], i == 0 ? &quot;DWO id&quot; : NULL);</span>
<span class="lineNum">   11121 </span>            :     }
<span class="lineNum">   11122 </span><span class="lineCov">      34110 :   output_die (die);</span>
<span class="lineNum">   11123 </span>            : 
<span class="lineNum">   11124 </span>            :   /* Leave the marks on the main CU, so we can check them in
<span class="lineNum">   11125 </span>            :      output_pubnames.  */
<span class="lineNum">   11126 </span><span class="lineCov">      34110 :   if (oldsym)</span>
<span class="lineNum">   11127 </span>            :     {
<span class="lineNum">   11128 </span><span class="lineCov">        808 :       unmark_dies (die);</span>
<span class="lineNum">   11129 </span><span class="lineCov">        808 :       die-&gt;die_id.die_symbol = oldsym;</span>
<span class="lineNum">   11130 </span>            :     }
<span class="lineNum">   11131 </span>            : }
<span class="lineNum">   11132 </span>            : 
<span class="lineNum">   11133 </span>            : /* Whether to generate the DWARF accelerator tables in .debug_pubnames
<span class="lineNum">   11134 </span>            :    and .debug_pubtypes.  This is configured per-target, but can be
<span class="lineNum">   11135 </span>            :    overridden by the -gpubnames or -gno-pubnames options.  */
<span class="lineNum">   11136 </span>            : 
<span class="lineNum">   11137 </span>            : static inline bool
<span class="lineNum">   11138 </span>            : want_pubnames (void)
<span class="lineNum">   11139 </span>            : {
<span class="lineNum">   11140 </span><span class="lineCov">   34104070 :   if (debug_info_level &lt;= DINFO_LEVEL_TERSE)</span>
<span class="lineNum">   11141 </span>            :     return false;
<span class="lineNum">   11142 </span><span class="lineCov">   34099501 :   if (debug_generate_pub_sections != -1)</span>
<span class="lineNum">   11143 </span><span class="lineCov">        315 :     return debug_generate_pub_sections;</span>
<span class="lineNum">   11144 </span><span class="lineCov">   34099186 :   return targetm.want_debug_pub_sections;</span>
<span class="lineNum">   11145 </span>            : }
<span class="lineNum">   11146 </span>            : 
<span class="lineNum">   11147 </span>            : /* Add the DW_AT_GNU_pubnames and DW_AT_GNU_pubtypes attributes.  */
<a name="11148"><span class="lineNum">   11148 </span>            : </a>
<span class="lineNum">   11149 </span>            : static void
<span class="lineNum">   11150 </span><span class="lineCov">      33603 : add_AT_pubnames (dw_die_ref die)</span>
<span class="lineNum">   11151 </span>            : {
<span class="lineNum">   11152 </span><span class="lineCov">      66394 :   if (want_pubnames ())</span>
<span class="lineNum">   11153 </span><span class="lineCov">          8 :     add_AT_flag (die, DW_AT_GNU_pubnames, 1);</span>
<span class="lineNum">   11154 </span><span class="lineCov">      33603 : }</span>
<span class="lineNum">   11155 </span>            : 
<span class="lineNum">   11156 </span>            : /* Add a string attribute value to a skeleton DIE.  */
<a name="11157"><span class="lineNum">   11157 </span>            : </a>
<span class="lineNum">   11158 </span>            : static inline void
<span class="lineNum">   11159 </span><span class="lineCov">          8 : add_skeleton_AT_string (dw_die_ref die, enum dwarf_attribute attr_kind,</span>
<span class="lineNum">   11160 </span>            :                         const char *str)
<span class="lineNum">   11161 </span>            : {
<span class="lineNum">   11162 </span><span class="lineCov">          8 :   dw_attr_node attr;</span>
<span class="lineNum">   11163 </span><span class="lineCov">          8 :   struct indirect_string_node *node;</span>
<span class="lineNum">   11164 </span>            : 
<span class="lineNum">   11165 </span><span class="lineCov">          8 :   if (! skeleton_debug_str_hash)</span>
<span class="lineNum">   11166 </span><span class="lineCov">          4 :     skeleton_debug_str_hash</span>
<span class="lineNum">   11167 </span><span class="lineCov">          4 :       = hash_table&lt;indirect_string_hasher&gt;::create_ggc (10);</span>
<span class="lineNum">   11168 </span>            : 
<span class="lineNum">   11169 </span><span class="lineCov">          8 :   node = find_AT_string_in_table (str, skeleton_debug_str_hash);</span>
<span class="lineNum">   11170 </span><span class="lineCov">          8 :   find_string_form (node);</span>
<span class="lineNum">   11171 </span><span class="lineCov">         16 :   if (node-&gt;form == dwarf_FORM (DW_FORM_strx))</span>
<span class="lineNum">   11172 </span><span class="lineCov">          8 :     node-&gt;form = DW_FORM_strp;</span>
<span class="lineNum">   11173 </span>            : 
<span class="lineNum">   11174 </span><span class="lineCov">          8 :   attr.dw_attr = attr_kind;</span>
<span class="lineNum">   11175 </span><span class="lineCov">          8 :   attr.dw_attr_val.val_class = dw_val_class_str;</span>
<span class="lineNum">   11176 </span><span class="lineCov">          8 :   attr.dw_attr_val.val_entry = NULL;</span>
<span class="lineNum">   11177 </span><span class="lineCov">          8 :   attr.dw_attr_val.v.val_str = node;</span>
<span class="lineNum">   11178 </span><span class="lineCov">          8 :   add_dwarf_attr (die, &amp;attr);</span>
<span class="lineNum">   11179 </span><span class="lineCov">          8 : }</span>
<span class="lineNum">   11180 </span>            : 
<span class="lineNum">   11181 </span>            : /* Helper function to generate top-level dies for skeleton debug_info and
<span class="lineNum">   11182 </span>            :    debug_types.  */
<a name="11183"><span class="lineNum">   11183 </span>            : </a>
<span class="lineNum">   11184 </span>            : static void
<span class="lineNum">   11185 </span><span class="lineCov">          4 : add_top_level_skeleton_die_attrs (dw_die_ref die)</span>
<span class="lineNum">   11186 </span>            : {
<span class="lineNum">   11187 </span><span class="lineCov">          4 :   const char *dwo_file_name = concat (aux_base_name, &quot;.dwo&quot;, NULL);</span>
<span class="lineNum">   11188 </span><span class="lineCov">          4 :   const char *comp_dir = comp_dir_string ();</span>
<span class="lineNum">   11189 </span>            : 
<span class="lineNum">   11190 </span><span class="lineCov">          8 :   add_skeleton_AT_string (die, dwarf_AT (DW_AT_dwo_name), dwo_file_name);</span>
<span class="lineNum">   11191 </span><span class="lineCov">          4 :   if (comp_dir != NULL)</span>
<span class="lineNum">   11192 </span><span class="lineCov">          4 :     add_skeleton_AT_string (die, DW_AT_comp_dir, comp_dir);</span>
<span class="lineNum">   11193 </span><span class="lineCov">          4 :   add_AT_pubnames (die);</span>
<span class="lineNum">   11194 </span><span class="lineCov">          8 :   add_AT_lineptr (die, dwarf_AT (DW_AT_addr_base), debug_addr_section_label);</span>
<span class="lineNum">   11195 </span><span class="lineCov">          4 : }</span>
<span class="lineNum">   11196 </span>            : 
<span class="lineNum">   11197 </span>            : /* Output skeleton debug sections that point to the dwo file.  */
<a name="11198"><span class="lineNum">   11198 </span>            : </a>
<span class="lineNum">   11199 </span>            : static void
<span class="lineNum">   11200 </span><span class="lineCov">          4 : output_skeleton_debug_sections (dw_die_ref comp_unit,</span>
<span class="lineNum">   11201 </span>            :                                 const unsigned char *dwo_id)
<span class="lineNum">   11202 </span>            : {
<span class="lineNum">   11203 </span>            :   /* These attributes will be found in the full debug_info section.  */
<span class="lineNum">   11204 </span><span class="lineCov">          4 :   remove_AT (comp_unit, DW_AT_producer);</span>
<span class="lineNum">   11205 </span><span class="lineCov">          4 :   remove_AT (comp_unit, DW_AT_language);</span>
<span class="lineNum">   11206 </span>            : 
<span class="lineNum">   11207 </span><span class="lineCov">          4 :   switch_to_section (debug_skeleton_info_section);</span>
<span class="lineNum">   11208 </span><span class="lineCov">          4 :   ASM_OUTPUT_LABEL (asm_out_file, debug_skeleton_info_section_label);</span>
<span class="lineNum">   11209 </span>            : 
<span class="lineNum">   11210 </span>            :   /* Produce the skeleton compilation-unit header.  This one differs enough from
<span class="lineNum">   11211 </span>            :      a normal CU header that it's better not to call output_compilation_unit
<span class="lineNum">   11212 </span>            :      header.  */
<span class="lineNum">   11213 </span><span class="lineCov">          4 :   if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)</span>
<span class="lineNum">   11214 </span>            :     dw2_asm_output_data (4, 0xffffffff,
<span class="lineNum">   11215 </span>            :                          &quot;Initial length escape value indicating 64-bit &quot;
<span class="lineNum">   11216 </span>            :                          &quot;DWARF extension&quot;);
<span class="lineNum">   11217 </span>            : 
<span class="lineNum">   11218 </span><span class="lineCov">          4 :   dw2_asm_output_data (DWARF_OFFSET_SIZE,</span>
<span class="lineNum">   11219 </span><span class="lineCov">          8 :                        DWARF_COMPILE_UNIT_SKELETON_HEADER_SIZE</span>
<span class="lineNum">   11220 </span><span class="lineCov">          4 :                        - DWARF_INITIAL_LENGTH_SIZE</span>
<span class="lineNum">   11221 </span><span class="lineCov">          4 :                        + size_of_die (comp_unit),</span>
<span class="lineNum">   11222 </span>            :                       &quot;Length of Compilation Unit Info&quot;);
<span class="lineNum">   11223 </span><span class="lineCov">          4 :   output_dwarf_version ();</span>
<span class="lineNum">   11224 </span><span class="lineCov">          4 :   if (dwarf_version &gt;= 5)</span>
<span class="lineNum">   11225 </span>            :     {
<span class="lineNum">   11226 </span><span class="lineNoCov">          0 :       dw2_asm_output_data (1, DW_UT_skeleton, &quot;DW_UT_skeleton&quot;);</span>
<span class="lineNum">   11227 </span><span class="lineNoCov">          0 :       dw2_asm_output_data (1, DWARF2_ADDR_SIZE, &quot;Pointer Size (in bytes)&quot;);</span>
<span class="lineNum">   11228 </span>            :     }
<span class="lineNum">   11229 </span><span class="lineCov">          4 :   dw2_asm_output_offset (DWARF_OFFSET_SIZE, debug_skeleton_abbrev_section_label,</span>
<span class="lineNum">   11230 </span>            :                          debug_skeleton_abbrev_section,
<span class="lineNum">   11231 </span>            :                          &quot;Offset Into Abbrev. Section&quot;);
<span class="lineNum">   11232 </span><span class="lineCov">          4 :   if (dwarf_version &lt; 5)</span>
<span class="lineNum">   11233 </span><span class="lineCov">          4 :     dw2_asm_output_data (1, DWARF2_ADDR_SIZE, &quot;Pointer Size (in bytes)&quot;);</span>
<span class="lineNum">   11234 </span>            :   else
<span class="lineNum">   11235 </span><span class="lineNoCov">          0 :     for (int i = 0; i &lt; 8; i++)</span>
<span class="lineNum">   11236 </span><span class="lineNoCov">          0 :       dw2_asm_output_data (1, dwo_id[i], i == 0 ? &quot;DWO id&quot; : NULL);</span>
<span class="lineNum">   11237 </span>            : 
<span class="lineNum">   11238 </span><span class="lineCov">          4 :   comp_unit-&gt;die_abbrev = SKELETON_COMP_DIE_ABBREV;</span>
<span class="lineNum">   11239 </span><span class="lineCov">          4 :   output_die (comp_unit);</span>
<span class="lineNum">   11240 </span>            : 
<span class="lineNum">   11241 </span>            :   /* Build the skeleton debug_abbrev section.  */
<span class="lineNum">   11242 </span><span class="lineCov">          4 :   switch_to_section (debug_skeleton_abbrev_section);</span>
<span class="lineNum">   11243 </span><span class="lineCov">          4 :   ASM_OUTPUT_LABEL (asm_out_file, debug_skeleton_abbrev_section_label);</span>
<span class="lineNum">   11244 </span>            : 
<span class="lineNum">   11245 </span><span class="lineCov">          4 :   output_die_abbrevs (SKELETON_COMP_DIE_ABBREV, comp_unit);</span>
<span class="lineNum">   11246 </span>            : 
<span class="lineNum">   11247 </span><span class="lineCov">          4 :   dw2_asm_output_data (1, 0, &quot;end of skeleton .debug_abbrev&quot;);</span>
<span class="lineNum">   11248 </span><span class="lineCov">          4 : }</span>
<span class="lineNum">   11249 </span>            : 
<span class="lineNum">   11250 </span>            : /* Output a comdat type unit DIE and its children.  */
<a name="11251"><span class="lineNum">   11251 </span>            : </a>
<span class="lineNum">   11252 </span>            : static void
<span class="lineNum">   11253 </span><span class="lineCov">         48 : output_comdat_type_unit (comdat_type_node *node)</span>
<span class="lineNum">   11254 </span>            : {
<span class="lineNum">   11255 </span><span class="lineCov">         48 :   const char *secname;</span>
<span class="lineNum">   11256 </span><span class="lineCov">         48 :   char *tmp;</span>
<span class="lineNum">   11257 </span><span class="lineCov">         48 :   int i;</span>
<span class="lineNum">   11258 </span>            : #if defined (OBJECT_FORMAT_ELF)
<span class="lineNum">   11259 </span><span class="lineCov">         48 :   tree comdat_key;</span>
<span class="lineNum">   11260 </span>            : #endif
<span class="lineNum">   11261 </span>            : 
<span class="lineNum">   11262 </span>            :   /* First mark all the DIEs in this CU so we know which get local refs.  */
<span class="lineNum">   11263 </span><span class="lineCov">         48 :   mark_dies (node-&gt;root_die);</span>
<span class="lineNum">   11264 </span>            : 
<span class="lineNum">   11265 </span><span class="lineCov">         48 :   external_ref_hash_type *extern_map = optimize_external_refs (node-&gt;root_die);</span>
<span class="lineNum">   11266 </span>            : 
<span class="lineNum">   11267 </span><span class="lineCov">         48 :   build_abbrev_table (node-&gt;root_die, extern_map);</span>
<span class="lineNum">   11268 </span>            : 
<span class="lineNum">   11269 </span><span class="lineCov">         48 :   delete extern_map;</span>
<span class="lineNum">   11270 </span><span class="lineCov">         48 :   extern_map = NULL;</span>
<span class="lineNum">   11271 </span>            : 
<span class="lineNum">   11272 </span>            :   /* Initialize the beginning DIE offset - and calculate sizes/offsets.  */
<span class="lineNum">   11273 </span><span class="lineCov">         48 :   next_die_offset = DWARF_COMDAT_TYPE_UNIT_HEADER_SIZE;</span>
<span class="lineNum">   11274 </span><span class="lineCov">         48 :   calc_die_sizes (node-&gt;root_die);</span>
<span class="lineNum">   11275 </span>            : 
<span class="lineNum">   11276 </span>            : #if defined (OBJECT_FORMAT_ELF)
<span class="lineNum">   11277 </span><span class="lineCov">         48 :   if (dwarf_version &gt;= 5)</span>
<span class="lineNum">   11278 </span>            :     {
<span class="lineNum">   11279 </span><span class="lineNoCov">          0 :       if (!dwarf_split_debug_info)</span>
<span class="lineNum">   11280 </span>            :         secname = &quot;.debug_info&quot;;
<span class="lineNum">   11281 </span>            :       else
<span class="lineNum">   11282 </span><span class="lineNoCov">          0 :         secname = &quot;.debug_info.dwo&quot;;</span>
<span class="lineNum">   11283 </span>            :     }
<span class="lineNum">   11284 </span><span class="lineCov">         48 :   else if (!dwarf_split_debug_info)</span>
<span class="lineNum">   11285 </span>            :     secname = &quot;.debug_types&quot;;
<span class="lineNum">   11286 </span>            :   else
<span class="lineNum">   11287 </span><span class="lineNoCov">          0 :     secname = &quot;.debug_types.dwo&quot;;</span>
<span class="lineNum">   11288 </span>            : 
<span class="lineNum">   11289 </span><span class="lineCov">         48 :   tmp = XALLOCAVEC (char, 4 + DWARF_TYPE_SIGNATURE_SIZE * 2);</span>
<span class="lineNum">   11290 </span><span class="lineCov">         48 :   sprintf (tmp, dwarf_version &gt;= 5 ? &quot;wi.&quot; : &quot;wt.&quot;);</span>
<span class="lineNum">   11291 </span><span class="lineCov">        432 :   for (i = 0; i &lt; DWARF_TYPE_SIGNATURE_SIZE; i++)</span>
<span class="lineNum">   11292 </span><span class="lineCov">        384 :     sprintf (tmp + 3 + i * 2, &quot;%02x&quot;, node-&gt;signature[i] &amp; 0xff);</span>
<span class="lineNum">   11293 </span><span class="lineCov">         48 :   comdat_key = get_identifier (tmp);</span>
<span class="lineNum">   11294 </span><span class="lineCov">         48 :   targetm.asm_out.named_section (secname,</span>
<span class="lineNum">   11295 </span>            :                                  SECTION_DEBUG | SECTION_LINKONCE,
<span class="lineNum">   11296 </span>            :                                  comdat_key);
<span class="lineNum">   11297 </span>            : #else
<span class="lineNum">   11298 </span>            :   tmp = XALLOCAVEC (char, 18 + DWARF_TYPE_SIGNATURE_SIZE * 2);
<span class="lineNum">   11299 </span>            :   sprintf (tmp, (dwarf_version &gt;= 5
<span class="lineNum">   11300 </span>            :                  ? &quot;.gnu.linkonce.wi.&quot; : &quot;.gnu.linkonce.wt.&quot;));
<span class="lineNum">   11301 </span>            :   for (i = 0; i &lt; DWARF_TYPE_SIGNATURE_SIZE; i++)
<span class="lineNum">   11302 </span>            :     sprintf (tmp + 17 + i * 2, &quot;%02x&quot;, node-&gt;signature[i] &amp; 0xff);
<span class="lineNum">   11303 </span>            :   secname = tmp;
<span class="lineNum">   11304 </span>            :   switch_to_section (get_section (secname, SECTION_DEBUG, NULL));
<span class="lineNum">   11305 </span>            : #endif
<span class="lineNum">   11306 </span>            : 
<span class="lineNum">   11307 </span>            :   /* Output debugging information.  */
<span class="lineNum">   11308 </span><span class="lineCov">         96 :   output_compilation_unit_header (dwarf_split_debug_info</span>
<span class="lineNum">   11309 </span>            :                                   ? DW_UT_split_type : DW_UT_type);
<span class="lineNum">   11310 </span><span class="lineCov">         48 :   output_signature (node-&gt;signature, &quot;Type Signature&quot;);</span>
<span class="lineNum">   11311 </span><span class="lineCov">         48 :   dw2_asm_output_data (DWARF_OFFSET_SIZE, node-&gt;type_die-&gt;die_offset,</span>
<span class="lineNum">   11312 </span>            :                        &quot;Offset to Type DIE&quot;);
<span class="lineNum">   11313 </span><span class="lineCov">         48 :   output_die (node-&gt;root_die);</span>
<span class="lineNum">   11314 </span>            : 
<span class="lineNum">   11315 </span><span class="lineCov">         48 :   unmark_dies (node-&gt;root_die);</span>
<span class="lineNum">   11316 </span><span class="lineCov">         48 : }</span>
<span class="lineNum">   11317 </span>            : 
<span class="lineNum">   11318 </span>            : /* Return the DWARF2/3 pubname associated with a decl.  */
<a name="11319"><span class="lineNum">   11319 </span>            : </a>
<span class="lineNum">   11320 </span>            : static const char *
<span class="lineNum">   11321 </span><span class="lineCov">   22021806 : dwarf2_name (tree decl, int scope)</span>
<span class="lineNum">   11322 </span>            : {
<span class="lineNum">   11323 </span><span class="lineCov">   22021806 :   if (DECL_NAMELESS (decl))</span>
<span class="lineNum">   11324 </span>            :     return NULL;
<span class="lineNum">   11325 </span><span class="lineCov">   44021207 :   return lang_hooks.dwarf_name (decl, scope ? 1 : 0);</span>
<span class="lineNum">   11326 </span>            : }
<span class="lineNum">   11327 </span>            : 
<span class="lineNum">   11328 </span>            : /* Add a new entry to .debug_pubnames if appropriate.  */
<a name="11329"><span class="lineNum">   11329 </span>            : </a>
<span class="lineNum">   11330 </span>            : static void
<span class="lineNum">   11331 </span><span class="lineCov">        156 : add_pubname_string (const char *str, dw_die_ref die)</span>
<span class="lineNum">   11332 </span>            : {
<span class="lineNum">   11333 </span><span class="lineCov">        156 :   pubname_entry e;</span>
<span class="lineNum">   11334 </span>            : 
<span class="lineNum">   11335 </span><span class="lineCov">        156 :   e.die = die;</span>
<span class="lineNum">   11336 </span><span class="lineCov">        156 :   e.name = xstrdup (str);</span>
<span class="lineNum">   11337 </span><span class="lineCov">        156 :   vec_safe_push (pubname_table, e);</span>
<span class="lineNum">   11338 </span><span class="lineCov">        156 : }</span>
<a name="11339"><span class="lineNum">   11339 </span>            : </a>
<span class="lineNum">   11340 </span>            : static void
<span class="lineNum">   11341 </span><span class="lineCov">    9355946 : add_pubname (tree decl, dw_die_ref die)</span>
<span class="lineNum">   11342 </span>            : {
<span class="lineNum">   11343 </span><span class="lineCov">   18708940 :   if (!want_pubnames ())</span>
<span class="lineNum">   11344 </span>            :     return;
<span class="lineNum">   11345 </span>            : 
<span class="lineNum">   11346 </span>            :   /* Don't add items to the table when we expect that the consumer will have
<span class="lineNum">   11347 </span>            :      just read the enclosing die.  For example, if the consumer is looking at a
<span class="lineNum">   11348 </span>            :      class_member, it will either be inside the class already, or will have just
<span class="lineNum">   11349 </span>            :      looked up the class to find the member.  Either way, searching the class is
<span class="lineNum">   11350 </span>            :      faster than searching the index.  */
<span class="lineNum">   11351 </span><span class="lineCov">        351 :   if ((TREE_PUBLIC (decl) &amp;&amp; !class_scope_p (die-&gt;die_parent))</span>
<span class="lineNum">   11352 </span><span class="lineCov">        308 :       || is_cu_die (die-&gt;die_parent) || is_namespace_die (die-&gt;die_parent))</span>
<span class="lineNum">   11353 </span>            :     {
<span class="lineNum">   11354 </span><span class="lineCov">        136 :       const char *name = dwarf2_name (decl, 1);</span>
<span class="lineNum">   11355 </span>            : 
<span class="lineNum">   11356 </span><span class="lineCov">        136 :       if (name)</span>
<span class="lineNum">   11357 </span><span class="lineCov">        136 :         add_pubname_string (name, die);</span>
<span class="lineNum">   11358 </span>            :     }
<span class="lineNum">   11359 </span>            : }
<span class="lineNum">   11360 </span>            : 
<span class="lineNum">   11361 </span>            : /* Add an enumerator to the pubnames section.  */
<a name="11362"><span class="lineNum">   11362 </span>            : </a>
<span class="lineNum">   11363 </span>            : static void
<span class="lineNum">   11364 </span><span class="lineCov">         24 : add_enumerator_pubname (const char *scope_name, dw_die_ref die)</span>
<span class="lineNum">   11365 </span>            : {
<span class="lineNum">   11366 </span><span class="lineCov">         24 :   pubname_entry e;</span>
<span class="lineNum">   11367 </span>            : 
<span class="lineNum">   11368 </span><span class="lineCov">         24 :   gcc_assert (scope_name);</span>
<span class="lineNum">   11369 </span><span class="lineCov">         24 :   e.name = concat (scope_name, get_AT_string (die, DW_AT_name), NULL);</span>
<span class="lineNum">   11370 </span><span class="lineCov">         24 :   e.die = die;</span>
<span class="lineNum">   11371 </span><span class="lineCov">         24 :   vec_safe_push (pubname_table, e);</span>
<span class="lineNum">   11372 </span><span class="lineCov">         24 : }</span>
<span class="lineNum">   11373 </span>            : 
<span class="lineNum">   11374 </span>            : /* Add a new entry to .debug_pubtypes if appropriate.  */
<a name="11375"><span class="lineNum">   11375 </span>            : </a>
<span class="lineNum">   11376 </span>            : static void
<span class="lineNum">   11377 </span><span class="lineCov">   24641036 : add_pubtype (tree decl, dw_die_ref die)</span>
<span class="lineNum">   11378 </span>            : {
<span class="lineNum">   11379 </span><span class="lineCov">   24641036 :   pubname_entry e;</span>
<span class="lineNum">   11380 </span>            : 
<span class="lineNum">   11381 </span><span class="lineCov">   49282072 :   if (!want_pubnames ())</span>
<span class="lineNum">   11382 </span><span class="lineCov">   24640954 :     return;</span>
<span class="lineNum">   11383 </span>            : 
<span class="lineNum">   11384 </span><span class="lineCov">         82 :   if ((TREE_PUBLIC (decl)</span>
<span class="lineNum">   11385 </span><span class="lineCov">        115 :        || is_cu_die (die-&gt;die_parent) || is_namespace_die (die-&gt;die_parent))</span>
<span class="lineNum">   11386 </span><span class="lineCov">        141 :       &amp;&amp; (die-&gt;die_tag == DW_TAG_typedef || COMPLETE_TYPE_P (decl)))</span>
<span class="lineNum">   11387 </span>            :     {
<span class="lineNum">   11388 </span><span class="lineCov">         66 :       tree scope = NULL;</span>
<span class="lineNum">   11389 </span><span class="lineCov">         66 :       const char *scope_name = &quot;&quot;;</span>
<span class="lineNum">   11390 </span><span class="lineCov">         66 :       const char *sep = is_cxx () ? &quot;::&quot; : &quot;.&quot;;</span>
<span class="lineNum">   11391 </span><span class="lineCov">         66 :       const char *name;</span>
<span class="lineNum">   11392 </span>            : 
<span class="lineNum">   11393 </span><span class="lineCov">         66 :       scope = TYPE_P (decl) ? TYPE_CONTEXT (decl) : NULL;</span>
<span class="lineNum">   11394 </span><span class="lineCov">         66 :       if (scope &amp;&amp; TREE_CODE (scope) == NAMESPACE_DECL)</span>
<span class="lineNum">   11395 </span>            :         {
<span class="lineNum">   11396 </span><span class="lineCov">         36 :           scope_name = lang_hooks.dwarf_name (scope, 1);</span>
<span class="lineNum">   11397 </span><span class="lineCov">         36 :           if (scope_name != NULL &amp;&amp; scope_name[0] != '\0')</span>
<span class="lineNum">   11398 </span><span class="lineCov">         36 :             scope_name = concat (scope_name, sep, NULL);</span>
<span class="lineNum">   11399 </span>            :           else
<span class="lineNum">   11400 </span>            :             scope_name = &quot;&quot;;
<span class="lineNum">   11401 </span>            :         }
<span class="lineNum">   11402 </span>            : 
<span class="lineNum">   11403 </span><span class="lineCov">         66 :       if (TYPE_P (decl))</span>
<span class="lineNum">   11404 </span><span class="lineCov">         66 :         name = type_tag (decl);</span>
<span class="lineNum">   11405 </span>            :       else
<span class="lineNum">   11406 </span><span class="lineNoCov">          0 :         name = lang_hooks.dwarf_name (decl, 1);</span>
<span class="lineNum">   11407 </span>            : 
<span class="lineNum">   11408 </span>            :       /* If we don't have a name for the type, there's no point in adding
<span class="lineNum">   11409 </span>            :          it to the table.  */
<span class="lineNum">   11410 </span><span class="lineCov">         66 :       if (name != NULL &amp;&amp; name[0] != '\0')</span>
<span class="lineNum">   11411 </span>            :         {
<span class="lineNum">   11412 </span><span class="lineCov">         66 :           e.die = die;</span>
<span class="lineNum">   11413 </span><span class="lineCov">         66 :           e.name = concat (scope_name, name, NULL);</span>
<span class="lineNum">   11414 </span><span class="lineCov">         66 :           vec_safe_push (pubtype_table, e);</span>
<span class="lineNum">   11415 </span>            :         }
<span class="lineNum">   11416 </span>            : 
<span class="lineNum">   11417 </span>            :       /* Although it might be more consistent to add the pubinfo for the
<span class="lineNum">   11418 </span>            :          enumerators as their dies are created, they should only be added if the
<span class="lineNum">   11419 </span>            :          enum type meets the criteria above.  So rather than re-check the parent
<span class="lineNum">   11420 </span>            :          enum type whenever an enumerator die is created, just output them all
<span class="lineNum">   11421 </span>            :          here.  This isn't protected by the name conditional because anonymous
<span class="lineNum">   11422 </span>            :          enums don't have names.  */
<span class="lineNum">   11423 </span><span class="lineCov">         66 :       if (die-&gt;die_tag == DW_TAG_enumeration_type)</span>
<span class="lineNum">   11424 </span>            :         {
<span class="lineNum">   11425 </span><span class="lineCov">          8 :           dw_die_ref c;</span>
<span class="lineNum">   11426 </span>            : 
<span class="lineNum">   11427 </span><span class="lineCov">         24 :           FOR_EACH_CHILD (die, c, add_enumerator_pubname (scope_name, c));</span>
<span class="lineNum">   11428 </span>            :         }
<span class="lineNum">   11429 </span>            :     }
<span class="lineNum">   11430 </span>            : }
<span class="lineNum">   11431 </span>            : 
<span class="lineNum">   11432 </span>            : /* Output a single entry in the pubnames table.  */
<a name="11433"><span class="lineNum">   11433 </span>            : </a>
<span class="lineNum">   11434 </span>            : static void
<span class="lineNum">   11435 </span><span class="lineCov">        246 : output_pubname (dw_offset die_offset, pubname_entry *entry)</span>
<span class="lineNum">   11436 </span>            : {
<span class="lineNum">   11437 </span><span class="lineCov">        246 :   dw_die_ref die = entry-&gt;die;</span>
<span class="lineNum">   11438 </span><span class="lineCov">        246 :   int is_static = get_AT_flag (die, DW_AT_external) ? 0 : 1;</span>
<span class="lineNum">   11439 </span>            : 
<span class="lineNum">   11440 </span><span class="lineCov">        246 :   dw2_asm_output_data (DWARF_OFFSET_SIZE, die_offset, &quot;DIE offset&quot;);</span>
<span class="lineNum">   11441 </span>            : 
<span class="lineNum">   11442 </span><span class="lineCov">        246 :   if (debug_generate_pub_sections == 2)</span>
<span class="lineNum">   11443 </span>            :     {
<span class="lineNum">   11444 </span>            :       /* This logic follows gdb's method for determining the value of the flag
<span class="lineNum">   11445 </span>            :          byte.  */
<span class="lineNum">   11446 </span><span class="lineCov">         18 :       uint32_t flags = GDB_INDEX_SYMBOL_KIND_NONE;</span>
<span class="lineNum">   11447 </span><span class="lineCov">         18 :       switch (die-&gt;die_tag)</span>
<span class="lineNum">   11448 </span>            :       {
<span class="lineNum">   11449 </span><span class="lineCov">          4 :         case DW_TAG_typedef:</span>
<span class="lineNum">   11450 </span><span class="lineCov">          4 :         case DW_TAG_base_type:</span>
<span class="lineNum">   11451 </span><span class="lineCov">          4 :         case DW_TAG_subrange_type:</span>
<span class="lineNum">   11452 </span><span class="lineCov">          4 :           GDB_INDEX_SYMBOL_KIND_SET_VALUE(flags, GDB_INDEX_SYMBOL_KIND_TYPE);</span>
<span class="lineNum">   11453 </span><span class="lineCov">          4 :           GDB_INDEX_SYMBOL_STATIC_SET_VALUE(flags, 1);</span>
<span class="lineNum">   11454 </span><span class="lineCov">          4 :           break;</span>
<span class="lineNum">   11455 </span><span class="lineNoCov">          0 :         case DW_TAG_enumerator:</span>
<span class="lineNum">   11456 </span><span class="lineNoCov">          0 :           GDB_INDEX_SYMBOL_KIND_SET_VALUE(flags,</span>
<span class="lineNum">   11457 </span>            :                                           GDB_INDEX_SYMBOL_KIND_VARIABLE);
<span class="lineNum">   11458 </span><span class="lineNoCov">          0 :           if (!is_cxx ())</span>
<span class="lineNum">   11459 </span><span class="lineNoCov">          0 :             GDB_INDEX_SYMBOL_STATIC_SET_VALUE(flags, 1);</span>
<span class="lineNum">   11460 </span>            :           break;
<span class="lineNum">   11461 </span><span class="lineCov">          5 :         case DW_TAG_subprogram:</span>
<span class="lineNum">   11462 </span><span class="lineCov">          5 :           GDB_INDEX_SYMBOL_KIND_SET_VALUE(flags,</span>
<span class="lineNum">   11463 </span>            :                                           GDB_INDEX_SYMBOL_KIND_FUNCTION);
<span class="lineNum">   11464 </span><span class="lineCov">          5 :           if (!is_ada ())</span>
<span class="lineNum">   11465 </span><span class="lineCov">          5 :             GDB_INDEX_SYMBOL_STATIC_SET_VALUE(flags, is_static);</span>
<span class="lineNum">   11466 </span>            :           break;
<span class="lineNum">   11467 </span><span class="lineNoCov">          0 :         case DW_TAG_constant:</span>
<span class="lineNum">   11468 </span><span class="lineNoCov">          0 :           GDB_INDEX_SYMBOL_KIND_SET_VALUE(flags,</span>
<span class="lineNum">   11469 </span>            :                                           GDB_INDEX_SYMBOL_KIND_VARIABLE);
<span class="lineNum">   11470 </span><span class="lineNoCov">          0 :           GDB_INDEX_SYMBOL_STATIC_SET_VALUE(flags, is_static);</span>
<span class="lineNum">   11471 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   11472 </span><span class="lineCov">          7 :         case DW_TAG_variable:</span>
<span class="lineNum">   11473 </span><span class="lineCov">          7 :           GDB_INDEX_SYMBOL_KIND_SET_VALUE(flags,</span>
<span class="lineNum">   11474 </span>            :                                           GDB_INDEX_SYMBOL_KIND_VARIABLE);
<span class="lineNum">   11475 </span><span class="lineCov">          7 :           GDB_INDEX_SYMBOL_STATIC_SET_VALUE(flags, is_static);</span>
<span class="lineNum">   11476 </span><span class="lineCov">          7 :           break;</span>
<span class="lineNum">   11477 </span><span class="lineNoCov">          0 :         case DW_TAG_namespace:</span>
<span class="lineNum">   11478 </span><span class="lineNoCov">          0 :         case DW_TAG_imported_declaration:</span>
<span class="lineNum">   11479 </span><span class="lineNoCov">          0 :           GDB_INDEX_SYMBOL_KIND_SET_VALUE(flags, GDB_INDEX_SYMBOL_KIND_TYPE);</span>
<span class="lineNum">   11480 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   11481 </span><span class="lineCov">          2 :         case DW_TAG_class_type:</span>
<span class="lineNum">   11482 </span><span class="lineCov">          2 :         case DW_TAG_interface_type:</span>
<span class="lineNum">   11483 </span><span class="lineCov">          2 :         case DW_TAG_structure_type:</span>
<span class="lineNum">   11484 </span><span class="lineCov">          2 :         case DW_TAG_union_type:</span>
<span class="lineNum">   11485 </span><span class="lineCov">          2 :         case DW_TAG_enumeration_type:</span>
<span class="lineNum">   11486 </span><span class="lineCov">          2 :           GDB_INDEX_SYMBOL_KIND_SET_VALUE(flags, GDB_INDEX_SYMBOL_KIND_TYPE);</span>
<span class="lineNum">   11487 </span><span class="lineCov">          2 :           if (!is_cxx ())</span>
<span class="lineNum">   11488 </span><span class="lineNoCov">          0 :             GDB_INDEX_SYMBOL_STATIC_SET_VALUE(flags, 1);</span>
<span class="lineNum">   11489 </span>            :           break;
<span class="lineNum">   11490 </span>            :         default:
<span class="lineNum">   11491 </span>            :           /* An unusual tag.  Leave the flag-byte empty.  */
<span class="lineNum">   11492 </span>            :           break;
<span class="lineNum">   11493 </span>            :       }
<span class="lineNum">   11494 </span><span class="lineCov">         18 :       dw2_asm_output_data (1, flags &gt;&gt; GDB_INDEX_CU_BITSIZE,</span>
<span class="lineNum">   11495 </span>            :                            &quot;GDB-index flags&quot;);
<span class="lineNum">   11496 </span>            :     }
<span class="lineNum">   11497 </span>            : 
<span class="lineNum">   11498 </span><span class="lineCov">        246 :   dw2_asm_output_nstring (entry-&gt;name, -1, &quot;external name&quot;);</span>
<span class="lineNum">   11499 </span><span class="lineCov">        246 : }</span>
<span class="lineNum">   11500 </span>            : 
<span class="lineNum">   11501 </span>            : 
<span class="lineNum">   11502 </span>            : /* Output the public names table used to speed up access to externally
<span class="lineNum">   11503 </span>            :    visible names; or the public types table used to find type definitions.  */
<a name="11504"><span class="lineNum">   11504 </span>            : </a>
<span class="lineNum">   11505 </span>            : static void
<span class="lineNum">   11506 </span><span class="lineCov">         16 : output_pubnames (vec&lt;pubname_entry, va_gc&gt; *names)</span>
<span class="lineNum">   11507 </span>            : {
<span class="lineNum">   11508 </span><span class="lineCov">         16 :   unsigned i;</span>
<span class="lineNum">   11509 </span><span class="lineCov">         16 :   unsigned long pubnames_length = size_of_pubnames (names);</span>
<span class="lineNum">   11510 </span><span class="lineCov">         16 :   pubname_entry *pub;</span>
<span class="lineNum">   11511 </span>            : 
<span class="lineNum">   11512 </span><span class="lineCov">         16 :   if (!XCOFF_DEBUGGING_INFO)</span>
<span class="lineNum">   11513 </span>            :     {
<span class="lineNum">   11514 </span><span class="lineCov">         16 :       if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)</span>
<span class="lineNum">   11515 </span>            :         dw2_asm_output_data (4, 0xffffffff,
<span class="lineNum">   11516 </span>            :           &quot;Initial length escape value indicating 64-bit DWARF extension&quot;);
<span class="lineNum">   11517 </span><span class="lineCov">         16 :       dw2_asm_output_data (DWARF_OFFSET_SIZE, pubnames_length,</span>
<span class="lineNum">   11518 </span>            :                            &quot;Pub Info Length&quot;);
<span class="lineNum">   11519 </span>            :     }
<span class="lineNum">   11520 </span>            : 
<span class="lineNum">   11521 </span>            :   /* Version number for pubnames/pubtypes is independent of dwarf version.  */
<span class="lineNum">   11522 </span><span class="lineCov">         16 :   dw2_asm_output_data (2, 2, &quot;DWARF pubnames/pubtypes version&quot;);</span>
<span class="lineNum">   11523 </span>            : 
<span class="lineNum">   11524 </span><span class="lineCov">         16 :   if (dwarf_split_debug_info)</span>
<span class="lineNum">   11525 </span><span class="lineCov">          8 :     dw2_asm_output_offset (DWARF_OFFSET_SIZE, debug_skeleton_info_section_label,</span>
<span class="lineNum">   11526 </span>            :                            debug_skeleton_info_section,
<span class="lineNum">   11527 </span>            :                            &quot;Offset of Compilation Unit Info&quot;);
<span class="lineNum">   11528 </span>            :   else
<span class="lineNum">   11529 </span><span class="lineCov">          8 :     dw2_asm_output_offset (DWARF_OFFSET_SIZE, debug_info_section_label,</span>
<span class="lineNum">   11530 </span>            :                            debug_info_section,
<span class="lineNum">   11531 </span>            :                            &quot;Offset of Compilation Unit Info&quot;);
<span class="lineNum">   11532 </span><span class="lineCov">         16 :   dw2_asm_output_data (DWARF_OFFSET_SIZE, next_die_offset,</span>
<span class="lineNum">   11533 </span>            :                        &quot;Compilation Unit Length&quot;);
<span class="lineNum">   11534 </span>            : 
<span class="lineNum">   11535 </span><span class="lineCov">        262 :   FOR_EACH_VEC_ELT (*names, i, pub)</span>
<span class="lineNum">   11536 </span>            :     {
<span class="lineNum">   11537 </span><span class="lineCov">        246 :       if (include_pubname_in_output (names, pub))</span>
<span class="lineNum">   11538 </span>            :         {
<span class="lineNum">   11539 </span><span class="lineCov">        246 :           dw_offset die_offset = pub-&gt;die-&gt;die_offset;</span>
<span class="lineNum">   11540 </span>            : 
<span class="lineNum">   11541 </span>            :           /* We shouldn't see pubnames for DIEs outside of the main CU.  */
<span class="lineNum">   11542 </span><span class="lineCov">        246 :           if (names == pubname_table &amp;&amp; pub-&gt;die-&gt;die_tag != DW_TAG_enumerator)</span>
<span class="lineNum">   11543 </span><span class="lineCov">        156 :             gcc_assert (pub-&gt;die-&gt;die_mark);</span>
<span class="lineNum">   11544 </span>            : 
<span class="lineNum">   11545 </span>            :           /* If we're putting types in their own .debug_types sections,
<span class="lineNum">   11546 </span>            :              the .debug_pubtypes table will still point to the compile
<span class="lineNum">   11547 </span>            :              unit (not the type unit), so we want to use the offset of
<span class="lineNum">   11548 </span>            :              the skeleton DIE (if there is one).  */
<span class="lineNum">   11549 </span><span class="lineCov">        246 :           if (pub-&gt;die-&gt;comdat_type_p &amp;&amp; names == pubtype_table)</span>
<span class="lineNum">   11550 </span>            :             {
<span class="lineNum">   11551 </span><span class="lineCov">         22 :               comdat_type_node *type_node = pub-&gt;die-&gt;die_id.die_type_node;</span>
<span class="lineNum">   11552 </span>            : 
<span class="lineNum">   11553 </span><span class="lineCov">         22 :               if (type_node != NULL)</span>
<span class="lineNum">   11554 </span><span class="lineCov">         22 :                 die_offset = (type_node-&gt;skeleton_die != NULL</span>
<span class="lineNum">   11555 </span><span class="lineCov">         26 :                               ? type_node-&gt;skeleton_die-&gt;die_offset</span>
<span class="lineNum">   11556 </span><span class="lineCov">          4 :                               : comp_unit_die ()-&gt;die_offset);</span>
<span class="lineNum">   11557 </span>            :             }
<span class="lineNum">   11558 </span>            : 
<span class="lineNum">   11559 </span><span class="lineCov">        246 :           output_pubname (die_offset, pub);</span>
<span class="lineNum">   11560 </span>            :         }
<span class="lineNum">   11561 </span>            :     }
<span class="lineNum">   11562 </span>            : 
<span class="lineNum">   11563 </span><span class="lineCov">         16 :   dw2_asm_output_data (DWARF_OFFSET_SIZE, 0, NULL);</span>
<span class="lineNum">   11564 </span><span class="lineCov">         16 : }</span>
<span class="lineNum">   11565 </span>            : 
<span class="lineNum">   11566 </span>            : /* Output public names and types tables if necessary.  */
<a name="11567"><span class="lineNum">   11567 </span>            : </a>
<span class="lineNum">   11568 </span>            : static void
<span class="lineNum">   11569 </span><span class="lineCov">      33687 : output_pubtables (void)</span>
<span class="lineNum">   11570 </span>            : {
<span class="lineNum">   11571 </span><span class="lineCov">      66569 :   if (!want_pubnames () || !info_section_emitted)</span>
<span class="lineNum">   11572 </span>            :     return;
<span class="lineNum">   11573 </span>            : 
<span class="lineNum">   11574 </span><span class="lineCov">          8 :   switch_to_section (debug_pubnames_section);</span>
<span class="lineNum">   11575 </span><span class="lineCov">          8 :   output_pubnames (pubname_table);</span>
<span class="lineNum">   11576 </span>            :   /* ??? Only defined by DWARF3, but emitted by Darwin for DWARF2.
<span class="lineNum">   11577 </span>            :      It shouldn't hurt to emit it always, since pure DWARF2 consumers
<span class="lineNum">   11578 </span>            :      simply won't look for the section.  */
<span class="lineNum">   11579 </span><span class="lineCov">          8 :   switch_to_section (debug_pubtypes_section);</span>
<span class="lineNum">   11580 </span><span class="lineCov">          8 :   output_pubnames (pubtype_table);</span>
<span class="lineNum">   11581 </span>            : }
<span class="lineNum">   11582 </span>            : 
<span class="lineNum">   11583 </span>            : 
<span class="lineNum">   11584 </span>            : /* Output the information that goes into the .debug_aranges table.
<span class="lineNum">   11585 </span>            :    Namely, define the beginning and ending address range of the
<span class="lineNum">   11586 </span>            :    text section generated for this compilation unit.  */
<a name="11587"><span class="lineNum">   11587 </span>            : </a>
<span class="lineNum">   11588 </span>            : static void
<span class="lineNum">   11589 </span><span class="lineCov">      33302 : output_aranges (void)</span>
<span class="lineNum">   11590 </span>            : {
<span class="lineNum">   11591 </span><span class="lineCov">      33302 :   unsigned i;</span>
<span class="lineNum">   11592 </span><span class="lineCov">      33302 :   unsigned long aranges_length = size_of_aranges ();</span>
<span class="lineNum">   11593 </span>            :   
<span class="lineNum">   11594 </span><span class="lineCov">      33302 :   if (!XCOFF_DEBUGGING_INFO)</span>
<span class="lineNum">   11595 </span>            :     {
<span class="lineNum">   11596 </span><span class="lineCov">      33302 :       if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)</span>
<span class="lineNum">   11597 </span>            :         dw2_asm_output_data (4, 0xffffffff,
<span class="lineNum">   11598 </span>            :           &quot;Initial length escape value indicating 64-bit DWARF extension&quot;);
<span class="lineNum">   11599 </span><span class="lineCov">      33302 :       dw2_asm_output_data (DWARF_OFFSET_SIZE, aranges_length,</span>
<span class="lineNum">   11600 </span>            :                            &quot;Length of Address Ranges Info&quot;);
<span class="lineNum">   11601 </span>            :     }
<span class="lineNum">   11602 </span>            : 
<span class="lineNum">   11603 </span>            :   /* Version number for aranges is still 2, even up to DWARF5.  */
<span class="lineNum">   11604 </span><span class="lineCov">      33302 :   dw2_asm_output_data (2, 2, &quot;DWARF aranges version&quot;);</span>
<span class="lineNum">   11605 </span><span class="lineCov">      33302 :   if (dwarf_split_debug_info)</span>
<span class="lineNum">   11606 </span><span class="lineCov">          4 :     dw2_asm_output_offset (DWARF_OFFSET_SIZE, debug_skeleton_info_section_label,</span>
<span class="lineNum">   11607 </span>            :                            debug_skeleton_info_section,
<span class="lineNum">   11608 </span>            :                            &quot;Offset of Compilation Unit Info&quot;);
<span class="lineNum">   11609 </span>            :   else
<span class="lineNum">   11610 </span><span class="lineCov">      33298 :     dw2_asm_output_offset (DWARF_OFFSET_SIZE, debug_info_section_label,</span>
<span class="lineNum">   11611 </span>            :                            debug_info_section,
<span class="lineNum">   11612 </span>            :                            &quot;Offset of Compilation Unit Info&quot;);
<span class="lineNum">   11613 </span><span class="lineCov">      38065 :   dw2_asm_output_data (1, DWARF2_ADDR_SIZE, &quot;Size of Address&quot;);</span>
<span class="lineNum">   11614 </span><span class="lineCov">      33302 :   dw2_asm_output_data (1, 0, &quot;Size of Segment Descriptor&quot;);</span>
<span class="lineNum">   11615 </span>            : 
<span class="lineNum">   11616 </span>            :   /* We need to align to twice the pointer size here.  */
<span class="lineNum">   11617 </span><span class="lineCov">      33302 :   if (DWARF_ARANGES_PAD_SIZE)</span>
<span class="lineNum">   11618 </span>            :     {
<span class="lineNum">   11619 </span>            :       /* Pad using a 2 byte words so that padding is correct for any
<span class="lineNum">   11620 </span>            :          pointer size.  */
<span class="lineNum">   11621 </span><span class="lineCov">      33302 :       dw2_asm_output_data (2, 0, &quot;Pad to %d byte boundary&quot;,</span>
<span class="lineNum">   11622 </span>            :                            2 * DWARF2_ADDR_SIZE);
<span class="lineNum">   11623 </span><span class="lineCov">      85656 :       for (i = 2; i &lt; (unsigned) DWARF_ARANGES_PAD_SIZE; i += 2)</span>
<span class="lineNum">   11624 </span><span class="lineCov">      33302 :         dw2_asm_output_data (2, 0, NULL);</span>
<span class="lineNum">   11625 </span>            :     }
<span class="lineNum">   11626 </span>            : 
<span class="lineNum">   11627 </span>            :   /* It is necessary not to output these entries if the sections were
<span class="lineNum">   11628 </span>            :      not used; if the sections were not used, the length will be 0 and
<span class="lineNum">   11629 </span>            :      the address may end up as 0 if the section is discarded by ld
<span class="lineNum">   11630 </span>            :      --gc-sections, leaving an invalid (0, 0) entry that can be
<span class="lineNum">   11631 </span>            :      confused with the terminator.  */
<span class="lineNum">   11632 </span><span class="lineCov">      33302 :   if (text_section_used)</span>
<span class="lineNum">   11633 </span>            :     {
<span class="lineNum">   11634 </span><span class="lineCov">      20256 :       dw2_asm_output_addr (DWARF2_ADDR_SIZE, text_section_label, &quot;Address&quot;);</span>
<span class="lineNum">   11635 </span><span class="lineCov">      20256 :       dw2_asm_output_delta (DWARF2_ADDR_SIZE, text_end_label,</span>
<span class="lineNum">   11636 </span>            :                             text_section_label, &quot;Length&quot;);
<span class="lineNum">   11637 </span>            :     }
<span class="lineNum">   11638 </span><span class="lineCov">      33302 :   if (cold_text_section_used)</span>
<span class="lineNum">   11639 </span>            :     {
<span class="lineNum">   11640 </span><span class="lineCov">       5592 :       dw2_asm_output_addr (DWARF2_ADDR_SIZE, cold_text_section_label,</span>
<span class="lineNum">   11641 </span>            :                            &quot;Address&quot;);
<span class="lineNum">   11642 </span><span class="lineCov">       5592 :       dw2_asm_output_delta (DWARF2_ADDR_SIZE, cold_end_label,</span>
<span class="lineNum">   11643 </span>            :                             cold_text_section_label, &quot;Length&quot;);
<span class="lineNum">   11644 </span>            :     }
<span class="lineNum">   11645 </span>            : 
<span class="lineNum">   11646 </span><span class="lineCov">      33302 :   if (have_multiple_function_sections)</span>
<span class="lineNum">   11647 </span>            :     {
<span class="lineNum">   11648 </span>            :       unsigned fde_idx;
<span class="lineNum">   11649 </span>            :       dw_fde_ref fde;
<span class="lineNum">   11650 </span>            : 
<span class="lineNum">   11651 </span><span class="lineCov">     180067 :       FOR_EACH_VEC_ELT (*fde_vec, fde_idx, fde)</span>
<span class="lineNum">   11652 </span>            :         {
<span class="lineNum">   11653 </span><span class="lineCov">     159737 :           if (DECL_IGNORED_P (fde-&gt;decl))</span>
<span class="lineNum">   11654 </span>            :             continue;
<span class="lineNum">   11655 </span><span class="lineCov">     154133 :           if (!fde-&gt;in_std_section)</span>
<span class="lineNum">   11656 </span>            :             {
<span class="lineNum">   11657 </span><span class="lineCov">     133935 :               dw2_asm_output_addr (DWARF2_ADDR_SIZE, fde-&gt;dw_fde_begin,</span>
<span class="lineNum">   11658 </span>            :                                    &quot;Address&quot;);
<span class="lineNum">   11659 </span><span class="lineCov">     133935 :               dw2_asm_output_delta (DWARF2_ADDR_SIZE, fde-&gt;dw_fde_end,</span>
<span class="lineNum">   11660 </span>            :                                     fde-&gt;dw_fde_begin, &quot;Length&quot;);
<span class="lineNum">   11661 </span>            :             }
<span class="lineNum">   11662 </span><span class="lineCov">     154133 :           if (fde-&gt;dw_fde_second_begin &amp;&amp; !fde-&gt;second_in_std_section)</span>
<span class="lineNum">   11663 </span>            :             {
<span class="lineNum">   11664 </span><span class="lineCov">       3259 :               dw2_asm_output_addr (DWARF2_ADDR_SIZE, fde-&gt;dw_fde_second_begin,</span>
<span class="lineNum">   11665 </span>            :                                    &quot;Address&quot;);
<span class="lineNum">   11666 </span><span class="lineCov">       3259 :               dw2_asm_output_delta (DWARF2_ADDR_SIZE, fde-&gt;dw_fde_second_end,</span>
<span class="lineNum">   11667 </span>            :                                     fde-&gt;dw_fde_second_begin, &quot;Length&quot;);
<span class="lineNum">   11668 </span>            :             }
<span class="lineNum">   11669 </span>            :         }
<span class="lineNum">   11670 </span>            :     }
<span class="lineNum">   11671 </span>            : 
<span class="lineNum">   11672 </span>            :   /* Output the terminator words.  */
<span class="lineNum">   11673 </span><span class="lineCov">      38065 :   dw2_asm_output_data (DWARF2_ADDR_SIZE, 0, NULL);</span>
<span class="lineNum">   11674 </span><span class="lineCov">      38065 :   dw2_asm_output_data (DWARF2_ADDR_SIZE, 0, NULL);</span>
<span class="lineNum">   11675 </span><span class="lineCov">      33302 : }</span>
<span class="lineNum">   11676 </span>            : 
<span class="lineNum">   11677 </span>            : /* Add a new entry to .debug_ranges.  Return its index into
<span class="lineNum">   11678 </span>            :    ranges_table vector.  */
<a name="11679"><span class="lineNum">   11679 </span>            : </a>
<span class="lineNum">   11680 </span>            : static unsigned int
<span class="lineNum">   11681 </span><span class="lineNoCov">          0 : add_ranges_num (int num, bool maybe_new_sec)</span>
<span class="lineNum">   11682 </span>            : {
<span class="lineNum">   11683 </span><span class="lineCov">    4553338 :   dw_ranges r = { NULL, num, 0, maybe_new_sec };</span>
<span class="lineNum">   11684 </span><span class="lineNoCov">          0 :   vec_safe_push (ranges_table, r);</span>
<span class="lineNum">   11685 </span><span class="lineCov">    4553338 :   return vec_safe_length (ranges_table) - 1;</span>
<span class="lineNum">   11686 </span>            : }
<span class="lineNum">   11687 </span>            : 
<span class="lineNum">   11688 </span>            : /* Add a new entry to .debug_ranges corresponding to a block, or a
<span class="lineNum">   11689 </span>            :    range terminator if BLOCK is NULL.  MAYBE_NEW_SEC is true if
<span class="lineNum">   11690 </span>            :    this entry might be in a different section from previous range.  */
<a name="11691"><span class="lineNum">   11691 </span>            : </a>
<span class="lineNum">   11692 </span>            : static unsigned int
<span class="lineNum">   11693 </span><span class="lineCov">    4394488 : add_ranges (const_tree block, bool maybe_new_sec)</span>
<span class="lineNum">   11694 </span>            : {
<span class="lineNum">   11695 </span><span class="lineCov">    4394488 :   return add_ranges_num (block ? BLOCK_NUMBER (block) : 0, maybe_new_sec);</span>
<span class="lineNum">   11696 </span>            : }
<span class="lineNum">   11697 </span>            : 
<span class="lineNum">   11698 </span>            : /* Note that (*rnglist_table)[offset] is either a head of a rnglist
<span class="lineNum">   11699 </span>            :    chain, or middle entry of a chain that will be directly referred to.  */
<a name="11700"><span class="lineNum">   11700 </span>            : </a>
<span class="lineNum">   11701 </span>            : static void
<span class="lineNum">   11702 </span><span class="lineCov">    1545590 : note_rnglist_head (unsigned int offset)</span>
<span class="lineNum">   11703 </span>            : {
<span class="lineNum">   11704 </span><span class="lineCov">    1545590 :   if (dwarf_version &lt; 5 || (*ranges_table)[offset].label)</span>
<span class="lineNum">   11705 </span>            :     return;
<span class="lineNum">   11706 </span><span class="lineCov">          8 :   (*ranges_table)[offset].label = gen_internal_sym (&quot;LLRL&quot;);</span>
<span class="lineNum">   11707 </span>            : }
<span class="lineNum">   11708 </span>            : 
<span class="lineNum">   11709 </span>            : /* Add a new entry to .debug_ranges corresponding to a pair of labels.
<span class="lineNum">   11710 </span>            :    When using dwarf_split_debug_info, address attributes in dies destined
<span class="lineNum">   11711 </span>            :    for the final executable should be direct references--setting the
<span class="lineNum">   11712 </span>            :    parameter force_direct ensures this behavior.  */
<a name="11713"><span class="lineNum">   11713 </span>            : </a>
<span class="lineNum">   11714 </span>            : static void
<span class="lineNum">   11715 </span><span class="lineCov">     158850 : add_ranges_by_labels (dw_die_ref die, const char *begin, const char *end,</span>
<span class="lineNum">   11716 </span>            :                       bool *added, bool force_direct)
<span class="lineNum">   11717 </span>            : {
<span class="lineNum">   11718 </span><span class="lineCov">     158850 :   unsigned int in_use = vec_safe_length (ranges_by_label);</span>
<span class="lineNum">   11719 </span><span class="lineCov">     158850 :   unsigned int offset;</span>
<span class="lineNum">   11720 </span><span class="lineCov">     158850 :   dw_ranges_by_label rbl = { begin, end };</span>
<span class="lineNum">   11721 </span><span class="lineCov">     158850 :   vec_safe_push (ranges_by_label, rbl);</span>
<span class="lineNum">   11722 </span><span class="lineCov">     158850 :   offset = add_ranges_num (-(int)in_use - 1, true);</span>
<span class="lineNum">   11723 </span><span class="lineCov">     158850 :   if (!*added)</span>
<span class="lineNum">   11724 </span>            :     {
<span class="lineNum">   11725 </span><span class="lineCov">      29753 :       add_AT_range_list (die, DW_AT_ranges, offset, force_direct);</span>
<span class="lineNum">   11726 </span><span class="lineCov">      29753 :       *added = true;</span>
<span class="lineNum">   11727 </span><span class="lineCov">      29753 :       note_rnglist_head (offset);</span>
<span class="lineNum">   11728 </span>            :     }
<span class="lineNum">   11729 </span><span class="lineCov">     158850 : }</span>
<span class="lineNum">   11730 </span>            : 
<span class="lineNum">   11731 </span>            : /* Emit .debug_ranges section.  */
<a name="11732"><span class="lineNum">   11732 </span>            : </a>
<span class="lineNum">   11733 </span>            : static void
<span class="lineNum">   11734 </span><span class="lineCov">      23678 : output_ranges (void)</span>
<span class="lineNum">   11735 </span>            : {
<span class="lineNum">   11736 </span><span class="lineCov">      23678 :   unsigned i;</span>
<span class="lineNum">   11737 </span><span class="lineCov">      23678 :   static const char *const start_fmt = &quot;Offset %#x&quot;;</span>
<span class="lineNum">   11738 </span><span class="lineCov">      23678 :   const char *fmt = start_fmt;</span>
<span class="lineNum">   11739 </span><span class="lineCov">      23678 :   dw_ranges *r;</span>
<span class="lineNum">   11740 </span>            : 
<span class="lineNum">   11741 </span><span class="lineCov">      23678 :   switch_to_section (debug_ranges_section);</span>
<span class="lineNum">   11742 </span><span class="lineCov">      23678 :   ASM_OUTPUT_LABEL (asm_out_file, ranges_section_label);</span>
<span class="lineNum">   11743 </span><span class="lineCov">    4576992 :   FOR_EACH_VEC_SAFE_ELT (ranges_table, i, r)</span>
<span class="lineNum">   11744 </span>            :     {
<span class="lineNum">   11745 </span><span class="lineCov">    4553314 :       int block_num = r-&gt;num;</span>
<span class="lineNum">   11746 </span>            : 
<span class="lineNum">   11747 </span><span class="lineCov">    4553314 :       if (block_num &gt; 0)</span>
<span class="lineNum">   11748 </span>            :         {
<span class="lineNum">   11749 </span><span class="lineCov">    3301758 :           char blabel[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">   11750 </span><span class="lineCov">    3301758 :           char elabel[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">   11751 </span>            : 
<span class="lineNum">   11752 </span><span class="lineCov">    3301758 :           ASM_GENERATE_INTERNAL_LABEL (blabel, BLOCK_BEGIN_LABEL, block_num);</span>
<span class="lineNum">   11753 </span><span class="lineCov">    3301758 :           ASM_GENERATE_INTERNAL_LABEL (elabel, BLOCK_END_LABEL, block_num);</span>
<span class="lineNum">   11754 </span>            : 
<span class="lineNum">   11755 </span>            :           /* If all code is in the text section, then the compilation
<span class="lineNum">   11756 </span>            :              unit base address defaults to DW_AT_low_pc, which is the
<span class="lineNum">   11757 </span>            :              base of the text section.  */
<span class="lineNum">   11758 </span><span class="lineCov">    3301758 :           if (!have_multiple_function_sections)</span>
<span class="lineNum">   11759 </span>            :             {
<span class="lineNum">   11760 </span><span class="lineCov">     563993 :               dw2_asm_output_delta (DWARF2_ADDR_SIZE, blabel,</span>
<span class="lineNum">   11761 </span>            :                                     text_section_label,
<span class="lineNum">   11762 </span><span class="lineCov">     563993 :                                     fmt, i * 2 * DWARF2_ADDR_SIZE);</span>
<span class="lineNum">   11763 </span><span class="lineCov">     563993 :               dw2_asm_output_delta (DWARF2_ADDR_SIZE, elabel,</span>
<span class="lineNum">   11764 </span>            :                                     text_section_label, NULL);
<span class="lineNum">   11765 </span>            :             }
<span class="lineNum">   11766 </span>            : 
<span class="lineNum">   11767 </span>            :           /* Otherwise, the compilation unit base address is zero,
<span class="lineNum">   11768 </span>            :              which allows us to use absolute addresses, and not worry
<span class="lineNum">   11769 </span>            :              about whether the target supports cross-section
<span class="lineNum">   11770 </span>            :              arithmetic.  */
<span class="lineNum">   11771 </span>            :           else
<span class="lineNum">   11772 </span>            :             {
<span class="lineNum">   11773 </span><span class="lineCov">    3199812 :               dw2_asm_output_addr (DWARF2_ADDR_SIZE, blabel,</span>
<span class="lineNum">   11774 </span><span class="lineCov">    3199812 :                                    fmt, i * 2 * DWARF2_ADDR_SIZE);</span>
<span class="lineNum">   11775 </span><span class="lineCov">    3199812 :               dw2_asm_output_addr (DWARF2_ADDR_SIZE, elabel, NULL);</span>
<span class="lineNum">   11776 </span>            :             }
<span class="lineNum">   11777 </span>            : 
<span class="lineNum">   11778 </span><span class="lineCov">    3301758 :           fmt = NULL;</span>
<span class="lineNum">   11779 </span>            :         }
<span class="lineNum">   11780 </span>            : 
<span class="lineNum">   11781 </span>            :       /* Negative block_num stands for an index into ranges_by_label.  */
<span class="lineNum">   11782 </span><span class="lineCov">    1251556 :       else if (block_num &lt; 0)</span>
<span class="lineNum">   11783 </span>            :         {
<span class="lineNum">   11784 </span><span class="lineCov">     158843 :           int lab_idx = - block_num - 1;</span>
<span class="lineNum">   11785 </span>            : 
<span class="lineNum">   11786 </span><span class="lineCov">     158843 :           if (!have_multiple_function_sections)</span>
<span class="lineNum">   11787 </span>            :             {
<span class="lineNum">   11788 </span><span class="lineNoCov">          0 :               gcc_unreachable ();</span>
<span class="lineNum">   11789 </span>            : #if 0
<span class="lineNum">   11790 </span>            :               /* If we ever use add_ranges_by_labels () for a single
<span class="lineNum">   11791 </span>            :                  function section, all we have to do is to take out
<span class="lineNum">   11792 </span>            :                  the #if 0 above.  */
<span class="lineNum">   11793 </span>            :               dw2_asm_output_delta (DWARF2_ADDR_SIZE,
<span class="lineNum">   11794 </span>            :                                     (*ranges_by_label)[lab_idx].begin,
<span class="lineNum">   11795 </span>            :                                     text_section_label,
<span class="lineNum">   11796 </span>            :                                     fmt, i * 2 * DWARF2_ADDR_SIZE);
<span class="lineNum">   11797 </span>            :               dw2_asm_output_delta (DWARF2_ADDR_SIZE,
<span class="lineNum">   11798 </span>            :                                     (*ranges_by_label)[lab_idx].end,
<span class="lineNum">   11799 </span>            :                                     text_section_label, NULL);
<span class="lineNum">   11800 </span>            : #endif
<span class="lineNum">   11801 </span>            :             }
<span class="lineNum">   11802 </span>            :           else
<span class="lineNum">   11803 </span>            :             {
<span class="lineNum">   11804 </span><span class="lineCov">     169927 :               dw2_asm_output_addr (DWARF2_ADDR_SIZE,</span>
<span class="lineNum">   11805 </span><span class="lineCov">     158843 :                                    (*ranges_by_label)[lab_idx].begin,</span>
<span class="lineNum">   11806 </span><span class="lineCov">     169927 :                                    fmt, i * 2 * DWARF2_ADDR_SIZE);</span>
<span class="lineNum">   11807 </span><span class="lineCov">     169927 :               dw2_asm_output_addr (DWARF2_ADDR_SIZE,</span>
<span class="lineNum">   11808 </span><span class="lineCov">     158843 :                                    (*ranges_by_label)[lab_idx].end,</span>
<span class="lineNum">   11809 </span>            :                                    NULL);
<span class="lineNum">   11810 </span>            :             }
<span class="lineNum">   11811 </span>            :         }
<span class="lineNum">   11812 </span>            :       else
<span class="lineNum">   11813 </span>            :         {
<span class="lineNum">   11814 </span><span class="lineCov">    1223728 :           dw2_asm_output_data (DWARF2_ADDR_SIZE, 0, NULL);</span>
<span class="lineNum">   11815 </span><span class="lineCov">    1092713 :           dw2_asm_output_data (DWARF2_ADDR_SIZE, 0, NULL);</span>
<span class="lineNum">   11816 </span><span class="lineCov">    1092713 :           fmt = start_fmt;</span>
<span class="lineNum">   11817 </span>            :         }
<span class="lineNum">   11818 </span>            :     }
<span class="lineNum">   11819 </span><span class="lineCov">      23678 : }</span>
<span class="lineNum">   11820 </span>            : 
<span class="lineNum">   11821 </span>            : /* Non-zero if .debug_line_str should be used for .debug_line section
<span class="lineNum">   11822 </span>            :    strings or strings that are likely shareable with those.  */
<span class="lineNum">   11823 </span>            : #define DWARF5_USE_DEBUG_LINE_STR \
<span class="lineNum">   11824 </span>            :   (!DWARF2_INDIRECT_STRING_SUPPORT_MISSING_ON_TARGET            \
<span class="lineNum">   11825 </span>            :    &amp;&amp; (DEBUG_STR_SECTION_FLAGS &amp; SECTION_MERGE) != 0                \
<span class="lineNum">   11826 </span>            :    /* FIXME: there is no .debug_line_str.dwo section,           \
<span class="lineNum">   11827 </span>            :       for -gsplit-dwarf we should use DW_FORM_strx instead.  */ \
<span class="lineNum">   11828 </span>            :    &amp;&amp; !dwarf_split_debug_info)
<span class="lineNum">   11829 </span>            : 
<span class="lineNum">   11830 </span>            : /* Assign .debug_rnglists indexes.  */
<a name="11831"><span class="lineNum">   11831 </span>            : </a>
<span class="lineNum">   11832 </span>            : static void
<span class="lineNum">   11833 </span><span class="lineNoCov">          0 : index_rnglists (void)</span>
<span class="lineNum">   11834 </span>            : {
<span class="lineNum">   11835 </span><span class="lineNoCov">          0 :   unsigned i;</span>
<span class="lineNum">   11836 </span><span class="lineNoCov">          0 :   dw_ranges *r;</span>
<span class="lineNum">   11837 </span>            : 
<span class="lineNum">   11838 </span><span class="lineNoCov">          0 :   FOR_EACH_VEC_SAFE_ELT (ranges_table, i, r)</span>
<span class="lineNum">   11839 </span><span class="lineNoCov">          0 :     if (r-&gt;label)</span>
<span class="lineNum">   11840 </span><span class="lineNoCov">          0 :       r-&gt;idx = rnglist_idx++;</span>
<span class="lineNum">   11841 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   11842 </span>            : 
<span class="lineNum">   11843 </span>            : /* Emit .debug_rnglists section.  */
<a name="11844"><span class="lineNum">   11844 </span>            : </a>
<span class="lineNum">   11845 </span>            : static void
<span class="lineNum">   11846 </span><span class="lineCov">          5 : output_rnglists (unsigned generation)</span>
<span class="lineNum">   11847 </span>            : {
<span class="lineNum">   11848 </span><span class="lineCov">          5 :   unsigned i;</span>
<span class="lineNum">   11849 </span><span class="lineCov">          5 :   dw_ranges *r;</span>
<span class="lineNum">   11850 </span><span class="lineCov">          5 :   char l1[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">   11851 </span><span class="lineCov">          5 :   char l2[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">   11852 </span><span class="lineCov">          5 :   char basebuf[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">   11853 </span>            : 
<span class="lineNum">   11854 </span><span class="lineCov">          5 :   switch_to_section (debug_ranges_section);</span>
<span class="lineNum">   11855 </span><span class="lineCov">          5 :   ASM_OUTPUT_LABEL (asm_out_file, ranges_section_label);</span>
<span class="lineNum">   11856 </span>            :   /* There are up to 4 unique ranges labels per generation.
<span class="lineNum">   11857 </span>            :      See also init_sections_and_labels.  */
<span class="lineNum">   11858 </span><span class="lineCov">          5 :   ASM_GENERATE_INTERNAL_LABEL (l1, DEBUG_RANGES_SECTION_LABEL,</span>
<span class="lineNum">   11859 </span>            :                                2 + generation * 4);
<span class="lineNum">   11860 </span><span class="lineCov">          5 :   ASM_GENERATE_INTERNAL_LABEL (l2, DEBUG_RANGES_SECTION_LABEL,</span>
<span class="lineNum">   11861 </span>            :                                3 + generation * 4);
<span class="lineNum">   11862 </span><span class="lineCov">          5 :   if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)</span>
<span class="lineNum">   11863 </span>            :     dw2_asm_output_data (4, 0xffffffff,
<span class="lineNum">   11864 </span>            :                          &quot;Initial length escape value indicating &quot;
<span class="lineNum">   11865 </span>            :                          &quot;64-bit DWARF extension&quot;);
<span class="lineNum">   11866 </span><span class="lineCov">          5 :   dw2_asm_output_delta (DWARF_OFFSET_SIZE, l2, l1,</span>
<span class="lineNum">   11867 </span>            :                         &quot;Length of Range Lists&quot;);
<span class="lineNum">   11868 </span><span class="lineCov">          5 :   ASM_OUTPUT_LABEL (asm_out_file, l1);</span>
<span class="lineNum">   11869 </span><span class="lineCov">          5 :   output_dwarf_version ();</span>
<span class="lineNum">   11870 </span><span class="lineCov">          5 :   dw2_asm_output_data (1, DWARF2_ADDR_SIZE, &quot;Address Size&quot;);</span>
<span class="lineNum">   11871 </span><span class="lineCov">          5 :   dw2_asm_output_data (1, 0, &quot;Segment Size&quot;);</span>
<span class="lineNum">   11872 </span>            :   /* Emit the offset table only for -gsplit-dwarf.  If we don't care
<span class="lineNum">   11873 </span>            :      about relocation sizes and primarily care about the size of .debug*
<span class="lineNum">   11874 </span>            :      sections in linked shared libraries and executables, then
<span class="lineNum">   11875 </span>            :      the offset table plus corresponding DW_FORM_rnglistx uleb128 indexes
<span class="lineNum">   11876 </span>            :      into it are usually larger than just DW_FORM_sec_offset offsets
<span class="lineNum">   11877 </span>            :      into the .debug_rnglists section.  */
<span class="lineNum">   11878 </span><span class="lineCov">          5 :   dw2_asm_output_data (4, dwarf_split_debug_info ? rnglist_idx : 0,</span>
<span class="lineNum">   11879 </span>            :                        &quot;Offset Entry Count&quot;);
<span class="lineNum">   11880 </span><span class="lineCov">          5 :   if (dwarf_split_debug_info)</span>
<span class="lineNum">   11881 </span>            :     {
<span class="lineNum">   11882 </span><span class="lineNoCov">          0 :       ASM_OUTPUT_LABEL (asm_out_file, ranges_base_label);</span>
<span class="lineNum">   11883 </span><span class="lineNoCov">          0 :       FOR_EACH_VEC_SAFE_ELT (ranges_table, i, r)</span>
<span class="lineNum">   11884 </span><span class="lineNoCov">          0 :         if (r-&gt;label)</span>
<span class="lineNum">   11885 </span><span class="lineNoCov">          0 :           dw2_asm_output_delta (DWARF_OFFSET_SIZE, r-&gt;label,</span>
<span class="lineNum">   11886 </span>            :                                 ranges_base_label, NULL);
<span class="lineNum">   11887 </span>            :     }
<span class="lineNum">   11888 </span>            : 
<span class="lineNum">   11889 </span><span class="lineCov">          5 :   const char *lab = &quot;&quot;;</span>
<span class="lineNum">   11890 </span><span class="lineCov">          5 :   unsigned int len = vec_safe_length (ranges_table);</span>
<span class="lineNum">   11891 </span><span class="lineCov">          5 :   const char *base = NULL;</span>
<span class="lineNum">   11892 </span><span class="lineCov">         29 :   FOR_EACH_VEC_SAFE_ELT (ranges_table, i, r)</span>
<span class="lineNum">   11893 </span>            :     {
<span class="lineNum">   11894 </span><span class="lineCov">         24 :       int block_num = r-&gt;num;</span>
<span class="lineNum">   11895 </span>            : 
<span class="lineNum">   11896 </span><span class="lineCov">         24 :       if (r-&gt;label)</span>
<span class="lineNum">   11897 </span>            :         {
<span class="lineNum">   11898 </span><span class="lineCov">          8 :           ASM_OUTPUT_LABEL (asm_out_file, r-&gt;label);</span>
<span class="lineNum">   11899 </span><span class="lineCov">          8 :           lab = r-&gt;label;</span>
<span class="lineNum">   11900 </span>            :         }
<span class="lineNum">   11901 </span><span class="lineCov">         24 :       if (HAVE_AS_LEB128 &amp;&amp; (r-&gt;label || r-&gt;maybe_new_sec))</span>
<span class="lineNum">   11902 </span><span class="lineCov">         10 :         base = NULL;</span>
<span class="lineNum">   11903 </span><span class="lineCov">         24 :       if (block_num &gt; 0)</span>
<span class="lineNum">   11904 </span>            :         {
<span class="lineNum">   11905 </span><span class="lineCov">          9 :           char blabel[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">   11906 </span><span class="lineCov">          9 :           char elabel[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">   11907 </span>            : 
<span class="lineNum">   11908 </span><span class="lineCov">          9 :           ASM_GENERATE_INTERNAL_LABEL (blabel, BLOCK_BEGIN_LABEL, block_num);</span>
<span class="lineNum">   11909 </span><span class="lineCov">          9 :           ASM_GENERATE_INTERNAL_LABEL (elabel, BLOCK_END_LABEL, block_num);</span>
<span class="lineNum">   11910 </span>            : 
<span class="lineNum">   11911 </span><span class="lineCov">          9 :           if (HAVE_AS_LEB128)</span>
<span class="lineNum">   11912 </span>            :             {
<span class="lineNum">   11913 </span>            :               /* If all code is in the text section, then the compilation
<span class="lineNum">   11914 </span>            :                  unit base address defaults to DW_AT_low_pc, which is the
<span class="lineNum">   11915 </span>            :                  base of the text section.  */
<span class="lineNum">   11916 </span><span class="lineCov">          9 :               if (!have_multiple_function_sections)</span>
<span class="lineNum">   11917 </span>            :                 {
<span class="lineNum">   11918 </span><span class="lineCov">          9 :                   dw2_asm_output_data (1, DW_RLE_offset_pair,</span>
<span class="lineNum">   11919 </span>            :                                        &quot;DW_RLE_offset_pair (%s)&quot;, lab);
<span class="lineNum">   11920 </span><span class="lineCov">          9 :                   dw2_asm_output_delta_uleb128 (blabel, text_section_label,</span>
<span class="lineNum">   11921 </span>            :                                                 &quot;Range begin address (%s)&quot;, lab);
<span class="lineNum">   11922 </span><span class="lineCov">          9 :                   dw2_asm_output_delta_uleb128 (elabel, text_section_label,</span>
<span class="lineNum">   11923 </span>            :                                                 &quot;Range end address (%s)&quot;, lab);
<span class="lineNum">   11924 </span><span class="lineCov">          9 :                   continue;</span>
<span class="lineNum">   11925 </span>            :                 }
<span class="lineNum">   11926 </span><span class="lineNoCov">          0 :               if (base == NULL)</span>
<span class="lineNum">   11927 </span>            :                 {
<span class="lineNum">   11928 </span><span class="lineNoCov">          0 :                   dw_ranges *r2 = NULL;</span>
<span class="lineNum">   11929 </span><span class="lineNoCov">          0 :                   if (i &lt; len - 1)</span>
<span class="lineNum">   11930 </span><span class="lineNoCov">          0 :                     r2 = &amp;(*ranges_table)[i + 1];</span>
<span class="lineNum">   11931 </span><span class="lineNoCov">          0 :                   if (r2</span>
<span class="lineNum">   11932 </span><span class="lineNoCov">          0 :                       &amp;&amp; r2-&gt;num != 0</span>
<span class="lineNum">   11933 </span><span class="lineNoCov">          0 :                       &amp;&amp; r2-&gt;label == NULL</span>
<span class="lineNum">   11934 </span><span class="lineNoCov">          0 :                       &amp;&amp; !r2-&gt;maybe_new_sec)</span>
<span class="lineNum">   11935 </span>            :                     {
<span class="lineNum">   11936 </span><span class="lineNoCov">          0 :                       dw2_asm_output_data (1, DW_RLE_base_address,</span>
<span class="lineNum">   11937 </span>            :                                            &quot;DW_RLE_base_address (%s)&quot;, lab);
<span class="lineNum">   11938 </span><span class="lineNoCov">          0 :                       dw2_asm_output_addr (DWARF2_ADDR_SIZE, blabel,</span>
<span class="lineNum">   11939 </span>            :                                            &quot;Base address (%s)&quot;, lab);
<span class="lineNum">   11940 </span><span class="lineNoCov">          0 :                       strcpy (basebuf, blabel);</span>
<span class="lineNum">   11941 </span><span class="lineNoCov">          0 :                       base = basebuf;</span>
<span class="lineNum">   11942 </span>            :                     }
<span class="lineNum">   11943 </span>            :                 }
<span class="lineNum">   11944 </span><span class="lineNoCov">          0 :               if (base)</span>
<span class="lineNum">   11945 </span>            :                 {
<span class="lineNum">   11946 </span><span class="lineNoCov">          0 :                   dw2_asm_output_data (1, DW_RLE_offset_pair,</span>
<span class="lineNum">   11947 </span>            :                                        &quot;DW_RLE_offset_pair (%s)&quot;, lab);
<span class="lineNum">   11948 </span><span class="lineNoCov">          0 :                   dw2_asm_output_delta_uleb128 (blabel, base,</span>
<span class="lineNum">   11949 </span>            :                                                 &quot;Range begin address (%s)&quot;, lab);
<span class="lineNum">   11950 </span><span class="lineNoCov">          0 :                   dw2_asm_output_delta_uleb128 (elabel, base,</span>
<span class="lineNum">   11951 </span>            :                                                 &quot;Range end address (%s)&quot;, lab);
<span class="lineNum">   11952 </span><span class="lineNoCov">          0 :                   continue;</span>
<span class="lineNum">   11953 </span>            :                 }
<span class="lineNum">   11954 </span><span class="lineNoCov">          0 :               dw2_asm_output_data (1, DW_RLE_start_length,</span>
<span class="lineNum">   11955 </span>            :                                    &quot;DW_RLE_start_length (%s)&quot;, lab);
<span class="lineNum">   11956 </span><span class="lineNoCov">          0 :               dw2_asm_output_addr (DWARF2_ADDR_SIZE, blabel,</span>
<span class="lineNum">   11957 </span>            :                                    &quot;Range begin address (%s)&quot;, lab);
<span class="lineNum">   11958 </span><span class="lineNoCov">          0 :               dw2_asm_output_delta_uleb128 (elabel, blabel,</span>
<span class="lineNum">   11959 </span>            :                                             &quot;Range length (%s)&quot;, lab);
<span class="lineNum">   11960 </span>            :             }
<span class="lineNum">   11961 </span>            :           else
<span class="lineNum">   11962 </span>            :             {
<span class="lineNum">   11963 </span>            :               dw2_asm_output_data (1, DW_RLE_start_end,
<span class="lineNum">   11964 </span>            :                                    &quot;DW_RLE_start_end (%s)&quot;, lab);
<span class="lineNum">   11965 </span>            :               dw2_asm_output_addr (DWARF2_ADDR_SIZE, blabel,
<span class="lineNum">   11966 </span>            :                                    &quot;Range begin address (%s)&quot;, lab);
<span class="lineNum">   11967 </span>            :               dw2_asm_output_addr (DWARF2_ADDR_SIZE, elabel,
<span class="lineNum">   11968 </span>            :                                    &quot;Range end address (%s)&quot;, lab);
<span class="lineNum">   11969 </span>            :             }
<span class="lineNum">   11970 </span>            :         }
<span class="lineNum">   11971 </span>            : 
<span class="lineNum">   11972 </span>            :       /* Negative block_num stands for an index into ranges_by_label.  */
<span class="lineNum">   11973 </span><span class="lineCov">         15 :       else if (block_num &lt; 0)</span>
<span class="lineNum">   11974 </span>            :         {
<span class="lineNum">   11975 </span><span class="lineCov">          7 :           int lab_idx = - block_num - 1;</span>
<span class="lineNum">   11976 </span><span class="lineCov">          7 :           const char *blabel = (*ranges_by_label)[lab_idx].begin;</span>
<span class="lineNum">   11977 </span><span class="lineCov">          7 :           const char *elabel = (*ranges_by_label)[lab_idx].end;</span>
<span class="lineNum">   11978 </span>            : 
<span class="lineNum">   11979 </span><span class="lineCov">          7 :           if (!have_multiple_function_sections)</span>
<span class="lineNum">   11980 </span><span class="lineNoCov">          0 :             gcc_unreachable ();</span>
<span class="lineNum">   11981 </span><span class="lineCov">          7 :           if (HAVE_AS_LEB128)</span>
<span class="lineNum">   11982 </span>            :             {
<span class="lineNum">   11983 </span><span class="lineCov">          7 :               dw2_asm_output_data (1, DW_RLE_start_length,</span>
<span class="lineNum">   11984 </span>            :                                    &quot;DW_RLE_start_length (%s)&quot;, lab);
<span class="lineNum">   11985 </span><span class="lineCov">          7 :               dw2_asm_output_addr (DWARF2_ADDR_SIZE, blabel,</span>
<span class="lineNum">   11986 </span>            :                                    &quot;Range begin address (%s)&quot;, lab);
<span class="lineNum">   11987 </span><span class="lineCov">          7 :               dw2_asm_output_delta_uleb128 (elabel, blabel,</span>
<span class="lineNum">   11988 </span>            :                                             &quot;Range length (%s)&quot;, lab);
<span class="lineNum">   11989 </span>            :             }
<span class="lineNum">   11990 </span>            :           else
<span class="lineNum">   11991 </span>            :             {
<span class="lineNum">   11992 </span>            :               dw2_asm_output_data (1, DW_RLE_start_end,
<span class="lineNum">   11993 </span>            :                                    &quot;DW_RLE_start_end (%s)&quot;, lab);
<span class="lineNum">   11994 </span>            :               dw2_asm_output_addr (DWARF2_ADDR_SIZE, blabel,
<span class="lineNum">   11995 </span>            :                                    &quot;Range begin address (%s)&quot;, lab);
<span class="lineNum">   11996 </span>            :               dw2_asm_output_addr (DWARF2_ADDR_SIZE, elabel,
<span class="lineNum">   11997 </span>            :                                    &quot;Range end address (%s)&quot;, lab);
<span class="lineNum">   11998 </span>            :             }
<span class="lineNum">   11999 </span>            :         }
<span class="lineNum">   12000 </span>            :       else
<span class="lineNum">   12001 </span><span class="lineCov">          8 :         dw2_asm_output_data (1, DW_RLE_end_of_list,</span>
<span class="lineNum">   12002 </span>            :                              &quot;DW_RLE_end_of_list (%s)&quot;, lab);
<span class="lineNum">   12003 </span>            :     }
<span class="lineNum">   12004 </span><span class="lineCov">          5 :   ASM_OUTPUT_LABEL (asm_out_file, l2);</span>
<span class="lineNum">   12005 </span><span class="lineCov">          5 : }</span>
<span class="lineNum">   12006 </span>            : 
<span class="lineNum">   12007 </span>            : /* Data structure containing information about input files.  */
<span class="lineNum">   12008 </span>            : struct file_info
<span class="lineNum">   12009 </span>            : {
<span class="lineNum">   12010 </span>            :   const char *path;     /* Complete file name.  */
<span class="lineNum">   12011 </span>            :   const char *fname;    /* File name part.  */
<span class="lineNum">   12012 </span>            :   int length;           /* Length of entire string.  */
<span class="lineNum">   12013 </span>            :   struct dwarf_file_data * file_idx;    /* Index in input file table.  */
<span class="lineNum">   12014 </span>            :   int dir_idx;          /* Index in directory table.  */
<span class="lineNum">   12015 </span>            : };
<span class="lineNum">   12016 </span>            : 
<span class="lineNum">   12017 </span>            : /* Data structure containing information about directories with source
<span class="lineNum">   12018 </span>            :    files.  */
<span class="lineNum">   12019 </span>            : struct dir_info
<span class="lineNum">   12020 </span>            : {
<span class="lineNum">   12021 </span>            :   const char *path;     /* Path including directory name.  */
<span class="lineNum">   12022 </span>            :   int length;           /* Path length.  */
<span class="lineNum">   12023 </span>            :   int prefix;           /* Index of directory entry which is a prefix.  */
<span class="lineNum">   12024 </span>            :   int count;            /* Number of files in this directory.  */
<span class="lineNum">   12025 </span>            :   int dir_idx;          /* Index of directory used as base.  */
<span class="lineNum">   12026 </span>            : };
<span class="lineNum">   12027 </span>            : 
<span class="lineNum">   12028 </span>            : /* Callback function for file_info comparison.  We sort by looking at
<span class="lineNum">   12029 </span>            :    the directories in the path.  */
<a name="12030"><span class="lineNum">   12030 </span>            : </a>
<span class="lineNum">   12031 </span>            : static int
<span class="lineNum">   12032 </span><span class="lineCov">      75498 : file_info_cmp (const void *p1, const void *p2)</span>
<span class="lineNum">   12033 </span>            : {
<span class="lineNum">   12034 </span><span class="lineCov">      75498 :   const struct file_info *const s1 = (const struct file_info *) p1;</span>
<span class="lineNum">   12035 </span><span class="lineCov">      75498 :   const struct file_info *const s2 = (const struct file_info *) p2;</span>
<span class="lineNum">   12036 </span><span class="lineCov">      75498 :   const unsigned char *cp1;</span>
<span class="lineNum">   12037 </span><span class="lineCov">      75498 :   const unsigned char *cp2;</span>
<span class="lineNum">   12038 </span>            : 
<span class="lineNum">   12039 </span>            :   /* Take care of file names without directories.  We need to make sure that
<span class="lineNum">   12040 </span>            :      we return consistent values to qsort since some will get confused if
<span class="lineNum">   12041 </span>            :      we return the same value when identical operands are passed in opposite
<span class="lineNum">   12042 </span>            :      orders.  So if neither has a directory, return 0 and otherwise return
<span class="lineNum">   12043 </span>            :      1 or -1 depending on which one has the directory.  We want the one with
<span class="lineNum">   12044 </span>            :      the directory to sort after the one without, so all no directory files
<span class="lineNum">   12045 </span>            :      are at the start (normally only the compilation unit file).  */
<span class="lineNum">   12046 </span><span class="lineCov">      75498 :   if ((s1-&gt;path == s1-&gt;fname || s2-&gt;path == s2-&gt;fname))</span>
<span class="lineNum">   12047 </span><span class="lineCov">       1865 :     return (s2-&gt;path == s2-&gt;fname) - (s1-&gt;path == s1-&gt;fname);</span>
<span class="lineNum">   12048 </span>            : 
<span class="lineNum">   12049 </span>            :   cp1 = (const unsigned char *) s1-&gt;path;
<span class="lineNum">   12050 </span>            :   cp2 = (const unsigned char *) s2-&gt;path;
<span class="lineNum">   12051 </span>            : 
<span class="lineNum">   12052 </span><span class="lineCov">    4297614 :   while (1)</span>
<span class="lineNum">   12053 </span>            :     {
<span class="lineNum">   12054 </span><span class="lineCov">    4297614 :       ++cp1;</span>
<span class="lineNum">   12055 </span><span class="lineCov">    4297614 :       ++cp2;</span>
<span class="lineNum">   12056 </span>            :       /* Reached the end of the first path?  If so, handle like above,
<span class="lineNum">   12057 </span>            :          but now we want longer directory prefixes before shorter ones.  */
<span class="lineNum">   12058 </span><span class="lineCov">    4297614 :       if ((cp1 == (const unsigned char *) s1-&gt;fname)</span>
<span class="lineNum">   12059 </span><span class="lineCov">    4270374 :           || (cp2 == (const unsigned char *) s2-&gt;fname))</span>
<span class="lineNum">   12060 </span><span class="lineCov">      39626 :         return ((cp1 == (const unsigned char *) s1-&gt;fname)</span>
<span class="lineNum">   12061 </span><span class="lineCov">      39626 :                 - (cp2 == (const unsigned char *) s2-&gt;fname));</span>
<span class="lineNum">   12062 </span>            : 
<span class="lineNum">   12063 </span>            :       /* Character of current path component the same?  */
<span class="lineNum">   12064 </span><span class="lineCov">    4257988 :       else if (*cp1 != *cp2)</span>
<span class="lineNum">   12065 </span><span class="lineCov">      34007 :         return *cp1 - *cp2;</span>
<span class="lineNum">   12066 </span>            :     }
<span class="lineNum">   12067 </span>            : }
<span class="lineNum">   12068 </span>            : 
<span class="lineNum">   12069 </span>            : struct file_name_acquire_data
<span class="lineNum">   12070 </span>            : {
<span class="lineNum">   12071 </span>            :   struct file_info *files;
<span class="lineNum">   12072 </span>            :   int used_files;
<span class="lineNum">   12073 </span>            :   int max_files;
<span class="lineNum">   12074 </span>            : };
<span class="lineNum">   12075 </span>            : 
<span class="lineNum">   12076 </span>            : /* Traversal function for the hash table.  */
<a name="12077"><span class="lineNum">   12077 </span>            : </a>
<span class="lineNum">   12078 </span>            : int
<span class="lineNum">   12079 </span><span class="lineCov">       5989 : file_name_acquire (dwarf_file_data **slot, file_name_acquire_data *fnad)</span>
<span class="lineNum">   12080 </span>            : {
<span class="lineNum">   12081 </span><span class="lineCov">       5989 :   struct dwarf_file_data *d = *slot;</span>
<span class="lineNum">   12082 </span><span class="lineCov">       5989 :   struct file_info *fi;</span>
<span class="lineNum">   12083 </span><span class="lineCov">       5989 :   const char *f;</span>
<span class="lineNum">   12084 </span>            : 
<span class="lineNum">   12085 </span><span class="lineCov">       5989 :   gcc_assert (fnad-&gt;max_files &gt;= d-&gt;emitted_number);</span>
<span class="lineNum">   12086 </span>            : 
<span class="lineNum">   12087 </span><span class="lineCov">       5989 :   if (! d-&gt;emitted_number)</span>
<span class="lineNum">   12088 </span>            :     return 1;
<span class="lineNum">   12089 </span>            : 
<span class="lineNum">   12090 </span><span class="lineCov">       3105 :   gcc_assert (fnad-&gt;max_files != fnad-&gt;used_files);</span>
<span class="lineNum">   12091 </span>            : 
<span class="lineNum">   12092 </span><span class="lineCov">       3105 :   fi = fnad-&gt;files + fnad-&gt;used_files++;</span>
<span class="lineNum">   12093 </span>            : 
<span class="lineNum">   12094 </span>            :   /* Skip all leading &quot;./&quot;.  */
<span class="lineNum">   12095 </span><span class="lineCov">       3105 :   f = d-&gt;filename;</span>
<span class="lineNum">   12096 </span><span class="lineCov">       3105 :   while (f[0] == '.' &amp;&amp; IS_DIR_SEPARATOR (f[1]))</span>
<span class="lineNum">   12097 </span><span class="lineNoCov">          0 :     f += 2;</span>
<span class="lineNum">   12098 </span>            : 
<span class="lineNum">   12099 </span>            :   /* Create a new array entry.  */
<span class="lineNum">   12100 </span><span class="lineCov">       3105 :   fi-&gt;path = f;</span>
<span class="lineNum">   12101 </span><span class="lineCov">       3105 :   fi-&gt;length = strlen (f);</span>
<span class="lineNum">   12102 </span><span class="lineCov">       3105 :   fi-&gt;file_idx = d;</span>
<span class="lineNum">   12103 </span>            : 
<span class="lineNum">   12104 </span>            :   /* Search for the file name part.  */
<span class="lineNum">   12105 </span><span class="lineCov">       3105 :   f = strrchr (f, DIR_SEPARATOR);</span>
<span class="lineNum">   12106 </span>            : #if defined (DIR_SEPARATOR_2)
<span class="lineNum">   12107 </span>            :   {
<span class="lineNum">   12108 </span>            :     char *g = strrchr (fi-&gt;path, DIR_SEPARATOR_2);
<span class="lineNum">   12109 </span>            : 
<span class="lineNum">   12110 </span>            :     if (g != NULL)
<span class="lineNum">   12111 </span>            :       {
<span class="lineNum">   12112 </span>            :         if (f == NULL || f &lt; g)
<span class="lineNum">   12113 </span>            :           f = g;
<span class="lineNum">   12114 </span>            :       }
<span class="lineNum">   12115 </span>            :   }
<span class="lineNum">   12116 </span>            : #endif
<span class="lineNum">   12117 </span>            : 
<span class="lineNum">   12118 </span><span class="lineCov">       3105 :   fi-&gt;fname = f == NULL ? fi-&gt;path : f + 1;</span>
<span class="lineNum">   12119 </span><span class="lineCov">       3105 :   return 1;</span>
<span class="lineNum">   12120 </span>            : }
<span class="lineNum">   12121 </span>            : 
<span class="lineNum">   12122 </span>            : /* Helper function for output_file_names.  Emit a FORM encoded
<span class="lineNum">   12123 </span>            :    string STR, with assembly comment start ENTRY_KIND and
<span class="lineNum">   12124 </span>            :    index IDX */
<a name="12125"><span class="lineNum">   12125 </span>            : </a>
<span class="lineNum">   12126 </span>            : static void
<span class="lineNum">   12127 </span><span class="lineCov">       3114 : output_line_string (enum dwarf_form form, const char *str,</span>
<span class="lineNum">   12128 </span>            :                     const char *entry_kind, unsigned int idx)
<span class="lineNum">   12129 </span>            : {
<span class="lineNum">   12130 </span><span class="lineCov">       3114 :   switch (form)</span>
<span class="lineNum">   12131 </span>            :     {
<span class="lineNum">   12132 </span><span class="lineCov">       3102 :     case DW_FORM_string:</span>
<span class="lineNum">   12133 </span><span class="lineCov">       3102 :       dw2_asm_output_nstring (str, -1, &quot;%s: %#x&quot;, entry_kind, idx);</span>
<span class="lineNum">   12134 </span><span class="lineCov">       3102 :       break;</span>
<span class="lineNum">   12135 </span><span class="lineCov">         12 :     case DW_FORM_line_strp:</span>
<span class="lineNum">   12136 </span><span class="lineCov">         12 :       if (!debug_line_str_hash)</span>
<span class="lineNum">   12137 </span><span class="lineCov">          3 :         debug_line_str_hash</span>
<span class="lineNum">   12138 </span><span class="lineCov">          3 :           = hash_table&lt;indirect_string_hasher&gt;::create_ggc (10);</span>
<span class="lineNum">   12139 </span>            : 
<span class="lineNum">   12140 </span><span class="lineCov">         12 :       struct indirect_string_node *node;</span>
<span class="lineNum">   12141 </span><span class="lineCov">         12 :       node = find_AT_string_in_table (str, debug_line_str_hash);</span>
<span class="lineNum">   12142 </span><span class="lineCov">         12 :       set_indirect_string (node);</span>
<span class="lineNum">   12143 </span><span class="lineCov">         12 :       node-&gt;form = form;</span>
<span class="lineNum">   12144 </span><span class="lineCov">         12 :       dw2_asm_output_offset (DWARF_OFFSET_SIZE, node-&gt;label,</span>
<span class="lineNum">   12145 </span>            :                              debug_line_str_section, &quot;%s: %#x: \&quot;%s\&quot;&quot;,
<span class="lineNum">   12146 </span>            :                              entry_kind, 0, node-&gt;str);
<span class="lineNum">   12147 </span><span class="lineCov">         12 :       break;</span>
<span class="lineNum">   12148 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">   12149 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">   12150 </span>            :     }
<span class="lineNum">   12151 </span><span class="lineCov">       3114 : }</span>
<span class="lineNum">   12152 </span>            : 
<span class="lineNum">   12153 </span>            : /* Output the directory table and the file name table.  We try to minimize
<span class="lineNum">   12154 </span>            :    the total amount of memory needed.  A heuristic is used to avoid large
<span class="lineNum">   12155 </span>            :    slowdowns with many input files.  */
<a name="12156"><span class="lineNum">   12156 </span>            : </a>
<span class="lineNum">   12157 </span>            : static void
<span class="lineNum">   12158 </span><span class="lineCov">        812 : output_file_names (void)</span>
<span class="lineNum">   12159 </span>            : {
<span class="lineNum">   12160 </span><span class="lineCov">        812 :   struct file_name_acquire_data fnad;</span>
<span class="lineNum">   12161 </span><span class="lineCov">        812 :   int numfiles;</span>
<span class="lineNum">   12162 </span><span class="lineCov">        812 :   struct file_info *files;</span>
<span class="lineNum">   12163 </span><span class="lineCov">        812 :   struct dir_info *dirs;</span>
<span class="lineNum">   12164 </span><span class="lineCov">        812 :   int *saved;</span>
<span class="lineNum">   12165 </span><span class="lineCov">        812 :   int *savehere;</span>
<span class="lineNum">   12166 </span><span class="lineCov">        812 :   int *backmap;</span>
<span class="lineNum">   12167 </span><span class="lineCov">        812 :   int ndirs;</span>
<span class="lineNum">   12168 </span><span class="lineCov">        812 :   int idx_offset;</span>
<span class="lineNum">   12169 </span><span class="lineCov">        812 :   int i;</span>
<span class="lineNum">   12170 </span>            : 
<span class="lineNum">   12171 </span><span class="lineCov">        812 :   if (!last_emitted_file)</span>
<span class="lineNum">   12172 </span>            :     {
<span class="lineNum">   12173 </span><span class="lineCov">          4 :       if (dwarf_version &gt;= 5)</span>
<span class="lineNum">   12174 </span>            :         {
<span class="lineNum">   12175 </span><span class="lineNoCov">          0 :           dw2_asm_output_data (1, 0, &quot;Directory entry format count&quot;);</span>
<span class="lineNum">   12176 </span><span class="lineNoCov">          0 :           dw2_asm_output_data_uleb128 (0, &quot;Directories count&quot;);</span>
<span class="lineNum">   12177 </span><span class="lineNoCov">          0 :           dw2_asm_output_data (1, 0, &quot;File name entry format count&quot;);</span>
<span class="lineNum">   12178 </span><span class="lineNoCov">          0 :           dw2_asm_output_data_uleb128 (0, &quot;File names count&quot;);</span>
<span class="lineNum">   12179 </span>            :         }
<span class="lineNum">   12180 </span>            :       else
<span class="lineNum">   12181 </span>            :         {
<span class="lineNum">   12182 </span><span class="lineCov">          4 :           dw2_asm_output_data (1, 0, &quot;End directory table&quot;);</span>
<span class="lineNum">   12183 </span><span class="lineCov">          4 :           dw2_asm_output_data (1, 0, &quot;End file name table&quot;);</span>
<span class="lineNum">   12184 </span>            :         }
<span class="lineNum">   12185 </span><span class="lineCov">          4 :       return;</span>
<span class="lineNum">   12186 </span>            :     }
<span class="lineNum">   12187 </span>            : 
<span class="lineNum">   12188 </span><span class="lineCov">        808 :   numfiles = last_emitted_file-&gt;emitted_number;</span>
<span class="lineNum">   12189 </span>            : 
<span class="lineNum">   12190 </span>            :   /* Allocate the various arrays we need.  */
<span class="lineNum">   12191 </span><span class="lineCov">        808 :   files = XALLOCAVEC (struct file_info, numfiles);</span>
<span class="lineNum">   12192 </span><span class="lineCov">        808 :   dirs = XALLOCAVEC (struct dir_info, numfiles);</span>
<span class="lineNum">   12193 </span>            : 
<span class="lineNum">   12194 </span><span class="lineCov">        808 :   fnad.files = files;</span>
<span class="lineNum">   12195 </span><span class="lineCov">        808 :   fnad.used_files = 0;</span>
<span class="lineNum">   12196 </span><span class="lineCov">        808 :   fnad.max_files = numfiles;</span>
<span class="lineNum">   12197 </span><span class="lineCov">        808 :   file_table-&gt;traverse&lt;file_name_acquire_data *, file_name_acquire&gt; (&amp;fnad);</span>
<span class="lineNum">   12198 </span><span class="lineCov">        808 :   gcc_assert (fnad.used_files == fnad.max_files);</span>
<span class="lineNum">   12199 </span>            : 
<span class="lineNum">   12200 </span><span class="lineCov">        808 :   qsort (files, numfiles, sizeof (files[0]), file_info_cmp);</span>
<span class="lineNum">   12201 </span>            : 
<span class="lineNum">   12202 </span>            :   /* Find all the different directories used.  */
<span class="lineNum">   12203 </span><span class="lineCov">        808 :   dirs[0].path = files[0].path;</span>
<span class="lineNum">   12204 </span><span class="lineCov">        808 :   dirs[0].length = files[0].fname - files[0].path;</span>
<span class="lineNum">   12205 </span><span class="lineCov">        808 :   dirs[0].prefix = -1;</span>
<span class="lineNum">   12206 </span><span class="lineCov">        808 :   dirs[0].count = 1;</span>
<span class="lineNum">   12207 </span><span class="lineCov">        808 :   dirs[0].dir_idx = 0;</span>
<span class="lineNum">   12208 </span><span class="lineCov">        808 :   files[0].dir_idx = 0;</span>
<span class="lineNum">   12209 </span><span class="lineCov">        808 :   ndirs = 1;</span>
<span class="lineNum">   12210 </span>            : 
<span class="lineNum">   12211 </span><span class="lineCov">       3105 :   for (i = 1; i &lt; numfiles; i++)</span>
<span class="lineNum">   12212 </span><span class="lineCov">       2297 :     if (files[i].fname - files[i].path == dirs[ndirs - 1].length</span>
<span class="lineNum">   12213 </span><span class="lineCov">       1643 :         &amp;&amp; memcmp (dirs[ndirs - 1].path, files[i].path,</span>
<span class="lineNum">   12214 </span>            :                    dirs[ndirs - 1].length) == 0)
<span class="lineNum">   12215 </span>            :       {
<span class="lineNum">   12216 </span>            :         /* Same directory as last entry.  */
<span class="lineNum">   12217 </span><span class="lineCov">       1642 :         files[i].dir_idx = ndirs - 1;</span>
<span class="lineNum">   12218 </span><span class="lineCov">       1642 :         ++dirs[ndirs - 1].count;</span>
<span class="lineNum">   12219 </span>            :       }
<span class="lineNum">   12220 </span>            :     else
<span class="lineNum">   12221 </span>            :       {
<span class="lineNum">   12222 </span><span class="lineCov">        655 :         int j;</span>
<span class="lineNum">   12223 </span>            : 
<span class="lineNum">   12224 </span>            :         /* This is a new directory.  */
<span class="lineNum">   12225 </span><span class="lineCov">        655 :         dirs[ndirs].path = files[i].path;</span>
<span class="lineNum">   12226 </span><span class="lineCov">        655 :         dirs[ndirs].length = files[i].fname - files[i].path;</span>
<span class="lineNum">   12227 </span><span class="lineCov">        655 :         dirs[ndirs].count = 1;</span>
<span class="lineNum">   12228 </span><span class="lineCov">        655 :         dirs[ndirs].dir_idx = ndirs;</span>
<span class="lineNum">   12229 </span><span class="lineCov">        655 :         files[i].dir_idx = ndirs;</span>
<span class="lineNum">   12230 </span>            : 
<span class="lineNum">   12231 </span>            :         /* Search for a prefix.  */
<span class="lineNum">   12232 </span><span class="lineCov">        655 :         dirs[ndirs].prefix = -1;</span>
<span class="lineNum">   12233 </span><span class="lineCov">       3576 :         for (j = 0; j &lt; ndirs; j++)</span>
<span class="lineNum">   12234 </span><span class="lineCov">       2921 :           if (dirs[j].length &lt; dirs[ndirs].length</span>
<span class="lineNum">   12235 </span><span class="lineCov">       1194 :               &amp;&amp; dirs[j].length &gt; 1</span>
<span class="lineNum">   12236 </span><span class="lineCov">        712 :               &amp;&amp; (dirs[ndirs].prefix == -1</span>
<span class="lineNum">   12237 </span><span class="lineNoCov">          0 :                   || dirs[j].length &gt; dirs[dirs[ndirs].prefix].length)</span>
<span class="lineNum">   12238 </span><span class="lineCov">        712 :               &amp;&amp; memcmp (dirs[j].path, dirs[ndirs].path, dirs[j].length) == 0)</span>
<span class="lineNum">   12239 </span><span class="lineNoCov">          0 :             dirs[ndirs].prefix = j;</span>
<span class="lineNum">   12240 </span>            : 
<span class="lineNum">   12241 </span><span class="lineCov">        655 :         ++ndirs;</span>
<span class="lineNum">   12242 </span>            :       }
<span class="lineNum">   12243 </span>            : 
<span class="lineNum">   12244 </span>            :   /* Now to the actual work.  We have to find a subset of the directories which
<span class="lineNum">   12245 </span>            :      allow expressing the file name using references to the directory table
<span class="lineNum">   12246 </span>            :      with the least amount of characters.  We do not do an exhaustive search
<span class="lineNum">   12247 </span>            :      where we would have to check out every combination of every single
<span class="lineNum">   12248 </span>            :      possible prefix.  Instead we use a heuristic which provides nearly optimal
<span class="lineNum">   12249 </span>            :      results in most cases and never is much off.  */
<span class="lineNum">   12250 </span><span class="lineCov">        808 :   saved = XALLOCAVEC (int, ndirs);</span>
<span class="lineNum">   12251 </span><span class="lineCov">        808 :   savehere = XALLOCAVEC (int, ndirs);</span>
<span class="lineNum">   12252 </span>            : 
<span class="lineNum">   12253 </span><span class="lineCov">        808 :   memset (saved, '\0', ndirs * sizeof (saved[0]));</span>
<span class="lineNum">   12254 </span><span class="lineCov">       2271 :   for (i = 0; i &lt; ndirs; i++)</span>
<span class="lineNum">   12255 </span>            :     {
<span class="lineNum">   12256 </span><span class="lineCov">       1463 :       int j;</span>
<span class="lineNum">   12257 </span><span class="lineCov">       1463 :       int total;</span>
<span class="lineNum">   12258 </span>            : 
<span class="lineNum">   12259 </span>            :       /* We can always save some space for the current directory.  But this
<span class="lineNum">   12260 </span>            :          does not mean it will be enough to justify adding the directory.  */
<span class="lineNum">   12261 </span><span class="lineCov">       1463 :       savehere[i] = dirs[i].length;</span>
<span class="lineNum">   12262 </span><span class="lineCov">       1463 :       total = (savehere[i] - saved[i]) * dirs[i].count;</span>
<span class="lineNum">   12263 </span>            : 
<span class="lineNum">   12264 </span><span class="lineCov">       4384 :       for (j = i + 1; j &lt; ndirs; j++)</span>
<span class="lineNum">   12265 </span>            :         {
<span class="lineNum">   12266 </span><span class="lineCov">       2921 :           savehere[j] = 0;</span>
<span class="lineNum">   12267 </span><span class="lineCov">       2921 :           if (saved[j] &lt; dirs[i].length)</span>
<span class="lineNum">   12268 </span>            :             {
<span class="lineNum">   12269 </span>            :               /* Determine whether the dirs[i] path is a prefix of the
<span class="lineNum">   12270 </span>            :                  dirs[j] path.  */
<span class="lineNum">   12271 </span><span class="lineCov">       2439 :               int k;</span>
<span class="lineNum">   12272 </span>            : 
<span class="lineNum">   12273 </span><span class="lineCov">       2439 :               k = dirs[j].prefix;</span>
<span class="lineNum">   12274 </span><span class="lineCov">       2439 :               while (k != -1 &amp;&amp; k != (int) i)</span>
<span class="lineNum">   12275 </span><span class="lineNoCov">          0 :                 k = dirs[k].prefix;</span>
<span class="lineNum">   12276 </span>            : 
<span class="lineNum">   12277 </span><span class="lineCov">       2439 :               if (k == (int) i)</span>
<span class="lineNum">   12278 </span>            :                 {
<span class="lineNum">   12279 </span>            :                   /* Yes it is.  We can possibly save some memory by
<span class="lineNum">   12280 </span>            :                      writing the filenames in dirs[j] relative to
<span class="lineNum">   12281 </span>            :                      dirs[i].  */
<span class="lineNum">   12282 </span><span class="lineNoCov">          0 :                   savehere[j] = dirs[i].length;</span>
<span class="lineNum">   12283 </span><span class="lineNoCov">          0 :                   total += (savehere[j] - saved[j]) * dirs[j].count;</span>
<span class="lineNum">   12284 </span>            :                 }
<span class="lineNum">   12285 </span>            :             }
<span class="lineNum">   12286 </span>            :         }
<span class="lineNum">   12287 </span>            : 
<span class="lineNum">   12288 </span>            :       /* Check whether we can save enough to justify adding the dirs[i]
<span class="lineNum">   12289 </span>            :          directory.  */
<span class="lineNum">   12290 </span><span class="lineCov">       1463 :       if (total &gt; dirs[i].length + 1)</span>
<span class="lineNum">   12291 </span>            :         {
<span class="lineNum">   12292 </span>            :           /* It's worthwhile adding.  */
<span class="lineNum">   12293 </span><span class="lineCov">       1752 :           for (j = i; j &lt; ndirs; j++)</span>
<span class="lineNum">   12294 </span><span class="lineCov">       1393 :             if (savehere[j] &gt; 0)</span>
<span class="lineNum">   12295 </span>            :               {
<span class="lineNum">   12296 </span>            :                 /* Remember how much we saved for this directory so far.  */
<span class="lineNum">   12297 </span><span class="lineCov">        359 :                 saved[j] = savehere[j];</span>
<span class="lineNum">   12298 </span>            : 
<span class="lineNum">   12299 </span>            :                 /* Remember the prefix directory.  */
<span class="lineNum">   12300 </span><span class="lineCov">        359 :                 dirs[j].dir_idx = i;</span>
<span class="lineNum">   12301 </span>            :               }
<span class="lineNum">   12302 </span>            :         }
<span class="lineNum">   12303 </span>            :     }
<span class="lineNum">   12304 </span>            : 
<span class="lineNum">   12305 </span>            :   /* Emit the directory name table.  */
<span class="lineNum">   12306 </span><span class="lineCov">        808 :   idx_offset = dirs[0].length &gt; 0 ? 1 : 0;</span>
<span class="lineNum">   12307 </span><span class="lineCov">        808 :   enum dwarf_form str_form = DW_FORM_string;</span>
<span class="lineNum">   12308 </span><span class="lineCov">        808 :   enum dwarf_form idx_form = DW_FORM_udata;</span>
<span class="lineNum">   12309 </span><span class="lineCov">        808 :   if (dwarf_version &gt;= 5)</span>
<span class="lineNum">   12310 </span>            :     {
<span class="lineNum">   12311 </span><span class="lineCov">          3 :       const char *comp_dir = comp_dir_string ();</span>
<span class="lineNum">   12312 </span><span class="lineCov">          3 :       if (comp_dir == NULL)</span>
<span class="lineNum">   12313 </span><span class="lineNoCov">          0 :         comp_dir = &quot;&quot;;</span>
<span class="lineNum">   12314 </span><span class="lineCov">          3 :       dw2_asm_output_data (1, 1, &quot;Directory entry format count&quot;);</span>
<span class="lineNum">   12315 </span><span class="lineCov">          3 :       if (DWARF5_USE_DEBUG_LINE_STR)</span>
<span class="lineNum">   12316 </span><span class="lineCov">          3 :         str_form = DW_FORM_line_strp;</span>
<span class="lineNum">   12317 </span><span class="lineCov">          3 :       dw2_asm_output_data_uleb128 (DW_LNCT_path, &quot;DW_LNCT_path&quot;);</span>
<span class="lineNum">   12318 </span><span class="lineCov">          3 :       dw2_asm_output_data_uleb128 (str_form, &quot;%s&quot;,</span>
<span class="lineNum">   12319 </span>            :                                    get_DW_FORM_name (str_form));
<span class="lineNum">   12320 </span><span class="lineCov">          3 :       dw2_asm_output_data_uleb128 (ndirs + idx_offset, &quot;Directories count&quot;);</span>
<span class="lineNum">   12321 </span><span class="lineCov">          3 :       if (str_form == DW_FORM_string)</span>
<span class="lineNum">   12322 </span>            :         {
<span class="lineNum">   12323 </span><span class="lineNoCov">          0 :           dw2_asm_output_nstring (comp_dir, -1, &quot;Directory Entry: %#x&quot;, 0);</span>
<span class="lineNum">   12324 </span><span class="lineNoCov">          0 :           for (i = 1 - idx_offset; i &lt; ndirs; i++)</span>
<span class="lineNum">   12325 </span><span class="lineNoCov">          0 :             dw2_asm_output_nstring (dirs[i].path,</span>
<span class="lineNum">   12326 </span><span class="lineNoCov">          0 :                                     dirs[i].length</span>
<span class="lineNum">   12327 </span><span class="lineNoCov">          0 :                                     - !DWARF2_DIR_SHOULD_END_WITH_SEPARATOR,</span>
<span class="lineNum">   12328 </span>            :                                     &quot;Directory Entry: %#x&quot;, i + idx_offset);
<span class="lineNum">   12329 </span>            :         }
<span class="lineNum">   12330 </span>            :       else
<span class="lineNum">   12331 </span>            :         {
<span class="lineNum">   12332 </span><span class="lineCov">          3 :           output_line_string (str_form, comp_dir, &quot;Directory Entry&quot;, 0);</span>
<span class="lineNum">   12333 </span><span class="lineCov">          6 :           for (i = 1 - idx_offset; i &lt; ndirs; i++)</span>
<span class="lineNum">   12334 </span>            :             {
<span class="lineNum">   12335 </span><span class="lineCov">          3 :               const char *str</span>
<span class="lineNum">   12336 </span><span class="lineCov">          6 :                 = ggc_alloc_string (dirs[i].path,</span>
<span class="lineNum">   12337 </span><span class="lineCov">          3 :                                     dirs[i].length</span>
<span class="lineNum">   12338 </span>            :                                     - !DWARF2_DIR_SHOULD_END_WITH_SEPARATOR);
<span class="lineNum">   12339 </span><span class="lineCov">          6 :               output_line_string (str_form, str, &quot;Directory Entry&quot;,</span>
<span class="lineNum">   12340 </span><span class="lineCov">          3 :                                   (unsigned) i + idx_offset);</span>
<span class="lineNum">   12341 </span>            :             }
<span class="lineNum">   12342 </span>            :         }
<span class="lineNum">   12343 </span>            :     }
<span class="lineNum">   12344 </span>            :   else
<span class="lineNum">   12345 </span>            :     {
<span class="lineNum">   12346 </span><span class="lineCov">       2199 :       for (i = 1 - idx_offset; i &lt; ndirs; i++)</span>
<span class="lineNum">   12347 </span><span class="lineCov">       2788 :         dw2_asm_output_nstring (dirs[i].path,</span>
<span class="lineNum">   12348 </span><span class="lineCov">       1394 :                                 dirs[i].length</span>
<span class="lineNum">   12349 </span><span class="lineCov">       1394 :                                 - !DWARF2_DIR_SHOULD_END_WITH_SEPARATOR,</span>
<span class="lineNum">   12350 </span>            :                                 &quot;Directory Entry: %#x&quot;, i + idx_offset);
<span class="lineNum">   12351 </span>            : 
<span class="lineNum">   12352 </span><span class="lineCov">        805 :       dw2_asm_output_data (1, 0, &quot;End directory table&quot;);</span>
<span class="lineNum">   12353 </span>            :     }
<span class="lineNum">   12354 </span>            : 
<span class="lineNum">   12355 </span>            :   /* We have to emit them in the order of emitted_number since that's
<span class="lineNum">   12356 </span>            :      used in the debug info generation.  To do this efficiently we
<span class="lineNum">   12357 </span>            :      generate a back-mapping of the indices first.  */
<span class="lineNum">   12358 </span><span class="lineCov">        808 :   backmap = XALLOCAVEC (int, numfiles);</span>
<span class="lineNum">   12359 </span><span class="lineCov">       3913 :   for (i = 0; i &lt; numfiles; i++)</span>
<span class="lineNum">   12360 </span><span class="lineCov">       3105 :     backmap[files[i].file_idx-&gt;emitted_number - 1] = i;</span>
<span class="lineNum">   12361 </span>            : 
<span class="lineNum">   12362 </span><span class="lineCov">        808 :   if (dwarf_version &gt;= 5)</span>
<span class="lineNum">   12363 </span>            :     {
<span class="lineNum">   12364 </span><span class="lineCov">          3 :       const char *filename0 = get_AT_string (comp_unit_die (), DW_AT_name);</span>
<span class="lineNum">   12365 </span><span class="lineCov">          3 :       if (filename0 == NULL)</span>
<span class="lineNum">   12366 </span><span class="lineNoCov">          0 :         filename0 = &quot;&quot;;</span>
<span class="lineNum">   12367 </span>            :       /* DW_LNCT_directory_index can use DW_FORM_udata, DW_FORM_data1 and
<span class="lineNum">   12368 </span>            :          DW_FORM_data2.  Choose one based on the number of directories
<span class="lineNum">   12369 </span>            :          and how much space would they occupy in each encoding.
<span class="lineNum">   12370 </span>            :          If we have at most 256 directories, all indexes fit into
<span class="lineNum">   12371 </span>            :          a single byte, so DW_FORM_data1 is most compact (if there
<span class="lineNum">   12372 </span>            :          are at most 128 directories, DW_FORM_udata would be as
<span class="lineNum">   12373 </span>            :          compact as that, but not shorter and slower to decode).  */
<span class="lineNum">   12374 </span><span class="lineCov">          3 :       if (ndirs + idx_offset &lt;= 256)</span>
<span class="lineNum">   12375 </span>            :         idx_form = DW_FORM_data1;
<span class="lineNum">   12376 </span>            :       /* If there are more than 65536 directories, we have to use
<span class="lineNum">   12377 </span>            :          DW_FORM_udata, DW_FORM_data2 can't refer to them.
<span class="lineNum">   12378 </span>            :          Otherwise, compute what space would occupy if all the indexes
<span class="lineNum">   12379 </span>            :          used DW_FORM_udata - sum - and compare that to how large would
<span class="lineNum">   12380 </span>            :          be DW_FORM_data2 encoding, and pick the more efficient one.  */
<span class="lineNum">   12381 </span><span class="lineNoCov">          0 :       else if (ndirs + idx_offset &lt;= 65536)</span>
<span class="lineNum">   12382 </span>            :         {
<span class="lineNum">   12383 </span>            :           unsigned HOST_WIDE_INT sum = 1;
<span class="lineNum">   12384 </span><span class="lineNoCov">          0 :           for (i = 0; i &lt; numfiles; i++)</span>
<span class="lineNum">   12385 </span>            :             {
<span class="lineNum">   12386 </span><span class="lineNoCov">          0 :               int file_idx = backmap[i];</span>
<span class="lineNum">   12387 </span><span class="lineNoCov">          0 :               int dir_idx = dirs[files[file_idx].dir_idx].dir_idx;</span>
<span class="lineNum">   12388 </span><span class="lineNoCov">          0 :               sum += size_of_uleb128 (dir_idx);</span>
<span class="lineNum">   12389 </span>            :             }
<span class="lineNum">   12390 </span><span class="lineNoCov">          0 :           if (sum &gt;= HOST_WIDE_INT_UC (2) * (numfiles + 1))</span>
<span class="lineNum">   12391 </span><span class="lineNoCov">          0 :             idx_form = DW_FORM_data2;</span>
<span class="lineNum">   12392 </span>            :         }
<span class="lineNum">   12393 </span>            : #ifdef VMS_DEBUGGING_INFO
<span class="lineNum">   12394 </span>            :       dw2_asm_output_data (1, 4, &quot;File name entry format count&quot;);
<span class="lineNum">   12395 </span>            : #else
<span class="lineNum">   12396 </span><span class="lineCov">          3 :       dw2_asm_output_data (1, 2, &quot;File name entry format count&quot;);</span>
<span class="lineNum">   12397 </span>            : #endif
<span class="lineNum">   12398 </span><span class="lineCov">          3 :       dw2_asm_output_data_uleb128 (DW_LNCT_path, &quot;DW_LNCT_path&quot;);</span>
<span class="lineNum">   12399 </span><span class="lineCov">          3 :       dw2_asm_output_data_uleb128 (str_form, &quot;%s&quot;,</span>
<span class="lineNum">   12400 </span>            :                                    get_DW_FORM_name (str_form));
<span class="lineNum">   12401 </span><span class="lineCov">          3 :       dw2_asm_output_data_uleb128 (DW_LNCT_directory_index,</span>
<span class="lineNum">   12402 </span>            :                                    &quot;DW_LNCT_directory_index&quot;);
<span class="lineNum">   12403 </span><span class="lineCov">          3 :       dw2_asm_output_data_uleb128 (idx_form, &quot;%s&quot;,</span>
<span class="lineNum">   12404 </span>            :                                    get_DW_FORM_name (idx_form));
<span class="lineNum">   12405 </span>            : #ifdef VMS_DEBUGGING_INFO
<span class="lineNum">   12406 </span>            :       dw2_asm_output_data_uleb128 (DW_LNCT_timestamp, &quot;DW_LNCT_timestamp&quot;);
<span class="lineNum">   12407 </span>            :       dw2_asm_output_data_uleb128 (DW_FORM_udata, &quot;DW_FORM_udata&quot;);
<span class="lineNum">   12408 </span>            :       dw2_asm_output_data_uleb128 (DW_LNCT_size, &quot;DW_LNCT_size&quot;);
<span class="lineNum">   12409 </span>            :       dw2_asm_output_data_uleb128 (DW_FORM_udata, &quot;DW_FORM_udata&quot;);
<span class="lineNum">   12410 </span>            : #endif
<span class="lineNum">   12411 </span><span class="lineCov">          3 :       dw2_asm_output_data_uleb128 (numfiles + 1, &quot;File names count&quot;);</span>
<span class="lineNum">   12412 </span>            : 
<span class="lineNum">   12413 </span><span class="lineCov">          3 :       output_line_string (str_form, filename0, &quot;File Entry&quot;, 0);</span>
<span class="lineNum">   12414 </span>            : 
<span class="lineNum">   12415 </span>            :       /* Include directory index.  */
<span class="lineNum">   12416 </span><span class="lineCov">          3 :       if (idx_form != DW_FORM_udata)</span>
<span class="lineNum">   12417 </span><span class="lineCov">          3 :         dw2_asm_output_data (idx_form == DW_FORM_data1 ? 1 : 2,</span>
<span class="lineNum">   12418 </span>            :                              0, NULL);
<span class="lineNum">   12419 </span>            :       else
<span class="lineNum">   12420 </span><span class="lineNoCov">          0 :         dw2_asm_output_data_uleb128 (0, NULL);</span>
<span class="lineNum">   12421 </span>            : 
<span class="lineNum">   12422 </span>            : #ifdef VMS_DEBUGGING_INFO
<span class="lineNum">   12423 </span>            :       dw2_asm_output_data_uleb128 (0, NULL);
<span class="lineNum">   12424 </span>            :       dw2_asm_output_data_uleb128 (0, NULL);
<span class="lineNum">   12425 </span>            : #endif
<span class="lineNum">   12426 </span>            :     }
<span class="lineNum">   12427 </span>            : 
<span class="lineNum">   12428 </span>            :   /* Now write all the file names.  */
<span class="lineNum">   12429 </span><span class="lineCov">       3913 :   for (i = 0; i &lt; numfiles; i++)</span>
<span class="lineNum">   12430 </span>            :     {
<span class="lineNum">   12431 </span><span class="lineCov">       3105 :       int file_idx = backmap[i];</span>
<span class="lineNum">   12432 </span><span class="lineCov">       3105 :       int dir_idx = dirs[files[file_idx].dir_idx].dir_idx;</span>
<span class="lineNum">   12433 </span>            : 
<span class="lineNum">   12434 </span>            : #ifdef VMS_DEBUGGING_INFO
<span class="lineNum">   12435 </span>            : #define MAX_VMS_VERSION_LEN 6 /* &quot;;32768&quot; */
<span class="lineNum">   12436 </span>            : 
<span class="lineNum">   12437 </span>            :       /* Setting these fields can lead to debugger miscomparisons,
<span class="lineNum">   12438 </span>            :          but VMS Debug requires them to be set correctly.  */
<span class="lineNum">   12439 </span>            : 
<span class="lineNum">   12440 </span>            :       int ver;
<span class="lineNum">   12441 </span>            :       long long cdt;
<span class="lineNum">   12442 </span>            :       long siz;
<span class="lineNum">   12443 </span>            :       int maxfilelen = (strlen (files[file_idx].path)
<span class="lineNum">   12444 </span>            :                         + dirs[dir_idx].length
<span class="lineNum">   12445 </span>            :                         + MAX_VMS_VERSION_LEN + 1);
<span class="lineNum">   12446 </span>            :       char *filebuf = XALLOCAVEC (char, maxfilelen);
<span class="lineNum">   12447 </span>            : 
<span class="lineNum">   12448 </span>            :       vms_file_stats_name (files[file_idx].path, 0, 0, 0, &amp;ver);
<span class="lineNum">   12449 </span>            :       snprintf (filebuf, maxfilelen, &quot;%s;%d&quot;,
<span class="lineNum">   12450 </span>            :                 files[file_idx].path + dirs[dir_idx].length, ver);
<span class="lineNum">   12451 </span>            : 
<span class="lineNum">   12452 </span>            :       output_line_string (str_form, filebuf, &quot;File Entry&quot;, (unsigned) i + 1);
<span class="lineNum">   12453 </span>            : 
<span class="lineNum">   12454 </span>            :       /* Include directory index.  */
<span class="lineNum">   12455 </span>            :       if (dwarf_version &gt;= 5 &amp;&amp; idx_form != DW_FORM_udata)
<span class="lineNum">   12456 </span>            :         dw2_asm_output_data (idx_form == DW_FORM_data1 ? 1 : 2,
<span class="lineNum">   12457 </span>            :                              dir_idx + idx_offset, NULL);
<span class="lineNum">   12458 </span>            :       else
<span class="lineNum">   12459 </span>            :         dw2_asm_output_data_uleb128 (dir_idx + idx_offset, NULL);
<span class="lineNum">   12460 </span>            : 
<span class="lineNum">   12461 </span>            :       /* Modification time.  */
<span class="lineNum">   12462 </span>            :       dw2_asm_output_data_uleb128 ((vms_file_stats_name (files[file_idx].path,
<span class="lineNum">   12463 </span>            :                                                          &amp;cdt, 0, 0, 0) == 0)
<span class="lineNum">   12464 </span>            :                                    ? cdt : 0, NULL);
<span class="lineNum">   12465 </span>            : 
<span class="lineNum">   12466 </span>            :       /* File length in bytes.  */
<span class="lineNum">   12467 </span>            :       dw2_asm_output_data_uleb128 ((vms_file_stats_name (files[file_idx].path,
<span class="lineNum">   12468 </span>            :                                                          0, &amp;siz, 0, 0) == 0)
<span class="lineNum">   12469 </span>            :                                    ? siz : 0, NULL);
<span class="lineNum">   12470 </span>            : #else
<span class="lineNum">   12471 </span><span class="lineCov">       9315 :       output_line_string (str_form,</span>
<span class="lineNum">   12472 </span><span class="lineCov">       3105 :                           files[file_idx].path + dirs[dir_idx].length,</span>
<span class="lineNum">   12473 </span><span class="lineCov">       3105 :                           &quot;File Entry&quot;, (unsigned) i + 1);</span>
<span class="lineNum">   12474 </span>            : 
<span class="lineNum">   12475 </span>            :       /* Include directory index.  */
<span class="lineNum">   12476 </span><span class="lineCov">       3105 :       if (dwarf_version &gt;= 5 &amp;&amp; idx_form != DW_FORM_udata)</span>
<span class="lineNum">   12477 </span><span class="lineCov">          3 :         dw2_asm_output_data (idx_form == DW_FORM_data1 ? 1 : 2,</span>
<span class="lineNum">   12478 </span><span class="lineCov">          3 :                              dir_idx + idx_offset, NULL);</span>
<span class="lineNum">   12479 </span>            :       else
<span class="lineNum">   12480 </span><span class="lineCov">       3102 :         dw2_asm_output_data_uleb128 (dir_idx + idx_offset, NULL);</span>
<span class="lineNum">   12481 </span>            : 
<span class="lineNum">   12482 </span><span class="lineCov">       3105 :       if (dwarf_version &gt;= 5)</span>
<span class="lineNum">   12483 </span>            :         continue;
<span class="lineNum">   12484 </span>            : 
<span class="lineNum">   12485 </span>            :       /* Modification time.  */
<span class="lineNum">   12486 </span><span class="lineCov">       3102 :       dw2_asm_output_data_uleb128 (0, NULL);</span>
<span class="lineNum">   12487 </span>            : 
<span class="lineNum">   12488 </span>            :       /* File length in bytes.  */
<span class="lineNum">   12489 </span><span class="lineCov">       3102 :       dw2_asm_output_data_uleb128 (0, NULL);</span>
<span class="lineNum">   12490 </span>            : #endif /* VMS_DEBUGGING_INFO */
<span class="lineNum">   12491 </span>            :     }
<span class="lineNum">   12492 </span>            : 
<span class="lineNum">   12493 </span><span class="lineCov">        808 :   if (dwarf_version &lt; 5)</span>
<span class="lineNum">   12494 </span><span class="lineCov">        805 :     dw2_asm_output_data (1, 0, &quot;End file name table&quot;);</span>
<span class="lineNum">   12495 </span>            : }
<span class="lineNum">   12496 </span>            : 
<span class="lineNum">   12497 </span>            : 
<span class="lineNum">   12498 </span>            : /* Output one line number table into the .debug_line section.  */
<a name="12499"><span class="lineNum">   12499 </span>            : </a>
<span class="lineNum">   12500 </span>            : static void
<span class="lineNum">   12501 </span><span class="lineNoCov">          0 : output_one_line_info_table (dw_line_info_table *table)</span>
<span class="lineNum">   12502 </span>            : {
<span class="lineNum">   12503 </span><span class="lineNoCov">          0 :   char line_label[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">   12504 </span><span class="lineNoCov">          0 :   unsigned int current_line = 1;</span>
<span class="lineNum">   12505 </span><span class="lineNoCov">          0 :   bool current_is_stmt = DWARF_LINE_DEFAULT_IS_STMT_START;</span>
<span class="lineNum">   12506 </span><span class="lineNoCov">          0 :   dw_line_info_entry *ent, *prev_addr;</span>
<span class="lineNum">   12507 </span><span class="lineNoCov">          0 :   size_t i;</span>
<span class="lineNum">   12508 </span><span class="lineNoCov">          0 :   unsigned int view;</span>
<span class="lineNum">   12509 </span>            : 
<span class="lineNum">   12510 </span><span class="lineNoCov">          0 :   view = 0;</span>
<span class="lineNum">   12511 </span>            : 
<span class="lineNum">   12512 </span><span class="lineNoCov">          0 :   FOR_EACH_VEC_SAFE_ELT (table-&gt;entries, i, ent)</span>
<span class="lineNum">   12513 </span>            :     {
<span class="lineNum">   12514 </span><span class="lineNoCov">          0 :       switch (ent-&gt;opcode)</span>
<span class="lineNum">   12515 </span>            :         {
<span class="lineNum">   12516 </span><span class="lineNoCov">          0 :         case LI_set_address:</span>
<span class="lineNum">   12517 </span>            :           /* ??? Unfortunately, we have little choice here currently, and
<span class="lineNum">   12518 </span>            :              must always use the most general form.  GCC does not know the
<span class="lineNum">   12519 </span>            :              address delta itself, so we can't use DW_LNS_advance_pc.  Many
<span class="lineNum">   12520 </span>            :              ports do have length attributes which will give an upper bound
<span class="lineNum">   12521 </span>            :              on the address range.  We could perhaps use length attributes
<span class="lineNum">   12522 </span>            :              to determine when it is safe to use DW_LNS_fixed_advance_pc.  */
<span class="lineNum">   12523 </span><span class="lineNoCov">          0 :           ASM_GENERATE_INTERNAL_LABEL (line_label, LINE_CODE_LABEL, ent-&gt;val);</span>
<span class="lineNum">   12524 </span>            : 
<span class="lineNum">   12525 </span><span class="lineNoCov">          0 :           view = 0;</span>
<span class="lineNum">   12526 </span>            : 
<span class="lineNum">   12527 </span>            :           /* This can handle any delta.  This takes
<span class="lineNum">   12528 </span>            :              4+DWARF2_ADDR_SIZE bytes.  */
<span class="lineNum">   12529 </span><span class="lineNoCov">          0 :           dw2_asm_output_data (1, 0, &quot;set address %s%s&quot;, line_label,</span>
<span class="lineNum">   12530 </span><span class="lineNoCov">          0 :                                debug_variable_location_views</span>
<span class="lineNum">   12531 </span>            :                                ? &quot;, reset view to 0&quot; : &quot;&quot;);
<span class="lineNum">   12532 </span><span class="lineNoCov">          0 :           dw2_asm_output_data_uleb128 (1 + DWARF2_ADDR_SIZE, NULL);</span>
<span class="lineNum">   12533 </span><span class="lineNoCov">          0 :           dw2_asm_output_data (1, DW_LNE_set_address, NULL);</span>
<span class="lineNum">   12534 </span><span class="lineNoCov">          0 :           dw2_asm_output_addr (DWARF2_ADDR_SIZE, line_label, NULL);</span>
<span class="lineNum">   12535 </span>            : 
<span class="lineNum">   12536 </span><span class="lineNoCov">          0 :           prev_addr = ent;</span>
<span class="lineNum">   12537 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   12538 </span>            : 
<span class="lineNum">   12539 </span><span class="lineNoCov">          0 :         case LI_adv_address:</span>
<span class="lineNum">   12540 </span><span class="lineNoCov">          0 :           {</span>
<span class="lineNum">   12541 </span><span class="lineNoCov">          0 :             ASM_GENERATE_INTERNAL_LABEL (line_label, LINE_CODE_LABEL, ent-&gt;val);</span>
<span class="lineNum">   12542 </span><span class="lineNoCov">          0 :             char prev_label[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">   12543 </span><span class="lineNoCov">          0 :             ASM_GENERATE_INTERNAL_LABEL (prev_label, LINE_CODE_LABEL, prev_addr-&gt;val);</span>
<span class="lineNum">   12544 </span>            : 
<span class="lineNum">   12545 </span><span class="lineNoCov">          0 :             view++;</span>
<span class="lineNum">   12546 </span>            : 
<span class="lineNum">   12547 </span><span class="lineNoCov">          0 :             dw2_asm_output_data (1, DW_LNS_fixed_advance_pc, &quot;fixed advance PC, increment view to %i&quot;, view);</span>
<span class="lineNum">   12548 </span><span class="lineNoCov">          0 :             dw2_asm_output_delta (2, line_label, prev_label,</span>
<span class="lineNum">   12549 </span>            :                                   &quot;from %s to %s&quot;, prev_label, line_label);
<span class="lineNum">   12550 </span>            : 
<span class="lineNum">   12551 </span><span class="lineNoCov">          0 :             prev_addr = ent;</span>
<span class="lineNum">   12552 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">   12553 </span>            :           }
<span class="lineNum">   12554 </span>            : 
<span class="lineNum">   12555 </span><span class="lineNoCov">          0 :         case LI_set_line:</span>
<span class="lineNum">   12556 </span><span class="lineNoCov">          0 :           if (ent-&gt;val == current_line)</span>
<span class="lineNum">   12557 </span>            :             {
<span class="lineNum">   12558 </span>            :               /* We still need to start a new row, so output a copy insn.  */
<span class="lineNum">   12559 </span><span class="lineNoCov">          0 :               dw2_asm_output_data (1, DW_LNS_copy,</span>
<span class="lineNum">   12560 </span>            :                                    &quot;copy line %u&quot;, current_line);
<span class="lineNum">   12561 </span>            :             }
<span class="lineNum">   12562 </span>            :           else
<span class="lineNum">   12563 </span>            :             {
<span class="lineNum">   12564 </span><span class="lineNoCov">          0 :               int line_offset = ent-&gt;val - current_line;</span>
<span class="lineNum">   12565 </span><span class="lineNoCov">          0 :               int line_delta = line_offset - DWARF_LINE_BASE;</span>
<span class="lineNum">   12566 </span>            : 
<span class="lineNum">   12567 </span><span class="lineNoCov">          0 :               current_line = ent-&gt;val;</span>
<span class="lineNum">   12568 </span><span class="lineNoCov">          0 :               if (line_delta &gt;= 0 &amp;&amp; line_delta &lt; (DWARF_LINE_RANGE - 1))</span>
<span class="lineNum">   12569 </span>            :                 {
<span class="lineNum">   12570 </span>            :                   /* This can handle deltas from -10 to 234, using the current
<span class="lineNum">   12571 </span>            :                      definitions of DWARF_LINE_BASE and DWARF_LINE_RANGE.
<span class="lineNum">   12572 </span>            :                      This takes 1 byte.  */
<span class="lineNum">   12573 </span><span class="lineNoCov">          0 :                   dw2_asm_output_data (1, DWARF_LINE_OPCODE_BASE + line_delta,</span>
<span class="lineNum">   12574 </span>            :                                        &quot;line %u&quot;, current_line);
<span class="lineNum">   12575 </span>            :                 }
<span class="lineNum">   12576 </span>            :               else
<span class="lineNum">   12577 </span>            :                 {
<span class="lineNum">   12578 </span>            :                   /* This can handle any delta.  This takes at least 4 bytes,
<span class="lineNum">   12579 </span>            :                      depending on the value being encoded.  */
<span class="lineNum">   12580 </span><span class="lineNoCov">          0 :                   dw2_asm_output_data (1, DW_LNS_advance_line,</span>
<span class="lineNum">   12581 </span>            :                                        &quot;advance to line %u&quot;, current_line);
<span class="lineNum">   12582 </span><span class="lineNoCov">          0 :                   dw2_asm_output_data_sleb128 (line_offset, NULL);</span>
<span class="lineNum">   12583 </span><span class="lineNoCov">          0 :                   dw2_asm_output_data (1, DW_LNS_copy, NULL);</span>
<span class="lineNum">   12584 </span>            :                 }
<span class="lineNum">   12585 </span>            :             }
<span class="lineNum">   12586 </span>            :           break;
<span class="lineNum">   12587 </span>            : 
<span class="lineNum">   12588 </span><span class="lineNoCov">          0 :         case LI_set_file:</span>
<span class="lineNum">   12589 </span><span class="lineNoCov">          0 :           dw2_asm_output_data (1, DW_LNS_set_file, &quot;set file %u&quot;, ent-&gt;val);</span>
<span class="lineNum">   12590 </span><span class="lineNoCov">          0 :           dw2_asm_output_data_uleb128 (ent-&gt;val, &quot;%u&quot;, ent-&gt;val);</span>
<span class="lineNum">   12591 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   12592 </span>            : 
<span class="lineNum">   12593 </span><span class="lineNoCov">          0 :         case LI_set_column:</span>
<span class="lineNum">   12594 </span><span class="lineNoCov">          0 :           dw2_asm_output_data (1, DW_LNS_set_column, &quot;column %u&quot;, ent-&gt;val);</span>
<span class="lineNum">   12595 </span><span class="lineNoCov">          0 :           dw2_asm_output_data_uleb128 (ent-&gt;val, &quot;%u&quot;, ent-&gt;val);</span>
<span class="lineNum">   12596 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   12597 </span>            : 
<span class="lineNum">   12598 </span><span class="lineNoCov">          0 :         case LI_negate_stmt:</span>
<span class="lineNum">   12599 </span><span class="lineNoCov">          0 :           current_is_stmt = !current_is_stmt;</span>
<span class="lineNum">   12600 </span><span class="lineNoCov">          0 :           dw2_asm_output_data (1, DW_LNS_negate_stmt,</span>
<span class="lineNum">   12601 </span>            :                                &quot;is_stmt %d&quot;, current_is_stmt);
<span class="lineNum">   12602 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   12603 </span>            : 
<span class="lineNum">   12604 </span><span class="lineNoCov">          0 :         case LI_set_prologue_end:</span>
<span class="lineNum">   12605 </span><span class="lineNoCov">          0 :           dw2_asm_output_data (1, DW_LNS_set_prologue_end,</span>
<span class="lineNum">   12606 </span>            :                                &quot;set prologue end&quot;);
<span class="lineNum">   12607 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   12608 </span>            :           
<span class="lineNum">   12609 </span><span class="lineNoCov">          0 :         case LI_set_epilogue_begin:</span>
<span class="lineNum">   12610 </span><span class="lineNoCov">          0 :           dw2_asm_output_data (1, DW_LNS_set_epilogue_begin,</span>
<span class="lineNum">   12611 </span>            :                                &quot;set epilogue begin&quot;);
<span class="lineNum">   12612 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   12613 </span>            : 
<span class="lineNum">   12614 </span><span class="lineNoCov">          0 :         case LI_set_discriminator:</span>
<span class="lineNum">   12615 </span><span class="lineNoCov">          0 :           dw2_asm_output_data (1, 0, &quot;discriminator %u&quot;, ent-&gt;val);</span>
<span class="lineNum">   12616 </span><span class="lineNoCov">          0 :           dw2_asm_output_data_uleb128 (1 + size_of_uleb128 (ent-&gt;val), NULL);</span>
<span class="lineNum">   12617 </span><span class="lineNoCov">          0 :           dw2_asm_output_data (1, DW_LNE_set_discriminator, NULL);</span>
<span class="lineNum">   12618 </span><span class="lineNoCov">          0 :           dw2_asm_output_data_uleb128 (ent-&gt;val, NULL);</span>
<span class="lineNum">   12619 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   12620 </span>            :         }
<span class="lineNum">   12621 </span>            :     }
<span class="lineNum">   12622 </span>            : 
<span class="lineNum">   12623 </span>            :   /* Emit debug info for the address of the end of the table.  */
<span class="lineNum">   12624 </span><span class="lineNoCov">          0 :   dw2_asm_output_data (1, 0, &quot;set address %s&quot;, table-&gt;end_label);</span>
<span class="lineNum">   12625 </span><span class="lineNoCov">          0 :   dw2_asm_output_data_uleb128 (1 + DWARF2_ADDR_SIZE, NULL);</span>
<span class="lineNum">   12626 </span><span class="lineNoCov">          0 :   dw2_asm_output_data (1, DW_LNE_set_address, NULL);</span>
<span class="lineNum">   12627 </span><span class="lineNoCov">          0 :   dw2_asm_output_addr (DWARF2_ADDR_SIZE, table-&gt;end_label, NULL);</span>
<span class="lineNum">   12628 </span>            : 
<span class="lineNum">   12629 </span><span class="lineNoCov">          0 :   dw2_asm_output_data (1, 0, &quot;end sequence&quot;);</span>
<span class="lineNum">   12630 </span><span class="lineNoCov">          0 :   dw2_asm_output_data_uleb128 (1, NULL);</span>
<span class="lineNum">   12631 </span><span class="lineNoCov">          0 :   dw2_asm_output_data (1, DW_LNE_end_sequence, NULL);</span>
<span class="lineNum">   12632 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   12633 </span>            : 
<span class="lineNum">   12634 </span>            : /* Output the source line number correspondence information.  This
<span class="lineNum">   12635 </span>            :    information goes into the .debug_line section.  */
<a name="12636"><span class="lineNum">   12636 </span>            : </a>
<span class="lineNum">   12637 </span>            : static void
<span class="lineNum">   12638 </span><span class="lineCov">        812 : output_line_info (bool prologue_only)</span>
<span class="lineNum">   12639 </span>            : {
<span class="lineNum">   12640 </span><span class="lineCov">        812 :   static unsigned int generation;</span>
<span class="lineNum">   12641 </span><span class="lineCov">        812 :   char l1[MAX_ARTIFICIAL_LABEL_BYTES], l2[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">   12642 </span><span class="lineCov">        812 :   char p1[MAX_ARTIFICIAL_LABEL_BYTES], p2[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">   12643 </span><span class="lineCov">        812 :   bool saw_one = false;</span>
<span class="lineNum">   12644 </span><span class="lineCov">        812 :   int opc;</span>
<span class="lineNum">   12645 </span>            : 
<span class="lineNum">   12646 </span><span class="lineCov">        812 :   ASM_GENERATE_INTERNAL_LABEL (l1, LINE_NUMBER_BEGIN_LABEL, generation);</span>
<span class="lineNum">   12647 </span><span class="lineCov">        812 :   ASM_GENERATE_INTERNAL_LABEL (l2, LINE_NUMBER_END_LABEL, generation);</span>
<span class="lineNum">   12648 </span><span class="lineCov">        812 :   ASM_GENERATE_INTERNAL_LABEL (p1, LN_PROLOG_AS_LABEL, generation);</span>
<span class="lineNum">   12649 </span><span class="lineCov">        812 :   ASM_GENERATE_INTERNAL_LABEL (p2, LN_PROLOG_END_LABEL, generation++);</span>
<span class="lineNum">   12650 </span>            : 
<span class="lineNum">   12651 </span><span class="lineCov">        812 :   if (!XCOFF_DEBUGGING_INFO)</span>
<span class="lineNum">   12652 </span>            :     {
<span class="lineNum">   12653 </span><span class="lineCov">        812 :       if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)</span>
<span class="lineNum">   12654 </span>            :         dw2_asm_output_data (4, 0xffffffff,
<span class="lineNum">   12655 </span>            :           &quot;Initial length escape value indicating 64-bit DWARF extension&quot;);
<span class="lineNum">   12656 </span><span class="lineCov">        812 :       dw2_asm_output_delta (DWARF_OFFSET_SIZE, l2, l1,</span>
<span class="lineNum">   12657 </span>            :                             &quot;Length of Source Line Info&quot;);
<span class="lineNum">   12658 </span>            :     }
<span class="lineNum">   12659 </span>            : 
<span class="lineNum">   12660 </span><span class="lineCov">        812 :   ASM_OUTPUT_LABEL (asm_out_file, l1);</span>
<span class="lineNum">   12661 </span>            : 
<span class="lineNum">   12662 </span><span class="lineCov">        812 :   output_dwarf_version ();</span>
<span class="lineNum">   12663 </span><span class="lineCov">        812 :   if (dwarf_version &gt;= 5)</span>
<span class="lineNum">   12664 </span>            :     {
<span class="lineNum">   12665 </span><span class="lineCov">          3 :       dw2_asm_output_data (1, DWARF2_ADDR_SIZE, &quot;Address Size&quot;);</span>
<span class="lineNum">   12666 </span><span class="lineCov">          3 :       dw2_asm_output_data (1, 0, &quot;Segment Size&quot;);</span>
<span class="lineNum">   12667 </span>            :     }
<span class="lineNum">   12668 </span><span class="lineCov">        812 :   dw2_asm_output_delta (DWARF_OFFSET_SIZE, p2, p1, &quot;Prolog Length&quot;);</span>
<span class="lineNum">   12669 </span><span class="lineCov">        812 :   ASM_OUTPUT_LABEL (asm_out_file, p1);</span>
<span class="lineNum">   12670 </span>            : 
<span class="lineNum">   12671 </span>            :   /* Define the architecture-dependent minimum instruction length (in bytes).
<span class="lineNum">   12672 </span>            :      In this implementation of DWARF, this field is used for information
<span class="lineNum">   12673 </span>            :      purposes only.  Since GCC generates assembly language, we have no
<span class="lineNum">   12674 </span>            :      a priori knowledge of how many instruction bytes are generated for each
<span class="lineNum">   12675 </span>            :      source line, and therefore can use only the DW_LNE_set_address and
<span class="lineNum">   12676 </span>            :      DW_LNS_fixed_advance_pc line information commands.  Accordingly, we fix
<span class="lineNum">   12677 </span>            :      this as '1', which is &quot;correct enough&quot; for all architectures,
<span class="lineNum">   12678 </span>            :      and don't let the target override.  */
<span class="lineNum">   12679 </span><span class="lineCov">        812 :   dw2_asm_output_data (1, 1, &quot;Minimum Instruction Length&quot;);</span>
<span class="lineNum">   12680 </span>            : 
<span class="lineNum">   12681 </span><span class="lineCov">        812 :   if (dwarf_version &gt;= 4)</span>
<span class="lineNum">   12682 </span><span class="lineCov">        783 :     dw2_asm_output_data (1, DWARF_LINE_DEFAULT_MAX_OPS_PER_INSN,</span>
<span class="lineNum">   12683 </span>            :                          &quot;Maximum Operations Per Instruction&quot;);
<span class="lineNum">   12684 </span><span class="lineCov">        812 :   dw2_asm_output_data (1, DWARF_LINE_DEFAULT_IS_STMT_START,</span>
<span class="lineNum">   12685 </span>            :                        &quot;Default is_stmt_start flag&quot;);
<span class="lineNum">   12686 </span><span class="lineCov">        812 :   dw2_asm_output_data (1, DWARF_LINE_BASE,</span>
<span class="lineNum">   12687 </span>            :                        &quot;Line Base Value (Special Opcodes)&quot;);
<span class="lineNum">   12688 </span><span class="lineCov">        812 :   dw2_asm_output_data (1, DWARF_LINE_RANGE,</span>
<span class="lineNum">   12689 </span>            :                        &quot;Line Range Value (Special Opcodes)&quot;);
<span class="lineNum">   12690 </span><span class="lineCov">        812 :   dw2_asm_output_data (1, DWARF_LINE_OPCODE_BASE,</span>
<span class="lineNum">   12691 </span>            :                        &quot;Special Opcode Base&quot;);
<span class="lineNum">   12692 </span>            : 
<span class="lineNum">   12693 </span><span class="lineCov">      10556 :   for (opc = 1; opc &lt; DWARF_LINE_OPCODE_BASE; opc++)</span>
<span class="lineNum">   12694 </span>            :     {
<span class="lineNum">   12695 </span><span class="lineCov">       9744 :       int n_op_args;</span>
<span class="lineNum">   12696 </span><span class="lineCov">       9744 :       switch (opc)</span>
<span class="lineNum">   12697 </span>            :         {
<span class="lineNum">   12698 </span>            :         case DW_LNS_advance_pc:
<span class="lineNum">   12699 </span>            :         case DW_LNS_advance_line:
<span class="lineNum">   12700 </span>            :         case DW_LNS_set_file:
<span class="lineNum">   12701 </span>            :         case DW_LNS_set_column:
<span class="lineNum">   12702 </span>            :         case DW_LNS_fixed_advance_pc:
<span class="lineNum">   12703 </span>            :         case DW_LNS_set_isa:
<span class="lineNum">   12704 </span>            :           n_op_args = 1;
<span class="lineNum">   12705 </span>            :           break;
<span class="lineNum">   12706 </span>            :         default:
<span class="lineNum">   12707 </span>            :           n_op_args = 0;
<span class="lineNum">   12708 </span>            :           break;
<span class="lineNum">   12709 </span>            :         }
<span class="lineNum">   12710 </span>            : 
<span class="lineNum">   12711 </span><span class="lineCov">       9744 :       dw2_asm_output_data (1, n_op_args, &quot;opcode: %#x has %d args&quot;,</span>
<span class="lineNum">   12712 </span>            :                            opc, n_op_args);
<span class="lineNum">   12713 </span>            :     }
<span class="lineNum">   12714 </span>            : 
<span class="lineNum">   12715 </span>            :   /* Write out the information about the files we use.  */
<span class="lineNum">   12716 </span><span class="lineCov">        812 :   output_file_names ();</span>
<span class="lineNum">   12717 </span><span class="lineCov">        812 :   ASM_OUTPUT_LABEL (asm_out_file, p2);</span>
<span class="lineNum">   12718 </span><span class="lineCov">        812 :   if (prologue_only)</span>
<span class="lineNum">   12719 </span>            :     {
<span class="lineNum">   12720 </span>            :       /* Output the marker for the end of the line number info.  */
<span class="lineNum">   12721 </span><span class="lineCov">        812 :       ASM_OUTPUT_LABEL (asm_out_file, l2);</span>
<span class="lineNum">   12722 </span><span class="lineCov">        812 :       return;</span>
<span class="lineNum">   12723 </span>            :     }
<span class="lineNum">   12724 </span>            : 
<span class="lineNum">   12725 </span><span class="lineNoCov">          0 :   if (separate_line_info)</span>
<span class="lineNum">   12726 </span>            :     {
<span class="lineNum">   12727 </span>            :       dw_line_info_table *table;
<span class="lineNum">   12728 </span>            :       size_t i;
<span class="lineNum">   12729 </span>            : 
<span class="lineNum">   12730 </span><span class="lineNoCov">          0 :       FOR_EACH_VEC_ELT (*separate_line_info, i, table)</span>
<span class="lineNum">   12731 </span><span class="lineNoCov">          0 :         if (table-&gt;in_use)</span>
<span class="lineNum">   12732 </span>            :           {
<span class="lineNum">   12733 </span><span class="lineNoCov">          0 :             output_one_line_info_table (table);</span>
<span class="lineNum">   12734 </span><span class="lineNoCov">          0 :             saw_one = true;</span>
<span class="lineNum">   12735 </span>            :           }
<span class="lineNum">   12736 </span>            :     }
<span class="lineNum">   12737 </span><span class="lineNoCov">          0 :   if (cold_text_section_line_info &amp;&amp; cold_text_section_line_info-&gt;in_use)</span>
<span class="lineNum">   12738 </span>            :     {
<span class="lineNum">   12739 </span><span class="lineNoCov">          0 :       output_one_line_info_table (cold_text_section_line_info);</span>
<span class="lineNum">   12740 </span><span class="lineNoCov">          0 :       saw_one = true;</span>
<span class="lineNum">   12741 </span>            :     }
<span class="lineNum">   12742 </span>            : 
<span class="lineNum">   12743 </span>            :   /* ??? Some Darwin linkers crash on a .debug_line section with no
<span class="lineNum">   12744 </span>            :      sequences.  Further, merely a DW_LNE_end_sequence entry is not
<span class="lineNum">   12745 </span>            :      sufficient -- the address column must also be initialized.
<span class="lineNum">   12746 </span>            :      Make sure to output at least one set_address/end_sequence pair,
<span class="lineNum">   12747 </span>            :      choosing .text since that section is always present.  */
<span class="lineNum">   12748 </span><span class="lineNoCov">          0 :   if (text_section_line_info-&gt;in_use || !saw_one)</span>
<span class="lineNum">   12749 </span><span class="lineNoCov">          0 :     output_one_line_info_table (text_section_line_info);</span>
<span class="lineNum">   12750 </span>            : 
<span class="lineNum">   12751 </span>            :   /* Output the marker for the end of the line number info.  */
<span class="lineNum">   12752 </span><span class="lineNoCov">          0 :   ASM_OUTPUT_LABEL (asm_out_file, l2);</span>
<span class="lineNum">   12753 </span>            : }
<span class="lineNum">   12754 </span>            : 
<span class="lineNum">   12755 </span>            : /* Return true if DW_AT_endianity should be emitted according to REVERSE.  */
<span class="lineNum">   12756 </span>            : 
<span class="lineNum">   12757 </span>            : static inline bool
<span class="lineNum">   12758 </span>            : need_endianity_attribute_p (bool reverse)
<span class="lineNum">   12759 </span>            : {
<span class="lineNum">   12760 </span><span class="lineCov">        227 :   return reverse &amp;&amp; (dwarf_version &gt;= 3 || !dwarf_strict);</span>
<span class="lineNum">   12761 </span>            : }
<span class="lineNum">   12762 </span>            : 
<span class="lineNum">   12763 </span>            : /* Given a pointer to a tree node for some base type, return a pointer to
<span class="lineNum">   12764 </span>            :    a DIE that describes the given type.  REVERSE is true if the type is
<span class="lineNum">   12765 </span>            :    to be interpreted in the reverse storage order wrt the target order.
<span class="lineNum">   12766 </span>            : 
<span class="lineNum">   12767 </span>            :    This routine must only be called for GCC type nodes that correspond to
<span class="lineNum">   12768 </span>            :    Dwarf base (fundamental) types.  */
<a name="12769"><span class="lineNum">   12769 </span>            : </a>
<span class="lineNum">   12770 </span>            : static dw_die_ref
<span class="lineNum">   12771 </span><span class="lineCov">     194488 : base_type_die (tree type, bool reverse)</span>
<span class="lineNum">   12772 </span>            : {
<span class="lineNum">   12773 </span><span class="lineCov">     194488 :   dw_die_ref base_type_result;</span>
<span class="lineNum">   12774 </span><span class="lineCov">     194488 :   enum dwarf_type encoding;</span>
<span class="lineNum">   12775 </span><span class="lineCov">     194488 :   bool fpt_used = false;</span>
<span class="lineNum">   12776 </span><span class="lineCov">     194488 :   struct fixed_point_type_info fpt_info;</span>
<span class="lineNum">   12777 </span><span class="lineCov">     194488 :   tree type_bias = NULL_TREE;</span>
<span class="lineNum">   12778 </span>            : 
<span class="lineNum">   12779 </span>            :   /* If this is a subtype that should not be emitted as a subrange type,
<span class="lineNum">   12780 </span>            :      use the base type.  See subrange_type_for_debug_p.  */
<span class="lineNum">   12781 </span><span class="lineCov">     194488 :   if (TREE_CODE (type) == INTEGER_TYPE &amp;&amp; TREE_TYPE (type) != NULL_TREE)</span>
<span class="lineNum">   12782 </span>            :     type = TREE_TYPE (type);
<span class="lineNum">   12783 </span>            : 
<span class="lineNum">   12784 </span><span class="lineCov">     194488 :   switch (TREE_CODE (type))</span>
<span class="lineNum">   12785 </span>            :     {
<span class="lineNum">   12786 </span><span class="lineCov">     148504 :     case INTEGER_TYPE:</span>
<span class="lineNum">   12787 </span><span class="lineCov">       3649 :       if ((dwarf_version &gt;= 4 || !dwarf_strict)</span>
<span class="lineNum">   12788 </span><span class="lineCov">     148504 :           &amp;&amp; TYPE_NAME (type)</span>
<span class="lineNum">   12789 </span><span class="lineCov">     292854 :           &amp;&amp; TREE_CODE (TYPE_NAME (type)) == TYPE_DECL</span>
<span class="lineNum">   12790 </span><span class="lineCov">     286426 :           &amp;&amp; DECL_IS_BUILTIN (TYPE_NAME (type))</span>
<span class="lineNum">   12791 </span><span class="lineCov">     291697 :           &amp;&amp; DECL_NAME (TYPE_NAME (type)))</span>
<span class="lineNum">   12792 </span>            :         {
<span class="lineNum">   12793 </span><span class="lineCov">     429579 :           const char *name = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type)));</span>
<span class="lineNum">   12794 </span><span class="lineCov">     143193 :           if (strcmp (name, &quot;char16_t&quot;) == 0</span>
<span class="lineNum">   12795 </span><span class="lineCov">     141518 :               || strcmp (name, &quot;char32_t&quot;) == 0)</span>
<span class="lineNum">   12796 </span>            :             {
<span class="lineNum">   12797 </span>            :               encoding = DW_ATE_UTF;
<span class="lineNum">   12798 </span>            :               break;
<span class="lineNum">   12799 </span>            :             }
<span class="lineNum">   12800 </span>            :         }
<span class="lineNum">   12801 </span><span class="lineCov">     145154 :       if ((dwarf_version &gt;= 3 || !dwarf_strict)</span>
<span class="lineNum">   12802 </span><span class="lineCov">     145154 :           &amp;&amp; lang_hooks.types.get_fixed_point_type_info)</span>
<span class="lineNum">   12803 </span>            :         {
<span class="lineNum">   12804 </span><span class="lineNoCov">          0 :           memset (&amp;fpt_info, 0, sizeof (fpt_info));</span>
<span class="lineNum">   12805 </span><span class="lineNoCov">          0 :           if (lang_hooks.types.get_fixed_point_type_info (type, &amp;fpt_info))</span>
<span class="lineNum">   12806 </span>            :             {
<span class="lineNum">   12807 </span><span class="lineNoCov">          0 :               fpt_used = true;</span>
<span class="lineNum">   12808 </span><span class="lineNoCov">          0 :               encoding = ((TYPE_UNSIGNED (type))</span>
<span class="lineNum">   12809 </span><span class="lineNoCov">          0 :                           ? DW_ATE_unsigned_fixed</span>
<span class="lineNum">   12810 </span><span class="lineNoCov">          0 :                           : DW_ATE_signed_fixed);</span>
<span class="lineNum">   12811 </span>            :               break;
<span class="lineNum">   12812 </span>            :             }
<span class="lineNum">   12813 </span>            :         }
<span class="lineNum">   12814 </span><span class="lineCov">     145154 :       if (TYPE_STRING_FLAG (type))</span>
<span class="lineNum">   12815 </span>            :         {
<span class="lineNum">   12816 </span><span class="lineCov">      70058 :           if (TYPE_UNSIGNED (type))</span>
<span class="lineNum">   12817 </span>            :             encoding = DW_ATE_unsigned_char;
<span class="lineNum">   12818 </span>            :           else
<span class="lineNum">   12819 </span><span class="lineCov">      20901 :             encoding = DW_ATE_signed_char;</span>
<span class="lineNum">   12820 </span>            :         }
<span class="lineNum">   12821 </span><span class="lineCov">     220250 :       else if (TYPE_UNSIGNED (type))</span>
<span class="lineNum">   12822 </span>            :         encoding = DW_ATE_unsigned;
<span class="lineNum">   12823 </span>            :       else
<span class="lineNum">   12824 </span><span class="lineCov">      61529 :         encoding = DW_ATE_signed;</span>
<span class="lineNum">   12825 </span>            : 
<span class="lineNum">   12826 </span><span class="lineCov">     145154 :       if (!dwarf_strict</span>
<span class="lineNum">   12827 </span><span class="lineCov">     145150 :           &amp;&amp; lang_hooks.types.get_type_bias)</span>
<span class="lineNum">   12828 </span><span class="lineNoCov">          0 :         type_bias = lang_hooks.types.get_type_bias (type);</span>
<span class="lineNum">   12829 </span>            :       break;
<span class="lineNum">   12830 </span>            : 
<span class="lineNum">   12831 </span><span class="lineCov">      27149 :     case REAL_TYPE:</span>
<span class="lineNum">   12832 </span><span class="lineCov">      27149 :       if (DECIMAL_FLOAT_MODE_P (TYPE_MODE (type)))</span>
<span class="lineNum">   12833 </span>            :         {
<span class="lineNum">   12834 </span><span class="lineCov">        779 :           if (dwarf_version &gt;= 3 || !dwarf_strict)</span>
<span class="lineNum">   12835 </span>            :             encoding = DW_ATE_decimal_float;
<span class="lineNum">   12836 </span>            :           else
<span class="lineNum">   12837 </span><span class="lineNoCov">          0 :             encoding = DW_ATE_lo_user;</span>
<span class="lineNum">   12838 </span>            :         }
<span class="lineNum">   12839 </span>            :       else
<span class="lineNum">   12840 </span>            :         encoding = DW_ATE_float;
<span class="lineNum">   12841 </span>            :       break;
<span class="lineNum">   12842 </span>            : 
<span class="lineNum">   12843 </span><span class="lineNoCov">          0 :     case FIXED_POINT_TYPE:</span>
<span class="lineNum">   12844 </span><span class="lineNoCov">          0 :       if (!(dwarf_version &gt;= 3 || !dwarf_strict))</span>
<span class="lineNum">   12845 </span>            :         encoding = DW_ATE_lo_user;
<span class="lineNum">   12846 </span><span class="lineNoCov">          0 :       else if (TYPE_UNSIGNED (type))</span>
<span class="lineNum">   12847 </span>            :         encoding = DW_ATE_unsigned_fixed;
<span class="lineNum">   12848 </span>            :       else
<span class="lineNum">   12849 </span><span class="lineNoCov">          0 :         encoding = DW_ATE_signed_fixed;</span>
<span class="lineNum">   12850 </span>            :       break;
<span class="lineNum">   12851 </span>            : 
<span class="lineNum">   12852 </span>            :       /* Dwarf2 doesn't know anything about complex ints, so use
<span class="lineNum">   12853 </span>            :          a user defined type for it.  */
<span class="lineNum">   12854 </span><span class="lineCov">      13007 :     case COMPLEX_TYPE:</span>
<span class="lineNum">   12855 </span><span class="lineCov">      13007 :       if (TREE_CODE (TREE_TYPE (type)) == REAL_TYPE)</span>
<span class="lineNum">   12856 </span>            :         encoding = DW_ATE_complex_float;
<span class="lineNum">   12857 </span>            :       else
<span class="lineNum">   12858 </span><span class="lineCov">         43 :         encoding = DW_ATE_lo_user;</span>
<span class="lineNum">   12859 </span>            :       break;
<span class="lineNum">   12860 </span>            : 
<span class="lineNum">   12861 </span>            :     case BOOLEAN_TYPE:
<span class="lineNum">   12862 </span>            :       /* GNU FORTRAN/Ada/C++ BOOLEAN type.  */
<span class="lineNum">   12863 </span>            :       encoding = DW_ATE_boolean;
<span class="lineNum">   12864 </span>            :       break;
<span class="lineNum">   12865 </span>            : 
<span class="lineNum">   12866 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">   12867 </span>            :       /* No other TREE_CODEs are Dwarf fundamental types.  */
<span class="lineNum">   12868 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">   12869 </span>            :     }
<span class="lineNum">   12870 </span>            : 
<span class="lineNum">   12871 </span><span class="lineCov">     194488 :   base_type_result = new_die_raw (DW_TAG_base_type);</span>
<span class="lineNum">   12872 </span>            : 
<span class="lineNum">   12873 </span><span class="lineCov">     194488 :   add_AT_unsigned (base_type_result, DW_AT_byte_size,</span>
<span class="lineNum">   12874 </span><span class="lineCov">     194488 :                    int_size_in_bytes (type));</span>
<span class="lineNum">   12875 </span><span class="lineCov">     194488 :   add_AT_unsigned (base_type_result, DW_AT_encoding, encoding);</span>
<span class="lineNum">   12876 </span>            : 
<span class="lineNum">   12877 </span><span class="lineCov">     194488 :   if (need_endianity_attribute_p (reverse))</span>
<span class="lineNum">   12878 </span><span class="lineCov">         47 :     add_AT_unsigned (base_type_result, DW_AT_endianity,</span>
<span class="lineNum">   12879 </span>            :                      BYTES_BIG_ENDIAN ? DW_END_little : DW_END_big);
<span class="lineNum">   12880 </span>            : 
<span class="lineNum">   12881 </span><span class="lineCov">     194488 :   add_alignment_attribute (base_type_result, type);</span>
<span class="lineNum">   12882 </span>            : 
<span class="lineNum">   12883 </span><span class="lineCov">     194488 :   if (fpt_used)</span>
<span class="lineNum">   12884 </span>            :     {
<span class="lineNum">   12885 </span><span class="lineNoCov">          0 :       switch (fpt_info.scale_factor_kind)</span>
<span class="lineNum">   12886 </span>            :         {
<span class="lineNum">   12887 </span><span class="lineNoCov">          0 :         case fixed_point_scale_factor_binary:</span>
<span class="lineNum">   12888 </span><span class="lineNoCov">          0 :           add_AT_int (base_type_result, DW_AT_binary_scale,</span>
<span class="lineNum">   12889 </span><span class="lineNoCov">          0 :                       fpt_info.scale_factor.binary);</span>
<span class="lineNum">   12890 </span>            :           break;
<span class="lineNum">   12891 </span>            : 
<span class="lineNum">   12892 </span><span class="lineNoCov">          0 :         case fixed_point_scale_factor_decimal:</span>
<span class="lineNum">   12893 </span><span class="lineNoCov">          0 :           add_AT_int (base_type_result, DW_AT_decimal_scale,</span>
<span class="lineNum">   12894 </span><span class="lineNoCov">          0 :                       fpt_info.scale_factor.decimal);</span>
<span class="lineNum">   12895 </span>            :           break;
<span class="lineNum">   12896 </span>            : 
<span class="lineNum">   12897 </span><span class="lineNoCov">          0 :         case fixed_point_scale_factor_arbitrary:</span>
<span class="lineNum">   12898 </span>            :           /* Arbitrary scale factors cannot be described in standard DWARF,
<span class="lineNum">   12899 </span>            :              yet.  */
<span class="lineNum">   12900 </span><span class="lineNoCov">          0 :           if (!dwarf_strict)</span>
<span class="lineNum">   12901 </span>            :             {
<span class="lineNum">   12902 </span>            :               /* Describe the scale factor as a rational constant.  */
<span class="lineNum">   12903 </span><span class="lineNoCov">          0 :               const dw_die_ref scale_factor</span>
<span class="lineNum">   12904 </span><span class="lineNoCov">          0 :                 = new_die (DW_TAG_constant, comp_unit_die (), type);</span>
<span class="lineNum">   12905 </span>            : 
<span class="lineNum">   12906 </span><span class="lineNoCov">          0 :               add_AT_unsigned (scale_factor, DW_AT_GNU_numerator,</span>
<span class="lineNum">   12907 </span>            :                                fpt_info.scale_factor.arbitrary.numerator);
<span class="lineNum">   12908 </span><span class="lineNoCov">          0 :               add_AT_int (scale_factor, DW_AT_GNU_denominator,</span>
<span class="lineNum">   12909 </span>            :                           fpt_info.scale_factor.arbitrary.denominator);
<span class="lineNum">   12910 </span>            : 
<span class="lineNum">   12911 </span><span class="lineNoCov">          0 :               add_AT_die_ref (base_type_result, DW_AT_small, scale_factor);</span>
<span class="lineNum">   12912 </span>            :             }
<span class="lineNum">   12913 </span>            :           break;
<span class="lineNum">   12914 </span>            : 
<span class="lineNum">   12915 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">   12916 </span><span class="lineNoCov">          0 :           gcc_unreachable ();</span>
<span class="lineNum">   12917 </span>            :         }
<span class="lineNum">   12918 </span>            :     }
<span class="lineNum">   12919 </span>            : 
<span class="lineNum">   12920 </span><span class="lineCov">     194488 :   if (type_bias)</span>
<span class="lineNum">   12921 </span><span class="lineNoCov">          0 :     add_scalar_info (base_type_result, DW_AT_GNU_bias, type_bias,</span>
<span class="lineNum">   12922 </span>            :                      dw_scalar_form_constant
<span class="lineNum">   12923 </span>            :                      | dw_scalar_form_exprloc
<span class="lineNum">   12924 </span>            :                      | dw_scalar_form_reference,
<span class="lineNum">   12925 </span>            :                      NULL);
<span class="lineNum">   12926 </span>            : 
<span class="lineNum">   12927 </span><span class="lineCov">     194488 :   return base_type_result;</span>
<span class="lineNum">   12928 </span>            : }
<span class="lineNum">   12929 </span>            : 
<span class="lineNum">   12930 </span>            : /* A C++ function with deduced return type can have a TEMPLATE_TYPE_PARM
<span class="lineNum">   12931 </span>            :    named 'auto' in its type: return true for it, false otherwise.  */
<a name="12932"><span class="lineNum">   12932 </span>            : </a>
<span class="lineNum">   12933 </span>            : static inline bool
<span class="lineNum">   12934 </span><span class="lineCov">         45 : is_cxx_auto (tree type)</span>
<span class="lineNum">   12935 </span>            : {
<span class="lineNum">   12936 </span><span class="lineCov">         45 :   if (is_cxx ())</span>
<span class="lineNum">   12937 </span>            :     {
<span class="lineNum">   12938 </span><span class="lineCov">         45 :       tree name = TYPE_IDENTIFIER (type);</span>
<span class="lineNum">   12939 </span><span class="lineCov">         45 :       if (name == get_identifier (&quot;auto&quot;)</span>
<span class="lineNum">   12940 </span><span class="lineCov">         45 :           || name == get_identifier (&quot;decltype(auto)&quot;))</span>
<span class="lineNum">   12941 </span><span class="lineCov">         45 :         return true;</span>
<span class="lineNum">   12942 </span>            :     }
<span class="lineNum">   12943 </span>            :   return false;
<span class="lineNum">   12944 </span>            : }
<span class="lineNum">   12945 </span>            : 
<span class="lineNum">   12946 </span>            : /* Given a pointer to an arbitrary ..._TYPE tree node, return nonzero if the
<span class="lineNum">   12947 </span>            :    given input type is a Dwarf &quot;fundamental&quot; type.  Otherwise return null.  */
<a name="12948"><span class="lineNum">   12948 </span>            : </a>
<span class="lineNum">   12949 </span>            : static inline int
<span class="lineNum">   12950 </span><span class="lineCov">    1367742 : is_base_type (tree type)</span>
<span class="lineNum">   12951 </span>            : {
<span class="lineNum">   12952 </span><span class="lineCov">    1367742 :   switch (TREE_CODE (type))</span>
<span class="lineNum">   12953 </span>            :     {
<span class="lineNum">   12954 </span>            :     case INTEGER_TYPE:
<span class="lineNum">   12955 </span>            :     case REAL_TYPE:
<span class="lineNum">   12956 </span>            :     case FIXED_POINT_TYPE:
<span class="lineNum">   12957 </span>            :     case COMPLEX_TYPE:
<span class="lineNum">   12958 </span>            :     case BOOLEAN_TYPE:
<span class="lineNum">   12959 </span>            :       return 1;
<span class="lineNum">   12960 </span>            : 
<span class="lineNum">   12961 </span>            :     case VOID_TYPE:
<span class="lineNum">   12962 </span>            :     case ARRAY_TYPE:
<span class="lineNum">   12963 </span>            :     case RECORD_TYPE:
<span class="lineNum">   12964 </span>            :     case UNION_TYPE:
<span class="lineNum">   12965 </span>            :     case QUAL_UNION_TYPE:
<span class="lineNum">   12966 </span>            :     case ENUMERAL_TYPE:
<span class="lineNum">   12967 </span>            :     case FUNCTION_TYPE:
<span class="lineNum">   12968 </span>            :     case METHOD_TYPE:
<span class="lineNum">   12969 </span>            :     case POINTER_TYPE:
<span class="lineNum">   12970 </span>            :     case REFERENCE_TYPE:
<span class="lineNum">   12971 </span>            :     case NULLPTR_TYPE:
<span class="lineNum">   12972 </span>            :     case OFFSET_TYPE:
<span class="lineNum">   12973 </span>            :     case LANG_TYPE:
<span class="lineNum">   12974 </span>            :     case VECTOR_TYPE:
<span class="lineNum">   12975 </span>            :       return 0;
<span class="lineNum">   12976 </span>            : 
<span class="lineNum">   12977 </span><span class="lineCov">          1 :     default:</span>
<span class="lineNum">   12978 </span><span class="lineCov">          1 :       if (is_cxx_auto (type))</span>
<span class="lineNum">   12979 </span>            :         return 0;
<span class="lineNum">   12980 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">   12981 </span>            :     }
<span class="lineNum">   12982 </span>            : 
<span class="lineNum">   12983 </span>            :   return 0;
<span class="lineNum">   12984 </span>            : }
<span class="lineNum">   12985 </span>            : 
<span class="lineNum">   12986 </span>            : /* Given a pointer to a tree node, assumed to be some kind of a ..._TYPE
<span class="lineNum">   12987 </span>            :    node, return the size in bits for the type if it is a constant, or else
<span class="lineNum">   12988 </span>            :    return the alignment for the type if the type's size is not constant, or
<span class="lineNum">   12989 </span>            :    else return BITS_PER_WORD if the type actually turns out to be an
<span class="lineNum">   12990 </span>            :    ERROR_MARK node.  */
<a name="12991"><span class="lineNum">   12991 </span>            : </a>
<span class="lineNum">   12992 </span>            : static inline unsigned HOST_WIDE_INT
<span class="lineNum">   12993 </span><span class="lineCov">    6975238 : simple_type_size_in_bits (const_tree type)</span>
<span class="lineNum">   12994 </span>            : {
<span class="lineNum">   12995 </span><span class="lineCov">    6975238 :   if (TREE_CODE (type) == ERROR_MARK)</span>
<span class="lineNum">   12996 </span><span class="lineNoCov">          0 :     return BITS_PER_WORD;</span>
<span class="lineNum">   12997 </span><span class="lineCov">    6975238 :   else if (TYPE_SIZE (type) == NULL_TREE)</span>
<span class="lineNum">   12998 </span>            :     return 0;
<span class="lineNum">   12999 </span><span class="lineCov">   13950476 :   else if (tree_fits_uhwi_p (TYPE_SIZE (type)))</span>
<span class="lineNum">   13000 </span><span class="lineCov">   13950476 :     return tree_to_uhwi (TYPE_SIZE (type));</span>
<span class="lineNum">   13001 </span>            :   else
<span class="lineNum">   13002 </span><span class="lineNoCov">          0 :     return TYPE_ALIGN (type);</span>
<span class="lineNum">   13003 </span>            : }
<span class="lineNum">   13004 </span>            : 
<span class="lineNum">   13005 </span>            : /* Similarly, but return an offset_int instead of UHWI.  */
<a name="13006"><span class="lineNum">   13006 </span>            : </a>
<span class="lineNum">   13007 </span>            : static inline offset_int
<span class="lineNum">   13008 </span><span class="lineCov">    2310573 : offset_int_type_size_in_bits (const_tree type)</span>
<span class="lineNum">   13009 </span>            : {
<span class="lineNum">   13010 </span><span class="lineCov">    2310573 :   if (TREE_CODE (type) == ERROR_MARK)</span>
<span class="lineNum">   13011 </span><span class="lineNoCov">          0 :     return BITS_PER_WORD;</span>
<span class="lineNum">   13012 </span><span class="lineCov">    2310573 :   else if (TYPE_SIZE (type) == NULL_TREE)</span>
<span class="lineNum">   13013 </span><span class="lineCov">      86602 :     return 0;</span>
<span class="lineNum">   13014 </span><span class="lineCov">    4534544 :   else if (TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST)</span>
<span class="lineNum">   13015 </span><span class="lineCov">    4534440 :     return wi::to_offset (TYPE_SIZE (type));</span>
<span class="lineNum">   13016 </span>            :   else
<span class="lineNum">   13017 </span><span class="lineCov">        104 :     return TYPE_ALIGN (type);</span>
<span class="lineNum">   13018 </span>            : }
<span class="lineNum">   13019 </span>            : 
<span class="lineNum">   13020 </span>            : /*  Given a pointer to a tree node for a subrange type, return a pointer
<span class="lineNum">   13021 </span>            :     to a DIE that describes the given type.  */
<a name="13022"><span class="lineNum">   13022 </span>            : </a>
<span class="lineNum">   13023 </span>            : static dw_die_ref
<span class="lineNum">   13024 </span><span class="lineNoCov">          0 : subrange_type_die (tree type, tree low, tree high, tree bias,</span>
<span class="lineNum">   13025 </span>            :                    dw_die_ref context_die)
<span class="lineNum">   13026 </span>            : {
<span class="lineNum">   13027 </span><span class="lineNoCov">          0 :   dw_die_ref subrange_die;</span>
<span class="lineNum">   13028 </span><span class="lineNoCov">          0 :   const HOST_WIDE_INT size_in_bytes = int_size_in_bytes (type);</span>
<span class="lineNum">   13029 </span>            : 
<span class="lineNum">   13030 </span><span class="lineNoCov">          0 :   if (context_die == NULL)</span>
<span class="lineNum">   13031 </span><span class="lineNoCov">          0 :     context_die = comp_unit_die ();</span>
<span class="lineNum">   13032 </span>            : 
<span class="lineNum">   13033 </span><span class="lineNoCov">          0 :   subrange_die = new_die (DW_TAG_subrange_type, context_die, type);</span>
<span class="lineNum">   13034 </span>            : 
<span class="lineNum">   13035 </span><span class="lineNoCov">          0 :   if (int_size_in_bytes (TREE_TYPE (type)) != size_in_bytes)</span>
<span class="lineNum">   13036 </span>            :     {
<span class="lineNum">   13037 </span>            :       /* The size of the subrange type and its base type do not match,
<span class="lineNum">   13038 </span>            :          so we need to generate a size attribute for the subrange type.  */
<span class="lineNum">   13039 </span><span class="lineNoCov">          0 :       add_AT_unsigned (subrange_die, DW_AT_byte_size, size_in_bytes);</span>
<span class="lineNum">   13040 </span>            :     }
<span class="lineNum">   13041 </span>            : 
<span class="lineNum">   13042 </span><span class="lineNoCov">          0 :   add_alignment_attribute (subrange_die, type);</span>
<span class="lineNum">   13043 </span>            : 
<span class="lineNum">   13044 </span><span class="lineNoCov">          0 :   if (low)</span>
<span class="lineNum">   13045 </span><span class="lineNoCov">          0 :     add_bound_info (subrange_die, DW_AT_lower_bound, low, NULL);</span>
<span class="lineNum">   13046 </span><span class="lineNoCov">          0 :   if (high)</span>
<span class="lineNum">   13047 </span><span class="lineNoCov">          0 :     add_bound_info (subrange_die, DW_AT_upper_bound, high, NULL);</span>
<span class="lineNum">   13048 </span><span class="lineNoCov">          0 :   if (bias &amp;&amp; !dwarf_strict)</span>
<span class="lineNum">   13049 </span><span class="lineNoCov">          0 :     add_scalar_info (subrange_die, DW_AT_GNU_bias, bias,</span>
<span class="lineNum">   13050 </span>            :                      dw_scalar_form_constant
<span class="lineNum">   13051 </span>            :                      | dw_scalar_form_exprloc
<span class="lineNum">   13052 </span>            :                      | dw_scalar_form_reference,
<span class="lineNum">   13053 </span>            :                      NULL);
<span class="lineNum">   13054 </span>            : 
<span class="lineNum">   13055 </span><span class="lineNoCov">          0 :   return subrange_die;</span>
<span class="lineNum">   13056 </span>            : }
<span class="lineNum">   13057 </span>            : 
<span class="lineNum">   13058 </span>            : /* Returns the (const and/or volatile) cv_qualifiers associated with
<span class="lineNum">   13059 </span>            :    the decl node.  This will normally be augmented with the
<span class="lineNum">   13060 </span>            :    cv_qualifiers of the underlying type in add_type_attribute.  */
<a name="13061"><span class="lineNum">   13061 </span>            : </a>
<span class="lineNum">   13062 </span>            : static int
<span class="lineNum">   13063 </span><span class="lineCov">   14279353 : decl_quals (const_tree decl)</span>
<span class="lineNum">   13064 </span>            : {
<span class="lineNum">   13065 </span><span class="lineCov">   14279353 :   return ((TREE_READONLY (decl)</span>
<span class="lineNum">   13066 </span>            :            /* The C++ front-end correctly marks reference-typed
<span class="lineNum">   13067 </span>            :               variables as readonly, but from a language (and debug
<span class="lineNum">   13068 </span>            :               info) standpoint they are not const-qualified.  */
<span class="lineNum">   13069 </span><span class="lineCov">    1864228 :            &amp;&amp; TREE_CODE (TREE_TYPE (decl)) != REFERENCE_TYPE</span>
<span class="lineNum">   13070 </span><span class="lineCov">   14279353 :            ? TYPE_QUAL_CONST : TYPE_UNQUALIFIED)</span>
<span class="lineNum">   13071 </span>            :           | (TREE_THIS_VOLATILE (decl)
<span class="lineNum">   13072 </span><span class="lineCov">   14279353 :              ? TYPE_QUAL_VOLATILE : TYPE_UNQUALIFIED));</span>
<span class="lineNum">   13073 </span>            : }
<span class="lineNum">   13074 </span>            : 
<span class="lineNum">   13075 </span>            : /* Determine the TYPE whose qualifiers match the largest strict subset
<span class="lineNum">   13076 </span>            :    of the given TYPE_QUALS, and return its qualifiers.  Ignore all
<span class="lineNum">   13077 </span>            :    qualifiers outside QUAL_MASK.  */
<a name="13078"><span class="lineNum">   13078 </span>            : </a>
<span class="lineNum">   13079 </span>            : static int
<span class="lineNum">   13080 </span><span class="lineCov">    1009346 : get_nearest_type_subqualifiers (tree type, int type_quals, int qual_mask)</span>
<span class="lineNum">   13081 </span>            : {
<span class="lineNum">   13082 </span><span class="lineCov">    1009346 :   tree t;</span>
<span class="lineNum">   13083 </span><span class="lineCov">    1009346 :   int best_rank = 0, best_qual = 0, max_rank;</span>
<span class="lineNum">   13084 </span>            : 
<span class="lineNum">   13085 </span><span class="lineCov">    1009346 :   type_quals &amp;= qual_mask;</span>
<span class="lineNum">   13086 </span><span class="lineCov">    1009346 :   max_rank = popcount_hwi (type_quals) - 1;</span>
<span class="lineNum">   13087 </span>            : 
<span class="lineNum">   13088 </span><span class="lineCov">    1064622 :   for (t = TYPE_MAIN_VARIANT (type); t &amp;&amp; best_rank &lt; max_rank;</span>
<span class="lineNum">   13089 </span><span class="lineCov">      55276 :        t = TYPE_NEXT_VARIANT (t))</span>
<span class="lineNum">   13090 </span>            :     {
<span class="lineNum">   13091 </span><span class="lineCov">      55276 :       int q = TYPE_QUALS (t) &amp; qual_mask;</span>
<span class="lineNum">   13092 </span>            : 
<span class="lineNum">   13093 </span><span class="lineCov">      55267 :       if ((q &amp; type_quals) == q &amp;&amp; q != type_quals</span>
<span class="lineNum">   13094 </span><span class="lineCov">      99715 :           &amp;&amp; check_base_type (t, type))</span>
<span class="lineNum">   13095 </span>            :         {
<span class="lineNum">   13096 </span><span class="lineCov">      18309 :           int rank = popcount_hwi (q);</span>
<span class="lineNum">   13097 </span>            : 
<span class="lineNum">   13098 </span><span class="lineCov">      18309 :           if (rank &gt; best_rank)</span>
<span class="lineNum">   13099 </span>            :             {
<span class="lineNum">   13100 </span><span class="lineCov">       7299 :               best_rank = rank;</span>
<span class="lineNum">   13101 </span><span class="lineCov">       7299 :               best_qual = q;</span>
<span class="lineNum">   13102 </span>            :             }
<span class="lineNum">   13103 </span>            :         }
<span class="lineNum">   13104 </span>            :     }
<span class="lineNum">   13105 </span>            : 
<span class="lineNum">   13106 </span><span class="lineCov">    1009346 :   return best_qual;</span>
<span class="lineNum">   13107 </span>            : }
<span class="lineNum">   13108 </span>            : 
<span class="lineNum">   13109 </span>            : struct dwarf_qual_info_t { int q; enum dwarf_tag t; };
<span class="lineNum">   13110 </span>            : static const dwarf_qual_info_t dwarf_qual_info[] =
<span class="lineNum">   13111 </span>            : {
<span class="lineNum">   13112 </span>            :   { TYPE_QUAL_CONST, DW_TAG_const_type },
<span class="lineNum">   13113 </span>            :   { TYPE_QUAL_VOLATILE, DW_TAG_volatile_type },
<span class="lineNum">   13114 </span>            :   { TYPE_QUAL_RESTRICT, DW_TAG_restrict_type },
<span class="lineNum">   13115 </span>            :   { TYPE_QUAL_ATOMIC, DW_TAG_atomic_type }
<span class="lineNum">   13116 </span>            : };
<span class="lineNum">   13117 </span>            : static const unsigned int dwarf_qual_info_size
<span class="lineNum">   13118 </span>            :   = sizeof (dwarf_qual_info) / sizeof (dwarf_qual_info[0]);
<span class="lineNum">   13119 </span>            : 
<span class="lineNum">   13120 </span>            : /* If DIE is a qualified DIE of some base DIE with the same parent,
<span class="lineNum">   13121 </span>            :    return the base DIE, otherwise return NULL.  Set MASK to the
<span class="lineNum">   13122 </span>            :    qualifiers added compared to the returned DIE.  */
<a name="13123"><span class="lineNum">   13123 </span>            : </a>
<span class="lineNum">   13124 </span>            : static dw_die_ref
<span class="lineNum">   13125 </span><span class="lineCov">    1794059 : qualified_die_p (dw_die_ref die, int *mask, unsigned int depth)</span>
<span class="lineNum">   13126 </span>            : {
<span class="lineNum">   13127 </span><span class="lineCov">    1794059 :   unsigned int i;</span>
<span class="lineNum">   13128 </span><span class="lineCov">    8509953 :   for (i = 0; i &lt; dwarf_qual_info_size; i++)</span>
<span class="lineNum">   13129 </span><span class="lineCov">    6837472 :     if (die-&gt;die_tag == dwarf_qual_info[i].t)</span>
<span class="lineNum">   13130 </span>            :       break;
<span class="lineNum">   13131 </span><span class="lineCov">    1794059 :   if (i == dwarf_qual_info_size)</span>
<span class="lineNum">   13132 </span>            :     return NULL;
<span class="lineNum">   13133 </span><span class="lineCov">     121578 :   if (vec_safe_length (die-&gt;die_attr) != 1)</span>
<span class="lineNum">   13134 </span>            :     return NULL;
<span class="lineNum">   13135 </span><span class="lineCov">     120447 :   dw_die_ref type = get_AT_ref (die, DW_AT_type);</span>
<span class="lineNum">   13136 </span><span class="lineCov">     120447 :   if (type == NULL || type-&gt;die_parent != die-&gt;die_parent)</span>
<span class="lineNum">   13137 </span>            :     return NULL;
<span class="lineNum">   13138 </span><span class="lineCov">     120002 :   *mask |= dwarf_qual_info[i].q;</span>
<span class="lineNum">   13139 </span><span class="lineCov">     120002 :   if (depth)</span>
<span class="lineNum">   13140 </span>            :     {
<span class="lineNum">   13141 </span><span class="lineCov">     120002 :       dw_die_ref ret = qualified_die_p (type, mask, depth - 1);</span>
<span class="lineNum">   13142 </span><span class="lineCov">     120002 :       if (ret)</span>
<span class="lineNum">   13143 </span><span class="lineCov">        542 :         return ret;</span>
<span class="lineNum">   13144 </span>            :     }
<span class="lineNum">   13145 </span>            :   return type;
<span class="lineNum">   13146 </span>            : }
<span class="lineNum">   13147 </span>            : 
<span class="lineNum">   13148 </span>            : /* Given a pointer to an arbitrary ..._TYPE tree node, return a debugging
<span class="lineNum">   13149 </span>            :    entry that chains the modifiers specified by CV_QUALS in front of the
<span class="lineNum">   13150 </span>            :    given type.  REVERSE is true if the type is to be interpreted in the
<span class="lineNum">   13151 </span>            :    reverse storage order wrt the target order.  */
<a name="13152"><span class="lineNum">   13152 </span>            : </a>
<span class="lineNum">   13153 </span>            : static dw_die_ref
<span class="lineNum">   13154 </span><span class="lineCov">   57740699 : modified_type_die (tree type, int cv_quals, bool reverse,</span>
<span class="lineNum">   13155 </span>            :                    dw_die_ref context_die)
<span class="lineNum">   13156 </span>            : {
<span class="lineNum">   13157 </span><span class="lineCov">   57740699 :   enum tree_code code = TREE_CODE (type);</span>
<span class="lineNum">   13158 </span><span class="lineCov">   57740699 :   dw_die_ref mod_type_die;</span>
<span class="lineNum">   13159 </span><span class="lineCov">   57740699 :   dw_die_ref sub_die = NULL;</span>
<span class="lineNum">   13160 </span><span class="lineCov">   57740699 :   tree item_type = NULL;</span>
<span class="lineNum">   13161 </span><span class="lineCov">   57740699 :   tree qualified_type;</span>
<span class="lineNum">   13162 </span><span class="lineCov">   57740699 :   tree name, low, high;</span>
<span class="lineNum">   13163 </span><span class="lineCov">   57740699 :   dw_die_ref mod_scope;</span>
<span class="lineNum">   13164 </span>            :   /* Only these cv-qualifiers are currently handled.  */
<span class="lineNum">   13165 </span><span class="lineCov">   57740699 :   const int cv_qual_mask = (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE</span>
<span class="lineNum">   13166 </span>            :                             | TYPE_QUAL_RESTRICT | TYPE_QUAL_ATOMIC | 
<span class="lineNum">   13167 </span>            :                             ENCODE_QUAL_ADDR_SPACE(~0U));
<span class="lineNum">   13168 </span><span class="lineCov">   57740699 :   const bool reverse_base_type</span>
<span class="lineNum">   13169 </span><span class="lineCov">   57740879 :     = need_endianity_attribute_p (reverse) &amp;&amp; is_base_type (type);</span>
<span class="lineNum">   13170 </span>            : 
<span class="lineNum">   13171 </span><span class="lineCov">   57740699 :   if (code == ERROR_MARK)</span>
<span class="lineNum">   13172 </span>            :     return NULL;
<span class="lineNum">   13173 </span>            : 
<span class="lineNum">   13174 </span><span class="lineCov">   57740699 :   if (lang_hooks.types.get_debug_type)</span>
<span class="lineNum">   13175 </span>            :     {
<span class="lineNum">   13176 </span><span class="lineCov">   52766283 :       tree debug_type = lang_hooks.types.get_debug_type (type);</span>
<span class="lineNum">   13177 </span>            : 
<span class="lineNum">   13178 </span><span class="lineCov">   52766283 :       if (debug_type != NULL_TREE &amp;&amp; debug_type != type)</span>
<span class="lineNum">   13179 </span><span class="lineCov">     220861 :         return modified_type_die (debug_type, cv_quals, reverse, context_die);</span>
<span class="lineNum">   13180 </span>            :     }
<span class="lineNum">   13181 </span>            : 
<span class="lineNum">   13182 </span><span class="lineCov">   57519838 :   cv_quals &amp;= cv_qual_mask;</span>
<span class="lineNum">   13183 </span>            : 
<span class="lineNum">   13184 </span>            :   /* Don't emit DW_TAG_restrict_type for DWARFv2, since it is a type
<span class="lineNum">   13185 </span>            :      tag modifier (and not an attribute) old consumers won't be able
<span class="lineNum">   13186 </span>            :      to handle it.  */
<span class="lineNum">   13187 </span><span class="lineCov">   57519838 :   if (dwarf_version &lt; 3)</span>
<span class="lineNum">   13188 </span><span class="lineCov">      54335 :     cv_quals &amp;= ~TYPE_QUAL_RESTRICT;</span>
<span class="lineNum">   13189 </span>            : 
<span class="lineNum">   13190 </span>            :   /* Likewise for DW_TAG_atomic_type for DWARFv5.  */
<span class="lineNum">   13191 </span><span class="lineCov">   57519838 :   if (dwarf_version &lt; 5)</span>
<span class="lineNum">   13192 </span><span class="lineCov">   57519722 :     cv_quals &amp;= ~TYPE_QUAL_ATOMIC;</span>
<span class="lineNum">   13193 </span>            : 
<span class="lineNum">   13194 </span>            :   /* See if we already have the appropriately qualified variant of
<span class="lineNum">   13195 </span>            :      this type.  */
<span class="lineNum">   13196 </span><span class="lineCov">   57519838 :   qualified_type = get_qualified_type (type, cv_quals);</span>
<span class="lineNum">   13197 </span>            : 
<span class="lineNum">   13198 </span><span class="lineCov">   57519838 :   if (qualified_type == sizetype)</span>
<span class="lineNum">   13199 </span>            :     {
<span class="lineNum">   13200 </span>            :       /* Try not to expose the internal sizetype type's name.  */
<span class="lineNum">   13201 </span><span class="lineCov">     206810 :       if (TYPE_NAME (qualified_type)</span>
<span class="lineNum">   13202 </span><span class="lineCov">     206810 :           &amp;&amp; TREE_CODE (TYPE_NAME (qualified_type)) == TYPE_DECL)</span>
<span class="lineNum">   13203 </span>            :         {
<span class="lineNum">   13204 </span><span class="lineNoCov">          0 :           tree t = TREE_TYPE (TYPE_NAME (qualified_type));</span>
<span class="lineNum">   13205 </span>            : 
<span class="lineNum">   13206 </span><span class="lineNoCov">          0 :           gcc_checking_assert (TREE_CODE (t) == INTEGER_TYPE</span>
<span class="lineNum">   13207 </span>            :                                &amp;&amp; (TYPE_PRECISION (t)
<span class="lineNum">   13208 </span>            :                                    == TYPE_PRECISION (qualified_type))
<span class="lineNum">   13209 </span>            :                                &amp;&amp; (TYPE_UNSIGNED (t)
<span class="lineNum">   13210 </span>            :                                    == TYPE_UNSIGNED (qualified_type)));
<span class="lineNum">   13211 </span>            :           qualified_type = t;
<span class="lineNum">   13212 </span>            :         }
<span class="lineNum">   13213 </span><span class="lineCov">     206810 :       else if (qualified_type == sizetype</span>
<span class="lineNum">   13214 </span><span class="lineCov">     206810 :                &amp;&amp; TREE_CODE (sizetype) == TREE_CODE (size_type_node)</span>
<span class="lineNum">   13215 </span><span class="lineCov">     206810 :                &amp;&amp; TYPE_PRECISION (sizetype) == TYPE_PRECISION (size_type_node)</span>
<span class="lineNum">   13216 </span><span class="lineCov">     620430 :                &amp;&amp; TYPE_UNSIGNED (sizetype) == TYPE_UNSIGNED (size_type_node))</span>
<span class="lineNum">   13217 </span>            :         qualified_type = size_type_node;
<span class="lineNum">   13218 </span>            :     }
<span class="lineNum">   13219 </span>            : 
<span class="lineNum">   13220 </span>            :   /* If we do, then we can just use its DIE, if it exists.  */
<span class="lineNum">   13221 </span><span class="lineCov">   57519838 :   if (qualified_type)</span>
<span class="lineNum">   13222 </span>            :     {
<span class="lineNum">   13223 </span><span class="lineCov">   57469184 :       mod_type_die = lookup_type_die (qualified_type);</span>
<span class="lineNum">   13224 </span>            : 
<span class="lineNum">   13225 </span>            :       /* DW_AT_endianity doesn't come from a qualifier on the type, so it is
<span class="lineNum">   13226 </span>            :          dealt with specially: the DIE with the attribute, if it exists, is
<span class="lineNum">   13227 </span>            :          placed immediately after the regular DIE for the same base type.  */
<span class="lineNum">   13228 </span><span class="lineCov">   57469184 :       if (mod_type_die</span>
<span class="lineNum">   13229 </span><span class="lineCov">   57469184 :           &amp;&amp; (!reverse_base_type</span>
<span class="lineNum">   13230 </span><span class="lineCov">        139 :               || ((mod_type_die = mod_type_die-&gt;die_sib) != NULL</span>
<span class="lineNum">   13231 </span><span class="lineCov">        139 :                   &amp;&amp; get_AT_unsigned (mod_type_die, DW_AT_endianity))))</span>
<span class="lineNum">   13232 </span><span class="lineCov">   51801859 :         return mod_type_die;</span>
<span class="lineNum">   13233 </span>            :     }
<span class="lineNum">   13234 </span>            : 
<span class="lineNum">   13235 </span><span class="lineCov">    5717979 :   name = qualified_type ? TYPE_NAME (qualified_type) : NULL;</span>
<span class="lineNum">   13236 </span>            : 
<span class="lineNum">   13237 </span>            :   /* Handle C typedef types.  */
<span class="lineNum">   13238 </span><span class="lineCov">    5667325 :   if (name</span>
<span class="lineNum">   13239 </span><span class="lineCov">    2548796 :       &amp;&amp; TREE_CODE (name) == TYPE_DECL</span>
<span class="lineNum">   13240 </span><span class="lineCov">    5047542 :       &amp;&amp; DECL_ORIGINAL_TYPE (name)</span>
<span class="lineNum">   13241 </span><span class="lineCov">    6438807 :       &amp;&amp; !DECL_ARTIFICIAL (name))</span>
<span class="lineNum">   13242 </span>            :     {
<span class="lineNum">   13243 </span><span class="lineCov">     770962 :       tree dtype = TREE_TYPE (name);</span>
<span class="lineNum">   13244 </span>            : 
<span class="lineNum">   13245 </span>            :       /* Skip the typedef for base types with DW_AT_endianity, no big deal.  */
<span class="lineNum">   13246 </span><span class="lineCov">     770962 :       if (qualified_type == dtype &amp;&amp; !reverse_base_type)</span>
<span class="lineNum">   13247 </span>            :         {
<span class="lineNum">   13248 </span><span class="lineCov">     577408 :           tree origin = decl_ultimate_origin (name);</span>
<span class="lineNum">   13249 </span>            : 
<span class="lineNum">   13250 </span>            :           /* Typedef variants that have an abstract origin don't get their own
<span class="lineNum">   13251 </span>            :              type DIE (see gen_typedef_die), so fall back on the ultimate
<span class="lineNum">   13252 </span>            :              abstract origin instead.  */
<span class="lineNum">   13253 </span><span class="lineCov">     577408 :           if (origin != NULL &amp;&amp; origin != name)</span>
<span class="lineNum">   13254 </span><span class="lineNoCov">          0 :             return modified_type_die (TREE_TYPE (origin), cv_quals, reverse,</span>
<span class="lineNum">   13255 </span><span class="lineNoCov">          0 :                                       context_die);</span>
<span class="lineNum">   13256 </span>            : 
<span class="lineNum">   13257 </span>            :           /* For a named type, use the typedef.  */
<span class="lineNum">   13258 </span><span class="lineCov">     577408 :           gen_type_die (qualified_type, context_die);</span>
<span class="lineNum">   13259 </span><span class="lineCov">     577408 :           return lookup_type_die (qualified_type);</span>
<span class="lineNum">   13260 </span>            :         }
<span class="lineNum">   13261 </span>            :       else
<span class="lineNum">   13262 </span>            :         {
<span class="lineNum">   13263 </span><span class="lineCov">     193554 :           int dquals = TYPE_QUALS_NO_ADDR_SPACE (dtype);</span>
<span class="lineNum">   13264 </span><span class="lineCov">     193554 :           dquals &amp;= cv_qual_mask;</span>
<span class="lineNum">   13265 </span><span class="lineCov">     193554 :           if ((dquals &amp; ~cv_quals) != TYPE_UNQUALIFIED</span>
<span class="lineNum">   13266 </span><span class="lineCov">     193554 :               || (cv_quals == dquals &amp;&amp; DECL_ORIGINAL_TYPE (name) != type))</span>
<span class="lineNum">   13267 </span>            :             /* cv-unqualified version of named type.  Just use
<span class="lineNum">   13268 </span>            :                the unnamed type to which it refers.  */
<span class="lineNum">   13269 </span><span class="lineCov">      14382 :             return modified_type_die (DECL_ORIGINAL_TYPE (name), cv_quals,</span>
<span class="lineNum">   13270 </span><span class="lineCov">       7191 :                                       reverse, context_die);</span>
<span class="lineNum">   13271 </span>            :           /* Else cv-qualified version of named type; fall through.  */
<span class="lineNum">   13272 </span>            :         }
<span class="lineNum">   13273 </span>            :     }
<span class="lineNum">   13274 </span>            : 
<span class="lineNum">   13275 </span><span class="lineCov">    5133380 :   mod_scope = scope_die_for (type, context_die);</span>
<span class="lineNum">   13276 </span>            : 
<span class="lineNum">   13277 </span><span class="lineCov">    5133380 :   if (cv_quals)</span>
<span class="lineNum">   13278 </span>            :     {
<span class="lineNum">   13279 </span><span class="lineCov">    1009346 :       int sub_quals = 0, first_quals = 0;</span>
<span class="lineNum">   13280 </span><span class="lineCov">    1009346 :       unsigned i;</span>
<span class="lineNum">   13281 </span><span class="lineCov">    1009346 :       dw_die_ref first = NULL, last = NULL;</span>
<span class="lineNum">   13282 </span>            : 
<span class="lineNum">   13283 </span>            :       /* Determine a lesser qualified type that most closely matches
<span class="lineNum">   13284 </span>            :          this one.  Then generate DW_TAG_* entries for the remaining
<span class="lineNum">   13285 </span>            :          qualifiers.  */
<span class="lineNum">   13286 </span><span class="lineCov">    1009346 :       sub_quals = get_nearest_type_subqualifiers (type, cv_quals,</span>
<span class="lineNum">   13287 </span>            :                                                   cv_qual_mask);
<span class="lineNum">   13288 </span><span class="lineCov">    1009346 :       if (sub_quals &amp;&amp; use_debug_types)</span>
<span class="lineNum">   13289 </span>            :         {
<span class="lineNum">   13290 </span>            :           bool needed = false;
<span class="lineNum">   13291 </span>            :           /* If emitting type units, make sure the order of qualifiers
<span class="lineNum">   13292 </span>            :              is canonical.  Thus, start from unqualified type if
<span class="lineNum">   13293 </span>            :              an earlier qualifier is missing in sub_quals, but some later
<span class="lineNum">   13294 </span>            :              one is present there.  */
<span class="lineNum">   13295 </span><span class="lineNoCov">          0 :           for (i = 0; i &lt; dwarf_qual_info_size; i++)</span>
<span class="lineNum">   13296 </span><span class="lineNoCov">          0 :             if (dwarf_qual_info[i].q &amp; cv_quals &amp; ~sub_quals)</span>
<span class="lineNum">   13297 </span>            :               needed = true;
<span class="lineNum">   13298 </span><span class="lineNoCov">          0 :             else if (needed &amp;&amp; (dwarf_qual_info[i].q &amp; cv_quals))</span>
<span class="lineNum">   13299 </span>            :               {
<span class="lineNum">   13300 </span>            :                 sub_quals = 0;
<span class="lineNum">   13301 </span>            :                 break;
<span class="lineNum">   13302 </span>            :               }
<span class="lineNum">   13303 </span>            :         }
<span class="lineNum">   13304 </span><span class="lineCov">    1009346 :       mod_type_die = modified_type_die (type, sub_quals, reverse, context_die);</span>
<span class="lineNum">   13305 </span><span class="lineCov">    1009346 :       if (mod_scope &amp;&amp; mod_type_die &amp;&amp; mod_type_die-&gt;die_parent == mod_scope)</span>
<span class="lineNum">   13306 </span>            :         {
<span class="lineNum">   13307 </span>            :           /* As not all intermediate qualified DIEs have corresponding
<span class="lineNum">   13308 </span>            :              tree types, ensure that qualified DIEs in the same scope
<span class="lineNum">   13309 </span>            :              as their DW_AT_type are emitted after their DW_AT_type,
<span class="lineNum">   13310 </span>            :              only with other qualified DIEs for the same type possibly
<span class="lineNum">   13311 </span>            :              in between them.  Determine the range of such qualified
<span class="lineNum">   13312 </span>            :              DIEs now (first being the base type, last being corresponding
<span class="lineNum">   13313 </span>            :              last qualified DIE for it).  */
<span class="lineNum">   13314 </span><span class="lineCov">     997253 :           unsigned int count = 0;</span>
<span class="lineNum">   13315 </span><span class="lineCov">     997253 :           first = qualified_die_p (mod_type_die, &amp;first_quals,</span>
<span class="lineNum">   13316 </span>            :                                    dwarf_qual_info_size);
<span class="lineNum">   13317 </span><span class="lineCov">     997253 :           if (first == NULL)</span>
<span class="lineNum">   13318 </span><span class="lineCov">     990959 :             first = mod_type_die;</span>
<span class="lineNum">   13319 </span><span class="lineCov">     997253 :           gcc_assert ((first_quals &amp; ~sub_quals) == 0);</span>
<span class="lineNum">   13320 </span><span class="lineCov">     109658 :           for (count = 0, last = first;</span>
<span class="lineNum">   13321 </span><span class="lineCov">    1052082 :                count &lt; (1U &lt;&lt; dwarf_qual_info_size);</span>
<span class="lineNum">   13322 </span><span class="lineCov">      54829 :                count++, last = last-&gt;die_sib)</span>
<span class="lineNum">   13323 </span>            :             {
<span class="lineNum">   13324 </span><span class="lineCov">    1052082 :               int quals = 0;</span>
<span class="lineNum">   13325 </span><span class="lineCov">    1052082 :               if (last == mod_scope-&gt;die_child)</span>
<span class="lineNum">   13326 </span>            :                 break;
<span class="lineNum">   13327 </span><span class="lineCov">     618467 :               if (qualified_die_p (last-&gt;die_sib, &amp;quals, dwarf_qual_info_size)</span>
<span class="lineNum">   13328 </span>            :                   != first)
<span class="lineNum">   13329 </span>            :                 break;
<span class="lineNum">   13330 </span>            :             }
<span class="lineNum">   13331 </span>            :         }
<span class="lineNum">   13332 </span>            : 
<span class="lineNum">   13333 </span><span class="lineCov">    5046730 :       for (i = 0; i &lt; dwarf_qual_info_size; i++)</span>
<span class="lineNum">   13334 </span><span class="lineCov">    4037384 :         if (dwarf_qual_info[i].q &amp; cv_quals &amp; ~sub_quals)</span>
<span class="lineNum">   13335 </span>            :           {
<span class="lineNum">   13336 </span><span class="lineCov">    1013075 :             dw_die_ref d;</span>
<span class="lineNum">   13337 </span><span class="lineCov">    1013075 :             if (first &amp;&amp; first != last)</span>
<span class="lineNum">   13338 </span>            :               {
<span class="lineNum">   13339 </span><span class="lineCov">      52087 :                 for (d = first-&gt;die_sib; ; d = d-&gt;die_sib)</span>
<span class="lineNum">   13340 </span>            :                   {
<span class="lineNum">   13341 </span><span class="lineCov">      58337 :                     int quals = 0;</span>
<span class="lineNum">   13342 </span><span class="lineCov">      58337 :                     qualified_die_p (d, &amp;quals, dwarf_qual_info_size);</span>
<span class="lineNum">   13343 </span><span class="lineCov">      58337 :                     if (quals == (first_quals | dwarf_qual_info[i].q))</span>
<span class="lineNum">   13344 </span>            :                       break;
<span class="lineNum">   13345 </span><span class="lineCov">      31528 :                     if (d == last)</span>
<span class="lineNum">   13346 </span>            :                       {
<span class="lineNum">   13347 </span>            :                         d = NULL;
<span class="lineNum">   13348 </span>            :                         break;
<span class="lineNum">   13349 </span>            :                       }
<span class="lineNum">   13350 </span><span class="lineCov">       6250 :                   }</span>
<span class="lineNum">   13351 </span><span class="lineCov">      52087 :                 if (d)</span>
<span class="lineNum">   13352 </span>            :                   {
<span class="lineNum">   13353 </span>            :                     mod_type_die = d;
<span class="lineNum">   13354 </span>            :                     continue;
<span class="lineNum">   13355 </span>            :                   }
<span class="lineNum">   13356 </span>            :               }
<span class="lineNum">   13357 </span><span class="lineCov">     986266 :             if (first)</span>
<span class="lineNum">   13358 </span>            :               {
<span class="lineNum">   13359 </span><span class="lineCov">     974173 :                 d = new_die_raw (dwarf_qual_info[i].t);</span>
<span class="lineNum">   13360 </span><span class="lineCov">     974173 :                 add_child_die_after (mod_scope, d, last);</span>
<span class="lineNum">   13361 </span><span class="lineCov">     974173 :                 last = d;</span>
<span class="lineNum">   13362 </span>            :               }
<span class="lineNum">   13363 </span>            :             else
<span class="lineNum">   13364 </span><span class="lineCov">      12093 :               d = new_die (dwarf_qual_info[i].t, mod_scope, type);</span>
<span class="lineNum">   13365 </span><span class="lineCov">     986266 :             if (mod_type_die)</span>
<span class="lineNum">   13366 </span><span class="lineCov">     978486 :               add_AT_die_ref (d, DW_AT_type, mod_type_die);</span>
<span class="lineNum">   13367 </span><span class="lineCov">     986266 :             mod_type_die = d;</span>
<span class="lineNum">   13368 </span><span class="lineCov">     986266 :             first_quals |= dwarf_qual_info[i].q;</span>
<span class="lineNum">   13369 </span>            :           }
<span class="lineNum">   13370 </span>            :     }
<span class="lineNum">   13371 </span><span class="lineCov">    4124034 :   else if (code == POINTER_TYPE || code == REFERENCE_TYPE)</span>
<span class="lineNum">   13372 </span>            :     {
<span class="lineNum">   13373 </span><span class="lineCov">    2756472 :       dwarf_tag tag = DW_TAG_pointer_type;</span>
<span class="lineNum">   13374 </span><span class="lineCov">    2756472 :       if (code == REFERENCE_TYPE)</span>
<span class="lineNum">   13375 </span>            :         {
<span class="lineNum">   13376 </span><span class="lineCov">    1429438 :           if (TYPE_REF_IS_RVALUE (type) &amp;&amp; dwarf_version &gt;= 4)</span>
<span class="lineNum">   13377 </span>            :             tag = DW_TAG_rvalue_reference_type;
<span class="lineNum">   13378 </span>            :           else
<span class="lineNum">   13379 </span>            :             tag = DW_TAG_reference_type;
<span class="lineNum">   13380 </span>            :         }
<span class="lineNum">   13381 </span><span class="lineCov">    2756472 :       mod_type_die = new_die (tag, mod_scope, type);</span>
<span class="lineNum">   13382 </span>            : 
<span class="lineNum">   13383 </span><span class="lineCov">    2756472 :       add_AT_unsigned (mod_type_die, DW_AT_byte_size,</span>
<span class="lineNum">   13384 </span><span class="lineCov">    2756472 :                        simple_type_size_in_bits (type) / BITS_PER_UNIT);</span>
<span class="lineNum">   13385 </span><span class="lineCov">    2756472 :       add_alignment_attribute (mod_type_die, type);</span>
<span class="lineNum">   13386 </span><span class="lineCov">    2756472 :       item_type = TREE_TYPE (type);</span>
<span class="lineNum">   13387 </span>            : 
<span class="lineNum">   13388 </span><span class="lineCov">    2756472 :       addr_space_t as = TYPE_ADDR_SPACE (item_type);</span>
<span class="lineNum">   13389 </span><span class="lineCov">    2756472 :       if (!ADDR_SPACE_GENERIC_P (as))</span>
<span class="lineNum">   13390 </span>            :         {
<span class="lineNum">   13391 </span><span class="lineNoCov">          0 :           int action = targetm.addr_space.debug (as);</span>
<span class="lineNum">   13392 </span><span class="lineNoCov">          0 :           if (action &gt;= 0)</span>
<span class="lineNum">   13393 </span>            :             {
<span class="lineNum">   13394 </span>            :               /* Positive values indicate an address_class.  */
<span class="lineNum">   13395 </span><span class="lineNoCov">          0 :               add_AT_unsigned (mod_type_die, DW_AT_address_class, action);</span>
<span class="lineNum">   13396 </span>            :             }
<span class="lineNum">   13397 </span>            :           else
<span class="lineNum">   13398 </span>            :             {
<span class="lineNum">   13399 </span>            :               /* Negative values indicate an (inverted) segment base reg.  */
<span class="lineNum">   13400 </span><span class="lineNoCov">          0 :               dw_loc_descr_ref d</span>
<span class="lineNum">   13401 </span><span class="lineNoCov">          0 :                 = one_reg_loc_descriptor (~action, VAR_INIT_STATUS_INITIALIZED);</span>
<span class="lineNum">   13402 </span><span class="lineNoCov">          0 :               add_AT_loc (mod_type_die, DW_AT_segment, d);</span>
<span class="lineNum">   13403 </span>            :             }
<span class="lineNum">   13404 </span>            :         }
<span class="lineNum">   13405 </span>            :     }
<span class="lineNum">   13406 </span><span class="lineCov">    1367562 :   else if (code == INTEGER_TYPE</span>
<span class="lineNum">   13407 </span><span class="lineCov">     148504 :            &amp;&amp; TREE_TYPE (type) != NULL_TREE</span>
<span class="lineNum">   13408 </span><span class="lineCov">    1367562 :            &amp;&amp; subrange_type_for_debug_p (type, &amp;low, &amp;high))</span>
<span class="lineNum">   13409 </span>            :     {
<span class="lineNum">   13410 </span><span class="lineNoCov">          0 :       tree bias = NULL_TREE;</span>
<span class="lineNum">   13411 </span><span class="lineNoCov">          0 :       if (lang_hooks.types.get_type_bias)</span>
<span class="lineNum">   13412 </span><span class="lineNoCov">          0 :         bias = lang_hooks.types.get_type_bias (type);</span>
<span class="lineNum">   13413 </span><span class="lineNoCov">          0 :       mod_type_die = subrange_type_die (type, low, high, bias, context_die);</span>
<span class="lineNum">   13414 </span><span class="lineNoCov">          0 :       item_type = TREE_TYPE (type);</span>
<span class="lineNum">   13415 </span>            :     }
<span class="lineNum">   13416 </span><span class="lineCov">    1367562 :   else if (is_base_type (type))</span>
<span class="lineNum">   13417 </span>            :     {
<span class="lineNum">   13418 </span><span class="lineCov">     194488 :       mod_type_die = base_type_die (type, reverse);</span>
<span class="lineNum">   13419 </span>            : 
<span class="lineNum">   13420 </span>            :       /* The DIE with DW_AT_endianity is placed right after the naked DIE.  */
<span class="lineNum">   13421 </span><span class="lineCov">     194488 :       if (reverse_base_type)</span>
<span class="lineNum">   13422 </span>            :         {
<span class="lineNum">   13423 </span><span class="lineCov">         47 :           dw_die_ref after_die</span>
<span class="lineNum">   13424 </span><span class="lineCov">         47 :             = modified_type_die (type, cv_quals, false, context_die);</span>
<span class="lineNum">   13425 </span><span class="lineCov">         47 :           add_child_die_after (comp_unit_die (), mod_type_die, after_die);</span>
<span class="lineNum">   13426 </span>            :         }
<span class="lineNum">   13427 </span>            :       else
<span class="lineNum">   13428 </span><span class="lineCov">     194441 :         add_child_die (comp_unit_die (), mod_type_die);</span>
<span class="lineNum">   13429 </span>            : 
<span class="lineNum">   13430 </span><span class="lineCov">     194488 :       add_pubtype (type, mod_type_die);</span>
<span class="lineNum">   13431 </span>            :     }
<span class="lineNum">   13432 </span>            :   else
<span class="lineNum">   13433 </span>            :     {
<span class="lineNum">   13434 </span><span class="lineCov">    1173074 :       gen_type_die (type, context_die);</span>
<span class="lineNum">   13435 </span>            : 
<span class="lineNum">   13436 </span>            :       /* We have to get the type_main_variant here (and pass that to the
<span class="lineNum">   13437 </span>            :          `lookup_type_die' routine) because the ..._TYPE node we have
<span class="lineNum">   13438 </span>            :          might simply be a *copy* of some original type node (where the
<span class="lineNum">   13439 </span>            :          copy was created to help us keep track of typedef names) and
<span class="lineNum">   13440 </span>            :          that copy might have a different TYPE_UID from the original
<span class="lineNum">   13441 </span>            :          ..._TYPE node.  */
<span class="lineNum">   13442 </span><span class="lineCov">    2346148 :       if (TREE_CODE (type) == FUNCTION_TYPE</span>
<span class="lineNum">   13443 </span><span class="lineCov">    1173074 :           || TREE_CODE (type) == METHOD_TYPE)</span>
<span class="lineNum">   13444 </span>            :         {
<span class="lineNum">   13445 </span>            :           /* For function/method types, can't just use type_main_variant here,
<span class="lineNum">   13446 </span>            :              because that can have different ref-qualifiers for C++,
<span class="lineNum">   13447 </span>            :              but try to canonicalize.  */
<span class="lineNum">   13448 </span><span class="lineCov">      73404 :           tree main = TYPE_MAIN_VARIANT (type);</span>
<span class="lineNum">   13449 </span><span class="lineCov">      73538 :           for (tree t = main; t; t = TYPE_NEXT_VARIANT (t))</span>
<span class="lineNum">   13450 </span><span class="lineCov">      73535 :             if (TYPE_QUALS_NO_ADDR_SPACE (t) == 0</span>
<span class="lineNum">   13451 </span><span class="lineCov">      73486 :                 &amp;&amp; check_base_type (t, main)</span>
<span class="lineNum">   13452 </span><span class="lineCov">     147010 :                 &amp;&amp; check_lang_type (t, type))</span>
<span class="lineNum">   13453 </span><span class="lineCov">      73401 :               return lookup_type_die (t);</span>
<span class="lineNum">   13454 </span><span class="lineCov">          3 :           return lookup_type_die (type);</span>
<span class="lineNum">   13455 </span>            :         }
<span class="lineNum">   13456 </span><span class="lineCov">    2199340 :       else if (TREE_CODE (type) != VECTOR_TYPE</span>
<span class="lineNum">   13457 </span><span class="lineCov">    1099670 :                &amp;&amp; TREE_CODE (type) != ARRAY_TYPE)</span>
<span class="lineNum">   13458 </span><span class="lineCov">    1079379 :         return lookup_type_die (type_main_variant (type));</span>
<span class="lineNum">   13459 </span>            :       else
<span class="lineNum">   13460 </span>            :         /* Vectors have the debugging information in the type,
<span class="lineNum">   13461 </span>            :            not the main variant.  */
<span class="lineNum">   13462 </span><span class="lineCov">      20291 :         return lookup_type_die (type);</span>
<span class="lineNum">   13463 </span>            :     }
<span class="lineNum">   13464 </span>            : 
<span class="lineNum">   13465 </span>            :   /* Builtin types don't have a DECL_ORIGINAL_TYPE.  For those,
<span class="lineNum">   13466 </span>            :      don't output a DW_TAG_typedef, since there isn't one in the
<span class="lineNum">   13467 </span>            :      user's program; just attach a DW_AT_name to the type.
<span class="lineNum">   13468 </span>            :      Don't attach a DW_AT_name to DW_TAG_const_type or DW_TAG_volatile_type
<span class="lineNum">   13469 </span>            :      if the base type already has the same name.  */
<span class="lineNum">   13470 </span><span class="lineCov">    3960306 :   if (name</span>
<span class="lineNum">   13471 </span><span class="lineCov">    3960306 :       &amp;&amp; ((TREE_CODE (name) != TYPE_DECL</span>
<span class="lineNum">   13472 </span><span class="lineCov">       3386 :            &amp;&amp; (qualified_type == TYPE_MAIN_VARIANT (type)</span>
<span class="lineNum">   13473 </span><span class="lineCov">       3346 :                || (cv_quals == TYPE_UNQUALIFIED)))</span>
<span class="lineNum">   13474 </span><span class="lineCov">     935664 :           || (TREE_CODE (name) == TYPE_DECL</span>
<span class="lineNum">   13475 </span><span class="lineCov">     932318 :               &amp;&amp; TREE_TYPE (name) == qualified_type</span>
<span class="lineNum">   13476 </span><span class="lineCov">     198790 :               &amp;&amp; DECL_NAME (name))))</span>
<span class="lineNum">   13477 </span>            :     {
<span class="lineNum">   13478 </span><span class="lineCov">     198819 :       if (TREE_CODE (name) == TYPE_DECL)</span>
<span class="lineNum">   13479 </span>            :         /* Could just call add_name_and_src_coords_attributes here,
<span class="lineNum">   13480 </span>            :            but since this is a builtin type it doesn't have any
<span class="lineNum">   13481 </span>            :            useful source coordinates anyway.  */
<span class="lineNum">   13482 </span><span class="lineCov">     198779 :         name = DECL_NAME (name);</span>
<span class="lineNum">   13483 </span><span class="lineCov">     198819 :       add_name_attribute (mod_type_die, IDENTIFIER_POINTER (name));</span>
<span class="lineNum">   13484 </span>            :     }
<span class="lineNum">   13485 </span>            :   /* This probably indicates a bug.  */
<span class="lineNum">   13486 </span><span class="lineCov">    3761487 :   else if (mod_type_die &amp;&amp; mod_type_die-&gt;die_tag == DW_TAG_base_type)</span>
<span class="lineNum">   13487 </span>            :     {
<span class="lineNum">   13488 </span><span class="lineCov">       4221 :       name = TYPE_IDENTIFIER (type);</span>
<span class="lineNum">   13489 </span><span class="lineCov">       4303 :       add_name_attribute (mod_type_die,</span>
<span class="lineNum">   13490 </span><span class="lineCov">         82 :                           name ? IDENTIFIER_POINTER (name) : &quot;__unknown__&quot;);</span>
<span class="lineNum">   13491 </span>            :     }
<span class="lineNum">   13492 </span>            : 
<span class="lineNum">   13493 </span><span class="lineCov">    3960306 :   if (qualified_type &amp;&amp; !reverse_base_type)</span>
<span class="lineNum">   13494 </span><span class="lineCov">    3909628 :     equate_type_number_to_die (qualified_type, mod_type_die);</span>
<span class="lineNum">   13495 </span>            : 
<span class="lineNum">   13496 </span><span class="lineCov">    3960306 :   if (item_type)</span>
<span class="lineNum">   13497 </span>            :     /* We must do this after the equate_type_number_to_die call, in case
<span class="lineNum">   13498 </span>            :        this is a recursive type.  This ensures that the modified_type_die
<span class="lineNum">   13499 </span>            :        recursion will terminate even if the type is recursive.  Recursive
<span class="lineNum">   13500 </span>            :        types are possible in Ada.  */
<span class="lineNum">   13501 </span><span class="lineCov">    8269416 :     sub_die = modified_type_die (item_type,</span>
<span class="lineNum">   13502 </span><span class="lineCov">    2756472 :                                  TYPE_QUALS_NO_ADDR_SPACE (item_type),</span>
<span class="lineNum">   13503 </span>            :                                  reverse,
<span class="lineNum">   13504 </span>            :                                  context_die);
<span class="lineNum">   13505 </span>            : 
<span class="lineNum">   13506 </span><span class="lineCov">    2756472 :   if (sub_die != NULL)</span>
<span class="lineNum">   13507 </span><span class="lineCov">    2743221 :     add_AT_die_ref (mod_type_die, DW_AT_type, sub_die);</span>
<span class="lineNum">   13508 </span>            : 
<span class="lineNum">   13509 </span><span class="lineCov">    3960306 :   add_gnat_descriptive_type_attribute (mod_type_die, type, context_die);</span>
<span class="lineNum">   13510 </span><span class="lineCov">    3960306 :   if (TYPE_ARTIFICIAL (type))</span>
<span class="lineNum">   13511 </span><span class="lineCov">        495 :     add_AT_flag (mod_type_die, DW_AT_artificial, 1);</span>
<span class="lineNum">   13512 </span>            : 
<span class="lineNum">   13513 </span>            :   return mod_type_die;
<span class="lineNum">   13514 </span>            : }
<span class="lineNum">   13515 </span>            : 
<span class="lineNum">   13516 </span>            : /* Generate DIEs for the generic parameters of T.
<span class="lineNum">   13517 </span>            :    T must be either a generic type or a generic function.
<span class="lineNum">   13518 </span>            :    See http://gcc.gnu.org/wiki/TemplateParmsDwarf for more.  */
<a name="13519"><span class="lineNum">   13519 </span>            : </a>
<span class="lineNum">   13520 </span>            : static void
<span class="lineNum">   13521 </span><span class="lineCov">   29758963 : gen_generic_params_dies (tree t)</span>
<span class="lineNum">   13522 </span>            : {
<span class="lineNum">   13523 </span><span class="lineCov">   29758963 :   tree parms, args;</span>
<span class="lineNum">   13524 </span><span class="lineCov">   29758963 :   int parms_num, i;</span>
<span class="lineNum">   13525 </span><span class="lineCov">   29758963 :   dw_die_ref die = NULL;</span>
<span class="lineNum">   13526 </span><span class="lineCov">   29758963 :   int non_default;</span>
<span class="lineNum">   13527 </span>            : 
<span class="lineNum">   13528 </span><span class="lineCov">   29758963 :   if (!t || (TYPE_P (t) &amp;&amp; !COMPLETE_TYPE_P (t)))</span>
<span class="lineNum">   13529 </span>            :     return;
<span class="lineNum">   13530 </span>            : 
<span class="lineNum">   13531 </span><span class="lineCov">   29758963 :   if (TYPE_P (t))</span>
<span class="lineNum">   13532 </span><span class="lineCov">   22140167 :     die = lookup_type_die (t);</span>
<span class="lineNum">   13533 </span><span class="lineCov">    7618796 :   else if (DECL_P (t))</span>
<span class="lineNum">   13534 </span><span class="lineCov">    7618796 :     die = lookup_decl_die (t);</span>
<span class="lineNum">   13535 </span>            : 
<span class="lineNum">   13536 </span><span class="lineCov">   29758963 :   gcc_assert (die);</span>
<span class="lineNum">   13537 </span>            : 
<span class="lineNum">   13538 </span><span class="lineCov">   29758963 :   parms = lang_hooks.get_innermost_generic_parms (t);</span>
<span class="lineNum">   13539 </span><span class="lineCov">   29758963 :   if (!parms)</span>
<span class="lineNum">   13540 </span>            :     /* T has no generic parameter. It means T is neither a generic type
<span class="lineNum">   13541 </span>            :        or function. End of story.  */
<span class="lineNum">   13542 </span>            :     return;
<span class="lineNum">   13543 </span>            : 
<span class="lineNum">   13544 </span><span class="lineCov">   22624695 :   parms_num = TREE_VEC_LENGTH (parms);</span>
<span class="lineNum">   13545 </span><span class="lineCov">   22624695 :   args = lang_hooks.get_innermost_generic_args (t);</span>
<span class="lineNum">   13546 </span><span class="lineCov">   22624695 :   if (TREE_CHAIN (args) &amp;&amp; TREE_CODE (TREE_CHAIN (args)) == INTEGER_CST)</span>
<span class="lineNum">   13547 </span><span class="lineCov">   45249330 :     non_default = int_cst_value (TREE_CHAIN (args));</span>
<span class="lineNum">   13548 </span>            :   else
<span class="lineNum">   13549 </span><span class="lineCov">         30 :     non_default = TREE_VEC_LENGTH (args);</span>
<span class="lineNum">   13550 </span><span class="lineCov">   58823077 :   for (i = 0; i &lt; parms_num; i++)</span>
<span class="lineNum">   13551 </span>            :     {
<span class="lineNum">   13552 </span><span class="lineCov">   36198382 :       tree parm, arg, arg_pack_elems;</span>
<span class="lineNum">   13553 </span><span class="lineCov">   36198382 :       dw_die_ref parm_die;</span>
<span class="lineNum">   13554 </span>            : 
<span class="lineNum">   13555 </span><span class="lineCov">   36198382 :       parm = TREE_VEC_ELT (parms, i);</span>
<span class="lineNum">   13556 </span><span class="lineCov">   36198382 :       arg = TREE_VEC_ELT (args, i);</span>
<span class="lineNum">   13557 </span><span class="lineCov">   36198382 :       arg_pack_elems = lang_hooks.types.get_argument_pack_elems (arg);</span>
<span class="lineNum">   13558 </span><span class="lineCov">   36198382 :       gcc_assert (parm &amp;&amp; TREE_VALUE (parm) &amp;&amp; arg);</span>
<span class="lineNum">   13559 </span>            : 
<span class="lineNum">   13560 </span><span class="lineCov">   36198382 :       if (parm &amp;&amp; TREE_VALUE (parm) &amp;&amp; arg)</span>
<span class="lineNum">   13561 </span>            :         {
<span class="lineNum">   13562 </span>            :           /* If PARM represents a template parameter pack,
<span class="lineNum">   13563 </span>            :              emit a DW_TAG_GNU_template_parameter_pack DIE, followed
<span class="lineNum">   13564 </span>            :              by DW_TAG_template_*_parameter DIEs for the argument
<span class="lineNum">   13565 </span>            :              pack elements of ARG. Note that ARG would then be
<span class="lineNum">   13566 </span>            :              an argument pack.  */
<span class="lineNum">   13567 </span><span class="lineCov">   36198382 :           if (arg_pack_elems)</span>
<span class="lineNum">   13568 </span><span class="lineCov">    8064624 :             parm_die = template_parameter_pack_die (TREE_VALUE (parm),</span>
<span class="lineNum">   13569 </span>            :                                                     arg_pack_elems,
<span class="lineNum">   13570 </span>            :                                                     die);
<span class="lineNum">   13571 </span>            :           else
<span class="lineNum">   13572 </span><span class="lineCov">   64332140 :             parm_die = generic_parameter_die (TREE_VALUE (parm), arg,</span>
<span class="lineNum">   13573 </span>            :                                               true /* emit name */, die);
<span class="lineNum">   13574 </span><span class="lineCov">   36198382 :           if (i &gt;= non_default)</span>
<span class="lineNum">   13575 </span><span class="lineCov">     349554 :             add_AT_flag (parm_die, DW_AT_default_value, 1);</span>
<span class="lineNum">   13576 </span>            :         }
<span class="lineNum">   13577 </span>            :     }
<span class="lineNum">   13578 </span>            : }
<span class="lineNum">   13579 </span>            : 
<span class="lineNum">   13580 </span>            : /* Create and return a DIE for PARM which should be
<span class="lineNum">   13581 </span>            :    the representation of a generic type parameter.
<span class="lineNum">   13582 </span>            :    For instance, in the C++ front end, PARM would be a template parameter.
<span class="lineNum">   13583 </span>            :    ARG is the argument to PARM.
<span class="lineNum">   13584 </span>            :    EMIT_NAME_P if tree, the DIE will have DW_AT_name attribute set to the
<span class="lineNum">   13585 </span>            :    name of the PARM.
<span class="lineNum">   13586 </span>            :    PARENT_DIE is the parent DIE which the new created DIE should be added to,
<span class="lineNum">   13587 </span>            :    as a child node.  */
<a name="13588"><span class="lineNum">   13588 </span>            : </a>
<span class="lineNum">   13589 </span>            : static dw_die_ref
<span class="lineNum">   13590 </span><span class="lineCov">   40353930 : generic_parameter_die (tree parm, tree arg,</span>
<span class="lineNum">   13591 </span>            :                        bool emit_name_p,
<span class="lineNum">   13592 </span>            :                        dw_die_ref parent_die)
<span class="lineNum">   13593 </span>            : {
<span class="lineNum">   13594 </span><span class="lineCov">   40353930 :   dw_die_ref tmpl_die = NULL;</span>
<span class="lineNum">   13595 </span><span class="lineCov">   40353930 :   const char *name = NULL;</span>
<span class="lineNum">   13596 </span>            : 
<span class="lineNum">   13597 </span><span class="lineCov">   40353930 :   if (!parm || !DECL_NAME (parm) || !arg)</span>
<span class="lineNum">   13598 </span>            :     return NULL;
<span class="lineNum">   13599 </span>            : 
<span class="lineNum">   13600 </span>            :   /* We support non-type generic parameters and arguments,
<span class="lineNum">   13601 </span>            :      type generic parameters and arguments, as well as
<span class="lineNum">   13602 </span>            :      generic generic parameters (a.k.a. template template parameters in C++)
<span class="lineNum">   13603 </span>            :      and arguments.  */
<span class="lineNum">   13604 </span><span class="lineCov">   18058491 :   if (TREE_CODE (parm) == PARM_DECL)</span>
<span class="lineNum">   13605 </span>            :     /* PARM is a nontype generic parameter  */
<span class="lineNum">   13606 </span><span class="lineCov">    1744056 :     tmpl_die = new_die (DW_TAG_template_value_param, parent_die, parm);</span>
<span class="lineNum">   13607 </span><span class="lineCov">   16314435 :   else if (TREE_CODE (parm) == TYPE_DECL)</span>
<span class="lineNum">   13608 </span>            :     /* PARM is a type generic parameter.  */
<span class="lineNum">   13609 </span><span class="lineCov">   16298618 :     tmpl_die = new_die (DW_TAG_template_type_param, parent_die, parm);</span>
<span class="lineNum">   13610 </span><span class="lineCov">      15817 :   else if (lang_hooks.decls.generic_generic_parameter_decl_p (parm))</span>
<span class="lineNum">   13611 </span>            :     /* PARM is a generic generic parameter.
<span class="lineNum">   13612 </span>            :        Its DIE is a GNU extension. It shall have a
<span class="lineNum">   13613 </span>            :        DW_AT_name attribute to represent the name of the template template
<span class="lineNum">   13614 </span>            :        parameter, and a DW_AT_GNU_template_name attribute to represent the
<span class="lineNum">   13615 </span>            :        name of the template template argument.  */
<span class="lineNum">   13616 </span><span class="lineCov">      15817 :     tmpl_die = new_die (DW_TAG_GNU_template_template_param,</span>
<span class="lineNum">   13617 </span>            :                         parent_die, parm);
<span class="lineNum">   13618 </span>            :   else
<span class="lineNum">   13619 </span><span class="lineNoCov">          0 :     gcc_unreachable ();</span>
<span class="lineNum">   13620 </span>            : 
<span class="lineNum">   13621 </span><span class="lineCov">   18058491 :   if (tmpl_die)</span>
<span class="lineNum">   13622 </span>            :     {
<span class="lineNum">   13623 </span><span class="lineCov">   18058491 :       tree tmpl_type;</span>
<span class="lineNum">   13624 </span>            : 
<span class="lineNum">   13625 </span>            :       /* If PARM is a generic parameter pack, it means we are
<span class="lineNum">   13626 </span>            :          emitting debug info for a template argument pack element.
<span class="lineNum">   13627 </span>            :          In other terms, ARG is a template argument pack element.
<span class="lineNum">   13628 </span>            :          In that case, we don't emit any DW_AT_name attribute for
<span class="lineNum">   13629 </span>            :          the die.  */
<span class="lineNum">   13630 </span><span class="lineCov">   18058491 :       if (emit_name_p)</span>
<span class="lineNum">   13631 </span>            :         {
<span class="lineNum">   13632 </span><span class="lineCov">   16943275 :           name = IDENTIFIER_POINTER (DECL_NAME (parm));</span>
<span class="lineNum">   13633 </span><span class="lineCov">   16943275 :           gcc_assert (name);</span>
<span class="lineNum">   13634 </span><span class="lineCov">   16943275 :           add_AT_string (tmpl_die, DW_AT_name, name);</span>
<span class="lineNum">   13635 </span>            :         }
<span class="lineNum">   13636 </span>            : 
<span class="lineNum">   13637 </span><span class="lineCov">   18058491 :       if (!lang_hooks.decls.generic_generic_parameter_decl_p (parm))</span>
<span class="lineNum">   13638 </span>            :         {
<span class="lineNum">   13639 </span>            :           /* DWARF3, 5.6.8 says if PARM is a non-type generic parameter
<span class="lineNum">   13640 </span>            :              TMPL_DIE should have a child DW_AT_type attribute that is set
<span class="lineNum">   13641 </span>            :              to the type of the argument to PARM, which is ARG.
<span class="lineNum">   13642 </span>            :              If PARM is a type generic parameter, TMPL_DIE should have a
<span class="lineNum">   13643 </span>            :              child DW_AT_type that is set to ARG.  */
<span class="lineNum">   13644 </span><span class="lineCov">   18042674 :           tmpl_type = TYPE_P (arg) ? arg : TREE_TYPE (arg);</span>
<span class="lineNum">   13645 </span><span class="lineCov">   18042674 :           add_type_attribute (tmpl_die, tmpl_type,</span>
<span class="lineNum">   13646 </span>            :                               (TREE_THIS_VOLATILE (tmpl_type)
<span class="lineNum">   13647 </span><span class="lineCov">   18042674 :                                ? TYPE_QUAL_VOLATILE : TYPE_UNQUALIFIED),</span>
<span class="lineNum">   13648 </span>            :                               false, parent_die);
<span class="lineNum">   13649 </span>            :         }
<span class="lineNum">   13650 </span>            :       else
<span class="lineNum">   13651 </span>            :         {
<span class="lineNum">   13652 </span>            :           /* So TMPL_DIE is a DIE representing a
<span class="lineNum">   13653 </span>            :              a generic generic template parameter, a.k.a template template
<span class="lineNum">   13654 </span>            :              parameter in C++ and arg is a template.  */
<span class="lineNum">   13655 </span>            : 
<span class="lineNum">   13656 </span>            :           /* The DW_AT_GNU_template_name attribute of the DIE must be set
<span class="lineNum">   13657 </span>            :              to the name of the argument.  */
<span class="lineNum">   13658 </span><span class="lineCov">      15817 :           name = dwarf2_name (TYPE_P (arg) ? TYPE_NAME (arg) : arg, 1);</span>
<span class="lineNum">   13659 </span><span class="lineCov">      15817 :           if (name)</span>
<span class="lineNum">   13660 </span><span class="lineCov">      15817 :             add_AT_string (tmpl_die, DW_AT_GNU_template_name, name);</span>
<span class="lineNum">   13661 </span>            :         }
<span class="lineNum">   13662 </span>            : 
<span class="lineNum">   13663 </span><span class="lineCov">   18058491 :       if (TREE_CODE (parm) == PARM_DECL)</span>
<span class="lineNum">   13664 </span>            :         /* So PARM is a non-type generic parameter.
<span class="lineNum">   13665 </span>            :            DWARF3 5.6.8 says we must set a DW_AT_const_value child
<span class="lineNum">   13666 </span>            :            attribute of TMPL_DIE which value represents the value
<span class="lineNum">   13667 </span>            :            of ARG.
<span class="lineNum">   13668 </span>            :            We must be careful here:
<span class="lineNum">   13669 </span>            :            The value of ARG might reference some function decls.
<span class="lineNum">   13670 </span>            :            We might currently be emitting debug info for a generic
<span class="lineNum">   13671 </span>            :            type and types are emitted before function decls, we don't
<span class="lineNum">   13672 </span>            :            know if the function decls referenced by ARG will actually be
<span class="lineNum">   13673 </span>            :            emitted after cgraph computations.
<span class="lineNum">   13674 </span>            :            So must defer the generation of the DW_AT_const_value to
<span class="lineNum">   13675 </span>            :            after cgraph is ready.  */
<span class="lineNum">   13676 </span><span class="lineCov">    1744056 :         append_entry_to_tmpl_value_parm_die_table (tmpl_die, arg);</span>
<span class="lineNum">   13677 </span>            :     }
<span class="lineNum">   13678 </span>            : 
<span class="lineNum">   13679 </span>            :   return tmpl_die;
<span class="lineNum">   13680 </span>            : }
<span class="lineNum">   13681 </span>            : 
<span class="lineNum">   13682 </span>            : /* Generate and return a  DW_TAG_GNU_template_parameter_pack DIE representing.
<span class="lineNum">   13683 </span>            :    PARM_PACK must be a template parameter pack. The returned DIE
<span class="lineNum">   13684 </span>            :    will be child DIE of PARENT_DIE.  */
<a name="13685"><span class="lineNum">   13685 </span>            : </a>
<span class="lineNum">   13686 </span>            : static dw_die_ref
<span class="lineNum">   13687 </span><span class="lineCov">    4032312 : template_parameter_pack_die (tree parm_pack,</span>
<span class="lineNum">   13688 </span>            :                              tree parm_pack_args,
<span class="lineNum">   13689 </span>            :                              dw_die_ref parent_die)
<span class="lineNum">   13690 </span>            : {
<span class="lineNum">   13691 </span><span class="lineCov">    4032312 :   dw_die_ref die;</span>
<span class="lineNum">   13692 </span><span class="lineCov">    4032312 :   int j;</span>
<span class="lineNum">   13693 </span>            : 
<span class="lineNum">   13694 </span><span class="lineCov">    4032312 :   gcc_assert (parent_die &amp;&amp; parm_pack);</span>
<span class="lineNum">   13695 </span>            : 
<span class="lineNum">   13696 </span><span class="lineCov">    4032312 :   die = new_die (DW_TAG_GNU_template_parameter_pack, parent_die, parm_pack);</span>
<span class="lineNum">   13697 </span><span class="lineCov">    4032312 :   add_name_and_src_coords_attributes (die, parm_pack);</span>
<span class="lineNum">   13698 </span><span class="lineCov">   12220172 :   for (j = 0; j &lt; TREE_VEC_LENGTH (parm_pack_args); j++)</span>
<span class="lineNum">   13699 </span><span class="lineCov">    8187860 :     generic_parameter_die (parm_pack,</span>
<span class="lineNum">   13700 </span><span class="lineCov">    8187860 :                            TREE_VEC_ELT (parm_pack_args, j),</span>
<span class="lineNum">   13701 </span>            :                            false /* Don't emit DW_AT_name */,
<span class="lineNum">   13702 </span>            :                            die);
<span class="lineNum">   13703 </span><span class="lineCov">    4032312 :   return die;</span>
<span class="lineNum">   13704 </span>            : }
<span class="lineNum">   13705 </span>            : 
<span class="lineNum">   13706 </span>            : /* Given a pointer to an arbitrary ..._TYPE tree node, return true if it is
<span class="lineNum">   13707 </span>            :    an enumerated type.  */
<span class="lineNum">   13708 </span>            : 
<span class="lineNum">   13709 </span>            : static inline int
<span class="lineNum">   13710 </span>            : type_is_enum (const_tree type)
<span class="lineNum">   13711 </span>            : {
<span class="lineNum">   13712 </span>            :   return TREE_CODE (type) == ENUMERAL_TYPE;
<span class="lineNum">   13713 </span>            : }
<span class="lineNum">   13714 </span>            : 
<span class="lineNum">   13715 </span>            : /* Return the DBX register number described by a given RTL node.  */
<a name="13716"><span class="lineNum">   13716 </span>            : </a>
<span class="lineNum">   13717 </span>            : static unsigned int
<span class="lineNum">   13718 </span><span class="lineCov">    9247704 : dbx_reg_number (const_rtx rtl)</span>
<span class="lineNum">   13719 </span>            : {
<span class="lineNum">   13720 </span><span class="lineCov">    9247704 :   unsigned regno = REGNO (rtl);</span>
<span class="lineNum">   13721 </span>            : 
<span class="lineNum">   13722 </span><span class="lineCov">    9247704 :   gcc_assert (regno &lt; FIRST_PSEUDO_REGISTER);</span>
<span class="lineNum">   13723 </span>            : 
<span class="lineNum">   13724 </span>            : #ifdef LEAF_REG_REMAP
<span class="lineNum">   13725 </span>            :   if (crtl-&gt;uses_only_leaf_regs)
<span class="lineNum">   13726 </span>            :     {
<span class="lineNum">   13727 </span>            :       int leaf_reg = LEAF_REG_REMAP (regno);
<span class="lineNum">   13728 </span>            :       if (leaf_reg != -1)
<span class="lineNum">   13729 </span>            :         regno = (unsigned) leaf_reg;
<span class="lineNum">   13730 </span>            :     }
<span class="lineNum">   13731 </span>            : #endif
<span class="lineNum">   13732 </span>            : 
<span class="lineNum">   13733 </span><span class="lineCov">    9247704 :   regno = DBX_REGISTER_NUMBER (regno);</span>
<span class="lineNum">   13734 </span><span class="lineCov">    9247704 :   gcc_assert (regno != INVALID_REGNUM);</span>
<span class="lineNum">   13735 </span><span class="lineCov">    9247704 :   return regno;</span>
<span class="lineNum">   13736 </span>            : }
<span class="lineNum">   13737 </span>            : 
<span class="lineNum">   13738 </span>            : /* Optionally add a DW_OP_piece term to a location description expression.
<span class="lineNum">   13739 </span>            :    DW_OP_piece is only added if the location description expression already
<span class="lineNum">   13740 </span>            :    doesn't end with DW_OP_piece.  */
<a name="13741"><span class="lineNum">   13741 </span>            : </a>
<span class="lineNum">   13742 </span>            : static void
<span class="lineNum">   13743 </span><span class="lineCov">     290379 : add_loc_descr_op_piece (dw_loc_descr_ref *list_head, int size)</span>
<span class="lineNum">   13744 </span>            : {
<span class="lineNum">   13745 </span><span class="lineCov">     290379 :   dw_loc_descr_ref loc;</span>
<span class="lineNum">   13746 </span>            : 
<span class="lineNum">   13747 </span><span class="lineCov">     290379 :   if (*list_head != NULL)</span>
<span class="lineNum">   13748 </span>            :     {
<span class="lineNum">   13749 </span>            :       /* Find the end of the chain.  */
<span class="lineNum">   13750 </span><span class="lineCov">     586269 :       for (loc = *list_head; loc-&gt;dw_loc_next != NULL; loc = loc-&gt;dw_loc_next)</span>
<span class="lineNum">   13751 </span>            :         ;
<span class="lineNum">   13752 </span>            : 
<span class="lineNum">   13753 </span><span class="lineCov">     290379 :       if (loc-&gt;dw_loc_opc != DW_OP_piece)</span>
<span class="lineNum">   13754 </span><span class="lineCov">     290379 :         loc-&gt;dw_loc_next = new_loc_descr (DW_OP_piece, size, 0);</span>
<span class="lineNum">   13755 </span>            :     }
<span class="lineNum">   13756 </span><span class="lineCov">     290379 : }</span>
<span class="lineNum">   13757 </span>            : 
<span class="lineNum">   13758 </span>            : /* Return a location descriptor that designates a machine register or
<span class="lineNum">   13759 </span>            :    zero if there is none.  */
<a name="13760"><span class="lineNum">   13760 </span>            : </a>
<span class="lineNum">   13761 </span>            : static dw_loc_descr_ref
<span class="lineNum">   13762 </span><span class="lineCov">    8372332 : reg_loc_descriptor (rtx rtl, enum var_init_status initialized)</span>
<span class="lineNum">   13763 </span>            : {
<span class="lineNum">   13764 </span><span class="lineCov">    8372332 :   rtx regs;</span>
<span class="lineNum">   13765 </span>            : 
<span class="lineNum">   13766 </span><span class="lineCov">   16744664 :   if (REGNO (rtl) &gt;= FIRST_PSEUDO_REGISTER)</span>
<span class="lineNum">   13767 </span>            :     return 0;
<span class="lineNum">   13768 </span>            : 
<span class="lineNum">   13769 </span>            :   /* We only use &quot;frame base&quot; when we're sure we're talking about the
<span class="lineNum">   13770 </span>            :      post-prologue local stack frame.  We do this by *not* running
<span class="lineNum">   13771 </span>            :      register elimination until this point, and recognizing the special
<span class="lineNum">   13772 </span>            :      argument pointer and soft frame pointer rtx's.
<span class="lineNum">   13773 </span>            :      Use DW_OP_fbreg offset DW_OP_stack_value in this case.  */
<span class="lineNum">   13774 </span><span class="lineCov">    8351118 :   if ((rtl == arg_pointer_rtx || rtl == frame_pointer_rtx)</span>
<span class="lineNum">   13775 </span><span class="lineCov">    8352012 :       &amp;&amp; eliminate_regs (rtl, VOIDmode, NULL_RTX) != rtl)</span>
<span class="lineNum">   13776 </span>            :     {
<span class="lineNum">   13777 </span><span class="lineCov">        894 :       dw_loc_descr_ref result = NULL;</span>
<span class="lineNum">   13778 </span>            : 
<span class="lineNum">   13779 </span><span class="lineCov">        894 :       if (dwarf_version &gt;= 4 || !dwarf_strict)</span>
<span class="lineNum">   13780 </span>            :         {
<span class="lineNum">   13781 </span><span class="lineCov">        894 :           result = mem_loc_descriptor (rtl, GET_MODE (rtl), VOIDmode,</span>
<span class="lineNum">   13782 </span>            :                                        initialized);
<span class="lineNum">   13783 </span><span class="lineCov">        894 :           if (result)</span>
<span class="lineNum">   13784 </span><span class="lineCov">        894 :             add_loc_descr (&amp;result,</span>
<span class="lineNum">   13785 </span>            :                            new_loc_descr (DW_OP_stack_value, 0, 0));
<span class="lineNum">   13786 </span>            :         }
<span class="lineNum">   13787 </span><span class="lineCov">        894 :       return result;</span>
<span class="lineNum">   13788 </span>            :     }
<span class="lineNum">   13789 </span>            : 
<span class="lineNum">   13790 </span><span class="lineCov">    8351118 :   regs = targetm.dwarf_register_span (rtl);</span>
<span class="lineNum">   13791 </span>            : 
<span class="lineNum">   13792 </span><span class="lineCov">    8351118 :   if (REG_NREGS (rtl) &gt; 1 || regs)</span>
<span class="lineNum">   13793 </span><span class="lineCov">      49837 :     return multiple_reg_loc_descriptor (rtl, regs, initialized);</span>
<span class="lineNum">   13794 </span>            :   else
<span class="lineNum">   13795 </span>            :     {
<span class="lineNum">   13796 </span><span class="lineCov">    8301281 :       unsigned int dbx_regnum = dbx_reg_number (rtl);</span>
<span class="lineNum">   13797 </span><span class="lineCov">    8301281 :       if (dbx_regnum == IGNORED_DWARF_REGNUM)</span>
<span class="lineNum">   13798 </span>            :         return 0;
<span class="lineNum">   13799 </span><span class="lineCov">    8301281 :       return one_reg_loc_descriptor (dbx_regnum, initialized);</span>
<span class="lineNum">   13800 </span>            :     }
<span class="lineNum">   13801 </span>            : }
<span class="lineNum">   13802 </span>            : 
<span class="lineNum">   13803 </span>            : /* Return a location descriptor that designates a machine register for
<span class="lineNum">   13804 </span>            :    a given hard register number.  */
<a name="13805"><span class="lineNum">   13805 </span>            : </a>
<span class="lineNum">   13806 </span>            : static dw_loc_descr_ref
<span class="lineNum">   13807 </span><span class="lineCov">    9252525 : one_reg_loc_descriptor (unsigned int regno, enum var_init_status initialized)</span>
<span class="lineNum">   13808 </span>            : {
<span class="lineNum">   13809 </span><span class="lineCov">    9252525 :   dw_loc_descr_ref reg_loc_descr;</span>
<span class="lineNum">   13810 </span>            : 
<span class="lineNum">   13811 </span><span class="lineCov">    9252525 :   if (regno &lt;= 31)</span>
<span class="lineNum">   13812 </span><span class="lineCov">    9234516 :     reg_loc_descr</span>
<span class="lineNum">   13813 </span><span class="lineCov">    9234516 :       = new_loc_descr ((enum dwarf_location_atom) (DW_OP_reg0 + regno), 0, 0);</span>
<span class="lineNum">   13814 </span>            :   else
<span class="lineNum">   13815 </span><span class="lineCov">      18009 :     reg_loc_descr = new_loc_descr (DW_OP_regx, regno, 0);</span>
<span class="lineNum">   13816 </span>            : 
<span class="lineNum">   13817 </span><span class="lineCov">    9252525 :   if (initialized == VAR_INIT_STATUS_UNINITIALIZED)</span>
<span class="lineNum">   13818 </span><span class="lineNoCov">          0 :     add_loc_descr (&amp;reg_loc_descr, new_loc_descr (DW_OP_GNU_uninit, 0, 0));</span>
<span class="lineNum">   13819 </span>            : 
<span class="lineNum">   13820 </span><span class="lineCov">    9252525 :   return reg_loc_descr;</span>
<span class="lineNum">   13821 </span>            : }
<span class="lineNum">   13822 </span>            : 
<span class="lineNum">   13823 </span>            : /* Given an RTL of a register, return a location descriptor that
<span class="lineNum">   13824 </span>            :    designates a value that spans more than one register.  */
<a name="13825"><span class="lineNum">   13825 </span>            : </a>
<span class="lineNum">   13826 </span>            : static dw_loc_descr_ref
<span class="lineNum">   13827 </span><span class="lineCov">      49837 : multiple_reg_loc_descriptor (rtx rtl, rtx regs,</span>
<span class="lineNum">   13828 </span>            :                              enum var_init_status initialized)
<span class="lineNum">   13829 </span>            : {
<span class="lineNum">   13830 </span><span class="lineCov">      49837 :   int size, i;</span>
<span class="lineNum">   13831 </span><span class="lineCov">      49837 :   dw_loc_descr_ref loc_result = NULL;</span>
<span class="lineNum">   13832 </span>            : 
<span class="lineNum">   13833 </span>            :   /* Simple, contiguous registers.  */
<span class="lineNum">   13834 </span><span class="lineCov">      49837 :   if (regs == NULL_RTX)</span>
<span class="lineNum">   13835 </span>            :     {
<span class="lineNum">   13836 </span><span class="lineCov">      49837 :       unsigned reg = REGNO (rtl);</span>
<span class="lineNum">   13837 </span><span class="lineCov">      49837 :       int nregs;</span>
<span class="lineNum">   13838 </span>            : 
<span class="lineNum">   13839 </span>            : #ifdef LEAF_REG_REMAP
<span class="lineNum">   13840 </span>            :       if (crtl-&gt;uses_only_leaf_regs)
<span class="lineNum">   13841 </span>            :         {
<span class="lineNum">   13842 </span>            :           int leaf_reg = LEAF_REG_REMAP (reg);
<span class="lineNum">   13843 </span>            :           if (leaf_reg != -1)
<span class="lineNum">   13844 </span>            :             reg = (unsigned) leaf_reg;
<span class="lineNum">   13845 </span>            :         }
<span class="lineNum">   13846 </span>            : #endif
<span class="lineNum">   13847 </span>            : 
<span class="lineNum">   13848 </span><span class="lineCov">      49837 :       gcc_assert ((unsigned) DBX_REGISTER_NUMBER (reg) == dbx_reg_number (rtl));</span>
<span class="lineNum">   13849 </span><span class="lineCov">      49837 :       nregs = REG_NREGS (rtl);</span>
<span class="lineNum">   13850 </span>            : 
<span class="lineNum">   13851 </span>            :       /* At present we only track constant-sized pieces.  */
<span class="lineNum">   13852 </span><span class="lineCov">      99674 :       if (!GET_MODE_SIZE (GET_MODE (rtl)).is_constant (&amp;size))</span>
<span class="lineNum">   13853 </span>            :         return NULL;
<span class="lineNum">   13854 </span><span class="lineCov">      49837 :       size /= nregs;</span>
<span class="lineNum">   13855 </span>            : 
<span class="lineNum">   13856 </span><span class="lineCov">      49837 :       loc_result = NULL;</span>
<span class="lineNum">   13857 </span><span class="lineCov">     149511 :       while (nregs--)</span>
<span class="lineNum">   13858 </span>            :         {
<span class="lineNum">   13859 </span><span class="lineCov">      99674 :           dw_loc_descr_ref t;</span>
<span class="lineNum">   13860 </span>            : 
<span class="lineNum">   13861 </span><span class="lineCov">      99674 :           t = one_reg_loc_descriptor (DBX_REGISTER_NUMBER (reg),</span>
<span class="lineNum">   13862 </span>            :                                       VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   13863 </span><span class="lineCov">      99674 :           add_loc_descr (&amp;loc_result, t);</span>
<span class="lineNum">   13864 </span><span class="lineCov">      99674 :           add_loc_descr_op_piece (&amp;loc_result, size);</span>
<span class="lineNum">   13865 </span><span class="lineCov">      99674 :           ++reg;</span>
<span class="lineNum">   13866 </span>            :         }
<span class="lineNum">   13867 </span><span class="lineCov">      49837 :       return loc_result;</span>
<span class="lineNum">   13868 </span>            :     }
<span class="lineNum">   13869 </span>            : 
<span class="lineNum">   13870 </span>            :   /* Now onto stupid register sets in non contiguous locations.  */
<span class="lineNum">   13871 </span>            : 
<span class="lineNum">   13872 </span><span class="lineNoCov">          0 :   gcc_assert (GET_CODE (regs) == PARALLEL);</span>
<span class="lineNum">   13873 </span>            : 
<span class="lineNum">   13874 </span>            :   /* At present we only track constant-sized pieces.  */
<span class="lineNum">   13875 </span><span class="lineNoCov">          0 :   if (!GET_MODE_SIZE (GET_MODE (XVECEXP (regs, 0, 0))).is_constant (&amp;size))</span>
<span class="lineNum">   13876 </span>            :     return NULL;
<span class="lineNum">   13877 </span><span class="lineNoCov">          0 :   loc_result = NULL;</span>
<span class="lineNum">   13878 </span>            : 
<span class="lineNum">   13879 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; XVECLEN (regs, 0); ++i)</span>
<span class="lineNum">   13880 </span>            :     {
<span class="lineNum">   13881 </span><span class="lineNoCov">          0 :       dw_loc_descr_ref t;</span>
<span class="lineNum">   13882 </span>            : 
<span class="lineNum">   13883 </span><span class="lineNoCov">          0 :       t = one_reg_loc_descriptor (dbx_reg_number (XVECEXP (regs, 0, i)),</span>
<span class="lineNum">   13884 </span>            :                                   VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   13885 </span><span class="lineNoCov">          0 :       add_loc_descr (&amp;loc_result, t);</span>
<span class="lineNum">   13886 </span><span class="lineNoCov">          0 :       add_loc_descr_op_piece (&amp;loc_result, size);</span>
<span class="lineNum">   13887 </span>            :     }
<span class="lineNum">   13888 </span>            : 
<span class="lineNum">   13889 </span><span class="lineNoCov">          0 :   if (loc_result &amp;&amp; initialized == VAR_INIT_STATUS_UNINITIALIZED)</span>
<span class="lineNum">   13890 </span><span class="lineNoCov">          0 :     add_loc_descr (&amp;loc_result, new_loc_descr (DW_OP_GNU_uninit, 0, 0));</span>
<span class="lineNum">   13891 </span><span class="lineNoCov">          0 :   return loc_result;</span>
<span class="lineNum">   13892 </span>            : }
<span class="lineNum">   13893 </span>            : 
<span class="lineNum">   13894 </span>            : static unsigned long size_of_int_loc_descriptor (HOST_WIDE_INT);
<span class="lineNum">   13895 </span>            : 
<span class="lineNum">   13896 </span>            : /* Return a location descriptor that designates a constant i,
<span class="lineNum">   13897 </span>            :    as a compound operation from constant (i &gt;&gt; shift), constant shift
<span class="lineNum">   13898 </span>            :    and DW_OP_shl.  */
<a name="13899"><span class="lineNum">   13899 </span>            : </a>
<span class="lineNum">   13900 </span>            : static dw_loc_descr_ref
<span class="lineNum">   13901 </span><span class="lineCov">      30151 : int_shift_loc_descriptor (HOST_WIDE_INT i, int shift)</span>
<span class="lineNum">   13902 </span>            : {
<span class="lineNum">   13903 </span><span class="lineCov">      60302 :   dw_loc_descr_ref ret = int_loc_descriptor (i &gt;&gt; shift);</span>
<span class="lineNum">   13904 </span><span class="lineCov">      60302 :   add_loc_descr (&amp;ret, int_loc_descriptor (shift));</span>
<span class="lineNum">   13905 </span><span class="lineCov">      30151 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_shl, 0, 0));</span>
<span class="lineNum">   13906 </span><span class="lineCov">      30151 :   return ret;</span>
<span class="lineNum">   13907 </span>            : }
<span class="lineNum">   13908 </span>            : 
<span class="lineNum">   13909 </span>            : /* Return a location descriptor that designates constant POLY_I.  */
<a name="13910"><span class="lineNum">   13910 </span>            : </a>
<span class="lineNum">   13911 </span>            : static dw_loc_descr_ref
<span class="lineNum">   13912 </span><span class="lineCov">    2581088 : int_loc_descriptor (poly_int64 poly_i)</span>
<span class="lineNum">   13913 </span>            : {
<span class="lineNum">   13914 </span><span class="lineCov">    2581088 :   enum dwarf_location_atom op;</span>
<span class="lineNum">   13915 </span>            : 
<span class="lineNum">   13916 </span><span class="lineCov">    2581088 :   HOST_WIDE_INT i;</span>
<span class="lineNum">   13917 </span><span class="lineCov">    2581088 :   if (!poly_i.is_constant (&amp;i))</span>
<span class="lineNum">   13918 </span>            :     {
<span class="lineNum">   13919 </span>            :       /* Create location descriptions for the non-constant part and
<span class="lineNum">   13920 </span>            :          add any constant offset at the end.  */
<span class="lineNum">   13921 </span>            :       dw_loc_descr_ref ret = NULL;
<span class="lineNum">   13922 </span>            :       HOST_WIDE_INT constant = poly_i.coeffs[0];
<span class="lineNum">   13923 </span>            :       for (unsigned int j = 1; j &lt; NUM_POLY_INT_COEFFS; ++j)
<span class="lineNum">   13924 </span>            :         {
<span class="lineNum">   13925 </span>            :           HOST_WIDE_INT coeff = poly_i.coeffs[j];
<span class="lineNum">   13926 </span>            :           if (coeff != 0)
<span class="lineNum">   13927 </span>            :             {
<span class="lineNum">   13928 </span>            :               dw_loc_descr_ref start = ret;
<span class="lineNum">   13929 </span>            :               unsigned int factor;
<span class="lineNum">   13930 </span>            :               int bias;
<span class="lineNum">   13931 </span>            :               unsigned int regno = targetm.dwarf_poly_indeterminate_value
<span class="lineNum">   13932 </span>            :                 (j, &amp;factor, &amp;bias);
<span class="lineNum">   13933 </span>            : 
<span class="lineNum">   13934 </span>            :               /* Add COEFF * ((REGNO / FACTOR) - BIAS) to the value:
<span class="lineNum">   13935 </span>            :                  add COEFF * (REGNO / FACTOR) now and subtract
<span class="lineNum">   13936 </span>            :                  COEFF * BIAS from the final constant part.  */
<span class="lineNum">   13937 </span>            :               constant -= coeff * bias;
<span class="lineNum">   13938 </span>            :               add_loc_descr (&amp;ret, new_reg_loc_descr (regno, 0));
<span class="lineNum">   13939 </span>            :               if (coeff % factor == 0)
<span class="lineNum">   13940 </span>            :                 coeff /= factor;
<span class="lineNum">   13941 </span>            :               else
<span class="lineNum">   13942 </span>            :                 {
<span class="lineNum">   13943 </span>            :                   int amount = exact_log2 (factor);
<span class="lineNum">   13944 </span>            :                   gcc_assert (amount &gt;= 0);
<span class="lineNum">   13945 </span>            :                   add_loc_descr (&amp;ret, int_loc_descriptor (amount));
<span class="lineNum">   13946 </span>            :                   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_shr, 0, 0));
<span class="lineNum">   13947 </span>            :                 }
<span class="lineNum">   13948 </span>            :               if (coeff != 1)
<span class="lineNum">   13949 </span>            :                 {
<span class="lineNum">   13950 </span>            :                   add_loc_descr (&amp;ret, int_loc_descriptor (coeff));
<span class="lineNum">   13951 </span>            :                   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_mul, 0, 0));
<span class="lineNum">   13952 </span>            :                 }
<span class="lineNum">   13953 </span>            :               if (start)
<span class="lineNum">   13954 </span>            :                 add_loc_descr (&amp;ret, new_loc_descr (DW_OP_plus, 0, 0));
<span class="lineNum">   13955 </span>            :             }
<span class="lineNum">   13956 </span>            :         }
<span class="lineNum">   13957 </span>            :       loc_descr_plus_const (&amp;ret, constant);
<span class="lineNum">   13958 </span>            :       return ret;
<span class="lineNum">   13959 </span>            :     }
<span class="lineNum">   13960 </span>            : 
<span class="lineNum">   13961 </span>            :   /* Pick the smallest representation of a constant, rather than just
<span class="lineNum">   13962 </span>            :      defaulting to the LEB encoding.  */
<span class="lineNum">   13963 </span><span class="lineCov">    2581088 :   if (i &gt;= 0)</span>
<span class="lineNum">   13964 </span>            :     {
<span class="lineNum">   13965 </span><span class="lineCov">    2415220 :       int clz = clz_hwi (i);</span>
<span class="lineNum">   13966 </span><span class="lineCov">    2415220 :       int ctz = ctz_hwi (i);</span>
<span class="lineNum">   13967 </span><span class="lineCov">    2415220 :       if (i &lt;= 31)</span>
<span class="lineNum">   13968 </span><span class="lineCov">    1904477 :         op = (enum dwarf_location_atom) (DW_OP_lit0 + i);</span>
<span class="lineNum">   13969 </span><span class="lineCov">     510743 :       else if (i &lt;= 0xff)</span>
<span class="lineNum">   13970 </span>            :         op = DW_OP_const1u;
<span class="lineNum">   13971 </span><span class="lineCov">     190899 :       else if (i &lt;= 0xffff)</span>
<span class="lineNum">   13972 </span>            :         op = DW_OP_const2u;
<span class="lineNum">   13973 </span><span class="lineCov">     100499 :       else if (clz + ctz &gt;= HOST_BITS_PER_WIDE_INT - 5</span>
<span class="lineNum">   13974 </span>            :                &amp;&amp; clz + 5 + 255 &gt;= HOST_BITS_PER_WIDE_INT)
<span class="lineNum">   13975 </span>            :         /* DW_OP_litX DW_OP_litY DW_OP_shl takes just 3 bytes and
<span class="lineNum">   13976 </span>            :            DW_OP_litX DW_OP_const1u Y DW_OP_shl takes just 4 bytes,
<span class="lineNum">   13977 </span>            :            while DW_OP_const4u is 5 bytes.  */
<span class="lineNum">   13978 </span><span class="lineCov">      28715 :         return int_shift_loc_descriptor (i, HOST_BITS_PER_WIDE_INT - clz - 5);</span>
<span class="lineNum">   13979 </span><span class="lineCov">      71784 :       else if (clz + ctz &gt;= HOST_BITS_PER_WIDE_INT - 8</span>
<span class="lineNum">   13980 </span><span class="lineCov">        774 :                &amp;&amp; clz + 8 + 31 &gt;= HOST_BITS_PER_WIDE_INT)</span>
<span class="lineNum">   13981 </span>            :         /* DW_OP_const1u X DW_OP_litY DW_OP_shl takes just 4 bytes,
<span class="lineNum">   13982 </span>            :            while DW_OP_const4u is 5 bytes.  */
<span class="lineNum">   13983 </span><span class="lineCov">        541 :         return int_shift_loc_descriptor (i, HOST_BITS_PER_WIDE_INT - clz - 8);</span>
<span class="lineNum">   13984 </span>            : 
<span class="lineNum">   13985 </span><span class="lineCov">       5936 :       else if (DWARF2_ADDR_SIZE == 4 &amp;&amp; i &gt; 0x7fffffff</span>
<span class="lineNum">   13986 </span><span class="lineCov">      74696 :                &amp;&amp; size_of_int_loc_descriptor ((HOST_WIDE_INT) (int32_t) i)</span>
<span class="lineNum">   13987 </span>            :                   &lt;= 4)
<span class="lineNum">   13988 </span>            :         {
<span class="lineNum">   13989 </span>            :           /* As i &gt;= 2**31, the double cast above will yield a negative number.
<span class="lineNum">   13990 </span>            :              Since wrapping is defined in DWARF expressions we can output big
<span class="lineNum">   13991 </span>            :              positive integers as small negative ones, regardless of the size
<span class="lineNum">   13992 </span>            :              of host wide ints.
<span class="lineNum">   13993 </span>            : 
<span class="lineNum">   13994 </span>            :              Here, since the evaluator will handle 32-bit values and since i &gt;=
<span class="lineNum">   13995 </span>            :              2**31, we know it's going to be interpreted as a negative literal:
<span class="lineNum">   13996 </span>            :              store it this way if we can do better than 5 bytes this way.  */
<span class="lineNum">   13997 </span><span class="lineNoCov">          0 :           return int_loc_descriptor ((HOST_WIDE_INT) (int32_t) i);</span>
<span class="lineNum">   13998 </span>            :         }
<span class="lineNum">   13999 </span><span class="lineCov">      71243 :       else if (HOST_BITS_PER_WIDE_INT == 32 || i &lt;= 0xffffffff)</span>
<span class="lineNum">   14000 </span>            :         op = DW_OP_const4u;
<span class="lineNum">   14001 </span>            : 
<span class="lineNum">   14002 </span>            :       /* Past this point, i &gt;= 0x100000000 and thus DW_OP_constu will take at
<span class="lineNum">   14003 </span>            :          least 6 bytes: see if we can do better before falling back to it.  */
<span class="lineNum">   14004 </span><span class="lineCov">       6302 :       else if (clz + ctz &gt;= HOST_BITS_PER_WIDE_INT - 8</span>
<span class="lineNum">   14005 </span>            :                &amp;&amp; clz + 8 + 255 &gt;= HOST_BITS_PER_WIDE_INT)
<span class="lineNum">   14006 </span>            :         /* DW_OP_const1u X DW_OP_const1u Y DW_OP_shl takes just 5 bytes.  */
<span class="lineNum">   14007 </span><span class="lineCov">        233 :         return int_shift_loc_descriptor (i, HOST_BITS_PER_WIDE_INT - clz - 8);</span>
<span class="lineNum">   14008 </span><span class="lineCov">       6069 :       else if (clz + ctz &gt;= HOST_BITS_PER_WIDE_INT - 16</span>
<span class="lineNum">   14009 </span><span class="lineCov">       6069 :                &amp;&amp; clz + 16 + (size_of_uleb128 (i) &gt; 5 ? 255 : 31)</span>
<span class="lineNum">   14010 </span>            :                   &gt;= HOST_BITS_PER_WIDE_INT)
<span class="lineNum">   14011 </span>            :         /* DW_OP_const2u X DW_OP_litY DW_OP_shl takes just 5 bytes,
<span class="lineNum">   14012 </span>            :            DW_OP_const2u X DW_OP_const1u Y DW_OP_shl takes 6 bytes.  */
<span class="lineNum">   14013 </span><span class="lineCov">        533 :         return int_shift_loc_descriptor (i, HOST_BITS_PER_WIDE_INT - clz - 16);</span>
<span class="lineNum">   14014 </span><span class="lineCov">       5536 :       else if (clz + ctz &gt;= HOST_BITS_PER_WIDE_INT - 32</span>
<span class="lineNum">   14015 </span>            :                &amp;&amp; clz + 32 + 31 &gt;= HOST_BITS_PER_WIDE_INT
<span class="lineNum">   14016 </span><span class="lineCov">       5536 :                &amp;&amp; size_of_uleb128 (i) &gt; 6)</span>
<span class="lineNum">   14017 </span>            :         /* DW_OP_const4u X DW_OP_litY DW_OP_shl takes just 7 bytes.  */
<span class="lineNum">   14018 </span><span class="lineCov">        129 :         return int_shift_loc_descriptor (i, HOST_BITS_PER_WIDE_INT - clz - 32);</span>
<span class="lineNum">   14019 </span>            :       else
<span class="lineNum">   14020 </span>            :         op = DW_OP_constu;
<span class="lineNum">   14021 </span>            :     }
<span class="lineNum">   14022 </span>            :   else
<span class="lineNum">   14023 </span>            :     {
<span class="lineNum">   14024 </span><span class="lineCov">     165868 :       if (i &gt;= -0x80)</span>
<span class="lineNum">   14025 </span>            :         op = DW_OP_const1s;
<span class="lineNum">   14026 </span><span class="lineCov">      68130 :       else if (i &gt;= -0x8000)</span>
<span class="lineNum">   14027 </span>            :         op = DW_OP_const2s;
<span class="lineNum">   14028 </span><span class="lineCov">      38433 :       else if (HOST_BITS_PER_WIDE_INT == 32 || i &gt;= -0x80000000)</span>
<span class="lineNum">   14029 </span>            :         {
<span class="lineNum">   14030 </span>            :           if (size_of_int_loc_descriptor (i) &lt; 5)
<span class="lineNum">   14031 </span>            :             {
<span class="lineNum">   14032 </span>            :               dw_loc_descr_ref ret = int_loc_descriptor (-i);
<span class="lineNum">   14033 </span>            :               add_loc_descr (&amp;ret, new_loc_descr (DW_OP_neg, 0, 0));
<span class="lineNum">   14034 </span>            :               return ret;
<span class="lineNum">   14035 </span>            :             }
<span class="lineNum">   14036 </span>            :           op = DW_OP_const4s;
<span class="lineNum">   14037 </span>            :         }
<span class="lineNum">   14038 </span>            :       else
<span class="lineNum">   14039 </span>            :         {
<span class="lineNum">   14040 </span><span class="lineCov">      38433 :           if (size_of_int_loc_descriptor (i)</span>
<span class="lineNum">   14041 </span><span class="lineCov">      38433 :               &lt; (unsigned long) 1 + size_of_sleb128 (i))</span>
<span class="lineNum">   14042 </span>            :             {
<span class="lineNum">   14043 </span><span class="lineCov">      12252 :               dw_loc_descr_ref ret = int_loc_descriptor (-i);</span>
<span class="lineNum">   14044 </span><span class="lineCov">       6126 :               add_loc_descr (&amp;ret, new_loc_descr (DW_OP_neg, 0, 0));</span>
<span class="lineNum">   14045 </span><span class="lineCov">       6126 :               return ret;</span>
<span class="lineNum">   14046 </span>            :             }
<span class="lineNum">   14047 </span>            :           op = DW_OP_consts;
<span class="lineNum">   14048 </span>            :         }
<span class="lineNum">   14049 </span>            :     }
<span class="lineNum">   14050 </span>            : 
<span class="lineNum">   14051 </span><span class="lineCov">    2544811 :   return new_loc_descr (op, i, 0);</span>
<span class="lineNum">   14052 </span>            : }
<span class="lineNum">   14053 </span>            : 
<span class="lineNum">   14054 </span>            : /* Likewise, for unsigned constants.  */
<a name="14055"><span class="lineNum">   14055 </span>            : </a>
<span class="lineNum">   14056 </span>            : static dw_loc_descr_ref
<span class="lineNum">   14057 </span><span class="lineCov">      74507 : uint_loc_descriptor (unsigned HOST_WIDE_INT i)</span>
<span class="lineNum">   14058 </span>            : {
<span class="lineNum">   14059 </span><span class="lineCov">      74507 :   const unsigned HOST_WIDE_INT max_int = INTTYPE_MAXIMUM (HOST_WIDE_INT);</span>
<span class="lineNum">   14060 </span><span class="lineCov">      74507 :   const unsigned HOST_WIDE_INT max_uint</span>
<span class="lineNum">   14061 </span>            :     = INTTYPE_MAXIMUM (unsigned HOST_WIDE_INT);
<span class="lineNum">   14062 </span>            : 
<span class="lineNum">   14063 </span>            :   /* If possible, use the clever signed constants handling.  */
<span class="lineNum">   14064 </span><span class="lineCov">      74507 :   if (i &lt;= max_int)</span>
<span class="lineNum">   14065 </span><span class="lineCov">     149006 :     return int_loc_descriptor ((HOST_WIDE_INT) i);</span>
<span class="lineNum">   14066 </span>            : 
<span class="lineNum">   14067 </span>            :   /* Here, we are left with positive numbers that cannot be represented as
<span class="lineNum">   14068 </span>            :      HOST_WIDE_INT, i.e.:
<span class="lineNum">   14069 </span>            :          max (HOST_WIDE_INT) &lt; i &lt;= max (unsigned HOST_WIDE_INT)
<span class="lineNum">   14070 </span>            : 
<span class="lineNum">   14071 </span>            :      Using DW_OP_const4/8/./u operation to encode them consumes a lot of bytes
<span class="lineNum">   14072 </span>            :      whereas may be better to output a negative integer: thanks to integer
<span class="lineNum">   14073 </span>            :      wrapping, we know that:
<span class="lineNum">   14074 </span>            :          x = x - 2 ** DWARF2_ADDR_SIZE
<span class="lineNum">   14075 </span>            :            = x - 2 * (max (HOST_WIDE_INT) + 1)
<span class="lineNum">   14076 </span>            :      So numbers close to max (unsigned HOST_WIDE_INT) could be represented as
<span class="lineNum">   14077 </span>            :      small negative integers.  Let's try that in cases it will clearly improve
<span class="lineNum">   14078 </span>            :      the encoding: there is no gain turning DW_OP_const4u into
<span class="lineNum">   14079 </span>            :      DW_OP_const4s.  */
<span class="lineNum">   14080 </span><span class="lineCov">          4 :   if (DWARF2_ADDR_SIZE * 8 == HOST_BITS_PER_WIDE_INT</span>
<span class="lineNum">   14081 </span><span class="lineCov">          4 :       &amp;&amp; ((DWARF2_ADDR_SIZE == 4 &amp;&amp; i &gt; max_uint - 0x8000)</span>
<span class="lineNum">   14082 </span><span class="lineCov">          4 :           || (DWARF2_ADDR_SIZE == 8 &amp;&amp; i &gt; max_uint - 0x80000000)))</span>
<span class="lineNum">   14083 </span>            :     {
<span class="lineNum">   14084 </span><span class="lineNoCov">          0 :       const unsigned HOST_WIDE_INT first_shift = i - max_int - 1;</span>
<span class="lineNum">   14085 </span>            : 
<span class="lineNum">   14086 </span>            :       /* Now, -1 &lt;  first_shift &lt;= max (HOST_WIDE_INT)
<span class="lineNum">   14087 </span>            :          i.e.  0 &lt;= first_shift &lt;= max (HOST_WIDE_INT).  */
<span class="lineNum">   14088 </span><span class="lineNoCov">          0 :       const HOST_WIDE_INT second_shift</span>
<span class="lineNum">   14089 </span>            :         = (HOST_WIDE_INT) first_shift - (HOST_WIDE_INT) max_int - 1;
<span class="lineNum">   14090 </span>            : 
<span class="lineNum">   14091 </span>            :       /* So we finally have:
<span class="lineNum">   14092 </span>            :               -max (HOST_WIDE_INT) - 1 &lt;= second_shift &lt;= -1.
<span class="lineNum">   14093 </span>            :          i.e.  min (HOST_WIDE_INT)     &lt;= second_shift &lt;  0.  */
<span class="lineNum">   14094 </span><span class="lineNoCov">          0 :       return int_loc_descriptor (second_shift);</span>
<span class="lineNum">   14095 </span>            :     }
<span class="lineNum">   14096 </span>            : 
<span class="lineNum">   14097 </span>            :   /* Last chance: fallback to a simple constant operation.  */
<span class="lineNum">   14098 </span><span class="lineCov">          4 :   return new_loc_descr</span>
<span class="lineNum">   14099 </span><span class="lineCov">          4 :      ((HOST_BITS_PER_WIDE_INT == 32 || i &lt;= 0xffffffff)</span>
<span class="lineNum">   14100 </span>            :       ? DW_OP_const4u
<span class="lineNum">   14101 </span>            :       : DW_OP_const8u,
<span class="lineNum">   14102 </span><span class="lineCov">          4 :       i, 0);</span>
<span class="lineNum">   14103 </span>            : }
<span class="lineNum">   14104 </span>            : 
<span class="lineNum">   14105 </span>            : /* Generate and return a location description that computes the unsigned
<span class="lineNum">   14106 </span>            :    comparison of the two stack top entries (a OP b where b is the top-most
<span class="lineNum">   14107 </span>            :    entry and a is the second one).  The KIND of comparison can be LT_EXPR,
<span class="lineNum">   14108 </span>            :    LE_EXPR, GT_EXPR or GE_EXPR.  */
<a name="14109"><span class="lineNum">   14109 </span>            : </a>
<span class="lineNum">   14110 </span>            : static dw_loc_descr_ref
<span class="lineNum">   14111 </span><span class="lineNoCov">          0 : uint_comparison_loc_list (enum tree_code kind)</span>
<span class="lineNum">   14112 </span>            : {
<span class="lineNum">   14113 </span><span class="lineNoCov">          0 :   enum dwarf_location_atom op, flip_op;</span>
<span class="lineNum">   14114 </span><span class="lineNoCov">          0 :   dw_loc_descr_ref ret, bra_node, jmp_node, tmp;</span>
<span class="lineNum">   14115 </span>            : 
<span class="lineNum">   14116 </span><span class="lineNoCov">          0 :   switch (kind)</span>
<span class="lineNum">   14117 </span>            :     {
<span class="lineNum">   14118 </span>            :     case LT_EXPR:
<span class="lineNum">   14119 </span>            :       op = DW_OP_lt;
<span class="lineNum">   14120 </span>            :       break;
<span class="lineNum">   14121 </span>            :     case LE_EXPR:
<span class="lineNum">   14122 </span>            :       op = DW_OP_le;
<span class="lineNum">   14123 </span>            :       break;
<span class="lineNum">   14124 </span>            :     case GT_EXPR:
<span class="lineNum">   14125 </span>            :       op = DW_OP_gt;
<span class="lineNum">   14126 </span>            :       break;
<span class="lineNum">   14127 </span>            :     case GE_EXPR:
<span class="lineNum">   14128 </span>            :       op = DW_OP_ge;
<span class="lineNum">   14129 </span>            :       break;
<span class="lineNum">   14130 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">   14131 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">   14132 </span>            :     }
<span class="lineNum">   14133 </span>            : 
<span class="lineNum">   14134 </span><span class="lineNoCov">          0 :   bra_node = new_loc_descr (DW_OP_bra, 0, 0);</span>
<span class="lineNum">   14135 </span><span class="lineNoCov">          0 :   jmp_node = new_loc_descr (DW_OP_skip, 0, 0);</span>
<span class="lineNum">   14136 </span>            : 
<span class="lineNum">   14137 </span>            :   /* Until DWARFv4, operations all work on signed integers.  It is nevertheless
<span class="lineNum">   14138 </span>            :      possible to perform unsigned comparisons: we just have to distinguish
<span class="lineNum">   14139 </span>            :      three cases:
<span class="lineNum">   14140 </span>            : 
<span class="lineNum">   14141 </span>            :        1. when a and b have the same sign (as signed integers); then we should
<span class="lineNum">   14142 </span>            :           return: a OP(signed) b;
<span class="lineNum">   14143 </span>            : 
<span class="lineNum">   14144 </span>            :        2. when a is a negative signed integer while b is a positive one, then a
<span class="lineNum">   14145 </span>            :           is a greater unsigned integer than b; likewise when a and b's roles
<span class="lineNum">   14146 </span>            :           are flipped.
<span class="lineNum">   14147 </span>            : 
<span class="lineNum">   14148 </span>            :      So first, compare the sign of the two operands.  */
<span class="lineNum">   14149 </span><span class="lineNoCov">          0 :   ret = new_loc_descr (DW_OP_over, 0, 0);</span>
<span class="lineNum">   14150 </span><span class="lineNoCov">          0 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_over, 0, 0));</span>
<span class="lineNum">   14151 </span><span class="lineNoCov">          0 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_xor, 0, 0));</span>
<span class="lineNum">   14152 </span>            :   /* If they have different signs (i.e. they have different sign bits), then
<span class="lineNum">   14153 </span>            :      the stack top value has now the sign bit set and thus it's smaller than
<span class="lineNum">   14154 </span>            :      zero.  */
<span class="lineNum">   14155 </span><span class="lineNoCov">          0 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_lit0, 0, 0));</span>
<span class="lineNum">   14156 </span><span class="lineNoCov">          0 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_lt, 0, 0));</span>
<span class="lineNum">   14157 </span><span class="lineNoCov">          0 :   add_loc_descr (&amp;ret, bra_node);</span>
<span class="lineNum">   14158 </span>            : 
<span class="lineNum">   14159 </span>            :   /* We are in case 1.  At this point, we know both operands have the same
<span class="lineNum">   14160 </span>            :      sign, to it's safe to use the built-in signed comparison.  */
<span class="lineNum">   14161 </span><span class="lineNoCov">          0 :   add_loc_descr (&amp;ret, new_loc_descr (op, 0, 0));</span>
<span class="lineNum">   14162 </span><span class="lineNoCov">          0 :   add_loc_descr (&amp;ret, jmp_node);</span>
<span class="lineNum">   14163 </span>            : 
<span class="lineNum">   14164 </span>            :   /* We are in case 2.  Here, we know both operands do not have the same sign,
<span class="lineNum">   14165 </span>            :      so we have to flip the signed comparison.  */
<span class="lineNum">   14166 </span><span class="lineNoCov">          0 :   flip_op = (kind == LT_EXPR || kind == LE_EXPR) ? DW_OP_gt : DW_OP_lt;</span>
<span class="lineNum">   14167 </span><span class="lineNoCov">          0 :   tmp = new_loc_descr (flip_op, 0, 0);</span>
<span class="lineNum">   14168 </span><span class="lineNoCov">          0 :   bra_node-&gt;dw_loc_oprnd1.val_class = dw_val_class_loc;</span>
<span class="lineNum">   14169 </span><span class="lineNoCov">          0 :   bra_node-&gt;dw_loc_oprnd1.v.val_loc = tmp;</span>
<span class="lineNum">   14170 </span><span class="lineNoCov">          0 :   add_loc_descr (&amp;ret, tmp);</span>
<span class="lineNum">   14171 </span>            : 
<span class="lineNum">   14172 </span>            :   /* This dummy operation is necessary to make the two branches join.  */
<span class="lineNum">   14173 </span><span class="lineNoCov">          0 :   tmp = new_loc_descr (DW_OP_nop, 0, 0);</span>
<span class="lineNum">   14174 </span><span class="lineNoCov">          0 :   jmp_node-&gt;dw_loc_oprnd1.val_class = dw_val_class_loc;</span>
<span class="lineNum">   14175 </span><span class="lineNoCov">          0 :   jmp_node-&gt;dw_loc_oprnd1.v.val_loc = tmp;</span>
<span class="lineNum">   14176 </span><span class="lineNoCov">          0 :   add_loc_descr (&amp;ret, tmp);</span>
<span class="lineNum">   14177 </span>            : 
<span class="lineNum">   14178 </span><span class="lineNoCov">          0 :   return ret;</span>
<span class="lineNum">   14179 </span>            : }
<span class="lineNum">   14180 </span>            : 
<span class="lineNum">   14181 </span>            : /* Likewise, but takes the location description lists (might be destructive on
<span class="lineNum">   14182 </span>            :    them).  Return NULL if either is NULL or if concatenation fails.  */
<a name="14183"><span class="lineNum">   14183 </span>            : </a>
<span class="lineNum">   14184 </span>            : static dw_loc_list_ref
<span class="lineNum">   14185 </span><span class="lineNoCov">          0 : loc_list_from_uint_comparison (dw_loc_list_ref left, dw_loc_list_ref right,</span>
<span class="lineNum">   14186 </span>            :                                enum tree_code kind)
<span class="lineNum">   14187 </span>            : {
<span class="lineNum">   14188 </span><span class="lineNoCov">          0 :   if (left == NULL || right == NULL)</span>
<span class="lineNum">   14189 </span>            :     return NULL;
<span class="lineNum">   14190 </span>            : 
<span class="lineNum">   14191 </span><span class="lineNoCov">          0 :   add_loc_list (&amp;left, right);</span>
<span class="lineNum">   14192 </span><span class="lineNoCov">          0 :   if (left == NULL)</span>
<span class="lineNum">   14193 </span>            :     return NULL;
<span class="lineNum">   14194 </span>            : 
<span class="lineNum">   14195 </span><span class="lineNoCov">          0 :   add_loc_descr_to_each (left, uint_comparison_loc_list (kind));</span>
<span class="lineNum">   14196 </span><span class="lineNoCov">          0 :   return left;</span>
<span class="lineNum">   14197 </span>            : }
<span class="lineNum">   14198 </span>            : 
<span class="lineNum">   14199 </span>            : /* Return size_of_locs (int_shift_loc_descriptor (i, shift))
<span class="lineNum">   14200 </span>            :    without actually allocating it.  */
<a name="14201"><span class="lineNum">   14201 </span>            : </a>
<span class="lineNum">   14202 </span>            : static unsigned long
<span class="lineNum">   14203 </span><span class="lineCov">      28346 : size_of_int_shift_loc_descriptor (HOST_WIDE_INT i, int shift)</span>
<span class="lineNum">   14204 </span>            : {
<span class="lineNum">   14205 </span><span class="lineCov">      28346 :   return size_of_int_loc_descriptor (i &gt;&gt; shift)</span>
<span class="lineNum">   14206 </span><span class="lineCov">      28346 :          + size_of_int_loc_descriptor (shift)</span>
<span class="lineNum">   14207 </span><span class="lineCov">      28346 :          + 1;</span>
<span class="lineNum">   14208 </span>            : }
<span class="lineNum">   14209 </span>            : 
<span class="lineNum">   14210 </span>            : /* Return size_of_locs (int_loc_descriptor (i)) without
<span class="lineNum">   14211 </span>            :    actually allocating it.  */
<a name="14212"><span class="lineNum">   14212 </span>            : </a>
<span class="lineNum">   14213 </span>            : static unsigned long
<span class="lineNum">   14214 </span><span class="lineCov">    1967919 : size_of_int_loc_descriptor (HOST_WIDE_INT i)</span>
<span class="lineNum">   14215 </span>            : {
<span class="lineNum">   14216 </span><span class="lineCov">    1968174 :   unsigned long s;</span>
<span class="lineNum">   14217 </span>            : 
<span class="lineNum">   14218 </span><span class="lineCov">    1968174 :   if (i &gt;= 0)</span>
<span class="lineNum">   14219 </span>            :     {
<span class="lineNum">   14220 </span><span class="lineCov">    1857412 :       int clz, ctz;</span>
<span class="lineNum">   14221 </span><span class="lineCov">    1857412 :       if (i &lt;= 31)</span>
<span class="lineNum">   14222 </span>            :         return 1;
<span class="lineNum">   14223 </span><span class="lineCov">     307595 :       else if (i &lt;= 0xff)</span>
<span class="lineNum">   14224 </span>            :         return 2;
<span class="lineNum">   14225 </span><span class="lineCov">     133855 :       else if (i &lt;= 0xffff)</span>
<span class="lineNum">   14226 </span>            :         return 3;
<span class="lineNum">   14227 </span><span class="lineCov">      87829 :       clz = clz_hwi (i);</span>
<span class="lineNum">   14228 </span><span class="lineCov">      87829 :       ctz = ctz_hwi (i);</span>
<span class="lineNum">   14229 </span><span class="lineCov">      87829 :       if (clz + ctz &gt;= HOST_BITS_PER_WIDE_INT - 5</span>
<span class="lineNum">   14230 </span>            :           &amp;&amp; clz + 5 + 255 &gt;= HOST_BITS_PER_WIDE_INT)
<span class="lineNum">   14231 </span><span class="lineCov">      26964 :         return size_of_int_shift_loc_descriptor (i, HOST_BITS_PER_WIDE_INT</span>
<span class="lineNum">   14232 </span><span class="lineCov">      26964 :                                                     - clz - 5);</span>
<span class="lineNum">   14233 </span><span class="lineCov">      60865 :       else if (clz + ctz &gt;= HOST_BITS_PER_WIDE_INT - 8</span>
<span class="lineNum">   14234 </span><span class="lineCov">       1072 :                &amp;&amp; clz + 8 + 31 &gt;= HOST_BITS_PER_WIDE_INT)</span>
<span class="lineNum">   14235 </span><span class="lineCov">        456 :         return size_of_int_shift_loc_descriptor (i, HOST_BITS_PER_WIDE_INT</span>
<span class="lineNum">   14236 </span><span class="lineCov">        456 :                                                     - clz - 8);</span>
<span class="lineNum">   14237 </span><span class="lineCov">       9128 :       else if (DWARF2_ADDR_SIZE == 4 &amp;&amp; i &gt; 0x7fffffff</span>
<span class="lineNum">   14238 </span><span class="lineCov">      61379 :                &amp;&amp; size_of_int_loc_descriptor ((HOST_WIDE_INT) (int32_t) i)</span>
<span class="lineNum">   14239 </span>            :                   &lt;= 4)
<span class="lineNum">   14240 </span>            :         return size_of_int_loc_descriptor ((HOST_WIDE_INT) (int32_t) i);
<span class="lineNum">   14241 </span><span class="lineCov">      60154 :       else if (HOST_BITS_PER_WIDE_INT == 32 || i &lt;= 0xffffffff)</span>
<span class="lineNum">   14242 </span>            :         return 5;
<span class="lineNum">   14243 </span><span class="lineCov">      24133 :       s = size_of_uleb128 ((unsigned HOST_WIDE_INT) i);</span>
<span class="lineNum">   14244 </span><span class="lineCov">      24133 :       if (clz + ctz &gt;= HOST_BITS_PER_WIDE_INT - 8</span>
<span class="lineNum">   14245 </span>            :           &amp;&amp; clz + 8 + 255 &gt;= HOST_BITS_PER_WIDE_INT)
<span class="lineNum">   14246 </span><span class="lineCov">        613 :         return size_of_int_shift_loc_descriptor (i, HOST_BITS_PER_WIDE_INT</span>
<span class="lineNum">   14247 </span><span class="lineCov">        613 :                                                     - clz - 8);</span>
<span class="lineNum">   14248 </span><span class="lineCov">      23520 :       else if (clz + ctz &gt;= HOST_BITS_PER_WIDE_INT - 16</span>
<span class="lineNum">   14249 </span><span class="lineCov">        119 :                &amp;&amp; clz + 16 + (s &gt; 5 ? 255 : 31) &gt;= HOST_BITS_PER_WIDE_INT)</span>
<span class="lineNum">   14250 </span><span class="lineCov">        119 :         return size_of_int_shift_loc_descriptor (i, HOST_BITS_PER_WIDE_INT</span>
<span class="lineNum">   14251 </span><span class="lineCov">        119 :                                                     - clz - 16);</span>
<span class="lineNum">   14252 </span><span class="lineCov">      23401 :       else if (clz + ctz &gt;= HOST_BITS_PER_WIDE_INT - 32</span>
<span class="lineNum">   14253 </span>            :                &amp;&amp; clz + 32 + 31 &gt;= HOST_BITS_PER_WIDE_INT
<span class="lineNum">   14254 </span><span class="lineCov">        275 :                &amp;&amp; s &gt; 6)</span>
<span class="lineNum">   14255 </span><span class="lineCov">        194 :         return size_of_int_shift_loc_descriptor (i, HOST_BITS_PER_WIDE_INT</span>
<span class="lineNum">   14256 </span><span class="lineCov">        194 :                                                     - clz - 32);</span>
<span class="lineNum">   14257 </span>            :       else
<span class="lineNum">   14258 </span><span class="lineCov">      23207 :         return 1 + s;</span>
<span class="lineNum">   14259 </span>            :     }
<span class="lineNum">   14260 </span>            :   else
<span class="lineNum">   14261 </span>            :     {
<span class="lineNum">   14262 </span><span class="lineCov">     110762 :       if (i &gt;= -0x80)</span>
<span class="lineNum">   14263 </span>            :         return 2;
<span class="lineNum">   14264 </span><span class="lineCov">      61069 :       else if (i &gt;= -0x8000)</span>
<span class="lineNum">   14265 </span>            :         return 3;
<span class="lineNum">   14266 </span><span class="lineCov">      60286 :       else if (HOST_BITS_PER_WIDE_INT == 32 || i &gt;= -0x80000000)</span>
<span class="lineNum">   14267 </span>            :         {
<span class="lineNum">   14268 </span>            :           if (-(unsigned HOST_WIDE_INT) i != (unsigned HOST_WIDE_INT) i)
<span class="lineNum">   14269 </span>            :             {
<span class="lineNum">   14270 </span>            :               s = size_of_int_loc_descriptor (-i) + 1;
<span class="lineNum">   14271 </span>            :               if (s &lt; 5)
<span class="lineNum">   14272 </span>            :                 return s;
<span class="lineNum">   14273 </span>            :             }
<span class="lineNum">   14274 </span>            :           return 5;
<span class="lineNum">   14275 </span>            :         }
<span class="lineNum">   14276 </span>            :       else
<span class="lineNum">   14277 </span>            :         {
<span class="lineNum">   14278 </span><span class="lineCov">      60286 :           unsigned long r = 1 + size_of_sleb128 (i);</span>
<span class="lineNum">   14279 </span><span class="lineCov">      60286 :           if (-(unsigned HOST_WIDE_INT) i != (unsigned HOST_WIDE_INT) i)</span>
<span class="lineNum">   14280 </span>            :             {
<span class="lineNum">   14281 </span><span class="lineCov">      43435 :               s = size_of_int_loc_descriptor (-i) + 1;</span>
<span class="lineNum">   14282 </span><span class="lineCov">      43435 :               if (s &lt; r)</span>
<span class="lineNum">   14283 </span>            :                 return s;
<span class="lineNum">   14284 </span>            :             }
<span class="lineNum">   14285 </span><span class="lineCov">      52210 :           return r;</span>
<span class="lineNum">   14286 </span>            :         }
<span class="lineNum">   14287 </span>            :     }
<span class="lineNum">   14288 </span>            : }
<span class="lineNum">   14289 </span>            : 
<span class="lineNum">   14290 </span>            : /* Return loc description representing &quot;address&quot; of integer value.
<span class="lineNum">   14291 </span>            :    This can appear only as toplevel expression.  */
<a name="14292"><span class="lineNum">   14292 </span>            : </a>
<span class="lineNum">   14293 </span>            : static dw_loc_descr_ref
<span class="lineNum">   14294 </span><span class="lineCov">    1360564 : address_of_int_loc_descriptor (int size, HOST_WIDE_INT i)</span>
<span class="lineNum">   14295 </span>            : {
<span class="lineNum">   14296 </span><span class="lineCov">    1360564 :   int litsize;</span>
<span class="lineNum">   14297 </span><span class="lineCov">    1360564 :   dw_loc_descr_ref loc_result = NULL;</span>
<span class="lineNum">   14298 </span>            : 
<span class="lineNum">   14299 </span><span class="lineCov">    1360564 :   if (!(dwarf_version &gt;= 4 || !dwarf_strict))</span>
<span class="lineNum">   14300 </span>            :     return NULL;
<span class="lineNum">   14301 </span>            : 
<span class="lineNum">   14302 </span><span class="lineCov">    1360564 :   litsize = size_of_int_loc_descriptor (i);</span>
<span class="lineNum">   14303 </span>            :   /* Determine if DW_OP_stack_value or DW_OP_implicit_value
<span class="lineNum">   14304 </span>            :      is more compact.  For DW_OP_stack_value we need:
<span class="lineNum">   14305 </span>            :      litsize + 1 (DW_OP_stack_value)
<span class="lineNum">   14306 </span>            :      and for DW_OP_implicit_value:
<span class="lineNum">   14307 </span>            :      1 (DW_OP_implicit_value) + 1 (length) + size.  */
<span class="lineNum">   14308 </span><span class="lineCov">    1716137 :   if ((int) DWARF2_ADDR_SIZE &gt;= size &amp;&amp; litsize + 1 &lt;= 1 + 1 + size)</span>
<span class="lineNum">   14309 </span>            :     {
<span class="lineNum">   14310 </span><span class="lineCov">    2684554 :       loc_result = int_loc_descriptor (i);</span>
<span class="lineNum">   14311 </span><span class="lineCov">    1342277 :       add_loc_descr (&amp;loc_result,</span>
<span class="lineNum">   14312 </span>            :                      new_loc_descr (DW_OP_stack_value, 0, 0));
<span class="lineNum">   14313 </span><span class="lineCov">    1342277 :       return loc_result;</span>
<span class="lineNum">   14314 </span>            :     }
<span class="lineNum">   14315 </span>            : 
<span class="lineNum">   14316 </span><span class="lineCov">      18287 :   loc_result = new_loc_descr (DW_OP_implicit_value,</span>
<span class="lineNum">   14317 </span>            :                               size, 0);
<span class="lineNum">   14318 </span><span class="lineCov">      18287 :   loc_result-&gt;dw_loc_oprnd2.val_class = dw_val_class_const;</span>
<span class="lineNum">   14319 </span><span class="lineCov">      18287 :   loc_result-&gt;dw_loc_oprnd2.v.val_int = i;</span>
<span class="lineNum">   14320 </span><span class="lineCov">      18287 :   return loc_result;</span>
<span class="lineNum">   14321 </span>            : }
<span class="lineNum">   14322 </span>            : 
<span class="lineNum">   14323 </span>            : /* Return a location descriptor that designates a base+offset location.  */
<a name="14324"><span class="lineNum">   14324 </span>            : </a>
<span class="lineNum">   14325 </span>            : static dw_loc_descr_ref
<span class="lineNum">   14326 </span><span class="lineCov">    8594887 : based_loc_descr (rtx reg, poly_int64 offset,</span>
<span class="lineNum">   14327 </span>            :                  enum var_init_status initialized)
<span class="lineNum">   14328 </span>            : {
<span class="lineNum">   14329 </span><span class="lineCov">    8594887 :   unsigned int regno;</span>
<span class="lineNum">   14330 </span><span class="lineCov">    8594887 :   dw_loc_descr_ref result;</span>
<span class="lineNum">   14331 </span><span class="lineCov">    8594887 :   dw_fde_ref fde = cfun-&gt;fde;</span>
<span class="lineNum">   14332 </span>            : 
<span class="lineNum">   14333 </span>            :   /* We only use &quot;frame base&quot; when we're sure we're talking about the
<span class="lineNum">   14334 </span>            :      post-prologue local stack frame.  We do this by *not* running
<span class="lineNum">   14335 </span>            :      register elimination until this point, and recognizing the special
<span class="lineNum">   14336 </span>            :      argument pointer and soft frame pointer rtx's.  */
<span class="lineNum">   14337 </span><span class="lineCov">    8594887 :   if (reg == arg_pointer_rtx || reg == frame_pointer_rtx)</span>
<span class="lineNum">   14338 </span>            :     {
<span class="lineNum">   14339 </span><span class="lineCov">    4627673 :       rtx elim = (ira_use_lra_p</span>
<span class="lineNum">   14340 </span><span class="lineCov">    4627673 :                   ? lra_eliminate_regs (reg, VOIDmode, NULL_RTX)</span>
<span class="lineNum">   14341 </span><span class="lineNoCov">          0 :                   : eliminate_regs (reg, VOIDmode, NULL_RTX));</span>
<span class="lineNum">   14342 </span>            : 
<span class="lineNum">   14343 </span><span class="lineCov">    4627673 :       if (elim != reg)</span>
<span class="lineNum">   14344 </span>            :         {
<span class="lineNum">   14345 </span>            :           /* Allow hard frame pointer here even if frame pointer
<span class="lineNum">   14346 </span>            :             isn't used since hard frame pointer is encoded with
<span class="lineNum">   14347 </span>            :             DW_OP_fbreg which uses the DW_AT_frame_base attribute,
<span class="lineNum">   14348 </span>            :             not hard frame pointer directly.  */
<span class="lineNum">   14349 </span><span class="lineCov">    4627673 :           elim = strip_offset_and_add (elim, &amp;offset);</span>
<span class="lineNum">   14350 </span><span class="lineCov">    4627673 :           gcc_assert (elim == hard_frame_pointer_rtx</span>
<span class="lineNum">   14351 </span>            :                       || elim == stack_pointer_rtx);
<span class="lineNum">   14352 </span>            : 
<span class="lineNum">   14353 </span>            :           /* If drap register is used to align stack, use frame
<span class="lineNum">   14354 </span>            :              pointer + offset to access stack variables.  If stack
<span class="lineNum">   14355 </span>            :              is aligned without drap, use stack pointer + offset to
<span class="lineNum">   14356 </span>            :              access stack variables.  */
<span class="lineNum">   14357 </span><span class="lineCov">    4627673 :           if (crtl-&gt;stack_realign_tried</span>
<span class="lineNum">   14358 </span><span class="lineCov">      11037 :               &amp;&amp; reg == frame_pointer_rtx)</span>
<span class="lineNum">   14359 </span>            :             {
<span class="lineNum">   14360 </span><span class="lineCov">       3771 :               int base_reg</span>
<span class="lineNum">   14361 </span><span class="lineCov">       3771 :                 = DWARF_FRAME_REGNUM ((fde &amp;&amp; fde-&gt;drap_reg != INVALID_REGNUM)</span>
<span class="lineNum">   14362 </span>            :                                       ? HARD_FRAME_POINTER_REGNUM
<span class="lineNum">   14363 </span>            :                                       : REGNO (elim));
<span class="lineNum">   14364 </span><span class="lineCov">       3771 :               return new_reg_loc_descr (base_reg, offset);</span>
<span class="lineNum">   14365 </span>            :             }
<span class="lineNum">   14366 </span>            : 
<span class="lineNum">   14367 </span><span class="lineCov">    4623902 :           gcc_assert (frame_pointer_fb_offset_valid);</span>
<span class="lineNum">   14368 </span><span class="lineCov">    4623902 :           offset += frame_pointer_fb_offset;</span>
<span class="lineNum">   14369 </span><span class="lineCov">    4623902 :           HOST_WIDE_INT const_offset;</span>
<span class="lineNum">   14370 </span><span class="lineCov">    4623902 :           if (offset.is_constant (&amp;const_offset))</span>
<span class="lineNum">   14371 </span><span class="lineCov">    4623902 :             return new_loc_descr (DW_OP_fbreg, const_offset, 0);</span>
<span class="lineNum">   14372 </span>            :           else
<span class="lineNum">   14373 </span>            :             {
<span class="lineNum">   14374 </span>            :               dw_loc_descr_ref ret = new_loc_descr (DW_OP_fbreg, 0, 0);
<span class="lineNum">   14375 </span>            :               loc_descr_plus_const (&amp;ret, offset);
<span class="lineNum">   14376 </span>            :               return ret;
<span class="lineNum">   14377 </span>            :             }
<span class="lineNum">   14378 </span>            :         }
<span class="lineNum">   14379 </span>            :     }
<span class="lineNum">   14380 </span>            : 
<span class="lineNum">   14381 </span><span class="lineCov">    3967214 :   regno = REGNO (reg);</span>
<span class="lineNum">   14382 </span>            : #ifdef LEAF_REG_REMAP
<span class="lineNum">   14383 </span>            :   if (crtl-&gt;uses_only_leaf_regs)
<span class="lineNum">   14384 </span>            :     {
<span class="lineNum">   14385 </span>            :       int leaf_reg = LEAF_REG_REMAP (regno);
<span class="lineNum">   14386 </span>            :       if (leaf_reg != -1)
<span class="lineNum">   14387 </span>            :         regno = (unsigned) leaf_reg;
<span class="lineNum">   14388 </span>            :     }
<span class="lineNum">   14389 </span>            : #endif
<span class="lineNum">   14390 </span><span class="lineCov">    3967214 :   regno = DWARF_FRAME_REGNUM (regno);</span>
<span class="lineNum">   14391 </span>            : 
<span class="lineNum">   14392 </span><span class="lineCov">    3967214 :   HOST_WIDE_INT const_offset;</span>
<span class="lineNum">   14393 </span><span class="lineCov">      16110 :   if (!optimize &amp;&amp; fde</span>
<span class="lineNum">   14394 </span><span class="lineCov">      16110 :       &amp;&amp; (fde-&gt;drap_reg == regno || fde-&gt;vdrap_reg == regno)</span>
<span class="lineNum">   14395 </span><span class="lineCov">    3970296 :       &amp;&amp; offset.is_constant (&amp;const_offset))</span>
<span class="lineNum">   14396 </span>            :     {
<span class="lineNum">   14397 </span>            :       /* Use cfa+offset to represent the location of arguments passed
<span class="lineNum">   14398 </span>            :          on the stack when drap is used to align stack.
<span class="lineNum">   14399 </span>            :          Only do this when not optimizing, for optimized code var-tracking
<span class="lineNum">   14400 </span>            :          is supposed to track where the arguments live and the register
<span class="lineNum">   14401 </span>            :          used as vdrap or drap in some spot might be used for something
<span class="lineNum">   14402 </span>            :          else in other part of the routine.  */
<span class="lineNum">   14403 </span><span class="lineCov">       3082 :       return new_loc_descr (DW_OP_fbreg, const_offset, 0);</span>
<span class="lineNum">   14404 </span>            :     }
<span class="lineNum">   14405 </span>            : 
<span class="lineNum">   14406 </span><span class="lineCov">    3964132 :   result = new_reg_loc_descr (regno, offset);</span>
<span class="lineNum">   14407 </span>            : 
<span class="lineNum">   14408 </span><span class="lineCov">    3964132 :   if (initialized == VAR_INIT_STATUS_UNINITIALIZED)</span>
<span class="lineNum">   14409 </span><span class="lineNoCov">          0 :     add_loc_descr (&amp;result, new_loc_descr (DW_OP_GNU_uninit, 0, 0));</span>
<span class="lineNum">   14410 </span>            : 
<span class="lineNum">   14411 </span><span class="lineCov">    3964132 :   return result;</span>
<span class="lineNum">   14412 </span>            : }
<span class="lineNum">   14413 </span>            : 
<span class="lineNum">   14414 </span>            : /* Return true if this RTL expression describes a base+offset calculation.  */
<a name="14415"><span class="lineNum">   14415 </span>            : </a>
<span class="lineNum">   14416 </span>            : static inline int
<span class="lineNum">   14417 </span><span class="lineCov">    7609347 : is_based_loc (const_rtx rtl)</span>
<span class="lineNum">   14418 </span>            : {
<span class="lineNum">   14419 </span><span class="lineCov">    7609347 :   return (GET_CODE (rtl) == PLUS</span>
<span class="lineNum">   14420 </span><span class="lineCov">    7609347 :           &amp;&amp; ((REG_P (XEXP (rtl, 0))</span>
<span class="lineNum">   14421 </span><span class="lineCov">   13919766 :                &amp;&amp; REGNO (XEXP (rtl, 0)) &lt; FIRST_PSEUDO_REGISTER</span>
<span class="lineNum">   14422 </span><span class="lineCov">    6958681 :                &amp;&amp; CONST_INT_P (XEXP (rtl, 1)))));</span>
<span class="lineNum">   14423 </span>            : }
<span class="lineNum">   14424 </span>            : 
<span class="lineNum">   14425 </span>            : /* Try to handle TLS MEMs, for which mem_loc_descriptor on XEXP (mem, 0)
<span class="lineNum">   14426 </span>            :    failed.  */
<a name="14427"><span class="lineNum">   14427 </span>            : </a>
<span class="lineNum">   14428 </span>            : static dw_loc_descr_ref
<span class="lineNum">   14429 </span><span class="lineCov">      23820 : tls_mem_loc_descriptor (rtx mem)</span>
<span class="lineNum">   14430 </span>            : {
<span class="lineNum">   14431 </span><span class="lineCov">      23820 :   tree base;</span>
<span class="lineNum">   14432 </span><span class="lineCov">      23820 :   dw_loc_descr_ref loc_result;</span>
<span class="lineNum">   14433 </span>            : 
<span class="lineNum">   14434 </span><span class="lineCov">      23820 :   if (MEM_EXPR (mem) == NULL_TREE || !MEM_OFFSET_KNOWN_P (mem))</span>
<span class="lineNum">   14435 </span>            :     return NULL;
<span class="lineNum">   14436 </span>            : 
<span class="lineNum">   14437 </span><span class="lineCov">      39862 :   base = get_base_address (MEM_EXPR (mem));</span>
<span class="lineNum">   14438 </span><span class="lineCov">      19931 :   if (base == NULL</span>
<span class="lineNum">   14439 </span><span class="lineCov">      19931 :       || !VAR_P (base)</span>
<span class="lineNum">   14440 </span><span class="lineCov">      32066 :       || !DECL_THREAD_LOCAL_P (base))</span>
<span class="lineNum">   14441 </span><span class="lineCov">      19931 :     return NULL;</span>
<span class="lineNum">   14442 </span>            : 
<span class="lineNum">   14443 </span><span class="lineNoCov">          0 :   loc_result = loc_descriptor_from_tree (MEM_EXPR (mem), 1, NULL);</span>
<span class="lineNum">   14444 </span><span class="lineNoCov">          0 :   if (loc_result == NULL)</span>
<span class="lineNum">   14445 </span>            :     return NULL;
<span class="lineNum">   14446 </span>            : 
<span class="lineNum">   14447 </span><span class="lineNoCov">          0 :   if (maybe_ne (MEM_OFFSET (mem), 0))</span>
<span class="lineNum">   14448 </span><span class="lineNoCov">          0 :     loc_descr_plus_const (&amp;loc_result, MEM_OFFSET (mem));</span>
<span class="lineNum">   14449 </span>            : 
<span class="lineNum">   14450 </span><span class="lineNoCov">          0 :   return loc_result;</span>
<span class="lineNum">   14451 </span>            : }
<span class="lineNum">   14452 </span>            : 
<span class="lineNum">   14453 </span>            : /* Output debug info about reason why we failed to expand expression as dwarf
<span class="lineNum">   14454 </span>            :    expression.  */
<a name="14455"><span class="lineNum">   14455 </span>            : </a>
<span class="lineNum">   14456 </span>            : static void
<span class="lineNum">   14457 </span><span class="lineCov">     852515 : expansion_failed (tree expr, rtx rtl, char const *reason)</span>
<span class="lineNum">   14458 </span>            : {
<span class="lineNum">   14459 </span><span class="lineCov">     852515 :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">   14460 </span>            :     {
<span class="lineNum">   14461 </span><span class="lineNoCov">          0 :       fprintf (dump_file, &quot;Failed to expand as dwarf: &quot;);</span>
<span class="lineNum">   14462 </span><span class="lineNoCov">          0 :       if (expr)</span>
<span class="lineNum">   14463 </span><span class="lineNoCov">          0 :         print_generic_expr (dump_file, expr, dump_flags);</span>
<span class="lineNum">   14464 </span><span class="lineNoCov">          0 :       if (rtl)</span>
<span class="lineNum">   14465 </span>            :         {
<span class="lineNum">   14466 </span><span class="lineNoCov">          0 :           fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">   14467 </span><span class="lineNoCov">          0 :           print_rtl (dump_file, rtl);</span>
<span class="lineNum">   14468 </span>            :         }
<span class="lineNum">   14469 </span><span class="lineNoCov">          0 :       fprintf (dump_file, &quot;\nReason: %s\n&quot;, reason);</span>
<span class="lineNum">   14470 </span>            :     }
<span class="lineNum">   14471 </span><span class="lineCov">     852515 : }</span>
<span class="lineNum">   14472 </span>            : 
<span class="lineNum">   14473 </span>            : /* Helper function for const_ok_for_output.  */
<a name="14474"><span class="lineNum">   14474 </span>            : </a>
<span class="lineNum">   14475 </span>            : static bool
<span class="lineNum">   14476 </span><span class="lineCov">    1509608 : const_ok_for_output_1 (rtx rtl)</span>
<span class="lineNum">   14477 </span>            : {
<span class="lineNum">   14478 </span><span class="lineCov">    1509608 :   if (targetm.const_not_ok_for_debug_p (rtl))</span>
<span class="lineNum">   14479 </span>            :     {
<span class="lineNum">   14480 </span><span class="lineCov">          8 :       if (GET_CODE (rtl) != UNSPEC)</span>
<span class="lineNum">   14481 </span>            :         {
<span class="lineNum">   14482 </span><span class="lineNoCov">          0 :           expansion_failed (NULL_TREE, rtl,</span>
<span class="lineNum">   14483 </span>            :                             &quot;Expression rejected for debug by the backend.\n&quot;);
<span class="lineNum">   14484 </span><span class="lineNoCov">          0 :           return false;</span>
<span class="lineNum">   14485 </span>            :         }
<span class="lineNum">   14486 </span>            : 
<span class="lineNum">   14487 </span>            :       /* If delegitimize_address couldn't do anything with the UNSPEC, and
<span class="lineNum">   14488 </span>            :          the target hook doesn't explicitly allow it in debug info, assume
<span class="lineNum">   14489 </span>            :          we can't express it in the debug info.  */
<span class="lineNum">   14490 </span>            :       /* Don't complain about TLS UNSPECs, those are just too hard to
<span class="lineNum">   14491 </span>            :          delegitimize.  Note this could be a non-decl SYMBOL_REF such as
<span class="lineNum">   14492 </span>            :          one in a constant pool entry, so testing SYMBOL_REF_TLS_MODEL
<span class="lineNum">   14493 </span>            :          rather than DECL_THREAD_LOCAL_P is not just an optimization.  */
<span class="lineNum">   14494 </span><span class="lineCov">          8 :       if (flag_checking</span>
<span class="lineNum">   14495 </span><span class="lineCov">          8 :           &amp;&amp; (XVECLEN (rtl, 0) == 0</span>
<span class="lineNum">   14496 </span><span class="lineCov">          8 :               || GET_CODE (XVECEXP (rtl, 0, 0)) != SYMBOL_REF</span>
<span class="lineNum">   14497 </span><span class="lineCov">          8 :               || SYMBOL_REF_TLS_MODEL (XVECEXP (rtl, 0, 0)) == TLS_MODEL_NONE))</span>
<span class="lineNum">   14498 </span><span class="lineNoCov">          0 :         inform (current_function_decl</span>
<span class="lineNum">   14499 </span><span class="lineNoCov">          0 :                 ? DECL_SOURCE_LOCATION (current_function_decl)</span>
<span class="lineNum">   14500 </span><span class="lineNoCov">          0 :                 : UNKNOWN_LOCATION,</span>
<span class="lineNum">   14501 </span>            : #if NUM_UNSPEC_VALUES &gt; 0
<span class="lineNum">   14502 </span>            :                 &quot;non-delegitimized UNSPEC %s (%d) found in variable location&quot;,
<span class="lineNum">   14503 </span><span class="lineNoCov">          0 :                 ((XINT (rtl, 1) &gt;= 0 &amp;&amp; XINT (rtl, 1) &lt; NUM_UNSPEC_VALUES)</span>
<span class="lineNum">   14504 </span>            :                  ? unspec_strings[XINT (rtl, 1)] : &quot;unknown&quot;),
<span class="lineNum">   14505 </span>            :                 XINT (rtl, 1));
<span class="lineNum">   14506 </span>            : #else
<span class="lineNum">   14507 </span>            :                 &quot;non-delegitimized UNSPEC %d found in variable location&quot;,
<span class="lineNum">   14508 </span>            :                 XINT (rtl, 1));
<span class="lineNum">   14509 </span>            : #endif
<span class="lineNum">   14510 </span><span class="lineCov">          8 :       expansion_failed (NULL_TREE, rtl,</span>
<span class="lineNum">   14511 </span>            :                         &quot;UNSPEC hasn't been delegitimized.\n&quot;);
<span class="lineNum">   14512 </span><span class="lineCov">          8 :       return false;</span>
<span class="lineNum">   14513 </span>            :     }
<span class="lineNum">   14514 </span>            : 
<span class="lineNum">   14515 </span><span class="lineCov">    1509600 :   if (CONST_POLY_INT_P (rtl))</span>
<span class="lineNum">   14516 </span>            :     return false;
<span class="lineNum">   14517 </span>            : 
<span class="lineNum">   14518 </span><span class="lineCov">    1509600 :   if (targetm.const_not_ok_for_debug_p (rtl))</span>
<span class="lineNum">   14519 </span>            :     {
<span class="lineNum">   14520 </span><span class="lineNoCov">          0 :       expansion_failed (NULL_TREE, rtl,</span>
<span class="lineNum">   14521 </span>            :                         &quot;Expression rejected for debug by the backend.\n&quot;);
<span class="lineNum">   14522 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">   14523 </span>            :     }
<span class="lineNum">   14524 </span>            : 
<span class="lineNum">   14525 </span>            :   /* FIXME: Refer to PR60655. It is possible for simplification
<span class="lineNum">   14526 </span>            :      of rtl expressions in var tracking to produce such expressions.
<span class="lineNum">   14527 </span>            :      We should really identify / validate expressions
<span class="lineNum">   14528 </span>            :      enclosed in CONST that can be handled by assemblers on various
<span class="lineNum">   14529 </span>            :      targets and only handle legitimate cases here.  */
<span class="lineNum">   14530 </span><span class="lineCov">    1509600 :   switch (GET_CODE (rtl))</span>
<span class="lineNum">   14531 </span>            :     {
<span class="lineNum">   14532 </span><span class="lineCov">    1277998 :     case SYMBOL_REF:</span>
<span class="lineNum">   14533 </span><span class="lineCov">    1277998 :       break;</span>
<span class="lineNum">   14534 </span>            :     case NOT:
<span class="lineNum">   14535 </span>            :     case NEG:
<span class="lineNum">   14536 </span>            :       return false;
<span class="lineNum">   14537 </span><span class="lineCov">     231602 :     default:</span>
<span class="lineNum">   14538 </span><span class="lineCov">     231602 :       return true;</span>
<span class="lineNum">   14539 </span>            :     }
<span class="lineNum">   14540 </span>            : 
<span class="lineNum">   14541 </span><span class="lineCov">    1277998 :   if (CONSTANT_POOL_ADDRESS_P (rtl))</span>
<span class="lineNum">   14542 </span>            :     {
<span class="lineNum">   14543 </span><span class="lineNoCov">          0 :       bool marked;</span>
<span class="lineNum">   14544 </span><span class="lineNoCov">          0 :       get_pool_constant_mark (rtl, &amp;marked);</span>
<span class="lineNum">   14545 </span>            :       /* If all references to this pool constant were optimized away,
<span class="lineNum">   14546 </span>            :          it was not output and thus we can't represent it.  */
<span class="lineNum">   14547 </span><span class="lineNoCov">          0 :       if (!marked)</span>
<span class="lineNum">   14548 </span>            :         {
<span class="lineNum">   14549 </span><span class="lineNoCov">          0 :           expansion_failed (NULL_TREE, rtl,</span>
<span class="lineNum">   14550 </span>            :                             &quot;Constant was removed from constant pool.\n&quot;);
<span class="lineNum">   14551 </span><span class="lineNoCov">          0 :           return false;</span>
<span class="lineNum">   14552 </span>            :         }
<span class="lineNum">   14553 </span>            :     }
<span class="lineNum">   14554 </span>            : 
<span class="lineNum">   14555 </span><span class="lineCov">    1277998 :   if (SYMBOL_REF_TLS_MODEL (rtl) != TLS_MODEL_NONE)</span>
<span class="lineNum">   14556 </span>            :     return false;
<span class="lineNum">   14557 </span>            : 
<span class="lineNum">   14558 </span>            :   /* Avoid references to external symbols in debug info, on several targets
<span class="lineNum">   14559 </span>            :      the linker might even refuse to link when linking a shared library,
<span class="lineNum">   14560 </span>            :      and in many other cases the relocations for .debug_info/.debug_loc are
<span class="lineNum">   14561 </span>            :      dropped, so the address becomes zero anyway.  Hidden symbols, guaranteed
<span class="lineNum">   14562 </span>            :      to be defined within the same shared library or executable are fine.  */
<span class="lineNum">   14563 </span><span class="lineCov">    1269119 :   if (SYMBOL_REF_EXTERNAL_P (rtl))</span>
<span class="lineNum">   14564 </span>            :     {
<span class="lineNum">   14565 </span><span class="lineCov">     145464 :       tree decl = SYMBOL_REF_DECL (rtl);</span>
<span class="lineNum">   14566 </span>            : 
<span class="lineNum">   14567 </span><span class="lineCov">     145464 :       if (decl == NULL || !targetm.binds_local_p (decl))</span>
<span class="lineNum">   14568 </span>            :         {
<span class="lineNum">   14569 </span><span class="lineCov">     131358 :           expansion_failed (NULL_TREE, rtl,</span>
<span class="lineNum">   14570 </span>            :                             &quot;Symbol not defined in current TU.\n&quot;);
<span class="lineNum">   14571 </span><span class="lineCov">     131358 :           return false;</span>
<span class="lineNum">   14572 </span>            :         }
<span class="lineNum">   14573 </span>            :     }
<span class="lineNum">   14574 </span>            : 
<span class="lineNum">   14575 </span>            :   return true;
<span class="lineNum">   14576 </span>            : }
<span class="lineNum">   14577 </span>            : 
<span class="lineNum">   14578 </span>            : /* Return true if constant RTL can be emitted in DW_OP_addr or
<span class="lineNum">   14579 </span>            :    DW_AT_const_value.  TLS SYMBOL_REFs, external SYMBOL_REFs or
<span class="lineNum">   14580 </span>            :    non-marked constant pool SYMBOL_REFs can't be referenced in it.  */
<a name="14581"><span class="lineNum">   14581 </span>            : </a>
<span class="lineNum">   14582 </span>            : static bool
<span class="lineNum">   14583 </span><span class="lineCov">    1280808 : const_ok_for_output (rtx rtl)</span>
<span class="lineNum">   14584 </span>            : {
<span class="lineNum">   14585 </span><span class="lineCov">    1280808 :   if (GET_CODE (rtl) == SYMBOL_REF)</span>
<span class="lineNum">   14586 </span><span class="lineCov">    1152737 :     return const_ok_for_output_1 (rtl);</span>
<span class="lineNum">   14587 </span>            : 
<span class="lineNum">   14588 </span><span class="lineCov">     128071 :   if (GET_CODE (rtl) == CONST)</span>
<span class="lineNum">   14589 </span>            :     {
<span class="lineNum">   14590 </span><span class="lineCov">     250538 :       subrtx_var_iterator::array_type array;</span>
<span class="lineNum">   14591 </span><span class="lineCov">     463325 :       FOR_EACH_SUBRTX_VAR (iter, array, XEXP (rtl, 0), ALL)</span>
<span class="lineNum">   14592 </span><span class="lineCov">     356871 :         if (!const_ok_for_output_1 (*iter))</span>
<span class="lineNum">   14593 </span><span class="lineCov">      18815 :           return false;</span>
<span class="lineNum">   14594 </span><span class="lineCov">     106454 :       return true;</span>
<span class="lineNum">   14595 </span>            :     }
<span class="lineNum">   14596 </span>            : 
<span class="lineNum">   14597 </span>            :   return true;
<span class="lineNum">   14598 </span>            : }
<span class="lineNum">   14599 </span>            : 
<span class="lineNum">   14600 </span>            : /* Return a reference to DW_TAG_base_type corresponding to MODE and UNSIGNEDP
<span class="lineNum">   14601 </span>            :    if possible, NULL otherwise.  */
<a name="14602"><span class="lineNum">   14602 </span>            : </a>
<span class="lineNum">   14603 </span>            : static dw_die_ref
<span class="lineNum">   14604 </span><span class="lineCov">     223279 : base_type_for_mode (machine_mode mode, bool unsignedp)</span>
<span class="lineNum">   14605 </span>            : {
<span class="lineNum">   14606 </span><span class="lineCov">     223279 :   dw_die_ref type_die;</span>
<span class="lineNum">   14607 </span><span class="lineCov">     223279 :   tree type = lang_hooks.types.type_for_mode (mode, unsignedp);</span>
<span class="lineNum">   14608 </span>            : 
<span class="lineNum">   14609 </span><span class="lineCov">     223279 :   if (type == NULL)</span>
<span class="lineNum">   14610 </span>            :     return NULL;
<span class="lineNum">   14611 </span><span class="lineCov">     222885 :   switch (TREE_CODE (type))</span>
<span class="lineNum">   14612 </span>            :     {
<span class="lineNum">   14613 </span><span class="lineCov">     222117 :     case INTEGER_TYPE:</span>
<span class="lineNum">   14614 </span><span class="lineCov">     222117 :     case REAL_TYPE:</span>
<span class="lineNum">   14615 </span><span class="lineCov">     222117 :       break;</span>
<span class="lineNum">   14616 </span>            :     default:
<span class="lineNum">   14617 </span>            :       return NULL;
<span class="lineNum">   14618 </span>            :     }
<span class="lineNum">   14619 </span><span class="lineCov">     222117 :   type_die = lookup_type_die (type);</span>
<span class="lineNum">   14620 </span><span class="lineCov">     222117 :   if (!type_die)</span>
<span class="lineNum">   14621 </span><span class="lineCov">       1392 :     type_die = modified_type_die (type, TYPE_UNQUALIFIED, false,</span>
<span class="lineNum">   14622 </span>            :                                   comp_unit_die ());
<span class="lineNum">   14623 </span><span class="lineCov">     222117 :   if (type_die == NULL || type_die-&gt;die_tag != DW_TAG_base_type)</span>
<span class="lineNum">   14624 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">   14625 </span>            :   return type_die;
<span class="lineNum">   14626 </span>            : }
<span class="lineNum">   14627 </span>            : 
<span class="lineNum">   14628 </span>            : /* For OP descriptor assumed to be in unsigned MODE, convert it to a unsigned
<span class="lineNum">   14629 </span>            :    type matching MODE, or, if MODE is narrower than or as wide as
<span class="lineNum">   14630 </span>            :    DWARF2_ADDR_SIZE, untyped.  Return NULL if the conversion is not
<span class="lineNum">   14631 </span>            :    possible.  */
<a name="14632"><span class="lineNum">   14632 </span>            : </a>
<span class="lineNum">   14633 </span>            : static dw_loc_descr_ref
<span class="lineNum">   14634 </span><span class="lineCov">       1988 : convert_descriptor_to_mode (scalar_int_mode mode, dw_loc_descr_ref op)</span>
<span class="lineNum">   14635 </span>            : {
<span class="lineNum">   14636 </span><span class="lineCov">       1988 :   machine_mode outer_mode = mode;</span>
<span class="lineNum">   14637 </span><span class="lineCov">       1988 :   dw_die_ref type_die;</span>
<span class="lineNum">   14638 </span><span class="lineCov">       1988 :   dw_loc_descr_ref cvt;</span>
<span class="lineNum">   14639 </span>            : 
<span class="lineNum">   14640 </span><span class="lineCov">       4862 :   if (GET_MODE_SIZE (mode) &lt;= DWARF2_ADDR_SIZE)</span>
<span class="lineNum">   14641 </span>            :     {
<span class="lineNum">   14642 </span><span class="lineCov">       3748 :       add_loc_descr (&amp;op, new_loc_descr (dwarf_OP (DW_OP_convert), 0, 0));</span>
<span class="lineNum">   14643 </span><span class="lineCov">       1874 :       return op;</span>
<span class="lineNum">   14644 </span>            :     }
<span class="lineNum">   14645 </span><span class="lineCov">        114 :   type_die = base_type_for_mode (outer_mode, 1);</span>
<span class="lineNum">   14646 </span><span class="lineCov">        114 :   if (type_die == NULL)</span>
<span class="lineNum">   14647 </span>            :     return NULL;
<span class="lineNum">   14648 </span><span class="lineCov">        228 :   cvt = new_loc_descr (dwarf_OP (DW_OP_convert), 0, 0);</span>
<span class="lineNum">   14649 </span><span class="lineCov">        114 :   cvt-&gt;dw_loc_oprnd1.val_class = dw_val_class_die_ref;</span>
<span class="lineNum">   14650 </span><span class="lineCov">        114 :   cvt-&gt;dw_loc_oprnd1.v.val_die_ref.die = type_die;</span>
<span class="lineNum">   14651 </span><span class="lineCov">        114 :   cvt-&gt;dw_loc_oprnd1.v.val_die_ref.external = 0;</span>
<span class="lineNum">   14652 </span><span class="lineCov">        114 :   add_loc_descr (&amp;op, cvt);</span>
<span class="lineNum">   14653 </span><span class="lineCov">        114 :   return op;</span>
<span class="lineNum">   14654 </span>            : }
<span class="lineNum">   14655 </span>            : 
<span class="lineNum">   14656 </span>            : /* Return location descriptor for comparison OP with operands OP0 and OP1.  */
<a name="14657"><span class="lineNum">   14657 </span>            : </a>
<span class="lineNum">   14658 </span>            : static dw_loc_descr_ref
<span class="lineNum">   14659 </span><span class="lineCov">      53727 : compare_loc_descriptor (enum dwarf_location_atom op, dw_loc_descr_ref op0,</span>
<span class="lineNum">   14660 </span>            :                         dw_loc_descr_ref op1)
<span class="lineNum">   14661 </span>            : {
<span class="lineNum">   14662 </span><span class="lineCov">      53727 :   dw_loc_descr_ref ret = op0;</span>
<span class="lineNum">   14663 </span><span class="lineCov">      53727 :   add_loc_descr (&amp;ret, op1);</span>
<span class="lineNum">   14664 </span><span class="lineCov">      53727 :   add_loc_descr (&amp;ret, new_loc_descr (op, 0, 0));</span>
<span class="lineNum">   14665 </span><span class="lineCov">      53727 :   if (STORE_FLAG_VALUE != 1)</span>
<span class="lineNum">   14666 </span>            :     {
<span class="lineNum">   14667 </span>            :       add_loc_descr (&amp;ret, int_loc_descriptor (STORE_FLAG_VALUE));
<span class="lineNum">   14668 </span>            :       add_loc_descr (&amp;ret, new_loc_descr (DW_OP_mul, 0, 0));
<span class="lineNum">   14669 </span>            :     }
<span class="lineNum">   14670 </span><span class="lineCov">      53727 :   return ret;</span>
<span class="lineNum">   14671 </span>            : }
<span class="lineNum">   14672 </span>            : 
<span class="lineNum">   14673 </span>            : /* Subroutine of scompare_loc_descriptor for the case in which we're
<span class="lineNum">   14674 </span>            :    comparing two scalar integer operands OP0 and OP1 that have mode OP_MODE,
<span class="lineNum">   14675 </span>            :    and in which OP_MODE is bigger than DWARF2_ADDR_SIZE.  */
<a name="14676"><span class="lineNum">   14676 </span>            : </a>
<span class="lineNum">   14677 </span>            : static dw_loc_descr_ref
<span class="lineNum">   14678 </span><span class="lineCov">        218 : scompare_loc_descriptor_wide (enum dwarf_location_atom op,</span>
<span class="lineNum">   14679 </span>            :                               scalar_int_mode op_mode,
<span class="lineNum">   14680 </span>            :                               dw_loc_descr_ref op0, dw_loc_descr_ref op1)
<span class="lineNum">   14681 </span>            : {
<span class="lineNum">   14682 </span><span class="lineCov">        436 :   dw_die_ref type_die = base_type_for_mode (op_mode, 0);</span>
<span class="lineNum">   14683 </span><span class="lineCov">        218 :   dw_loc_descr_ref cvt;</span>
<span class="lineNum">   14684 </span>            : 
<span class="lineNum">   14685 </span><span class="lineCov">        218 :   if (type_die == NULL)</span>
<span class="lineNum">   14686 </span>            :     return NULL;
<span class="lineNum">   14687 </span><span class="lineCov">        436 :   cvt = new_loc_descr (dwarf_OP (DW_OP_convert), 0, 0);</span>
<span class="lineNum">   14688 </span><span class="lineCov">        218 :   cvt-&gt;dw_loc_oprnd1.val_class = dw_val_class_die_ref;</span>
<span class="lineNum">   14689 </span><span class="lineCov">        218 :   cvt-&gt;dw_loc_oprnd1.v.val_die_ref.die = type_die;</span>
<span class="lineNum">   14690 </span><span class="lineCov">        218 :   cvt-&gt;dw_loc_oprnd1.v.val_die_ref.external = 0;</span>
<span class="lineNum">   14691 </span><span class="lineCov">        218 :   add_loc_descr (&amp;op0, cvt);</span>
<span class="lineNum">   14692 </span><span class="lineCov">        436 :   cvt = new_loc_descr (dwarf_OP (DW_OP_convert), 0, 0);</span>
<span class="lineNum">   14693 </span><span class="lineCov">        218 :   cvt-&gt;dw_loc_oprnd1.val_class = dw_val_class_die_ref;</span>
<span class="lineNum">   14694 </span><span class="lineCov">        218 :   cvt-&gt;dw_loc_oprnd1.v.val_die_ref.die = type_die;</span>
<span class="lineNum">   14695 </span><span class="lineCov">        218 :   cvt-&gt;dw_loc_oprnd1.v.val_die_ref.external = 0;</span>
<span class="lineNum">   14696 </span><span class="lineCov">        218 :   add_loc_descr (&amp;op1, cvt);</span>
<span class="lineNum">   14697 </span><span class="lineCov">        218 :   return compare_loc_descriptor (op, op0, op1);</span>
<span class="lineNum">   14698 </span>            : }
<span class="lineNum">   14699 </span>            : 
<span class="lineNum">   14700 </span>            : /* Subroutine of scompare_loc_descriptor for the case in which we're
<span class="lineNum">   14701 </span>            :    comparing two scalar integer operands OP0 and OP1 that have mode OP_MODE,
<span class="lineNum">   14702 </span>            :    and in which OP_MODE is smaller than DWARF2_ADDR_SIZE.  */
<a name="14703"><span class="lineNum">   14703 </span>            : </a>
<span class="lineNum">   14704 </span>            : static dw_loc_descr_ref
<span class="lineNum">   14705 </span><span class="lineCov">      13533 : scompare_loc_descriptor_narrow (enum dwarf_location_atom op, rtx rtl,</span>
<span class="lineNum">   14706 </span>            :                                 scalar_int_mode op_mode,
<span class="lineNum">   14707 </span>            :                                 dw_loc_descr_ref op0, dw_loc_descr_ref op1)
<span class="lineNum">   14708 </span>            : {
<span class="lineNum">   14709 </span><span class="lineCov">      15135 :   int shift = (DWARF2_ADDR_SIZE - GET_MODE_SIZE (op_mode)) * BITS_PER_UNIT;</span>
<span class="lineNum">   14710 </span>            :   /* For eq/ne, if the operands are known to be zero-extended,
<span class="lineNum">   14711 </span>            :      there is no need to do the fancy shifting up.  */
<span class="lineNum">   14712 </span><span class="lineCov">      13533 :   if (op == DW_OP_eq || op == DW_OP_ne)</span>
<span class="lineNum">   14713 </span>            :     {
<span class="lineNum">   14714 </span><span class="lineCov">      12099 :       dw_loc_descr_ref last0, last1;</span>
<span class="lineNum">   14715 </span><span class="lineCov">      42483 :       for (last0 = op0; last0-&gt;dw_loc_next != NULL; last0 = last0-&gt;dw_loc_next)</span>
<span class="lineNum">   14716 </span>            :         ;
<span class="lineNum">   14717 </span><span class="lineCov">      21086 :       for (last1 = op1; last1-&gt;dw_loc_next != NULL; last1 = last1-&gt;dw_loc_next)</span>
<span class="lineNum">   14718 </span>            :         ;
<span class="lineNum">   14719 </span>            :       /* deref_size zero extends, and for constants we can check
<span class="lineNum">   14720 </span>            :          whether they are zero extended or not.  */
<span class="lineNum">   14721 </span><span class="lineCov">      12099 :       if (((last0-&gt;dw_loc_opc == DW_OP_deref_size</span>
<span class="lineNum">   14722 </span><span class="lineCov">       3092 :             &amp;&amp; last0-&gt;dw_loc_oprnd1.v.val_int &lt;= GET_MODE_SIZE (op_mode))</span>
<span class="lineNum">   14723 </span><span class="lineCov">      10553 :            || (CONST_INT_P (XEXP (rtl, 0))</span>
<span class="lineNum">   14724 </span><span class="lineCov">         50 :                &amp;&amp; (unsigned HOST_WIDE_INT) INTVAL (XEXP (rtl, 0))</span>
<span class="lineNum">   14725 </span><span class="lineCov">         50 :                   == (INTVAL (XEXP (rtl, 0)) &amp; GET_MODE_MASK (op_mode))))</span>
<span class="lineNum">   14726 </span><span class="lineCov">      13664 :           &amp;&amp; ((last1-&gt;dw_loc_opc == DW_OP_deref_size</span>
<span class="lineNum">   14727 </span><span class="lineCov">        270 :                &amp;&amp; last1-&gt;dw_loc_oprnd1.v.val_int &lt;= GET_MODE_SIZE (op_mode))</span>
<span class="lineNum">   14728 </span><span class="lineCov">       1430 :               || (CONST_INT_P (XEXP (rtl, 1))</span>
<span class="lineNum">   14729 </span><span class="lineCov">       2710 :                   &amp;&amp; (unsigned HOST_WIDE_INT) INTVAL (XEXP (rtl, 1))</span>
<span class="lineNum">   14730 </span><span class="lineCov">       2710 :                      == (INTVAL (XEXP (rtl, 1)) &amp; GET_MODE_MASK (op_mode)))))</span>
<span class="lineNum">   14731 </span><span class="lineCov">       1431 :         return compare_loc_descriptor (op, op0, op1);</span>
<span class="lineNum">   14732 </span>            : 
<span class="lineNum">   14733 </span>            :       /* EQ/NE comparison against constant in narrower type than
<span class="lineNum">   14734 </span>            :          DWARF2_ADDR_SIZE can be performed either as
<span class="lineNum">   14735 </span>            :          DW_OP_const1u &lt;shift&gt; DW_OP_shl DW_OP_const* &lt;cst &lt;&lt; shift&gt;
<span class="lineNum">   14736 </span>            :          DW_OP_{eq,ne}
<span class="lineNum">   14737 </span>            :          or
<span class="lineNum">   14738 </span>            :          DW_OP_const*u &lt;mode_mask&gt; DW_OP_and DW_OP_const* &lt;cst &amp; mode_mask&gt;
<span class="lineNum">   14739 </span>            :          DW_OP_{eq,ne}.  Pick whatever is shorter.  */
<span class="lineNum">   14740 </span><span class="lineCov">      10668 :       if (CONST_INT_P (XEXP (rtl, 1))</span>
<span class="lineNum">   14741 </span><span class="lineCov">      19794 :           &amp;&amp; GET_MODE_BITSIZE (op_mode) &lt; HOST_BITS_PER_WIDE_INT</span>
<span class="lineNum">   14742 </span><span class="lineCov">      20565 :           &amp;&amp; (size_of_int_loc_descriptor (shift) + 1</span>
<span class="lineNum">   14743 </span><span class="lineCov">       9897 :               + size_of_int_loc_descriptor (UINTVAL (XEXP (rtl, 1)) &lt;&lt; shift)</span>
<span class="lineNum">   14744 </span><span class="lineCov">      19794 :               &gt;= size_of_int_loc_descriptor (GET_MODE_MASK (op_mode)) + 1</span>
<span class="lineNum">   14745 </span><span class="lineCov">       9897 :                  + size_of_int_loc_descriptor (INTVAL (XEXP (rtl, 1))</span>
<span class="lineNum">   14746 </span><span class="lineCov">      19794 :                                                &amp; GET_MODE_MASK (op_mode))))</span>
<span class="lineNum">   14747 </span>            :         {
<span class="lineNum">   14748 </span><span class="lineCov">       3567 :           add_loc_descr (&amp;op0, int_loc_descriptor (GET_MODE_MASK (op_mode)));</span>
<span class="lineNum">   14749 </span><span class="lineCov">       1189 :           add_loc_descr (&amp;op0, new_loc_descr (DW_OP_and, 0, 0));</span>
<span class="lineNum">   14750 </span><span class="lineCov">       1189 :           op1 = int_loc_descriptor (INTVAL (XEXP (rtl, 1))</span>
<span class="lineNum">   14751 </span><span class="lineCov">       2378 :                                     &amp; GET_MODE_MASK (op_mode));</span>
<span class="lineNum">   14752 </span><span class="lineCov">       1189 :           return compare_loc_descriptor (op, op0, op1);</span>
<span class="lineNum">   14753 </span>            :         }
<span class="lineNum">   14754 </span>            :     }
<span class="lineNum">   14755 </span><span class="lineCov">      21826 :   add_loc_descr (&amp;op0, int_loc_descriptor (shift));</span>
<span class="lineNum">   14756 </span><span class="lineCov">      10913 :   add_loc_descr (&amp;op0, new_loc_descr (DW_OP_shl, 0, 0));</span>
<span class="lineNum">   14757 </span><span class="lineCov">      10913 :   if (CONST_INT_P (XEXP (rtl, 1)))</span>
<span class="lineNum">   14758 </span><span class="lineCov">      19566 :     op1 = int_loc_descriptor (UINTVAL (XEXP (rtl, 1)) &lt;&lt; shift);</span>
<span class="lineNum">   14759 </span>            :   else
<span class="lineNum">   14760 </span>            :     {
<span class="lineNum">   14761 </span><span class="lineCov">       2260 :       add_loc_descr (&amp;op1, int_loc_descriptor (shift));</span>
<span class="lineNum">   14762 </span><span class="lineCov">       1130 :       add_loc_descr (&amp;op1, new_loc_descr (DW_OP_shl, 0, 0));</span>
<span class="lineNum">   14763 </span>            :     }
<span class="lineNum">   14764 </span><span class="lineCov">      10913 :   return compare_loc_descriptor (op, op0, op1);</span>
<span class="lineNum">   14765 </span>            : }
<span class="lineNum">   14766 </span>            : 
<span class="lineNum">   14767 </span>            : /* Return location descriptor for unsigned comparison OP RTL.  */
<a name="14768"><span class="lineNum">   14768 </span>            : </a>
<span class="lineNum">   14769 </span>            : static dw_loc_descr_ref
<span class="lineNum">   14770 </span><span class="lineCov">      35576 : scompare_loc_descriptor (enum dwarf_location_atom op, rtx rtl,</span>
<span class="lineNum">   14771 </span>            :                          machine_mode mem_mode)
<span class="lineNum">   14772 </span>            : {
<span class="lineNum">   14773 </span><span class="lineCov">      35576 :   machine_mode op_mode = GET_MODE (XEXP (rtl, 0));</span>
<span class="lineNum">   14774 </span><span class="lineCov">      35576 :   dw_loc_descr_ref op0, op1;</span>
<span class="lineNum">   14775 </span>            : 
<span class="lineNum">   14776 </span><span class="lineCov">      35576 :   if (op_mode == VOIDmode)</span>
<span class="lineNum">   14777 </span><span class="lineCov">         29 :     op_mode = GET_MODE (XEXP (rtl, 1));</span>
<span class="lineNum">   14778 </span><span class="lineCov">      35576 :   if (op_mode == VOIDmode)</span>
<span class="lineNum">   14779 </span>            :     return NULL;
<span class="lineNum">   14780 </span>            : 
<span class="lineNum">   14781 </span><span class="lineCov">      35576 :   scalar_int_mode int_op_mode;</span>
<span class="lineNum">   14782 </span><span class="lineCov">      35576 :   if (dwarf_strict</span>
<span class="lineNum">   14783 </span><span class="lineNoCov">          0 :       &amp;&amp; dwarf_version &lt; 5</span>
<span class="lineNum">   14784 </span><span class="lineCov">      35576 :       &amp;&amp; (!is_a &lt;scalar_int_mode&gt; (op_mode, &amp;int_op_mode)</span>
<span class="lineNum">   14785 </span><span class="lineNoCov">          0 :           || GET_MODE_SIZE (int_op_mode) &gt; DWARF2_ADDR_SIZE))</span>
<span class="lineNum">   14786 </span>            :     return NULL;
<span class="lineNum">   14787 </span>            : 
<span class="lineNum">   14788 </span><span class="lineCov">      35576 :   op0 = mem_loc_descriptor (XEXP (rtl, 0), op_mode, mem_mode,</span>
<span class="lineNum">   14789 </span>            :                             VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   14790 </span><span class="lineCov">      35576 :   op1 = mem_loc_descriptor (XEXP (rtl, 1), op_mode, mem_mode,</span>
<span class="lineNum">   14791 </span>            :                             VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   14792 </span>            : 
<span class="lineNum">   14793 </span><span class="lineCov">      35576 :   if (op0 == NULL || op1 == NULL)</span>
<span class="lineNum">   14794 </span>            :     return NULL;
<span class="lineNum">   14795 </span>            : 
<span class="lineNum">   14796 </span><span class="lineCov">      34902 :   if (is_a &lt;scalar_int_mode&gt; (op_mode, &amp;int_op_mode))</span>
<span class="lineNum">   14797 </span>            :     {
<span class="lineNum">   14798 </span><span class="lineCov">      76697 :       if (GET_MODE_SIZE (int_op_mode) &lt; DWARF2_ADDR_SIZE)</span>
<span class="lineNum">   14799 </span><span class="lineCov">      13533 :         return scompare_loc_descriptor_narrow (op, rtl, int_op_mode, op0, op1);</span>
<span class="lineNum">   14800 </span>            : 
<span class="lineNum">   14801 </span><span class="lineCov">      40794 :       if (GET_MODE_SIZE (int_op_mode) &gt; DWARF2_ADDR_SIZE)</span>
<span class="lineNum">   14802 </span><span class="lineCov">        218 :         return scompare_loc_descriptor_wide (op, int_op_mode, op0, op1);</span>
<span class="lineNum">   14803 </span>            :     }
<span class="lineNum">   14804 </span><span class="lineCov">      21151 :   return compare_loc_descriptor (op, op0, op1);</span>
<span class="lineNum">   14805 </span>            : }
<span class="lineNum">   14806 </span>            : 
<span class="lineNum">   14807 </span>            : /* Return location descriptor for unsigned comparison OP RTL.  */
<a name="14808"><span class="lineNum">   14808 </span>            : </a>
<span class="lineNum">   14809 </span>            : static dw_loc_descr_ref
<span class="lineNum">   14810 </span><span class="lineCov">      19507 : ucompare_loc_descriptor (enum dwarf_location_atom op, rtx rtl,</span>
<span class="lineNum">   14811 </span>            :                          machine_mode mem_mode)
<span class="lineNum">   14812 </span>            : {
<span class="lineNum">   14813 </span><span class="lineCov">      19507 :   dw_loc_descr_ref op0, op1;</span>
<span class="lineNum">   14814 </span>            : 
<span class="lineNum">   14815 </span><span class="lineCov">      19507 :   machine_mode test_op_mode = GET_MODE (XEXP (rtl, 0));</span>
<span class="lineNum">   14816 </span><span class="lineCov">      19507 :   if (test_op_mode == VOIDmode)</span>
<span class="lineNum">   14817 </span><span class="lineCov">         32 :     test_op_mode = GET_MODE (XEXP (rtl, 1));</span>
<span class="lineNum">   14818 </span>            : 
<span class="lineNum">   14819 </span><span class="lineCov">      19507 :   scalar_int_mode op_mode;</span>
<span class="lineNum">   14820 </span><span class="lineCov">      19507 :   if (!is_a &lt;scalar_int_mode&gt; (test_op_mode, &amp;op_mode))</span>
<span class="lineNum">   14821 </span>            :     return NULL;
<span class="lineNum">   14822 </span>            : 
<span class="lineNum">   14823 </span><span class="lineCov">      19171 :   if (dwarf_strict</span>
<span class="lineNum">   14824 </span><span class="lineNoCov">          0 :       &amp;&amp; dwarf_version &lt; 5</span>
<span class="lineNum">   14825 </span><span class="lineCov">      19171 :       &amp;&amp; GET_MODE_SIZE (op_mode) &gt; DWARF2_ADDR_SIZE)</span>
<span class="lineNum">   14826 </span>            :     return NULL;
<span class="lineNum">   14827 </span>            : 
<span class="lineNum">   14828 </span><span class="lineCov">      38342 :   op0 = mem_loc_descriptor (XEXP (rtl, 0), op_mode, mem_mode,</span>
<span class="lineNum">   14829 </span>            :                             VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   14830 </span><span class="lineCov">      38342 :   op1 = mem_loc_descriptor (XEXP (rtl, 1), op_mode, mem_mode,</span>
<span class="lineNum">   14831 </span>            :                             VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   14832 </span>            : 
<span class="lineNum">   14833 </span><span class="lineCov">      19171 :   if (op0 == NULL || op1 == NULL)</span>
<span class="lineNum">   14834 </span>            :     return NULL;
<span class="lineNum">   14835 </span>            : 
<span class="lineNum">   14836 </span><span class="lineCov">      41943 :   if (GET_MODE_SIZE (op_mode) &lt; DWARF2_ADDR_SIZE)</span>
<span class="lineNum">   14837 </span>            :     {
<span class="lineNum">   14838 </span><span class="lineCov">       7463 :       HOST_WIDE_INT mask = GET_MODE_MASK (op_mode);</span>
<span class="lineNum">   14839 </span><span class="lineCov">       7463 :       dw_loc_descr_ref last0, last1;</span>
<span class="lineNum">   14840 </span><span class="lineCov">      10623 :       for (last0 = op0; last0-&gt;dw_loc_next != NULL; last0 = last0-&gt;dw_loc_next)</span>
<span class="lineNum">   14841 </span>            :         ;
<span class="lineNum">   14842 </span><span class="lineCov">       7638 :       for (last1 = op1; last1-&gt;dw_loc_next != NULL; last1 = last1-&gt;dw_loc_next)</span>
<span class="lineNum">   14843 </span>            :         ;
<span class="lineNum">   14844 </span><span class="lineCov">       7463 :       if (CONST_INT_P (XEXP (rtl, 0)))</span>
<span class="lineNum">   14845 </span><span class="lineNoCov">          0 :         op0 = int_loc_descriptor (INTVAL (XEXP (rtl, 0)) &amp; mask);</span>
<span class="lineNum">   14846 </span>            :       /* deref_size zero extends, so no need to mask it again.  */
<span class="lineNum">   14847 </span><span class="lineCov">       7463 :       else if (last0-&gt;dw_loc_opc != DW_OP_deref_size</span>
<span class="lineNum">   14848 </span><span class="lineCov">      10142 :                || last0-&gt;dw_loc_oprnd1.v.val_int &gt; GET_MODE_SIZE (op_mode))</span>
<span class="lineNum">   14849 </span>            :         {
<span class="lineNum">   14850 </span><span class="lineCov">       9568 :           add_loc_descr (&amp;op0, int_loc_descriptor (mask));</span>
<span class="lineNum">   14851 </span><span class="lineCov">       4784 :           add_loc_descr (&amp;op0, new_loc_descr (DW_OP_and, 0, 0));</span>
<span class="lineNum">   14852 </span>            :         }
<span class="lineNum">   14853 </span><span class="lineCov">       7463 :       if (CONST_INT_P (XEXP (rtl, 1)))</span>
<span class="lineNum">   14854 </span><span class="lineCov">      14750 :         op1 = int_loc_descriptor (INTVAL (XEXP (rtl, 1)) &amp; mask);</span>
<span class="lineNum">   14855 </span>            :       /* deref_size zero extends, so no need to mask it again.  */
<span class="lineNum">   14856 </span><span class="lineCov">         88 :       else if (last1-&gt;dw_loc_opc != DW_OP_deref_size</span>
<span class="lineNum">   14857 </span><span class="lineCov">        137 :                || last1-&gt;dw_loc_oprnd1.v.val_int &gt; GET_MODE_SIZE (op_mode))</span>
<span class="lineNum">   14858 </span>            :         {
<span class="lineNum">   14859 </span><span class="lineCov">         78 :           add_loc_descr (&amp;op1, int_loc_descriptor (mask));</span>
<span class="lineNum">   14860 </span><span class="lineCov">         39 :           add_loc_descr (&amp;op1, new_loc_descr (DW_OP_and, 0, 0));</span>
<span class="lineNum">   14861 </span>            :         }
<span class="lineNum">   14862 </span>            :     }
<span class="lineNum">   14863 </span><span class="lineCov">      26949 :   else if (GET_MODE_SIZE (op_mode) == DWARF2_ADDR_SIZE)</span>
<span class="lineNum">   14864 </span>            :     {
<span class="lineNum">   14865 </span><span class="lineCov">      11200 :       HOST_WIDE_INT bias = 1;</span>
<span class="lineNum">   14866 </span><span class="lineCov">      11200 :       bias &lt;&lt;= (DWARF2_ADDR_SIZE * BITS_PER_UNIT - 1);</span>
<span class="lineNum">   14867 </span><span class="lineCov">      11200 :       add_loc_descr (&amp;op0, new_loc_descr (DW_OP_plus_uconst, bias, 0));</span>
<span class="lineNum">   14868 </span><span class="lineCov">      11200 :       if (CONST_INT_P (XEXP (rtl, 1)))</span>
<span class="lineNum">   14869 </span><span class="lineCov">       4158 :         op1 = int_loc_descriptor ((unsigned HOST_WIDE_INT) bias</span>
<span class="lineNum">   14870 </span><span class="lineCov">       4158 :                                   + INTVAL (XEXP (rtl, 1)));</span>
<span class="lineNum">   14871 </span>            :       else
<span class="lineNum">   14872 </span><span class="lineCov">       7042 :         add_loc_descr (&amp;op1, new_loc_descr (DW_OP_plus_uconst,</span>
<span class="lineNum">   14873 </span>            :                                             bias, 0));
<span class="lineNum">   14874 </span>            :     }
<span class="lineNum">   14875 </span><span class="lineCov">      18825 :   return compare_loc_descriptor (op, op0, op1);</span>
<span class="lineNum">   14876 </span>            : }
<span class="lineNum">   14877 </span>            : 
<span class="lineNum">   14878 </span>            : /* Return location descriptor for {U,S}{MIN,MAX}.  */
<a name="14879"><span class="lineNum">   14879 </span>            : </a>
<span class="lineNum">   14880 </span>            : static dw_loc_descr_ref
<span class="lineNum">   14881 </span><span class="lineCov">       8248 : minmax_loc_descriptor (rtx rtl, machine_mode mode,</span>
<span class="lineNum">   14882 </span>            :                        machine_mode mem_mode)
<span class="lineNum">   14883 </span>            : {
<span class="lineNum">   14884 </span><span class="lineCov">       8248 :   enum dwarf_location_atom op;</span>
<span class="lineNum">   14885 </span><span class="lineCov">       8248 :   dw_loc_descr_ref op0, op1, ret;</span>
<span class="lineNum">   14886 </span><span class="lineCov">       8248 :   dw_loc_descr_ref bra_node, drop_node;</span>
<span class="lineNum">   14887 </span>            : 
<span class="lineNum">   14888 </span><span class="lineCov">       8248 :   scalar_int_mode int_mode;</span>
<span class="lineNum">   14889 </span><span class="lineCov">       8248 :   if (dwarf_strict</span>
<span class="lineNum">   14890 </span><span class="lineNoCov">          0 :       &amp;&amp; dwarf_version &lt; 5</span>
<span class="lineNum">   14891 </span><span class="lineCov">       8248 :       &amp;&amp; (!is_a &lt;scalar_int_mode&gt; (mode, &amp;int_mode)</span>
<span class="lineNum">   14892 </span><span class="lineNoCov">          0 :           || GET_MODE_SIZE (int_mode) &gt; DWARF2_ADDR_SIZE))</span>
<span class="lineNum">   14893 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">   14894 </span>            : 
<span class="lineNum">   14895 </span><span class="lineCov">       8248 :   op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,</span>
<span class="lineNum">   14896 </span>            :                             VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   14897 </span><span class="lineCov">       8248 :   op1 = mem_loc_descriptor (XEXP (rtl, 1), mode, mem_mode,</span>
<span class="lineNum">   14898 </span>            :                             VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   14899 </span>            : 
<span class="lineNum">   14900 </span><span class="lineCov">       8248 :   if (op0 == NULL || op1 == NULL)</span>
<span class="lineNum">   14901 </span>            :     return NULL;
<span class="lineNum">   14902 </span>            : 
<span class="lineNum">   14903 </span><span class="lineCov">       8196 :   add_loc_descr (&amp;op0, new_loc_descr (DW_OP_dup, 0, 0));</span>
<span class="lineNum">   14904 </span><span class="lineCov">       8196 :   add_loc_descr (&amp;op1, new_loc_descr (DW_OP_swap, 0, 0));</span>
<span class="lineNum">   14905 </span><span class="lineCov">       8196 :   add_loc_descr (&amp;op1, new_loc_descr (DW_OP_over, 0, 0));</span>
<span class="lineNum">   14906 </span><span class="lineCov">       8196 :   if (GET_CODE (rtl) == UMIN || GET_CODE (rtl) == UMAX)</span>
<span class="lineNum">   14907 </span>            :     {
<span class="lineNum">   14908 </span>            :       /* Checked by the caller.  */
<span class="lineNum">   14909 </span><span class="lineCov">        875 :       int_mode = as_a &lt;scalar_int_mode&gt; (mode);</span>
<span class="lineNum">   14910 </span><span class="lineCov">       1986 :       if (GET_MODE_SIZE (int_mode) &lt; DWARF2_ADDR_SIZE)</span>
<span class="lineNum">   14911 </span>            :         {
<span class="lineNum">   14912 </span><span class="lineCov">         55 :           HOST_WIDE_INT mask = GET_MODE_MASK (int_mode);</span>
<span class="lineNum">   14913 </span><span class="lineCov">        110 :           add_loc_descr (&amp;op0, int_loc_descriptor (mask));</span>
<span class="lineNum">   14914 </span><span class="lineCov">         55 :           add_loc_descr (&amp;op0, new_loc_descr (DW_OP_and, 0, 0));</span>
<span class="lineNum">   14915 </span><span class="lineCov">        110 :           add_loc_descr (&amp;op1, int_loc_descriptor (mask));</span>
<span class="lineNum">   14916 </span><span class="lineCov">         55 :           add_loc_descr (&amp;op1, new_loc_descr (DW_OP_and, 0, 0));</span>
<span class="lineNum">   14917 </span>            :         }
<span class="lineNum">   14918 </span><span class="lineCov">       1862 :       else if (GET_MODE_SIZE (int_mode) == DWARF2_ADDR_SIZE)</span>
<span class="lineNum">   14919 </span>            :         {
<span class="lineNum">   14920 </span><span class="lineCov">        817 :           HOST_WIDE_INT bias = 1;</span>
<span class="lineNum">   14921 </span><span class="lineCov">        817 :           bias &lt;&lt;= (DWARF2_ADDR_SIZE * BITS_PER_UNIT - 1);</span>
<span class="lineNum">   14922 </span><span class="lineCov">        817 :           add_loc_descr (&amp;op0, new_loc_descr (DW_OP_plus_uconst, bias, 0));</span>
<span class="lineNum">   14923 </span><span class="lineCov">        817 :           add_loc_descr (&amp;op1, new_loc_descr (DW_OP_plus_uconst, bias, 0));</span>
<span class="lineNum">   14924 </span>            :         }
<span class="lineNum">   14925 </span>            :     }
<span class="lineNum">   14926 </span><span class="lineCov">       7321 :   else if (is_a &lt;scalar_int_mode&gt; (mode, &amp;int_mode)</span>
<span class="lineNum">   14927 </span><span class="lineCov">      18224 :            &amp;&amp; GET_MODE_SIZE (int_mode) &lt; DWARF2_ADDR_SIZE)</span>
<span class="lineNum">   14928 </span>            :     {
<span class="lineNum">   14929 </span><span class="lineCov">        578 :       int shift = (DWARF2_ADDR_SIZE - GET_MODE_SIZE (int_mode)) * BITS_PER_UNIT;</span>
<span class="lineNum">   14930 </span><span class="lineCov">       1156 :       add_loc_descr (&amp;op0, int_loc_descriptor (shift));</span>
<span class="lineNum">   14931 </span><span class="lineCov">        578 :       add_loc_descr (&amp;op0, new_loc_descr (DW_OP_shl, 0, 0));</span>
<span class="lineNum">   14932 </span><span class="lineCov">       1156 :       add_loc_descr (&amp;op1, int_loc_descriptor (shift));</span>
<span class="lineNum">   14933 </span><span class="lineCov">        578 :       add_loc_descr (&amp;op1, new_loc_descr (DW_OP_shl, 0, 0));</span>
<span class="lineNum">   14934 </span>            :     }
<span class="lineNum">   14935 </span><span class="lineCov">       6743 :   else if (is_a &lt;scalar_int_mode&gt; (mode, &amp;int_mode)</span>
<span class="lineNum">   14936 </span><span class="lineCov">      17068 :            &amp;&amp; GET_MODE_SIZE (int_mode) &gt; DWARF2_ADDR_SIZE)</span>
<span class="lineNum">   14937 </span>            :     {
<span class="lineNum">   14938 </span><span class="lineCov">         50 :       dw_die_ref type_die = base_type_for_mode (int_mode, 0);</span>
<span class="lineNum">   14939 </span><span class="lineCov">         25 :       dw_loc_descr_ref cvt;</span>
<span class="lineNum">   14940 </span><span class="lineCov">         25 :       if (type_die == NULL)</span>
<span class="lineNum">   14941 </span>            :         return NULL;
<span class="lineNum">   14942 </span><span class="lineCov">         25 :       cvt = new_loc_descr (dwarf_OP (DW_OP_convert), 0, 0);</span>
<span class="lineNum">   14943 </span><span class="lineCov">         25 :       cvt-&gt;dw_loc_oprnd1.val_class = dw_val_class_die_ref;</span>
<span class="lineNum">   14944 </span><span class="lineCov">         25 :       cvt-&gt;dw_loc_oprnd1.v.val_die_ref.die = type_die;</span>
<span class="lineNum">   14945 </span><span class="lineCov">         25 :       cvt-&gt;dw_loc_oprnd1.v.val_die_ref.external = 0;</span>
<span class="lineNum">   14946 </span><span class="lineCov">         25 :       add_loc_descr (&amp;op0, cvt);</span>
<span class="lineNum">   14947 </span><span class="lineCov">         25 :       cvt = new_loc_descr (dwarf_OP (DW_OP_convert), 0, 0);</span>
<span class="lineNum">   14948 </span><span class="lineCov">         25 :       cvt-&gt;dw_loc_oprnd1.val_class = dw_val_class_die_ref;</span>
<span class="lineNum">   14949 </span><span class="lineCov">         25 :       cvt-&gt;dw_loc_oprnd1.v.val_die_ref.die = type_die;</span>
<span class="lineNum">   14950 </span><span class="lineCov">         25 :       cvt-&gt;dw_loc_oprnd1.v.val_die_ref.external = 0;</span>
<span class="lineNum">   14951 </span><span class="lineCov">         25 :       add_loc_descr (&amp;op1, cvt);</span>
<span class="lineNum">   14952 </span>            :     }
<span class="lineNum">   14953 </span>            : 
<span class="lineNum">   14954 </span><span class="lineCov">       8196 :   if (GET_CODE (rtl) == SMIN || GET_CODE (rtl) == UMIN)</span>
<span class="lineNum">   14955 </span>            :     op = DW_OP_lt;
<span class="lineNum">   14956 </span>            :   else
<span class="lineNum">   14957 </span><span class="lineCov">       5821 :     op = DW_OP_gt;</span>
<span class="lineNum">   14958 </span><span class="lineCov">       8196 :   ret = op0;</span>
<span class="lineNum">   14959 </span><span class="lineCov">       8196 :   add_loc_descr (&amp;ret, op1);</span>
<span class="lineNum">   14960 </span><span class="lineCov">       8196 :   add_loc_descr (&amp;ret, new_loc_descr (op, 0, 0));</span>
<span class="lineNum">   14961 </span><span class="lineCov">       8196 :   bra_node = new_loc_descr (DW_OP_bra, 0, 0);</span>
<span class="lineNum">   14962 </span><span class="lineCov">       8196 :   add_loc_descr (&amp;ret, bra_node);</span>
<span class="lineNum">   14963 </span><span class="lineCov">       8196 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_swap, 0, 0));</span>
<span class="lineNum">   14964 </span><span class="lineCov">       8196 :   drop_node = new_loc_descr (DW_OP_drop, 0, 0);</span>
<span class="lineNum">   14965 </span><span class="lineCov">       8196 :   add_loc_descr (&amp;ret, drop_node);</span>
<span class="lineNum">   14966 </span><span class="lineCov">       8196 :   bra_node-&gt;dw_loc_oprnd1.val_class = dw_val_class_loc;</span>
<span class="lineNum">   14967 </span><span class="lineCov">       8196 :   bra_node-&gt;dw_loc_oprnd1.v.val_loc = drop_node;</span>
<span class="lineNum">   14968 </span><span class="lineCov">       8196 :   if ((GET_CODE (rtl) == SMIN || GET_CODE (rtl) == SMAX)</span>
<span class="lineNum">   14969 </span><span class="lineCov">       7321 :       &amp;&amp; is_a &lt;scalar_int_mode&gt; (mode, &amp;int_mode)</span>
<span class="lineNum">   14970 </span><span class="lineCov">      26401 :       &amp;&amp; GET_MODE_SIZE (int_mode) &gt; DWARF2_ADDR_SIZE)</span>
<span class="lineNum">   14971 </span><span class="lineCov">         25 :     ret = convert_descriptor_to_mode (int_mode, ret);</span>
<span class="lineNum">   14972 </span><span class="lineCov">       8196 :   return ret;</span>
<span class="lineNum">   14973 </span>            : }
<span class="lineNum">   14974 </span>            : 
<span class="lineNum">   14975 </span>            : /* Helper function for mem_loc_descriptor.  Perform OP binary op,
<span class="lineNum">   14976 </span>            :    but after converting arguments to type_die, afterwards
<span class="lineNum">   14977 </span>            :    convert back to unsigned.  */
<a name="14978"><span class="lineNum">   14978 </span>            : </a>
<span class="lineNum">   14979 </span>            : static dw_loc_descr_ref
<span class="lineNum">   14980 </span><span class="lineCov">       1558 : typed_binop (enum dwarf_location_atom op, rtx rtl, dw_die_ref type_die,</span>
<span class="lineNum">   14981 </span>            :              scalar_int_mode mode, machine_mode mem_mode)
<span class="lineNum">   14982 </span>            : {
<span class="lineNum">   14983 </span><span class="lineCov">       1558 :   dw_loc_descr_ref cvt, op0, op1;</span>
<span class="lineNum">   14984 </span>            : 
<span class="lineNum">   14985 </span><span class="lineCov">       1558 :   if (type_die == NULL)</span>
<span class="lineNum">   14986 </span>            :     return NULL;
<span class="lineNum">   14987 </span><span class="lineCov">       3116 :   op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,</span>
<span class="lineNum">   14988 </span>            :                             VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   14989 </span><span class="lineCov">       3116 :   op1 = mem_loc_descriptor (XEXP (rtl, 1), mode, mem_mode,</span>
<span class="lineNum">   14990 </span>            :                             VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   14991 </span><span class="lineCov">       1558 :   if (op0 == NULL || op1 == NULL)</span>
<span class="lineNum">   14992 </span>            :     return NULL;
<span class="lineNum">   14993 </span><span class="lineCov">       3116 :   cvt = new_loc_descr (dwarf_OP (DW_OP_convert), 0, 0);</span>
<span class="lineNum">   14994 </span><span class="lineCov">       1558 :   cvt-&gt;dw_loc_oprnd1.val_class = dw_val_class_die_ref;</span>
<span class="lineNum">   14995 </span><span class="lineCov">       1558 :   cvt-&gt;dw_loc_oprnd1.v.val_die_ref.die = type_die;</span>
<span class="lineNum">   14996 </span><span class="lineCov">       1558 :   cvt-&gt;dw_loc_oprnd1.v.val_die_ref.external = 0;</span>
<span class="lineNum">   14997 </span><span class="lineCov">       1558 :   add_loc_descr (&amp;op0, cvt);</span>
<span class="lineNum">   14998 </span><span class="lineCov">       3116 :   cvt = new_loc_descr (dwarf_OP (DW_OP_convert), 0, 0);</span>
<span class="lineNum">   14999 </span><span class="lineCov">       1558 :   cvt-&gt;dw_loc_oprnd1.val_class = dw_val_class_die_ref;</span>
<span class="lineNum">   15000 </span><span class="lineCov">       1558 :   cvt-&gt;dw_loc_oprnd1.v.val_die_ref.die = type_die;</span>
<span class="lineNum">   15001 </span><span class="lineCov">       1558 :   cvt-&gt;dw_loc_oprnd1.v.val_die_ref.external = 0;</span>
<span class="lineNum">   15002 </span><span class="lineCov">       1558 :   add_loc_descr (&amp;op1, cvt);</span>
<span class="lineNum">   15003 </span><span class="lineCov">       1558 :   add_loc_descr (&amp;op0, op1);</span>
<span class="lineNum">   15004 </span><span class="lineCov">       1558 :   add_loc_descr (&amp;op0, new_loc_descr (op, 0, 0));</span>
<span class="lineNum">   15005 </span><span class="lineCov">       1558 :   return convert_descriptor_to_mode (mode, op0);</span>
<span class="lineNum">   15006 </span>            : }
<span class="lineNum">   15007 </span>            : 
<span class="lineNum">   15008 </span>            : /* CLZ (where constV is CLZ_DEFINED_VALUE_AT_ZERO computed value,
<span class="lineNum">   15009 </span>            :    const0 is DW_OP_lit0 or corresponding typed constant,
<span class="lineNum">   15010 </span>            :    const1 is DW_OP_lit1 or corresponding typed constant
<span class="lineNum">   15011 </span>            :    and constMSB is constant with just the MSB bit set
<span class="lineNum">   15012 </span>            :    for the mode):
<span class="lineNum">   15013 </span>            :        DW_OP_dup DW_OP_bra &lt;L1&gt; DW_OP_drop constV DW_OP_skip &lt;L4&gt;
<span class="lineNum">   15014 </span>            :    L1: const0 DW_OP_swap
<span class="lineNum">   15015 </span>            :    L2: DW_OP_dup constMSB DW_OP_and DW_OP_bra &lt;L3&gt; const1 DW_OP_shl
<span class="lineNum">   15016 </span>            :        DW_OP_swap DW_OP_plus_uconst &lt;1&gt; DW_OP_swap DW_OP_skip &lt;L2&gt;
<span class="lineNum">   15017 </span>            :    L3: DW_OP_drop
<span class="lineNum">   15018 </span>            :    L4: DW_OP_nop
<span class="lineNum">   15019 </span>            : 
<span class="lineNum">   15020 </span>            :    CTZ is similar:
<span class="lineNum">   15021 </span>            :        DW_OP_dup DW_OP_bra &lt;L1&gt; DW_OP_drop constV DW_OP_skip &lt;L4&gt;
<span class="lineNum">   15022 </span>            :    L1: const0 DW_OP_swap
<span class="lineNum">   15023 </span>            :    L2: DW_OP_dup const1 DW_OP_and DW_OP_bra &lt;L3&gt; const1 DW_OP_shr
<span class="lineNum">   15024 </span>            :        DW_OP_swap DW_OP_plus_uconst &lt;1&gt; DW_OP_swap DW_OP_skip &lt;L2&gt;
<span class="lineNum">   15025 </span>            :    L3: DW_OP_drop
<span class="lineNum">   15026 </span>            :    L4: DW_OP_nop
<span class="lineNum">   15027 </span>            : 
<span class="lineNum">   15028 </span>            :    FFS is similar:
<span class="lineNum">   15029 </span>            :        DW_OP_dup DW_OP_bra &lt;L1&gt; DW_OP_drop const0 DW_OP_skip &lt;L4&gt;
<span class="lineNum">   15030 </span>            :    L1: const1 DW_OP_swap
<span class="lineNum">   15031 </span>            :    L2: DW_OP_dup const1 DW_OP_and DW_OP_bra &lt;L3&gt; const1 DW_OP_shr
<span class="lineNum">   15032 </span>            :        DW_OP_swap DW_OP_plus_uconst &lt;1&gt; DW_OP_swap DW_OP_skip &lt;L2&gt;
<span class="lineNum">   15033 </span>            :    L3: DW_OP_drop
<span class="lineNum">   15034 </span>            :    L4: DW_OP_nop  */
<a name="15035"><span class="lineNum">   15035 </span>            : </a>
<span class="lineNum">   15036 </span>            : static dw_loc_descr_ref
<span class="lineNum">   15037 </span><span class="lineCov">       1279 : clz_loc_descriptor (rtx rtl, scalar_int_mode mode,</span>
<span class="lineNum">   15038 </span>            :                     machine_mode mem_mode)
<span class="lineNum">   15039 </span>            : {
<span class="lineNum">   15040 </span><span class="lineCov">       1279 :   dw_loc_descr_ref op0, ret, tmp;</span>
<span class="lineNum">   15041 </span><span class="lineCov">       1279 :   HOST_WIDE_INT valv;</span>
<span class="lineNum">   15042 </span><span class="lineCov">       1279 :   dw_loc_descr_ref l1jump, l1label;</span>
<span class="lineNum">   15043 </span><span class="lineCov">       1279 :   dw_loc_descr_ref l2jump, l2label;</span>
<span class="lineNum">   15044 </span><span class="lineCov">       1279 :   dw_loc_descr_ref l3jump, l3label;</span>
<span class="lineNum">   15045 </span><span class="lineCov">       1279 :   dw_loc_descr_ref l4jump, l4label;</span>
<span class="lineNum">   15046 </span><span class="lineCov">       1279 :   rtx msb;</span>
<span class="lineNum">   15047 </span>            : 
<span class="lineNum">   15048 </span><span class="lineCov">       2558 :   if (GET_MODE (XEXP (rtl, 0)) != mode)</span>
<span class="lineNum">   15049 </span>            :     return NULL;
<span class="lineNum">   15050 </span>            : 
<span class="lineNum">   15051 </span><span class="lineCov">       2558 :   op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,</span>
<span class="lineNum">   15052 </span>            :                             VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   15053 </span><span class="lineCov">       1279 :   if (op0 == NULL)</span>
<span class="lineNum">   15054 </span>            :     return NULL;
<span class="lineNum">   15055 </span><span class="lineCov">       1279 :   ret = op0;</span>
<span class="lineNum">   15056 </span><span class="lineCov">       1279 :   if (GET_CODE (rtl) == CLZ)</span>
<span class="lineNum">   15057 </span>            :     {
<span class="lineNum">   15058 </span><span class="lineCov">       2290 :       if (!CLZ_DEFINED_VALUE_AT_ZERO (mode, valv))</span>
<span class="lineNum">   15059 </span><span class="lineCov">       2290 :         valv = GET_MODE_BITSIZE (mode);</span>
<span class="lineNum">   15060 </span>            :     }
<span class="lineNum">   15061 </span><span class="lineCov">        134 :   else if (GET_CODE (rtl) == FFS)</span>
<span class="lineNum">   15062 </span>            :     valv = 0;
<span class="lineNum">   15063 </span><span class="lineCov">        268 :   else if (!CTZ_DEFINED_VALUE_AT_ZERO (mode, valv))</span>
<span class="lineNum">   15064 </span><span class="lineCov">        268 :     valv = GET_MODE_BITSIZE (mode);</span>
<span class="lineNum">   15065 </span><span class="lineCov">       1279 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_dup, 0, 0));</span>
<span class="lineNum">   15066 </span><span class="lineCov">       1279 :   l1jump = new_loc_descr (DW_OP_bra, 0, 0);</span>
<span class="lineNum">   15067 </span><span class="lineCov">       1279 :   add_loc_descr (&amp;ret, l1jump);</span>
<span class="lineNum">   15068 </span><span class="lineCov">       1279 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_drop, 0, 0));</span>
<span class="lineNum">   15069 </span><span class="lineCov">       2558 :   tmp = mem_loc_descriptor (GEN_INT (valv), mode, mem_mode,</span>
<span class="lineNum">   15070 </span>            :                             VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   15071 </span><span class="lineCov">       1279 :   if (tmp == NULL)</span>
<span class="lineNum">   15072 </span>            :     return NULL;
<span class="lineNum">   15073 </span><span class="lineCov">       1279 :   add_loc_descr (&amp;ret, tmp);</span>
<span class="lineNum">   15074 </span><span class="lineCov">       1279 :   l4jump = new_loc_descr (DW_OP_skip, 0, 0);</span>
<span class="lineNum">   15075 </span><span class="lineCov">       1279 :   add_loc_descr (&amp;ret, l4jump);</span>
<span class="lineNum">   15076 </span><span class="lineCov">       2558 :   l1label = mem_loc_descriptor (GET_CODE (rtl) == FFS</span>
<span class="lineNum">   15077 </span>            :                                 ? const1_rtx : const0_rtx,
<span class="lineNum">   15078 </span>            :                                 mode, mem_mode,
<span class="lineNum">   15079 </span>            :                                 VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   15080 </span><span class="lineCov">       1279 :   if (l1label == NULL)</span>
<span class="lineNum">   15081 </span>            :     return NULL;
<span class="lineNum">   15082 </span><span class="lineCov">       1279 :   add_loc_descr (&amp;ret, l1label);</span>
<span class="lineNum">   15083 </span><span class="lineCov">       1279 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_swap, 0, 0));</span>
<span class="lineNum">   15084 </span><span class="lineCov">       1279 :   l2label = new_loc_descr (DW_OP_dup, 0, 0);</span>
<span class="lineNum">   15085 </span><span class="lineCov">       1279 :   add_loc_descr (&amp;ret, l2label);</span>
<span class="lineNum">   15086 </span><span class="lineCov">       1279 :   if (GET_CODE (rtl) != CLZ)</span>
<span class="lineNum">   15087 </span><span class="lineCov">        134 :     msb = const1_rtx;</span>
<span class="lineNum">   15088 </span><span class="lineCov">       2290 :   else if (GET_MODE_BITSIZE (mode) &lt;= HOST_BITS_PER_WIDE_INT)</span>
<span class="lineNum">   15089 </span><span class="lineCov">       2290 :     msb = GEN_INT (HOST_WIDE_INT_1U</span>
<span class="lineNum">   15090 </span>            :                    &lt;&lt; (GET_MODE_BITSIZE (mode) - 1));
<span class="lineNum">   15091 </span>            :   else
<span class="lineNum">   15092 </span><span class="lineNoCov">          0 :     msb = immed_wide_int_const</span>
<span class="lineNum">   15093 </span><span class="lineNoCov">          0 :       (wi::set_bit_in_zero (GET_MODE_PRECISION (mode) - 1,</span>
<span class="lineNum">   15094 </span><span class="lineNoCov">          0 :                             GET_MODE_PRECISION (mode)), mode);</span>
<span class="lineNum">   15095 </span><span class="lineCov">       1279 :   if (GET_CODE (msb) == CONST_INT &amp;&amp; INTVAL (msb) &lt; 0)</span>
<span class="lineNum">   15096 </span><span class="lineCov">        993 :     tmp = new_loc_descr (HOST_BITS_PER_WIDE_INT == 32</span>
<span class="lineNum">   15097 </span>            :                          ? DW_OP_const4u : HOST_BITS_PER_WIDE_INT == 64
<span class="lineNum">   15098 </span>            :                          ? DW_OP_const8u : DW_OP_constu, INTVAL (msb), 0);
<span class="lineNum">   15099 </span>            :   else
<span class="lineNum">   15100 </span><span class="lineCov">        572 :     tmp = mem_loc_descriptor (msb, mode, mem_mode,</span>
<span class="lineNum">   15101 </span>            :                               VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   15102 </span><span class="lineCov">       1279 :   if (tmp == NULL)</span>
<span class="lineNum">   15103 </span>            :     return NULL;
<span class="lineNum">   15104 </span><span class="lineCov">       1279 :   add_loc_descr (&amp;ret, tmp);</span>
<span class="lineNum">   15105 </span><span class="lineCov">       1279 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_and, 0, 0));</span>
<span class="lineNum">   15106 </span><span class="lineCov">       1279 :   l3jump = new_loc_descr (DW_OP_bra, 0, 0);</span>
<span class="lineNum">   15107 </span><span class="lineCov">       1279 :   add_loc_descr (&amp;ret, l3jump);</span>
<span class="lineNum">   15108 </span><span class="lineCov">       2558 :   tmp = mem_loc_descriptor (const1_rtx, mode, mem_mode,</span>
<span class="lineNum">   15109 </span>            :                             VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   15110 </span><span class="lineCov">       1279 :   if (tmp == NULL)</span>
<span class="lineNum">   15111 </span>            :     return NULL;
<span class="lineNum">   15112 </span><span class="lineCov">       1279 :   add_loc_descr (&amp;ret, tmp);</span>
<span class="lineNum">   15113 </span><span class="lineCov">       1413 :   add_loc_descr (&amp;ret, new_loc_descr (GET_CODE (rtl) == CLZ</span>
<span class="lineNum">   15114 </span>            :                                       ? DW_OP_shl : DW_OP_shr, 0, 0));
<span class="lineNum">   15115 </span><span class="lineCov">       1279 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_swap, 0, 0));</span>
<span class="lineNum">   15116 </span><span class="lineCov">       1279 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_plus_uconst, 1, 0));</span>
<span class="lineNum">   15117 </span><span class="lineCov">       1279 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_swap, 0, 0));</span>
<span class="lineNum">   15118 </span><span class="lineCov">       1279 :   l2jump = new_loc_descr (DW_OP_skip, 0, 0);</span>
<span class="lineNum">   15119 </span><span class="lineCov">       1279 :   add_loc_descr (&amp;ret, l2jump);</span>
<span class="lineNum">   15120 </span><span class="lineCov">       1279 :   l3label = new_loc_descr (DW_OP_drop, 0, 0);</span>
<span class="lineNum">   15121 </span><span class="lineCov">       1279 :   add_loc_descr (&amp;ret, l3label);</span>
<span class="lineNum">   15122 </span><span class="lineCov">       1279 :   l4label = new_loc_descr (DW_OP_nop, 0, 0);</span>
<span class="lineNum">   15123 </span><span class="lineCov">       1279 :   add_loc_descr (&amp;ret, l4label);</span>
<span class="lineNum">   15124 </span><span class="lineCov">       1279 :   l1jump-&gt;dw_loc_oprnd1.val_class = dw_val_class_loc;</span>
<span class="lineNum">   15125 </span><span class="lineCov">       1279 :   l1jump-&gt;dw_loc_oprnd1.v.val_loc = l1label;</span>
<span class="lineNum">   15126 </span><span class="lineCov">       1279 :   l2jump-&gt;dw_loc_oprnd1.val_class = dw_val_class_loc;</span>
<span class="lineNum">   15127 </span><span class="lineCov">       1279 :   l2jump-&gt;dw_loc_oprnd1.v.val_loc = l2label;</span>
<span class="lineNum">   15128 </span><span class="lineCov">       1279 :   l3jump-&gt;dw_loc_oprnd1.val_class = dw_val_class_loc;</span>
<span class="lineNum">   15129 </span><span class="lineCov">       1279 :   l3jump-&gt;dw_loc_oprnd1.v.val_loc = l3label;</span>
<span class="lineNum">   15130 </span><span class="lineCov">       1279 :   l4jump-&gt;dw_loc_oprnd1.val_class = dw_val_class_loc;</span>
<span class="lineNum">   15131 </span><span class="lineCov">       1279 :   l4jump-&gt;dw_loc_oprnd1.v.val_loc = l4label;</span>
<span class="lineNum">   15132 </span><span class="lineCov">       1279 :   return ret;</span>
<span class="lineNum">   15133 </span>            : }
<span class="lineNum">   15134 </span>            : 
<span class="lineNum">   15135 </span>            : /* POPCOUNT (const0 is DW_OP_lit0 or corresponding typed constant,
<span class="lineNum">   15136 </span>            :    const1 is DW_OP_lit1 or corresponding typed constant):
<span class="lineNum">   15137 </span>            :        const0 DW_OP_swap
<span class="lineNum">   15138 </span>            :    L1: DW_OP_dup DW_OP_bra &lt;L2&gt; DW_OP_dup DW_OP_rot const1 DW_OP_and
<span class="lineNum">   15139 </span>            :        DW_OP_plus DW_OP_swap const1 DW_OP_shr DW_OP_skip &lt;L1&gt;
<span class="lineNum">   15140 </span>            :    L2: DW_OP_drop
<span class="lineNum">   15141 </span>            : 
<span class="lineNum">   15142 </span>            :    PARITY is similar:
<span class="lineNum">   15143 </span>            :    L1: DW_OP_dup DW_OP_bra &lt;L2&gt; DW_OP_dup DW_OP_rot const1 DW_OP_and
<span class="lineNum">   15144 </span>            :        DW_OP_xor DW_OP_swap const1 DW_OP_shr DW_OP_skip &lt;L1&gt;
<span class="lineNum">   15145 </span>            :    L2: DW_OP_drop  */
<a name="15146"><span class="lineNum">   15146 </span>            : </a>
<span class="lineNum">   15147 </span>            : static dw_loc_descr_ref
<span class="lineNum">   15148 </span><span class="lineNoCov">          0 : popcount_loc_descriptor (rtx rtl, scalar_int_mode mode,</span>
<span class="lineNum">   15149 </span>            :                          machine_mode mem_mode)
<span class="lineNum">   15150 </span>            : {
<span class="lineNum">   15151 </span><span class="lineNoCov">          0 :   dw_loc_descr_ref op0, ret, tmp;</span>
<span class="lineNum">   15152 </span><span class="lineNoCov">          0 :   dw_loc_descr_ref l1jump, l1label;</span>
<span class="lineNum">   15153 </span><span class="lineNoCov">          0 :   dw_loc_descr_ref l2jump, l2label;</span>
<span class="lineNum">   15154 </span>            : 
<span class="lineNum">   15155 </span><span class="lineNoCov">          0 :   if (GET_MODE (XEXP (rtl, 0)) != mode)</span>
<span class="lineNum">   15156 </span>            :     return NULL;
<span class="lineNum">   15157 </span>            : 
<span class="lineNum">   15158 </span><span class="lineNoCov">          0 :   op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,</span>
<span class="lineNum">   15159 </span>            :                             VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   15160 </span><span class="lineNoCov">          0 :   if (op0 == NULL)</span>
<span class="lineNum">   15161 </span>            :     return NULL;
<span class="lineNum">   15162 </span><span class="lineNoCov">          0 :   ret = op0;</span>
<span class="lineNum">   15163 </span><span class="lineNoCov">          0 :   tmp = mem_loc_descriptor (const0_rtx, mode, mem_mode,</span>
<span class="lineNum">   15164 </span>            :                             VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   15165 </span><span class="lineNoCov">          0 :   if (tmp == NULL)</span>
<span class="lineNum">   15166 </span>            :     return NULL;
<span class="lineNum">   15167 </span><span class="lineNoCov">          0 :   add_loc_descr (&amp;ret, tmp);</span>
<span class="lineNum">   15168 </span><span class="lineNoCov">          0 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_swap, 0, 0));</span>
<span class="lineNum">   15169 </span><span class="lineNoCov">          0 :   l1label = new_loc_descr (DW_OP_dup, 0, 0);</span>
<span class="lineNum">   15170 </span><span class="lineNoCov">          0 :   add_loc_descr (&amp;ret, l1label);</span>
<span class="lineNum">   15171 </span><span class="lineNoCov">          0 :   l2jump = new_loc_descr (DW_OP_bra, 0, 0);</span>
<span class="lineNum">   15172 </span><span class="lineNoCov">          0 :   add_loc_descr (&amp;ret, l2jump);</span>
<span class="lineNum">   15173 </span><span class="lineNoCov">          0 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_dup, 0, 0));</span>
<span class="lineNum">   15174 </span><span class="lineNoCov">          0 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_rot, 0, 0));</span>
<span class="lineNum">   15175 </span><span class="lineNoCov">          0 :   tmp = mem_loc_descriptor (const1_rtx, mode, mem_mode,</span>
<span class="lineNum">   15176 </span>            :                             VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   15177 </span><span class="lineNoCov">          0 :   if (tmp == NULL)</span>
<span class="lineNum">   15178 </span>            :     return NULL;
<span class="lineNum">   15179 </span><span class="lineNoCov">          0 :   add_loc_descr (&amp;ret, tmp);</span>
<span class="lineNum">   15180 </span><span class="lineNoCov">          0 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_and, 0, 0));</span>
<span class="lineNum">   15181 </span><span class="lineNoCov">          0 :   add_loc_descr (&amp;ret, new_loc_descr (GET_CODE (rtl) == POPCOUNT</span>
<span class="lineNum">   15182 </span>            :                                       ? DW_OP_plus : DW_OP_xor, 0, 0));
<span class="lineNum">   15183 </span><span class="lineNoCov">          0 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_swap, 0, 0));</span>
<span class="lineNum">   15184 </span><span class="lineNoCov">          0 :   tmp = mem_loc_descriptor (const1_rtx, mode, mem_mode,</span>
<span class="lineNum">   15185 </span>            :                             VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   15186 </span><span class="lineNoCov">          0 :   add_loc_descr (&amp;ret, tmp);</span>
<span class="lineNum">   15187 </span><span class="lineNoCov">          0 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_shr, 0, 0));</span>
<span class="lineNum">   15188 </span><span class="lineNoCov">          0 :   l1jump = new_loc_descr (DW_OP_skip, 0, 0);</span>
<span class="lineNum">   15189 </span><span class="lineNoCov">          0 :   add_loc_descr (&amp;ret, l1jump);</span>
<span class="lineNum">   15190 </span><span class="lineNoCov">          0 :   l2label = new_loc_descr (DW_OP_drop, 0, 0);</span>
<span class="lineNum">   15191 </span><span class="lineNoCov">          0 :   add_loc_descr (&amp;ret, l2label);</span>
<span class="lineNum">   15192 </span><span class="lineNoCov">          0 :   l1jump-&gt;dw_loc_oprnd1.val_class = dw_val_class_loc;</span>
<span class="lineNum">   15193 </span><span class="lineNoCov">          0 :   l1jump-&gt;dw_loc_oprnd1.v.val_loc = l1label;</span>
<span class="lineNum">   15194 </span><span class="lineNoCov">          0 :   l2jump-&gt;dw_loc_oprnd1.val_class = dw_val_class_loc;</span>
<span class="lineNum">   15195 </span><span class="lineNoCov">          0 :   l2jump-&gt;dw_loc_oprnd1.v.val_loc = l2label;</span>
<span class="lineNum">   15196 </span><span class="lineNoCov">          0 :   return ret;</span>
<span class="lineNum">   15197 </span>            : }
<span class="lineNum">   15198 </span>            : 
<span class="lineNum">   15199 </span>            : /* BSWAP (constS is initial shift count, either 56 or 24):
<span class="lineNum">   15200 </span>            :        constS const0
<span class="lineNum">   15201 </span>            :    L1: DW_OP_pick &lt;2&gt; constS DW_OP_pick &lt;3&gt; DW_OP_minus DW_OP_shr
<span class="lineNum">   15202 </span>            :        const255 DW_OP_and DW_OP_pick &lt;2&gt; DW_OP_shl DW_OP_or
<span class="lineNum">   15203 </span>            :        DW_OP_swap DW_OP_dup const0 DW_OP_eq DW_OP_bra &lt;L2&gt; const8
<span class="lineNum">   15204 </span>            :        DW_OP_minus DW_OP_swap DW_OP_skip &lt;L1&gt;
<span class="lineNum">   15205 </span>            :    L2: DW_OP_drop DW_OP_swap DW_OP_drop  */
<a name="15206"><span class="lineNum">   15206 </span>            : </a>
<span class="lineNum">   15207 </span>            : static dw_loc_descr_ref
<span class="lineNum">   15208 </span><span class="lineCov">         69 : bswap_loc_descriptor (rtx rtl, scalar_int_mode mode,</span>
<span class="lineNum">   15209 </span>            :                       machine_mode mem_mode)
<span class="lineNum">   15210 </span>            : {
<span class="lineNum">   15211 </span><span class="lineCov">         69 :   dw_loc_descr_ref op0, ret, tmp;</span>
<span class="lineNum">   15212 </span><span class="lineCov">         69 :   dw_loc_descr_ref l1jump, l1label;</span>
<span class="lineNum">   15213 </span><span class="lineCov">         69 :   dw_loc_descr_ref l2jump, l2label;</span>
<span class="lineNum">   15214 </span>            : 
<span class="lineNum">   15215 </span><span class="lineCov">         69 :   if (BITS_PER_UNIT != 8</span>
<span class="lineNum">   15216 </span><span class="lineCov">         69 :       || (GET_MODE_BITSIZE (mode) != 32</span>
<span class="lineNum">   15217 </span><span class="lineCov">         76 :           &amp;&amp; GET_MODE_BITSIZE (mode) != 64))</span>
<span class="lineNum">   15218 </span>            :     return NULL;
<span class="lineNum">   15219 </span>            : 
<span class="lineNum">   15220 </span><span class="lineCov">        138 :   op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,</span>
<span class="lineNum">   15221 </span>            :                             VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   15222 </span><span class="lineCov">         69 :   if (op0 == NULL)</span>
<span class="lineNum">   15223 </span>            :     return NULL;
<span class="lineNum">   15224 </span>            : 
<span class="lineNum">   15225 </span><span class="lineCov">         69 :   ret = op0;</span>
<span class="lineNum">   15226 </span><span class="lineCov">        207 :   tmp = mem_loc_descriptor (GEN_INT (GET_MODE_BITSIZE (mode) - 8),</span>
<span class="lineNum">   15227 </span>            :                             mode, mem_mode,
<span class="lineNum">   15228 </span>            :                             VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   15229 </span><span class="lineCov">         69 :   if (tmp == NULL)</span>
<span class="lineNum">   15230 </span>            :     return NULL;
<span class="lineNum">   15231 </span><span class="lineCov">         69 :   add_loc_descr (&amp;ret, tmp);</span>
<span class="lineNum">   15232 </span><span class="lineCov">        138 :   tmp = mem_loc_descriptor (const0_rtx, mode, mem_mode,</span>
<span class="lineNum">   15233 </span>            :                             VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   15234 </span><span class="lineCov">         69 :   if (tmp == NULL)</span>
<span class="lineNum">   15235 </span>            :     return NULL;
<span class="lineNum">   15236 </span><span class="lineCov">         69 :   add_loc_descr (&amp;ret, tmp);</span>
<span class="lineNum">   15237 </span><span class="lineCov">         69 :   l1label = new_loc_descr (DW_OP_pick, 2, 0);</span>
<span class="lineNum">   15238 </span><span class="lineCov">         69 :   add_loc_descr (&amp;ret, l1label);</span>
<span class="lineNum">   15239 </span><span class="lineCov">        207 :   tmp = mem_loc_descriptor (GEN_INT (GET_MODE_BITSIZE (mode) - 8),</span>
<span class="lineNum">   15240 </span>            :                             mode, mem_mode,
<span class="lineNum">   15241 </span>            :                             VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   15242 </span><span class="lineCov">         69 :   add_loc_descr (&amp;ret, tmp);</span>
<span class="lineNum">   15243 </span><span class="lineCov">         69 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_pick, 3, 0));</span>
<span class="lineNum">   15244 </span><span class="lineCov">         69 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_minus, 0, 0));</span>
<span class="lineNum">   15245 </span><span class="lineCov">         69 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_shr, 0, 0));</span>
<span class="lineNum">   15246 </span><span class="lineCov">        138 :   tmp = mem_loc_descriptor (GEN_INT (255), mode, mem_mode,</span>
<span class="lineNum">   15247 </span>            :                             VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   15248 </span><span class="lineCov">         69 :   if (tmp == NULL)</span>
<span class="lineNum">   15249 </span>            :     return NULL;
<span class="lineNum">   15250 </span><span class="lineCov">         69 :   add_loc_descr (&amp;ret, tmp);</span>
<span class="lineNum">   15251 </span><span class="lineCov">         69 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_and, 0, 0));</span>
<span class="lineNum">   15252 </span><span class="lineCov">         69 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_pick, 2, 0));</span>
<span class="lineNum">   15253 </span><span class="lineCov">         69 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_shl, 0, 0));</span>
<span class="lineNum">   15254 </span><span class="lineCov">         69 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_or, 0, 0));</span>
<span class="lineNum">   15255 </span><span class="lineCov">         69 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_swap, 0, 0));</span>
<span class="lineNum">   15256 </span><span class="lineCov">         69 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_dup, 0, 0));</span>
<span class="lineNum">   15257 </span><span class="lineCov">         69 :   tmp = mem_loc_descriptor (const0_rtx, mode, mem_mode,</span>
<span class="lineNum">   15258 </span>            :                             VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   15259 </span><span class="lineCov">         69 :   add_loc_descr (&amp;ret, tmp);</span>
<span class="lineNum">   15260 </span><span class="lineCov">         69 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_eq, 0, 0));</span>
<span class="lineNum">   15261 </span><span class="lineCov">         69 :   l2jump = new_loc_descr (DW_OP_bra, 0, 0);</span>
<span class="lineNum">   15262 </span><span class="lineCov">         69 :   add_loc_descr (&amp;ret, l2jump);</span>
<span class="lineNum">   15263 </span><span class="lineCov">        138 :   tmp = mem_loc_descriptor (GEN_INT (8), mode, mem_mode,</span>
<span class="lineNum">   15264 </span>            :                             VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   15265 </span><span class="lineCov">         69 :   add_loc_descr (&amp;ret, tmp);</span>
<span class="lineNum">   15266 </span><span class="lineCov">         69 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_minus, 0, 0));</span>
<span class="lineNum">   15267 </span><span class="lineCov">         69 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_swap, 0, 0));</span>
<span class="lineNum">   15268 </span><span class="lineCov">         69 :   l1jump = new_loc_descr (DW_OP_skip, 0, 0);</span>
<span class="lineNum">   15269 </span><span class="lineCov">         69 :   add_loc_descr (&amp;ret, l1jump);</span>
<span class="lineNum">   15270 </span><span class="lineCov">         69 :   l2label = new_loc_descr (DW_OP_drop, 0, 0);</span>
<span class="lineNum">   15271 </span><span class="lineCov">         69 :   add_loc_descr (&amp;ret, l2label);</span>
<span class="lineNum">   15272 </span><span class="lineCov">         69 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_swap, 0, 0));</span>
<span class="lineNum">   15273 </span><span class="lineCov">         69 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_drop, 0, 0));</span>
<span class="lineNum">   15274 </span><span class="lineCov">         69 :   l1jump-&gt;dw_loc_oprnd1.val_class = dw_val_class_loc;</span>
<span class="lineNum">   15275 </span><span class="lineCov">         69 :   l1jump-&gt;dw_loc_oprnd1.v.val_loc = l1label;</span>
<span class="lineNum">   15276 </span><span class="lineCov">         69 :   l2jump-&gt;dw_loc_oprnd1.val_class = dw_val_class_loc;</span>
<span class="lineNum">   15277 </span><span class="lineCov">         69 :   l2jump-&gt;dw_loc_oprnd1.v.val_loc = l2label;</span>
<span class="lineNum">   15278 </span><span class="lineCov">         69 :   return ret;</span>
<span class="lineNum">   15279 </span>            : }
<span class="lineNum">   15280 </span>            : 
<span class="lineNum">   15281 </span>            : /* ROTATE (constMASK is mode mask, BITSIZE is bitsize of mode):
<span class="lineNum">   15282 </span>            :    DW_OP_over DW_OP_over DW_OP_shl [ constMASK DW_OP_and ] DW_OP_rot
<span class="lineNum">   15283 </span>            :    [ DW_OP_swap constMASK DW_OP_and DW_OP_swap ] DW_OP_neg
<span class="lineNum">   15284 </span>            :    DW_OP_plus_uconst &lt;BITSIZE&gt; DW_OP_shr DW_OP_or
<span class="lineNum">   15285 </span>            : 
<span class="lineNum">   15286 </span>            :    ROTATERT is similar:
<span class="lineNum">   15287 </span>            :    DW_OP_over DW_OP_over DW_OP_neg DW_OP_plus_uconst &lt;BITSIZE&gt;
<span class="lineNum">   15288 </span>            :    DW_OP_shl [ constMASK DW_OP_and ] DW_OP_rot
<span class="lineNum">   15289 </span>            :    [ DW_OP_swap constMASK DW_OP_and DW_OP_swap ] DW_OP_shr DW_OP_or  */
<a name="15290"><span class="lineNum">   15290 </span>            : </a>
<span class="lineNum">   15291 </span>            : static dw_loc_descr_ref
<span class="lineNum">   15292 </span><span class="lineCov">       1973 : rotate_loc_descriptor (rtx rtl, scalar_int_mode mode,</span>
<span class="lineNum">   15293 </span>            :                        machine_mode mem_mode)
<span class="lineNum">   15294 </span>            : {
<span class="lineNum">   15295 </span><span class="lineCov">       1973 :   rtx rtlop1 = XEXP (rtl, 1);</span>
<span class="lineNum">   15296 </span><span class="lineCov">       1973 :   dw_loc_descr_ref op0, op1, ret, mask[2] = { NULL, NULL };</span>
<span class="lineNum">   15297 </span><span class="lineCov">       1973 :   int i;</span>
<span class="lineNum">   15298 </span>            : 
<span class="lineNum">   15299 </span><span class="lineCov">       1973 :   if (is_narrower_int_mode (GET_MODE (rtlop1), mode))</span>
<span class="lineNum">   15300 </span><span class="lineCov">        108 :     rtlop1 = gen_rtx_ZERO_EXTEND (mode, rtlop1);</span>
<span class="lineNum">   15301 </span><span class="lineCov">       3946 :   op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,</span>
<span class="lineNum">   15302 </span>            :                             VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   15303 </span><span class="lineCov">       3946 :   op1 = mem_loc_descriptor (rtlop1, mode, mem_mode,</span>
<span class="lineNum">   15304 </span>            :                             VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   15305 </span><span class="lineCov">       1973 :   if (op0 == NULL || op1 == NULL)</span>
<span class="lineNum">   15306 </span>            :     return NULL;
<span class="lineNum">   15307 </span><span class="lineCov">       4965 :   if (GET_MODE_SIZE (mode) &lt; DWARF2_ADDR_SIZE)</span>
<span class="lineNum">   15308 </span><span class="lineCov">       2334 :     for (i = 0; i &lt; 2; i++)</span>
<span class="lineNum">   15309 </span>            :       {
<span class="lineNum">   15310 </span><span class="lineCov">       3112 :         if (GET_MODE_BITSIZE (mode) &lt; HOST_BITS_PER_WIDE_INT)</span>
<span class="lineNum">   15311 </span><span class="lineCov">       4668 :           mask[i] = mem_loc_descriptor (GEN_INT (GET_MODE_MASK (mode)),</span>
<span class="lineNum">   15312 </span>            :                                         mode, mem_mode,
<span class="lineNum">   15313 </span>            :                                         VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   15314 </span><span class="lineNoCov">          0 :         else if (GET_MODE_BITSIZE (mode) == HOST_BITS_PER_WIDE_INT)</span>
<span class="lineNum">   15315 </span><span class="lineNoCov">          0 :           mask[i] = new_loc_descr (HOST_BITS_PER_WIDE_INT == 32</span>
<span class="lineNum">   15316 </span>            :                                    ? DW_OP_const4u
<span class="lineNum">   15317 </span>            :                                    : HOST_BITS_PER_WIDE_INT == 64
<span class="lineNum">   15318 </span>            :                                    ? DW_OP_const8u : DW_OP_constu,
<span class="lineNum">   15319 </span><span class="lineNoCov">          0 :                                    GET_MODE_MASK (mode), 0);</span>
<span class="lineNum">   15320 </span>            :         else
<span class="lineNum">   15321 </span><span class="lineNoCov">          0 :           mask[i] = NULL;</span>
<span class="lineNum">   15322 </span><span class="lineCov">       1556 :         if (mask[i] == NULL)</span>
<span class="lineNum">   15323 </span>            :           return NULL;
<span class="lineNum">   15324 </span><span class="lineCov">       1556 :         add_loc_descr (&amp;mask[i], new_loc_descr (DW_OP_and, 0, 0));</span>
<span class="lineNum">   15325 </span>            :       }
<span class="lineNum">   15326 </span><span class="lineCov">       1967 :   ret = op0;</span>
<span class="lineNum">   15327 </span><span class="lineCov">       1967 :   add_loc_descr (&amp;ret, op1);</span>
<span class="lineNum">   15328 </span><span class="lineCov">       1967 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_over, 0, 0));</span>
<span class="lineNum">   15329 </span><span class="lineCov">       1967 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_over, 0, 0));</span>
<span class="lineNum">   15330 </span><span class="lineCov">       1967 :   if (GET_CODE (rtl) == ROTATERT)</span>
<span class="lineNum">   15331 </span>            :     {
<span class="lineNum">   15332 </span><span class="lineCov">        405 :       add_loc_descr (&amp;ret, new_loc_descr (DW_OP_neg, 0, 0));</span>
<span class="lineNum">   15333 </span><span class="lineCov">        405 :       add_loc_descr (&amp;ret, new_loc_descr (DW_OP_plus_uconst,</span>
<span class="lineNum">   15334 </span><span class="lineCov">        810 :                                           GET_MODE_BITSIZE (mode), 0));</span>
<span class="lineNum">   15335 </span>            :     }
<span class="lineNum">   15336 </span><span class="lineCov">       1967 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_shl, 0, 0));</span>
<span class="lineNum">   15337 </span><span class="lineCov">       1967 :   if (mask[0] != NULL)</span>
<span class="lineNum">   15338 </span><span class="lineCov">        778 :     add_loc_descr (&amp;ret, mask[0]);</span>
<span class="lineNum">   15339 </span><span class="lineCov">       1967 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_rot, 0, 0));</span>
<span class="lineNum">   15340 </span><span class="lineCov">       1967 :   if (mask[1] != NULL)</span>
<span class="lineNum">   15341 </span>            :     {
<span class="lineNum">   15342 </span><span class="lineCov">        778 :       add_loc_descr (&amp;ret, new_loc_descr (DW_OP_swap, 0, 0));</span>
<span class="lineNum">   15343 </span><span class="lineCov">        778 :       add_loc_descr (&amp;ret, mask[1]);</span>
<span class="lineNum">   15344 </span><span class="lineCov">        778 :       add_loc_descr (&amp;ret, new_loc_descr (DW_OP_swap, 0, 0));</span>
<span class="lineNum">   15345 </span>            :     }
<span class="lineNum">   15346 </span><span class="lineCov">       1967 :   if (GET_CODE (rtl) == ROTATE)</span>
<span class="lineNum">   15347 </span>            :     {
<span class="lineNum">   15348 </span><span class="lineCov">       1562 :       add_loc_descr (&amp;ret, new_loc_descr (DW_OP_neg, 0, 0));</span>
<span class="lineNum">   15349 </span><span class="lineCov">       1562 :       add_loc_descr (&amp;ret, new_loc_descr (DW_OP_plus_uconst,</span>
<span class="lineNum">   15350 </span><span class="lineCov">       3124 :                                           GET_MODE_BITSIZE (mode), 0));</span>
<span class="lineNum">   15351 </span>            :     }
<span class="lineNum">   15352 </span><span class="lineCov">       1967 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_shr, 0, 0));</span>
<span class="lineNum">   15353 </span><span class="lineCov">       1967 :   add_loc_descr (&amp;ret, new_loc_descr (DW_OP_or, 0, 0));</span>
<span class="lineNum">   15354 </span><span class="lineCov">       1967 :   return ret;</span>
<span class="lineNum">   15355 </span>            : }
<span class="lineNum">   15356 </span>            : 
<span class="lineNum">   15357 </span>            : /* Helper function for mem_loc_descriptor.  Return DW_OP_GNU_parameter_ref
<span class="lineNum">   15358 </span>            :    for DEBUG_PARAMETER_REF RTL.  */
<a name="15359"><span class="lineNum">   15359 </span>            : </a>
<span class="lineNum">   15360 </span>            : static dw_loc_descr_ref
<span class="lineNum">   15361 </span><span class="lineCov">       4914 : parameter_ref_descriptor (rtx rtl)</span>
<span class="lineNum">   15362 </span>            : {
<span class="lineNum">   15363 </span><span class="lineCov">       4914 :   dw_loc_descr_ref ret;</span>
<span class="lineNum">   15364 </span><span class="lineCov">       4914 :   dw_die_ref ref;</span>
<span class="lineNum">   15365 </span>            : 
<span class="lineNum">   15366 </span><span class="lineCov">       4914 :   if (dwarf_strict)</span>
<span class="lineNum">   15367 </span>            :     return NULL;
<span class="lineNum">   15368 </span><span class="lineCov">       4914 :   gcc_assert (TREE_CODE (DEBUG_PARAMETER_REF_DECL (rtl)) == PARM_DECL);</span>
<span class="lineNum">   15369 </span>            :   /* With LTO during LTRANS we get the late DIE that refers to the early
<span class="lineNum">   15370 </span>            :      DIE, thus we add another indirection here.  This seems to confuse
<span class="lineNum">   15371 </span>            :      gdb enough to make gcc.dg/guality/pr68860-1.c FAIL with LTO.  */
<span class="lineNum">   15372 </span><span class="lineCov">       4914 :   ref = lookup_decl_die (DEBUG_PARAMETER_REF_DECL (rtl));</span>
<span class="lineNum">   15373 </span><span class="lineCov">       4914 :   ret = new_loc_descr (DW_OP_GNU_parameter_ref, 0, 0);</span>
<span class="lineNum">   15374 </span><span class="lineCov">       4914 :   if (ref)</span>
<span class="lineNum">   15375 </span>            :     {
<span class="lineNum">   15376 </span><span class="lineCov">       4914 :       ret-&gt;dw_loc_oprnd1.val_class = dw_val_class_die_ref;</span>
<span class="lineNum">   15377 </span><span class="lineCov">       4914 :       ret-&gt;dw_loc_oprnd1.v.val_die_ref.die = ref;</span>
<span class="lineNum">   15378 </span><span class="lineCov">       4914 :       ret-&gt;dw_loc_oprnd1.v.val_die_ref.external = 0;</span>
<span class="lineNum">   15379 </span>            :     }
<span class="lineNum">   15380 </span>            :   else
<span class="lineNum">   15381 </span>            :     {
<span class="lineNum">   15382 </span><span class="lineNoCov">          0 :       ret-&gt;dw_loc_oprnd1.val_class = dw_val_class_decl_ref;</span>
<span class="lineNum">   15383 </span><span class="lineNoCov">          0 :       ret-&gt;dw_loc_oprnd1.v.val_decl_ref = DEBUG_PARAMETER_REF_DECL (rtl);</span>
<span class="lineNum">   15384 </span>            :     }
<span class="lineNum">   15385 </span>            :   return ret;
<span class="lineNum">   15386 </span>            : }
<span class="lineNum">   15387 </span>            : 
<span class="lineNum">   15388 </span>            : /* The following routine converts the RTL for a variable or parameter
<span class="lineNum">   15389 </span>            :    (resident in memory) into an equivalent Dwarf representation of a
<span class="lineNum">   15390 </span>            :    mechanism for getting the address of that same variable onto the top of a
<span class="lineNum">   15391 </span>            :    hypothetical &quot;address evaluation&quot; stack.
<span class="lineNum">   15392 </span>            : 
<span class="lineNum">   15393 </span>            :    When creating memory location descriptors, we are effectively transforming
<span class="lineNum">   15394 </span>            :    the RTL for a memory-resident object into its Dwarf postfix expression
<span class="lineNum">   15395 </span>            :    equivalent.  This routine recursively descends an RTL tree, turning
<span class="lineNum">   15396 </span>            :    it into Dwarf postfix code as it goes.
<span class="lineNum">   15397 </span>            : 
<span class="lineNum">   15398 </span>            :    MODE is the mode that should be assumed for the rtl if it is VOIDmode.
<span class="lineNum">   15399 </span>            : 
<span class="lineNum">   15400 </span>            :    MEM_MODE is the mode of the memory reference, needed to handle some
<span class="lineNum">   15401 </span>            :    autoincrement addressing modes.
<span class="lineNum">   15402 </span>            : 
<span class="lineNum">   15403 </span>            :    Return 0 if we can't represent the location.  */
<a name="15404"><span class="lineNum">   15404 </span>            : </a>
<span class="lineNum">   15405 </span>            : dw_loc_descr_ref
<span class="lineNum">   15406 </span><span class="lineCov">   13878921 : mem_loc_descriptor (rtx rtl, machine_mode mode,</span>
<span class="lineNum">   15407 </span>            :                     machine_mode mem_mode,
<span class="lineNum">   15408 </span>            :                     enum var_init_status initialized)
<span class="lineNum">   15409 </span>            : {
<span class="lineNum">   15410 </span><span class="lineCov">   13878921 :   dw_loc_descr_ref mem_loc_result = NULL;</span>
<span class="lineNum">   15411 </span><span class="lineCov">   13878921 :   enum dwarf_location_atom op;</span>
<span class="lineNum">   15412 </span><span class="lineCov">   13878921 :   dw_loc_descr_ref op0, op1;</span>
<span class="lineNum">   15413 </span><span class="lineCov">   13878921 :   rtx inner = NULL_RTX;</span>
<span class="lineNum">   15414 </span><span class="lineCov">   13878921 :   poly_int64 offset;</span>
<span class="lineNum">   15415 </span>            : 
<span class="lineNum">   15416 </span><span class="lineCov">   13878921 :   if (mode == VOIDmode)</span>
<span class="lineNum">   15417 </span><span class="lineCov">         93 :     mode = GET_MODE (rtl);</span>
<span class="lineNum">   15418 </span>            : 
<span class="lineNum">   15419 </span>            :   /* Note that for a dynamically sized array, the location we will generate a
<span class="lineNum">   15420 </span>            :      description of here will be the lowest numbered location which is
<span class="lineNum">   15421 </span>            :      actually within the array.  That's *not* necessarily the same as the
<span class="lineNum">   15422 </span>            :      zeroth element of the array.  */
<span class="lineNum">   15423 </span>            : 
<span class="lineNum">   15424 </span><span class="lineCov">   13878921 :   rtl = targetm.delegitimize_address (rtl);</span>
<span class="lineNum">   15425 </span>            : 
<span class="lineNum">   15426 </span><span class="lineCov">   13878921 :   if (mode != GET_MODE (rtl) &amp;&amp; GET_MODE (rtl) != VOIDmode)</span>
<span class="lineNum">   15427 </span>            :     return NULL;
<span class="lineNum">   15428 </span>            : 
<span class="lineNum">   15429 </span><span class="lineCov">   41636763 :   scalar_int_mode int_mode, inner_mode, op1_mode;</span>
<span class="lineNum">   15430 </span><span class="lineCov">   13878921 :   switch (GET_CODE (rtl))</span>
<span class="lineNum">   15431 </span>            :     {
<span class="lineNum">   15432 </span><span class="lineNoCov">          0 :     case POST_INC:</span>
<span class="lineNum">   15433 </span><span class="lineNoCov">          0 :     case POST_DEC:</span>
<span class="lineNum">   15434 </span><span class="lineNoCov">          0 :     case POST_MODIFY:</span>
<span class="lineNum">   15435 </span><span class="lineNoCov">          0 :       return mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode, initialized);</span>
<span class="lineNum">   15436 </span>            : 
<span class="lineNum">   15437 </span><span class="lineCov">      24806 :     case SUBREG:</span>
<span class="lineNum">   15438 </span>            :       /* The case of a subreg may arise when we have a local (register)
<span class="lineNum">   15439 </span>            :          variable or a formal (register) parameter which doesn't quite fill
<span class="lineNum">   15440 </span>            :          up an entire register.  For now, just assume that it is
<span class="lineNum">   15441 </span>            :          legitimate to make the Dwarf info refer to the whole register which
<span class="lineNum">   15442 </span>            :          contains the given subreg.  */
<span class="lineNum">   15443 </span><span class="lineCov">      24806 :       if (!subreg_lowpart_p (rtl))</span>
<span class="lineNum">   15444 </span>            :         break;
<span class="lineNum">   15445 </span><span class="lineCov">      16901 :       inner = SUBREG_REG (rtl);</span>
<span class="lineNum">   15446 </span>            :       /* FALLTHRU */
<span class="lineNum">   15447 </span><span class="lineCov">      16901 :     case TRUNCATE:</span>
<span class="lineNum">   15448 </span><span class="lineCov">      16901 :       if (inner == NULL_RTX)</span>
<span class="lineNum">   15449 </span><span class="lineCov">       1040 :         inner = XEXP (rtl, 0);</span>
<span class="lineNum">   15450 </span><span class="lineCov">      17941 :       if (is_a &lt;scalar_int_mode&gt; (mode, &amp;int_mode)</span>
<span class="lineNum">   15451 </span><span class="lineCov">      17848 :           &amp;&amp; is_a &lt;scalar_int_mode&gt; (GET_MODE (inner), &amp;inner_mode)</span>
<span class="lineNum">   15452 </span><span class="lineCov">      38110 :           &amp;&amp; (GET_MODE_SIZE (int_mode) &lt;= DWARF2_ADDR_SIZE</span>
<span class="lineNum">   15453 </span>            : #ifdef POINTERS_EXTEND_UNSIGNED
<span class="lineNum">   15454 </span><span class="lineNoCov">          0 :               || (int_mode == Pmode &amp;&amp; mem_mode != VOIDmode)</span>
<span class="lineNum">   15455 </span>            : #endif
<span class="lineNum">   15456 </span>            :              )
<span class="lineNum">   15457 </span><span class="lineCov">      56051 :           &amp;&amp; GET_MODE_SIZE (inner_mode) &lt;= DWARF2_ADDR_SIZE)</span>
<span class="lineNum">   15458 </span>            :         {
<span class="lineNum">   15459 </span><span class="lineCov">      20042 :           mem_loc_result = mem_loc_descriptor (inner,</span>
<span class="lineNum">   15460 </span>            :                                                inner_mode,
<span class="lineNum">   15461 </span>            :                                                mem_mode, initialized);
<span class="lineNum">   15462 </span><span class="lineCov">      10021 :           break;</span>
<span class="lineNum">   15463 </span>            :         }
<span class="lineNum">   15464 </span><span class="lineCov">       7920 :       if (dwarf_strict &amp;&amp; dwarf_version &lt; 5)</span>
<span class="lineNum">   15465 </span>            :         break;
<span class="lineNum">   15466 </span><span class="lineCov">      15840 :       if (is_a &lt;scalar_int_mode&gt; (mode, &amp;int_mode)</span>
<span class="lineNum">   15467 </span><span class="lineCov">       7827 :           &amp;&amp; is_a &lt;scalar_int_mode&gt; (GET_MODE (inner), &amp;inner_mode)</span>
<span class="lineNum">   15468 </span><span class="lineCov">      28758 :           ? GET_MODE_SIZE (int_mode) &lt;= GET_MODE_SIZE (inner_mode)</span>
<span class="lineNum">   15469 </span><span class="lineCov">       2922 :           : known_eq (GET_MODE_SIZE (mode), GET_MODE_SIZE (GET_MODE (inner))))</span>
<span class="lineNum">   15470 </span>            :         {
<span class="lineNum">   15471 </span><span class="lineCov">       7823 :           dw_die_ref type_die;</span>
<span class="lineNum">   15472 </span><span class="lineCov">       7823 :           dw_loc_descr_ref cvt;</span>
<span class="lineNum">   15473 </span>            : 
<span class="lineNum">   15474 </span><span class="lineCov">      23469 :           mem_loc_result = mem_loc_descriptor (inner,</span>
<span class="lineNum">   15475 </span><span class="lineCov">       7823 :                                                GET_MODE (inner),</span>
<span class="lineNum">   15476 </span>            :                                                mem_mode, initialized);
<span class="lineNum">   15477 </span><span class="lineCov">       7823 :           if (mem_loc_result == NULL)</span>
<span class="lineNum">   15478 </span>            :             break;
<span class="lineNum">   15479 </span><span class="lineCov">       1958 :           type_die = base_type_for_mode (mode, SCALAR_INT_MODE_P (mode));</span>
<span class="lineNum">   15480 </span><span class="lineCov">       1958 :           if (type_die == NULL)</span>
<span class="lineNum">   15481 </span>            :             {
<span class="lineNum">   15482 </span><span class="lineNoCov">          0 :               mem_loc_result = NULL;</span>
<span class="lineNum">   15483 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">   15484 </span>            :             }
<span class="lineNum">   15485 </span><span class="lineCov">       5874 :           if (maybe_ne (GET_MODE_SIZE (mode), GET_MODE_SIZE (GET_MODE (inner))))</span>
<span class="lineNum">   15486 </span><span class="lineCov">       1087 :             cvt = new_loc_descr (dwarf_OP (DW_OP_convert), 0, 0);</span>
<span class="lineNum">   15487 </span>            :           else
<span class="lineNum">   15488 </span><span class="lineCov">        871 :             cvt = new_loc_descr (dwarf_OP (DW_OP_reinterpret), 0, 0);</span>
<span class="lineNum">   15489 </span><span class="lineCov">       1958 :           cvt-&gt;dw_loc_oprnd1.val_class = dw_val_class_die_ref;</span>
<span class="lineNum">   15490 </span><span class="lineCov">       1958 :           cvt-&gt;dw_loc_oprnd1.v.val_die_ref.die = type_die;</span>
<span class="lineNum">   15491 </span><span class="lineCov">       1958 :           cvt-&gt;dw_loc_oprnd1.v.val_die_ref.external = 0;</span>
<span class="lineNum">   15492 </span><span class="lineCov">       1958 :           add_loc_descr (&amp;mem_loc_result, cvt);</span>
<span class="lineNum">   15493 </span><span class="lineCov">       1958 :           if (is_a &lt;scalar_int_mode&gt; (mode, &amp;int_mode)</span>
<span class="lineNum">   15494 </span><span class="lineCov">       4602 :               &amp;&amp; GET_MODE_SIZE (int_mode) &lt;= DWARF2_ADDR_SIZE)</span>
<span class="lineNum">   15495 </span>            :             {
<span class="lineNum">   15496 </span>            :               /* Convert it to untyped afterwards.  */
<span class="lineNum">   15497 </span><span class="lineCov">       1616 :               cvt = new_loc_descr (dwarf_OP (DW_OP_convert), 0, 0);</span>
<span class="lineNum">   15498 </span><span class="lineCov">       1616 :               add_loc_descr (&amp;mem_loc_result, cvt);</span>
<span class="lineNum">   15499 </span>            :             }
<span class="lineNum">   15500 </span>            :         }
<span class="lineNum">   15501 </span>            :       break;
<span class="lineNum">   15502 </span>            : 
<span class="lineNum">   15503 </span><span class="lineCov">    1795897 :     case REG:</span>
<span class="lineNum">   15504 </span><span class="lineCov">    1795897 :       if (!is_a &lt;scalar_int_mode&gt; (mode, &amp;int_mode)</span>
<span class="lineNum">   15505 </span><span class="lineCov">    3816399 :           || (GET_MODE_SIZE (int_mode) &gt; DWARF2_ADDR_SIZE</span>
<span class="lineNum">   15506 </span><span class="lineCov">       3632 :               &amp;&amp; rtl != arg_pointer_rtx</span>
<span class="lineNum">   15507 </span><span class="lineCov">       3630 :               &amp;&amp; rtl != frame_pointer_rtx</span>
<span class="lineNum">   15508 </span>            : #ifdef POINTERS_EXTEND_UNSIGNED
<span class="lineNum">   15509 </span><span class="lineCov">       7260 :               &amp;&amp; (int_mode != Pmode || mem_mode == VOIDmode)</span>
<span class="lineNum">   15510 </span>            : #endif
<span class="lineNum">   15511 </span>            :               ))
<span class="lineNum">   15512 </span>            :         {
<span class="lineNum">   15513 </span><span class="lineCov">      45942 :           dw_die_ref type_die;</span>
<span class="lineNum">   15514 </span><span class="lineCov">      45942 :           unsigned int dbx_regnum;</span>
<span class="lineNum">   15515 </span>            : 
<span class="lineNum">   15516 </span><span class="lineCov">      45942 :           if (dwarf_strict &amp;&amp; dwarf_version &lt; 5)</span>
<span class="lineNum">   15517 </span>            :             break;
<span class="lineNum">   15518 </span><span class="lineCov">      91884 :           if (REGNO (rtl) &gt;= FIRST_PSEUDO_REGISTER)</span>
<span class="lineNum">   15519 </span>            :             break;
<span class="lineNum">   15520 </span><span class="lineCov">      45940 :           type_die = base_type_for_mode (mode, SCALAR_INT_MODE_P (mode));</span>
<span class="lineNum">   15521 </span><span class="lineCov">      45940 :           if (type_die == NULL)</span>
<span class="lineNum">   15522 </span>            :             break;
<span class="lineNum">   15523 </span>            : 
<span class="lineNum">   15524 </span><span class="lineCov">      45016 :           dbx_regnum = dbx_reg_number (rtl);</span>
<span class="lineNum">   15525 </span><span class="lineCov">      45016 :           if (dbx_regnum == IGNORED_DWARF_REGNUM)</span>
<span class="lineNum">   15526 </span>            :             break;
<span class="lineNum">   15527 </span><span class="lineCov">      45016 :           mem_loc_result = new_loc_descr (dwarf_OP (DW_OP_regval_type),</span>
<span class="lineNum">   15528 </span>            :                                           dbx_regnum, 0);
<span class="lineNum">   15529 </span><span class="lineCov">      45016 :           mem_loc_result-&gt;dw_loc_oprnd2.val_class = dw_val_class_die_ref;</span>
<span class="lineNum">   15530 </span><span class="lineCov">      45016 :           mem_loc_result-&gt;dw_loc_oprnd2.v.val_die_ref.die = type_die;</span>
<span class="lineNum">   15531 </span><span class="lineCov">      45016 :           mem_loc_result-&gt;dw_loc_oprnd2.v.val_die_ref.external = 0;</span>
<span class="lineNum">   15532 </span><span class="lineCov">      45016 :           break;</span>
<span class="lineNum">   15533 </span>            :         }
<span class="lineNum">   15534 </span>            :       /* Whenever a register number forms a part of the description of the
<span class="lineNum">   15535 </span>            :          method for calculating the (dynamic) address of a memory resident
<span class="lineNum">   15536 </span>            :          object, DWARF rules require the register number be referred to as
<span class="lineNum">   15537 </span>            :          a &quot;base register&quot;.  This distinction is not based in any way upon
<span class="lineNum">   15538 </span>            :          what category of register the hardware believes the given register
<span class="lineNum">   15539 </span>            :          belongs to.  This is strictly DWARF terminology we're dealing with
<span class="lineNum">   15540 </span>            :          here. Note that in cases where the location of a memory-resident
<span class="lineNum">   15541 </span>            :          data object could be expressed as: OP_ADD (OP_BASEREG (basereg),
<span class="lineNum">   15542 </span>            :          OP_CONST (0)) the actual DWARF location descriptor that we generate
<span class="lineNum">   15543 </span>            :          may just be OP_BASEREG (basereg).  This may look deceptively like
<span class="lineNum">   15544 </span>            :          the object in question was allocated to a register (rather than in
<span class="lineNum">   15545 </span>            :          memory) so DWARF consumers need to be aware of the subtle
<span class="lineNum">   15546 </span>            :          distinction between OP_REG and OP_BASEREG.  */
<span class="lineNum">   15547 </span><span class="lineCov">    3499910 :       if (REGNO (rtl) &lt; FIRST_PSEUDO_REGISTER)</span>
<span class="lineNum">   15548 </span><span class="lineCov">    3497464 :         mem_loc_result = based_loc_descr (rtl, 0, VAR_INIT_STATUS_INITIALIZED);</span>
<span class="lineNum">   15549 </span><span class="lineCov">         28 :       else if (stack_realign_drap</span>
<span class="lineNum">   15550 </span><span class="lineNoCov">          0 :                &amp;&amp; crtl-&gt;drap_reg</span>
<span class="lineNum">   15551 </span><span class="lineNoCov">          0 :                &amp;&amp; crtl-&gt;args.internal_arg_pointer == rtl</span>
<span class="lineNum">   15552 </span><span class="lineCov">       1223 :                &amp;&amp; REGNO (crtl-&gt;drap_reg) &lt; FIRST_PSEUDO_REGISTER)</span>
<span class="lineNum">   15553 </span>            :         {
<span class="lineNum">   15554 </span>            :           /* If RTL is internal_arg_pointer, which has been optimized
<span class="lineNum">   15555 </span>            :              out, use DRAP instead.  */
<span class="lineNum">   15556 </span><span class="lineNoCov">          0 :           mem_loc_result = based_loc_descr (crtl-&gt;drap_reg, 0,</span>
<span class="lineNum">   15557 </span>            :                                             VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   15558 </span>            :         }
<span class="lineNum">   15559 </span>            :       break;
<span class="lineNum">   15560 </span>            : 
<span class="lineNum">   15561 </span><span class="lineCov">     103126 :     case SIGN_EXTEND:</span>
<span class="lineNum">   15562 </span><span class="lineCov">     103126 :     case ZERO_EXTEND:</span>
<span class="lineNum">   15563 </span><span class="lineCov">     103126 :       if (!is_a &lt;scalar_int_mode&gt; (mode, &amp;int_mode)</span>
<span class="lineNum">   15564 </span><span class="lineCov">     103126 :           || !is_a &lt;scalar_int_mode&gt; (GET_MODE (XEXP (rtl, 0)), &amp;inner_mode))</span>
<span class="lineNum">   15565 </span>            :         break;
<span class="lineNum">   15566 </span><span class="lineCov">     206252 :       op0 = mem_loc_descriptor (XEXP (rtl, 0), inner_mode,</span>
<span class="lineNum">   15567 </span>            :                                 mem_mode, VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   15568 </span><span class="lineCov">     103126 :       if (op0 == 0)</span>
<span class="lineNum">   15569 </span>            :         break;
<span class="lineNum">   15570 </span><span class="lineCov">      97703 :       else if (GET_CODE (rtl) == ZERO_EXTEND</span>
<span class="lineNum">   15571 </span><span class="lineCov">     166721 :                &amp;&amp; GET_MODE_SIZE (int_mode) &lt;= DWARF2_ADDR_SIZE</span>
<span class="lineNum">   15572 </span><span class="lineCov">     117874 :                &amp;&amp; GET_MODE_BITSIZE (inner_mode) &lt; HOST_BITS_PER_WIDE_INT</span>
<span class="lineNum">   15573 </span>            :                /* If DW_OP_const{1,2,4}u won't be used, it is shorter
<span class="lineNum">   15574 </span>            :                   to expand zero extend as two shifts instead of
<span class="lineNum">   15575 </span>            :                   masking.  */
<span class="lineNum">   15576 </span><span class="lineCov">     215577 :                &amp;&amp; GET_MODE_SIZE (inner_mode) &lt;= 4)</span>
<span class="lineNum">   15577 </span>            :         {
<span class="lineNum">   15578 </span><span class="lineCov">      58937 :           mem_loc_result = op0;</span>
<span class="lineNum">   15579 </span><span class="lineCov">      58937 :           add_loc_descr (&amp;mem_loc_result,</span>
<span class="lineNum">   15580 </span><span class="lineCov">     117874 :                          int_loc_descriptor (GET_MODE_MASK (inner_mode)));</span>
<span class="lineNum">   15581 </span><span class="lineCov">      58937 :           add_loc_descr (&amp;mem_loc_result, new_loc_descr (DW_OP_and, 0, 0));</span>
<span class="lineNum">   15582 </span>            :         }
<span class="lineNum">   15583 </span><span class="lineCov">      95705 :       else if (GET_MODE_SIZE (int_mode) &lt;= DWARF2_ADDR_SIZE)</span>
<span class="lineNum">   15584 </span>            :         {
<span class="lineNum">   15585 </span><span class="lineCov">      20610 :           int shift = DWARF2_ADDR_SIZE - GET_MODE_SIZE (inner_mode);</span>
<span class="lineNum">   15586 </span><span class="lineCov">      20610 :           shift *= BITS_PER_UNIT;</span>
<span class="lineNum">   15587 </span><span class="lineCov">      20610 :           if (GET_CODE (rtl) == SIGN_EXTEND)</span>
<span class="lineNum">   15588 </span>            :             op = DW_OP_shra;
<span class="lineNum">   15589 </span>            :           else
<span class="lineNum">   15590 </span><span class="lineNoCov">          0 :             op = DW_OP_shr;</span>
<span class="lineNum">   15591 </span><span class="lineCov">      20610 :           mem_loc_result = op0;</span>
<span class="lineNum">   15592 </span><span class="lineCov">      41220 :           add_loc_descr (&amp;mem_loc_result, int_loc_descriptor (shift));</span>
<span class="lineNum">   15593 </span><span class="lineCov">      20610 :           add_loc_descr (&amp;mem_loc_result, new_loc_descr (DW_OP_shl, 0, 0));</span>
<span class="lineNum">   15594 </span><span class="lineCov">      41220 :           add_loc_descr (&amp;mem_loc_result, int_loc_descriptor (shift));</span>
<span class="lineNum">   15595 </span><span class="lineCov">      20610 :           add_loc_descr (&amp;mem_loc_result, new_loc_descr (op, 0, 0));</span>
<span class="lineNum">   15596 </span>            :         }
<span class="lineNum">   15597 </span><span class="lineCov">      18156 :       else if (!dwarf_strict || dwarf_version &gt;= 5)</span>
<span class="lineNum">   15598 </span>            :         {
<span class="lineNum">   15599 </span><span class="lineCov">      18156 :           dw_die_ref type_die1, type_die2;</span>
<span class="lineNum">   15600 </span><span class="lineCov">      18156 :           dw_loc_descr_ref cvt;</span>
<span class="lineNum">   15601 </span>            : 
<span class="lineNum">   15602 </span><span class="lineCov">      18156 :           type_die1 = base_type_for_mode (inner_mode,</span>
<span class="lineNum">   15603 </span><span class="lineCov">      18156 :                                           GET_CODE (rtl) == ZERO_EXTEND);</span>
<span class="lineNum">   15604 </span><span class="lineCov">      18156 :           if (type_die1 == NULL)</span>
<span class="lineNum">   15605 </span>            :             break;
<span class="lineNum">   15606 </span><span class="lineCov">      36312 :           type_die2 = base_type_for_mode (int_mode, 1);</span>
<span class="lineNum">   15607 </span><span class="lineCov">      18156 :           if (type_die2 == NULL)</span>
<span class="lineNum">   15608 </span>            :             break;
<span class="lineNum">   15609 </span><span class="lineCov">      18156 :           mem_loc_result = op0;</span>
<span class="lineNum">   15610 </span><span class="lineCov">      18156 :           cvt = new_loc_descr (dwarf_OP (DW_OP_convert), 0, 0);</span>
<span class="lineNum">   15611 </span><span class="lineCov">      18156 :           cvt-&gt;dw_loc_oprnd1.val_class = dw_val_class_die_ref;</span>
<span class="lineNum">   15612 </span><span class="lineCov">      18156 :           cvt-&gt;dw_loc_oprnd1.v.val_die_ref.die = type_die1;</span>
<span class="lineNum">   15613 </span><span class="lineCov">      18156 :           cvt-&gt;dw_loc_oprnd1.v.val_die_ref.external = 0;</span>
<span class="lineNum">   15614 </span><span class="lineCov">      18156 :           add_loc_descr (&amp;mem_loc_result, cvt);</span>
<span class="lineNum">   15615 </span><span class="lineCov">      18156 :           cvt = new_loc_descr (dwarf_OP (DW_OP_convert), 0, 0);</span>
<span class="lineNum">   15616 </span><span class="lineCov">      18156 :           cvt-&gt;dw_loc_oprnd1.val_class = dw_val_class_die_ref;</span>
<span class="lineNum">   15617 </span><span class="lineCov">      18156 :           cvt-&gt;dw_loc_oprnd1.v.val_die_ref.die = type_die2;</span>
<span class="lineNum">   15618 </span><span class="lineCov">      18156 :           cvt-&gt;dw_loc_oprnd1.v.val_die_ref.external = 0;</span>
<span class="lineNum">   15619 </span><span class="lineCov">      18156 :           add_loc_descr (&amp;mem_loc_result, cvt);</span>
<span class="lineNum">   15620 </span>            :         }
<span class="lineNum">   15621 </span>            :       break;
<span class="lineNum">   15622 </span>            : 
<span class="lineNum">   15623 </span><span class="lineCov">     776204 :     case MEM:</span>
<span class="lineNum">   15624 </span><span class="lineCov">     776204 :       {</span>
<span class="lineNum">   15625 </span><span class="lineCov">     776204 :         rtx new_rtl = avoid_constant_pool_reference (rtl);</span>
<span class="lineNum">   15626 </span><span class="lineCov">     776204 :         if (new_rtl != rtl)</span>
<span class="lineNum">   15627 </span>            :           {
<span class="lineNum">   15628 </span><span class="lineNoCov">          0 :             mem_loc_result = mem_loc_descriptor (new_rtl, mode, mem_mode,</span>
<span class="lineNum">   15629 </span>            :                                                  initialized);
<span class="lineNum">   15630 </span><span class="lineNoCov">          0 :             if (mem_loc_result != NULL)</span>
<span class="lineNum">   15631 </span>            :               return mem_loc_result;
<span class="lineNum">   15632 </span>            :           }
<span class="lineNum">   15633 </span>            :       }
<span class="lineNum">   15634 </span><span class="lineCov">     776204 :       mem_loc_result = mem_loc_descriptor (XEXP (rtl, 0),</span>
<span class="lineNum">   15635 </span><span class="lineCov">     776204 :                                            get_address_mode (rtl), mode,</span>
<span class="lineNum">   15636 </span>            :                                            VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   15637 </span><span class="lineCov">     776204 :       if (mem_loc_result == NULL)</span>
<span class="lineNum">   15638 </span><span class="lineCov">      15171 :         mem_loc_result = tls_mem_loc_descriptor (rtl);</span>
<span class="lineNum">   15639 </span><span class="lineCov">     776204 :       if (mem_loc_result != NULL)</span>
<span class="lineNum">   15640 </span>            :         {
<span class="lineNum">   15641 </span><span class="lineCov">     761033 :           if (!is_a &lt;scalar_int_mode&gt; (mode, &amp;int_mode)</span>
<span class="lineNum">   15642 </span><span class="lineCov">    1668990 :               || GET_MODE_SIZE (int_mode) &gt; DWARF2_ADDR_SIZE)</span>
<span class="lineNum">   15643 </span>            :             {
<span class="lineNum">   15644 </span><span class="lineCov">      53878 :               dw_die_ref type_die;</span>
<span class="lineNum">   15645 </span><span class="lineCov">      53878 :               dw_loc_descr_ref deref;</span>
<span class="lineNum">   15646 </span><span class="lineCov">      53878 :               HOST_WIDE_INT size;</span>
<span class="lineNum">   15647 </span>            : 
<span class="lineNum">   15648 </span><span class="lineCov">      53878 :               if (dwarf_strict &amp;&amp; dwarf_version &lt; 5)</span>
<span class="lineNum">   15649 </span>            :                 return NULL;
<span class="lineNum">   15650 </span><span class="lineCov">     107756 :               if (!GET_MODE_SIZE (mode).is_constant (&amp;size))</span>
<span class="lineNum">   15651 </span>            :                 return NULL;
<span class="lineNum">   15652 </span><span class="lineCov">      53878 :               type_die</span>
<span class="lineNum">   15653 </span><span class="lineCov">      53878 :                 = base_type_for_mode (mode, SCALAR_INT_MODE_P (mode));</span>
<span class="lineNum">   15654 </span><span class="lineCov">      53878 :               if (type_die == NULL)</span>
<span class="lineNum">   15655 </span>            :                 return NULL;
<span class="lineNum">   15656 </span><span class="lineCov">      53640 :               deref = new_loc_descr (dwarf_OP (DW_OP_deref_type), size, 0);</span>
<span class="lineNum">   15657 </span><span class="lineCov">      53640 :               deref-&gt;dw_loc_oprnd2.val_class = dw_val_class_die_ref;</span>
<span class="lineNum">   15658 </span><span class="lineCov">      53640 :               deref-&gt;dw_loc_oprnd2.v.val_die_ref.die = type_die;</span>
<span class="lineNum">   15659 </span><span class="lineCov">      53640 :               deref-&gt;dw_loc_oprnd2.v.val_die_ref.external = 0;</span>
<span class="lineNum">   15660 </span><span class="lineCov">      53640 :               add_loc_descr (&amp;mem_loc_result, deref);</span>
<span class="lineNum">   15661 </span>            :             }
<span class="lineNum">   15662 </span><span class="lineCov">    1592318 :           else if (GET_MODE_SIZE (int_mode) == DWARF2_ADDR_SIZE)</span>
<span class="lineNum">   15663 </span><span class="lineCov">     649383 :             add_loc_descr (&amp;mem_loc_result, new_loc_descr (DW_OP_deref, 0, 0));</span>
<span class="lineNum">   15664 </span>            :           else
<span class="lineNum">   15665 </span><span class="lineCov">      57772 :             add_loc_descr (&amp;mem_loc_result,</span>
<span class="lineNum">   15666 </span>            :                            new_loc_descr (DW_OP_deref_size,
<span class="lineNum">   15667 </span><span class="lineCov">     115544 :                                           GET_MODE_SIZE (int_mode), 0));</span>
<span class="lineNum">   15668 </span>            :         }
<span class="lineNum">   15669 </span>            :       break;
<span class="lineNum">   15670 </span>            : 
<span class="lineNum">   15671 </span><span class="lineNoCov">          0 :     case LO_SUM:</span>
<span class="lineNum">   15672 </span><span class="lineNoCov">          0 :       return mem_loc_descriptor (XEXP (rtl, 1), mode, mem_mode, initialized);</span>
<span class="lineNum">   15673 </span>            : 
<span class="lineNum">   15674 </span><span class="lineCov">     845995 :     case LABEL_REF:</span>
<span class="lineNum">   15675 </span>            :       /* Some ports can transform a symbol ref into a label ref, because
<span class="lineNum">   15676 </span>            :          the symbol ref is too far away and has to be dumped into a constant
<span class="lineNum">   15677 </span>            :          pool.  */
<span class="lineNum">   15678 </span><span class="lineCov">     845995 :     case CONST:</span>
<span class="lineNum">   15679 </span><span class="lineCov">     845995 :     case SYMBOL_REF:</span>
<span class="lineNum">   15680 </span><span class="lineCov">     845995 :       if (!is_a &lt;scalar_int_mode&gt; (mode, &amp;int_mode)</span>
<span class="lineNum">   15681 </span><span class="lineCov">    1731944 :           || (GET_MODE_SIZE (int_mode) &gt; DWARF2_ADDR_SIZE</span>
<span class="lineNum">   15682 </span>            : #ifdef POINTERS_EXTEND_UNSIGNED
<span class="lineNum">   15683 </span><span class="lineNoCov">          0 :               &amp;&amp; (int_mode != Pmode || mem_mode == VOIDmode)</span>
<span class="lineNum">   15684 </span>            : #endif
<span class="lineNum">   15685 </span>            :               ))
<span class="lineNum">   15686 </span>            :         break;
<span class="lineNum">   15687 </span><span class="lineCov">     845992 :       if (GET_CODE (rtl) == SYMBOL_REF</span>
<span class="lineNum">   15688 </span><span class="lineCov">     845992 :           &amp;&amp; SYMBOL_REF_TLS_MODEL (rtl) != TLS_MODEL_NONE)</span>
<span class="lineNum">   15689 </span>            :         {
<span class="lineNum">   15690 </span><span class="lineCov">       3742 :           dw_loc_descr_ref temp;</span>
<span class="lineNum">   15691 </span>            : 
<span class="lineNum">   15692 </span>            :           /* If this is not defined, we have no way to emit the data.  */
<span class="lineNum">   15693 </span><span class="lineCov">       3742 :           if (!targetm.have_tls || !targetm.asm_out.output_dwarf_dtprel)</span>
<span class="lineNum">   15694 </span>            :             break;
<span class="lineNum">   15695 </span>            : 
<span class="lineNum">   15696 </span><span class="lineCov">       3742 :           temp = new_addr_loc_descr (rtl, dtprel_true);</span>
<span class="lineNum">   15697 </span>            : 
<span class="lineNum">   15698 </span>            :           /* We check for DWARF 5 here because gdb did not implement
<span class="lineNum">   15699 </span>            :              DW_OP_form_tls_address until after 7.12.  */
<span class="lineNum">   15700 </span><span class="lineCov">       7484 :           mem_loc_result = new_loc_descr ((dwarf_version &gt;= 5</span>
<span class="lineNum">   15701 </span>            :                                            ? DW_OP_form_tls_address
<span class="lineNum">   15702 </span>            :                                            : DW_OP_GNU_push_tls_address),
<span class="lineNum">   15703 </span>            :                                           0, 0);
<span class="lineNum">   15704 </span><span class="lineCov">       3742 :           add_loc_descr (&amp;mem_loc_result, temp);</span>
<span class="lineNum">   15705 </span>            : 
<span class="lineNum">   15706 </span><span class="lineCov">       3742 :           break;</span>
<span class="lineNum">   15707 </span>            :         }
<span class="lineNum">   15708 </span>            : 
<span class="lineNum">   15709 </span><span class="lineCov">     842250 :       if (!const_ok_for_output (rtl))</span>
<span class="lineNum">   15710 </span>            :         {
<span class="lineNum">   15711 </span><span class="lineCov">      85812 :           if (GET_CODE (rtl) == CONST)</span>
<span class="lineNum">   15712 </span><span class="lineCov">       8840 :             switch (GET_CODE (XEXP (rtl, 0)))</span>
<span class="lineNum">   15713 </span>            :               {
<span class="lineNum">   15714 </span>            :               case NOT:
<span class="lineNum">   15715 </span>            :                 op = DW_OP_not;
<span class="lineNum">   15716 </span>            :                 goto try_const_unop;
<span class="lineNum">   15717 </span><span class="lineNoCov">          0 :               case NEG:</span>
<span class="lineNum">   15718 </span><span class="lineNoCov">          0 :                 op = DW_OP_neg;</span>
<span class="lineNum">   15719 </span><span class="lineNoCov">          0 :                 goto try_const_unop;</span>
<span class="lineNum">   15720 </span><span class="lineNoCov">          0 :               try_const_unop:</span>
<span class="lineNum">   15721 </span><span class="lineNoCov">          0 :                 rtx arg;</span>
<span class="lineNum">   15722 </span><span class="lineNoCov">          0 :                 arg = XEXP (XEXP (rtl, 0), 0);</span>
<span class="lineNum">   15723 </span><span class="lineNoCov">          0 :                 if (!CONSTANT_P (arg))</span>
<span class="lineNum">   15724 </span><span class="lineNoCov">          0 :                   arg = gen_rtx_CONST (int_mode, arg);</span>
<span class="lineNum">   15725 </span><span class="lineNoCov">          0 :                 op0 = mem_loc_descriptor (arg, int_mode, mem_mode,</span>
<span class="lineNum">   15726 </span>            :                                           initialized);
<span class="lineNum">   15727 </span><span class="lineNoCov">          0 :                 if (op0)</span>
<span class="lineNum">   15728 </span>            :                   {
<span class="lineNum">   15729 </span><span class="lineNoCov">          0 :                     mem_loc_result = op0;</span>
<span class="lineNum">   15730 </span><span class="lineNoCov">          0 :                     add_loc_descr (&amp;mem_loc_result, new_loc_descr (op, 0, 0));</span>
<span class="lineNum">   15731 </span>            :                   }
<span class="lineNum">   15732 </span>            :                 break;
<span class="lineNum">   15733 </span><span class="lineCov">       8840 :               default:</span>
<span class="lineNum">   15734 </span><span class="lineCov">      17680 :                 mem_loc_result = mem_loc_descriptor (XEXP (rtl, 0), int_mode,</span>
<span class="lineNum">   15735 </span>            :                                                      mem_mode, initialized);
<span class="lineNum">   15736 </span><span class="lineCov">       8840 :                 break;</span>
<span class="lineNum">   15737 </span>            :               }
<span class="lineNum">   15738 </span>            :           break;
<span class="lineNum">   15739 </span>            :         }
<span class="lineNum">   15740 </span>            : 
<span class="lineNum">   15741 </span><span class="lineCov">     756438 :     symref:</span>
<span class="lineNum">   15742 </span><span class="lineCov">     821079 :       mem_loc_result = new_addr_loc_descr (rtl, dtprel_false);</span>
<span class="lineNum">   15743 </span><span class="lineCov">     821079 :       vec_safe_push (used_rtx_array, rtl);</span>
<span class="lineNum">   15744 </span><span class="lineCov">     821079 :       break;</span>
<span class="lineNum">   15745 </span>            : 
<span class="lineNum">   15746 </span><span class="lineCov">      21765 :     case CONCAT:</span>
<span class="lineNum">   15747 </span><span class="lineCov">      21765 :     case CONCATN:</span>
<span class="lineNum">   15748 </span><span class="lineCov">      21765 :     case VAR_LOCATION:</span>
<span class="lineNum">   15749 </span><span class="lineCov">      21765 :     case DEBUG_IMPLICIT_PTR:</span>
<span class="lineNum">   15750 </span><span class="lineCov">      21765 :       expansion_failed (NULL_TREE, rtl,</span>
<span class="lineNum">   15751 </span>            :                         &quot;CONCAT/CONCATN/VAR_LOCATION is handled only by loc_descriptor&quot;);
<span class="lineNum">   15752 </span><span class="lineCov">      21765 :       return 0;</span>
<span class="lineNum">   15753 </span>            : 
<span class="lineNum">   15754 </span><span class="lineCov">     864370 :     case ENTRY_VALUE:</span>
<span class="lineNum">   15755 </span><span class="lineCov">     864370 :       if (dwarf_strict &amp;&amp; dwarf_version &lt; 5)</span>
<span class="lineNum">   15756 </span>            :         return NULL;
<span class="lineNum">   15757 </span><span class="lineCov">     864370 :       if (REG_P (ENTRY_VALUE_EXP (rtl)))</span>
<span class="lineNum">   15758 </span>            :         {
<span class="lineNum">   15759 </span><span class="lineCov">     862286 :           if (!is_a &lt;scalar_int_mode&gt; (mode, &amp;int_mode)</span>
<span class="lineNum">   15760 </span><span class="lineCov">    1731431 :               || GET_MODE_SIZE (int_mode) &gt; DWARF2_ADDR_SIZE)</span>
<span class="lineNum">   15761 </span><span class="lineCov">      10716 :             op0 = mem_loc_descriptor (ENTRY_VALUE_EXP (rtl), mode,</span>
<span class="lineNum">   15762 </span>            :                                       VOIDmode, VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   15763 </span>            :           else
<span class="lineNum">   15764 </span>            :             {
<span class="lineNum">   15765 </span><span class="lineCov">     851570 :               unsigned int dbx_regnum = dbx_reg_number (ENTRY_VALUE_EXP (rtl));</span>
<span class="lineNum">   15766 </span><span class="lineCov">     851570 :               if (dbx_regnum == IGNORED_DWARF_REGNUM)</span>
<span class="lineNum">   15767 </span>            :                 return NULL;
<span class="lineNum">   15768 </span><span class="lineCov">     851570 :               op0 = one_reg_loc_descriptor (dbx_regnum,</span>
<span class="lineNum">   15769 </span>            :                                             VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   15770 </span>            :             }
<span class="lineNum">   15771 </span>            :         }
<span class="lineNum">   15772 </span><span class="lineCov">       2084 :       else if (MEM_P (ENTRY_VALUE_EXP (rtl))</span>
<span class="lineNum">   15773 </span><span class="lineCov">       2084 :                &amp;&amp; REG_P (XEXP (ENTRY_VALUE_EXP (rtl), 0)))</span>
<span class="lineNum">   15774 </span>            :         {
<span class="lineNum">   15775 </span><span class="lineCov">       2084 :           op0 = mem_loc_descriptor (ENTRY_VALUE_EXP (rtl), mode,</span>
<span class="lineNum">   15776 </span>            :                                     VOIDmode, VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   15777 </span><span class="lineCov">       2084 :           if (op0 &amp;&amp; op0-&gt;dw_loc_opc == DW_OP_fbreg)</span>
<span class="lineNum">   15778 </span>            :             return NULL;
<span class="lineNum">   15779 </span>            :         }
<span class="lineNum">   15780 </span>            :       else
<span class="lineNum">   15781 </span><span class="lineNoCov">          0 :         gcc_unreachable ();</span>
<span class="lineNum">   15782 </span><span class="lineCov">     864332 :       if (op0 == NULL)</span>
<span class="lineNum">   15783 </span>            :         return NULL;
<span class="lineNum">   15784 </span><span class="lineCov">     864061 :       mem_loc_result = new_loc_descr (dwarf_OP (DW_OP_entry_value), 0, 0);</span>
<span class="lineNum">   15785 </span><span class="lineCov">     864061 :       mem_loc_result-&gt;dw_loc_oprnd1.val_class = dw_val_class_loc;</span>
<span class="lineNum">   15786 </span><span class="lineCov">     864061 :       mem_loc_result-&gt;dw_loc_oprnd1.v.val_loc = op0;</span>
<span class="lineNum">   15787 </span><span class="lineCov">     864061 :       break;</span>
<span class="lineNum">   15788 </span>            : 
<span class="lineNum">   15789 </span><span class="lineCov">       4914 :     case DEBUG_PARAMETER_REF:</span>
<span class="lineNum">   15790 </span><span class="lineCov">       4914 :       mem_loc_result = parameter_ref_descriptor (rtl);</span>
<span class="lineNum">   15791 </span><span class="lineCov">       4914 :       break;</span>
<span class="lineNum">   15792 </span>            : 
<span class="lineNum">   15793 </span><span class="lineNoCov">          0 :     case PRE_MODIFY:</span>
<span class="lineNum">   15794 </span>            :       /* Extract the PLUS expression nested inside and fall into
<span class="lineNum">   15795 </span>            :          PLUS code below.  */
<span class="lineNum">   15796 </span><span class="lineNoCov">          0 :       rtl = XEXP (rtl, 1);</span>
<span class="lineNum">   15797 </span><span class="lineNoCov">          0 :       goto plus;</span>
<span class="lineNum">   15798 </span>            : 
<span class="lineNum">   15799 </span><span class="lineNoCov">          0 :     case PRE_INC:</span>
<span class="lineNum">   15800 </span><span class="lineNoCov">          0 :     case PRE_DEC:</span>
<span class="lineNum">   15801 </span>            :       /* Turn these into a PLUS expression and fall into the PLUS code
<span class="lineNum">   15802 </span>            :          below.  */
<span class="lineNum">   15803 </span><span class="lineNoCov">          0 :       rtl = gen_rtx_PLUS (mode, XEXP (rtl, 0),</span>
<span class="lineNum">   15804 </span>            :                           gen_int_mode (GET_CODE (rtl) == PRE_INC
<span class="lineNum">   15805 </span>            :                                         ? GET_MODE_UNIT_SIZE (mem_mode)
<span class="lineNum">   15806 </span>            :                                         : -GET_MODE_UNIT_SIZE (mem_mode),
<span class="lineNum">   15807 </span>            :                                         mode));
<span class="lineNum">   15808 </span>            : 
<span class="lineNum">   15809 </span>            :       /* fall through */
<span class="lineNum">   15810 </span>            : 
<span class="lineNum">   15811 </span><span class="lineCov">    7609347 :     case PLUS:</span>
<span class="lineNum">   15812 </span><span class="lineCov">   15218694 :     plus:</span>
<span class="lineNum">   15813 </span><span class="lineCov">    7609347 :       if (is_based_loc (rtl)</span>
<span class="lineNum">   15814 </span><span class="lineCov">    6846228 :           &amp;&amp; is_a &lt;scalar_int_mode&gt; (mode, &amp;int_mode)</span>
<span class="lineNum">   15815 </span><span class="lineCov">   22374748 :           &amp;&amp; (GET_MODE_SIZE (int_mode) &lt;= DWARF2_ADDR_SIZE</span>
<span class="lineNum">   15816 </span><span class="lineCov">         74 :               || XEXP (rtl, 0) == arg_pointer_rtx</span>
<span class="lineNum">   15817 </span><span class="lineCov">         74 :               || XEXP (rtl, 0) == frame_pointer_rtx))</span>
<span class="lineNum">   15818 </span><span class="lineCov">    6846155 :         mem_loc_result = based_loc_descr (XEXP (rtl, 0),</span>
<span class="lineNum">   15819 </span><span class="lineCov">    6846155 :                                           INTVAL (XEXP (rtl, 1)),</span>
<span class="lineNum">   15820 </span>            :                                           VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   15821 </span>            :       else
<span class="lineNum">   15822 </span>            :         {
<span class="lineNum">   15823 </span><span class="lineCov">     763192 :           mem_loc_result = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,</span>
<span class="lineNum">   15824 </span>            :                                                VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   15825 </span><span class="lineCov">     763192 :           if (mem_loc_result == 0)</span>
<span class="lineNum">   15826 </span>            :             break;
<span class="lineNum">   15827 </span>            : 
<span class="lineNum">   15828 </span><span class="lineCov">     739256 :           if (CONST_INT_P (XEXP (rtl, 1))</span>
<span class="lineNum">   15829 </span><span class="lineCov">    1176995 :               &amp;&amp; (GET_MODE_SIZE (as_a &lt;scalar_int_mode&gt; (mode))</span>
<span class="lineNum">   15830 </span><span class="lineCov">     437739 :                   &lt;= DWARF2_ADDR_SIZE))</span>
<span class="lineNum">   15831 </span><span class="lineCov">     874622 :             loc_descr_plus_const (&amp;mem_loc_result, INTVAL (XEXP (rtl, 1)));</span>
<span class="lineNum">   15832 </span>            :           else
<span class="lineNum">   15833 </span>            :             {
<span class="lineNum">   15834 </span><span class="lineCov">     301945 :               op1 = mem_loc_descriptor (XEXP (rtl, 1), mode, mem_mode,</span>
<span class="lineNum">   15835 </span>            :                                         VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   15836 </span><span class="lineCov">     301945 :               if (op1 == 0)</span>
<span class="lineNum">   15837 </span>            :                 return NULL;
<span class="lineNum">   15838 </span><span class="lineCov">     292901 :               add_loc_descr (&amp;mem_loc_result, op1);</span>
<span class="lineNum">   15839 </span><span class="lineCov">     292901 :               add_loc_descr (&amp;mem_loc_result,</span>
<span class="lineNum">   15840 </span>            :                              new_loc_descr (DW_OP_plus, 0, 0));
<span class="lineNum">   15841 </span>            :             }
<span class="lineNum">   15842 </span>            :         }
<span class="lineNum">   15843 </span>            :       break;
<span class="lineNum">   15844 </span>            : 
<span class="lineNum">   15845 </span>            :     /* If a pseudo-reg is optimized away, it is possible for it to
<span class="lineNum">   15846 </span>            :        be replaced with a MEM containing a multiply or shift.  */
<span class="lineNum">   15847 </span>            :     case MINUS:
<span class="lineNum">   15848 </span>            :       op = DW_OP_minus;
<span class="lineNum">   15849 </span>            :       goto do_binop;
<span class="lineNum">   15850 </span>            : 
<span class="lineNum">   15851 </span><span class="lineCov">     137680 :     case MULT:</span>
<span class="lineNum">   15852 </span><span class="lineCov">     137680 :       op = DW_OP_mul;</span>
<span class="lineNum">   15853 </span><span class="lineCov">     137680 :       goto do_binop;</span>
<span class="lineNum">   15854 </span>            : 
<span class="lineNum">   15855 </span><span class="lineCov">      84301 :     case DIV:</span>
<span class="lineNum">   15856 </span><span class="lineNoCov">          0 :       if ((!dwarf_strict || dwarf_version &gt;= 5)</span>
<span class="lineNum">   15857 </span><span class="lineCov">      84301 :           &amp;&amp; is_a &lt;scalar_int_mode&gt; (mode, &amp;int_mode)</span>
<span class="lineNum">   15858 </span><span class="lineCov">     247282 :           &amp;&amp; GET_MODE_SIZE (int_mode) &gt; DWARF2_ADDR_SIZE)</span>
<span class="lineNum">   15859 </span>            :         {
<span class="lineNum">   15860 </span><span class="lineCov">         19 :           mem_loc_result = typed_binop (DW_OP_div, rtl,</span>
<span class="lineNum">   15861 </span>            :                                         base_type_for_mode (mode, 0),
<span class="lineNum">   15862 </span>            :                                         int_mode, mem_mode);
<span class="lineNum">   15863 </span><span class="lineCov">         19 :           break;</span>
<span class="lineNum">   15864 </span>            :         }
<span class="lineNum">   15865 </span><span class="lineCov">      84282 :       op = DW_OP_div;</span>
<span class="lineNum">   15866 </span><span class="lineCov">      84282 :       goto do_binop;</span>
<span class="lineNum">   15867 </span>            : 
<span class="lineNum">   15868 </span><span class="lineCov">       1810 :     case UMOD:</span>
<span class="lineNum">   15869 </span><span class="lineCov">       1810 :       op = DW_OP_mod;</span>
<span class="lineNum">   15870 </span><span class="lineCov">       1810 :       goto do_binop;</span>
<span class="lineNum">   15871 </span>            : 
<span class="lineNum">   15872 </span>            :     case ASHIFT:
<span class="lineNum">   15873 </span>            :       op = DW_OP_shl;
<span class="lineNum">   15874 </span>            :       goto do_shift;
<span class="lineNum">   15875 </span>            : 
<span class="lineNum">   15876 </span><span class="lineCov">      55811 :     case ASHIFTRT:</span>
<span class="lineNum">   15877 </span><span class="lineCov">      55811 :       op = DW_OP_shra;</span>
<span class="lineNum">   15878 </span><span class="lineCov">      55811 :       goto do_shift;</span>
<span class="lineNum">   15879 </span>            : 
<span class="lineNum">   15880 </span><span class="lineCov">      66923 :     case LSHIFTRT:</span>
<span class="lineNum">   15881 </span><span class="lineCov">      66923 :       op = DW_OP_shr;</span>
<span class="lineNum">   15882 </span><span class="lineCov">      66923 :       goto do_shift;</span>
<span class="lineNum">   15883 </span>            : 
<span class="lineNum">   15884 </span><span class="lineCov">     237208 :     do_shift:</span>
<span class="lineNum">   15885 </span><span class="lineCov">     237208 :       if (!is_a &lt;scalar_int_mode&gt; (mode, &amp;int_mode))</span>
<span class="lineNum">   15886 </span>            :         break;
<span class="lineNum">   15887 </span><span class="lineCov">     474392 :       op0 = mem_loc_descriptor (XEXP (rtl, 0), int_mode, mem_mode,</span>
<span class="lineNum">   15888 </span>            :                                 VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   15889 </span><span class="lineCov">     237196 :       {</span>
<span class="lineNum">   15890 </span><span class="lineCov">     237196 :         rtx rtlop1 = XEXP (rtl, 1);</span>
<span class="lineNum">   15891 </span><span class="lineCov">     237196 :         if (is_a &lt;scalar_int_mode&gt; (GET_MODE (rtlop1), &amp;op1_mode)</span>
<span class="lineNum">   15892 </span><span class="lineCov">     249430 :             &amp;&amp; GET_MODE_BITSIZE (op1_mode) &lt; GET_MODE_BITSIZE (int_mode))</span>
<span class="lineNum">   15893 </span><span class="lineCov">      10142 :           rtlop1 = gen_rtx_ZERO_EXTEND (int_mode, rtlop1);</span>
<span class="lineNum">   15894 </span><span class="lineCov">     474392 :         op1 = mem_loc_descriptor (rtlop1, int_mode, mem_mode,</span>
<span class="lineNum">   15895 </span><span class="lineCov">     237196 :                                   VAR_INIT_STATUS_INITIALIZED);</span>
<span class="lineNum">   15896 </span>            :       }
<span class="lineNum">   15897 </span>            : 
<span class="lineNum">   15898 </span><span class="lineCov">     237196 :       if (op0 == 0 || op1 == 0)</span>
<span class="lineNum">   15899 </span>            :         break;
<span class="lineNum">   15900 </span>            : 
<span class="lineNum">   15901 </span><span class="lineCov">     233138 :       mem_loc_result = op0;</span>
<span class="lineNum">   15902 </span><span class="lineCov">     233138 :       add_loc_descr (&amp;mem_loc_result, op1);</span>
<span class="lineNum">   15903 </span><span class="lineCov">     233138 :       add_loc_descr (&amp;mem_loc_result, new_loc_descr (op, 0, 0));</span>
<span class="lineNum">   15904 </span><span class="lineCov">     233138 :       break;</span>
<span class="lineNum">   15905 </span>            : 
<span class="lineNum">   15906 </span><span class="lineCov">      64891 :     case AND:</span>
<span class="lineNum">   15907 </span><span class="lineCov">      64891 :       op = DW_OP_and;</span>
<span class="lineNum">   15908 </span><span class="lineCov">      64891 :       goto do_binop;</span>
<span class="lineNum">   15909 </span>            : 
<span class="lineNum">   15910 </span><span class="lineCov">      13405 :     case IOR:</span>
<span class="lineNum">   15911 </span><span class="lineCov">      13405 :       op = DW_OP_or;</span>
<span class="lineNum">   15912 </span><span class="lineCov">      13405 :       goto do_binop;</span>
<span class="lineNum">   15913 </span>            : 
<span class="lineNum">   15914 </span><span class="lineCov">      11032 :     case XOR:</span>
<span class="lineNum">   15915 </span><span class="lineCov">      11032 :       op = DW_OP_xor;</span>
<span class="lineNum">   15916 </span><span class="lineCov">      11032 :       goto do_binop;</span>
<span class="lineNum">   15917 </span>            : 
<span class="lineNum">   15918 </span><span class="lineCov">     512115 :     do_binop:</span>
<span class="lineNum">   15919 </span><span class="lineCov">     512115 :       op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,</span>
<span class="lineNum">   15920 </span>            :                                 VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   15921 </span><span class="lineCov">     512115 :       op1 = mem_loc_descriptor (XEXP (rtl, 1), mode, mem_mode,</span>
<span class="lineNum">   15922 </span>            :                                 VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   15923 </span>            : 
<span class="lineNum">   15924 </span><span class="lineCov">     512115 :       if (op0 == 0 || op1 == 0)</span>
<span class="lineNum">   15925 </span>            :         break;
<span class="lineNum">   15926 </span>            : 
<span class="lineNum">   15927 </span><span class="lineCov">     494710 :       mem_loc_result = op0;</span>
<span class="lineNum">   15928 </span><span class="lineCov">     494710 :       add_loc_descr (&amp;mem_loc_result, op1);</span>
<span class="lineNum">   15929 </span><span class="lineCov">     494710 :       add_loc_descr (&amp;mem_loc_result, new_loc_descr (op, 0, 0));</span>
<span class="lineNum">   15930 </span><span class="lineCov">     494710 :       break;</span>
<span class="lineNum">   15931 </span>            : 
<span class="lineNum">   15932 </span><span class="lineCov">        742 :     case MOD:</span>
<span class="lineNum">   15933 </span><span class="lineNoCov">          0 :       if ((!dwarf_strict || dwarf_version &gt;= 5)</span>
<span class="lineNum">   15934 </span><span class="lineCov">        742 :           &amp;&amp; is_a &lt;scalar_int_mode&gt; (mode, &amp;int_mode)</span>
<span class="lineNum">   15935 </span><span class="lineCov">       2380 :           &amp;&amp; GET_MODE_SIZE (int_mode) &gt; DWARF2_ADDR_SIZE)</span>
<span class="lineNum">   15936 </span>            :         {
<span class="lineNum">   15937 </span><span class="lineCov">         12 :           mem_loc_result = typed_binop (DW_OP_mod, rtl,</span>
<span class="lineNum">   15938 </span>            :                                         base_type_for_mode (mode, 0),
<span class="lineNum">   15939 </span>            :                                         int_mode, mem_mode);
<span class="lineNum">   15940 </span><span class="lineCov">         12 :           break;</span>
<span class="lineNum">   15941 </span>            :         }
<span class="lineNum">   15942 </span>            : 
<span class="lineNum">   15943 </span><span class="lineCov">        730 :       op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,</span>
<span class="lineNum">   15944 </span>            :                                 VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   15945 </span><span class="lineCov">        730 :       op1 = mem_loc_descriptor (XEXP (rtl, 1), mode, mem_mode,</span>
<span class="lineNum">   15946 </span>            :                                 VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   15947 </span>            : 
<span class="lineNum">   15948 </span><span class="lineCov">        730 :       if (op0 == 0 || op1 == 0)</span>
<span class="lineNum">   15949 </span>            :         break;
<span class="lineNum">   15950 </span>            : 
<span class="lineNum">   15951 </span><span class="lineCov">        727 :       mem_loc_result = op0;</span>
<span class="lineNum">   15952 </span><span class="lineCov">        727 :       add_loc_descr (&amp;mem_loc_result, op1);</span>
<span class="lineNum">   15953 </span><span class="lineCov">        727 :       add_loc_descr (&amp;mem_loc_result, new_loc_descr (DW_OP_over, 0, 0));</span>
<span class="lineNum">   15954 </span><span class="lineCov">        727 :       add_loc_descr (&amp;mem_loc_result, new_loc_descr (DW_OP_over, 0, 0));</span>
<span class="lineNum">   15955 </span><span class="lineCov">        727 :       add_loc_descr (&amp;mem_loc_result, new_loc_descr (DW_OP_div, 0, 0));</span>
<span class="lineNum">   15956 </span><span class="lineCov">        727 :       add_loc_descr (&amp;mem_loc_result, new_loc_descr (DW_OP_mul, 0, 0));</span>
<span class="lineNum">   15957 </span><span class="lineCov">        727 :       add_loc_descr (&amp;mem_loc_result, new_loc_descr (DW_OP_minus, 0, 0));</span>
<span class="lineNum">   15958 </span><span class="lineCov">        727 :       break;</span>
<span class="lineNum">   15959 </span>            : 
<span class="lineNum">   15960 </span><span class="lineCov">       1575 :     case UDIV:</span>
<span class="lineNum">   15961 </span><span class="lineNoCov">          0 :       if ((!dwarf_strict || dwarf_version &gt;= 5)</span>
<span class="lineNum">   15962 </span><span class="lineCov">       1575 :           &amp;&amp; is_a &lt;scalar_int_mode&gt; (mode, &amp;int_mode))</span>
<span class="lineNum">   15963 </span>            :         {
<span class="lineNum">   15964 </span><span class="lineCov">       3898 :           if (GET_MODE_SIZE (int_mode) &gt; DWARF2_ADDR_SIZE)</span>
<span class="lineNum">   15965 </span>            :             {
<span class="lineNum">   15966 </span>            :               op = DW_OP_div;
<span class="lineNum">   15967 </span>            :               goto do_binop;
<span class="lineNum">   15968 </span>            :             }
<span class="lineNum">   15969 </span><span class="lineCov">       3054 :           mem_loc_result = typed_binop (DW_OP_div, rtl,</span>
<span class="lineNum">   15970 </span>            :                                         base_type_for_mode (int_mode, 1),
<span class="lineNum">   15971 </span>            :                                         int_mode, mem_mode);
<span class="lineNum">   15972 </span>            :         }
<span class="lineNum">   15973 </span>            :       break;
<span class="lineNum">   15974 </span>            : 
<span class="lineNum">   15975 </span>            :     case NOT:
<span class="lineNum">   15976 </span>            :       op = DW_OP_not;
<span class="lineNum">   15977 </span>            :       goto do_unop;
<span class="lineNum">   15978 </span>            : 
<span class="lineNum">   15979 </span><span class="lineCov">        592 :     case ABS:</span>
<span class="lineNum">   15980 </span><span class="lineCov">        592 :       op = DW_OP_abs;</span>
<span class="lineNum">   15981 </span><span class="lineCov">        592 :       goto do_unop;</span>
<span class="lineNum">   15982 </span>            : 
<span class="lineNum">   15983 </span><span class="lineCov">       4893 :     case NEG:</span>
<span class="lineNum">   15984 </span><span class="lineCov">       4893 :       op = DW_OP_neg;</span>
<span class="lineNum">   15985 </span><span class="lineCov">       4893 :       goto do_unop;</span>
<span class="lineNum">   15986 </span>            : 
<span class="lineNum">   15987 </span><span class="lineCov">      12897 :     do_unop:</span>
<span class="lineNum">   15988 </span><span class="lineCov">      12897 :       op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,</span>
<span class="lineNum">   15989 </span>            :                                 VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   15990 </span>            : 
<span class="lineNum">   15991 </span><span class="lineCov">      12897 :       if (op0 == 0)</span>
<span class="lineNum">   15992 </span>            :         break;
<span class="lineNum">   15993 </span>            : 
<span class="lineNum">   15994 </span><span class="lineCov">      12412 :       mem_loc_result = op0;</span>
<span class="lineNum">   15995 </span><span class="lineCov">      12412 :       add_loc_descr (&amp;mem_loc_result, new_loc_descr (op, 0, 0));</span>
<span class="lineNum">   15996 </span><span class="lineCov">      12412 :       break;</span>
<span class="lineNum">   15997 </span>            : 
<span class="lineNum">   15998 </span><span class="lineCov">     856705 :     case CONST_INT:</span>
<span class="lineNum">   15999 </span><span class="lineCov">     856705 :       if (!is_a &lt;scalar_int_mode&gt; (mode, &amp;int_mode)</span>
<span class="lineNum">   16000 </span><span class="lineCov">    1816419 :           || GET_MODE_SIZE (int_mode) &lt;= DWARF2_ADDR_SIZE</span>
<span class="lineNum">   16001 </span>            : #ifdef POINTERS_EXTEND_UNSIGNED
<span class="lineNum">   16002 </span><span class="lineCov">     881431 :           || (int_mode == Pmode</span>
<span class="lineNum">   16003 </span><span class="lineNoCov">          0 :               &amp;&amp; mem_mode != VOIDmode</span>
<span class="lineNum">   16004 </span><span class="lineNoCov">          0 :               &amp;&amp; trunc_int_for_mode (INTVAL (rtl), ptr_mode) == INTVAL (rtl))</span>
<span class="lineNum">   16005 </span>            : #endif
<span class="lineNum">   16006 </span>            :           )
<span class="lineNum">   16007 </span>            :         {
<span class="lineNum">   16008 </span><span class="lineCov">    1688684 :           mem_loc_result = int_loc_descriptor (INTVAL (rtl));</span>
<span class="lineNum">   16009 </span><span class="lineCov">     844342 :           break;</span>
<span class="lineNum">   16010 </span>            :         }
<span class="lineNum">   16011 </span><span class="lineNoCov">          0 :       if ((!dwarf_strict || dwarf_version &gt;= 5)</span>
<span class="lineNum">   16012 </span><span class="lineCov">      24726 :           &amp;&amp; (GET_MODE_BITSIZE (int_mode) == HOST_BITS_PER_WIDE_INT</span>
<span class="lineNum">   16013 </span><span class="lineCov">       2392 :               || GET_MODE_BITSIZE (int_mode) == HOST_BITS_PER_DOUBLE_INT))</span>
<span class="lineNum">   16014 </span>            :         {
<span class="lineNum">   16015 </span><span class="lineCov">      24726 :           dw_die_ref type_die = base_type_for_mode (int_mode, 1);</span>
<span class="lineNum">   16016 </span><span class="lineCov">      12363 :           scalar_int_mode amode;</span>
<span class="lineNum">   16017 </span><span class="lineCov">      12363 :           if (type_die == NULL)</span>
<span class="lineNum">   16018 </span>            :             return NULL;
<span class="lineNum">   16019 </span><span class="lineCov">      12363 :           if (INTVAL (rtl) &gt;= 0</span>
<span class="lineNum">   16020 </span><span class="lineCov">      32107 :               &amp;&amp; (int_mode_for_size (DWARF2_ADDR_SIZE * BITS_PER_UNIT, 0)</span>
<span class="lineNum">   16021 </span><span class="lineCov">      11487 :                   .exists (&amp;amode))</span>
<span class="lineNum">   16022 </span><span class="lineCov">      22974 :               &amp;&amp; trunc_int_for_mode (INTVAL (rtl), amode) == INTVAL (rtl)</span>
<span class="lineNum">   16023 </span>            :               /* const DW_OP_convert &lt;XXX&gt; vs.
<span class="lineNum">   16024 </span>            :                  DW_OP_const_type &lt;XXX, 1, const&gt;.  */
<span class="lineNum">   16025 </span><span class="lineCov">      20332 :               &amp;&amp; size_of_int_loc_descriptor (INTVAL (rtl)) + 1 + 1</span>
<span class="lineNum">   16026 </span><span class="lineCov">      15938 :                  &lt; (unsigned long) 1 + 1 + 1 + GET_MODE_SIZE (int_mode))</span>
<span class="lineNum">   16027 </span>            :             {
<span class="lineNum">   16028 </span><span class="lineCov">      15938 :               mem_loc_result = int_loc_descriptor (INTVAL (rtl));</span>
<span class="lineNum">   16029 </span><span class="lineCov">       7969 :               op0 = new_loc_descr (dwarf_OP (DW_OP_convert), 0, 0);</span>
<span class="lineNum">   16030 </span><span class="lineCov">       7969 :               op0-&gt;dw_loc_oprnd1.val_class = dw_val_class_die_ref;</span>
<span class="lineNum">   16031 </span><span class="lineCov">       7969 :               op0-&gt;dw_loc_oprnd1.v.val_die_ref.die = type_die;</span>
<span class="lineNum">   16032 </span><span class="lineCov">       7969 :               op0-&gt;dw_loc_oprnd1.v.val_die_ref.external = 0;</span>
<span class="lineNum">   16033 </span><span class="lineCov">       7969 :               add_loc_descr (&amp;mem_loc_result, op0);</span>
<span class="lineNum">   16034 </span><span class="lineCov">       7969 :               return mem_loc_result;</span>
<span class="lineNum">   16035 </span>            :             }
<span class="lineNum">   16036 </span><span class="lineCov">      13182 :           mem_loc_result = new_loc_descr (dwarf_OP (DW_OP_const_type), 0,</span>
<span class="lineNum">   16037 </span><span class="lineCov">       4394 :                                           INTVAL (rtl));</span>
<span class="lineNum">   16038 </span><span class="lineCov">       4394 :           mem_loc_result-&gt;dw_loc_oprnd1.val_class = dw_val_class_die_ref;</span>
<span class="lineNum">   16039 </span><span class="lineCov">       4394 :           mem_loc_result-&gt;dw_loc_oprnd1.v.val_die_ref.die = type_die;</span>
<span class="lineNum">   16040 </span><span class="lineCov">       4394 :           mem_loc_result-&gt;dw_loc_oprnd1.v.val_die_ref.external = 0;</span>
<span class="lineNum">   16041 </span><span class="lineCov">       8788 :           if (GET_MODE_BITSIZE (int_mode) == HOST_BITS_PER_WIDE_INT)</span>
<span class="lineNum">   16042 </span><span class="lineCov">       4375 :             mem_loc_result-&gt;dw_loc_oprnd2.val_class = dw_val_class_const;</span>
<span class="lineNum">   16043 </span>            :           else
<span class="lineNum">   16044 </span>            :             {
<span class="lineNum">   16045 </span><span class="lineCov">         19 :               mem_loc_result-&gt;dw_loc_oprnd2.val_class</span>
<span class="lineNum">   16046 </span><span class="lineCov">         19 :                 = dw_val_class_const_double;</span>
<span class="lineNum">   16047 </span><span class="lineCov">         19 :               mem_loc_result-&gt;dw_loc_oprnd2.v.val_double</span>
<span class="lineNum">   16048 </span><span class="lineCov">         19 :                 = double_int::from_shwi (INTVAL (rtl));</span>
<span class="lineNum">   16049 </span>            :             }
<span class="lineNum">   16050 </span>            :         }
<span class="lineNum">   16051 </span>            :       break;
<span class="lineNum">   16052 </span>            : 
<span class="lineNum">   16053 </span><span class="lineCov">      44833 :     case CONST_DOUBLE:</span>
<span class="lineNum">   16054 </span><span class="lineCov">      44833 :       if (!dwarf_strict || dwarf_version &gt;= 5)</span>
<span class="lineNum">   16055 </span>            :         {
<span class="lineNum">   16056 </span><span class="lineCov">      44833 :           dw_die_ref type_die;</span>
<span class="lineNum">   16057 </span>            : 
<span class="lineNum">   16058 </span>            :           /* Note that if TARGET_SUPPORTS_WIDE_INT == 0, a
<span class="lineNum">   16059 </span>            :              CONST_DOUBLE rtx could represent either a large integer
<span class="lineNum">   16060 </span>            :              or a floating-point constant.  If TARGET_SUPPORTS_WIDE_INT != 0,
<span class="lineNum">   16061 </span>            :              the value is always a floating point constant.
<span class="lineNum">   16062 </span>            : 
<span class="lineNum">   16063 </span>            :              When it is an integer, a CONST_DOUBLE is used whenever
<span class="lineNum">   16064 </span>            :              the constant requires 2 HWIs to be adequately represented.
<span class="lineNum">   16065 </span>            :              We output CONST_DOUBLEs as blocks.  */
<span class="lineNum">   16066 </span><span class="lineCov">      44833 :           if (mode == VOIDmode</span>
<span class="lineNum">   16067 </span><span class="lineCov">      44833 :               || (GET_MODE (rtl) == VOIDmode</span>
<span class="lineNum">   16068 </span><span class="lineNoCov">          0 :                   &amp;&amp; maybe_ne (GET_MODE_BITSIZE (mode),</span>
<span class="lineNum">   16069 </span>            :                                HOST_BITS_PER_DOUBLE_INT)))
<span class="lineNum">   16070 </span>            :             break;
<span class="lineNum">   16071 </span><span class="lineCov">      44833 :           type_die = base_type_for_mode (mode, SCALAR_INT_MODE_P (mode));</span>
<span class="lineNum">   16072 </span><span class="lineCov">      44833 :           if (type_die == NULL)</span>
<span class="lineNum">   16073 </span>            :             return NULL;
<span class="lineNum">   16074 </span><span class="lineCov">      44833 :           mem_loc_result = new_loc_descr (dwarf_OP (DW_OP_const_type), 0, 0);</span>
<span class="lineNum">   16075 </span><span class="lineCov">      44833 :           mem_loc_result-&gt;dw_loc_oprnd1.val_class = dw_val_class_die_ref;</span>
<span class="lineNum">   16076 </span><span class="lineCov">      44833 :           mem_loc_result-&gt;dw_loc_oprnd1.v.val_die_ref.die = type_die;</span>
<span class="lineNum">   16077 </span><span class="lineCov">      44833 :           mem_loc_result-&gt;dw_loc_oprnd1.v.val_die_ref.external = 0;</span>
<span class="lineNum">   16078 </span>            : #if TARGET_SUPPORTS_WIDE_INT == 0
<span class="lineNum">   16079 </span>            :           if (!SCALAR_FLOAT_MODE_P (mode))
<span class="lineNum">   16080 </span>            :             {
<span class="lineNum">   16081 </span>            :               mem_loc_result-&gt;dw_loc_oprnd2.val_class
<span class="lineNum">   16082 </span>            :                 = dw_val_class_const_double;
<span class="lineNum">   16083 </span>            :               mem_loc_result-&gt;dw_loc_oprnd2.v.val_double
<span class="lineNum">   16084 </span>            :                 = rtx_to_double_int (rtl);
<span class="lineNum">   16085 </span>            :             }
<span class="lineNum">   16086 </span>            :           else
<span class="lineNum">   16087 </span>            : #endif
<span class="lineNum">   16088 </span><span class="lineCov">      44833 :             {</span>
<span class="lineNum">   16089 </span><span class="lineCov">      44833 :               scalar_float_mode float_mode = as_a &lt;scalar_float_mode&gt; (mode);</span>
<span class="lineNum">   16090 </span><span class="lineCov">      44833 :               unsigned int length = GET_MODE_SIZE (float_mode);</span>
<span class="lineNum">   16091 </span><span class="lineCov">      44833 :               unsigned char *array = ggc_vec_alloc&lt;unsigned char&gt; (length);</span>
<span class="lineNum">   16092 </span>            : 
<span class="lineNum">   16093 </span><span class="lineCov">      44833 :               insert_float (rtl, array);</span>
<span class="lineNum">   16094 </span><span class="lineCov">      44833 :               mem_loc_result-&gt;dw_loc_oprnd2.val_class = dw_val_class_vec;</span>
<span class="lineNum">   16095 </span><span class="lineCov">      44833 :               mem_loc_result-&gt;dw_loc_oprnd2.v.val_vec.length = length / 4;</span>
<span class="lineNum">   16096 </span><span class="lineCov">      44833 :               mem_loc_result-&gt;dw_loc_oprnd2.v.val_vec.elt_size = 4;</span>
<span class="lineNum">   16097 </span><span class="lineCov">      44833 :               mem_loc_result-&gt;dw_loc_oprnd2.v.val_vec.array = array;</span>
<span class="lineNum">   16098 </span>            :             }
<span class="lineNum">   16099 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">   16100 </span>            :       break;
<span class="lineNum">   16101 </span>            : 
<span class="lineNum">   16102 </span><span class="lineCov">         65 :     case CONST_WIDE_INT:</span>
<span class="lineNum">   16103 </span><span class="lineCov">         65 :       if (!dwarf_strict || dwarf_version &gt;= 5)</span>
<span class="lineNum">   16104 </span>            :         {
<span class="lineNum">   16105 </span><span class="lineCov">         65 :           dw_die_ref type_die;</span>
<span class="lineNum">   16106 </span>            : 
<span class="lineNum">   16107 </span><span class="lineCov">         65 :           type_die = base_type_for_mode (mode, SCALAR_INT_MODE_P (mode));</span>
<span class="lineNum">   16108 </span><span class="lineCov">         65 :           if (type_die == NULL)</span>
<span class="lineNum">   16109 </span>            :             return NULL;
<span class="lineNum">   16110 </span><span class="lineCov">         65 :           mem_loc_result = new_loc_descr (dwarf_OP (DW_OP_const_type), 0, 0);</span>
<span class="lineNum">   16111 </span><span class="lineCov">         65 :           mem_loc_result-&gt;dw_loc_oprnd1.val_class = dw_val_class_die_ref;</span>
<span class="lineNum">   16112 </span><span class="lineCov">         65 :           mem_loc_result-&gt;dw_loc_oprnd1.v.val_die_ref.die = type_die;</span>
<span class="lineNum">   16113 </span><span class="lineCov">         65 :           mem_loc_result-&gt;dw_loc_oprnd1.v.val_die_ref.external = 0;</span>
<span class="lineNum">   16114 </span><span class="lineCov">         65 :           mem_loc_result-&gt;dw_loc_oprnd2.val_class</span>
<span class="lineNum">   16115 </span><span class="lineCov">         65 :             = dw_val_class_wide_int;</span>
<span class="lineNum">   16116 </span><span class="lineCov">         65 :           mem_loc_result-&gt;dw_loc_oprnd2.v.val_wide = ggc_alloc&lt;wide_int&gt; ();</span>
<span class="lineNum">   16117 </span><span class="lineCov">        130 :           *mem_loc_result-&gt;dw_loc_oprnd2.v.val_wide = rtx_mode_t (rtl, mode);</span>
<span class="lineNum">   16118 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">   16119 </span>            :       break;
<span class="lineNum">   16120 </span>            : 
<span class="lineNum">   16121 </span><span class="lineNoCov">          0 :     case CONST_POLY_INT:</span>
<span class="lineNum">   16122 </span><span class="lineNoCov">          0 :       mem_loc_result = int_loc_descriptor (rtx_to_poly_int64 (rtl));</span>
<span class="lineNum">   16123 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">   16124 </span>            : 
<span class="lineNum">   16125 </span><span class="lineCov">      15077 :     case EQ:</span>
<span class="lineNum">   16126 </span><span class="lineCov">      15077 :       mem_loc_result = scompare_loc_descriptor (DW_OP_eq, rtl, mem_mode);</span>
<span class="lineNum">   16127 </span><span class="lineCov">      15077 :       break;</span>
<span class="lineNum">   16128 </span>            : 
<span class="lineNum">   16129 </span><span class="lineCov">       2092 :     case GE:</span>
<span class="lineNum">   16130 </span><span class="lineCov">       2092 :       mem_loc_result = scompare_loc_descriptor (DW_OP_ge, rtl, mem_mode);</span>
<span class="lineNum">   16131 </span><span class="lineCov">       2092 :       break;</span>
<span class="lineNum">   16132 </span>            : 
<span class="lineNum">   16133 </span><span class="lineCov">       1519 :     case GT:</span>
<span class="lineNum">   16134 </span><span class="lineCov">       1519 :       mem_loc_result = scompare_loc_descriptor (DW_OP_gt, rtl, mem_mode);</span>
<span class="lineNum">   16135 </span><span class="lineCov">       1519 :       break;</span>
<span class="lineNum">   16136 </span>            : 
<span class="lineNum">   16137 </span><span class="lineCov">       1066 :     case LE:</span>
<span class="lineNum">   16138 </span><span class="lineCov">       1066 :       mem_loc_result = scompare_loc_descriptor (DW_OP_le, rtl, mem_mode);</span>
<span class="lineNum">   16139 </span><span class="lineCov">       1066 :       break;</span>
<span class="lineNum">   16140 </span>            : 
<span class="lineNum">   16141 </span><span class="lineCov">       2730 :     case LT:</span>
<span class="lineNum">   16142 </span><span class="lineCov">       2730 :       mem_loc_result = scompare_loc_descriptor (DW_OP_lt, rtl, mem_mode);</span>
<span class="lineNum">   16143 </span><span class="lineCov">       2730 :       break;</span>
<span class="lineNum">   16144 </span>            : 
<span class="lineNum">   16145 </span><span class="lineCov">      13092 :     case NE:</span>
<span class="lineNum">   16146 </span><span class="lineCov">      13092 :       mem_loc_result = scompare_loc_descriptor (DW_OP_ne, rtl, mem_mode);</span>
<span class="lineNum">   16147 </span><span class="lineCov">      13092 :       break;</span>
<span class="lineNum">   16148 </span>            : 
<span class="lineNum">   16149 </span><span class="lineCov">        632 :     case GEU:</span>
<span class="lineNum">   16150 </span><span class="lineCov">        632 :       mem_loc_result = ucompare_loc_descriptor (DW_OP_ge, rtl, mem_mode);</span>
<span class="lineNum">   16151 </span><span class="lineCov">        632 :       break;</span>
<span class="lineNum">   16152 </span>            : 
<span class="lineNum">   16153 </span><span class="lineCov">       3179 :     case GTU:</span>
<span class="lineNum">   16154 </span><span class="lineCov">       3179 :       mem_loc_result = ucompare_loc_descriptor (DW_OP_gt, rtl, mem_mode);</span>
<span class="lineNum">   16155 </span><span class="lineCov">       3179 :       break;</span>
<span class="lineNum">   16156 </span>            : 
<span class="lineNum">   16157 </span><span class="lineCov">      12572 :     case LEU:</span>
<span class="lineNum">   16158 </span><span class="lineCov">      12572 :       mem_loc_result = ucompare_loc_descriptor (DW_OP_le, rtl, mem_mode);</span>
<span class="lineNum">   16159 </span><span class="lineCov">      12572 :       break;</span>
<span class="lineNum">   16160 </span>            : 
<span class="lineNum">   16161 </span><span class="lineCov">       3124 :     case LTU:</span>
<span class="lineNum">   16162 </span><span class="lineCov">       3124 :       mem_loc_result = ucompare_loc_descriptor (DW_OP_lt, rtl, mem_mode);</span>
<span class="lineNum">   16163 </span><span class="lineCov">       3124 :       break;</span>
<span class="lineNum">   16164 </span>            : 
<span class="lineNum">   16165 </span><span class="lineCov">        878 :     case UMIN:</span>
<span class="lineNum">   16166 </span><span class="lineCov">        878 :     case UMAX:</span>
<span class="lineNum">   16167 </span><span class="lineCov">        878 :       if (!SCALAR_INT_MODE_P (mode))</span>
<span class="lineNum">   16168 </span>            :         break;
<span class="lineNum">   16169 </span>            :       /* FALLTHRU */
<span class="lineNum">   16170 </span><span class="lineCov">       8248 :     case SMIN:</span>
<span class="lineNum">   16171 </span><span class="lineCov">       8248 :     case SMAX:</span>
<span class="lineNum">   16172 </span><span class="lineCov">       8248 :       mem_loc_result = minmax_loc_descriptor (rtl, mode, mem_mode);</span>
<span class="lineNum">   16173 </span><span class="lineCov">       8248 :       break;</span>
<span class="lineNum">   16174 </span>            : 
<span class="lineNum">   16175 </span><span class="lineCov">       1718 :     case ZERO_EXTRACT:</span>
<span class="lineNum">   16176 </span><span class="lineCov">       1718 :     case SIGN_EXTRACT:</span>
<span class="lineNum">   16177 </span><span class="lineCov">       1718 :       if (CONST_INT_P (XEXP (rtl, 1))</span>
<span class="lineNum">   16178 </span><span class="lineCov">       1718 :           &amp;&amp; CONST_INT_P (XEXP (rtl, 2))</span>
<span class="lineNum">   16179 </span><span class="lineCov">       1718 :           &amp;&amp; is_a &lt;scalar_int_mode&gt; (mode, &amp;int_mode)</span>
<span class="lineNum">   16180 </span><span class="lineCov">       1718 :           &amp;&amp; is_a &lt;scalar_int_mode&gt; (GET_MODE (XEXP (rtl, 0)), &amp;inner_mode)</span>
<span class="lineNum">   16181 </span><span class="lineCov">       2171 :           &amp;&amp; GET_MODE_SIZE (int_mode) &lt;= DWARF2_ADDR_SIZE</span>
<span class="lineNum">   16182 </span><span class="lineCov">       2171 :           &amp;&amp; GET_MODE_SIZE (inner_mode) &lt;= DWARF2_ADDR_SIZE</span>
<span class="lineNum">   16183 </span><span class="lineCov">       1718 :           &amp;&amp; ((unsigned) INTVAL (XEXP (rtl, 1))</span>
<span class="lineNum">   16184 </span><span class="lineCov">        967 :               + (unsigned) INTVAL (XEXP (rtl, 2))</span>
<span class="lineNum">   16185 </span><span class="lineCov">       1934 :               &lt;= GET_MODE_BITSIZE (int_mode)))</span>
<span class="lineNum">   16186 </span>            :         {
<span class="lineNum">   16187 </span><span class="lineCov">        858 :           int shift, size;</span>
<span class="lineNum">   16188 </span><span class="lineCov">       1716 :           op0 = mem_loc_descriptor (XEXP (rtl, 0), inner_mode,</span>
<span class="lineNum">   16189 </span>            :                                     mem_mode, VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   16190 </span><span class="lineCov">        858 :           if (op0 == 0)</span>
<span class="lineNum">   16191 </span>            :             break;
<span class="lineNum">   16192 </span><span class="lineCov">        858 :           if (GET_CODE (rtl) == SIGN_EXTRACT)</span>
<span class="lineNum">   16193 </span>            :             op = DW_OP_shra;
<span class="lineNum">   16194 </span>            :           else
<span class="lineNum">   16195 </span><span class="lineCov">        254 :             op = DW_OP_shr;</span>
<span class="lineNum">   16196 </span><span class="lineCov">        858 :           mem_loc_result = op0;</span>
<span class="lineNum">   16197 </span><span class="lineCov">        858 :           size = INTVAL (XEXP (rtl, 1));</span>
<span class="lineNum">   16198 </span><span class="lineCov">        858 :           shift = INTVAL (XEXP (rtl, 2));</span>
<span class="lineNum">   16199 </span><span class="lineCov">        858 :           if (BITS_BIG_ENDIAN)</span>
<span class="lineNum">   16200 </span>            :             shift = GET_MODE_BITSIZE (inner_mode) - shift - size;
<span class="lineNum">   16201 </span><span class="lineCov">        983 :           if (shift + size != (int) DWARF2_ADDR_SIZE)</span>
<span class="lineNum">   16202 </span>            :             {
<span class="lineNum">   16203 </span><span class="lineCov">        810 :               add_loc_descr (&amp;mem_loc_result,</span>
<span class="lineNum">   16204 </span>            :                              int_loc_descriptor (DWARF2_ADDR_SIZE
<span class="lineNum">   16205 </span><span class="lineCov">        810 :                                                  - shift - size));</span>
<span class="lineNum">   16206 </span><span class="lineCov">        810 :               add_loc_descr (&amp;mem_loc_result, new_loc_descr (DW_OP_shl, 0, 0));</span>
<span class="lineNum">   16207 </span>            :             }
<span class="lineNum">   16208 </span><span class="lineCov">        983 :           if (size != (int) DWARF2_ADDR_SIZE)</span>
<span class="lineNum">   16209 </span>            :             {
<span class="lineNum">   16210 </span><span class="lineCov">        453 :               add_loc_descr (&amp;mem_loc_result,</span>
<span class="lineNum">   16211 </span><span class="lineCov">        453 :                              int_loc_descriptor (DWARF2_ADDR_SIZE - size));</span>
<span class="lineNum">   16212 </span><span class="lineCov">        453 :               add_loc_descr (&amp;mem_loc_result, new_loc_descr (op, 0, 0));</span>
<span class="lineNum">   16213 </span>            :             }
<span class="lineNum">   16214 </span>            :         }
<span class="lineNum">   16215 </span>            :       break;
<span class="lineNum">   16216 </span>            : 
<span class="lineNum">   16217 </span><span class="lineCov">      10346 :     case IF_THEN_ELSE:</span>
<span class="lineNum">   16218 </span><span class="lineCov">      10346 :       {</span>
<span class="lineNum">   16219 </span><span class="lineCov">      10346 :         dw_loc_descr_ref op2, bra_node, drop_node;</span>
<span class="lineNum">   16220 </span><span class="lineCov">      10346 :         op0 = mem_loc_descriptor (XEXP (rtl, 0),</span>
<span class="lineNum">   16221 </span><span class="lineCov">      10346 :                                   GET_MODE (XEXP (rtl, 0)) == VOIDmode</span>
<span class="lineNum">   16222 </span><span class="lineCov">      20272 :                                   ? word_mode : GET_MODE (XEXP (rtl, 0)),</span>
<span class="lineNum">   16223 </span>            :                                   mem_mode, VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   16224 </span><span class="lineCov">      10346 :         op1 = mem_loc_descriptor (XEXP (rtl, 1), mode, mem_mode,</span>
<span class="lineNum">   16225 </span>            :                                   VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   16226 </span><span class="lineCov">      10346 :         op2 = mem_loc_descriptor (XEXP (rtl, 2), mode, mem_mode,</span>
<span class="lineNum">   16227 </span>            :                                   VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   16228 </span><span class="lineCov">      10346 :         if (op0 == NULL || op1 == NULL || op2 == NULL)</span>
<span class="lineNum">   16229 </span>            :           break;
<span class="lineNum">   16230 </span>            : 
<span class="lineNum">   16231 </span><span class="lineCov">       9942 :         mem_loc_result = op1;</span>
<span class="lineNum">   16232 </span><span class="lineCov">       9942 :         add_loc_descr (&amp;mem_loc_result, op2);</span>
<span class="lineNum">   16233 </span><span class="lineCov">       9942 :         add_loc_descr (&amp;mem_loc_result, op0);</span>
<span class="lineNum">   16234 </span><span class="lineCov">       9942 :         bra_node = new_loc_descr (DW_OP_bra, 0, 0);</span>
<span class="lineNum">   16235 </span><span class="lineCov">       9942 :         add_loc_descr (&amp;mem_loc_result, bra_node);</span>
<span class="lineNum">   16236 </span><span class="lineCov">       9942 :         add_loc_descr (&amp;mem_loc_result, new_loc_descr (DW_OP_swap, 0, 0));</span>
<span class="lineNum">   16237 </span><span class="lineCov">       9942 :         drop_node = new_loc_descr (DW_OP_drop, 0, 0);</span>
<span class="lineNum">   16238 </span><span class="lineCov">       9942 :         add_loc_descr (&amp;mem_loc_result, drop_node);</span>
<span class="lineNum">   16239 </span><span class="lineCov">       9942 :         bra_node-&gt;dw_loc_oprnd1.val_class = dw_val_class_loc;</span>
<span class="lineNum">   16240 </span><span class="lineCov">       9942 :         bra_node-&gt;dw_loc_oprnd1.v.val_loc = drop_node;</span>
<span class="lineNum">   16241 </span>            :       }
<span class="lineNum">   16242 </span><span class="lineCov">       9942 :       break;</span>
<span class="lineNum">   16243 </span>            : 
<span class="lineNum">   16244 </span><span class="lineCov">      19944 :     case FLOAT_EXTEND:</span>
<span class="lineNum">   16245 </span><span class="lineCov">      19944 :     case FLOAT_TRUNCATE:</span>
<span class="lineNum">   16246 </span><span class="lineCov">      19944 :     case FLOAT:</span>
<span class="lineNum">   16247 </span><span class="lineCov">      19944 :     case UNSIGNED_FLOAT:</span>
<span class="lineNum">   16248 </span><span class="lineCov">      19944 :     case FIX:</span>
<span class="lineNum">   16249 </span><span class="lineCov">      19944 :     case UNSIGNED_FIX:</span>
<span class="lineNum">   16250 </span><span class="lineCov">      19944 :       if (!dwarf_strict || dwarf_version &gt;= 5)</span>
<span class="lineNum">   16251 </span>            :         {
<span class="lineNum">   16252 </span><span class="lineCov">      19944 :           dw_die_ref type_die;</span>
<span class="lineNum">   16253 </span><span class="lineCov">      19944 :           dw_loc_descr_ref cvt;</span>
<span class="lineNum">   16254 </span>            : 
<span class="lineNum">   16255 </span><span class="lineCov">      19944 :           op0 = mem_loc_descriptor (XEXP (rtl, 0), GET_MODE (XEXP (rtl, 0)),</span>
<span class="lineNum">   16256 </span>            :                                     mem_mode, VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   16257 </span><span class="lineCov">      19944 :           if (op0 == NULL)</span>
<span class="lineNum">   16258 </span>            :             break;
<span class="lineNum">   16259 </span><span class="lineCov">      19808 :           if (is_a &lt;scalar_int_mode&gt; (GET_MODE (XEXP (rtl, 0)), &amp;int_mode)</span>
<span class="lineNum">   16260 </span><span class="lineCov">      19808 :               &amp;&amp; (GET_CODE (rtl) == FLOAT</span>
<span class="lineNum">   16261 </span><span class="lineCov">      10057 :                   || GET_MODE_SIZE (int_mode) &lt;= DWARF2_ADDR_SIZE))</span>
<span class="lineNum">   16262 </span>            :             {
<span class="lineNum">   16263 </span><span class="lineCov">       6207 :               type_die = base_type_for_mode (int_mode,</span>
<span class="lineNum">   16264 </span><span class="lineCov">       6207 :                                              GET_CODE (rtl) == UNSIGNED_FLOAT);</span>
<span class="lineNum">   16265 </span><span class="lineCov">       6207 :               if (type_die == NULL)</span>
<span class="lineNum">   16266 </span>            :                 break;
<span class="lineNum">   16267 </span><span class="lineCov">       6207 :               cvt = new_loc_descr (dwarf_OP (DW_OP_convert), 0, 0);</span>
<span class="lineNum">   16268 </span><span class="lineCov">       6207 :               cvt-&gt;dw_loc_oprnd1.val_class = dw_val_class_die_ref;</span>
<span class="lineNum">   16269 </span><span class="lineCov">       6207 :               cvt-&gt;dw_loc_oprnd1.v.val_die_ref.die = type_die;</span>
<span class="lineNum">   16270 </span><span class="lineCov">       6207 :               cvt-&gt;dw_loc_oprnd1.v.val_die_ref.external = 0;</span>
<span class="lineNum">   16271 </span><span class="lineCov">       6207 :               add_loc_descr (&amp;op0, cvt);</span>
<span class="lineNum">   16272 </span>            :             }
<span class="lineNum">   16273 </span><span class="lineCov">      19808 :           type_die = base_type_for_mode (mode, GET_CODE (rtl) == UNSIGNED_FIX);</span>
<span class="lineNum">   16274 </span><span class="lineCov">      19808 :           if (type_die == NULL)</span>
<span class="lineNum">   16275 </span>            :             break;
<span class="lineNum">   16276 </span><span class="lineCov">      19808 :           cvt = new_loc_descr (dwarf_OP (DW_OP_convert), 0, 0);</span>
<span class="lineNum">   16277 </span><span class="lineCov">      19808 :           cvt-&gt;dw_loc_oprnd1.val_class = dw_val_class_die_ref;</span>
<span class="lineNum">   16278 </span><span class="lineCov">      19808 :           cvt-&gt;dw_loc_oprnd1.v.val_die_ref.die = type_die;</span>
<span class="lineNum">   16279 </span><span class="lineCov">      19808 :           cvt-&gt;dw_loc_oprnd1.v.val_die_ref.external = 0;</span>
<span class="lineNum">   16280 </span><span class="lineCov">      19808 :           add_loc_descr (&amp;op0, cvt);</span>
<span class="lineNum">   16281 </span><span class="lineCov">      19808 :           if (is_a &lt;scalar_int_mode&gt; (mode, &amp;int_mode)</span>
<span class="lineNum">   16282 </span><span class="lineCov">      19808 :               &amp;&amp; (GET_CODE (rtl) == FIX</span>
<span class="lineNum">   16283 </span><span class="lineCov">        568 :                   || GET_MODE_SIZE (int_mode) &lt; DWARF2_ADDR_SIZE))</span>
<span class="lineNum">   16284 </span>            :             {
<span class="lineNum">   16285 </span><span class="lineCov">        405 :               op0 = convert_descriptor_to_mode (int_mode, op0);</span>
<span class="lineNum">   16286 </span><span class="lineCov">        405 :               if (op0 == NULL)</span>
<span class="lineNum">   16287 </span>            :                 break;
<span class="lineNum">   16288 </span>            :             }
<span class="lineNum">   16289 </span><span class="lineCov">      19808 :           mem_loc_result = op0;</span>
<span class="lineNum">   16290 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">   16291 </span>            :       break;
<span class="lineNum">   16292 </span>            : 
<span class="lineNum">   16293 </span><span class="lineCov">       1279 :     case CLZ:</span>
<span class="lineNum">   16294 </span><span class="lineCov">       1279 :     case CTZ:</span>
<span class="lineNum">   16295 </span><span class="lineCov">       1279 :     case FFS:</span>
<span class="lineNum">   16296 </span><span class="lineCov">       1279 :       if (is_a &lt;scalar_int_mode&gt; (mode, &amp;int_mode))</span>
<span class="lineNum">   16297 </span><span class="lineCov">       1279 :         mem_loc_result = clz_loc_descriptor (rtl, int_mode, mem_mode);</span>
<span class="lineNum">   16298 </span>            :       break;
<span class="lineNum">   16299 </span>            : 
<span class="lineNum">   16300 </span><span class="lineNoCov">          0 :     case POPCOUNT:</span>
<span class="lineNum">   16301 </span><span class="lineNoCov">          0 :     case PARITY:</span>
<span class="lineNum">   16302 </span><span class="lineNoCov">          0 :       if (is_a &lt;scalar_int_mode&gt; (mode, &amp;int_mode))</span>
<span class="lineNum">   16303 </span><span class="lineNoCov">          0 :         mem_loc_result = popcount_loc_descriptor (rtl, int_mode, mem_mode);</span>
<span class="lineNum">   16304 </span>            :       break;
<span class="lineNum">   16305 </span>            : 
<span class="lineNum">   16306 </span><span class="lineCov">         69 :     case BSWAP:</span>
<span class="lineNum">   16307 </span><span class="lineCov">         69 :       if (is_a &lt;scalar_int_mode&gt; (mode, &amp;int_mode))</span>
<span class="lineNum">   16308 </span><span class="lineCov">         69 :         mem_loc_result = bswap_loc_descriptor (rtl, int_mode, mem_mode);</span>
<span class="lineNum">   16309 </span>            :       break;
<span class="lineNum">   16310 </span>            : 
<span class="lineNum">   16311 </span><span class="lineCov">       1973 :     case ROTATE:</span>
<span class="lineNum">   16312 </span><span class="lineCov">       1973 :     case ROTATERT:</span>
<span class="lineNum">   16313 </span><span class="lineCov">       1973 :       if (is_a &lt;scalar_int_mode&gt; (mode, &amp;int_mode))</span>
<span class="lineNum">   16314 </span><span class="lineCov">       1973 :         mem_loc_result = rotate_loc_descriptor (rtl, int_mode, mem_mode);</span>
<span class="lineNum">   16315 </span>            :       break;
<span class="lineNum">   16316 </span>            : 
<span class="lineNum">   16317 </span>            :     case COMPARE:
<span class="lineNum">   16318 </span>            :       /* In theory, we could implement the above.  */
<span class="lineNum">   16319 </span>            :       /* DWARF cannot represent the unsigned compare operations
<span class="lineNum">   16320 </span>            :          natively.  */
<span class="lineNum">   16321 </span>            :     case SS_MULT:
<span class="lineNum">   16322 </span>            :     case US_MULT:
<span class="lineNum">   16323 </span>            :     case SS_DIV:
<span class="lineNum">   16324 </span>            :     case US_DIV:
<span class="lineNum">   16325 </span>            :     case SS_PLUS:
<span class="lineNum">   16326 </span>            :     case US_PLUS:
<span class="lineNum">   16327 </span>            :     case SS_MINUS:
<span class="lineNum">   16328 </span>            :     case US_MINUS:
<span class="lineNum">   16329 </span>            :     case SS_NEG:
<span class="lineNum">   16330 </span>            :     case US_NEG:
<span class="lineNum">   16331 </span>            :     case SS_ABS:
<span class="lineNum">   16332 </span>            :     case SS_ASHIFT:
<span class="lineNum">   16333 </span>            :     case US_ASHIFT:
<span class="lineNum">   16334 </span>            :     case SS_TRUNCATE:
<span class="lineNum">   16335 </span>            :     case US_TRUNCATE:
<span class="lineNum">   16336 </span>            :     case UNORDERED:
<span class="lineNum">   16337 </span>            :     case ORDERED:
<span class="lineNum">   16338 </span>            :     case UNEQ:
<span class="lineNum">   16339 </span>            :     case UNGE:
<span class="lineNum">   16340 </span>            :     case UNGT:
<span class="lineNum">   16341 </span>            :     case UNLE:
<span class="lineNum">   16342 </span>            :     case UNLT:
<span class="lineNum">   16343 </span>            :     case LTGT:
<span class="lineNum">   16344 </span>            :     case FRACT_CONVERT:
<span class="lineNum">   16345 </span>            :     case UNSIGNED_FRACT_CONVERT:
<span class="lineNum">   16346 </span>            :     case SAT_FRACT:
<span class="lineNum">   16347 </span>            :     case UNSIGNED_SAT_FRACT:
<span class="lineNum">   16348 </span>            :     case SQRT:
<span class="lineNum">   16349 </span>            :     case ASM_OPERANDS:
<span class="lineNum">   16350 </span>            :     case VEC_MERGE:
<span class="lineNum">   16351 </span>            :     case VEC_SELECT:
<span class="lineNum">   16352 </span>            :     case VEC_CONCAT:
<span class="lineNum">   16353 </span>            :     case VEC_DUPLICATE:
<span class="lineNum">   16354 </span>            :     case VEC_SERIES:
<span class="lineNum">   16355 </span>            :     case UNSPEC:
<span class="lineNum">   16356 </span>            :     case HIGH:
<span class="lineNum">   16357 </span>            :     case FMA:
<span class="lineNum">   16358 </span>            :     case STRICT_LOW_PART:
<span class="lineNum">   16359 </span>            :     case CONST_VECTOR:
<span class="lineNum">   16360 </span>            :     case CONST_FIXED:
<span class="lineNum">   16361 </span>            :     case CLRSB:
<span class="lineNum">   16362 </span>            :     case CLOBBER:
<span class="lineNum">   16363 </span>            :     case CLOBBER_HIGH:
<span class="lineNum">   16364 </span>            :       /* If delegitimize_address couldn't do anything with the UNSPEC, we
<span class="lineNum">   16365 </span>            :          can't express it in the debug info.  This can happen e.g. with some
<span class="lineNum">   16366 </span>            :          TLS UNSPECs.  */
<span class="lineNum">   16367 </span>            :       break;
<span class="lineNum">   16368 </span>            : 
<span class="lineNum">   16369 </span><span class="lineCov">      64641 :     case CONST_STRING:</span>
<span class="lineNum">   16370 </span><span class="lineCov">      64641 :       resolve_one_addr (&amp;rtl);</span>
<span class="lineNum">   16371 </span><span class="lineCov">      64641 :       goto symref;</span>
<span class="lineNum">   16372 </span>            : 
<span class="lineNum">   16373 </span>            :     /* RTL sequences inside PARALLEL record a series of DWARF operations for
<span class="lineNum">   16374 </span>            :        the expression.  An UNSPEC rtx represents a raw DWARF operation,
<span class="lineNum">   16375 </span>            :        new_loc_descr is called for it to build the operation directly.
<span class="lineNum">   16376 </span>            :        Otherwise mem_loc_descriptor is called recursively.  */
<span class="lineNum">   16377 </span>            :     case PARALLEL:
<span class="lineNum">   16378 </span>            :       {
<span class="lineNum">   16379 </span>            :         int index = 0;
<span class="lineNum">   16380 </span>            :         dw_loc_descr_ref exp_result = NULL;
<span class="lineNum">   16381 </span>            : 
<span class="lineNum">   16382 </span><span class="lineNoCov">          0 :         for (; index &lt; XVECLEN (rtl, 0); index++)</span>
<span class="lineNum">   16383 </span>            :           {
<span class="lineNum">   16384 </span><span class="lineNoCov">          0 :             rtx elem = XVECEXP (rtl, 0, index);</span>
<span class="lineNum">   16385 </span><span class="lineNoCov">          0 :             if (GET_CODE (elem) == UNSPEC)</span>
<span class="lineNum">   16386 </span>            :               {
<span class="lineNum">   16387 </span>            :                 /* Each DWARF operation UNSPEC contain two operands, if
<span class="lineNum">   16388 </span>            :                    one operand is not used for the operation, const0_rtx is
<span class="lineNum">   16389 </span>            :                    passed.  */
<span class="lineNum">   16390 </span><span class="lineNoCov">          0 :                 gcc_assert (XVECLEN (elem, 0) == 2);</span>
<span class="lineNum">   16391 </span>            : 
<span class="lineNum">   16392 </span><span class="lineNoCov">          0 :                 HOST_WIDE_INT dw_op = XINT (elem, 1);</span>
<span class="lineNum">   16393 </span><span class="lineNoCov">          0 :                 HOST_WIDE_INT oprnd1 = INTVAL (XVECEXP (elem, 0, 0));</span>
<span class="lineNum">   16394 </span><span class="lineNoCov">          0 :                 HOST_WIDE_INT oprnd2 = INTVAL (XVECEXP (elem, 0, 1));</span>
<span class="lineNum">   16395 </span><span class="lineNoCov">          0 :                 exp_result</span>
<span class="lineNum">   16396 </span><span class="lineNoCov">          0 :                   = new_loc_descr ((enum dwarf_location_atom) dw_op, oprnd1,</span>
<span class="lineNum">   16397 </span>            :                                    oprnd2);
<span class="lineNum">   16398 </span>            :               }
<span class="lineNum">   16399 </span>            :             else
<span class="lineNum">   16400 </span><span class="lineNoCov">          0 :               exp_result</span>
<span class="lineNum">   16401 </span><span class="lineNoCov">          0 :                 = mem_loc_descriptor (elem, mode, mem_mode,</span>
<span class="lineNum">   16402 </span>            :                                       VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   16403 </span>            : 
<span class="lineNum">   16404 </span><span class="lineNoCov">          0 :             if (!mem_loc_result)</span>
<span class="lineNum">   16405 </span><span class="lineNoCov">          0 :               mem_loc_result = exp_result;</span>
<span class="lineNum">   16406 </span>            :             else
<span class="lineNum">   16407 </span><span class="lineNoCov">          0 :               add_loc_descr (&amp;mem_loc_result, exp_result);</span>
<span class="lineNum">   16408 </span>            :           }
<span class="lineNum">   16409 </span>            : 
<span class="lineNum">   16410 </span>            :         break;
<span class="lineNum">   16411 </span>            :       }
<span class="lineNum">   16412 </span>            : 
<span class="lineNum">   16413 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">   16414 </span><span class="lineNoCov">          0 :       if (flag_checking)</span>
<span class="lineNum">   16415 </span>            :         {
<span class="lineNum">   16416 </span><span class="lineNoCov">          0 :           print_rtl (stderr, rtl);</span>
<span class="lineNum">   16417 </span><span class="lineNoCov">          0 :           gcc_unreachable ();</span>
<span class="lineNum">   16418 </span>            :         }
<span class="lineNum">   16419 </span>            :       break;
<span class="lineNum">   16420 </span>            :     }
<span class="lineNum">   16421 </span>            : 
<span class="lineNum">   16422 </span><span class="lineCov">   13839596 :   if (mem_loc_result &amp;&amp; initialized == VAR_INIT_STATUS_UNINITIALIZED)</span>
<span class="lineNum">   16423 </span><span class="lineNoCov">          0 :     add_loc_descr (&amp;mem_loc_result, new_loc_descr (DW_OP_GNU_uninit, 0, 0));</span>
<span class="lineNum">   16424 </span>            : 
<span class="lineNum">   16425 </span><span class="lineCov">   13839596 :   return mem_loc_result;</span>
<span class="lineNum">   16426 </span>            : }
<span class="lineNum">   16427 </span>            : 
<span class="lineNum">   16428 </span>            : /* Return a descriptor that describes the concatenation of two locations.
<span class="lineNum">   16429 </span>            :    This is typically a complex variable.  */
<a name="16430"><span class="lineNum">   16430 </span>            : </a>
<span class="lineNum">   16431 </span>            : static dw_loc_descr_ref
<span class="lineNum">   16432 </span><span class="lineCov">      19854 : concat_loc_descriptor (rtx x0, rtx x1, enum var_init_status initialized)</span>
<span class="lineNum">   16433 </span>            : {
<span class="lineNum">   16434 </span>            :   /* At present we only track constant-sized pieces.  */
<span class="lineNum">   16435 </span><span class="lineCov">      19854 :   unsigned int size0, size1;</span>
<span class="lineNum">   16436 </span><span class="lineCov">      39708 :   if (!GET_MODE_SIZE (GET_MODE (x0)).is_constant (&amp;size0)</span>
<span class="lineNum">   16437 </span><span class="lineCov">      39708 :       || !GET_MODE_SIZE (GET_MODE (x1)).is_constant (&amp;size1))</span>
<span class="lineNum">   16438 </span>            :     return 0;
<span class="lineNum">   16439 </span>            : 
<span class="lineNum">   16440 </span><span class="lineCov">      19854 :   dw_loc_descr_ref cc_loc_result = NULL;</span>
<span class="lineNum">   16441 </span><span class="lineCov">      19854 :   dw_loc_descr_ref x0_ref</span>
<span class="lineNum">   16442 </span><span class="lineCov">      19854 :     = loc_descriptor (x0, VOIDmode, VAR_INIT_STATUS_INITIALIZED);</span>
<span class="lineNum">   16443 </span><span class="lineCov">      19854 :   dw_loc_descr_ref x1_ref</span>
<span class="lineNum">   16444 </span><span class="lineCov">      19854 :     = loc_descriptor (x1, VOIDmode, VAR_INIT_STATUS_INITIALIZED);</span>
<span class="lineNum">   16445 </span>            : 
<span class="lineNum">   16446 </span><span class="lineCov">      19854 :   if (x0_ref == 0 || x1_ref == 0)</span>
<span class="lineNum">   16447 </span>            :     return 0;
<span class="lineNum">   16448 </span>            : 
<span class="lineNum">   16449 </span><span class="lineCov">      19295 :   cc_loc_result = x0_ref;</span>
<span class="lineNum">   16450 </span><span class="lineCov">      19295 :   add_loc_descr_op_piece (&amp;cc_loc_result, size0);</span>
<span class="lineNum">   16451 </span>            : 
<span class="lineNum">   16452 </span><span class="lineCov">      19295 :   add_loc_descr (&amp;cc_loc_result, x1_ref);</span>
<span class="lineNum">   16453 </span><span class="lineCov">      19295 :   add_loc_descr_op_piece (&amp;cc_loc_result, size1);</span>
<span class="lineNum">   16454 </span>            : 
<span class="lineNum">   16455 </span><span class="lineCov">      19295 :   if (initialized == VAR_INIT_STATUS_UNINITIALIZED)</span>
<span class="lineNum">   16456 </span><span class="lineNoCov">          0 :     add_loc_descr (&amp;cc_loc_result, new_loc_descr (DW_OP_GNU_uninit, 0, 0));</span>
<span class="lineNum">   16457 </span>            : 
<span class="lineNum">   16458 </span><span class="lineCov">      19295 :   return cc_loc_result;</span>
<span class="lineNum">   16459 </span>            : }
<span class="lineNum">   16460 </span>            : 
<span class="lineNum">   16461 </span>            : /* Return a descriptor that describes the concatenation of N
<span class="lineNum">   16462 </span>            :    locations.  */
<a name="16463"><span class="lineNum">   16463 </span>            : </a>
<span class="lineNum">   16464 </span>            : static dw_loc_descr_ref
<span class="lineNum">   16465 </span><span class="lineCov">      15751 : concatn_loc_descriptor (rtx concatn, enum var_init_status initialized)</span>
<span class="lineNum">   16466 </span>            : {
<span class="lineNum">   16467 </span><span class="lineCov">      15751 :   unsigned int i;</span>
<span class="lineNum">   16468 </span><span class="lineCov">      15751 :   dw_loc_descr_ref cc_loc_result = NULL;</span>
<span class="lineNum">   16469 </span><span class="lineCov">      15751 :   unsigned int n = XVECLEN (concatn, 0);</span>
<span class="lineNum">   16470 </span><span class="lineCov">      15751 :   unsigned int size;</span>
<span class="lineNum">   16471 </span>            : 
<span class="lineNum">   16472 </span><span class="lineCov">      30144 :   for (i = 0; i &lt; n; ++i)</span>
<span class="lineNum">   16473 </span>            :     {
<span class="lineNum">   16474 </span><span class="lineCov">      25097 :       dw_loc_descr_ref ref;</span>
<span class="lineNum">   16475 </span><span class="lineCov">      25097 :       rtx x = XVECEXP (concatn, 0, i);</span>
<span class="lineNum">   16476 </span>            : 
<span class="lineNum">   16477 </span>            :       /* At present we only track constant-sized pieces.  */
<span class="lineNum">   16478 </span><span class="lineCov">      50194 :       if (!GET_MODE_SIZE (GET_MODE (x)).is_constant (&amp;size))</span>
<span class="lineNum">   16479 </span>            :         return NULL;
<span class="lineNum">   16480 </span>            : 
<span class="lineNum">   16481 </span><span class="lineCov">      25097 :       ref = loc_descriptor (x, VOIDmode, VAR_INIT_STATUS_INITIALIZED);</span>
<span class="lineNum">   16482 </span><span class="lineCov">      25097 :       if (ref == NULL)</span>
<span class="lineNum">   16483 </span>            :         return NULL;
<span class="lineNum">   16484 </span>            : 
<span class="lineNum">   16485 </span><span class="lineCov">      14393 :       add_loc_descr (&amp;cc_loc_result, ref);</span>
<span class="lineNum">   16486 </span><span class="lineCov">      14393 :       add_loc_descr_op_piece (&amp;cc_loc_result, size);</span>
<span class="lineNum">   16487 </span>            :     }
<span class="lineNum">   16488 </span>            : 
<span class="lineNum">   16489 </span><span class="lineCov">       5047 :   if (cc_loc_result &amp;&amp; initialized == VAR_INIT_STATUS_UNINITIALIZED)</span>
<span class="lineNum">   16490 </span><span class="lineNoCov">          0 :     add_loc_descr (&amp;cc_loc_result, new_loc_descr (DW_OP_GNU_uninit, 0, 0));</span>
<span class="lineNum">   16491 </span>            : 
<span class="lineNum">   16492 </span><span class="lineCov">       5047 :   return cc_loc_result;</span>
<span class="lineNum">   16493 </span>            : }
<span class="lineNum">   16494 </span>            : 
<span class="lineNum">   16495 </span>            : /* Helper function for loc_descriptor.  Return DW_OP_implicit_pointer
<span class="lineNum">   16496 </span>            :    for DEBUG_IMPLICIT_PTR RTL.  */
<a name="16497"><span class="lineNum">   16497 </span>            : </a>
<span class="lineNum">   16498 </span>            : static dw_loc_descr_ref
<span class="lineNum">   16499 </span><span class="lineCov">    2377743 : implicit_ptr_descriptor (rtx rtl, HOST_WIDE_INT offset)</span>
<span class="lineNum">   16500 </span>            : {
<span class="lineNum">   16501 </span><span class="lineCov">    2377743 :   dw_loc_descr_ref ret;</span>
<span class="lineNum">   16502 </span><span class="lineCov">    2377743 :   dw_die_ref ref;</span>
<span class="lineNum">   16503 </span>            : 
<span class="lineNum">   16504 </span><span class="lineCov">    2377743 :   if (dwarf_strict &amp;&amp; dwarf_version &lt; 5)</span>
<span class="lineNum">   16505 </span>            :     return NULL;
<span class="lineNum">   16506 </span><span class="lineCov">    2377743 :   gcc_assert (TREE_CODE (DEBUG_IMPLICIT_PTR_DECL (rtl)) == VAR_DECL</span>
<span class="lineNum">   16507 </span>            :               || TREE_CODE (DEBUG_IMPLICIT_PTR_DECL (rtl)) == PARM_DECL
<span class="lineNum">   16508 </span>            :               || TREE_CODE (DEBUG_IMPLICIT_PTR_DECL (rtl)) == RESULT_DECL);
<span class="lineNum">   16509 </span><span class="lineCov">    2377743 :   ref = lookup_decl_die (DEBUG_IMPLICIT_PTR_DECL (rtl));</span>
<span class="lineNum">   16510 </span><span class="lineCov">    4755486 :   ret = new_loc_descr (dwarf_OP (DW_OP_implicit_pointer), 0, offset);</span>
<span class="lineNum">   16511 </span><span class="lineCov">    2377743 :   ret-&gt;dw_loc_oprnd2.val_class = dw_val_class_const;</span>
<span class="lineNum">   16512 </span><span class="lineCov">    2377743 :   if (ref)</span>
<span class="lineNum">   16513 </span>            :     {
<span class="lineNum">   16514 </span><span class="lineCov">     461114 :       ret-&gt;dw_loc_oprnd1.val_class = dw_val_class_die_ref;</span>
<span class="lineNum">   16515 </span><span class="lineCov">     461114 :       ret-&gt;dw_loc_oprnd1.v.val_die_ref.die = ref;</span>
<span class="lineNum">   16516 </span><span class="lineCov">     461114 :       ret-&gt;dw_loc_oprnd1.v.val_die_ref.external = 0;</span>
<span class="lineNum">   16517 </span>            :     }
<span class="lineNum">   16518 </span>            :   else
<span class="lineNum">   16519 </span>            :     {
<span class="lineNum">   16520 </span><span class="lineCov">    1916629 :       ret-&gt;dw_loc_oprnd1.val_class = dw_val_class_decl_ref;</span>
<span class="lineNum">   16521 </span><span class="lineCov">    1916629 :       ret-&gt;dw_loc_oprnd1.v.val_decl_ref = DEBUG_IMPLICIT_PTR_DECL (rtl);</span>
<span class="lineNum">   16522 </span>            :     }
<span class="lineNum">   16523 </span>            :   return ret;
<span class="lineNum">   16524 </span>            : }
<span class="lineNum">   16525 </span>            : 
<span class="lineNum">   16526 </span>            : /* Output a proper Dwarf location descriptor for a variable or parameter
<span class="lineNum">   16527 </span>            :    which is either allocated in a register or in a memory location.  For a
<span class="lineNum">   16528 </span>            :    register, we just generate an OP_REG and the register number.  For a
<span class="lineNum">   16529 </span>            :    memory location we provide a Dwarf postfix expression describing how to
<span class="lineNum">   16530 </span>            :    generate the (dynamic) address of the object onto the address stack.
<span class="lineNum">   16531 </span>            : 
<span class="lineNum">   16532 </span>            :    MODE is mode of the decl if this loc_descriptor is going to be used in
<span class="lineNum">   16533 </span>            :    .debug_loc section where DW_OP_stack_value and DW_OP_implicit_value are
<span class="lineNum">   16534 </span>            :    allowed, VOIDmode otherwise.
<span class="lineNum">   16535 </span>            : 
<span class="lineNum">   16536 </span>            :    If we don't know how to describe it, return 0.  */
<a name="16537"><span class="lineNum">   16537 </span>            : </a>
<span class="lineNum">   16538 </span>            : static dw_loc_descr_ref
<span class="lineNum">   16539 </span><span class="lineCov">   36839037 : loc_descriptor (rtx rtl, machine_mode mode,</span>
<span class="lineNum">   16540 </span>            :                 enum var_init_status initialized)
<span class="lineNum">   16541 </span>            : {
<span class="lineNum">   16542 </span><span class="lineCov">   36839037 :   dw_loc_descr_ref loc_result = NULL;</span>
<span class="lineNum">   16543 </span><span class="lineCov">   36839037 :   scalar_int_mode int_mode;</span>
<span class="lineNum">   16544 </span>            : 
<span class="lineNum">   16545 </span><span class="lineCov">   36839037 :   switch (GET_CODE (rtl))</span>
<span class="lineNum">   16546 </span>            :     {
<span class="lineNum">   16547 </span><span class="lineCov">      17260 :     case SUBREG:</span>
<span class="lineNum">   16548 </span>            :       /* The case of a subreg may arise when we have a local (register)
<span class="lineNum">   16549 </span>            :          variable or a formal (register) parameter which doesn't quite fill
<span class="lineNum">   16550 </span>            :          up an entire register.  For now, just assume that it is
<span class="lineNum">   16551 </span>            :          legitimate to make the Dwarf info refer to the whole register which
<span class="lineNum">   16552 </span>            :          contains the given subreg.  */
<span class="lineNum">   16553 </span><span class="lineCov">      17260 :       if (REG_P (SUBREG_REG (rtl)) &amp;&amp; subreg_lowpart_p (rtl))</span>
<span class="lineNum">   16554 </span><span class="lineCov">         72 :         loc_result = loc_descriptor (SUBREG_REG (rtl),</span>
<span class="lineNum">   16555 </span><span class="lineCov">         24 :                                      GET_MODE (SUBREG_REG (rtl)), initialized);</span>
<span class="lineNum">   16556 </span>            :       else
<span class="lineNum">   16557 </span><span class="lineCov">      17236 :         goto do_default;</span>
<span class="lineNum">   16558 </span><span class="lineCov">         24 :       break;</span>
<span class="lineNum">   16559 </span>            : 
<span class="lineNum">   16560 </span><span class="lineCov">    6379888 :     case REG:</span>
<span class="lineNum">   16561 </span><span class="lineCov">    6379888 :       loc_result = reg_loc_descriptor (rtl, initialized);</span>
<span class="lineNum">   16562 </span><span class="lineCov">    6379888 :       break;</span>
<span class="lineNum">   16563 </span>            : 
<span class="lineNum">   16564 </span><span class="lineCov">    2386891 :     case MEM:</span>
<span class="lineNum">   16565 </span><span class="lineCov">    4773782 :       loc_result = mem_loc_descriptor (XEXP (rtl, 0), get_address_mode (rtl),</span>
<span class="lineNum">   16566 </span><span class="lineCov">    2386891 :                                        GET_MODE (rtl), initialized);</span>
<span class="lineNum">   16567 </span><span class="lineCov">    2386891 :       if (loc_result == NULL)</span>
<span class="lineNum">   16568 </span><span class="lineCov">       8649 :         loc_result = tls_mem_loc_descriptor (rtl);</span>
<span class="lineNum">   16569 </span><span class="lineCov">    2386891 :       if (loc_result == NULL)</span>
<span class="lineNum">   16570 </span>            :         {
<span class="lineNum">   16571 </span><span class="lineCov">       8649 :           rtx new_rtl = avoid_constant_pool_reference (rtl);</span>
<span class="lineNum">   16572 </span><span class="lineCov">       8649 :           if (new_rtl != rtl)</span>
<span class="lineNum">   16573 </span><span class="lineNoCov">          0 :             loc_result = loc_descriptor (new_rtl, mode, initialized);</span>
<span class="lineNum">   16574 </span>            :         }
<span class="lineNum">   16575 </span>            :       break;
<span class="lineNum">   16576 </span>            : 
<span class="lineNum">   16577 </span><span class="lineCov">      19854 :     case CONCAT:</span>
<span class="lineNum">   16578 </span><span class="lineCov">      19854 :       loc_result = concat_loc_descriptor (XEXP (rtl, 0), XEXP (rtl, 1),</span>
<span class="lineNum">   16579 </span>            :                                           initialized);
<span class="lineNum">   16580 </span><span class="lineCov">      19854 :       break;</span>
<span class="lineNum">   16581 </span>            : 
<span class="lineNum">   16582 </span><span class="lineCov">      15751 :     case CONCATN:</span>
<span class="lineNum">   16583 </span><span class="lineCov">      15751 :       loc_result = concatn_loc_descriptor (rtl, initialized);</span>
<span class="lineNum">   16584 </span><span class="lineCov">      15751 :       break;</span>
<span class="lineNum">   16585 </span>            : 
<span class="lineNum">   16586 </span><span class="lineCov">   18132044 :     case VAR_LOCATION:</span>
<span class="lineNum">   16587 </span>            :       /* Single part.  */
<span class="lineNum">   16588 </span><span class="lineCov">   18132044 :       if (GET_CODE (PAT_VAR_LOCATION_LOC (rtl)) != PARALLEL)</span>
<span class="lineNum">   16589 </span>            :         {
<span class="lineNum">   16590 </span><span class="lineCov">   18063402 :           rtx loc = PAT_VAR_LOCATION_LOC (rtl);</span>
<span class="lineNum">   16591 </span><span class="lineCov">   18063402 :           if (GET_CODE (loc) == EXPR_LIST)</span>
<span class="lineNum">   16592 </span><span class="lineNoCov">          0 :             loc = XEXP (loc, 0);</span>
<span class="lineNum">   16593 </span><span class="lineCov">   18063402 :           loc_result = loc_descriptor (loc, mode, initialized);</span>
<span class="lineNum">   16594 </span><span class="lineCov">   18063402 :           break;</span>
<span class="lineNum">   16595 </span><span class="lineCov">      68642 :         }</span>
<span class="lineNum">   16596 </span>            : 
<span class="lineNum">   16597 </span><span class="lineCov">      68642 :       rtl = XEXP (rtl, 1);</span>
<span class="lineNum">   16598 </span>            :       /* FALLTHRU */
<span class="lineNum">   16599 </span>            : 
<span class="lineNum">   16600 </span><span class="lineCov">      68862 :     case PARALLEL:</span>
<span class="lineNum">   16601 </span><span class="lineCov">      68862 :       {</span>
<span class="lineNum">   16602 </span><span class="lineCov">      68862 :         rtvec par_elems = XVEC (rtl, 0);</span>
<span class="lineNum">   16603 </span><span class="lineCov">      68862 :         int num_elem = GET_NUM_ELEM (par_elems);</span>
<span class="lineNum">   16604 </span><span class="lineCov">      68862 :         machine_mode mode;</span>
<span class="lineNum">   16605 </span><span class="lineCov">      68862 :         int i, size;</span>
<span class="lineNum">   16606 </span>            : 
<span class="lineNum">   16607 </span>            :         /* Create the first one, so we have something to add to.  */
<span class="lineNum">   16608 </span><span class="lineCov">      68862 :         loc_result = loc_descriptor (XEXP (RTVEC_ELT (par_elems, 0), 0),</span>
<span class="lineNum">   16609 </span>            :                                      VOIDmode, initialized);
<span class="lineNum">   16610 </span><span class="lineCov">      68862 :         if (loc_result == NULL)</span>
<span class="lineNum">   16611 </span>            :           return NULL;
<span class="lineNum">   16612 </span><span class="lineCov">      68862 :         mode = GET_MODE (XEXP (RTVEC_ELT (par_elems, 0), 0));</span>
<span class="lineNum">   16613 </span>            :         /* At present we only track constant-sized pieces.  */
<span class="lineNum">   16614 </span><span class="lineCov">     137724 :         if (!GET_MODE_SIZE (mode).is_constant (&amp;size))</span>
<span class="lineNum">   16615 </span>            :           return NULL;
<span class="lineNum">   16616 </span><span class="lineCov">      68862 :         add_loc_descr_op_piece (&amp;loc_result, size);</span>
<span class="lineNum">   16617 </span><span class="lineCov">     137722 :         for (i = 1; i &lt; num_elem; i++)</span>
<span class="lineNum">   16618 </span>            :           {
<span class="lineNum">   16619 </span><span class="lineCov">      68860 :             dw_loc_descr_ref temp;</span>
<span class="lineNum">   16620 </span>            : 
<span class="lineNum">   16621 </span><span class="lineCov">      68860 :             temp = loc_descriptor (XEXP (RTVEC_ELT (par_elems, i), 0),</span>
<span class="lineNum">   16622 </span>            :                                    VOIDmode, initialized);
<span class="lineNum">   16623 </span><span class="lineCov">      68860 :             if (temp == NULL)</span>
<span class="lineNum">   16624 </span>            :               return NULL;
<span class="lineNum">   16625 </span><span class="lineCov">      68860 :             add_loc_descr (&amp;loc_result, temp);</span>
<span class="lineNum">   16626 </span><span class="lineCov">      68860 :             mode = GET_MODE (XEXP (RTVEC_ELT (par_elems, i), 0));</span>
<span class="lineNum">   16627 </span>            :             /* At present we only track constant-sized pieces.  */
<span class="lineNum">   16628 </span><span class="lineCov">     137720 :             if (!GET_MODE_SIZE (mode).is_constant (&amp;size))</span>
<span class="lineNum">   16629 </span>            :               return NULL;
<span class="lineNum">   16630 </span><span class="lineCov">      68860 :             add_loc_descr_op_piece (&amp;loc_result, size);</span>
<span class="lineNum">   16631 </span>            :           }
<span class="lineNum">   16632 </span>            :       }
<span class="lineNum">   16633 </span>            :       break;
<span class="lineNum">   16634 </span>            : 
<span class="lineNum">   16635 </span><span class="lineCov">    1364638 :     case CONST_INT:</span>
<span class="lineNum">   16636 </span><span class="lineCov">    1364638 :       if (mode != VOIDmode &amp;&amp; mode != BLKmode)</span>
<span class="lineNum">   16637 </span>            :         {
<span class="lineNum">   16638 </span><span class="lineCov">    1360556 :           int_mode = as_a &lt;scalar_int_mode&gt; (mode);</span>
<span class="lineNum">   16639 </span><span class="lineCov">    2721112 :           loc_result = address_of_int_loc_descriptor (GET_MODE_SIZE (int_mode),</span>
<span class="lineNum">   16640 </span>            :                                                       INTVAL (rtl));
<span class="lineNum">   16641 </span>            :         }
<span class="lineNum">   16642 </span>            :       break;
<span class="lineNum">   16643 </span>            : 
<span class="lineNum">   16644 </span><span class="lineCov">      49044 :     case CONST_DOUBLE:</span>
<span class="lineNum">   16645 </span><span class="lineCov">      49044 :       if (mode == VOIDmode)</span>
<span class="lineNum">   16646 </span><span class="lineCov">      10417 :         mode = GET_MODE (rtl);</span>
<span class="lineNum">   16647 </span>            : 
<span class="lineNum">   16648 </span><span class="lineCov">      49044 :       if (mode != VOIDmode &amp;&amp; (dwarf_version &gt;= 4 || !dwarf_strict))</span>
<span class="lineNum">   16649 </span>            :         {
<span class="lineNum">   16650 </span><span class="lineCov">      49044 :           gcc_assert (mode == GET_MODE (rtl) || VOIDmode == GET_MODE (rtl));</span>
<span class="lineNum">   16651 </span>            : 
<span class="lineNum">   16652 </span>            :           /* Note that a CONST_DOUBLE rtx could represent either an integer
<span class="lineNum">   16653 </span>            :              or a floating-point constant.  A CONST_DOUBLE is used whenever
<span class="lineNum">   16654 </span>            :              the constant requires more than one word in order to be
<span class="lineNum">   16655 </span>            :              adequately represented.  We output CONST_DOUBLEs as blocks.  */
<span class="lineNum">   16656 </span><span class="lineCov">      49044 :           scalar_mode smode = as_a &lt;scalar_mode&gt; (mode);</span>
<span class="lineNum">   16657 </span><span class="lineCov">     147132 :           loc_result = new_loc_descr (DW_OP_implicit_value,</span>
<span class="lineNum">   16658 </span><span class="lineCov">      98088 :                                       GET_MODE_SIZE (smode), 0);</span>
<span class="lineNum">   16659 </span>            : #if TARGET_SUPPORTS_WIDE_INT == 0
<span class="lineNum">   16660 </span>            :           if (!SCALAR_FLOAT_MODE_P (smode))
<span class="lineNum">   16661 </span>            :             {
<span class="lineNum">   16662 </span>            :               loc_result-&gt;dw_loc_oprnd2.val_class = dw_val_class_const_double;
<span class="lineNum">   16663 </span>            :               loc_result-&gt;dw_loc_oprnd2.v.val_double
<span class="lineNum">   16664 </span>            :                 = rtx_to_double_int (rtl);
<span class="lineNum">   16665 </span>            :             }
<span class="lineNum">   16666 </span>            :           else
<span class="lineNum">   16667 </span>            : #endif
<span class="lineNum">   16668 </span><span class="lineCov">      49044 :             {</span>
<span class="lineNum">   16669 </span><span class="lineCov">      49044 :               unsigned int length = GET_MODE_SIZE (smode);</span>
<span class="lineNum">   16670 </span><span class="lineCov">      49044 :               unsigned char *array = ggc_vec_alloc&lt;unsigned char&gt; (length);</span>
<span class="lineNum">   16671 </span>            : 
<span class="lineNum">   16672 </span><span class="lineCov">      49044 :               insert_float (rtl, array);</span>
<span class="lineNum">   16673 </span><span class="lineCov">      49044 :               loc_result-&gt;dw_loc_oprnd2.val_class = dw_val_class_vec;</span>
<span class="lineNum">   16674 </span><span class="lineCov">      49044 :               loc_result-&gt;dw_loc_oprnd2.v.val_vec.length = length / 4;</span>
<span class="lineNum">   16675 </span><span class="lineCov">      49044 :               loc_result-&gt;dw_loc_oprnd2.v.val_vec.elt_size = 4;</span>
<span class="lineNum">   16676 </span><span class="lineCov">      49044 :               loc_result-&gt;dw_loc_oprnd2.v.val_vec.array = array;</span>
<span class="lineNum">   16677 </span>            :             }
<span class="lineNum">   16678 </span>            :         }
<span class="lineNum">   16679 </span>            :       break;
<span class="lineNum">   16680 </span>            : 
<span class="lineNum">   16681 </span><span class="lineCov">         79 :     case CONST_WIDE_INT:</span>
<span class="lineNum">   16682 </span><span class="lineCov">         79 :       if (mode == VOIDmode)</span>
<span class="lineNum">   16683 </span><span class="lineCov">          1 :         mode = GET_MODE (rtl);</span>
<span class="lineNum">   16684 </span>            : 
<span class="lineNum">   16685 </span><span class="lineCov">         79 :       if (mode != VOIDmode &amp;&amp; (dwarf_version &gt;= 4 || !dwarf_strict))</span>
<span class="lineNum">   16686 </span>            :         {
<span class="lineNum">   16687 </span><span class="lineCov">         78 :           int_mode = as_a &lt;scalar_int_mode&gt; (mode);</span>
<span class="lineNum">   16688 </span><span class="lineCov">        234 :           loc_result = new_loc_descr (DW_OP_implicit_value,</span>
<span class="lineNum">   16689 </span><span class="lineCov">        156 :                                       GET_MODE_SIZE (int_mode), 0);</span>
<span class="lineNum">   16690 </span><span class="lineCov">         78 :           loc_result-&gt;dw_loc_oprnd2.val_class = dw_val_class_wide_int;</span>
<span class="lineNum">   16691 </span><span class="lineCov">         78 :           loc_result-&gt;dw_loc_oprnd2.v.val_wide = ggc_alloc&lt;wide_int&gt; ();</span>
<span class="lineNum">   16692 </span><span class="lineCov">        156 :           *loc_result-&gt;dw_loc_oprnd2.v.val_wide = rtx_mode_t (rtl, int_mode);</span>
<span class="lineNum">   16693 </span>            :         }
<span class="lineNum">   16694 </span>            :       break;
<span class="lineNum">   16695 </span>            : 
<span class="lineNum">   16696 </span><span class="lineCov">          5 :     case CONST_VECTOR:</span>
<span class="lineNum">   16697 </span><span class="lineCov">          5 :       if (mode == VOIDmode)</span>
<span class="lineNum">   16698 </span><span class="lineNoCov">          0 :         mode = GET_MODE (rtl);</span>
<span class="lineNum">   16699 </span>            : 
<span class="lineNum">   16700 </span><span class="lineCov">          5 :       if (mode != VOIDmode &amp;&amp; (dwarf_version &gt;= 4 || !dwarf_strict))</span>
<span class="lineNum">   16701 </span>            :         {
<span class="lineNum">   16702 </span><span class="lineCov">          5 :           unsigned int length;</span>
<span class="lineNum">   16703 </span><span class="lineCov">         10 :           if (!CONST_VECTOR_NUNITS (rtl).is_constant (&amp;length))</span>
<span class="lineNum">   16704 </span>            :             return NULL;
<span class="lineNum">   16705 </span>            : 
<span class="lineNum">   16706 </span><span class="lineCov">          5 :           unsigned int elt_size = GET_MODE_UNIT_SIZE (GET_MODE (rtl));</span>
<span class="lineNum">   16707 </span><span class="lineCov">          5 :           unsigned char *array</span>
<span class="lineNum">   16708 </span><span class="lineCov">          5 :             = ggc_vec_alloc&lt;unsigned char&gt; (length * elt_size);</span>
<span class="lineNum">   16709 </span><span class="lineCov">          5 :           unsigned int i;</span>
<span class="lineNum">   16710 </span><span class="lineCov">          5 :           unsigned char *p;</span>
<span class="lineNum">   16711 </span><span class="lineCov">         10 :           machine_mode imode = GET_MODE_INNER (mode);</span>
<span class="lineNum">   16712 </span>            : 
<span class="lineNum">   16713 </span><span class="lineCov">          5 :           gcc_assert (mode == GET_MODE (rtl) || VOIDmode == GET_MODE (rtl));</span>
<span class="lineNum">   16714 </span><span class="lineCov">          5 :           switch (GET_MODE_CLASS (mode))</span>
<span class="lineNum">   16715 </span>            :             {
<span class="lineNum">   16716 </span>            :             case MODE_VECTOR_INT:
<span class="lineNum">   16717 </span><span class="lineCov">         25 :               for (i = 0, p = array; i &lt; length; i++, p += elt_size)</span>
<span class="lineNum">   16718 </span>            :                 {
<span class="lineNum">   16719 </span><span class="lineCov">         20 :                   rtx elt = CONST_VECTOR_ELT (rtl, i);</span>
<span class="lineNum">   16720 </span><span class="lineCov">         40 :                   insert_wide_int (rtx_mode_t (elt, imode), p, elt_size);</span>
<span class="lineNum">   16721 </span><span class="lineCov">          5 :                 }</span>
<span class="lineNum">   16722 </span>            :               break;
<span class="lineNum">   16723 </span>            : 
<span class="lineNum">   16724 </span>            :             case MODE_VECTOR_FLOAT:
<span class="lineNum">   16725 </span><span class="lineNoCov">          0 :               for (i = 0, p = array; i &lt; length; i++, p += elt_size)</span>
<span class="lineNum">   16726 </span>            :                 {
<span class="lineNum">   16727 </span><span class="lineNoCov">          0 :                   rtx elt = CONST_VECTOR_ELT (rtl, i);</span>
<span class="lineNum">   16728 </span><span class="lineNoCov">          0 :                   insert_float (elt, p);</span>
<span class="lineNum">   16729 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">   16730 </span>            :               break;
<span class="lineNum">   16731 </span>            : 
<span class="lineNum">   16732 </span><span class="lineNoCov">          0 :             default:</span>
<span class="lineNum">   16733 </span><span class="lineNoCov">          0 :               gcc_unreachable ();</span>
<span class="lineNum">   16734 </span>            :             }
<span class="lineNum">   16735 </span>            : 
<span class="lineNum">   16736 </span><span class="lineCov">          5 :           loc_result = new_loc_descr (DW_OP_implicit_value,</span>
<span class="lineNum">   16737 </span>            :                                       length * elt_size, 0);
<span class="lineNum">   16738 </span><span class="lineCov">          5 :           loc_result-&gt;dw_loc_oprnd2.val_class = dw_val_class_vec;</span>
<span class="lineNum">   16739 </span><span class="lineCov">          5 :           loc_result-&gt;dw_loc_oprnd2.v.val_vec.length = length;</span>
<span class="lineNum">   16740 </span><span class="lineCov">          5 :           loc_result-&gt;dw_loc_oprnd2.v.val_vec.elt_size = elt_size;</span>
<span class="lineNum">   16741 </span><span class="lineCov">          5 :           loc_result-&gt;dw_loc_oprnd2.v.val_vec.array = array;</span>
<span class="lineNum">   16742 </span>            :         }
<span class="lineNum">   16743 </span>            :       break;
<span class="lineNum">   16744 </span>            : 
<span class="lineNum">   16745 </span><span class="lineCov">      87320 :     case CONST:</span>
<span class="lineNum">   16746 </span><span class="lineCov">      87320 :       if (mode == VOIDmode</span>
<span class="lineNum">   16747 </span><span class="lineCov">      87320 :           || CONST_SCALAR_INT_P (XEXP (rtl, 0))</span>
<span class="lineNum">   16748 </span><span class="lineCov">      87320 :           || CONST_DOUBLE_AS_FLOAT_P (XEXP (rtl, 0))</span>
<span class="lineNum">   16749 </span><span class="lineCov">      87320 :           || GET_CODE (XEXP (rtl, 0)) == CONST_VECTOR)</span>
<span class="lineNum">   16750 </span>            :         {
<span class="lineNum">   16751 </span><span class="lineNoCov">          0 :           loc_result = loc_descriptor (XEXP (rtl, 0), mode, initialized);</span>
<span class="lineNum">   16752 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   16753 </span>            :         }
<span class="lineNum">   16754 </span>            :       /* FALLTHROUGH */
<span class="lineNum">   16755 </span><span class="lineCov">     429257 :     case SYMBOL_REF:</span>
<span class="lineNum">   16756 </span><span class="lineCov">     429257 :       if (!const_ok_for_output (rtl))</span>
<span class="lineNum">   16757 </span>            :         break;
<span class="lineNum">   16758 </span>            :       /* FALLTHROUGH */
<span class="lineNum">   16759 </span><span class="lineCov">     376543 :     case LABEL_REF:</span>
<span class="lineNum">   16760 </span><span class="lineCov">     376543 :       if (is_a &lt;scalar_int_mode&gt; (mode, &amp;int_mode)</span>
<span class="lineNum">   16761 </span><span class="lineCov">     772624 :           &amp;&amp; GET_MODE_SIZE (int_mode) == DWARF2_ADDR_SIZE</span>
<span class="lineNum">   16762 </span><span class="lineCov">     753084 :           &amp;&amp; (dwarf_version &gt;= 4 || !dwarf_strict))</span>
<span class="lineNum">   16763 </span>            :         {
<span class="lineNum">   16764 </span><span class="lineCov">     376541 :          loc_result = new_addr_loc_descr (rtl, dtprel_false);</span>
<span class="lineNum">   16765 </span><span class="lineCov">     376541 :           add_loc_descr (&amp;loc_result, new_loc_descr (DW_OP_stack_value, 0, 0));</span>
<span class="lineNum">   16766 </span><span class="lineCov">     376541 :           vec_safe_push (used_rtx_array, rtl);</span>
<span class="lineNum">   16767 </span>            :         }
<span class="lineNum">   16768 </span>            :       break;
<span class="lineNum">   16769 </span>            : 
<span class="lineNum">   16770 </span><span class="lineCov">    2082987 :     case DEBUG_IMPLICIT_PTR:</span>
<span class="lineNum">   16771 </span><span class="lineCov">    2082987 :       loc_result = implicit_ptr_descriptor (rtl, 0);</span>
<span class="lineNum">   16772 </span><span class="lineCov">    2082987 :       break;</span>
<span class="lineNum">   16773 </span>            : 
<span class="lineNum">   16774 </span><span class="lineCov">    4857415 :     case PLUS:</span>
<span class="lineNum">   16775 </span><span class="lineCov">    4857415 :       if (GET_CODE (XEXP (rtl, 0)) == DEBUG_IMPLICIT_PTR</span>
<span class="lineNum">   16776 </span><span class="lineCov">     294756 :           &amp;&amp; CONST_INT_P (XEXP (rtl, 1)))</span>
<span class="lineNum">   16777 </span>            :         {
<span class="lineNum">   16778 </span><span class="lineCov">     294756 :           loc_result</span>
<span class="lineNum">   16779 </span><span class="lineCov">     294756 :             = implicit_ptr_descriptor (XEXP (rtl, 0), INTVAL (XEXP (rtl, 1)));</span>
<span class="lineNum">   16780 </span><span class="lineCov">     294756 :           break;</span>
<span class="lineNum">   16781 </span>            :         }
<span class="lineNum">   16782 </span>            :       /* FALLTHRU */
<span class="lineNum">   16783 </span><span class="lineCov">    4562659 :     do_default:</span>
<span class="lineNum">   16784 </span><span class="lineCov">    5683594 :     default:</span>
<span class="lineNum">   16785 </span><span class="lineCov">    5683594 :       if ((is_a &lt;scalar_int_mode&gt; (mode, &amp;int_mode)</span>
<span class="lineNum">   16786 </span><span class="lineCov">   11301208 :            &amp;&amp; GET_MODE (rtl) == int_mode</span>
<span class="lineNum">   16787 </span><span class="lineCov">   11593640 :            &amp;&amp; GET_MODE_SIZE (int_mode) &lt;= DWARF2_ADDR_SIZE</span>
<span class="lineNum">   16788 </span><span class="lineCov">    5624923 :            &amp;&amp; dwarf_version &gt;= 4)</span>
<span class="lineNum">   16789 </span><span class="lineCov">    5710280 :           || (!dwarf_strict &amp;&amp; mode != VOIDmode &amp;&amp; mode != BLKmode))</span>
<span class="lineNum">   16790 </span>            :         {
<span class="lineNum">   16791 </span>            :           /* Value expression.  */
<span class="lineNum">   16792 </span><span class="lineCov">    5683110 :           loc_result = mem_loc_descriptor (rtl, mode, VOIDmode, initialized);</span>
<span class="lineNum">   16793 </span><span class="lineCov">    5683110 :           if (loc_result)</span>
<span class="lineNum">   16794 </span><span class="lineCov">    5648124 :             add_loc_descr (&amp;loc_result,</span>
<span class="lineNum">   16795 </span>            :                            new_loc_descr (DW_OP_stack_value, 0, 0));
<span class="lineNum">   16796 </span>            :         }
<span class="lineNum">   16797 </span>            :       break;
<span class="lineNum">   16798 </span>            :     }
<span class="lineNum">   16799 </span>            : 
<span class="lineNum">   16800 </span><span class="lineCov">   36839037 :   return loc_result;</span>
<span class="lineNum">   16801 </span>            : }
<span class="lineNum">   16802 </span>            : 
<span class="lineNum">   16803 </span>            : /* We need to figure out what section we should use as the base for the
<span class="lineNum">   16804 </span>            :    address ranges where a given location is valid.
<span class="lineNum">   16805 </span>            :    1. If this particular DECL has a section associated with it, use that.
<span class="lineNum">   16806 </span>            :    2. If this function has a section associated with it, use that.
<span class="lineNum">   16807 </span>            :    3. Otherwise, use the text section.
<span class="lineNum">   16808 </span>            :    XXX: If you split a variable across multiple sections, we won't notice.  */
<a name="16809"><span class="lineNum">   16809 </span>            : </a>
<span class="lineNum">   16810 </span>            : static const char *
<span class="lineNum">   16811 </span><span class="lineCov">    8183298 : secname_for_decl (const_tree decl)</span>
<span class="lineNum">   16812 </span>            : {
<span class="lineNum">   16813 </span><span class="lineCov">    8183298 :   const char *secname;</span>
<span class="lineNum">   16814 </span>            : 
<span class="lineNum">   16815 </span><span class="lineCov">    8183298 :   if (VAR_OR_FUNCTION_DECL_P (decl)</span>
<span class="lineNum">   16816 </span><span class="lineCov">    7579903 :       &amp;&amp; (DECL_EXTERNAL (decl) || TREE_PUBLIC (decl) || TREE_STATIC (decl))</span>
<span class="lineNum">   16817 </span><span class="lineCov">    8185942 :       &amp;&amp; DECL_SECTION_NAME (decl))</span>
<span class="lineNum">   16818 </span><span class="lineCov">        389 :     secname = DECL_SECTION_NAME (decl);</span>
<span class="lineNum">   16819 </span><span class="lineCov">    8182909 :   else if (current_function_decl &amp;&amp; DECL_SECTION_NAME (current_function_decl))</span>
<span class="lineNum">   16820 </span><span class="lineCov">    6876616 :     secname = DECL_SECTION_NAME (current_function_decl);</span>
<span class="lineNum">   16821 </span><span class="lineCov">    1306293 :   else if (cfun &amp;&amp; in_cold_section_p)</span>
<span class="lineNum">   16822 </span><span class="lineCov">      22366 :     secname = crtl-&gt;subsections.cold_section_label;</span>
<span class="lineNum">   16823 </span>            :   else
<span class="lineNum">   16824 </span>            :     secname = text_section_label;
<span class="lineNum">   16825 </span>            : 
<span class="lineNum">   16826 </span><span class="lineCov">    8183298 :   return secname;</span>
<span class="lineNum">   16827 </span>            : }
<span class="lineNum">   16828 </span>            : 
<span class="lineNum">   16829 </span>            : /* Return true when DECL_BY_REFERENCE is defined and set for DECL.  */
<a name="16830"><span class="lineNum">   16830 </span>            : </a>
<span class="lineNum">   16831 </span>            : static bool
<span class="lineNum">   16832 </span><span class="lineCov">   15329768 : decl_by_reference_p (tree decl)</span>
<span class="lineNum">   16833 </span>            : {
<span class="lineNum">   16834 </span><span class="lineCov">   15329768 :   return ((TREE_CODE (decl) == PARM_DECL || TREE_CODE (decl) == RESULT_DECL</span>
<span class="lineNum">   16835 </span><span class="lineCov">   12647480 :            || VAR_P (decl))</span>
<span class="lineNum">   16836 </span><span class="lineCov">   30659536 :           &amp;&amp; DECL_BY_REFERENCE (decl));</span>
<span class="lineNum">   16837 </span>            : }
<span class="lineNum">   16838 </span>            : 
<span class="lineNum">   16839 </span>            : /* Helper function for dw_loc_list.  Compute proper Dwarf location descriptor
<span class="lineNum">   16840 </span>            :    for VARLOC.  */
<a name="16841"><span class="lineNum">   16841 </span>            : </a>
<span class="lineNum">   16842 </span>            : static dw_loc_descr_ref
<span class="lineNum">   16843 </span><span class="lineCov">   18195153 : dw_loc_list_1 (tree loc, rtx varloc, int want_address,</span>
<span class="lineNum">   16844 </span>            :                enum var_init_status initialized)
<span class="lineNum">   16845 </span>            : {
<span class="lineNum">   16846 </span><span class="lineCov">   18195153 :   int have_address = 0;</span>
<span class="lineNum">   16847 </span><span class="lineCov">   18195153 :   dw_loc_descr_ref descr;</span>
<span class="lineNum">   16848 </span><span class="lineCov">   18195153 :   machine_mode mode;</span>
<span class="lineNum">   16849 </span>            : 
<span class="lineNum">   16850 </span><span class="lineCov">   18195153 :   if (want_address != 2)</span>
<span class="lineNum">   16851 </span>            :     {
<span class="lineNum">   16852 </span><span class="lineCov">      63109 :       gcc_assert (GET_CODE (varloc) == VAR_LOCATION);</span>
<span class="lineNum">   16853 </span>            :       /* Single part.  */
<span class="lineNum">   16854 </span><span class="lineCov">      63109 :       if (GET_CODE (PAT_VAR_LOCATION_LOC (varloc)) != PARALLEL)</span>
<span class="lineNum">   16855 </span>            :         {
<span class="lineNum">   16856 </span><span class="lineCov">      63109 :           varloc = PAT_VAR_LOCATION_LOC (varloc);</span>
<span class="lineNum">   16857 </span><span class="lineCov">      63109 :           if (GET_CODE (varloc) == EXPR_LIST)</span>
<span class="lineNum">   16858 </span><span class="lineNoCov">          0 :             varloc = XEXP (varloc, 0);</span>
<span class="lineNum">   16859 </span><span class="lineCov">      63109 :           mode = GET_MODE (varloc);</span>
<span class="lineNum">   16860 </span><span class="lineCov">      63109 :           if (MEM_P (varloc))</span>
<span class="lineNum">   16861 </span>            :             {
<span class="lineNum">   16862 </span><span class="lineCov">       4180 :               rtx addr = XEXP (varloc, 0);</span>
<span class="lineNum">   16863 </span><span class="lineCov">       4180 :               descr = mem_loc_descriptor (addr, get_address_mode (varloc),</span>
<span class="lineNum">   16864 </span>            :                                           mode, initialized);
<span class="lineNum">   16865 </span><span class="lineCov">       4180 :               if (descr)</span>
<span class="lineNum">   16866 </span>            :                 have_address = 1;
<span class="lineNum">   16867 </span>            :               else
<span class="lineNum">   16868 </span>            :                 {
<span class="lineNum">   16869 </span><span class="lineNoCov">          0 :                   rtx x = avoid_constant_pool_reference (varloc);</span>
<span class="lineNum">   16870 </span><span class="lineNoCov">          0 :                   if (x != varloc)</span>
<span class="lineNum">   16871 </span><span class="lineNoCov">          0 :                     descr = mem_loc_descriptor (x, mode, VOIDmode,</span>
<span class="lineNum">   16872 </span>            :                                                 initialized);
<span class="lineNum">   16873 </span>            :                 }
<span class="lineNum">   16874 </span>            :             }
<span class="lineNum">   16875 </span>            :           else
<span class="lineNum">   16876 </span><span class="lineCov">      58929 :             descr = mem_loc_descriptor (varloc, mode, VOIDmode, initialized);</span>
<span class="lineNum">   16877 </span>            :         }
<span class="lineNum">   16878 </span>            :       else
<span class="lineNum">   16879 </span>            :         return 0;
<span class="lineNum">   16880 </span>            :     }
<span class="lineNum">   16881 </span>            :   else
<span class="lineNum">   16882 </span>            :     {
<span class="lineNum">   16883 </span><span class="lineCov">   18132044 :       if (GET_CODE (varloc) == VAR_LOCATION)</span>
<span class="lineNum">   16884 </span><span class="lineCov">   18132044 :         mode = DECL_MODE (PAT_VAR_LOCATION_DECL (varloc));</span>
<span class="lineNum">   16885 </span>            :       else
<span class="lineNum">   16886 </span><span class="lineNoCov">          0 :         mode = DECL_MODE (loc);</span>
<span class="lineNum">   16887 </span><span class="lineCov">   18132044 :       descr = loc_descriptor (varloc, mode, initialized);</span>
<span class="lineNum">   16888 </span><span class="lineCov">   18132044 :       have_address = 1;</span>
<span class="lineNum">   16889 </span>            :     }
<span class="lineNum">   16890 </span>            : 
<span class="lineNum">   16891 </span><span class="lineCov">   18195153 :   if (!descr)</span>
<span class="lineNum">   16892 </span>            :     return 0;
<span class="lineNum">   16893 </span>            : 
<span class="lineNum">   16894 </span><span class="lineCov">   18095032 :   if (want_address == 2 &amp;&amp; !have_address</span>
<span class="lineNum">   16895 </span><span class="lineNoCov">          0 :       &amp;&amp; (dwarf_version &gt;= 4 || !dwarf_strict))</span>
<span class="lineNum">   16896 </span>            :     {
<span class="lineNum">   16897 </span><span class="lineNoCov">          0 :       if (int_size_in_bytes (TREE_TYPE (loc)) &gt; DWARF2_ADDR_SIZE)</span>
<span class="lineNum">   16898 </span>            :         {
<span class="lineNum">   16899 </span><span class="lineNoCov">          0 :           expansion_failed (loc, NULL_RTX,</span>
<span class="lineNum">   16900 </span>            :                             &quot;DWARF address size mismatch&quot;);
<span class="lineNum">   16901 </span><span class="lineNoCov">          0 :           return 0;</span>
<span class="lineNum">   16902 </span>            :         }
<span class="lineNum">   16903 </span><span class="lineNoCov">          0 :       add_loc_descr (&amp;descr, new_loc_descr (DW_OP_stack_value, 0, 0));</span>
<span class="lineNum">   16904 </span><span class="lineNoCov">          0 :       have_address = 1;</span>
<span class="lineNum">   16905 </span>            :     }
<span class="lineNum">   16906 </span>            :   /* Show if we can't fill the request for an address.  */
<span class="lineNum">   16907 </span><span class="lineCov">   18095032 :   if (want_address &amp;&amp; !have_address)</span>
<span class="lineNum">   16908 </span>            :     {
<span class="lineNum">   16909 </span><span class="lineNoCov">          0 :       expansion_failed (loc, NULL_RTX,</span>
<span class="lineNum">   16910 </span>            :                         &quot;Want address and only have value&quot;);
<span class="lineNum">   16911 </span><span class="lineNoCov">          0 :       return 0;</span>
<span class="lineNum">   16912 </span>            :     }
<span class="lineNum">   16913 </span>            : 
<span class="lineNum">   16914 </span>            :   /* If we've got an address and don't want one, dereference.  */
<span class="lineNum">   16915 </span><span class="lineCov">   18095032 :   if (!want_address &amp;&amp; have_address)</span>
<span class="lineNum">   16916 </span>            :     {
<span class="lineNum">   16917 </span><span class="lineCov">       4180 :       HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (loc));</span>
<span class="lineNum">   16918 </span><span class="lineCov">       4180 :       enum dwarf_location_atom op;</span>
<span class="lineNum">   16919 </span>            : 
<span class="lineNum">   16920 </span><span class="lineCov">       5774 :       if (size &gt; DWARF2_ADDR_SIZE || size == -1)</span>
<span class="lineNum">   16921 </span>            :         {
<span class="lineNum">   16922 </span><span class="lineNoCov">          0 :           expansion_failed (loc, NULL_RTX,</span>
<span class="lineNum">   16923 </span>            :                             &quot;DWARF address size mismatch&quot;);
<span class="lineNum">   16924 </span><span class="lineNoCov">          0 :           return 0;</span>
<span class="lineNum">   16925 </span>            :         }
<span class="lineNum">   16926 </span><span class="lineCov">       4180 :       else if (size == DWARF2_ADDR_SIZE)</span>
<span class="lineNum">   16927 </span>            :         op = DW_OP_deref;
<span class="lineNum">   16928 </span>            :       else
<span class="lineNum">   16929 </span><span class="lineNoCov">          0 :         op = DW_OP_deref_size;</span>
<span class="lineNum">   16930 </span>            : 
<span class="lineNum">   16931 </span><span class="lineCov">       4180 :       add_loc_descr (&amp;descr, new_loc_descr (op, size, 0));</span>
<span class="lineNum">   16932 </span>            :     }
<span class="lineNum">   16933 </span>            : 
<span class="lineNum">   16934 </span><span class="lineCov">   18095032 :   return descr;</span>
<span class="lineNum">   16935 </span>            : }
<span class="lineNum">   16936 </span>            : 
<span class="lineNum">   16937 </span>            : /* Create a DW_OP_piece or DW_OP_bit_piece for bitsize, or return NULL
<span class="lineNum">   16938 </span>            :    if it is not possible.  */
<a name="16939"><span class="lineNum">   16939 </span>            : </a>
<span class="lineNum">   16940 </span>            : static dw_loc_descr_ref
<span class="lineNum">   16941 </span><span class="lineCov">    2217490 : new_loc_descr_op_bit_piece (HOST_WIDE_INT bitsize, HOST_WIDE_INT offset)</span>
<span class="lineNum">   16942 </span>            : {
<span class="lineNum">   16943 </span><span class="lineCov">    2217490 :   if ((bitsize % BITS_PER_UNIT) == 0 &amp;&amp; offset == 0)</span>
<span class="lineNum">   16944 </span><span class="lineCov">    2215261 :     return new_loc_descr (DW_OP_piece, bitsize / BITS_PER_UNIT, 0);</span>
<span class="lineNum">   16945 </span><span class="lineCov">       2229 :   else if (dwarf_version &gt;= 3 || !dwarf_strict)</span>
<span class="lineNum">   16946 </span><span class="lineCov">       2229 :     return new_loc_descr (DW_OP_bit_piece, bitsize, offset);</span>
<span class="lineNum">   16947 </span>            :   else
<span class="lineNum">   16948 </span>            :     return NULL;
<span class="lineNum">   16949 </span>            : }
<span class="lineNum">   16950 </span>            : 
<span class="lineNum">   16951 </span>            : /* Helper function for dw_loc_list.  Compute proper Dwarf location descriptor
<span class="lineNum">   16952 </span>            :    for VAR_LOC_NOTE for variable DECL that has been optimized by SRA.  */
<a name="16953"><span class="lineNum">   16953 </span>            : </a>
<span class="lineNum">   16954 </span>            : static dw_loc_descr_ref
<span class="lineNum">   16955 </span><span class="lineCov">    1320988 : dw_sra_loc_expr (tree decl, rtx loc)</span>
<span class="lineNum">   16956 </span>            : {
<span class="lineNum">   16957 </span><span class="lineCov">    1320988 :   rtx p;</span>
<span class="lineNum">   16958 </span><span class="lineCov">    1320988 :   unsigned HOST_WIDE_INT padsize = 0;</span>
<span class="lineNum">   16959 </span><span class="lineCov">    1320988 :   dw_loc_descr_ref descr, *descr_tail;</span>
<span class="lineNum">   16960 </span><span class="lineCov">    1320988 :   unsigned HOST_WIDE_INT decl_size;</span>
<span class="lineNum">   16961 </span><span class="lineCov">    1320988 :   rtx varloc;</span>
<span class="lineNum">   16962 </span><span class="lineCov">    1320988 :   enum var_init_status initialized;</span>
<span class="lineNum">   16963 </span>            : 
<span class="lineNum">   16964 </span><span class="lineCov">    1320988 :   if (DECL_SIZE (decl) == NULL</span>
<span class="lineNum">   16965 </span><span class="lineCov">    1320988 :       || !tree_fits_uhwi_p (DECL_SIZE (decl)))</span>
<span class="lineNum">   16966 </span>            :     return NULL;
<span class="lineNum">   16967 </span>            : 
<span class="lineNum">   16968 </span><span class="lineCov">    2641976 :   decl_size = tree_to_uhwi (DECL_SIZE (decl));</span>
<span class="lineNum">   16969 </span><span class="lineCov">    1320988 :   descr = NULL;</span>
<span class="lineNum">   16970 </span><span class="lineCov">    1320988 :   descr_tail = &amp;descr;</span>
<span class="lineNum">   16971 </span>            : 
<span class="lineNum">   16972 </span><span class="lineCov">    4277754 :   for (p = loc; p; p = XEXP (p, 1))</span>
<span class="lineNum">   16973 </span>            :     {
<span class="lineNum">   16974 </span><span class="lineCov">    2957099 :       unsigned HOST_WIDE_INT bitsize = decl_piece_bitsize (p);</span>
<span class="lineNum">   16975 </span><span class="lineCov">    2957099 :       rtx loc_note = *decl_piece_varloc_ptr (p);</span>
<span class="lineNum">   16976 </span><span class="lineCov">    2957099 :       dw_loc_descr_ref cur_descr;</span>
<span class="lineNum">   16977 </span><span class="lineCov">    2957099 :       dw_loc_descr_ref *tail, last = NULL;</span>
<span class="lineNum">   16978 </span><span class="lineCov">    2957099 :       unsigned HOST_WIDE_INT opsize = 0;</span>
<span class="lineNum">   16979 </span>            : 
<span class="lineNum">   16980 </span><span class="lineCov">    2957099 :       if (loc_note == NULL_RTX</span>
<span class="lineNum">   16981 </span><span class="lineCov">    2855902 :           || NOTE_VAR_LOCATION_LOC (loc_note) == NULL_RTX)</span>
<span class="lineNum">   16982 </span>            :         {
<span class="lineNum">   16983 </span><span class="lineCov">    1091123 :           padsize += bitsize;</span>
<span class="lineNum">   16984 </span><span class="lineCov">    1095966 :           continue;</span>
<span class="lineNum">   16985 </span>            :         }
<span class="lineNum">   16986 </span><span class="lineCov">    1865976 :       initialized = NOTE_VAR_LOCATION_STATUS (loc_note);</span>
<span class="lineNum">   16987 </span><span class="lineCov">    1865976 :       varloc = NOTE_VAR_LOCATION (loc_note);</span>
<span class="lineNum">   16988 </span><span class="lineCov">    1865976 :       cur_descr = dw_loc_list_1 (decl, varloc, 2, initialized);</span>
<span class="lineNum">   16989 </span><span class="lineCov">    1865976 :       if (cur_descr == NULL)</span>
<span class="lineNum">   16990 </span>            :         {
<span class="lineNum">   16991 </span><span class="lineCov">       4843 :           padsize += bitsize;</span>
<span class="lineNum">   16992 </span><span class="lineCov">       4843 :           continue;</span>
<span class="lineNum">   16993 </span>            :         }
<span class="lineNum">   16994 </span>            : 
<span class="lineNum">   16995 </span>            :       /* Check that cur_descr either doesn't use
<span class="lineNum">   16996 </span>            :          DW_OP_*piece operations, or their sum is equal
<span class="lineNum">   16997 </span>            :          to bitsize.  Otherwise we can't embed it.  */
<span class="lineNum">   16998 </span><span class="lineCov">    4436614 :       for (tail = &amp;cur_descr; *tail != NULL;</span>
<span class="lineNum">   16999 </span><span class="lineCov">    2575481 :            tail = &amp;(*tail)-&gt;dw_loc_next)</span>
<span class="lineNum">   17000 </span><span class="lineCov">    2575481 :         if ((*tail)-&gt;dw_loc_opc == DW_OP_piece)</span>
<span class="lineNum">   17001 </span>            :           {
<span class="lineNum">   17002 </span><span class="lineCov">      19332 :             opsize += (*tail)-&gt;dw_loc_oprnd1.v.val_unsigned</span>
<span class="lineNum">   17003 </span><span class="lineCov">       9666 :                       * BITS_PER_UNIT;</span>
<span class="lineNum">   17004 </span><span class="lineCov">       9666 :             last = *tail;</span>
<span class="lineNum">   17005 </span>            :           }
<span class="lineNum">   17006 </span><span class="lineCov">    2565815 :         else if ((*tail)-&gt;dw_loc_opc == DW_OP_bit_piece)</span>
<span class="lineNum">   17007 </span>            :           {
<span class="lineNum">   17008 </span><span class="lineNoCov">          0 :             opsize += (*tail)-&gt;dw_loc_oprnd1.v.val_unsigned;</span>
<span class="lineNum">   17009 </span><span class="lineNoCov">          0 :             last = *tail;</span>
<span class="lineNum">   17010 </span>            :           }
<span class="lineNum">   17011 </span>            : 
<span class="lineNum">   17012 </span><span class="lineCov">    1861133 :       if (last != NULL &amp;&amp; opsize != bitsize)</span>
<span class="lineNum">   17013 </span>            :         {
<span class="lineNum">   17014 </span><span class="lineNoCov">          0 :           padsize += bitsize;</span>
<span class="lineNum">   17015 </span>            :           /* Discard the current piece of the descriptor and release any
<span class="lineNum">   17016 </span>            :              addr_table entries it uses.  */
<span class="lineNum">   17017 </span><span class="lineNoCov">          0 :           remove_loc_list_addr_table_entries (cur_descr);</span>
<span class="lineNum">   17018 </span><span class="lineNoCov">          0 :           continue;</span>
<span class="lineNum">   17019 </span>            :         }
<span class="lineNum">   17020 </span>            : 
<span class="lineNum">   17021 </span>            :       /* If there is a hole, add DW_OP_*piece after empty DWARF
<span class="lineNum">   17022 </span>            :          expression, which means that those bits are optimized out.  */
<span class="lineNum">   17023 </span><span class="lineCov">    1861133 :       if (padsize)</span>
<span class="lineNum">   17024 </span>            :         {
<span class="lineNum">   17025 </span><span class="lineCov">     155962 :           if (padsize &gt; decl_size)</span>
<span class="lineNum">   17026 </span>            :             {
<span class="lineNum">   17027 </span><span class="lineNoCov">          0 :               remove_loc_list_addr_table_entries (cur_descr);</span>
<span class="lineNum">   17028 </span><span class="lineCov">        333 :               goto discard_descr;</span>
<span class="lineNum">   17029 </span>            :             }
<span class="lineNum">   17030 </span><span class="lineCov">     155962 :           decl_size -= padsize;</span>
<span class="lineNum">   17031 </span><span class="lineCov">     155962 :           *descr_tail = new_loc_descr_op_bit_piece (padsize, 0);</span>
<span class="lineNum">   17032 </span><span class="lineCov">     155962 :           if (*descr_tail == NULL)</span>
<span class="lineNum">   17033 </span>            :             {
<span class="lineNum">   17034 </span><span class="lineNoCov">          0 :               remove_loc_list_addr_table_entries (cur_descr);</span>
<span class="lineNum">   17035 </span><span class="lineNoCov">          0 :               goto discard_descr;</span>
<span class="lineNum">   17036 </span>            :             }
<span class="lineNum">   17037 </span><span class="lineCov">     155962 :           descr_tail = &amp;(*descr_tail)-&gt;dw_loc_next;</span>
<span class="lineNum">   17038 </span><span class="lineCov">     155962 :           padsize = 0;</span>
<span class="lineNum">   17039 </span>            :         }
<span class="lineNum">   17040 </span><span class="lineCov">    1861133 :       *descr_tail = cur_descr;</span>
<span class="lineNum">   17041 </span><span class="lineCov">    1861133 :       descr_tail = tail;</span>
<span class="lineNum">   17042 </span><span class="lineCov">    1861133 :       if (bitsize &gt; decl_size)</span>
<span class="lineNum">   17043 </span>            :         goto discard_descr;
<span class="lineNum">   17044 </span><span class="lineCov">    1861124 :       decl_size -= bitsize;</span>
<span class="lineNum">   17045 </span><span class="lineCov">    1861124 :       if (last == NULL)</span>
<span class="lineNum">   17046 </span>            :         {
<span class="lineNum">   17047 </span><span class="lineCov">    1856295 :           HOST_WIDE_INT offset = 0;</span>
<span class="lineNum">   17048 </span><span class="lineCov">    1856295 :           if (GET_CODE (varloc) == VAR_LOCATION</span>
<span class="lineNum">   17049 </span><span class="lineCov">    1856295 :               &amp;&amp; GET_CODE (PAT_VAR_LOCATION_LOC (varloc)) != PARALLEL)</span>
<span class="lineNum">   17050 </span>            :             {
<span class="lineNum">   17051 </span><span class="lineCov">    1856295 :               varloc = PAT_VAR_LOCATION_LOC (varloc);</span>
<span class="lineNum">   17052 </span><span class="lineCov">    1856295 :               if (GET_CODE (varloc) == EXPR_LIST)</span>
<span class="lineNum">   17053 </span><span class="lineNoCov">          0 :                 varloc = XEXP (varloc, 0);</span>
<span class="lineNum">   17054 </span>            :             }
<span class="lineNum">   17055 </span><span class="lineCov">    1859253 :           do </span>
<span class="lineNum">   17056 </span>            :             {
<span class="lineNum">   17057 </span><span class="lineCov">    1859253 :               if (GET_CODE (varloc) == CONST</span>
<span class="lineNum">   17058 </span><span class="lineCov">    1858561 :                   || GET_CODE (varloc) == SIGN_EXTEND</span>
<span class="lineNum">   17059 </span><span class="lineCov">    1858230 :                   || GET_CODE (varloc) == ZERO_EXTEND)</span>
<span class="lineNum">   17060 </span><span class="lineCov">       1515 :                 varloc = XEXP (varloc, 0);</span>
<span class="lineNum">   17061 </span><span class="lineCov">    1857738 :               else if (GET_CODE (varloc) == SUBREG)</span>
<span class="lineNum">   17062 </span><span class="lineCov">       1443 :                 varloc = SUBREG_REG (varloc);</span>
<span class="lineNum">   17063 </span>            :               else
<span class="lineNum">   17064 </span>            :                 break;
<span class="lineNum">   17065 </span>            :             }
<span class="lineNum">   17066 </span>            :           while (1);
<span class="lineNum">   17067 </span>            :           /* DW_OP_bit_size offset should be zero for register
<span class="lineNum">   17068 </span>            :              or implicit location descriptions and empty location
<span class="lineNum">   17069 </span>            :              descriptions, but for memory addresses needs big endian
<span class="lineNum">   17070 </span>            :              adjustment.  */
<span class="lineNum">   17071 </span><span class="lineCov">    1856295 :           if (MEM_P (varloc))</span>
<span class="lineNum">   17072 </span>            :             {
<span class="lineNum">   17073 </span><span class="lineCov">     640684 :               unsigned HOST_WIDE_INT memsize;</span>
<span class="lineNum">   17074 </span><span class="lineCov">     643600 :               if (!poly_uint64 (MEM_SIZE (varloc)).is_constant (&amp;memsize))</span>
<span class="lineNum">   17075 </span>            :                 goto discard_descr;
<span class="lineNum">   17076 </span><span class="lineCov">     640684 :               memsize *= BITS_PER_UNIT;</span>
<span class="lineNum">   17077 </span><span class="lineCov">     640684 :               if (memsize != bitsize)</span>
<span class="lineNum">   17078 </span>            :                 {
<span class="lineNum">   17079 </span><span class="lineCov">        853 :                   if (BYTES_BIG_ENDIAN != WORDS_BIG_ENDIAN</span>
<span class="lineNum">   17080 </span>            :                       &amp;&amp; (memsize &gt; BITS_PER_WORD || bitsize &gt; BITS_PER_WORD))
<span class="lineNum">   17081 </span>            :                     goto discard_descr;
<span class="lineNum">   17082 </span><span class="lineCov">        853 :                   if (memsize &lt; bitsize)</span>
<span class="lineNum">   17083 </span>            :                     goto discard_descr;
<span class="lineNum">   17084 </span>            :                   if (BITS_BIG_ENDIAN)
<span class="lineNum">   17085 </span>            :                     offset = memsize - bitsize;
<span class="lineNum">   17086 </span>            :                 }
<span class="lineNum">   17087 </span>            :             }
<span class="lineNum">   17088 </span>            : 
<span class="lineNum">   17089 </span><span class="lineCov">    1855971 :           *descr_tail = new_loc_descr_op_bit_piece (bitsize, offset);</span>
<span class="lineNum">   17090 </span><span class="lineCov">    1855971 :           if (*descr_tail == NULL)</span>
<span class="lineNum">   17091 </span>            :             goto discard_descr;
<span class="lineNum">   17092 </span><span class="lineCov">    1855971 :           descr_tail = &amp;(*descr_tail)-&gt;dw_loc_next;</span>
<span class="lineNum">   17093 </span>            :         }
<span class="lineNum">   17094 </span>            :     }
<span class="lineNum">   17095 </span>            : 
<span class="lineNum">   17096 </span>            :   /* If there were any non-empty expressions, add padding till the end of
<span class="lineNum">   17097 </span>            :      the decl.  */
<span class="lineNum">   17098 </span><span class="lineCov">    1320655 :   if (descr != NULL &amp;&amp; decl_size != 0)</span>
<span class="lineNum">   17099 </span>            :     {
<span class="lineNum">   17100 </span><span class="lineCov">     205557 :       *descr_tail = new_loc_descr_op_bit_piece (decl_size, 0);</span>
<span class="lineNum">   17101 </span><span class="lineCov">     205557 :       if (*descr_tail == NULL)</span>
<span class="lineNum">   17102 </span>            :         goto discard_descr;
<span class="lineNum">   17103 </span>            :     }
<span class="lineNum">   17104 </span><span class="lineCov">    1320655 :   return descr;</span>
<span class="lineNum">   17105 </span>            : 
<span class="lineNum">   17106 </span><span class="lineCov">        333 : discard_descr:</span>
<span class="lineNum">   17107 </span>            :   /* Discard the descriptor and release any addr_table entries it uses.  */
<span class="lineNum">   17108 </span><span class="lineCov">        333 :   remove_loc_list_addr_table_entries (descr);</span>
<span class="lineNum">   17109 </span><span class="lineCov">        333 :   return NULL;</span>
<span class="lineNum">   17110 </span>            : }
<span class="lineNum">   17111 </span>            : 
<span class="lineNum">   17112 </span>            : /* Return the dwarf representation of the location list LOC_LIST of
<span class="lineNum">   17113 </span>            :    DECL.  WANT_ADDRESS has the same meaning as in loc_list_from_tree
<span class="lineNum">   17114 </span>            :    function.  */
<a name="17115"><span class="lineNum">   17115 </span>            : </a>
<span class="lineNum">   17116 </span>            : static dw_loc_list_ref
<span class="lineNum">   17117 </span><span class="lineCov">    6738908 : dw_loc_list (var_loc_list *loc_list, tree decl, int want_address)</span>
<span class="lineNum">   17118 </span>            : {
<span class="lineNum">   17119 </span><span class="lineCov">    6738908 :   const char *endname, *secname;</span>
<span class="lineNum">   17120 </span><span class="lineCov">    6738908 :   var_loc_view endview;</span>
<span class="lineNum">   17121 </span><span class="lineCov">    6738908 :   rtx varloc;</span>
<span class="lineNum">   17122 </span><span class="lineCov">    6738908 :   enum var_init_status initialized;</span>
<span class="lineNum">   17123 </span><span class="lineCov">    6738908 :   struct var_loc_node *node;</span>
<span class="lineNum">   17124 </span><span class="lineCov">    6738908 :   dw_loc_descr_ref descr;</span>
<span class="lineNum">   17125 </span><span class="lineCov">    6738908 :   char label_id[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">   17126 </span><span class="lineCov">    6738908 :   dw_loc_list_ref list = NULL;</span>
<span class="lineNum">   17127 </span><span class="lineCov">    6738908 :   dw_loc_list_ref *listp = &amp;list;</span>
<span class="lineNum">   17128 </span>            : 
<span class="lineNum">   17129 </span>            :   /* Now that we know what section we are using for a base,
<span class="lineNum">   17130 </span>            :      actually construct the list of locations.
<span class="lineNum">   17131 </span>            :      The first location information is what is passed to the
<span class="lineNum">   17132 </span>            :      function that creates the location list, and the remaining
<span class="lineNum">   17133 </span>            :      locations just get added on to that list.
<span class="lineNum">   17134 </span>            :      Note that we only know the start address for a location
<span class="lineNum">   17135 </span>            :      (IE location changes), so to build the range, we use
<span class="lineNum">   17136 </span>            :      the range [current location start, next location start].
<span class="lineNum">   17137 </span>            :      This means we have to special case the last node, and generate
<span class="lineNum">   17138 </span>            :      a range of [last location start, end of function label].  */
<span class="lineNum">   17139 </span>            : 
<span class="lineNum">   17140 </span><span class="lineCov">    6738908 :   if (cfun &amp;&amp; crtl-&gt;has_bb_partition)</span>
<span class="lineNum">   17141 </span>            :     {
<span class="lineNum">   17142 </span><span class="lineCov">    1701907 :       bool save_in_cold_section_p = in_cold_section_p;</span>
<span class="lineNum">   17143 </span><span class="lineCov">    1701907 :       in_cold_section_p = first_function_block_is_cold;</span>
<span class="lineNum">   17144 </span><span class="lineCov">    1701907 :       if (loc_list-&gt;last_before_switch == NULL)</span>
<span class="lineNum">   17145 </span><span class="lineCov">     260161 :         in_cold_section_p = !in_cold_section_p;</span>
<span class="lineNum">   17146 </span><span class="lineCov">    1701907 :       secname = secname_for_decl (decl);</span>
<span class="lineNum">   17147 </span><span class="lineCov">    1701907 :       in_cold_section_p = save_in_cold_section_p;</span>
<span class="lineNum">   17148 </span>            :     }
<span class="lineNum">   17149 </span>            :   else
<span class="lineNum">   17150 </span><span class="lineCov">    5037001 :     secname = secname_for_decl (decl);</span>
<span class="lineNum">   17151 </span>            : 
<span class="lineNum">   17152 </span><span class="lineCov">   33882196 :   for (node = loc_list-&gt;first; node; node = node-&gt;next)</span>
<span class="lineNum">   17153 </span>            :     {
<span class="lineNum">   17154 </span><span class="lineCov">   27143288 :       bool range_across_switch = false;</span>
<span class="lineNum">   17155 </span><span class="lineCov">   27143288 :       if (GET_CODE (node-&gt;loc) == EXPR_LIST</span>
<span class="lineNum">   17156 </span><span class="lineCov">   25823974 :           || NOTE_VAR_LOCATION_LOC (node-&gt;loc) != NULL_RTX)</span>
<span class="lineNum">   17157 </span>            :         {
<span class="lineNum">   17158 </span><span class="lineCov">   17565594 :           if (GET_CODE (node-&gt;loc) == EXPR_LIST)</span>
<span class="lineNum">   17159 </span>            :             {
<span class="lineNum">   17160 </span><span class="lineCov">    1319314 :               descr = NULL;</span>
<span class="lineNum">   17161 </span>            :               /* This requires DW_OP_{,bit_}piece, which is not usable
<span class="lineNum">   17162 </span>            :                  inside DWARF expressions.  */
<span class="lineNum">   17163 </span><span class="lineCov">    1319314 :               if (want_address == 2)</span>
<span class="lineNum">   17164 </span><span class="lineCov">    1319314 :                 descr = dw_sra_loc_expr (decl, node-&gt;loc);</span>
<span class="lineNum">   17165 </span>            :             }
<span class="lineNum">   17166 </span>            :           else
<span class="lineNum">   17167 </span>            :             {
<span class="lineNum">   17168 </span><span class="lineCov">   16246280 :               initialized = NOTE_VAR_LOCATION_STATUS (node-&gt;loc);</span>
<span class="lineNum">   17169 </span><span class="lineCov">   16246280 :               varloc = NOTE_VAR_LOCATION (node-&gt;loc);</span>
<span class="lineNum">   17170 </span><span class="lineCov">   16246280 :               descr = dw_loc_list_1 (decl, varloc, want_address, initialized);</span>
<span class="lineNum">   17171 </span>            :             }
<span class="lineNum">   17172 </span><span class="lineCov">   17565594 :           if (descr)</span>
<span class="lineNum">   17173 </span>            :             {
<span class="lineNum">   17174 </span>            :               /* If section switch happens in between node-&gt;label
<span class="lineNum">   17175 </span>            :                  and node-&gt;next-&gt;label (or end of function) and
<span class="lineNum">   17176 </span>            :                  we can't emit it as a single entry list,
<span class="lineNum">   17177 </span>            :                  emit two ranges, first one ending at the end
<span class="lineNum">   17178 </span>            :                  of first partition and second one starting at the
<span class="lineNum">   17179 </span>            :                  beginning of second partition.  */
<span class="lineNum">   17180 </span><span class="lineCov">   17074364 :               if (node == loc_list-&gt;last_before_switch</span>
<span class="lineNum">   17181 </span><span class="lineCov">      85340 :                   &amp;&amp; (node != loc_list-&gt;first || loc_list-&gt;first-&gt;next</span>
<span class="lineNum">   17182 </span>            :                       /* If we are to emit a view number, we will emit
<span class="lineNum">   17183 </span>            :                          a loclist rather than a single location
<span class="lineNum">   17184 </span>            :                          expression for the entire function (see
<span class="lineNum">   17185 </span>            :                          loc_list_has_views), so we have to split the
<span class="lineNum">   17186 </span>            :                          range that straddles across partitions.  */
<span class="lineNum">   17187 </span><span class="lineCov">       4656 :                       || !ZERO_VIEW_P (node-&gt;view))</span>
<span class="lineNum">   17188 </span><span class="lineCov">   17158935 :                   &amp;&amp; current_function_decl)</span>
<span class="lineNum">   17189 </span>            :                 {
<span class="lineNum">   17190 </span><span class="lineCov">      84571 :                   endname = cfun-&gt;fde-&gt;dw_fde_end;</span>
<span class="lineNum">   17191 </span><span class="lineCov">      84571 :                   endview = 0;</span>
<span class="lineNum">   17192 </span><span class="lineCov">      84571 :                   range_across_switch = true;</span>
<span class="lineNum">   17193 </span>            :                 }
<span class="lineNum">   17194 </span>            :               /* The variable has a location between NODE-&gt;LABEL and
<span class="lineNum">   17195 </span>            :                  NODE-&gt;NEXT-&gt;LABEL.  */
<span class="lineNum">   17196 </span><span class="lineCov">   16989793 :               else if (node-&gt;next)</span>
<span class="lineNum">   17197 </span><span class="lineCov">   15970678 :                 endname = node-&gt;next-&gt;label, endview = node-&gt;next-&gt;view;</span>
<span class="lineNum">   17198 </span>            :               /* If the variable has a location at the last label
<span class="lineNum">   17199 </span>            :                  it keeps its location until the end of function.  */
<span class="lineNum">   17200 </span><span class="lineCov">    1019115 :               else if (!current_function_decl)</span>
<span class="lineNum">   17201 </span>            :                 endname = text_end_label, endview = 0;
<span class="lineNum">   17202 </span>            :               else
<span class="lineNum">   17203 </span>            :                 {
<span class="lineNum">   17204 </span><span class="lineCov">    1019115 :                   ASM_GENERATE_INTERNAL_LABEL (label_id, FUNC_END_LABEL,</span>
<span class="lineNum">   17205 </span>            :                                                current_function_funcdef_no);
<span class="lineNum">   17206 </span><span class="lineCov">    1019115 :                   endname = ggc_strdup (label_id);</span>
<span class="lineNum">   17207 </span><span class="lineCov">    1019115 :                   endview = 0;</span>
<span class="lineNum">   17208 </span>            :                 }
<span class="lineNum">   17209 </span>            : 
<span class="lineNum">   17210 </span><span class="lineCov">   17074364 :               *listp = new_loc_list (descr, node-&gt;label, node-&gt;view,</span>
<span class="lineNum">   17211 </span>            :                                      endname, endview, secname);
<span class="lineNum">   17212 </span><span class="lineCov">   17074364 :               if (TREE_CODE (decl) == PARM_DECL</span>
<span class="lineNum">   17213 </span><span class="lineCov">    1803629 :                   &amp;&amp; node == loc_list-&gt;first</span>
<span class="lineNum">   17214 </span><span class="lineCov">     595524 :                   &amp;&amp; NOTE_P (node-&gt;loc)</span>
<span class="lineNum">   17215 </span><span class="lineCov">     588852 :                   &amp;&amp; strcmp (node-&gt;label, endname) == 0)</span>
<span class="lineNum">   17216 </span><span class="lineCov">        341 :                 (*listp)-&gt;force = true;</span>
<span class="lineNum">   17217 </span><span class="lineCov">   17074364 :               listp = &amp;(*listp)-&gt;dw_loc_next;</span>
<span class="lineNum">   17218 </span>            :             }
<span class="lineNum">   17219 </span>            :         }
<span class="lineNum">   17220 </span>            : 
<span class="lineNum">   17221 </span><span class="lineCov">   54286576 :       if (cfun</span>
<span class="lineNum">   17222 </span><span class="lineCov">   27143288 :           &amp;&amp; crtl-&gt;has_bb_partition</span>
<span class="lineNum">   17223 </span><span class="lineCov">    8464537 :           &amp;&amp; node == loc_list-&gt;last_before_switch)</span>
<span class="lineNum">   17224 </span>            :         {
<span class="lineNum">   17225 </span><span class="lineCov">    1441746 :           bool save_in_cold_section_p = in_cold_section_p;</span>
<span class="lineNum">   17226 </span><span class="lineCov">    1441746 :           in_cold_section_p = !first_function_block_is_cold;</span>
<span class="lineNum">   17227 </span><span class="lineCov">    1441746 :           secname = secname_for_decl (decl);</span>
<span class="lineNum">   17228 </span><span class="lineCov">    1441746 :           in_cold_section_p = save_in_cold_section_p;</span>
<span class="lineNum">   17229 </span>            :         }
<span class="lineNum">   17230 </span>            : 
<span class="lineNum">   17231 </span><span class="lineCov">   27143288 :       if (range_across_switch)</span>
<span class="lineNum">   17232 </span>            :         {
<span class="lineNum">   17233 </span><span class="lineCov">      84571 :           if (GET_CODE (node-&gt;loc) == EXPR_LIST)</span>
<span class="lineNum">   17234 </span><span class="lineCov">       1674 :             descr = dw_sra_loc_expr (decl, node-&gt;loc);</span>
<span class="lineNum">   17235 </span>            :           else
<span class="lineNum">   17236 </span>            :             {
<span class="lineNum">   17237 </span><span class="lineCov">      82897 :               initialized = NOTE_VAR_LOCATION_STATUS (node-&gt;loc);</span>
<span class="lineNum">   17238 </span><span class="lineCov">      82897 :               varloc = NOTE_VAR_LOCATION (node-&gt;loc);</span>
<span class="lineNum">   17239 </span><span class="lineCov">      82897 :               descr = dw_loc_list_1 (decl, varloc, want_address,</span>
<span class="lineNum">   17240 </span>            :                                      initialized);
<span class="lineNum">   17241 </span>            :             }
<span class="lineNum">   17242 </span><span class="lineCov">      84571 :           gcc_assert (descr);</span>
<span class="lineNum">   17243 </span>            :           /* The variable has a location between NODE-&gt;LABEL and
<span class="lineNum">   17244 </span>            :              NODE-&gt;NEXT-&gt;LABEL.  */
<span class="lineNum">   17245 </span><span class="lineCov">      84571 :           if (node-&gt;next)</span>
<span class="lineNum">   17246 </span><span class="lineCov">      67858 :             endname = node-&gt;next-&gt;label, endview = node-&gt;next-&gt;view;</span>
<span class="lineNum">   17247 </span>            :           else
<span class="lineNum">   17248 </span><span class="lineCov">      16713 :             endname = cfun-&gt;fde-&gt;dw_fde_second_end, endview = 0;</span>
<span class="lineNum">   17249 </span><span class="lineCov">      84571 :           *listp = new_loc_list (descr, cfun-&gt;fde-&gt;dw_fde_second_begin, 0,</span>
<span class="lineNum">   17250 </span>            :                                  endname, endview, secname);
<span class="lineNum">   17251 </span><span class="lineCov">      84571 :           listp = &amp;(*listp)-&gt;dw_loc_next;</span>
<span class="lineNum">   17252 </span>            :         }
<span class="lineNum">   17253 </span>            :     }
<span class="lineNum">   17254 </span>            : 
<span class="lineNum">   17255 </span>            :   /* Try to avoid the overhead of a location list emitting a location
<span class="lineNum">   17256 </span>            :      expression instead, but only if we didn't have more than one
<span class="lineNum">   17257 </span>            :      location entry in the first place.  If some entries were not
<span class="lineNum">   17258 </span>            :      representable, we don't want to pretend a single entry that was
<span class="lineNum">   17259 </span>            :      applies to the entire scope in which the variable is
<span class="lineNum">   17260 </span>            :      available.  */
<span class="lineNum">   17261 </span><span class="lineCov">    6738908 :   if (list &amp;&amp; loc_list-&gt;first-&gt;next)</span>
<span class="lineNum">   17262 </span><span class="lineCov">    6073467 :     gen_llsym (list);</span>
<span class="lineNum">   17263 </span>            :   else
<span class="lineNum">   17264 </span><span class="lineCov">     665441 :     maybe_gen_llsym (list);</span>
<span class="lineNum">   17265 </span>            : 
<span class="lineNum">   17266 </span><span class="lineCov">    6738908 :   return list;</span>
<span class="lineNum">   17267 </span>            : }
<span class="lineNum">   17268 </span>            : 
<span class="lineNum">   17269 </span>            : /* Return if the loc_list has only single element and thus can be represented
<span class="lineNum">   17270 </span>            :    as location description.   */
<a name="17271"><span class="lineNum">   17271 </span>            : </a>
<span class="lineNum">   17272 </span>            : static bool
<span class="lineNum">   17273 </span><span class="lineCov">    6905033 : single_element_loc_list_p (dw_loc_list_ref list)</span>
<span class="lineNum">   17274 </span>            : {
<span class="lineNum">   17275 </span><span class="lineCov">    6905033 :   gcc_assert (!list-&gt;dw_loc_next || list-&gt;ll_symbol);</span>
<span class="lineNum">   17276 </span><span class="lineCov">    6905033 :   return !list-&gt;ll_symbol;</span>
<span class="lineNum">   17277 </span>            : }
<span class="lineNum">   17278 </span>            : 
<span class="lineNum">   17279 </span>            : /* Duplicate a single element of location list.  */
<a name="17280"><span class="lineNum">   17280 </span>            : </a>
<span class="lineNum">   17281 </span>            : static inline dw_loc_descr_ref
<span class="lineNum">   17282 </span><span class="lineCov">       6578 : copy_loc_descr (dw_loc_descr_ref ref)</span>
<span class="lineNum">   17283 </span>            : {
<span class="lineNum">   17284 </span><span class="lineCov">       6578 :   dw_loc_descr_ref copy = ggc_alloc&lt;dw_loc_descr_node&gt; ();</span>
<span class="lineNum">   17285 </span><span class="lineCov">       6578 :   memcpy (copy, ref, sizeof (dw_loc_descr_node));</span>
<span class="lineNum">   17286 </span><span class="lineCov">       6578 :   return copy;</span>
<span class="lineNum">   17287 </span>            : }
<span class="lineNum">   17288 </span>            : 
<span class="lineNum">   17289 </span>            : /* To each location in list LIST append loc descr REF.  */
<a name="17290"><span class="lineNum">   17290 </span>            : </a>
<span class="lineNum">   17291 </span>            : static void
<span class="lineNum">   17292 </span><span class="lineCov">     151634 : add_loc_descr_to_each (dw_loc_list_ref list, dw_loc_descr_ref ref)</span>
<span class="lineNum">   17293 </span>            : {
<span class="lineNum">   17294 </span><span class="lineCov">     151634 :   dw_loc_descr_ref copy;</span>
<span class="lineNum">   17295 </span><span class="lineCov">     151634 :   add_loc_descr (&amp;list-&gt;expr, ref);</span>
<span class="lineNum">   17296 </span><span class="lineCov">     151634 :   list = list-&gt;dw_loc_next;</span>
<span class="lineNum">   17297 </span><span class="lineCov">     158212 :   while (list)</span>
<span class="lineNum">   17298 </span>            :     {
<span class="lineNum">   17299 </span><span class="lineCov">       6578 :       copy = copy_loc_descr (ref);</span>
<span class="lineNum">   17300 </span><span class="lineCov">       6578 :       add_loc_descr (&amp;list-&gt;expr, copy);</span>
<span class="lineNum">   17301 </span><span class="lineCov">       6578 :       while (copy-&gt;dw_loc_next)</span>
<span class="lineNum">   17302 </span><span class="lineNoCov">          0 :         copy = copy-&gt;dw_loc_next = copy_loc_descr (copy-&gt;dw_loc_next);</span>
<span class="lineNum">   17303 </span><span class="lineCov">       6578 :       list = list-&gt;dw_loc_next;</span>
<span class="lineNum">   17304 </span>            :     }
<span class="lineNum">   17305 </span><span class="lineCov">     151634 : }</span>
<span class="lineNum">   17306 </span>            : 
<span class="lineNum">   17307 </span>            : /* To each location in list LIST prepend loc descr REF.  */
<a name="17308"><span class="lineNum">   17308 </span>            : </a>
<span class="lineNum">   17309 </span>            : static void
<span class="lineNum">   17310 </span><span class="lineNoCov">          0 : prepend_loc_descr_to_each (dw_loc_list_ref list, dw_loc_descr_ref ref)</span>
<span class="lineNum">   17311 </span>            : {
<span class="lineNum">   17312 </span><span class="lineNoCov">          0 :   dw_loc_descr_ref copy;</span>
<span class="lineNum">   17313 </span><span class="lineNoCov">          0 :   dw_loc_descr_ref ref_end = list-&gt;expr;</span>
<span class="lineNum">   17314 </span><span class="lineNoCov">          0 :   add_loc_descr (&amp;ref, list-&gt;expr);</span>
<span class="lineNum">   17315 </span><span class="lineNoCov">          0 :   list-&gt;expr = ref;</span>
<span class="lineNum">   17316 </span><span class="lineNoCov">          0 :   list = list-&gt;dw_loc_next;</span>
<span class="lineNum">   17317 </span><span class="lineNoCov">          0 :   while (list)</span>
<span class="lineNum">   17318 </span>            :     {
<span class="lineNum">   17319 </span><span class="lineNoCov">          0 :       dw_loc_descr_ref end = list-&gt;expr;</span>
<span class="lineNum">   17320 </span><span class="lineNoCov">          0 :       list-&gt;expr = copy = copy_loc_descr (ref);</span>
<span class="lineNum">   17321 </span><span class="lineNoCov">          0 :       while (copy-&gt;dw_loc_next != ref_end)</span>
<span class="lineNum">   17322 </span><span class="lineNoCov">          0 :         copy = copy-&gt;dw_loc_next = copy_loc_descr (copy-&gt;dw_loc_next);</span>
<span class="lineNum">   17323 </span><span class="lineNoCov">          0 :       copy-&gt;dw_loc_next = end;</span>
<span class="lineNum">   17324 </span><span class="lineNoCov">          0 :       list = list-&gt;dw_loc_next;</span>
<span class="lineNum">   17325 </span>            :     }
<span class="lineNum">   17326 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   17327 </span>            : 
<span class="lineNum">   17328 </span>            : /* Given two lists RET and LIST
<span class="lineNum">   17329 </span>            :    produce location list that is result of adding expression in LIST
<span class="lineNum">   17330 </span>            :    to expression in RET on each position in program.
<span class="lineNum">   17331 </span>            :    Might be destructive on both RET and LIST.
<span class="lineNum">   17332 </span>            : 
<span class="lineNum">   17333 </span>            :    TODO: We handle only simple cases of RET or LIST having at most one
<span class="lineNum">   17334 </span>            :    element.  General case would involve sorting the lists in program order
<span class="lineNum">   17335 </span>            :    and merging them that will need some additional work.
<span class="lineNum">   17336 </span>            :    Adding that will improve quality of debug info especially for SRA-ed
<span class="lineNum">   17337 </span>            :    structures.  */
<a name="17338"><span class="lineNum">   17338 </span>            : </a>
<span class="lineNum">   17339 </span>            : static void
<span class="lineNum">   17340 </span><span class="lineCov">      27680 : add_loc_list (dw_loc_list_ref *ret, dw_loc_list_ref list)</span>
<span class="lineNum">   17341 </span>            : {
<span class="lineNum">   17342 </span><span class="lineCov">      27680 :   if (!list)</span>
<span class="lineNum">   17343 </span>            :     return;
<span class="lineNum">   17344 </span><span class="lineCov">      27680 :   if (!*ret)</span>
<span class="lineNum">   17345 </span>            :     {
<span class="lineNum">   17346 </span><span class="lineNoCov">          0 :       *ret = list;</span>
<span class="lineNum">   17347 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">   17348 </span>            :     }
<span class="lineNum">   17349 </span><span class="lineCov">      27680 :   if (!list-&gt;dw_loc_next)</span>
<span class="lineNum">   17350 </span>            :     {
<span class="lineNum">   17351 </span><span class="lineCov">      27680 :       add_loc_descr_to_each (*ret, list-&gt;expr);</span>
<span class="lineNum">   17352 </span><span class="lineCov">      27680 :       return;</span>
<span class="lineNum">   17353 </span>            :     }
<span class="lineNum">   17354 </span><span class="lineNoCov">          0 :   if (!(*ret)-&gt;dw_loc_next)</span>
<span class="lineNum">   17355 </span>            :     {
<span class="lineNum">   17356 </span><span class="lineNoCov">          0 :       prepend_loc_descr_to_each (list, (*ret)-&gt;expr);</span>
<span class="lineNum">   17357 </span><span class="lineNoCov">          0 :       *ret = list;</span>
<span class="lineNum">   17358 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">   17359 </span>            :     }
<span class="lineNum">   17360 </span><span class="lineNoCov">          0 :   expansion_failed (NULL_TREE, NULL_RTX,</span>
<span class="lineNum">   17361 </span>            :                     &quot;Don't know how to merge two non-trivial&quot;
<span class="lineNum">   17362 </span>            :                     &quot; location lists.\n&quot;);
<span class="lineNum">   17363 </span><span class="lineNoCov">          0 :   *ret = NULL;</span>
<span class="lineNum">   17364 </span><span class="lineNoCov">          0 :   return;</span>
<span class="lineNum">   17365 </span>            : }
<span class="lineNum">   17366 </span>            : 
<span class="lineNum">   17367 </span>            : /* LOC is constant expression.  Try a luck, look it up in constant
<span class="lineNum">   17368 </span>            :    pool and return its loc_descr of its address.  */
<a name="17369"><span class="lineNum">   17369 </span>            : </a>
<span class="lineNum">   17370 </span>            : static dw_loc_descr_ref
<span class="lineNum">   17371 </span><span class="lineCov">         86 : cst_pool_loc_descr (tree loc)</span>
<span class="lineNum">   17372 </span>            : {
<span class="lineNum">   17373 </span>            :   /* Get an RTL for this, if something has been emitted.  */
<span class="lineNum">   17374 </span><span class="lineCov">         86 :   rtx rtl = lookup_constant_def (loc);</span>
<span class="lineNum">   17375 </span>            : 
<span class="lineNum">   17376 </span><span class="lineCov">         86 :   if (!rtl || !MEM_P (rtl))</span>
<span class="lineNum">   17377 </span>            :     {
<span class="lineNum">   17378 </span><span class="lineCov">         86 :       gcc_assert (!rtl);</span>
<span class="lineNum">   17379 </span>            :       return 0;
<span class="lineNum">   17380 </span>            :     }
<span class="lineNum">   17381 </span><span class="lineNoCov">          0 :   gcc_assert (GET_CODE (XEXP (rtl, 0)) == SYMBOL_REF);</span>
<span class="lineNum">   17382 </span>            : 
<span class="lineNum">   17383 </span>            :   /* TODO: We might get more coverage if we was actually delaying expansion
<span class="lineNum">   17384 </span>            :      of all expressions till end of compilation when constant pools are fully
<span class="lineNum">   17385 </span>            :      populated.  */
<span class="lineNum">   17386 </span><span class="lineNoCov">          0 :   if (!TREE_ASM_WRITTEN (SYMBOL_REF_DECL (XEXP (rtl, 0))))</span>
<span class="lineNum">   17387 </span>            :     {
<span class="lineNum">   17388 </span><span class="lineNoCov">          0 :       expansion_failed (loc, NULL_RTX,</span>
<span class="lineNum">   17389 </span>            :                         &quot;CST value in contant pool but not marked.&quot;);
<span class="lineNum">   17390 </span><span class="lineNoCov">          0 :       return 0;</span>
<span class="lineNum">   17391 </span>            :     }
<span class="lineNum">   17392 </span><span class="lineNoCov">          0 :   return mem_loc_descriptor (XEXP (rtl, 0), get_address_mode (rtl),</span>
<span class="lineNum">   17393 </span><span class="lineNoCov">          0 :                              GET_MODE (rtl), VAR_INIT_STATUS_INITIALIZED);</span>
<span class="lineNum">   17394 </span>            : }
<span class="lineNum">   17395 </span>            : 
<span class="lineNum">   17396 </span>            : /* Return dw_loc_list representing address of addr_expr LOC
<span class="lineNum">   17397 </span>            :    by looking for inner INDIRECT_REF expression and turning
<span class="lineNum">   17398 </span>            :    it into simple arithmetics.
<span class="lineNum">   17399 </span>            : 
<span class="lineNum">   17400 </span>            :    See loc_list_from_tree for the meaning of CONTEXT.  */
<a name="17401"><span class="lineNum">   17401 </span>            : </a>
<span class="lineNum">   17402 </span>            : static dw_loc_list_ref
<span class="lineNum">   17403 </span><span class="lineCov">         68 : loc_list_for_address_of_addr_expr_of_indirect_ref (tree loc, bool toplev,</span>
<span class="lineNum">   17404 </span>            :                                                    loc_descr_context *context)
<span class="lineNum">   17405 </span>            : {
<span class="lineNum">   17406 </span><span class="lineCov">         68 :   tree obj, offset;</span>
<span class="lineNum">   17407 </span><span class="lineCov">        204 :   poly_int64 bitsize, bitpos, bytepos;</span>
<span class="lineNum">   17408 </span><span class="lineCov">         68 :   machine_mode mode;</span>
<span class="lineNum">   17409 </span><span class="lineCov">         68 :   int unsignedp, reversep, volatilep = 0;</span>
<span class="lineNum">   17410 </span><span class="lineCov">         68 :   dw_loc_list_ref list_ret = NULL, list_ret1 = NULL;</span>
<span class="lineNum">   17411 </span>            : 
<span class="lineNum">   17412 </span><span class="lineCov">         68 :   obj = get_inner_reference (TREE_OPERAND (loc, 0),</span>
<span class="lineNum">   17413 </span>            :                              &amp;bitsize, &amp;bitpos, &amp;offset, &amp;mode,
<span class="lineNum">   17414 </span>            :                              &amp;unsignedp, &amp;reversep, &amp;volatilep);
<span class="lineNum">   17415 </span><span class="lineCov">         68 :   STRIP_NOPS (obj);</span>
<span class="lineNum">   17416 </span><span class="lineCov">        136 :   if (!multiple_p (bitpos, BITS_PER_UNIT, &amp;bytepos))</span>
<span class="lineNum">   17417 </span>            :     {
<span class="lineNum">   17418 </span><span class="lineNoCov">          0 :       expansion_failed (loc, NULL_RTX, &quot;bitfield access&quot;);</span>
<span class="lineNum">   17419 </span><span class="lineNoCov">          0 :       return 0;</span>
<span class="lineNum">   17420 </span>            :     }
<span class="lineNum">   17421 </span><span class="lineCov">         68 :   if (!INDIRECT_REF_P (obj))</span>
<span class="lineNum">   17422 </span>            :     {
<span class="lineNum">   17423 </span><span class="lineCov">         68 :       expansion_failed (obj,</span>
<span class="lineNum">   17424 </span>            :                         NULL_RTX, &quot;no indirect ref in inner refrence&quot;);
<span class="lineNum">   17425 </span><span class="lineCov">         68 :       return 0;</span>
<span class="lineNum">   17426 </span>            :     }
<span class="lineNum">   17427 </span><span class="lineNoCov">          0 :   if (!offset &amp;&amp; known_eq (bitpos, 0))</span>
<span class="lineNum">   17428 </span><span class="lineNoCov">          0 :     list_ret = loc_list_from_tree (TREE_OPERAND (obj, 0), toplev ? 2 : 1,</span>
<span class="lineNum">   17429 </span>            :                                    context);
<span class="lineNum">   17430 </span><span class="lineNoCov">          0 :   else if (toplev</span>
<span class="lineNum">   17431 </span><span class="lineNoCov">          0 :            &amp;&amp; int_size_in_bytes (TREE_TYPE (loc)) &lt;= DWARF2_ADDR_SIZE</span>
<span class="lineNum">   17432 </span><span class="lineNoCov">          0 :            &amp;&amp; (dwarf_version &gt;= 4 || !dwarf_strict))</span>
<span class="lineNum">   17433 </span>            :     {
<span class="lineNum">   17434 </span><span class="lineNoCov">          0 :       list_ret = loc_list_from_tree (TREE_OPERAND (obj, 0), 0, context);</span>
<span class="lineNum">   17435 </span><span class="lineNoCov">          0 :       if (!list_ret)</span>
<span class="lineNum">   17436 </span>            :         return 0;
<span class="lineNum">   17437 </span><span class="lineNoCov">          0 :       if (offset)</span>
<span class="lineNum">   17438 </span>            :         {
<span class="lineNum">   17439 </span>            :           /* Variable offset.  */
<span class="lineNum">   17440 </span><span class="lineNoCov">          0 :           list_ret1 = loc_list_from_tree (offset, 0, context);</span>
<span class="lineNum">   17441 </span><span class="lineNoCov">          0 :           if (list_ret1 == 0)</span>
<span class="lineNum">   17442 </span>            :             return 0;
<span class="lineNum">   17443 </span><span class="lineNoCov">          0 :           add_loc_list (&amp;list_ret, list_ret1);</span>
<span class="lineNum">   17444 </span><span class="lineNoCov">          0 :           if (!list_ret)</span>
<span class="lineNum">   17445 </span>            :             return 0;
<span class="lineNum">   17446 </span><span class="lineNoCov">          0 :           add_loc_descr_to_each (list_ret,</span>
<span class="lineNum">   17447 </span>            :                                  new_loc_descr (DW_OP_plus, 0, 0));
<span class="lineNum">   17448 </span>            :         }
<span class="lineNum">   17449 </span><span class="lineNoCov">          0 :       HOST_WIDE_INT value;</span>
<span class="lineNum">   17450 </span><span class="lineNoCov">          0 :       if (bytepos.is_constant (&amp;value) &amp;&amp; value &gt; 0)</span>
<span class="lineNum">   17451 </span><span class="lineNoCov">          0 :         add_loc_descr_to_each (list_ret,</span>
<span class="lineNum">   17452 </span>            :                                new_loc_descr (DW_OP_plus_uconst, value, 0));
<span class="lineNum">   17453 </span><span class="lineNoCov">          0 :       else if (maybe_ne (bytepos, 0))</span>
<span class="lineNum">   17454 </span><span class="lineNoCov">          0 :         loc_list_plus_const (list_ret, bytepos);</span>
<span class="lineNum">   17455 </span><span class="lineNoCov">          0 :       add_loc_descr_to_each (list_ret,</span>
<span class="lineNum">   17456 </span>            :                              new_loc_descr (DW_OP_stack_value, 0, 0));
<span class="lineNum">   17457 </span>            :     }
<span class="lineNum">   17458 </span><span class="lineNoCov">          0 :   return list_ret;</span>
<span class="lineNum">   17459 </span>            : }
<span class="lineNum">   17460 </span>            : 
<span class="lineNum">   17461 </span>            : /* Set LOC to the next operation that is not a DW_OP_nop operation. In the case
<span class="lineNum">   17462 </span>            :    all operations from LOC are nops, move to the last one.  Insert in NOPS all
<span class="lineNum">   17463 </span>            :    operations that are skipped.  */
<a name="17464"><span class="lineNum">   17464 </span>            : </a>
<span class="lineNum">   17465 </span>            : static void
<span class="lineNum">   17466 </span><span class="lineCov">   33414824 : loc_descr_to_next_no_nop (dw_loc_descr_ref &amp;loc,</span>
<span class="lineNum">   17467 </span>            :                           hash_set&lt;dw_loc_descr_ref&gt; &amp;nops)
<span class="lineNum">   17468 </span>            : {
<span class="lineNum">   17469 </span><span class="lineCov">   33416752 :   while (loc-&gt;dw_loc_next != NULL &amp;&amp; loc-&gt;dw_loc_opc == DW_OP_nop)</span>
<span class="lineNum">   17470 </span>            :     {
<span class="lineNum">   17471 </span><span class="lineCov">       1928 :       nops.add (loc);</span>
<span class="lineNum">   17472 </span><span class="lineCov">       1928 :       loc = loc-&gt;dw_loc_next;</span>
<span class="lineNum">   17473 </span>            :     }
<span class="lineNum">   17474 </span><span class="lineCov">   33414824 : }</span>
<span class="lineNum">   17475 </span>            : 
<span class="lineNum">   17476 </span>            : /* Helper for loc_descr_without_nops: free the location description operation
<span class="lineNum">   17477 </span>            :    P.  */
<a name="17478"><span class="lineNum">   17478 </span>            : </a>
<span class="lineNum">   17479 </span>            : bool
<span class="lineNum">   17480 </span><span class="lineCov">        964 : free_loc_descr (const dw_loc_descr_ref &amp;loc, void *data ATTRIBUTE_UNUSED)</span>
<span class="lineNum">   17481 </span>            : {
<span class="lineNum">   17482 </span><span class="lineCov">        964 :   ggc_free (loc);</span>
<span class="lineNum">   17483 </span><span class="lineCov">        964 :   return true;</span>
<span class="lineNum">   17484 </span>            : }
<span class="lineNum">   17485 </span>            : 
<span class="lineNum">   17486 </span>            : /* Remove all DW_OP_nop operations from LOC except, if it exists, the one that
<span class="lineNum">   17487 </span>            :    finishes LOC.  */
<a name="17488"><span class="lineNum">   17488 </span>            : </a>
<span class="lineNum">   17489 </span>            : static void
<span class="lineNum">   17490 </span><span class="lineCov">   17660964 : loc_descr_without_nops (dw_loc_descr_ref &amp;loc)</span>
<span class="lineNum">   17491 </span>            : {
<span class="lineNum">   17492 </span><span class="lineCov">   17660964 :   if (loc-&gt;dw_loc_opc == DW_OP_nop &amp;&amp; loc-&gt;dw_loc_next == NULL)</span>
<span class="lineNum">   17493 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">   17494 </span>            : 
<span class="lineNum">   17495 </span>            :   /* Set of all DW_OP_nop operations we remove.  */
<span class="lineNum">   17496 </span><span class="lineCov">   35321928 :   hash_set&lt;dw_loc_descr_ref&gt; nops;</span>
<span class="lineNum">   17497 </span>            : 
<span class="lineNum">   17498 </span>            :   /* First, strip all prefix NOP operations in order to keep the head of the
<span class="lineNum">   17499 </span>            :      operations list.  */
<span class="lineNum">   17500 </span><span class="lineCov">   17660964 :   loc_descr_to_next_no_nop (loc, nops);</span>
<span class="lineNum">   17501 </span>            : 
<span class="lineNum">   17502 </span><span class="lineCov">   50235606 :   for (dw_loc_descr_ref cur = loc; cur != NULL;)</span>
<span class="lineNum">   17503 </span>            :     {
<span class="lineNum">   17504 </span>            :       /* For control flow operations: strip &quot;prefix&quot; nops in destination
<span class="lineNum">   17505 </span>            :          labels.  */
<span class="lineNum">   17506 </span><span class="lineCov">   32574642 :       if (cur-&gt;dw_loc_oprnd1.val_class == dw_val_class_loc)</span>
<span class="lineNum">   17507 </span><span class="lineCov">     840182 :         loc_descr_to_next_no_nop (cur-&gt;dw_loc_oprnd1.v.val_loc, nops);</span>
<span class="lineNum">   17508 </span><span class="lineCov">   32574642 :       if (cur-&gt;dw_loc_oprnd2.val_class == dw_val_class_loc)</span>
<span class="lineNum">   17509 </span><span class="lineNoCov">          0 :         loc_descr_to_next_no_nop (cur-&gt;dw_loc_oprnd2.v.val_loc, nops);</span>
<span class="lineNum">   17510 </span>            : 
<span class="lineNum">   17511 </span>            :       /* Do the same for the operations that follow, then move to the next
<span class="lineNum">   17512 </span>            :          iteration.  */
<span class="lineNum">   17513 </span><span class="lineCov">   32574642 :       if (cur-&gt;dw_loc_next != NULL)</span>
<span class="lineNum">   17514 </span><span class="lineCov">   14913678 :         loc_descr_to_next_no_nop (cur-&gt;dw_loc_next, nops);</span>
<span class="lineNum">   17515 </span><span class="lineCov">   32574642 :       cur = cur-&gt;dw_loc_next;</span>
<span class="lineNum">   17516 </span>            :     }
<span class="lineNum">   17517 </span>            : 
<span class="lineNum">   17518 </span><span class="lineCov">   17660964 :   nops.traverse&lt;void *, free_loc_descr&gt; (NULL);</span>
<span class="lineNum">   17519 </span>            : }
<span class="lineNum">   17520 </span>            : 
<span class="lineNum">   17521 </span>            : 
<span class="lineNum">   17522 </span>            : struct dwarf_procedure_info;
<span class="lineNum">   17523 </span>            : 
<span class="lineNum">   17524 </span>            : /* Helper structure for location descriptions generation.  */
<span class="lineNum">   17525 </span>            : struct loc_descr_context
<span class="lineNum">   17526 </span>            : {
<span class="lineNum">   17527 </span>            :   /* The type that is implicitly referenced by DW_OP_push_object_address, or
<span class="lineNum">   17528 </span>            :      NULL_TREE if DW_OP_push_object_address in invalid for this location
<span class="lineNum">   17529 </span>            :      description.  This is used when processing PLACEHOLDER_EXPR nodes.  */
<span class="lineNum">   17530 </span>            :   tree context_type;
<span class="lineNum">   17531 </span>            :   /* The ..._DECL node that should be translated as a
<span class="lineNum">   17532 </span>            :      DW_OP_push_object_address operation.  */
<span class="lineNum">   17533 </span>            :   tree base_decl;
<span class="lineNum">   17534 </span>            :   /* Information about the DWARF procedure we are currently generating. NULL if
<span class="lineNum">   17535 </span>            :      we are not generating a DWARF procedure.  */
<span class="lineNum">   17536 </span>            :   struct dwarf_procedure_info *dpi;
<span class="lineNum">   17537 </span>            :   /* True if integral PLACEHOLDER_EXPR stands for the first argument passed
<span class="lineNum">   17538 </span>            :      by consumer.  Used for DW_TAG_generic_subrange attributes.  */
<span class="lineNum">   17539 </span>            :   bool placeholder_arg;
<span class="lineNum">   17540 </span>            :   /* True if PLACEHOLDER_EXPR has been seen.  */
<span class="lineNum">   17541 </span>            :   bool placeholder_seen;
<span class="lineNum">   17542 </span>            : };
<span class="lineNum">   17543 </span>            : 
<span class="lineNum">   17544 </span>            : /* DWARF procedures generation
<span class="lineNum">   17545 </span>            : 
<span class="lineNum">   17546 </span>            :    DWARF expressions (aka. location descriptions) are used to encode variable
<span class="lineNum">   17547 </span>            :    things such as sizes or offsets.  Such computations can have redundant parts
<span class="lineNum">   17548 </span>            :    that can be factorized in order to reduce the size of the output debug
<span class="lineNum">   17549 </span>            :    information.  This is the whole point of DWARF procedures.
<span class="lineNum">   17550 </span>            : 
<span class="lineNum">   17551 </span>            :    Thanks to stor-layout.c, size and offset expressions in GENERIC trees are
<span class="lineNum">   17552 </span>            :    already factorized into functions (&quot;size functions&quot;) in order to handle very
<span class="lineNum">   17553 </span>            :    big and complex types.  Such functions are quite simple: they have integral
<span class="lineNum">   17554 </span>            :    arguments, they return an integral result and their body contains only a
<span class="lineNum">   17555 </span>            :    return statement with arithmetic expressions.  This is the only kind of
<span class="lineNum">   17556 </span>            :    function we are interested in translating into DWARF procedures, here.
<span class="lineNum">   17557 </span>            : 
<span class="lineNum">   17558 </span>            :    DWARF expressions and DWARF procedure are executed using a stack, so we have
<span class="lineNum">   17559 </span>            :    to define some calling convention for them to interact.  Let's say that:
<span class="lineNum">   17560 </span>            : 
<span class="lineNum">   17561 </span>            :    - Before calling a DWARF procedure, DWARF expressions must push on the stack
<span class="lineNum">   17562 </span>            :      all arguments in reverse order (right-to-left) so that when the DWARF
<span class="lineNum">   17563 </span>            :      procedure execution starts, the first argument is the top of the stack.
<span class="lineNum">   17564 </span>            : 
<span class="lineNum">   17565 </span>            :    - Then, when returning, the DWARF procedure must have consumed all arguments
<span class="lineNum">   17566 </span>            :      on the stack, must have pushed the result and touched nothing else.
<span class="lineNum">   17567 </span>            : 
<span class="lineNum">   17568 </span>            :    - Each integral argument and the result are integral types can be hold in a
<span class="lineNum">   17569 </span>            :      single stack slot.
<span class="lineNum">   17570 </span>            : 
<span class="lineNum">   17571 </span>            :    - We call &quot;frame offset&quot; the number of stack slots that are &quot;under DWARF
<span class="lineNum">   17572 </span>            :      procedure control&quot;: it includes the arguments slots, the temporaries and
<span class="lineNum">   17573 </span>            :      the result slot. Thus, it is equal to the number of arguments when the
<span class="lineNum">   17574 </span>            :      procedure execution starts and must be equal to one (the result) when it
<span class="lineNum">   17575 </span>            :      returns.  */
<span class="lineNum">   17576 </span>            : 
<span class="lineNum">   17577 </span>            : /* Helper structure used when generating operations for a DWARF procedure.  */
<span class="lineNum">   17578 </span>            : struct dwarf_procedure_info
<span class="lineNum">   17579 </span>            : {
<span class="lineNum">   17580 </span>            :   /* The FUNCTION_DECL node corresponding to the DWARF procedure that is
<span class="lineNum">   17581 </span>            :      currently translated.  */
<span class="lineNum">   17582 </span>            :   tree fndecl;
<span class="lineNum">   17583 </span>            :   /* The number of arguments FNDECL takes.  */
<span class="lineNum">   17584 </span>            :   unsigned args_count;
<span class="lineNum">   17585 </span>            : };
<span class="lineNum">   17586 </span>            : 
<span class="lineNum">   17587 </span>            : /* Return a pointer to a newly created DIE node for a DWARF procedure.  Add
<span class="lineNum">   17588 </span>            :    LOCATION as its DW_AT_location attribute.  If FNDECL is not NULL_TREE,
<span class="lineNum">   17589 </span>            :    equate it to this DIE.  */
<a name="17590"><span class="lineNum">   17590 </span>            : </a>
<span class="lineNum">   17591 </span>            : static dw_die_ref
<span class="lineNum">   17592 </span><span class="lineNoCov">          0 : new_dwarf_proc_die (dw_loc_descr_ref location, tree fndecl,</span>
<span class="lineNum">   17593 </span>            :                     dw_die_ref parent_die)
<span class="lineNum">   17594 </span>            : {
<span class="lineNum">   17595 </span><span class="lineNoCov">          0 :   dw_die_ref dwarf_proc_die;</span>
<span class="lineNum">   17596 </span>            : 
<span class="lineNum">   17597 </span><span class="lineNoCov">          0 :   if ((dwarf_version &lt; 3 &amp;&amp; dwarf_strict)</span>
<span class="lineNum">   17598 </span><span class="lineNoCov">          0 :       || location == NULL)</span>
<span class="lineNum">   17599 </span>            :     return NULL;
<span class="lineNum">   17600 </span>            : 
<span class="lineNum">   17601 </span><span class="lineNoCov">          0 :   dwarf_proc_die = new_die (DW_TAG_dwarf_procedure, parent_die, fndecl);</span>
<span class="lineNum">   17602 </span><span class="lineNoCov">          0 :   if (fndecl)</span>
<span class="lineNum">   17603 </span><span class="lineNoCov">          0 :     equate_decl_number_to_die (fndecl, dwarf_proc_die);</span>
<span class="lineNum">   17604 </span><span class="lineNoCov">          0 :   add_AT_loc (dwarf_proc_die, DW_AT_location, location);</span>
<span class="lineNum">   17605 </span><span class="lineNoCov">          0 :   return dwarf_proc_die;</span>
<span class="lineNum">   17606 </span>            : }
<span class="lineNum">   17607 </span>            : 
<span class="lineNum">   17608 </span>            : /* Return whether TYPE is a supported type as a DWARF procedure argument
<span class="lineNum">   17609 </span>            :    type or return type (we handle only scalar types and pointer types that
<span class="lineNum">   17610 </span>            :    aren't wider than the DWARF expression evaluation stack.  */
<a name="17611"><span class="lineNum">   17611 </span>            : </a>
<span class="lineNum">   17612 </span>            : static bool
<span class="lineNum">   17613 </span><span class="lineNoCov">          0 : is_handled_procedure_type (tree type)</span>
<span class="lineNum">   17614 </span>            : {
<span class="lineNum">   17615 </span><span class="lineNoCov">          0 :   return ((INTEGRAL_TYPE_P (type)</span>
<span class="lineNum">   17616 </span>            :            || TREE_CODE (type) == OFFSET_TYPE
<span class="lineNum">   17617 </span><span class="lineNoCov">          0 :            || TREE_CODE (type) == POINTER_TYPE)</span>
<span class="lineNum">   17618 </span><span class="lineNoCov">          0 :           &amp;&amp; int_size_in_bytes (type) &lt;= DWARF2_ADDR_SIZE);</span>
<span class="lineNum">   17619 </span>            : }
<span class="lineNum">   17620 </span>            : 
<span class="lineNum">   17621 </span>            : /* Helper for resolve_args_picking: do the same but stop when coming across
<span class="lineNum">   17622 </span>            :    visited nodes.  For each node we visit, register in FRAME_OFFSETS the frame
<span class="lineNum">   17623 </span>            :    offset *before* evaluating the corresponding operation.  */
<a name="17624"><span class="lineNum">   17624 </span>            : </a>
<span class="lineNum">   17625 </span>            : static bool
<span class="lineNum">   17626 </span><span class="lineNoCov">          0 : resolve_args_picking_1 (dw_loc_descr_ref loc, unsigned initial_frame_offset,</span>
<span class="lineNum">   17627 </span>            :                         struct dwarf_procedure_info *dpi,
<span class="lineNum">   17628 </span>            :                         hash_map&lt;dw_loc_descr_ref, unsigned&gt; &amp;frame_offsets)
<span class="lineNum">   17629 </span>            : {
<span class="lineNum">   17630 </span>            :   /* The &quot;frame_offset&quot; identifier is already used to name a macro... */
<span class="lineNum">   17631 </span><span class="lineNoCov">          0 :   unsigned frame_offset_ = initial_frame_offset;</span>
<span class="lineNum">   17632 </span><span class="lineNoCov">          0 :   dw_loc_descr_ref l;</span>
<span class="lineNum">   17633 </span>            : 
<span class="lineNum">   17634 </span><span class="lineNoCov">          0 :   for (l = loc; l != NULL;)</span>
<span class="lineNum">   17635 </span>            :     {
<span class="lineNum">   17636 </span><span class="lineNoCov">          0 :       bool existed;</span>
<span class="lineNum">   17637 </span><span class="lineNoCov">          0 :       unsigned &amp;l_frame_offset = frame_offsets.get_or_insert (l, &amp;existed);</span>
<span class="lineNum">   17638 </span>            : 
<span class="lineNum">   17639 </span>            :       /* If we already met this node, there is nothing to compute anymore.  */
<span class="lineNum">   17640 </span><span class="lineNoCov">          0 :       if (existed)</span>
<span class="lineNum">   17641 </span>            :         {
<span class="lineNum">   17642 </span>            :           /* Make sure that the stack size is consistent wherever the execution
<span class="lineNum">   17643 </span>            :              flow comes from.  */
<span class="lineNum">   17644 </span><span class="lineNoCov">          0 :           gcc_assert ((unsigned) l_frame_offset == frame_offset_);</span>
<span class="lineNum">   17645 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   17646 </span>            :         }
<span class="lineNum">   17647 </span><span class="lineNoCov">          0 :       l_frame_offset = frame_offset_;</span>
<span class="lineNum">   17648 </span>            : 
<span class="lineNum">   17649 </span>            :       /* If needed, relocate the picking offset with respect to the frame
<span class="lineNum">   17650 </span>            :          offset. */
<span class="lineNum">   17651 </span><span class="lineNoCov">          0 :       if (l-&gt;frame_offset_rel)</span>
<span class="lineNum">   17652 </span>            :         {
<span class="lineNum">   17653 </span><span class="lineNoCov">          0 :           unsigned HOST_WIDE_INT off;</span>
<span class="lineNum">   17654 </span><span class="lineNoCov">          0 :           switch (l-&gt;dw_loc_opc)</span>
<span class="lineNum">   17655 </span>            :             {
<span class="lineNum">   17656 </span><span class="lineNoCov">          0 :             case DW_OP_pick:</span>
<span class="lineNum">   17657 </span><span class="lineNoCov">          0 :               off = l-&gt;dw_loc_oprnd1.v.val_unsigned;</span>
<span class="lineNum">   17658 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">   17659 </span>            :             case DW_OP_dup:
<span class="lineNum">   17660 </span>            :               off = 0;
<span class="lineNum">   17661 </span>            :               break;
<span class="lineNum">   17662 </span><span class="lineNoCov">          0 :             case DW_OP_over:</span>
<span class="lineNum">   17663 </span><span class="lineNoCov">          0 :               off = 1;</span>
<span class="lineNum">   17664 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">   17665 </span><span class="lineNoCov">          0 :             default:</span>
<span class="lineNum">   17666 </span><span class="lineNoCov">          0 :               gcc_unreachable ();</span>
<span class="lineNum">   17667 </span>            :             }
<span class="lineNum">   17668 </span>            :           /* frame_offset_ is the size of the current stack frame, including
<span class="lineNum">   17669 </span>            :              incoming arguments. Besides, the arguments are pushed
<span class="lineNum">   17670 </span>            :              right-to-left.  Thus, in order to access the Nth argument from
<span class="lineNum">   17671 </span>            :              this operation node, the picking has to skip temporaries *plus*
<span class="lineNum">   17672 </span>            :              one stack slot per argument (0 for the first one, 1 for the second
<span class="lineNum">   17673 </span>            :              one, etc.).
<span class="lineNum">   17674 </span>            : 
<span class="lineNum">   17675 </span>            :              The targetted argument number (N) is already set as the operand,
<span class="lineNum">   17676 </span>            :              and the number of temporaries can be computed with:
<span class="lineNum">   17677 </span>            :                frame_offsets_ - dpi-&gt;args_count */
<span class="lineNum">   17678 </span><span class="lineNoCov">          0 :           off += frame_offset_ - dpi-&gt;args_count;</span>
<span class="lineNum">   17679 </span>            : 
<span class="lineNum">   17680 </span>            :           /* DW_OP_pick handles only offsets from 0 to 255 (inclusive)...  */
<span class="lineNum">   17681 </span><span class="lineNoCov">          0 :           if (off &gt; 255)</span>
<span class="lineNum">   17682 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">   17683 </span>            : 
<span class="lineNum">   17684 </span><span class="lineNoCov">          0 :           if (off == 0)</span>
<span class="lineNum">   17685 </span>            :             {
<span class="lineNum">   17686 </span><span class="lineNoCov">          0 :               l-&gt;dw_loc_opc = DW_OP_dup;</span>
<span class="lineNum">   17687 </span><span class="lineNoCov">          0 :               l-&gt;dw_loc_oprnd1.v.val_unsigned = 0;</span>
<span class="lineNum">   17688 </span>            :             }
<span class="lineNum">   17689 </span><span class="lineNoCov">          0 :           else if (off == 1)</span>
<span class="lineNum">   17690 </span>            :             {
<span class="lineNum">   17691 </span><span class="lineNoCov">          0 :               l-&gt;dw_loc_opc = DW_OP_over;</span>
<span class="lineNum">   17692 </span><span class="lineNoCov">          0 :               l-&gt;dw_loc_oprnd1.v.val_unsigned = 0;</span>
<span class="lineNum">   17693 </span>            :             }
<span class="lineNum">   17694 </span>            :           else
<span class="lineNum">   17695 </span>            :             {
<span class="lineNum">   17696 </span><span class="lineNoCov">          0 :               l-&gt;dw_loc_opc = DW_OP_pick;</span>
<span class="lineNum">   17697 </span><span class="lineNoCov">          0 :               l-&gt;dw_loc_oprnd1.v.val_unsigned = off;</span>
<span class="lineNum">   17698 </span>            :             }
<span class="lineNum">   17699 </span>            :         }
<span class="lineNum">   17700 </span>            : 
<span class="lineNum">   17701 </span>            :       /* Update frame_offset according to the effect the current operation has
<span class="lineNum">   17702 </span>            :          on the stack.  */
<span class="lineNum">   17703 </span><span class="lineNoCov">          0 :       switch (l-&gt;dw_loc_opc)</span>
<span class="lineNum">   17704 </span>            :         {
<span class="lineNum">   17705 </span>            :         case DW_OP_deref:
<span class="lineNum">   17706 </span>            :         case DW_OP_swap:
<span class="lineNum">   17707 </span>            :         case DW_OP_rot:
<span class="lineNum">   17708 </span>            :         case DW_OP_abs:
<span class="lineNum">   17709 </span>            :         case DW_OP_neg:
<span class="lineNum">   17710 </span>            :         case DW_OP_not:
<span class="lineNum">   17711 </span>            :         case DW_OP_plus_uconst:
<span class="lineNum">   17712 </span>            :         case DW_OP_skip:
<span class="lineNum">   17713 </span>            :         case DW_OP_reg0:
<span class="lineNum">   17714 </span>            :         case DW_OP_reg1:
<span class="lineNum">   17715 </span>            :         case DW_OP_reg2:
<span class="lineNum">   17716 </span>            :         case DW_OP_reg3:
<span class="lineNum">   17717 </span>            :         case DW_OP_reg4:
<span class="lineNum">   17718 </span>            :         case DW_OP_reg5:
<span class="lineNum">   17719 </span>            :         case DW_OP_reg6:
<span class="lineNum">   17720 </span>            :         case DW_OP_reg7:
<span class="lineNum">   17721 </span>            :         case DW_OP_reg8:
<span class="lineNum">   17722 </span>            :         case DW_OP_reg9:
<span class="lineNum">   17723 </span>            :         case DW_OP_reg10:
<span class="lineNum">   17724 </span>            :         case DW_OP_reg11:
<span class="lineNum">   17725 </span>            :         case DW_OP_reg12:
<span class="lineNum">   17726 </span>            :         case DW_OP_reg13:
<span class="lineNum">   17727 </span>            :         case DW_OP_reg14:
<span class="lineNum">   17728 </span>            :         case DW_OP_reg15:
<span class="lineNum">   17729 </span>            :         case DW_OP_reg16:
<span class="lineNum">   17730 </span>            :         case DW_OP_reg17:
<span class="lineNum">   17731 </span>            :         case DW_OP_reg18:
<span class="lineNum">   17732 </span>            :         case DW_OP_reg19:
<span class="lineNum">   17733 </span>            :         case DW_OP_reg20:
<span class="lineNum">   17734 </span>            :         case DW_OP_reg21:
<span class="lineNum">   17735 </span>            :         case DW_OP_reg22:
<span class="lineNum">   17736 </span>            :         case DW_OP_reg23:
<span class="lineNum">   17737 </span>            :         case DW_OP_reg24:
<span class="lineNum">   17738 </span>            :         case DW_OP_reg25:
<span class="lineNum">   17739 </span>            :         case DW_OP_reg26:
<span class="lineNum">   17740 </span>            :         case DW_OP_reg27:
<span class="lineNum">   17741 </span>            :         case DW_OP_reg28:
<span class="lineNum">   17742 </span>            :         case DW_OP_reg29:
<span class="lineNum">   17743 </span>            :         case DW_OP_reg30:
<span class="lineNum">   17744 </span>            :         case DW_OP_reg31:
<span class="lineNum">   17745 </span>            :         case DW_OP_bregx:
<span class="lineNum">   17746 </span>            :         case DW_OP_piece:
<span class="lineNum">   17747 </span>            :         case DW_OP_deref_size:
<span class="lineNum">   17748 </span>            :         case DW_OP_nop:
<span class="lineNum">   17749 </span>            :         case DW_OP_bit_piece:
<span class="lineNum">   17750 </span>            :         case DW_OP_implicit_value:
<span class="lineNum">   17751 </span>            :         case DW_OP_stack_value:
<span class="lineNum">   17752 </span>            :           break;
<span class="lineNum">   17753 </span>            : 
<span class="lineNum">   17754 </span><span class="lineNoCov">          0 :         case DW_OP_addr:</span>
<span class="lineNum">   17755 </span><span class="lineNoCov">          0 :         case DW_OP_const1u:</span>
<span class="lineNum">   17756 </span><span class="lineNoCov">          0 :         case DW_OP_const1s:</span>
<span class="lineNum">   17757 </span><span class="lineNoCov">          0 :         case DW_OP_const2u:</span>
<span class="lineNum">   17758 </span><span class="lineNoCov">          0 :         case DW_OP_const2s:</span>
<span class="lineNum">   17759 </span><span class="lineNoCov">          0 :         case DW_OP_const4u:</span>
<span class="lineNum">   17760 </span><span class="lineNoCov">          0 :         case DW_OP_const4s:</span>
<span class="lineNum">   17761 </span><span class="lineNoCov">          0 :         case DW_OP_const8u:</span>
<span class="lineNum">   17762 </span><span class="lineNoCov">          0 :         case DW_OP_const8s:</span>
<span class="lineNum">   17763 </span><span class="lineNoCov">          0 :         case DW_OP_constu:</span>
<span class="lineNum">   17764 </span><span class="lineNoCov">          0 :         case DW_OP_consts:</span>
<span class="lineNum">   17765 </span><span class="lineNoCov">          0 :         case DW_OP_dup:</span>
<span class="lineNum">   17766 </span><span class="lineNoCov">          0 :         case DW_OP_over:</span>
<span class="lineNum">   17767 </span><span class="lineNoCov">          0 :         case DW_OP_pick:</span>
<span class="lineNum">   17768 </span><span class="lineNoCov">          0 :         case DW_OP_lit0:</span>
<span class="lineNum">   17769 </span><span class="lineNoCov">          0 :         case DW_OP_lit1:</span>
<span class="lineNum">   17770 </span><span class="lineNoCov">          0 :         case DW_OP_lit2:</span>
<span class="lineNum">   17771 </span><span class="lineNoCov">          0 :         case DW_OP_lit3:</span>
<span class="lineNum">   17772 </span><span class="lineNoCov">          0 :         case DW_OP_lit4:</span>
<span class="lineNum">   17773 </span><span class="lineNoCov">          0 :         case DW_OP_lit5:</span>
<span class="lineNum">   17774 </span><span class="lineNoCov">          0 :         case DW_OP_lit6:</span>
<span class="lineNum">   17775 </span><span class="lineNoCov">          0 :         case DW_OP_lit7:</span>
<span class="lineNum">   17776 </span><span class="lineNoCov">          0 :         case DW_OP_lit8:</span>
<span class="lineNum">   17777 </span><span class="lineNoCov">          0 :         case DW_OP_lit9:</span>
<span class="lineNum">   17778 </span><span class="lineNoCov">          0 :         case DW_OP_lit10:</span>
<span class="lineNum">   17779 </span><span class="lineNoCov">          0 :         case DW_OP_lit11:</span>
<span class="lineNum">   17780 </span><span class="lineNoCov">          0 :         case DW_OP_lit12:</span>
<span class="lineNum">   17781 </span><span class="lineNoCov">          0 :         case DW_OP_lit13:</span>
<span class="lineNum">   17782 </span><span class="lineNoCov">          0 :         case DW_OP_lit14:</span>
<span class="lineNum">   17783 </span><span class="lineNoCov">          0 :         case DW_OP_lit15:</span>
<span class="lineNum">   17784 </span><span class="lineNoCov">          0 :         case DW_OP_lit16:</span>
<span class="lineNum">   17785 </span><span class="lineNoCov">          0 :         case DW_OP_lit17:</span>
<span class="lineNum">   17786 </span><span class="lineNoCov">          0 :         case DW_OP_lit18:</span>
<span class="lineNum">   17787 </span><span class="lineNoCov">          0 :         case DW_OP_lit19:</span>
<span class="lineNum">   17788 </span><span class="lineNoCov">          0 :         case DW_OP_lit20:</span>
<span class="lineNum">   17789 </span><span class="lineNoCov">          0 :         case DW_OP_lit21:</span>
<span class="lineNum">   17790 </span><span class="lineNoCov">          0 :         case DW_OP_lit22:</span>
<span class="lineNum">   17791 </span><span class="lineNoCov">          0 :         case DW_OP_lit23:</span>
<span class="lineNum">   17792 </span><span class="lineNoCov">          0 :         case DW_OP_lit24:</span>
<span class="lineNum">   17793 </span><span class="lineNoCov">          0 :         case DW_OP_lit25:</span>
<span class="lineNum">   17794 </span><span class="lineNoCov">          0 :         case DW_OP_lit26:</span>
<span class="lineNum">   17795 </span><span class="lineNoCov">          0 :         case DW_OP_lit27:</span>
<span class="lineNum">   17796 </span><span class="lineNoCov">          0 :         case DW_OP_lit28:</span>
<span class="lineNum">   17797 </span><span class="lineNoCov">          0 :         case DW_OP_lit29:</span>
<span class="lineNum">   17798 </span><span class="lineNoCov">          0 :         case DW_OP_lit30:</span>
<span class="lineNum">   17799 </span><span class="lineNoCov">          0 :         case DW_OP_lit31:</span>
<span class="lineNum">   17800 </span><span class="lineNoCov">          0 :         case DW_OP_breg0:</span>
<span class="lineNum">   17801 </span><span class="lineNoCov">          0 :         case DW_OP_breg1:</span>
<span class="lineNum">   17802 </span><span class="lineNoCov">          0 :         case DW_OP_breg2:</span>
<span class="lineNum">   17803 </span><span class="lineNoCov">          0 :         case DW_OP_breg3:</span>
<span class="lineNum">   17804 </span><span class="lineNoCov">          0 :         case DW_OP_breg4:</span>
<span class="lineNum">   17805 </span><span class="lineNoCov">          0 :         case DW_OP_breg5:</span>
<span class="lineNum">   17806 </span><span class="lineNoCov">          0 :         case DW_OP_breg6:</span>
<span class="lineNum">   17807 </span><span class="lineNoCov">          0 :         case DW_OP_breg7:</span>
<span class="lineNum">   17808 </span><span class="lineNoCov">          0 :         case DW_OP_breg8:</span>
<span class="lineNum">   17809 </span><span class="lineNoCov">          0 :         case DW_OP_breg9:</span>
<span class="lineNum">   17810 </span><span class="lineNoCov">          0 :         case DW_OP_breg10:</span>
<span class="lineNum">   17811 </span><span class="lineNoCov">          0 :         case DW_OP_breg11:</span>
<span class="lineNum">   17812 </span><span class="lineNoCov">          0 :         case DW_OP_breg12:</span>
<span class="lineNum">   17813 </span><span class="lineNoCov">          0 :         case DW_OP_breg13:</span>
<span class="lineNum">   17814 </span><span class="lineNoCov">          0 :         case DW_OP_breg14:</span>
<span class="lineNum">   17815 </span><span class="lineNoCov">          0 :         case DW_OP_breg15:</span>
<span class="lineNum">   17816 </span><span class="lineNoCov">          0 :         case DW_OP_breg16:</span>
<span class="lineNum">   17817 </span><span class="lineNoCov">          0 :         case DW_OP_breg17:</span>
<span class="lineNum">   17818 </span><span class="lineNoCov">          0 :         case DW_OP_breg18:</span>
<span class="lineNum">   17819 </span><span class="lineNoCov">          0 :         case DW_OP_breg19:</span>
<span class="lineNum">   17820 </span><span class="lineNoCov">          0 :         case DW_OP_breg20:</span>
<span class="lineNum">   17821 </span><span class="lineNoCov">          0 :         case DW_OP_breg21:</span>
<span class="lineNum">   17822 </span><span class="lineNoCov">          0 :         case DW_OP_breg22:</span>
<span class="lineNum">   17823 </span><span class="lineNoCov">          0 :         case DW_OP_breg23:</span>
<span class="lineNum">   17824 </span><span class="lineNoCov">          0 :         case DW_OP_breg24:</span>
<span class="lineNum">   17825 </span><span class="lineNoCov">          0 :         case DW_OP_breg25:</span>
<span class="lineNum">   17826 </span><span class="lineNoCov">          0 :         case DW_OP_breg26:</span>
<span class="lineNum">   17827 </span><span class="lineNoCov">          0 :         case DW_OP_breg27:</span>
<span class="lineNum">   17828 </span><span class="lineNoCov">          0 :         case DW_OP_breg28:</span>
<span class="lineNum">   17829 </span><span class="lineNoCov">          0 :         case DW_OP_breg29:</span>
<span class="lineNum">   17830 </span><span class="lineNoCov">          0 :         case DW_OP_breg30:</span>
<span class="lineNum">   17831 </span><span class="lineNoCov">          0 :         case DW_OP_breg31:</span>
<span class="lineNum">   17832 </span><span class="lineNoCov">          0 :         case DW_OP_fbreg:</span>
<span class="lineNum">   17833 </span><span class="lineNoCov">          0 :         case DW_OP_push_object_address:</span>
<span class="lineNum">   17834 </span><span class="lineNoCov">          0 :         case DW_OP_call_frame_cfa:</span>
<span class="lineNum">   17835 </span><span class="lineNoCov">          0 :         case DW_OP_GNU_variable_value:</span>
<span class="lineNum">   17836 </span><span class="lineNoCov">          0 :           ++frame_offset_;</span>
<span class="lineNum">   17837 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   17838 </span>            : 
<span class="lineNum">   17839 </span><span class="lineNoCov">          0 :         case DW_OP_drop:</span>
<span class="lineNum">   17840 </span><span class="lineNoCov">          0 :         case DW_OP_xderef:</span>
<span class="lineNum">   17841 </span><span class="lineNoCov">          0 :         case DW_OP_and:</span>
<span class="lineNum">   17842 </span><span class="lineNoCov">          0 :         case DW_OP_div:</span>
<span class="lineNum">   17843 </span><span class="lineNoCov">          0 :         case DW_OP_minus:</span>
<span class="lineNum">   17844 </span><span class="lineNoCov">          0 :         case DW_OP_mod:</span>
<span class="lineNum">   17845 </span><span class="lineNoCov">          0 :         case DW_OP_mul:</span>
<span class="lineNum">   17846 </span><span class="lineNoCov">          0 :         case DW_OP_or:</span>
<span class="lineNum">   17847 </span><span class="lineNoCov">          0 :         case DW_OP_plus:</span>
<span class="lineNum">   17848 </span><span class="lineNoCov">          0 :         case DW_OP_shl:</span>
<span class="lineNum">   17849 </span><span class="lineNoCov">          0 :         case DW_OP_shr:</span>
<span class="lineNum">   17850 </span><span class="lineNoCov">          0 :         case DW_OP_shra:</span>
<span class="lineNum">   17851 </span><span class="lineNoCov">          0 :         case DW_OP_xor:</span>
<span class="lineNum">   17852 </span><span class="lineNoCov">          0 :         case DW_OP_bra:</span>
<span class="lineNum">   17853 </span><span class="lineNoCov">          0 :         case DW_OP_eq:</span>
<span class="lineNum">   17854 </span><span class="lineNoCov">          0 :         case DW_OP_ge:</span>
<span class="lineNum">   17855 </span><span class="lineNoCov">          0 :         case DW_OP_gt:</span>
<span class="lineNum">   17856 </span><span class="lineNoCov">          0 :         case DW_OP_le:</span>
<span class="lineNum">   17857 </span><span class="lineNoCov">          0 :         case DW_OP_lt:</span>
<span class="lineNum">   17858 </span><span class="lineNoCov">          0 :         case DW_OP_ne:</span>
<span class="lineNum">   17859 </span><span class="lineNoCov">          0 :         case DW_OP_regx:</span>
<span class="lineNum">   17860 </span><span class="lineNoCov">          0 :         case DW_OP_xderef_size:</span>
<span class="lineNum">   17861 </span><span class="lineNoCov">          0 :           --frame_offset_;</span>
<span class="lineNum">   17862 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   17863 </span>            : 
<span class="lineNum">   17864 </span><span class="lineNoCov">          0 :         case DW_OP_call2:</span>
<span class="lineNum">   17865 </span><span class="lineNoCov">          0 :         case DW_OP_call4:</span>
<span class="lineNum">   17866 </span><span class="lineNoCov">          0 :         case DW_OP_call_ref:</span>
<span class="lineNum">   17867 </span><span class="lineNoCov">          0 :           {</span>
<span class="lineNum">   17868 </span><span class="lineNoCov">          0 :             dw_die_ref dwarf_proc = l-&gt;dw_loc_oprnd1.v.val_die_ref.die;</span>
<span class="lineNum">   17869 </span><span class="lineNoCov">          0 :             int *stack_usage = dwarf_proc_stack_usage_map-&gt;get (dwarf_proc);</span>
<span class="lineNum">   17870 </span>            : 
<span class="lineNum">   17871 </span><span class="lineNoCov">          0 :             if (stack_usage == NULL)</span>
<span class="lineNum">   17872 </span><span class="lineNoCov">          0 :               return false;</span>
<span class="lineNum">   17873 </span><span class="lineNoCov">          0 :             frame_offset_ += *stack_usage;</span>
<span class="lineNum">   17874 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">   17875 </span>            :           }
<span class="lineNum">   17876 </span>            : 
<span class="lineNum">   17877 </span><span class="lineNoCov">          0 :         case DW_OP_implicit_pointer:</span>
<span class="lineNum">   17878 </span><span class="lineNoCov">          0 :         case DW_OP_entry_value:</span>
<span class="lineNum">   17879 </span><span class="lineNoCov">          0 :         case DW_OP_const_type:</span>
<span class="lineNum">   17880 </span><span class="lineNoCov">          0 :         case DW_OP_regval_type:</span>
<span class="lineNum">   17881 </span><span class="lineNoCov">          0 :         case DW_OP_deref_type:</span>
<span class="lineNum">   17882 </span><span class="lineNoCov">          0 :         case DW_OP_convert:</span>
<span class="lineNum">   17883 </span><span class="lineNoCov">          0 :         case DW_OP_reinterpret:</span>
<span class="lineNum">   17884 </span><span class="lineNoCov">          0 :         case DW_OP_form_tls_address:</span>
<span class="lineNum">   17885 </span><span class="lineNoCov">          0 :         case DW_OP_GNU_push_tls_address:</span>
<span class="lineNum">   17886 </span><span class="lineNoCov">          0 :         case DW_OP_GNU_uninit:</span>
<span class="lineNum">   17887 </span><span class="lineNoCov">          0 :         case DW_OP_GNU_encoded_addr:</span>
<span class="lineNum">   17888 </span><span class="lineNoCov">          0 :         case DW_OP_GNU_implicit_pointer:</span>
<span class="lineNum">   17889 </span><span class="lineNoCov">          0 :         case DW_OP_GNU_entry_value:</span>
<span class="lineNum">   17890 </span><span class="lineNoCov">          0 :         case DW_OP_GNU_const_type:</span>
<span class="lineNum">   17891 </span><span class="lineNoCov">          0 :         case DW_OP_GNU_regval_type:</span>
<span class="lineNum">   17892 </span><span class="lineNoCov">          0 :         case DW_OP_GNU_deref_type:</span>
<span class="lineNum">   17893 </span><span class="lineNoCov">          0 :         case DW_OP_GNU_convert:</span>
<span class="lineNum">   17894 </span><span class="lineNoCov">          0 :         case DW_OP_GNU_reinterpret:</span>
<span class="lineNum">   17895 </span><span class="lineNoCov">          0 :         case DW_OP_GNU_parameter_ref:</span>
<span class="lineNum">   17896 </span>            :           /* loc_list_from_tree will probably not output these operations for
<span class="lineNum">   17897 </span>            :              size functions, so assume they will not appear here.  */
<span class="lineNum">   17898 </span>            :           /* Fall through...  */
<span class="lineNum">   17899 </span>            : 
<span class="lineNum">   17900 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">   17901 </span><span class="lineNoCov">          0 :           gcc_unreachable ();</span>
<span class="lineNum">   17902 </span>            :         }
<span class="lineNum">   17903 </span>            : 
<span class="lineNum">   17904 </span>            :       /* Now, follow the control flow (except subroutine calls).  */
<span class="lineNum">   17905 </span><span class="lineNoCov">          0 :       switch (l-&gt;dw_loc_opc)</span>
<span class="lineNum">   17906 </span>            :         {
<span class="lineNum">   17907 </span><span class="lineNoCov">          0 :         case DW_OP_bra:</span>
<span class="lineNum">   17908 </span><span class="lineNoCov">          0 :           if (!resolve_args_picking_1 (l-&gt;dw_loc_next, frame_offset_, dpi,</span>
<span class="lineNum">   17909 </span>            :                                        frame_offsets))
<span class="lineNum">   17910 </span>            :             return false;
<span class="lineNum">   17911 </span>            :           /* Fall through. */
<span class="lineNum">   17912 </span>            : 
<span class="lineNum">   17913 </span><span class="lineNoCov">          0 :         case DW_OP_skip:</span>
<span class="lineNum">   17914 </span><span class="lineNoCov">          0 :           l = l-&gt;dw_loc_oprnd1.v.val_loc;</span>
<span class="lineNum">   17915 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   17916 </span>            : 
<span class="lineNum">   17917 </span>            :         case DW_OP_stack_value:
<span class="lineNum">   17918 </span>            :           return true;
<span class="lineNum">   17919 </span>            : 
<span class="lineNum">   17920 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">   17921 </span><span class="lineNoCov">          0 :           l = l-&gt;dw_loc_next;</span>
<span class="lineNum">   17922 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   17923 </span>            :         }
<span class="lineNum">   17924 </span>            :     }
<span class="lineNum">   17925 </span>            : 
<span class="lineNum">   17926 </span>            :   return true;
<span class="lineNum">   17927 </span>            : }
<span class="lineNum">   17928 </span>            : 
<span class="lineNum">   17929 </span>            : /* Make a DFS over operations reachable through LOC (i.e. follow branch
<span class="lineNum">   17930 </span>            :    operations) in order to resolve the operand of DW_OP_pick operations that
<span class="lineNum">   17931 </span>            :    target DWARF procedure arguments (DPI).  INITIAL_FRAME_OFFSET is the frame
<span class="lineNum">   17932 </span>            :    offset *before* LOC is executed.  Return if all relocations were
<span class="lineNum">   17933 </span>            :    successful.  */
<a name="17934"><span class="lineNum">   17934 </span>            : </a>
<span class="lineNum">   17935 </span>            : static bool
<span class="lineNum">   17936 </span><span class="lineNoCov">          0 : resolve_args_picking (dw_loc_descr_ref loc, unsigned initial_frame_offset,</span>
<span class="lineNum">   17937 </span>            :                       struct dwarf_procedure_info *dpi)
<span class="lineNum">   17938 </span>            : {
<span class="lineNum">   17939 </span>            :   /* Associate to all visited operations the frame offset *before* evaluating
<span class="lineNum">   17940 </span>            :      this operation.  */
<span class="lineNum">   17941 </span><span class="lineNoCov">          0 :   hash_map&lt;dw_loc_descr_ref, unsigned&gt; frame_offsets;</span>
<span class="lineNum">   17942 </span>            : 
<span class="lineNum">   17943 </span><span class="lineNoCov">          0 :   return resolve_args_picking_1 (loc, initial_frame_offset, dpi,</span>
<span class="lineNum">   17944 </span><span class="lineNoCov">          0 :                                  frame_offsets);</span>
<span class="lineNum">   17945 </span>            : }
<span class="lineNum">   17946 </span>            : 
<span class="lineNum">   17947 </span>            : /* Try to generate a DWARF procedure that computes the same result as FNDECL.
<span class="lineNum">   17948 </span>            :    Return NULL if it is not possible.  */
<a name="17949"><span class="lineNum">   17949 </span>            : </a>
<span class="lineNum">   17950 </span>            : static dw_die_ref
<span class="lineNum">   17951 </span><span class="lineNoCov">          0 : function_to_dwarf_procedure (tree fndecl)</span>
<span class="lineNum">   17952 </span>            : {
<span class="lineNum">   17953 </span><span class="lineNoCov">          0 :   struct loc_descr_context ctx;</span>
<span class="lineNum">   17954 </span><span class="lineNoCov">          0 :   struct dwarf_procedure_info dpi;</span>
<span class="lineNum">   17955 </span><span class="lineNoCov">          0 :   dw_die_ref dwarf_proc_die;</span>
<span class="lineNum">   17956 </span><span class="lineNoCov">          0 :   tree tree_body = DECL_SAVED_TREE (fndecl);</span>
<span class="lineNum">   17957 </span><span class="lineNoCov">          0 :   dw_loc_descr_ref loc_body, epilogue;</span>
<span class="lineNum">   17958 </span>            : 
<span class="lineNum">   17959 </span><span class="lineNoCov">          0 :   tree cursor;</span>
<span class="lineNum">   17960 </span><span class="lineNoCov">          0 :   unsigned i;</span>
<span class="lineNum">   17961 </span>            : 
<span class="lineNum">   17962 </span>            :   /* Do not generate multiple DWARF procedures for the same function
<span class="lineNum">   17963 </span>            :      declaration.  */
<span class="lineNum">   17964 </span><span class="lineNoCov">          0 :   dwarf_proc_die = lookup_decl_die (fndecl);</span>
<span class="lineNum">   17965 </span><span class="lineNoCov">          0 :   if (dwarf_proc_die != NULL)</span>
<span class="lineNum">   17966 </span>            :     return dwarf_proc_die;
<span class="lineNum">   17967 </span>            : 
<span class="lineNum">   17968 </span>            :   /* DWARF procedures are available starting with the DWARFv3 standard.  */
<span class="lineNum">   17969 </span><span class="lineNoCov">          0 :   if (dwarf_version &lt; 3 &amp;&amp; dwarf_strict)</span>
<span class="lineNum">   17970 </span>            :     return NULL;
<span class="lineNum">   17971 </span>            : 
<span class="lineNum">   17972 </span>            :   /* We handle only functions for which we still have a body, that return a
<span class="lineNum">   17973 </span>            :      supported type and that takes arguments with supported types.  Note that
<span class="lineNum">   17974 </span>            :      there is no point translating functions that return nothing.  */
<span class="lineNum">   17975 </span><span class="lineNoCov">          0 :   if (tree_body == NULL_TREE</span>
<span class="lineNum">   17976 </span><span class="lineNoCov">          0 :       || DECL_RESULT (fndecl) == NULL_TREE</span>
<span class="lineNum">   17977 </span><span class="lineNoCov">          0 :       || !is_handled_procedure_type (TREE_TYPE (DECL_RESULT (fndecl))))</span>
<span class="lineNum">   17978 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">   17979 </span>            : 
<span class="lineNum">   17980 </span><span class="lineNoCov">          0 :   for (cursor = DECL_ARGUMENTS (fndecl);</span>
<span class="lineNum">   17981 </span><span class="lineNoCov">          0 :        cursor != NULL_TREE;</span>
<span class="lineNum">   17982 </span><span class="lineNoCov">          0 :        cursor = TREE_CHAIN (cursor))</span>
<span class="lineNum">   17983 </span><span class="lineNoCov">          0 :     if (!is_handled_procedure_type (TREE_TYPE (cursor)))</span>
<span class="lineNum">   17984 </span>            :       return NULL;
<span class="lineNum">   17985 </span>            : 
<span class="lineNum">   17986 </span>            :   /* Match only &quot;expr&quot; in: RETURN_EXPR (MODIFY_EXPR (RESULT_DECL, expr)).  */
<span class="lineNum">   17987 </span><span class="lineNoCov">          0 :   if (TREE_CODE (tree_body) != RETURN_EXPR)</span>
<span class="lineNum">   17988 </span>            :     return NULL;
<span class="lineNum">   17989 </span><span class="lineNoCov">          0 :   tree_body = TREE_OPERAND (tree_body, 0);</span>
<span class="lineNum">   17990 </span><span class="lineNoCov">          0 :   if (TREE_CODE (tree_body) != MODIFY_EXPR</span>
<span class="lineNum">   17991 </span><span class="lineNoCov">          0 :       || TREE_OPERAND (tree_body, 0) != DECL_RESULT (fndecl))</span>
<span class="lineNum">   17992 </span>            :     return NULL;
<span class="lineNum">   17993 </span><span class="lineNoCov">          0 :   tree_body = TREE_OPERAND (tree_body, 1);</span>
<span class="lineNum">   17994 </span>            : 
<span class="lineNum">   17995 </span>            :   /* Try to translate the body expression itself.  Note that this will probably
<span class="lineNum">   17996 </span>            :      cause an infinite recursion if its call graph has a cycle.  This is very
<span class="lineNum">   17997 </span>            :      unlikely for size functions, however, so don't bother with such things at
<span class="lineNum">   17998 </span>            :      the moment.  */
<span class="lineNum">   17999 </span><span class="lineNoCov">          0 :   ctx.context_type = NULL_TREE;</span>
<span class="lineNum">   18000 </span><span class="lineNoCov">          0 :   ctx.base_decl = NULL_TREE;</span>
<span class="lineNum">   18001 </span><span class="lineNoCov">          0 :   ctx.dpi = &amp;dpi;</span>
<span class="lineNum">   18002 </span><span class="lineNoCov">          0 :   ctx.placeholder_arg = false;</span>
<span class="lineNum">   18003 </span><span class="lineNoCov">          0 :   ctx.placeholder_seen = false;</span>
<span class="lineNum">   18004 </span><span class="lineNoCov">          0 :   dpi.fndecl = fndecl;</span>
<span class="lineNum">   18005 </span><span class="lineNoCov">          0 :   dpi.args_count = list_length (DECL_ARGUMENTS (fndecl));</span>
<span class="lineNum">   18006 </span><span class="lineNoCov">          0 :   loc_body = loc_descriptor_from_tree (tree_body, 0, &amp;ctx);</span>
<span class="lineNum">   18007 </span><span class="lineNoCov">          0 :   if (!loc_body)</span>
<span class="lineNum">   18008 </span>            :     return NULL;
<span class="lineNum">   18009 </span>            : 
<span class="lineNum">   18010 </span>            :   /* After evaluating all operands in &quot;loc_body&quot;, we should still have on the
<span class="lineNum">   18011 </span>            :      stack all arguments plus the desired function result (top of the stack).
<span class="lineNum">   18012 </span>            :      Generate code in order to keep only the result in our stack frame.  */
<span class="lineNum">   18013 </span>            :   epilogue = NULL;
<span class="lineNum">   18014 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; dpi.args_count; ++i)</span>
<span class="lineNum">   18015 </span>            :     {
<span class="lineNum">   18016 </span><span class="lineNoCov">          0 :       dw_loc_descr_ref op_couple = new_loc_descr (DW_OP_swap, 0, 0);</span>
<span class="lineNum">   18017 </span><span class="lineNoCov">          0 :       op_couple-&gt;dw_loc_next = new_loc_descr (DW_OP_drop, 0, 0);</span>
<span class="lineNum">   18018 </span><span class="lineNoCov">          0 :       op_couple-&gt;dw_loc_next-&gt;dw_loc_next = epilogue;</span>
<span class="lineNum">   18019 </span><span class="lineNoCov">          0 :       epilogue = op_couple;</span>
<span class="lineNum">   18020 </span>            :     }
<span class="lineNum">   18021 </span><span class="lineNoCov">          0 :   add_loc_descr (&amp;loc_body, epilogue);</span>
<span class="lineNum">   18022 </span><span class="lineNoCov">          0 :   if (!resolve_args_picking (loc_body, dpi.args_count, &amp;dpi))</span>
<span class="lineNum">   18023 </span>            :     return NULL;
<span class="lineNum">   18024 </span>            : 
<span class="lineNum">   18025 </span>            :   /* Trailing nops from loc_descriptor_from_tree (if any) cannot be removed
<span class="lineNum">   18026 </span>            :      because they are considered useful.  Now there is an epilogue, they are
<span class="lineNum">   18027 </span>            :      not anymore, so give it another try.   */
<span class="lineNum">   18028 </span><span class="lineNoCov">          0 :   loc_descr_without_nops (loc_body);</span>
<span class="lineNum">   18029 </span>            : 
<span class="lineNum">   18030 </span>            :   /* fndecl may be used both as a regular DW_TAG_subprogram DIE and as
<span class="lineNum">   18031 </span>            :      a DW_TAG_dwarf_procedure, so we may have a conflict, here.  It's unlikely,
<span class="lineNum">   18032 </span>            :      though, given that size functions do not come from source, so they should
<span class="lineNum">   18033 </span>            :      not have a dedicated DW_TAG_subprogram DIE.  */
<span class="lineNum">   18034 </span><span class="lineNoCov">          0 :   dwarf_proc_die</span>
<span class="lineNum">   18035 </span><span class="lineNoCov">          0 :     = new_dwarf_proc_die (loc_body, fndecl,</span>
<span class="lineNum">   18036 </span><span class="lineNoCov">          0 :                           get_context_die (DECL_CONTEXT (fndecl)));</span>
<span class="lineNum">   18037 </span>            : 
<span class="lineNum">   18038 </span>            :   /* The called DWARF procedure consumes one stack slot per argument and
<span class="lineNum">   18039 </span>            :      returns one stack slot.  */
<span class="lineNum">   18040 </span><span class="lineNoCov">          0 :   dwarf_proc_stack_usage_map-&gt;put (dwarf_proc_die, 1 - dpi.args_count);</span>
<span class="lineNum">   18041 </span>            : 
<span class="lineNum">   18042 </span><span class="lineNoCov">          0 :   return dwarf_proc_die;</span>
<span class="lineNum">   18043 </span>            : }
<span class="lineNum">   18044 </span>            : 
<span class="lineNum">   18045 </span>            : 
<span class="lineNum">   18046 </span>            : /* Generate Dwarf location list representing LOC.
<span class="lineNum">   18047 </span>            :    If WANT_ADDRESS is false, expression computing LOC will be computed
<span class="lineNum">   18048 </span>            :    If WANT_ADDRESS is 1, expression computing address of LOC will be returned
<span class="lineNum">   18049 </span>            :    if WANT_ADDRESS is 2, expression computing address useable in location
<span class="lineNum">   18050 </span>            :      will be returned (i.e. DW_OP_reg can be used
<span class="lineNum">   18051 </span>            :      to refer to register values).
<span class="lineNum">   18052 </span>            : 
<span class="lineNum">   18053 </span>            :    CONTEXT provides information to customize the location descriptions
<span class="lineNum">   18054 </span>            :    generation.  Its context_type field specifies what type is implicitly
<span class="lineNum">   18055 </span>            :    referenced by DW_OP_push_object_address.  If it is NULL_TREE, this operation
<span class="lineNum">   18056 </span>            :    will not be generated.
<span class="lineNum">   18057 </span>            : 
<span class="lineNum">   18058 </span>            :    Its DPI field determines whether we are generating a DWARF expression for a
<span class="lineNum">   18059 </span>            :    DWARF procedure, so PARM_DECL references are processed specifically.
<span class="lineNum">   18060 </span>            : 
<span class="lineNum">   18061 </span>            :    If CONTEXT is NULL, the behavior is the same as if context_type, base_decl
<span class="lineNum">   18062 </span>            :    and dpi fields were null.  */
<a name="18063"><span class="lineNum">   18063 </span>            : </a>
<span class="lineNum">   18064 </span>            : static dw_loc_list_ref
<span class="lineNum">   18065 </span><span class="lineCov">    8218268 : loc_list_from_tree_1 (tree loc, int want_address,</span>
<span class="lineNum">   18066 </span>            :                       struct loc_descr_context *context)
<span class="lineNum">   18067 </span>            : {
<span class="lineNum">   18068 </span><span class="lineCov">    8218268 :   dw_loc_descr_ref ret = NULL, ret1 = NULL;</span>
<span class="lineNum">   18069 </span><span class="lineCov">    8218268 :   dw_loc_list_ref list_ret = NULL, list_ret1 = NULL;</span>
<span class="lineNum">   18070 </span><span class="lineCov">    8218268 :   int have_address = 0;</span>
<span class="lineNum">   18071 </span><span class="lineCov">    8218268 :   enum dwarf_location_atom op;</span>
<span class="lineNum">   18072 </span>            : 
<span class="lineNum">   18073 </span>            :   /* ??? Most of the time we do not take proper care for sign/zero
<span class="lineNum">   18074 </span>            :      extending the values properly.  Hopefully this won't be a real
<span class="lineNum">   18075 </span>            :      problem...  */
<span class="lineNum">   18076 </span>            : 
<span class="lineNum">   18077 </span><span class="lineCov">    8218268 :   if (context != NULL</span>
<span class="lineNum">   18078 </span><span class="lineCov">     277554 :       &amp;&amp; context-&gt;base_decl == loc</span>
<span class="lineNum">   18079 </span><span class="lineCov">      69988 :       &amp;&amp; want_address == 0)</span>
<span class="lineNum">   18080 </span>            :     {
<span class="lineNum">   18081 </span><span class="lineCov">      69988 :       if (dwarf_version &gt;= 3 || !dwarf_strict)</span>
<span class="lineNum">   18082 </span><span class="lineCov">      69988 :         return new_loc_list (new_loc_descr (DW_OP_push_object_address, 0, 0),</span>
<span class="lineNum">   18083 </span><span class="lineCov">      69988 :                              NULL, 0, NULL, 0, NULL);</span>
<span class="lineNum">   18084 </span>            :       else
<span class="lineNum">   18085 </span>            :         return NULL;
<span class="lineNum">   18086 </span>            :     }
<span class="lineNum">   18087 </span>            : 
<span class="lineNum">   18088 </span><span class="lineCov">    8148280 :   switch (TREE_CODE (loc))</span>
<span class="lineNum">   18089 </span>            :     {
<span class="lineNum">   18090 </span><span class="lineNoCov">          0 :     case ERROR_MARK:</span>
<span class="lineNum">   18091 </span><span class="lineNoCov">          0 :       expansion_failed (loc, NULL_RTX, &quot;ERROR_MARK&quot;);</span>
<span class="lineNum">   18092 </span><span class="lineNoCov">          0 :       return 0;</span>
<span class="lineNum">   18093 </span>            : 
<span class="lineNum">   18094 </span><span class="lineNoCov">          0 :     case PLACEHOLDER_EXPR:</span>
<span class="lineNum">   18095 </span>            :       /* This case involves extracting fields from an object to determine the
<span class="lineNum">   18096 </span>            :          position of other fields. It is supposed to appear only as the first
<span class="lineNum">   18097 </span>            :          operand of COMPONENT_REF nodes and to reference precisely the type
<span class="lineNum">   18098 </span>            :          that the context allows.  */
<span class="lineNum">   18099 </span><span class="lineNoCov">          0 :       if (context != NULL</span>
<span class="lineNum">   18100 </span><span class="lineNoCov">          0 :           &amp;&amp; TREE_TYPE (loc) == context-&gt;context_type</span>
<span class="lineNum">   18101 </span><span class="lineNoCov">          0 :           &amp;&amp; want_address &gt;= 1)</span>
<span class="lineNum">   18102 </span>            :         {
<span class="lineNum">   18103 </span><span class="lineNoCov">          0 :           if (dwarf_version &gt;= 3 || !dwarf_strict)</span>
<span class="lineNum">   18104 </span>            :             {
<span class="lineNum">   18105 </span><span class="lineNoCov">          0 :               ret = new_loc_descr (DW_OP_push_object_address, 0, 0);</span>
<span class="lineNum">   18106 </span><span class="lineNoCov">          0 :               have_address = 1;</span>
<span class="lineNum">   18107 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">   18108 </span>            :             }
<span class="lineNum">   18109 </span>            :           else
<span class="lineNum">   18110 </span>            :             return NULL;
<span class="lineNum">   18111 </span>            :         }
<span class="lineNum">   18112 </span>            :       /* For DW_TAG_generic_subrange attributes, PLACEHOLDER_EXPR stands for
<span class="lineNum">   18113 </span>            :          the single argument passed by consumer.  */
<span class="lineNum">   18114 </span><span class="lineNoCov">          0 :       else if (context != NULL</span>
<span class="lineNum">   18115 </span><span class="lineNoCov">          0 :                &amp;&amp; context-&gt;placeholder_arg</span>
<span class="lineNum">   18116 </span><span class="lineNoCov">          0 :                &amp;&amp; INTEGRAL_TYPE_P (TREE_TYPE (loc))</span>
<span class="lineNum">   18117 </span><span class="lineNoCov">          0 :                &amp;&amp; want_address == 0)</span>
<span class="lineNum">   18118 </span>            :         {
<span class="lineNum">   18119 </span><span class="lineNoCov">          0 :           ret = new_loc_descr (DW_OP_pick, 0, 0);</span>
<span class="lineNum">   18120 </span><span class="lineNoCov">          0 :           ret-&gt;frame_offset_rel = 1;</span>
<span class="lineNum">   18121 </span><span class="lineNoCov">          0 :           context-&gt;placeholder_seen = true;</span>
<span class="lineNum">   18122 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   18123 </span>            :         }
<span class="lineNum">   18124 </span>            :       else
<span class="lineNum">   18125 </span><span class="lineNoCov">          0 :         expansion_failed (loc, NULL_RTX,</span>
<span class="lineNum">   18126 </span>            :                           &quot;PLACEHOLDER_EXPR for an unexpected type&quot;);
<span class="lineNum">   18127 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">   18128 </span>            : 
<span class="lineNum">   18129 </span><span class="lineNoCov">          0 :     case CALL_EXPR:</span>
<span class="lineNum">   18130 </span><span class="lineNoCov">          0 :         {</span>
<span class="lineNum">   18131 </span><span class="lineNoCov">          0 :           const int nargs = call_expr_nargs (loc);</span>
<span class="lineNum">   18132 </span><span class="lineNoCov">          0 :           tree callee = get_callee_fndecl (loc);</span>
<span class="lineNum">   18133 </span><span class="lineNoCov">          0 :           int i;</span>
<span class="lineNum">   18134 </span><span class="lineNoCov">          0 :           dw_die_ref dwarf_proc;</span>
<span class="lineNum">   18135 </span>            : 
<span class="lineNum">   18136 </span><span class="lineNoCov">          0 :           if (callee == NULL_TREE)</span>
<span class="lineNum">   18137 </span>            :             goto call_expansion_failed;
<span class="lineNum">   18138 </span>            : 
<span class="lineNum">   18139 </span>            :           /* We handle only functions that return an integer.  */
<span class="lineNum">   18140 </span><span class="lineNoCov">          0 :           if (!is_handled_procedure_type (TREE_TYPE (TREE_TYPE (callee))))</span>
<span class="lineNum">   18141 </span>            :             goto call_expansion_failed;
<span class="lineNum">   18142 </span>            : 
<span class="lineNum">   18143 </span><span class="lineNoCov">          0 :           dwarf_proc = function_to_dwarf_procedure (callee);</span>
<span class="lineNum">   18144 </span><span class="lineNoCov">          0 :           if (dwarf_proc == NULL)</span>
<span class="lineNum">   18145 </span>            :             goto call_expansion_failed;
<span class="lineNum">   18146 </span>            : 
<span class="lineNum">   18147 </span>            :           /* Evaluate arguments right-to-left so that the first argument will
<span class="lineNum">   18148 </span>            :              be the top-most one on the stack.  */
<span class="lineNum">   18149 </span><span class="lineNoCov">          0 :           for (i = nargs - 1; i &gt;= 0; --i)</span>
<span class="lineNum">   18150 </span>            :             {
<span class="lineNum">   18151 </span><span class="lineNoCov">          0 :               dw_loc_descr_ref loc_descr</span>
<span class="lineNum">   18152 </span><span class="lineNoCov">          0 :                 = loc_descriptor_from_tree (CALL_EXPR_ARG (loc, i), 0,</span>
<span class="lineNum">   18153 </span>            :                                             context);
<span class="lineNum">   18154 </span>            : 
<span class="lineNum">   18155 </span><span class="lineNoCov">          0 :               if (loc_descr == NULL)</span>
<span class="lineNum">   18156 </span>            :                 goto call_expansion_failed;
<span class="lineNum">   18157 </span>            : 
<span class="lineNum">   18158 </span><span class="lineNoCov">          0 :               add_loc_descr (&amp;ret, loc_descr);</span>
<span class="lineNum">   18159 </span>            :             }
<span class="lineNum">   18160 </span>            : 
<span class="lineNum">   18161 </span><span class="lineNoCov">          0 :           ret1 = new_loc_descr (DW_OP_call4, 0, 0);</span>
<span class="lineNum">   18162 </span><span class="lineNoCov">          0 :           ret1-&gt;dw_loc_oprnd1.val_class = dw_val_class_die_ref;</span>
<span class="lineNum">   18163 </span><span class="lineNoCov">          0 :           ret1-&gt;dw_loc_oprnd1.v.val_die_ref.die = dwarf_proc;</span>
<span class="lineNum">   18164 </span><span class="lineNoCov">          0 :           ret1-&gt;dw_loc_oprnd1.v.val_die_ref.external = 0;</span>
<span class="lineNum">   18165 </span><span class="lineNoCov">          0 :           add_loc_descr (&amp;ret, ret1);</span>
<span class="lineNum">   18166 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   18167 </span>            : 
<span class="lineNum">   18168 </span><span class="lineNoCov">          0 :         call_expansion_failed:</span>
<span class="lineNum">   18169 </span><span class="lineNoCov">          0 :           expansion_failed (loc, NULL_RTX, &quot;CALL_EXPR&quot;);</span>
<span class="lineNum">   18170 </span>            :           /* There are no opcodes for these operations.  */
<span class="lineNum">   18171 </span><span class="lineNoCov">          0 :           return 0;</span>
<span class="lineNum">   18172 </span>            :         }
<span class="lineNum">   18173 </span>            : 
<span class="lineNum">   18174 </span><span class="lineNoCov">          0 :     case PREINCREMENT_EXPR:</span>
<span class="lineNum">   18175 </span><span class="lineNoCov">          0 :     case PREDECREMENT_EXPR:</span>
<span class="lineNum">   18176 </span><span class="lineNoCov">          0 :     case POSTINCREMENT_EXPR:</span>
<span class="lineNum">   18177 </span><span class="lineNoCov">          0 :     case POSTDECREMENT_EXPR:</span>
<span class="lineNum">   18178 </span><span class="lineNoCov">          0 :       expansion_failed (loc, NULL_RTX, &quot;PRE/POST INDCREMENT/DECREMENT&quot;);</span>
<span class="lineNum">   18179 </span>            :       /* There are no opcodes for these operations.  */
<span class="lineNum">   18180 </span><span class="lineNoCov">          0 :       return 0;</span>
<span class="lineNum">   18181 </span>            : 
<span class="lineNum">   18182 </span><span class="lineCov">         69 :     case ADDR_EXPR:</span>
<span class="lineNum">   18183 </span>            :       /* If we already want an address, see if there is INDIRECT_REF inside
<span class="lineNum">   18184 </span>            :          e.g. for &amp;this-&gt;field.  */
<span class="lineNum">   18185 </span><span class="lineCov">         69 :       if (want_address)</span>
<span class="lineNum">   18186 </span>            :         {
<span class="lineNum">   18187 </span><span class="lineCov">        136 :           list_ret = loc_list_for_address_of_addr_expr_of_indirect_ref</span>
<span class="lineNum">   18188 </span><span class="lineCov">         68 :                        (loc, want_address == 2, context);</span>
<span class="lineNum">   18189 </span><span class="lineCov">         68 :           if (list_ret)</span>
<span class="lineNum">   18190 </span>            :             have_address = 1;
<span class="lineNum">   18191 </span><span class="lineCov">         68 :           else if (decl_address_ip_invariant_p (TREE_OPERAND (loc, 0))</span>
<span class="lineNum">   18192 </span><span class="lineCov">         68 :                    &amp;&amp; (ret = cst_pool_loc_descr (loc)))</span>
<span class="lineNum">   18193 </span>            :             have_address = 1;
<span class="lineNum">   18194 </span>            :         }
<span class="lineNum">   18195 </span>            :         /* Otherwise, process the argument and look for the address.  */
<span class="lineNum">   18196 </span><span class="lineCov">         69 :       if (!list_ret &amp;&amp; !ret)</span>
<span class="lineNum">   18197 </span><span class="lineCov">         69 :         list_ret = loc_list_from_tree_1 (TREE_OPERAND (loc, 0), 1, context);</span>
<span class="lineNum">   18198 </span>            :       else
<span class="lineNum">   18199 </span>            :         {
<span class="lineNum">   18200 </span><span class="lineNoCov">          0 :           if (want_address)</span>
<span class="lineNum">   18201 </span><span class="lineNoCov">          0 :             expansion_failed (loc, NULL_RTX, &quot;need address of ADDR_EXPR&quot;);</span>
<span class="lineNum">   18202 </span><span class="lineNoCov">          0 :           return NULL;</span>
<span class="lineNum">   18203 </span>            :         }
<span class="lineNum">   18204 </span><span class="lineCov">         69 :       break;</span>
<span class="lineNum">   18205 </span>            : 
<span class="lineNum">   18206 </span><span class="lineCov">    7219110 :     case VAR_DECL:</span>
<span class="lineNum">   18207 </span><span class="lineCov">    7219110 :       if (DECL_THREAD_LOCAL_P (loc))</span>
<span class="lineNum">   18208 </span>            :         {
<span class="lineNum">   18209 </span><span class="lineCov">        438 :           rtx rtl;</span>
<span class="lineNum">   18210 </span><span class="lineCov">        438 :          enum dwarf_location_atom tls_op;</span>
<span class="lineNum">   18211 </span><span class="lineCov">        438 :          enum dtprel_bool dtprel = dtprel_false;</span>
<span class="lineNum">   18212 </span>            : 
<span class="lineNum">   18213 </span><span class="lineCov">        438 :           if (targetm.have_tls)</span>
<span class="lineNum">   18214 </span>            :             {
<span class="lineNum">   18215 </span>            :               /* If this is not defined, we have no way to emit the
<span class="lineNum">   18216 </span>            :                  data.  */
<span class="lineNum">   18217 </span><span class="lineCov">        438 :               if (!targetm.asm_out.output_dwarf_dtprel)</span>
<span class="lineNum">   18218 </span>            :                 return 0;
<span class="lineNum">   18219 </span>            : 
<span class="lineNum">   18220 </span>            :                /* The way DW_OP_GNU_push_tls_address is specified, we
<span class="lineNum">   18221 </span>            :                   can only look up addresses of objects in the current
<span class="lineNum">   18222 </span>            :                   module.  We used DW_OP_addr as first op, but that's
<span class="lineNum">   18223 </span>            :                   wrong, because DW_OP_addr is relocated by the debug
<span class="lineNum">   18224 </span>            :                   info consumer, while DW_OP_GNU_push_tls_address
<span class="lineNum">   18225 </span>            :                   operand shouldn't be.  */
<span class="lineNum">   18226 </span><span class="lineCov">        438 :               if (DECL_EXTERNAL (loc) &amp;&amp; !targetm.binds_local_p (loc))</span>
<span class="lineNum">   18227 </span>            :                 return 0;
<span class="lineNum">   18228 </span><span class="lineCov">        438 :               dtprel = dtprel_true;</span>
<span class="lineNum">   18229 </span>            :               /* We check for DWARF 5 here because gdb did not implement
<span class="lineNum">   18230 </span>            :                  DW_OP_form_tls_address until after 7.12.  */
<span class="lineNum">   18231 </span><span class="lineCov">        438 :               tls_op = (dwarf_version &gt;= 5 ? DW_OP_form_tls_address</span>
<span class="lineNum">   18232 </span>            :                         : DW_OP_GNU_push_tls_address);
<span class="lineNum">   18233 </span>            :             }
<span class="lineNum">   18234 </span>            :           else
<span class="lineNum">   18235 </span>            :             {
<span class="lineNum">   18236 </span><span class="lineNoCov">          0 :               if (!targetm.emutls.debug_form_tls_address</span>
<span class="lineNum">   18237 </span><span class="lineNoCov">          0 :                   || !(dwarf_version &gt;= 3 || !dwarf_strict))</span>
<span class="lineNum">   18238 </span>            :                 return 0;
<span class="lineNum">   18239 </span>            :               /* We stuffed the control variable into the DECL_VALUE_EXPR
<span class="lineNum">   18240 </span>            :                  to signal (via DECL_HAS_VALUE_EXPR_P) that the decl should
<span class="lineNum">   18241 </span>            :                  no longer appear in gimple code.  We used the control
<span class="lineNum">   18242 </span>            :                  variable in specific so that we could pick it up here.  */
<span class="lineNum">   18243 </span><span class="lineNoCov">          0 :               loc = DECL_VALUE_EXPR (loc);</span>
<span class="lineNum">   18244 </span><span class="lineNoCov">          0 :               tls_op = DW_OP_form_tls_address;</span>
<span class="lineNum">   18245 </span>            :             }
<span class="lineNum">   18246 </span>            : 
<span class="lineNum">   18247 </span><span class="lineCov">        438 :           rtl = rtl_for_decl_location (loc);</span>
<span class="lineNum">   18248 </span><span class="lineCov">        438 :           if (rtl == NULL_RTX)</span>
<span class="lineNum">   18249 </span>            :             return 0;
<span class="lineNum">   18250 </span>            : 
<span class="lineNum">   18251 </span><span class="lineCov">        438 :           if (!MEM_P (rtl))</span>
<span class="lineNum">   18252 </span>            :             return 0;
<span class="lineNum">   18253 </span><span class="lineCov">        438 :           rtl = XEXP (rtl, 0);</span>
<span class="lineNum">   18254 </span><span class="lineCov">        438 :           if (! CONSTANT_P (rtl))</span>
<span class="lineNum">   18255 </span>            :             return 0;
<span class="lineNum">   18256 </span>            : 
<span class="lineNum">   18257 </span><span class="lineCov">        438 :           ret = new_addr_loc_descr (rtl, dtprel);</span>
<span class="lineNum">   18258 </span><span class="lineCov">        438 :           ret1 = new_loc_descr (tls_op, 0, 0);</span>
<span class="lineNum">   18259 </span><span class="lineCov">        438 :           add_loc_descr (&amp;ret, ret1);</span>
<span class="lineNum">   18260 </span>            : 
<span class="lineNum">   18261 </span><span class="lineCov">        438 :           have_address = 1;</span>
<span class="lineNum">   18262 </span><span class="lineCov">        438 :           break;</span>
<span class="lineNum">   18263 </span><span class="lineCov">    7893375 :         }</span>
<span class="lineNum">   18264 </span>            :       /* FALLTHRU */
<span class="lineNum">   18265 </span>            : 
<span class="lineNum">   18266 </span><span class="lineCov">    7893375 :     case PARM_DECL:</span>
<span class="lineNum">   18267 </span><span class="lineCov">        108 :       if (context != NULL &amp;&amp; context-&gt;dpi != NULL</span>
<span class="lineNum">   18268 </span><span class="lineCov">    7893375 :           &amp;&amp; DECL_CONTEXT (loc) == context-&gt;dpi-&gt;fndecl)</span>
<span class="lineNum">   18269 </span>            :         {
<span class="lineNum">   18270 </span>            :           /* We are generating code for a DWARF procedure and we want to access
<span class="lineNum">   18271 </span>            :              one of its arguments: find the appropriate argument offset and let
<span class="lineNum">   18272 </span>            :              the resolve_args_picking pass compute the offset that complies
<span class="lineNum">   18273 </span>            :              with the stack frame size.  */
<span class="lineNum">   18274 </span><span class="lineNoCov">          0 :           unsigned i = 0;</span>
<span class="lineNum">   18275 </span><span class="lineNoCov">          0 :           tree cursor;</span>
<span class="lineNum">   18276 </span>            : 
<span class="lineNum">   18277 </span><span class="lineNoCov">          0 :           for (cursor = DECL_ARGUMENTS (context-&gt;dpi-&gt;fndecl);</span>
<span class="lineNum">   18278 </span><span class="lineNoCov">          0 :                cursor != NULL_TREE &amp;&amp; cursor != loc;</span>
<span class="lineNum">   18279 </span><span class="lineNoCov">          0 :                cursor = TREE_CHAIN (cursor), ++i)</span>
<span class="lineNum">   18280 </span>            :             ;
<span class="lineNum">   18281 </span>            :           /* If we are translating a DWARF procedure, all referenced parameters
<span class="lineNum">   18282 </span>            :              must belong to the current function.  */
<span class="lineNum">   18283 </span><span class="lineNoCov">          0 :           gcc_assert (cursor != NULL_TREE);</span>
<span class="lineNum">   18284 </span>            : 
<span class="lineNum">   18285 </span><span class="lineNoCov">          0 :           ret = new_loc_descr (DW_OP_pick, i, 0);</span>
<span class="lineNum">   18286 </span><span class="lineNoCov">          0 :           ret-&gt;frame_offset_rel = 1;</span>
<span class="lineNum">   18287 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   18288 </span><span class="lineCov">    7894649 :         }</span>
<span class="lineNum">   18289 </span>            :       /* FALLTHRU */
<span class="lineNum">   18290 </span>            : 
<span class="lineNum">   18291 </span><span class="lineCov">    7894649 :     case RESULT_DECL:</span>
<span class="lineNum">   18292 </span><span class="lineCov">    8570626 :       if (DECL_HAS_VALUE_EXPR_P (loc))</span>
<span class="lineNum">   18293 </span><span class="lineCov">      22676 :         return loc_list_from_tree_1 (DECL_VALUE_EXPR (loc),</span>
<span class="lineNum">   18294 </span><span class="lineCov">      22676 :                                      want_address, context);</span>
<span class="lineNum">   18295 </span>            :       /* FALLTHRU */
<span class="lineNum">   18296 </span>            : 
<span class="lineNum">   18297 </span><span class="lineCov">    7872040 :     case FUNCTION_DECL:</span>
<span class="lineNum">   18298 </span><span class="lineCov">    7872040 :       {</span>
<span class="lineNum">   18299 </span><span class="lineCov">    7872040 :         rtx rtl;</span>
<span class="lineNum">   18300 </span><span class="lineCov">    7872040 :         var_loc_list *loc_list = lookup_decl_loc (loc);</span>
<span class="lineNum">   18301 </span>            : 
<span class="lineNum">   18302 </span><span class="lineCov">    7872040 :         if (loc_list &amp;&amp; loc_list-&gt;first)</span>
<span class="lineNum">   18303 </span>            :           {
<span class="lineNum">   18304 </span><span class="lineCov">    6738908 :             list_ret = dw_loc_list (loc_list, loc, want_address);</span>
<span class="lineNum">   18305 </span><span class="lineCov">    6738908 :             have_address = want_address != 0;</span>
<span class="lineNum">   18306 </span><span class="lineCov">    6738908 :             break;</span>
<span class="lineNum">   18307 </span>            :           }
<span class="lineNum">   18308 </span><span class="lineCov">    1133132 :         rtl = rtl_for_decl_location (loc);</span>
<span class="lineNum">   18309 </span><span class="lineCov">    1133132 :         if (rtl == NULL_RTX)</span>
<span class="lineNum">   18310 </span>            :           {
<span class="lineNum">   18311 </span><span class="lineCov">     683187 :             if (TREE_CODE (loc) != FUNCTION_DECL</span>
<span class="lineNum">   18312 </span><span class="lineCov">     683187 :                 &amp;&amp; early_dwarf</span>
<span class="lineNum">   18313 </span><span class="lineCov">       5454 :                 &amp;&amp; current_function_decl</span>
<span class="lineNum">   18314 </span><span class="lineCov">       5452 :                 &amp;&amp; want_address != 1</span>
<span class="lineNum">   18315 </span><span class="lineCov">       5448 :                 &amp;&amp; ! DECL_IGNORED_P (loc)</span>
<span class="lineNum">   18316 </span><span class="lineCov">       5351 :                 &amp;&amp; (INTEGRAL_TYPE_P (TREE_TYPE (loc))</span>
<span class="lineNum">   18317 </span><span class="lineCov">         48 :                     || POINTER_TYPE_P (TREE_TYPE (loc)))</span>
<span class="lineNum">   18318 </span><span class="lineCov">       5351 :                 &amp;&amp; DECL_CONTEXT (loc) == current_function_decl</span>
<span class="lineNum">   18319 </span><span class="lineCov">     698976 :                 &amp;&amp; (GET_MODE_SIZE (SCALAR_INT_TYPE_MODE (TREE_TYPE (loc)))</span>
<span class="lineNum">   18320 </span><span class="lineCov">       5263 :                     &lt;= DWARF2_ADDR_SIZE))</span>
<span class="lineNum">   18321 </span>            :               {
<span class="lineNum">   18322 </span><span class="lineCov">       5263 :                 dw_die_ref ref = lookup_decl_die (loc);</span>
<span class="lineNum">   18323 </span><span class="lineCov">       5263 :                 ret = new_loc_descr (DW_OP_GNU_variable_value, 0, 0);</span>
<span class="lineNum">   18324 </span><span class="lineCov">       5263 :                 if (ref)</span>
<span class="lineNum">   18325 </span>            :                   {
<span class="lineNum">   18326 </span><span class="lineCov">       2760 :                     ret-&gt;dw_loc_oprnd1.val_class = dw_val_class_die_ref;</span>
<span class="lineNum">   18327 </span><span class="lineCov">       2760 :                     ret-&gt;dw_loc_oprnd1.v.val_die_ref.die = ref;</span>
<span class="lineNum">   18328 </span><span class="lineCov">       2760 :                     ret-&gt;dw_loc_oprnd1.v.val_die_ref.external = 0;</span>
<span class="lineNum">   18329 </span>            :                   }
<span class="lineNum">   18330 </span>            :                 else
<span class="lineNum">   18331 </span>            :                   {
<span class="lineNum">   18332 </span><span class="lineCov">       2503 :                     ret-&gt;dw_loc_oprnd1.val_class = dw_val_class_decl_ref;</span>
<span class="lineNum">   18333 </span><span class="lineCov">       2503 :                     ret-&gt;dw_loc_oprnd1.v.val_decl_ref = loc;</span>
<span class="lineNum">   18334 </span>            :                   }
<span class="lineNum">   18335 </span>            :                 break;
<span class="lineNum">   18336 </span>            :               }
<span class="lineNum">   18337 </span><span class="lineCov">     677924 :             expansion_failed (loc, NULL_RTX, &quot;DECL has no RTL&quot;);</span>
<span class="lineNum">   18338 </span><span class="lineCov">     677924 :             return 0;</span>
<span class="lineNum">   18339 </span>            :           }
<span class="lineNum">   18340 </span><span class="lineCov">     449945 :         else if (CONST_INT_P (rtl))</span>
<span class="lineNum">   18341 </span>            :           {
<span class="lineNum">   18342 </span><span class="lineNoCov">          0 :             HOST_WIDE_INT val = INTVAL (rtl);</span>
<span class="lineNum">   18343 </span><span class="lineNoCov">          0 :             if (TYPE_UNSIGNED (TREE_TYPE (loc)))</span>
<span class="lineNum">   18344 </span><span class="lineNoCov">          0 :               val &amp;= GET_MODE_MASK (DECL_MODE (loc));</span>
<span class="lineNum">   18345 </span><span class="lineNoCov">          0 :             ret = int_loc_descriptor (val);</span>
<span class="lineNum">   18346 </span>            :           }
<span class="lineNum">   18347 </span><span class="lineCov">     449945 :         else if (GET_CODE (rtl) == CONST_STRING)</span>
<span class="lineNum">   18348 </span>            :           {
<span class="lineNum">   18349 </span><span class="lineNoCov">          0 :             expansion_failed (loc, NULL_RTX, &quot;CONST_STRING&quot;);</span>
<span class="lineNum">   18350 </span><span class="lineNoCov">          0 :             return 0;</span>
<span class="lineNum">   18351 </span>            :           }
<span class="lineNum">   18352 </span><span class="lineCov">     449945 :         else if (CONSTANT_P (rtl) &amp;&amp; const_ok_for_output (rtl))</span>
<span class="lineNum">   18353 </span><span class="lineNoCov">          0 :           ret = new_addr_loc_descr (rtl, dtprel_false);</span>
<span class="lineNum">   18354 </span>            :         else
<span class="lineNum">   18355 </span>            :           {
<span class="lineNum">   18356 </span><span class="lineCov">     449945 :             machine_mode mode, mem_mode;</span>
<span class="lineNum">   18357 </span>            : 
<span class="lineNum">   18358 </span>            :             /* Certain constructs can only be represented at top-level.  */
<span class="lineNum">   18359 </span><span class="lineCov">     449945 :             if (want_address == 2)</span>
<span class="lineNum">   18360 </span>            :               {
<span class="lineNum">   18361 </span><span class="lineCov">     441040 :                 ret = loc_descriptor (rtl, VOIDmode,</span>
<span class="lineNum">   18362 </span>            :                                       VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   18363 </span><span class="lineCov">     441040 :                 have_address = 1;</span>
<span class="lineNum">   18364 </span>            :               }
<span class="lineNum">   18365 </span>            :             else
<span class="lineNum">   18366 </span>            :               {
<span class="lineNum">   18367 </span><span class="lineCov">       8905 :                 mode = GET_MODE (rtl);</span>
<span class="lineNum">   18368 </span><span class="lineCov">       8905 :                 mem_mode = VOIDmode;</span>
<span class="lineNum">   18369 </span><span class="lineCov">       8905 :                 if (MEM_P (rtl))</span>
<span class="lineNum">   18370 </span>            :                   {
<span class="lineNum">   18371 </span><span class="lineCov">        988 :                     mem_mode = mode;</span>
<span class="lineNum">   18372 </span><span class="lineCov">        988 :                     mode = get_address_mode (rtl);</span>
<span class="lineNum">   18373 </span><span class="lineCov">        988 :                     rtl = XEXP (rtl, 0);</span>
<span class="lineNum">   18374 </span><span class="lineCov">        988 :                     have_address = 1;</span>
<span class="lineNum">   18375 </span>            :                   }
<span class="lineNum">   18376 </span><span class="lineCov">       8905 :                 ret = mem_loc_descriptor (rtl, mode, mem_mode,</span>
<span class="lineNum">   18377 </span>            :                                           VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   18378 </span>            :               }
<span class="lineNum">   18379 </span><span class="lineCov">     449945 :             if (!ret)</span>
<span class="lineNum">   18380 </span><span class="lineCov">      21304 :               expansion_failed (loc, rtl,</span>
<span class="lineNum">   18381 </span>            :                                 &quot;failed to produce loc descriptor for rtl&quot;);
<span class="lineNum">   18382 </span>            :           }
<span class="lineNum">   18383 </span>            :       }
<span class="lineNum">   18384 </span>            :       break;
<span class="lineNum">   18385 </span>            : 
<span class="lineNum">   18386 </span><span class="lineCov">       3171 :     case MEM_REF:</span>
<span class="lineNum">   18387 </span><span class="lineCov">       3171 :       if (!integer_zerop (TREE_OPERAND (loc, 1)))</span>
<span class="lineNum">   18388 </span>            :         {
<span class="lineNum">   18389 </span>            :           have_address = 1;
<span class="lineNum">   18390 </span>            :           goto do_plus;
<span class="lineNum">   18391 </span>            :         }
<span class="lineNum">   18392 </span>            :       /* Fallthru.  */
<span class="lineNum">   18393 </span><span class="lineCov">     109660 :     case INDIRECT_REF:</span>
<span class="lineNum">   18394 </span><span class="lineCov">     109660 :       list_ret = loc_list_from_tree_1 (TREE_OPERAND (loc, 0), 0, context);</span>
<span class="lineNum">   18395 </span><span class="lineCov">     109660 :       have_address = 1;</span>
<span class="lineNum">   18396 </span><span class="lineCov">     109660 :       break;</span>
<span class="lineNum">   18397 </span>            : 
<span class="lineNum">   18398 </span>            :     case TARGET_MEM_REF:
<span class="lineNum">   18399 </span>            :     case SSA_NAME:
<span class="lineNum">   18400 </span>            :     case DEBUG_EXPR_DECL:
<span class="lineNum">   18401 </span>            :       return NULL;
<span class="lineNum">   18402 </span>            : 
<span class="lineNum">   18403 </span><span class="lineNoCov">          0 :     case COMPOUND_EXPR:</span>
<span class="lineNum">   18404 </span><span class="lineNoCov">          0 :       return loc_list_from_tree_1 (TREE_OPERAND (loc, 1), want_address,</span>
<span class="lineNum">   18405 </span><span class="lineNoCov">          0 :                                    context);</span>
<span class="lineNum">   18406 </span>            : 
<span class="lineNum">   18407 </span><span class="lineCov">       9075 :     CASE_CONVERT:</span>
<span class="lineNum">   18408 </span><span class="lineCov">       9075 :     case VIEW_CONVERT_EXPR:</span>
<span class="lineNum">   18409 </span><span class="lineCov">       9075 :     case SAVE_EXPR:</span>
<span class="lineNum">   18410 </span><span class="lineCov">       9075 :     case MODIFY_EXPR:</span>
<span class="lineNum">   18411 </span><span class="lineCov">       9075 :     case NON_LVALUE_EXPR:</span>
<span class="lineNum">   18412 </span><span class="lineCov">       9075 :       return loc_list_from_tree_1 (TREE_OPERAND (loc, 0), want_address,</span>
<span class="lineNum">   18413 </span><span class="lineCov">       9075 :                                    context);</span>
<span class="lineNum">   18414 </span>            : 
<span class="lineNum">   18415 </span><span class="lineCov">      19970 :     case COMPONENT_REF:</span>
<span class="lineNum">   18416 </span><span class="lineCov">      19970 :     case BIT_FIELD_REF:</span>
<span class="lineNum">   18417 </span><span class="lineCov">      19970 :     case ARRAY_REF:</span>
<span class="lineNum">   18418 </span><span class="lineCov">      19970 :     case ARRAY_RANGE_REF:</span>
<span class="lineNum">   18419 </span><span class="lineCov">      19970 :     case REALPART_EXPR:</span>
<span class="lineNum">   18420 </span><span class="lineCov">      19970 :     case IMAGPART_EXPR:</span>
<span class="lineNum">   18421 </span><span class="lineCov">      19970 :       {</span>
<span class="lineNum">   18422 </span><span class="lineCov">      19970 :         tree obj, offset;</span>
<span class="lineNum">   18423 </span><span class="lineCov">      59910 :         poly_int64 bitsize, bitpos, bytepos;</span>
<span class="lineNum">   18424 </span><span class="lineCov">      19970 :         machine_mode mode;</span>
<span class="lineNum">   18425 </span><span class="lineCov">      19970 :         int unsignedp, reversep, volatilep = 0;</span>
<span class="lineNum">   18426 </span>            : 
<span class="lineNum">   18427 </span><span class="lineCov">      19970 :         obj = get_inner_reference (loc, &amp;bitsize, &amp;bitpos, &amp;offset, &amp;mode,</span>
<span class="lineNum">   18428 </span>            :                                    &amp;unsignedp, &amp;reversep, &amp;volatilep);
<span class="lineNum">   18429 </span>            : 
<span class="lineNum">   18430 </span><span class="lineCov">      19970 :         gcc_assert (obj != loc);</span>
<span class="lineNum">   18431 </span>            : 
<span class="lineNum">   18432 </span><span class="lineCov">      30655 :         list_ret = loc_list_from_tree_1 (obj,</span>
<span class="lineNum">   18433 </span>            :                                          want_address == 2
<span class="lineNum">   18434 </span><span class="lineCov">      10685 :                                          &amp;&amp; known_eq (bitpos, 0)</span>
<span class="lineNum">   18435 </span><span class="lineCov">       5428 :                                          &amp;&amp; !offset ? 2 : 1,</span>
<span class="lineNum">   18436 </span>            :                                          context);
<span class="lineNum">   18437 </span>            :         /* TODO: We can extract value of the small expression via shifting even
<span class="lineNum">   18438 </span>            :            for nonzero bitpos.  */
<span class="lineNum">   18439 </span><span class="lineCov">      19970 :         if (list_ret == 0)</span>
<span class="lineNum">   18440 </span><span class="lineCov">       6416 :           return 0;</span>
<span class="lineNum">   18441 </span><span class="lineCov">      13616 :         if (!multiple_p (bitpos, BITS_PER_UNIT, &amp;bytepos)</span>
<span class="lineNum">   18442 </span><span class="lineCov">      13616 :             || !multiple_p (bitsize, BITS_PER_UNIT))</span>
<span class="lineNum">   18443 </span>            :           {
<span class="lineNum">   18444 </span><span class="lineCov">          1 :             expansion_failed (loc, NULL_RTX,</span>
<span class="lineNum">   18445 </span>            :                               &quot;bitfield access&quot;);
<span class="lineNum">   18446 </span><span class="lineCov">          1 :             return 0;</span>
<span class="lineNum">   18447 </span>            :           }
<span class="lineNum">   18448 </span>            : 
<span class="lineNum">   18449 </span><span class="lineCov">      13615 :         if (offset != NULL_TREE)</span>
<span class="lineNum">   18450 </span>            :           {
<span class="lineNum">   18451 </span>            :             /* Variable offset.  */
<span class="lineNum">   18452 </span><span class="lineCov">         61 :             list_ret1 = loc_list_from_tree_1 (offset, 0, context);</span>
<span class="lineNum">   18453 </span><span class="lineCov">         61 :             if (list_ret1 == 0)</span>
<span class="lineNum">   18454 </span>            :               return 0;
<span class="lineNum">   18455 </span><span class="lineNoCov">          0 :             add_loc_list (&amp;list_ret, list_ret1);</span>
<span class="lineNum">   18456 </span><span class="lineNoCov">          0 :             if (!list_ret)</span>
<span class="lineNum">   18457 </span>            :               return 0;
<span class="lineNum">   18458 </span><span class="lineNoCov">          0 :             add_loc_descr_to_each (list_ret, new_loc_descr (DW_OP_plus, 0, 0));</span>
<span class="lineNum">   18459 </span>            :           }
<span class="lineNum">   18460 </span>            : 
<span class="lineNum">   18461 </span><span class="lineCov">      13554 :         HOST_WIDE_INT value;</span>
<span class="lineNum">   18462 </span><span class="lineCov">      27108 :         if (bytepos.is_constant (&amp;value) &amp;&amp; value &gt; 0)</span>
<span class="lineNum">   18463 </span><span class="lineCov">      11087 :           add_loc_descr_to_each (list_ret, new_loc_descr (DW_OP_plus_uconst,</span>
<span class="lineNum">   18464 </span>            :                                                           value, 0));
<span class="lineNum">   18465 </span><span class="lineCov">       2467 :         else if (maybe_ne (bytepos, 0))</span>
<span class="lineNum">   18466 </span><span class="lineNoCov">          0 :           loc_list_plus_const (list_ret, bytepos);</span>
<span class="lineNum">   18467 </span>            : 
<span class="lineNum">   18468 </span><span class="lineCov">      13554 :         have_address = 1;</span>
<span class="lineNum">   18469 </span><span class="lineCov">      13554 :         break;</span>
<span class="lineNum">   18470 </span>            :       }
<span class="lineNum">   18471 </span>            : 
<span class="lineNum">   18472 </span><span class="lineCov">      25581 :     case INTEGER_CST:</span>
<span class="lineNum">   18473 </span><span class="lineCov">      25573 :       if ((want_address || !tree_fits_shwi_p (loc))</span>
<span class="lineNum">   18474 </span><span class="lineCov">      25581 :           &amp;&amp; (ret = cst_pool_loc_descr (loc)))</span>
<span class="lineNum">   18475 </span>            :         have_address = 1;
<span class="lineNum">   18476 </span><span class="lineCov">      25581 :       else if (want_address == 2</span>
<span class="lineNum">   18477 </span><span class="lineCov">          8 :                &amp;&amp; tree_fits_shwi_p (loc)</span>
<span class="lineNum">   18478 </span><span class="lineCov">      25589 :                &amp;&amp; (ret = address_of_int_loc_descriptor</span>
<span class="lineNum">   18479 </span><span class="lineCov">          8 :                            (int_size_in_bytes (TREE_TYPE (loc)),</span>
<span class="lineNum">   18480 </span>            :                             tree_to_shwi (loc))))
<span class="lineNum">   18481 </span>            :         have_address = 1;
<span class="lineNum">   18482 </span><span class="lineCov">      25573 :       else if (tree_fits_shwi_p (loc))</span>
<span class="lineNum">   18483 </span><span class="lineCov">      25573 :         ret = int_loc_descriptor (tree_to_shwi (loc));</span>
<span class="lineNum">   18484 </span><span class="lineNoCov">          0 :       else if (tree_fits_uhwi_p (loc))</span>
<span class="lineNum">   18485 </span><span class="lineNoCov">          0 :         ret = uint_loc_descriptor (tree_to_uhwi (loc));</span>
<span class="lineNum">   18486 </span>            :       else
<span class="lineNum">   18487 </span>            :         {
<span class="lineNum">   18488 </span><span class="lineNoCov">          0 :           expansion_failed (loc, NULL_RTX,</span>
<span class="lineNum">   18489 </span>            :                             &quot;Integer operand is not host integer&quot;);
<span class="lineNum">   18490 </span><span class="lineNoCov">          0 :           return 0;</span>
<span class="lineNum">   18491 </span>            :         }
<span class="lineNum">   18492 </span>            :       break;
<span class="lineNum">   18493 </span>            : 
<span class="lineNum">   18494 </span><span class="lineCov">         11 :     case CONSTRUCTOR:</span>
<span class="lineNum">   18495 </span><span class="lineCov">         11 :     case REAL_CST:</span>
<span class="lineNum">   18496 </span><span class="lineCov">         11 :     case STRING_CST:</span>
<span class="lineNum">   18497 </span><span class="lineCov">         11 :     case COMPLEX_CST:</span>
<span class="lineNum">   18498 </span><span class="lineCov">         11 :       if ((ret = cst_pool_loc_descr (loc)))</span>
<span class="lineNum">   18499 </span>            :         have_address = 1;
<span class="lineNum">   18500 </span><span class="lineCov">         11 :       else if (TREE_CODE (loc) == CONSTRUCTOR)</span>
<span class="lineNum">   18501 </span>            :         {
<span class="lineNum">   18502 </span><span class="lineCov">         11 :           tree type = TREE_TYPE (loc);</span>
<span class="lineNum">   18503 </span><span class="lineCov">         11 :           unsigned HOST_WIDE_INT size = int_size_in_bytes (type);</span>
<span class="lineNum">   18504 </span><span class="lineCov">         11 :           unsigned HOST_WIDE_INT offset = 0;</span>
<span class="lineNum">   18505 </span><span class="lineCov">         11 :           unsigned HOST_WIDE_INT cnt;</span>
<span class="lineNum">   18506 </span><span class="lineCov">         11 :           constructor_elt *ce;</span>
<span class="lineNum">   18507 </span>            : 
<span class="lineNum">   18508 </span><span class="lineCov">         11 :           if (TREE_CODE (type) == RECORD_TYPE)</span>
<span class="lineNum">   18509 </span>            :             {
<span class="lineNum">   18510 </span>            :               /* This is very limited, but it's enough to output
<span class="lineNum">   18511 </span>            :                  pointers to member functions, as long as the
<span class="lineNum">   18512 </span>            :                  referenced function is defined in the current
<span class="lineNum">   18513 </span>            :                  translation unit.  */
<span class="lineNum">   18514 </span><span class="lineCov">         27 :               FOR_EACH_VEC_SAFE_ELT (CONSTRUCTOR_ELTS (loc), cnt, ce)</span>
<span class="lineNum">   18515 </span>            :                 {
<span class="lineNum">   18516 </span><span class="lineCov">         19 :                   tree val = ce-&gt;value;</span>
<span class="lineNum">   18517 </span>            : 
<span class="lineNum">   18518 </span><span class="lineCov">         19 :                   tree field = ce-&gt;index;</span>
<span class="lineNum">   18519 </span>            : 
<span class="lineNum">   18520 </span><span class="lineCov">         19 :                   if (val)</span>
<span class="lineNum">   18521 </span><span class="lineCov">         19 :                     STRIP_NOPS (val);</span>
<span class="lineNum">   18522 </span>            : 
<span class="lineNum">   18523 </span><span class="lineCov">         19 :                   if (!field || DECL_BIT_FIELD (field))</span>
<span class="lineNum">   18524 </span>            :                     {
<span class="lineNum">   18525 </span><span class="lineNoCov">          0 :                       expansion_failed (loc, NULL_RTX,</span>
<span class="lineNum">   18526 </span>            :                                         &quot;bitfield in record type constructor&quot;);
<span class="lineNum">   18527 </span><span class="lineNoCov">          0 :                       size = offset = (unsigned HOST_WIDE_INT)-1;</span>
<span class="lineNum">   18528 </span><span class="lineNoCov">          0 :                       ret = NULL;</span>
<span class="lineNum">   18529 </span><span class="lineNoCov">          0 :                       break;</span>
<span class="lineNum">   18530 </span>            :                     }
<span class="lineNum">   18531 </span>            : 
<span class="lineNum">   18532 </span><span class="lineCov">         19 :                   HOST_WIDE_INT fieldsize = tree_to_shwi (DECL_SIZE_UNIT (field));</span>
<span class="lineNum">   18533 </span><span class="lineCov">         19 :                   unsigned HOST_WIDE_INT pos = int_byte_position (field);</span>
<span class="lineNum">   18534 </span><span class="lineCov">         19 :                   gcc_assert (pos + fieldsize &lt;= size);</span>
<span class="lineNum">   18535 </span><span class="lineCov">         19 :                   if (pos &lt; offset)</span>
<span class="lineNum">   18536 </span>            :                     {
<span class="lineNum">   18537 </span><span class="lineNoCov">          0 :                       expansion_failed (loc, NULL_RTX,</span>
<span class="lineNum">   18538 </span>            :                                         &quot;out-of-order fields in record constructor&quot;);
<span class="lineNum">   18539 </span><span class="lineNoCov">          0 :                       size = offset = (unsigned HOST_WIDE_INT)-1;</span>
<span class="lineNum">   18540 </span><span class="lineNoCov">          0 :                       ret = NULL;</span>
<span class="lineNum">   18541 </span><span class="lineNoCov">          0 :                       break;</span>
<span class="lineNum">   18542 </span>            :                     }
<span class="lineNum">   18543 </span><span class="lineCov">         19 :                   if (pos &gt; offset)</span>
<span class="lineNum">   18544 </span>            :                     {
<span class="lineNum">   18545 </span><span class="lineNoCov">          0 :                       ret1 = new_loc_descr (DW_OP_piece, pos - offset, 0);</span>
<span class="lineNum">   18546 </span><span class="lineNoCov">          0 :                       add_loc_descr (&amp;ret, ret1);</span>
<span class="lineNum">   18547 </span><span class="lineNoCov">          0 :                       offset = pos;</span>
<span class="lineNum">   18548 </span>            :                     }
<span class="lineNum">   18549 </span><span class="lineCov">         19 :                   if (val &amp;&amp; fieldsize != 0)</span>
<span class="lineNum">   18550 </span>            :                     {
<span class="lineNum">   18551 </span><span class="lineCov">         19 :                       ret1 = loc_descriptor_from_tree (val, want_address, context);</span>
<span class="lineNum">   18552 </span><span class="lineCov">         19 :                       if (!ret1)</span>
<span class="lineNum">   18553 </span>            :                         {
<span class="lineNum">   18554 </span><span class="lineCov">          3 :                           expansion_failed (loc, NULL_RTX,</span>
<span class="lineNum">   18555 </span>            :                                             &quot;unsupported expression in field&quot;);
<span class="lineNum">   18556 </span><span class="lineCov">          3 :                           size = offset = (unsigned HOST_WIDE_INT)-1;</span>
<span class="lineNum">   18557 </span><span class="lineCov">          3 :                           ret = NULL;</span>
<span class="lineNum">   18558 </span><span class="lineCov">          3 :                           break;</span>
<span class="lineNum">   18559 </span>            :                         }
<span class="lineNum">   18560 </span>            :                       add_loc_descr (&amp;ret, ret1);
<span class="lineNum">   18561 </span>            :                     }
<span class="lineNum">   18562 </span><span class="lineCov">         16 :                   if (fieldsize)</span>
<span class="lineNum">   18563 </span>            :                     {
<span class="lineNum">   18564 </span><span class="lineCov">         16 :                       ret1 = new_loc_descr (DW_OP_piece, fieldsize, 0);</span>
<span class="lineNum">   18565 </span><span class="lineCov">         16 :                       add_loc_descr (&amp;ret, ret1);</span>
<span class="lineNum">   18566 </span><span class="lineCov">         16 :                       offset = pos + fieldsize;</span>
<span class="lineNum">   18567 </span>            :                     }
<span class="lineNum">   18568 </span>            :                 }
<span class="lineNum">   18569 </span>            : 
<span class="lineNum">   18570 </span><span class="lineCov">         11 :               if (offset != size)</span>
<span class="lineNum">   18571 </span>            :                 {
<span class="lineNum">   18572 </span><span class="lineNoCov">          0 :                   ret1 = new_loc_descr (DW_OP_piece, size - offset, 0);</span>
<span class="lineNum">   18573 </span><span class="lineNoCov">          0 :                   add_loc_descr (&amp;ret, ret1);</span>
<span class="lineNum">   18574 </span><span class="lineNoCov">          0 :                   offset = size;</span>
<span class="lineNum">   18575 </span>            :                 }
<span class="lineNum">   18576 </span>            : 
<span class="lineNum">   18577 </span><span class="lineCov">         11 :               have_address = !!want_address;</span>
<span class="lineNum">   18578 </span>            :             }
<span class="lineNum">   18579 </span>            :           else
<span class="lineNum">   18580 </span><span class="lineNoCov">          0 :             expansion_failed (loc, NULL_RTX,</span>
<span class="lineNum">   18581 </span>            :                               &quot;constructor of non-record type&quot;);
<span class="lineNum">   18582 </span>            :         }
<span class="lineNum">   18583 </span>            :       else
<span class="lineNum">   18584 </span>            :       /* We can construct small constants here using int_loc_descriptor.  */
<span class="lineNum">   18585 </span><span class="lineNoCov">          0 :         expansion_failed (loc, NULL_RTX,</span>
<span class="lineNum">   18586 </span>            :                           &quot;constructor or constant not in constant pool&quot;);
<span class="lineNum">   18587 </span>            :       break;
<span class="lineNum">   18588 </span>            : 
<span class="lineNum">   18589 </span>            :     case TRUTH_AND_EXPR:
<span class="lineNum">   18590 </span>            :     case TRUTH_ANDIF_EXPR:
<span class="lineNum">   18591 </span>            :     case BIT_AND_EXPR:
<span class="lineNum">   18592 </span>            :       op = DW_OP_and;
<span class="lineNum">   18593 </span>            :       goto do_binop;
<span class="lineNum">   18594 </span>            : 
<span class="lineNum">   18595 </span><span class="lineNoCov">          0 :     case TRUTH_XOR_EXPR:</span>
<span class="lineNum">   18596 </span><span class="lineNoCov">          0 :     case BIT_XOR_EXPR:</span>
<span class="lineNum">   18597 </span><span class="lineNoCov">          0 :       op = DW_OP_xor;</span>
<span class="lineNum">   18598 </span><span class="lineNoCov">          0 :       goto do_binop;</span>
<span class="lineNum">   18599 </span>            : 
<span class="lineNum">   18600 </span><span class="lineNoCov">          0 :     case TRUTH_OR_EXPR:</span>
<span class="lineNum">   18601 </span><span class="lineNoCov">          0 :     case TRUTH_ORIF_EXPR:</span>
<span class="lineNum">   18602 </span><span class="lineNoCov">          0 :     case BIT_IOR_EXPR:</span>
<span class="lineNum">   18603 </span><span class="lineNoCov">          0 :       op = DW_OP_or;</span>
<span class="lineNum">   18604 </span><span class="lineNoCov">          0 :       goto do_binop;</span>
<span class="lineNum">   18605 </span>            : 
<span class="lineNum">   18606 </span><span class="lineNoCov">          0 :     case FLOOR_DIV_EXPR:</span>
<span class="lineNum">   18607 </span><span class="lineNoCov">          0 :     case CEIL_DIV_EXPR:</span>
<span class="lineNum">   18608 </span><span class="lineNoCov">          0 :     case ROUND_DIV_EXPR:</span>
<span class="lineNum">   18609 </span><span class="lineNoCov">          0 :     case TRUNC_DIV_EXPR:</span>
<span class="lineNum">   18610 </span><span class="lineNoCov">          0 :     case EXACT_DIV_EXPR:</span>
<span class="lineNum">   18611 </span><span class="lineNoCov">          0 :       if (TYPE_UNSIGNED (TREE_TYPE (loc)))</span>
<span class="lineNum">   18612 </span>            :         return 0;
<span class="lineNum">   18613 </span>            :       op = DW_OP_div;
<span class="lineNum">   18614 </span>            :       goto do_binop;
<span class="lineNum">   18615 </span>            : 
<span class="lineNum">   18616 </span><span class="lineCov">       2168 :     case MINUS_EXPR:</span>
<span class="lineNum">   18617 </span><span class="lineCov">       2168 :       op = DW_OP_minus;</span>
<span class="lineNum">   18618 </span><span class="lineCov">       2168 :       goto do_binop;</span>
<span class="lineNum">   18619 </span>            : 
<span class="lineNum">   18620 </span><span class="lineNoCov">          0 :     case FLOOR_MOD_EXPR:</span>
<span class="lineNum">   18621 </span><span class="lineNoCov">          0 :     case CEIL_MOD_EXPR:</span>
<span class="lineNum">   18622 </span><span class="lineNoCov">          0 :     case ROUND_MOD_EXPR:</span>
<span class="lineNum">   18623 </span><span class="lineNoCov">          0 :     case TRUNC_MOD_EXPR:</span>
<span class="lineNum">   18624 </span><span class="lineNoCov">          0 :       if (TYPE_UNSIGNED (TREE_TYPE (loc)))</span>
<span class="lineNum">   18625 </span>            :         {
<span class="lineNum">   18626 </span>            :           op = DW_OP_mod;
<span class="lineNum">   18627 </span>            :           goto do_binop;
<span class="lineNum">   18628 </span>            :         }
<span class="lineNum">   18629 </span><span class="lineNoCov">          0 :       list_ret = loc_list_from_tree_1 (TREE_OPERAND (loc, 0), 0, context);</span>
<span class="lineNum">   18630 </span><span class="lineNoCov">          0 :       list_ret1 = loc_list_from_tree_1 (TREE_OPERAND (loc, 1), 0, context);</span>
<span class="lineNum">   18631 </span><span class="lineNoCov">          0 :       if (list_ret == 0 || list_ret1 == 0)</span>
<span class="lineNum">   18632 </span>            :         return 0;
<span class="lineNum">   18633 </span>            : 
<span class="lineNum">   18634 </span><span class="lineNoCov">          0 :       add_loc_list (&amp;list_ret, list_ret1);</span>
<span class="lineNum">   18635 </span><span class="lineNoCov">          0 :       if (list_ret == 0)</span>
<span class="lineNum">   18636 </span>            :         return 0;
<span class="lineNum">   18637 </span><span class="lineNoCov">          0 :       add_loc_descr_to_each (list_ret, new_loc_descr (DW_OP_over, 0, 0));</span>
<span class="lineNum">   18638 </span><span class="lineNoCov">          0 :       add_loc_descr_to_each (list_ret, new_loc_descr (DW_OP_over, 0, 0));</span>
<span class="lineNum">   18639 </span><span class="lineNoCov">          0 :       add_loc_descr_to_each (list_ret, new_loc_descr (DW_OP_div, 0, 0));</span>
<span class="lineNum">   18640 </span><span class="lineNoCov">          0 :       add_loc_descr_to_each (list_ret, new_loc_descr (DW_OP_mul, 0, 0));</span>
<span class="lineNum">   18641 </span><span class="lineNoCov">          0 :       add_loc_descr_to_each (list_ret, new_loc_descr (DW_OP_minus, 0, 0));</span>
<span class="lineNum">   18642 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">   18643 </span>            : 
<span class="lineNum">   18644 </span><span class="lineCov">      20395 :     case MULT_EXPR:</span>
<span class="lineNum">   18645 </span><span class="lineCov">      20395 :       op = DW_OP_mul;</span>
<span class="lineNum">   18646 </span><span class="lineCov">      20395 :       goto do_binop;</span>
<span class="lineNum">   18647 </span>            : 
<span class="lineNum">   18648 </span><span class="lineNoCov">          0 :     case LSHIFT_EXPR:</span>
<span class="lineNum">   18649 </span><span class="lineNoCov">          0 :       op = DW_OP_shl;</span>
<span class="lineNum">   18650 </span><span class="lineNoCov">          0 :       goto do_binop;</span>
<span class="lineNum">   18651 </span>            : 
<span class="lineNum">   18652 </span><span class="lineNoCov">          0 :     case RSHIFT_EXPR:</span>
<span class="lineNum">   18653 </span><span class="lineNoCov">          0 :       op = (TYPE_UNSIGNED (TREE_TYPE (loc)) ? DW_OP_shr : DW_OP_shra);</span>
<span class="lineNum">   18654 </span><span class="lineNoCov">          0 :       goto do_binop;</span>
<span class="lineNum">   18655 </span>            : 
<span class="lineNum">   18656 </span><span class="lineCov">      63186 :     case POINTER_PLUS_EXPR:</span>
<span class="lineNum">   18657 </span><span class="lineCov">      63186 :     case PLUS_EXPR:</span>
<span class="lineNum">   18658 </span><span class="lineCov">     126372 :     do_plus:</span>
<span class="lineNum">   18659 </span><span class="lineCov">      63186 :       if (tree_fits_shwi_p (TREE_OPERAND (loc, 1)))</span>
<span class="lineNum">   18660 </span>            :         {
<span class="lineNum">   18661 </span>            :           /* Big unsigned numbers can fit in HOST_WIDE_INT but it may be
<span class="lineNum">   18662 </span>            :              smarter to encode their opposite.  The DW_OP_plus_uconst operation
<span class="lineNum">   18663 </span>            :              takes 1 + X bytes, X being the size of the ULEB128 addend.  On the
<span class="lineNum">   18664 </span>            :              other hand, a &quot;&lt;push literal&gt;; DW_OP_minus&quot; pattern takes 1 + Y
<span class="lineNum">   18665 </span>            :              bytes, Y being the size of the operation that pushes the opposite
<span class="lineNum">   18666 </span>            :              of the addend.  So let's choose the smallest representation.  */
<span class="lineNum">   18667 </span><span class="lineCov">      61018 :           const tree tree_addend = TREE_OPERAND (loc, 1);</span>
<span class="lineNum">   18668 </span><span class="lineCov">      61018 :           offset_int wi_addend;</span>
<span class="lineNum">   18669 </span><span class="lineCov">      61018 :           HOST_WIDE_INT shwi_addend;</span>
<span class="lineNum">   18670 </span><span class="lineCov">      61018 :           dw_loc_descr_ref loc_naddend;</span>
<span class="lineNum">   18671 </span>            : 
<span class="lineNum">   18672 </span><span class="lineCov">      61018 :           list_ret = loc_list_from_tree_1 (TREE_OPERAND (loc, 0), 0, context);</span>
<span class="lineNum">   18673 </span><span class="lineCov">      61018 :           if (list_ret == 0)</span>
<span class="lineNum">   18674 </span><span class="lineCov">         16 :             return 0;</span>
<span class="lineNum">   18675 </span>            : 
<span class="lineNum">   18676 </span>            :           /* Try to get the literal to push.  It is the opposite of the addend,
<span class="lineNum">   18677 </span>            :              so as we rely on wrapping during DWARF evaluation, first decode
<span class="lineNum">   18678 </span>            :              the literal as a &quot;DWARF-sized&quot; signed number.  */
<span class="lineNum">   18679 </span><span class="lineCov">      61002 :           wi_addend = wi::to_offset (tree_addend);</span>
<span class="lineNum">   18680 </span><span class="lineCov">      66774 :           wi_addend = wi::sext (wi_addend, DWARF2_ADDR_SIZE * 8);</span>
<span class="lineNum">   18681 </span><span class="lineCov">      61002 :           shwi_addend = wi_addend.to_shwi ();</span>
<span class="lineNum">   18682 </span><span class="lineCov">     122004 :           loc_naddend = (shwi_addend != INTTYPE_MINIMUM (HOST_WIDE_INT))</span>
<span class="lineNum">   18683 </span><span class="lineCov">      61002 :                         ? int_loc_descriptor (-shwi_addend)</span>
<span class="lineNum">   18684 </span>            :                         : NULL;
<span class="lineNum">   18685 </span>            : 
<span class="lineNum">   18686 </span><span class="lineNoCov">          0 :           if (loc_naddend != NULL</span>
<span class="lineNum">   18687 </span><span class="lineCov">     122004 :               &amp;&amp; ((unsigned) size_of_uleb128 (shwi_addend)</span>
<span class="lineNum">   18688 </span><span class="lineCov">      61002 :                   &gt; size_of_loc_descr (loc_naddend)))</span>
<span class="lineNum">   18689 </span>            :             {
<span class="lineNum">   18690 </span><span class="lineNoCov">          0 :               add_loc_descr_to_each (list_ret, loc_naddend);</span>
<span class="lineNum">   18691 </span><span class="lineNoCov">          0 :               add_loc_descr_to_each (list_ret,</span>
<span class="lineNum">   18692 </span>            :                                      new_loc_descr (DW_OP_minus, 0, 0));
<span class="lineNum">   18693 </span>            :             }
<span class="lineNum">   18694 </span>            :           else
<span class="lineNum">   18695 </span>            :             {
<span class="lineNum">   18696 </span><span class="lineCov">     122004 :               for (dw_loc_descr_ref loc_cur = loc_naddend; loc_cur != NULL; )</span>
<span class="lineNum">   18697 </span>            :                 {
<span class="lineNum">   18698 </span><span class="lineCov">      61002 :                   loc_naddend = loc_cur;</span>
<span class="lineNum">   18699 </span><span class="lineCov">      61002 :                   loc_cur = loc_cur-&gt;dw_loc_next;</span>
<span class="lineNum">   18700 </span><span class="lineCov">      61002 :                   ggc_free (loc_naddend);</span>
<span class="lineNum">   18701 </span>            :                 }
<span class="lineNum">   18702 </span><span class="lineCov">     244008 :               loc_list_plus_const (list_ret, wi_addend.to_shwi ());</span>
<span class="lineNum">   18703 </span>            :             }
<span class="lineNum">   18704 </span><span class="lineCov">      61002 :           break;</span>
<span class="lineNum">   18705 </span><span class="lineCov">       2168 :         }</span>
<span class="lineNum">   18706 </span>            : 
<span class="lineNum">   18707 </span>            :       op = DW_OP_plus;
<span class="lineNum">   18708 </span>            :       goto do_binop;
<span class="lineNum">   18709 </span>            : 
<span class="lineNum">   18710 </span>            :     case LE_EXPR:
<span class="lineNum">   18711 </span>            :       op = DW_OP_le;
<span class="lineNum">   18712 </span>            :       goto do_comp_binop;
<span class="lineNum">   18713 </span>            : 
<span class="lineNum">   18714 </span><span class="lineNoCov">          0 :     case GE_EXPR:</span>
<span class="lineNum">   18715 </span><span class="lineNoCov">          0 :       op = DW_OP_ge;</span>
<span class="lineNum">   18716 </span><span class="lineNoCov">          0 :       goto do_comp_binop;</span>
<span class="lineNum">   18717 </span>            : 
<span class="lineNum">   18718 </span><span class="lineNoCov">          0 :     case LT_EXPR:</span>
<span class="lineNum">   18719 </span><span class="lineNoCov">          0 :       op = DW_OP_lt;</span>
<span class="lineNum">   18720 </span><span class="lineNoCov">          0 :       goto do_comp_binop;</span>
<span class="lineNum">   18721 </span>            : 
<span class="lineNum">   18722 </span><span class="lineNoCov">          0 :     case GT_EXPR:</span>
<span class="lineNum">   18723 </span><span class="lineNoCov">          0 :       op = DW_OP_gt;</span>
<span class="lineNum">   18724 </span><span class="lineNoCov">          0 :       goto do_comp_binop;</span>
<span class="lineNum">   18725 </span>            : 
<span class="lineNum">   18726 </span><span class="lineNoCov">          0 :     do_comp_binop:</span>
<span class="lineNum">   18727 </span><span class="lineNoCov">          0 :       if (TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (loc, 0))))</span>
<span class="lineNum">   18728 </span>            :         {
<span class="lineNum">   18729 </span><span class="lineNoCov">          0 :           list_ret = loc_list_from_tree (TREE_OPERAND (loc, 0), 0, context);</span>
<span class="lineNum">   18730 </span><span class="lineNoCov">          0 :           list_ret1 = loc_list_from_tree (TREE_OPERAND (loc, 1), 0, context);</span>
<span class="lineNum">   18731 </span><span class="lineNoCov">          0 :           list_ret = loc_list_from_uint_comparison (list_ret, list_ret1,</span>
<span class="lineNum">   18732 </span><span class="lineNoCov">          0 :                                                     TREE_CODE (loc));</span>
<span class="lineNum">   18733 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   18734 </span>            :         }
<span class="lineNum">   18735 </span>            :       else
<span class="lineNum">   18736 </span>            :         goto do_binop;
<span class="lineNum">   18737 </span>            : 
<span class="lineNum">   18738 </span><span class="lineNoCov">          0 :     case EQ_EXPR:</span>
<span class="lineNum">   18739 </span><span class="lineNoCov">          0 :       op = DW_OP_eq;</span>
<span class="lineNum">   18740 </span><span class="lineNoCov">          0 :       goto do_binop;</span>
<span class="lineNum">   18741 </span>            : 
<span class="lineNum">   18742 </span><span class="lineCov">       3010 :     case NE_EXPR:</span>
<span class="lineNum">   18743 </span><span class="lineCov">       3010 :       op = DW_OP_ne;</span>
<span class="lineNum">   18744 </span><span class="lineCov">       3010 :       goto do_binop;</span>
<span class="lineNum">   18745 </span>            : 
<span class="lineNum">   18746 </span><span class="lineCov">      27741 :     do_binop:</span>
<span class="lineNum">   18747 </span><span class="lineCov">      27741 :       list_ret = loc_list_from_tree_1 (TREE_OPERAND (loc, 0), 0, context);</span>
<span class="lineNum">   18748 </span><span class="lineCov">      27741 :       list_ret1 = loc_list_from_tree_1 (TREE_OPERAND (loc, 1), 0, context);</span>
<span class="lineNum">   18749 </span><span class="lineCov">      27741 :       if (list_ret == 0 || list_ret1 == 0)</span>
<span class="lineNum">   18750 </span>            :         return 0;
<span class="lineNum">   18751 </span>            : 
<span class="lineNum">   18752 </span><span class="lineCov">      27680 :       add_loc_list (&amp;list_ret, list_ret1);</span>
<span class="lineNum">   18753 </span><span class="lineCov">      27680 :       if (list_ret == 0)</span>
<span class="lineNum">   18754 </span>            :         return 0;
<span class="lineNum">   18755 </span><span class="lineCov">      27680 :       add_loc_descr_to_each (list_ret, new_loc_descr (op, 0, 0));</span>
<span class="lineNum">   18756 </span><span class="lineCov">      27680 :       break;</span>
<span class="lineNum">   18757 </span>            : 
<span class="lineNum">   18758 </span>            :     case TRUTH_NOT_EXPR:
<span class="lineNum">   18759 </span>            :     case BIT_NOT_EXPR:
<span class="lineNum">   18760 </span>            :       op = DW_OP_not;
<span class="lineNum">   18761 </span>            :       goto do_unop;
<span class="lineNum">   18762 </span>            : 
<span class="lineNum">   18763 </span><span class="lineNoCov">          0 :     case ABS_EXPR:</span>
<span class="lineNum">   18764 </span><span class="lineNoCov">          0 :       op = DW_OP_abs;</span>
<span class="lineNum">   18765 </span><span class="lineNoCov">          0 :       goto do_unop;</span>
<span class="lineNum">   18766 </span>            : 
<span class="lineNum">   18767 </span><span class="lineNoCov">          0 :     case NEGATE_EXPR:</span>
<span class="lineNum">   18768 </span><span class="lineNoCov">          0 :       op = DW_OP_neg;</span>
<span class="lineNum">   18769 </span><span class="lineNoCov">          0 :       goto do_unop;</span>
<span class="lineNum">   18770 </span>            : 
<span class="lineNum">   18771 </span><span class="lineNoCov">          0 :     do_unop:</span>
<span class="lineNum">   18772 </span><span class="lineNoCov">          0 :       list_ret = loc_list_from_tree_1 (TREE_OPERAND (loc, 0), 0, context);</span>
<span class="lineNum">   18773 </span><span class="lineNoCov">          0 :       if (list_ret == 0)</span>
<span class="lineNum">   18774 </span>            :         return 0;
<span class="lineNum">   18775 </span>            : 
<span class="lineNum">   18776 </span><span class="lineNoCov">          0 :       add_loc_descr_to_each (list_ret, new_loc_descr (op, 0, 0));</span>
<span class="lineNum">   18777 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">   18778 </span>            : 
<span class="lineNum">   18779 </span><span class="lineNoCov">          0 :     case MIN_EXPR:</span>
<span class="lineNum">   18780 </span><span class="lineNoCov">          0 :     case MAX_EXPR:</span>
<span class="lineNum">   18781 </span><span class="lineNoCov">          0 :       {</span>
<span class="lineNum">   18782 </span><span class="lineNoCov">          0 :         const enum tree_code code =</span>
<span class="lineNum">   18783 </span><span class="lineNoCov">          0 :           TREE_CODE (loc) == MIN_EXPR ? GT_EXPR : LT_EXPR;</span>
<span class="lineNum">   18784 </span>            : 
<span class="lineNum">   18785 </span><span class="lineNoCov">          0 :         loc = build3 (COND_EXPR, TREE_TYPE (loc),</span>
<span class="lineNum">   18786 </span>            :                       build2 (code, integer_type_node,
<span class="lineNum">   18787 </span><span class="lineNoCov">          0 :                               TREE_OPERAND (loc, 0), TREE_OPERAND (loc, 1)),</span>
<span class="lineNum">   18788 </span><span class="lineNoCov">          0 :                       TREE_OPERAND (loc, 1), TREE_OPERAND (loc, 0));</span>
<span class="lineNum">   18789 </span>            :       }
<span class="lineNum">   18790 </span>            : 
<span class="lineNum">   18791 </span>            :       /* fall through */
<span class="lineNum">   18792 </span>            : 
<span class="lineNum">   18793 </span><span class="lineNoCov">          0 :     case COND_EXPR:</span>
<span class="lineNum">   18794 </span><span class="lineNoCov">          0 :       {</span>
<span class="lineNum">   18795 </span><span class="lineNoCov">          0 :         dw_loc_descr_ref lhs</span>
<span class="lineNum">   18796 </span><span class="lineNoCov">          0 :           = loc_descriptor_from_tree (TREE_OPERAND (loc, 1), 0, context);</span>
<span class="lineNum">   18797 </span><span class="lineNoCov">          0 :         dw_loc_list_ref rhs</span>
<span class="lineNum">   18798 </span><span class="lineNoCov">          0 :           = loc_list_from_tree_1 (TREE_OPERAND (loc, 2), 0, context);</span>
<span class="lineNum">   18799 </span><span class="lineNoCov">          0 :         dw_loc_descr_ref bra_node, jump_node, tmp;</span>
<span class="lineNum">   18800 </span>            : 
<span class="lineNum">   18801 </span><span class="lineNoCov">          0 :         list_ret = loc_list_from_tree_1 (TREE_OPERAND (loc, 0), 0, context);</span>
<span class="lineNum">   18802 </span><span class="lineNoCov">          0 :         if (list_ret == 0 || lhs == 0 || rhs == 0)</span>
<span class="lineNum">   18803 </span>            :           return 0;
<span class="lineNum">   18804 </span>            : 
<span class="lineNum">   18805 </span><span class="lineNoCov">          0 :         bra_node = new_loc_descr (DW_OP_bra, 0, 0);</span>
<span class="lineNum">   18806 </span><span class="lineNoCov">          0 :         add_loc_descr_to_each (list_ret, bra_node);</span>
<span class="lineNum">   18807 </span>            : 
<span class="lineNum">   18808 </span><span class="lineNoCov">          0 :         add_loc_list (&amp;list_ret, rhs);</span>
<span class="lineNum">   18809 </span><span class="lineNoCov">          0 :         jump_node = new_loc_descr (DW_OP_skip, 0, 0);</span>
<span class="lineNum">   18810 </span><span class="lineNoCov">          0 :         add_loc_descr_to_each (list_ret, jump_node);</span>
<span class="lineNum">   18811 </span>            : 
<span class="lineNum">   18812 </span><span class="lineNoCov">          0 :         add_loc_descr_to_each (list_ret, lhs);</span>
<span class="lineNum">   18813 </span><span class="lineNoCov">          0 :         bra_node-&gt;dw_loc_oprnd1.val_class = dw_val_class_loc;</span>
<span class="lineNum">   18814 </span><span class="lineNoCov">          0 :         bra_node-&gt;dw_loc_oprnd1.v.val_loc = lhs;</span>
<span class="lineNum">   18815 </span>            : 
<span class="lineNum">   18816 </span>            :         /* ??? Need a node to point the skip at.  Use a nop.  */
<span class="lineNum">   18817 </span><span class="lineNoCov">          0 :         tmp = new_loc_descr (DW_OP_nop, 0, 0);</span>
<span class="lineNum">   18818 </span><span class="lineNoCov">          0 :         add_loc_descr_to_each (list_ret, tmp);</span>
<span class="lineNum">   18819 </span><span class="lineNoCov">          0 :         jump_node-&gt;dw_loc_oprnd1.val_class = dw_val_class_loc;</span>
<span class="lineNum">   18820 </span><span class="lineNoCov">          0 :         jump_node-&gt;dw_loc_oprnd1.v.val_loc = tmp;</span>
<span class="lineNum">   18821 </span>            :       }
<span class="lineNum">   18822 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">   18823 </span>            : 
<span class="lineNum">   18824 </span>            :     case FIX_TRUNC_EXPR:
<span class="lineNum">   18825 </span>            :       return 0;
<span class="lineNum">   18826 </span>            : 
<span class="lineNum">   18827 </span><span class="lineCov">          1 :     default:</span>
<span class="lineNum">   18828 </span>            :       /* Leave front-end specific codes as simply unknown.  This comes
<span class="lineNum">   18829 </span>            :          up, for instance, with the C STMT_EXPR.  */
<span class="lineNum">   18830 </span><span class="lineCov">          1 :       if ((unsigned int) TREE_CODE (loc)</span>
<span class="lineNum">   18831 </span>            :           &gt;= (unsigned int) LAST_AND_UNUSED_TREE_CODE)
<span class="lineNum">   18832 </span>            :         {
<span class="lineNum">   18833 </span><span class="lineCov">          1 :           expansion_failed (loc, NULL_RTX,</span>
<span class="lineNum">   18834 </span>            :                             &quot;language specific tree node&quot;);
<span class="lineNum">   18835 </span><span class="lineCov">          1 :           return 0;</span>
<span class="lineNum">   18836 </span>            :         }
<span class="lineNum">   18837 </span>            : 
<span class="lineNum">   18838 </span>            :       /* Otherwise this is a generic code; we should just lists all of
<span class="lineNum">   18839 </span>            :          these explicitly.  We forgot one.  */
<span class="lineNum">   18840 </span><span class="lineNoCov">          0 :       if (flag_checking)</span>
<span class="lineNum">   18841 </span><span class="lineNoCov">          0 :         gcc_unreachable ();</span>
<span class="lineNum">   18842 </span>            : 
<span class="lineNum">   18843 </span>            :       /* In a release build, we want to degrade gracefully: better to
<span class="lineNum">   18844 </span>            :          generate incomplete debugging information than to crash.  */
<span class="lineNum">   18845 </span>            :       return NULL;
<span class="lineNum">   18846 </span>            :     }
<span class="lineNum">   18847 </span>            : 
<span class="lineNum">   18848 </span><span class="lineCov">    7432111 :   if (!ret &amp;&amp; !list_ret)</span>
<span class="lineNum">   18849 </span>            :     return 0;
<span class="lineNum">   18850 </span>            : 
<span class="lineNum">   18851 </span><span class="lineCov">    7065716 :   if (want_address == 2 &amp;&amp; !have_address</span>
<span class="lineNum">   18852 </span><span class="lineCov">      15849 :       &amp;&amp; (dwarf_version &gt;= 4 || !dwarf_strict))</span>
<span class="lineNum">   18853 </span>            :     {
<span class="lineNum">   18854 </span><span class="lineCov">      16855 :       if (int_size_in_bytes (TREE_TYPE (loc)) &gt; DWARF2_ADDR_SIZE)</span>
<span class="lineNum">   18855 </span>            :         {
<span class="lineNum">   18856 </span><span class="lineNoCov">          0 :           expansion_failed (loc, NULL_RTX,</span>
<span class="lineNum">   18857 </span>            :                             &quot;DWARF address size mismatch&quot;);
<span class="lineNum">   18858 </span><span class="lineNoCov">          0 :           return 0;</span>
<span class="lineNum">   18859 </span>            :         }
<span class="lineNum">   18860 </span><span class="lineCov">      15849 :       if (ret)</span>
<span class="lineNum">   18861 </span><span class="lineCov">       3029 :         add_loc_descr (&amp;ret, new_loc_descr (DW_OP_stack_value, 0, 0));</span>
<span class="lineNum">   18862 </span>            :       else
<span class="lineNum">   18863 </span><span class="lineCov">      12820 :         add_loc_descr_to_each (list_ret,</span>
<span class="lineNum">   18864 </span>            :                                new_loc_descr (DW_OP_stack_value, 0, 0));
<span class="lineNum">   18865 </span>            :       have_address = 1;
<span class="lineNum">   18866 </span>            :     }
<span class="lineNum">   18867 </span>            :   /* Show if we can't fill the request for an address.  */
<span class="lineNum">   18868 </span><span class="lineCov">    7065716 :   if (want_address &amp;&amp; !have_address)</span>
<span class="lineNum">   18869 </span>            :     {
<span class="lineNum">   18870 </span><span class="lineCov">         15 :       expansion_failed (loc, NULL_RTX,</span>
<span class="lineNum">   18871 </span>            :                         &quot;Want address and only have value&quot;);
<span class="lineNum">   18872 </span><span class="lineCov">         15 :       return 0;</span>
<span class="lineNum">   18873 </span>            :     }
<span class="lineNum">   18874 </span>            : 
<span class="lineNum">   18875 </span><span class="lineCov">    7065701 :   gcc_assert (!ret || !list_ret);</span>
<span class="lineNum">   18876 </span>            : 
<span class="lineNum">   18877 </span>            :   /* If we've got an address and don't want one, dereference.  */
<span class="lineNum">   18878 </span><span class="lineCov">    7065701 :   if (!want_address &amp;&amp; have_address)</span>
<span class="lineNum">   18879 </span>            :     {
<span class="lineNum">   18880 </span><span class="lineCov">      72783 :       HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (loc));</span>
<span class="lineNum">   18881 </span>            : 
<span class="lineNum">   18882 </span><span class="lineCov">      80218 :       if (size &gt; DWARF2_ADDR_SIZE || size == -1)</span>
<span class="lineNum">   18883 </span>            :         {
<span class="lineNum">   18884 </span><span class="lineCov">         68 :           expansion_failed (loc, NULL_RTX,</span>
<span class="lineNum">   18885 </span>            :                             &quot;DWARF address size mismatch&quot;);
<span class="lineNum">   18886 </span><span class="lineCov">         68 :           return 0;</span>
<span class="lineNum">   18887 </span>            :         }
<span class="lineNum">   18888 </span><span class="lineCov">      72715 :       else if (size == DWARF2_ADDR_SIZE)</span>
<span class="lineNum">   18889 </span>            :         op = DW_OP_deref;
<span class="lineNum">   18890 </span>            :       else
<span class="lineNum">   18891 </span><span class="lineCov">          3 :         op = DW_OP_deref_size;</span>
<span class="lineNum">   18892 </span>            : 
<span class="lineNum">   18893 </span><span class="lineCov">      72715 :       if (ret)</span>
<span class="lineNum">   18894 </span><span class="lineCov">        348 :         add_loc_descr (&amp;ret, new_loc_descr (op, size, 0));</span>
<span class="lineNum">   18895 </span>            :       else
<span class="lineNum">   18896 </span><span class="lineCov">      72367 :         add_loc_descr_to_each (list_ret, new_loc_descr (op, size, 0));</span>
<span class="lineNum">   18897 </span>            :     }
<span class="lineNum">   18898 </span><span class="lineCov">    7065633 :   if (ret)</span>
<span class="lineNum">   18899 </span><span class="lineCov">     459916 :     list_ret = new_loc_list (ret, NULL, 0, NULL, 0, NULL);</span>
<span class="lineNum">   18900 </span>            : 
<span class="lineNum">   18901 </span><span class="lineCov">    7065633 :   return list_ret;</span>
<span class="lineNum">   18902 </span>            : }
<span class="lineNum">   18903 </span>            : 
<span class="lineNum">   18904 </span>            : /* Likewise, but strip useless DW_OP_nop operations in the resulting
<span class="lineNum">   18905 </span>            :    expressions.  */
<a name="18906"><span class="lineNum">   18906 </span>            : </a>
<span class="lineNum">   18907 </span>            : static dw_loc_list_ref
<span class="lineNum">   18908 </span><span class="lineCov">    7940257 : loc_list_from_tree (tree loc, int want_address,</span>
<span class="lineNum">   18909 </span>            :                     struct loc_descr_context *context)
<span class="lineNum">   18910 </span>            : {
<span class="lineNum">   18911 </span><span class="lineCov">    7940257 :   dw_loc_list_ref result = loc_list_from_tree_1 (loc, want_address, context);</span>
<span class="lineNum">   18912 </span>            : 
<span class="lineNum">   18913 </span><span class="lineCov">    7940257 :   for (dw_loc_list_ref loc_cur = result;</span>
<span class="lineNum">   18914 </span><span class="lineCov">   25601221 :        loc_cur != NULL; loc_cur = loc_cur-&gt;dw_loc_next)</span>
<span class="lineNum">   18915 </span><span class="lineCov">   17660964 :     loc_descr_without_nops (loc_cur-&gt;expr);</span>
<span class="lineNum">   18916 </span><span class="lineCov">    7940257 :   return result;</span>
<span class="lineNum">   18917 </span>            : }
<span class="lineNum">   18918 </span>            : 
<a name="18919"><span class="lineNum">   18919 </span>            : /* Same as above but return only single location expression.  */</a>
<span class="lineNum">   18920 </span>            : static dw_loc_descr_ref
<span class="lineNum">   18921 </span><span class="lineCov">        153 : loc_descriptor_from_tree (tree loc, int want_address,</span>
<span class="lineNum">   18922 </span>            :                           struct loc_descr_context *context)
<span class="lineNum">   18923 </span>            : {
<span class="lineNum">   18924 </span><span class="lineCov">        153 :   dw_loc_list_ref ret = loc_list_from_tree (loc, want_address, context);</span>
<span class="lineNum">   18925 </span><span class="lineCov">        153 :   if (!ret)</span>
<span class="lineNum">   18926 </span>            :     return NULL;
<span class="lineNum">   18927 </span><span class="lineCov">         80 :   if (ret-&gt;dw_loc_next)</span>
<span class="lineNum">   18928 </span>            :     {
<span class="lineNum">   18929 </span><span class="lineNoCov">          0 :       expansion_failed (loc, NULL_RTX,</span>
<span class="lineNum">   18930 </span>            :                         &quot;Location list where only loc descriptor needed&quot;);
<span class="lineNum">   18931 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">   18932 </span>            :     }
<span class="lineNum">   18933 </span><span class="lineCov">         80 :   return ret-&gt;expr;</span>
<span class="lineNum">   18934 </span>            : }
<span class="lineNum">   18935 </span>            : 
<span class="lineNum">   18936 </span>            : /* Given a value, round it up to the lowest multiple of `boundary'
<span class="lineNum">   18937 </span>            :    which is not less than the value itself.  */
<span class="lineNum">   18938 </span>            : 
<span class="lineNum">   18939 </span>            : static inline HOST_WIDE_INT
<span class="lineNum">   18940 </span>            : ceiling (HOST_WIDE_INT value, unsigned int boundary)
<span class="lineNum">   18941 </span>            : {
<span class="lineNum">   18942 </span>            :   return (((value + boundary - 1) / boundary) * boundary);
<span class="lineNum">   18943 </span>            : }
<span class="lineNum">   18944 </span>            : 
<span class="lineNum">   18945 </span>            : /* Given a pointer to what is assumed to be a FIELD_DECL node, return a
<span class="lineNum">   18946 </span>            :    pointer to the declared type for the relevant field variable, or return
<span class="lineNum">   18947 </span>            :    `integer_type_node' if the given node turns out to be an
<span class="lineNum">   18948 </span>            :    ERROR_MARK node.  */
<a name="18949"><span class="lineNum">   18949 </span>            : </a>
<span class="lineNum">   18950 </span>            : static inline tree
<span class="lineNum">   18951 </span><span class="lineCov">    2320051 : field_type (const_tree decl)</span>
<span class="lineNum">   18952 </span>            : {
<span class="lineNum">   18953 </span><span class="lineCov">    2320051 :   tree type;</span>
<span class="lineNum">   18954 </span>            : 
<span class="lineNum">   18955 </span><span class="lineCov">    2320051 :   if (TREE_CODE (decl) == ERROR_MARK)</span>
<span class="lineNum">   18956 </span><span class="lineNoCov">          0 :     return integer_type_node;</span>
<span class="lineNum">   18957 </span>            : 
<span class="lineNum">   18958 </span><span class="lineCov">    2320051 :   type = DECL_BIT_FIELD_TYPE (decl);</span>
<span class="lineNum">   18959 </span><span class="lineCov">    2320051 :   if (type == NULL_TREE)</span>
<span class="lineNum">   18960 </span><span class="lineCov">    2291658 :     type = TREE_TYPE (decl);</span>
<span class="lineNum">   18961 </span>            : 
<span class="lineNum">   18962 </span>            :   return type;
<span class="lineNum">   18963 </span>            : }
<span class="lineNum">   18964 </span>            : 
<span class="lineNum">   18965 </span>            : /* Given a pointer to a tree node, return the alignment in bits for
<span class="lineNum">   18966 </span>            :    it, or else return BITS_PER_WORD if the node actually turns out to
<span class="lineNum">   18967 </span>            :    be an ERROR_MARK node.  */
<a name="18968"><span class="lineNum">   18968 </span>            : </a>
<span class="lineNum">   18969 </span>            : static inline unsigned
<span class="lineNum">   18970 </span><span class="lineCov">    2310573 : simple_type_align_in_bits (const_tree type)</span>
<span class="lineNum">   18971 </span>            : {
<span class="lineNum">   18972 </span><span class="lineCov">    2310573 :   return (TREE_CODE (type) != ERROR_MARK) ? TYPE_ALIGN (type) : BITS_PER_WORD;</span>
<span class="lineNum">   18973 </span>            : }
<a name="18974"><span class="lineNum">   18974 </span>            : </a>
<span class="lineNum">   18975 </span>            : static inline unsigned
<span class="lineNum">   18976 </span><span class="lineCov">    2310573 : simple_decl_align_in_bits (const_tree decl)</span>
<span class="lineNum">   18977 </span>            : {
<span class="lineNum">   18978 </span><span class="lineCov">    2310573 :   return (TREE_CODE (decl) != ERROR_MARK) ? DECL_ALIGN (decl) : BITS_PER_WORD;</span>
<span class="lineNum">   18979 </span>            : }
<span class="lineNum">   18980 </span>            : 
<span class="lineNum">   18981 </span>            : /* Return the result of rounding T up to ALIGN.  */
<a name="18982"><span class="lineNum">   18982 </span>            : </a>
<span class="lineNum">   18983 </span>            : static inline offset_int
<span class="lineNum">   18984 </span><span class="lineCov">    2315420 : round_up_to_align (const offset_int &amp;t, unsigned int align)</span>
<span class="lineNum">   18985 </span>            : {
<span class="lineNum">   18986 </span><span class="lineCov">    2315420 :   return wi::udiv_trunc (t + align - 1, align) * align;</span>
<span class="lineNum">   18987 </span>            : }
<span class="lineNum">   18988 </span>            : 
<span class="lineNum">   18989 </span>            : /* Compute the size of TYPE in bytes.  If possible, return NULL and store the
<span class="lineNum">   18990 </span>            :    size as an integer constant in CST_SIZE.  Otherwise, if possible, return a
<span class="lineNum">   18991 </span>            :    DWARF expression that computes the size.  Return NULL and set CST_SIZE to -1
<span class="lineNum">   18992 </span>            :    if we fail to return the size in one of these two forms.  */
<a name="18993"><span class="lineNum">   18993 </span>            : </a>
<span class="lineNum">   18994 </span>            : static dw_loc_descr_ref
<span class="lineNum">   18995 </span><span class="lineCov">    8519479 : type_byte_size (const_tree type, HOST_WIDE_INT *cst_size)</span>
<span class="lineNum">   18996 </span>            : {
<span class="lineNum">   18997 </span><span class="lineCov">    8519479 :   tree tree_size;</span>
<span class="lineNum">   18998 </span><span class="lineCov">    8519479 :   struct loc_descr_context ctx;</span>
<span class="lineNum">   18999 </span>            : 
<span class="lineNum">   19000 </span>            :   /* Return a constant integer in priority, if possible.  */
<span class="lineNum">   19001 </span><span class="lineCov">    8519479 :   *cst_size = int_size_in_bytes (type);</span>
<span class="lineNum">   19002 </span><span class="lineCov">    8519479 :   if (*cst_size != -1)</span>
<span class="lineNum">   19003 </span>            :     return NULL;
<span class="lineNum">   19004 </span>            : 
<span class="lineNum">   19005 </span><span class="lineCov">         66 :   ctx.context_type = const_cast&lt;tree&gt; (type);</span>
<span class="lineNum">   19006 </span><span class="lineCov">         66 :   ctx.base_decl = NULL_TREE;</span>
<span class="lineNum">   19007 </span><span class="lineCov">         66 :   ctx.dpi = NULL;</span>
<span class="lineNum">   19008 </span><span class="lineCov">         66 :   ctx.placeholder_arg = false;</span>
<span class="lineNum">   19009 </span><span class="lineCov">         66 :   ctx.placeholder_seen = false;</span>
<span class="lineNum">   19010 </span>            : 
<span class="lineNum">   19011 </span><span class="lineCov">         66 :   type = TYPE_MAIN_VARIANT (type);</span>
<span class="lineNum">   19012 </span><span class="lineCov">         66 :   tree_size = TYPE_SIZE_UNIT (type);</span>
<span class="lineNum">   19013 </span><span class="lineCov">         66 :   return ((tree_size != NULL_TREE)</span>
<span class="lineNum">   19014 </span><span class="lineCov">         66 :           ? loc_descriptor_from_tree (tree_size, 0, &amp;ctx)</span>
<span class="lineNum">   19015 </span>            :           : NULL);
<span class="lineNum">   19016 </span>            : }
<span class="lineNum">   19017 </span>            : 
<span class="lineNum">   19018 </span>            : /* Helper structure for RECORD_TYPE processing.  */
<span class="lineNum">   19019 </span>            : struct vlr_context
<span class="lineNum">   19020 </span>            : {
<span class="lineNum">   19021 </span>            :   /* Root RECORD_TYPE.  It is needed to generate data member location
<span class="lineNum">   19022 </span>            :      descriptions in variable-length records (VLR), but also to cope with
<span class="lineNum">   19023 </span>            :      variants, which are composed of nested structures multiplexed with
<span class="lineNum">   19024 </span>            :      QUAL_UNION_TYPE nodes.  Each time such a structure is passed to a
<span class="lineNum">   19025 </span>            :      function processing a FIELD_DECL, it is required to be non null.  */
<span class="lineNum">   19026 </span>            :   tree struct_type;
<span class="lineNum">   19027 </span>            :   /* When generating a variant part in a RECORD_TYPE (i.e. a nested
<span class="lineNum">   19028 </span>            :      QUAL_UNION_TYPE), this holds an expression that computes the offset for
<span class="lineNum">   19029 </span>            :      this variant part as part of the root record (in storage units).  For
<span class="lineNum">   19030 </span>            :      regular records, it must be NULL_TREE.  */
<span class="lineNum">   19031 </span>            :   tree variant_part_offset;
<span class="lineNum">   19032 </span>            : };
<span class="lineNum">   19033 </span>            : 
<span class="lineNum">   19034 </span>            : /* Given a pointer to a FIELD_DECL, compute the byte offset of the lowest
<span class="lineNum">   19035 </span>            :    addressed byte of the &quot;containing object&quot; for the given FIELD_DECL. If
<span class="lineNum">   19036 </span>            :    possible, return a native constant through CST_OFFSET (in which case NULL is
<span class="lineNum">   19037 </span>            :    returned); otherwise return a DWARF expression that computes the offset.
<span class="lineNum">   19038 </span>            : 
<span class="lineNum">   19039 </span>            :    Set *CST_OFFSET to 0 and return NULL if we are unable to determine what
<span class="lineNum">   19040 </span>            :    that offset is, either because the argument turns out to be a pointer to an
<span class="lineNum">   19041 </span>            :    ERROR_MARK node, or because the offset expression is too complex for us.
<span class="lineNum">   19042 </span>            : 
<span class="lineNum">   19043 </span>            :    CTX is required: see the comment for VLR_CONTEXT.  */
<a name="19044"><span class="lineNum">   19044 </span>            : </a>
<span class="lineNum">   19045 </span>            : static dw_loc_descr_ref
<span class="lineNum">   19046 </span><span class="lineCov">    2310613 : field_byte_offset (const_tree decl, struct vlr_context *ctx,</span>
<span class="lineNum">   19047 </span>            :                    HOST_WIDE_INT *cst_offset)
<span class="lineNum">   19048 </span>            : {
<span class="lineNum">   19049 </span><span class="lineCov">    2310613 :   tree tree_result;</span>
<span class="lineNum">   19050 </span><span class="lineCov">    2310613 :   dw_loc_list_ref loc_result;</span>
<span class="lineNum">   19051 </span>            : 
<span class="lineNum">   19052 </span><span class="lineCov">    2310613 :   *cst_offset = 0;</span>
<span class="lineNum">   19053 </span>            : 
<span class="lineNum">   19054 </span><span class="lineCov">    2310613 :   if (TREE_CODE (decl) == ERROR_MARK)</span>
<span class="lineNum">   19055 </span>            :     return NULL;
<span class="lineNum">   19056 </span>            :   else
<span class="lineNum">   19057 </span><span class="lineCov">    2310613 :     gcc_assert (TREE_CODE (decl) == FIELD_DECL);</span>
<span class="lineNum">   19058 </span>            : 
<span class="lineNum">   19059 </span>            :   /* We cannot handle variable bit offsets at the moment, so abort if it's the
<span class="lineNum">   19060 </span>            :      case.  */
<span class="lineNum">   19061 </span><span class="lineCov">    4621226 :   if (TREE_CODE (DECL_FIELD_BIT_OFFSET (decl)) != INTEGER_CST)</span>
<span class="lineNum">   19062 </span>            :     return NULL;
<span class="lineNum">   19063 </span>            : 
<span class="lineNum">   19064 </span>            : #ifdef PCC_BITFIELD_TYPE_MATTERS
<span class="lineNum">   19065 </span>            :   /* We used to handle only constant offsets in all cases.  Now, we handle
<span class="lineNum">   19066 </span>            :      properly dynamic byte offsets only when PCC bitfield type doesn't
<span class="lineNum">   19067 </span>            :      matter.  */
<span class="lineNum">   19068 </span><span class="lineCov">    4621226 :   if (PCC_BITFIELD_TYPE_MATTERS</span>
<span class="lineNum">   19069 </span><span class="lineCov">    4621226 :       &amp;&amp; TREE_CODE (DECL_FIELD_OFFSET (decl)) == INTEGER_CST)</span>
<span class="lineNum">   19070 </span>            :     {
<span class="lineNum">   19071 </span><span class="lineCov">    2310573 :       offset_int object_offset_in_bits;</span>
<span class="lineNum">   19072 </span><span class="lineCov">    2310573 :       offset_int object_offset_in_bytes;</span>
<span class="lineNum">   19073 </span><span class="lineCov">    2310573 :       offset_int bitpos_int;</span>
<span class="lineNum">   19074 </span><span class="lineCov">    2310573 :       tree type;</span>
<span class="lineNum">   19075 </span><span class="lineCov">    2310573 :       tree field_size_tree;</span>
<span class="lineNum">   19076 </span><span class="lineCov">    2310573 :       offset_int deepest_bitpos;</span>
<span class="lineNum">   19077 </span><span class="lineCov">    2310573 :       offset_int field_size_in_bits;</span>
<span class="lineNum">   19078 </span><span class="lineCov">    2310573 :       unsigned int type_align_in_bits;</span>
<span class="lineNum">   19079 </span><span class="lineCov">    2310573 :       unsigned int decl_align_in_bits;</span>
<span class="lineNum">   19080 </span><span class="lineCov">    2310573 :       offset_int type_size_in_bits;</span>
<span class="lineNum">   19081 </span>            : 
<span class="lineNum">   19082 </span><span class="lineCov">    2310573 :       bitpos_int = wi::to_offset (bit_position (decl));</span>
<span class="lineNum">   19083 </span><span class="lineCov">    2310573 :       type = field_type (decl);</span>
<span class="lineNum">   19084 </span><span class="lineCov">    2310573 :       type_size_in_bits = offset_int_type_size_in_bits (type);</span>
<span class="lineNum">   19085 </span><span class="lineCov">    2310573 :       type_align_in_bits = simple_type_align_in_bits (type);</span>
<span class="lineNum">   19086 </span>            : 
<span class="lineNum">   19087 </span><span class="lineCov">    2310573 :       field_size_tree = DECL_SIZE (decl);</span>
<span class="lineNum">   19088 </span>            : 
<span class="lineNum">   19089 </span>            :       /* The size could be unspecified if there was an error, or for
<span class="lineNum">   19090 </span>            :          a flexible array member.  */
<span class="lineNum">   19091 </span><span class="lineCov">    2310573 :       if (!field_size_tree)</span>
<span class="lineNum">   19092 </span><span class="lineCov">      43301 :         field_size_tree = bitsize_zero_node;</span>
<span class="lineNum">   19093 </span>            : 
<span class="lineNum">   19094 </span>            :       /* If the size of the field is not constant, use the type size.  */
<span class="lineNum">   19095 </span><span class="lineCov">    2310573 :       if (TREE_CODE (field_size_tree) == INTEGER_CST)</span>
<span class="lineNum">   19096 </span><span class="lineCov">    2310521 :         field_size_in_bits = wi::to_offset (field_size_tree);</span>
<span class="lineNum">   19097 </span>            :       else
<span class="lineNum">   19098 </span><span class="lineCov">         52 :         field_size_in_bits = type_size_in_bits;</span>
<span class="lineNum">   19099 </span>            : 
<span class="lineNum">   19100 </span><span class="lineCov">    2310573 :       decl_align_in_bits = simple_decl_align_in_bits (decl);</span>
<span class="lineNum">   19101 </span>            : 
<span class="lineNum">   19102 </span>            :       /* The GCC front-end doesn't make any attempt to keep track of the
<span class="lineNum">   19103 </span>            :          starting bit offset (relative to the start of the containing
<span class="lineNum">   19104 </span>            :          structure type) of the hypothetical &quot;containing object&quot; for a
<span class="lineNum">   19105 </span>            :          bit-field.  Thus, when computing the byte offset value for the
<span class="lineNum">   19106 </span>            :          start of the &quot;containing object&quot; of a bit-field, we must deduce
<span class="lineNum">   19107 </span>            :          this information on our own. This can be rather tricky to do in
<span class="lineNum">   19108 </span>            :          some cases.  For example, handling the following structure type
<span class="lineNum">   19109 </span>            :          definition when compiling for an i386/i486 target (which only
<span class="lineNum">   19110 </span>            :          aligns long long's to 32-bit boundaries) can be very tricky:
<span class="lineNum">   19111 </span>            : 
<span class="lineNum">   19112 </span>            :          struct S { int field1; long long field2:31; };
<span class="lineNum">   19113 </span>            : 
<span class="lineNum">   19114 </span>            :          Fortunately, there is a simple rule-of-thumb which can be used
<span class="lineNum">   19115 </span>            :          in such cases.  When compiling for an i386/i486, GCC will
<span class="lineNum">   19116 </span>            :          allocate 8 bytes for the structure shown above.  It decides to
<span class="lineNum">   19117 </span>            :          do this based upon one simple rule for bit-field allocation.
<span class="lineNum">   19118 </span>            :          GCC allocates each &quot;containing object&quot; for each bit-field at
<span class="lineNum">   19119 </span>            :          the first (i.e. lowest addressed) legitimate alignment boundary
<span class="lineNum">   19120 </span>            :          (based upon the required minimum alignment for the declared
<span class="lineNum">   19121 </span>            :          type of the field) which it can possibly use, subject to the
<span class="lineNum">   19122 </span>            :          condition that there is still enough available space remaining
<span class="lineNum">   19123 </span>            :          in the containing object (when allocated at the selected point)
<span class="lineNum">   19124 </span>            :          to fully accommodate all of the bits of the bit-field itself.
<span class="lineNum">   19125 </span>            : 
<span class="lineNum">   19126 </span>            :          This simple rule makes it obvious why GCC allocates 8 bytes for
<span class="lineNum">   19127 </span>            :          each object of the structure type shown above.  When looking
<span class="lineNum">   19128 </span>            :          for a place to allocate the &quot;containing object&quot; for `field2',
<span class="lineNum">   19129 </span>            :          the compiler simply tries to allocate a 64-bit &quot;containing
<span class="lineNum">   19130 </span>            :          object&quot; at each successive 32-bit boundary (starting at zero)
<span class="lineNum">   19131 </span>            :          until it finds a place to allocate that 64- bit field such that
<span class="lineNum">   19132 </span>            :          at least 31 contiguous (and previously unallocated) bits remain
<span class="lineNum">   19133 </span>            :          within that selected 64 bit field.  (As it turns out, for the
<span class="lineNum">   19134 </span>            :          example above, the compiler finds it is OK to allocate the
<span class="lineNum">   19135 </span>            :          &quot;containing object&quot; 64-bit field at bit-offset zero within the
<span class="lineNum">   19136 </span>            :          structure type.)
<span class="lineNum">   19137 </span>            : 
<span class="lineNum">   19138 </span>            :          Here we attempt to work backwards from the limited set of facts
<span class="lineNum">   19139 </span>            :          we're given, and we try to deduce from those facts, where GCC
<span class="lineNum">   19140 </span>            :          must have believed that the containing object started (within
<span class="lineNum">   19141 </span>            :          the structure type). The value we deduce is then used (by the
<span class="lineNum">   19142 </span>            :          callers of this routine) to generate DW_AT_location and
<span class="lineNum">   19143 </span>            :          DW_AT_bit_offset attributes for fields (both bit-fields and, in
<span class="lineNum">   19144 </span>            :          the case of DW_AT_location, regular fields as well).  */
<span class="lineNum">   19145 </span>            : 
<span class="lineNum">   19146 </span>            :       /* Figure out the bit-distance from the start of the structure to
<span class="lineNum">   19147 </span>            :          the &quot;deepest&quot; bit of the bit-field.  */
<span class="lineNum">   19148 </span><span class="lineCov">    2310573 :       deepest_bitpos = bitpos_int + field_size_in_bits;</span>
<span class="lineNum">   19149 </span>            : 
<span class="lineNum">   19150 </span>            :       /* This is the tricky part.  Use some fancy footwork to deduce
<span class="lineNum">   19151 </span>            :          where the lowest addressed bit of the containing object must
<span class="lineNum">   19152 </span>            :          be.  */
<span class="lineNum">   19153 </span><span class="lineCov">    2310573 :       object_offset_in_bits = deepest_bitpos - type_size_in_bits;</span>
<span class="lineNum">   19154 </span>            : 
<span class="lineNum">   19155 </span>            :       /* Round up to type_align by default.  This works best for
<span class="lineNum">   19156 </span>            :          bitfields.  */
<span class="lineNum">   19157 </span><span class="lineCov">    2310573 :       object_offset_in_bits</span>
<span class="lineNum">   19158 </span><span class="lineCov">    2310573 :         = round_up_to_align (object_offset_in_bits, type_align_in_bits);</span>
<span class="lineNum">   19159 </span>            : 
<span class="lineNum">   19160 </span><span class="lineCov">    2310573 :       if (wi::gtu_p (object_offset_in_bits, bitpos_int))</span>
<span class="lineNum">   19161 </span>            :         {
<span class="lineNum">   19162 </span><span class="lineCov">       4847 :           object_offset_in_bits = deepest_bitpos - type_size_in_bits;</span>
<span class="lineNum">   19163 </span>            : 
<span class="lineNum">   19164 </span>            :           /* Round up to decl_align instead.  */
<span class="lineNum">   19165 </span><span class="lineCov">       4847 :           object_offset_in_bits</span>
<span class="lineNum">   19166 </span><span class="lineCov">       4847 :             = round_up_to_align (object_offset_in_bits, decl_align_in_bits);</span>
<span class="lineNum">   19167 </span>            :         }
<span class="lineNum">   19168 </span>            : 
<span class="lineNum">   19169 </span><span class="lineCov">    2310573 :       object_offset_in_bytes</span>
<span class="lineNum">   19170 </span><span class="lineCov">    2310573 :         = wi::lrshift (object_offset_in_bits, LOG2_BITS_PER_UNIT);</span>
<span class="lineNum">   19171 </span><span class="lineCov">    2310573 :       if (ctx-&gt;variant_part_offset == NULL_TREE)</span>
<span class="lineNum">   19172 </span>            :         {
<span class="lineNum">   19173 </span><span class="lineCov">    2310573 :           *cst_offset = object_offset_in_bytes.to_shwi ();</span>
<span class="lineNum">   19174 </span><span class="lineCov">    2310573 :           return NULL;</span>
<span class="lineNum">   19175 </span>            :         }
<span class="lineNum">   19176 </span><span class="lineNoCov">          0 :       tree_result = wide_int_to_tree (sizetype, object_offset_in_bytes);</span>
<span class="lineNum">   19177 </span>            :     }
<span class="lineNum">   19178 </span>            :   else
<span class="lineNum">   19179 </span>            : #endif /* PCC_BITFIELD_TYPE_MATTERS */
<span class="lineNum">   19180 </span><span class="lineCov">         40 :     tree_result = byte_position (decl);</span>
<span class="lineNum">   19181 </span>            : 
<span class="lineNum">   19182 </span><span class="lineCov">         40 :   if (ctx-&gt;variant_part_offset != NULL_TREE)</span>
<span class="lineNum">   19183 </span><span class="lineNoCov">          0 :     tree_result = fold_build2 (PLUS_EXPR, TREE_TYPE (tree_result),</span>
<span class="lineNum">   19184 </span>            :                                ctx-&gt;variant_part_offset, tree_result);
<span class="lineNum">   19185 </span>            : 
<span class="lineNum">   19186 </span>            :   /* If the byte offset is a constant, it's simplier to handle a native
<span class="lineNum">   19187 </span>            :      constant rather than a DWARF expression.  */
<span class="lineNum">   19188 </span><span class="lineCov">         40 :   if (TREE_CODE (tree_result) == INTEGER_CST)</span>
<span class="lineNum">   19189 </span>            :     {
<span class="lineNum">   19190 </span><span class="lineNoCov">          0 :       *cst_offset = wi::to_offset (tree_result).to_shwi ();</span>
<span class="lineNum">   19191 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">   19192 </span>            :     }
<span class="lineNum">   19193 </span><span class="lineCov">         40 :   struct loc_descr_context loc_ctx = {</span>
<span class="lineNum">   19194 </span><span class="lineCov">         40 :     ctx-&gt;struct_type, /* context_type */</span>
<span class="lineNum">   19195 </span>            :     NULL_TREE,        /* base_decl */
<span class="lineNum">   19196 </span>            :     NULL,             /* dpi */
<span class="lineNum">   19197 </span>            :     false,            /* placeholder_arg */
<span class="lineNum">   19198 </span>            :     false             /* placeholder_seen */
<span class="lineNum">   19199 </span><span class="lineCov">         40 :   };</span>
<span class="lineNum">   19200 </span><span class="lineCov">         40 :   loc_result = loc_list_from_tree (tree_result, 0, &amp;loc_ctx);</span>
<span class="lineNum">   19201 </span>            : 
<span class="lineNum">   19202 </span>            :   /* We want a DWARF expression: abort if we only have a location list with
<span class="lineNum">   19203 </span>            :      multiple elements.  */
<span class="lineNum">   19204 </span><span class="lineCov">         40 :   if (!loc_result || !single_element_loc_list_p (loc_result))</span>
<span class="lineNum">   19205 </span>            :     return NULL;
<span class="lineNum">   19206 </span>            :   else
<span class="lineNum">   19207 </span><span class="lineNoCov">          0 :     return loc_result-&gt;expr;</span>
<span class="lineNum">   19208 </span>            : }
<span class="lineNum">   19209 </span>            : 
<span class="lineNum">   19210 </span>            : /* The following routines define various Dwarf attributes and any data
<span class="lineNum">   19211 </span>            :    associated with them.  */
<span class="lineNum">   19212 </span>            : 
<span class="lineNum">   19213 </span>            : /* Add a location description attribute value to a DIE.
<span class="lineNum">   19214 </span>            : 
<span class="lineNum">   19215 </span>            :    This emits location attributes suitable for whole variables and
<span class="lineNum">   19216 </span>            :    whole parameters.  Note that the location attributes for struct fields are
<span class="lineNum">   19217 </span>            :    generated by the routine `data_member_location_attribute' below.  */
<a name="19218"><span class="lineNum">   19218 </span>            : </a>
<span class="lineNum">   19219 </span>            : static inline void
<span class="lineNum">   19220 </span><span class="lineCov">    6832055 : add_AT_location_description (dw_die_ref die, enum dwarf_attribute attr_kind,</span>
<span class="lineNum">   19221 </span>            :                              dw_loc_list_ref descr)
<span class="lineNum">   19222 </span>            : {
<span class="lineNum">   19223 </span><span class="lineCov">    6832055 :   bool check_no_locviews = true;</span>
<span class="lineNum">   19224 </span><span class="lineCov">    6832055 :   if (descr == 0)</span>
<span class="lineNum">   19225 </span>            :     return;
<span class="lineNum">   19226 </span><span class="lineCov">    6831987 :   if (single_element_loc_list_p (descr))</span>
<span class="lineNum">   19227 </span><span class="lineCov">     697625 :     add_AT_loc (die, attr_kind, descr-&gt;expr);</span>
<span class="lineNum">   19228 </span>            :   else
<span class="lineNum">   19229 </span>            :     {
<span class="lineNum">   19230 </span><span class="lineCov">    6134362 :       add_AT_loc_list (die, attr_kind, descr);</span>
<span class="lineNum">   19231 </span><span class="lineCov">    6134362 :       gcc_assert (descr-&gt;ll_symbol);</span>
<span class="lineNum">   19232 </span><span class="lineCov">    6133759 :       if (attr_kind == DW_AT_location &amp;&amp; descr-&gt;vl_symbol</span>
<span class="lineNum">   19233 </span><span class="lineCov">   12185198 :           &amp;&amp; dwarf2out_locviews_in_attribute ())</span>
<span class="lineNum">   19234 </span>            :         {
<span class="lineNum">   19235 </span><span class="lineCov">    6050836 :           add_AT_view_list (die, DW_AT_GNU_locviews);</span>
<span class="lineNum">   19236 </span><span class="lineCov">    6050836 :           check_no_locviews = false;</span>
<span class="lineNum">   19237 </span>            :         }
<span class="lineNum">   19238 </span>            :     }
<span class="lineNum">   19239 </span>            : 
<span class="lineNum">   19240 </span><span class="lineCov">    6748461 :   if (check_no_locviews)</span>
<span class="lineNum">   19241 </span><span class="lineCov">     781151 :     gcc_assert (!get_AT (die, DW_AT_GNU_locviews));</span>
<span class="lineNum">   19242 </span>            : }
<span class="lineNum">   19243 </span>            : 
<span class="lineNum">   19244 </span>            : /* Add DW_AT_accessibility attribute to DIE if needed.  */
<a name="19245"><span class="lineNum">   19245 </span>            : </a>
<span class="lineNum">   19246 </span>            : static void
<span class="lineNum">   19247 </span><span class="lineCov">   27403801 : add_accessibility_attribute (dw_die_ref die, tree decl)</span>
<span class="lineNum">   19248 </span>            : {
<span class="lineNum">   19249 </span>            :   /* In DWARF3+ the default is DW_ACCESS_private only in DW_TAG_class_type
<span class="lineNum">   19250 </span>            :      children, otherwise the default is DW_ACCESS_public.  In DWARF2
<span class="lineNum">   19251 </span>            :      the default has always been DW_ACCESS_public.  */
<span class="lineNum">   19252 </span><span class="lineCov">   27403801 :   if (TREE_PROTECTED (decl))</span>
<span class="lineNum">   19253 </span><span class="lineCov">     508596 :     add_AT_unsigned (die, DW_AT_accessibility, DW_ACCESS_protected);</span>
<span class="lineNum">   19254 </span><span class="lineCov">   26895205 :   else if (TREE_PRIVATE (decl))</span>
<span class="lineNum">   19255 </span>            :     {
<span class="lineNum">   19256 </span><span class="lineCov">     984813 :       if (dwarf_version == 2</span>
<span class="lineNum">   19257 </span><span class="lineCov">     984702 :           || die-&gt;die_parent == NULL</span>
<span class="lineNum">   19258 </span><span class="lineCov">     984702 :           || die-&gt;die_parent-&gt;die_tag != DW_TAG_class_type)</span>
<span class="lineNum">   19259 </span><span class="lineCov">     121925 :         add_AT_unsigned (die, DW_AT_accessibility, DW_ACCESS_private);</span>
<span class="lineNum">   19260 </span>            :     }
<span class="lineNum">   19261 </span><span class="lineCov">   25910392 :   else if (dwarf_version &gt; 2</span>
<span class="lineNum">   19262 </span><span class="lineCov">   25864930 :            &amp;&amp; die-&gt;die_parent</span>
<span class="lineNum">   19263 </span><span class="lineCov">   25863781 :            &amp;&amp; die-&gt;die_parent-&gt;die_tag == DW_TAG_class_type)</span>
<span class="lineNum">   19264 </span><span class="lineCov">    4926847 :     add_AT_unsigned (die, DW_AT_accessibility, DW_ACCESS_public);</span>
<span class="lineNum">   19265 </span><span class="lineCov">   27403801 : }</span>
<span class="lineNum">   19266 </span>            : 
<span class="lineNum">   19267 </span>            : /* Attach the specialized form of location attribute used for data members of
<span class="lineNum">   19268 </span>            :    struct and union types.  In the special case of a FIELD_DECL node which
<span class="lineNum">   19269 </span>            :    represents a bit-field, the &quot;offset&quot; part of this special location
<span class="lineNum">   19270 </span>            :    descriptor must indicate the distance in bytes from the lowest-addressed
<span class="lineNum">   19271 </span>            :    byte of the containing struct or union type to the lowest-addressed byte of
<span class="lineNum">   19272 </span>            :    the &quot;containing object&quot; for the bit-field.  (See the `field_byte_offset'
<span class="lineNum">   19273 </span>            :    function above).
<span class="lineNum">   19274 </span>            : 
<span class="lineNum">   19275 </span>            :    For any given bit-field, the &quot;containing object&quot; is a hypothetical object
<span class="lineNum">   19276 </span>            :    (of some integral or enum type) within which the given bit-field lives.  The
<span class="lineNum">   19277 </span>            :    type of this hypothetical &quot;containing object&quot; is always the same as the
<span class="lineNum">   19278 </span>            :    declared type of the individual bit-field itself (for GCC anyway... the
<span class="lineNum">   19279 </span>            :    DWARF spec doesn't actually mandate this).  Note that it is the size (in
<span class="lineNum">   19280 </span>            :    bytes) of the hypothetical &quot;containing object&quot; which will be given in the
<span class="lineNum">   19281 </span>            :    DW_AT_byte_size attribute for this bit-field.  (See the
<span class="lineNum">   19282 </span>            :    `byte_size_attribute' function below.)  It is also used when calculating the
<span class="lineNum">   19283 </span>            :    value of the DW_AT_bit_offset attribute.  (See the `bit_offset_attribute'
<span class="lineNum">   19284 </span>            :    function below.)
<span class="lineNum">   19285 </span>            : 
<span class="lineNum">   19286 </span>            :    CTX is required: see the comment for VLR_CONTEXT.  */
<a name="19287"><span class="lineNum">   19287 </span>            : </a>
<span class="lineNum">   19288 </span>            : static void
<span class="lineNum">   19289 </span><span class="lineCov">    6617062 : add_data_member_location_attribute (dw_die_ref die,</span>
<span class="lineNum">   19290 </span>            :                                     tree decl,
<span class="lineNum">   19291 </span>            :                                     struct vlr_context *ctx)
<span class="lineNum">   19292 </span>            : {
<span class="lineNum">   19293 </span><span class="lineCov">    6617062 :   HOST_WIDE_INT offset;</span>
<span class="lineNum">   19294 </span><span class="lineCov">    6617062 :   dw_loc_descr_ref loc_descr = 0;</span>
<span class="lineNum">   19295 </span>            : 
<span class="lineNum">   19296 </span><span class="lineCov">    6617062 :   if (TREE_CODE (decl) == TREE_BINFO)</span>
<span class="lineNum">   19297 </span>            :     {
<span class="lineNum">   19298 </span>            :       /* We're working on the TAG_inheritance for a base class.  */
<span class="lineNum">   19299 </span><span class="lineCov">    8631854 :       if (BINFO_VIRTUAL_P (decl) &amp;&amp; is_cxx ())</span>
<span class="lineNum">   19300 </span>            :         {
<span class="lineNum">   19301 </span>            :           /* For C++ virtual bases we can't just use BINFO_OFFSET, as they
<span class="lineNum">   19302 </span>            :              aren't at a fixed offset from all (sub)objects of the same
<span class="lineNum">   19303 </span>            :              type.  We need to extract the appropriate offset from our
<span class="lineNum">   19304 </span>            :              vtable.  The following dwarf expression means
<span class="lineNum">   19305 </span>            : 
<span class="lineNum">   19306 </span>            :                BaseAddr = ObAddr + *((*ObAddr) - Offset)
<span class="lineNum">   19307 </span>            : 
<span class="lineNum">   19308 </span>            :              This is specific to the V3 ABI, of course.  */
<span class="lineNum">   19309 </span>            : 
<span class="lineNum">   19310 </span><span class="lineCov">        279 :           dw_loc_descr_ref tmp;</span>
<span class="lineNum">   19311 </span>            : 
<span class="lineNum">   19312 </span>            :           /* Make a copy of the object address.  */
<span class="lineNum">   19313 </span><span class="lineCov">        279 :           tmp = new_loc_descr (DW_OP_dup, 0, 0);</span>
<span class="lineNum">   19314 </span><span class="lineCov">        279 :           add_loc_descr (&amp;loc_descr, tmp);</span>
<span class="lineNum">   19315 </span>            : 
<span class="lineNum">   19316 </span>            :           /* Extract the vtable address.  */
<span class="lineNum">   19317 </span><span class="lineCov">        279 :           tmp = new_loc_descr (DW_OP_deref, 0, 0);</span>
<span class="lineNum">   19318 </span><span class="lineCov">        279 :           add_loc_descr (&amp;loc_descr, tmp);</span>
<span class="lineNum">   19319 </span>            : 
<span class="lineNum">   19320 </span>            :           /* Calculate the address of the offset.  */
<span class="lineNum">   19321 </span><span class="lineCov">        279 :           offset = tree_to_shwi (BINFO_VPTR_FIELD (decl));</span>
<span class="lineNum">   19322 </span><span class="lineCov">        279 :           gcc_assert (offset &lt; 0);</span>
<span class="lineNum">   19323 </span>            : 
<span class="lineNum">   19324 </span><span class="lineCov">        558 :           tmp = int_loc_descriptor (-offset);</span>
<span class="lineNum">   19325 </span><span class="lineCov">        279 :           add_loc_descr (&amp;loc_descr, tmp);</span>
<span class="lineNum">   19326 </span><span class="lineCov">        279 :           tmp = new_loc_descr (DW_OP_minus, 0, 0);</span>
<span class="lineNum">   19327 </span><span class="lineCov">        279 :           add_loc_descr (&amp;loc_descr, tmp);</span>
<span class="lineNum">   19328 </span>            : 
<span class="lineNum">   19329 </span>            :           /* Extract the offset.  */
<span class="lineNum">   19330 </span><span class="lineCov">        279 :           tmp = new_loc_descr (DW_OP_deref, 0, 0);</span>
<span class="lineNum">   19331 </span><span class="lineCov">        279 :           add_loc_descr (&amp;loc_descr, tmp);</span>
<span class="lineNum">   19332 </span>            : 
<span class="lineNum">   19333 </span>            :           /* Add it to the object address.  */
<span class="lineNum">   19334 </span><span class="lineCov">        279 :           tmp = new_loc_descr (DW_OP_plus, 0, 0);</span>
<span class="lineNum">   19335 </span><span class="lineCov">        279 :           add_loc_descr (&amp;loc_descr, tmp);</span>
<span class="lineNum">   19336 </span>            :         }
<span class="lineNum">   19337 </span>            :       else
<span class="lineNum">   19338 </span><span class="lineCov">    4315648 :         offset = tree_to_shwi (BINFO_OFFSET (decl));</span>
<span class="lineNum">   19339 </span>            :     }
<span class="lineNum">   19340 </span>            :   else
<span class="lineNum">   19341 </span>            :     {
<span class="lineNum">   19342 </span><span class="lineCov">    2301135 :       loc_descr = field_byte_offset (decl, ctx, &amp;offset);</span>
<span class="lineNum">   19343 </span>            : 
<span class="lineNum">   19344 </span>            :       /* If loc_descr is available then we know the field offset is dynamic.
<span class="lineNum">   19345 </span>            :          However, GDB does not handle dynamic field offsets very well at the
<span class="lineNum">   19346 </span>            :          moment.  */
<span class="lineNum">   19347 </span><span class="lineCov">    2301135 :       if (loc_descr != NULL &amp;&amp; gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL)</span>
<span class="lineNum">   19348 </span>            :         {
<span class="lineNum">   19349 </span><span class="lineNoCov">          0 :           loc_descr = NULL;</span>
<span class="lineNum">   19350 </span><span class="lineNoCov">          0 :           offset = 0;</span>
<span class="lineNum">   19351 </span>            :         }
<span class="lineNum">   19352 </span>            : 
<span class="lineNum">   19353 </span>            :       /* Data member location evalutation starts with the base address on the
<span class="lineNum">   19354 </span>            :          stack.  Compute the field offset and add it to this base address.  */
<span class="lineNum">   19355 </span><span class="lineCov">    2301135 :       else if (loc_descr != NULL)</span>
<span class="lineNum">   19356 </span><span class="lineNoCov">          0 :         add_loc_descr (&amp;loc_descr, new_loc_descr (DW_OP_plus, 0, 0));</span>
<span class="lineNum">   19357 </span>            :     }
<span class="lineNum">   19358 </span>            : 
<span class="lineNum">   19359 </span><span class="lineCov">    6617062 :   if (! loc_descr)</span>
<span class="lineNum">   19360 </span>            :     {
<span class="lineNum">   19361 </span>            :       /* While DW_AT_data_bit_offset has been added already in DWARF4,
<span class="lineNum">   19362 </span>            :          e.g. GDB only added support to it in November 2016.  For DWARF5
<span class="lineNum">   19363 </span>            :          we need newer debug info consumers anyway.  We might change this
<span class="lineNum">   19364 </span>            :          to dwarf_version &gt;= 4 once most consumers catched up.  */
<span class="lineNum">   19365 </span><span class="lineCov">    6616783 :       if (dwarf_version &gt;= 5</span>
<span class="lineNum">   19366 </span><span class="lineCov">          7 :           &amp;&amp; TREE_CODE (decl) == FIELD_DECL</span>
<span class="lineNum">   19367 </span><span class="lineCov">    6616797 :           &amp;&amp; DECL_BIT_FIELD_TYPE (decl))</span>
<span class="lineNum">   19368 </span>            :         {
<span class="lineNum">   19369 </span><span class="lineNoCov">          0 :           tree off = bit_position (decl);</span>
<span class="lineNum">   19370 </span><span class="lineNoCov">          0 :           if (tree_fits_uhwi_p (off) &amp;&amp; get_AT (die, DW_AT_bit_size))</span>
<span class="lineNum">   19371 </span>            :             {
<span class="lineNum">   19372 </span><span class="lineNoCov">          0 :               remove_AT (die, DW_AT_byte_size);</span>
<span class="lineNum">   19373 </span><span class="lineNoCov">          0 :               remove_AT (die, DW_AT_bit_offset);</span>
<span class="lineNum">   19374 </span><span class="lineNoCov">          0 :               add_AT_unsigned (die, DW_AT_data_bit_offset, tree_to_uhwi (off));</span>
<span class="lineNum">   19375 </span><span class="lineCov">    6602725 :               return;</span>
<span class="lineNum">   19376 </span>            :             }
<span class="lineNum">   19377 </span>            :         }
<span class="lineNum">   19378 </span><span class="lineCov">    6616783 :       if (dwarf_version &gt; 2)</span>
<span class="lineNum">   19379 </span>            :         {
<span class="lineNum">   19380 </span>            :           /* Don't need to output a location expression, just the constant. */
<span class="lineNum">   19381 </span><span class="lineCov">    6602725 :           if (offset &lt; 0)</span>
<span class="lineNum">   19382 </span><span class="lineNoCov">          0 :             add_AT_int (die, DW_AT_data_member_location, offset);</span>
<span class="lineNum">   19383 </span>            :           else
<span class="lineNum">   19384 </span><span class="lineCov">    6602725 :             add_AT_unsigned (die, DW_AT_data_member_location, offset);</span>
<span class="lineNum">   19385 </span><span class="lineCov">    6602725 :           return;</span>
<span class="lineNum">   19386 </span>            :         }
<span class="lineNum">   19387 </span>            :       else
<span class="lineNum">   19388 </span>            :         {
<span class="lineNum">   19389 </span><span class="lineCov">      14058 :           enum dwarf_location_atom op;</span>
<span class="lineNum">   19390 </span>            : 
<span class="lineNum">   19391 </span>            :           /* The DWARF2 standard says that we should assume that the structure
<span class="lineNum">   19392 </span>            :              address is already on the stack, so we can specify a structure
<span class="lineNum">   19393 </span>            :              field address by using DW_OP_plus_uconst.  */
<span class="lineNum">   19394 </span><span class="lineCov">      14058 :           op = DW_OP_plus_uconst;</span>
<span class="lineNum">   19395 </span><span class="lineCov">      14058 :           loc_descr = new_loc_descr (op, offset, 0);</span>
<span class="lineNum">   19396 </span>            :         }
<span class="lineNum">   19397 </span>            :     }
<span class="lineNum">   19398 </span>            : 
<span class="lineNum">   19399 </span><span class="lineCov">      14337 :   add_AT_loc (die, DW_AT_data_member_location, loc_descr);</span>
<span class="lineNum">   19400 </span>            : }
<span class="lineNum">   19401 </span>            : 
<span class="lineNum">   19402 </span>            : /* Writes integer values to dw_vec_const array.  */
<a name="19403"><span class="lineNum">   19403 </span>            : </a>
<span class="lineNum">   19404 </span>            : static void
<span class="lineNum">   19405 </span><span class="lineNoCov">          0 : insert_int (HOST_WIDE_INT val, unsigned int size, unsigned char *dest)</span>
<span class="lineNum">   19406 </span>            : {
<span class="lineNum">   19407 </span><span class="lineCov">    1302457 :   while (size != 0)</span>
<span class="lineNum">   19408 </span>            :     {
<span class="lineNum">   19409 </span><span class="lineCov">    1041956 :       *dest++ = val &amp; 0xff;</span>
<span class="lineNum">   19410 </span><span class="lineCov">    1041956 :       val &gt;&gt;= 8;</span>
<span class="lineNum">   19411 </span><span class="lineCov">    1041956 :       --size;</span>
<span class="lineNum">   19412 </span>            :     }
<span class="lineNum">   19413 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   19414 </span>            : 
<span class="lineNum">   19415 </span>            : /* Reads integers from dw_vec_const array.  Inverse of insert_int.  */
<a name="19416"><span class="lineNum">   19416 </span>            : </a>
<span class="lineNum">   19417 </span>            : static HOST_WIDE_INT
<span class="lineNum">   19418 </span><span class="lineNoCov">          0 : extract_int (const unsigned char *src, unsigned int size)</span>
<span class="lineNum">   19419 </span>            : {
<span class="lineNum">   19420 </span><span class="lineCov">     635765 :   HOST_WIDE_INT val = 0;</span>
<span class="lineNum">   19421 </span>            : 
<span class="lineNum">   19422 </span><span class="lineCov">     635765 :   src += size;</span>
<span class="lineNum">   19423 </span><span class="lineCov">    2047362 :   while (size != 0)</span>
<span class="lineNum">   19424 </span>            :     {
<span class="lineNum">   19425 </span><span class="lineCov">    1411597 :       val &lt;&lt;= 8;</span>
<span class="lineNum">   19426 </span><span class="lineCov">    1411597 :       val |= *--src &amp; 0xff;</span>
<span class="lineNum">   19427 </span><span class="lineCov">    1411597 :       --size;</span>
<span class="lineNum">   19428 </span>            :     }
<span class="lineNum">   19429 </span><span class="lineCov">     635765 :   return val;</span>
<span class="lineNum">   19430 </span>            : }
<span class="lineNum">   19431 </span>            : 
<span class="lineNum">   19432 </span>            : /* Writes wide_int values to dw_vec_const array.  */
<a name="19433"><span class="lineNum">   19433 </span>            : </a>
<span class="lineNum">   19434 </span>            : static void
<span class="lineNum">   19435 </span><span class="lineCov">         60 : insert_wide_int (const wide_int &amp;val, unsigned char *dest, int elt_size)</span>
<span class="lineNum">   19436 </span>            : {
<span class="lineNum">   19437 </span><span class="lineCov">         60 :   int i;</span>
<span class="lineNum">   19438 </span>            : 
<span class="lineNum">   19439 </span><span class="lineCov">         60 :   if (elt_size &lt;= HOST_BITS_PER_WIDE_INT/BITS_PER_UNIT)</span>
<span class="lineNum">   19440 </span>            :     {
<span class="lineNum">   19441 </span><span class="lineCov">         56 :       insert_int ((HOST_WIDE_INT) val.elt (0), elt_size, dest);</span>
<span class="lineNum">   19442 </span>            :       return;
<span class="lineNum">   19443 </span>            :     }
<span class="lineNum">   19444 </span>            : 
<span class="lineNum">   19445 </span>            :   /* We'd have to extend this code to support odd sizes.  */
<span class="lineNum">   19446 </span><span class="lineCov">          4 :   gcc_assert (elt_size % (HOST_BITS_PER_WIDE_INT / BITS_PER_UNIT) == 0);</span>
<span class="lineNum">   19447 </span>            : 
<span class="lineNum">   19448 </span><span class="lineCov">          4 :   int n = elt_size / (HOST_BITS_PER_WIDE_INT / BITS_PER_UNIT);</span>
<span class="lineNum">   19449 </span>            : 
<span class="lineNum">   19450 </span><span class="lineCov">          4 :   if (WORDS_BIG_ENDIAN)</span>
<span class="lineNum">   19451 </span>            :     for (i = n - 1; i &gt;= 0; i--)
<span class="lineNum">   19452 </span>            :       {
<span class="lineNum">   19453 </span>            :         insert_int ((HOST_WIDE_INT) val.elt (i), sizeof (HOST_WIDE_INT), dest);
<span class="lineNum">   19454 </span>            :         dest += sizeof (HOST_WIDE_INT);
<span class="lineNum">   19455 </span>            :       }
<span class="lineNum">   19456 </span>            :   else
<span class="lineNum">   19457 </span><span class="lineCov">         12 :     for (i = 0; i &lt; n; i++)</span>
<span class="lineNum">   19458 </span>            :       {
<span class="lineNum">   19459 </span><span class="lineCov">          8 :         insert_int ((HOST_WIDE_INT) val.elt (i), sizeof (HOST_WIDE_INT), dest);</span>
<span class="lineNum">   19460 </span><span class="lineCov">          8 :         dest += sizeof (HOST_WIDE_INT);</span>
<span class="lineNum">   19461 </span>            :       }
<span class="lineNum">   19462 </span>            : }
<span class="lineNum">   19463 </span>            : 
<span class="lineNum">   19464 </span>            : /* Writes floating point values to dw_vec_const array.  */
<a name="19465"><span class="lineNum">   19465 </span>            : </a>
<span class="lineNum">   19466 </span>            : static void
<span class="lineNum">   19467 </span><span class="lineCov">     100652 : insert_float (const_rtx rtl, unsigned char *array)</span>
<span class="lineNum">   19468 </span>            : {
<span class="lineNum">   19469 </span><span class="lineCov">     100652 :   long val[4];</span>
<span class="lineNum">   19470 </span><span class="lineCov">     100652 :   int i;</span>
<span class="lineNum">   19471 </span><span class="lineCov">     100652 :   scalar_float_mode mode = as_a &lt;scalar_float_mode&gt; (GET_MODE (rtl));</span>
<span class="lineNum">   19472 </span>            : 
<span class="lineNum">   19473 </span><span class="lineCov">     100652 :   real_to_target (val, CONST_DOUBLE_REAL_VALUE (rtl), mode);</span>
<span class="lineNum">   19474 </span>            : 
<span class="lineNum">   19475 </span>            :   /* real_to_target puts 32-bit pieces in each long.  Pack them.  */
<span class="lineNum">   19476 </span><span class="lineCov">     722178 :   for (i = 0; i &lt; GET_MODE_SIZE (mode) / 4; i++)</span>
<span class="lineNum">   19477 </span>            :     {
<span class="lineNum">   19478 </span><span class="lineCov">     260437 :       insert_int (val[i], 4, array);</span>
<span class="lineNum">   19479 </span><span class="lineCov">     260437 :       array += 4;</span>
<span class="lineNum">   19480 </span>            :     }
<span class="lineNum">   19481 </span><span class="lineCov">     100652 : }</span>
<span class="lineNum">   19482 </span>            : 
<span class="lineNum">   19483 </span>            : /* Attach a DW_AT_const_value attribute for a variable or a parameter which
<span class="lineNum">   19484 </span>            :    does not have a &quot;location&quot; either in memory or in a register.  These
<span class="lineNum">   19485 </span>            :    things can arise in GNU C when a constant is passed as an actual parameter
<span class="lineNum">   19486 </span>            :    to an inlined function.  They can also arise in C++ where declared
<span class="lineNum">   19487 </span>            :    constants do not necessarily get memory &quot;homes&quot;.  */
<a name="19488"><span class="lineNum">   19488 </span>            : </a>
<span class="lineNum">   19489 </span>            : static bool
<span class="lineNum">   19490 </span><span class="lineCov">      49023 : add_const_value_attribute (dw_die_ref die, rtx rtl)</span>
<span class="lineNum">   19491 </span>            : {
<span class="lineNum">   19492 </span><span class="lineCov">      49023 :   switch (GET_CODE (rtl))</span>
<span class="lineNum">   19493 </span>            :     {
<span class="lineNum">   19494 </span><span class="lineCov">      31035 :     case CONST_INT:</span>
<span class="lineNum">   19495 </span><span class="lineCov">      31035 :       {</span>
<span class="lineNum">   19496 </span><span class="lineCov">      31035 :         HOST_WIDE_INT val = INTVAL (rtl);</span>
<span class="lineNum">   19497 </span>            : 
<span class="lineNum">   19498 </span><span class="lineCov">      31035 :         if (val &lt; 0)</span>
<span class="lineNum">   19499 </span><span class="lineCov">        601 :           add_AT_int (die, DW_AT_const_value, val);</span>
<span class="lineNum">   19500 </span>            :         else
<span class="lineNum">   19501 </span><span class="lineCov">      30434 :           add_AT_unsigned (die, DW_AT_const_value, (unsigned HOST_WIDE_INT) val);</span>
<span class="lineNum">   19502 </span>            :       }
<span class="lineNum">   19503 </span>            :       return true;
<span class="lineNum">   19504 </span>            : 
<span class="lineNum">   19505 </span><span class="lineCov">          8 :     case CONST_WIDE_INT:</span>
<span class="lineNum">   19506 </span><span class="lineCov">          8 :       {</span>
<span class="lineNum">   19507 </span><span class="lineCov">         16 :         wide_int w1 = rtx_mode_t (rtl, MAX_MODE_INT);</span>
<span class="lineNum">   19508 </span><span class="lineCov">          8 :         unsigned int prec = MIN (wi::min_precision (w1, UNSIGNED),</span>
<span class="lineNum">   19509 </span>            :                                  (unsigned int)CONST_WIDE_INT_NUNITS (rtl) * HOST_BITS_PER_WIDE_INT);
<span class="lineNum">   19510 </span><span class="lineCov">          8 :         wide_int w = wi::zext (w1, prec);</span>
<span class="lineNum">   19511 </span><span class="lineCov">          8 :         add_AT_wide (die, DW_AT_const_value, w);</span>
<span class="lineNum">   19512 </span>            :       }
<span class="lineNum">   19513 </span><span class="lineCov">          8 :       return true;</span>
<span class="lineNum">   19514 </span>            : 
<span class="lineNum">   19515 </span><span class="lineCov">       6721 :     case CONST_DOUBLE:</span>
<span class="lineNum">   19516 </span>            :       /* Note that a CONST_DOUBLE rtx could represent either an integer or a
<span class="lineNum">   19517 </span>            :          floating-point constant.  A CONST_DOUBLE is used whenever the
<span class="lineNum">   19518 </span>            :          constant requires more than one word in order to be adequately
<span class="lineNum">   19519 </span>            :          represented.  */
<span class="lineNum">   19520 </span><span class="lineCov">       6721 :       if (TARGET_SUPPORTS_WIDE_INT == 0</span>
<span class="lineNum">   19521 </span>            :           &amp;&amp; !SCALAR_FLOAT_MODE_P (GET_MODE (rtl)))
<span class="lineNum">   19522 </span>            :         add_AT_double (die, DW_AT_const_value,
<span class="lineNum">   19523 </span>            :                        CONST_DOUBLE_HIGH (rtl), CONST_DOUBLE_LOW (rtl));
<span class="lineNum">   19524 </span>            :       else
<span class="lineNum">   19525 </span>            :         {
<span class="lineNum">   19526 </span><span class="lineCov">       6721 :           scalar_float_mode mode = as_a &lt;scalar_float_mode&gt; (GET_MODE (rtl));</span>
<span class="lineNum">   19527 </span><span class="lineCov">       6721 :           unsigned int length = GET_MODE_SIZE (mode);</span>
<span class="lineNum">   19528 </span><span class="lineCov">       6721 :           unsigned char *array = ggc_vec_alloc&lt;unsigned char&gt; (length);</span>
<span class="lineNum">   19529 </span>            : 
<span class="lineNum">   19530 </span><span class="lineCov">       6721 :           insert_float (rtl, array);</span>
<span class="lineNum">   19531 </span><span class="lineCov">       6721 :           add_AT_vec (die, DW_AT_const_value, length / 4, 4, array);</span>
<span class="lineNum">   19532 </span>            :         }
<span class="lineNum">   19533 </span><span class="lineCov">       6721 :       return true;</span>
<span class="lineNum">   19534 </span>            : 
<span class="lineNum">   19535 </span><span class="lineCov">         20 :     case CONST_VECTOR:</span>
<span class="lineNum">   19536 </span><span class="lineCov">         20 :       {</span>
<span class="lineNum">   19537 </span><span class="lineCov">         20 :         unsigned int length;</span>
<span class="lineNum">   19538 </span><span class="lineCov">         40 :         if (!CONST_VECTOR_NUNITS (rtl).is_constant (&amp;length))</span>
<span class="lineNum">   19539 </span>            :           return false;
<span class="lineNum">   19540 </span>            : 
<span class="lineNum">   19541 </span><span class="lineCov">         20 :         machine_mode mode = GET_MODE (rtl);</span>
<span class="lineNum">   19542 </span><span class="lineCov">         20 :         unsigned int elt_size = GET_MODE_UNIT_SIZE (mode);</span>
<span class="lineNum">   19543 </span><span class="lineCov">         20 :         unsigned char *array</span>
<span class="lineNum">   19544 </span><span class="lineCov">         20 :           = ggc_vec_alloc&lt;unsigned char&gt; (length * elt_size);</span>
<span class="lineNum">   19545 </span><span class="lineCov">         20 :         unsigned int i;</span>
<span class="lineNum">   19546 </span><span class="lineCov">         20 :         unsigned char *p;</span>
<span class="lineNum">   19547 </span><span class="lineCov">         40 :         machine_mode imode = GET_MODE_INNER (mode);</span>
<span class="lineNum">   19548 </span>            : 
<span class="lineNum">   19549 </span><span class="lineCov">         20 :         switch (GET_MODE_CLASS (mode))</span>
<span class="lineNum">   19550 </span>            :           {
<span class="lineNum">   19551 </span>            :           case MODE_VECTOR_INT:
<span class="lineNum">   19552 </span><span class="lineCov">         46 :             for (i = 0, p = array; i &lt; length; i++, p += elt_size)</span>
<span class="lineNum">   19553 </span>            :               {
<span class="lineNum">   19554 </span><span class="lineCov">         40 :                 rtx elt = CONST_VECTOR_ELT (rtl, i);</span>
<span class="lineNum">   19555 </span><span class="lineCov">         80 :                 insert_wide_int (rtx_mode_t (elt, imode), p, elt_size);</span>
<span class="lineNum">   19556 </span><span class="lineCov">          6 :               }</span>
<span class="lineNum">   19557 </span>            :             break;
<span class="lineNum">   19558 </span>            : 
<span class="lineNum">   19559 </span>            :           case MODE_VECTOR_FLOAT:
<span class="lineNum">   19560 </span><span class="lineCov">         68 :             for (i = 0, p = array; i &lt; length; i++, p += elt_size)</span>
<span class="lineNum">   19561 </span>            :               {
<span class="lineNum">   19562 </span><span class="lineCov">         54 :                 rtx elt = CONST_VECTOR_ELT (rtl, i);</span>
<span class="lineNum">   19563 </span><span class="lineCov">         54 :                 insert_float (elt, p);</span>
<span class="lineNum">   19564 </span><span class="lineCov">         14 :               }</span>
<span class="lineNum">   19565 </span>            :             break;
<span class="lineNum">   19566 </span>            : 
<span class="lineNum">   19567 </span><span class="lineNoCov">          0 :           default:</span>
<span class="lineNum">   19568 </span><span class="lineNoCov">          0 :             gcc_unreachable ();</span>
<span class="lineNum">   19569 </span>            :           }
<span class="lineNum">   19570 </span>            : 
<span class="lineNum">   19571 </span><span class="lineCov">         20 :         add_AT_vec (die, DW_AT_const_value, length, elt_size, array);</span>
<span class="lineNum">   19572 </span>            :       }
<span class="lineNum">   19573 </span><span class="lineCov">         20 :       return true;</span>
<span class="lineNum">   19574 </span>            : 
<span class="lineNum">   19575 </span><span class="lineCov">        908 :     case CONST_STRING:</span>
<span class="lineNum">   19576 </span><span class="lineCov">        908 :       if (dwarf_version &gt;= 4 || !dwarf_strict)</span>
<span class="lineNum">   19577 </span>            :         {
<span class="lineNum">   19578 </span><span class="lineCov">        908 :           dw_loc_descr_ref loc_result;</span>
<span class="lineNum">   19579 </span><span class="lineCov">        908 :           resolve_one_addr (&amp;rtl);</span>
<span class="lineNum">   19580 </span><span class="lineCov">       8495 :         rtl_addr:</span>
<span class="lineNum">   19581 </span><span class="lineCov">       8495 :           loc_result = new_addr_loc_descr (rtl, dtprel_false);</span>
<span class="lineNum">   19582 </span><span class="lineCov">       8495 :           add_loc_descr (&amp;loc_result, new_loc_descr (DW_OP_stack_value, 0, 0));</span>
<span class="lineNum">   19583 </span><span class="lineCov">       8495 :           add_AT_loc (die, DW_AT_location, loc_result);</span>
<span class="lineNum">   19584 </span><span class="lineCov">       8495 :           vec_safe_push (used_rtx_array, rtl);</span>
<span class="lineNum">   19585 </span><span class="lineCov">       8495 :           return true;</span>
<span class="lineNum">   19586 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">   19587 </span>            :       return false;
<span class="lineNum">   19588 </span>            : 
<span class="lineNum">   19589 </span><span class="lineCov">        359 :     case CONST:</span>
<span class="lineNum">   19590 </span><span class="lineCov">        359 :       if (CONSTANT_P (XEXP (rtl, 0)))</span>
<span class="lineNum">   19591 </span><span class="lineNoCov">          0 :         return add_const_value_attribute (die, XEXP (rtl, 0));</span>
<span class="lineNum">   19592 </span>            :       /* FALLTHROUGH */
<span class="lineNum">   19593 </span><span class="lineCov">       9301 :     case SYMBOL_REF:</span>
<span class="lineNum">   19594 </span><span class="lineCov">       9301 :       if (!const_ok_for_output (rtl))</span>
<span class="lineNum">   19595 </span>            :         return false;
<span class="lineNum">   19596 </span>            :       /* FALLTHROUGH */
<span class="lineNum">   19597 </span><span class="lineCov">       7587 :     case LABEL_REF:</span>
<span class="lineNum">   19598 </span><span class="lineCov">       7587 :       if (dwarf_version &gt;= 4 || !dwarf_strict)</span>
<span class="lineNum">   19599 </span>            :         goto rtl_addr;
<span class="lineNum">   19600 </span>            :       return false;
<span class="lineNum">   19601 </span>            : 
<span class="lineNum">   19602 </span>            :     case PLUS:
<span class="lineNum">   19603 </span>            :       /* In cases where an inlined instance of an inline function is passed
<span class="lineNum">   19604 </span>            :          the address of an `auto' variable (which is local to the caller) we
<span class="lineNum">   19605 </span>            :          can get a situation where the DECL_RTL of the artificial local
<span class="lineNum">   19606 </span>            :          variable (for the inlining) which acts as a stand-in for the
<span class="lineNum">   19607 </span>            :          corresponding formal parameter (of the inline function) will look
<span class="lineNum">   19608 </span>            :          like (plus:SI (reg:SI FRAME_PTR) (const_int ...)).  This is not
<span class="lineNum">   19609 </span>            :          exactly a compile-time constant expression, but it isn't the address
<span class="lineNum">   19610 </span>            :          of the (artificial) local variable either.  Rather, it represents the
<span class="lineNum">   19611 </span>            :          *value* which the artificial local variable always has during its
<span class="lineNum">   19612 </span>            :          lifetime.  We currently have no way to represent such quasi-constant
<span class="lineNum">   19613 </span>            :          values in Dwarf, so for now we just punt and generate nothing.  */
<span class="lineNum">   19614 </span>            :       return false;
<span class="lineNum">   19615 </span>            : 
<span class="lineNum">   19616 </span>            :     case HIGH:
<span class="lineNum">   19617 </span>            :     case CONST_FIXED:
<span class="lineNum">   19618 </span>            :       return false;
<span class="lineNum">   19619 </span>            : 
<span class="lineNum">   19620 </span><span class="lineCov">       1030 :     case MEM:</span>
<span class="lineNum">   19621 </span><span class="lineCov">       1030 :       if (GET_CODE (XEXP (rtl, 0)) == CONST_STRING</span>
<span class="lineNum">   19622 </span><span class="lineCov">       1030 :           &amp;&amp; MEM_READONLY_P (rtl)</span>
<span class="lineNum">   19623 </span><span class="lineCov">       2060 :           &amp;&amp; GET_MODE (rtl) == BLKmode)</span>
<span class="lineNum">   19624 </span>            :         {
<span class="lineNum">   19625 </span><span class="lineCov">       1030 :           add_AT_string (die, DW_AT_const_value, XSTR (XEXP (rtl, 0), 0));</span>
<span class="lineNum">   19626 </span><span class="lineCov">       1030 :           return true;</span>
<span class="lineNum">   19627 </span>            :         }
<span class="lineNum">   19628 </span>            :       return false;
<span class="lineNum">   19629 </span>            : 
<span class="lineNum">   19630 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">   19631 </span>            :       /* No other kinds of rtx should be possible here.  */
<span class="lineNum">   19632 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">   19633 </span>            :     }
<span class="lineNum">   19634 </span>            :   return false;
<span class="lineNum">   19635 </span>            : }
<span class="lineNum">   19636 </span>            : 
<span class="lineNum">   19637 </span>            : /* Determine whether the evaluation of EXPR references any variables
<span class="lineNum">   19638 </span>            :    or functions which aren't otherwise used (and therefore may not be
<a name="19639"><span class="lineNum">   19639 </span>            :    output).  */</a>
<span class="lineNum">   19640 </span>            : static tree
<span class="lineNum">   19641 </span><span class="lineCov">       5530 : reference_to_unused (tree * tp, int * walk_subtrees,</span>
<span class="lineNum">   19642 </span>            :                      void * data ATTRIBUTE_UNUSED)
<span class="lineNum">   19643 </span>            : {
<span class="lineNum">   19644 </span><span class="lineCov">       5530 :   if (! EXPR_P (*tp) &amp;&amp; ! CONSTANT_CLASS_P (*tp))</span>
<span class="lineNum">   19645 </span><span class="lineCov">       1010 :     *walk_subtrees = 0;</span>
<span class="lineNum">   19646 </span>            : 
<span class="lineNum">   19647 </span><span class="lineCov">       5530 :   if (DECL_P (*tp) &amp;&amp; ! TREE_PUBLIC (*tp) &amp;&amp; ! TREE_USED (*tp)</span>
<span class="lineNum">   19648 </span><span class="lineCov">       1010 :       &amp;&amp; ! TREE_ASM_WRITTEN (*tp))</span>
<span class="lineNum">   19649 </span>            :     return *tp;
<span class="lineNum">   19650 </span>            :   /* ???  The C++ FE emits debug information for using decls, so
<span class="lineNum">   19651 </span>            :      putting gcc_unreachable here falls over.  See PR31899.  For now
<span class="lineNum">   19652 </span>            :      be conservative.  */
<span class="lineNum">   19653 </span><span class="lineCov">       5527 :   else if (!symtab-&gt;global_info_ready &amp;&amp; VAR_OR_FUNCTION_DECL_P (*tp))</span>
<span class="lineNum">   19654 </span>            :     return *tp;
<span class="lineNum">   19655 </span><span class="lineCov">       4618 :   else if (VAR_P (*tp))</span>
<span class="lineNum">   19656 </span>            :     {
<span class="lineNum">   19657 </span><span class="lineCov">         10 :       varpool_node *node = varpool_node::get (*tp);</span>
<span class="lineNum">   19658 </span><span class="lineCov">         10 :       if (!node || !node-&gt;definition)</span>
<span class="lineNum">   19659 </span><span class="lineNoCov">          0 :         return *tp;</span>
<span class="lineNum">   19660 </span>            :     }
<span class="lineNum">   19661 </span><span class="lineCov">       4608 :   else if (TREE_CODE (*tp) == FUNCTION_DECL</span>
<span class="lineNum">   19662 </span><span class="lineCov">       4608 :            &amp;&amp; (!DECL_EXTERNAL (*tp) || DECL_DECLARED_INLINE_P (*tp)))</span>
<span class="lineNum">   19663 </span>            :     {
<span class="lineNum">   19664 </span>            :       /* The call graph machinery must have finished analyzing,
<span class="lineNum">   19665 </span>            :          optimizing and gimplifying the CU by now.
<span class="lineNum">   19666 </span>            :          So if *TP has no call graph node associated
<span class="lineNum">   19667 </span>            :          to it, it means *TP will not be emitted.  */
<span class="lineNum">   19668 </span><span class="lineCov">         88 :       if (!cgraph_node::get (*tp))</span>
<span class="lineNum">   19669 </span><span class="lineCov">         56 :         return *tp;</span>
<span class="lineNum">   19670 </span>            :     }
<span class="lineNum">   19671 </span><span class="lineCov">       4520 :   else if (TREE_CODE (*tp) == STRING_CST &amp;&amp; !TREE_ASM_WRITTEN (*tp))</span>
<span class="lineNum">   19672 </span><span class="lineCov">         25 :     return *tp;</span>
<span class="lineNum">   19673 </span>            : 
<span class="lineNum">   19674 </span>            :   return NULL_TREE;
<span class="lineNum">   19675 </span>            : }
<span class="lineNum">   19676 </span>            : 
<span class="lineNum">   19677 </span>            : /* Generate an RTL constant from a decl initializer INIT with decl type TYPE,
<span class="lineNum">   19678 </span>            :    for use in a later add_const_value_attribute call.  */
<a name="19679"><span class="lineNum">   19679 </span>            : </a>
<span class="lineNum">   19680 </span>            : static rtx
<span class="lineNum">   19681 </span><span class="lineCov">       6894 : rtl_for_decl_init (tree init, tree type)</span>
<span class="lineNum">   19682 </span>            : {
<span class="lineNum">   19683 </span><span class="lineCov">       6894 :   rtx rtl = NULL_RTX;</span>
<span class="lineNum">   19684 </span>            : 
<span class="lineNum">   19685 </span><span class="lineCov">       6894 :   STRIP_NOPS (init);</span>
<span class="lineNum">   19686 </span>            : 
<span class="lineNum">   19687 </span>            :   /* If a variable is initialized with a string constant without embedded
<span class="lineNum">   19688 </span>            :      zeros, build CONST_STRING.  */
<span class="lineNum">   19689 </span><span class="lineCov">       6894 :   if (TREE_CODE (init) == STRING_CST &amp;&amp; TREE_CODE (type) == ARRAY_TYPE)</span>
<span class="lineNum">   19690 </span>            :     {
<span class="lineNum">   19691 </span><span class="lineCov">       1703 :       tree enttype = TREE_TYPE (type);</span>
<span class="lineNum">   19692 </span><span class="lineCov">       1703 :       tree domain = TYPE_DOMAIN (type);</span>
<span class="lineNum">   19693 </span><span class="lineCov">       1703 :       scalar_int_mode mode;</span>
<span class="lineNum">   19694 </span>            : 
<span class="lineNum">   19695 </span><span class="lineCov">       1703 :       if (is_int_mode (TYPE_MODE (enttype), &amp;mode)</span>
<span class="lineNum">   19696 </span><span class="lineCov">       3406 :           &amp;&amp; GET_MODE_SIZE (mode) == 1</span>
<span class="lineNum">   19697 </span><span class="lineCov">       1693 :           &amp;&amp; domain</span>
<span class="lineNum">   19698 </span><span class="lineCov">       1693 :           &amp;&amp; TYPE_MAX_VALUE (domain)</span>
<span class="lineNum">   19699 </span><span class="lineCov">       1661 :           &amp;&amp; TREE_CODE (TYPE_MAX_VALUE (domain)) == INTEGER_CST</span>
<span class="lineNum">   19700 </span><span class="lineCov">       1661 :           &amp;&amp; integer_zerop (TYPE_MIN_VALUE (domain))</span>
<span class="lineNum">   19701 </span><span class="lineCov">       1655 :           &amp;&amp; compare_tree_int (TYPE_MAX_VALUE (domain),</span>
<span class="lineNum">   19702 </span><span class="lineCov">       1655 :                                TREE_STRING_LENGTH (init) - 1) == 0</span>
<span class="lineNum">   19703 </span><span class="lineCov">       1649 :           &amp;&amp; ((size_t) TREE_STRING_LENGTH (init)</span>
<span class="lineNum">   19704 </span><span class="lineCov">       3298 :               == strlen (TREE_STRING_POINTER (init)) + 1))</span>
<span class="lineNum">   19705 </span>            :         {
<span class="lineNum">   19706 </span><span class="lineCov">       3224 :           rtl = gen_rtx_CONST_STRING (VOIDmode,</span>
<span class="lineNum">   19707 </span>            :                                       ggc_strdup (TREE_STRING_POINTER (init)));
<span class="lineNum">   19708 </span><span class="lineCov">       1612 :           rtl = gen_rtx_MEM (BLKmode, rtl);</span>
<span class="lineNum">   19709 </span><span class="lineCov">       1612 :           MEM_READONLY_P (rtl) = 1;</span>
<span class="lineNum">   19710 </span>            :         }
<span class="lineNum">   19711 </span>            :     }
<span class="lineNum">   19712 </span>            :   /* Other aggregates, and complex values, could be represented using
<span class="lineNum">   19713 </span>            :      CONCAT: FIXME!  */
<span class="lineNum">   19714 </span><span class="lineCov">       5191 :   else if (AGGREGATE_TYPE_P (type)</span>
<span class="lineNum">   19715 </span><span class="lineCov">       4490 :            || (TREE_CODE (init) == VIEW_CONVERT_EXPR</span>
<span class="lineNum">   19716 </span><span class="lineNoCov">          0 :                &amp;&amp; AGGREGATE_TYPE_P (TREE_TYPE (TREE_OPERAND (init, 0))))</span>
<span class="lineNum">   19717 </span><span class="lineCov">       9681 :            || TREE_CODE (type) == COMPLEX_TYPE)</span>
<span class="lineNum">   19718 </span>            :     ;
<span class="lineNum">   19719 </span>            :   /* Vectors only work if their mode is supported by the target.
<span class="lineNum">   19720 </span>            :      FIXME: generic vectors ought to work too.  */
<span class="lineNum">   19721 </span><span class="lineCov">       4473 :   else if (TREE_CODE (type) == VECTOR_TYPE</span>
<span class="lineNum">   19722 </span><span class="lineCov">       4473 :            &amp;&amp; !VECTOR_MODE_P (TYPE_MODE (type)))</span>
<span class="lineNum">   19723 </span>            :     ;
<span class="lineNum">   19724 </span>            :   /* If the initializer is something that we know will expand into an
<span class="lineNum">   19725 </span>            :      immediate RTL constant, expand it now.  We must be careful not to
<span class="lineNum">   19726 </span>            :      reference variables which won't be output.  */
<span class="lineNum">   19727 </span><span class="lineCov">       4468 :   else if (initializer_constant_valid_p (init, type)</span>
<span class="lineNum">   19728 </span><span class="lineCov">       4468 :            &amp;&amp; ! walk_tree (&amp;init, reference_to_unused, NULL, NULL))</span>
<span class="lineNum">   19729 </span>            :     {
<span class="lineNum">   19730 </span>            :       /* Convert vector CONSTRUCTOR initializers to VECTOR_CST if
<span class="lineNum">   19731 </span>            :          possible.  */
<span class="lineNum">   19732 </span><span class="lineCov">       3474 :       if (TREE_CODE (type) == VECTOR_TYPE)</span>
<span class="lineNum">   19733 </span><span class="lineCov">         20 :         switch (TREE_CODE (init))</span>
<span class="lineNum">   19734 </span>            :           {
<span class="lineNum">   19735 </span>            :           case VECTOR_CST:
<span class="lineNum">   19736 </span>            :             break;
<span class="lineNum">   19737 </span><span class="lineNoCov">          0 :           case CONSTRUCTOR:</span>
<span class="lineNum">   19738 </span><span class="lineNoCov">          0 :             if (TREE_CONSTANT (init))</span>
<span class="lineNum">   19739 </span>            :               {
<span class="lineNum">   19740 </span><span class="lineNoCov">          0 :                 vec&lt;constructor_elt, va_gc&gt; *elts = CONSTRUCTOR_ELTS (init);</span>
<span class="lineNum">   19741 </span><span class="lineNoCov">          0 :                 bool constant_p = true;</span>
<span class="lineNum">   19742 </span><span class="lineNoCov">          0 :                 tree value;</span>
<span class="lineNum">   19743 </span><span class="lineNoCov">          0 :                 unsigned HOST_WIDE_INT ix;</span>
<span class="lineNum">   19744 </span>            : 
<span class="lineNum">   19745 </span>            :                 /* Even when ctor is constant, it might contain non-*_CST
<span class="lineNum">   19746 </span>            :                    elements (e.g. { 1.0/0.0 - 1.0/0.0, 0.0 }) and those don't
<span class="lineNum">   19747 </span>            :                    belong into VECTOR_CST nodes.  */
<span class="lineNum">   19748 </span><span class="lineNoCov">          0 :                 FOR_EACH_CONSTRUCTOR_VALUE (elts, ix, value)</span>
<span class="lineNum">   19749 </span><span class="lineNoCov">          0 :                   if (!CONSTANT_CLASS_P (value))</span>
<span class="lineNum">   19750 </span>            :                     {
<span class="lineNum">   19751 </span>            :                       constant_p = false;
<span class="lineNum">   19752 </span>            :                       break;
<span class="lineNum">   19753 </span>            :                     }
<span class="lineNum">   19754 </span>            : 
<span class="lineNum">   19755 </span><span class="lineNoCov">          0 :                 if (constant_p)</span>
<span class="lineNum">   19756 </span>            :                   {
<span class="lineNum">   19757 </span><span class="lineNoCov">          0 :                     init = build_vector_from_ctor (type, elts);</span>
<span class="lineNum">   19758 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">   19759 </span>            :                   }
<span class="lineNum">   19760 </span>            :               }
<span class="lineNum">   19761 </span>            :             /* FALLTHRU */
<span class="lineNum">   19762 </span>            : 
<span class="lineNum">   19763 </span><span class="lineNoCov">          0 :           default:</span>
<span class="lineNum">   19764 </span><span class="lineNoCov">          0 :             return NULL;</span>
<span class="lineNum">   19765 </span>            :           }
<span class="lineNum">   19766 </span>            : 
<span class="lineNum">   19767 </span><span class="lineCov">       3474 :       rtl = expand_expr (init, NULL_RTX, VOIDmode, EXPAND_INITIALIZER);</span>
<span class="lineNum">   19768 </span>            : 
<span class="lineNum">   19769 </span>            :       /* If expand_expr returns a MEM, it wasn't immediate.  */
<span class="lineNum">   19770 </span><span class="lineCov">       3474 :       gcc_assert (!rtl || !MEM_P (rtl));</span>
<span class="lineNum">   19771 </span>            :     }
<span class="lineNum">   19772 </span>            : 
<span class="lineNum">   19773 </span>            :   return rtl;
<span class="lineNum">   19774 </span>            : }
<span class="lineNum">   19775 </span>            : 
<span class="lineNum">   19776 </span>            : /* Generate RTL for the variable DECL to represent its location.  */
<a name="19777"><span class="lineNum">   19777 </span>            : </a>
<span class="lineNum">   19778 </span>            : static rtx
<span class="lineNum">   19779 </span><span class="lineCov">    9033648 : rtl_for_decl_location (tree decl)</span>
<span class="lineNum">   19780 </span>            : {
<span class="lineNum">   19781 </span><span class="lineCov">    9033648 :   rtx rtl;</span>
<span class="lineNum">   19782 </span>            : 
<span class="lineNum">   19783 </span>            :   /* Here we have to decide where we are going to say the parameter &quot;lives&quot;
<span class="lineNum">   19784 </span>            :      (as far as the debugger is concerned).  We only have a couple of
<span class="lineNum">   19785 </span>            :      choices.  GCC provides us with DECL_RTL and with DECL_INCOMING_RTL.
<span class="lineNum">   19786 </span>            : 
<span class="lineNum">   19787 </span>            :      DECL_RTL normally indicates where the parameter lives during most of the
<span class="lineNum">   19788 </span>            :      activation of the function.  If optimization is enabled however, this
<span class="lineNum">   19789 </span>            :      could be either NULL or else a pseudo-reg.  Both of those cases indicate
<span class="lineNum">   19790 </span>            :      that the parameter doesn't really live anywhere (as far as the code
<span class="lineNum">   19791 </span>            :      generation parts of GCC are concerned) during most of the function's
<span class="lineNum">   19792 </span>            :      activation.  That will happen (for example) if the parameter is never
<span class="lineNum">   19793 </span>            :      referenced within the function.
<span class="lineNum">   19794 </span>            : 
<span class="lineNum">   19795 </span>            :      We could just generate a location descriptor here for all non-NULL
<span class="lineNum">   19796 </span>            :      non-pseudo values of DECL_RTL and ignore all of the rest, but we can be
<span class="lineNum">   19797 </span>            :      a little nicer than that if we also consider DECL_INCOMING_RTL in cases
<span class="lineNum">   19798 </span>            :      where DECL_RTL is NULL or is a pseudo-reg.
<span class="lineNum">   19799 </span>            : 
<span class="lineNum">   19800 </span>            :      Note however that we can only get away with using DECL_INCOMING_RTL as
<span class="lineNum">   19801 </span>            :      a backup substitute for DECL_RTL in certain limited cases.  In cases
<span class="lineNum">   19802 </span>            :      where DECL_ARG_TYPE (decl) indicates the same type as TREE_TYPE (decl),
<span class="lineNum">   19803 </span>            :      we can be sure that the parameter was passed using the same type as it is
<span class="lineNum">   19804 </span>            :      declared to have within the function, and that its DECL_INCOMING_RTL
<span class="lineNum">   19805 </span>            :      points us to a place where a value of that type is passed.
<span class="lineNum">   19806 </span>            : 
<span class="lineNum">   19807 </span>            :      In cases where DECL_ARG_TYPE (decl) and TREE_TYPE (decl) are different,
<span class="lineNum">   19808 </span>            :      we cannot (in general) use DECL_INCOMING_RTL as a substitute for DECL_RTL
<span class="lineNum">   19809 </span>            :      because in these cases DECL_INCOMING_RTL points us to a value of some
<span class="lineNum">   19810 </span>            :      type which is *different* from the type of the parameter itself.  Thus,
<span class="lineNum">   19811 </span>            :      if we tried to use DECL_INCOMING_RTL to generate a location attribute in
<span class="lineNum">   19812 </span>            :      such cases, the debugger would end up (for example) trying to fetch a
<span class="lineNum">   19813 </span>            :      `float' from a place which actually contains the first part of a
<span class="lineNum">   19814 </span>            :      `double'.  That would lead to really incorrect and confusing
<span class="lineNum">   19815 </span>            :      output at debug-time.
<span class="lineNum">   19816 </span>            : 
<span class="lineNum">   19817 </span>            :      So, in general, we *do not* use DECL_INCOMING_RTL as a backup for DECL_RTL
<span class="lineNum">   19818 </span>            :      in cases where DECL_ARG_TYPE (decl) != TREE_TYPE (decl).  There
<span class="lineNum">   19819 </span>            :      are a couple of exceptions however.  On little-endian machines we can
<span class="lineNum">   19820 </span>            :      get away with using DECL_INCOMING_RTL even when DECL_ARG_TYPE (decl) is
<span class="lineNum">   19821 </span>            :      not the same as TREE_TYPE (decl), but only when DECL_ARG_TYPE (decl) is
<span class="lineNum">   19822 </span>            :      an integral type that is smaller than TREE_TYPE (decl). These cases arise
<span class="lineNum">   19823 </span>            :      when (on a little-endian machine) a non-prototyped function has a
<span class="lineNum">   19824 </span>            :      parameter declared to be of type `short' or `char'.  In such cases,
<span class="lineNum">   19825 </span>            :      TREE_TYPE (decl) will be `short' or `char', DECL_ARG_TYPE (decl) will
<span class="lineNum">   19826 </span>            :      be `int', and DECL_INCOMING_RTL will point to the lowest-order byte of the
<span class="lineNum">   19827 </span>            :      passed `int' value.  If the debugger then uses that address to fetch
<span class="lineNum">   19828 </span>            :      a `short' or a `char' (on a little-endian machine) the result will be
<span class="lineNum">   19829 </span>            :      the correct data, so we allow for such exceptional cases below.
<span class="lineNum">   19830 </span>            : 
<span class="lineNum">   19831 </span>            :      Note that our goal here is to describe the place where the given formal
<span class="lineNum">   19832 </span>            :      parameter lives during most of the function's activation (i.e. between the
<span class="lineNum">   19833 </span>            :      end of the prologue and the start of the epilogue).  We'll do that as best
<span class="lineNum">   19834 </span>            :      as we can. Note however that if the given formal parameter is modified
<span class="lineNum">   19835 </span>            :      sometime during the execution of the function, then a stack backtrace (at
<span class="lineNum">   19836 </span>            :      debug-time) will show the function as having been called with the *new*
<span class="lineNum">   19837 </span>            :      value rather than the value which was originally passed in.  This happens
<span class="lineNum">   19838 </span>            :      rarely enough that it is not a major problem, but it *is* a problem, and
<span class="lineNum">   19839 </span>            :      I'd like to fix it.
<span class="lineNum">   19840 </span>            : 
<span class="lineNum">   19841 </span>            :      A future version of dwarf2out.c may generate two additional attributes for
<span class="lineNum">   19842 </span>            :      any given DW_TAG_formal_parameter DIE which will describe the &quot;passed
<span class="lineNum">   19843 </span>            :      type&quot; and the &quot;passed location&quot; for the given formal parameter in addition
<span class="lineNum">   19844 </span>            :      to the attributes we now generate to indicate the &quot;declared type&quot; and the
<span class="lineNum">   19845 </span>            :      &quot;active location&quot; for each parameter.  This additional set of attributes
<span class="lineNum">   19846 </span>            :      could be used by debuggers for stack backtraces. Separately, note that
<span class="lineNum">   19847 </span>            :      sometimes DECL_RTL can be NULL and DECL_INCOMING_RTL can be NULL also.
<span class="lineNum">   19848 </span>            :      This happens (for example) for inlined-instances of inline function formal
<span class="lineNum">   19849 </span>            :      parameters which are never referenced.  This really shouldn't be
<span class="lineNum">   19850 </span>            :      happening.  All PARM_DECL nodes should get valid non-NULL
<span class="lineNum">   19851 </span>            :      DECL_INCOMING_RTL values.  FIXME.  */
<span class="lineNum">   19852 </span>            : 
<span class="lineNum">   19853 </span>            :   /* Use DECL_RTL as the &quot;location&quot; unless we find something better.  */
<span class="lineNum">   19854 </span><span class="lineCov">    9033648 :   rtl = DECL_RTL_IF_SET (decl);</span>
<span class="lineNum">   19855 </span>            : 
<span class="lineNum">   19856 </span>            :   /* When generating abstract instances, ignore everything except
<span class="lineNum">   19857 </span>            :      constants, symbols living in memory, and symbols living in
<span class="lineNum">   19858 </span>            :      fixed registers.  */
<span class="lineNum">   19859 </span><span class="lineCov">    9033648 :   if (! reload_completed)</span>
<span class="lineNum">   19860 </span>            :     {
<span class="lineNum">   19861 </span><span class="lineCov">     376917 :       if (rtl</span>
<span class="lineNum">   19862 </span><span class="lineCov">     371461 :           &amp;&amp; (CONSTANT_P (rtl)</span>
<span class="lineNum">   19863 </span><span class="lineCov">     371461 :               || (MEM_P (rtl)</span>
<span class="lineNum">   19864 </span><span class="lineCov">     371461 :                   &amp;&amp; CONSTANT_P (XEXP (rtl, 0)))</span>
<span class="lineNum">   19865 </span><span class="lineNoCov">          0 :               || (REG_P (rtl)</span>
<span class="lineNum">   19866 </span>            :                   &amp;&amp; VAR_P (decl)
<span class="lineNum">   19867 </span><span class="lineNoCov">          0 :                   &amp;&amp; TREE_STATIC (decl))))</span>
<span class="lineNum">   19868 </span>            :         {
<span class="lineNum">   19869 </span><span class="lineCov">     371461 :           rtl = targetm.delegitimize_address (rtl);</span>
<span class="lineNum">   19870 </span><span class="lineCov">     371461 :           return rtl;</span>
<span class="lineNum">   19871 </span>            :         }
<span class="lineNum">   19872 </span>            :       rtl = NULL_RTX;
<span class="lineNum">   19873 </span>            :     }
<span class="lineNum">   19874 </span><span class="lineCov">    8656731 :   else if (TREE_CODE (decl) == PARM_DECL)</span>
<span class="lineNum">   19875 </span>            :     {
<span class="lineNum">   19876 </span><span class="lineCov">     740332 :       if (rtl == NULL_RTX</span>
<span class="lineNum">   19877 </span><span class="lineCov">     740331 :           || is_pseudo_reg (rtl)</span>
<span class="lineNum">   19878 </span><span class="lineCov">    1243320 :           || (MEM_P (rtl)</span>
<span class="lineNum">   19879 </span><span class="lineCov">     139546 :               &amp;&amp; is_pseudo_reg (XEXP (rtl, 0))</span>
<span class="lineNum">   19880 </span><span class="lineCov">          4 :               &amp;&amp; DECL_INCOMING_RTL (decl)</span>
<span class="lineNum">   19881 </span><span class="lineCov">          4 :               &amp;&amp; MEM_P (DECL_INCOMING_RTL (decl))</span>
<span class="lineNum">   19882 </span><span class="lineCov">          4 :               &amp;&amp; GET_MODE (rtl) == GET_MODE (DECL_INCOMING_RTL (decl))))</span>
<span class="lineNum">   19883 </span>            :         {
<span class="lineNum">   19884 </span><span class="lineCov">     237346 :           tree declared_type = TREE_TYPE (decl);</span>
<span class="lineNum">   19885 </span><span class="lineCov">     237346 :           tree passed_type = DECL_ARG_TYPE (decl);</span>
<span class="lineNum">   19886 </span><span class="lineCov">     237346 :           machine_mode dmode = TYPE_MODE (declared_type);</span>
<span class="lineNum">   19887 </span><span class="lineCov">     237346 :           machine_mode pmode = TYPE_MODE (passed_type);</span>
<span class="lineNum">   19888 </span>            : 
<span class="lineNum">   19889 </span>            :           /* This decl represents a formal parameter which was optimized out.
<span class="lineNum">   19890 </span>            :              Note that DECL_INCOMING_RTL may be NULL in here, but we handle
<span class="lineNum">   19891 </span>            :              all cases where (rtl == NULL_RTX) just below.  */
<span class="lineNum">   19892 </span><span class="lineCov">     237346 :           if (dmode == pmode)</span>
<span class="lineNum">   19893 </span><span class="lineCov">     230582 :             rtl = DECL_INCOMING_RTL (decl);</span>
<span class="lineNum">   19894 </span><span class="lineCov">       6764 :           else if ((rtl == NULL_RTX || is_pseudo_reg (rtl))</span>
<span class="lineNum">   19895 </span><span class="lineCov">       6764 :                    &amp;&amp; SCALAR_INT_MODE_P (dmode)</span>
<span class="lineNum">   19896 </span><span class="lineCov">      20037 :                    &amp;&amp; known_le (GET_MODE_SIZE (dmode), GET_MODE_SIZE (pmode))</span>
<span class="lineNum">   19897 </span><span class="lineCov">      13443 :                    &amp;&amp; DECL_INCOMING_RTL (decl))</span>
<span class="lineNum">   19898 </span>            :             {
<span class="lineNum">   19899 </span><span class="lineCov">       6679 :               rtx inc = DECL_INCOMING_RTL (decl);</span>
<span class="lineNum">   19900 </span><span class="lineCov">       6679 :               if (REG_P (inc))</span>
<span class="lineNum">   19901 </span>            :                 rtl = inc;
<span class="lineNum">   19902 </span><span class="lineCov">        850 :               else if (MEM_P (inc))</span>
<span class="lineNum">   19903 </span>            :                 {
<span class="lineNum">   19904 </span><span class="lineCov">        850 :                   if (BYTES_BIG_ENDIAN)</span>
<span class="lineNum">   19905 </span>            :                     rtl = adjust_address_nv (inc, dmode,
<span class="lineNum">   19906 </span>            :                                              GET_MODE_SIZE (pmode)
<span class="lineNum">   19907 </span>            :                                              - GET_MODE_SIZE (dmode));
<span class="lineNum">   19908 </span>            :                   else
<span class="lineNum">   19909 </span><span class="lineCov">        850 :                     rtl = inc;</span>
<span class="lineNum">   19910 </span>            :                 }
<span class="lineNum">   19911 </span>            :             }
<span class="lineNum">   19912 </span>            :         }
<span class="lineNum">   19913 </span>            : 
<span class="lineNum">   19914 </span>            :       /* If the parm was passed in registers, but lives on the stack, then
<span class="lineNum">   19915 </span>            :          make a big endian correction if the mode of the type of the
<span class="lineNum">   19916 </span>            :          parameter is not the same as the mode of the rtl.  */
<span class="lineNum">   19917 </span>            :       /* ??? This is the same series of checks that are made in dbxout.c before
<span class="lineNum">   19918 </span>            :          we reach the big endian correction code there.  It isn't clear if all
<span class="lineNum">   19919 </span>            :          of these checks are necessary here, but keeping them all is the safe
<span class="lineNum">   19920 </span>            :          thing to do.  */
<span class="lineNum">   19921 </span><span class="lineCov">     502986 :       else if (MEM_P (rtl)</span>
<span class="lineNum">   19922 </span><span class="lineCov">     139544 :                &amp;&amp; XEXP (rtl, 0) != const0_rtx</span>
<span class="lineNum">   19923 </span><span class="lineCov">     139544 :                &amp;&amp; ! CONSTANT_P (XEXP (rtl, 0))</span>
<span class="lineNum">   19924 </span>            :                /* Not passed in memory.  */
<span class="lineNum">   19925 </span><span class="lineCov">     279088 :                &amp;&amp; !MEM_P (DECL_INCOMING_RTL (decl))</span>
<span class="lineNum">   19926 </span>            :                /* Not passed by invisible reference.  */
<span class="lineNum">   19927 </span><span class="lineCov">     603152 :                &amp;&amp; (!REG_P (XEXP (rtl, 0))</span>
<span class="lineNum">   19928 </span><span class="lineCov">       8208 :                    || REGNO (XEXP (rtl, 0)) == HARD_FRAME_POINTER_REGNUM</span>
<span class="lineNum">   19929 </span>            :                    || REGNO (XEXP (rtl, 0)) == STACK_POINTER_REGNUM
<span class="lineNum">   19930 </span>            : #if !HARD_FRAME_POINTER_IS_ARG_POINTER
<span class="lineNum">   19931 </span>            :                    || REGNO (XEXP (rtl, 0)) == ARG_POINTER_REGNUM
<span class="lineNum">   19932 </span>            : #endif
<span class="lineNum">   19933 </span>            :                      )
<span class="lineNum">   19934 </span>            :                /* Big endian correction check.  */
<span class="lineNum">   19935 </span>            :                &amp;&amp; BYTES_BIG_ENDIAN
<span class="lineNum">   19936 </span>            :                &amp;&amp; TYPE_MODE (TREE_TYPE (decl)) != GET_MODE (rtl)
<span class="lineNum">   19937 </span>            :                &amp;&amp; known_lt (GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (decl))),
<span class="lineNum">   19938 </span>            :                             UNITS_PER_WORD))
<span class="lineNum">   19939 </span>            :         {
<span class="lineNum">   19940 </span>            :           machine_mode addr_mode = get_address_mode (rtl);
<span class="lineNum">   19941 </span>            :           poly_int64 offset = (UNITS_PER_WORD
<span class="lineNum">   19942 </span>            :                                - GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (decl))));
<span class="lineNum">   19943 </span>            : 
<span class="lineNum">   19944 </span>            :           rtl = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (decl)),
<span class="lineNum">   19945 </span>            :                              plus_constant (addr_mode, XEXP (rtl, 0), offset));
<span class="lineNum">   19946 </span>            :         }
<span class="lineNum">   19947 </span>            :     }
<span class="lineNum">   19948 </span><span class="lineCov">    7916399 :   else if (VAR_P (decl)</span>
<span class="lineNum">   19949 </span><span class="lineCov">    7916399 :            &amp;&amp; rtl</span>
<span class="lineNum">   19950 </span><span class="lineCov">     730263 :            &amp;&amp; MEM_P (rtl)</span>
<span class="lineNum">   19951 </span><span class="lineCov">    8256024 :            &amp;&amp; GET_MODE (rtl) != TYPE_MODE (TREE_TYPE (decl)))</span>
<span class="lineNum">   19952 </span>            :     {
<span class="lineNum">   19953 </span><span class="lineCov">          2 :       machine_mode addr_mode = get_address_mode (rtl);</span>
<span class="lineNum">   19954 </span><span class="lineCov">          4 :       poly_int64 offset = byte_lowpart_offset (TYPE_MODE (TREE_TYPE (decl)),</span>
<span class="lineNum">   19955 </span><span class="lineCov">          4 :                                                GET_MODE (rtl));</span>
<span class="lineNum">   19956 </span>            : 
<span class="lineNum">   19957 </span>            :       /* If a variable is declared &quot;register&quot; yet is smaller than
<span class="lineNum">   19958 </span>            :          a register, then if we store the variable to memory, it
<span class="lineNum">   19959 </span>            :          looks like we're storing a register-sized value, when in
<span class="lineNum">   19960 </span>            :          fact we are not.  We need to adjust the offset of the
<span class="lineNum">   19961 </span>            :          storage location to reflect the actual value's bytes,
<span class="lineNum">   19962 </span>            :          else gdb will not be able to display it.  */
<span class="lineNum">   19963 </span><span class="lineCov">          2 :       if (maybe_ne (offset, 0))</span>
<span class="lineNum">   19964 </span><span class="lineNoCov">          0 :         rtl = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (decl)),</span>
<span class="lineNum">   19965 </span>            :                            plus_constant (addr_mode, XEXP (rtl, 0), offset));
<span class="lineNum">   19966 </span>            :     }
<span class="lineNum">   19967 </span>            : 
<span class="lineNum">   19968 </span>            :   /* A variable with no DECL_RTL but a DECL_INITIAL is a compile-time constant,
<span class="lineNum">   19969 </span>            :      and will have been substituted directly into all expressions that use it.
<span class="lineNum">   19970 </span>            :      C does not have such a concept, but C++ and other languages do.  */
<span class="lineNum">   19971 </span><span class="lineCov">    8662187 :   if (!rtl &amp;&amp; VAR_P (decl) &amp;&amp; DECL_INITIAL (decl))</span>
<span class="lineNum">   19972 </span><span class="lineCov">       1223 :     rtl = rtl_for_decl_init (DECL_INITIAL (decl), TREE_TYPE (decl));</span>
<span class="lineNum">   19973 </span>            : 
<span class="lineNum">   19974 </span><span class="lineCov">    8662187 :   if (rtl)</span>
<span class="lineNum">   19975 </span><span class="lineCov">    1471439 :     rtl = targetm.delegitimize_address (rtl);</span>
<span class="lineNum">   19976 </span>            : 
<span class="lineNum">   19977 </span>            :   /* If we don't look past the constant pool, we risk emitting a
<span class="lineNum">   19978 </span>            :      reference to a constant pool entry that isn't referenced from
<span class="lineNum">   19979 </span>            :      code, and thus is not emitted.  */
<span class="lineNum">   19980 </span><span class="lineCov">    8662187 :   if (rtl)</span>
<span class="lineNum">   19981 </span><span class="lineCov">    1471439 :     rtl = avoid_constant_pool_reference (rtl);</span>
<span class="lineNum">   19982 </span>            : 
<span class="lineNum">   19983 </span>            :   /* Try harder to get a rtl.  If this symbol ends up not being emitted
<span class="lineNum">   19984 </span>            :      in the current CU, resolve_addr will remove the expression referencing
<span class="lineNum">   19985 </span>            :      it.  */
<span class="lineNum">   19986 </span><span class="lineCov">    8662187 :   if (rtl == NULL_RTX</span>
<span class="lineNum">   19987 </span><span class="lineCov">    7190748 :       &amp;&amp; !(early_dwarf &amp;&amp; (flag_generate_lto || flag_generate_offload))</span>
<span class="lineNum">   19988 </span><span class="lineCov">    7190604 :       &amp;&amp; VAR_P (decl)</span>
<span class="lineNum">   19989 </span><span class="lineCov">    7189976 :       &amp;&amp; !DECL_EXTERNAL (decl)</span>
<span class="lineNum">   19990 </span><span class="lineCov">    7189976 :       &amp;&amp; TREE_STATIC (decl)</span>
<span class="lineNum">   19991 </span><span class="lineCov">        757 :       &amp;&amp; DECL_NAME (decl)</span>
<span class="lineNum">   19992 </span><span class="lineCov">       1514 :       &amp;&amp; !DECL_HARD_REGISTER (decl)</span>
<span class="lineNum">   19993 </span><span class="lineCov">    8663701 :       &amp;&amp; DECL_MODE (decl) != VOIDmode)</span>
<span class="lineNum">   19994 </span>            :     {
<span class="lineNum">   19995 </span><span class="lineCov">        757 :       rtl = make_decl_rtl_for_debug (decl);</span>
<span class="lineNum">   19996 </span><span class="lineCov">        757 :       if (!MEM_P (rtl)</span>
<span class="lineNum">   19997 </span><span class="lineCov">        757 :           || GET_CODE (XEXP (rtl, 0)) != SYMBOL_REF</span>
<span class="lineNum">   19998 </span><span class="lineCov">       1514 :           || SYMBOL_REF_DECL (XEXP (rtl, 0)) != decl)</span>
<span class="lineNum">   19999 </span>            :         rtl = NULL_RTX;
<span class="lineNum">   20000 </span>            :     }
<span class="lineNum">   20001 </span>            : 
<span class="lineNum">   20002 </span>            :   return rtl;
<span class="lineNum">   20003 </span>            : }
<span class="lineNum">   20004 </span>            : 
<span class="lineNum">   20005 </span>            : /* Check whether decl is a Fortran COMMON symbol.  If not, NULL_TREE is
<span class="lineNum">   20006 </span>            :    returned.  If so, the decl for the COMMON block is returned, and the
<span class="lineNum">   20007 </span>            :    value is the offset into the common block for the symbol.  */
<a name="20008"><span class="lineNum">   20008 </span>            : </a>
<span class="lineNum">   20009 </span>            : static tree
<span class="lineNum">   20010 </span><span class="lineCov">    4483304 : fortran_common (tree decl, HOST_WIDE_INT *value)</span>
<span class="lineNum">   20011 </span>            : {
<span class="lineNum">   20012 </span><span class="lineCov">    4483304 :   tree val_expr, cvar;</span>
<span class="lineNum">   20013 </span><span class="lineCov">    4483304 :   machine_mode mode;</span>
<span class="lineNum">   20014 </span><span class="lineCov">    8966608 :   poly_int64 bitsize, bitpos;</span>
<span class="lineNum">   20015 </span><span class="lineCov">    4483304 :   tree offset;</span>
<span class="lineNum">   20016 </span><span class="lineCov">    4483304 :   HOST_WIDE_INT cbitpos;</span>
<span class="lineNum">   20017 </span><span class="lineCov">    4483304 :   int unsignedp, reversep, volatilep = 0;</span>
<span class="lineNum">   20018 </span>            : 
<span class="lineNum">   20019 </span>            :   /* If the decl isn't a VAR_DECL, or if it isn't static, or if
<span class="lineNum">   20020 </span>            :      it does not have a value (the offset into the common area), or if it
<span class="lineNum">   20021 </span>            :      is thread local (as opposed to global) then it isn't common, and shouldn't
<span class="lineNum">   20022 </span>            :      be handled as such.  */
<span class="lineNum">   20023 </span><span class="lineCov">    4483304 :   if (!VAR_P (decl)</span>
<span class="lineNum">   20024 </span><span class="lineCov">    4483304 :       || !TREE_STATIC (decl)</span>
<span class="lineNum">   20025 </span><span class="lineCov">    1650351 :       || !DECL_HAS_VALUE_EXPR_P (decl)</span>
<span class="lineNum">   20026 </span><span class="lineCov">    4484400 :       || !is_fortran ())</span>
<span class="lineNum">   20027 </span><span class="lineCov">    4482209 :     return NULL_TREE;</span>
<span class="lineNum">   20028 </span>            : 
<span class="lineNum">   20029 </span><span class="lineCov">       1095 :   val_expr = DECL_VALUE_EXPR (decl);</span>
<span class="lineNum">   20030 </span><span class="lineCov">       1095 :   if (TREE_CODE (val_expr) != COMPONENT_REF)</span>
<span class="lineNum">   20031 </span>            :     return NULL_TREE;
<span class="lineNum">   20032 </span>            : 
<span class="lineNum">   20033 </span><span class="lineCov">       1095 :   cvar = get_inner_reference (val_expr, &amp;bitsize, &amp;bitpos, &amp;offset, &amp;mode,</span>
<span class="lineNum">   20034 </span>            :                               &amp;unsignedp, &amp;reversep, &amp;volatilep);
<span class="lineNum">   20035 </span>            : 
<span class="lineNum">   20036 </span><span class="lineCov">       1095 :   if (cvar == NULL_TREE</span>
<span class="lineNum">   20037 </span><span class="lineCov">       1095 :       || !VAR_P (cvar)</span>
<span class="lineNum">   20038 </span><span class="lineCov">       1095 :       || DECL_ARTIFICIAL (cvar)</span>
<span class="lineNum">   20039 </span><span class="lineCov">        982 :       || !TREE_PUBLIC (cvar)</span>
<span class="lineNum">   20040 </span>            :       /* We don't expect to have to cope with variable offsets,
<span class="lineNum">   20041 </span>            :          since at present all static data must have a constant size.  */
<span class="lineNum">   20042 </span><span class="lineCov">       2077 :       || !bitpos.is_constant (&amp;cbitpos))</span>
<span class="lineNum">   20043 </span>            :     return NULL_TREE;
<span class="lineNum">   20044 </span>            : 
<span class="lineNum">   20045 </span><span class="lineCov">        982 :   *value = 0;</span>
<span class="lineNum">   20046 </span><span class="lineCov">        982 :   if (offset != NULL)</span>
<span class="lineNum">   20047 </span>            :     {
<span class="lineNum">   20048 </span><span class="lineNoCov">          0 :       if (!tree_fits_shwi_p (offset))</span>
<span class="lineNum">   20049 </span>            :         return NULL_TREE;
<span class="lineNum">   20050 </span><span class="lineNoCov">          0 :       *value = tree_to_shwi (offset);</span>
<span class="lineNum">   20051 </span>            :     }
<span class="lineNum">   20052 </span><span class="lineCov">        982 :   if (cbitpos != 0)</span>
<span class="lineNum">   20053 </span><span class="lineCov">        674 :     *value += cbitpos / BITS_PER_UNIT;</span>
<span class="lineNum">   20054 </span>            : 
<span class="lineNum">   20055 </span>            :   return cvar;
<span class="lineNum">   20056 </span>            : }
<span class="lineNum">   20057 </span>            : 
<span class="lineNum">   20058 </span>            : /* Generate *either* a DW_AT_location attribute or else a DW_AT_const_value
<span class="lineNum">   20059 </span>            :    data attribute for a variable or a parameter.  We generate the
<span class="lineNum">   20060 </span>            :    DW_AT_const_value attribute only in those cases where the given variable
<span class="lineNum">   20061 </span>            :    or parameter does not have a true &quot;location&quot; either in memory or in a
<span class="lineNum">   20062 </span>            :    register.  This can happen (for example) when a constant is passed as an
<span class="lineNum">   20063 </span>            :    actual argument in a call to an inline function.  (It's possible that
<span class="lineNum">   20064 </span>            :    these things can crop up in other ways also.)  Note that one type of
<span class="lineNum">   20065 </span>            :    constant value which can be passed into an inlined function is a constant
<span class="lineNum">   20066 </span>            :    pointer.  This can happen for example if an actual argument in an inlined
<span class="lineNum">   20067 </span>            :    function call evaluates to a compile-time constant address.
<span class="lineNum">   20068 </span>            : 
<span class="lineNum">   20069 </span>            :    CACHE_P is true if it is worth caching the location list for DECL,
<span class="lineNum">   20070 </span>            :    so that future calls can reuse it rather than regenerate it from scratch.
<span class="lineNum">   20071 </span>            :    This is true for BLOCK_NONLOCALIZED_VARS in inlined subroutines,
<span class="lineNum">   20072 </span>            :    since we will need to refer to them each time the function is inlined.  */
<a name="20073"><span class="lineNum">   20073 </span>            : </a>
<span class="lineNum">   20074 </span>            : static bool
<span class="lineNum">   20075 </span><span class="lineCov">   10284111 : add_location_or_const_value_attribute (dw_die_ref die, tree decl, bool cache_p)</span>
<span class="lineNum">   20076 </span>            : {
<span class="lineNum">   20077 </span><span class="lineCov">   10284111 :   rtx rtl;</span>
<span class="lineNum">   20078 </span><span class="lineCov">   10284111 :   dw_loc_list_ref list;</span>
<span class="lineNum">   20079 </span><span class="lineCov">   10284111 :   var_loc_list *loc_list;</span>
<span class="lineNum">   20080 </span><span class="lineCov">   10284111 :   cached_dw_loc_list *cache;</span>
<span class="lineNum">   20081 </span>            : 
<span class="lineNum">   20082 </span><span class="lineCov">   10284111 :   if (early_dwarf)</span>
<span class="lineNum">   20083 </span>            :     return false;
<span class="lineNum">   20084 </span>            : 
<span class="lineNum">   20085 </span><span class="lineCov">    7919242 :   if (TREE_CODE (decl) == ERROR_MARK)</span>
<span class="lineNum">   20086 </span>            :     return false;
<span class="lineNum">   20087 </span>            : 
<span class="lineNum">   20088 </span><span class="lineCov">    7919242 :   if (get_AT (die, DW_AT_location)</span>
<span class="lineNum">   20089 </span><span class="lineCov">    7919242 :       || get_AT (die, DW_AT_const_value))</span>
<span class="lineNum">   20090 </span>            :     return true;
<span class="lineNum">   20091 </span>            : 
<span class="lineNum">   20092 </span><span class="lineCov">    7900078 :   gcc_assert (VAR_P (decl) || TREE_CODE (decl) == PARM_DECL</span>
<span class="lineNum">   20093 </span>            :               || TREE_CODE (decl) == RESULT_DECL);
<span class="lineNum">   20094 </span>            : 
<span class="lineNum">   20095 </span>            :   /* Try to get some constant RTL for this decl, and use that as the value of
<span class="lineNum">   20096 </span>            :      the location.  */
<span class="lineNum">   20097 </span>            : 
<span class="lineNum">   20098 </span><span class="lineCov">    7900078 :   rtl = rtl_for_decl_location (decl);</span>
<span class="lineNum">   20099 </span><span class="lineCov">    1393274 :   if (rtl &amp;&amp; (CONSTANT_P (rtl) || GET_CODE (rtl) == CONST_STRING)</span>
<span class="lineNum">   20100 </span><span class="lineCov">    7900341 :       &amp;&amp; add_const_value_attribute (die, rtl))</span>
<span class="lineNum">   20101 </span>            :     return true;
<span class="lineNum">   20102 </span>            : 
<span class="lineNum">   20103 </span>            :   /* See if we have single element location list that is equivalent to
<span class="lineNum">   20104 </span>            :      a constant value.  That way we are better to use add_const_value_attribute
<span class="lineNum">   20105 </span>            :      rather than expanding constant value equivalent.  */
<span class="lineNum">   20106 </span><span class="lineCov">    7899815 :   loc_list = lookup_decl_loc (decl);</span>
<span class="lineNum">   20107 </span><span class="lineCov">    7899815 :   if (loc_list</span>
<span class="lineNum">   20108 </span><span class="lineCov">    6772988 :       &amp;&amp; loc_list-&gt;first</span>
<span class="lineNum">   20109 </span><span class="lineCov">    6772988 :       &amp;&amp; loc_list-&gt;first-&gt;next == NULL</span>
<span class="lineNum">   20110 </span><span class="lineCov">     654478 :       &amp;&amp; NOTE_P (loc_list-&gt;first-&gt;loc)</span>
<span class="lineNum">   20111 </span><span class="lineCov">     646475 :       &amp;&amp; NOTE_VAR_LOCATION (loc_list-&gt;first-&gt;loc)</span>
<span class="lineNum">   20112 </span><span class="lineCov">     646475 :       &amp;&amp; NOTE_VAR_LOCATION_LOC (loc_list-&gt;first-&gt;loc))</span>
<span class="lineNum">   20113 </span>            :     {
<span class="lineNum">   20114 </span><span class="lineCov">     369818 :       struct var_loc_node *node;</span>
<span class="lineNum">   20115 </span>            : 
<span class="lineNum">   20116 </span><span class="lineCov">     369818 :       node = loc_list-&gt;first;</span>
<span class="lineNum">   20117 </span><span class="lineCov">     369818 :       rtl = NOTE_VAR_LOCATION_LOC (node-&gt;loc);</span>
<span class="lineNum">   20118 </span><span class="lineCov">     369818 :       if (GET_CODE (rtl) == EXPR_LIST)</span>
<span class="lineNum">   20119 </span><span class="lineNoCov">          0 :         rtl = XEXP (rtl, 0);</span>
<span class="lineNum">   20120 </span><span class="lineCov">     326207 :       if ((CONSTANT_P (rtl) || GET_CODE (rtl) == CONST_STRING)</span>
<span class="lineNum">   20121 </span><span class="lineCov">     370726 :           &amp;&amp; add_const_value_attribute (die, rtl))</span>
<span class="lineNum">   20122 </span>            :          return true;
<span class="lineNum">   20123 </span>            :     }
<span class="lineNum">   20124 </span>            :   /* If this decl is from BLOCK_NONLOCALIZED_VARS, we might need its
<span class="lineNum">   20125 </span>            :      list several times.  See if we've already cached the contents.  */
<span class="lineNum">   20126 </span><span class="lineCov">    7857010 :   list = NULL;</span>
<span class="lineNum">   20127 </span><span class="lineCov">    7857010 :   if (loc_list == NULL || cached_dw_loc_list_table == NULL)</span>
<span class="lineNum">   20128 </span>            :     cache_p = false;
<span class="lineNum">   20129 </span><span class="lineCov">    6730183 :   if (cache_p)</span>
<span class="lineNum">   20130 </span>            :     {
<span class="lineNum">   20131 </span><span class="lineNoCov">          0 :       cache = cached_dw_loc_list_table-&gt;find_with_hash (decl, DECL_UID (decl));</span>
<span class="lineNum">   20132 </span><span class="lineNoCov">          0 :       if (cache)</span>
<span class="lineNum">   20133 </span><span class="lineNoCov">          0 :         list = cache-&gt;loc_list;</span>
<span class="lineNum">   20134 </span>            :     }
<span class="lineNum">   20135 </span><span class="lineNoCov">          0 :   if (list == NULL)</span>
<span class="lineNum">   20136 </span>            :     {
<span class="lineNum">   20137 </span><span class="lineCov">   15700205 :       list = loc_list_from_tree (decl, decl_by_reference_p (decl) ? 0 : 2,</span>
<span class="lineNum">   20138 </span>            :                                  NULL);
<span class="lineNum">   20139 </span>            :       /* It is usually worth caching this result if the decl is from
<span class="lineNum">   20140 </span>            :          BLOCK_NONLOCALIZED_VARS and if the list has at least two elements.  */
<span class="lineNum">   20141 </span><span class="lineCov">    7857010 :       if (cache_p &amp;&amp; list &amp;&amp; list-&gt;dw_loc_next)</span>
<span class="lineNum">   20142 </span>            :         {
<span class="lineNum">   20143 </span><span class="lineNoCov">          0 :           cached_dw_loc_list **slot</span>
<span class="lineNum">   20144 </span><span class="lineNoCov">          0 :             = cached_dw_loc_list_table-&gt;find_slot_with_hash (decl,</span>
<span class="lineNum">   20145 </span><span class="lineNoCov">          0 :                                                              DECL_UID (decl),</span>
<span class="lineNum">   20146 </span>            :                                                              INSERT);
<span class="lineNum">   20147 </span><span class="lineNoCov">          0 :           cache = ggc_cleared_alloc&lt;cached_dw_loc_list&gt; ();</span>
<span class="lineNum">   20148 </span><span class="lineNoCov">          0 :           cache-&gt;decl_id = DECL_UID (decl);</span>
<span class="lineNum">   20149 </span><span class="lineNoCov">          0 :           cache-&gt;loc_list = list;</span>
<span class="lineNum">   20150 </span><span class="lineNoCov">          0 :           *slot = cache;</span>
<span class="lineNum">   20151 </span>            :         }
<span class="lineNum">   20152 </span>            :     }
<span class="lineNum">   20153 </span><span class="lineCov">    7857010 :   if (list)</span>
<span class="lineNum">   20154 </span>            :     {
<span class="lineNum">   20155 </span><span class="lineCov">    6822098 :       add_AT_location_description (die, DW_AT_location, list);</span>
<span class="lineNum">   20156 </span><span class="lineCov">    6822098 :       return true;</span>
<span class="lineNum">   20157 </span>            :     }
<span class="lineNum">   20158 </span>            :   /* None of that worked, so it must not really have a location;
<span class="lineNum">   20159 </span>            :      try adding a constant value attribute from the DECL_INITIAL.  */
<span class="lineNum">   20160 </span><span class="lineCov">    1034912 :   return tree_add_const_value_attribute_for_decl (die, decl);</span>
<span class="lineNum">   20161 </span>            : }
<span class="lineNum">   20162 </span>            : 
<span class="lineNum">   20163 </span>            : /* Helper function for tree_add_const_value_attribute.  Natively encode
<span class="lineNum">   20164 </span>            :    initializer INIT into an array.  Return true if successful.  */
<a name="20165"><span class="lineNum">   20165 </span>            : </a>
<span class="lineNum">   20166 </span>            : static bool
<span class="lineNum">   20167 </span><span class="lineCov">      19290 : native_encode_initializer (tree init, unsigned char *array, int size)</span>
<span class="lineNum">   20168 </span>            : {
<span class="lineNum">   20169 </span><span class="lineCov">      19290 :   tree type;</span>
<span class="lineNum">   20170 </span>            : 
<span class="lineNum">   20171 </span><span class="lineCov">      19290 :   if (init == NULL_TREE)</span>
<span class="lineNum">   20172 </span>            :     return false;
<span class="lineNum">   20173 </span>            : 
<span class="lineNum">   20174 </span><span class="lineCov">      19290 :   STRIP_NOPS (init);</span>
<span class="lineNum">   20175 </span><span class="lineCov">      19290 :   switch (TREE_CODE (init))</span>
<span class="lineNum">   20176 </span>            :     {
<span class="lineNum">   20177 </span><span class="lineCov">        337 :     case STRING_CST:</span>
<span class="lineNum">   20178 </span><span class="lineCov">        337 :       type = TREE_TYPE (init);</span>
<span class="lineNum">   20179 </span><span class="lineCov">        337 :       if (TREE_CODE (type) == ARRAY_TYPE)</span>
<span class="lineNum">   20180 </span>            :         {
<span class="lineNum">   20181 </span><span class="lineCov">        337 :           tree enttype = TREE_TYPE (type);</span>
<span class="lineNum">   20182 </span><span class="lineCov">        337 :           scalar_int_mode mode;</span>
<span class="lineNum">   20183 </span>            : 
<span class="lineNum">   20184 </span><span class="lineCov">        337 :           if (!is_int_mode (TYPE_MODE (enttype), &amp;mode)</span>
<span class="lineNum">   20185 </span><span class="lineCov">        674 :               || GET_MODE_SIZE (mode) != 1)</span>
<span class="lineNum">   20186 </span>            :             return false;
<span class="lineNum">   20187 </span><span class="lineCov">        312 :           if (int_size_in_bytes (type) != size)</span>
<span class="lineNum">   20188 </span>            :             return false;
<span class="lineNum">   20189 </span><span class="lineCov">        311 :           if (size &gt; TREE_STRING_LENGTH (init))</span>
<span class="lineNum">   20190 </span>            :             {
<span class="lineNum">   20191 </span><span class="lineCov">         18 :               memcpy (array, TREE_STRING_POINTER (init),</span>
<span class="lineNum">   20192 </span><span class="lineCov">         12 :                       TREE_STRING_LENGTH (init));</span>
<span class="lineNum">   20193 </span><span class="lineCov">          6 :               memset (array + TREE_STRING_LENGTH (init),</span>
<span class="lineNum">   20194 </span><span class="lineCov">          6 :                       '\0', size - TREE_STRING_LENGTH (init));</span>
<span class="lineNum">   20195 </span>            :             }
<span class="lineNum">   20196 </span>            :           else
<span class="lineNum">   20197 </span><span class="lineCov">        610 :             memcpy (array, TREE_STRING_POINTER (init), size);</span>
<span class="lineNum">   20198 </span><span class="lineCov">        311 :           return true;</span>
<span class="lineNum">   20199 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">   20200 </span>            :       return false;
<span class="lineNum">   20201 </span><span class="lineCov">       6029 :     case CONSTRUCTOR:</span>
<span class="lineNum">   20202 </span><span class="lineCov">       6029 :       type = TREE_TYPE (init);</span>
<span class="lineNum">   20203 </span><span class="lineCov">       6029 :       if (int_size_in_bytes (type) != size)</span>
<span class="lineNum">   20204 </span>            :         return false;
<span class="lineNum">   20205 </span><span class="lineCov">       6027 :       if (TREE_CODE (type) == ARRAY_TYPE)</span>
<span class="lineNum">   20206 </span>            :         {
<span class="lineNum">   20207 </span><span class="lineCov">        617 :           HOST_WIDE_INT min_index;</span>
<span class="lineNum">   20208 </span><span class="lineCov">        617 :           unsigned HOST_WIDE_INT cnt;</span>
<span class="lineNum">   20209 </span><span class="lineCov">        617 :           int curpos = 0, fieldsize;</span>
<span class="lineNum">   20210 </span><span class="lineCov">        617 :           constructor_elt *ce;</span>
<span class="lineNum">   20211 </span>            : 
<span class="lineNum">   20212 </span><span class="lineCov">        617 :           if (TYPE_DOMAIN (type) == NULL_TREE</span>
<span class="lineNum">   20213 </span><span class="lineCov">        617 :               || !tree_fits_shwi_p (TYPE_MIN_VALUE (TYPE_DOMAIN (type))))</span>
<span class="lineNum">   20214 </span>            :             return false;
<span class="lineNum">   20215 </span>            : 
<span class="lineNum">   20216 </span><span class="lineCov">        617 :           fieldsize = int_size_in_bytes (TREE_TYPE (type));</span>
<span class="lineNum">   20217 </span><span class="lineCov">        617 :           if (fieldsize &lt;= 0)</span>
<span class="lineNum">   20218 </span>            :             return false;
<span class="lineNum">   20219 </span>            : 
<span class="lineNum">   20220 </span><span class="lineCov">        617 :           min_index = tree_to_shwi (TYPE_MIN_VALUE (TYPE_DOMAIN (type)));</span>
<span class="lineNum">   20221 </span><span class="lineCov">        617 :           memset (array, '\0', size);</span>
<span class="lineNum">   20222 </span><span class="lineCov">      11363 :           FOR_EACH_VEC_SAFE_ELT (CONSTRUCTOR_ELTS (init), cnt, ce)</span>
<span class="lineNum">   20223 </span>            :             {
<span class="lineNum">   20224 </span><span class="lineCov">      10867 :               tree val = ce-&gt;value;</span>
<span class="lineNum">   20225 </span><span class="lineCov">      10867 :               tree index = ce-&gt;index;</span>
<span class="lineNum">   20226 </span><span class="lineCov">      10867 :               int pos = curpos;</span>
<span class="lineNum">   20227 </span><span class="lineCov">      10867 :               if (index &amp;&amp; TREE_CODE (index) == RANGE_EXPR)</span>
<span class="lineNum">   20228 </span><span class="lineCov">          1 :                 pos = (tree_to_shwi (TREE_OPERAND (index, 0)) - min_index)</span>
<span class="lineNum">   20229 </span>            :                       * fieldsize;
<span class="lineNum">   20230 </span><span class="lineCov">      10866 :               else if (index)</span>
<span class="lineNum">   20231 </span><span class="lineCov">      10656 :                 pos = (tree_to_shwi (index) - min_index) * fieldsize;</span>
<span class="lineNum">   20232 </span>            : 
<span class="lineNum">   20233 </span><span class="lineCov">      10867 :               if (val)</span>
<span class="lineNum">   20234 </span>            :                 {
<span class="lineNum">   20235 </span><span class="lineCov">      10867 :                   STRIP_NOPS (val);</span>
<span class="lineNum">   20236 </span><span class="lineCov">      10867 :                   if (!native_encode_initializer (val, array + pos, fieldsize))</span>
<span class="lineNum">   20237 </span>            :                     return false;
<span class="lineNum">   20238 </span>            :                 }
<span class="lineNum">   20239 </span><span class="lineCov">      10746 :               curpos = pos + fieldsize;</span>
<span class="lineNum">   20240 </span><span class="lineCov">      10746 :               if (index &amp;&amp; TREE_CODE (index) == RANGE_EXPR)</span>
<span class="lineNum">   20241 </span>            :                 {
<span class="lineNum">   20242 </span><span class="lineCov">          1 :                   int count = tree_to_shwi (TREE_OPERAND (index, 1))</span>
<span class="lineNum">   20243 </span><span class="lineCov">          1 :                               - tree_to_shwi (TREE_OPERAND (index, 0));</span>
<span class="lineNum">   20244 </span><span class="lineCov">         16 :                   while (count-- &gt; 0)</span>
<span class="lineNum">   20245 </span>            :                     {
<span class="lineNum">   20246 </span><span class="lineCov">         15 :                       if (val)</span>
<span class="lineNum">   20247 </span><span class="lineCov">         15 :                         memcpy (array + curpos, array + pos, fieldsize);</span>
<span class="lineNum">   20248 </span><span class="lineCov">         15 :                       curpos += fieldsize;</span>
<span class="lineNum">   20249 </span>            :                     }
<span class="lineNum">   20250 </span>            :                 }
<span class="lineNum">   20251 </span><span class="lineCov">      10746 :               gcc_assert (curpos &lt;= size);</span>
<span class="lineNum">   20252 </span>            :             }
<span class="lineNum">   20253 </span>            :           return true;
<span class="lineNum">   20254 </span>            :         }
<span class="lineNum">   20255 </span><span class="lineCov">      10820 :       else if (TREE_CODE (type) == RECORD_TYPE</span>
<span class="lineNum">   20256 </span><span class="lineCov">       5410 :                || TREE_CODE (type) == UNION_TYPE)</span>
<span class="lineNum">   20257 </span>            :         {
<span class="lineNum">   20258 </span><span class="lineCov">       5410 :           tree field = NULL_TREE;</span>
<span class="lineNum">   20259 </span><span class="lineCov">       5410 :           unsigned HOST_WIDE_INT cnt;</span>
<span class="lineNum">   20260 </span><span class="lineCov">       5410 :           constructor_elt *ce;</span>
<span class="lineNum">   20261 </span>            : 
<span class="lineNum">   20262 </span><span class="lineCov">       5410 :           if (int_size_in_bytes (type) != size)</span>
<span class="lineNum">   20263 </span>            :             return false;
<span class="lineNum">   20264 </span>            : 
<span class="lineNum">   20265 </span><span class="lineCov">       5410 :           if (TREE_CODE (type) == RECORD_TYPE)</span>
<span class="lineNum">   20266 </span><span class="lineCov">      10820 :             field = TYPE_FIELDS (type);</span>
<span class="lineNum">   20267 </span>            : 
<span class="lineNum">   20268 </span><span class="lineCov">       6642 :           FOR_EACH_VEC_SAFE_ELT (CONSTRUCTOR_ELTS (init), cnt, ce)</span>
<span class="lineNum">   20269 </span>            :             {
<span class="lineNum">   20270 </span><span class="lineCov">       1345 :               tree val = ce-&gt;value;</span>
<span class="lineNum">   20271 </span><span class="lineCov">       1345 :               int pos, fieldsize;</span>
<span class="lineNum">   20272 </span>            : 
<span class="lineNum">   20273 </span><span class="lineCov">       1345 :               if (ce-&gt;index != 0)</span>
<span class="lineNum">   20274 </span><span class="lineCov">       1345 :                 field = ce-&gt;index;</span>
<span class="lineNum">   20275 </span>            : 
<span class="lineNum">   20276 </span><span class="lineCov">       1345 :               if (val)</span>
<span class="lineNum">   20277 </span><span class="lineCov">       1345 :                 STRIP_NOPS (val);</span>
<span class="lineNum">   20278 </span>            : 
<span class="lineNum">   20279 </span><span class="lineCov">       1345 :               if (field == NULL_TREE || DECL_BIT_FIELD (field))</span>
<span class="lineNum">   20280 </span>            :                 return false;
<span class="lineNum">   20281 </span>            : 
<span class="lineNum">   20282 </span><span class="lineCov">       1342 :               if (TREE_CODE (TREE_TYPE (field)) == ARRAY_TYPE</span>
<span class="lineNum">   20283 </span><span class="lineCov">         54 :                   &amp;&amp; TYPE_DOMAIN (TREE_TYPE (field))</span>
<span class="lineNum">   20284 </span><span class="lineCov">       1396 :                   &amp;&amp; ! TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (field))))</span>
<span class="lineNum">   20285 </span>            :                 return false;
<span class="lineNum">   20286 </span><span class="lineCov">       1342 :               else if (DECL_SIZE_UNIT (field) == NULL_TREE</span>
<span class="lineNum">   20287 </span><span class="lineCov">       1342 :                        || !tree_fits_shwi_p (DECL_SIZE_UNIT (field)))</span>
<span class="lineNum">   20288 </span>            :                 return false;
<span class="lineNum">   20289 </span><span class="lineCov">       2684 :               fieldsize = tree_to_shwi (DECL_SIZE_UNIT (field));</span>
<span class="lineNum">   20290 </span><span class="lineCov">       1342 :               pos = int_byte_position (field);</span>
<span class="lineNum">   20291 </span><span class="lineCov">       1342 :               gcc_assert (pos + fieldsize &lt;= size);</span>
<span class="lineNum">   20292 </span><span class="lineCov">       1342 :               if (val &amp;&amp; fieldsize != 0</span>
<span class="lineNum">   20293 </span><span class="lineCov">       2683 :                   &amp;&amp; !native_encode_initializer (val, array + pos, fieldsize))</span>
<span class="lineNum">   20294 </span>            :                 return false;
<span class="lineNum">   20295 </span>            :             }
<span class="lineNum">   20296 </span>            :           return true;
<span class="lineNum">   20297 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">   20298 </span>            :       return false;
<span class="lineNum">   20299 </span><span class="lineNoCov">          0 :     case VIEW_CONVERT_EXPR:</span>
<span class="lineNum">   20300 </span><span class="lineNoCov">          0 :     case NON_LVALUE_EXPR:</span>
<span class="lineNum">   20301 </span><span class="lineNoCov">          0 :       return native_encode_initializer (TREE_OPERAND (init, 0), array, size);</span>
<span class="lineNum">   20302 </span><span class="lineCov">      12924 :     default:</span>
<span class="lineNum">   20303 </span><span class="lineCov">      12924 :       return native_encode_expr (init, array, size) == size;</span>
<span class="lineNum">   20304 </span>            :     }
<span class="lineNum">   20305 </span>            : }
<span class="lineNum">   20306 </span>            : 
<span class="lineNum">   20307 </span>            : /* Attach a DW_AT_const_value attribute to DIE. The value of the
<span class="lineNum">   20308 </span>            :    attribute is the const value T.  */
<a name="20309"><span class="lineNum">   20309 </span>            : </a>
<span class="lineNum">   20310 </span>            : static bool
<span class="lineNum">   20311 </span><span class="lineCov">    2555318 : tree_add_const_value_attribute (dw_die_ref die, tree t)</span>
<span class="lineNum">   20312 </span>            : {
<span class="lineNum">   20313 </span><span class="lineCov">    2555318 :   tree init;</span>
<span class="lineNum">   20314 </span><span class="lineCov">    2555318 :   tree type = TREE_TYPE (t);</span>
<span class="lineNum">   20315 </span><span class="lineCov">    2555318 :   rtx rtl;</span>
<span class="lineNum">   20316 </span>            : 
<span class="lineNum">   20317 </span><span class="lineCov">    5110636 :   if (!t || !TREE_TYPE (t) || TREE_TYPE (t) == error_mark_node)</span>
<span class="lineNum">   20318 </span>            :     return false;
<span class="lineNum">   20319 </span>            : 
<span class="lineNum">   20320 </span><span class="lineCov">    2555318 :   init = t;</span>
<span class="lineNum">   20321 </span><span class="lineCov">    2555318 :   gcc_assert (!DECL_P (init));</span>
<span class="lineNum">   20322 </span>            : 
<span class="lineNum">   20323 </span><span class="lineCov">    2555318 :   if (TREE_CODE (init) == INTEGER_CST)</span>
<span class="lineNum">   20324 </span>            :     {
<span class="lineNum">   20325 </span><span class="lineCov">    2543968 :       if (tree_fits_uhwi_p (init))</span>
<span class="lineNum">   20326 </span>            :         {
<span class="lineNum">   20327 </span><span class="lineCov">    2517192 :           add_AT_unsigned (die, DW_AT_const_value, tree_to_uhwi (init));</span>
<span class="lineNum">   20328 </span><span class="lineCov">    2517192 :           return true;</span>
<span class="lineNum">   20329 </span>            :         }
<span class="lineNum">   20330 </span><span class="lineCov">      26776 :       if (tree_fits_shwi_p (init))</span>
<span class="lineNum">   20331 </span>            :         {
<span class="lineNum">   20332 </span><span class="lineCov">      26774 :           add_AT_int (die, DW_AT_const_value, tree_to_shwi (init));</span>
<span class="lineNum">   20333 </span><span class="lineCov">      26774 :           return true;</span>
<span class="lineNum">   20334 </span>            :         }
<span class="lineNum">   20335 </span>            :     }
<span class="lineNum">   20336 </span><span class="lineCov">      11352 :   if (! early_dwarf)</span>
<span class="lineNum">   20337 </span>            :     {
<span class="lineNum">   20338 </span><span class="lineCov">       5671 :       rtl = rtl_for_decl_init (init, type);</span>
<span class="lineNum">   20339 </span><span class="lineCov">       5671 :       if (rtl)</span>
<span class="lineNum">   20340 </span><span class="lineCov">       4241 :         return add_const_value_attribute (die, rtl);</span>
<span class="lineNum">   20341 </span>            :     }
<span class="lineNum">   20342 </span>            :   /* If the host and target are sane, try harder.  */
<span class="lineNum">   20343 </span><span class="lineCov">       7111 :   if (CHAR_BIT == 8 &amp;&amp; BITS_PER_UNIT == 8</span>
<span class="lineNum">   20344 </span><span class="lineCov">       7111 :       &amp;&amp; initializer_constant_valid_p (init, type))</span>
<span class="lineNum">   20345 </span>            :     {
<span class="lineNum">   20346 </span><span class="lineCov">       7109 :       HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (init));</span>
<span class="lineNum">   20347 </span><span class="lineCov">       7109 :       if (size &gt; 0 &amp;&amp; (int) size == size)</span>
<span class="lineNum">   20348 </span>            :         {
<span class="lineNum">   20349 </span><span class="lineCov">       7082 :           unsigned char *array = ggc_cleared_vec_alloc&lt;unsigned char&gt; (size);</span>
<span class="lineNum">   20350 </span>            : 
<span class="lineNum">   20351 </span><span class="lineCov">       7082 :           if (native_encode_initializer (init, array, size))</span>
<span class="lineNum">   20352 </span>            :             {
<span class="lineNum">   20353 </span><span class="lineCov">       5763 :               add_AT_vec (die, DW_AT_const_value, size, 1, array);</span>
<span class="lineNum">   20354 </span><span class="lineCov">       5763 :               return true;</span>
<span class="lineNum">   20355 </span>            :             }
<span class="lineNum">   20356 </span><span class="lineCov">       1319 :           ggc_free (array);</span>
<span class="lineNum">   20357 </span>            :         }
<span class="lineNum">   20358 </span>            :     }
<span class="lineNum">   20359 </span>            :   return false;
<span class="lineNum">   20360 </span>            : }
<span class="lineNum">   20361 </span>            : 
<span class="lineNum">   20362 </span>            : /* Attach a DW_AT_const_value attribute to VAR_DIE. The value of the
<span class="lineNum">   20363 </span>            :    attribute is the const value of T, where T is an integral constant
<span class="lineNum">   20364 </span>            :    variable with static storage duration
<span class="lineNum">   20365 </span>            :    (so it can't be a PARM_DECL or a RESULT_DECL).  */
<a name="20366"><span class="lineNum">   20366 </span>            : </a>
<span class="lineNum">   20367 </span>            : static bool
<span class="lineNum">   20368 </span><span class="lineCov">    7330100 : tree_add_const_value_attribute_for_decl (dw_die_ref var_die, tree decl)</span>
<span class="lineNum">   20369 </span>            : {
<span class="lineNum">   20370 </span>            : 
<span class="lineNum">   20371 </span><span class="lineCov">    7330100 :   if (!decl</span>
<span class="lineNum">   20372 </span><span class="lineCov">    7330100 :       || (!VAR_P (decl) &amp;&amp; TREE_CODE (decl) != CONST_DECL)</span>
<span class="lineNum">   20373 </span><span class="lineCov">    7329546 :       || (VAR_P (decl) &amp;&amp; !TREE_STATIC (decl)))</span>
<span class="lineNum">   20374 </span>            :     return false;
<span class="lineNum">   20375 </span>            : 
<span class="lineNum">   20376 </span><span class="lineCov">    5976830 :   if (TREE_READONLY (decl)</span>
<span class="lineNum">   20377 </span><span class="lineCov">    5907198 :       &amp;&amp; ! TREE_THIS_VOLATILE (decl)</span>
<span class="lineNum">   20378 </span><span class="lineCov">   11883854 :       &amp;&amp; DECL_INITIAL (decl))</span>
<span class="lineNum">   20379 </span>            :     /* OK */;
<span class="lineNum">   20380 </span>            :   else
<span class="lineNum">   20381 </span>            :     return false;
<span class="lineNum">   20382 </span>            : 
<span class="lineNum">   20383 </span>            :   /* Don't add DW_AT_const_value if abstract origin already has one.  */
<span class="lineNum">   20384 </span><span class="lineCov">    5114998 :   if (get_AT (var_die, DW_AT_const_value))</span>
<span class="lineNum">   20385 </span>            :     return false;
<span class="lineNum">   20386 </span>            : 
<span class="lineNum">   20387 </span><span class="lineCov">    1622042 :   return tree_add_const_value_attribute (var_die, DECL_INITIAL (decl));</span>
<span class="lineNum">   20388 </span>            : }
<span class="lineNum">   20389 </span>            : 
<span class="lineNum">   20390 </span>            : /* Convert the CFI instructions for the current function into a
<span class="lineNum">   20391 </span>            :    location list.  This is used for DW_AT_frame_base when we targeting
<span class="lineNum">   20392 </span>            :    a dwarf2 consumer that does not support the dwarf3
<span class="lineNum">   20393 </span>            :    DW_OP_call_frame_cfa.  OFFSET is a constant to be added to all CFA
<span class="lineNum">   20394 </span>            :    expressions.  */
<a name="20395"><span class="lineNum">   20395 </span>            : </a>
<span class="lineNum">   20396 </span>            : static dw_loc_list_ref
<span class="lineNum">   20397 </span><span class="lineCov">       2644 : convert_cfa_to_fb_loc_list (HOST_WIDE_INT offset)</span>
<span class="lineNum">   20398 </span>            : {
<span class="lineNum">   20399 </span><span class="lineCov">       2644 :   int ix;</span>
<span class="lineNum">   20400 </span><span class="lineCov">       2644 :   dw_fde_ref fde;</span>
<span class="lineNum">   20401 </span><span class="lineCov">       2644 :   dw_loc_list_ref list, *list_tail;</span>
<span class="lineNum">   20402 </span><span class="lineCov">       2644 :   dw_cfi_ref cfi;</span>
<span class="lineNum">   20403 </span><span class="lineCov">       2644 :   dw_cfa_location last_cfa, next_cfa;</span>
<span class="lineNum">   20404 </span><span class="lineCov">       2644 :   const char *start_label, *last_label, *section;</span>
<span class="lineNum">   20405 </span><span class="lineCov">       2644 :   dw_cfa_location remember;</span>
<span class="lineNum">   20406 </span>            : 
<span class="lineNum">   20407 </span><span class="lineCov">       2644 :   fde = cfun-&gt;fde;</span>
<span class="lineNum">   20408 </span><span class="lineCov">       2644 :   gcc_assert (fde != NULL);</span>
<span class="lineNum">   20409 </span>            : 
<span class="lineNum">   20410 </span><span class="lineCov">       2644 :   section = secname_for_decl (current_function_decl);</span>
<span class="lineNum">   20411 </span><span class="lineCov">       2644 :   list_tail = &amp;list;</span>
<span class="lineNum">   20412 </span><span class="lineCov">       2644 :   list = NULL;</span>
<span class="lineNum">   20413 </span>            : 
<span class="lineNum">   20414 </span><span class="lineCov">       2644 :   memset (&amp;next_cfa, 0, sizeof (next_cfa));</span>
<span class="lineNum">   20415 </span><span class="lineCov">       2644 :   next_cfa.reg = INVALID_REGNUM;</span>
<span class="lineNum">   20416 </span><span class="lineCov">       2644 :   remember = next_cfa;</span>
<span class="lineNum">   20417 </span>            : 
<span class="lineNum">   20418 </span><span class="lineCov">       2644 :   start_label = fde-&gt;dw_fde_begin;</span>
<span class="lineNum">   20419 </span>            : 
<span class="lineNum">   20420 </span>            :   /* ??? Bald assumption that the CIE opcode list does not contain
<span class="lineNum">   20421 </span>            :      advance opcodes.  */
<span class="lineNum">   20422 </span><span class="lineCov">       7932 :   FOR_EACH_VEC_ELT (*cie_cfi_vec, ix, cfi)</span>
<span class="lineNum">   20423 </span><span class="lineCov">       5288 :     lookup_cfa_1 (cfi, &amp;next_cfa, &amp;remember);</span>
<span class="lineNum">   20424 </span>            : 
<span class="lineNum">   20425 </span><span class="lineCov">       2644 :   last_cfa = next_cfa;</span>
<span class="lineNum">   20426 </span><span class="lineCov">       2644 :   last_label = start_label;</span>
<span class="lineNum">   20427 </span>            : 
<span class="lineNum">   20428 </span><span class="lineCov">       2644 :   if (fde-&gt;dw_fde_second_begin &amp;&amp; fde-&gt;dw_fde_switch_cfi_index == 0)</span>
<span class="lineNum">   20429 </span>            :     {
<span class="lineNum">   20430 </span>            :       /* If the first partition contained no CFI adjustments, the
<span class="lineNum">   20431 </span>            :          CIE opcodes apply to the whole first partition.  */
<span class="lineNum">   20432 </span><span class="lineNoCov">          0 :       *list_tail = new_loc_list (build_cfa_loc (&amp;last_cfa, offset),</span>
<span class="lineNum">   20433 </span>            :                                  fde-&gt;dw_fde_begin, 0, fde-&gt;dw_fde_end, 0, section);
<span class="lineNum">   20434 </span><span class="lineNoCov">          0 :       list_tail =&amp;(*list_tail)-&gt;dw_loc_next;</span>
<span class="lineNum">   20435 </span><span class="lineNoCov">          0 :       start_label = last_label = fde-&gt;dw_fde_second_begin;</span>
<span class="lineNum">   20436 </span>            :     }
<span class="lineNum">   20437 </span>            : 
<span class="lineNum">   20438 </span><span class="lineCov">      15484 :   FOR_EACH_VEC_SAFE_ELT (fde-&gt;dw_fde_cfi, ix, cfi)</span>
<span class="lineNum">   20439 </span>            :     {
<span class="lineNum">   20440 </span><span class="lineCov">      12840 :       switch (cfi-&gt;dw_cfi_opc)</span>
<span class="lineNum">   20441 </span>            :         {
<span class="lineNum">   20442 </span><span class="lineCov">       4921 :         case DW_CFA_set_loc:</span>
<span class="lineNum">   20443 </span><span class="lineCov">       4921 :         case DW_CFA_advance_loc1:</span>
<span class="lineNum">   20444 </span><span class="lineCov">       4921 :         case DW_CFA_advance_loc2:</span>
<span class="lineNum">   20445 </span><span class="lineCov">       4921 :         case DW_CFA_advance_loc4:</span>
<span class="lineNum">   20446 </span><span class="lineCov">       4921 :           if (!cfa_equal_p (&amp;last_cfa, &amp;next_cfa))</span>
<span class="lineNum">   20447 </span>            :             {
<span class="lineNum">   20448 </span><span class="lineCov">       6686 :               *list_tail = new_loc_list (build_cfa_loc (&amp;last_cfa, offset),</span>
<span class="lineNum">   20449 </span>            :                                          start_label, 0, last_label, 0, section);
<span class="lineNum">   20450 </span>            : 
<span class="lineNum">   20451 </span><span class="lineCov">       3343 :               list_tail = &amp;(*list_tail)-&gt;dw_loc_next;</span>
<span class="lineNum">   20452 </span><span class="lineCov">       3343 :               last_cfa = next_cfa;</span>
<span class="lineNum">   20453 </span><span class="lineCov">       3343 :               start_label = last_label;</span>
<span class="lineNum">   20454 </span>            :             }
<span class="lineNum">   20455 </span><span class="lineCov">       4921 :           last_label = cfi-&gt;dw_cfi_oprnd1.dw_cfi_addr;</span>
<span class="lineNum">   20456 </span><span class="lineCov">       4921 :           break;</span>
<span class="lineNum">   20457 </span>            : 
<span class="lineNum">   20458 </span><span class="lineNoCov">          0 :         case DW_CFA_advance_loc:</span>
<span class="lineNum">   20459 </span>            :           /* The encoding is complex enough that we should never emit this.  */
<span class="lineNum">   20460 </span><span class="lineNoCov">          0 :           gcc_unreachable ();</span>
<span class="lineNum">   20461 </span>            : 
<span class="lineNum">   20462 </span><span class="lineCov">       7919 :         default:</span>
<span class="lineNum">   20463 </span><span class="lineCov">       7919 :           lookup_cfa_1 (cfi, &amp;next_cfa, &amp;remember);</span>
<span class="lineNum">   20464 </span><span class="lineCov">       7919 :           break;</span>
<span class="lineNum">   20465 </span>            :         }
<span class="lineNum">   20466 </span><span class="lineCov">      12840 :       if (ix + 1 == fde-&gt;dw_fde_switch_cfi_index)</span>
<span class="lineNum">   20467 </span>            :         {
<span class="lineNum">   20468 </span><span class="lineCov">         33 :           if (!cfa_equal_p (&amp;last_cfa, &amp;next_cfa))</span>
<span class="lineNum">   20469 </span>            :             {
<span class="lineNum">   20470 </span><span class="lineCov">         64 :               *list_tail = new_loc_list (build_cfa_loc (&amp;last_cfa, offset),</span>
<span class="lineNum">   20471 </span>            :                                          start_label, 0, last_label, 0, section);
<span class="lineNum">   20472 </span>            : 
<span class="lineNum">   20473 </span><span class="lineCov">         32 :               list_tail = &amp;(*list_tail)-&gt;dw_loc_next;</span>
<span class="lineNum">   20474 </span><span class="lineCov">         32 :               last_cfa = next_cfa;</span>
<span class="lineNum">   20475 </span><span class="lineCov">         32 :               start_label = last_label;</span>
<span class="lineNum">   20476 </span>            :             }
<span class="lineNum">   20477 </span><span class="lineCov">         66 :           *list_tail = new_loc_list (build_cfa_loc (&amp;last_cfa, offset),</span>
<span class="lineNum">   20478 </span>            :                                      start_label, 0, fde-&gt;dw_fde_end, 0, section);
<span class="lineNum">   20479 </span><span class="lineCov">         33 :           list_tail = &amp;(*list_tail)-&gt;dw_loc_next;</span>
<span class="lineNum">   20480 </span><span class="lineCov">         33 :           start_label = last_label = fde-&gt;dw_fde_second_begin;</span>
<span class="lineNum">   20481 </span>            :         }
<span class="lineNum">   20482 </span>            :     }
<span class="lineNum">   20483 </span>            : 
<span class="lineNum">   20484 </span><span class="lineCov">       2644 :   if (!cfa_equal_p (&amp;last_cfa, &amp;next_cfa))</span>
<span class="lineNum">   20485 </span>            :     {
<span class="lineNum">   20486 </span><span class="lineCov">       3078 :       *list_tail = new_loc_list (build_cfa_loc (&amp;last_cfa, offset),</span>
<span class="lineNum">   20487 </span>            :                                  start_label, 0, last_label, 0, section);
<span class="lineNum">   20488 </span><span class="lineCov">       1539 :       list_tail = &amp;(*list_tail)-&gt;dw_loc_next;</span>
<span class="lineNum">   20489 </span><span class="lineCov">       1539 :       start_label = last_label;</span>
<span class="lineNum">   20490 </span>            :     }
<span class="lineNum">   20491 </span>            : 
<span class="lineNum">   20492 </span><span class="lineCov">       2644 :   *list_tail = new_loc_list (build_cfa_loc (&amp;next_cfa, offset),</span>
<span class="lineNum">   20493 </span>            :                              start_label, 0,
<span class="lineNum">   20494 </span><span class="lineCov">       2644 :                              fde-&gt;dw_fde_second_begin</span>
<span class="lineNum">   20495 </span>            :                              ? fde-&gt;dw_fde_second_end : fde-&gt;dw_fde_end, 0,
<span class="lineNum">   20496 </span>            :                              section);
<span class="lineNum">   20497 </span>            : 
<span class="lineNum">   20498 </span><span class="lineCov">       2644 :   maybe_gen_llsym (list);</span>
<span class="lineNum">   20499 </span>            : 
<span class="lineNum">   20500 </span><span class="lineCov">       2644 :   return list;</span>
<span class="lineNum">   20501 </span>            : }
<span class="lineNum">   20502 </span>            : 
<span class="lineNum">   20503 </span>            : /* Compute a displacement from the &quot;steady-state frame pointer&quot; to the
<span class="lineNum">   20504 </span>            :    frame base (often the same as the CFA), and store it in
<span class="lineNum">   20505 </span>            :    frame_pointer_fb_offset.  OFFSET is added to the displacement
<span class="lineNum">   20506 </span>            :    before the latter is negated.  */
<a name="20507"><span class="lineNum">   20507 </span>            : </a>
<span class="lineNum">   20508 </span>            : static void
<span class="lineNum">   20509 </span><span class="lineCov">     339893 : compute_frame_pointer_to_fb_displacement (poly_int64 offset)</span>
<span class="lineNum">   20510 </span>            : {
<span class="lineNum">   20511 </span><span class="lineCov">     339893 :   rtx reg, elim;</span>
<span class="lineNum">   20512 </span>            : 
<span class="lineNum">   20513 </span>            : #ifdef FRAME_POINTER_CFA_OFFSET
<span class="lineNum">   20514 </span>            :   reg = frame_pointer_rtx;
<span class="lineNum">   20515 </span>            :   offset += FRAME_POINTER_CFA_OFFSET (current_function_decl);
<span class="lineNum">   20516 </span>            : #else
<span class="lineNum">   20517 </span><span class="lineCov">     339893 :   reg = arg_pointer_rtx;</span>
<span class="lineNum">   20518 </span><span class="lineCov">     339893 :   offset += ARG_POINTER_CFA_OFFSET (current_function_decl);</span>
<span class="lineNum">   20519 </span>            : #endif
<span class="lineNum">   20520 </span>            : 
<span class="lineNum">   20521 </span><span class="lineCov">     679786 :   elim = (ira_use_lra_p</span>
<span class="lineNum">   20522 </span><span class="lineCov">     339893 :           ? lra_eliminate_regs (reg, VOIDmode, NULL_RTX)</span>
<span class="lineNum">   20523 </span><span class="lineNoCov">          0 :           : eliminate_regs (reg, VOIDmode, NULL_RTX));</span>
<span class="lineNum">   20524 </span><span class="lineCov">     339893 :   elim = strip_offset_and_add (elim, &amp;offset);</span>
<span class="lineNum">   20525 </span>            : 
<span class="lineNum">   20526 </span><span class="lineCov">     339893 :   frame_pointer_fb_offset = -offset;</span>
<span class="lineNum">   20527 </span>            : 
<span class="lineNum">   20528 </span>            :   /* ??? AVR doesn't set up valid eliminations when there is no stack frame
<span class="lineNum">   20529 </span>            :      in which to eliminate.  This is because it's stack pointer isn't 
<span class="lineNum">   20530 </span>            :      directly accessible as a register within the ISA.  To work around
<span class="lineNum">   20531 </span>            :      this, assume that while we cannot provide a proper value for
<span class="lineNum">   20532 </span>            :      frame_pointer_fb_offset, we won't need one either.  We can use
<span class="lineNum">   20533 </span>            :      hard frame pointer in debug info even if frame pointer isn't used
<span class="lineNum">   20534 </span>            :      since hard frame pointer in debug info is encoded with DW_OP_fbreg
<span class="lineNum">   20535 </span>            :      which uses the DW_AT_frame_base attribute, not hard frame pointer
<span class="lineNum">   20536 </span>            :      directly.  */
<span class="lineNum">   20537 </span><span class="lineCov">     339893 :   frame_pointer_fb_offset_valid</span>
<span class="lineNum">   20538 </span><span class="lineCov">     339893 :     = (elim == hard_frame_pointer_rtx || elim == stack_pointer_rtx);</span>
<span class="lineNum">   20539 </span><span class="lineCov">     339893 : }</span>
<span class="lineNum">   20540 </span>            : 
<span class="lineNum">   20541 </span>            : /* Generate a DW_AT_name attribute given some string value to be included as
<span class="lineNum">   20542 </span>            :    the value of the attribute.  */
<a name="20543"><span class="lineNum">   20543 </span>            : </a>
<span class="lineNum">   20544 </span>            : static void
<span class="lineNum">   20545 </span><span class="lineCov">   35119797 : add_name_attribute (dw_die_ref die, const char *name_string)</span>
<span class="lineNum">   20546 </span>            : {
<span class="lineNum">   20547 </span><span class="lineCov">   35119797 :   if (name_string != NULL &amp;&amp; *name_string != 0)</span>
<span class="lineNum">   20548 </span>            :     {
<span class="lineNum">   20549 </span><span class="lineCov">   34404583 :       if (demangle_name_func)</span>
<span class="lineNum">   20550 </span><span class="lineNoCov">          0 :         name_string = (*demangle_name_func) (name_string);</span>
<span class="lineNum">   20551 </span>            : 
<span class="lineNum">   20552 </span><span class="lineCov">   34404583 :       add_AT_string (die, DW_AT_name, name_string);</span>
<span class="lineNum">   20553 </span>            :     }
<span class="lineNum">   20554 </span><span class="lineCov">   35119797 : }</span>
<span class="lineNum">   20555 </span>            : 
<span class="lineNum">   20556 </span>            : /* Generate a DW_AT_description attribute given some string value to be included
<span class="lineNum">   20557 </span>            :    as the value of the attribute.  */
<a name="20558"><span class="lineNum">   20558 </span>            : </a>
<span class="lineNum">   20559 </span>            : static void
<span class="lineNum">   20560 </span><span class="lineNoCov">          0 : add_desc_attribute (dw_die_ref die, const char *name_string)</span>
<span class="lineNum">   20561 </span>            : {
<span class="lineNum">   20562 </span><span class="lineNoCov">          0 :   if (!flag_describe_dies || (dwarf_version &lt; 3 &amp;&amp; dwarf_strict))</span>
<span class="lineNum">   20563 </span>            :     return;
<span class="lineNum">   20564 </span>            : 
<span class="lineNum">   20565 </span><span class="lineNoCov">          0 :   if (name_string == NULL || *name_string == 0)</span>
<span class="lineNum">   20566 </span>            :     return;
<span class="lineNum">   20567 </span>            : 
<span class="lineNum">   20568 </span><span class="lineNoCov">          0 :   if (demangle_name_func)</span>
<span class="lineNum">   20569 </span><span class="lineNoCov">          0 :     name_string = (*demangle_name_func) (name_string);</span>
<span class="lineNum">   20570 </span>            : 
<span class="lineNum">   20571 </span><span class="lineNoCov">          0 :   add_AT_string (die, DW_AT_description, name_string);</span>
<span class="lineNum">   20572 </span>            : }
<span class="lineNum">   20573 </span>            : 
<span class="lineNum">   20574 </span>            : /* Generate a DW_AT_description attribute given some decl to be included
<span class="lineNum">   20575 </span>            :    as the value of the attribute.  */
<a name="20576"><span class="lineNum">   20576 </span>            : </a>
<span class="lineNum">   20577 </span>            : static void
<span class="lineNum">   20578 </span><span class="lineCov">    5197130 : add_desc_attribute (dw_die_ref die, tree decl)</span>
<span class="lineNum">   20579 </span>            : {
<span class="lineNum">   20580 </span><span class="lineCov">    5197130 :   tree decl_name;</span>
<span class="lineNum">   20581 </span>            : 
<span class="lineNum">   20582 </span><span class="lineCov">    5197130 :   if (!flag_describe_dies || (dwarf_version &lt; 3 &amp;&amp; dwarf_strict))</span>
<span class="lineNum">   20583 </span>            :     return;
<span class="lineNum">   20584 </span>            : 
<span class="lineNum">   20585 </span><span class="lineNoCov">          0 :   if (decl == NULL_TREE || !DECL_P (decl))</span>
<span class="lineNum">   20586 </span>            :     return;
<span class="lineNum">   20587 </span><span class="lineNoCov">          0 :   decl_name = DECL_NAME (decl);</span>
<span class="lineNum">   20588 </span>            : 
<span class="lineNum">   20589 </span><span class="lineNoCov">          0 :   if (decl_name != NULL &amp;&amp; IDENTIFIER_POINTER (decl_name) != NULL)</span>
<span class="lineNum">   20590 </span>            :     {
<span class="lineNum">   20591 </span><span class="lineNoCov">          0 :       const char *name = dwarf2_name (decl, 0);</span>
<span class="lineNum">   20592 </span><span class="lineNoCov">          0 :       add_desc_attribute (die, name ? name : IDENTIFIER_POINTER (decl_name));</span>
<span class="lineNum">   20593 </span>            :     }
<span class="lineNum">   20594 </span>            :   else
<span class="lineNum">   20595 </span>            :     {
<span class="lineNum">   20596 </span><span class="lineNoCov">          0 :       char *desc = print_generic_expr_to_str (decl);</span>
<span class="lineNum">   20597 </span><span class="lineNoCov">          0 :       add_desc_attribute (die, desc);</span>
<span class="lineNum">   20598 </span><span class="lineNoCov">          0 :       free (desc);</span>
<span class="lineNum">   20599 </span>            :     }
<span class="lineNum">   20600 </span>            : }
<span class="lineNum">   20601 </span>            : 
<span class="lineNum">   20602 </span>            : /* Retrieve the descriptive type of TYPE, if any, make sure it has a
<span class="lineNum">   20603 </span>            :    DIE and attach a DW_AT_GNAT_descriptive_type attribute to the DIE
<span class="lineNum">   20604 </span>            :    of TYPE accordingly.
<span class="lineNum">   20605 </span>            : 
<span class="lineNum">   20606 </span>            :    ??? This is a temporary measure until after we're able to generate
<span class="lineNum">   20607 </span>            :    regular DWARF for the complex Ada type system.  */
<a name="20608"><span class="lineNum">   20608 </span>            : </a>
<span class="lineNum">   20609 </span>            : static void 
<span class="lineNum">   20610 </span><span class="lineCov">   12710839 : add_gnat_descriptive_type_attribute (dw_die_ref die, tree type,</span>
<span class="lineNum">   20611 </span>            :                                      dw_die_ref context_die)
<span class="lineNum">   20612 </span>            : {
<span class="lineNum">   20613 </span><span class="lineCov">   12710839 :   tree dtype;</span>
<span class="lineNum">   20614 </span><span class="lineCov">   12710839 :   dw_die_ref dtype_die;</span>
<span class="lineNum">   20615 </span>            : 
<span class="lineNum">   20616 </span><span class="lineCov">   12710839 :   if (!lang_hooks.types.descriptive_type)</span>
<span class="lineNum">   20617 </span>            :     return;
<span class="lineNum">   20618 </span>            : 
<span class="lineNum">   20619 </span><span class="lineNoCov">          0 :   dtype = lang_hooks.types.descriptive_type (type);</span>
<span class="lineNum">   20620 </span><span class="lineNoCov">          0 :   if (!dtype)</span>
<span class="lineNum">   20621 </span>            :     return;
<span class="lineNum">   20622 </span>            : 
<span class="lineNum">   20623 </span><span class="lineNoCov">          0 :   dtype_die = lookup_type_die (dtype);</span>
<span class="lineNum">   20624 </span><span class="lineNoCov">          0 :   if (!dtype_die)</span>
<span class="lineNum">   20625 </span>            :     {
<span class="lineNum">   20626 </span><span class="lineNoCov">          0 :       gen_type_die (dtype, context_die);</span>
<span class="lineNum">   20627 </span><span class="lineNoCov">          0 :       dtype_die = lookup_type_die (dtype);</span>
<span class="lineNum">   20628 </span><span class="lineNoCov">          0 :       gcc_assert (dtype_die);</span>
<span class="lineNum">   20629 </span>            :     }
<span class="lineNum">   20630 </span>            : 
<span class="lineNum">   20631 </span><span class="lineNoCov">          0 :   add_AT_die_ref (die, DW_AT_GNAT_descriptive_type, dtype_die);</span>
<span class="lineNum">   20632 </span>            : }
<span class="lineNum">   20633 </span>            : 
<span class="lineNum">   20634 </span>            : /* Retrieve the comp_dir string suitable for use with DW_AT_comp_dir.  */
<a name="20635"><span class="lineNum">   20635 </span>            : </a>
<span class="lineNum">   20636 </span>            : static const char *
<span class="lineNum">   20637 </span><span class="lineCov">      34148 : comp_dir_string (void)</span>
<span class="lineNum">   20638 </span>            : {
<span class="lineNum">   20639 </span><span class="lineCov">      34148 :   const char *wd;</span>
<span class="lineNum">   20640 </span><span class="lineCov">      34148 :   char *wd1;</span>
<span class="lineNum">   20641 </span><span class="lineCov">      34148 :   static const char *cached_wd = NULL;</span>
<span class="lineNum">   20642 </span>            : 
<span class="lineNum">   20643 </span><span class="lineCov">      34148 :   if (cached_wd != NULL)</span>
<span class="lineNum">   20644 </span>            :     return cached_wd;
<span class="lineNum">   20645 </span>            : 
<span class="lineNum">   20646 </span><span class="lineCov">      33756 :   wd = get_src_pwd ();</span>
<span class="lineNum">   20647 </span><span class="lineCov">      33756 :   if (wd == NULL)</span>
<span class="lineNum">   20648 </span>            :     return NULL;
<span class="lineNum">   20649 </span>            : 
<span class="lineNum">   20650 </span><span class="lineCov">      33756 :   if (DWARF2_DIR_SHOULD_END_WITH_SEPARATOR)</span>
<span class="lineNum">   20651 </span>            :     {
<span class="lineNum">   20652 </span>            :       int wdlen;
<span class="lineNum">   20653 </span>            : 
<span class="lineNum">   20654 </span>            :       wdlen = strlen (wd);
<span class="lineNum">   20655 </span>            :       wd1 = ggc_vec_alloc&lt;char&gt; (wdlen + 2);
<span class="lineNum">   20656 </span>            :       strcpy (wd1, wd);
<span class="lineNum">   20657 </span>            :       wd1 [wdlen] = DIR_SEPARATOR;
<span class="lineNum">   20658 </span>            :       wd1 [wdlen + 1] = 0;
<span class="lineNum">   20659 </span>            :       wd = wd1;
<span class="lineNum">   20660 </span>            :     }
<span class="lineNum">   20661 </span>            : 
<span class="lineNum">   20662 </span><span class="lineCov">      33756 :   cached_wd = remap_debug_filename (wd);</span>
<span class="lineNum">   20663 </span><span class="lineCov">      33756 :   return cached_wd;</span>
<span class="lineNum">   20664 </span>            : }
<span class="lineNum">   20665 </span>            : 
<span class="lineNum">   20666 </span>            : /* Generate a DW_AT_comp_dir attribute for DIE.  */
<a name="20667"><span class="lineNum">   20667 </span>            : </a>
<span class="lineNum">   20668 </span>            : static void
<span class="lineNum">   20669 </span><span class="lineCov">      34141 : add_comp_dir_attribute (dw_die_ref die)</span>
<span class="lineNum">   20670 </span>            : {
<span class="lineNum">   20671 </span><span class="lineCov">      34141 :   const char * wd = comp_dir_string ();</span>
<span class="lineNum">   20672 </span><span class="lineCov">      34141 :   if (wd != NULL)</span>
<span class="lineNum">   20673 </span><span class="lineCov">      34141 :     add_AT_string (die, DW_AT_comp_dir, wd);</span>
<span class="lineNum">   20674 </span><span class="lineCov">      34141 : }</span>
<span class="lineNum">   20675 </span>            : 
<span class="lineNum">   20676 </span>            : /* Given a tree node VALUE describing a scalar attribute ATTR (i.e. a bound, a
<span class="lineNum">   20677 </span>            :    pointer computation, ...), output a representation for that bound according
<span class="lineNum">   20678 </span>            :    to the accepted FORMS (see enum dw_scalar_form) and add it to DIE.  See
<span class="lineNum">   20679 </span>            :    loc_list_from_tree for the meaning of CONTEXT.  */
<a name="20680"><span class="lineNum">   20680 </span>            : </a>
<span class="lineNum">   20681 </span>            : static void
<span class="lineNum">   20682 </span><span class="lineCov">     260914 : add_scalar_info (dw_die_ref die, enum dwarf_attribute attr, tree value,</span>
<span class="lineNum">   20683 </span>            :                  int forms, struct loc_descr_context *context)
<span class="lineNum">   20684 </span>            : {
<span class="lineNum">   20685 </span><span class="lineCov">     260914 :   dw_die_ref context_die, decl_die = NULL;</span>
<span class="lineNum">   20686 </span><span class="lineCov">     260914 :   dw_loc_list_ref list;</span>
<span class="lineNum">   20687 </span><span class="lineCov">     260914 :   bool strip_conversions = true;</span>
<span class="lineNum">   20688 </span><span class="lineCov">     260914 :   bool placeholder_seen = false;</span>
<span class="lineNum">   20689 </span>            : 
<span class="lineNum">   20690 </span><span class="lineCov">     521811 :   while (strip_conversions)</span>
<span class="lineNum">   20691 </span><span class="lineCov">     260914 :     switch (TREE_CODE (value))</span>
<span class="lineNum">   20692 </span>            :       {
<span class="lineNum">   20693 </span>            :       case ERROR_MARK:
<span class="lineNum">   20694 </span>            :       case SAVE_EXPR:
<span class="lineNum">   20695 </span>            :         return;
<span class="lineNum">   20696 </span>            : 
<span class="lineNum">   20697 </span><span class="lineNoCov">          0 :       CASE_CONVERT:</span>
<span class="lineNum">   20698 </span><span class="lineNoCov">          0 :       case VIEW_CONVERT_EXPR:</span>
<span class="lineNum">   20699 </span><span class="lineNoCov">          0 :         value = TREE_OPERAND (value, 0);</span>
<span class="lineNum">   20700 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">   20701 </span>            : 
<span class="lineNum">   20702 </span>            :       default:
<span class="lineNum">   20703 </span>            :         strip_conversions = false;
<span class="lineNum">   20704 </span>            :         break;
<span class="lineNum">   20705 </span>            :       }
<span class="lineNum">   20706 </span>            : 
<span class="lineNum">   20707 </span>            :   /* If possible and permitted, output the attribute as a constant.  */
<span class="lineNum">   20708 </span><span class="lineCov">     260897 :   if ((forms &amp; dw_scalar_form_constant) != 0</span>
<span class="lineNum">   20709 </span><span class="lineCov">     257909 :       &amp;&amp; TREE_CODE (value) == INTEGER_CST)</span>
<span class="lineNum">   20710 </span>            :     {
<span class="lineNum">   20711 </span><span class="lineCov">     224237 :       unsigned int prec = simple_type_size_in_bits (TREE_TYPE (value));</span>
<span class="lineNum">   20712 </span>            : 
<span class="lineNum">   20713 </span>            :       /* If HOST_WIDE_INT is big enough then represent the bound as
<span class="lineNum">   20714 </span>            :          a constant value.  We need to choose a form based on
<span class="lineNum">   20715 </span>            :          whether the type is signed or unsigned.  We cannot just
<span class="lineNum">   20716 </span>            :          call add_AT_unsigned if the value itself is positive
<span class="lineNum">   20717 </span>            :          (add_AT_unsigned might add the unsigned value encoded as
<span class="lineNum">   20718 </span>            :          DW_FORM_data[1248]).  Some DWARF consumers will lookup the
<span class="lineNum">   20719 </span>            :          bounds type and then sign extend any unsigned values found
<span class="lineNum">   20720 </span>            :          for signed types.  This is needed only for
<span class="lineNum">   20721 </span>            :          DW_AT_{lower,upper}_bound, since for most other attributes,
<span class="lineNum">   20722 </span>            :          consumers will treat DW_FORM_data[1248] as unsigned values,
<span class="lineNum">   20723 </span>            :          regardless of the underlying type.  */
<span class="lineNum">   20724 </span><span class="lineCov">     224237 :       if (prec &lt;= HOST_BITS_PER_WIDE_INT</span>
<span class="lineNum">   20725 </span><span class="lineNoCov">          0 :           || tree_fits_uhwi_p (value))</span>
<span class="lineNum">   20726 </span>            :         {
<span class="lineNum">   20727 </span><span class="lineCov">     224237 :           if (TYPE_UNSIGNED (TREE_TYPE (value)))</span>
<span class="lineNum">   20728 </span><span class="lineCov">     216986 :             add_AT_unsigned (die, attr, TREE_INT_CST_LOW (value));</span>
<span class="lineNum">   20729 </span>            :           else
<span class="lineNum">   20730 </span><span class="lineCov">       7251 :             add_AT_int (die, attr, TREE_INT_CST_LOW (value));</span>
<span class="lineNum">   20731 </span>            :         }
<span class="lineNum">   20732 </span>            :       else
<span class="lineNum">   20733 </span>            :         /* Otherwise represent the bound as an unsigned value with
<span class="lineNum">   20734 </span>            :            the precision of its type.  The precision and signedness
<span class="lineNum">   20735 </span>            :            of the type will be necessary to re-interpret it
<span class="lineNum">   20736 </span>            :            unambiguously.  */
<span class="lineNum">   20737 </span><span class="lineNoCov">          0 :         add_AT_wide (die, attr, wi::to_wide (value));</span>
<span class="lineNum">   20738 </span><span class="lineCov">     224237 :       return;</span>
<span class="lineNum">   20739 </span>            :     }
<span class="lineNum">   20740 </span>            : 
<span class="lineNum">   20741 </span>            :   /* Otherwise, if it's possible and permitted too, output a reference to
<span class="lineNum">   20742 </span>            :      another DIE.  */
<span class="lineNum">   20743 </span><span class="lineCov">      36660 :   if ((forms &amp; dw_scalar_form_reference) != 0)</span>
<span class="lineNum">   20744 </span>            :     {
<span class="lineNum">   20745 </span><span class="lineCov">      33672 :       tree decl = NULL_TREE;</span>
<span class="lineNum">   20746 </span>            : 
<span class="lineNum">   20747 </span>            :       /* Some type attributes reference an outer type.  For instance, the upper
<span class="lineNum">   20748 </span>            :          bound of an array may reference an embedding record (this happens in
<span class="lineNum">   20749 </span>            :          Ada).  */
<span class="lineNum">   20750 </span><span class="lineCov">      33672 :       if (TREE_CODE (value) == COMPONENT_REF</span>
<span class="lineNum">   20751 </span><span class="lineNoCov">          0 :           &amp;&amp; TREE_CODE (TREE_OPERAND (value, 0)) == PLACEHOLDER_EXPR</span>
<span class="lineNum">   20752 </span><span class="lineCov">      33672 :           &amp;&amp; TREE_CODE (TREE_OPERAND (value, 1)) == FIELD_DECL)</span>
<span class="lineNum">   20753 </span><span class="lineNoCov">          0 :         decl = TREE_OPERAND (value, 1);</span>
<span class="lineNum">   20754 </span>            : 
<span class="lineNum">   20755 </span><span class="lineCov">      33672 :       else if (VAR_P (value)</span>
<span class="lineNum">   20756 </span><span class="lineCov">      31278 :                || TREE_CODE (value) == PARM_DECL</span>
<span class="lineNum">   20757 </span><span class="lineCov">      30927 :                || TREE_CODE (value) == RESULT_DECL)</span>
<span class="lineNum">   20758 </span>            :         decl = value;
<span class="lineNum">   20759 </span>            : 
<span class="lineNum">   20760 </span><span class="lineCov">       2745 :       if (decl != NULL_TREE)</span>
<span class="lineNum">   20761 </span>            :         {
<span class="lineNum">   20762 </span><span class="lineCov">       2745 :           decl_die = lookup_decl_die (decl);</span>
<span class="lineNum">   20763 </span>            : 
<span class="lineNum">   20764 </span>            :           /* ??? Can this happen, or should the variable have been bound
<span class="lineNum">   20765 </span>            :              first?  Probably it can, since I imagine that we try to create
<span class="lineNum">   20766 </span>            :              the types of parameters in the order in which they exist in
<span class="lineNum">   20767 </span>            :              the list, and won't have created a forward reference to a
<span class="lineNum">   20768 </span>            :              later parameter.  */
<span class="lineNum">   20769 </span><span class="lineCov">       2745 :           if (decl_die != NULL)</span>
<span class="lineNum">   20770 </span>            :             {
<span class="lineNum">   20771 </span><span class="lineCov">       1706 :               if (get_AT (decl_die, DW_AT_location)</span>
<span class="lineNum">   20772 </span><span class="lineCov">       1706 :                   || get_AT (decl_die, DW_AT_const_value))</span>
<span class="lineNum">   20773 </span>            :                 {
<span class="lineNum">   20774 </span><span class="lineCov">         64 :                   add_AT_die_ref (die, attr, decl_die);</span>
<span class="lineNum">   20775 </span><span class="lineCov">         64 :                   return;</span>
<span class="lineNum">   20776 </span>            :                 }
<span class="lineNum">   20777 </span>            :             }
<span class="lineNum">   20778 </span>            :         }
<span class="lineNum">   20779 </span>            :     }
<span class="lineNum">   20780 </span>            : 
<span class="lineNum">   20781 </span>            :   /* Last chance: try to create a stack operation procedure to evaluate the
<span class="lineNum">   20782 </span>            :      value.  Do nothing if even that is not possible or permitted.  */
<span class="lineNum">   20783 </span><span class="lineCov">      36596 :   if ((forms &amp; dw_scalar_form_exprloc) == 0)</span>
<span class="lineNum">   20784 </span>            :     return;
<span class="lineNum">   20785 </span>            : 
<span class="lineNum">   20786 </span><span class="lineCov">      36596 :   list = loc_list_from_tree (value, 2, context);</span>
<span class="lineNum">   20787 </span><span class="lineCov">      36596 :   if (context &amp;&amp; context-&gt;placeholder_arg)</span>
<span class="lineNum">   20788 </span>            :     {
<span class="lineNum">   20789 </span><span class="lineNoCov">          0 :       placeholder_seen = context-&gt;placeholder_seen;</span>
<span class="lineNum">   20790 </span><span class="lineNoCov">          0 :       context-&gt;placeholder_seen = false;</span>
<span class="lineNum">   20791 </span>            :     }
<span class="lineNum">   20792 </span><span class="lineCov">      36596 :   if (list == NULL || single_element_loc_list_p (list))</span>
<span class="lineNum">   20793 </span>            :     {
<span class="lineNum">   20794 </span>            :       /* If this attribute is not a reference nor constant, it is
<span class="lineNum">   20795 </span>            :          a DWARF expression rather than location description.  For that
<span class="lineNum">   20796 </span>            :          loc_list_from_tree (value, 0, &amp;context) is needed.  */
<span class="lineNum">   20797 </span><span class="lineCov">      36278 :       dw_loc_list_ref list2 = loc_list_from_tree (value, 0, context);</span>
<span class="lineNum">   20798 </span><span class="lineCov">      36278 :       if (list2 &amp;&amp; single_element_loc_list_p (list2))</span>
<span class="lineNum">   20799 </span>            :         {
<span class="lineNum">   20800 </span><span class="lineCov">      36227 :           if (placeholder_seen)</span>
<span class="lineNum">   20801 </span>            :             {
<span class="lineNum">   20802 </span><span class="lineNoCov">          0 :               struct dwarf_procedure_info dpi;</span>
<span class="lineNum">   20803 </span><span class="lineNoCov">          0 :               dpi.fndecl = NULL_TREE;</span>
<span class="lineNum">   20804 </span><span class="lineNoCov">          0 :               dpi.args_count = 1;</span>
<span class="lineNum">   20805 </span><span class="lineNoCov">          0 :               if (!resolve_args_picking (list2-&gt;expr, 1, &amp;dpi))</span>
<span class="lineNum">   20806 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">   20807 </span>            :             }
<span class="lineNum">   20808 </span><span class="lineCov">      36227 :           add_AT_loc (die, attr, list2-&gt;expr);</span>
<span class="lineNum">   20809 </span><span class="lineCov">      36227 :           return;</span>
<span class="lineNum">   20810 </span>            :         }
<span class="lineNum">   20811 </span>            :     }
<span class="lineNum">   20812 </span>            : 
<span class="lineNum">   20813 </span>            :   /* If that failed to give a single element location list, fall back to
<span class="lineNum">   20814 </span>            :      outputting this as a reference... still if permitted.  */
<span class="lineNum">   20815 </span><span class="lineCov">        369 :   if (list == NULL</span>
<span class="lineNum">   20816 </span><span class="lineCov">        318 :       || (forms &amp; dw_scalar_form_reference) == 0</span>
<span class="lineNum">   20817 </span><span class="lineCov">        318 :       || placeholder_seen)</span>
<span class="lineNum">   20818 </span>            :     return;
<span class="lineNum">   20819 </span>            : 
<span class="lineNum">   20820 </span><span class="lineCov">        318 :   if (!decl_die)</span>
<span class="lineNum">   20821 </span>            :     {
<span class="lineNum">   20822 </span><span class="lineCov">         58 :       if (current_function_decl == 0)</span>
<span class="lineNum">   20823 </span><span class="lineNoCov">          0 :         context_die = comp_unit_die ();</span>
<span class="lineNum">   20824 </span>            :       else
<span class="lineNum">   20825 </span><span class="lineCov">         58 :         context_die = lookup_decl_die (current_function_decl);</span>
<span class="lineNum">   20826 </span>            : 
<span class="lineNum">   20827 </span><span class="lineCov">         58 :       decl_die = new_die (DW_TAG_variable, context_die, value);</span>
<span class="lineNum">   20828 </span><span class="lineCov">         58 :       add_AT_flag (decl_die, DW_AT_artificial, 1);</span>
<span class="lineNum">   20829 </span><span class="lineCov">         58 :       add_type_attribute (decl_die, TREE_TYPE (value), TYPE_QUAL_CONST, false,</span>
<span class="lineNum">   20830 </span>            :                           context_die);
<span class="lineNum">   20831 </span>            :     }
<span class="lineNum">   20832 </span>            : 
<span class="lineNum">   20833 </span><span class="lineCov">        318 :   add_AT_location_description (decl_die, DW_AT_location, list);</span>
<span class="lineNum">   20834 </span><span class="lineCov">        318 :   add_AT_die_ref (die, attr, decl_die);</span>
<span class="lineNum">   20835 </span>            : }
<span class="lineNum">   20836 </span>            : 
<span class="lineNum">   20837 </span>            : /* Return the default for DW_AT_lower_bound, or -1 if there is not any
<span class="lineNum">   20838 </span>            :    default.  */
<a name="20839"><span class="lineNum">   20839 </span>            : </a>
<span class="lineNum">   20840 </span>            : static int
<span class="lineNum">   20841 </span><span class="lineCov">     225453 : lower_bound_default (void)</span>
<span class="lineNum">   20842 </span>            : {
<span class="lineNum">   20843 </span><span class="lineCov">     225453 :   switch (get_AT_unsigned (comp_unit_die (), DW_AT_language))</span>
<span class="lineNum">   20844 </span>            :     {
<span class="lineNum">   20845 </span>            :     case DW_LANG_C:
<span class="lineNum">   20846 </span>            :     case DW_LANG_C89:
<span class="lineNum">   20847 </span>            :     case DW_LANG_C99:
<span class="lineNum">   20848 </span>            :     case DW_LANG_C11:
<span class="lineNum">   20849 </span>            :     case DW_LANG_C_plus_plus:
<span class="lineNum">   20850 </span>            :     case DW_LANG_C_plus_plus_11:
<span class="lineNum">   20851 </span>            :     case DW_LANG_C_plus_plus_14:
<span class="lineNum">   20852 </span>            :     case DW_LANG_ObjC:
<span class="lineNum">   20853 </span>            :     case DW_LANG_ObjC_plus_plus:
<span class="lineNum">   20854 </span>            :       return 0;
<span class="lineNum">   20855 </span><span class="lineCov">       9860 :     case DW_LANG_Fortran77:</span>
<span class="lineNum">   20856 </span><span class="lineCov">       9860 :     case DW_LANG_Fortran90:</span>
<span class="lineNum">   20857 </span><span class="lineCov">       9860 :     case DW_LANG_Fortran95:</span>
<span class="lineNum">   20858 </span><span class="lineCov">       9860 :     case DW_LANG_Fortran03:</span>
<span class="lineNum">   20859 </span><span class="lineCov">       9860 :     case DW_LANG_Fortran08:</span>
<span class="lineNum">   20860 </span><span class="lineCov">       9860 :       return 1;</span>
<span class="lineNum">   20861 </span><span class="lineNoCov">          0 :     case DW_LANG_UPC:</span>
<span class="lineNum">   20862 </span><span class="lineNoCov">          0 :     case DW_LANG_D:</span>
<span class="lineNum">   20863 </span><span class="lineNoCov">          0 :     case DW_LANG_Python:</span>
<span class="lineNum">   20864 </span><span class="lineNoCov">          0 :       return dwarf_version &gt;= 4 ? 0 : -1;</span>
<span class="lineNum">   20865 </span><span class="lineNoCov">          0 :     case DW_LANG_Ada95:</span>
<span class="lineNum">   20866 </span><span class="lineNoCov">          0 :     case DW_LANG_Ada83:</span>
<span class="lineNum">   20867 </span><span class="lineNoCov">          0 :     case DW_LANG_Cobol74:</span>
<span class="lineNum">   20868 </span><span class="lineNoCov">          0 :     case DW_LANG_Cobol85:</span>
<span class="lineNum">   20869 </span><span class="lineNoCov">          0 :     case DW_LANG_Modula2:</span>
<span class="lineNum">   20870 </span><span class="lineNoCov">          0 :     case DW_LANG_PLI:</span>
<span class="lineNum">   20871 </span><span class="lineNoCov">          0 :       return dwarf_version &gt;= 4 ? 1 : -1;</span>
<span class="lineNum">   20872 </span><span class="lineCov">       5775 :     default:</span>
<span class="lineNum">   20873 </span><span class="lineCov">       5775 :       return -1;</span>
<span class="lineNum">   20874 </span>            :     }
<span class="lineNum">   20875 </span>            : }
<span class="lineNum">   20876 </span>            : 
<span class="lineNum">   20877 </span>            : /* Given a tree node describing an array bound (either lower or upper) output
<span class="lineNum">   20878 </span>            :    a representation for that bound.  */
<a name="20879"><span class="lineNum">   20879 </span>            : </a>
<span class="lineNum">   20880 </span>            : static void
<span class="lineNum">   20881 </span><span class="lineCov">     463674 : add_bound_info (dw_die_ref subrange_die, enum dwarf_attribute bound_attr,</span>
<span class="lineNum">   20882 </span>            :                 tree bound, struct loc_descr_context *context)
<span class="lineNum">   20883 </span>            : {
<span class="lineNum">   20884 </span><span class="lineCov">     463688 :   int dflt;</span>
<span class="lineNum">   20885 </span>            : 
<span class="lineNum">   20886 </span><span class="lineCov">     463688 :   while (1)</span>
<span class="lineNum">   20887 </span><span class="lineCov">     463688 :     switch (TREE_CODE (bound))</span>
<span class="lineNum">   20888 </span>            :       {
<span class="lineNum">   20889 </span>            :       /* Strip all conversions.  */
<span class="lineNum">   20890 </span><span class="lineCov">         14 :       CASE_CONVERT:</span>
<span class="lineNum">   20891 </span><span class="lineCov">         14 :       case VIEW_CONVERT_EXPR:</span>
<span class="lineNum">   20892 </span><span class="lineCov">         14 :         bound = TREE_OPERAND (bound, 0);</span>
<span class="lineNum">   20893 </span><span class="lineCov">         14 :         break;</span>
<span class="lineNum">   20894 </span>            : 
<span class="lineNum">   20895 </span>            :       /* All fixed-bounds are represented by INTEGER_CST nodes.  Lower bounds
<span class="lineNum">   20896 </span>            :          are even omitted when they are the default.  */
<span class="lineNum">   20897 </span><span class="lineCov">     441657 :       case INTEGER_CST:</span>
<span class="lineNum">   20898 </span>            :         /* If the value for this bound is the default one, we can even omit the
<span class="lineNum">   20899 </span>            :            attribute.  */
<span class="lineNum">   20900 </span><span class="lineCov">     441657 :         if (bound_attr == DW_AT_lower_bound</span>
<span class="lineNum">   20901 </span><span class="lineCov">     225453 :             &amp;&amp; tree_fits_shwi_p (bound)</span>
<span class="lineNum">   20902 </span><span class="lineCov">     225453 :             &amp;&amp; (dflt = lower_bound_default ()) != -1</span>
<span class="lineNum">   20903 </span><span class="lineCov">     661335 :             &amp;&amp; tree_to_shwi (bound) == dflt)</span>
<span class="lineNum">   20904 </span>            :           return;
<span class="lineNum">   20905 </span>            : 
<span class="lineNum">   20906 </span>            :         /* FALLTHRU */
<span class="lineNum">   20907 </span>            : 
<span class="lineNum">   20908 </span><span class="lineCov">     246254 :       default:</span>
<span class="lineNum">   20909 </span>            :         /* Because of the complex interaction there can be with other GNAT
<span class="lineNum">   20910 </span>            :            encodings, GDB isn't ready yet to handle proper DWARF description
<span class="lineNum">   20911 </span>            :            for self-referencial subrange bounds: let GNAT encodings do the
<span class="lineNum">   20912 </span>            :            magic in such a case.  */
<span class="lineNum">   20913 </span><span class="lineCov">     246254 :         if (is_ada ()</span>
<span class="lineNum">   20914 </span><span class="lineNoCov">          0 :             &amp;&amp; gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL</span>
<span class="lineNum">   20915 </span><span class="lineCov">     246254 :             &amp;&amp; contains_placeholder_p (bound))</span>
<span class="lineNum">   20916 </span>            :           return;
<span class="lineNum">   20917 </span>            : 
<span class="lineNum">   20918 </span><span class="lineCov">     246254 :         add_scalar_info (subrange_die, bound_attr, bound,</span>
<span class="lineNum">   20919 </span>            :                          dw_scalar_form_constant
<span class="lineNum">   20920 </span>            :                          | dw_scalar_form_exprloc
<span class="lineNum">   20921 </span>            :                          | dw_scalar_form_reference,
<span class="lineNum">   20922 </span>            :                          context);
<span class="lineNum">   20923 </span><span class="lineCov">     246254 :         return;</span>
<span class="lineNum">   20924 </span>            :       }
<span class="lineNum">   20925 </span>            : }
<span class="lineNum">   20926 </span>            : 
<span class="lineNum">   20927 </span>            : /* Add subscript info to TYPE_DIE, describing an array TYPE, collapsing
<span class="lineNum">   20928 </span>            :    possibly nested array subscripts in a flat sequence if COLLAPSE_P is true.
<span class="lineNum">   20929 </span>            :    Note that the block of subscript information for an array type also
<span class="lineNum">   20930 </span>            :    includes information about the element type of the given array type.
<span class="lineNum">   20931 </span>            : 
<span class="lineNum">   20932 </span>            :    This function reuses previously set type and bound information if
<span class="lineNum">   20933 </span>            :    available.  */
<a name="20934"><span class="lineNum">   20934 </span>            : </a>
<span class="lineNum">   20935 </span>            : static void
<span class="lineNum">   20936 </span><span class="lineCov">     221866 : add_subscript_info (dw_die_ref type_die, tree type, bool collapse_p)</span>
<span class="lineNum">   20937 </span>            : {
<span class="lineNum">   20938 </span><span class="lineCov">     221866 :   unsigned dimension_number;</span>
<span class="lineNum">   20939 </span><span class="lineCov">     221866 :   tree lower, upper;</span>
<span class="lineNum">   20940 </span><span class="lineCov">     221866 :   dw_die_ref child = type_die-&gt;die_child;</span>
<span class="lineNum">   20941 </span>            : 
<span class="lineNum">   20942 </span><span class="lineCov">     221866 :   for (dimension_number = 0;</span>
<span class="lineNum">   20943 </span><span class="lineCov">     446924 :        TREE_CODE (type) == ARRAY_TYPE &amp;&amp; (dimension_number == 0 || collapse_p);</span>
<span class="lineNum">   20944 </span><span class="lineCov">     225058 :        type = TREE_TYPE (type), dimension_number++)</span>
<span class="lineNum">   20945 </span>            :     {
<span class="lineNum">   20946 </span><span class="lineCov">     225748 :       tree domain = TYPE_DOMAIN (type);</span>
<span class="lineNum">   20947 </span>            : 
<span class="lineNum">   20948 </span><span class="lineCov">     225748 :       if (TYPE_STRING_FLAG (type) &amp;&amp; is_fortran () &amp;&amp; dimension_number &gt; 0)</span>
<span class="lineNum">   20949 </span>            :         break;
<span class="lineNum">   20950 </span>            : 
<span class="lineNum">   20951 </span>            :       /* Arrays come in three flavors: Unspecified bounds, fixed bounds,
<span class="lineNum">   20952 </span>            :          and (in GNU C only) variable bounds.  Handle all three forms
<span class="lineNum">   20953 </span>            :          here.  */
<span class="lineNum">   20954 </span>            : 
<span class="lineNum">   20955 </span>            :       /* Find and reuse a previously generated DW_TAG_subrange_type if
<span class="lineNum">   20956 </span>            :          available.
<span class="lineNum">   20957 </span>            : 
<span class="lineNum">   20958 </span>            :          For multi-dimensional arrays, as we iterate through the
<span class="lineNum">   20959 </span>            :          various dimensions in the enclosing for loop above, we also
<span class="lineNum">   20960 </span>            :          iterate through the DIE children and pick at each
<span class="lineNum">   20961 </span>            :          DW_TAG_subrange_type previously generated (if available).
<span class="lineNum">   20962 </span>            :          Each child DW_TAG_subrange_type DIE describes the range of
<span class="lineNum">   20963 </span>            :          the current dimension.  At this point we should have as many
<span class="lineNum">   20964 </span>            :          DW_TAG_subrange_type's as we have dimensions in the
<span class="lineNum">   20965 </span>            :          array.  */
<span class="lineNum">   20966 </span><span class="lineCov">     225058 :       dw_die_ref subrange_die = NULL;</span>
<span class="lineNum">   20967 </span><span class="lineCov">     225058 :       if (child)</span>
<span class="lineNum">   20968 </span><span class="lineCov">       2541 :         while (1)</span>
<span class="lineNum">   20969 </span>            :           {
<span class="lineNum">   20970 </span><span class="lineCov">       2541 :             child = child-&gt;die_sib;</span>
<span class="lineNum">   20971 </span><span class="lineCov">       2541 :             if (child-&gt;die_tag == DW_TAG_subrange_type)</span>
<span class="lineNum">   20972 </span><span class="lineCov">       2541 :               subrange_die = child;</span>
<span class="lineNum">   20973 </span><span class="lineCov">       2541 :             if (child == type_die-&gt;die_child)</span>
<span class="lineNum">   20974 </span>            :               {
<span class="lineNum">   20975 </span>            :                 /* If we wrapped around, stop looking next time.  */
<span class="lineNum">   20976 </span>            :                 child = NULL;
<span class="lineNum">   20977 </span>            :                 break;
<span class="lineNum">   20978 </span>            :               }
<span class="lineNum">   20979 </span><span class="lineCov">        553 :             if (child-&gt;die_tag == DW_TAG_subrange_type)</span>
<span class="lineNum">   20980 </span>            :               break;
<span class="lineNum">   20981 </span>            :           }
<span class="lineNum">   20982 </span><span class="lineCov">       2541 :       if (!subrange_die)</span>
<span class="lineNum">   20983 </span><span class="lineCov">     222517 :         subrange_die = new_die (DW_TAG_subrange_type, type_die, NULL);</span>
<span class="lineNum">   20984 </span>            : 
<span class="lineNum">   20985 </span><span class="lineCov">     225058 :       if (domain)</span>
<span class="lineNum">   20986 </span>            :         {
<span class="lineNum">   20987 </span>            :           /* We have an array type with specified bounds.  */
<span class="lineNum">   20988 </span><span class="lineCov">     216239 :           lower = TYPE_MIN_VALUE (domain);</span>
<span class="lineNum">   20989 </span><span class="lineCov">     216239 :           upper = TYPE_MAX_VALUE (domain);</span>
<span class="lineNum">   20990 </span>            : 
<span class="lineNum">   20991 </span>            :           /* Define the index type.  */
<span class="lineNum">   20992 </span><span class="lineCov">     216239 :           if (TREE_TYPE (domain)</span>
<span class="lineNum">   20993 </span><span class="lineCov">     216239 :               &amp;&amp; !get_AT (subrange_die, DW_AT_type))</span>
<span class="lineNum">   20994 </span>            :             {
<span class="lineNum">   20995 </span>            :               /* ??? This is probably an Ada unnamed subrange type.  Ignore the
<span class="lineNum">   20996 </span>            :                  TREE_TYPE field.  We can't emit debug info for this
<span class="lineNum">   20997 </span>            :                  because it is an unnamed integral type.  */
<span class="lineNum">   20998 </span><span class="lineCov">     213698 :               if (TREE_CODE (domain) == INTEGER_TYPE</span>
<span class="lineNum">   20999 </span><span class="lineCov">     213698 :                   &amp;&amp; TYPE_NAME (domain) == NULL_TREE</span>
<span class="lineNum">   21000 </span><span class="lineCov">     427396 :                   &amp;&amp; TREE_CODE (TREE_TYPE (domain)) == INTEGER_TYPE</span>
<span class="lineNum">   21001 </span><span class="lineCov">     641094 :                   &amp;&amp; TYPE_NAME (TREE_TYPE (domain)) == NULL_TREE)</span>
<span class="lineNum">   21002 </span>            :                 ;
<span class="lineNum">   21003 </span>            :               else
<span class="lineNum">   21004 </span><span class="lineCov">     427396 :                 add_type_attribute (subrange_die, TREE_TYPE (domain),</span>
<span class="lineNum">   21005 </span>            :                                     TYPE_UNQUALIFIED, false, type_die);
<span class="lineNum">   21006 </span>            :             }
<span class="lineNum">   21007 </span>            : 
<span class="lineNum">   21008 </span>            :           /* ??? If upper is NULL, the array has unspecified length,
<span class="lineNum">   21009 </span>            :              but it does have a lower bound.  This happens with Fortran
<span class="lineNum">   21010 </span>            :                dimension arr(N:*)
<span class="lineNum">   21011 </span>            :              Since the debugger is definitely going to need to know N
<span class="lineNum">   21012 </span>            :              to produce useful results, go ahead and output the lower
<span class="lineNum">   21013 </span>            :              bound solo, and hope the debugger can cope.  */
<span class="lineNum">   21014 </span>            : 
<span class="lineNum">   21015 </span><span class="lineCov">     216239 :           if (!get_AT (subrange_die, DW_AT_lower_bound))</span>
<span class="lineNum">   21016 </span><span class="lineCov">     215853 :             add_bound_info (subrange_die, DW_AT_lower_bound, lower, NULL);</span>
<span class="lineNum">   21017 </span><span class="lineCov">     216239 :           if (!get_AT (subrange_die, DW_AT_upper_bound)</span>
<span class="lineNum">   21018 </span><span class="lineCov">     216239 :               &amp;&amp; !get_AT (subrange_die, DW_AT_count))</span>
<span class="lineNum">   21019 </span>            :             {
<span class="lineNum">   21020 </span><span class="lineCov">     213728 :               if (upper)</span>
<span class="lineNum">   21021 </span><span class="lineCov">     209681 :                 add_bound_info (subrange_die, DW_AT_upper_bound, upper, NULL);</span>
<span class="lineNum">   21022 </span><span class="lineCov">       4047 :               else if ((is_c () || is_cxx ()) &amp;&amp; COMPLETE_TYPE_P (type))</span>
<span class="lineNum">   21023 </span>            :                 /* Zero-length array.  */
<span class="lineNum">   21024 </span><span class="lineCov">        722 :                 add_bound_info (subrange_die, DW_AT_count,</span>
<span class="lineNum">   21025 </span><span class="lineCov">       1444 :                                 build_int_cst (TREE_TYPE (lower), 0), NULL);</span>
<span class="lineNum">   21026 </span>            :             }
<span class="lineNum">   21027 </span>            :         }
<span class="lineNum">   21028 </span>            : 
<span class="lineNum">   21029 </span>            :       /* Otherwise we have an array type with an unspecified length.  The
<span class="lineNum">   21030 </span>            :          DWARF-2 spec does not say how to handle this; let's just leave out the
<span class="lineNum">   21031 </span>            :          bounds.  */
<span class="lineNum">   21032 </span>            :     }
<span class="lineNum">   21033 </span><span class="lineCov">     221866 : }</span>
<span class="lineNum">   21034 </span>            : 
<span class="lineNum">   21035 </span>            : /* Add a DW_AT_byte_size attribute to DIE with TREE_NODE's size.  */
<a name="21036"><span class="lineNum">   21036 </span>            : </a>
<span class="lineNum">   21037 </span>            : static void
<span class="lineNum">   21038 </span><span class="lineCov">    8528957 : add_byte_size_attribute (dw_die_ref die, tree tree_node)</span>
<span class="lineNum">   21039 </span>            : {
<span class="lineNum">   21040 </span><span class="lineCov">    8528957 :   dw_die_ref decl_die;</span>
<span class="lineNum">   21041 </span><span class="lineCov">    8528957 :   HOST_WIDE_INT size;</span>
<span class="lineNum">   21042 </span><span class="lineCov">    8528957 :   dw_loc_descr_ref size_expr = NULL;</span>
<span class="lineNum">   21043 </span>            : 
<span class="lineNum">   21044 </span><span class="lineCov">    8528957 :   switch (TREE_CODE (tree_node))</span>
<span class="lineNum">   21045 </span>            :     {
<span class="lineNum">   21046 </span><span class="lineNoCov">          0 :     case ERROR_MARK:</span>
<span class="lineNum">   21047 </span><span class="lineNoCov">          0 :       size = 0;</span>
<span class="lineNum">   21048 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">   21049 </span><span class="lineCov">    8519479 :     case ENUMERAL_TYPE:</span>
<span class="lineNum">   21050 </span><span class="lineCov">    8519479 :     case RECORD_TYPE:</span>
<span class="lineNum">   21051 </span><span class="lineCov">    8519479 :     case UNION_TYPE:</span>
<span class="lineNum">   21052 </span><span class="lineCov">    8519479 :     case QUAL_UNION_TYPE:</span>
<span class="lineNum">   21053 </span><span class="lineCov">    8519479 :       if (TREE_CODE (TYPE_SIZE_UNIT (tree_node)) == VAR_DECL</span>
<span class="lineNum">   21054 </span><span class="lineCov">    8519479 :           &amp;&amp; (decl_die = lookup_decl_die (TYPE_SIZE_UNIT (tree_node))))</span>
<span class="lineNum">   21055 </span>            :         {
<span class="lineNum">   21056 </span><span class="lineNoCov">          0 :           add_AT_die_ref (die, DW_AT_byte_size, decl_die);</span>
<span class="lineNum">   21057 </span><span class="lineNoCov">          0 :           return;</span>
<span class="lineNum">   21058 </span>            :         }
<span class="lineNum">   21059 </span><span class="lineCov">    8519479 :       size_expr = type_byte_size (tree_node, &amp;size);</span>
<span class="lineNum">   21060 </span><span class="lineCov">    8519479 :       break;</span>
<span class="lineNum">   21061 </span><span class="lineCov">       9478 :     case FIELD_DECL:</span>
<span class="lineNum">   21062 </span>            :       /* For a data member of a struct or union, the DW_AT_byte_size is
<span class="lineNum">   21063 </span>            :          generally given as the number of bytes normally allocated for an
<span class="lineNum">   21064 </span>            :          object of the *declared* type of the member itself.  This is true
<span class="lineNum">   21065 </span>            :          even for bit-fields.  */
<span class="lineNum">   21066 </span><span class="lineCov">       9478 :       size = int_size_in_bytes (field_type (tree_node));</span>
<span class="lineNum">   21067 </span><span class="lineCov">       9478 :       break;</span>
<span class="lineNum">   21068 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">   21069 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">   21070 </span>            :     }
<span class="lineNum">   21071 </span>            : 
<span class="lineNum">   21072 </span>            :   /* Support for dynamically-sized objects was introduced by DWARFv3.
<span class="lineNum">   21073 </span>            :      At the moment, GDB does not handle variable byte sizes very well,
<span class="lineNum">   21074 </span>            :      though.  */
<span class="lineNum">   21075 </span><span class="lineCov">    8528957 :   if ((dwarf_version &gt;= 3 || !dwarf_strict)</span>
<span class="lineNum">   21076 </span><span class="lineCov">    8528957 :       &amp;&amp; gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL</span>
<span class="lineNum">   21077 </span><span class="lineNoCov">          0 :       &amp;&amp; size_expr != NULL)</span>
<span class="lineNum">   21078 </span><span class="lineNoCov">          0 :     add_AT_loc (die, DW_AT_byte_size, size_expr);</span>
<span class="lineNum">   21079 </span>            : 
<span class="lineNum">   21080 </span>            :   /* Note that `size' might be -1 when we get to this point.  If it is, that
<span class="lineNum">   21081 </span>            :      indicates that the byte size of the entity in question is variable and
<span class="lineNum">   21082 </span>            :      that we could not generate a DWARF expression that computes it.  */
<span class="lineNum">   21083 </span><span class="lineCov">    8528957 :   if (size &gt;= 0)</span>
<span class="lineNum">   21084 </span><span class="lineCov">    8528891 :     add_AT_unsigned (die, DW_AT_byte_size, size);</span>
<span class="lineNum">   21085 </span>            : }
<span class="lineNum">   21086 </span>            : 
<span class="lineNum">   21087 </span>            : /* Add a DW_AT_alignment attribute to DIE with TREE_NODE's non-default
<span class="lineNum">   21088 </span>            :    alignment.  */
<a name="21089"><span class="lineNum">   21089 </span>            : </a>
<span class="lineNum">   21090 </span>            : static void
<span class="lineNum">   21091 </span><span class="lineCov">   30734090 : add_alignment_attribute (dw_die_ref die, tree tree_node)</span>
<span class="lineNum">   21092 </span>            : {
<span class="lineNum">   21093 </span><span class="lineCov">   30734090 :   if (dwarf_version &lt; 5 &amp;&amp; dwarf_strict)</span>
<span class="lineNum">   21094 </span>            :     return;
<span class="lineNum">   21095 </span>            : 
<span class="lineNum">   21096 </span><span class="lineCov">   30734034 :   unsigned align;</span>
<span class="lineNum">   21097 </span>            : 
<span class="lineNum">   21098 </span><span class="lineCov">   30734034 :   if (DECL_P (tree_node))</span>
<span class="lineNum">   21099 </span>            :     {
<span class="lineNum">   21100 </span><span class="lineCov">   11487985 :       if (!DECL_USER_ALIGN (tree_node))</span>
<span class="lineNum">   21101 </span>            :         return;
<span class="lineNum">   21102 </span>            : 
<span class="lineNum">   21103 </span><span class="lineCov">     153818 :       align = DECL_ALIGN_UNIT (tree_node);</span>
<span class="lineNum">   21104 </span>            :     }
<span class="lineNum">   21105 </span><span class="lineCov">   19246049 :   else if (TYPE_P (tree_node))</span>
<span class="lineNum">   21106 </span>            :     {
<span class="lineNum">   21107 </span><span class="lineCov">   38492098 :       if (!TYPE_USER_ALIGN (tree_node))</span>
<span class="lineNum">   21108 </span>            :         return;
<span class="lineNum">   21109 </span>            : 
<span class="lineNum">   21110 </span><span class="lineCov">     515854 :       align = TYPE_ALIGN_UNIT (tree_node);</span>
<span class="lineNum">   21111 </span>            :     }
<span class="lineNum">   21112 </span>            :   else
<span class="lineNum">   21113 </span><span class="lineNoCov">          0 :     gcc_unreachable ();</span>
<span class="lineNum">   21114 </span>            : 
<span class="lineNum">   21115 </span><span class="lineCov">     334836 :   add_AT_unsigned (die, DW_AT_alignment, align);</span>
<span class="lineNum">   21116 </span>            : }
<span class="lineNum">   21117 </span>            : 
<span class="lineNum">   21118 </span>            : /* For a FIELD_DECL node which represents a bit-field, output an attribute
<span class="lineNum">   21119 </span>            :    which specifies the distance in bits from the highest order bit of the
<span class="lineNum">   21120 </span>            :    &quot;containing object&quot; for the bit-field to the highest order bit of the
<span class="lineNum">   21121 </span>            :    bit-field itself.
<span class="lineNum">   21122 </span>            : 
<span class="lineNum">   21123 </span>            :    For any given bit-field, the &quot;containing object&quot; is a hypothetical object
<span class="lineNum">   21124 </span>            :    (of some integral or enum type) within which the given bit-field lives.  The
<span class="lineNum">   21125 </span>            :    type of this hypothetical &quot;containing object&quot; is always the same as the
<span class="lineNum">   21126 </span>            :    declared type of the individual bit-field itself.  The determination of the
<span class="lineNum">   21127 </span>            :    exact location of the &quot;containing object&quot; for a bit-field is rather
<span class="lineNum">   21128 </span>            :    complicated.  It's handled by the `field_byte_offset' function (above).
<span class="lineNum">   21129 </span>            : 
<span class="lineNum">   21130 </span>            :    CTX is required: see the comment for VLR_CONTEXT.
<span class="lineNum">   21131 </span>            : 
<span class="lineNum">   21132 </span>            :    Note that it is the size (in bytes) of the hypothetical &quot;containing object&quot;
<span class="lineNum">   21133 </span>            :    which will be given in the DW_AT_byte_size attribute for this bit-field.
<span class="lineNum">   21134 </span>            :    (See `byte_size_attribute' above).  */
<a name="21135"><span class="lineNum">   21135 </span>            : </a>
<span class="lineNum">   21136 </span>            : static inline void
<span class="lineNum">   21137 </span><span class="lineCov">       9478 : add_bit_offset_attribute (dw_die_ref die, tree decl, struct vlr_context *ctx)</span>
<span class="lineNum">   21138 </span>            : {
<span class="lineNum">   21139 </span><span class="lineCov">       9478 :   HOST_WIDE_INT object_offset_in_bytes;</span>
<span class="lineNum">   21140 </span><span class="lineCov">       9478 :   tree original_type = DECL_BIT_FIELD_TYPE (decl);</span>
<span class="lineNum">   21141 </span><span class="lineCov">       9478 :   HOST_WIDE_INT bitpos_int;</span>
<span class="lineNum">   21142 </span><span class="lineCov">       9478 :   HOST_WIDE_INT highest_order_object_bit_offset;</span>
<span class="lineNum">   21143 </span><span class="lineCov">       9478 :   HOST_WIDE_INT highest_order_field_bit_offset;</span>
<span class="lineNum">   21144 </span><span class="lineCov">       9478 :   HOST_WIDE_INT bit_offset;</span>
<span class="lineNum">   21145 </span>            : 
<span class="lineNum">   21146 </span><span class="lineCov">       9478 :   field_byte_offset (decl, ctx, &amp;object_offset_in_bytes);</span>
<span class="lineNum">   21147 </span>            : 
<span class="lineNum">   21148 </span>            :   /* Must be a field and a bit field.  */
<span class="lineNum">   21149 </span><span class="lineCov">       9478 :   gcc_assert (original_type &amp;&amp; TREE_CODE (decl) == FIELD_DECL);</span>
<span class="lineNum">   21150 </span>            : 
<span class="lineNum">   21151 </span>            :   /* We can't yet handle bit-fields whose offsets are variable, so if we
<span class="lineNum">   21152 </span>            :      encounter such things, just return without generating any attribute
<span class="lineNum">   21153 </span>            :      whatsoever.  Likewise for variable or too large size.  */
<span class="lineNum">   21154 </span><span class="lineCov">       9478 :   if (! tree_fits_shwi_p (bit_position (decl))</span>
<span class="lineNum">   21155 </span><span class="lineCov">       9478 :       || ! tree_fits_uhwi_p (DECL_SIZE (decl)))</span>
<span class="lineNum">   21156 </span><span class="lineCov">         16 :     return;</span>
<span class="lineNum">   21157 </span>            : 
<span class="lineNum">   21158 </span><span class="lineCov">       9462 :   bitpos_int = int_bit_position (decl);</span>
<span class="lineNum">   21159 </span>            : 
<span class="lineNum">   21160 </span>            :   /* Note that the bit offset is always the distance (in bits) from the
<span class="lineNum">   21161 </span>            :      highest-order bit of the &quot;containing object&quot; to the highest-order bit of
<span class="lineNum">   21162 </span>            :      the bit-field itself.  Since the &quot;high-order end&quot; of any object or field
<span class="lineNum">   21163 </span>            :      is different on big-endian and little-endian machines, the computation
<span class="lineNum">   21164 </span>            :      below must take account of these differences.  */
<span class="lineNum">   21165 </span><span class="lineCov">       9462 :   highest_order_object_bit_offset = object_offset_in_bytes * BITS_PER_UNIT;</span>
<span class="lineNum">   21166 </span><span class="lineCov">       9462 :   highest_order_field_bit_offset = bitpos_int;</span>
<span class="lineNum">   21167 </span>            : 
<span class="lineNum">   21168 </span><span class="lineCov">       9462 :   if (! BYTES_BIG_ENDIAN)</span>
<span class="lineNum">   21169 </span>            :     {
<span class="lineNum">   21170 </span><span class="lineCov">       9462 :       highest_order_field_bit_offset += tree_to_shwi (DECL_SIZE (decl));</span>
<span class="lineNum">   21171 </span><span class="lineCov">      18924 :       highest_order_object_bit_offset +=</span>
<span class="lineNum">   21172 </span><span class="lineCov">       9462 :         simple_type_size_in_bits (original_type);</span>
<span class="lineNum">   21173 </span>            :     }
<span class="lineNum">   21174 </span>            : 
<span class="lineNum">   21175 </span><span class="lineCov">       9462 :   bit_offset</span>
<span class="lineNum">   21176 </span><span class="lineCov">       9462 :     = (! BYTES_BIG_ENDIAN</span>
<span class="lineNum">   21177 </span>            :        ? highest_order_object_bit_offset - highest_order_field_bit_offset
<span class="lineNum">   21178 </span>            :        : highest_order_field_bit_offset - highest_order_object_bit_offset);
<span class="lineNum">   21179 </span>            : 
<span class="lineNum">   21180 </span><span class="lineCov">       9462 :   if (bit_offset &lt; 0)</span>
<span class="lineNum">   21181 </span><span class="lineCov">         32 :     add_AT_int (die, DW_AT_bit_offset, bit_offset);</span>
<span class="lineNum">   21182 </span>            :   else
<span class="lineNum">   21183 </span><span class="lineCov">       9430 :     add_AT_unsigned (die, DW_AT_bit_offset, (unsigned HOST_WIDE_INT) bit_offset);</span>
<span class="lineNum">   21184 </span>            : }
<span class="lineNum">   21185 </span>            : 
<span class="lineNum">   21186 </span>            : /* For a FIELD_DECL node which represents a bit field, output an attribute
<span class="lineNum">   21187 </span>            :    which specifies the length in bits of the given field.  */
<a name="21188"><span class="lineNum">   21188 </span>            : </a>
<span class="lineNum">   21189 </span>            : static inline void
<span class="lineNum">   21190 </span><span class="lineCov">       9478 : add_bit_size_attribute (dw_die_ref die, tree decl)</span>
<span class="lineNum">   21191 </span>            : {
<span class="lineNum">   21192 </span>            :   /* Must be a field and a bit field.  */
<span class="lineNum">   21193 </span><span class="lineCov">       9478 :   gcc_assert (TREE_CODE (decl) == FIELD_DECL</span>
<span class="lineNum">   21194 </span>            :               &amp;&amp; DECL_BIT_FIELD_TYPE (decl));
<span class="lineNum">   21195 </span>            : 
<span class="lineNum">   21196 </span><span class="lineCov">       9478 :   if (tree_fits_uhwi_p (DECL_SIZE (decl)))</span>
<span class="lineNum">   21197 </span><span class="lineCov">      18956 :     add_AT_unsigned (die, DW_AT_bit_size, tree_to_uhwi (DECL_SIZE (decl)));</span>
<span class="lineNum">   21198 </span><span class="lineCov">       9478 : }</span>
<span class="lineNum">   21199 </span>            : 
<span class="lineNum">   21200 </span>            : /* If the compiled language is ANSI C, then add a 'prototyped'
<span class="lineNum">   21201 </span>            :    attribute, if arg types are given for the parameters of a function.  */
<a name="21202"><span class="lineNum">   21202 </span>            : </a>
<span class="lineNum">   21203 </span>            : static inline void
<span class="lineNum">   21204 </span><span class="lineCov">    6733048 : add_prototyped_attribute (dw_die_ref die, tree func_type)</span>
<span class="lineNum">   21205 </span>            : {
<span class="lineNum">   21206 </span><span class="lineCov">    6733048 :   switch (get_AT_unsigned (comp_unit_die (), DW_AT_language))</span>
<span class="lineNum">   21207 </span>            :     {
<span class="lineNum">   21208 </span><span class="lineCov">      88699 :     case DW_LANG_C:</span>
<span class="lineNum">   21209 </span><span class="lineCov">      88699 :     case DW_LANG_C89:</span>
<span class="lineNum">   21210 </span><span class="lineCov">      88699 :     case DW_LANG_C99:</span>
<span class="lineNum">   21211 </span><span class="lineCov">      88699 :     case DW_LANG_C11:</span>
<span class="lineNum">   21212 </span><span class="lineCov">      88699 :     case DW_LANG_ObjC:</span>
<span class="lineNum">   21213 </span><span class="lineCov">      88699 :       if (prototype_p (func_type))</span>
<span class="lineNum">   21214 </span><span class="lineCov">      78998 :         add_AT_flag (die, DW_AT_prototyped, 1);</span>
<span class="lineNum">   21215 </span>            :       break;
<span class="lineNum">   21216 </span>            :     default:
<span class="lineNum">   21217 </span>            :       break;
<span class="lineNum">   21218 </span>            :     }
<span class="lineNum">   21219 </span><span class="lineCov">    6733048 : }</span>
<span class="lineNum">   21220 </span>            : 
<span class="lineNum">   21221 </span>            : /* Add an 'abstract_origin' attribute below a given DIE.  The DIE is found
<span class="lineNum">   21222 </span>            :    by looking in the type declaration, the object declaration equate table or
<span class="lineNum">   21223 </span>            :    the block mapping.  */
<a name="21224"><span class="lineNum">   21224 </span>            : </a>
<span class="lineNum">   21225 </span>            : static inline dw_die_ref
<span class="lineNum">   21226 </span><span class="lineCov">   10631816 : add_abstract_origin_attribute (dw_die_ref die, tree origin)</span>
<span class="lineNum">   21227 </span>            : {
<span class="lineNum">   21228 </span><span class="lineCov">   10631816 :   dw_die_ref origin_die = NULL;</span>
<span class="lineNum">   21229 </span>            : 
<span class="lineNum">   21230 </span><span class="lineCov">   10631816 :   if (DECL_P (origin))</span>
<span class="lineNum">   21231 </span>            :     {
<span class="lineNum">   21232 </span><span class="lineCov">   10194859 :       dw_die_ref c;</span>
<span class="lineNum">   21233 </span><span class="lineCov">   10194859 :       origin_die = lookup_decl_die (origin);</span>
<span class="lineNum">   21234 </span>            :       /* &quot;Unwrap&quot; the decls DIE which we put in the imported unit context.
<span class="lineNum">   21235 </span>            :          We are looking for the abstract copy here.  */
<span class="lineNum">   21236 </span><span class="lineCov">   10194859 :       if (in_lto_p</span>
<span class="lineNum">   21237 </span><span class="lineCov">       2403 :           &amp;&amp; origin_die</span>
<span class="lineNum">   21238 </span><span class="lineCov">       2403 :           &amp;&amp; (c = get_AT_ref (origin_die, DW_AT_abstract_origin))</span>
<span class="lineNum">   21239 </span>            :           /* ???  Identify this better.  */
<span class="lineNum">   21240 </span><span class="lineCov">   10197262 :           &amp;&amp; c-&gt;with_offset)</span>
<span class="lineNum">   21241 </span>            :         origin_die = c;
<span class="lineNum">   21242 </span>            :     }
<span class="lineNum">   21243 </span><span class="lineCov">     436957 :   else if (TYPE_P (origin))</span>
<span class="lineNum">   21244 </span><span class="lineNoCov">          0 :     origin_die = lookup_type_die (origin);</span>
<span class="lineNum">   21245 </span><span class="lineCov">     436957 :   else if (TREE_CODE (origin) == BLOCK)</span>
<span class="lineNum">   21246 </span><span class="lineCov">     873914 :     origin_die = BLOCK_DIE (origin);</span>
<span class="lineNum">   21247 </span>            : 
<span class="lineNum">   21248 </span>            :   /* XXX: Functions that are never lowered don't always have correct block
<span class="lineNum">   21249 </span>            :      trees (in the case of java, they simply have no block tree, in some other
<span class="lineNum">   21250 </span>            :      languages).  For these functions, there is nothing we can really do to
<span class="lineNum">   21251 </span>            :      output correct debug info for inlined functions in all cases.  Rather
<span class="lineNum">   21252 </span>            :      than die, we'll just produce deficient debug info now, in that we will
<span class="lineNum">   21253 </span>            :      have variables without a proper abstract origin.  In the future, when all
<span class="lineNum">   21254 </span>            :      functions are lowered, we should re-add a gcc_assert (origin_die)
<span class="lineNum">   21255 </span>            :      here.  */
<span class="lineNum">   21256 </span>            : 
<span class="lineNum">   21257 </span><span class="lineCov">   10631816 :   if (origin_die)</span>
<span class="lineNum">   21258 </span><span class="lineCov">   10296250 :     add_AT_die_ref (die, DW_AT_abstract_origin, origin_die);</span>
<span class="lineNum">   21259 </span><span class="lineCov">   10631816 :   return origin_die;</span>
<span class="lineNum">   21260 </span>            : }
<span class="lineNum">   21261 </span>            : 
<span class="lineNum">   21262 </span>            : /* We do not currently support the pure_virtual attribute.  */
<a name="21263"><span class="lineNum">   21263 </span>            : </a>
<span class="lineNum">   21264 </span>            : static inline void
<span class="lineNum">   21265 </span><span class="lineCov">    6630225 : add_pure_or_virtual_attribute (dw_die_ref die, tree func_decl)</span>
<span class="lineNum">   21266 </span>            : {
<span class="lineNum">   21267 </span><span class="lineCov">    6630225 :   if (DECL_VINDEX (func_decl))</span>
<span class="lineNum">   21268 </span>            :     {
<span class="lineNum">   21269 </span><span class="lineCov">     331286 :       add_AT_unsigned (die, DW_AT_virtuality, DW_VIRTUALITY_virtual);</span>
<span class="lineNum">   21270 </span>            : 
<span class="lineNum">   21271 </span><span class="lineCov">     331286 :       if (tree_fits_shwi_p (DECL_VINDEX (func_decl)))</span>
<span class="lineNum">   21272 </span><span class="lineCov">     231689 :         add_AT_loc (die, DW_AT_vtable_elem_location,</span>
<span class="lineNum">   21273 </span>            :                     new_loc_descr (DW_OP_constu,
<span class="lineNum">   21274 </span><span class="lineCov">     463378 :                                    tree_to_shwi (DECL_VINDEX (func_decl)),</span>
<span class="lineNum">   21275 </span>            :                                    0));
<span class="lineNum">   21276 </span>            : 
<span class="lineNum">   21277 </span>            :       /* GNU extension: Record what type this method came from originally.  */
<span class="lineNum">   21278 </span><span class="lineCov">     331286 :       if (debug_info_level &gt; DINFO_LEVEL_TERSE</span>
<span class="lineNum">   21279 </span><span class="lineCov">     331286 :           &amp;&amp; DECL_CONTEXT (func_decl))</span>
<span class="lineNum">   21280 </span><span class="lineCov">     331271 :         add_AT_die_ref (die, DW_AT_containing_type,</span>
<span class="lineNum">   21281 </span><span class="lineCov">     662542 :                         lookup_type_die (DECL_CONTEXT (func_decl)));</span>
<span class="lineNum">   21282 </span>            :     }
<span class="lineNum">   21283 </span><span class="lineCov">    6630225 : }</span>
<span class="lineNum">   21284 </span>            : 
<span class="lineNum">   21285 </span>            : /* Add a DW_AT_linkage_name or DW_AT_MIPS_linkage_name attribute for the
<span class="lineNum">   21286 </span>            :    given decl.  This used to be a vendor extension until after DWARF 4
<span class="lineNum">   21287 </span>            :    standardized it.  */
<a name="21288"><span class="lineNum">   21288 </span>            : </a>
<span class="lineNum">   21289 </span>            : static void
<span class="lineNum">   21290 </span><span class="lineCov">   33705908 : add_linkage_attr (dw_die_ref die, tree decl)</span>
<span class="lineNum">   21291 </span>            : {
<span class="lineNum">   21292 </span><span class="lineCov">   33705908 :   const char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));</span>
<span class="lineNum">   21293 </span>            : 
<span class="lineNum">   21294 </span>            :   /* Mimic what assemble_name_raw does with a leading '*'.  */
<span class="lineNum">   21295 </span><span class="lineCov">   33705908 :   if (name[0] == '*')</span>
<span class="lineNum">   21296 </span><span class="lineCov">      36423 :     name = &amp;name[1];</span>
<span class="lineNum">   21297 </span>            : 
<span class="lineNum">   21298 </span><span class="lineCov">   33705908 :   if (dwarf_version &gt;= 4)</span>
<span class="lineNum">   21299 </span><span class="lineCov">   33703021 :     add_AT_string (die, DW_AT_linkage_name, name);</span>
<span class="lineNum">   21300 </span>            :   else
<span class="lineNum">   21301 </span><span class="lineCov">       2887 :     add_AT_string (die, DW_AT_MIPS_linkage_name, name);</span>
<span class="lineNum">   21302 </span><span class="lineCov">   33705908 : }</span>
<span class="lineNum">   21303 </span>            : 
<span class="lineNum">   21304 </span>            : /* Add source coordinate attributes for the given decl.  */
<a name="21305"><span class="lineNum">   21305 </span>            : </a>
<span class="lineNum">   21306 </span>            : static void
<span class="lineNum">   21307 </span><span class="lineCov">   28666606 : add_src_coords_attributes (dw_die_ref die, tree decl)</span>
<span class="lineNum">   21308 </span>            : {
<span class="lineNum">   21309 </span><span class="lineCov">   28666606 :   expanded_location s;</span>
<span class="lineNum">   21310 </span>            : 
<span class="lineNum">   21311 </span><span class="lineCov">   28666606 :   if (LOCATION_LOCUS (DECL_SOURCE_LOCATION (decl)) == UNKNOWN_LOCATION)</span>
<span class="lineNum">   21312 </span><span class="lineCov">      39431 :     return;</span>
<span class="lineNum">   21313 </span><span class="lineCov">   28627175 :   s = expand_location (DECL_SOURCE_LOCATION (decl));</span>
<span class="lineNum">   21314 </span><span class="lineCov">   28627175 :   add_AT_file (die, DW_AT_decl_file, lookup_filename (s.file));</span>
<span class="lineNum">   21315 </span><span class="lineCov">   28627175 :   add_AT_unsigned (die, DW_AT_decl_line, s.line);</span>
<span class="lineNum">   21316 </span><span class="lineCov">   28627175 :   if (debug_column_info &amp;&amp; s.column)</span>
<span class="lineNum">   21317 </span><span class="lineCov">   28222335 :     add_AT_unsigned (die, DW_AT_decl_column, s.column);</span>
<span class="lineNum">   21318 </span>            : }
<span class="lineNum">   21319 </span>            : 
<span class="lineNum">   21320 </span>            : /* Add DW_AT_{,MIPS_}linkage_name attribute for the given decl.  */
<a name="21321"><span class="lineNum">   21321 </span>            : </a>
<span class="lineNum">   21322 </span>            : static void
<span class="lineNum">   21323 </span><span class="lineCov">    7771087 : add_linkage_name_raw (dw_die_ref die, tree decl)</span>
<span class="lineNum">   21324 </span>            : {
<span class="lineNum">   21325 </span>            :   /* Defer until we have an assembler name set.  */
<span class="lineNum">   21326 </span><span class="lineCov">    7771087 :   if (!DECL_ASSEMBLER_NAME_SET_P (decl))</span>
<span class="lineNum">   21327 </span>            :     {
<span class="lineNum">   21328 </span><span class="lineCov">    6765825 :       limbo_die_node *asm_name;</span>
<span class="lineNum">   21329 </span>            : 
<span class="lineNum">   21330 </span><span class="lineCov">    6765825 :       asm_name = ggc_cleared_alloc&lt;limbo_die_node&gt; ();</span>
<span class="lineNum">   21331 </span><span class="lineCov">    6765825 :       asm_name-&gt;die = die;</span>
<span class="lineNum">   21332 </span><span class="lineCov">    6765825 :       asm_name-&gt;created_for = decl;</span>
<span class="lineNum">   21333 </span><span class="lineCov">    6765825 :       asm_name-&gt;next = deferred_asm_name;</span>
<span class="lineNum">   21334 </span><span class="lineCov">    6765825 :       deferred_asm_name = asm_name;</span>
<span class="lineNum">   21335 </span>            :     }
<span class="lineNum">   21336 </span><span class="lineCov">    1005262 :   else if (DECL_ASSEMBLER_NAME (decl) != DECL_NAME (decl))</span>
<span class="lineNum">   21337 </span><span class="lineCov">     884766 :     add_linkage_attr (die, decl);</span>
<span class="lineNum">   21338 </span><span class="lineCov">    7771087 : }</span>
<span class="lineNum">   21339 </span>            : 
<span class="lineNum">   21340 </span>            : /* Add DW_AT_{,MIPS_}linkage_name attribute for the given decl if desired.  */
<a name="21341"><span class="lineNum">   21341 </span>            : </a>
<span class="lineNum">   21342 </span>            : static void
<span class="lineNum">   21343 </span><span class="lineCov">   22312651 : add_linkage_name (dw_die_ref die, tree decl)</span>
<span class="lineNum">   21344 </span>            : {
<span class="lineNum">   21345 </span><span class="lineCov">   22312651 :   if (debug_info_level &gt; DINFO_LEVEL_NONE</span>
<span class="lineNum">   21346 </span><span class="lineCov">   22312651 :       &amp;&amp; VAR_OR_FUNCTION_DECL_P (decl)</span>
<span class="lineNum">   21347 </span><span class="lineCov">    9463809 :       &amp;&amp; TREE_PUBLIC (decl)</span>
<span class="lineNum">   21348 </span><span class="lineCov">    8196821 :       &amp;&amp; !(VAR_P (decl) &amp;&amp; DECL_REGISTER (decl))</span>
<span class="lineNum">   21349 </span><span class="lineCov">   30509469 :       &amp;&amp; die-&gt;die_tag != DW_TAG_member)</span>
<span class="lineNum">   21350 </span><span class="lineCov">    7733061 :     add_linkage_name_raw (die, decl);</span>
<span class="lineNum">   21351 </span><span class="lineCov">   22312651 : }</span>
<span class="lineNum">   21352 </span>            : 
<span class="lineNum">   21353 </span>            : /* Add a DW_AT_name attribute and source coordinate attribute for the
<span class="lineNum">   21354 </span>            :    given decl, but only if it actually has a name.  */
<a name="21355"><span class="lineNum">   21355 </span>            : </a>
<span class="lineNum">   21356 </span>            : static void
<span class="lineNum">   21357 </span><span class="lineCov">   25225457 : add_name_and_src_coords_attributes (dw_die_ref die, tree decl,</span>
<span class="lineNum">   21358 </span>            :                                     bool no_linkage_name)
<span class="lineNum">   21359 </span>            : {
<span class="lineNum">   21360 </span><span class="lineCov">   25225457 :   tree decl_name;</span>
<span class="lineNum">   21361 </span>            : 
<span class="lineNum">   21362 </span><span class="lineCov">   25225457 :   decl_name = DECL_NAME (decl);</span>
<span class="lineNum">   21363 </span><span class="lineCov">   25225457 :   if (decl_name != NULL &amp;&amp; IDENTIFIER_POINTER (decl_name) != NULL)</span>
<span class="lineNum">   21364 </span>            :     {
<span class="lineNum">   21365 </span><span class="lineCov">   22005747 :       const char *name = dwarf2_name (decl, 0);</span>
<span class="lineNum">   21366 </span><span class="lineCov">   22005747 :       if (name)</span>
<span class="lineNum">   21367 </span><span class="lineCov">   22002513 :         add_name_attribute (die, name);</span>
<span class="lineNum">   21368 </span>            :       else
<span class="lineNum">   21369 </span><span class="lineCov">       3234 :         add_desc_attribute (die, decl);</span>
<span class="lineNum">   21370 </span>            : 
<span class="lineNum">   21371 </span><span class="lineCov">   22005747 :       if (! DECL_ARTIFICIAL (decl))</span>
<span class="lineNum">   21372 </span><span class="lineCov">   20151239 :         add_src_coords_attributes (die, decl);</span>
<span class="lineNum">   21373 </span>            : 
<span class="lineNum">   21374 </span><span class="lineCov">   22005747 :       if (!no_linkage_name)</span>
<span class="lineNum">   21375 </span><span class="lineCov">   21538694 :         add_linkage_name (die, decl);</span>
<span class="lineNum">   21376 </span>            :     }
<span class="lineNum">   21377 </span>            :   else
<span class="lineNum">   21378 </span><span class="lineCov">    3219710 :     add_desc_attribute (die, decl);</span>
<span class="lineNum">   21379 </span>            : 
<span class="lineNum">   21380 </span>            : #ifdef VMS_DEBUGGING_INFO
<span class="lineNum">   21381 </span>            :   /* Get the function's name, as described by its RTL.  This may be different
<span class="lineNum">   21382 </span>            :      from the DECL_NAME name used in the source file.  */
<span class="lineNum">   21383 </span>            :   if (TREE_CODE (decl) == FUNCTION_DECL &amp;&amp; TREE_ASM_WRITTEN (decl))
<span class="lineNum">   21384 </span>            :     {
<span class="lineNum">   21385 </span>            :       add_AT_addr (die, DW_AT_VMS_rtnbeg_pd_address,
<span class="lineNum">   21386 </span>            :                   XEXP (DECL_RTL (decl), 0), false);
<span class="lineNum">   21387 </span>            :       vec_safe_push (used_rtx_array, XEXP (DECL_RTL (decl), 0));
<span class="lineNum">   21388 </span>            :     }
<span class="lineNum">   21389 </span>            : #endif /* VMS_DEBUGGING_INFO */
<span class="lineNum">   21390 </span><span class="lineCov">   25225457 : }</span>
<span class="lineNum">   21391 </span>            : 
<span class="lineNum">   21392 </span>            : /* Add VALUE as a DW_AT_discr_value attribute to DIE.  */
<a name="21393"><span class="lineNum">   21393 </span>            : </a>
<span class="lineNum">   21394 </span>            : static void
<span class="lineNum">   21395 </span><span class="lineNoCov">          0 : add_discr_value (dw_die_ref die, dw_discr_value *value)</span>
<span class="lineNum">   21396 </span>            : {
<span class="lineNum">   21397 </span><span class="lineNoCov">          0 :   dw_attr_node attr;</span>
<span class="lineNum">   21398 </span>            : 
<span class="lineNum">   21399 </span><span class="lineNoCov">          0 :   attr.dw_attr = DW_AT_discr_value;</span>
<span class="lineNum">   21400 </span><span class="lineNoCov">          0 :   attr.dw_attr_val.val_class = dw_val_class_discr_value;</span>
<span class="lineNum">   21401 </span><span class="lineNoCov">          0 :   attr.dw_attr_val.val_entry = NULL;</span>
<span class="lineNum">   21402 </span><span class="lineNoCov">          0 :   attr.dw_attr_val.v.val_discr_value.pos = value-&gt;pos;</span>
<span class="lineNum">   21403 </span><span class="lineNoCov">          0 :   if (value-&gt;pos)</span>
<span class="lineNum">   21404 </span><span class="lineNoCov">          0 :     attr.dw_attr_val.v.val_discr_value.v.uval = value-&gt;v.uval;</span>
<span class="lineNum">   21405 </span>            :   else
<span class="lineNum">   21406 </span><span class="lineNoCov">          0 :     attr.dw_attr_val.v.val_discr_value.v.sval = value-&gt;v.sval;</span>
<span class="lineNum">   21407 </span><span class="lineNoCov">          0 :   add_dwarf_attr (die, &amp;attr);</span>
<span class="lineNum">   21408 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   21409 </span>            : 
<span class="lineNum">   21410 </span>            : /* Add DISCR_LIST as a DW_AT_discr_list to DIE.  */
<a name="21411"><span class="lineNum">   21411 </span>            : </a>
<span class="lineNum">   21412 </span>            : static void
<span class="lineNum">   21413 </span><span class="lineNoCov">          0 : add_discr_list (dw_die_ref die, dw_discr_list_ref discr_list)</span>
<span class="lineNum">   21414 </span>            : {
<span class="lineNum">   21415 </span><span class="lineNoCov">          0 :   dw_attr_node attr;</span>
<span class="lineNum">   21416 </span>            : 
<span class="lineNum">   21417 </span><span class="lineNoCov">          0 :   attr.dw_attr = DW_AT_discr_list;</span>
<span class="lineNum">   21418 </span><span class="lineNoCov">          0 :   attr.dw_attr_val.val_class = dw_val_class_discr_list;</span>
<span class="lineNum">   21419 </span><span class="lineNoCov">          0 :   attr.dw_attr_val.val_entry = NULL;</span>
<span class="lineNum">   21420 </span><span class="lineNoCov">          0 :   attr.dw_attr_val.v.val_discr_list = discr_list;</span>
<span class="lineNum">   21421 </span><span class="lineNoCov">          0 :   add_dwarf_attr (die, &amp;attr);</span>
<span class="lineNum">   21422 </span><span class="lineNoCov">          0 : }</span>
<a name="21423"><span class="lineNum">   21423 </span>            : </a>
<span class="lineNum">   21424 </span>            : static inline dw_discr_list_ref
<span class="lineNum">   21425 </span><span class="lineNoCov">          0 : AT_discr_list (dw_attr_node *attr)</span>
<span class="lineNum">   21426 </span>            : {
<span class="lineNum">   21427 </span><span class="lineNoCov">          0 :   return attr-&gt;dw_attr_val.v.val_discr_list;</span>
<span class="lineNum">   21428 </span>            : }
<span class="lineNum">   21429 </span>            : 
<span class="lineNum">   21430 </span>            : #ifdef VMS_DEBUGGING_INFO
<span class="lineNum">   21431 </span>            : /* Output the debug main pointer die for VMS */
<span class="lineNum">   21432 </span>            : 
<span class="lineNum">   21433 </span>            : void
<span class="lineNum">   21434 </span>            : dwarf2out_vms_debug_main_pointer (void)
<span class="lineNum">   21435 </span>            : {
<span class="lineNum">   21436 </span>            :   char label[MAX_ARTIFICIAL_LABEL_BYTES];
<span class="lineNum">   21437 </span>            :   dw_die_ref die;
<span class="lineNum">   21438 </span>            : 
<span class="lineNum">   21439 </span>            :   /* Allocate the VMS debug main subprogram die.  */
<span class="lineNum">   21440 </span>            :   die = new_die_raw (DW_TAG_subprogram);
<span class="lineNum">   21441 </span>            :   add_name_attribute (die, VMS_DEBUG_MAIN_POINTER);
<span class="lineNum">   21442 </span>            :   ASM_GENERATE_INTERNAL_LABEL (label, PROLOGUE_END_LABEL,
<span class="lineNum">   21443 </span>            :                                current_function_funcdef_no);
<span class="lineNum">   21444 </span>            :   add_AT_lbl_id (die, DW_AT_entry_pc, label);
<span class="lineNum">   21445 </span>            : 
<span class="lineNum">   21446 </span>            :   /* Make it the first child of comp_unit_die ().  */
<span class="lineNum">   21447 </span>            :   die-&gt;die_parent = comp_unit_die ();
<span class="lineNum">   21448 </span>            :   if (comp_unit_die ()-&gt;die_child)
<span class="lineNum">   21449 </span>            :     {
<span class="lineNum">   21450 </span>            :       die-&gt;die_sib = comp_unit_die ()-&gt;die_child-&gt;die_sib;
<span class="lineNum">   21451 </span>            :       comp_unit_die ()-&gt;die_child-&gt;die_sib = die;
<span class="lineNum">   21452 </span>            :     }
<span class="lineNum">   21453 </span>            :   else
<span class="lineNum">   21454 </span>            :     {
<span class="lineNum">   21455 </span>            :       die-&gt;die_sib = die;
<span class="lineNum">   21456 </span>            :       comp_unit_die ()-&gt;die_child = die;
<span class="lineNum">   21457 </span>            :     }
<span class="lineNum">   21458 </span>            : }
<span class="lineNum">   21459 </span>            : #endif /* VMS_DEBUGGING_INFO */
<span class="lineNum">   21460 </span>            : 
<span class="lineNum">   21461 </span>            : /* walk_tree helper function for uses_local_type, below.  */
<a name="21462"><span class="lineNum">   21462 </span>            : </a>
<span class="lineNum">   21463 </span>            : static tree
<span class="lineNum">   21464 </span><span class="lineCov">     980906 : uses_local_type_r (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)</span>
<span class="lineNum">   21465 </span>            : {
<span class="lineNum">   21466 </span><span class="lineCov">     980906 :   if (!TYPE_P (*tp))</span>
<span class="lineNum">   21467 </span><span class="lineNoCov">          0 :     *walk_subtrees = 0;</span>
<span class="lineNum">   21468 </span>            :   else
<span class="lineNum">   21469 </span>            :     {
<span class="lineNum">   21470 </span><span class="lineCov">     980906 :       tree name = TYPE_NAME (*tp);</span>
<span class="lineNum">   21471 </span><span class="lineCov">     980906 :       if (name &amp;&amp; DECL_P (name) &amp;&amp; decl_function_context (name))</span>
<span class="lineNum">   21472 </span><span class="lineCov">      14457 :         return *tp;</span>
<span class="lineNum">   21473 </span>            :     }
<span class="lineNum">   21474 </span>            :   return NULL_TREE;
<span class="lineNum">   21475 </span>            : }
<span class="lineNum">   21476 </span>            : 
<span class="lineNum">   21477 </span>            : /* If TYPE involves a function-local type (including a local typedef to a
<span class="lineNum">   21478 </span>            :    non-local type), returns that type; otherwise returns NULL_TREE.  */
<a name="21479"><span class="lineNum">   21479 </span>            : </a>
<span class="lineNum">   21480 </span>            : static tree
<span class="lineNum">   21481 </span><span class="lineNoCov">          0 : uses_local_type (tree type)</span>
<span class="lineNum">   21482 </span>            : {
<span class="lineNum">   21483 </span><span class="lineNoCov">          0 :   tree used = walk_tree_without_duplicates (&amp;type, uses_local_type_r, NULL);</span>
<span class="lineNum">   21484 </span><span class="lineCov">     508375 :   return used;</span>
<span class="lineNum">   21485 </span>            : }
<span class="lineNum">   21486 </span>            : 
<span class="lineNum">   21487 </span>            : /* Return the DIE for the scope that immediately contains this type.
<span class="lineNum">   21488 </span>            :    Non-named types that do not involve a function-local type get global
<span class="lineNum">   21489 </span>            :    scope.  Named types nested in namespaces or other types get their
<span class="lineNum">   21490 </span>            :    containing scope.  All other types (i.e. function-local named types) get
<span class="lineNum">   21491 </span>            :    the current active scope.  */
<a name="21492"><span class="lineNum">   21492 </span>            : </a>
<span class="lineNum">   21493 </span>            : static dw_die_ref
<span class="lineNum">   21494 </span><span class="lineCov">   24431964 : scope_die_for (tree t, dw_die_ref context_die)</span>
<span class="lineNum">   21495 </span>            : {
<span class="lineNum">   21496 </span><span class="lineCov">   24431964 :   dw_die_ref scope_die = NULL;</span>
<span class="lineNum">   21497 </span><span class="lineCov">   24431964 :   tree containing_scope;</span>
<span class="lineNum">   21498 </span>            : 
<span class="lineNum">   21499 </span>            :   /* Non-types always go in the current scope.  */
<span class="lineNum">   21500 </span><span class="lineCov">   24431964 :   gcc_assert (TYPE_P (t));</span>
<span class="lineNum">   21501 </span>            : 
<span class="lineNum">   21502 </span>            :   /* Use the scope of the typedef, rather than the scope of the type
<span class="lineNum">   21503 </span>            :      it refers to.  */
<span class="lineNum">   21504 </span><span class="lineCov">   48863928 :   if (TYPE_NAME (t) &amp;&amp; DECL_P (TYPE_NAME (t)))</span>
<span class="lineNum">   21505 </span><span class="lineCov">   40870158 :     containing_scope = DECL_CONTEXT (TYPE_NAME (t));</span>
<span class="lineNum">   21506 </span>            :   else
<span class="lineNum">   21507 </span><span class="lineCov">    7993770 :     containing_scope = TYPE_CONTEXT (t);</span>
<span class="lineNum">   21508 </span>            : 
<span class="lineNum">   21509 </span>            :   /* Use the containing namespace if there is one.  */
<span class="lineNum">   21510 </span><span class="lineCov">   24431964 :   if (containing_scope &amp;&amp; TREE_CODE (containing_scope) == NAMESPACE_DECL)</span>
<span class="lineNum">   21511 </span>            :     {
<span class="lineNum">   21512 </span><span class="lineCov">   17934256 :       if (context_die == lookup_decl_die (containing_scope))</span>
<span class="lineNum">   21513 </span>            :         /* OK */;
<span class="lineNum">   21514 </span><span class="lineCov">    9171476 :       else if (debug_info_level &gt; DINFO_LEVEL_TERSE)</span>
<span class="lineNum">   21515 </span><span class="lineCov">    9171476 :         context_die = get_context_die (containing_scope);</span>
<span class="lineNum">   21516 </span>            :       else
<span class="lineNum">   21517 </span>            :         containing_scope = NULL_TREE;
<span class="lineNum">   21518 </span>            :     }
<span class="lineNum">   21519 </span>            : 
<span class="lineNum">   21520 </span>            :   /* Ignore function type &quot;scopes&quot; from the C frontend.  They mean that
<span class="lineNum">   21521 </span>            :      a tagged type is local to a parmlist of a function declarator, but
<span class="lineNum">   21522 </span>            :      that isn't useful to DWARF.  */
<span class="lineNum">   21523 </span><span class="lineCov">   24431964 :   if (containing_scope &amp;&amp; TREE_CODE (containing_scope) == FUNCTION_TYPE)</span>
<span class="lineNum">   21524 </span>            :     containing_scope = NULL_TREE;
<span class="lineNum">   21525 </span>            : 
<span class="lineNum">   21526 </span><span class="lineCov">   24431943 :   if (SCOPE_FILE_SCOPE_P (containing_scope))</span>
<span class="lineNum">   21527 </span>            :     {
<span class="lineNum">   21528 </span>            :       /* If T uses a local type keep it local as well, to avoid references
<span class="lineNum">   21529 </span>            :          to function-local DIEs from outside the function.  */
<span class="lineNum">   21530 </span><span class="lineCov">    4778462 :       if (current_function_decl &amp;&amp; uses_local_type (t))</span>
<span class="lineNum">   21531 </span>            :         scope_die = context_die;
<span class="lineNum">   21532 </span>            :       else
<span class="lineNum">   21533 </span><span class="lineCov">    4764005 :         scope_die = comp_unit_die ();</span>
<span class="lineNum">   21534 </span>            :     }
<span class="lineNum">   21535 </span><span class="lineCov">   19653502 :   else if (TYPE_P (containing_scope))</span>
<span class="lineNum">   21536 </span>            :     {
<span class="lineNum">   21537 </span>            :       /* For types, we can just look up the appropriate DIE.  */
<span class="lineNum">   21538 </span><span class="lineCov">    1696828 :       if (debug_info_level &gt; DINFO_LEVEL_TERSE)</span>
<span class="lineNum">   21539 </span><span class="lineCov">    1696828 :         scope_die = get_context_die (containing_scope);</span>
<span class="lineNum">   21540 </span>            :       else
<span class="lineNum">   21541 </span>            :         {
<span class="lineNum">   21542 </span><span class="lineNoCov">          0 :           scope_die = lookup_type_die_strip_naming_typedef (containing_scope);</span>
<span class="lineNum">   21543 </span><span class="lineNoCov">          0 :           if (scope_die == NULL)</span>
<span class="lineNum">   21544 </span><span class="lineNoCov">          0 :             scope_die = comp_unit_die ();</span>
<span class="lineNum">   21545 </span>            :         }
<span class="lineNum">   21546 </span>            :     }
<span class="lineNum">   21547 </span>            :   else
<span class="lineNum">   21548 </span>            :     scope_die = context_die;
<span class="lineNum">   21549 </span>            : 
<span class="lineNum">   21550 </span><span class="lineCov">   24431964 :   return scope_die;</span>
<span class="lineNum">   21551 </span>            : }
<span class="lineNum">   21552 </span>            : 
<span class="lineNum">   21553 </span>            : /* Returns nonzero if CONTEXT_DIE is internal to a function.  */
<span class="lineNum">   21554 </span>            : 
<span class="lineNum">   21555 </span>            : static inline int
<span class="lineNum">   21556 </span>            : local_scope_p (dw_die_ref context_die)
<span class="lineNum">   21557 </span>            : {
<span class="lineNum">   21558 </span><span class="lineCov">   30659247 :   for (; context_die; context_die = context_die-&gt;die_parent)</span>
<span class="lineNum">   21559 </span><span class="lineCov">   23186962 :     if (context_die-&gt;die_tag == DW_TAG_inlined_subroutine</span>
<span class="lineNum">   21560 </span><span class="lineCov">   23186961 :         || context_die-&gt;die_tag == DW_TAG_subprogram)</span>
<span class="lineNum">   21561 </span>            :       return 1;
<span class="lineNum">   21562 </span>            : 
<span class="lineNum">   21563 </span>            :   return 0;
<span class="lineNum">   21564 </span>            : }
<span class="lineNum">   21565 </span>            : 
<span class="lineNum">   21566 </span>            : /* Returns nonzero if CONTEXT_DIE is a class.  */
<span class="lineNum">   21567 </span>            : 
<span class="lineNum">   21568 </span>            : static inline int
<span class="lineNum">   21569 </span>            : class_scope_p (dw_die_ref context_die)
<span class="lineNum">   21570 </span>            : {
<span class="lineNum">   21571 </span><span class="lineCov">   21454154 :   return (context_die</span>
<span class="lineNum">   21572 </span><span class="lineCov">        154 :           &amp;&amp; (context_die-&gt;die_tag == DW_TAG_structure_type</span>
<span class="lineNum">   21573 </span><span class="lineCov">   10999264 :               || context_die-&gt;die_tag == DW_TAG_class_type</span>
<span class="lineNum">   21574 </span><span class="lineCov">   14922988 :               || context_die-&gt;die_tag == DW_TAG_interface_type</span>
<span class="lineNum">   21575 </span><span class="lineCov">   14922988 :               || context_die-&gt;die_tag == DW_TAG_union_type));</span>
<span class="lineNum">   21576 </span>            : }
<span class="lineNum">   21577 </span>            : 
<span class="lineNum">   21578 </span>            : /* Returns nonzero if CONTEXT_DIE is a class or namespace, for deciding
<span class="lineNum">   21579 </span>            :    whether or not to treat a DIE in this context as a declaration.  */
<span class="lineNum">   21580 </span>            : 
<span class="lineNum">   21581 </span>            : static inline int
<span class="lineNum">   21582 </span>            : class_or_namespace_scope_p (dw_die_ref context_die)
<span class="lineNum">   21583 </span>            : {
<span class="lineNum">   21584 </span><span class="lineCov">   15379320 :   return (class_scope_p (context_die)</span>
<span class="lineNum">   21585 </span><span class="lineCov">    5418516 :           || (context_die &amp;&amp; context_die-&gt;die_tag == DW_TAG_namespace));</span>
<span class="lineNum">   21586 </span>            : }
<span class="lineNum">   21587 </span>            : 
<span class="lineNum">   21588 </span>            : /* Many forms of DIEs require a &quot;type description&quot; attribute.  This
<span class="lineNum">   21589 </span>            :    routine locates the proper &quot;type descriptor&quot; die for the type given
<span class="lineNum">   21590 </span>            :    by 'type' plus any additional qualifiers given by 'cv_quals', and
<span class="lineNum">   21591 </span>            :    adds a DW_AT_type attribute below the given die.  */
<a name="21592"><span class="lineNum">   21592 </span>            : </a>
<span class="lineNum">   21593 </span>            : static void
<span class="lineNum">   21594 </span><span class="lineCov">   56910631 : add_type_attribute (dw_die_ref object_die, tree type, int cv_quals,</span>
<span class="lineNum">   21595 </span>            :                     bool reverse, dw_die_ref context_die)
<span class="lineNum">   21596 </span>            : {
<span class="lineNum">   21597 </span><span class="lineCov">   56910631 :   enum tree_code code  = TREE_CODE (type);</span>
<span class="lineNum">   21598 </span><span class="lineCov">   56910631 :   dw_die_ref type_die  = NULL;</span>
<span class="lineNum">   21599 </span>            : 
<span class="lineNum">   21600 </span>            :   /* ??? If this type is an unnamed subrange type of an integral, floating-point
<span class="lineNum">   21601 </span>            :      or fixed-point type, use the inner type.  This is because we have no
<span class="lineNum">   21602 </span>            :      support for unnamed types in base_type_die.  This can happen if this is
<span class="lineNum">   21603 </span>            :      an Ada subrange type.  Correct solution is emit a subrange type die.  */
<span class="lineNum">   21604 </span><span class="lineCov">   56910631 :   if ((code == INTEGER_TYPE || code == REAL_TYPE || code == FIXED_POINT_TYPE)</span>
<span class="lineNum">   21605 </span><span class="lineCov">   56910631 :       &amp;&amp; TREE_TYPE (type) != 0 &amp;&amp; TYPE_NAME (type) == 0)</span>
<span class="lineNum">   21606 </span><span class="lineCov">         20 :     type = TREE_TYPE (type), code = TREE_CODE (type);</span>
<span class="lineNum">   21607 </span>            : 
<span class="lineNum">   21608 </span><span class="lineCov">  113821262 :   if (code == ERROR_MARK</span>
<span class="lineNum">   21609 </span>            :       /* Handle a special case.  For functions whose return type is void, we
<span class="lineNum">   21610 </span>            :          generate *no* type attribute.  (Note that no object may have type
<span class="lineNum">   21611 </span>            :          `void', so this only applies to function return types).  */
<span class="lineNum">   21612 </span><span class="lineCov">   56910631 :       || code == VOID_TYPE)</span>
<span class="lineNum">   21613 </span>            :     return;
<span class="lineNum">   21614 </span>            : 
<span class="lineNum">   21615 </span><span class="lineCov">  161181819 :   type_die = modified_type_die (type,</span>
<span class="lineNum">   21616 </span><span class="lineCov">   53727273 :                                 cv_quals | TYPE_QUALS (type),</span>
<span class="lineNum">   21617 </span>            :                                 reverse,
<span class="lineNum">   21618 </span>            :                                 context_die);
<span class="lineNum">   21619 </span>            : 
<span class="lineNum">   21620 </span><span class="lineCov">   53727273 :   if (type_die != NULL)</span>
<span class="lineNum">   21621 </span><span class="lineCov">   53727273 :     add_AT_die_ref (object_die, DW_AT_type, type_die);</span>
<span class="lineNum">   21622 </span>            : }
<span class="lineNum">   21623 </span>            : 
<span class="lineNum">   21624 </span>            : /* Given an object die, add the calling convention attribute for the
<a name="21625"><span class="lineNum">   21625 </span>            :    function call type.  */</a>
<span class="lineNum">   21626 </span>            : static void
<span class="lineNum">   21627 </span><span class="lineCov">    7657263 : add_calling_convention_attribute (dw_die_ref subr_die, tree decl)</span>
<span class="lineNum">   21628 </span>            : {
<span class="lineNum">   21629 </span><span class="lineCov">    7657263 :   enum dwarf_calling_convention value = DW_CC_normal;</span>
<span class="lineNum">   21630 </span>            : 
<span class="lineNum">   21631 </span><span class="lineCov">   15314526 :   value = ((enum dwarf_calling_convention)</span>
<span class="lineNum">   21632 </span><span class="lineCov">    7657263 :            targetm.dwarf_calling_convention (TREE_TYPE (decl)));</span>
<span class="lineNum">   21633 </span>            : 
<span class="lineNum">   21634 </span><span class="lineCov">    7657263 :   if (is_fortran ()</span>
<span class="lineNum">   21635 </span><span class="lineCov">    7657263 :       &amp;&amp; id_equal (DECL_ASSEMBLER_NAME (decl), &quot;MAIN__&quot;))</span>
<span class="lineNum">   21636 </span>            :     {
<span class="lineNum">   21637 </span>            :       /* DWARF 2 doesn't provide a way to identify a program's source-level
<span class="lineNum">   21638 </span>            :         entry point.  DW_AT_calling_convention attributes are only meant
<span class="lineNum">   21639 </span>            :         to describe functions' calling conventions.  However, lacking a
<span class="lineNum">   21640 </span>            :         better way to signal the Fortran main program, we used this for 
<span class="lineNum">   21641 </span>            :         a long time, following existing custom.  Now, DWARF 4 has 
<span class="lineNum">   21642 </span>            :         DW_AT_main_subprogram, which we add below, but some tools still
<span class="lineNum">   21643 </span>            :         rely on the old way, which we thus keep.  */
<span class="lineNum">   21644 </span><span class="lineCov">       2993 :       value = DW_CC_program;</span>
<span class="lineNum">   21645 </span>            : 
<span class="lineNum">   21646 </span><span class="lineCov">       2993 :       if (dwarf_version &gt;= 4 || !dwarf_strict)</span>
<span class="lineNum">   21647 </span><span class="lineCov">       2993 :         add_AT_flag (subr_die, DW_AT_main_subprogram, 1);</span>
<span class="lineNum">   21648 </span>            :     }
<span class="lineNum">   21649 </span>            : 
<span class="lineNum">   21650 </span>            :   /* Only add the attribute if the backend requests it, and
<span class="lineNum">   21651 </span>            :      is not DW_CC_normal.  */
<span class="lineNum">   21652 </span><span class="lineCov">    7657263 :   if (value &amp;&amp; (value != DW_CC_normal))</span>
<span class="lineNum">   21653 </span><span class="lineCov">       2993 :     add_AT_unsigned (subr_die, DW_AT_calling_convention, value);</span>
<span class="lineNum">   21654 </span><span class="lineCov">    7657263 : }</span>
<span class="lineNum">   21655 </span>            : 
<span class="lineNum">   21656 </span>            : /* Given a tree pointer to a struct, class, union, or enum type node, return
<span class="lineNum">   21657 </span>            :    a pointer to the (string) tag name for the given type, or zero if the type
<span class="lineNum">   21658 </span>            :    was declared without a tag.  */
<a name="21659"><span class="lineNum">   21659 </span>            : </a>
<span class="lineNum">   21660 </span>            : static const char *
<span class="lineNum">   21661 </span><span class="lineCov">    8893463 : type_tag (const_tree type)</span>
<span class="lineNum">   21662 </span>            : {
<span class="lineNum">   21663 </span><span class="lineCov">    8893463 :   const char *name = 0;</span>
<span class="lineNum">   21664 </span>            : 
<span class="lineNum">   21665 </span><span class="lineCov">    8893463 :   if (TYPE_NAME (type) != 0)</span>
<span class="lineNum">   21666 </span>            :     {
<span class="lineNum">   21667 </span><span class="lineCov">    8416015 :       tree t = 0;</span>
<span class="lineNum">   21668 </span>            : 
<span class="lineNum">   21669 </span>            :       /* Find the IDENTIFIER_NODE for the type name.  */
<span class="lineNum">   21670 </span><span class="lineCov">    8416015 :       if (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE</span>
<span class="lineNum">   21671 </span><span class="lineCov">    8416015 :           &amp;&amp; !TYPE_NAMELESS (type))</span>
<span class="lineNum">   21672 </span>            :         t = TYPE_NAME (type);
<span class="lineNum">   21673 </span>            : 
<span class="lineNum">   21674 </span>            :       /* The g++ front end makes the TYPE_NAME of *each* tagged type point to
<span class="lineNum">   21675 </span>            :          a TYPE_DECL node, regardless of whether or not a `typedef' was
<span class="lineNum">   21676 </span>            :          involved.  */
<span class="lineNum">   21677 </span><span class="lineCov">    8227625 :       else if (TREE_CODE (TYPE_NAME (type)) == TYPE_DECL</span>
<span class="lineNum">   21678 </span><span class="lineCov">    8227625 :                &amp;&amp; ! DECL_IGNORED_P (TYPE_NAME (type)))</span>
<span class="lineNum">   21679 </span>            :         {
<span class="lineNum">   21680 </span>            :           /* We want to be extra verbose.  Don't call dwarf_name if
<span class="lineNum">   21681 </span>            :              DECL_NAME isn't set.  The default hook for decl_printable_name
<span class="lineNum">   21682 </span>            :              doesn't like that, and in this context it's correct to return
<span class="lineNum">   21683 </span>            :              0, instead of &quot;&lt;anonymous&gt;&quot; or the like.  */
<span class="lineNum">   21684 </span><span class="lineCov">   16442048 :           if (DECL_NAME (TYPE_NAME (type))</span>
<span class="lineNum">   21685 </span><span class="lineCov">    8221024 :               &amp;&amp; !DECL_NAMELESS (TYPE_NAME (type)))</span>
<span class="lineNum">   21686 </span><span class="lineCov">   16440346 :             name = lang_hooks.dwarf_name (TYPE_NAME (type), 2);</span>
<span class="lineNum">   21687 </span>            :         }
<span class="lineNum">   21688 </span>            : 
<span class="lineNum">   21689 </span>            :       /* Now get the name as a string, or invent one.  */
<span class="lineNum">   21690 </span><span class="lineCov">    8416015 :       if (!name &amp;&amp; t != 0)</span>
<span class="lineNum">   21691 </span><span class="lineCov">     188390 :         name = IDENTIFIER_POINTER (t);</span>
<span class="lineNum">   21692 </span>            :     }
<span class="lineNum">   21693 </span>            : 
<span class="lineNum">   21694 </span><span class="lineCov">    8416015 :   return (name == 0 || *name == '\0') ? 0 : name;</span>
<span class="lineNum">   21695 </span>            : }
<span class="lineNum">   21696 </span>            : 
<span class="lineNum">   21697 </span>            : /* Return the type associated with a data member, make a special check
<span class="lineNum">   21698 </span>            :    for bit field types.  */
<a name="21699"><span class="lineNum">   21699 </span>            : </a>
<span class="lineNum">   21700 </span>            : static inline tree
<span class="lineNum">   21701 </span><span class="lineCov">    5125054 : member_declared_type (const_tree member)</span>
<span class="lineNum">   21702 </span>            : {
<span class="lineNum">   21703 </span><span class="lineCov">    5125054 :   return (DECL_BIT_FIELD_TYPE (member)</span>
<span class="lineNum">   21704 </span><span class="lineCov">    5125054 :           ? DECL_BIT_FIELD_TYPE (member) : TREE_TYPE (member));</span>
<span class="lineNum">   21705 </span>            : }
<span class="lineNum">   21706 </span>            : 
<span class="lineNum">   21707 </span>            : /* Get the decl's label, as described by its RTL. This may be different
<span class="lineNum">   21708 </span>            :    from the DECL_NAME name used in the source file.  */
<span class="lineNum">   21709 </span>            : 
<span class="lineNum">   21710 </span>            : #if 0
<span class="lineNum">   21711 </span>            : static const char *
<span class="lineNum">   21712 </span>            : decl_start_label (tree decl)
<span class="lineNum">   21713 </span>            : {
<span class="lineNum">   21714 </span>            :   rtx x;
<span class="lineNum">   21715 </span>            :   const char *fnname;
<span class="lineNum">   21716 </span>            : 
<span class="lineNum">   21717 </span>            :   x = DECL_RTL (decl);
<span class="lineNum">   21718 </span>            :   gcc_assert (MEM_P (x));
<span class="lineNum">   21719 </span>            : 
<span class="lineNum">   21720 </span>            :   x = XEXP (x, 0);
<span class="lineNum">   21721 </span>            :   gcc_assert (GET_CODE (x) == SYMBOL_REF);
<span class="lineNum">   21722 </span>            : 
<span class="lineNum">   21723 </span>            :   fnname = XSTR (x, 0);
<span class="lineNum">   21724 </span>            :   return fnname;
<span class="lineNum">   21725 </span>            : }
<span class="lineNum">   21726 </span>            : #endif
<span class="lineNum">   21727 </span>            : 
<span class="lineNum">   21728 </span>            : /* For variable-length arrays that have been previously generated, but
<span class="lineNum">   21729 </span>            :    may be incomplete due to missing subscript info, fill the subscript
<a name="21730"><span class="lineNum">   21730 </span>            :    info.  Return TRUE if this is one of those cases.  */</a>
<span class="lineNum">   21731 </span>            : static bool
<span class="lineNum">   21732 </span><span class="lineCov">    1608372 : fill_variable_array_bounds (tree type)</span>
<span class="lineNum">   21733 </span>            : {
<span class="lineNum">   21734 </span><span class="lineCov">    1608372 :   if (TREE_ASM_WRITTEN (type)</span>
<span class="lineNum">   21735 </span><span class="lineCov">    1608372 :       &amp;&amp; TREE_CODE (type) == ARRAY_TYPE</span>
<span class="lineNum">   21736 </span><span class="lineCov">    1608372 :       &amp;&amp; variably_modified_type_p (type, NULL))</span>
<span class="lineNum">   21737 </span>            :     {
<span class="lineNum">   21738 </span><span class="lineCov">       2343 :       dw_die_ref array_die = lookup_type_die (type);</span>
<span class="lineNum">   21739 </span><span class="lineCov">       2343 :       if (!array_die)</span>
<span class="lineNum">   21740 </span>            :         return false;
<span class="lineNum">   21741 </span><span class="lineCov">       2343 :       add_subscript_info (array_die, type, !is_ada ());</span>
<span class="lineNum">   21742 </span><span class="lineCov">       2343 :       return true;</span>
<span class="lineNum">   21743 </span>            :     }
<span class="lineNum">   21744 </span>            :   return false;
<span class="lineNum">   21745 </span>            : }
<span class="lineNum">   21746 </span>            : 
<span class="lineNum">   21747 </span>            : /* These routines generate the internal representation of the DIE's for
<span class="lineNum">   21748 </span>            :    the compilation unit.  Debugging information is collected by walking
<span class="lineNum">   21749 </span>            :    the declaration trees passed in from dwarf2out_decl().  */
<a name="21750"><span class="lineNum">   21750 </span>            : </a>
<span class="lineNum">   21751 </span>            : static void
<span class="lineNum">   21752 </span><span class="lineCov">     233280 : gen_array_type_die (tree type, dw_die_ref context_die)</span>
<span class="lineNum">   21753 </span>            : {
<span class="lineNum">   21754 </span><span class="lineCov">     233280 :   dw_die_ref array_die;</span>
<span class="lineNum">   21755 </span>            : 
<span class="lineNum">   21756 </span>            :   /* GNU compilers represent multidimensional array types as sequences of one
<span class="lineNum">   21757 </span>            :      dimensional array types whose element types are themselves array types.
<span class="lineNum">   21758 </span>            :      We sometimes squish that down to a single array_type DIE with multiple
<span class="lineNum">   21759 </span>            :      subscripts in the Dwarf debugging info.  The draft Dwarf specification
<span class="lineNum">   21760 </span>            :      say that we are allowed to do this kind of compression in C, because
<span class="lineNum">   21761 </span>            :      there is no difference between an array of arrays and a multidimensional
<span class="lineNum">   21762 </span>            :      array.  We don't do this for Ada to remain as close as possible to the
<span class="lineNum">   21763 </span>            :      actual representation, which is especially important against the language
<span class="lineNum">   21764 </span>            :      flexibilty wrt arrays of variable size.  */
<span class="lineNum">   21765 </span>            : 
<span class="lineNum">   21766 </span><span class="lineCov">     233280 :   bool collapse_nested_arrays = !is_ada ();</span>
<span class="lineNum">   21767 </span>            : 
<span class="lineNum">   21768 </span><span class="lineCov">     233280 :   if (fill_variable_array_bounds (type))</span>
<span class="lineNum">   21769 </span>            :     return;
<span class="lineNum">   21770 </span>            : 
<span class="lineNum">   21771 </span><span class="lineCov">     231001 :   dw_die_ref scope_die = scope_die_for (type, context_die);</span>
<span class="lineNum">   21772 </span><span class="lineCov">     231001 :   tree element_type;</span>
<span class="lineNum">   21773 </span>            : 
<span class="lineNum">   21774 </span>            :   /* Emit DW_TAG_string_type for Fortran character types (with kind 1 only, as
<span class="lineNum">   21775 </span>            :      DW_TAG_string_type doesn't have DW_AT_type attribute).  */
<span class="lineNum">   21776 </span><span class="lineCov">     231001 :   if (TYPE_STRING_FLAG (type)</span>
<span class="lineNum">   21777 </span><span class="lineCov">       3096 :       &amp;&amp; TREE_CODE (type) == ARRAY_TYPE</span>
<span class="lineNum">   21778 </span><span class="lineCov">       3096 :       &amp;&amp; is_fortran ()</span>
<span class="lineNum">   21779 </span><span class="lineCov">     234097 :       &amp;&amp; TYPE_MODE (TREE_TYPE (type)) == TYPE_MODE (char_type_node))</span>
<span class="lineNum">   21780 </span>            :     {
<span class="lineNum">   21781 </span><span class="lineCov">       2936 :       HOST_WIDE_INT size;</span>
<span class="lineNum">   21782 </span>            : 
<span class="lineNum">   21783 </span><span class="lineCov">       2936 :       array_die = new_die (DW_TAG_string_type, scope_die, type);</span>
<span class="lineNum">   21784 </span><span class="lineCov">       2936 :       add_name_attribute (array_die, type_tag (type));</span>
<span class="lineNum">   21785 </span><span class="lineCov">       2936 :       equate_type_number_to_die (type, array_die);</span>
<span class="lineNum">   21786 </span><span class="lineCov">       2936 :       size = int_size_in_bytes (type);</span>
<span class="lineNum">   21787 </span><span class="lineCov">       2936 :       if (size &gt;= 0)</span>
<span class="lineNum">   21788 </span><span class="lineCov">       1252 :         add_AT_unsigned (array_die, DW_AT_byte_size, size);</span>
<span class="lineNum">   21789 </span>            :       /* ???  We can't annotate types late, but for LTO we may not
<span class="lineNum">   21790 </span>            :          generate a location early either (gfortran.dg/save_6.f90).  */
<span class="lineNum">   21791 </span><span class="lineCov">       1031 :       else if (! (early_dwarf &amp;&amp; (flag_generate_lto || flag_generate_offload))</span>
<span class="lineNum">   21792 </span><span class="lineCov">       1672 :                &amp;&amp; TYPE_DOMAIN (type) != NULL_TREE</span>
<span class="lineNum">   21793 </span><span class="lineCov">       5028 :                &amp;&amp; TYPE_MAX_VALUE (TYPE_DOMAIN (type)) != NULL_TREE)</span>
<span class="lineNum">   21794 </span>            :         {
<span class="lineNum">   21795 </span><span class="lineCov">       3078 :           tree szdecl = TYPE_MAX_VALUE (TYPE_DOMAIN (type));</span>
<span class="lineNum">   21796 </span><span class="lineCov">       1539 :           tree rszdecl = szdecl;</span>
<span class="lineNum">   21797 </span>            : 
<span class="lineNum">   21798 </span><span class="lineCov">       1539 :           size = int_size_in_bytes (TREE_TYPE (szdecl));</span>
<span class="lineNum">   21799 </span><span class="lineCov">       1539 :           if (!DECL_P (szdecl))</span>
<span class="lineNum">   21800 </span>            :             {
<span class="lineNum">   21801 </span><span class="lineCov">         31 :               if (TREE_CODE (szdecl) == INDIRECT_REF</span>
<span class="lineNum">   21802 </span><span class="lineCov">         31 :                   &amp;&amp; DECL_P (TREE_OPERAND (szdecl, 0)))</span>
<span class="lineNum">   21803 </span>            :                 {
<span class="lineNum">   21804 </span><span class="lineCov">         31 :                   rszdecl = TREE_OPERAND (szdecl, 0);</span>
<span class="lineNum">   21805 </span><span class="lineCov">         62 :                   if (int_size_in_bytes (TREE_TYPE (rszdecl))</span>
<span class="lineNum">   21806 </span><span class="lineCov">         31 :                       != DWARF2_ADDR_SIZE)</span>
<span class="lineNum">   21807 </span>            :                     size = 0;
<span class="lineNum">   21808 </span>            :                 }
<span class="lineNum">   21809 </span>            :               else
<span class="lineNum">   21810 </span>            :                 size = 0;
<span class="lineNum">   21811 </span>            :             }
<span class="lineNum">   21812 </span><span class="lineCov">       1539 :           if (size &gt; 0)</span>
<span class="lineNum">   21813 </span>            :             {
<span class="lineNum">   21814 </span><span class="lineCov">       1539 :               dw_loc_list_ref loc</span>
<span class="lineNum">   21815 </span><span class="lineCov">       1570 :                 = loc_list_from_tree (rszdecl, szdecl == rszdecl ? 2 : 0,</span>
<span class="lineNum">   21816 </span>            :                                       NULL);
<span class="lineNum">   21817 </span><span class="lineCov">       1539 :               if (loc)</span>
<span class="lineNum">   21818 </span>            :                 {
<span class="lineNum">   21819 </span><span class="lineCov">       1452 :                   add_AT_location_description (array_die, DW_AT_string_length,</span>
<span class="lineNum">   21820 </span>            :                                                loc);
<span class="lineNum">   21821 </span><span class="lineCov">       1464 :                   if (size != DWARF2_ADDR_SIZE)</span>
<span class="lineNum">   21822 </span><span class="lineNoCov">          0 :                     add_AT_unsigned (array_die, dwarf_version &gt;= 5</span>
<span class="lineNum">   21823 </span>            :                                                 ? DW_AT_string_length_byte_size
<span class="lineNum">   21824 </span>            :                                                 : DW_AT_byte_size, size);
<span class="lineNum">   21825 </span>            :                 }
<span class="lineNum">   21826 </span>            :             }
<span class="lineNum">   21827 </span>            :         }
<span class="lineNum">   21828 </span><span class="lineCov">       2936 :       return;</span>
<span class="lineNum">   21829 </span>            :     }
<span class="lineNum">   21830 </span>            : 
<span class="lineNum">   21831 </span><span class="lineCov">     228065 :   array_die = new_die (DW_TAG_array_type, scope_die, type);</span>
<span class="lineNum">   21832 </span><span class="lineCov">     228065 :   add_name_attribute (array_die, type_tag (type));</span>
<span class="lineNum">   21833 </span><span class="lineCov">     228065 :   equate_type_number_to_die (type, array_die);</span>
<span class="lineNum">   21834 </span>            : 
<span class="lineNum">   21835 </span><span class="lineCov">     228065 :   if (TREE_CODE (type) == VECTOR_TYPE)</span>
<span class="lineNum">   21836 </span><span class="lineCov">       8542 :     add_AT_flag (array_die, DW_AT_GNU_vector, 1);</span>
<span class="lineNum">   21837 </span>            : 
<span class="lineNum">   21838 </span>            :   /* For Fortran multidimensional arrays use DW_ORD_col_major ordering.  */
<span class="lineNum">   21839 </span><span class="lineCov">     228065 :   if (is_fortran ()</span>
<span class="lineNum">   21840 </span><span class="lineCov">       5497 :       &amp;&amp; TREE_CODE (type) == ARRAY_TYPE</span>
<span class="lineNum">   21841 </span><span class="lineCov">       5497 :       &amp;&amp; TREE_CODE (TREE_TYPE (type)) == ARRAY_TYPE</span>
<span class="lineNum">   21842 </span><span class="lineCov">     230955 :       &amp;&amp; !TYPE_STRING_FLAG (TREE_TYPE (type)))</span>
<span class="lineNum">   21843 </span><span class="lineCov">       1053 :     add_AT_unsigned (array_die, DW_AT_ordering, DW_ORD_col_major);</span>
<span class="lineNum">   21844 </span>            : 
<span class="lineNum">   21845 </span>            : #if 0
<span class="lineNum">   21846 </span>            :   /* We default the array ordering.  Debuggers will probably do the right
<span class="lineNum">   21847 </span>            :      things even if DW_AT_ordering is not present.  It's not even an issue
<span class="lineNum">   21848 </span>            :      until we start to get into multidimensional arrays anyway.  If a debugger
<span class="lineNum">   21849 </span>            :      is ever caught doing the Wrong Thing for multi-dimensional arrays,
<span class="lineNum">   21850 </span>            :      then we'll have to put the DW_AT_ordering attribute back in.  (But if
<span class="lineNum">   21851 </span>            :      and when we find out that we need to put these in, we will only do so
<span class="lineNum">   21852 </span>            :      for multidimensional arrays.  */
<span class="lineNum">   21853 </span>            :   add_AT_unsigned (array_die, DW_AT_ordering, DW_ORD_row_major);
<span class="lineNum">   21854 </span>            : #endif
<span class="lineNum">   21855 </span>            : 
<span class="lineNum">   21856 </span><span class="lineCov">     228065 :   if (TREE_CODE (type) == VECTOR_TYPE)</span>
<span class="lineNum">   21857 </span>            :     {
<span class="lineNum">   21858 </span>            :       /* For VECTOR_TYPEs we use an array die with appropriate bounds.  */
<span class="lineNum">   21859 </span><span class="lineCov">       8542 :       dw_die_ref subrange_die = new_die (DW_TAG_subrange_type, array_die, NULL);</span>
<span class="lineNum">   21860 </span><span class="lineCov">       8542 :       add_bound_info (subrange_die, DW_AT_lower_bound, size_zero_node, NULL);</span>
<span class="lineNum">   21861 </span><span class="lineCov">       8542 :       add_bound_info (subrange_die, DW_AT_upper_bound,</span>
<span class="lineNum">   21862 </span><span class="lineCov">      17084 :                       size_int (TYPE_VECTOR_SUBPARTS (type) - 1), NULL);</span>
<span class="lineNum">   21863 </span>            :     }
<span class="lineNum">   21864 </span>            :   else
<span class="lineNum">   21865 </span><span class="lineCov">     219523 :     add_subscript_info (array_die, type, collapse_nested_arrays);</span>
<span class="lineNum">   21866 </span>            : 
<span class="lineNum">   21867 </span>            :   /* Add representation of the type of the elements of this array type and
<span class="lineNum">   21868 </span>            :      emit the corresponding DIE if we haven't done it already.  */
<span class="lineNum">   21869 </span><span class="lineCov">     228065 :   element_type = TREE_TYPE (type);</span>
<span class="lineNum">   21870 </span><span class="lineCov">     228065 :   if (collapse_nested_arrays)</span>
<span class="lineNum">   21871 </span><span class="lineCov">     230704 :     while (TREE_CODE (element_type) == ARRAY_TYPE)</span>
<span class="lineNum">   21872 </span>            :       {
<span class="lineNum">   21873 </span><span class="lineCov">       3148 :         if (TYPE_STRING_FLAG (element_type) &amp;&amp; is_fortran ())</span>
<span class="lineNum">   21874 </span>            :           break;
<span class="lineNum">   21875 </span><span class="lineCov">       2639 :         element_type = TREE_TYPE (element_type);</span>
<span class="lineNum">   21876 </span>            :       }
<span class="lineNum">   21877 </span>            : 
<span class="lineNum">   21878 </span><span class="lineCov">     228065 :   add_type_attribute (array_die, element_type, TYPE_UNQUALIFIED,</span>
<span class="lineNum">   21879 </span><span class="lineCov">     228065 :                       TREE_CODE (type) == ARRAY_TYPE</span>
<span class="lineNum">   21880 </span><span class="lineCov">     228065 :                       &amp;&amp; TYPE_REVERSE_STORAGE_ORDER (type),</span>
<span class="lineNum">   21881 </span>            :                       context_die);
<span class="lineNum">   21882 </span>            : 
<span class="lineNum">   21883 </span><span class="lineCov">     228065 :   add_gnat_descriptive_type_attribute (array_die, type, context_die);</span>
<span class="lineNum">   21884 </span><span class="lineCov">     228065 :   if (TYPE_ARTIFICIAL (type))</span>
<span class="lineNum">   21885 </span><span class="lineNoCov">          0 :     add_AT_flag (array_die, DW_AT_artificial, 1);</span>
<span class="lineNum">   21886 </span>            : 
<span class="lineNum">   21887 </span><span class="lineCov">     228065 :   if (get_AT (array_die, DW_AT_name))</span>
<span class="lineNum">   21888 </span><span class="lineCov">          8 :     add_pubtype (type, array_die);</span>
<span class="lineNum">   21889 </span>            : 
<span class="lineNum">   21890 </span><span class="lineCov">     228065 :   add_alignment_attribute (array_die, type);</span>
<span class="lineNum">   21891 </span>            : }
<span class="lineNum">   21892 </span>            : 
<span class="lineNum">   21893 </span>            : /* This routine generates DIE for array with hidden descriptor, details
<span class="lineNum">   21894 </span>            :    are filled into *info by a langhook.  */
<a name="21895"><span class="lineNum">   21895 </span>            : </a>
<span class="lineNum">   21896 </span>            : static void
<span class="lineNum">   21897 </span><span class="lineCov">       2988 : gen_descr_array_type_die (tree type, struct array_descr_info *info,</span>
<span class="lineNum">   21898 </span>            :                           dw_die_ref context_die)
<span class="lineNum">   21899 </span>            : {
<span class="lineNum">   21900 </span><span class="lineCov">       2988 :   const dw_die_ref scope_die = scope_die_for (type, context_die);</span>
<span class="lineNum">   21901 </span><span class="lineCov">       2988 :   const dw_die_ref array_die = new_die (DW_TAG_array_type, scope_die, type);</span>
<span class="lineNum">   21902 </span><span class="lineCov">       5976 :   struct loc_descr_context context = { type, info-&gt;base_decl, NULL,</span>
<span class="lineNum">   21903 </span><span class="lineCov">       5976 :                                        false, false };</span>
<span class="lineNum">   21904 </span><span class="lineCov">       2988 :   enum dwarf_tag subrange_tag = DW_TAG_subrange_type;</span>
<span class="lineNum">   21905 </span><span class="lineCov">       2988 :   int dim;</span>
<span class="lineNum">   21906 </span>            : 
<span class="lineNum">   21907 </span><span class="lineCov">       2988 :   add_name_attribute (array_die, type_tag (type));</span>
<span class="lineNum">   21908 </span><span class="lineCov">       2988 :   equate_type_number_to_die (type, array_die);</span>
<span class="lineNum">   21909 </span>            : 
<span class="lineNum">   21910 </span><span class="lineCov">       2988 :   if (info-&gt;ndimensions &gt; 1)</span>
<span class="lineNum">   21911 </span><span class="lineCov">       1148 :     switch (info-&gt;ordering)</span>
<span class="lineNum">   21912 </span>            :       {
<span class="lineNum">   21913 </span><span class="lineNoCov">          0 :       case array_descr_ordering_row_major:</span>
<span class="lineNum">   21914 </span><span class="lineNoCov">          0 :         add_AT_unsigned (array_die, DW_AT_ordering, DW_ORD_row_major);</span>
<span class="lineNum">   21915 </span>            :         break;
<span class="lineNum">   21916 </span><span class="lineCov">       1148 :       case array_descr_ordering_column_major:</span>
<span class="lineNum">   21917 </span><span class="lineCov">       1148 :         add_AT_unsigned (array_die, DW_AT_ordering, DW_ORD_col_major);</span>
<span class="lineNum">   21918 </span>            :         break;
<span class="lineNum">   21919 </span>            :       default:
<span class="lineNum">   21920 </span>            :         break;
<span class="lineNum">   21921 </span>            :       }
<span class="lineNum">   21922 </span>            : 
<span class="lineNum">   21923 </span><span class="lineCov">       2988 :   if (dwarf_version &gt;= 3 || !dwarf_strict)</span>
<span class="lineNum">   21924 </span>            :     {
<span class="lineNum">   21925 </span><span class="lineCov">       2988 :       if (info-&gt;data_location)</span>
<span class="lineNum">   21926 </span><span class="lineCov">       2988 :         add_scalar_info (array_die, DW_AT_data_location, info-&gt;data_location,</span>
<span class="lineNum">   21927 </span>            :                          dw_scalar_form_exprloc, &amp;context);
<span class="lineNum">   21928 </span><span class="lineCov">       2988 :       if (info-&gt;associated)</span>
<span class="lineNum">   21929 </span><span class="lineCov">        495 :         add_scalar_info (array_die, DW_AT_associated, info-&gt;associated,</span>
<span class="lineNum">   21930 </span>            :                          dw_scalar_form_constant
<span class="lineNum">   21931 </span>            :                          | dw_scalar_form_exprloc
<span class="lineNum">   21932 </span>            :                          | dw_scalar_form_reference, &amp;context);
<span class="lineNum">   21933 </span><span class="lineCov">       2988 :       if (info-&gt;allocated)</span>
<span class="lineNum">   21934 </span><span class="lineCov">       1010 :         add_scalar_info (array_die, DW_AT_allocated, info-&gt;allocated,</span>
<span class="lineNum">   21935 </span>            :                          dw_scalar_form_constant
<span class="lineNum">   21936 </span>            :                          | dw_scalar_form_exprloc
<span class="lineNum">   21937 </span>            :                          | dw_scalar_form_reference, &amp;context);
<span class="lineNum">   21938 </span><span class="lineCov">       2988 :       if (info-&gt;stride)</span>
<span class="lineNum">   21939 </span>            :         {
<span class="lineNum">   21940 </span><span class="lineNoCov">          0 :           const enum dwarf_attribute attr</span>
<span class="lineNum">   21941 </span><span class="lineNoCov">          0 :             = (info-&gt;stride_in_bits) ? DW_AT_bit_stride : DW_AT_byte_stride;</span>
<span class="lineNum">   21942 </span><span class="lineNoCov">          0 :           const int forms</span>
<span class="lineNum">   21943 </span>            :             = (info-&gt;stride_in_bits)
<span class="lineNum">   21944 </span><span class="lineNoCov">          0 :               ? dw_scalar_form_constant</span>
<span class="lineNum">   21945 </span>            :               : (dw_scalar_form_constant
<span class="lineNum">   21946 </span>            :                  | dw_scalar_form_exprloc
<span class="lineNum">   21947 </span>            :                  | dw_scalar_form_reference);
<span class="lineNum">   21948 </span>            : 
<span class="lineNum">   21949 </span><span class="lineNoCov">          0 :           add_scalar_info (array_die, attr, info-&gt;stride, forms, &amp;context);</span>
<span class="lineNum">   21950 </span>            :         }
<span class="lineNum">   21951 </span>            :     }
<span class="lineNum">   21952 </span><span class="lineCov">       2988 :   if (dwarf_version &gt;= 5)</span>
<span class="lineNum">   21953 </span>            :     {
<span class="lineNum">   21954 </span><span class="lineNoCov">          0 :       if (info-&gt;rank)</span>
<span class="lineNum">   21955 </span>            :         {
<span class="lineNum">   21956 </span><span class="lineNoCov">          0 :           add_scalar_info (array_die, DW_AT_rank, info-&gt;rank,</span>
<span class="lineNum">   21957 </span>            :                            dw_scalar_form_constant
<span class="lineNum">   21958 </span>            :                            | dw_scalar_form_exprloc, &amp;context);
<span class="lineNum">   21959 </span><span class="lineNoCov">          0 :           subrange_tag = DW_TAG_generic_subrange;</span>
<span class="lineNum">   21960 </span><span class="lineNoCov">          0 :           context.placeholder_arg = true;</span>
<span class="lineNum">   21961 </span>            :         }
<span class="lineNum">   21962 </span>            :     }
<span class="lineNum">   21963 </span>            : 
<span class="lineNum">   21964 </span><span class="lineCov">       2988 :   add_gnat_descriptive_type_attribute (array_die, type, context_die);</span>
<span class="lineNum">   21965 </span>            : 
<span class="lineNum">   21966 </span><span class="lineCov">      13155 :   for (dim = 0; dim &lt; info-&gt;ndimensions; dim++)</span>
<span class="lineNum">   21967 </span>            :     {
<span class="lineNum">   21968 </span><span class="lineCov">      10167 :       dw_die_ref subrange_die = new_die (subrange_tag, array_die, NULL);</span>
<span class="lineNum">   21969 </span>            : 
<span class="lineNum">   21970 </span><span class="lineCov">      10167 :       if (info-&gt;dimen[dim].bounds_type)</span>
<span class="lineNum">   21971 </span><span class="lineNoCov">          0 :         add_type_attribute (subrange_die,</span>
<span class="lineNum">   21972 </span>            :                             info-&gt;dimen[dim].bounds_type, TYPE_UNQUALIFIED,
<span class="lineNum">   21973 </span>            :                             false, context_die);
<span class="lineNum">   21974 </span><span class="lineCov">      10167 :       if (info-&gt;dimen[dim].lower_bound)</span>
<span class="lineNum">   21975 </span><span class="lineCov">      10167 :         add_bound_info (subrange_die, DW_AT_lower_bound,</span>
<span class="lineNum">   21976 </span>            :                         info-&gt;dimen[dim].lower_bound, &amp;context);
<span class="lineNum">   21977 </span><span class="lineCov">      10167 :       if (info-&gt;dimen[dim].upper_bound)</span>
<span class="lineNum">   21978 </span><span class="lineCov">      10167 :         add_bound_info (subrange_die, DW_AT_upper_bound,</span>
<span class="lineNum">   21979 </span>            :                         info-&gt;dimen[dim].upper_bound, &amp;context);
<span class="lineNum">   21980 </span><span class="lineCov">      10167 :       if ((dwarf_version &gt;= 3 || !dwarf_strict) &amp;&amp; info-&gt;dimen[dim].stride)</span>
<span class="lineNum">   21981 </span><span class="lineCov">      10167 :         add_scalar_info (subrange_die, DW_AT_byte_stride,</span>
<span class="lineNum">   21982 </span>            :                          info-&gt;dimen[dim].stride,
<span class="lineNum">   21983 </span>            :                          dw_scalar_form_constant
<span class="lineNum">   21984 </span>            :                          | dw_scalar_form_exprloc
<span class="lineNum">   21985 </span>            :                          | dw_scalar_form_reference,
<span class="lineNum">   21986 </span>            :                          &amp;context);
<span class="lineNum">   21987 </span>            :     }
<span class="lineNum">   21988 </span>            : 
<span class="lineNum">   21989 </span><span class="lineCov">       2988 :   gen_type_die (info-&gt;element_type, context_die);</span>
<span class="lineNum">   21990 </span><span class="lineCov">       2988 :   add_type_attribute (array_die, info-&gt;element_type, TYPE_UNQUALIFIED,</span>
<span class="lineNum">   21991 </span><span class="lineCov">       2988 :                       TREE_CODE (type) == ARRAY_TYPE</span>
<span class="lineNum">   21992 </span><span class="lineCov">       2988 :                       &amp;&amp; TYPE_REVERSE_STORAGE_ORDER (type),</span>
<span class="lineNum">   21993 </span>            :                       context_die);
<span class="lineNum">   21994 </span>            : 
<span class="lineNum">   21995 </span><span class="lineCov">       2988 :   if (get_AT (array_die, DW_AT_name))</span>
<span class="lineNum">   21996 </span><span class="lineNoCov">          0 :     add_pubtype (type, array_die);</span>
<span class="lineNum">   21997 </span>            : 
<span class="lineNum">   21998 </span><span class="lineCov">       2988 :   add_alignment_attribute (array_die, type);</span>
<span class="lineNum">   21999 </span><span class="lineCov">       2988 : }</span>
<span class="lineNum">   22000 </span>            : 
<span class="lineNum">   22001 </span>            : #if 0
<span class="lineNum">   22002 </span>            : static void
<span class="lineNum">   22003 </span>            : gen_entry_point_die (tree decl, dw_die_ref context_die)
<span class="lineNum">   22004 </span>            : {
<span class="lineNum">   22005 </span>            :   tree origin = decl_ultimate_origin (decl);
<span class="lineNum">   22006 </span>            :   dw_die_ref decl_die = new_die (DW_TAG_entry_point, context_die, decl);
<span class="lineNum">   22007 </span>            : 
<span class="lineNum">   22008 </span>            :   if (origin != NULL)
<span class="lineNum">   22009 </span>            :     add_abstract_origin_attribute (decl_die, origin);
<span class="lineNum">   22010 </span>            :   else
<span class="lineNum">   22011 </span>            :     {
<span class="lineNum">   22012 </span>            :       add_name_and_src_coords_attributes (decl_die, decl);
<span class="lineNum">   22013 </span>            :       add_type_attribute (decl_die, TREE_TYPE (TREE_TYPE (decl)),
<span class="lineNum">   22014 </span>            :                           TYPE_UNQUALIFIED, false, context_die);
<span class="lineNum">   22015 </span>            :     }
<span class="lineNum">   22016 </span>            : 
<span class="lineNum">   22017 </span>            :   if (DECL_ABSTRACT_P (decl))
<span class="lineNum">   22018 </span>            :     equate_decl_number_to_die (decl, decl_die);
<span class="lineNum">   22019 </span>            :   else
<span class="lineNum">   22020 </span>            :     add_AT_lbl_id (decl_die, DW_AT_low_pc, decl_start_label (decl));
<span class="lineNum">   22021 </span>            : }
<span class="lineNum">   22022 </span>            : #endif
<span class="lineNum">   22023 </span>            : 
<span class="lineNum">   22024 </span>            : /* Walk through the list of incomplete types again, trying once more to
<span class="lineNum">   22025 </span>            :    emit full debugging info for them.  */
<a name="22026"><span class="lineNum">   22026 </span>            : </a>
<span class="lineNum">   22027 </span>            : static void
<span class="lineNum">   22028 </span><span class="lineCov">      33604 : retry_incomplete_types (void)</span>
<span class="lineNum">   22029 </span>            : {
<span class="lineNum">   22030 </span><span class="lineCov">      33604 :   set_early_dwarf s;</span>
<span class="lineNum">   22031 </span><span class="lineCov">      33604 :   int i;</span>
<span class="lineNum">   22032 </span>            : 
<span class="lineNum">   22033 </span><span class="lineCov">   27062280 :   for (i = vec_safe_length (incomplete_types) - 1; i &gt;= 0; i--)</span>
<span class="lineNum">   22034 </span><span class="lineCov">   26995072 :     if (should_emit_struct_debug ((*incomplete_types)[i], DINFO_USAGE_DIR_USE))</span>
<span class="lineNum">   22035 </span><span class="lineCov">   26994778 :       gen_type_die ((*incomplete_types)[i], comp_unit_die ());</span>
<span class="lineNum">   22036 </span><span class="lineCov">      33604 :   vec_safe_truncate (incomplete_types, 0);</span>
<span class="lineNum">   22037 </span><span class="lineCov">      33604 : }</span>
<span class="lineNum">   22038 </span>            : 
<span class="lineNum">   22039 </span>            : /* Determine what tag to use for a record type.  */
<a name="22040"><span class="lineNum">   22040 </span>            : </a>
<span class="lineNum">   22041 </span>            : static enum dwarf_tag
<span class="lineNum">   22042 </span><span class="lineCov">    8280924 : record_type_tag (tree type)</span>
<span class="lineNum">   22043 </span>            : {
<span class="lineNum">   22044 </span><span class="lineCov">    8280924 :   if (! lang_hooks.types.classify_record)</span>
<span class="lineNum">   22045 </span>            :     return DW_TAG_structure_type;
<span class="lineNum">   22046 </span>            : 
<span class="lineNum">   22047 </span><span class="lineCov">    7988057 :   switch (lang_hooks.types.classify_record (type))</span>
<span class="lineNum">   22048 </span>            :     {
<span class="lineNum">   22049 </span>            :     case RECORD_IS_STRUCT:
<span class="lineNum">   22050 </span>            :       return DW_TAG_structure_type;
<span class="lineNum">   22051 </span>            : 
<span class="lineNum">   22052 </span><span class="lineCov">     453404 :     case RECORD_IS_CLASS:</span>
<span class="lineNum">   22053 </span><span class="lineCov">     453404 :       return DW_TAG_class_type;</span>
<span class="lineNum">   22054 </span>            : 
<span class="lineNum">   22055 </span><span class="lineNoCov">          0 :     case RECORD_IS_INTERFACE:</span>
<span class="lineNum">   22056 </span><span class="lineNoCov">          0 :       if (dwarf_version &gt;= 3 || !dwarf_strict)</span>
<span class="lineNum">   22057 </span><span class="lineNoCov">          0 :         return DW_TAG_interface_type;</span>
<span class="lineNum">   22058 </span>            :       return DW_TAG_structure_type;
<span class="lineNum">   22059 </span>            : 
<span class="lineNum">   22060 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">   22061 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">   22062 </span>            :     }
<span class="lineNum">   22063 </span>            : }
<span class="lineNum">   22064 </span>            : 
<span class="lineNum">   22065 </span>            : /* Generate a DIE to represent an enumeration type.  Note that these DIEs
<span class="lineNum">   22066 </span>            :    include all of the information about the enumeration values also. Each
<span class="lineNum">   22067 </span>            :    enumerated type name/value is listed as a child of the enumerated type
<span class="lineNum">   22068 </span>            :    DIE.  */
<a name="22069"><span class="lineNum">   22069 </span>            : </a>
<span class="lineNum">   22070 </span>            : static dw_die_ref
<span class="lineNum">   22071 </span><span class="lineCov">     262221 : gen_enumeration_type_die (tree type, dw_die_ref context_die)</span>
<span class="lineNum">   22072 </span>            : {
<span class="lineNum">   22073 </span><span class="lineCov">     262221 :   dw_die_ref type_die = lookup_type_die (type);</span>
<span class="lineNum">   22074 </span><span class="lineCov">     262221 :   dw_die_ref orig_type_die = type_die;</span>
<span class="lineNum">   22075 </span>            : 
<span class="lineNum">   22076 </span><span class="lineCov">     262221 :   if (type_die == NULL)</span>
<span class="lineNum">   22077 </span>            :     {
<span class="lineNum">   22078 </span><span class="lineCov">     261737 :       type_die = new_die (DW_TAG_enumeration_type,</span>
<span class="lineNum">   22079 </span>            :                           scope_die_for (type, context_die), type);
<span class="lineNum">   22080 </span><span class="lineCov">     261737 :       equate_type_number_to_die (type, type_die);</span>
<span class="lineNum">   22081 </span><span class="lineCov">     261737 :       add_name_attribute (type_die, type_tag (type));</span>
<span class="lineNum">   22082 </span><span class="lineCov">        873 :       if ((dwarf_version &gt;= 4 || !dwarf_strict)</span>
<span class="lineNum">   22083 </span><span class="lineCov">     262610 :           &amp;&amp; ENUM_IS_SCOPED (type))</span>
<span class="lineNum">   22084 </span><span class="lineCov">       5757 :         add_AT_flag (type_die, DW_AT_enum_class, 1);</span>
<span class="lineNum">   22085 </span><span class="lineCov">     261737 :       if (ENUM_IS_OPAQUE (type) &amp;&amp; TYPE_SIZE (type))</span>
<span class="lineNum">   22086 </span><span class="lineCov">        438 :         add_AT_flag (type_die, DW_AT_declaration, 1);</span>
<span class="lineNum">   22087 </span><span class="lineCov">     261737 :       if (!dwarf_strict)</span>
<span class="lineNum">   22088 </span><span class="lineCov">     261737 :         add_AT_unsigned (type_die, DW_AT_encoding,</span>
<span class="lineNum">   22089 </span><span class="lineCov">     261737 :                          TYPE_UNSIGNED (type)</span>
<span class="lineNum">   22090 </span>            :                          ? DW_ATE_unsigned
<span class="lineNum">   22091 </span><span class="lineCov">     261737 :                          : DW_ATE_signed);</span>
<span class="lineNum">   22092 </span>            :     }
<span class="lineNum">   22093 </span><span class="lineCov">        484 :   else if (! TYPE_SIZE (type) || ENUM_IS_OPAQUE (type))</span>
<span class="lineNum">   22094 </span>            :     return type_die;
<span class="lineNum">   22095 </span>            :   else
<span class="lineNum">   22096 </span><span class="lineCov">          2 :     remove_AT (type_die, DW_AT_declaration);</span>
<span class="lineNum">   22097 </span>            : 
<span class="lineNum">   22098 </span>            :   /* Handle a GNU C/C++ extension, i.e. incomplete enum types.  If the
<span class="lineNum">   22099 </span>            :      given enum type is incomplete, do not generate the DW_AT_byte_size
<span class="lineNum">   22100 </span>            :      attribute or the DW_AT_element_list attribute.  */
<span class="lineNum">   22101 </span><span class="lineCov">     261739 :   if (TYPE_SIZE (type))</span>
<span class="lineNum">   22102 </span>            :     {
<span class="lineNum">   22103 </span><span class="lineCov">     261737 :       tree link;</span>
<span class="lineNum">   22104 </span>            : 
<span class="lineNum">   22105 </span><span class="lineCov">     261737 :       if (!ENUM_IS_OPAQUE (type))</span>
<span class="lineNum">   22106 </span><span class="lineCov">     261299 :         TREE_ASM_WRITTEN (type) = 1;</span>
<span class="lineNum">   22107 </span><span class="lineCov">     261737 :       if (!orig_type_die || !get_AT (type_die, DW_AT_byte_size))</span>
<span class="lineNum">   22108 </span><span class="lineCov">     261736 :         add_byte_size_attribute (type_die, type);</span>
<span class="lineNum">   22109 </span><span class="lineCov">     261737 :       if (!orig_type_die || !get_AT (type_die, DW_AT_alignment))</span>
<span class="lineNum">   22110 </span><span class="lineCov">     261737 :         add_alignment_attribute (type_die, type);</span>
<span class="lineNum">   22111 </span><span class="lineCov">        873 :       if ((dwarf_version &gt;= 3 || !dwarf_strict)</span>
<span class="lineNum">   22112 </span><span class="lineCov">     262610 :           &amp;&amp; (!orig_type_die || !get_AT (type_die, DW_AT_type)))</span>
<span class="lineNum">   22113 </span>            :         {
<span class="lineNum">   22114 </span><span class="lineCov">     261736 :           tree underlying = lang_hooks.types.enum_underlying_base_type (type);</span>
<span class="lineNum">   22115 </span><span class="lineCov">     261736 :           add_type_attribute (type_die, underlying, TYPE_UNQUALIFIED, false,</span>
<span class="lineNum">   22116 </span>            :                               context_die);
<span class="lineNum">   22117 </span>            :         }
<span class="lineNum">   22118 </span><span class="lineCov">     261737 :       if (TYPE_STUB_DECL (type) != NULL_TREE)</span>
<span class="lineNum">   22119 </span>            :         {
<span class="lineNum">   22120 </span><span class="lineCov">     261737 :           if (!orig_type_die || !get_AT (type_die, DW_AT_decl_file))</span>
<span class="lineNum">   22121 </span><span class="lineCov">     785208 :             add_src_coords_attributes (type_die, TYPE_STUB_DECL (type));</span>
<span class="lineNum">   22122 </span><span class="lineCov">     261737 :           if (!orig_type_die || !get_AT (type_die, DW_AT_accessibility))</span>
<span class="lineNum">   22123 </span><span class="lineCov">     261737 :             add_accessibility_attribute (type_die, TYPE_STUB_DECL (type));</span>
<span class="lineNum">   22124 </span>            :         }
<span class="lineNum">   22125 </span>            : 
<span class="lineNum">   22126 </span>            :       /* If the first reference to this type was as the return type of an
<span class="lineNum">   22127 </span>            :          inline function, then it may not have a parent.  Fix this now.  */
<span class="lineNum">   22128 </span><span class="lineCov">     261737 :       if (type_die-&gt;die_parent == NULL)</span>
<span class="lineNum">   22129 </span><span class="lineCov">          3 :         add_child_die (scope_die_for (type, context_die), type_die);</span>
<span class="lineNum">   22130 </span>            : 
<span class="lineNum">   22131 </span><span class="lineCov">     261737 :       for (link = TYPE_VALUES (type);</span>
<span class="lineNum">   22132 </span><span class="lineCov">    4246804 :            link != NULL; link = TREE_CHAIN (link))</span>
<span class="lineNum">   22133 </span>            :         {
<span class="lineNum">   22134 </span><span class="lineCov">    3985067 :           dw_die_ref enum_die = new_die (DW_TAG_enumerator, type_die, link);</span>
<span class="lineNum">   22135 </span><span class="lineCov">    3985067 :           tree value = TREE_VALUE (link);</span>
<span class="lineNum">   22136 </span>            : 
<span class="lineNum">   22137 </span><span class="lineCov">    3985067 :           gcc_assert (!ENUM_IS_OPAQUE (type));</span>
<span class="lineNum">   22138 </span><span class="lineCov">    7970134 :           add_name_attribute (enum_die,</span>
<span class="lineNum">   22139 </span><span class="lineCov">    7970134 :                               IDENTIFIER_POINTER (TREE_PURPOSE (link)));</span>
<span class="lineNum">   22140 </span>            : 
<span class="lineNum">   22141 </span><span class="lineCov">    3985067 :           if (TREE_CODE (value) == CONST_DECL)</span>
<span class="lineNum">   22142 </span><span class="lineCov">    1886201 :             value = DECL_INITIAL (value);</span>
<span class="lineNum">   22143 </span>            : 
<span class="lineNum">   22144 </span><span class="lineCov">    3985067 :           if (simple_type_size_in_bits (TREE_TYPE (value))</span>
<span class="lineNum">   22145 </span><span class="lineCov">    3985067 :               &lt;= HOST_BITS_PER_WIDE_INT || tree_fits_shwi_p (value))</span>
<span class="lineNum">   22146 </span>            :             {
<span class="lineNum">   22147 </span>            :               /* For constant forms created by add_AT_unsigned DWARF
<span class="lineNum">   22148 </span>            :                  consumers (GDB, elfutils, etc.) always zero extend
<span class="lineNum">   22149 </span>            :                  the value.  Only when the actual value is negative
<span class="lineNum">   22150 </span>            :                  do we need to use add_AT_int to generate a constant
<span class="lineNum">   22151 </span>            :                  form that can represent negative values.  */
<span class="lineNum">   22152 </span><span class="lineCov">    3985067 :               HOST_WIDE_INT val = TREE_INT_CST_LOW (value);</span>
<span class="lineNum">   22153 </span><span class="lineCov">    3985067 :               if (TYPE_UNSIGNED (TREE_TYPE (value)) || val &gt;= 0)</span>
<span class="lineNum">   22154 </span><span class="lineCov">    3968256 :                 add_AT_unsigned (enum_die, DW_AT_const_value,</span>
<span class="lineNum">   22155 </span>            :                                  (unsigned HOST_WIDE_INT) val);
<span class="lineNum">   22156 </span>            :               else
<span class="lineNum">   22157 </span><span class="lineCov">      16811 :                 add_AT_int (enum_die, DW_AT_const_value, val);</span>
<span class="lineNum">   22158 </span>            :             }
<span class="lineNum">   22159 </span>            :           else
<span class="lineNum">   22160 </span>            :             /* Enumeration constants may be wider than HOST_WIDE_INT.  Handle
<span class="lineNum">   22161 </span>            :                that here.  TODO: This should be re-worked to use correct
<span class="lineNum">   22162 </span>            :                signed/unsigned double tags for all cases.  */
<span class="lineNum">   22163 </span><span class="lineNoCov">          0 :             add_AT_wide (enum_die, DW_AT_const_value, wi::to_wide (value));</span>
<span class="lineNum">   22164 </span>            :         }
<span class="lineNum">   22165 </span>            : 
<span class="lineNum">   22166 </span><span class="lineCov">     261737 :       add_gnat_descriptive_type_attribute (type_die, type, context_die);</span>
<span class="lineNum">   22167 </span><span class="lineCov">     261737 :       if (TYPE_ARTIFICIAL (type)</span>
<span class="lineNum">   22168 </span><span class="lineCov">     261737 :           &amp;&amp; (!orig_type_die || !get_AT (type_die, DW_AT_artificial)))</span>
<span class="lineNum">   22169 </span><span class="lineNoCov">          0 :         add_AT_flag (type_die, DW_AT_artificial, 1);</span>
<span class="lineNum">   22170 </span>            :     }
<span class="lineNum">   22171 </span>            :   else
<span class="lineNum">   22172 </span><span class="lineCov">          2 :     add_AT_flag (type_die, DW_AT_declaration, 1);</span>
<span class="lineNum">   22173 </span>            : 
<span class="lineNum">   22174 </span><span class="lineCov">     261739 :   add_pubtype (type, type_die);</span>
<span class="lineNum">   22175 </span>            : 
<span class="lineNum">   22176 </span><span class="lineCov">     261739 :   return type_die;</span>
<span class="lineNum">   22177 </span>            : }
<span class="lineNum">   22178 </span>            : 
<span class="lineNum">   22179 </span>            : /* Generate a DIE to represent either a real live formal parameter decl or to
<span class="lineNum">   22180 </span>            :    represent just the type of some formal parameter position in some function
<span class="lineNum">   22181 </span>            :    type.
<span class="lineNum">   22182 </span>            : 
<span class="lineNum">   22183 </span>            :    Note that this routine is a bit unusual because its argument may be a
<span class="lineNum">   22184 </span>            :    ..._DECL node (i.e. either a PARM_DECL or perhaps a VAR_DECL which
<span class="lineNum">   22185 </span>            :    represents an inlining of some PARM_DECL) or else some sort of a ..._TYPE
<span class="lineNum">   22186 </span>            :    node.  If it's the former then this function is being called to output a
<span class="lineNum">   22187 </span>            :    DIE to represent a formal parameter object (or some inlining thereof).  If
<span class="lineNum">   22188 </span>            :    it's the latter, then this function is only being called to output a
<span class="lineNum">   22189 </span>            :    DW_TAG_formal_parameter DIE to stand as a placeholder for some formal
<span class="lineNum">   22190 </span>            :    argument type of some subprogram type.
<span class="lineNum">   22191 </span>            :    If EMIT_NAME_P is true, name and source coordinate attributes
<span class="lineNum">   22192 </span>            :    are emitted.  */
<a name="22193"><span class="lineNum">   22193 </span>            : </a>
<span class="lineNum">   22194 </span>            : static dw_die_ref
<span class="lineNum">   22195 </span><span class="lineCov">   21177523 : gen_formal_parameter_die (tree node, tree origin, bool emit_name_p,</span>
<span class="lineNum">   22196 </span>            :                           dw_die_ref context_die)
<span class="lineNum">   22197 </span>            : {
<span class="lineNum">   22198 </span><span class="lineCov">   21177523 :   tree node_or_origin = node ? node : origin;</span>
<span class="lineNum">   22199 </span><span class="lineCov">   21177523 :   tree ultimate_origin;</span>
<span class="lineNum">   22200 </span><span class="lineCov">   21177523 :   dw_die_ref parm_die = NULL;</span>
<span class="lineNum">   22201 </span>            :   
<span class="lineNum">   22202 </span><span class="lineCov">   21177523 :   if (DECL_P (node_or_origin))</span>
<span class="lineNum">   22203 </span>            :     {
<span class="lineNum">   22204 </span><span class="lineCov">    8751412 :       parm_die = lookup_decl_die (node);</span>
<span class="lineNum">   22205 </span>            : 
<span class="lineNum">   22206 </span>            :       /* If the contexts differ, we may not be talking about the same
<span class="lineNum">   22207 </span>            :          thing.
<span class="lineNum">   22208 </span>            :          ???  When in LTO the DIE parent is the &quot;abstract&quot; copy and the
<span class="lineNum">   22209 </span>            :          context_die is the specification &quot;copy&quot;.  But this whole block
<span class="lineNum">   22210 </span>            :          should eventually be no longer needed.  */
<span class="lineNum">   22211 </span><span class="lineCov">    8751412 :       if (parm_die &amp;&amp; parm_die-&gt;die_parent != context_die &amp;&amp; !in_lto_p)</span>
<span class="lineNum">   22212 </span>            :         {
<span class="lineNum">   22213 </span><span class="lineCov">      62698 :           if (!DECL_ABSTRACT_P (node))</span>
<span class="lineNum">   22214 </span>            :             {
<span class="lineNum">   22215 </span>            :               /* This can happen when creating an inlined instance, in
<span class="lineNum">   22216 </span>            :                  which case we need to create a new DIE that will get
<span class="lineNum">   22217 </span>            :                  annotated with DW_AT_abstract_origin.  */
<span class="lineNum">   22218 </span>            :               parm_die = NULL;
<span class="lineNum">   22219 </span>            :             }
<span class="lineNum">   22220 </span>            :           else
<span class="lineNum">   22221 </span><span class="lineNoCov">          0 :             gcc_unreachable ();</span>
<span class="lineNum">   22222 </span>            :         }
<span class="lineNum">   22223 </span>            : 
<span class="lineNum">   22224 </span><span class="lineCov">    8688714 :       if (parm_die &amp;&amp; parm_die-&gt;die_parent == NULL)</span>
<span class="lineNum">   22225 </span>            :         {
<span class="lineNum">   22226 </span>            :           /* Check that parm_die already has the right attributes that
<span class="lineNum">   22227 </span>            :              we would have added below.  If any attributes are
<span class="lineNum">   22228 </span>            :              missing, fall through to add them.  */
<span class="lineNum">   22229 </span><span class="lineNoCov">          0 :           if (! DECL_ABSTRACT_P (node_or_origin)</span>
<span class="lineNum">   22230 </span><span class="lineNoCov">          0 :               &amp;&amp; !get_AT (parm_die, DW_AT_location)</span>
<span class="lineNum">   22231 </span><span class="lineNoCov">          0 :               &amp;&amp; !get_AT (parm_die, DW_AT_const_value))</span>
<span class="lineNum">   22232 </span>            :             /* We are missing  location info, and are about to add it.  */
<span class="lineNum">   22233 </span>            :             ;
<span class="lineNum">   22234 </span>            :           else
<span class="lineNum">   22235 </span>            :             {
<span class="lineNum">   22236 </span><span class="lineNoCov">          0 :               add_child_die (context_die, parm_die);</span>
<span class="lineNum">   22237 </span><span class="lineNoCov">          0 :               return parm_die;</span>
<span class="lineNum">   22238 </span>            :             }
<span class="lineNum">   22239 </span>            :         }
<span class="lineNum">   22240 </span>            :     }
<span class="lineNum">   22241 </span>            : 
<span class="lineNum">   22242 </span>            :   /* If we have a previously generated DIE, use it, unless this is an
<span class="lineNum">   22243 </span>            :      concrete instance (origin != NULL), in which case we need a new
<span class="lineNum">   22244 </span>            :      DIE with a corresponding DW_AT_abstract_origin.  */
<span class="lineNum">   22245 </span><span class="lineCov">   21177523 :   bool reusing_die;</span>
<span class="lineNum">   22246 </span><span class="lineCov">   21177523 :   if (parm_die &amp;&amp; origin == NULL)</span>
<span class="lineNum">   22247 </span>            :     reusing_die = true;
<span class="lineNum">   22248 </span>            :   else
<span class="lineNum">   22249 </span>            :     {
<span class="lineNum">   22250 </span><span class="lineCov">   20588477 :       parm_die = new_die (DW_TAG_formal_parameter, context_die, node);</span>
<span class="lineNum">   22251 </span><span class="lineCov">   20588477 :       reusing_die = false;</span>
<span class="lineNum">   22252 </span>            :     }
<span class="lineNum">   22253 </span>            : 
<span class="lineNum">   22254 </span><span class="lineCov">   21177523 :   switch (TREE_CODE_CLASS (TREE_CODE (node_or_origin)))</span>
<span class="lineNum">   22255 </span>            :     {
<span class="lineNum">   22256 </span><span class="lineCov">    8751412 :     case tcc_declaration:</span>
<span class="lineNum">   22257 </span><span class="lineCov">    8751412 :       ultimate_origin = decl_ultimate_origin (node_or_origin);</span>
<span class="lineNum">   22258 </span><span class="lineCov">    8751412 :       if (node || ultimate_origin)</span>
<span class="lineNum">   22259 </span><span class="lineCov">    8751412 :         origin = ultimate_origin;</span>
<span class="lineNum">   22260 </span>            : 
<span class="lineNum">   22261 </span><span class="lineCov">    8751412 :       if (reusing_die)</span>
<span class="lineNum">   22262 </span>            :         goto add_location;
<span class="lineNum">   22263 </span>            : 
<span class="lineNum">   22264 </span><span class="lineCov">    8162366 :       if (origin != NULL)</span>
<span class="lineNum">   22265 </span><span class="lineCov">    6142587 :         add_abstract_origin_attribute (parm_die, origin);</span>
<span class="lineNum">   22266 </span><span class="lineCov">    2019779 :       else if (emit_name_p)</span>
<span class="lineNum">   22267 </span><span class="lineCov">    1993947 :         add_name_and_src_coords_attributes (parm_die, node);</span>
<span class="lineNum">   22268 </span><span class="lineCov">    8162366 :       if (origin == NULL</span>
<span class="lineNum">   22269 </span><span class="lineCov">    8162366 :           || (! DECL_ABSTRACT_P (node_or_origin)</span>
<span class="lineNum">   22270 </span><span class="lineCov">    6142587 :               &amp;&amp; variably_modified_type_p (TREE_TYPE (node_or_origin),</span>
<span class="lineNum">   22271 </span>            :                                            decl_function_context
<span class="lineNum">   22272 </span>            :                                                             (node_or_origin))))
<span class="lineNum">   22273 </span>            :         {
<span class="lineNum">   22274 </span><span class="lineCov">    2020833 :           tree type = TREE_TYPE (node_or_origin);</span>
<span class="lineNum">   22275 </span><span class="lineCov">    2020833 :           if (decl_by_reference_p (node_or_origin))</span>
<span class="lineNum">   22276 </span><span class="lineCov">      24068 :             add_type_attribute (parm_die, TREE_TYPE (type),</span>
<span class="lineNum">   22277 </span>            :                                 TYPE_UNQUALIFIED,
<span class="lineNum">   22278 </span>            :                                 false, context_die);
<span class="lineNum">   22279 </span>            :           else
<span class="lineNum">   22280 </span><span class="lineCov">    1996765 :             add_type_attribute (parm_die, type,</span>
<span class="lineNum">   22281 </span>            :                                 decl_quals (node_or_origin),
<span class="lineNum">   22282 </span>            :                                 false, context_die);
<span class="lineNum">   22283 </span>            :         }
<span class="lineNum">   22284 </span><span class="lineCov">    8162366 :       if (origin == NULL &amp;&amp; DECL_ARTIFICIAL (node))</span>
<span class="lineNum">   22285 </span><span class="lineCov">     596034 :         add_AT_flag (parm_die, DW_AT_artificial, 1);</span>
<span class="lineNum">   22286 </span><span class="lineCov">    8751412 :     add_location:</span>
<span class="lineNum">   22287 </span><span class="lineCov">    8751412 :       if (node &amp;&amp; node != origin)</span>
<span class="lineNum">   22288 </span><span class="lineCov">    8691804 :         equate_decl_number_to_die (node, parm_die);</span>
<span class="lineNum">   22289 </span><span class="lineCov">    8751412 :       if (! DECL_ABSTRACT_P (node_or_origin))</span>
<span class="lineNum">   22290 </span><span class="lineCov">    8751412 :         add_location_or_const_value_attribute (parm_die, node_or_origin,</span>
<span class="lineNum">   22291 </span>            :                                                node == NULL);
<span class="lineNum">   22292 </span>            : 
<span class="lineNum">   22293 </span>            :       break;
<span class="lineNum">   22294 </span>            : 
<span class="lineNum">   22295 </span><span class="lineCov">   12426111 :     case tcc_type:</span>
<span class="lineNum">   22296 </span>            :       /* We were called with some kind of a ..._TYPE node.  */
<span class="lineNum">   22297 </span><span class="lineCov">   12426111 :       add_type_attribute (parm_die, node_or_origin, TYPE_UNQUALIFIED, false,</span>
<span class="lineNum">   22298 </span>            :                           context_die);
<span class="lineNum">   22299 </span><span class="lineCov">   12426111 :       break;</span>
<span class="lineNum">   22300 </span>            : 
<span class="lineNum">   22301 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">   22302 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">   22303 </span>            :     }
<span class="lineNum">   22304 </span>            : 
<span class="lineNum">   22305 </span>            :   return parm_die;
<span class="lineNum">   22306 </span>            : }
<span class="lineNum">   22307 </span>            : 
<span class="lineNum">   22308 </span>            : /* Generate and return a DW_TAG_GNU_formal_parameter_pack. Also generate
<span class="lineNum">   22309 </span>            :    children DW_TAG_formal_parameter DIEs representing the arguments of the
<span class="lineNum">   22310 </span>            :    parameter pack.
<span class="lineNum">   22311 </span>            : 
<span class="lineNum">   22312 </span>            :    PARM_PACK must be a function parameter pack.
<span class="lineNum">   22313 </span>            :    PACK_ARG is the first argument of the parameter pack. Its TREE_CHAIN
<span class="lineNum">   22314 </span>            :    must point to the subsequent arguments of the function PACK_ARG belongs to.
<span class="lineNum">   22315 </span>            :    SUBR_DIE is the DIE of the function PACK_ARG belongs to.
<span class="lineNum">   22316 </span>            :    If NEXT_ARG is non NULL, *NEXT_ARG is set to the function argument
<span class="lineNum">   22317 </span>            :    following the last one for which a DIE was generated.  */
<a name="22318"><span class="lineNum">   22318 </span>            : </a>
<span class="lineNum">   22319 </span>            : static dw_die_ref
<span class="lineNum">   22320 </span><span class="lineCov">      23623 : gen_formal_parameter_pack_die  (tree parm_pack,</span>
<span class="lineNum">   22321 </span>            :                                 tree pack_arg,
<span class="lineNum">   22322 </span>            :                                 dw_die_ref subr_die,
<span class="lineNum">   22323 </span>            :                                 tree *next_arg)
<span class="lineNum">   22324 </span>            : {
<span class="lineNum">   22325 </span><span class="lineCov">      23623 :   tree arg;</span>
<span class="lineNum">   22326 </span><span class="lineCov">      23623 :   dw_die_ref parm_pack_die;</span>
<span class="lineNum">   22327 </span>            : 
<span class="lineNum">   22328 </span><span class="lineCov">      23623 :   gcc_assert (parm_pack</span>
<span class="lineNum">   22329 </span>            :               &amp;&amp; lang_hooks.function_parameter_pack_p (parm_pack)
<span class="lineNum">   22330 </span>            :               &amp;&amp; subr_die);
<span class="lineNum">   22331 </span>            : 
<span class="lineNum">   22332 </span><span class="lineCov">      23623 :   parm_pack_die = new_die (DW_TAG_GNU_formal_parameter_pack, subr_die, parm_pack);</span>
<span class="lineNum">   22333 </span><span class="lineCov">      23623 :   add_src_coords_attributes (parm_pack_die, parm_pack);</span>
<span class="lineNum">   22334 </span>            : 
<span class="lineNum">   22335 </span><span class="lineCov">      53462 :   for (arg = pack_arg; arg; arg = DECL_CHAIN (arg))</span>
<span class="lineNum">   22336 </span>            :     {
<span class="lineNum">   22337 </span><span class="lineCov">      29839 :       if (! lang_hooks.decls.function_parm_expanded_from_pack_p (arg,</span>
<span class="lineNum">   22338 </span>            :                                                                  parm_pack))
<span class="lineNum">   22339 </span>            :         break;
<span class="lineNum">   22340 </span><span class="lineCov">      29839 :       gen_formal_parameter_die (arg, NULL,</span>
<span class="lineNum">   22341 </span>            :                                 false /* Don't emit name attribute.  */,
<span class="lineNum">   22342 </span>            :                                 parm_pack_die);
<span class="lineNum">   22343 </span>            :     }
<span class="lineNum">   22344 </span><span class="lineCov">      23623 :   if (next_arg)</span>
<span class="lineNum">   22345 </span><span class="lineCov">      23623 :     *next_arg = arg;</span>
<span class="lineNum">   22346 </span><span class="lineCov">      23623 :   return parm_pack_die;</span>
<span class="lineNum">   22347 </span>            : }
<span class="lineNum">   22348 </span>            : 
<span class="lineNum">   22349 </span>            : /* Generate a special type of DIE used as a stand-in for a trailing ellipsis
<span class="lineNum">   22350 </span>            :    at the end of an (ANSI prototyped) formal parameters list.  */
<a name="22351"><span class="lineNum">   22351 </span>            : </a>
<span class="lineNum">   22352 </span>            : static void
<span class="lineNum">   22353 </span><span class="lineNoCov">          0 : gen_unspecified_parameters_die (tree decl_or_type, dw_die_ref context_die)</span>
<span class="lineNum">   22354 </span>            : {
<span class="lineNum">   22355 </span><span class="lineNoCov">          0 :   new_die (DW_TAG_unspecified_parameters, context_die, decl_or_type);</span>
<span class="lineNum">   22356 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   22357 </span>            : 
<span class="lineNum">   22358 </span>            : /* Generate a list of nameless DW_TAG_formal_parameter DIEs (and perhaps a
<span class="lineNum">   22359 </span>            :    DW_TAG_unspecified_parameters DIE) to represent the types of the formal
<span class="lineNum">   22360 </span>            :    parameters as specified in some function type specification (except for
<span class="lineNum">   22361 </span>            :    those which appear as part of a function *definition*).  */
<a name="22362"><span class="lineNum">   22362 </span>            : </a>
<span class="lineNum">   22363 </span>            : static void
<span class="lineNum">   22364 </span><span class="lineCov">    6458698 : gen_formal_types_die (tree function_or_method_type, dw_die_ref context_die)</span>
<span class="lineNum">   22365 </span>            : {
<span class="lineNum">   22366 </span><span class="lineCov">    6458698 :   tree link;</span>
<span class="lineNum">   22367 </span><span class="lineCov">    6458698 :   tree formal_type = NULL;</span>
<span class="lineNum">   22368 </span><span class="lineCov">    6458698 :   tree first_parm_type;</span>
<span class="lineNum">   22369 </span><span class="lineCov">    6458698 :   tree arg;</span>
<span class="lineNum">   22370 </span>            : 
<span class="lineNum">   22371 </span><span class="lineCov">    6458698 :   if (TREE_CODE (function_or_method_type) == FUNCTION_DECL)</span>
<span class="lineNum">   22372 </span>            :     {
<span class="lineNum">   22373 </span><span class="lineCov">    6352923 :       arg = DECL_ARGUMENTS (function_or_method_type);</span>
<span class="lineNum">   22374 </span><span class="lineCov">    6352923 :       function_or_method_type = TREE_TYPE (function_or_method_type);</span>
<span class="lineNum">   22375 </span>            :     }
<span class="lineNum">   22376 </span>            :   else
<span class="lineNum">   22377 </span>            :     arg = NULL_TREE;
<span class="lineNum">   22378 </span>            : 
<span class="lineNum">   22379 </span><span class="lineCov">    6458698 :   first_parm_type = TYPE_ARG_TYPES (function_or_method_type);</span>
<span class="lineNum">   22380 </span>            : 
<span class="lineNum">   22381 </span>            :   /* Make our first pass over the list of formal parameter types and output a
<span class="lineNum">   22382 </span>            :      DW_TAG_formal_parameter DIE for each one.  */
<span class="lineNum">   22383 </span><span class="lineCov">   18884809 :   for (link = first_parm_type; link; )</span>
<span class="lineNum">   22384 </span>            :     {
<span class="lineNum">   22385 </span><span class="lineCov">   18865763 :       dw_die_ref parm_die;</span>
<span class="lineNum">   22386 </span>            : 
<span class="lineNum">   22387 </span><span class="lineCov">   18865763 :       formal_type = TREE_VALUE (link);</span>
<span class="lineNum">   22388 </span><span class="lineCov">   18865763 :       if (formal_type == void_type_node)</span>
<span class="lineNum">   22389 </span>            :         break;
<span class="lineNum">   22390 </span>            : 
<span class="lineNum">   22391 </span>            :       /* Output a (nameless) DIE to represent the formal parameter itself.  */
<span class="lineNum">   22392 </span><span class="lineCov">   12426111 :       parm_die = gen_formal_parameter_die (formal_type, NULL,</span>
<span class="lineNum">   22393 </span>            :                                            true /* Emit name attribute.  */,
<span class="lineNum">   22394 </span>            :                                            context_die);
<span class="lineNum">   22395 </span><span class="lineCov">   12426111 :       if (TREE_CODE (function_or_method_type) == METHOD_TYPE</span>
<span class="lineNum">   22396 </span><span class="lineCov">   10356721 :           &amp;&amp; link == first_parm_type)</span>
<span class="lineNum">   22397 </span>            :         {
<span class="lineNum">   22398 </span><span class="lineCov">    5028796 :           add_AT_flag (parm_die, DW_AT_artificial, 1);</span>
<span class="lineNum">   22399 </span><span class="lineCov">    5028796 :           if (dwarf_version &gt;= 3 || !dwarf_strict)</span>
<span class="lineNum">   22400 </span><span class="lineCov">    5028796 :             add_AT_die_ref (context_die, DW_AT_object_pointer, parm_die);</span>
<span class="lineNum">   22401 </span>            :         }
<span class="lineNum">   22402 </span><span class="lineCov">    7397315 :       else if (arg &amp;&amp; DECL_ARTIFICIAL (arg))</span>
<span class="lineNum">   22403 </span><span class="lineCov">     286394 :         add_AT_flag (parm_die, DW_AT_artificial, 1);</span>
<span class="lineNum">   22404 </span>            : 
<span class="lineNum">   22405 </span><span class="lineCov">   12426111 :       link = TREE_CHAIN (link);</span>
<span class="lineNum">   22406 </span><span class="lineCov">   12426111 :       if (arg)</span>
<span class="lineNum">   22407 </span><span class="lineCov">   12260458 :         arg = DECL_CHAIN (arg);</span>
<span class="lineNum">   22408 </span>            :     }
<span class="lineNum">   22409 </span>            : 
<span class="lineNum">   22410 </span>            :   /* If this function type has an ellipsis, add a
<span class="lineNum">   22411 </span>            :      DW_TAG_unspecified_parameters DIE to the end of the parameter list.  */
<span class="lineNum">   22412 </span><span class="lineCov">    6458698 :   if (formal_type != void_type_node)</span>
<span class="lineNum">   22413 </span><span class="lineCov">      19046 :     gen_unspecified_parameters_die (function_or_method_type, context_die);</span>
<span class="lineNum">   22414 </span>            : 
<span class="lineNum">   22415 </span>            :   /* Make our second (and final) pass over the list of formal parameter types
<span class="lineNum">   22416 </span>            :      and output DIEs to represent those types (as necessary).  */
<span class="lineNum">   22417 </span><span class="lineCov">   11487494 :   for (link = TYPE_ARG_TYPES (function_or_method_type);</span>
<span class="lineNum">   22418 </span><span class="lineCov">   25324461 :        link &amp;&amp; TREE_VALUE (link);</span>
<span class="lineNum">   22419 </span><span class="lineCov">   18865763 :        link = TREE_CHAIN (link))</span>
<span class="lineNum">   22420 </span><span class="lineCov">   37731526 :     gen_type_die (TREE_VALUE (link), context_die);</span>
<span class="lineNum">   22421 </span><span class="lineCov">    6458698 : }</span>
<span class="lineNum">   22422 </span>            : 
<span class="lineNum">   22423 </span>            : /* We want to generate the DIE for TYPE so that we can generate the
<span class="lineNum">   22424 </span>            :    die for MEMBER, which has been defined; we will need to refer back
<span class="lineNum">   22425 </span>            :    to the member declaration nested within TYPE.  If we're trying to
<span class="lineNum">   22426 </span>            :    generate minimal debug info for TYPE, processing TYPE won't do the
<span class="lineNum">   22427 </span>            :    trick; we need to attach the member declaration by hand.  */
<a name="22428"><span class="lineNum">   22428 </span>            : </a>
<span class="lineNum">   22429 </span>            : static void
<span class="lineNum">   22430 </span><span class="lineCov">    7684442 : gen_type_die_for_member (tree type, tree member, dw_die_ref context_die)</span>
<span class="lineNum">   22431 </span>            : {
<span class="lineNum">   22432 </span><span class="lineCov">    7684442 :   gen_type_die (type, context_die);</span>
<span class="lineNum">   22433 </span>            : 
<span class="lineNum">   22434 </span>            :   /* If we're trying to avoid duplicate debug info, we may not have
<span class="lineNum">   22435 </span>            :      emitted the member decl for this function.  Emit it now.  */
<span class="lineNum">   22436 </span><span class="lineCov">    7684442 :   if (TYPE_STUB_DECL (type)</span>
<span class="lineNum">   22437 </span><span class="lineCov">   23053326 :       &amp;&amp; TYPE_DECL_SUPPRESS_DEBUG (TYPE_STUB_DECL (type))</span>
<span class="lineNum">   22438 </span><span class="lineCov">    7784073 :       &amp;&amp; ! lookup_decl_die (member))</span>
<span class="lineNum">   22439 </span>            :     {
<span class="lineNum">   22440 </span><span class="lineCov">      46325 :       dw_die_ref type_die;</span>
<span class="lineNum">   22441 </span><span class="lineCov">      46325 :       gcc_assert (!decl_ultimate_origin (member));</span>
<span class="lineNum">   22442 </span>            : 
<span class="lineNum">   22443 </span><span class="lineCov">      46325 :       type_die = lookup_type_die_strip_naming_typedef (type);</span>
<span class="lineNum">   22444 </span><span class="lineCov">      46325 :       if (TREE_CODE (member) == FUNCTION_DECL)</span>
<span class="lineNum">   22445 </span><span class="lineCov">      45921 :         gen_subprogram_die (member, type_die);</span>
<span class="lineNum">   22446 </span><span class="lineCov">        404 :       else if (TREE_CODE (member) == FIELD_DECL)</span>
<span class="lineNum">   22447 </span>            :         {
<span class="lineNum">   22448 </span>            :           /* Ignore the nameless fields that are used to skip bits but handle
<span class="lineNum">   22449 </span>            :              C++ anonymous unions and structs.  */
<span class="lineNum">   22450 </span><span class="lineCov">          6 :           if (DECL_NAME (member) != NULL_TREE</span>
<span class="lineNum">   22451 </span><span class="lineNoCov">          0 :               || TREE_CODE (TREE_TYPE (member)) == UNION_TYPE</span>
<span class="lineNum">   22452 </span><span class="lineCov">          6 :               || TREE_CODE (TREE_TYPE (member)) == RECORD_TYPE)</span>
<span class="lineNum">   22453 </span>            :             {
<span class="lineNum">   22454 </span><span class="lineCov">          6 :               struct vlr_context vlr_ctx = {</span>
<span class="lineNum">   22455 </span><span class="lineCov">          6 :                 DECL_CONTEXT (member), /* struct_type */</span>
<span class="lineNum">   22456 </span>            :                 NULL_TREE /* variant_part_offset */
<span class="lineNum">   22457 </span><span class="lineCov">          6 :               };</span>
<span class="lineNum">   22458 </span><span class="lineCov">          6 :               gen_type_die (member_declared_type (member), type_die);</span>
<span class="lineNum">   22459 </span><span class="lineCov">          6 :               gen_field_die (member, &amp;vlr_ctx, type_die);</span>
<span class="lineNum">   22460 </span>            :             }
<span class="lineNum">   22461 </span>            :         }
<span class="lineNum">   22462 </span>            :       else
<span class="lineNum">   22463 </span><span class="lineCov">        398 :         gen_variable_die (member, NULL_TREE, type_die);</span>
<span class="lineNum">   22464 </span>            :     }
<span class="lineNum">   22465 </span><span class="lineCov">    7684442 : }</span>
<span class="lineNum">   22466 </span>            : 
<span class="lineNum">   22467 </span>            : /* Forward declare these functions, because they are mutually recursive
<span class="lineNum">   22468 </span>            :   with their set_block_* pairing functions.  */
<span class="lineNum">   22469 </span>            : static void set_decl_origin_self (tree);
<span class="lineNum">   22470 </span>            : 
<span class="lineNum">   22471 </span>            : /* Given a pointer to some BLOCK node, if the BLOCK_ABSTRACT_ORIGIN for the
<span class="lineNum">   22472 </span>            :    given BLOCK node is NULL, set the BLOCK_ABSTRACT_ORIGIN for the node so
<span class="lineNum">   22473 </span>            :    that it points to the node itself, thus indicating that the node is its
<span class="lineNum">   22474 </span>            :    own (abstract) origin.  Additionally, if the BLOCK_ABSTRACT_ORIGIN for
<span class="lineNum">   22475 </span>            :    the given node is NULL, recursively descend the decl/block tree which
<span class="lineNum">   22476 </span>            :    it is the root of, and for each other ..._DECL or BLOCK node contained
<span class="lineNum">   22477 </span>            :    therein whose DECL_ABSTRACT_ORIGINs or BLOCK_ABSTRACT_ORIGINs are also
<span class="lineNum">   22478 </span>            :    still NULL, set *their* DECL_ABSTRACT_ORIGIN or BLOCK_ABSTRACT_ORIGIN
<span class="lineNum">   22479 </span>            :    values to point to themselves.  */
<a name="22480"><span class="lineNum">   22480 </span>            : </a>
<span class="lineNum">   22481 </span>            : static void
<span class="lineNum">   22482 </span><span class="lineCov">    1478602 : set_block_origin_self (tree stmt)</span>
<span class="lineNum">   22483 </span>            : {
<span class="lineNum">   22484 </span><span class="lineCov">    1478602 :   if (BLOCK_ABSTRACT_ORIGIN (stmt) == NULL_TREE)</span>
<span class="lineNum">   22485 </span>            :     {
<span class="lineNum">   22486 </span><span class="lineCov">    1014860 :       BLOCK_ABSTRACT_ORIGIN (stmt) = stmt;</span>
<span class="lineNum">   22487 </span>            : 
<span class="lineNum">   22488 </span><span class="lineCov">    1014860 :       {</span>
<span class="lineNum">   22489 </span><span class="lineCov">    1014860 :         tree local_decl;</span>
<span class="lineNum">   22490 </span>            : 
<span class="lineNum">   22491 </span><span class="lineCov">    2029720 :         for (local_decl = BLOCK_VARS (stmt);</span>
<span class="lineNum">   22492 </span><span class="lineCov">    1310160 :              local_decl != NULL_TREE;</span>
<span class="lineNum">   22493 </span><span class="lineCov">     295300 :              local_decl = DECL_CHAIN (local_decl))</span>
<span class="lineNum">   22494 </span>            :           /* Do not recurse on nested functions since the inlining status
<span class="lineNum">   22495 </span>            :              of parent and child can be different as per the DWARF spec.  */
<span class="lineNum">   22496 </span><span class="lineCov">     295300 :           if (TREE_CODE (local_decl) != FUNCTION_DECL</span>
<span class="lineNum">   22497 </span><span class="lineCov">     295300 :               &amp;&amp; !DECL_EXTERNAL (local_decl))</span>
<span class="lineNum">   22498 </span><span class="lineCov">     293501 :             set_decl_origin_self (local_decl);</span>
<span class="lineNum">   22499 </span>            :       }
<span class="lineNum">   22500 </span>            : 
<span class="lineNum">   22501 </span><span class="lineCov">    1014860 :       {</span>
<span class="lineNum">   22502 </span><span class="lineCov">    1014860 :         tree subblock;</span>
<span class="lineNum">   22503 </span>            : 
<span class="lineNum">   22504 </span><span class="lineCov">    1014860 :         for (subblock = BLOCK_SUBBLOCKS (stmt);</span>
<span class="lineNum">   22505 </span><span class="lineCov">    1727983 :              subblock != NULL_TREE;</span>
<span class="lineNum">   22506 </span><span class="lineCov">     713123 :              subblock = BLOCK_CHAIN (subblock))</span>
<span class="lineNum">   22507 </span><span class="lineCov">     713123 :           set_block_origin_self (subblock);     /* Recurse.  */</span>
<span class="lineNum">   22508 </span>            :       }
<span class="lineNum">   22509 </span>            :     }
<span class="lineNum">   22510 </span><span class="lineCov">    1478602 : }</span>
<span class="lineNum">   22511 </span>            : 
<span class="lineNum">   22512 </span>            : /* Given a pointer to some ..._DECL node, if the DECL_ABSTRACT_ORIGIN for
<span class="lineNum">   22513 </span>            :    the given ..._DECL node is NULL, set the DECL_ABSTRACT_ORIGIN for the
<span class="lineNum">   22514 </span>            :    node to so that it points to the node itself, thus indicating that the
<span class="lineNum">   22515 </span>            :    node represents its own (abstract) origin.  Additionally, if the
<span class="lineNum">   22516 </span>            :    DECL_ABSTRACT_ORIGIN for the given node is NULL, recursively descend
<span class="lineNum">   22517 </span>            :    the decl/block tree of which the given node is the root of, and for
<span class="lineNum">   22518 </span>            :    each other ..._DECL or BLOCK node contained therein whose
<span class="lineNum">   22519 </span>            :    DECL_ABSTRACT_ORIGINs or BLOCK_ABSTRACT_ORIGINs are also still NULL,
<span class="lineNum">   22520 </span>            :    set *their* DECL_ABSTRACT_ORIGIN or BLOCK_ABSTRACT_ORIGIN values to
<span class="lineNum">   22521 </span>            :    point to themselves.  */
<a name="22522"><span class="lineNum">   22522 </span>            : </a>
<span class="lineNum">   22523 </span>            : static void
<span class="lineNum">   22524 </span><span class="lineCov">    1058980 : set_decl_origin_self (tree decl)</span>
<span class="lineNum">   22525 </span>            : {
<span class="lineNum">   22526 </span><span class="lineCov">    1058980 :   if (DECL_ABSTRACT_ORIGIN (decl) == NULL_TREE)</span>
<span class="lineNum">   22527 </span>            :     {
<span class="lineNum">   22528 </span><span class="lineCov">    1058980 :       DECL_ABSTRACT_ORIGIN (decl) = decl;</span>
<span class="lineNum">   22529 </span><span class="lineCov">    1058980 :       if (TREE_CODE (decl) == FUNCTION_DECL)</span>
<span class="lineNum">   22530 </span>            :         {
<span class="lineNum">   22531 </span><span class="lineCov">     765479 :           tree arg;</span>
<span class="lineNum">   22532 </span>            : 
<span class="lineNum">   22533 </span><span class="lineCov">    2957410 :           for (arg = DECL_ARGUMENTS (decl); arg; arg = DECL_CHAIN (arg))</span>
<span class="lineNum">   22534 </span><span class="lineCov">    1426452 :             DECL_ABSTRACT_ORIGIN (arg) = arg;</span>
<span class="lineNum">   22535 </span><span class="lineCov">     765479 :           if (DECL_INITIAL (decl) != NULL_TREE</span>
<span class="lineNum">   22536 </span><span class="lineCov">     765479 :               &amp;&amp; DECL_INITIAL (decl) != error_mark_node)</span>
<span class="lineNum">   22537 </span><span class="lineCov">    1530958 :             set_block_origin_self (DECL_INITIAL (decl));</span>
<span class="lineNum">   22538 </span>            :         }
<span class="lineNum">   22539 </span>            :     }
<span class="lineNum">   22540 </span><span class="lineCov">    1058980 : }</span>
<span class="lineNum">   22541 </span>            : 
<span class="lineNum">   22542 </span>            : /* Mark the early DIE for DECL as the abstract instance.  */
<a name="22543"><span class="lineNum">   22543 </span>            : </a>
<span class="lineNum">   22544 </span>            : static void
<span class="lineNum">   22545 </span><span class="lineCov">    2323331 : dwarf2out_abstract_function (tree decl)</span>
<span class="lineNum">   22546 </span>            : {
<span class="lineNum">   22547 </span><span class="lineCov">    2323331 :   dw_die_ref old_die;</span>
<span class="lineNum">   22548 </span>            : 
<span class="lineNum">   22549 </span>            :   /* Make sure we have the actual abstract inline, not a clone.  */
<span class="lineNum">   22550 </span><span class="lineCov">    2323331 :   decl = DECL_ORIGIN (decl);</span>
<span class="lineNum">   22551 </span>            : 
<span class="lineNum">   22552 </span><span class="lineCov">    2323331 :   if (DECL_IGNORED_P (decl))</span>
<span class="lineNum">   22553 </span>            :     return;
<span class="lineNum">   22554 </span>            : 
<span class="lineNum">   22555 </span><span class="lineCov">    2323325 :   old_die = lookup_decl_die (decl);</span>
<span class="lineNum">   22556 </span>            :   /* With early debug we always have an old DIE unless we are in LTO
<span class="lineNum">   22557 </span>            :      and the user did not compile but only link with debug.  */
<span class="lineNum">   22558 </span><span class="lineCov">    2323325 :   if (in_lto_p &amp;&amp; ! old_die)</span>
<span class="lineNum">   22559 </span>            :     return;
<span class="lineNum">   22560 </span><span class="lineCov">    2323325 :   gcc_assert (old_die != NULL);</span>
<span class="lineNum">   22561 </span><span class="lineCov">    2323325 :   if (get_AT (old_die, DW_AT_inline)</span>
<span class="lineNum">   22562 </span><span class="lineCov">    2323325 :       || get_AT (old_die, DW_AT_abstract_origin))</span>
<span class="lineNum">   22563 </span>            :     /* We've already generated the abstract instance.  */
<span class="lineNum">   22564 </span>            :     return;
<span class="lineNum">   22565 </span>            : 
<span class="lineNum">   22566 </span>            :   /* Go ahead and put DW_AT_inline on the DIE.  */
<span class="lineNum">   22567 </span><span class="lineCov">     765479 :   if (DECL_DECLARED_INLINE_P (decl))</span>
<span class="lineNum">   22568 </span>            :     {
<span class="lineNum">   22569 </span><span class="lineCov">     683172 :       if (cgraph_function_possibly_inlined_p (decl))</span>
<span class="lineNum">   22570 </span><span class="lineCov">     495256 :         add_AT_unsigned (old_die, DW_AT_inline, DW_INL_declared_inlined);</span>
<span class="lineNum">   22571 </span>            :       else
<span class="lineNum">   22572 </span><span class="lineCov">     187916 :         add_AT_unsigned (old_die, DW_AT_inline, DW_INL_declared_not_inlined);</span>
<span class="lineNum">   22573 </span>            :     }
<span class="lineNum">   22574 </span>            :   else
<span class="lineNum">   22575 </span>            :     {
<span class="lineNum">   22576 </span><span class="lineCov">      82307 :       if (cgraph_function_possibly_inlined_p (decl))</span>
<span class="lineNum">   22577 </span><span class="lineCov">      75626 :         add_AT_unsigned (old_die, DW_AT_inline, DW_INL_inlined);</span>
<span class="lineNum">   22578 </span>            :       else
<span class="lineNum">   22579 </span><span class="lineCov">       6681 :         add_AT_unsigned (old_die, DW_AT_inline, DW_INL_not_inlined);</span>
<span class="lineNum">   22580 </span>            :     }
<span class="lineNum">   22581 </span>            : 
<span class="lineNum">   22582 </span><span class="lineCov">     765479 :   if (DECL_DECLARED_INLINE_P (decl)</span>
<span class="lineNum">   22583 </span><span class="lineCov">     765479 :       &amp;&amp; lookup_attribute (&quot;artificial&quot;, DECL_ATTRIBUTES (decl)))</span>
<span class="lineNum">   22584 </span><span class="lineCov">        328 :     add_AT_flag (old_die, DW_AT_artificial, 1);</span>
<span class="lineNum">   22585 </span>            : 
<span class="lineNum">   22586 </span><span class="lineCov">     765479 :   set_decl_origin_self (decl);</span>
<span class="lineNum">   22587 </span>            : }
<span class="lineNum">   22588 </span>            : 
<span class="lineNum">   22589 </span>            : /* Helper function of premark_used_types() which gets called through
<span class="lineNum">   22590 </span>            :    htab_traverse.
<span class="lineNum">   22591 </span>            : 
<span class="lineNum">   22592 </span>            :    Marks the DIE of a given type in *SLOT as perennial, so it never gets
<span class="lineNum">   22593 </span>            :    marked as unused by prune_unused_types.  */
<a name="22594"><span class="lineNum">   22594 </span>            : </a>
<span class="lineNum">   22595 </span>            : bool
<span class="lineNum">   22596 </span><span class="lineCov">     604114 : premark_used_types_helper (tree const &amp;type, void *)</span>
<span class="lineNum">   22597 </span>            : {
<span class="lineNum">   22598 </span><span class="lineCov">     604114 :   dw_die_ref die;</span>
<span class="lineNum">   22599 </span>            : 
<span class="lineNum">   22600 </span><span class="lineCov">     604114 :   die = lookup_type_die (type);</span>
<span class="lineNum">   22601 </span><span class="lineCov">     604114 :   if (die != NULL)</span>
<span class="lineNum">   22602 </span><span class="lineCov">     536400 :     die-&gt;die_perennial_p = 1;</span>
<span class="lineNum">   22603 </span><span class="lineCov">     604114 :   return true;</span>
<span class="lineNum">   22604 </span>            : }
<span class="lineNum">   22605 </span>            : 
<span class="lineNum">   22606 </span>            : /* Helper function of premark_types_used_by_global_vars which gets called
<span class="lineNum">   22607 </span>            :    through htab_traverse.
<span class="lineNum">   22608 </span>            : 
<span class="lineNum">   22609 </span>            :    Marks the DIE of a given type in *SLOT as perennial, so it never gets
<span class="lineNum">   22610 </span>            :    marked as unused by prune_unused_types. The DIE of the type is marked
<span class="lineNum">   22611 </span>            :    only if the global variable using the type will actually be emitted.  */
<a name="22612"><span class="lineNum">   22612 </span>            : </a>
<span class="lineNum">   22613 </span>            : int
<span class="lineNum">   22614 </span><span class="lineCov">    1933424 : premark_types_used_by_global_vars_helper (types_used_by_vars_entry **slot,</span>
<span class="lineNum">   22615 </span>            :                                           void *)
<span class="lineNum">   22616 </span>            : {
<span class="lineNum">   22617 </span><span class="lineCov">    1933424 :   struct types_used_by_vars_entry *entry;</span>
<span class="lineNum">   22618 </span><span class="lineCov">    1933424 :   dw_die_ref die;</span>
<span class="lineNum">   22619 </span>            : 
<span class="lineNum">   22620 </span><span class="lineCov">    1933424 :   entry = (struct types_used_by_vars_entry *) *slot;</span>
<span class="lineNum">   22621 </span><span class="lineCov">    1933424 :   gcc_assert (entry-&gt;type != NULL</span>
<span class="lineNum">   22622 </span>            :               &amp;&amp; entry-&gt;var_decl != NULL);
<span class="lineNum">   22623 </span><span class="lineCov">    1933424 :   die = lookup_type_die (entry-&gt;type);</span>
<span class="lineNum">   22624 </span><span class="lineCov">    1933424 :   if (die)</span>
<span class="lineNum">   22625 </span>            :     {
<span class="lineNum">   22626 </span>            :       /* Ask cgraph if the global variable really is to be emitted.
<span class="lineNum">   22627 </span>            :          If yes, then we'll keep the DIE of ENTRY-&gt;TYPE.  */
<span class="lineNum">   22628 </span><span class="lineCov">    1899736 :       varpool_node *node = varpool_node::get (entry-&gt;var_decl);</span>
<span class="lineNum">   22629 </span><span class="lineCov">    1899736 :       if (node &amp;&amp; node-&gt;definition)</span>
<span class="lineNum">   22630 </span>            :         {
<span class="lineNum">   22631 </span><span class="lineCov">      13683 :           die-&gt;die_perennial_p = 1;</span>
<span class="lineNum">   22632 </span>            :           /* Keep the parent DIEs as well.  */
<span class="lineNum">   22633 </span><span class="lineCov">      22294 :           while ((die = die-&gt;die_parent) &amp;&amp; die-&gt;die_perennial_p == 0)</span>
<span class="lineNum">   22634 </span><span class="lineCov">       8611 :             die-&gt;die_perennial_p = 1;</span>
<span class="lineNum">   22635 </span>            :         }
<span class="lineNum">   22636 </span>            :     }
<span class="lineNum">   22637 </span><span class="lineCov">    1933424 :   return 1;</span>
<span class="lineNum">   22638 </span>            : }
<span class="lineNum">   22639 </span>            : 
<span class="lineNum">   22640 </span>            : /* Mark all members of used_types_hash as perennial.  */
<a name="22641"><span class="lineNum">   22641 </span>            : </a>
<span class="lineNum">   22642 </span>            : static void
<span class="lineNum">   22643 </span><span class="lineNoCov">          0 : premark_used_types (struct function *fun)</span>
<span class="lineNum">   22644 </span>            : {
<span class="lineNum">   22645 </span><span class="lineCov">    2123945 :   if (fun &amp;&amp; fun-&gt;used_types_hash)</span>
<span class="lineNum">   22646 </span><span class="lineCov">     425230 :     fun-&gt;used_types_hash-&gt;traverse&lt;void *, premark_used_types_helper&gt; (NULL);</span>
<span class="lineNum">   22647 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   22648 </span>            : 
<span class="lineNum">   22649 </span>            : /* Mark all members of types_used_by_vars_entry as perennial.  */
<a name="22650"><span class="lineNum">   22650 </span>            : </a>
<span class="lineNum">   22651 </span>            : static void
<span class="lineNum">   22652 </span><span class="lineNoCov">          0 : premark_types_used_by_global_vars (void)</span>
<span class="lineNum">   22653 </span>            : {
<span class="lineNum">   22654 </span><span class="lineNoCov">          0 :   if (types_used_by_vars_hash)</span>
<span class="lineNum">   22655 </span><span class="lineCov">       9309 :     types_used_by_vars_hash</span>
<span class="lineNum">   22656 </span><span class="lineCov">       9309 :       -&gt;traverse&lt;void *, premark_types_used_by_global_vars_helper&gt; (NULL);</span>
<span class="lineNum">   22657 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   22658 </span>            : 
<span class="lineNum">   22659 </span>            : /* Generate a DW_TAG_call_site DIE in function DECL under SUBR_DIE
<span class="lineNum">   22660 </span>            :    for CA_LOC call arg loc node.  */
<a name="22661"><span class="lineNum">   22661 </span>            : </a>
<span class="lineNum">   22662 </span>            : static dw_die_ref
<span class="lineNum">   22663 </span><span class="lineCov">    1914914 : gen_call_site_die (tree decl, dw_die_ref subr_die,</span>
<span class="lineNum">   22664 </span>            :                    struct call_arg_loc_node *ca_loc)
<span class="lineNum">   22665 </span>            : {
<span class="lineNum">   22666 </span><span class="lineCov">    1914914 :   dw_die_ref stmt_die = NULL, die;</span>
<span class="lineNum">   22667 </span><span class="lineCov">    1914914 :   tree block = ca_loc-&gt;block;</span>
<span class="lineNum">   22668 </span>            : 
<span class="lineNum">   22669 </span><span class="lineCov">    5152396 :   while (block</span>
<span class="lineNum">   22670 </span><span class="lineCov">    3495077 :          &amp;&amp; block != DECL_INITIAL (decl)</span>
<span class="lineNum">   22671 </span><span class="lineCov">    6330145 :          &amp;&amp; TREE_CODE (block) == BLOCK)</span>
<span class="lineNum">   22672 </span>            :     {
<span class="lineNum">   22673 </span><span class="lineCov">    2796490 :       stmt_die = BLOCK_DIE (block);</span>
<span class="lineNum">   22674 </span><span class="lineCov">    2796490 :       if (stmt_die)</span>
<span class="lineNum">   22675 </span>            :         break;
<span class="lineNum">   22676 </span><span class="lineCov">    3237482 :       block = BLOCK_SUPERCONTEXT (block);</span>
<span class="lineNum">   22677 </span>            :     }
<span class="lineNum">   22678 </span><span class="lineCov">    1914914 :   if (stmt_die == NULL)</span>
<span class="lineNum">   22679 </span><span class="lineCov">     737165 :     stmt_die = subr_die;</span>
<span class="lineNum">   22680 </span><span class="lineCov">    3829825 :   die = new_die (dwarf_TAG (DW_TAG_call_site), stmt_die, NULL_TREE);</span>
<span class="lineNum">   22681 </span><span class="lineCov">    3829825 :   add_AT_lbl_id (die, dwarf_AT (DW_AT_call_return_pc), ca_loc-&gt;label);</span>
<span class="lineNum">   22682 </span><span class="lineCov">    1914914 :   if (ca_loc-&gt;tail_call_p)</span>
<span class="lineNum">   22683 </span><span class="lineCov">      67482 :     add_AT_flag (die, dwarf_AT (DW_AT_call_tail_call), 1);</span>
<span class="lineNum">   22684 </span><span class="lineCov">    1914914 :   if (ca_loc-&gt;symbol_ref)</span>
<span class="lineNum">   22685 </span>            :     {
<span class="lineNum">   22686 </span><span class="lineCov">    1865447 :       dw_die_ref tdie = lookup_decl_die (SYMBOL_REF_DECL (ca_loc-&gt;symbol_ref));</span>
<span class="lineNum">   22687 </span><span class="lineCov">    1865447 :       if (tdie)</span>
<span class="lineNum">   22688 </span><span class="lineCov">     904850 :         add_AT_die_ref (die, dwarf_AT (DW_AT_call_origin), tdie);</span>
<span class="lineNum">   22689 </span>            :       else
<span class="lineNum">   22690 </span><span class="lineCov">    2826041 :         add_AT_addr (die, dwarf_AT (DW_AT_call_origin), ca_loc-&gt;symbol_ref,</span>
<span class="lineNum">   22691 </span>            :                      false);
<span class="lineNum">   22692 </span>            :     }
<span class="lineNum">   22693 </span><span class="lineCov">    1914914 :   return die;</span>
<span class="lineNum">   22694 </span>            : }
<span class="lineNum">   22695 </span>            : 
<span class="lineNum">   22696 </span>            : /* Generate a DIE to represent a declared function (either file-scope or
<span class="lineNum">   22697 </span>            :    block-local).  */
<a name="22698"><span class="lineNum">   22698 </span>            : </a>
<span class="lineNum">   22699 </span>            : static void
<span class="lineNum">   22700 </span><span class="lineCov">    7967742 : gen_subprogram_die (tree decl, dw_die_ref context_die)</span>
<span class="lineNum">   22701 </span>            : {
<span class="lineNum">   22702 </span><span class="lineCov">    7967742 :   tree origin = decl_ultimate_origin (decl);</span>
<span class="lineNum">   22703 </span><span class="lineCov">    7967742 :   dw_die_ref subr_die;</span>
<span class="lineNum">   22704 </span><span class="lineCov">    7967742 :   dw_die_ref old_die = lookup_decl_die (decl);</span>
<span class="lineNum">   22705 </span>            : 
<span class="lineNum">   22706 </span>            :   /* This function gets called multiple times for different stages of
<span class="lineNum">   22707 </span>            :      the debug process.  For example, for func() in this code:
<span class="lineNum">   22708 </span>            : 
<span class="lineNum">   22709 </span>            :         namespace S
<span class="lineNum">   22710 </span>            :         {
<span class="lineNum">   22711 </span>            :           void func() { ... }
<span class="lineNum">   22712 </span>            :         }
<span class="lineNum">   22713 </span>            : 
<span class="lineNum">   22714 </span>            :      ...we get called 4 times.  Twice in early debug and twice in
<span class="lineNum">   22715 </span>            :      late debug:
<span class="lineNum">   22716 </span>            : 
<span class="lineNum">   22717 </span>            :      Early debug
<span class="lineNum">   22718 </span>            :      -----------
<span class="lineNum">   22719 </span>            : 
<span class="lineNum">   22720 </span>            :        1. Once while generating func() within the namespace.  This is
<span class="lineNum">   22721 </span>            :           the declaration.  The declaration bit below is set, as the
<span class="lineNum">   22722 </span>            :           context is the namespace.
<span class="lineNum">   22723 </span>            : 
<span class="lineNum">   22724 </span>            :           A new DIE will be generated with DW_AT_declaration set.
<span class="lineNum">   22725 </span>            : 
<span class="lineNum">   22726 </span>            :        2. Once for func() itself.  This is the specification.  The
<span class="lineNum">   22727 </span>            :           declaration bit below is clear as the context is the CU.
<span class="lineNum">   22728 </span>            : 
<span class="lineNum">   22729 </span>            :           We will use the cached DIE from (1) to create a new DIE with
<span class="lineNum">   22730 </span>            :           DW_AT_specification pointing to the declaration in (1).
<span class="lineNum">   22731 </span>            : 
<span class="lineNum">   22732 </span>            :      Late debug via rest_of_handle_final()
<span class="lineNum">   22733 </span>            :      -------------------------------------
<span class="lineNum">   22734 </span>            : 
<span class="lineNum">   22735 </span>            :        3. Once generating func() within the namespace.  This is also the
<span class="lineNum">   22736 </span>            :           declaration, as in (1), but this time we will early exit below
<span class="lineNum">   22737 </span>            :           as we have a cached DIE and a declaration needs no additional
<span class="lineNum">   22738 </span>            :           annotations (no locations), as the source declaration line
<span class="lineNum">   22739 </span>            :           info is enough.
<span class="lineNum">   22740 </span>            : 
<span class="lineNum">   22741 </span>            :        4. Once for func() itself.  As in (2), this is the specification,
<span class="lineNum">   22742 </span>            :           but this time we will re-use the cached DIE, and just annotate
<span class="lineNum">   22743 </span>            :           it with the location information that should now be available.
<span class="lineNum">   22744 </span>            : 
<span class="lineNum">   22745 </span>            :      For something without namespaces, but with abstract instances, we
<span class="lineNum">   22746 </span>            :      are also called a multiple times:
<span class="lineNum">   22747 </span>            : 
<span class="lineNum">   22748 </span>            :         class Base
<span class="lineNum">   22749 </span>            :         {
<span class="lineNum">   22750 </span>            :         public:
<span class="lineNum">   22751 </span>            :           Base ();        // constructor declaration (1)
<span class="lineNum">   22752 </span>            :         };
<span class="lineNum">   22753 </span>            : 
<span class="lineNum">   22754 </span>            :         Base::Base () { } // constructor specification (2)
<span class="lineNum">   22755 </span>            : 
<span class="lineNum">   22756 </span>            :     Early debug
<span class="lineNum">   22757 </span>            :     -----------
<span class="lineNum">   22758 </span>            : 
<span class="lineNum">   22759 </span>            :        1. Once for the Base() constructor by virtue of it being a
<span class="lineNum">   22760 </span>            :           member of the Base class.  This is done via
<span class="lineNum">   22761 </span>            :           rest_of_type_compilation.
<span class="lineNum">   22762 </span>            : 
<span class="lineNum">   22763 </span>            :           This is a declaration, so a new DIE will be created with
<span class="lineNum">   22764 </span>            :           DW_AT_declaration.
<span class="lineNum">   22765 </span>            : 
<span class="lineNum">   22766 </span>            :        2. Once for the Base() constructor definition, but this time
<span class="lineNum">   22767 </span>            :           while generating the abstract instance of the base
<span class="lineNum">   22768 </span>            :           constructor (__base_ctor) which is being generated via early
<span class="lineNum">   22769 </span>            :           debug of reachable functions.
<span class="lineNum">   22770 </span>            : 
<span class="lineNum">   22771 </span>            :           Even though we have a cached version of the declaration (1),
<span class="lineNum">   22772 </span>            :           we will create a DW_AT_specification of the declaration DIE
<span class="lineNum">   22773 </span>            :           in (1).
<span class="lineNum">   22774 </span>            : 
<span class="lineNum">   22775 </span>            :        3. Once for the __base_ctor itself, but this time, we generate
<span class="lineNum">   22776 </span>            :           an DW_AT_abstract_origin version of the DW_AT_specification in
<span class="lineNum">   22777 </span>            :           (2).
<span class="lineNum">   22778 </span>            : 
<span class="lineNum">   22779 </span>            :     Late debug via rest_of_handle_final
<span class="lineNum">   22780 </span>            :     -----------------------------------
<span class="lineNum">   22781 </span>            : 
<span class="lineNum">   22782 </span>            :        4. One final time for the __base_ctor (which will have a cached
<span class="lineNum">   22783 </span>            :           DIE with DW_AT_abstract_origin created in (3).  This time,
<span class="lineNum">   22784 </span>            :           we will just annotate the location information now
<span class="lineNum">   22785 </span>            :           available.
<span class="lineNum">   22786 </span>            :   */
<span class="lineNum">   22787 </span><span class="lineCov">    7967742 :   int declaration = (current_function_decl != decl</span>
<span class="lineNum">   22788 </span><span class="lineCov">    7967742 :                      || class_or_namespace_scope_p (context_die));</span>
<span class="lineNum">   22789 </span>            : 
<span class="lineNum">   22790 </span>            :   /* A declaration that has been previously dumped needs no
<span class="lineNum">   22791 </span>            :      additional information.  */
<span class="lineNum">   22792 </span><span class="lineCov">    7967742 :   if (old_die &amp;&amp; declaration)</span>
<span class="lineNum">   22793 </span>            :     return;
<span class="lineNum">   22794 </span>            : 
<span class="lineNum">   22795 </span>            :   /* Now that the C++ front end lazily declares artificial member fns, we
<span class="lineNum">   22796 </span>            :      might need to retrofit the declaration into its class.  */
<span class="lineNum">   22797 </span><span class="lineCov">    1341631 :   if (!declaration &amp;&amp; !origin &amp;&amp; !old_die</span>
<span class="lineNum">   22798 </span><span class="lineCov">     375635 :       &amp;&amp; DECL_CONTEXT (decl) &amp;&amp; TYPE_P (DECL_CONTEXT (decl))</span>
<span class="lineNum">   22799 </span><span class="lineCov">      98489 :       &amp;&amp; !class_or_namespace_scope_p (context_die)</span>
<span class="lineNum">   22800 </span><span class="lineCov">    8060217 :       &amp;&amp; debug_info_level &gt; DINFO_LEVEL_TERSE)</span>
<span class="lineNum">   22801 </span><span class="lineCov">      98333 :     old_die = force_decl_die (decl);</span>
<span class="lineNum">   22802 </span>            : 
<span class="lineNum">   22803 </span>            :   /* A concrete instance, tag a new DIE with DW_AT_abstract_origin.  */
<span class="lineNum">   22804 </span><span class="lineCov">    7961728 :   if (origin != NULL)</span>
<span class="lineNum">   22805 </span>            :     {
<span class="lineNum">   22806 </span><span class="lineCov">     267174 :       gcc_assert (!declaration || local_scope_p (context_die));</span>
<span class="lineNum">   22807 </span>            : 
<span class="lineNum">   22808 </span>            :       /* Fixup die_parent for the abstract instance of a nested
<span class="lineNum">   22809 </span>            :          inline function.  */
<span class="lineNum">   22810 </span><span class="lineCov">     267174 :       if (old_die &amp;&amp; old_die-&gt;die_parent == NULL)</span>
<span class="lineNum">   22811 </span><span class="lineNoCov">          0 :         add_child_die (context_die, old_die);</span>
<span class="lineNum">   22812 </span>            : 
<span class="lineNum">   22813 </span><span class="lineCov">     267174 :       if (old_die &amp;&amp; get_AT_ref (old_die, DW_AT_abstract_origin))</span>
<span class="lineNum">   22814 </span>            :         {
<span class="lineNum">   22815 </span>            :           /* If we have a DW_AT_abstract_origin we have a working
<span class="lineNum">   22816 </span>            :              cached version.  */
<span class="lineNum">   22817 </span>            :           subr_die = old_die;
<span class="lineNum">   22818 </span>            :         }
<span class="lineNum">   22819 </span>            :       else
<span class="lineNum">   22820 </span>            :         {
<span class="lineNum">   22821 </span><span class="lineCov">     246577 :           subr_die = new_die (DW_TAG_subprogram, context_die, decl);</span>
<span class="lineNum">   22822 </span><span class="lineCov">     246577 :           add_abstract_origin_attribute (subr_die, origin);</span>
<span class="lineNum">   22823 </span>            :           /*  This is where the actual code for a cloned function is.
<span class="lineNum">   22824 </span>            :               Let's emit linkage name attribute for it.  This helps
<span class="lineNum">   22825 </span>            :               debuggers to e.g, set breakpoints into
<span class="lineNum">   22826 </span>            :               constructors/destructors when the user asks &quot;break
<span class="lineNum">   22827 </span>            :               K::K&quot;.  */
<span class="lineNum">   22828 </span><span class="lineCov">     246577 :           add_linkage_name (subr_die, decl);</span>
<span class="lineNum">   22829 </span>            :         }
<span class="lineNum">   22830 </span>            :     }
<span class="lineNum">   22831 </span>            :   /* A cached copy, possibly from early dwarf generation.  Reuse as
<span class="lineNum">   22832 </span>            :      much as possible.  */
<span class="lineNum">   22833 </span><span class="lineCov">    7694554 :   else if (old_die)</span>
<span class="lineNum">   22834 </span>            :     {
<span class="lineNum">   22835 </span><span class="lineCov">    1064329 :       if (!get_AT_flag (old_die, DW_AT_declaration)</span>
<span class="lineNum">   22836 </span>            :           /* We can have a normal definition following an inline one in the
<span class="lineNum">   22837 </span>            :              case of redefinition of GNU C extern inlines.
<span class="lineNum">   22838 </span>            :              It seems reasonable to use AT_specification in this case.  */
<span class="lineNum">   22839 </span><span class="lineCov">    1064329 :           &amp;&amp; !get_AT (old_die, DW_AT_inline))</span>
<span class="lineNum">   22840 </span>            :         {
<span class="lineNum">   22841 </span>            :           /* Detect and ignore this case, where we are trying to output
<span class="lineNum">   22842 </span>            :              something we have already output.  */
<span class="lineNum">   22843 </span><span class="lineCov">     219359 :           if (get_AT (old_die, DW_AT_low_pc)</span>
<span class="lineNum">   22844 </span><span class="lineCov">     219359 :               || get_AT (old_die, DW_AT_ranges))</span>
<span class="lineNum">   22845 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">   22846 </span>            : 
<span class="lineNum">   22847 </span>            :           /* If we have no location information, this must be a
<span class="lineNum">   22848 </span>            :              partially generated DIE from early dwarf generation.
<span class="lineNum">   22849 </span>            :              Fall through and generate it.  */
<span class="lineNum">   22850 </span>            :         }
<span class="lineNum">   22851 </span>            : 
<span class="lineNum">   22852 </span>            :       /* If the definition comes from the same place as the declaration,
<span class="lineNum">   22853 </span>            :          maybe use the old DIE.  We always want the DIE for this function
<span class="lineNum">   22854 </span>            :          that has the *_pc attributes to be under comp_unit_die so the
<span class="lineNum">   22855 </span>            :          debugger can find it.  We also need to do this for abstract
<span class="lineNum">   22856 </span>            :          instances of inlines, since the spec requires the out-of-line copy
<span class="lineNum">   22857 </span>            :          to have the same parent.  For local class methods, this doesn't
<span class="lineNum">   22858 </span>            :          apply; we just use the old DIE.  */
<span class="lineNum">   22859 </span><span class="lineCov">    1064329 :       expanded_location s = expand_location (DECL_SOURCE_LOCATION (decl));</span>
<span class="lineNum">   22860 </span><span class="lineCov">    1064329 :       struct dwarf_file_data * file_index = lookup_filename (s.file);</span>
<span class="lineNum">   22861 </span><span class="lineCov">    1064329 :       if (((is_unit_die (old_die-&gt;die_parent)</span>
<span class="lineNum">   22862 </span>            :             /* This condition fixes the inconsistency/ICE with the
<span class="lineNum">   22863 </span>            :                following Fortran test (or some derivative thereof) while
<span class="lineNum">   22864 </span>            :                building libgfortran:
<span class="lineNum">   22865 </span>            : 
<span class="lineNum">   22866 </span>            :                   module some_m
<span class="lineNum">   22867 </span>            :                   contains
<span class="lineNum">   22868 </span>            :                      logical function funky (FLAG)
<span class="lineNum">   22869 </span>            :                        funky = .true.
<span class="lineNum">   22870 </span>            :                     end function
<span class="lineNum">   22871 </span>            :                   end module
<span class="lineNum">   22872 </span>            :              */
<span class="lineNum">   22873 </span><span class="lineCov">     791095 :             || (old_die-&gt;die_parent</span>
<span class="lineNum">   22874 </span><span class="lineCov">     791095 :                 &amp;&amp; old_die-&gt;die_parent-&gt;die_tag == DW_TAG_module)</span>
<span class="lineNum">   22875 </span><span class="lineCov">     789589 :             || local_scope_p (old_die-&gt;die_parent)</span>
<span class="lineNum">   22876 </span><span class="lineCov">     783422 :             || context_die == NULL)</span>
<span class="lineNum">   22877 </span><span class="lineCov">     280907 :            &amp;&amp; (DECL_ARTIFICIAL (decl)</span>
<span class="lineNum">   22878 </span><span class="lineCov">     268843 :                || (get_AT_file (old_die, DW_AT_decl_file) == file_index</span>
<span class="lineNum">   22879 </span><span class="lineCov">     267586 :                    &amp;&amp; (get_AT_unsigned (old_die, DW_AT_decl_line)</span>
<span class="lineNum">   22880 </span><span class="lineCov">     267586 :                        == (unsigned) s.line)</span>
<span class="lineNum">   22881 </span><span class="lineCov">     267585 :                    &amp;&amp; (!debug_column_info</span>
<span class="lineNum">   22882 </span><span class="lineCov">     267581 :                        || s.column == 0</span>
<span class="lineNum">   22883 </span><span class="lineCov">     224321 :                        || (get_AT_unsigned (old_die, DW_AT_decl_column)</span>
<span class="lineNum">   22884 </span><span class="lineCov">     505228 :                            == (unsigned) s.column)))))</span>
<span class="lineNum">   22885 </span>            :           /* With LTO if there's an abstract instance for
<span class="lineNum">   22886 </span>            :              the old DIE, this is a concrete instance and
<span class="lineNum">   22887 </span>            :              thus re-use the DIE.  */
<span class="lineNum">   22888 </span><span class="lineCov">     784680 :           || get_AT (old_die, DW_AT_abstract_origin))</span>
<span class="lineNum">   22889 </span>            :         {
<span class="lineNum">   22890 </span><span class="lineCov">     283868 :           subr_die = old_die;</span>
<span class="lineNum">   22891 </span>            : 
<span class="lineNum">   22892 </span>            :           /* Clear out the declaration attribute, but leave the
<span class="lineNum">   22893 </span>            :              parameters so they can be augmented with location
<span class="lineNum">   22894 </span>            :              information later.  Unless this was a declaration, in
<span class="lineNum">   22895 </span>            :              which case, wipe out the nameless parameters and recreate
<span class="lineNum">   22896 </span>            :              them further down.  */
<span class="lineNum">   22897 </span><span class="lineCov">     283868 :           if (remove_AT (subr_die, DW_AT_declaration))</span>
<span class="lineNum">   22898 </span>            :             {
<span class="lineNum">   22899 </span>            : 
<span class="lineNum">   22900 </span><span class="lineCov">       6252 :               remove_AT (subr_die, DW_AT_object_pointer);</span>
<span class="lineNum">   22901 </span><span class="lineCov">       6252 :               remove_child_TAG (subr_die, DW_TAG_formal_parameter);</span>
<span class="lineNum">   22902 </span>            :             }
<span class="lineNum">   22903 </span>            :         }
<span class="lineNum">   22904 </span>            :       /* Make a specification pointing to the previously built
<span class="lineNum">   22905 </span>            :          declaration.  */
<span class="lineNum">   22906 </span>            :       else
<span class="lineNum">   22907 </span>            :         {
<span class="lineNum">   22908 </span><span class="lineCov">     780461 :           subr_die = new_die (DW_TAG_subprogram, context_die, decl);</span>
<span class="lineNum">   22909 </span><span class="lineCov">     780461 :           add_AT_specification (subr_die, old_die);</span>
<span class="lineNum">   22910 </span><span class="lineCov">     780461 :           add_pubname (decl, subr_die);</span>
<span class="lineNum">   22911 </span><span class="lineCov">     780461 :           if (get_AT_file (old_die, DW_AT_decl_file) != file_index)</span>
<span class="lineNum">   22912 </span><span class="lineCov">      26559 :             add_AT_file (subr_die, DW_AT_decl_file, file_index);</span>
<span class="lineNum">   22913 </span><span class="lineCov">     780461 :           if (get_AT_unsigned (old_die, DW_AT_decl_line) != (unsigned) s.line)</span>
<span class="lineNum">   22914 </span><span class="lineCov">      29976 :             add_AT_unsigned (subr_die, DW_AT_decl_line, s.line);</span>
<span class="lineNum">   22915 </span><span class="lineCov">     780461 :           if (debug_column_info</span>
<span class="lineNum">   22916 </span><span class="lineCov">     780449 :               &amp;&amp; s.column</span>
<span class="lineNum">   22917 </span><span class="lineCov">    1560909 :               &amp;&amp; (get_AT_unsigned (old_die, DW_AT_decl_column)</span>
<span class="lineNum">   22918 </span><span class="lineCov">     780448 :                   != (unsigned) s.column))</span>
<span class="lineNum">   22919 </span><span class="lineCov">      29952 :             add_AT_unsigned (subr_die, DW_AT_decl_column, s.column);</span>
<span class="lineNum">   22920 </span>            : 
<span class="lineNum">   22921 </span>            :           /* If the prototype had an 'auto' or 'decltype(auto)' return type,
<span class="lineNum">   22922 </span>            :              emit the real type on the definition die.  */
<span class="lineNum">   22923 </span><span class="lineCov">     780461 :           if (is_cxx () &amp;&amp; debug_info_level &gt; DINFO_LEVEL_TERSE)</span>
<span class="lineNum">   22924 </span>            :             {
<span class="lineNum">   22925 </span><span class="lineCov">     780460 :               dw_die_ref die = get_AT_ref (old_die, DW_AT_type);</span>
<span class="lineNum">   22926 </span><span class="lineCov">     780460 :               if (die == auto_die || die == decltype_auto_die)</span>
<span class="lineNum">   22927 </span><span class="lineCov">     356292 :                 add_type_attribute (subr_die, TREE_TYPE (TREE_TYPE (decl)),</span>
<span class="lineNum">   22928 </span>            :                                     TYPE_UNQUALIFIED, false, context_die);
<span class="lineNum">   22929 </span>            :             }
<span class="lineNum">   22930 </span>            : 
<span class="lineNum">   22931 </span>            :           /* When we process the method declaration, we haven't seen
<span class="lineNum">   22932 </span>            :              the out-of-class defaulted definition yet, so we have to
<span class="lineNum">   22933 </span>            :              recheck now.  */
<span class="lineNum">   22934 </span><span class="lineCov">     780460 :           if ((dwarf_version &gt;= 5 || ! dwarf_strict)</span>
<span class="lineNum">   22935 </span><span class="lineCov">    1560909 :               &amp;&amp; !get_AT (subr_die, DW_AT_defaulted))</span>
<span class="lineNum">   22936 </span>            :             {
<span class="lineNum">   22937 </span><span class="lineCov">     768826 :               int defaulted</span>
<span class="lineNum">   22938 </span><span class="lineCov">     768826 :                 = lang_hooks.decls.decl_dwarf_attribute (decl,</span>
<span class="lineNum">   22939 </span>            :                                                          DW_AT_defaulted);
<span class="lineNum">   22940 </span><span class="lineCov">     768826 :               if (defaulted != -1)</span>
<span class="lineNum">   22941 </span>            :                 {
<span class="lineNum">   22942 </span>            :                   /* Other values must have been handled before.  */
<span class="lineNum">   22943 </span><span class="lineCov">         35 :                   gcc_assert (defaulted == DW_DEFAULTED_out_of_class);</span>
<span class="lineNum">   22944 </span><span class="lineCov">         35 :                   add_AT_unsigned (subr_die, DW_AT_defaulted, defaulted);</span>
<span class="lineNum">   22945 </span>            :                 }
<span class="lineNum">   22946 </span>            :             }
<span class="lineNum">   22947 </span>            :         }
<span class="lineNum">   22948 </span>            :     }
<span class="lineNum">   22949 </span>            :   /* Create a fresh DIE for anything else.  */
<span class="lineNum">   22950 </span>            :   else
<span class="lineNum">   22951 </span>            :     {
<span class="lineNum">   22952 </span><span class="lineCov">    6630225 :       subr_die = new_die (DW_TAG_subprogram, context_die, decl);</span>
<span class="lineNum">   22953 </span>            : 
<span class="lineNum">   22954 </span><span class="lineCov">    6630225 :       if (TREE_PUBLIC (decl))</span>
<span class="lineNum">   22955 </span><span class="lineCov">    6507592 :         add_AT_flag (subr_die, DW_AT_external, 1);</span>
<span class="lineNum">   22956 </span>            : 
<span class="lineNum">   22957 </span><span class="lineCov">    6630225 :       add_name_and_src_coords_attributes (subr_die, decl);</span>
<span class="lineNum">   22958 </span><span class="lineCov">    6630225 :       add_pubname (decl, subr_die);</span>
<span class="lineNum">   22959 </span><span class="lineCov">    6630225 :       if (debug_info_level &gt; DINFO_LEVEL_TERSE)</span>
<span class="lineNum">   22960 </span>            :         {
<span class="lineNum">   22961 </span><span class="lineCov">    6627273 :           add_prototyped_attribute (subr_die, TREE_TYPE (decl));</span>
<span class="lineNum">   22962 </span><span class="lineCov">    6627273 :           add_type_attribute (subr_die, TREE_TYPE (TREE_TYPE (decl)),</span>
<span class="lineNum">   22963 </span>            :                               TYPE_UNQUALIFIED, false, context_die);
<span class="lineNum">   22964 </span>            :         }
<span class="lineNum">   22965 </span>            : 
<span class="lineNum">   22966 </span><span class="lineCov">    6630225 :       add_pure_or_virtual_attribute (subr_die, decl);</span>
<span class="lineNum">   22967 </span><span class="lineCov">    6630225 :       if (DECL_ARTIFICIAL (decl))</span>
<span class="lineNum">   22968 </span><span class="lineCov">     219143 :         add_AT_flag (subr_die, DW_AT_artificial, 1);</span>
<span class="lineNum">   22969 </span>            : 
<span class="lineNum">   22970 </span><span class="lineCov">    6630225 :       if (TREE_THIS_VOLATILE (decl) &amp;&amp; (dwarf_version &gt;= 5 || !dwarf_strict))</span>
<span class="lineNum">   22971 </span><span class="lineCov">       6129 :         add_AT_flag (subr_die, DW_AT_noreturn, 1);</span>
<span class="lineNum">   22972 </span>            : 
<span class="lineNum">   22973 </span><span class="lineCov">    6630225 :       add_alignment_attribute (subr_die, decl);</span>
<span class="lineNum">   22974 </span>            : 
<span class="lineNum">   22975 </span><span class="lineCov">    6630225 :       add_accessibility_attribute (subr_die, decl);</span>
<span class="lineNum">   22976 </span>            :     }
<span class="lineNum">   22977 </span>            : 
<span class="lineNum">   22978 </span>            :   /* Unless we have an existing non-declaration DIE, equate the new
<span class="lineNum">   22979 </span>            :      DIE.  */
<span class="lineNum">   22980 </span><span class="lineCov">    9082127 :   if (!old_die || is_declaration_die (old_die))</span>
<span class="lineNum">   22981 </span><span class="lineCov">    7621790 :     equate_decl_number_to_die (decl, subr_die);</span>
<span class="lineNum">   22982 </span>            : 
<span class="lineNum">   22983 </span><span class="lineCov">    7961728 :   if (declaration)</span>
<span class="lineNum">   22984 </span>            :     {
<span class="lineNum">   22985 </span><span class="lineCov">    6352923 :       if (!old_die || !get_AT (old_die, DW_AT_inline))</span>
<span class="lineNum">   22986 </span>            :         {
<span class="lineNum">   22987 </span><span class="lineCov">    6352923 :           add_AT_flag (subr_die, DW_AT_declaration, 1);</span>
<span class="lineNum">   22988 </span>            : 
<span class="lineNum">   22989 </span>            :           /* If this is an explicit function declaration then generate
<span class="lineNum">   22990 </span>            :              a DW_AT_explicit attribute.  */
<span class="lineNum">   22991 </span><span class="lineCov">       1486 :           if ((dwarf_version &gt;= 3 || !dwarf_strict)</span>
<span class="lineNum">   22992 </span><span class="lineCov">    6354409 :               &amp;&amp; lang_hooks.decls.decl_dwarf_attribute (decl,</span>
<span class="lineNum">   22993 </span>            :                                                         DW_AT_explicit) == 1)
<span class="lineNum">   22994 </span><span class="lineCov">     193563 :             add_AT_flag (subr_die, DW_AT_explicit, 1);</span>
<span class="lineNum">   22995 </span>            : 
<span class="lineNum">   22996 </span>            :           /* If this is a C++11 deleted special function member then generate
<span class="lineNum">   22997 </span>            :              a DW_AT_deleted attribute.  */
<span class="lineNum">   22998 </span><span class="lineCov">    6352922 :           if ((dwarf_version &gt;= 5 || !dwarf_strict)</span>
<span class="lineNum">   22999 </span><span class="lineCov">   12705827 :               &amp;&amp; lang_hooks.decls.decl_dwarf_attribute (decl,</span>
<span class="lineNum">   23000 </span>            :                                                         DW_AT_deleted) == 1)
<span class="lineNum">   23001 </span><span class="lineCov">     143836 :             add_AT_flag (subr_die, DW_AT_deleted, 1);</span>
<span class="lineNum">   23002 </span>            : 
<span class="lineNum">   23003 </span>            :           /* If this is a C++11 defaulted special function member then
<span class="lineNum">   23004 </span>            :              generate a DW_AT_defaulted attribute.  */
<span class="lineNum">   23005 </span><span class="lineCov">    6352923 :           if (dwarf_version &gt;= 5 || !dwarf_strict)</span>
<span class="lineNum">   23006 </span>            :             {
<span class="lineNum">   23007 </span><span class="lineCov">    6352905 :               int defaulted</span>
<span class="lineNum">   23008 </span><span class="lineCov">    6352905 :                 = lang_hooks.decls.decl_dwarf_attribute (decl,</span>
<span class="lineNum">   23009 </span>            :                                                          DW_AT_defaulted);
<span class="lineNum">   23010 </span><span class="lineCov">    6352905 :               if (defaulted != -1)</span>
<span class="lineNum">   23011 </span><span class="lineCov">     236295 :                 add_AT_unsigned (subr_die, DW_AT_defaulted, defaulted);</span>
<span class="lineNum">   23012 </span>            :             }
<span class="lineNum">   23013 </span>            : 
<span class="lineNum">   23014 </span>            :           /* If this is a C++11 non-static member function with &amp; ref-qualifier
<span class="lineNum">   23015 </span>            :              then generate a DW_AT_reference attribute.  */
<span class="lineNum">   23016 </span><span class="lineCov">    6352922 :           if ((dwarf_version &gt;= 5 || !dwarf_strict)</span>
<span class="lineNum">   23017 </span><span class="lineCov">   12705827 :               &amp;&amp; lang_hooks.decls.decl_dwarf_attribute (decl,</span>
<span class="lineNum">   23018 </span>            :                                                         DW_AT_reference) == 1)
<span class="lineNum">   23019 </span><span class="lineCov">       1497 :             add_AT_flag (subr_die, DW_AT_reference, 1);</span>
<span class="lineNum">   23020 </span>            : 
<span class="lineNum">   23021 </span>            :           /* If this is a C++11 non-static member function with &amp;&amp;
<span class="lineNum">   23022 </span>            :              ref-qualifier then generate a DW_AT_reference attribute.  */
<span class="lineNum">   23023 </span><span class="lineCov">    6352922 :           if ((dwarf_version &gt;= 5 || !dwarf_strict)</span>
<span class="lineNum">   23024 </span><span class="lineCov">   12705827 :               &amp;&amp; lang_hooks.decls.decl_dwarf_attribute (decl,</span>
<span class="lineNum">   23025 </span>            :                                                         DW_AT_rvalue_reference)
<span class="lineNum">   23026 </span>            :                  == 1)
<span class="lineNum">   23027 </span><span class="lineCov">       1500 :             add_AT_flag (subr_die, DW_AT_rvalue_reference, 1);</span>
<span class="lineNum">   23028 </span>            :         }
<span class="lineNum">   23029 </span>            :     }
<span class="lineNum">   23030 </span>            :   /* For non DECL_EXTERNALs, if range information is available, fill
<span class="lineNum">   23031 </span>            :      the DIE with it.  */
<span class="lineNum">   23032 </span><span class="lineCov">    1608805 :   else if (!DECL_EXTERNAL (decl) &amp;&amp; !early_dwarf)</span>
<span class="lineNum">   23033 </span>            :     {
<span class="lineNum">   23034 </span><span class="lineCov">     339893 :       HOST_WIDE_INT cfa_fb_offset;</span>
<span class="lineNum">   23035 </span>            : 
<span class="lineNum">   23036 </span><span class="lineCov">     339893 :       struct function *fun = DECL_STRUCT_FUNCTION (decl);</span>
<span class="lineNum">   23037 </span>            : 
<span class="lineNum">   23038 </span><span class="lineCov">     339893 :       if (!crtl-&gt;has_bb_partition)</span>
<span class="lineNum">   23039 </span>            :         {
<span class="lineNum">   23040 </span><span class="lineCov">     330470 :           dw_fde_ref fde = fun-&gt;fde;</span>
<span class="lineNum">   23041 </span><span class="lineCov">     330470 :           if (fde-&gt;dw_fde_begin)</span>
<span class="lineNum">   23042 </span>            :             {
<span class="lineNum">   23043 </span>            :               /* We have already generated the labels.  */
<span class="lineNum">   23044 </span><span class="lineCov">     330470 :              add_AT_low_high_pc (subr_die, fde-&gt;dw_fde_begin,</span>
<span class="lineNum">   23045 </span>            :                                  fde-&gt;dw_fde_end, false);
<span class="lineNum">   23046 </span>            :             }
<span class="lineNum">   23047 </span>            :           else
<span class="lineNum">   23048 </span>            :             {
<span class="lineNum">   23049 </span>            :               /* Create start/end labels and add the range.  */
<span class="lineNum">   23050 </span><span class="lineNoCov">          0 :               char label_id_low[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">   23051 </span><span class="lineNoCov">          0 :               char label_id_high[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">   23052 </span><span class="lineNoCov">          0 :               ASM_GENERATE_INTERNAL_LABEL (label_id_low, FUNC_BEGIN_LABEL,</span>
<span class="lineNum">   23053 </span>            :                                            current_function_funcdef_no);
<span class="lineNum">   23054 </span><span class="lineNoCov">          0 :               ASM_GENERATE_INTERNAL_LABEL (label_id_high, FUNC_END_LABEL,</span>
<span class="lineNum">   23055 </span>            :                                            current_function_funcdef_no);
<span class="lineNum">   23056 </span><span class="lineNoCov">          0 :              add_AT_low_high_pc (subr_die, label_id_low, label_id_high,</span>
<span class="lineNum">   23057 </span>            :                                  false);
<span class="lineNum">   23058 </span>            :             }
<span class="lineNum">   23059 </span>            : 
<span class="lineNum">   23060 </span>            : #if VMS_DEBUGGING_INFO
<span class="lineNum">   23061 </span>            :       /* HP OpenVMS Industry Standard 64: DWARF Extensions
<span class="lineNum">   23062 </span>            :          Section 2.3 Prologue and Epilogue Attributes:
<span class="lineNum">   23063 </span>            :          When a breakpoint is set on entry to a function, it is generally
<span class="lineNum">   23064 </span>            :          desirable for execution to be suspended, not on the very first
<span class="lineNum">   23065 </span>            :          instruction of the function, but rather at a point after the
<span class="lineNum">   23066 </span>            :          function's frame has been set up, after any language defined local
<span class="lineNum">   23067 </span>            :          declaration processing has been completed, and before execution of
<span class="lineNum">   23068 </span>            :          the first statement of the function begins. Debuggers generally
<span class="lineNum">   23069 </span>            :          cannot properly determine where this point is.  Similarly for a
<span class="lineNum">   23070 </span>            :          breakpoint set on exit from a function. The prologue and epilogue
<span class="lineNum">   23071 </span>            :          attributes allow a compiler to communicate the location(s) to use.  */
<span class="lineNum">   23072 </span>            : 
<span class="lineNum">   23073 </span>            :       {
<span class="lineNum">   23074 </span>            :         if (fde-&gt;dw_fde_vms_end_prologue)
<span class="lineNum">   23075 </span>            :           add_AT_vms_delta (subr_die, DW_AT_HP_prologue,
<span class="lineNum">   23076 </span>            :             fde-&gt;dw_fde_begin, fde-&gt;dw_fde_vms_end_prologue);
<span class="lineNum">   23077 </span>            : 
<span class="lineNum">   23078 </span>            :         if (fde-&gt;dw_fde_vms_begin_epilogue)
<span class="lineNum">   23079 </span>            :           add_AT_vms_delta (subr_die, DW_AT_HP_epilogue,
<span class="lineNum">   23080 </span>            :             fde-&gt;dw_fde_begin, fde-&gt;dw_fde_vms_begin_epilogue);
<span class="lineNum">   23081 </span>            :       }
<span class="lineNum">   23082 </span>            : #endif
<span class="lineNum">   23083 </span>            : 
<span class="lineNum">   23084 </span>            :         }
<span class="lineNum">   23085 </span>            :       else
<span class="lineNum">   23086 </span>            :         {
<span class="lineNum">   23087 </span>            :           /* Generate pubnames entries for the split function code ranges.  */
<span class="lineNum">   23088 </span><span class="lineCov">       9423 :           dw_fde_ref fde = fun-&gt;fde;</span>
<span class="lineNum">   23089 </span>            : 
<span class="lineNum">   23090 </span><span class="lineCov">       9423 :           if (fde-&gt;dw_fde_second_begin)</span>
<span class="lineNum">   23091 </span>            :             {
<span class="lineNum">   23092 </span><span class="lineCov">       9423 :               if (dwarf_version &gt;= 3 || !dwarf_strict)</span>
<span class="lineNum">   23093 </span>            :                 {
<span class="lineNum">   23094 </span>            :                   /* We should use ranges for non-contiguous code section 
<span class="lineNum">   23095 </span>            :                      addresses.  Use the actual code range for the initial
<span class="lineNum">   23096 </span>            :                      section, since the HOT/COLD labels might precede an 
<span class="lineNum">   23097 </span>            :                      alignment offset.  */
<span class="lineNum">   23098 </span><span class="lineCov">       9423 :                   bool range_list_added = false;</span>
<span class="lineNum">   23099 </span><span class="lineCov">       9423 :                   add_ranges_by_labels (subr_die, fde-&gt;dw_fde_begin,</span>
<span class="lineNum">   23100 </span>            :                                         fde-&gt;dw_fde_end, &amp;range_list_added,
<span class="lineNum">   23101 </span>            :                                         false);
<span class="lineNum">   23102 </span><span class="lineCov">       9423 :                   add_ranges_by_labels (subr_die, fde-&gt;dw_fde_second_begin,</span>
<span class="lineNum">   23103 </span>            :                                         fde-&gt;dw_fde_second_end,
<span class="lineNum">   23104 </span>            :                                         &amp;range_list_added, false);
<span class="lineNum">   23105 </span><span class="lineCov">       9423 :                   if (range_list_added)</span>
<span class="lineNum">   23106 </span><span class="lineCov">       9423 :                     add_ranges (NULL);</span>
<span class="lineNum">   23107 </span>            :                 }
<span class="lineNum">   23108 </span>            :               else
<span class="lineNum">   23109 </span>            :                 {
<span class="lineNum">   23110 </span>            :                   /* There is no real support in DW2 for this .. so we make
<span class="lineNum">   23111 </span>            :                      a work-around.  First, emit the pub name for the segment
<span class="lineNum">   23112 </span>            :                      containing the function label.  Then make and emit a
<span class="lineNum">   23113 </span>            :                      simplified subprogram DIE for the second segment with the
<span class="lineNum">   23114 </span>            :                      name pre-fixed by __hot/cold_sect_of_.  We use the same
<span class="lineNum">   23115 </span>            :                      linkage name for the second die so that gdb will find both
<span class="lineNum">   23116 </span>            :                      sections when given &quot;b foo&quot;.  */
<span class="lineNum">   23117 </span><span class="lineNoCov">          0 :                   const char *name = NULL;</span>
<span class="lineNum">   23118 </span><span class="lineNoCov">          0 :                   tree decl_name = DECL_NAME (decl);</span>
<span class="lineNum">   23119 </span><span class="lineNoCov">          0 :                   dw_die_ref seg_die;</span>
<span class="lineNum">   23120 </span>            : 
<span class="lineNum">   23121 </span>            :                   /* Do the 'primary' section.   */
<span class="lineNum">   23122 </span><span class="lineNoCov">          0 :                   add_AT_low_high_pc (subr_die, fde-&gt;dw_fde_begin,</span>
<span class="lineNum">   23123 </span>            :                                       fde-&gt;dw_fde_end, false);
<span class="lineNum">   23124 </span>            : 
<span class="lineNum">   23125 </span>            :                   /* Build a minimal DIE for the secondary section.  */
<span class="lineNum">   23126 </span><span class="lineNoCov">          0 :                   seg_die = new_die (DW_TAG_subprogram,</span>
<span class="lineNum">   23127 </span>            :                                      subr_die-&gt;die_parent, decl);
<span class="lineNum">   23128 </span>            : 
<span class="lineNum">   23129 </span><span class="lineNoCov">          0 :                   if (TREE_PUBLIC (decl))</span>
<span class="lineNum">   23130 </span><span class="lineNoCov">          0 :                     add_AT_flag (seg_die, DW_AT_external, 1);</span>
<span class="lineNum">   23131 </span>            : 
<span class="lineNum">   23132 </span><span class="lineNoCov">          0 :                   if (decl_name != NULL </span>
<span class="lineNum">   23133 </span><span class="lineNoCov">          0 :                       &amp;&amp; IDENTIFIER_POINTER (decl_name) != NULL)</span>
<span class="lineNum">   23134 </span>            :                     {
<span class="lineNum">   23135 </span><span class="lineNoCov">          0 :                       name = dwarf2_name (decl, 1);</span>
<span class="lineNum">   23136 </span><span class="lineNoCov">          0 :                       if (! DECL_ARTIFICIAL (decl))</span>
<span class="lineNum">   23137 </span><span class="lineNoCov">          0 :                         add_src_coords_attributes (seg_die, decl);</span>
<span class="lineNum">   23138 </span>            : 
<span class="lineNum">   23139 </span><span class="lineNoCov">          0 :                       add_linkage_name (seg_die, decl);</span>
<span class="lineNum">   23140 </span>            :                     }
<span class="lineNum">   23141 </span><span class="lineNoCov">          0 :                   gcc_assert (name != NULL);</span>
<span class="lineNum">   23142 </span><span class="lineNoCov">          0 :                   add_pure_or_virtual_attribute (seg_die, decl);</span>
<span class="lineNum">   23143 </span><span class="lineNoCov">          0 :                   if (DECL_ARTIFICIAL (decl))</span>
<span class="lineNum">   23144 </span><span class="lineNoCov">          0 :                     add_AT_flag (seg_die, DW_AT_artificial, 1);</span>
<span class="lineNum">   23145 </span>            : 
<span class="lineNum">   23146 </span><span class="lineNoCov">          0 :                   name = concat (&quot;__second_sect_of_&quot;, name, NULL); </span>
<span class="lineNum">   23147 </span><span class="lineNoCov">          0 :                   add_AT_low_high_pc (seg_die, fde-&gt;dw_fde_second_begin,</span>
<span class="lineNum">   23148 </span>            :                                       fde-&gt;dw_fde_second_end, false);
<span class="lineNum">   23149 </span><span class="lineNoCov">          0 :                   add_name_attribute (seg_die, name);</span>
<span class="lineNum">   23150 </span><span class="lineNoCov">          0 :                   if (want_pubnames ())</span>
<span class="lineNum">   23151 </span><span class="lineNoCov">          0 :                     add_pubname_string (name, seg_die);</span>
<span class="lineNum">   23152 </span>            :                 }
<span class="lineNum">   23153 </span>            :             }
<span class="lineNum">   23154 </span>            :           else
<span class="lineNum">   23155 </span><span class="lineNoCov">          0 :            add_AT_low_high_pc (subr_die, fde-&gt;dw_fde_begin, fde-&gt;dw_fde_end,</span>
<span class="lineNum">   23156 </span>            :                                false);
<span class="lineNum">   23157 </span>            :         }
<span class="lineNum">   23158 </span>            : 
<span class="lineNum">   23159 </span><span class="lineCov">     339893 :       cfa_fb_offset = CFA_FRAME_BASE_OFFSET (decl);</span>
<span class="lineNum">   23160 </span>            : 
<span class="lineNum">   23161 </span>            :       /* We define the &quot;frame base&quot; as the function's CFA.  This is more
<span class="lineNum">   23162 </span>            :          convenient for several reasons: (1) It's stable across the prologue
<span class="lineNum">   23163 </span>            :          and epilogue, which makes it better than just a frame pointer,
<span class="lineNum">   23164 </span>            :          (2) With dwarf3, there exists a one-byte encoding that allows us
<span class="lineNum">   23165 </span>            :          to reference the .debug_frame data by proxy, but failing that,
<span class="lineNum">   23166 </span>            :          (3) We can at least reuse the code inspection and interpretation
<span class="lineNum">   23167 </span>            :          code that determines the CFA position at various points in the
<span class="lineNum">   23168 </span>            :          function.  */
<span class="lineNum">   23169 </span><span class="lineCov">     339893 :       if (dwarf_version &gt;= 3 &amp;&amp; targetm.debug_unwind_info () == UI_DWARF2)</span>
<span class="lineNum">   23170 </span>            :         {
<span class="lineNum">   23171 </span><span class="lineCov">     337249 :           dw_loc_descr_ref op = new_loc_descr (DW_OP_call_frame_cfa, 0, 0);</span>
<span class="lineNum">   23172 </span><span class="lineCov">     337249 :           add_AT_loc (subr_die, DW_AT_frame_base, op);</span>
<span class="lineNum">   23173 </span>            :         }
<span class="lineNum">   23174 </span>            :       else
<span class="lineNum">   23175 </span>            :         {
<span class="lineNum">   23176 </span><span class="lineCov">       2644 :           dw_loc_list_ref list = convert_cfa_to_fb_loc_list (cfa_fb_offset);</span>
<span class="lineNum">   23177 </span><span class="lineCov">       2644 :           if (list-&gt;dw_loc_next)</span>
<span class="lineNum">   23178 </span><span class="lineCov">       1569 :             add_AT_loc_list (subr_die, DW_AT_frame_base, list);</span>
<span class="lineNum">   23179 </span>            :           else
<span class="lineNum">   23180 </span><span class="lineCov">       1075 :             add_AT_loc (subr_die, DW_AT_frame_base, list-&gt;expr);</span>
<span class="lineNum">   23181 </span>            :         }
<span class="lineNum">   23182 </span>            : 
<span class="lineNum">   23183 </span>            :       /* Compute a displacement from the &quot;steady-state frame pointer&quot; to
<span class="lineNum">   23184 </span>            :          the CFA.  The former is what all stack slots and argument slots
<span class="lineNum">   23185 </span>            :          will reference in the rtl; the latter is what we've told the
<span class="lineNum">   23186 </span>            :          debugger about.  We'll need to adjust all frame_base references
<span class="lineNum">   23187 </span>            :          by this displacement.  */
<span class="lineNum">   23188 </span><span class="lineCov">     679786 :       compute_frame_pointer_to_fb_displacement (cfa_fb_offset);</span>
<span class="lineNum">   23189 </span>            : 
<span class="lineNum">   23190 </span><span class="lineCov">     339893 :       if (fun-&gt;static_chain_decl)</span>
<span class="lineNum">   23191 </span>            :         {
<span class="lineNum">   23192 </span>            :           /* DWARF requires here a location expression that computes the
<span class="lineNum">   23193 </span>            :              address of the enclosing subprogram's frame base.  The machinery
<span class="lineNum">   23194 </span>            :              in tree-nested.c is supposed to store this specific address in the
<span class="lineNum">   23195 </span>            :              last field of the FRAME record.  */
<span class="lineNum">   23196 </span><span class="lineCov">       7844 :           const tree frame_type</span>
<span class="lineNum">   23197 </span><span class="lineCov">       7844 :             = TREE_TYPE (TREE_TYPE (fun-&gt;static_chain_decl));</span>
<span class="lineNum">   23198 </span><span class="lineCov">       7844 :           const tree fb_decl = tree_last (TYPE_FIELDS (frame_type));</span>
<span class="lineNum">   23199 </span>            : 
<span class="lineNum">   23200 </span><span class="lineCov">       7844 :           tree fb_expr</span>
<span class="lineNum">   23201 </span><span class="lineCov">       7844 :             = build1 (INDIRECT_REF, frame_type, fun-&gt;static_chain_decl);</span>
<span class="lineNum">   23202 </span><span class="lineCov">       7844 :           fb_expr = build3 (COMPONENT_REF, TREE_TYPE (fb_decl),</span>
<span class="lineNum">   23203 </span>            :                             fb_expr, fb_decl, NULL_TREE);
<span class="lineNum">   23204 </span>            : 
<span class="lineNum">   23205 </span><span class="lineCov">       7844 :           add_AT_location_description (subr_die, DW_AT_static_link,</span>
<span class="lineNum">   23206 </span>            :                                        loc_list_from_tree (fb_expr, 0, NULL));
<span class="lineNum">   23207 </span>            :         }
<span class="lineNum">   23208 </span>            : 
<span class="lineNum">   23209 </span><span class="lineCov">     339893 :       resolve_variable_values ();</span>
<span class="lineNum">   23210 </span>            :     }
<span class="lineNum">   23211 </span>            : 
<span class="lineNum">   23212 </span>            :   /* Generate child dies for template paramaters.  */
<span class="lineNum">   23213 </span><span class="lineCov">    7961728 :   if (early_dwarf &amp;&amp; debug_info_level &gt; DINFO_LEVEL_TERSE)</span>
<span class="lineNum">   23214 </span><span class="lineCov">    7618796 :     gen_generic_params_dies (decl);</span>
<span class="lineNum">   23215 </span>            : 
<span class="lineNum">   23216 </span>            :   /* Now output descriptions of the arguments for this function. This gets
<span class="lineNum">   23217 </span>            :      (unnecessarily?) complex because of the fact that the DECL_ARGUMENT list
<span class="lineNum">   23218 </span>            :      for a FUNCTION_DECL doesn't indicate cases where there was a trailing
<span class="lineNum">   23219 </span>            :      `...' at the end of the formal parameter list.  In order to find out if
<span class="lineNum">   23220 </span>            :      there was a trailing ellipsis or not, we must instead look at the type
<span class="lineNum">   23221 </span>            :      associated with the FUNCTION_DECL.  This will be a node of type
<span class="lineNum">   23222 </span>            :      FUNCTION_TYPE. If the chain of type nodes hanging off of this
<span class="lineNum">   23223 </span>            :      FUNCTION_TYPE node ends with a void_type_node then there should *not* be
<span class="lineNum">   23224 </span>            :      an ellipsis at the end.  */
<span class="lineNum">   23225 </span>            : 
<span class="lineNum">   23226 </span>            :   /* In the case where we are describing a mere function declaration, all we
<span class="lineNum">   23227 </span>            :      need to do here (and all we *can* do here) is to describe the *types* of
<span class="lineNum">   23228 </span>            :      its formal parameters.  */
<span class="lineNum">   23229 </span><span class="lineCov">    7961728 :   if (debug_info_level &lt;= DINFO_LEVEL_TERSE)</span>
<span class="lineNum">   23230 </span>            :     ;
<span class="lineNum">   23231 </span><span class="lineCov">    7956074 :   else if (declaration)</span>
<span class="lineNum">   23232 </span><span class="lineCov">    6352923 :     gen_formal_types_die (decl, subr_die);</span>
<span class="lineNum">   23233 </span>            :   else
<span class="lineNum">   23234 </span>            :     {
<span class="lineNum">   23235 </span>            :       /* Generate DIEs to represent all known formal parameters.  */
<span class="lineNum">   23236 </span><span class="lineCov">    1603151 :       tree parm = DECL_ARGUMENTS (decl);</span>
<span class="lineNum">   23237 </span><span class="lineCov">    1603151 :       tree generic_decl = early_dwarf</span>
<span class="lineNum">   23238 </span><span class="lineCov">    1603151 :         ? lang_hooks.decls.get_generic_function_decl (decl) : NULL;</span>
<span class="lineNum">   23239 </span><span class="lineCov">    1265882 :       tree generic_decl_parm = generic_decl</span>
<span class="lineNum">   23240 </span><span class="lineCov">    1265882 :                                 ? DECL_ARGUMENTS (generic_decl)</span>
<span class="lineNum">   23241 </span>            :                                 : NULL;
<span class="lineNum">   23242 </span>            : 
<span class="lineNum">   23243 </span>            :       /* Now we want to walk the list of parameters of the function and
<span class="lineNum">   23244 </span>            :          emit their relevant DIEs.
<span class="lineNum">   23245 </span>            : 
<span class="lineNum">   23246 </span>            :          We consider the case of DECL being an instance of a generic function
<span class="lineNum">   23247 </span>            :          as well as it being a normal function.
<span class="lineNum">   23248 </span>            : 
<span class="lineNum">   23249 </span>            :          If DECL is an instance of a generic function we walk the
<span class="lineNum">   23250 </span>            :          parameters of the generic function declaration _and_ the parameters of
<span class="lineNum">   23251 </span>            :          DECL itself. This is useful because we want to emit specific DIEs for
<span class="lineNum">   23252 </span>            :          function parameter packs and those are declared as part of the
<span class="lineNum">   23253 </span>            :          generic function declaration. In that particular case,
<span class="lineNum">   23254 </span>            :          the parameter pack yields a DW_TAG_GNU_formal_parameter_pack DIE.
<span class="lineNum">   23255 </span>            :          That DIE has children DIEs representing the set of arguments
<span class="lineNum">   23256 </span>            :          of the pack. Note that the set of pack arguments can be empty.
<span class="lineNum">   23257 </span>            :          In that case, the DW_TAG_GNU_formal_parameter_pack DIE will not have any
<span class="lineNum">   23258 </span>            :          children DIE.
<span class="lineNum">   23259 </span>            : 
<span class="lineNum">   23260 </span>            :          Otherwise, we just consider the parameters of DECL.  */
<span class="lineNum">   23261 </span><span class="lineCov">    4626698 :       while (generic_decl_parm || parm)</span>
<span class="lineNum">   23262 </span>            :         {
<span class="lineNum">   23263 </span><span class="lineCov">    3023547 :           if (generic_decl_parm</span>
<span class="lineNum">   23264 </span><span class="lineCov">    3023547 :               &amp;&amp; lang_hooks.function_parameter_pack_p (generic_decl_parm))</span>
<span class="lineNum">   23265 </span><span class="lineCov">      23623 :             gen_formal_parameter_pack_die (generic_decl_parm,</span>
<span class="lineNum">   23266 </span>            :                                            parm, subr_die,
<span class="lineNum">   23267 </span>            :                                            &amp;parm);
<span class="lineNum">   23268 </span><span class="lineCov">    2999924 :           else if (parm)</span>
<span class="lineNum">   23269 </span>            :             {
<span class="lineNum">   23270 </span><span class="lineCov">    2999924 :               dw_die_ref parm_die = gen_decl_die (parm, NULL, NULL, subr_die);</span>
<span class="lineNum">   23271 </span>            : 
<span class="lineNum">   23272 </span><span class="lineCov">    2999924 :               if (early_dwarf</span>
<span class="lineNum">   23273 </span><span class="lineCov">    2335030 :                   &amp;&amp; parm == DECL_ARGUMENTS (decl)</span>
<span class="lineNum">   23274 </span><span class="lineCov">    1194593 :                   &amp;&amp; TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE</span>
<span class="lineNum">   23275 </span><span class="lineCov">     730854 :                   &amp;&amp; parm_die</span>
<span class="lineNum">   23276 </span><span class="lineCov">    3730778 :                   &amp;&amp; (dwarf_version &gt;= 3 || !dwarf_strict))</span>
<span class="lineNum">   23277 </span><span class="lineCov">     730854 :                 add_AT_die_ref (subr_die, DW_AT_object_pointer, parm_die);</span>
<span class="lineNum">   23278 </span>            : 
<span class="lineNum">   23279 </span><span class="lineCov">    2999924 :               parm = DECL_CHAIN (parm);</span>
<span class="lineNum">   23280 </span>            :             }
<span class="lineNum">   23281 </span>            :           else if (parm)
<span class="lineNum">   23282 </span>            :             parm = DECL_CHAIN (parm);
<span class="lineNum">   23283 </span>            : 
<span class="lineNum">   23284 </span><span class="lineCov">    3023547 :           if (generic_decl_parm)</span>
<span class="lineNum">   23285 </span><span class="lineCov">     551740 :             generic_decl_parm = DECL_CHAIN (generic_decl_parm);</span>
<span class="lineNum">   23286 </span>            :         }
<span class="lineNum">   23287 </span>            : 
<span class="lineNum">   23288 </span>            :       /* Decide whether we need an unspecified_parameters DIE at the end.
<span class="lineNum">   23289 </span>            :          There are 2 more cases to do this for: 1) the ansi ... declaration -
<span class="lineNum">   23290 </span>            :          this is detectable when the end of the arg list is not a
<span class="lineNum">   23291 </span>            :          void_type_node 2) an unprototyped function declaration (not a
<span class="lineNum">   23292 </span>            :          definition).  This just means that we have no info about the
<span class="lineNum">   23293 </span>            :          parameters at all.  */
<span class="lineNum">   23294 </span><span class="lineCov">    1603151 :       if (early_dwarf)</span>
<span class="lineNum">   23295 </span>            :         {
<span class="lineNum">   23296 </span><span class="lineCov">    1265882 :           if (prototype_p (TREE_TYPE (decl)))</span>
<span class="lineNum">   23297 </span>            :             {
<span class="lineNum">   23298 </span>            :               /* This is the prototyped case, check for....  */
<span class="lineNum">   23299 </span><span class="lineCov">    1257073 :               if (stdarg_p (TREE_TYPE (decl)))</span>
<span class="lineNum">   23300 </span><span class="lineCov">       3196 :                 gen_unspecified_parameters_die (decl, subr_die);</span>
<span class="lineNum">   23301 </span>            :             }
<span class="lineNum">   23302 </span><span class="lineCov">       8809 :           else if (DECL_INITIAL (decl) == NULL_TREE)</span>
<span class="lineNum">   23303 </span><span class="lineNoCov">          0 :             gen_unspecified_parameters_die (decl, subr_die);</span>
<span class="lineNum">   23304 </span>            :         }
<span class="lineNum">   23305 </span>            :     }
<span class="lineNum">   23306 </span>            : 
<span class="lineNum">   23307 </span><span class="lineCov">    7961728 :   if (subr_die != old_die)</span>
<span class="lineNum">   23308 </span>            :     /* Add the calling convention attribute if requested.  */
<span class="lineNum">   23309 </span><span class="lineCov">    7657263 :     add_calling_convention_attribute (subr_die, decl);</span>
<span class="lineNum">   23310 </span>            : 
<span class="lineNum">   23311 </span>            :   /* Output Dwarf info for all of the stuff within the body of the function
<span class="lineNum">   23312 </span>            :      (if it has one - it may be just a declaration).
<span class="lineNum">   23313 </span>            : 
<span class="lineNum">   23314 </span>            :      OUTER_SCOPE is a pointer to the outermost BLOCK node created to represent
<span class="lineNum">   23315 </span>            :      a function.  This BLOCK actually represents the outermost binding contour
<span class="lineNum">   23316 </span>            :      for the function, i.e. the contour in which the function's formal
<span class="lineNum">   23317 </span>            :      parameters and labels get declared. Curiously, it appears that the front
<span class="lineNum">   23318 </span>            :      end doesn't actually put the PARM_DECL nodes for the current function onto
<span class="lineNum">   23319 </span>            :      the BLOCK_VARS list for this outer scope, but are strung off of the
<span class="lineNum">   23320 </span>            :      DECL_ARGUMENTS list for the function instead.
<span class="lineNum">   23321 </span>            : 
<span class="lineNum">   23322 </span>            :      The BLOCK_VARS list for the `outer_scope' does provide us with a list of
<span class="lineNum">   23323 </span>            :      the LABEL_DECL nodes for the function however, and we output DWARF info
<span class="lineNum">   23324 </span>            :      for those in decls_for_scope.  Just within the `outer_scope' there will be
<span class="lineNum">   23325 </span>            :      a BLOCK node representing the function's outermost pair of curly braces,
<span class="lineNum">   23326 </span>            :      and any blocks used for the base and member initializers of a C++
<span class="lineNum">   23327 </span>            :      constructor function.  */
<span class="lineNum">   23328 </span><span class="lineCov">    7961728 :   tree outer_scope = DECL_INITIAL (decl);</span>
<span class="lineNum">   23329 </span><span class="lineCov">    7961728 :   if (! declaration &amp;&amp; outer_scope &amp;&amp; TREE_CODE (outer_scope) != ERROR_MARK)</span>
<span class="lineNum">   23330 </span>            :     {
<span class="lineNum">   23331 </span><span class="lineCov">    1608805 :       int call_site_note_count = 0;</span>
<span class="lineNum">   23332 </span><span class="lineCov">    1608805 :       int tail_call_site_note_count = 0;</span>
<span class="lineNum">   23333 </span>            : 
<span class="lineNum">   23334 </span>            :       /* Emit a DW_TAG_variable DIE for a named return value.  */
<span class="lineNum">   23335 </span><span class="lineCov">    1608805 :       if (DECL_NAME (DECL_RESULT (decl)))</span>
<span class="lineNum">   23336 </span><span class="lineCov">       8872 :         gen_decl_die (DECL_RESULT (decl), NULL, NULL, subr_die);</span>
<span class="lineNum">   23337 </span>            : 
<span class="lineNum">   23338 </span>            :       /* The first time through decls_for_scope we will generate the
<span class="lineNum">   23339 </span>            :          DIEs for the locals.  The second time, we fill in the
<span class="lineNum">   23340 </span>            :          location info.  */
<span class="lineNum">   23341 </span><span class="lineCov">    1608805 :       decls_for_scope (outer_scope, subr_die);</span>
<span class="lineNum">   23342 </span>            : 
<span class="lineNum">   23343 </span><span class="lineCov">    1608805 :       if (call_arg_locations &amp;&amp; (!dwarf_strict || dwarf_version &gt;= 5))</span>
<span class="lineNum">   23344 </span>            :         {
<span class="lineNum">   23345 </span>            :           struct call_arg_loc_node *ca_loc;
<span class="lineNum">   23346 </span><span class="lineCov">    2436517 :           for (ca_loc = call_arg_locations; ca_loc; ca_loc = ca_loc-&gt;next)</span>
<span class="lineNum">   23347 </span>            :             {
<span class="lineNum">   23348 </span><span class="lineCov">    2157080 :               dw_die_ref die = NULL;</span>
<span class="lineNum">   23349 </span><span class="lineCov">    2157080 :               rtx tloc = NULL_RTX, tlocc = NULL_RTX;</span>
<span class="lineNum">   23350 </span><span class="lineCov">    2157080 :               rtx arg, next_arg;</span>
<span class="lineNum">   23351 </span><span class="lineCov">    2157080 :               tree arg_decl = NULL_TREE;</span>
<span class="lineNum">   23352 </span>            : 
<span class="lineNum">   23353 </span><span class="lineCov">    2157080 :               for (arg = (ca_loc-&gt;call_arg_loc_note != NULL_RTX</span>
<span class="lineNum">   23354 </span><span class="lineCov">    2157080 :                           ? XEXP (ca_loc-&gt;call_arg_loc_note, 0)</span>
<span class="lineNum">   23355 </span>            :                           : NULL_RTX);
<span class="lineNum">   23356 </span><span class="lineCov">    4171131 :                    arg; arg = next_arg)</span>
<span class="lineNum">   23357 </span>            :                 {
<span class="lineNum">   23358 </span><span class="lineCov">    2014051 :                   dw_loc_descr_ref reg, val;</span>
<span class="lineNum">   23359 </span><span class="lineCov">    2014051 :                   machine_mode mode = GET_MODE (XEXP (XEXP (arg, 0), 1));</span>
<span class="lineNum">   23360 </span><span class="lineCov">    2014051 :                   dw_die_ref cdie, tdie = NULL;</span>
<span class="lineNum">   23361 </span>            : 
<span class="lineNum">   23362 </span><span class="lineCov">    2014051 :                   next_arg = XEXP (arg, 1);</span>
<span class="lineNum">   23363 </span><span class="lineCov">    2014051 :                   if (REG_P (XEXP (XEXP (arg, 0), 0))</span>
<span class="lineNum">   23364 </span><span class="lineCov">    1992444 :                       &amp;&amp; next_arg</span>
<span class="lineNum">   23365 </span><span class="lineCov">     900213 :                       &amp;&amp; MEM_P (XEXP (XEXP (next_arg, 0), 0))</span>
<span class="lineNum">   23366 </span><span class="lineCov">       5142 :                       &amp;&amp; REG_P (XEXP (XEXP (XEXP (next_arg, 0), 0), 0))</span>
<span class="lineNum">   23367 </span><span class="lineCov">    2024335 :                       &amp;&amp; REGNO (XEXP (XEXP (arg, 0), 0))</span>
<span class="lineNum">   23368 </span><span class="lineCov">       5142 :                          == REGNO (XEXP (XEXP (XEXP (next_arg, 0), 0), 0)))</span>
<span class="lineNum">   23369 </span><span class="lineCov">       4725 :                     next_arg = XEXP (next_arg, 1);</span>
<span class="lineNum">   23370 </span><span class="lineCov">    2014051 :                   if (mode == VOIDmode)</span>
<span class="lineNum">   23371 </span>            :                     {
<span class="lineNum">   23372 </span><span class="lineCov">     338200 :                       mode = GET_MODE (XEXP (XEXP (arg, 0), 0));</span>
<span class="lineNum">   23373 </span><span class="lineCov">     338200 :                       if (mode == VOIDmode)</span>
<span class="lineNum">   23374 </span><span class="lineCov">         10 :                         mode = GET_MODE (XEXP (arg, 0));</span>
<span class="lineNum">   23375 </span>            :                     }
<span class="lineNum">   23376 </span><span class="lineCov">    2014051 :                   if (mode == VOIDmode || mode == BLKmode)</span>
<span class="lineNum">   23377 </span>            :                     continue;
<span class="lineNum">   23378 </span>            :                   /* Get dynamic information about call target only if we
<span class="lineNum">   23379 </span>            :                      have no static information: we cannot generate both
<span class="lineNum">   23380 </span>            :                      DW_AT_call_origin and DW_AT_call_target
<span class="lineNum">   23381 </span>            :                      attributes.  */
<span class="lineNum">   23382 </span><span class="lineCov">    2014051 :                   if (ca_loc-&gt;symbol_ref == NULL_RTX)</span>
<span class="lineNum">   23383 </span>            :                     {
<span class="lineNum">   23384 </span><span class="lineCov">      90858 :                       if (XEXP (XEXP (arg, 0), 0) == pc_rtx)</span>
<span class="lineNum">   23385 </span>            :                         {
<span class="lineNum">   23386 </span>            :                           tloc = XEXP (XEXP (arg, 0), 1);
<span class="lineNum">   23387 </span>            :                           continue;
<span class="lineNum">   23388 </span>            :                         }
<span class="lineNum">   23389 </span><span class="lineCov">      86558 :                       else if (GET_CODE (XEXP (XEXP (arg, 0), 0)) == CLOBBER</span>
<span class="lineNum">   23390 </span><span class="lineNoCov">          0 :                                &amp;&amp; XEXP (XEXP (XEXP (arg, 0), 0), 0) == pc_rtx)</span>
<span class="lineNum">   23391 </span>            :                         {
<span class="lineNum">   23392 </span>            :                           tlocc = XEXP (XEXP (arg, 0), 1);
<span class="lineNum">   23393 </span>            :                           continue;
<span class="lineNum">   23394 </span>            :                         }
<span class="lineNum">   23395 </span>            :                     }
<span class="lineNum">   23396 </span><span class="lineCov">    2009751 :                   reg = NULL;</span>
<span class="lineNum">   23397 </span><span class="lineCov">    2009751 :                   if (REG_P (XEXP (XEXP (arg, 0), 0)))</span>
<span class="lineNum">   23398 </span><span class="lineCov">    1992444 :                     reg = reg_loc_descriptor (XEXP (XEXP (arg, 0), 0),</span>
<span class="lineNum">   23399 </span>            :                                               VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   23400 </span><span class="lineCov">      17307 :                   else if (MEM_P (XEXP (XEXP (arg, 0), 0)))</span>
<span class="lineNum">   23401 </span>            :                     {
<span class="lineNum">   23402 </span><span class="lineCov">       2369 :                       rtx mem = XEXP (XEXP (arg, 0), 0);</span>
<span class="lineNum">   23403 </span><span class="lineCov">       2369 :                       reg = mem_loc_descriptor (XEXP (mem, 0),</span>
<span class="lineNum">   23404 </span><span class="lineCov">       2369 :                                                 get_address_mode (mem),</span>
<span class="lineNum">   23405 </span><span class="lineCov">       2369 :                                                 GET_MODE (mem),</span>
<span class="lineNum">   23406 </span>            :                                                 VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   23407 </span>            :                     }
<span class="lineNum">   23408 </span><span class="lineCov">      14938 :                   else if (GET_CODE (XEXP (XEXP (arg, 0), 0))</span>
<span class="lineNum">   23409 </span>            :                            == DEBUG_PARAMETER_REF)
<span class="lineNum">   23410 </span>            :                     {
<span class="lineNum">   23411 </span><span class="lineCov">      14938 :                       tree tdecl</span>
<span class="lineNum">   23412 </span>            :                         = DEBUG_PARAMETER_REF_DECL (XEXP (XEXP (arg, 0), 0));
<span class="lineNum">   23413 </span><span class="lineCov">      14938 :                       tdie = lookup_decl_die (tdecl);</span>
<span class="lineNum">   23414 </span><span class="lineCov">      14938 :                       if (tdie == NULL)</span>
<span class="lineNum">   23415 </span>            :                         continue;
<span class="lineNum">   23416 </span>            :                       arg_decl = tdecl;
<span class="lineNum">   23417 </span>            :                     }
<span class="lineNum">   23418 </span>            :                   else
<span class="lineNum">   23419 </span>            :                     continue;
<span class="lineNum">   23420 </span><span class="lineCov">    2009685 :                   if (reg == NULL</span>
<span class="lineNum">   23421 </span><span class="lineCov">      14872 :                       &amp;&amp; GET_CODE (XEXP (XEXP (arg, 0), 0))</span>
<span class="lineNum">   23422 </span>            :                          != DEBUG_PARAMETER_REF)
<span class="lineNum">   23423 </span>            :                     continue;
<span class="lineNum">   23424 </span><span class="lineCov">    2009685 :                   val = mem_loc_descriptor (XEXP (XEXP (arg, 0), 1), mode,</span>
<span class="lineNum">   23425 </span>            :                                             VOIDmode,
<span class="lineNum">   23426 </span>            :                                             VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   23427 </span><span class="lineCov">    2009685 :                   if (val == NULL)</span>
<span class="lineNum">   23428 </span>            :                     continue;
<span class="lineNum">   23429 </span><span class="lineCov">    1943200 :                   if (die == NULL)</span>
<span class="lineNum">   23430 </span><span class="lineCov">    1091075 :                     die = gen_call_site_die (decl, subr_die, ca_loc);</span>
<span class="lineNum">   23431 </span><span class="lineCov">    3886396 :                   cdie = new_die (dwarf_TAG (DW_TAG_call_site_parameter), die,</span>
<span class="lineNum">   23432 </span>            :                                   NULL_TREE);
<span class="lineNum">   23433 </span><span class="lineCov">    1943200 :                   add_desc_attribute (cdie, arg_decl);</span>
<span class="lineNum">   23434 </span><span class="lineCov">    1943200 :                   if (reg != NULL)</span>
<span class="lineNum">   23435 </span><span class="lineCov">    1932536 :                     add_AT_loc (cdie, DW_AT_location, reg);</span>
<span class="lineNum">   23436 </span><span class="lineCov">      10664 :                   else if (tdie != NULL)</span>
<span class="lineNum">   23437 </span><span class="lineCov">      21328 :                     add_AT_die_ref (cdie, dwarf_AT (DW_AT_call_parameter),</span>
<span class="lineNum">   23438 </span>            :                                     tdie);
<span class="lineNum">   23439 </span><span class="lineCov">    3886396 :                   add_AT_loc (cdie, dwarf_AT (DW_AT_call_value), val);</span>
<span class="lineNum">   23440 </span><span class="lineCov">    1943200 :                   if (next_arg != XEXP (arg, 1))</span>
<span class="lineNum">   23441 </span>            :                     {
<span class="lineNum">   23442 </span><span class="lineCov">       4725 :                       mode = GET_MODE (XEXP (XEXP (XEXP (arg, 1), 0), 1));</span>
<span class="lineNum">   23443 </span><span class="lineCov">       4725 :                       if (mode == VOIDmode)</span>
<span class="lineNum">   23444 </span><span class="lineCov">       3673 :                         mode = GET_MODE (XEXP (XEXP (XEXP (arg, 1), 0), 0));</span>
<span class="lineNum">   23445 </span><span class="lineCov">       4725 :                       val = mem_loc_descriptor (XEXP (XEXP (XEXP (arg, 1),</span>
<span class="lineNum">   23446 </span>            :                                                             0), 1),
<span class="lineNum">   23447 </span>            :                                                 mode, VOIDmode,
<span class="lineNum">   23448 </span>            :                                                 VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   23449 </span><span class="lineCov">       4725 :                       if (val != NULL)</span>
<span class="lineNum">   23450 </span><span class="lineCov">       9450 :                         add_AT_loc (cdie, dwarf_AT (DW_AT_call_data_value),</span>
<span class="lineNum">   23451 </span>            :                                     val);
<span class="lineNum">   23452 </span>            :                     }
<span class="lineNum">   23453 </span>            :                 }
<span class="lineNum">   23454 </span><span class="lineCov">    2157080 :               if (die == NULL</span>
<span class="lineNum">   23455 </span><span class="lineCov">    1066005 :                   &amp;&amp; (ca_loc-&gt;symbol_ref || tloc))</span>
<span class="lineNum">   23456 </span><span class="lineCov">     823839 :                 die = gen_call_site_die (decl, subr_die, ca_loc);</span>
<span class="lineNum">   23457 </span><span class="lineCov">    2157080 :               if (die != NULL &amp;&amp; (tloc != NULL_RTX || tlocc != NULL_RTX))</span>
<span class="lineNum">   23458 </span>            :                 {
<span class="lineNum">   23459 </span><span class="lineCov">       4300 :                   dw_loc_descr_ref tval = NULL;</span>
<span class="lineNum">   23460 </span>            : 
<span class="lineNum">   23461 </span><span class="lineCov">       4300 :                   if (tloc != NULL_RTX)</span>
<span class="lineNum">   23462 </span><span class="lineCov">       4300 :                     tval = mem_loc_descriptor (tloc,</span>
<span class="lineNum">   23463 </span><span class="lineCov">       4300 :                                                GET_MODE (tloc) == VOIDmode</span>
<span class="lineNum">   23464 </span><span class="lineCov">         10 :                                                ? Pmode : GET_MODE (tloc),</span>
<span class="lineNum">   23465 </span>            :                                                VOIDmode,
<span class="lineNum">   23466 </span>            :                                                VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   23467 </span><span class="lineCov">       4300 :                   if (tval)</span>
<span class="lineNum">   23468 </span><span class="lineCov">       8598 :                     add_AT_loc (die, dwarf_AT (DW_AT_call_target), tval);</span>
<span class="lineNum">   23469 </span><span class="lineCov">          1 :                   else if (tlocc != NULL_RTX)</span>
<span class="lineNum">   23470 </span>            :                     {
<span class="lineNum">   23471 </span><span class="lineNoCov">          0 :                       tval = mem_loc_descriptor (tlocc,</span>
<span class="lineNum">   23472 </span><span class="lineNoCov">          0 :                                                  GET_MODE (tlocc) == VOIDmode</span>
<span class="lineNum">   23473 </span><span class="lineNoCov">          0 :                                                  ? Pmode : GET_MODE (tlocc),</span>
<span class="lineNum">   23474 </span>            :                                                  VOIDmode,
<span class="lineNum">   23475 </span>            :                                                  VAR_INIT_STATUS_INITIALIZED);
<span class="lineNum">   23476 </span><span class="lineNoCov">          0 :                       if (tval)</span>
<span class="lineNum">   23477 </span><span class="lineNoCov">          0 :                         add_AT_loc (die,</span>
<span class="lineNum">   23478 </span>            :                                     dwarf_AT (DW_AT_call_target_clobbered),
<span class="lineNum">   23479 </span>            :                                     tval);
<span class="lineNum">   23480 </span>            :                     }
<span class="lineNum">   23481 </span>            :                 }
<span class="lineNum">   23482 </span><span class="lineCov">    2157080 :               if (die != NULL)</span>
<span class="lineNum">   23483 </span>            :                 {
<span class="lineNum">   23484 </span><span class="lineCov">    1914914 :                   call_site_note_count++;</span>
<span class="lineNum">   23485 </span><span class="lineCov">    1914914 :                   if (ca_loc-&gt;tail_call_p)</span>
<span class="lineNum">   23486 </span><span class="lineCov">      33741 :                     tail_call_site_note_count++;</span>
<span class="lineNum">   23487 </span>            :                 }
<span class="lineNum">   23488 </span>            :             }
<span class="lineNum">   23489 </span>            :         }
<span class="lineNum">   23490 </span><span class="lineCov">    1608805 :       call_arg_locations = NULL;</span>
<span class="lineNum">   23491 </span><span class="lineCov">    1608805 :       call_arg_loc_last = NULL;</span>
<span class="lineNum">   23492 </span><span class="lineCov">    1608805 :       if (tail_call_site_count &gt;= 0</span>
<span class="lineNum">   23493 </span><span class="lineCov">     339893 :           &amp;&amp; tail_call_site_count == tail_call_site_note_count</span>
<span class="lineNum">   23494 </span><span class="lineCov">     338477 :           &amp;&amp; (!dwarf_strict || dwarf_version &gt;= 5))</span>
<span class="lineNum">   23495 </span>            :         {
<span class="lineNum">   23496 </span><span class="lineCov">     338462 :           if (call_site_count &gt;= 0</span>
<span class="lineNum">   23497 </span><span class="lineCov">     338462 :               &amp;&amp; call_site_count == call_site_note_count)</span>
<span class="lineNum">   23498 </span><span class="lineCov">     313164 :             add_AT_flag (subr_die, dwarf_AT (DW_AT_call_all_calls), 1);</span>
<span class="lineNum">   23499 </span>            :           else
<span class="lineNum">   23500 </span><span class="lineCov">     363753 :             add_AT_flag (subr_die, dwarf_AT (DW_AT_call_all_tail_calls), 1);</span>
<span class="lineNum">   23501 </span>            :         }
<span class="lineNum">   23502 </span><span class="lineCov">    1608805 :       call_site_count = -1;</span>
<span class="lineNum">   23503 </span><span class="lineCov">    1608805 :       tail_call_site_count = -1;</span>
<span class="lineNum">   23504 </span>            :     }
<span class="lineNum">   23505 </span>            : 
<span class="lineNum">   23506 </span>            :   /* Mark used types after we have created DIEs for the functions scopes.  */
<span class="lineNum">   23507 </span><span class="lineCov">    7961728 :   premark_used_types (DECL_STRUCT_FUNCTION (decl));</span>
<span class="lineNum">   23508 </span>            : }
<span class="lineNum">   23509 </span>            : 
<span class="lineNum">   23510 </span>            : /* Returns a hash value for X (which really is a die_struct).  */
<a name="23511"><span class="lineNum">   23511 </span>            : </a>
<span class="lineNum">   23512 </span>            : hashval_t
<span class="lineNum">   23513 </span><span class="lineCov">        855 : block_die_hasher::hash (die_struct *d)</span>
<span class="lineNum">   23514 </span>            : {
<span class="lineNum">   23515 </span><span class="lineCov">        855 :   return (hashval_t) d-&gt;decl_id ^ htab_hash_pointer (d-&gt;die_parent);</span>
<span class="lineNum">   23516 </span>            : }
<span class="lineNum">   23517 </span>            : 
<span class="lineNum">   23518 </span>            : /* Return nonzero if decl_id and die_parent of die_struct X is the same
<span class="lineNum">   23519 </span>            :    as decl_id and die_parent of die_struct Y.  */
<a name="23520"><span class="lineNum">   23520 </span>            : </a>
<span class="lineNum">   23521 </span>            : bool
<span class="lineNum">   23522 </span><span class="lineCov">        533 : block_die_hasher::equal (die_struct *x, die_struct *y)</span>
<span class="lineNum">   23523 </span>            : {
<span class="lineNum">   23524 </span><span class="lineCov">        533 :   return x-&gt;decl_id == y-&gt;decl_id &amp;&amp; x-&gt;die_parent == y-&gt;die_parent;</span>
<span class="lineNum">   23525 </span>            : }
<span class="lineNum">   23526 </span>            : 
<span class="lineNum">   23527 </span>            : /* Hold information about markers for inlined entry points.  */
<span class="lineNum">   23528 </span>            : struct GTY ((for_user)) inline_entry_data
<span class="lineNum">   23529 </span>            : {
<span class="lineNum">   23530 </span>            :   /* The block that's the inlined_function_outer_scope for an inlined
<span class="lineNum">   23531 </span>            :      function.  */
<span class="lineNum">   23532 </span>            :   tree block;
<span class="lineNum">   23533 </span>            : 
<span class="lineNum">   23534 </span>            :   /* The label at the inlined entry point.  */
<span class="lineNum">   23535 </span>            :   const char *label_pfx;
<span class="lineNum">   23536 </span>            :   unsigned int label_num;
<span class="lineNum">   23537 </span>            : 
<span class="lineNum">   23538 </span>            :   /* The view number to be used as the inlined entry point.  */
<span class="lineNum">   23539 </span>            :   var_loc_view view;
<span class="lineNum">   23540 </span>            : };
<span class="lineNum">   23541 </span>            : 
<span class="lineNum">   23542 </span>            : struct inline_entry_data_hasher : ggc_ptr_hash &lt;inline_entry_data&gt;
<span class="lineNum">   23543 </span>            : {
<span class="lineNum">   23544 </span>            :   typedef tree compare_type;
<span class="lineNum">   23545 </span>            :   static inline hashval_t hash (const inline_entry_data *);
<span class="lineNum">   23546 </span>            :   static inline bool equal (const inline_entry_data *, const_tree);
<span class="lineNum">   23547 </span>            : };
<span class="lineNum">   23548 </span>            : 
<span class="lineNum">   23549 </span>            : /* Hash table routines for inline_entry_data.  */
<a name="23550"><span class="lineNum">   23550 </span>            : </a>
<span class="lineNum">   23551 </span>            : inline hashval_t
<span class="lineNum">   23552 </span><span class="lineNoCov">          0 : inline_entry_data_hasher::hash (const inline_entry_data *data)</span>
<span class="lineNum">   23553 </span>            : {
<span class="lineNum">   23554 </span><span class="lineCov">    2062706 :   return htab_hash_pointer (data-&gt;block);</span>
<span class="lineNum">   23555 </span>            : }
<a name="23556"><span class="lineNum">   23556 </span>            : </a>
<span class="lineNum">   23557 </span>            : inline bool
<span class="lineNum">   23558 </span><span class="lineNoCov">          0 : inline_entry_data_hasher::equal (const inline_entry_data *data,</span>
<span class="lineNum">   23559 </span>            :                                  const_tree block)
<span class="lineNum">   23560 </span>            : {
<span class="lineNum">   23561 </span><span class="lineCov">    6090210 :   return data-&gt;block == block;</span>
<span class="lineNum">   23562 </span>            : }
<span class="lineNum">   23563 </span>            : 
<span class="lineNum">   23564 </span>            : /* Inlined entry points pending DIE creation in this compilation unit.  */
<span class="lineNum">   23565 </span>            : 
<span class="lineNum">   23566 </span>            : static GTY(()) hash_table&lt;inline_entry_data_hasher&gt; *inline_entry_data_table;
<span class="lineNum">   23567 </span>            : 
<span class="lineNum">   23568 </span>            : 
<span class="lineNum">   23569 </span>            : /* Return TRUE if DECL, which may have been previously generated as
<span class="lineNum">   23570 </span>            :    OLD_DIE, is a candidate for a DW_AT_specification.  DECLARATION is
<span class="lineNum">   23571 </span>            :    true if decl (or its origin) is either an extern declaration or a
<span class="lineNum">   23572 </span>            :    class/namespace scoped declaration.
<span class="lineNum">   23573 </span>            : 
<span class="lineNum">   23574 </span>            :    The declare_in_namespace support causes us to get two DIEs for one
<span class="lineNum">   23575 </span>            :    variable, both of which are declarations.  We want to avoid
<span class="lineNum">   23576 </span>            :    considering one to be a specification, so we must test for
<a name="23577"><span class="lineNum">   23577 </span>            :    DECLARATION and DW_AT_declaration.  */</a>
<span class="lineNum">   23578 </span>            : static inline bool
<span class="lineNum">   23579 </span><span class="lineCov">    4410589 : decl_will_get_specification_p (dw_die_ref old_die, tree decl, bool declaration)</span>
<span class="lineNum">   23580 </span>            : {
<span class="lineNum">   23581 </span><span class="lineCov">    2115962 :   return (old_die &amp;&amp; TREE_STATIC (decl) &amp;&amp; !declaration</span>
<span class="lineNum">   23582 </span><span class="lineCov">    5690725 :           &amp;&amp; get_AT_flag (old_die, DW_AT_declaration) == 1);</span>
<span class="lineNum">   23583 </span>            : }
<span class="lineNum">   23584 </span>            : 
<span class="lineNum">   23585 </span>            : /* Return true if DECL is a local static.  */
<a name="23586"><span class="lineNum">   23586 </span>            : </a>
<span class="lineNum">   23587 </span>            : static inline bool
<span class="lineNum">   23588 </span><span class="lineCov">    1658608 : local_function_static (tree decl)</span>
<span class="lineNum">   23589 </span>            : {
<span class="lineNum">   23590 </span><span class="lineCov">    1658608 :   gcc_assert (VAR_P (decl));</span>
<span class="lineNum">   23591 </span><span class="lineCov">    1658608 :   return TREE_STATIC (decl)</span>
<span class="lineNum">   23592 </span><span class="lineCov">    1344229 :     &amp;&amp; DECL_CONTEXT (decl)</span>
<span class="lineNum">   23593 </span><span class="lineCov">    3224212 :     &amp;&amp; TREE_CODE (DECL_CONTEXT (decl)) == FUNCTION_DECL;</span>
<span class="lineNum">   23594 </span>            : }
<span class="lineNum">   23595 </span>            : 
<span class="lineNum">   23596 </span>            : /* Generate a DIE to represent a declared data object.
<span class="lineNum">   23597 </span>            :    Either DECL or ORIGIN must be non-null.  */
<a name="23598"><span class="lineNum">   23598 </span>            : </a>
<span class="lineNum">   23599 </span>            : static void
<span class="lineNum">   23600 </span><span class="lineCov">    4483304 : gen_variable_die (tree decl, tree origin, dw_die_ref context_die)</span>
<span class="lineNum">   23601 </span>            : {
<span class="lineNum">   23602 </span><span class="lineCov">    4483304 :   HOST_WIDE_INT off = 0;</span>
<span class="lineNum">   23603 </span><span class="lineCov">    4483304 :   tree com_decl;</span>
<span class="lineNum">   23604 </span><span class="lineCov">    4483304 :   tree decl_or_origin = decl ? decl : origin;</span>
<span class="lineNum">   23605 </span><span class="lineCov">    4483304 :   tree ultimate_origin;</span>
<span class="lineNum">   23606 </span><span class="lineCov">    4483304 :   dw_die_ref var_die;</span>
<span class="lineNum">   23607 </span><span class="lineCov">    4483304 :   dw_die_ref old_die = decl ? lookup_decl_die (decl) : NULL;</span>
<span class="lineNum">   23608 </span><span class="lineCov">    4483304 :   bool declaration = (DECL_EXTERNAL (decl_or_origin)</span>
<span class="lineNum">   23609 </span><span class="lineCov">    4483304 :                       || class_or_namespace_scope_p (context_die));</span>
<span class="lineNum">   23610 </span><span class="lineCov">    4483304 :   bool specialization_p = false;</span>
<span class="lineNum">   23611 </span><span class="lineCov">    4483304 :   bool no_linkage_name = false;</span>
<span class="lineNum">   23612 </span>            : 
<span class="lineNum">   23613 </span>            :   /* While C++ inline static data members have definitions inside of the
<span class="lineNum">   23614 </span>            :      class, force the first DIE to be a declaration, then let gen_member_die
<span class="lineNum">   23615 </span>            :      reparent it to the class context and call gen_variable_die again
<span class="lineNum">   23616 </span>            :      to create the outside of the class DIE for the definition.  */
<span class="lineNum">   23617 </span><span class="lineCov">    4483304 :   if (!declaration</span>
<span class="lineNum">   23618 </span><span class="lineCov">    4483304 :       &amp;&amp; old_die == NULL</span>
<span class="lineNum">   23619 </span><span class="lineCov">    1963251 :       &amp;&amp; decl</span>
<span class="lineNum">   23620 </span><span class="lineCov">    1963251 :       &amp;&amp; DECL_CONTEXT (decl)</span>
<span class="lineNum">   23621 </span><span class="lineCov">    3604410 :       &amp;&amp; TYPE_P (DECL_CONTEXT (decl))</span>
<span class="lineNum">   23622 </span><span class="lineCov">    4717096 :       &amp;&amp; lang_hooks.decls.decl_dwarf_attribute (decl, DW_AT_inline) != -1)</span>
<span class="lineNum">   23623 </span>            :     {
<span class="lineNum">   23624 </span><span class="lineCov">     233792 :       declaration = true;</span>
<span class="lineNum">   23625 </span><span class="lineCov">     233792 :       if (dwarf_version &lt; 5)</span>
<span class="lineNum">   23626 </span><span class="lineCov">     233788 :         no_linkage_name = true;</span>
<span class="lineNum">   23627 </span>            :     }
<span class="lineNum">   23628 </span>            : 
<span class="lineNum">   23629 </span><span class="lineCov">    4483304 :   ultimate_origin = decl_ultimate_origin (decl_or_origin);</span>
<span class="lineNum">   23630 </span><span class="lineCov">    4483304 :   if (decl || ultimate_origin)</span>
<span class="lineNum">   23631 </span><span class="lineCov">    4483293 :     origin = ultimate_origin;</span>
<span class="lineNum">   23632 </span><span class="lineCov">    4483304 :   com_decl = fortran_common (decl_or_origin, &amp;off);</span>
<span class="lineNum">   23633 </span>            : 
<span class="lineNum">   23634 </span>            :   /* Symbol in common gets emitted as a child of the common block, in the form
<span class="lineNum">   23635 </span>            :      of a data member.  */
<span class="lineNum">   23636 </span><span class="lineCov">    4483304 :   if (com_decl)</span>
<span class="lineNum">   23637 </span>            :     {
<span class="lineNum">   23638 </span><span class="lineCov">        982 :       dw_die_ref com_die;</span>
<span class="lineNum">   23639 </span><span class="lineCov">        982 :       dw_loc_list_ref loc = NULL;</span>
<span class="lineNum">   23640 </span><span class="lineCov">        982 :       die_node com_die_arg;</span>
<span class="lineNum">   23641 </span>            : 
<span class="lineNum">   23642 </span><span class="lineCov">        982 :       var_die = lookup_decl_die (decl_or_origin);</span>
<span class="lineNum">   23643 </span><span class="lineCov">        982 :       if (var_die)</span>
<span class="lineNum">   23644 </span>            :         {
<span class="lineNum">   23645 </span><span class="lineCov">        351 :           if (! early_dwarf &amp;&amp; get_AT (var_die, DW_AT_location) == NULL)</span>
<span class="lineNum">   23646 </span>            :             {
<span class="lineNum">   23647 </span><span class="lineCov">        412 :               loc = loc_list_from_tree (com_decl, off ? 1 : 2, NULL);</span>
<span class="lineNum">   23648 </span><span class="lineCov">        343 :               if (loc)</span>
<span class="lineNum">   23649 </span>            :                 {
<span class="lineNum">   23650 </span><span class="lineCov">        343 :                   if (off)</span>
<span class="lineNum">   23651 </span>            :                     {
<span class="lineNum">   23652 </span>            :                       /* Optimize the common case.  */
<span class="lineNum">   23653 </span><span class="lineCov">        274 :                       if (single_element_loc_list_p (loc)</span>
<span class="lineNum">   23654 </span><span class="lineCov">        274 :                           &amp;&amp; loc-&gt;expr-&gt;dw_loc_opc == DW_OP_addr</span>
<span class="lineNum">   23655 </span><span class="lineCov">        274 :                           &amp;&amp; loc-&gt;expr-&gt;dw_loc_next == NULL</span>
<span class="lineNum">   23656 </span><span class="lineCov">        548 :                           &amp;&amp; GET_CODE (loc-&gt;expr-&gt;dw_loc_oprnd1.v.val_addr)</span>
<span class="lineNum">   23657 </span>            :                              == SYMBOL_REF)
<span class="lineNum">   23658 </span>            :                         {
<span class="lineNum">   23659 </span><span class="lineCov">        274 :                           rtx x = loc-&gt;expr-&gt;dw_loc_oprnd1.v.val_addr;</span>
<span class="lineNum">   23660 </span><span class="lineCov">        274 :                           loc-&gt;expr-&gt;dw_loc_oprnd1.v.val_addr</span>
<span class="lineNum">   23661 </span><span class="lineCov">        548 :                             = plus_constant (GET_MODE (x), x , off);</span>
<span class="lineNum">   23662 </span>            :                         }
<span class="lineNum">   23663 </span>            :                       else
<span class="lineNum">   23664 </span><span class="lineNoCov">          0 :                         loc_list_plus_const (loc, off);</span>
<span class="lineNum">   23665 </span>            :                     }
<span class="lineNum">   23666 </span><span class="lineCov">        343 :                   add_AT_location_description (var_die, DW_AT_location, loc);</span>
<span class="lineNum">   23667 </span><span class="lineCov">        343 :                   remove_AT (var_die, DW_AT_declaration);</span>
<span class="lineNum">   23668 </span>            :                 }
<span class="lineNum">   23669 </span>            :             }
<span class="lineNum">   23670 </span><span class="lineCov">        351 :           return;</span>
<span class="lineNum">   23671 </span>            :         }
<span class="lineNum">   23672 </span>            : 
<span class="lineNum">   23673 </span><span class="lineCov">        631 :       if (common_block_die_table == NULL)</span>
<span class="lineNum">   23674 </span><span class="lineCov">         95 :         common_block_die_table = hash_table&lt;block_die_hasher&gt;::create_ggc (10);</span>
<span class="lineNum">   23675 </span>            : 
<span class="lineNum">   23676 </span><span class="lineCov">        631 :       com_die_arg.decl_id = DECL_UID (com_decl);</span>
<span class="lineNum">   23677 </span><span class="lineCov">        631 :       com_die_arg.die_parent = context_die;</span>
<span class="lineNum">   23678 </span><span class="lineCov">        631 :       com_die = common_block_die_table-&gt;find (&amp;com_die_arg);</span>
<span class="lineNum">   23679 </span><span class="lineCov">        631 :       if (! early_dwarf)</span>
<span class="lineNum">   23680 </span><span class="lineNoCov">          0 :         loc = loc_list_from_tree (com_decl, 2, NULL);</span>
<span class="lineNum">   23681 </span><span class="lineCov">        631 :       if (com_die == NULL)</span>
<span class="lineNum">   23682 </span>            :         {
<span class="lineNum">   23683 </span><span class="lineCov">        214 :           const char *cnam</span>
<span class="lineNum">   23684 </span><span class="lineCov">        214 :             = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (com_decl));</span>
<span class="lineNum">   23685 </span><span class="lineCov">        214 :           die_node **slot;</span>
<span class="lineNum">   23686 </span>            : 
<span class="lineNum">   23687 </span><span class="lineCov">        214 :           com_die = new_die (DW_TAG_common_block, context_die, decl);</span>
<span class="lineNum">   23688 </span><span class="lineCov">        214 :           add_name_and_src_coords_attributes (com_die, com_decl);</span>
<span class="lineNum">   23689 </span><span class="lineCov">        214 :           if (loc)</span>
<span class="lineNum">   23690 </span>            :             {
<span class="lineNum">   23691 </span><span class="lineNoCov">          0 :               add_AT_location_description (com_die, DW_AT_location, loc);</span>
<span class="lineNum">   23692 </span>            :               /* Avoid sharing the same loc descriptor between
<span class="lineNum">   23693 </span>            :                  DW_TAG_common_block and DW_TAG_variable.  */
<span class="lineNum">   23694 </span><span class="lineNoCov">          0 :               loc = loc_list_from_tree (com_decl, 2, NULL);</span>
<span class="lineNum">   23695 </span>            :             }
<span class="lineNum">   23696 </span><span class="lineCov">        214 :           else if (DECL_EXTERNAL (decl_or_origin))</span>
<span class="lineNum">   23697 </span><span class="lineCov">          7 :             add_AT_flag (com_die, DW_AT_declaration, 1);</span>
<span class="lineNum">   23698 </span><span class="lineCov">        428 :           if (want_pubnames ())</span>
<span class="lineNum">   23699 </span><span class="lineNoCov">          0 :             add_pubname_string (cnam, com_die); /* ??? needed? */</span>
<span class="lineNum">   23700 </span><span class="lineCov">        214 :           com_die-&gt;decl_id = DECL_UID (com_decl);</span>
<span class="lineNum">   23701 </span><span class="lineCov">        214 :           slot = common_block_die_table-&gt;find_slot (com_die, INSERT);</span>
<span class="lineNum">   23702 </span><span class="lineCov">        214 :           *slot = com_die;</span>
<span class="lineNum">   23703 </span>            :         }
<span class="lineNum">   23704 </span><span class="lineCov">        417 :       else if (get_AT (com_die, DW_AT_location) == NULL &amp;&amp; loc)</span>
<span class="lineNum">   23705 </span>            :         {
<span class="lineNum">   23706 </span><span class="lineNoCov">          0 :           add_AT_location_description (com_die, DW_AT_location, loc);</span>
<span class="lineNum">   23707 </span><span class="lineNoCov">          0 :           loc = loc_list_from_tree (com_decl, 2, NULL);</span>
<span class="lineNum">   23708 </span><span class="lineNoCov">          0 :           remove_AT (com_die, DW_AT_declaration);</span>
<span class="lineNum">   23709 </span>            :         }
<span class="lineNum">   23710 </span><span class="lineCov">        631 :       var_die = new_die (DW_TAG_variable, com_die, decl);</span>
<span class="lineNum">   23711 </span><span class="lineCov">        631 :       add_name_and_src_coords_attributes (var_die, decl_or_origin);</span>
<span class="lineNum">   23712 </span><span class="lineCov">        631 :       add_type_attribute (var_die, TREE_TYPE (decl_or_origin),</span>
<span class="lineNum">   23713 </span>            :                           decl_quals (decl_or_origin), false,
<span class="lineNum">   23714 </span>            :                           context_die);
<span class="lineNum">   23715 </span><span class="lineCov">        631 :       add_alignment_attribute (var_die, decl);</span>
<span class="lineNum">   23716 </span><span class="lineCov">        631 :       add_AT_flag (var_die, DW_AT_external, 1);</span>
<span class="lineNum">   23717 </span><span class="lineCov">        631 :       if (loc)</span>
<span class="lineNum">   23718 </span>            :         {
<span class="lineNum">   23719 </span><span class="lineNoCov">          0 :           if (off)</span>
<span class="lineNum">   23720 </span>            :             {
<span class="lineNum">   23721 </span>            :               /* Optimize the common case.  */
<span class="lineNum">   23722 </span><span class="lineNoCov">          0 :               if (single_element_loc_list_p (loc)</span>
<span class="lineNum">   23723 </span><span class="lineNoCov">          0 :                   &amp;&amp; loc-&gt;expr-&gt;dw_loc_opc == DW_OP_addr</span>
<span class="lineNum">   23724 </span><span class="lineNoCov">          0 :                   &amp;&amp; loc-&gt;expr-&gt;dw_loc_next == NULL</span>
<span class="lineNum">   23725 </span><span class="lineNoCov">          0 :                   &amp;&amp; GET_CODE (loc-&gt;expr-&gt;dw_loc_oprnd1.v.val_addr) == SYMBOL_REF)</span>
<span class="lineNum">   23726 </span>            :                 {
<span class="lineNum">   23727 </span><span class="lineNoCov">          0 :                   rtx x = loc-&gt;expr-&gt;dw_loc_oprnd1.v.val_addr;</span>
<span class="lineNum">   23728 </span><span class="lineNoCov">          0 :                   loc-&gt;expr-&gt;dw_loc_oprnd1.v.val_addr</span>
<span class="lineNum">   23729 </span><span class="lineNoCov">          0 :                     = plus_constant (GET_MODE (x), x, off);</span>
<span class="lineNum">   23730 </span>            :                 }
<span class="lineNum">   23731 </span>            :               else
<span class="lineNum">   23732 </span><span class="lineNoCov">          0 :                 loc_list_plus_const (loc, off);</span>
<span class="lineNum">   23733 </span>            :             }
<span class="lineNum">   23734 </span><span class="lineNoCov">          0 :           add_AT_location_description (var_die, DW_AT_location, loc);</span>
<span class="lineNum">   23735 </span>            :         }
<span class="lineNum">   23736 </span><span class="lineCov">        631 :       else if (DECL_EXTERNAL (decl_or_origin))</span>
<span class="lineNum">   23737 </span><span class="lineCov">          8 :         add_AT_flag (var_die, DW_AT_declaration, 1);</span>
<span class="lineNum">   23738 </span><span class="lineCov">        631 :       if (decl)</span>
<span class="lineNum">   23739 </span><span class="lineCov">        631 :         equate_decl_number_to_die (decl, var_die);</span>
<span class="lineNum">   23740 </span><span class="lineCov">        631 :       return;</span>
<span class="lineNum">   23741 </span>            :     }
<span class="lineNum">   23742 </span>            : 
<span class="lineNum">   23743 </span><span class="lineCov">    4482322 :   if (old_die)</span>
<span class="lineNum">   23744 </span>            :     {
<span class="lineNum">   23745 </span><span class="lineCov">    1708934 :       if (declaration)</span>
<span class="lineNum">   23746 </span>            :         {
<span class="lineNum">   23747 </span>            :           /* A declaration that has been previously dumped, needs no
<span class="lineNum">   23748 </span>            :              further annotations, since it doesn't need location on
<span class="lineNum">   23749 </span>            :              the second pass.  */
<span class="lineNum">   23750 </span>            :           return;
<span class="lineNum">   23751 </span>            :         }
<span class="lineNum">   23752 </span><span class="lineCov">    1545043 :       else if (decl_will_get_specification_p (old_die, decl, declaration)</span>
<span class="lineNum">   23753 </span><span class="lineCov">    1545043 :                &amp;&amp; !get_AT (old_die, DW_AT_specification))</span>
<span class="lineNum">   23754 </span>            :         {
<span class="lineNum">   23755 </span>            :           /* Fall-thru so we can make a new variable die along with a
<span class="lineNum">   23756 </span>            :              DW_AT_specification.  */
<span class="lineNum">   23757 </span>            :         }
<span class="lineNum">   23758 </span><span class="lineCov">     974124 :       else if (origin &amp;&amp; old_die-&gt;die_parent != context_die)</span>
<span class="lineNum">   23759 </span>            :         {
<span class="lineNum">   23760 </span>            :           /* If we will be creating an inlined instance, we need a
<span class="lineNum">   23761 </span>            :              new DIE that will get annotated with
<span class="lineNum">   23762 </span>            :              DW_AT_abstract_origin.  */
<span class="lineNum">   23763 </span><span class="lineCov">      35036 :           gcc_assert (!DECL_ABSTRACT_P (decl));</span>
<span class="lineNum">   23764 </span>            :         }
<span class="lineNum">   23765 </span>            :       else
<span class="lineNum">   23766 </span>            :         {
<span class="lineNum">   23767 </span>            :           /* If a DIE was dumped early, it still needs location info.
<span class="lineNum">   23768 </span>            :              Skip to where we fill the location bits.  */
<span class="lineNum">   23769 </span><span class="lineCov">     939088 :           var_die = old_die;</span>
<span class="lineNum">   23770 </span>            : 
<span class="lineNum">   23771 </span>            :           /* ???  In LTRANS we cannot annotate early created variably
<span class="lineNum">   23772 </span>            :              modified type DIEs without copying them and adjusting all
<span class="lineNum">   23773 </span>            :              references to them.  Thus we dumped them again.  Also add a
<span class="lineNum">   23774 </span>            :              reference to them but beware of -g0 compile and -g link
<span class="lineNum">   23775 </span>            :              in which case the reference will be already present.  */
<span class="lineNum">   23776 </span><span class="lineCov">     939088 :           tree type = TREE_TYPE (decl_or_origin);</span>
<span class="lineNum">   23777 </span><span class="lineCov">     939088 :           if (in_lto_p</span>
<span class="lineNum">   23778 </span><span class="lineCov">       2236 :               &amp;&amp; ! get_AT (var_die, DW_AT_type)</span>
<span class="lineNum">   23779 </span><span class="lineCov">     941324 :               &amp;&amp; variably_modified_type_p</span>
<span class="lineNum">   23780 </span><span class="lineCov">       2236 :                    (type, decl_function_context (decl_or_origin)))</span>
<span class="lineNum">   23781 </span>            :             {
<span class="lineNum">   23782 </span><span class="lineCov">         46 :               if (decl_by_reference_p (decl_or_origin))</span>
<span class="lineNum">   23783 </span><span class="lineCov">          4 :                 add_type_attribute (var_die, TREE_TYPE (type),</span>
<span class="lineNum">   23784 </span>            :                                     TYPE_UNQUALIFIED, false, context_die);
<span class="lineNum">   23785 </span>            :               else
<span class="lineNum">   23786 </span><span class="lineCov">         42 :                 add_type_attribute (var_die, type, decl_quals (decl_or_origin),</span>
<span class="lineNum">   23787 </span>            :                                     false, context_die);
<span class="lineNum">   23788 </span>            :             }
<span class="lineNum">   23789 </span>            : 
<span class="lineNum">   23790 </span><span class="lineCov">     939088 :           goto gen_variable_die_location;</span>
<span class="lineNum">   23791 </span>            :         }
<span class="lineNum">   23792 </span>            :     }
<span class="lineNum">   23793 </span>            : 
<span class="lineNum">   23794 </span>            :   /* For static data members, the declaration in the class is supposed
<span class="lineNum">   23795 </span>            :      to have DW_TAG_member tag in DWARF{3,4} and we emit it for compatibility
<span class="lineNum">   23796 </span>            :      also in DWARF2; the specification should still be DW_TAG_variable
<span class="lineNum">   23797 </span>            :      referencing the DW_TAG_member DIE.  */
<span class="lineNum">   23798 </span><span class="lineCov">    3844067 :   if (declaration &amp;&amp; class_scope_p (context_die) &amp;&amp; dwarf_version &lt; 5)</span>
<span class="lineNum">   23799 </span><span class="lineCov">     464715 :     var_die = new_die (DW_TAG_member, context_die, decl);</span>
<span class="lineNum">   23800 </span>            :   else
<span class="lineNum">   23801 </span><span class="lineCov">    2914628 :     var_die = new_die (DW_TAG_variable, context_die, decl);</span>
<span class="lineNum">   23802 </span>            : 
<span class="lineNum">   23803 </span><span class="lineCov">    3379343 :   if (origin != NULL)</span>
<span class="lineNum">   23804 </span><span class="lineCov">     513797 :     add_abstract_origin_attribute (var_die, origin);</span>
<span class="lineNum">   23805 </span>            : 
<span class="lineNum">   23806 </span>            :   /* Loop unrolling can create multiple blocks that refer to the same
<span class="lineNum">   23807 </span>            :      static variable, so we must test for the DW_AT_declaration flag.
<span class="lineNum">   23808 </span>            : 
<span class="lineNum">   23809 </span>            :      ??? Loop unrolling/reorder_blocks should perhaps be rewritten to
<span class="lineNum">   23810 </span>            :      copy decls and set the DECL_ABSTRACT_P flag on them instead of
<span class="lineNum">   23811 </span>            :      sharing them.
<span class="lineNum">   23812 </span>            : 
<span class="lineNum">   23813 </span>            :      ??? Duplicated blocks have been rewritten to use .debug_ranges.  */
<span class="lineNum">   23814 </span><span class="lineCov">    2865546 :   else if (decl_will_get_specification_p (old_die, decl, declaration))</span>
<span class="lineNum">   23815 </span>            :     {
<span class="lineNum">   23816 </span>            :       /* This is a definition of a C++ class level static.  */
<span class="lineNum">   23817 </span><span class="lineCov">     570919 :       add_AT_specification (var_die, old_die);</span>
<span class="lineNum">   23818 </span><span class="lineCov">     570919 :       specialization_p = true;</span>
<span class="lineNum">   23819 </span><span class="lineCov">     570919 :       if (DECL_NAME (decl))</span>
<span class="lineNum">   23820 </span>            :         {
<span class="lineNum">   23821 </span><span class="lineCov">    1141838 :           expanded_location s = expand_location (DECL_SOURCE_LOCATION (decl));</span>
<span class="lineNum">   23822 </span><span class="lineCov">     570919 :           struct dwarf_file_data * file_index = lookup_filename (s.file);</span>
<span class="lineNum">   23823 </span>            : 
<span class="lineNum">   23824 </span><span class="lineCov">     570919 :           if (get_AT_file (old_die, DW_AT_decl_file) != file_index)</span>
<span class="lineNum">   23825 </span><span class="lineCov">       3168 :             add_AT_file (var_die, DW_AT_decl_file, file_index);</span>
<span class="lineNum">   23826 </span>            : 
<span class="lineNum">   23827 </span><span class="lineCov">     570919 :           if (get_AT_unsigned (old_die, DW_AT_decl_line) != (unsigned) s.line)</span>
<span class="lineNum">   23828 </span><span class="lineCov">       3926 :             add_AT_unsigned (var_die, DW_AT_decl_line, s.line);</span>
<span class="lineNum">   23829 </span>            : 
<span class="lineNum">   23830 </span><span class="lineCov">     570919 :           if (debug_column_info</span>
<span class="lineNum">   23831 </span><span class="lineCov">     570919 :               &amp;&amp; s.column</span>
<span class="lineNum">   23832 </span><span class="lineCov">    1141781 :               &amp;&amp; (get_AT_unsigned (old_die, DW_AT_decl_column)</span>
<span class="lineNum">   23833 </span><span class="lineCov">     570862 :                   != (unsigned) s.column))</span>
<span class="lineNum">   23834 </span><span class="lineCov">       3818 :             add_AT_unsigned (var_die, DW_AT_decl_column, s.column);</span>
<span class="lineNum">   23835 </span>            : 
<span class="lineNum">   23836 </span><span class="lineCov">     570919 :           if (old_die-&gt;die_tag == DW_TAG_member)</span>
<span class="lineNum">   23837 </span><span class="lineCov">     527380 :             add_linkage_name (var_die, decl);</span>
<span class="lineNum">   23838 </span>            :         }
<span class="lineNum">   23839 </span>            :     }
<span class="lineNum">   23840 </span>            :   else
<span class="lineNum">   23841 </span><span class="lineCov">    2294627 :     add_name_and_src_coords_attributes (var_die, decl, no_linkage_name);</span>
<span class="lineNum">   23842 </span>            : 
<span class="lineNum">   23843 </span><span class="lineCov">    3379343 :   if ((origin == NULL &amp;&amp; !specialization_p)</span>
<span class="lineNum">   23844 </span><span class="lineCov">    3379343 :       || (origin != NULL</span>
<span class="lineNum">   23845 </span><span class="lineCov">     513797 :           &amp;&amp; !DECL_ABSTRACT_P (decl_or_origin)</span>
<span class="lineNum">   23846 </span><span class="lineCov">     513797 :           &amp;&amp; variably_modified_type_p (TREE_TYPE (decl_or_origin),</span>
<span class="lineNum">   23847 </span>            :                                        decl_function_context
<span class="lineNum">   23848 </span>            :                                                         (decl_or_origin))))
<span class="lineNum">   23849 </span>            :     {
<span class="lineNum">   23850 </span><span class="lineCov">    2295394 :       tree type = TREE_TYPE (decl_or_origin);</span>
<span class="lineNum">   23851 </span>            : 
<span class="lineNum">   23852 </span><span class="lineCov">    2295394 :       if (decl_by_reference_p (decl_or_origin))</span>
<span class="lineNum">   23853 </span><span class="lineCov">        683 :         add_type_attribute (var_die, TREE_TYPE (type), TYPE_UNQUALIFIED, false,</span>
<span class="lineNum">   23854 </span>            :                             context_die);
<span class="lineNum">   23855 </span>            :       else
<span class="lineNum">   23856 </span><span class="lineCov">    2294711 :         add_type_attribute (var_die, type, decl_quals (decl_or_origin), false,</span>
<span class="lineNum">   23857 </span>            :                             context_die);
<span class="lineNum">   23858 </span>            :     }
<span class="lineNum">   23859 </span>            : 
<span class="lineNum">   23860 </span><span class="lineCov">    3379343 :   if (origin == NULL &amp;&amp; !specialization_p)</span>
<span class="lineNum">   23861 </span>            :     {
<span class="lineNum">   23862 </span><span class="lineCov">    2294627 :       if (TREE_PUBLIC (decl))</span>
<span class="lineNum">   23863 </span><span class="lineCov">    1160743 :         add_AT_flag (var_die, DW_AT_external, 1);</span>
<span class="lineNum">   23864 </span>            : 
<span class="lineNum">   23865 </span><span class="lineCov">    2294627 :       if (DECL_ARTIFICIAL (decl))</span>
<span class="lineNum">   23866 </span><span class="lineCov">      56061 :         add_AT_flag (var_die, DW_AT_artificial, 1);</span>
<span class="lineNum">   23867 </span>            : 
<span class="lineNum">   23868 </span><span class="lineCov">    2294627 :       add_alignment_attribute (var_die, decl);</span>
<span class="lineNum">   23869 </span>            : 
<span class="lineNum">   23870 </span><span class="lineCov">    2294627 :       add_accessibility_attribute (var_die, decl);</span>
<span class="lineNum">   23871 </span>            :     }
<span class="lineNum">   23872 </span>            : 
<span class="lineNum">   23873 </span><span class="lineCov">    3379343 :   if (declaration)</span>
<span class="lineNum">   23874 </span><span class="lineCov">    1044552 :     add_AT_flag (var_die, DW_AT_declaration, 1);</span>
<span class="lineNum">   23875 </span>            : 
<span class="lineNum">   23876 </span><span class="lineCov">    3379343 :   if (decl &amp;&amp; (DECL_ABSTRACT_P (decl)</span>
<span class="lineNum">   23877 </span><span class="lineCov">    3985287 :                || !old_die || is_declaration_die (old_die)))</span>
<span class="lineNum">   23878 </span><span class="lineCov">    3344296 :     equate_decl_number_to_die (decl, var_die);</span>
<span class="lineNum">   23879 </span>            : 
<span class="lineNum">   23880 </span><span class="lineCov">    4318431 :  gen_variable_die_location:</span>
<span class="lineNum">   23881 </span><span class="lineCov">    4318431 :   if (! declaration</span>
<span class="lineNum">   23882 </span><span class="lineCov">    4318431 :       &amp;&amp; (! DECL_ABSTRACT_P (decl_or_origin)</span>
<span class="lineNum">   23883 </span>            :           /* Local static vars are shared between all clones/inlines,
<span class="lineNum">   23884 </span>            :              so emit DW_AT_location on the abstract DIE if DECL_RTL is
<span class="lineNum">   23885 </span>            :              already set.  */
<span class="lineNum">   23886 </span><span class="lineNoCov">          0 :           || (VAR_P (decl_or_origin)</span>
<span class="lineNum">   23887 </span><span class="lineNoCov">          0 :               &amp;&amp; TREE_STATIC (decl_or_origin)</span>
<span class="lineNum">   23888 </span><span class="lineNoCov">          0 :               &amp;&amp; DECL_RTL_SET_P (decl_or_origin))))</span>
<span class="lineNum">   23889 </span>            :     {
<span class="lineNum">   23890 </span><span class="lineCov">    3273879 :       if (early_dwarf)</span>
<span class="lineNum">   23891 </span><span class="lineCov">    1945260 :         add_pubname (decl_or_origin, var_die);</span>
<span class="lineNum">   23892 </span>            :       else
<span class="lineNum">   23893 </span><span class="lineCov">    1328619 :         add_location_or_const_value_attribute (var_die, decl_or_origin,</span>
<span class="lineNum">   23894 </span>            :                                                decl == NULL);
<span class="lineNum">   23895 </span>            :     }
<span class="lineNum">   23896 </span>            :   else
<span class="lineNum">   23897 </span><span class="lineCov">    1044552 :     tree_add_const_value_attribute_for_decl (var_die, decl_or_origin);</span>
<span class="lineNum">   23898 </span>            : 
<span class="lineNum">   23899 </span><span class="lineCov">       6961 :   if ((dwarf_version &gt;= 4 || !dwarf_strict)</span>
<span class="lineNum">   23900 </span><span class="lineCov">    4318431 :       &amp;&amp; lang_hooks.decls.decl_dwarf_attribute (decl_or_origin,</span>
<span class="lineNum">   23901 </span>            :                                                 DW_AT_const_expr) == 1
<span class="lineNum">   23902 </span><span class="lineCov">    1044475 :       &amp;&amp; !get_AT (var_die, DW_AT_const_expr)</span>
<span class="lineNum">   23903 </span><span class="lineCov">    4888065 :       &amp;&amp; !specialization_p)</span>
<span class="lineNum">   23904 </span><span class="lineCov">     569634 :     add_AT_flag (var_die, DW_AT_const_expr, 1);</span>
<span class="lineNum">   23905 </span>            : 
<span class="lineNum">   23906 </span><span class="lineCov">    4318431 :   if (!dwarf_strict)</span>
<span class="lineNum">   23907 </span>            :     {
<span class="lineNum">   23908 </span><span class="lineCov">    4318429 :       int inl = lang_hooks.decls.decl_dwarf_attribute (decl_or_origin,</span>
<span class="lineNum">   23909 </span>            :                                                        DW_AT_inline);
<span class="lineNum">   23910 </span><span class="lineCov">    4318429 :       if (inl != -1</span>
<span class="lineNum">   23911 </span><span class="lineCov">     525134 :           &amp;&amp; !get_AT (var_die, DW_AT_inline)</span>
<span class="lineNum">   23912 </span><span class="lineCov">    4577261 :           &amp;&amp; !specialization_p)</span>
<span class="lineNum">   23913 </span><span class="lineCov">     258832 :         add_AT_unsigned (var_die, DW_AT_inline, inl);</span>
<span class="lineNum">   23914 </span>            :     }
<span class="lineNum">   23915 </span>            : }
<span class="lineNum">   23916 </span>            : 
<span class="lineNum">   23917 </span>            : /* Generate a DIE to represent a named constant.  */
<a name="23918"><span class="lineNum">   23918 </span>            : </a>
<span class="lineNum">   23919 </span>            : static void
<span class="lineNum">   23920 </span><span class="lineCov">      15121 : gen_const_die (tree decl, dw_die_ref context_die)</span>
<span class="lineNum">   23921 </span>            : {
<span class="lineNum">   23922 </span><span class="lineCov">      15121 :   dw_die_ref const_die;</span>
<span class="lineNum">   23923 </span><span class="lineCov">      15121 :   tree type = TREE_TYPE (decl);</span>
<span class="lineNum">   23924 </span>            : 
<span class="lineNum">   23925 </span><span class="lineCov">      15121 :   const_die = lookup_decl_die (decl);</span>
<span class="lineNum">   23926 </span><span class="lineCov">      15121 :   if (const_die)</span>
<span class="lineNum">   23927 </span>            :     return;
<span class="lineNum">   23928 </span>            : 
<span class="lineNum">   23929 </span><span class="lineCov">      11791 :   const_die = new_die (DW_TAG_constant, context_die, decl);</span>
<span class="lineNum">   23930 </span><span class="lineCov">      11791 :   equate_decl_number_to_die (decl, const_die);</span>
<span class="lineNum">   23931 </span><span class="lineCov">      11791 :   add_name_and_src_coords_attributes (const_die, decl);</span>
<span class="lineNum">   23932 </span><span class="lineCov">      11791 :   add_type_attribute (const_die, type, TYPE_QUAL_CONST, false, context_die);</span>
<span class="lineNum">   23933 </span><span class="lineCov">      11791 :   if (TREE_PUBLIC (decl))</span>
<span class="lineNum">   23934 </span><span class="lineCov">        126 :     add_AT_flag (const_die, DW_AT_external, 1);</span>
<span class="lineNum">   23935 </span><span class="lineCov">      11791 :   if (DECL_ARTIFICIAL (decl))</span>
<span class="lineNum">   23936 </span><span class="lineNoCov">          0 :     add_AT_flag (const_die, DW_AT_artificial, 1);</span>
<span class="lineNum">   23937 </span><span class="lineCov">      11791 :   tree_add_const_value_attribute_for_decl (const_die, decl);</span>
<span class="lineNum">   23938 </span>            : }
<span class="lineNum">   23939 </span>            : 
<span class="lineNum">   23940 </span>            : /* Generate a DIE to represent a label identifier.  */
<a name="23941"><span class="lineNum">   23941 </span>            : </a>
<span class="lineNum">   23942 </span>            : static void
<span class="lineNum">   23943 </span><span class="lineCov">       3873 : gen_label_die (tree decl, dw_die_ref context_die)</span>
<span class="lineNum">   23944 </span>            : {
<span class="lineNum">   23945 </span><span class="lineCov">       3873 :   tree origin = decl_ultimate_origin (decl);</span>
<span class="lineNum">   23946 </span><span class="lineCov">       3873 :   dw_die_ref lbl_die = lookup_decl_die (decl);</span>
<span class="lineNum">   23947 </span><span class="lineCov">       3873 :   rtx insn;</span>
<span class="lineNum">   23948 </span><span class="lineCov">       3873 :   char label[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">   23949 </span>            : 
<span class="lineNum">   23950 </span><span class="lineCov">       3873 :   if (!lbl_die)</span>
<span class="lineNum">   23951 </span>            :     {
<span class="lineNum">   23952 </span><span class="lineCov">       2414 :       lbl_die = new_die (DW_TAG_label, context_die, decl);</span>
<span class="lineNum">   23953 </span><span class="lineCov">       2414 :       equate_decl_number_to_die (decl, lbl_die);</span>
<span class="lineNum">   23954 </span>            : 
<span class="lineNum">   23955 </span><span class="lineCov">       2414 :       if (origin != NULL)</span>
<span class="lineNum">   23956 </span><span class="lineCov">        651 :         add_abstract_origin_attribute (lbl_die, origin);</span>
<span class="lineNum">   23957 </span>            :       else
<span class="lineNum">   23958 </span><span class="lineCov">       1763 :         add_name_and_src_coords_attributes (lbl_die, decl);</span>
<span class="lineNum">   23959 </span>            :     }
<span class="lineNum">   23960 </span>            : 
<span class="lineNum">   23961 </span><span class="lineCov">       3873 :   if (DECL_ABSTRACT_P (decl))</span>
<span class="lineNum">   23962 </span><span class="lineNoCov">          0 :     equate_decl_number_to_die (decl, lbl_die);</span>
<span class="lineNum">   23963 </span><span class="lineCov">       3873 :   else if (! early_dwarf)</span>
<span class="lineNum">   23964 </span>            :     {
<span class="lineNum">   23965 </span><span class="lineCov">       2110 :       insn = DECL_RTL_IF_SET (decl);</span>
<span class="lineNum">   23966 </span>            : 
<span class="lineNum">   23967 </span>            :       /* Deleted labels are programmer specified labels which have been
<span class="lineNum">   23968 </span>            :          eliminated because of various optimizations.  We still emit them
<span class="lineNum">   23969 </span>            :          here so that it is possible to put breakpoints on them.  */
<span class="lineNum">   23970 </span><span class="lineCov">       1645 :       if (insn</span>
<span class="lineNum">   23971 </span><span class="lineCov">       1645 :           &amp;&amp; (LABEL_P (insn)</span>
<span class="lineNum">   23972 </span><span class="lineCov">        648 :               || ((NOTE_P (insn)</span>
<span class="lineNum">   23973 </span><span class="lineCov">        648 :                    &amp;&amp; NOTE_KIND (insn) == NOTE_INSN_DELETED_LABEL))))</span>
<span class="lineNum">   23974 </span>            :         {
<span class="lineNum">   23975 </span>            :           /* When optimization is enabled (via -O) some parts of the compiler
<span class="lineNum">   23976 </span>            :              (e.g. jump.c and cse.c) may try to delete CODE_LABEL insns which
<span class="lineNum">   23977 </span>            :              represent source-level labels which were explicitly declared by
<span class="lineNum">   23978 </span>            :              the user.  This really shouldn't be happening though, so catch
<span class="lineNum">   23979 </span>            :              it if it ever does happen.  */
<span class="lineNum">   23980 </span><span class="lineCov">       1261 :           gcc_assert (!as_a&lt;rtx_insn *&gt; (insn)-&gt;deleted ());</span>
<span class="lineNum">   23981 </span>            : 
<span class="lineNum">   23982 </span><span class="lineCov">       1261 :           ASM_GENERATE_INTERNAL_LABEL (label, &quot;L&quot;, CODE_LABEL_NUMBER (insn));</span>
<span class="lineNum">   23983 </span><span class="lineCov">       1261 :           add_AT_lbl_id (lbl_die, DW_AT_low_pc, label);</span>
<span class="lineNum">   23984 </span>            :         }
<span class="lineNum">   23985 </span><span class="lineCov">        849 :       else if (insn</span>
<span class="lineNum">   23986 </span><span class="lineCov">        384 :                &amp;&amp; NOTE_P (insn)</span>
<span class="lineNum">   23987 </span><span class="lineCov">        384 :                &amp;&amp; NOTE_KIND (insn) == NOTE_INSN_DELETED_DEBUG_LABEL</span>
<span class="lineNum">   23988 </span><span class="lineCov">        384 :                &amp;&amp; CODE_LABEL_NUMBER (insn) != -1)</span>
<span class="lineNum">   23989 </span>            :         {
<span class="lineNum">   23990 </span><span class="lineCov">        384 :           ASM_GENERATE_INTERNAL_LABEL (label, &quot;LDL&quot;, CODE_LABEL_NUMBER (insn));</span>
<span class="lineNum">   23991 </span><span class="lineCov">        384 :           add_AT_lbl_id (lbl_die, DW_AT_low_pc, label);</span>
<span class="lineNum">   23992 </span>            :         }
<span class="lineNum">   23993 </span>            :     }
<span class="lineNum">   23994 </span><span class="lineCov">       3873 : }</span>
<span class="lineNum">   23995 </span>            : 
<span class="lineNum">   23996 </span>            : /* A helper function for gen_inlined_subroutine_die.  Add source coordinate
<span class="lineNum">   23997 </span>            :    attributes to the DIE for a block STMT, to describe where the inlined
<span class="lineNum">   23998 </span>            :    function was called from.  This is similar to add_src_coords_attributes.  */
<a name="23999"><span class="lineNum">   23999 </span>            : </a>
<span class="lineNum">   24000 </span>            : static inline void
<span class="lineNum">   24001 </span><span class="lineCov">    3234843 : add_call_src_coords_attributes (tree stmt, dw_die_ref die)</span>
<span class="lineNum">   24002 </span>            : {
<span class="lineNum">   24003 </span><span class="lineCov">    3234843 :   expanded_location s = expand_location (BLOCK_SOURCE_LOCATION (stmt));</span>
<span class="lineNum">   24004 </span>            : 
<span class="lineNum">   24005 </span><span class="lineCov">    3234843 :   if (dwarf_version &gt;= 3 || !dwarf_strict)</span>
<span class="lineNum">   24006 </span>            :     {
<span class="lineNum">   24007 </span><span class="lineCov">    3234843 :       add_AT_file (die, DW_AT_call_file, lookup_filename (s.file));</span>
<span class="lineNum">   24008 </span><span class="lineCov">    3234843 :       add_AT_unsigned (die, DW_AT_call_line, s.line);</span>
<span class="lineNum">   24009 </span><span class="lineCov">    3234843 :       if (debug_column_info &amp;&amp; s.column)</span>
<span class="lineNum">   24010 </span><span class="lineCov">    3230196 :         add_AT_unsigned (die, DW_AT_call_column, s.column);</span>
<span class="lineNum">   24011 </span>            :     }
<span class="lineNum">   24012 </span><span class="lineCov">    3234843 : }</span>
<span class="lineNum">   24013 </span>            : 
<span class="lineNum">   24014 </span>            : 
<span class="lineNum">   24015 </span>            : /* A helper function for gen_lexical_block_die and gen_inlined_subroutine_die.
<span class="lineNum">   24016 </span>            :    Add low_pc and high_pc attributes to the DIE for a block STMT.  */
<a name="24017"><span class="lineNum">   24017 </span>            : </a>
<span class="lineNum">   24018 </span>            : static inline void
<span class="lineNum">   24019 </span><span class="lineCov">    3901085 : add_high_low_attributes (tree stmt, dw_die_ref die)</span>
<span class="lineNum">   24020 </span>            : {
<span class="lineNum">   24021 </span><span class="lineCov">    3901085 :   char label[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">   24022 </span>            : 
<span class="lineNum">   24023 </span><span class="lineCov">    7558290 :   if (inline_entry_data **iedp</span>
<span class="lineNum">   24024 </span><span class="lineCov">    3901085 :       = !inline_entry_data_table ? NULL</span>
<span class="lineNum">   24025 </span><span class="lineCov">    3657205 :       : inline_entry_data_table-&gt;find_slot_with_hash (stmt,</span>
<span class="lineNum">   24026 </span>            :                                                       htab_hash_pointer (stmt),
<span class="lineNum">   24027 </span><span class="lineCov">    3657205 :                                                       NO_INSERT))</span>
<span class="lineNum">   24028 </span>            :     {
<span class="lineNum">   24029 </span><span class="lineCov">    3149934 :       inline_entry_data *ied = *iedp;</span>
<span class="lineNum">   24030 </span><span class="lineCov">    3149934 :       gcc_assert (MAY_HAVE_DEBUG_MARKER_INSNS);</span>
<span class="lineNum">   24031 </span><span class="lineCov">    3149934 :       gcc_assert (debug_inline_points);</span>
<span class="lineNum">   24032 </span><span class="lineCov">    3149934 :       gcc_assert (inlined_function_outer_scope_p (stmt));</span>
<span class="lineNum">   24033 </span>            : 
<span class="lineNum">   24034 </span><span class="lineCov">    3149934 :       ASM_GENERATE_INTERNAL_LABEL (label, ied-&gt;label_pfx, ied-&gt;label_num);</span>
<span class="lineNum">   24035 </span><span class="lineCov">    3149934 :       add_AT_lbl_id (die, DW_AT_entry_pc, label);</span>
<span class="lineNum">   24036 </span>            : 
<span class="lineNum">   24037 </span><span class="lineCov">    3149934 :       if (debug_variable_location_views &amp;&amp; !ZERO_VIEW_P (ied-&gt;view)</span>
<span class="lineNum">   24038 </span><span class="lineCov">    6299755 :           &amp;&amp; !dwarf_strict)</span>
<span class="lineNum">   24039 </span>            :         {
<span class="lineNum">   24040 </span><span class="lineCov">    3149821 :           if (!output_asm_line_debug_info ())</span>
<span class="lineNum">   24041 </span><span class="lineNoCov">          0 :             add_AT_unsigned (die, DW_AT_GNU_entry_view, ied-&gt;view);</span>
<span class="lineNum">   24042 </span>            :           else
<span class="lineNum">   24043 </span>            :             {
<span class="lineNum">   24044 </span><span class="lineCov">    3149821 :               ASM_GENERATE_INTERNAL_LABEL (label, &quot;LVU&quot;, ied-&gt;view);</span>
<span class="lineNum">   24045 </span>            :               /* FIXME: this will resolve to a small number.  Could we
<span class="lineNum">   24046 </span>            :                  possibly emit smaller data?  Ideally we'd emit a
<span class="lineNum">   24047 </span>            :                  uleb128, but that would make the size of DIEs
<span class="lineNum">   24048 </span>            :                  impossible for the compiler to compute, since it's
<span class="lineNum">   24049 </span>            :                  the assembler that computes the value of the view
<span class="lineNum">   24050 </span>            :                  label in this case.  Ideally, we'd have a single form
<span class="lineNum">   24051 </span>            :                  encompassing both the address and the view, and
<span class="lineNum">   24052 </span>            :                  indirecting them through a table might make things
<span class="lineNum">   24053 </span>            :                  easier, but even that would be more wasteful,
<span class="lineNum">   24054 </span>            :                  space-wise, than what we have now.  */
<span class="lineNum">   24055 </span><span class="lineCov">    3149821 :               add_AT_symview (die, DW_AT_GNU_entry_view, label);</span>
<span class="lineNum">   24056 </span>            :             }
<span class="lineNum">   24057 </span>            :         }
<span class="lineNum">   24058 </span>            : 
<span class="lineNum">   24059 </span><span class="lineCov">    3149934 :       inline_entry_data_table-&gt;clear_slot (iedp);</span>
<span class="lineNum">   24060 </span>            :     }
<span class="lineNum">   24061 </span>            : 
<span class="lineNum">   24062 </span><span class="lineCov">    3901085 :   if (BLOCK_FRAGMENT_CHAIN (stmt)</span>
<span class="lineNum">   24063 </span><span class="lineCov">    3901085 :       &amp;&amp; (dwarf_version &gt;= 3 || !dwarf_strict))</span>
<span class="lineNum">   24064 </span>            :     {
<span class="lineNum">   24065 </span><span class="lineCov">    1515837 :       tree chain, superblock = NULL_TREE;</span>
<span class="lineNum">   24066 </span><span class="lineCov">    1515837 :       dw_die_ref pdie;</span>
<span class="lineNum">   24067 </span><span class="lineCov">    1515837 :       dw_attr_node *attr = NULL;</span>
<span class="lineNum">   24068 </span>            : 
<span class="lineNum">   24069 </span><span class="lineCov">    1515837 :       if (!debug_inline_points &amp;&amp; inlined_function_outer_scope_p (stmt))</span>
<span class="lineNum">   24070 </span>            :         {
<span class="lineNum">   24071 </span><span class="lineCov">         56 :           ASM_GENERATE_INTERNAL_LABEL (label, BLOCK_BEGIN_LABEL,</span>
<span class="lineNum">   24072 </span>            :                                        BLOCK_NUMBER (stmt));
<span class="lineNum">   24073 </span><span class="lineCov">         56 :           add_AT_lbl_id (die, DW_AT_entry_pc, label);</span>
<span class="lineNum">   24074 </span>            :         }
<span class="lineNum">   24075 </span>            : 
<span class="lineNum">   24076 </span>            :       /* Optimize duplicate .debug_ranges lists or even tails of
<span class="lineNum">   24077 </span>            :          lists.  If this BLOCK has same ranges as its supercontext,
<span class="lineNum">   24078 </span>            :          lookup DW_AT_ranges attribute in the supercontext (and
<span class="lineNum">   24079 </span>            :          recursively so), verify that the ranges_table contains the
<span class="lineNum">   24080 </span>            :          right values and use it instead of adding a new .debug_range.  */
<span class="lineNum">   24081 </span><span class="lineCov">    1515837 :       for (chain = stmt, pdie = die;</span>
<span class="lineNum">   24082 </span><span class="lineCov">    2334982 :            BLOCK_SAME_RANGE (chain);</span>
<span class="lineNum">   24083 </span>            :            chain = BLOCK_SUPERCONTEXT (chain))
<span class="lineNum">   24084 </span>            :         {
<span class="lineNum">   24085 </span><span class="lineCov">     830706 :           dw_attr_node *new_attr;</span>
<span class="lineNum">   24086 </span>            : 
<span class="lineNum">   24087 </span><span class="lineCov">     830706 :           pdie = pdie-&gt;die_parent;</span>
<span class="lineNum">   24088 </span><span class="lineCov">     830706 :           if (pdie == NULL)</span>
<span class="lineNum">   24089 </span>            :             break;
<span class="lineNum">   24090 </span><span class="lineCov">    1661412 :           if (BLOCK_SUPERCONTEXT (chain) == NULL_TREE)</span>
<span class="lineNum">   24091 </span>            :             break;
<span class="lineNum">   24092 </span><span class="lineCov">     830706 :           new_attr = get_AT (pdie, DW_AT_ranges);</span>
<span class="lineNum">   24093 </span><span class="lineCov">     830706 :           if (new_attr == NULL</span>
<span class="lineNum">   24094 </span><span class="lineCov">     819145 :               || new_attr-&gt;dw_attr_val.val_class != dw_val_class_range_list)</span>
<span class="lineNum">   24095 </span>            :             break;
<span class="lineNum">   24096 </span>            :           attr = new_attr;
<span class="lineNum">   24097 </span>            :           superblock = BLOCK_SUPERCONTEXT (chain);
<span class="lineNum">   24098 </span>            :         }
<span class="lineNum">   24099 </span><span class="lineCov">    1515837 :       if (attr != NULL</span>
<span class="lineNum">   24100 </span><span class="lineCov">     491312 :           &amp;&amp; ((*ranges_table)[attr-&gt;dw_attr_val.v.val_offset].num</span>
<span class="lineNum">   24101 </span><span class="lineCov">     491312 :               == BLOCK_NUMBER (superblock))</span>
<span class="lineNum">   24102 </span><span class="lineCov">    2421575 :           &amp;&amp; BLOCK_FRAGMENT_CHAIN (superblock))</span>
<span class="lineNum">   24103 </span>            :         {
<span class="lineNum">   24104 </span>            :           unsigned long off = attr-&gt;dw_attr_val.v.val_offset;
<span class="lineNum">   24105 </span>            :           unsigned long supercnt = 0, thiscnt = 0;
<span class="lineNum">   24106 </span><span class="lineCov">    1050506 :           for (chain = BLOCK_FRAGMENT_CHAIN (superblock);</span>
<span class="lineNum">   24107 </span><span class="lineCov">    2553881 :                chain; chain = BLOCK_FRAGMENT_CHAIN (chain))</span>
<span class="lineNum">   24108 </span>            :             {
<span class="lineNum">   24109 </span><span class="lineCov">    1050506 :               ++supercnt;</span>
<span class="lineNum">   24110 </span><span class="lineCov">    1050506 :               gcc_checking_assert ((*ranges_table)[off + supercnt].num</span>
<span class="lineNum">   24111 </span>            :                                    == BLOCK_NUMBER (chain));
<span class="lineNum">   24112 </span>            :             }
<span class="lineNum">   24113 </span><span class="lineCov">     452869 :           gcc_checking_assert ((*ranges_table)[off + supercnt + 1].num == 0);</span>
<span class="lineNum">   24114 </span><span class="lineCov">     452869 :           for (chain = BLOCK_FRAGMENT_CHAIN (stmt);</span>
<span class="lineNum">   24115 </span><span class="lineCov">    1469950 :                chain; chain = BLOCK_FRAGMENT_CHAIN (chain))</span>
<span class="lineNum">   24116 </span><span class="lineCov">    1017081 :             ++thiscnt;</span>
<span class="lineNum">   24117 </span><span class="lineCov">     452869 :           gcc_assert (supercnt &gt;= thiscnt);</span>
<span class="lineNum">   24118 </span><span class="lineCov">     452869 :           add_AT_range_list (die, DW_AT_ranges, off + supercnt - thiscnt,</span>
<span class="lineNum">   24119 </span>            :                              false);
<span class="lineNum">   24120 </span><span class="lineCov">     452869 :           note_rnglist_head (off + supercnt - thiscnt);</span>
<span class="lineNum">   24121 </span><span class="lineCov">     452869 :           return;</span>
<span class="lineNum">   24122 </span>            :         }
<span class="lineNum">   24123 </span>            : 
<span class="lineNum">   24124 </span><span class="lineCov">    1062968 :       unsigned int offset = add_ranges (stmt, true);</span>
<span class="lineNum">   24125 </span><span class="lineCov">    1062968 :       add_AT_range_list (die, DW_AT_ranges, offset, false);</span>
<span class="lineNum">   24126 </span><span class="lineCov">    1062968 :       note_rnglist_head (offset);</span>
<span class="lineNum">   24127 </span>            : 
<span class="lineNum">   24128 </span><span class="lineCov">    1062968 :       bool prev_in_cold = BLOCK_IN_COLD_SECTION_P (stmt);</span>
<span class="lineNum">   24129 </span><span class="lineCov">    2125936 :       chain = BLOCK_FRAGMENT_CHAIN (stmt);</span>
<span class="lineNum">   24130 </span><span class="lineCov">    2238799 :       do</span>
<span class="lineNum">   24131 </span>            :         {
<span class="lineNum">   24132 </span><span class="lineCov">    2238799 :           add_ranges (chain, prev_in_cold != BLOCK_IN_COLD_SECTION_P (chain));</span>
<span class="lineNum">   24133 </span><span class="lineCov">    2238799 :           prev_in_cold = BLOCK_IN_COLD_SECTION_P (chain);</span>
<span class="lineNum">   24134 </span><span class="lineCov">    2238799 :           chain = BLOCK_FRAGMENT_CHAIN (chain);</span>
<span class="lineNum">   24135 </span>            :         }
<span class="lineNum">   24136 </span><span class="lineCov">    2238799 :       while (chain);</span>
<span class="lineNum">   24137 </span><span class="lineCov">    1062968 :       add_ranges (NULL);</span>
<span class="lineNum">   24138 </span>            :     }
<span class="lineNum">   24139 </span>            :   else
<span class="lineNum">   24140 </span>            :     {
<span class="lineNum">   24141 </span><span class="lineCov">    2385248 :       char label_high[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">   24142 </span><span class="lineCov">    2385248 :       ASM_GENERATE_INTERNAL_LABEL (label, BLOCK_BEGIN_LABEL,</span>
<span class="lineNum">   24143 </span>            :                                    BLOCK_NUMBER (stmt));
<span class="lineNum">   24144 </span><span class="lineCov">    2385248 :       ASM_GENERATE_INTERNAL_LABEL (label_high, BLOCK_END_LABEL,</span>
<span class="lineNum">   24145 </span>            :                                    BLOCK_NUMBER (stmt));
<span class="lineNum">   24146 </span><span class="lineCov">    2385248 :       add_AT_low_high_pc (die, label, label_high, false);</span>
<span class="lineNum">   24147 </span>            :     }
<span class="lineNum">   24148 </span>            : }
<span class="lineNum">   24149 </span>            : 
<span class="lineNum">   24150 </span>            : /* Generate a DIE for a lexical block.  */
<a name="24151"><span class="lineNum">   24151 </span>            : </a>
<span class="lineNum">   24152 </span>            : static void
<span class="lineNum">   24153 </span><span class="lineCov">     917372 : gen_lexical_block_die (tree stmt, dw_die_ref context_die)</span>
<span class="lineNum">   24154 </span>            : {
<span class="lineNum">   24155 </span><span class="lineCov">     917372 :   dw_die_ref old_die = BLOCK_DIE (stmt);</span>
<span class="lineNum">   24156 </span><span class="lineCov">     917372 :   dw_die_ref stmt_die = NULL;</span>
<span class="lineNum">   24157 </span><span class="lineCov">     917372 :   if (!old_die)</span>
<span class="lineNum">   24158 </span>            :     {
<span class="lineNum">   24159 </span><span class="lineCov">     736047 :       stmt_die = new_die (DW_TAG_lexical_block, context_die, stmt);</span>
<span class="lineNum">   24160 </span><span class="lineCov">     736047 :       BLOCK_DIE (stmt) = stmt_die;</span>
<span class="lineNum">   24161 </span>            :     }
<span class="lineNum">   24162 </span>            : 
<span class="lineNum">   24163 </span><span class="lineCov">     917372 :   if (BLOCK_ABSTRACT (stmt))</span>
<span class="lineNum">   24164 </span>            :     {
<span class="lineNum">   24165 </span><span class="lineNoCov">          0 :       if (old_die)</span>
<span class="lineNum">   24166 </span>            :         {
<span class="lineNum">   24167 </span>            :           /* This must have been generated early and it won't even
<span class="lineNum">   24168 </span>            :              need location information since it's a DW_AT_inline
<span class="lineNum">   24169 </span>            :              function.  */
<span class="lineNum">   24170 </span><span class="lineNoCov">          0 :           if (flag_checking)</span>
<span class="lineNum">   24171 </span><span class="lineNoCov">          0 :             for (dw_die_ref c = context_die; c; c = c-&gt;die_parent)</span>
<span class="lineNum">   24172 </span><span class="lineNoCov">          0 :               if (c-&gt;die_tag == DW_TAG_inlined_subroutine</span>
<span class="lineNum">   24173 </span><span class="lineNoCov">          0 :                   || c-&gt;die_tag == DW_TAG_subprogram)</span>
<span class="lineNum">   24174 </span>            :                 {
<span class="lineNum">   24175 </span><span class="lineNoCov">          0 :                   gcc_assert (get_AT (c, DW_AT_inline));</span>
<span class="lineNum">   24176 </span>            :                   break;
<span class="lineNum">   24177 </span>            :                 }
<span class="lineNum">   24178 </span>            :           return;
<span class="lineNum">   24179 </span>            :         }
<span class="lineNum">   24180 </span>            :     }
<span class="lineNum">   24181 </span><span class="lineCov">    1834744 :   else if (BLOCK_ABSTRACT_ORIGIN (stmt))</span>
<span class="lineNum">   24182 </span>            :     {
<span class="lineNum">   24183 </span>            :       /* If this is an inlined instance, create a new lexical die for
<span class="lineNum">   24184 </span>            :          anything below to attach DW_AT_abstract_origin to.  */
<span class="lineNum">   24185 </span><span class="lineCov">     496621 :       if (old_die)</span>
<span class="lineNum">   24186 </span>            :         {
<span class="lineNum">   24187 </span><span class="lineCov">       4735 :           stmt_die = new_die (DW_TAG_lexical_block, context_die, stmt);</span>
<span class="lineNum">   24188 </span><span class="lineCov">       4735 :           BLOCK_DIE (stmt) = stmt_die;</span>
<span class="lineNum">   24189 </span><span class="lineCov">       4735 :           old_die = NULL;</span>
<span class="lineNum">   24190 </span>            :         }
<span class="lineNum">   24191 </span>            : 
<span class="lineNum">   24192 </span><span class="lineCov">     496621 :       tree origin = block_ultimate_origin (stmt);</span>
<span class="lineNum">   24193 </span><span class="lineCov">     496621 :       if (origin != NULL_TREE &amp;&amp; origin != stmt)</span>
<span class="lineNum">   24194 </span><span class="lineCov">     493361 :         add_abstract_origin_attribute (stmt_die, origin);</span>
<span class="lineNum">   24195 </span>            :     }
<span class="lineNum">   24196 </span>            : 
<span class="lineNum">   24197 </span><span class="lineCov">     917372 :   if (old_die)</span>
<span class="lineNum">   24198 </span><span class="lineCov">     176590 :     stmt_die = old_die;</span>
<span class="lineNum">   24199 </span>            : 
<span class="lineNum">   24200 </span>            :   /* A non abstract block whose blocks have already been reordered
<span class="lineNum">   24201 </span>            :      should have the instruction range for this block.  If so, set the
<span class="lineNum">   24202 </span>            :      high/low attributes.  */
<span class="lineNum">   24203 </span><span class="lineCov">     917372 :   if (!early_dwarf &amp;&amp; !BLOCK_ABSTRACT (stmt) &amp;&amp; TREE_ASM_WRITTEN (stmt))</span>
<span class="lineNum">   24204 </span>            :     {
<span class="lineNum">   24205 </span><span class="lineCov">     666242 :       gcc_assert (stmt_die);</span>
<span class="lineNum">   24206 </span><span class="lineCov">     666242 :       add_high_low_attributes (stmt, stmt_die);</span>
<span class="lineNum">   24207 </span>            :     }
<span class="lineNum">   24208 </span>            : 
<span class="lineNum">   24209 </span><span class="lineCov">     917372 :   decls_for_scope (stmt, stmt_die);</span>
<span class="lineNum">   24210 </span>            : }
<span class="lineNum">   24211 </span>            : 
<span class="lineNum">   24212 </span>            : /* Generate a DIE for an inlined subprogram.  */
<a name="24213"><span class="lineNum">   24213 </span>            : </a>
<span class="lineNum">   24214 </span>            : static void
<span class="lineNum">   24215 </span><span class="lineCov">    3234843 : gen_inlined_subroutine_die (tree stmt, dw_die_ref context_die)</span>
<span class="lineNum">   24216 </span>            : {
<span class="lineNum">   24217 </span><span class="lineCov">    3234843 :   tree decl;</span>
<span class="lineNum">   24218 </span>            : 
<span class="lineNum">   24219 </span>            :   /* The instance of function that is effectively being inlined shall not
<span class="lineNum">   24220 </span>            :      be abstract.  */
<span class="lineNum">   24221 </span><span class="lineCov">    3234843 :   gcc_assert (! BLOCK_ABSTRACT (stmt));</span>
<span class="lineNum">   24222 </span>            : 
<span class="lineNum">   24223 </span><span class="lineCov">    3234843 :   decl = block_ultimate_origin (stmt);</span>
<span class="lineNum">   24224 </span>            : 
<span class="lineNum">   24225 </span>            :   /* Make sure any inlined functions are known to be inlineable.  */
<span class="lineNum">   24226 </span><span class="lineCov">    3234843 :   gcc_checking_assert (DECL_ABSTRACT_P (decl)</span>
<span class="lineNum">   24227 </span>            :                        || cgraph_function_possibly_inlined_p (decl));
<span class="lineNum">   24228 </span>            : 
<span class="lineNum">   24229 </span><span class="lineCov">    3234843 :   if (! BLOCK_ABSTRACT (stmt))</span>
<span class="lineNum">   24230 </span>            :     {
<span class="lineNum">   24231 </span><span class="lineCov">    3234843 :       dw_die_ref subr_die</span>
<span class="lineNum">   24232 </span><span class="lineCov">    3234843 :         = new_die (DW_TAG_inlined_subroutine, context_die, stmt);</span>
<span class="lineNum">   24233 </span>            : 
<span class="lineNum">   24234 </span><span class="lineCov">    3234843 :       if (call_arg_locations || debug_inline_points)</span>
<span class="lineNum">   24235 </span><span class="lineCov">    3234668 :         BLOCK_DIE (stmt) = subr_die;</span>
<span class="lineNum">   24236 </span><span class="lineCov">    3234843 :       add_abstract_origin_attribute (subr_die, decl);</span>
<span class="lineNum">   24237 </span><span class="lineCov">    3234843 :       if (TREE_ASM_WRITTEN (stmt))</span>
<span class="lineNum">   24238 </span><span class="lineCov">    3234843 :         add_high_low_attributes (stmt, subr_die);</span>
<span class="lineNum">   24239 </span><span class="lineCov">    3234843 :       add_call_src_coords_attributes (stmt, subr_die);</span>
<span class="lineNum">   24240 </span>            : 
<span class="lineNum">   24241 </span><span class="lineCov">    3234843 :       decls_for_scope (stmt, subr_die);</span>
<span class="lineNum">   24242 </span>            :     }
<span class="lineNum">   24243 </span><span class="lineCov">    3234843 : }</span>
<span class="lineNum">   24244 </span>            : 
<span class="lineNum">   24245 </span>            : /* Generate a DIE for a field in a record, or structure.  CTX is required: see
<span class="lineNum">   24246 </span>            :    the comment for VLR_CONTEXT.  */
<a name="24247"><span class="lineNum">   24247 </span>            : </a>
<span class="lineNum">   24248 </span>            : static void
<span class="lineNum">   24249 </span><span class="lineCov">    2562527 : gen_field_die (tree decl, struct vlr_context *ctx, dw_die_ref context_die)</span>
<span class="lineNum">   24250 </span>            : {
<span class="lineNum">   24251 </span><span class="lineCov">    2562527 :   dw_die_ref decl_die;</span>
<span class="lineNum">   24252 </span>            : 
<span class="lineNum">   24253 </span><span class="lineCov">    2562527 :   if (TREE_TYPE (decl) == error_mark_node)</span>
<span class="lineNum">   24254 </span>            :     return;
<span class="lineNum">   24255 </span>            : 
<span class="lineNum">   24256 </span><span class="lineCov">    2562527 :   decl_die = new_die (DW_TAG_member, context_die, decl);</span>
<span class="lineNum">   24257 </span><span class="lineCov">    2562527 :   add_name_and_src_coords_attributes (decl_die, decl);</span>
<span class="lineNum">   24258 </span><span class="lineCov">    2562527 :   add_type_attribute (decl_die, member_declared_type (decl), decl_quals (decl),</span>
<span class="lineNum">   24259 </span><span class="lineCov">    2562527 :                       TYPE_REVERSE_STORAGE_ORDER (DECL_FIELD_CONTEXT (decl)),</span>
<span class="lineNum">   24260 </span><span class="lineCov">    2562527 :                       context_die);</span>
<span class="lineNum">   24261 </span>            : 
<span class="lineNum">   24262 </span><span class="lineCov">    2562527 :   if (DECL_BIT_FIELD_TYPE (decl))</span>
<span class="lineNum">   24263 </span>            :     {
<span class="lineNum">   24264 </span><span class="lineCov">       9478 :       add_byte_size_attribute (decl_die, decl);</span>
<span class="lineNum">   24265 </span><span class="lineCov">       9478 :       add_bit_size_attribute (decl_die, decl);</span>
<span class="lineNum">   24266 </span><span class="lineCov">       9478 :       add_bit_offset_attribute (decl_die, decl, ctx);</span>
<span class="lineNum">   24267 </span>            :     }
<span class="lineNum">   24268 </span>            : 
<span class="lineNum">   24269 </span><span class="lineCov">    2562527 :   add_alignment_attribute (decl_die, decl);</span>
<span class="lineNum">   24270 </span>            : 
<span class="lineNum">   24271 </span>            :   /* If we have a variant part offset, then we are supposed to process a member
<span class="lineNum">   24272 </span>            :      of a QUAL_UNION_TYPE, which is how we represent variant parts in
<span class="lineNum">   24273 </span>            :      trees.  */
<span class="lineNum">   24274 </span><span class="lineCov">    2562527 :   gcc_assert (ctx-&gt;variant_part_offset == NULL_TREE</span>
<span class="lineNum">   24275 </span>            :               || TREE_CODE (DECL_FIELD_CONTEXT (decl)) != QUAL_UNION_TYPE);
<span class="lineNum">   24276 </span><span class="lineCov">    2562527 :   if (TREE_CODE (DECL_FIELD_CONTEXT (decl)) != UNION_TYPE)</span>
<span class="lineNum">   24277 </span><span class="lineCov">    2301135 :     add_data_member_location_attribute (decl_die, decl, ctx);</span>
<span class="lineNum">   24278 </span>            : 
<span class="lineNum">   24279 </span><span class="lineCov">    2562527 :   if (DECL_ARTIFICIAL (decl))</span>
<span class="lineNum">   24280 </span><span class="lineCov">      19446 :     add_AT_flag (decl_die, DW_AT_artificial, 1);</span>
<span class="lineNum">   24281 </span>            : 
<span class="lineNum">   24282 </span><span class="lineCov">    2562527 :   add_accessibility_attribute (decl_die, decl);</span>
<span class="lineNum">   24283 </span>            : 
<span class="lineNum">   24284 </span>            :   /* Equate decl number to die, so that we can look up this decl later on.  */
<span class="lineNum">   24285 </span><span class="lineCov">    2562527 :   equate_decl_number_to_die (decl, decl_die);</span>
<span class="lineNum">   24286 </span>            : }
<span class="lineNum">   24287 </span>            : 
<span class="lineNum">   24288 </span>            : /* Generate a DIE for a pointer to a member type.  TYPE can be an
<span class="lineNum">   24289 </span>            :    OFFSET_TYPE, for a pointer to data member, or a RECORD_TYPE, for a
<span class="lineNum">   24290 </span>            :    pointer to member function.  */
<a name="24291"><span class="lineNum">   24291 </span>            : </a>
<span class="lineNum">   24292 </span>            : static void
<span class="lineNum">   24293 </span><span class="lineCov">      14135 : gen_ptr_to_mbr_type_die (tree type, dw_die_ref context_die)</span>
<span class="lineNum">   24294 </span>            : {
<span class="lineNum">   24295 </span><span class="lineCov">      14135 :   if (lookup_type_die (type))</span>
<span class="lineNum">   24296 </span>            :     return;
<span class="lineNum">   24297 </span>            : 
<span class="lineNum">   24298 </span><span class="lineCov">      14135 :   dw_die_ref ptr_die = new_die (DW_TAG_ptr_to_member_type,</span>
<span class="lineNum">   24299 </span>            :                                 scope_die_for (type, context_die), type);
<span class="lineNum">   24300 </span>            : 
<span class="lineNum">   24301 </span><span class="lineCov">      14135 :   equate_type_number_to_die (type, ptr_die);</span>
<span class="lineNum">   24302 </span><span class="lineCov">      14135 :   add_AT_die_ref (ptr_die, DW_AT_containing_type,</span>
<span class="lineNum">   24303 </span><span class="lineCov">      14135 :                   lookup_type_die (TYPE_OFFSET_BASETYPE (type)));</span>
<span class="lineNum">   24304 </span><span class="lineCov">      14135 :   add_type_attribute (ptr_die, TREE_TYPE (type), TYPE_UNQUALIFIED, false,</span>
<span class="lineNum">   24305 </span>            :                       context_die);
<span class="lineNum">   24306 </span><span class="lineCov">      14135 :   add_alignment_attribute (ptr_die, type);</span>
<span class="lineNum">   24307 </span>            : 
<span class="lineNum">   24308 </span><span class="lineCov">      14135 :   if (TREE_CODE (TREE_TYPE (type)) != FUNCTION_TYPE</span>
<span class="lineNum">   24309 </span><span class="lineCov">      14135 :       &amp;&amp; TREE_CODE (TREE_TYPE (type)) != METHOD_TYPE)</span>
<span class="lineNum">   24310 </span>            :     {
<span class="lineNum">   24311 </span><span class="lineCov">        211 :       dw_loc_descr_ref op = new_loc_descr (DW_OP_plus, 0, 0);</span>
<span class="lineNum">   24312 </span><span class="lineCov">        211 :       add_AT_loc (ptr_die, DW_AT_use_location, op);</span>
<span class="lineNum">   24313 </span>            :     }
<span class="lineNum">   24314 </span>            : }
<span class="lineNum">   24315 </span>            : 
<span class="lineNum">   24316 </span>            : static char *producer_string;
<span class="lineNum">   24317 </span>            : 
<span class="lineNum">   24318 </span>            : /* Return a heap allocated producer string including command line options
<span class="lineNum">   24319 </span>            :    if -grecord-gcc-switches.  */
<a name="24320"><span class="lineNum">   24320 </span>            : </a>
<span class="lineNum">   24321 </span>            : static char *
<span class="lineNum">   24322 </span><span class="lineCov">      34141 : gen_producer_string (void)</span>
<span class="lineNum">   24323 </span>            : {
<span class="lineNum">   24324 </span><span class="lineCov">      34141 :   size_t j;</span>
<span class="lineNum">   24325 </span><span class="lineCov">      34141 :   auto_vec&lt;const char *&gt; switches;</span>
<span class="lineNum">   24326 </span><span class="lineCov">      34141 :   const char *language_string = lang_hooks.name;</span>
<span class="lineNum">   24327 </span><span class="lineCov">      34141 :   char *producer, *tail;</span>
<span class="lineNum">   24328 </span><span class="lineCov">      34141 :   const char *p;</span>
<span class="lineNum">   24329 </span><span class="lineCov">      34141 :   size_t len = dwarf_record_gcc_switches ? 0 : 3;</span>
<span class="lineNum">   24330 </span><span class="lineCov">      34141 :   size_t plen = strlen (language_string) + 1 + strlen (version_string);</span>
<span class="lineNum">   24331 </span>            : 
<span class="lineNum">   24332 </span><span class="lineCov">     901906 :   for (j = 1; dwarf_record_gcc_switches &amp;&amp; j &lt; save_decoded_options_count; j++)</span>
<span class="lineNum">   24333 </span><span class="lineCov">     867765 :     switch (save_decoded_options[j].opt_index)</span>
<span class="lineNum">   24334 </span>            :       {
<span class="lineNum">   24335 </span>            :       case OPT_o:
<span class="lineNum">   24336 </span>            :       case OPT_d:
<span class="lineNum">   24337 </span>            :       case OPT_dumpbase:
<span class="lineNum">   24338 </span>            :       case OPT_dumpdir:
<span class="lineNum">   24339 </span>            :       case OPT_auxbase:
<span class="lineNum">   24340 </span>            :       case OPT_auxbase_strip:
<span class="lineNum">   24341 </span>            :       case OPT_quiet:
<span class="lineNum">   24342 </span>            :       case OPT_version:
<span class="lineNum">   24343 </span>            :       case OPT_v:
<span class="lineNum">   24344 </span>            :       case OPT_w:
<span class="lineNum">   24345 </span>            :       case OPT_L:
<span class="lineNum">   24346 </span>            :       case OPT_D:
<span class="lineNum">   24347 </span>            :       case OPT_I:
<span class="lineNum">   24348 </span>            :       case OPT_U:
<span class="lineNum">   24349 </span>            :       case OPT_SPECIAL_unknown:
<span class="lineNum">   24350 </span>            :       case OPT_SPECIAL_ignore:
<span class="lineNum">   24351 </span>            :       case OPT_SPECIAL_deprecated:
<span class="lineNum">   24352 </span>            :       case OPT_SPECIAL_program_name:
<span class="lineNum">   24353 </span>            :       case OPT_SPECIAL_input_file:
<span class="lineNum">   24354 </span>            :       case OPT_grecord_gcc_switches:
<span class="lineNum">   24355 </span>            :       case OPT__output_pch_:
<span class="lineNum">   24356 </span>            :       case OPT_fdiagnostics_show_location_:
<span class="lineNum">   24357 </span>            :       case OPT_fdiagnostics_show_option:
<span class="lineNum">   24358 </span>            :       case OPT_fdiagnostics_show_caret:
<span class="lineNum">   24359 </span>            :       case OPT_fdiagnostics_show_labels:
<span class="lineNum">   24360 </span>            :       case OPT_fdiagnostics_show_line_numbers:
<span class="lineNum">   24361 </span>            :       case OPT_fdiagnostics_color_:
<span class="lineNum">   24362 </span>            :       case OPT_fverbose_asm:
<span class="lineNum">   24363 </span>            :       case OPT____:
<span class="lineNum">   24364 </span>            :       case OPT__sysroot_:
<span class="lineNum">   24365 </span>            :       case OPT_nostdinc:
<span class="lineNum">   24366 </span>            :       case OPT_nostdinc__:
<span class="lineNum">   24367 </span>            :       case OPT_fpreprocessed:
<span class="lineNum">   24368 </span>            :       case OPT_fltrans_output_list_:
<span class="lineNum">   24369 </span>            :       case OPT_fresolution_:
<span class="lineNum">   24370 </span>            :       case OPT_fdebug_prefix_map_:
<span class="lineNum">   24371 </span>            :       case OPT_fmacro_prefix_map_:
<span class="lineNum">   24372 </span>            :       case OPT_ffile_prefix_map_:
<span class="lineNum">   24373 </span>            :       case OPT_fcompare_debug:
<span class="lineNum">   24374 </span>            :       case OPT_fchecking:
<span class="lineNum">   24375 </span>            :       case OPT_fchecking_:
<span class="lineNum">   24376 </span>            :         /* Ignore these.  */
<span class="lineNum">   24377 </span>            :         continue;
<span class="lineNum">   24378 </span><span class="lineCov">     412386 :       default:</span>
<span class="lineNum">   24379 </span><span class="lineCov">     824772 :         if (cl_options[save_decoded_options[j].opt_index].flags</span>
<span class="lineNum">   24380 </span><span class="lineCov">     412386 :             &amp; CL_NO_DWARF_RECORD)</span>
<span class="lineNum">   24381 </span>            :           continue;
<span class="lineNum">   24382 </span><span class="lineCov">     411778 :         gcc_checking_assert (save_decoded_options[j].canonical_option[0][0]</span>
<span class="lineNum">   24383 </span>            :                              == '-');
<span class="lineNum">   24384 </span><span class="lineCov">     411778 :         switch (save_decoded_options[j].canonical_option[0][1])</span>
<span class="lineNum">   24385 </span>            :           {
<span class="lineNum">   24386 </span>            :           case 'M':
<span class="lineNum">   24387 </span>            :           case 'i':
<span class="lineNum">   24388 </span>            :           case 'W':
<span class="lineNum">   24389 </span>            :             continue;
<span class="lineNum">   24390 </span><span class="lineCov">      76625 :           case 'f':</span>
<span class="lineNum">   24391 </span><span class="lineCov">      76625 :             if (strncmp (save_decoded_options[j].canonical_option[0] + 2,</span>
<span class="lineNum">   24392 </span>            :                          &quot;dump&quot;, 4) == 0)
<span class="lineNum">   24393 </span>            :               continue;
<span class="lineNum">   24394 </span>            :             break;
<span class="lineNum">   24395 </span>            :           default:
<span class="lineNum">   24396 </span>            :             break;
<span class="lineNum">   24397 </span>            :           }
<span class="lineNum">   24398 </span><span class="lineCov">     232700 :         switches.safe_push (save_decoded_options[j].orig_option_with_args_text);</span>
<span class="lineNum">   24399 </span><span class="lineCov">     232700 :         len += strlen (save_decoded_options[j].orig_option_with_args_text) + 1;</span>
<span class="lineNum">   24400 </span><span class="lineCov">     232700 :         break;</span>
<span class="lineNum">   24401 </span>            :       }
<span class="lineNum">   24402 </span>            : 
<span class="lineNum">   24403 </span><span class="lineCov">      34141 :   producer = XNEWVEC (char, plen + 1 + len + 1);</span>
<span class="lineNum">   24404 </span><span class="lineCov">      34141 :   tail = producer;</span>
<span class="lineNum">   24405 </span><span class="lineCov">      34141 :   sprintf (tail, &quot;%s %s&quot;, language_string, version_string);</span>
<span class="lineNum">   24406 </span><span class="lineCov">      34141 :   tail += plen;</span>
<span class="lineNum">   24407 </span>            : 
<span class="lineNum">   24408 </span><span class="lineCov">     266841 :   FOR_EACH_VEC_ELT (switches, j, p)</span>
<span class="lineNum">   24409 </span>            :     {
<span class="lineNum">   24410 </span><span class="lineCov">     232700 :       len = strlen (p);</span>
<span class="lineNum">   24411 </span><span class="lineCov">     232700 :       *tail = ' ';</span>
<span class="lineNum">   24412 </span><span class="lineCov">     232700 :       memcpy (tail + 1, p, len);</span>
<span class="lineNum">   24413 </span><span class="lineCov">     232700 :       tail += len + 1;</span>
<span class="lineNum">   24414 </span>            :     }
<span class="lineNum">   24415 </span>            : 
<span class="lineNum">   24416 </span><span class="lineCov">      34141 :   *tail = '\0';</span>
<span class="lineNum">   24417 </span><span class="lineCov">      34141 :   return producer;</span>
<span class="lineNum">   24418 </span>            : }
<span class="lineNum">   24419 </span>            : 
<span class="lineNum">   24420 </span>            : /* Given a C and/or C++ language/version string return the &quot;highest&quot;.
<span class="lineNum">   24421 </span>            :    C++ is assumed to be &quot;higher&quot; than C in this case.  Used for merging
<a name="24422"><span class="lineNum">   24422 </span>            :    LTO translation unit languages.  */</a>
<span class="lineNum">   24423 </span>            : static const char *
<span class="lineNum">   24424 </span><span class="lineNoCov">          0 : highest_c_language (const char *lang1, const char *lang2)</span>
<span class="lineNum">   24425 </span>            : {
<span class="lineNum">   24426 </span><span class="lineNoCov">          0 :   if (strcmp (&quot;GNU C++17&quot;, lang1) == 0 || strcmp (&quot;GNU C++17&quot;, lang2) == 0)</span>
<span class="lineNum">   24427 </span>            :     return &quot;GNU C++17&quot;;
<span class="lineNum">   24428 </span><span class="lineNoCov">          0 :   if (strcmp (&quot;GNU C++14&quot;, lang1) == 0 || strcmp (&quot;GNU C++14&quot;, lang2) == 0)</span>
<span class="lineNum">   24429 </span>            :     return &quot;GNU C++14&quot;;
<span class="lineNum">   24430 </span><span class="lineNoCov">          0 :   if (strcmp (&quot;GNU C++11&quot;, lang1) == 0 || strcmp (&quot;GNU C++11&quot;, lang2) == 0)</span>
<span class="lineNum">   24431 </span>            :     return &quot;GNU C++11&quot;;
<span class="lineNum">   24432 </span><span class="lineNoCov">          0 :   if (strcmp (&quot;GNU C++98&quot;, lang1) == 0 || strcmp (&quot;GNU C++98&quot;, lang2) == 0)</span>
<span class="lineNum">   24433 </span>            :     return &quot;GNU C++98&quot;;
<span class="lineNum">   24434 </span>            : 
<span class="lineNum">   24435 </span><span class="lineNoCov">          0 :   if (strcmp (&quot;GNU C17&quot;, lang1) == 0 || strcmp (&quot;GNU C17&quot;, lang2) == 0)</span>
<span class="lineNum">   24436 </span>            :     return &quot;GNU C17&quot;;
<span class="lineNum">   24437 </span><span class="lineNoCov">          0 :   if (strcmp (&quot;GNU C11&quot;, lang1) == 0 || strcmp (&quot;GNU C11&quot;, lang2) == 0)</span>
<span class="lineNum">   24438 </span>            :     return &quot;GNU C11&quot;;
<span class="lineNum">   24439 </span><span class="lineNoCov">          0 :   if (strcmp (&quot;GNU C99&quot;, lang1) == 0 || strcmp (&quot;GNU C99&quot;, lang2) == 0)</span>
<span class="lineNum">   24440 </span>            :     return &quot;GNU C99&quot;;
<span class="lineNum">   24441 </span><span class="lineNoCov">          0 :   if (strcmp (&quot;GNU C89&quot;, lang1) == 0 || strcmp (&quot;GNU C89&quot;, lang2) == 0)</span>
<span class="lineNum">   24442 </span>            :     return &quot;GNU C89&quot;;
<span class="lineNum">   24443 </span>            : 
<span class="lineNum">   24444 </span><span class="lineNoCov">          0 :   gcc_unreachable ();</span>
<span class="lineNum">   24445 </span>            : }
<span class="lineNum">   24446 </span>            : 
<span class="lineNum">   24447 </span>            : 
<span class="lineNum">   24448 </span>            : /* Generate the DIE for the compilation unit.  */
<a name="24449"><span class="lineNum">   24449 </span>            : </a>
<span class="lineNum">   24450 </span>            : static dw_die_ref
<span class="lineNum">   24451 </span><span class="lineCov">      37183 : gen_compile_unit_die (const char *filename)</span>
<span class="lineNum">   24452 </span>            : {
<span class="lineNum">   24453 </span><span class="lineCov">      37183 :   dw_die_ref die;</span>
<span class="lineNum">   24454 </span><span class="lineCov">      37183 :   const char *language_string = lang_hooks.name;</span>
<span class="lineNum">   24455 </span><span class="lineCov">      37183 :   int language;</span>
<span class="lineNum">   24456 </span>            : 
<span class="lineNum">   24457 </span><span class="lineCov">      37183 :   die = new_die (DW_TAG_compile_unit, NULL, NULL);</span>
<span class="lineNum">   24458 </span>            : 
<span class="lineNum">   24459 </span><span class="lineCov">      37183 :   if (filename)</span>
<span class="lineNum">   24460 </span>            :     {
<span class="lineNum">   24461 </span><span class="lineNoCov">          0 :       add_name_attribute (die, filename);</span>
<span class="lineNum">   24462 </span>            :       /* Don't add cwd for &lt;built-in&gt;.  */
<span class="lineNum">   24463 </span><span class="lineNoCov">          0 :       if (filename[0] != '&lt;')</span>
<span class="lineNum">   24464 </span><span class="lineNoCov">          0 :         add_comp_dir_attribute (die);</span>
<span class="lineNum">   24465 </span>            :     }
<span class="lineNum">   24466 </span>            : 
<span class="lineNum">   24467 </span><span class="lineCov">      37187 :   add_AT_string (die, DW_AT_producer, producer_string ? producer_string : &quot;&quot;);</span>
<span class="lineNum">   24468 </span>            : 
<span class="lineNum">   24469 </span>            :   /* If our producer is LTO try to figure out a common language to use
<span class="lineNum">   24470 </span>            :      from the global list of translation units.  */
<span class="lineNum">   24471 </span><span class="lineCov">      37183 :   if (strcmp (language_string, &quot;GNU GIMPLE&quot;) == 0)</span>
<span class="lineNum">   24472 </span>            :     {
<span class="lineNum">   24473 </span>            :       unsigned i;
<span class="lineNum">   24474 </span>            :       tree t;
<span class="lineNum">   24475 </span>            :       const char *common_lang = NULL;
<span class="lineNum">   24476 </span>            : 
<span class="lineNum">   24477 </span><span class="lineCov">       1664 :       FOR_EACH_VEC_SAFE_ELT (all_translation_units, i, t)</span>
<span class="lineNum">   24478 </span>            :         {
<span class="lineNum">   24479 </span><span class="lineCov">        832 :           if (!TRANSLATION_UNIT_LANGUAGE (t))</span>
<span class="lineNum">   24480 </span>            :             continue;
<span class="lineNum">   24481 </span><span class="lineCov">        832 :           if (!common_lang)</span>
<span class="lineNum">   24482 </span>            :             common_lang = TRANSLATION_UNIT_LANGUAGE (t);
<span class="lineNum">   24483 </span><span class="lineNoCov">          0 :           else if (strcmp (common_lang, TRANSLATION_UNIT_LANGUAGE (t)) == 0)</span>
<span class="lineNum">   24484 </span>            :             ;
<span class="lineNum">   24485 </span><span class="lineNoCov">          0 :           else if (strncmp (common_lang, &quot;GNU C&quot;, 5) == 0</span>
<span class="lineNum">   24486 </span><span class="lineNoCov">          0 :                     &amp;&amp; strncmp (TRANSLATION_UNIT_LANGUAGE (t), &quot;GNU C&quot;, 5) == 0)</span>
<span class="lineNum">   24487 </span>            :             /* Mixing C and C++ is ok, use C++ in that case.  */
<span class="lineNum">   24488 </span><span class="lineNoCov">          0 :             common_lang = highest_c_language (common_lang,</span>
<span class="lineNum">   24489 </span><span class="lineNoCov">          0 :                                               TRANSLATION_UNIT_LANGUAGE (t));</span>
<span class="lineNum">   24490 </span>            :           else
<span class="lineNum">   24491 </span>            :             {
<span class="lineNum">   24492 </span>            :               /* Fall back to C.  */
<span class="lineNum">   24493 </span>            :               common_lang = NULL;
<span class="lineNum">   24494 </span>            :               break;
<span class="lineNum">   24495 </span>            :             }
<span class="lineNum">   24496 </span>            :         }
<span class="lineNum">   24497 </span>            : 
<span class="lineNum">   24498 </span><span class="lineCov">        832 :       if (common_lang)</span>
<span class="lineNum">   24499 </span><span class="lineCov">        832 :         language_string = common_lang;</span>
<span class="lineNum">   24500 </span>            :     }
<span class="lineNum">   24501 </span>            : 
<span class="lineNum">   24502 </span><span class="lineCov">      37183 :   language = DW_LANG_C;</span>
<span class="lineNum">   24503 </span><span class="lineCov">      37183 :   if (strncmp (language_string, &quot;GNU C&quot;, 5) == 0</span>
<span class="lineNum">   24504 </span><span class="lineCov">      30400 :       &amp;&amp; ISDIGIT (language_string[5]))</span>
<span class="lineNum">   24505 </span>            :     {
<span class="lineNum">   24506 </span><span class="lineCov">      16920 :       language = DW_LANG_C89;</span>
<span class="lineNum">   24507 </span><span class="lineCov">      16920 :       if (dwarf_version &gt;= 3 || !dwarf_strict)</span>
<span class="lineNum">   24508 </span>            :         {
<span class="lineNum">   24509 </span><span class="lineCov">      16920 :           if (strcmp (language_string, &quot;GNU C89&quot;) != 0)</span>
<span class="lineNum">   24510 </span><span class="lineCov">      16866 :             language = DW_LANG_C99;</span>
<span class="lineNum">   24511 </span>            : 
<span class="lineNum">   24512 </span><span class="lineCov">      16920 :           if (dwarf_version &gt;= 5 /* || !dwarf_strict */)</span>
<span class="lineNum">   24513 </span><span class="lineCov">          5 :             if (strcmp (language_string, &quot;GNU C11&quot;) == 0</span>
<span class="lineNum">   24514 </span><span class="lineCov">          2 :                 || strcmp (language_string, &quot;GNU C17&quot;) == 0)</span>
<span class="lineNum">   24515 </span><span class="lineCov">          5 :               language = DW_LANG_C11;</span>
<span class="lineNum">   24516 </span>            :         }
<span class="lineNum">   24517 </span>            :     }
<span class="lineNum">   24518 </span><span class="lineCov">      20263 :   else if (strncmp (language_string, &quot;GNU C++&quot;, 7) == 0)</span>
<span class="lineNum">   24519 </span>            :     {
<span class="lineNum">   24520 </span><span class="lineCov">      13480 :       language = DW_LANG_C_plus_plus;</span>
<span class="lineNum">   24521 </span><span class="lineCov">      13480 :       if (dwarf_version &gt;= 5 /* || !dwarf_strict */)</span>
<span class="lineNum">   24522 </span>            :         {
<span class="lineNum">   24523 </span><span class="lineCov">         10 :           if (strcmp (language_string, &quot;GNU C++11&quot;) == 0)</span>
<span class="lineNum">   24524 </span>            :             language = DW_LANG_C_plus_plus_11;
<span class="lineNum">   24525 </span><span class="lineCov">          7 :           else if (strcmp (language_string, &quot;GNU C++14&quot;) == 0)</span>
<span class="lineNum">   24526 </span>            :             language = DW_LANG_C_plus_plus_14;
<span class="lineNum">   24527 </span><span class="lineCov">          4 :           else if (strcmp (language_string, &quot;GNU C++17&quot;) == 0)</span>
<span class="lineNum">   24528 </span>            :             /* For now.  */
<span class="lineNum">   24529 </span><span class="lineCov">          2 :             language = DW_LANG_C_plus_plus_14;</span>
<span class="lineNum">   24530 </span>            :         }
<span class="lineNum">   24531 </span>            :     }
<span class="lineNum">   24532 </span><span class="lineCov">       6783 :   else if (strcmp (language_string, &quot;GNU F77&quot;) == 0)</span>
<span class="lineNum">   24533 </span>            :     language = DW_LANG_Fortran77;
<span class="lineNum">   24534 </span><span class="lineCov">       6783 :   else if (dwarf_version &gt;= 3 || !dwarf_strict)</span>
<span class="lineNum">   24535 </span>            :     {
<span class="lineNum">   24536 </span><span class="lineCov">       6783 :       if (strcmp (language_string, &quot;GNU Ada&quot;) == 0)</span>
<span class="lineNum">   24537 </span>            :         language = DW_LANG_Ada95;
<span class="lineNum">   24538 </span><span class="lineCov">       6783 :       else if (strncmp (language_string, &quot;GNU Fortran&quot;, 11) == 0)</span>
<span class="lineNum">   24539 </span>            :         {
<span class="lineNum">   24540 </span><span class="lineCov">       3716 :           language = DW_LANG_Fortran95;</span>
<span class="lineNum">   24541 </span><span class="lineCov">       3716 :           if (dwarf_version &gt;= 5 /* || !dwarf_strict */)</span>
<span class="lineNum">   24542 </span>            :             {
<span class="lineNum">   24543 </span><span class="lineNoCov">          0 :               if (strcmp (language_string, &quot;GNU Fortran2003&quot;) == 0)</span>
<span class="lineNum">   24544 </span>            :                 language = DW_LANG_Fortran03;
<span class="lineNum">   24545 </span><span class="lineNoCov">          0 :               else if (strcmp (language_string, &quot;GNU Fortran2008&quot;) == 0)</span>
<span class="lineNum">   24546 </span><span class="lineNoCov">          0 :                 language = DW_LANG_Fortran08;</span>
<span class="lineNum">   24547 </span>            :             }
<span class="lineNum">   24548 </span>            :         }
<span class="lineNum">   24549 </span><span class="lineCov">       3067 :       else if (strcmp (language_string, &quot;GNU Objective-C&quot;) == 0)</span>
<span class="lineNum">   24550 </span>            :         language = DW_LANG_ObjC;
<span class="lineNum">   24551 </span><span class="lineCov">       3067 :       else if (strcmp (language_string, &quot;GNU Objective-C++&quot;) == 0)</span>
<span class="lineNum">   24552 </span>            :         language = DW_LANG_ObjC_plus_plus;
<span class="lineNum">   24553 </span><span class="lineCov">       3067 :       else if (dwarf_version &gt;= 5 || !dwarf_strict)</span>
<span class="lineNum">   24554 </span>            :         {
<span class="lineNum">   24555 </span><span class="lineCov">       3067 :           if (strcmp (language_string, &quot;GNU Go&quot;) == 0)</span>
<span class="lineNum">   24556 </span><span class="lineCov">       2625 :             language = DW_LANG_Go;</span>
<span class="lineNum">   24557 </span>            :         }
<span class="lineNum">   24558 </span>            :     }
<span class="lineNum">   24559 </span>            :   /* Use a degraded Fortran setting in strict DWARF2 so is_fortran works.  */
<span class="lineNum">   24560 </span><span class="lineNoCov">          0 :   else if (strncmp (language_string, &quot;GNU Fortran&quot;, 11) == 0)</span>
<span class="lineNum">   24561 </span>            :     language = DW_LANG_Fortran90;
<span class="lineNum">   24562 </span>            :   /* Likewise for Ada.  */
<span class="lineNum">   24563 </span><span class="lineNoCov">          0 :   else if (strcmp (language_string, &quot;GNU Ada&quot;) == 0)</span>
<span class="lineNum">   24564 </span><span class="lineNoCov">          0 :     language = DW_LANG_Ada83;</span>
<span class="lineNum">   24565 </span>            : 
<span class="lineNum">   24566 </span><span class="lineCov">      37183 :   add_AT_unsigned (die, DW_AT_language, language);</span>
<span class="lineNum">   24567 </span>            : 
<span class="lineNum">   24568 </span><span class="lineCov">      37183 :   switch (language)</span>
<span class="lineNum">   24569 </span>            :     {
<span class="lineNum">   24570 </span><span class="lineCov">       3716 :     case DW_LANG_Fortran77:</span>
<span class="lineNum">   24571 </span><span class="lineCov">       3716 :     case DW_LANG_Fortran90:</span>
<span class="lineNum">   24572 </span><span class="lineCov">       3716 :     case DW_LANG_Fortran95:</span>
<span class="lineNum">   24573 </span><span class="lineCov">       3716 :     case DW_LANG_Fortran03:</span>
<span class="lineNum">   24574 </span><span class="lineCov">       3716 :     case DW_LANG_Fortran08:</span>
<span class="lineNum">   24575 </span>            :       /* Fortran has case insensitive identifiers and the front-end
<span class="lineNum">   24576 </span>            :          lowercases everything.  */
<span class="lineNum">   24577 </span><span class="lineCov">       3716 :       add_AT_unsigned (die, DW_AT_identifier_case, DW_ID_down_case);</span>
<span class="lineNum">   24578 </span>            :       break;
<span class="lineNum">   24579 </span>            :     default:
<span class="lineNum">   24580 </span>            :       /* The default DW_ID_case_sensitive doesn't need to be specified.  */
<span class="lineNum">   24581 </span>            :       break;
<span class="lineNum">   24582 </span>            :     }
<span class="lineNum">   24583 </span><span class="lineCov">      37183 :   return die;</span>
<span class="lineNum">   24584 </span>            : }
<span class="lineNum">   24585 </span>            : 
<span class="lineNum">   24586 </span>            : /* Generate the DIE for a base class.  */
<a name="24587"><span class="lineNum">   24587 </span>            : </a>
<span class="lineNum">   24588 </span>            : static void
<span class="lineNum">   24589 </span><span class="lineCov">    4315927 : gen_inheritance_die (tree binfo, tree access, tree type,</span>
<span class="lineNum">   24590 </span>            :                      dw_die_ref context_die)
<span class="lineNum">   24591 </span>            : {
<span class="lineNum">   24592 </span><span class="lineCov">    4315927 :   dw_die_ref die = new_die (DW_TAG_inheritance, context_die, binfo);</span>
<span class="lineNum">   24593 </span><span class="lineCov">    4315927 :   struct vlr_context ctx = { type, NULL };</span>
<span class="lineNum">   24594 </span>            : 
<span class="lineNum">   24595 </span><span class="lineCov">    4315927 :   add_type_attribute (die, BINFO_TYPE (binfo), TYPE_UNQUALIFIED, false,</span>
<span class="lineNum">   24596 </span>            :                       context_die);
<span class="lineNum">   24597 </span><span class="lineCov">    4315927 :   add_data_member_location_attribute (die, binfo, &amp;ctx);</span>
<span class="lineNum">   24598 </span>            : 
<span class="lineNum">   24599 </span><span class="lineCov">    4315927 :   if (BINFO_VIRTUAL_P (binfo))</span>
<span class="lineNum">   24600 </span><span class="lineCov">        279 :     add_AT_unsigned (die, DW_AT_virtuality, DW_VIRTUALITY_virtual);</span>
<span class="lineNum">   24601 </span>            : 
<span class="lineNum">   24602 </span>            :   /* In DWARF3+ the default is DW_ACCESS_private only in DW_TAG_class_type
<span class="lineNum">   24603 </span>            :      children, otherwise the default is DW_ACCESS_public.  In DWARF2
<span class="lineNum">   24604 </span>            :      the default has always been DW_ACCESS_private.  */
<span class="lineNum">   24605 </span><span class="lineCov">    4315927 :   if (access == access_public_node)</span>
<span class="lineNum">   24606 </span>            :     {
<span class="lineNum">   24607 </span><span class="lineCov">    4230131 :       if (dwarf_version == 2</span>
<span class="lineNum">   24608 </span><span class="lineCov">    4229892 :           || context_die-&gt;die_tag == DW_TAG_class_type)</span>
<span class="lineNum">   24609 </span><span class="lineCov">     170758 :       add_AT_unsigned (die, DW_AT_accessibility, DW_ACCESS_public);</span>
<span class="lineNum">   24610 </span>            :     }
<span class="lineNum">   24611 </span><span class="lineCov">      85796 :   else if (access == access_protected_node)</span>
<span class="lineNum">   24612 </span><span class="lineCov">       3344 :     add_AT_unsigned (die, DW_AT_accessibility, DW_ACCESS_protected);</span>
<span class="lineNum">   24613 </span><span class="lineCov">      82452 :   else if (dwarf_version &gt; 2</span>
<span class="lineNum">   24614 </span><span class="lineCov">      82452 :            &amp;&amp; context_die-&gt;die_tag != DW_TAG_class_type)</span>
<span class="lineNum">   24615 </span><span class="lineCov">      60540 :     add_AT_unsigned (die, DW_AT_accessibility, DW_ACCESS_private);</span>
<span class="lineNum">   24616 </span><span class="lineCov">    4315927 : }</span>
<span class="lineNum">   24617 </span>            : 
<span class="lineNum">   24618 </span>            : /* Return whether DECL is a FIELD_DECL that represents the variant part of a
<a name="24619"><span class="lineNum">   24619 </span>            :    structure.  */</a>
<span class="lineNum">   24620 </span>            : static bool
<span class="lineNum">   24621 </span><span class="lineCov">   25340751 : is_variant_part (tree decl)</span>
<span class="lineNum">   24622 </span>            : {
<span class="lineNum">   24623 </span><span class="lineCov">   25340751 :   return (TREE_CODE (decl) == FIELD_DECL</span>
<span class="lineNum">   24624 </span><span class="lineCov">   25340751 :           &amp;&amp; TREE_CODE (TREE_TYPE (decl)) == QUAL_UNION_TYPE);</span>
<span class="lineNum">   24625 </span>            : }
<span class="lineNum">   24626 </span>            : 
<span class="lineNum">   24627 </span>            : /* Check that OPERAND is a reference to a field in STRUCT_TYPE.  If it is,
<span class="lineNum">   24628 </span>            :    return the FIELD_DECL.  Return NULL_TREE otherwise.  */
<a name="24629"><span class="lineNum">   24629 </span>            : </a>
<span class="lineNum">   24630 </span>            : static tree
<span class="lineNum">   24631 </span><span class="lineNoCov">          0 : analyze_discr_in_predicate (tree operand, tree struct_type)</span>
<span class="lineNum">   24632 </span>            : {
<span class="lineNum">   24633 </span><span class="lineNoCov">          0 :   bool continue_stripping = true;</span>
<span class="lineNum">   24634 </span><span class="lineNoCov">          0 :   while (continue_stripping)</span>
<span class="lineNum">   24635 </span><span class="lineNoCov">          0 :     switch (TREE_CODE (operand))</span>
<span class="lineNum">   24636 </span>            :       {
<span class="lineNum">   24637 </span><span class="lineNoCov">          0 :       CASE_CONVERT:</span>
<span class="lineNum">   24638 </span><span class="lineNoCov">          0 :         operand = TREE_OPERAND (operand, 0);</span>
<span class="lineNum">   24639 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">   24640 </span>            :       default:
<span class="lineNum">   24641 </span>            :         continue_stripping = false;
<span class="lineNum">   24642 </span>            :         break;
<span class="lineNum">   24643 </span>            :       }
<span class="lineNum">   24644 </span>            : 
<span class="lineNum">   24645 </span>            :   /* Match field access to members of struct_type only.  */
<span class="lineNum">   24646 </span><span class="lineNoCov">          0 :   if (TREE_CODE (operand) == COMPONENT_REF</span>
<span class="lineNum">   24647 </span><span class="lineNoCov">          0 :       &amp;&amp; TREE_CODE (TREE_OPERAND (operand, 0)) == PLACEHOLDER_EXPR</span>
<span class="lineNum">   24648 </span><span class="lineNoCov">          0 :       &amp;&amp; TREE_TYPE (TREE_OPERAND (operand, 0)) == struct_type</span>
<span class="lineNum">   24649 </span><span class="lineNoCov">          0 :       &amp;&amp; TREE_CODE (TREE_OPERAND (operand, 1)) == FIELD_DECL)</span>
<span class="lineNum">   24650 </span><span class="lineNoCov">          0 :     return TREE_OPERAND (operand, 1);</span>
<span class="lineNum">   24651 </span>            :   else
<span class="lineNum">   24652 </span>            :     return NULL_TREE;
<span class="lineNum">   24653 </span>            : }
<span class="lineNum">   24654 </span>            : 
<span class="lineNum">   24655 </span>            : /* Check that SRC is a constant integer that can be represented as a native
<span class="lineNum">   24656 </span>            :    integer constant (either signed or unsigned).  If so, store it into DEST and
<span class="lineNum">   24657 </span>            :    return true.  Return false otherwise. */
<a name="24658"><span class="lineNum">   24658 </span>            : </a>
<span class="lineNum">   24659 </span>            : static bool
<span class="lineNum">   24660 </span><span class="lineNoCov">          0 : get_discr_value (tree src, dw_discr_value *dest)</span>
<span class="lineNum">   24661 </span>            : {
<span class="lineNum">   24662 </span><span class="lineNoCov">          0 :   tree discr_type = TREE_TYPE (src);</span>
<span class="lineNum">   24663 </span>            : 
<span class="lineNum">   24664 </span><span class="lineNoCov">          0 :   if (lang_hooks.types.get_debug_type)</span>
<span class="lineNum">   24665 </span>            :     {
<span class="lineNum">   24666 </span><span class="lineNoCov">          0 :       tree debug_type = lang_hooks.types.get_debug_type (discr_type);</span>
<span class="lineNum">   24667 </span><span class="lineNoCov">          0 :       if (debug_type != NULL)</span>
<span class="lineNum">   24668 </span><span class="lineNoCov">          0 :         discr_type = debug_type;</span>
<span class="lineNum">   24669 </span>            :     }
<span class="lineNum">   24670 </span>            : 
<span class="lineNum">   24671 </span><span class="lineNoCov">          0 :   if (TREE_CODE (src) != INTEGER_CST || !INTEGRAL_TYPE_P (discr_type))</span>
<span class="lineNum">   24672 </span>            :     return false;
<span class="lineNum">   24673 </span>            : 
<span class="lineNum">   24674 </span>            :   /* Signedness can vary between the original type and the debug type. This
<span class="lineNum">   24675 </span>            :      can happen for character types in Ada for instance: the character type
<span class="lineNum">   24676 </span>            :      used for code generation can be signed, to be compatible with the C one,
<span class="lineNum">   24677 </span>            :      but from a debugger point of view, it must be unsigned.  */
<span class="lineNum">   24678 </span><span class="lineNoCov">          0 :   bool is_orig_unsigned = TYPE_UNSIGNED (TREE_TYPE (src));</span>
<span class="lineNum">   24679 </span><span class="lineNoCov">          0 :   bool is_debug_unsigned = TYPE_UNSIGNED (discr_type);</span>
<span class="lineNum">   24680 </span>            : 
<span class="lineNum">   24681 </span><span class="lineNoCov">          0 :   if (is_orig_unsigned != is_debug_unsigned)</span>
<span class="lineNum">   24682 </span><span class="lineNoCov">          0 :     src = fold_convert (discr_type, src);</span>
<span class="lineNum">   24683 </span>            : 
<span class="lineNum">   24684 </span><span class="lineNoCov">          0 :   if (!(is_debug_unsigned ? tree_fits_uhwi_p (src) : tree_fits_shwi_p (src)))</span>
<span class="lineNum">   24685 </span>            :     return false;
<span class="lineNum">   24686 </span>            : 
<span class="lineNum">   24687 </span><span class="lineNoCov">          0 :   dest-&gt;pos = is_debug_unsigned;</span>
<span class="lineNum">   24688 </span><span class="lineNoCov">          0 :   if (is_debug_unsigned)</span>
<span class="lineNum">   24689 </span><span class="lineNoCov">          0 :     dest-&gt;v.uval = tree_to_uhwi (src);</span>
<span class="lineNum">   24690 </span>            :   else
<span class="lineNum">   24691 </span><span class="lineNoCov">          0 :     dest-&gt;v.sval = tree_to_shwi (src);</span>
<span class="lineNum">   24692 </span>            : 
<span class="lineNum">   24693 </span>            :   return true;
<span class="lineNum">   24694 </span>            : }
<span class="lineNum">   24695 </span>            : 
<span class="lineNum">   24696 </span>            : /* Try to extract synthetic properties out of VARIANT_PART_DECL, which is a
<span class="lineNum">   24697 </span>            :    FIELD_DECL in STRUCT_TYPE that represents a variant part.  If unsuccessful,
<span class="lineNum">   24698 </span>            :    store NULL_TREE in DISCR_DECL.  Otherwise:
<span class="lineNum">   24699 </span>            : 
<span class="lineNum">   24700 </span>            :      - store the discriminant field in STRUCT_TYPE that controls the variant
<span class="lineNum">   24701 </span>            :        part to *DISCR_DECL
<span class="lineNum">   24702 </span>            : 
<span class="lineNum">   24703 </span>            :      - put in *DISCR_LISTS_P an array where for each variant, the item
<span class="lineNum">   24704 </span>            :        represents the corresponding matching list of discriminant values.
<span class="lineNum">   24705 </span>            : 
<span class="lineNum">   24706 </span>            :      - put in *DISCR_LISTS_LENGTH the number of variants, which is the size of
<span class="lineNum">   24707 </span>            :        the above array.
<span class="lineNum">   24708 </span>            : 
<span class="lineNum">   24709 </span>            :    Note that when the array is allocated (i.e. when the analysis is
<span class="lineNum">   24710 </span>            :    successful), it is up to the caller to free the array.  */
<a name="24711"><span class="lineNum">   24711 </span>            : </a>
<span class="lineNum">   24712 </span>            : static void
<span class="lineNum">   24713 </span><span class="lineNoCov">          0 : analyze_variants_discr (tree variant_part_decl,</span>
<span class="lineNum">   24714 </span>            :                         tree struct_type,
<span class="lineNum">   24715 </span>            :                         tree *discr_decl,
<span class="lineNum">   24716 </span>            :                         dw_discr_list_ref **discr_lists_p,
<span class="lineNum">   24717 </span>            :                         unsigned *discr_lists_length)
<span class="lineNum">   24718 </span>            : {
<span class="lineNum">   24719 </span><span class="lineNoCov">          0 :   tree variant_part_type = TREE_TYPE (variant_part_decl);</span>
<span class="lineNum">   24720 </span><span class="lineNoCov">          0 :   tree variant;</span>
<span class="lineNum">   24721 </span><span class="lineNoCov">          0 :   dw_discr_list_ref *discr_lists;</span>
<span class="lineNum">   24722 </span><span class="lineNoCov">          0 :   unsigned i;</span>
<span class="lineNum">   24723 </span>            : 
<span class="lineNum">   24724 </span>            :   /* Compute how many variants there are in this variant part.  */
<span class="lineNum">   24725 </span><span class="lineNoCov">          0 :   *discr_lists_length = 0;</span>
<span class="lineNum">   24726 </span><span class="lineNoCov">          0 :   for (variant = TYPE_FIELDS (variant_part_type);</span>
<span class="lineNum">   24727 </span><span class="lineNoCov">          0 :        variant != NULL_TREE;</span>
<span class="lineNum">   24728 </span><span class="lineNoCov">          0 :        variant = DECL_CHAIN (variant))</span>
<span class="lineNum">   24729 </span><span class="lineNoCov">          0 :     ++*discr_lists_length;</span>
<span class="lineNum">   24730 </span>            : 
<span class="lineNum">   24731 </span><span class="lineNoCov">          0 :   *discr_decl = NULL_TREE;</span>
<span class="lineNum">   24732 </span><span class="lineNoCov">          0 :   *discr_lists_p</span>
<span class="lineNum">   24733 </span><span class="lineNoCov">          0 :     = (dw_discr_list_ref *) xcalloc (*discr_lists_length,</span>
<span class="lineNum">   24734 </span>            :                                      sizeof (**discr_lists_p));
<span class="lineNum">   24735 </span><span class="lineNoCov">          0 :   discr_lists = *discr_lists_p;</span>
<span class="lineNum">   24736 </span>            : 
<span class="lineNum">   24737 </span>            :   /* And then analyze all variants to extract discriminant information for all
<span class="lineNum">   24738 </span>            :      of them.  This analysis is conservative: as soon as we detect something we
<span class="lineNum">   24739 </span>            :      do not support, abort everything and pretend we found nothing.  */
<span class="lineNum">   24740 </span><span class="lineNoCov">          0 :   for (variant = TYPE_FIELDS (variant_part_type), i = 0;</span>
<span class="lineNum">   24741 </span><span class="lineNoCov">          0 :        variant != NULL_TREE;</span>
<span class="lineNum">   24742 </span><span class="lineNoCov">          0 :        variant = DECL_CHAIN (variant), ++i)</span>
<span class="lineNum">   24743 </span>            :     {
<span class="lineNum">   24744 </span><span class="lineNoCov">          0 :       tree match_expr = DECL_QUALIFIER (variant);</span>
<span class="lineNum">   24745 </span>            : 
<span class="lineNum">   24746 </span>            :       /* Now, try to analyze the predicate and deduce a discriminant for
<span class="lineNum">   24747 </span>            :          it.  */
<span class="lineNum">   24748 </span><span class="lineNoCov">          0 :       if (match_expr == boolean_true_node)</span>
<span class="lineNum">   24749 </span>            :         /* Typically happens for the default variant: it matches all cases that
<span class="lineNum">   24750 </span>            :            previous variants rejected.  Don't output any matching value for
<span class="lineNum">   24751 </span>            :            this one.  */
<span class="lineNum">   24752 </span>            :         continue;
<span class="lineNum">   24753 </span>            : 
<span class="lineNum">   24754 </span>            :       /* The following loop tries to iterate over each discriminant
<span class="lineNum">   24755 </span>            :          possibility: single values or ranges.  */
<span class="lineNum">   24756 </span><span class="lineNoCov">          0 :       while (match_expr != NULL_TREE)</span>
<span class="lineNum">   24757 </span>            :         {
<span class="lineNum">   24758 </span><span class="lineNoCov">          0 :           tree next_round_match_expr;</span>
<span class="lineNum">   24759 </span><span class="lineNoCov">          0 :           tree candidate_discr = NULL_TREE;</span>
<span class="lineNum">   24760 </span><span class="lineNoCov">          0 :           dw_discr_list_ref new_node = NULL;</span>
<span class="lineNum">   24761 </span>            : 
<span class="lineNum">   24762 </span>            :           /* Possibilities are matched one after the other by nested
<span class="lineNum">   24763 </span>            :              TRUTH_ORIF_EXPR expressions.  Process the current possibility and
<span class="lineNum">   24764 </span>            :              continue with the rest at next iteration.  */
<span class="lineNum">   24765 </span><span class="lineNoCov">          0 :           if (TREE_CODE (match_expr) == TRUTH_ORIF_EXPR)</span>
<span class="lineNum">   24766 </span>            :             {
<span class="lineNum">   24767 </span><span class="lineNoCov">          0 :               next_round_match_expr = TREE_OPERAND (match_expr, 0);</span>
<span class="lineNum">   24768 </span><span class="lineNoCov">          0 :               match_expr = TREE_OPERAND (match_expr, 1);</span>
<span class="lineNum">   24769 </span>            :             }
<span class="lineNum">   24770 </span>            :           else
<span class="lineNum">   24771 </span>            :             next_round_match_expr = NULL_TREE;
<span class="lineNum">   24772 </span>            : 
<span class="lineNum">   24773 </span><span class="lineNoCov">          0 :           if (match_expr == boolean_false_node)</span>
<span class="lineNum">   24774 </span>            :             /* This sub-expression matches nothing: just wait for the next
<span class="lineNum">   24775 </span>            :                one.  */
<span class="lineNum">   24776 </span>            :             ;
<span class="lineNum">   24777 </span>            : 
<span class="lineNum">   24778 </span><span class="lineNoCov">          0 :           else if (TREE_CODE (match_expr) == EQ_EXPR)</span>
<span class="lineNum">   24779 </span>            :             {
<span class="lineNum">   24780 </span>            :               /* We are matching:  &lt;discr_field&gt; == &lt;integer_cst&gt;
<span class="lineNum">   24781 </span>            :                  This sub-expression matches a single value.  */
<span class="lineNum">   24782 </span><span class="lineNoCov">          0 :               tree integer_cst = TREE_OPERAND (match_expr, 1);</span>
<span class="lineNum">   24783 </span>            : 
<span class="lineNum">   24784 </span><span class="lineNoCov">          0 :               candidate_discr</span>
<span class="lineNum">   24785 </span><span class="lineNoCov">          0 :                = analyze_discr_in_predicate (TREE_OPERAND (match_expr, 0),</span>
<span class="lineNum">   24786 </span>            :                                              struct_type);
<span class="lineNum">   24787 </span>            : 
<span class="lineNum">   24788 </span><span class="lineNoCov">          0 :               new_node = ggc_cleared_alloc&lt;dw_discr_list_node&gt; ();</span>
<span class="lineNum">   24789 </span><span class="lineNoCov">          0 :               if (!get_discr_value (integer_cst,</span>
<span class="lineNum">   24790 </span>            :                                     &amp;new_node-&gt;dw_discr_lower_bound))
<span class="lineNum">   24791 </span><span class="lineNoCov">          0 :                 goto abort;</span>
<span class="lineNum">   24792 </span><span class="lineNoCov">          0 :               new_node-&gt;dw_discr_range = false;</span>
<span class="lineNum">   24793 </span>            :             }
<span class="lineNum">   24794 </span>            : 
<span class="lineNum">   24795 </span><span class="lineNoCov">          0 :           else if (TREE_CODE (match_expr) == TRUTH_ANDIF_EXPR)</span>
<span class="lineNum">   24796 </span>            :             {
<span class="lineNum">   24797 </span>            :               /* We are matching:
<span class="lineNum">   24798 </span>            :                    &lt;discr_field&gt; &gt; &lt;integer_cst&gt;
<span class="lineNum">   24799 </span>            :                    &amp;&amp; &lt;discr_field&gt; &lt; &lt;integer_cst&gt;.
<span class="lineNum">   24800 </span>            :                  This sub-expression matches the range of values between the
<span class="lineNum">   24801 </span>            :                  two matched integer constants.  Note that comparisons can be
<span class="lineNum">   24802 </span>            :                  inclusive or exclusive.  */
<span class="lineNum">   24803 </span><span class="lineNoCov">          0 :               tree candidate_discr_1, candidate_discr_2;</span>
<span class="lineNum">   24804 </span><span class="lineNoCov">          0 :               tree lower_cst, upper_cst;</span>
<span class="lineNum">   24805 </span><span class="lineNoCov">          0 :               bool lower_cst_included, upper_cst_included;</span>
<span class="lineNum">   24806 </span><span class="lineNoCov">          0 :               tree lower_op = TREE_OPERAND (match_expr, 0);</span>
<span class="lineNum">   24807 </span><span class="lineNoCov">          0 :               tree upper_op = TREE_OPERAND (match_expr, 1);</span>
<span class="lineNum">   24808 </span>            : 
<span class="lineNum">   24809 </span>            :               /* When the comparison is exclusive, the integer constant is not
<span class="lineNum">   24810 </span>            :                  the discriminant range bound we are looking for: we will have
<span class="lineNum">   24811 </span>            :                  to increment or decrement it.  */
<span class="lineNum">   24812 </span><span class="lineNoCov">          0 :               if (TREE_CODE (lower_op) == GE_EXPR)</span>
<span class="lineNum">   24813 </span>            :                 lower_cst_included = true;
<span class="lineNum">   24814 </span><span class="lineNoCov">          0 :               else if (TREE_CODE (lower_op) == GT_EXPR)</span>
<span class="lineNum">   24815 </span>            :                 lower_cst_included = false;
<span class="lineNum">   24816 </span>            :               else
<span class="lineNum">   24817 </span>            :                 goto abort;
<span class="lineNum">   24818 </span>            : 
<span class="lineNum">   24819 </span><span class="lineNoCov">          0 :               if (TREE_CODE (upper_op) == LE_EXPR)</span>
<span class="lineNum">   24820 </span>            :                 upper_cst_included = true;
<span class="lineNum">   24821 </span><span class="lineNoCov">          0 :               else if (TREE_CODE (upper_op) == LT_EXPR)</span>
<span class="lineNum">   24822 </span>            :                 upper_cst_included = false;
<span class="lineNum">   24823 </span>            :               else
<span class="lineNum">   24824 </span>            :                 goto abort;
<span class="lineNum">   24825 </span>            : 
<span class="lineNum">   24826 </span>            :               /* Extract the discriminant from the first operand and check it
<span class="lineNum">   24827 </span>            :                  is consistant with the same analysis in the second
<span class="lineNum">   24828 </span>            :                  operand.  */
<span class="lineNum">   24829 </span><span class="lineNoCov">          0 :               candidate_discr_1</span>
<span class="lineNum">   24830 </span><span class="lineNoCov">          0 :                 = analyze_discr_in_predicate (TREE_OPERAND (lower_op, 0),</span>
<span class="lineNum">   24831 </span>            :                                               struct_type);
<span class="lineNum">   24832 </span><span class="lineNoCov">          0 :               candidate_discr_2</span>
<span class="lineNum">   24833 </span><span class="lineNoCov">          0 :                 = analyze_discr_in_predicate (TREE_OPERAND (upper_op, 0),</span>
<span class="lineNum">   24834 </span>            :                                               struct_type);
<span class="lineNum">   24835 </span><span class="lineNoCov">          0 :               if (candidate_discr_1 == candidate_discr_2)</span>
<span class="lineNum">   24836 </span><span class="lineNoCov">          0 :                 candidate_discr = candidate_discr_1;</span>
<span class="lineNum">   24837 </span>            :               else
<span class="lineNum">   24838 </span>            :                 goto abort;
<span class="lineNum">   24839 </span>            : 
<span class="lineNum">   24840 </span>            :               /* Extract bounds from both.  */
<span class="lineNum">   24841 </span><span class="lineNoCov">          0 :               new_node = ggc_cleared_alloc&lt;dw_discr_list_node&gt; ();</span>
<span class="lineNum">   24842 </span><span class="lineNoCov">          0 :               lower_cst = TREE_OPERAND (lower_op, 1);</span>
<span class="lineNum">   24843 </span><span class="lineNoCov">          0 :               upper_cst = TREE_OPERAND (upper_op, 1);</span>
<span class="lineNum">   24844 </span>            : 
<span class="lineNum">   24845 </span><span class="lineNoCov">          0 :               if (!lower_cst_included)</span>
<span class="lineNum">   24846 </span><span class="lineNoCov">          0 :                 lower_cst</span>
<span class="lineNum">   24847 </span><span class="lineNoCov">          0 :                   = fold_build2 (PLUS_EXPR, TREE_TYPE (lower_cst), lower_cst,</span>
<span class="lineNum">   24848 </span>            :                                  build_int_cst (TREE_TYPE (lower_cst), 1));
<span class="lineNum">   24849 </span><span class="lineNoCov">          0 :               if (!upper_cst_included)</span>
<span class="lineNum">   24850 </span><span class="lineNoCov">          0 :                 upper_cst</span>
<span class="lineNum">   24851 </span><span class="lineNoCov">          0 :                   = fold_build2 (MINUS_EXPR, TREE_TYPE (upper_cst), upper_cst,</span>
<span class="lineNum">   24852 </span>            :                                  build_int_cst (TREE_TYPE (upper_cst), 1));
<span class="lineNum">   24853 </span>            : 
<span class="lineNum">   24854 </span><span class="lineNoCov">          0 :               if (!get_discr_value (lower_cst,</span>
<span class="lineNum">   24855 </span>            :                                     &amp;new_node-&gt;dw_discr_lower_bound)
<span class="lineNum">   24856 </span><span class="lineNoCov">          0 :                   || !get_discr_value (upper_cst,</span>
<span class="lineNum">   24857 </span>            :                                        &amp;new_node-&gt;dw_discr_upper_bound))
<span class="lineNum">   24858 </span><span class="lineNoCov">          0 :                 goto abort;</span>
<span class="lineNum">   24859 </span>            : 
<span class="lineNum">   24860 </span><span class="lineNoCov">          0 :               new_node-&gt;dw_discr_range = true;</span>
<span class="lineNum">   24861 </span>            :             }
<span class="lineNum">   24862 </span>            : 
<span class="lineNum">   24863 </span>            :           else
<span class="lineNum">   24864 </span>            :             /* Unsupported sub-expression: we cannot determine the set of
<span class="lineNum">   24865 </span>            :                matching discriminant values.  Abort everything.  */
<span class="lineNum">   24866 </span>            :             goto abort;
<span class="lineNum">   24867 </span>            : 
<span class="lineNum">   24868 </span>            :           /* If the discriminant info is not consistant with what we saw so
<span class="lineNum">   24869 </span>            :              far, consider the analysis failed and abort everything.  */
<span class="lineNum">   24870 </span><span class="lineNoCov">          0 :           if (candidate_discr == NULL_TREE</span>
<span class="lineNum">   24871 </span><span class="lineNoCov">          0 :               || (*discr_decl != NULL_TREE &amp;&amp; candidate_discr != *discr_decl))</span>
<span class="lineNum">   24872 </span><span class="lineNoCov">          0 :             goto abort;</span>
<span class="lineNum">   24873 </span>            :           else
<span class="lineNum">   24874 </span><span class="lineNoCov">          0 :             *discr_decl = candidate_discr;</span>
<span class="lineNum">   24875 </span>            : 
<span class="lineNum">   24876 </span><span class="lineNoCov">          0 :           if (new_node != NULL)</span>
<span class="lineNum">   24877 </span>            :             {
<span class="lineNum">   24878 </span><span class="lineNoCov">          0 :               new_node-&gt;dw_discr_next = discr_lists[i];</span>
<span class="lineNum">   24879 </span><span class="lineNoCov">          0 :               discr_lists[i] = new_node;</span>
<span class="lineNum">   24880 </span>            :             }
<span class="lineNum">   24881 </span>            :           match_expr = next_round_match_expr;
<span class="lineNum">   24882 </span>            :         }
<span class="lineNum">   24883 </span>            :     }
<span class="lineNum">   24884 </span>            : 
<span class="lineNum">   24885 </span>            :   /* If we reach this point, we could match everything we were interested
<span class="lineNum">   24886 </span>            :      in.  */
<span class="lineNum">   24887 </span>            :   return;
<span class="lineNum">   24888 </span>            : 
<span class="lineNum">   24889 </span><span class="lineNoCov">          0 : abort:</span>
<span class="lineNum">   24890 </span>            :   /* Clean all data structure and return no result.  */
<span class="lineNum">   24891 </span><span class="lineNoCov">          0 :   free (*discr_lists_p);</span>
<span class="lineNum">   24892 </span><span class="lineNoCov">          0 :   *discr_lists_p = NULL;</span>
<span class="lineNum">   24893 </span><span class="lineNoCov">          0 :   *discr_decl = NULL_TREE;</span>
<span class="lineNum">   24894 </span>            : }
<span class="lineNum">   24895 </span>            : 
<span class="lineNum">   24896 </span>            : /* Generate a DIE to represent VARIANT_PART_DECL, a variant part that is part
<span class="lineNum">   24897 </span>            :    of STRUCT_TYPE, a record type.  This new DIE is emitted as the next child
<span class="lineNum">   24898 </span>            :    under CONTEXT_DIE.
<span class="lineNum">   24899 </span>            : 
<span class="lineNum">   24900 </span>            :    Variant parts are supposed to be implemented as a FIELD_DECL whose type is a
<span class="lineNum">   24901 </span>            :    QUAL_UNION_TYPE: this is the VARIANT_PART_DECL parameter.  The members for
<span class="lineNum">   24902 </span>            :    this type, which are record types, represent the available variants and each
<span class="lineNum">   24903 </span>            :    has a DECL_QUALIFIER attribute.  The discriminant and the discriminant
<span class="lineNum">   24904 </span>            :    values are inferred from these attributes.
<span class="lineNum">   24905 </span>            : 
<span class="lineNum">   24906 </span>            :    In trees, the offsets for the fields inside these sub-records are relative
<span class="lineNum">   24907 </span>            :    to the variant part itself, whereas the corresponding DIEs should have
<span class="lineNum">   24908 </span>            :    offset attributes that are relative to the embedding record base address.
<span class="lineNum">   24909 </span>            :    This is why the caller must provide a VARIANT_PART_OFFSET expression: it
<span class="lineNum">   24910 </span>            :    must be an expression that computes the offset of the variant part to
<span class="lineNum">   24911 </span>            :    describe in DWARF.  */
<a name="24912"><span class="lineNum">   24912 </span>            : </a>
<span class="lineNum">   24913 </span>            : static void
<span class="lineNum">   24914 </span><span class="lineNoCov">          0 : gen_variant_part (tree variant_part_decl, struct vlr_context *vlr_ctx,</span>
<span class="lineNum">   24915 </span>            :                   dw_die_ref context_die)
<span class="lineNum">   24916 </span>            : {
<span class="lineNum">   24917 </span><span class="lineNoCov">          0 :   const tree variant_part_type = TREE_TYPE (variant_part_decl);</span>
<span class="lineNum">   24918 </span><span class="lineNoCov">          0 :   tree variant_part_offset = vlr_ctx-&gt;variant_part_offset;</span>
<span class="lineNum">   24919 </span><span class="lineNoCov">          0 :   struct loc_descr_context ctx = {</span>
<span class="lineNum">   24920 </span><span class="lineNoCov">          0 :     vlr_ctx-&gt;struct_type, /* context_type */</span>
<span class="lineNum">   24921 </span>            :     NULL_TREE,            /* base_decl */
<span class="lineNum">   24922 </span>            :     NULL,                 /* dpi */
<span class="lineNum">   24923 </span>            :     false,                /* placeholder_arg */
<span class="lineNum">   24924 </span>            :     false                 /* placeholder_seen */
<span class="lineNum">   24925 </span><span class="lineNoCov">          0 :   };</span>
<span class="lineNum">   24926 </span>            : 
<span class="lineNum">   24927 </span>            :   /* The FIELD_DECL node in STRUCT_TYPE that acts as the discriminant, or
<span class="lineNum">   24928 </span>            :      NULL_TREE if there is no such field.  */
<span class="lineNum">   24929 </span><span class="lineNoCov">          0 :   tree discr_decl = NULL_TREE;</span>
<span class="lineNum">   24930 </span><span class="lineNoCov">          0 :   dw_discr_list_ref *discr_lists;</span>
<span class="lineNum">   24931 </span><span class="lineNoCov">          0 :   unsigned discr_lists_length = 0;</span>
<span class="lineNum">   24932 </span><span class="lineNoCov">          0 :   unsigned i;</span>
<span class="lineNum">   24933 </span>            : 
<span class="lineNum">   24934 </span><span class="lineNoCov">          0 :   dw_die_ref dwarf_proc_die = NULL;</span>
<span class="lineNum">   24935 </span><span class="lineNoCov">          0 :   dw_die_ref variant_part_die</span>
<span class="lineNum">   24936 </span><span class="lineNoCov">          0 :     = new_die (DW_TAG_variant_part, context_die, variant_part_type);</span>
<span class="lineNum">   24937 </span>            : 
<span class="lineNum">   24938 </span><span class="lineNoCov">          0 :   equate_decl_number_to_die (variant_part_decl, variant_part_die);</span>
<span class="lineNum">   24939 </span>            : 
<span class="lineNum">   24940 </span><span class="lineNoCov">          0 :   analyze_variants_discr (variant_part_decl, vlr_ctx-&gt;struct_type,</span>
<span class="lineNum">   24941 </span>            :                           &amp;discr_decl, &amp;discr_lists, &amp;discr_lists_length);
<span class="lineNum">   24942 </span>            : 
<span class="lineNum">   24943 </span><span class="lineNoCov">          0 :   if (discr_decl != NULL_TREE)</span>
<span class="lineNum">   24944 </span>            :     {
<span class="lineNum">   24945 </span><span class="lineNoCov">          0 :       dw_die_ref discr_die = lookup_decl_die (discr_decl);</span>
<span class="lineNum">   24946 </span>            : 
<span class="lineNum">   24947 </span><span class="lineNoCov">          0 :       if (discr_die)</span>
<span class="lineNum">   24948 </span><span class="lineNoCov">          0 :         add_AT_die_ref (variant_part_die, DW_AT_discr, discr_die);</span>
<span class="lineNum">   24949 </span>            :       else
<span class="lineNum">   24950 </span>            :         /* We have no DIE for the discriminant, so just discard all
<span class="lineNum">   24951 </span>            :            discrimimant information in the output.  */
<span class="lineNum">   24952 </span><span class="lineNoCov">          0 :         discr_decl = NULL_TREE;</span>
<span class="lineNum">   24953 </span>            :     }
<span class="lineNum">   24954 </span>            : 
<span class="lineNum">   24955 </span>            :   /* If the offset for this variant part is more complex than a constant,
<span class="lineNum">   24956 </span>            :      create a DWARF procedure for it so that we will not have to generate DWARF
<span class="lineNum">   24957 </span>            :      expressions for it for each member.  */
<span class="lineNum">   24958 </span><span class="lineNoCov">          0 :   if (TREE_CODE (variant_part_offset) != INTEGER_CST</span>
<span class="lineNum">   24959 </span><span class="lineNoCov">          0 :       &amp;&amp; (dwarf_version &gt;= 3 || !dwarf_strict))</span>
<span class="lineNum">   24960 </span>            :     {
<span class="lineNum">   24961 </span><span class="lineNoCov">          0 :       const tree dwarf_proc_fndecl</span>
<span class="lineNum">   24962 </span><span class="lineNoCov">          0 :         = build_decl (UNKNOWN_LOCATION, FUNCTION_DECL, NULL_TREE,</span>
<span class="lineNum">   24963 </span><span class="lineNoCov">          0 :                       build_function_type (TREE_TYPE (variant_part_offset),</span>
<span class="lineNum">   24964 </span>            :                                            NULL_TREE));
<span class="lineNum">   24965 </span><span class="lineNoCov">          0 :       const tree dwarf_proc_call = build_call_expr (dwarf_proc_fndecl, 0);</span>
<span class="lineNum">   24966 </span><span class="lineNoCov">          0 :       const dw_loc_descr_ref dwarf_proc_body</span>
<span class="lineNum">   24967 </span><span class="lineNoCov">          0 :         = loc_descriptor_from_tree (variant_part_offset, 0, &amp;ctx);</span>
<span class="lineNum">   24968 </span>            : 
<span class="lineNum">   24969 </span><span class="lineNoCov">          0 :       dwarf_proc_die = new_dwarf_proc_die (dwarf_proc_body,</span>
<span class="lineNum">   24970 </span>            :                                            dwarf_proc_fndecl, context_die);
<span class="lineNum">   24971 </span><span class="lineNoCov">          0 :       if (dwarf_proc_die != NULL)</span>
<span class="lineNum">   24972 </span><span class="lineNoCov">          0 :         variant_part_offset = dwarf_proc_call;</span>
<span class="lineNum">   24973 </span>            :     }
<span class="lineNum">   24974 </span>            : 
<span class="lineNum">   24975 </span>            :   /* Output DIEs for all variants.  */
<span class="lineNum">   24976 </span><span class="lineNoCov">          0 :   i = 0;</span>
<span class="lineNum">   24977 </span><span class="lineNoCov">          0 :   for (tree variant = TYPE_FIELDS (variant_part_type);</span>
<span class="lineNum">   24978 </span><span class="lineNoCov">          0 :        variant != NULL_TREE;</span>
<span class="lineNum">   24979 </span><span class="lineNoCov">          0 :        variant = DECL_CHAIN (variant), ++i)</span>
<span class="lineNum">   24980 </span>            :     {
<span class="lineNum">   24981 </span><span class="lineNoCov">          0 :       tree variant_type = TREE_TYPE (variant);</span>
<span class="lineNum">   24982 </span><span class="lineNoCov">          0 :       dw_die_ref variant_die;</span>
<span class="lineNum">   24983 </span>            : 
<span class="lineNum">   24984 </span>            :       /* All variants (i.e. members of a variant part) are supposed to be
<span class="lineNum">   24985 </span>            :          encoded as structures.  Sub-variant parts are QUAL_UNION_TYPE fields
<span class="lineNum">   24986 </span>            :          under these records.  */
<span class="lineNum">   24987 </span><span class="lineNoCov">          0 :       gcc_assert (TREE_CODE (variant_type) == RECORD_TYPE);</span>
<span class="lineNum">   24988 </span>            : 
<span class="lineNum">   24989 </span><span class="lineNoCov">          0 :       variant_die = new_die (DW_TAG_variant, variant_part_die, variant_type);</span>
<span class="lineNum">   24990 </span><span class="lineNoCov">          0 :       equate_decl_number_to_die (variant, variant_die);</span>
<span class="lineNum">   24991 </span>            : 
<span class="lineNum">   24992 </span>            :       /* Output discriminant values this variant matches, if any.  */
<span class="lineNum">   24993 </span><span class="lineNoCov">          0 :       if (discr_decl == NULL || discr_lists[i] == NULL)</span>
<span class="lineNum">   24994 </span>            :         /* In the case we have discriminant information at all, this is
<span class="lineNum">   24995 </span>            :            probably the default variant: as the standard says, don't
<span class="lineNum">   24996 </span>            :            output any discriminant value/list attribute.  */
<span class="lineNum">   24997 </span>            :         ;
<span class="lineNum">   24998 </span><span class="lineNoCov">          0 :       else if (discr_lists[i]-&gt;dw_discr_next == NULL</span>
<span class="lineNum">   24999 </span><span class="lineNoCov">          0 :                &amp;&amp; !discr_lists[i]-&gt;dw_discr_range)</span>
<span class="lineNum">   25000 </span>            :         /* If there is only one accepted value, don't bother outputting a
<span class="lineNum">   25001 </span>            :            list.  */
<span class="lineNum">   25002 </span><span class="lineNoCov">          0 :         add_discr_value (variant_die, &amp;discr_lists[i]-&gt;dw_discr_lower_bound);</span>
<span class="lineNum">   25003 </span>            :       else
<span class="lineNum">   25004 </span><span class="lineNoCov">          0 :         add_discr_list (variant_die, discr_lists[i]);</span>
<span class="lineNum">   25005 </span>            : 
<span class="lineNum">   25006 </span><span class="lineNoCov">          0 :       for (tree member = TYPE_FIELDS (variant_type);</span>
<span class="lineNum">   25007 </span><span class="lineNoCov">          0 :            member != NULL_TREE;</span>
<span class="lineNum">   25008 </span><span class="lineNoCov">          0 :            member = DECL_CHAIN (member))</span>
<span class="lineNum">   25009 </span>            :         {
<span class="lineNum">   25010 </span><span class="lineNoCov">          0 :           struct vlr_context vlr_sub_ctx = {</span>
<span class="lineNum">   25011 </span><span class="lineNoCov">          0 :             vlr_ctx-&gt;struct_type, /* struct_type */</span>
<span class="lineNum">   25012 </span>            :             NULL                  /* variant_part_offset */
<span class="lineNum">   25013 </span><span class="lineNoCov">          0 :           };</span>
<span class="lineNum">   25014 </span><span class="lineNoCov">          0 :           if (is_variant_part (member))</span>
<span class="lineNum">   25015 </span>            :             {
<span class="lineNum">   25016 </span>            :               /* All offsets for fields inside variant parts are relative to
<span class="lineNum">   25017 </span>            :                  the top-level embedding RECORD_TYPE's base address.  On the
<span class="lineNum">   25018 </span>            :                  other hand, offsets in GCC's types are relative to the
<span class="lineNum">   25019 </span>            :                  nested-most variant part.  So we have to sum offsets each time
<span class="lineNum">   25020 </span>            :                  we recurse.  */
<span class="lineNum">   25021 </span>            : 
<span class="lineNum">   25022 </span><span class="lineNoCov">          0 :               vlr_sub_ctx.variant_part_offset</span>
<span class="lineNum">   25023 </span><span class="lineNoCov">          0 :                 = fold_build2 (PLUS_EXPR, TREE_TYPE (variant_part_offset),</span>
<span class="lineNum">   25024 </span>            :                                variant_part_offset, byte_position (member));
<span class="lineNum">   25025 </span><span class="lineNoCov">          0 :               gen_variant_part (member, &amp;vlr_sub_ctx, variant_die);</span>
<span class="lineNum">   25026 </span>            :             }
<span class="lineNum">   25027 </span>            :           else
<span class="lineNum">   25028 </span>            :             {
<span class="lineNum">   25029 </span><span class="lineNoCov">          0 :               vlr_sub_ctx.variant_part_offset = variant_part_offset;</span>
<span class="lineNum">   25030 </span><span class="lineNoCov">          0 :               gen_decl_die (member, NULL, &amp;vlr_sub_ctx, variant_die);</span>
<span class="lineNum">   25031 </span>            :             }
<span class="lineNum">   25032 </span>            :         }
<span class="lineNum">   25033 </span>            :     }
<span class="lineNum">   25034 </span>            : 
<span class="lineNum">   25035 </span><span class="lineNoCov">          0 :   free (discr_lists);</span>
<span class="lineNum">   25036 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   25037 </span>            : 
<span class="lineNum">   25038 </span>            : /* Generate a DIE for a class member.  */
<a name="25039"><span class="lineNum">   25039 </span>            : </a>
<span class="lineNum">   25040 </span>            : static void
<span class="lineNum">   25041 </span><span class="lineCov">    8257743 : gen_member_die (tree type, dw_die_ref context_die)</span>
<span class="lineNum">   25042 </span>            : {
<span class="lineNum">   25043 </span><span class="lineCov">    8257743 :   tree member;</span>
<span class="lineNum">   25044 </span><span class="lineCov">    8257743 :   tree binfo = TYPE_BINFO (type);</span>
<span class="lineNum">   25045 </span>            : 
<span class="lineNum">   25046 </span><span class="lineCov">    8257743 :   gcc_assert (TYPE_MAIN_VARIANT (type) == type);</span>
<span class="lineNum">   25047 </span>            : 
<span class="lineNum">   25048 </span>            :   /* If this is not an incomplete type, output descriptions of each of its
<span class="lineNum">   25049 </span>            :      members. Note that as we output the DIEs necessary to represent the
<span class="lineNum">   25050 </span>            :      members of this record or union type, we will also be trying to output
<span class="lineNum">   25051 </span>            :      DIEs to represent the *types* of those members. However the `type'
<span class="lineNum">   25052 </span>            :      function (above) will specifically avoid generating type DIEs for member
<span class="lineNum">   25053 </span>            :      types *within* the list of member DIEs for this (containing) type except
<span class="lineNum">   25054 </span>            :      for those types (of members) which are explicitly marked as also being
<span class="lineNum">   25055 </span>            :      members of this (containing) type themselves.  The g++ front- end can
<span class="lineNum">   25056 </span>            :      force any given type to be treated as a member of some other (containing)
<span class="lineNum">   25057 </span>            :      type by setting the TYPE_CONTEXT of the given (member) type to point to
<span class="lineNum">   25058 </span>            :      the TREE node representing the appropriate (containing) type.  */
<span class="lineNum">   25059 </span>            : 
<span class="lineNum">   25060 </span>            :   /* First output info about the base classes.  */
<span class="lineNum">   25061 </span><span class="lineCov">    8257743 :   if (binfo)</span>
<span class="lineNum">   25062 </span>            :     {
<span class="lineNum">   25063 </span><span class="lineCov">    7909571 :       vec&lt;tree, va_gc&gt; *accesses = BINFO_BASE_ACCESSES (binfo);</span>
<span class="lineNum">   25064 </span><span class="lineCov">    7909571 :       int i;</span>
<span class="lineNum">   25065 </span><span class="lineCov">    7909571 :       tree base;</span>
<span class="lineNum">   25066 </span>            : 
<span class="lineNum">   25067 </span><span class="lineCov">   12225498 :       for (i = 0; BINFO_BASE_ITERATE (binfo, i, base); i++)</span>
<span class="lineNum">   25068 </span><span class="lineCov">    8631851 :         gen_inheritance_die (base,</span>
<span class="lineNum">   25069 </span><span class="lineCov">    4315924 :                              (accesses ? (*accesses)[i] : access_public_node),</span>
<span class="lineNum">   25070 </span>            :                              type,
<span class="lineNum">   25071 </span>            :                              context_die);
<span class="lineNum">   25072 </span>            :     }
<span class="lineNum">   25073 </span>            : 
<span class="lineNum">   25074 </span>            :   /* Now output info about the data members and type members.  */
<span class="lineNum">   25075 </span><span class="lineCov">   37591650 :   for (member = TYPE_FIELDS (type); member; member = DECL_CHAIN (member))</span>
<span class="lineNum">   25076 </span>            :     {
<span class="lineNum">   25077 </span><span class="lineCov">   29217785 :       struct vlr_context vlr_ctx = { type, NULL_TREE };</span>
<span class="lineNum">   25078 </span><span class="lineCov">   29217785 :       bool static_inline_p</span>
<span class="lineNum">   25079 </span>            :         = (TREE_STATIC (member)
<span class="lineNum">   25080 </span><span class="lineCov">    1576377 :            &amp;&amp; (lang_hooks.decls.decl_dwarf_attribute (member, DW_AT_inline)</span>
<span class="lineNum">   25081 </span><span class="lineCov">   29217785 :                != -1));</span>
<span class="lineNum">   25082 </span>            : 
<span class="lineNum">   25083 </span>            :       /* Ignore clones.  */
<span class="lineNum">   25084 </span><span class="lineCov">   29217785 :       if (DECL_ABSTRACT_ORIGIN (member))</span>
<span class="lineNum">   25085 </span><span class="lineCov">    3643057 :         continue;</span>
<span class="lineNum">   25086 </span>            : 
<span class="lineNum">   25087 </span>            :       /* If we thought we were generating minimal debug info for TYPE
<span class="lineNum">   25088 </span>            :          and then changed our minds, some of the member declarations
<span class="lineNum">   25089 </span>            :          may have already been defined.  Don't define them again, but
<span class="lineNum">   25090 </span>            :          do put them in the right order.  */
<span class="lineNum">   25091 </span>            : 
<span class="lineNum">   25092 </span><span class="lineCov">   25574728 :       if (dw_die_ref child = lookup_decl_die (member))</span>
<span class="lineNum">   25093 </span>            :         {
<span class="lineNum">   25094 </span>            :           /* Handle inline static data members, which only have in-class
<span class="lineNum">   25095 </span>            :              declarations.  */
<span class="lineNum">   25096 </span><span class="lineCov">     233977 :           dw_die_ref ref = NULL; </span>
<span class="lineNum">   25097 </span><span class="lineCov">     233977 :           if (child-&gt;die_tag == DW_TAG_variable</span>
<span class="lineNum">   25098 </span><span class="lineCov">     233977 :               &amp;&amp; child-&gt;die_parent == comp_unit_die ())</span>
<span class="lineNum">   25099 </span>            :             {
<span class="lineNum">   25100 </span><span class="lineCov">     233781 :               ref = get_AT_ref (child, DW_AT_specification);</span>
<span class="lineNum">   25101 </span>            :               /* For C++17 inline static data members followed by redundant
<span class="lineNum">   25102 </span>            :                  out of class redeclaration, we might get here with
<span class="lineNum">   25103 </span>            :                  child being the DIE created for the out of class
<span class="lineNum">   25104 </span>            :                  redeclaration and with its DW_AT_specification being
<span class="lineNum">   25105 </span>            :                  the DIE created for in-class definition.  We want to
<span class="lineNum">   25106 </span>            :                  reparent the latter, and don't want to create another
<span class="lineNum">   25107 </span>            :                  DIE with DW_AT_specification in that case, because
<span class="lineNum">   25108 </span>            :                  we already have one.  */
<span class="lineNum">   25109 </span><span class="lineCov">     233781 :               if (ref</span>
<span class="lineNum">   25110 </span><span class="lineCov">     233781 :                   &amp;&amp; static_inline_p</span>
<span class="lineNum">   25111 </span><span class="lineCov">          2 :                   &amp;&amp; ref-&gt;die_tag == DW_TAG_variable</span>
<span class="lineNum">   25112 </span><span class="lineCov">          2 :                   &amp;&amp; ref-&gt;die_parent == comp_unit_die ()</span>
<span class="lineNum">   25113 </span><span class="lineCov">     233783 :                   &amp;&amp; get_AT (ref, DW_AT_specification) == NULL)</span>
<span class="lineNum">   25114 </span>            :                 {
<span class="lineNum">   25115 </span>            :                   child = ref;
<span class="lineNum">   25116 </span>            :                   ref = NULL;
<span class="lineNum">   25117 </span>            :                   static_inline_p = false;
<span class="lineNum">   25118 </span>            :                 }
<span class="lineNum">   25119 </span>            :             }
<span class="lineNum">   25120 </span>            : 
<span class="lineNum">   25121 </span><span class="lineCov">     233977 :           if (child-&gt;die_tag == DW_TAG_variable</span>
<span class="lineNum">   25122 </span><span class="lineCov">     233781 :               &amp;&amp; child-&gt;die_parent == comp_unit_die ()</span>
<span class="lineNum">   25123 </span><span class="lineCov">     467758 :               &amp;&amp; ref == NULL)</span>
<span class="lineNum">   25124 </span>            :             {
<span class="lineNum">   25125 </span><span class="lineCov">     233550 :               reparent_child (child, context_die);</span>
<span class="lineNum">   25126 </span><span class="lineCov">     233550 :               if (dwarf_version &lt; 5)</span>
<span class="lineNum">   25127 </span><span class="lineCov">     233546 :                 child-&gt;die_tag = DW_TAG_member;</span>
<span class="lineNum">   25128 </span>            :             }
<span class="lineNum">   25129 </span>            :           else
<span class="lineNum">   25130 </span><span class="lineCov">        427 :             splice_child_die (context_die, child);</span>
<span class="lineNum">   25131 </span>            :         }
<span class="lineNum">   25132 </span>            : 
<span class="lineNum">   25133 </span>            :       /* Do not generate standard DWARF for variant parts if we are generating
<span class="lineNum">   25134 </span>            :          the corresponding GNAT encodings: DIEs generated for both would
<span class="lineNum">   25135 </span>            :          conflict in our mappings.  */
<span class="lineNum">   25136 </span><span class="lineCov">   25340751 :       else if (is_variant_part (member)</span>
<span class="lineNum">   25137 </span><span class="lineCov">   25340751 :                &amp;&amp; gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)</span>
<span class="lineNum">   25138 </span>            :         {
<span class="lineNum">   25139 </span><span class="lineNoCov">          0 :           vlr_ctx.variant_part_offset = byte_position (member);</span>
<span class="lineNum">   25140 </span><span class="lineNoCov">          0 :           gen_variant_part (member, &amp;vlr_ctx, context_die);</span>
<span class="lineNum">   25141 </span>            :         }
<span class="lineNum">   25142 </span>            :       else
<span class="lineNum">   25143 </span>            :         {
<span class="lineNum">   25144 </span><span class="lineCov">   25340751 :           vlr_ctx.variant_part_offset = NULL_TREE;</span>
<span class="lineNum">   25145 </span><span class="lineCov">   25340751 :           gen_decl_die (member, NULL, &amp;vlr_ctx, context_die);</span>
<span class="lineNum">   25146 </span>            :         }
<span class="lineNum">   25147 </span>            : 
<span class="lineNum">   25148 </span>            :       /* For C++ inline static data members emit immediately a DW_TAG_variable
<span class="lineNum">   25149 </span>            :          DIE that will refer to that DW_TAG_member/DW_TAG_variable through
<span class="lineNum">   25150 </span>            :          DW_AT_specification.  */
<span class="lineNum">   25151 </span><span class="lineCov">   25574728 :       if (static_inline_p)</span>
<span class="lineNum">   25152 </span>            :         {
<span class="lineNum">   25153 </span><span class="lineCov">     249048 :           int old_extern = DECL_EXTERNAL (member);</span>
<span class="lineNum">   25154 </span><span class="lineCov">     249048 :           DECL_EXTERNAL (member) = 0;</span>
<span class="lineNum">   25155 </span><span class="lineCov">     249048 :           gen_decl_die (member, NULL, NULL, comp_unit_die ());</span>
<span class="lineNum">   25156 </span><span class="lineCov">     249048 :           DECL_EXTERNAL (member) = old_extern;</span>
<span class="lineNum">   25157 </span>            :         }
<span class="lineNum">   25158 </span>            :     }
<span class="lineNum">   25159 </span><span class="lineCov">    8257743 : }</span>
<span class="lineNum">   25160 </span>            : 
<span class="lineNum">   25161 </span>            : /* Generate a DIE for a structure or union type.  If TYPE_DECL_SUPPRESS_DEBUG
<span class="lineNum">   25162 </span>            :    is set, we pretend that the type was never defined, so we only get the
<span class="lineNum">   25163 </span>            :    member DIEs needed by later specification DIEs.  */
<a name="25164"><span class="lineNum">   25164 </span>            : </a>
<span class="lineNum">   25165 </span>            : static void
<span class="lineNum">   25166 </span><span class="lineCov">   20812186 : gen_struct_or_union_type_die (tree type, dw_die_ref context_die,</span>
<span class="lineNum">   25167 </span>            :                                 enum debug_info_usage usage)
<span class="lineNum">   25168 </span>            : {
<span class="lineNum">   25169 </span><span class="lineCov">   20812186 :   if (TREE_ASM_WRITTEN (type))</span>
<span class="lineNum">   25170 </span>            :     {
<span class="lineNum">   25171 </span>            :       /* Fill in the bound of variable-length fields in late dwarf if
<span class="lineNum">   25172 </span>            :          still incomplete.  */
<span class="lineNum">   25173 </span><span class="lineCov">        123 :       if (!early_dwarf &amp;&amp; variably_modified_type_p (type, NULL))</span>
<span class="lineNum">   25174 </span><span class="lineCov">         67 :         for (tree member = TYPE_FIELDS (type);</span>
<span class="lineNum">   25175 </span><span class="lineCov">        161 :              member;</span>
<span class="lineNum">   25176 </span><span class="lineCov">         98 :              member = DECL_CHAIN (member))</span>
<span class="lineNum">   25177 </span><span class="lineCov">         98 :           fill_variable_array_bounds (TREE_TYPE (member));</span>
<span class="lineNum">   25178 </span><span class="lineCov">        123 :       return;</span>
<span class="lineNum">   25179 </span>            :     }
<span class="lineNum">   25180 </span>            : 
<span class="lineNum">   25181 </span><span class="lineCov">   20812063 :   dw_die_ref type_die = lookup_type_die (type);</span>
<span class="lineNum">   25182 </span><span class="lineCov">   20812063 :   dw_die_ref scope_die = 0;</span>
<span class="lineNum">   25183 </span><span class="lineCov">   20812063 :   int nested = 0;</span>
<span class="lineNum">   25184 </span><span class="lineCov">   20812063 :   int complete = (TYPE_SIZE (type)</span>
<span class="lineNum">   25185 </span><span class="lineCov">   20812063 :                   &amp;&amp; (! TYPE_STUB_DECL (type)</span>
<span class="lineNum">   25186 </span><span class="lineCov">   49539753 :                       || ! TYPE_DECL_SUPPRESS_DEBUG (TYPE_STUB_DECL (type))));</span>
<span class="lineNum">   25187 </span><span class="lineCov">   20812063 :   int ns_decl = (context_die &amp;&amp; context_die-&gt;die_tag == DW_TAG_namespace);</span>
<span class="lineNum">   25188 </span><span class="lineCov">   20812063 :   complete = complete &amp;&amp; should_emit_struct_debug (type, usage);</span>
<span class="lineNum">   25189 </span>            : 
<span class="lineNum">   25190 </span><span class="lineCov">   20812063 :   if (type_die &amp;&amp; ! complete)</span>
<span class="lineNum">   25191 </span>            :     return;
<span class="lineNum">   25192 </span>            : 
<span class="lineNum">   25193 </span><span class="lineCov">   17054244 :   if (TYPE_CONTEXT (type) != NULL_TREE</span>
<span class="lineNum">   25194 </span><span class="lineCov">   17054244 :       &amp;&amp; (AGGREGATE_TYPE_P (TYPE_CONTEXT (type))</span>
<span class="lineNum">   25195 </span><span class="lineCov">   32880770 :           || TREE_CODE (TYPE_CONTEXT (type)) == NAMESPACE_DECL))</span>
<span class="lineNum">   25196 </span>            :     nested = 1;
<span class="lineNum">   25197 </span>            : 
<span class="lineNum">   25198 </span><span class="lineCov">   17054244 :   scope_die = scope_die_for (type, context_die);</span>
<span class="lineNum">   25199 </span>            : 
<span class="lineNum">   25200 </span>            :   /* Generate child dies for template paramaters.  */
<span class="lineNum">   25201 </span><span class="lineCov">   17054244 :   if (!type_die &amp;&amp; debug_info_level &gt; DINFO_LEVEL_TERSE)</span>
<span class="lineNum">   25202 </span><span class="lineCov">    8397671 :     schedule_generic_params_dies_gen (type);</span>
<span class="lineNum">   25203 </span>            : 
<span class="lineNum">   25204 </span><span class="lineCov">   17054244 :   if (! type_die || (nested &amp;&amp; is_cu_die (scope_die)))</span>
<span class="lineNum">   25205 </span>            :     /* First occurrence of type or toplevel definition of nested class.  */
<span class="lineNum">   25206 </span>            :     {
<span class="lineNum">   25207 </span><span class="lineCov">    8397671 :       dw_die_ref old_die = type_die;</span>
<span class="lineNum">   25208 </span>            : 
<span class="lineNum">   25209 </span><span class="lineCov">   16678595 :       type_die = new_die (TREE_CODE (type) == RECORD_TYPE</span>
<span class="lineNum">   25210 </span><span class="lineCov">    8280924 :                           ? record_type_tag (type) : DW_TAG_union_type,</span>
<span class="lineNum">   25211 </span>            :                           scope_die, type);
<span class="lineNum">   25212 </span><span class="lineCov">    8397671 :       equate_type_number_to_die (type, type_die);</span>
<span class="lineNum">   25213 </span><span class="lineCov">    8397671 :       if (old_die)</span>
<span class="lineNum">   25214 </span><span class="lineNoCov">          0 :         add_AT_specification (type_die, old_die);</span>
<span class="lineNum">   25215 </span>            :       else
<span class="lineNum">   25216 </span><span class="lineCov">    8397671 :         add_name_attribute (type_die, type_tag (type));</span>
<span class="lineNum">   25217 </span>            :     }
<span class="lineNum">   25218 </span>            :   else
<span class="lineNum">   25219 </span><span class="lineCov">    8656573 :     remove_AT (type_die, DW_AT_declaration);</span>
<span class="lineNum">   25220 </span>            : 
<span class="lineNum">   25221 </span>            :   /* If this type has been completed, then give it a byte_size attribute and
<span class="lineNum">   25222 </span>            :      then give a list of members.  */
<span class="lineNum">   25223 </span><span class="lineCov">   17054244 :   if (complete &amp;&amp; !ns_decl)</span>
<span class="lineNum">   25224 </span>            :     {
<span class="lineNum">   25225 </span>            :       /* Prevent infinite recursion in cases where the type of some member of
<span class="lineNum">   25226 </span>            :          this type is expressed in terms of this type itself.  */
<span class="lineNum">   25227 </span><span class="lineCov">    8257743 :       TREE_ASM_WRITTEN (type) = 1;</span>
<span class="lineNum">   25228 </span><span class="lineCov">    8257743 :       add_byte_size_attribute (type_die, type);</span>
<span class="lineNum">   25229 </span><span class="lineCov">    8257743 :       add_alignment_attribute (type_die, type);</span>
<span class="lineNum">   25230 </span><span class="lineCov">    8257743 :       if (TYPE_STUB_DECL (type) != NULL_TREE)</span>
<span class="lineNum">   25231 </span>            :         {
<span class="lineNum">   25232 </span><span class="lineCov">   24690024 :           add_src_coords_attributes (type_die, TYPE_STUB_DECL (type));</span>
<span class="lineNum">   25233 </span><span class="lineCov">    8230008 :           add_accessibility_attribute (type_die, TYPE_STUB_DECL (type));</span>
<span class="lineNum">   25234 </span>            :         }
<span class="lineNum">   25235 </span>            : 
<span class="lineNum">   25236 </span>            :       /* If the first reference to this type was as the return type of an
<span class="lineNum">   25237 </span>            :          inline function, then it may not have a parent.  Fix this now.  */
<span class="lineNum">   25238 </span><span class="lineCov">    8257743 :       if (type_die-&gt;die_parent == NULL)</span>
<span class="lineNum">   25239 </span><span class="lineCov">        820 :         add_child_die (scope_die, type_die);</span>
<span class="lineNum">   25240 </span>            : 
<span class="lineNum">   25241 </span><span class="lineCov">    8257743 :       gen_member_die (type, type_die);</span>
<span class="lineNum">   25242 </span>            : 
<span class="lineNum">   25243 </span><span class="lineCov">    8257743 :       add_gnat_descriptive_type_attribute (type_die, type, context_die);</span>
<span class="lineNum">   25244 </span><span class="lineCov">    8257743 :       if (TYPE_ARTIFICIAL (type))</span>
<span class="lineNum">   25245 </span><span class="lineCov">        824 :         add_AT_flag (type_die, DW_AT_artificial, 1);</span>
<span class="lineNum">   25246 </span>            : 
<span class="lineNum">   25247 </span>            :       /* GNU extension: Record what type our vtable lives in.  */
<span class="lineNum">   25248 </span><span class="lineCov">    8373865 :       if (TYPE_VFIELD (type))</span>
<span class="lineNum">   25249 </span>            :         {
<span class="lineNum">   25250 </span><span class="lineCov">      93996 :           tree vtype = DECL_FCONTEXT (TYPE_VFIELD (type));</span>
<span class="lineNum">   25251 </span>            : 
<span class="lineNum">   25252 </span><span class="lineCov">      93996 :           gen_type_die (vtype, context_die);</span>
<span class="lineNum">   25253 </span><span class="lineCov">      93996 :           add_AT_die_ref (type_die, DW_AT_containing_type,</span>
<span class="lineNum">   25254 </span>            :                           lookup_type_die (vtype));
<span class="lineNum">   25255 </span>            :         }
<span class="lineNum">   25256 </span>            :     }
<span class="lineNum">   25257 </span>            :   else
<span class="lineNum">   25258 </span>            :     {
<span class="lineNum">   25259 </span><span class="lineCov">    8796501 :       add_AT_flag (type_die, DW_AT_declaration, 1);</span>
<span class="lineNum">   25260 </span>            : 
<span class="lineNum">   25261 </span>            :       /* We don't need to do this for function-local types.  */
<span class="lineNum">   25262 </span><span class="lineCov">    8796501 :       if (TYPE_STUB_DECL (type)</span>
<span class="lineNum">   25263 </span><span class="lineCov">    8796501 :           &amp;&amp; ! decl_function_context (TYPE_STUB_DECL (type)))</span>
<span class="lineNum">   25264 </span><span class="lineCov">    8796391 :         vec_safe_push (incomplete_types, type);</span>
<span class="lineNum">   25265 </span>            :     }
<span class="lineNum">   25266 </span>            : 
<span class="lineNum">   25267 </span><span class="lineCov">   17054244 :   if (get_AT (type_die, DW_AT_name))</span>
<span class="lineNum">   25268 </span><span class="lineCov">   16760132 :     add_pubtype (type, type_die);</span>
<span class="lineNum">   25269 </span>            : }
<span class="lineNum">   25270 </span>            : 
<span class="lineNum">   25271 </span>            : /* Generate a DIE for a subroutine _type_.  */
<a name="25272"><span class="lineNum">   25272 </span>            : </a>
<span class="lineNum">   25273 </span>            : static void
<span class="lineNum">   25274 </span><span class="lineCov">     105775 : gen_subroutine_type_die (tree type, dw_die_ref context_die)</span>
<span class="lineNum">   25275 </span>            : {
<span class="lineNum">   25276 </span><span class="lineCov">     105775 :   tree return_type = TREE_TYPE (type);</span>
<span class="lineNum">   25277 </span><span class="lineCov">     105775 :   dw_die_ref subr_die</span>
<span class="lineNum">   25278 </span><span class="lineCov">     105775 :     = new_die (DW_TAG_subroutine_type,</span>
<span class="lineNum">   25279 </span>            :                scope_die_for (type, context_die), type);
<span class="lineNum">   25280 </span>            : 
<span class="lineNum">   25281 </span><span class="lineCov">     105775 :   equate_type_number_to_die (type, subr_die);</span>
<span class="lineNum">   25282 </span><span class="lineCov">     105775 :   add_prototyped_attribute (subr_die, type);</span>
<span class="lineNum">   25283 </span><span class="lineCov">     105775 :   add_type_attribute (subr_die, return_type, TYPE_UNQUALIFIED, false,</span>
<span class="lineNum">   25284 </span>            :                       context_die);
<span class="lineNum">   25285 </span><span class="lineCov">     105775 :   add_alignment_attribute (subr_die, type);</span>
<span class="lineNum">   25286 </span><span class="lineCov">     105775 :   gen_formal_types_die (type, subr_die);</span>
<span class="lineNum">   25287 </span>            : 
<span class="lineNum">   25288 </span><span class="lineCov">     105775 :   if (get_AT (subr_die, DW_AT_name))</span>
<span class="lineNum">   25289 </span><span class="lineNoCov">          0 :     add_pubtype (type, subr_die);</span>
<span class="lineNum">   25290 </span><span class="lineCov">     105774 :   if ((dwarf_version &gt;= 5 || !dwarf_strict)</span>
<span class="lineNum">   25291 </span><span class="lineCov">     211543 :       &amp;&amp; lang_hooks.types.type_dwarf_attribute (type, DW_AT_reference) != -1)</span>
<span class="lineNum">   25292 </span><span class="lineCov">         61 :     add_AT_flag (subr_die, DW_AT_reference, 1);</span>
<span class="lineNum">   25293 </span><span class="lineCov">     105774 :   if ((dwarf_version &gt;= 5 || !dwarf_strict)</span>
<span class="lineNum">   25294 </span><span class="lineCov">     211543 :       &amp;&amp; lang_hooks.types.type_dwarf_attribute (type,</span>
<span class="lineNum">   25295 </span>            :                                                 DW_AT_rvalue_reference) != -1)
<span class="lineNum">   25296 </span><span class="lineCov">         20 :     add_AT_flag (subr_die, DW_AT_rvalue_reference, 1);</span>
<span class="lineNum">   25297 </span><span class="lineCov">     105775 : }</span>
<span class="lineNum">   25298 </span>            : 
<span class="lineNum">   25299 </span>            : /* Generate a DIE for a type definition.  */
<a name="25300"><span class="lineNum">   25300 </span>            : </a>
<span class="lineNum">   25301 </span>            : static void
<span class="lineNum">   25302 </span><span class="lineCov">    8827257 : gen_typedef_die (tree decl, dw_die_ref context_die)</span>
<span class="lineNum">   25303 </span>            : {
<span class="lineNum">   25304 </span><span class="lineCov">    8827257 :   dw_die_ref type_die;</span>
<span class="lineNum">   25305 </span><span class="lineCov">    8827257 :   tree type;</span>
<span class="lineNum">   25306 </span>            : 
<span class="lineNum">   25307 </span><span class="lineCov">    8827257 :   if (TREE_ASM_WRITTEN (decl))</span>
<span class="lineNum">   25308 </span>            :     {
<span class="lineNum">   25309 </span><span class="lineCov">    1402580 :       if (DECL_ORIGINAL_TYPE (decl))</span>
<span class="lineNum">   25310 </span><span class="lineCov">    2749988 :         fill_variable_array_bounds (DECL_ORIGINAL_TYPE (decl));</span>
<span class="lineNum">   25311 </span><span class="lineCov">    1402580 :       return;</span>
<span class="lineNum">   25312 </span>            :     }
<span class="lineNum">   25313 </span>            : 
<span class="lineNum">   25314 </span>            :   /* As we avoid creating DIEs for local typedefs (see decl_ultimate_origin
<span class="lineNum">   25315 </span>            :      checks in process_scope_var and modified_type_die), this should be called
<span class="lineNum">   25316 </span>            :      only for original types.  */
<span class="lineNum">   25317 </span><span class="lineCov">    7424677 :   gcc_assert (decl_ultimate_origin (decl) == NULL</span>
<span class="lineNum">   25318 </span>            :               || decl_ultimate_origin (decl) == decl);
<span class="lineNum">   25319 </span>            : 
<span class="lineNum">   25320 </span><span class="lineCov">    7424677 :   TREE_ASM_WRITTEN (decl) = 1;</span>
<span class="lineNum">   25321 </span><span class="lineCov">    7424677 :   type_die = new_die (DW_TAG_typedef, context_die, decl);</span>
<span class="lineNum">   25322 </span>            : 
<span class="lineNum">   25323 </span><span class="lineCov">    7424677 :   add_name_and_src_coords_attributes (type_die, decl);</span>
<span class="lineNum">   25324 </span><span class="lineCov">    7424677 :   if (DECL_ORIGINAL_TYPE (decl))</span>
<span class="lineNum">   25325 </span>            :     {
<span class="lineNum">   25326 </span><span class="lineCov">    7386645 :       type = DECL_ORIGINAL_TYPE (decl);</span>
<span class="lineNum">   25327 </span><span class="lineCov">    7386645 :       if (type == error_mark_node)</span>
<span class="lineNum">   25328 </span>            :         return;
<span class="lineNum">   25329 </span>            : 
<span class="lineNum">   25330 </span><span class="lineCov">    7386645 :       gcc_assert (type != TREE_TYPE (decl));</span>
<span class="lineNum">   25331 </span><span class="lineCov">   14773290 :       equate_type_number_to_die (TREE_TYPE (decl), type_die);</span>
<span class="lineNum">   25332 </span>            :     }
<span class="lineNum">   25333 </span>            :   else
<span class="lineNum">   25334 </span>            :     {
<span class="lineNum">   25335 </span><span class="lineCov">      38032 :       type = TREE_TYPE (decl);</span>
<span class="lineNum">   25336 </span><span class="lineCov">      38032 :       if (type == error_mark_node)</span>
<span class="lineNum">   25337 </span>            :         return;
<span class="lineNum">   25338 </span>            : 
<span class="lineNum">   25339 </span><span class="lineCov">      38032 :       if (is_naming_typedef_decl (TYPE_NAME (type)))</span>
<span class="lineNum">   25340 </span>            :         {
<span class="lineNum">   25341 </span>            :           /* Here, we are in the case of decl being a typedef naming
<span class="lineNum">   25342 </span>            :              an anonymous type, e.g:
<span class="lineNum">   25343 </span>            :                  typedef struct {...} foo;
<span class="lineNum">   25344 </span>            :              In that case TREE_TYPE (decl) is not a typedef variant
<span class="lineNum">   25345 </span>            :              type and TYPE_NAME of the anonymous type is set to the
<span class="lineNum">   25346 </span>            :              TYPE_DECL of the typedef. This construct is emitted by
<span class="lineNum">   25347 </span>            :              the C++ FE.
<span class="lineNum">   25348 </span>            : 
<span class="lineNum">   25349 </span>            :              TYPE is the anonymous struct named by the typedef
<span class="lineNum">   25350 </span>            :              DECL. As we need the DW_AT_type attribute of the
<span class="lineNum">   25351 </span>            :              DW_TAG_typedef to point to the DIE of TYPE, let's
<span class="lineNum">   25352 </span>            :              generate that DIE right away. add_type_attribute
<span class="lineNum">   25353 </span>            :              called below will then pick (via lookup_type_die) that
<span class="lineNum">   25354 </span>            :              anonymous struct DIE.  */
<span class="lineNum">   25355 </span><span class="lineCov">      38026 :           if (!TREE_ASM_WRITTEN (type))</span>
<span class="lineNum">   25356 </span><span class="lineCov">         45 :             gen_tagged_type_die (type, context_die, DINFO_USAGE_DIR_USE);</span>
<span class="lineNum">   25357 </span>            : 
<span class="lineNum">   25358 </span>            :           /* This is a GNU Extension.  We are adding a
<span class="lineNum">   25359 </span>            :              DW_AT_linkage_name attribute to the DIE of the
<span class="lineNum">   25360 </span>            :              anonymous struct TYPE.  The value of that attribute
<span class="lineNum">   25361 </span>            :              is the name of the typedef decl naming the anonymous
<span class="lineNum">   25362 </span>            :              struct.  This greatly eases the work of consumers of
<span class="lineNum">   25363 </span>            :              this debug info.  */
<span class="lineNum">   25364 </span><span class="lineCov">      38026 :           add_linkage_name_raw (lookup_type_die (type), decl);</span>
<span class="lineNum">   25365 </span>            :         }
<span class="lineNum">   25366 </span>            :     }
<span class="lineNum">   25367 </span>            : 
<span class="lineNum">   25368 </span><span class="lineCov">    7424677 :   add_type_attribute (type_die, type, decl_quals (decl), false,</span>
<span class="lineNum">   25369 </span>            :                       context_die);
<span class="lineNum">   25370 </span>            : 
<span class="lineNum">   25371 </span><span class="lineCov">    7424677 :   if (is_naming_typedef_decl (decl))</span>
<span class="lineNum">   25372 </span>            :     /* We want that all subsequent calls to lookup_type_die with
<span class="lineNum">   25373 </span>            :        TYPE in argument yield the DW_TAG_typedef we have just
<span class="lineNum">   25374 </span>            :        created.  */
<span class="lineNum">   25375 </span><span class="lineCov">      38026 :     equate_type_number_to_die (type, type_die);</span>
<span class="lineNum">   25376 </span>            : 
<span class="lineNum">   25377 </span><span class="lineCov">    7424677 :   add_alignment_attribute (type_die, TREE_TYPE (decl));</span>
<span class="lineNum">   25378 </span>            : 
<span class="lineNum">   25379 </span><span class="lineCov">    7424677 :   add_accessibility_attribute (type_die, decl);</span>
<span class="lineNum">   25380 </span>            : 
<span class="lineNum">   25381 </span><span class="lineCov">    7424677 :   if (DECL_ABSTRACT_P (decl))</span>
<span class="lineNum">   25382 </span><span class="lineCov">       2908 :     equate_decl_number_to_die (decl, type_die);</span>
<span class="lineNum">   25383 </span>            : 
<span class="lineNum">   25384 </span><span class="lineCov">    7424677 :   if (get_AT (type_die, DW_AT_name))</span>
<span class="lineNum">   25385 </span><span class="lineCov">    7424669 :     add_pubtype (decl, type_die);</span>
<span class="lineNum">   25386 </span>            : }
<span class="lineNum">   25387 </span>            : 
<span class="lineNum">   25388 </span>            : /* Generate a DIE for a struct, class, enum or union type.  */
<a name="25389"><span class="lineNum">   25389 </span>            : </a>
<span class="lineNum">   25390 </span>            : static void
<span class="lineNum">   25391 </span><span class="lineCov">   21091582 : gen_tagged_type_die (tree type,</span>
<span class="lineNum">   25392 </span>            :                      dw_die_ref context_die,
<span class="lineNum">   25393 </span>            :                      enum debug_info_usage usage)
<span class="lineNum">   25394 </span>            : {
<span class="lineNum">   25395 </span><span class="lineCov">   21091582 :   if (type == NULL_TREE</span>
<span class="lineNum">   25396 </span><span class="lineCov">   21091582 :       || !is_tagged_type (type))</span>
<span class="lineNum">   25397 </span>            :     return;
<span class="lineNum">   25398 </span>            : 
<span class="lineNum">   25399 </span><span class="lineCov">   21091582 :   if (TREE_ASM_WRITTEN (type))</span>
<span class="lineNum">   25400 </span>            :     ;
<span class="lineNum">   25401 </span>            :   /* If this is a nested type whose containing class hasn't been written
<span class="lineNum">   25402 </span>            :      out yet, writing it out will cover this one, too.  This does not apply
<span class="lineNum">   25403 </span>            :      to instantiations of member class templates; they need to be added to
<span class="lineNum">   25404 </span>            :      the containing class as they are generated.  FIXME: This hurts the
<span class="lineNum">   25405 </span>            :      idea of combining type decls from multiple TUs, since we can't predict
<span class="lineNum">   25406 </span>            :      what set of template instantiations we'll get.  */
<span class="lineNum">   25407 </span><span class="lineCov">   21091459 :   else if (TYPE_CONTEXT (type)</span>
<span class="lineNum">   25408 </span><span class="lineCov">   41240270 :       &amp;&amp; AGGREGATE_TYPE_P (TYPE_CONTEXT (type))</span>
<span class="lineNum">   25409 </span><span class="lineCov">   22129175 :       &amp;&amp; ! TREE_ASM_WRITTEN (TYPE_CONTEXT (type)))</span>
<span class="lineNum">   25410 </span>            :     {
<span class="lineNum">   25411 </span><span class="lineCov">     358062 :       gen_type_die_with_usage (TYPE_CONTEXT (type), context_die, usage);</span>
<span class="lineNum">   25412 </span>            : 
<span class="lineNum">   25413 </span><span class="lineCov">     179031 :       if (TREE_ASM_WRITTEN (type))</span>
<span class="lineNum">   25414 </span>            :         return;
<span class="lineNum">   25415 </span>            : 
<span class="lineNum">   25416 </span>            :       /* If that failed, attach ourselves to the stub.  */
<span class="lineNum">   25417 </span><span class="lineCov">     179031 :       context_die = lookup_type_die (TYPE_CONTEXT (type));</span>
<span class="lineNum">   25418 </span>            :     }
<span class="lineNum">   25419 </span><span class="lineCov">   20912428 :   else if (TYPE_CONTEXT (type) != NULL_TREE</span>
<span class="lineNum">   25420 </span><span class="lineCov">   20912428 :            &amp;&amp; (TREE_CODE (TYPE_CONTEXT (type)) == FUNCTION_DECL))</span>
<span class="lineNum">   25421 </span>            :     {
<span class="lineNum">   25422 </span>            :       /* If this type is local to a function that hasn't been written
<span class="lineNum">   25423 </span>            :          out yet, use a NULL context for now; it will be fixed up in
<span class="lineNum">   25424 </span>            :          decls_for_scope.  */
<span class="lineNum">   25425 </span><span class="lineCov">       7832 :       context_die = lookup_decl_die (TYPE_CONTEXT (type));</span>
<span class="lineNum">   25426 </span>            :       /* A declaration DIE doesn't count; nested types need to go in the
<span class="lineNum">   25427 </span>            :          specification.  */
<span class="lineNum">   25428 </span><span class="lineCov">       7404 :       if (context_die &amp;&amp; is_declaration_die (context_die))</span>
<span class="lineNum">   25429 </span>            :         context_die = NULL;
<span class="lineNum">   25430 </span>            :     }
<span class="lineNum">   25431 </span>            :   else
<span class="lineNum">   25432 </span><span class="lineCov">   20908512 :     context_die = declare_in_namespace (type, context_die);</span>
<span class="lineNum">   25433 </span>            : 
<span class="lineNum">   25434 </span><span class="lineCov">   21091582 :   if (TREE_CODE (type) == ENUMERAL_TYPE)</span>
<span class="lineNum">   25435 </span>            :     {
<span class="lineNum">   25436 </span>            :       /* This might have been written out by the call to
<span class="lineNum">   25437 </span>            :          declare_in_namespace.  */
<span class="lineNum">   25438 </span><span class="lineCov">     279396 :       if (!TREE_ASM_WRITTEN (type))</span>
<span class="lineNum">   25439 </span><span class="lineCov">     262221 :         gen_enumeration_type_die (type, context_die);</span>
<span class="lineNum">   25440 </span>            :     }
<span class="lineNum">   25441 </span>            :   else
<span class="lineNum">   25442 </span><span class="lineCov">   20812186 :     gen_struct_or_union_type_die (type, context_die, usage);</span>
<span class="lineNum">   25443 </span>            : 
<span class="lineNum">   25444 </span>            :   /* Don't set TREE_ASM_WRITTEN on an incomplete struct; we want to fix
<span class="lineNum">   25445 </span>            :      it up if it is ever completed.  gen_*_type_die will set it for us
<span class="lineNum">   25446 </span>            :      when appropriate.  */
<span class="lineNum">   25447 </span>            : }
<span class="lineNum">   25448 </span>            : 
<span class="lineNum">   25449 </span>            : /* Generate a type description DIE.  */
<a name="25450"><span class="lineNum">   25450 </span>            : </a>
<span class="lineNum">   25451 </span>            : static void
<span class="lineNum">   25452 </span><span class="lineCov">  106547861 : gen_type_die_with_usage (tree type, dw_die_ref context_die,</span>
<span class="lineNum">   25453 </span>            :                          enum debug_info_usage usage)
<span class="lineNum">   25454 </span>            : {
<span class="lineNum">   25455 </span><span class="lineCov">  106547861 :   struct array_descr_info info;</span>
<span class="lineNum">   25456 </span>            : 
<span class="lineNum">   25457 </span><span class="lineCov">  106547861 :   if (type == NULL_TREE || type == error_mark_node)</span>
<span class="lineNum">   25458 </span><span class="lineCov">  103661450 :     return;</span>
<span class="lineNum">   25459 </span>            : 
<span class="lineNum">   25460 </span><span class="lineCov">  106547861 :   if (flag_checking &amp;&amp; type)</span>
<span class="lineNum">   25461 </span><span class="lineCov">  106547852 :      verify_type (type);</span>
<span class="lineNum">   25462 </span>            : 
<span class="lineNum">   25463 </span><span class="lineCov">  106547861 :   if (TYPE_NAME (type) != NULL_TREE</span>
<span class="lineNum">   25464 </span><span class="lineCov">  185753168 :       &amp;&amp; TREE_CODE (TYPE_NAME (type)) == TYPE_DECL</span>
<span class="lineNum">   25465 </span><span class="lineCov">  185057630 :       &amp;&amp; is_redundant_typedef (TYPE_NAME (type))</span>
<span class="lineNum">   25466 </span><span class="lineCov">  320909759 :       &amp;&amp; DECL_ORIGINAL_TYPE (TYPE_NAME (type)))</span>
<span class="lineNum">   25467 </span>            :     /* The DECL of this type is a typedef we don't want to emit debug
<span class="lineNum">   25468 </span>            :        info for but we want debug info for its underlying typedef.
<span class="lineNum">   25469 </span>            :        This can happen for e.g, the injected-class-name of a C++
<span class="lineNum">   25470 </span>            :        type.  */
<span class="lineNum">   25471 </span>            :     type = DECL_ORIGINAL_TYPE (TYPE_NAME (type));
<span class="lineNum">   25472 </span>            : 
<span class="lineNum">   25473 </span>            :   /* If TYPE is a typedef type variant, let's generate debug info
<span class="lineNum">   25474 </span>            :      for the parent typedef which TYPE is a type of.  */
<span class="lineNum">   25475 </span><span class="lineCov">  106547861 :   if (typedef_variant_p (type))</span>
<span class="lineNum">   25476 </span>            :     {
<span class="lineNum">   25477 </span><span class="lineCov">    7147151 :       if (TREE_ASM_WRITTEN (type))</span>
<span class="lineNum">   25478 </span>            :         return;
<span class="lineNum">   25479 </span>            : 
<span class="lineNum">   25480 </span><span class="lineCov">    1601190 :       tree name = TYPE_NAME (type);</span>
<span class="lineNum">   25481 </span><span class="lineCov">    1601190 :       tree origin = decl_ultimate_origin (name);</span>
<span class="lineNum">   25482 </span><span class="lineCov">    1601190 :       if (origin != NULL &amp;&amp; origin != name)</span>
<span class="lineNum">   25483 </span>            :         {
<span class="lineNum">   25484 </span><span class="lineNoCov">          0 :           gen_decl_die (origin, NULL, NULL, context_die);</span>
<span class="lineNum">   25485 </span><span class="lineNoCov">          0 :           return;</span>
<span class="lineNum">   25486 </span>            :         }
<span class="lineNum">   25487 </span>            : 
<span class="lineNum">   25488 </span>            :       /* Prevent broken recursion; we can't hand off to the same type.  */
<span class="lineNum">   25489 </span><span class="lineCov">    1601190 :       gcc_assert (DECL_ORIGINAL_TYPE (name) != type);</span>
<span class="lineNum">   25490 </span>            : 
<span class="lineNum">   25491 </span>            :       /* Give typedefs the right scope.  */
<span class="lineNum">   25492 </span><span class="lineCov">    1601190 :       context_die = scope_die_for (type, context_die);</span>
<span class="lineNum">   25493 </span>            : 
<span class="lineNum">   25494 </span><span class="lineCov">    1601190 :       TREE_ASM_WRITTEN (type) = 1;</span>
<span class="lineNum">   25495 </span>            : 
<span class="lineNum">   25496 </span><span class="lineCov">    1601190 :       gen_decl_die (name, NULL, NULL, context_die);</span>
<span class="lineNum">   25497 </span><span class="lineCov">    1601190 :       return;</span>
<span class="lineNum">   25498 </span>            :     }
<span class="lineNum">   25499 </span>            : 
<span class="lineNum">   25500 </span>            :   /* If type is an anonymous tagged type named by a typedef, let's
<span class="lineNum">   25501 </span>            :      generate debug info for the typedef.  */
<span class="lineNum">   25502 </span><span class="lineCov">   99400710 :   if (is_naming_typedef_decl (TYPE_NAME (type)))</span>
<span class="lineNum">   25503 </span>            :     {
<span class="lineNum">   25504 </span>            :       /* Give typedefs the right scope.  */
<span class="lineNum">   25505 </span><span class="lineCov">      27479 :       context_die = scope_die_for (type, context_die);</span>
<span class="lineNum">   25506 </span>            : 
<span class="lineNum">   25507 </span><span class="lineCov">      27479 :       gen_decl_die (TYPE_NAME (type), NULL, NULL, context_die);</span>
<span class="lineNum">   25508 </span><span class="lineCov">      27479 :       return;</span>
<span class="lineNum">   25509 </span>            :     }
<span class="lineNum">   25510 </span>            : 
<span class="lineNum">   25511 </span><span class="lineCov">   99373231 :   if (lang_hooks.types.get_debug_type)</span>
<span class="lineNum">   25512 </span>            :     {
<span class="lineNum">   25513 </span><span class="lineCov">   96064213 :       tree debug_type = lang_hooks.types.get_debug_type (type);</span>
<span class="lineNum">   25514 </span>            : 
<span class="lineNum">   25515 </span><span class="lineCov">   96064213 :       if (debug_type != NULL_TREE &amp;&amp; debug_type != type)</span>
<span class="lineNum">   25516 </span>            :         {
<span class="lineNum">   25517 </span><span class="lineCov">       2960 :           gen_type_die_with_usage (debug_type, context_die, usage);</span>
<span class="lineNum">   25518 </span><span class="lineCov">       2960 :           return;</span>
<span class="lineNum">   25519 </span>            :         }
<span class="lineNum">   25520 </span>            :     }
<span class="lineNum">   25521 </span>            : 
<span class="lineNum">   25522 </span>            :   /* We are going to output a DIE to represent the unqualified version
<span class="lineNum">   25523 </span>            :      of this type (i.e. without any const or volatile qualifiers) so
<span class="lineNum">   25524 </span>            :      get the main variant (i.e. the unqualified version) of this type
<span class="lineNum">   25525 </span>            :      now.  (Vectors and arrays are special because the debugging info is in the
<span class="lineNum">   25526 </span>            :      cloned type itself.  Similarly function/method types can contain extra
<span class="lineNum">   25527 </span>            :      ref-qualification).  */
<span class="lineNum">   25528 </span><span class="lineCov">  198740542 :   if (TREE_CODE (type) == FUNCTION_TYPE</span>
<span class="lineNum">   25529 </span><span class="lineCov">   99370271 :       || TREE_CODE (type) == METHOD_TYPE)</span>
<span class="lineNum">   25530 </span>            :     {
<span class="lineNum">   25531 </span>            :       /* For function/method types, can't use type_main_variant here,
<span class="lineNum">   25532 </span>            :          because that can have different ref-qualifiers for C++,
<span class="lineNum">   25533 </span>            :          but try to canonicalize.  */
<span class="lineNum">   25534 </span><span class="lineCov">     108830 :       tree main = TYPE_MAIN_VARIANT (type);</span>
<span class="lineNum">   25535 </span><span class="lineCov">     109095 :       for (tree t = main; t; t = TYPE_NEXT_VARIANT (t))</span>
<span class="lineNum">   25536 </span><span class="lineCov">     109092 :         if (TYPE_QUALS_NO_ADDR_SPACE (t) == 0</span>
<span class="lineNum">   25537 </span><span class="lineCov">     109043 :             &amp;&amp; check_base_type (t, main)</span>
<span class="lineNum">   25538 </span><span class="lineCov">     218105 :             &amp;&amp; check_lang_type (t, type))</span>
<span class="lineNum">   25539 </span>            :           {
<span class="lineNum">   25540 </span>            :             type = t;
<span class="lineNum">   25541 </span>            :             break;
<span class="lineNum">   25542 </span>            :           }
<span class="lineNum">   25543 </span>            :     }
<span class="lineNum">   25544 </span><span class="lineCov">  198522882 :   else if (TREE_CODE (type) != VECTOR_TYPE</span>
<span class="lineNum">   25545 </span><span class="lineCov">   99261441 :            &amp;&amp; TREE_CODE (type) != ARRAY_TYPE)</span>
<span class="lineNum">   25546 </span><span class="lineCov">   98873899 :     type = type_main_variant (type);</span>
<span class="lineNum">   25547 </span>            : 
<span class="lineNum">   25548 </span>            :   /* If this is an array type with hidden descriptor, handle it first.  */
<span class="lineNum">   25549 </span><span class="lineCov">   99370271 :   if (!TREE_ASM_WRITTEN (type)</span>
<span class="lineNum">   25550 </span><span class="lineCov">   23978534 :       &amp;&amp; lang_hooks.types.get_array_descr_info)</span>
<span class="lineNum">   25551 </span>            :     {
<span class="lineNum">   25552 </span><span class="lineCov">      51824 :       memset (&amp;info, 0, sizeof (info));</span>
<span class="lineNum">   25553 </span><span class="lineCov">      51824 :       if (lang_hooks.types.get_array_descr_info (type, &amp;info))</span>
<span class="lineNum">   25554 </span>            :         {
<span class="lineNum">   25555 </span>            :           /* Fortran sometimes emits array types with no dimension.  */
<span class="lineNum">   25556 </span><span class="lineCov">       2988 :           gcc_assert (info.ndimensions &gt;= 0</span>
<span class="lineNum">   25557 </span>            :                       &amp;&amp; (info.ndimensions
<span class="lineNum">   25558 </span>            :                           &lt;= DWARF2OUT_ARRAY_DESCR_INFO_MAX_DIMEN));
<span class="lineNum">   25559 </span><span class="lineCov">       2988 :           gen_descr_array_type_die (type, &amp;info, context_die);</span>
<span class="lineNum">   25560 </span><span class="lineCov">       2988 :           TREE_ASM_WRITTEN (type) = 1;</span>
<span class="lineNum">   25561 </span><span class="lineCov">       2988 :           return;</span>
<span class="lineNum">   25562 </span>            :         }
<span class="lineNum">   25563 </span>            :     }
<span class="lineNum">   25564 </span>            : 
<span class="lineNum">   25565 </span><span class="lineCov">   99367283 :   if (TREE_ASM_WRITTEN (type))</span>
<span class="lineNum">   25566 </span>            :     {
<span class="lineNum">   25567 </span>            :       /* Variable-length types may be incomplete even if
<span class="lineNum">   25568 </span>            :          TREE_ASM_WRITTEN.  For such types, fall through to
<span class="lineNum">   25569 </span>            :          gen_array_type_die() and possibly fill in
<span class="lineNum">   25570 </span>            :          DW_AT_{upper,lower}_bound attributes.  */
<span class="lineNum">   25571 </span><span class="lineCov">   75391737 :       if ((TREE_CODE (type) != ARRAY_TYPE</span>
<span class="lineNum">   25572 </span>            :            &amp;&amp; TREE_CODE (type) != RECORD_TYPE
<span class="lineNum">   25573 </span>            :            &amp;&amp; TREE_CODE (type) != UNION_TYPE
<span class="lineNum">   25574 </span><span class="lineCov">   75391737 :            &amp;&amp; TREE_CODE (type) != QUAL_UNION_TYPE)</span>
<span class="lineNum">   25575 </span><span class="lineCov">   75391737 :           || !variably_modified_type_p (type, NULL))</span>
<span class="lineNum">   25576 </span><span class="lineCov">   75389335 :         return;</span>
<span class="lineNum">   25577 </span>            :     }
<span class="lineNum">   25578 </span>            : 
<span class="lineNum">   25579 </span><span class="lineCov">   23977948 :   switch (TREE_CODE (type))</span>
<span class="lineNum">   25580 </span>            :     {
<span class="lineNum">   25581 </span>            :     case ERROR_MARK:
<span class="lineNum">   25582 </span>            :       break;
<span class="lineNum">   25583 </span>            : 
<span class="lineNum">   25584 </span><span class="lineCov">    2370172 :     case POINTER_TYPE:</span>
<span class="lineNum">   25585 </span><span class="lineCov">    2370172 :     case REFERENCE_TYPE:</span>
<span class="lineNum">   25586 </span>            :       /* We must set TREE_ASM_WRITTEN in case this is a recursive type.  This
<span class="lineNum">   25587 </span>            :          ensures that the gen_type_die recursion will terminate even if the
<span class="lineNum">   25588 </span>            :          type is recursive.  Recursive types are possible in Ada.  */
<span class="lineNum">   25589 </span>            :       /* ??? We could perhaps do this for all types before the switch
<span class="lineNum">   25590 </span>            :          statement.  */
<span class="lineNum">   25591 </span><span class="lineCov">    2370172 :       TREE_ASM_WRITTEN (type) = 1;</span>
<span class="lineNum">   25592 </span>            : 
<span class="lineNum">   25593 </span>            :       /* For these types, all that is required is that we output a DIE (or a
<span class="lineNum">   25594 </span>            :          set of DIEs) to represent the &quot;basis&quot; type.  */
<span class="lineNum">   25595 </span><span class="lineCov">    2370172 :       gen_type_die_with_usage (TREE_TYPE (type), context_die,</span>
<span class="lineNum">   25596 </span>            :                                DINFO_USAGE_IND_USE);
<span class="lineNum">   25597 </span><span class="lineCov">    2370172 :       break;</span>
<span class="lineNum">   25598 </span>            : 
<span class="lineNum">   25599 </span><span class="lineCov">      14135 :     case OFFSET_TYPE:</span>
<span class="lineNum">   25600 </span>            :       /* This code is used for C++ pointer-to-data-member types.
<span class="lineNum">   25601 </span>            :          Output a description of the relevant class type.  */
<span class="lineNum">   25602 </span><span class="lineCov">      14135 :       gen_type_die_with_usage (TYPE_OFFSET_BASETYPE (type), context_die,</span>
<span class="lineNum">   25603 </span>            :                                DINFO_USAGE_IND_USE);
<span class="lineNum">   25604 </span>            : 
<span class="lineNum">   25605 </span>            :       /* Output a description of the type of the object pointed to.  */
<span class="lineNum">   25606 </span><span class="lineCov">      14135 :       gen_type_die_with_usage (TREE_TYPE (type), context_die,</span>
<span class="lineNum">   25607 </span>            :                                DINFO_USAGE_IND_USE);
<span class="lineNum">   25608 </span>            : 
<span class="lineNum">   25609 </span>            :       /* Now output a DIE to represent this pointer-to-data-member type
<span class="lineNum">   25610 </span>            :          itself.  */
<span class="lineNum">   25611 </span><span class="lineCov">      14135 :       gen_ptr_to_mbr_type_die (type, context_die);</span>
<span class="lineNum">   25612 </span><span class="lineCov">      14135 :       break;</span>
<span class="lineNum">   25613 </span>            : 
<span class="lineNum">   25614 </span><span class="lineCov">      91851 :     case FUNCTION_TYPE:</span>
<span class="lineNum">   25615 </span>            :       /* Force out return type (in case it wasn't forced out already).  */
<span class="lineNum">   25616 </span><span class="lineCov">      91851 :       gen_type_die_with_usage (TREE_TYPE (type), context_die,</span>
<span class="lineNum">   25617 </span>            :                                DINFO_USAGE_DIR_USE);
<span class="lineNum">   25618 </span><span class="lineCov">      91851 :       gen_subroutine_type_die (type, context_die);</span>
<span class="lineNum">   25619 </span><span class="lineCov">      91851 :       break;</span>
<span class="lineNum">   25620 </span>            : 
<span class="lineNum">   25621 </span><span class="lineCov">      13924 :     case METHOD_TYPE:</span>
<span class="lineNum">   25622 </span>            :       /* Force out return type (in case it wasn't forced out already).  */
<span class="lineNum">   25623 </span><span class="lineCov">      13924 :       gen_type_die_with_usage (TREE_TYPE (type), context_die,</span>
<span class="lineNum">   25624 </span>            :                                DINFO_USAGE_DIR_USE);
<span class="lineNum">   25625 </span><span class="lineCov">      13924 :       gen_subroutine_type_die (type, context_die);</span>
<span class="lineNum">   25626 </span><span class="lineCov">      13924 :       break;</span>
<span class="lineNum">   25627 </span>            : 
<span class="lineNum">   25628 </span><span class="lineCov">     233280 :     case ARRAY_TYPE:</span>
<span class="lineNum">   25629 </span><span class="lineCov">     233280 :     case VECTOR_TYPE:</span>
<span class="lineNum">   25630 </span><span class="lineCov">     233280 :       gen_array_type_die (type, context_die);</span>
<span class="lineNum">   25631 </span><span class="lineCov">     233280 :       break;</span>
<span class="lineNum">   25632 </span>            : 
<span class="lineNum">   25633 </span><span class="lineCov">   21091537 :     case ENUMERAL_TYPE:</span>
<span class="lineNum">   25634 </span><span class="lineCov">   21091537 :     case RECORD_TYPE:</span>
<span class="lineNum">   25635 </span><span class="lineCov">   21091537 :     case UNION_TYPE:</span>
<span class="lineNum">   25636 </span><span class="lineCov">   21091537 :     case QUAL_UNION_TYPE:</span>
<span class="lineNum">   25637 </span><span class="lineCov">   21091537 :       gen_tagged_type_die (type, context_die, usage);</span>
<span class="lineNum">   25638 </span><span class="lineCov">   21091537 :       return;</span>
<span class="lineNum">   25639 </span>            : 
<span class="lineNum">   25640 </span>            :     case VOID_TYPE:
<span class="lineNum">   25641 </span>            :     case INTEGER_TYPE:
<span class="lineNum">   25642 </span>            :     case REAL_TYPE:
<span class="lineNum">   25643 </span>            :     case FIXED_POINT_TYPE:
<span class="lineNum">   25644 </span>            :     case COMPLEX_TYPE:
<span class="lineNum">   25645 </span>            :     case BOOLEAN_TYPE:
<span class="lineNum">   25646 </span>            :       /* No DIEs needed for fundamental types.  */
<span class="lineNum">   25647 </span>            :       break;
<span class="lineNum">   25648 </span>            : 
<span class="lineNum">   25649 </span><span class="lineCov">       1517 :     case NULLPTR_TYPE:</span>
<span class="lineNum">   25650 </span><span class="lineCov">       1517 :     case LANG_TYPE:</span>
<span class="lineNum">   25651 </span>            :       /* Just use DW_TAG_unspecified_type.  */
<span class="lineNum">   25652 </span><span class="lineCov">       1517 :       {</span>
<span class="lineNum">   25653 </span><span class="lineCov">       1517 :         dw_die_ref type_die = lookup_type_die (type);</span>
<span class="lineNum">   25654 </span><span class="lineCov">       1517 :         if (type_die == NULL)</span>
<span class="lineNum">   25655 </span>            :           {
<span class="lineNum">   25656 </span><span class="lineCov">       1517 :             tree name = TYPE_IDENTIFIER (type);</span>
<span class="lineNum">   25657 </span><span class="lineCov">       1517 :             type_die = new_die (DW_TAG_unspecified_type, comp_unit_die (),</span>
<span class="lineNum">   25658 </span>            :                                 type);
<span class="lineNum">   25659 </span><span class="lineCov">       1517 :             add_name_attribute (type_die, IDENTIFIER_POINTER (name));</span>
<span class="lineNum">   25660 </span><span class="lineCov">       1517 :             equate_type_number_to_die (type, type_die);</span>
<span class="lineNum">   25661 </span>            :           }
<span class="lineNum">   25662 </span>            :       }
<span class="lineNum">   25663 </span>            :       break;
<span class="lineNum">   25664 </span>            : 
<span class="lineNum">   25665 </span><span class="lineCov">         44 :     default:</span>
<span class="lineNum">   25666 </span><span class="lineCov">         44 :       if (is_cxx_auto (type))</span>
<span class="lineNum">   25667 </span>            :         {
<span class="lineNum">   25668 </span><span class="lineCov">         44 :           tree name = TYPE_IDENTIFIER (type);</span>
<span class="lineNum">   25669 </span><span class="lineCov">         44 :           dw_die_ref *die = (name == get_identifier (&quot;auto&quot;)</span>
<span class="lineNum">   25670 </span><span class="lineCov">         44 :                              ? &amp;auto_die : &amp;decltype_auto_die);</span>
<span class="lineNum">   25671 </span><span class="lineCov">         44 :           if (!*die)</span>
<span class="lineNum">   25672 </span>            :             {
<span class="lineNum">   25673 </span><span class="lineCov">         16 :               *die = new_die (DW_TAG_unspecified_type,</span>
<span class="lineNum">   25674 </span>            :                               comp_unit_die (), NULL_TREE);
<span class="lineNum">   25675 </span><span class="lineCov">         16 :               add_name_attribute (*die, IDENTIFIER_POINTER (name));</span>
<span class="lineNum">   25676 </span>            :             }
<span class="lineNum">   25677 </span><span class="lineCov">         44 :           equate_type_number_to_die (type, *die);</span>
<span class="lineNum">   25678 </span><span class="lineCov">         44 :           break;</span>
<span class="lineNum">   25679 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">   25680 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">   25681 </span>            :     }
<span class="lineNum">   25682 </span>            : 
<span class="lineNum">   25683 </span><span class="lineCov">    2886411 :   TREE_ASM_WRITTEN (type) = 1;</span>
<span class="lineNum">   25684 </span>            : }
<a name="25685"><span class="lineNum">   25685 </span>            : </a>
<span class="lineNum">   25686 </span>            : static void
<span class="lineNum">   25687 </span><span class="lineCov">  103861653 : gen_type_die (tree type, dw_die_ref context_die)</span>
<span class="lineNum">   25688 </span>            : {
<span class="lineNum">   25689 </span><span class="lineCov">  103861653 :   if (type != error_mark_node)</span>
<span class="lineNum">   25690 </span>            :     {
<span class="lineNum">   25691 </span><span class="lineCov">  103861653 :       gen_type_die_with_usage (type, context_die, DINFO_USAGE_DIR_USE);</span>
<span class="lineNum">   25692 </span><span class="lineCov">  103861653 :       if (flag_checking)</span>
<span class="lineNum">   25693 </span>            :         {
<span class="lineNum">   25694 </span><span class="lineCov">  103861644 :           dw_die_ref die = lookup_type_die (type);</span>
<span class="lineNum">   25695 </span><span class="lineCov">  103861644 :           if (die)</span>
<span class="lineNum">   25696 </span><span class="lineCov">   85919797 :             check_die (die);</span>
<span class="lineNum">   25697 </span>            :         }
<span class="lineNum">   25698 </span>            :     }
<span class="lineNum">   25699 </span><span class="lineCov">  103861653 : }</span>
<span class="lineNum">   25700 </span>            : 
<span class="lineNum">   25701 </span>            : /* Generate a DW_TAG_lexical_block DIE followed by DIEs to represent all of the
<span class="lineNum">   25702 </span>            :    things which are local to the given block.  */
<a name="25703"><span class="lineNum">   25703 </span>            : </a>
<span class="lineNum">   25704 </span>            : static void
<span class="lineNum">   25705 </span><span class="lineCov">   13162943 : gen_block_die (tree stmt, dw_die_ref context_die)</span>
<span class="lineNum">   25706 </span>            : {
<span class="lineNum">   25707 </span><span class="lineCov">   13162943 :   int must_output_die = 0;</span>
<span class="lineNum">   25708 </span><span class="lineCov">   13162943 :   bool inlined_func;</span>
<span class="lineNum">   25709 </span>            : 
<span class="lineNum">   25710 </span>            :   /* Ignore blocks that are NULL.  */
<span class="lineNum">   25711 </span><span class="lineCov">   13162943 :   if (stmt == NULL_TREE)</span>
<span class="lineNum">   25712 </span>            :     return;
<span class="lineNum">   25713 </span>            : 
<span class="lineNum">   25714 </span><span class="lineCov">   13162943 :   inlined_func = inlined_function_outer_scope_p (stmt);</span>
<span class="lineNum">   25715 </span>            : 
<span class="lineNum">   25716 </span>            :   /* If the block is one fragment of a non-contiguous block, do not
<span class="lineNum">   25717 </span>            :      process the variables, since they will have been done by the
<span class="lineNum">   25718 </span>            :      origin block.  Do process subblocks.  */
<span class="lineNum">   25719 </span><span class="lineCov">   13162943 :   if (BLOCK_FRAGMENT_ORIGIN (stmt))</span>
<span class="lineNum">   25720 </span>            :     {
<span class="lineNum">   25721 </span><span class="lineCov">    5123711 :       tree sub;</span>
<span class="lineNum">   25722 </span>            : 
<span class="lineNum">   25723 </span><span class="lineCov">   10247422 :       for (sub = BLOCK_SUBBLOCKS (stmt); sub; sub = BLOCK_CHAIN (sub))</span>
<span class="lineNum">   25724 </span><span class="lineNoCov">          0 :         gen_block_die (sub, context_die);</span>
<span class="lineNum">   25725 </span>            : 
<span class="lineNum">   25726 </span>            :       return;
<span class="lineNum">   25727 </span>            :     }
<span class="lineNum">   25728 </span>            : 
<span class="lineNum">   25729 </span>            :   /* Determine if we need to output any Dwarf DIEs at all to represent this
<span class="lineNum">   25730 </span>            :      block.  */
<span class="lineNum">   25731 </span><span class="lineCov">    8039232 :   if (inlined_func)</span>
<span class="lineNum">   25732 </span>            :     /* The outer scopes for inlinings *must* always be represented.  We
<span class="lineNum">   25733 </span>            :        generate DW_TAG_inlined_subroutine DIEs for them.  (See below.) */
<span class="lineNum">   25734 </span>            :     must_output_die = 1;
<span class="lineNum">   25735 </span><span class="lineCov">    9608778 :   else if (BLOCK_DIE (stmt))</span>
<span class="lineNum">   25736 </span>            :     /* If we already have a DIE then it was filled early.  Meanwhile
<span class="lineNum">   25737 </span>            :        we might have pruned all BLOCK_VARS as optimized out but we
<span class="lineNum">   25738 </span>            :        still want to generate high/low PC attributes so output it.  */
<span class="lineNum">   25739 </span>            :     must_output_die = 1;
<span class="lineNum">   25740 </span><span class="lineCov">    4623064 :   else if (TREE_USED (stmt)</span>
<span class="lineNum">   25741 </span><span class="lineCov">    4623064 :            || TREE_ASM_WRITTEN (stmt)</span>
<span class="lineNum">   25742 </span><span class="lineCov">    4623064 :            || BLOCK_ABSTRACT (stmt))</span>
<span class="lineNum">   25743 </span>            :     {
<span class="lineNum">   25744 </span>            :       /* Determine if this block directly contains any &quot;significant&quot;
<span class="lineNum">   25745 </span>            :          local declarations which we will need to output DIEs for.  */
<span class="lineNum">   25746 </span><span class="lineCov">    4622604 :       if (debug_info_level &gt; DINFO_LEVEL_TERSE)</span>
<span class="lineNum">   25747 </span>            :         {
<span class="lineNum">   25748 </span>            :           /* We are not in terse mode so any local declaration that
<span class="lineNum">   25749 </span>            :              is not ignored for debug purposes counts as being a
<span class="lineNum">   25750 </span>            :              &quot;significant&quot; one.  */
<span class="lineNum">   25751 </span><span class="lineCov">    9212146 :           if (BLOCK_NUM_NONLOCALIZED_VARS (stmt))</span>
<span class="lineNum">   25752 </span>            :             must_output_die = 1;
<span class="lineNum">   25753 </span>            :           else
<span class="lineNum">   25754 </span><span class="lineCov">    9256849 :             for (tree var = BLOCK_VARS (stmt); var; var = DECL_CHAIN (var))</span>
<span class="lineNum">   25755 </span><span class="lineCov">     810611 :               if (!DECL_IGNORED_P (var))</span>
<span class="lineNum">   25756 </span>            :                 {
<span class="lineNum">   25757 </span>            :                   must_output_die = 1;
<span class="lineNum">   25758 </span>            :                   break;
<span class="lineNum">   25759 </span>            :                 }
<span class="lineNum">   25760 </span>            :         }
<span class="lineNum">   25761 </span><span class="lineCov">      16531 :       else if (!dwarf2out_ignore_block (stmt))</span>
<span class="lineNum">   25762 </span>            :         must_output_die = 1;
<span class="lineNum">   25763 </span>            :     }
<span class="lineNum">   25764 </span>            : 
<span class="lineNum">   25765 </span>            :   /* It would be a waste of space to generate a Dwarf DW_TAG_lexical_block
<span class="lineNum">   25766 </span>            :      DIE for any block which contains no significant local declarations at
<span class="lineNum">   25767 </span>            :      all.  Rather, in such cases we just call `decls_for_scope' so that any
<span class="lineNum">   25768 </span>            :      needed Dwarf info for any sub-blocks will get properly generated. Note
<span class="lineNum">   25769 </span>            :      that in terse mode, our definition of what constitutes a &quot;significant&quot;
<span class="lineNum">   25770 </span>            :      local declaration gets restricted to include only inlined function
<span class="lineNum">   25771 </span>            :      instances and local (nested) function definitions.  */
<span class="lineNum">   25772 </span><span class="lineCov">    4576172 :   if (must_output_die)</span>
<span class="lineNum">   25773 </span>            :     {
<span class="lineNum">   25774 </span><span class="lineCov">    4152215 :       if (inlined_func)</span>
<span class="lineNum">   25775 </span>            :         {
<span class="lineNum">   25776 </span>            :           /* If STMT block is abstract, that means we have been called
<span class="lineNum">   25777 </span>            :              indirectly from dwarf2out_abstract_function.
<span class="lineNum">   25778 </span>            :              That function rightfully marks the descendent blocks (of
<span class="lineNum">   25779 </span>            :              the abstract function it is dealing with) as being abstract,
<span class="lineNum">   25780 </span>            :              precisely to prevent us from emitting any
<span class="lineNum">   25781 </span>            :              DW_TAG_inlined_subroutine DIE as a descendent
<span class="lineNum">   25782 </span>            :              of an abstract function instance. So in that case, we should
<span class="lineNum">   25783 </span>            :              not call gen_inlined_subroutine_die.
<span class="lineNum">   25784 </span>            : 
<span class="lineNum">   25785 </span>            :              Later though, when cgraph asks dwarf2out to emit info
<span class="lineNum">   25786 </span>            :              for the concrete instance of the function decl into which
<span class="lineNum">   25787 </span>            :              the concrete instance of STMT got inlined, the later will lead
<span class="lineNum">   25788 </span>            :              to the generation of a DW_TAG_inlined_subroutine DIE.  */
<span class="lineNum">   25789 </span><span class="lineCov">    6469686 :           if (! BLOCK_ABSTRACT (stmt))</span>
<span class="lineNum">   25790 </span><span class="lineCov">    3234843 :             gen_inlined_subroutine_die (stmt, context_die);</span>
<span class="lineNum">   25791 </span>            :         }
<span class="lineNum">   25792 </span>            :       else
<span class="lineNum">   25793 </span><span class="lineCov">     917372 :         gen_lexical_block_die (stmt, context_die);</span>
<span class="lineNum">   25794 </span>            :     }
<span class="lineNum">   25795 </span>            :   else
<span class="lineNum">   25796 </span><span class="lineCov">    3887017 :     decls_for_scope (stmt, context_die);</span>
<span class="lineNum">   25797 </span>            : }
<span class="lineNum">   25798 </span>            : 
<span class="lineNum">   25799 </span>            : /* Process variable DECL (or variable with origin ORIGIN) within
<a name="25800"><span class="lineNum">   25800 </span>            :    block STMT and add it to CONTEXT_DIE.  */</a>
<span class="lineNum">   25801 </span>            : static void
<span class="lineNum">   25802 </span><span class="lineCov">    8593201 : process_scope_var (tree stmt, tree decl, tree origin, dw_die_ref context_die)</span>
<span class="lineNum">   25803 </span>            : {
<span class="lineNum">   25804 </span><span class="lineCov">    8593201 :   dw_die_ref die;</span>
<span class="lineNum">   25805 </span><span class="lineCov">    8593201 :   tree decl_or_origin = decl ? decl : origin;</span>
<span class="lineNum">   25806 </span>            : 
<span class="lineNum">   25807 </span><span class="lineCov">    8593201 :   if (TREE_CODE (decl_or_origin) == FUNCTION_DECL)</span>
<span class="lineNum">   25808 </span><span class="lineCov">      10578 :     die = lookup_decl_die (decl_or_origin);</span>
<span class="lineNum">   25809 </span><span class="lineCov">    8582623 :   else if (TREE_CODE (decl_or_origin) == TYPE_DECL)</span>
<span class="lineNum">   25810 </span>            :     {
<span class="lineNum">   25811 </span><span class="lineCov">     243722 :       if (TYPE_DECL_IS_STUB (decl_or_origin))</span>
<span class="lineNum">   25812 </span><span class="lineCov">      12366 :         die = lookup_type_die (TREE_TYPE (decl_or_origin));</span>
<span class="lineNum">   25813 </span>            :       else
<span class="lineNum">   25814 </span><span class="lineCov">     231356 :         die = lookup_decl_die (decl_or_origin);</span>
<span class="lineNum">   25815 </span>            :       /* Avoid re-creating the DIE late if it was optimized as unused early.  */
<span class="lineNum">   25816 </span><span class="lineCov">     243722 :       if (! die &amp;&amp; ! early_dwarf)</span>
<span class="lineNum">   25817 </span>            :         return;
<span class="lineNum">   25818 </span>            :     }
<span class="lineNum">   25819 </span>            :   else
<span class="lineNum">   25820 </span>            :     die = NULL;
<span class="lineNum">   25821 </span>            : 
<span class="lineNum">   25822 </span>            :   /* Avoid creating DIEs for local typedefs and concrete static variables that
<span class="lineNum">   25823 </span>            :      will only be pruned later.  */
<span class="lineNum">   25824 </span><span class="lineCov">    8399523 :   if ((origin || decl_ultimate_origin (decl))</span>
<span class="lineNum">   25825 </span><span class="lineCov">   14682192 :       &amp;&amp; (TREE_CODE (decl_or_origin) == TYPE_DECL</span>
<span class="lineNum">   25826 </span><span class="lineCov">    6278079 :           || (VAR_P (decl_or_origin) &amp;&amp; TREE_STATIC (decl_or_origin))))</span>
<span class="lineNum">   25827 </span>            :     {
<span class="lineNum">   25828 </span><span class="lineCov">      36179 :       origin = decl_ultimate_origin (decl_or_origin);</span>
<span class="lineNum">   25829 </span><span class="lineCov">      36179 :       if (decl &amp;&amp; VAR_P (decl) &amp;&amp; die != NULL)</span>
<span class="lineNum">   25830 </span>            :         {
<span class="lineNum">   25831 </span><span class="lineNoCov">          0 :           die = lookup_decl_die (origin);</span>
<span class="lineNum">   25832 </span><span class="lineNoCov">          0 :           if (die != NULL)</span>
<span class="lineNum">   25833 </span><span class="lineNoCov">          0 :             equate_decl_number_to_die (decl, die);</span>
<span class="lineNum">   25834 </span>            :         }
<span class="lineNum">   25835 </span><span class="lineCov">      36179 :       return;</span>
<span class="lineNum">   25836 </span>            :     }
<span class="lineNum">   25837 </span>            : 
<span class="lineNum">   25838 </span><span class="lineCov">    8393597 :   if (die != NULL &amp;&amp; die-&gt;die_parent == NULL)</span>
<span class="lineNum">   25839 </span><span class="lineCov">        817 :     add_child_die (context_die, die);</span>
<span class="lineNum">   25840 </span><span class="lineCov">    8392780 :   else if (TREE_CODE (decl_or_origin) == IMPORTED_DECL)</span>
<span class="lineNum">   25841 </span>            :     {
<span class="lineNum">   25842 </span><span class="lineCov">      10206 :       if (early_dwarf)</span>
<span class="lineNum">   25843 </span><span class="lineCov">       3876 :         dwarf2out_imported_module_or_decl_1 (decl_or_origin, DECL_NAME (decl_or_origin),</span>
<span class="lineNum">   25844 </span>            :                                              stmt, context_die);
<span class="lineNum">   25845 </span>            :     }
<span class="lineNum">   25846 </span>            :   else
<span class="lineNum">   25847 </span>            :     {
<span class="lineNum">   25848 </span><span class="lineCov">    8382574 :       if (decl &amp;&amp; DECL_P (decl))</span>
<span class="lineNum">   25849 </span>            :         {
<span class="lineNum">   25850 </span><span class="lineCov">    8382563 :           die = lookup_decl_die (decl);</span>
<span class="lineNum">   25851 </span>            : 
<span class="lineNum">   25852 </span>            :           /* Early created DIEs do not have a parent as the decls refer
<span class="lineNum">   25853 </span>            :              to the function as DECL_CONTEXT rather than the BLOCK.  */
<span class="lineNum">   25854 </span><span class="lineCov">    8382563 :           if (die &amp;&amp; die-&gt;die_parent == NULL)</span>
<span class="lineNum">   25855 </span>            :             {
<span class="lineNum">   25856 </span><span class="lineCov">       2236 :               gcc_assert (in_lto_p);</span>
<span class="lineNum">   25857 </span><span class="lineCov">       2236 :               add_child_die (context_die, die);</span>
<span class="lineNum">   25858 </span>            :             }
<span class="lineNum">   25859 </span>            :         }
<span class="lineNum">   25860 </span>            : 
<span class="lineNum">   25861 </span><span class="lineCov">    8382574 :       gen_decl_die (decl, origin, NULL, context_die);</span>
<span class="lineNum">   25862 </span>            :     }
<span class="lineNum">   25863 </span>            : }
<span class="lineNum">   25864 </span>            : 
<span class="lineNum">   25865 </span>            : /* Generate all of the decls declared within a given scope and (recursively)
<span class="lineNum">   25866 </span>            :    all of its sub-blocks.  */
<a name="25867"><span class="lineNum">   25867 </span>            : </a>
<span class="lineNum">   25868 </span>            : static void
<span class="lineNum">   25869 </span><span class="lineCov">    9648037 : decls_for_scope (tree stmt, dw_die_ref context_die)</span>
<span class="lineNum">   25870 </span>            : {
<span class="lineNum">   25871 </span><span class="lineCov">    9648037 :   tree decl;</span>
<span class="lineNum">   25872 </span><span class="lineCov">    9648037 :   unsigned int i;</span>
<span class="lineNum">   25873 </span><span class="lineCov">    9648037 :   tree subblocks;</span>
<span class="lineNum">   25874 </span>            : 
<span class="lineNum">   25875 </span>            :   /* Ignore NULL blocks.  */
<span class="lineNum">   25876 </span><span class="lineCov">    9648037 :   if (stmt == NULL_TREE)</span>
<span class="lineNum">   25877 </span>            :     return;
<span class="lineNum">   25878 </span>            : 
<span class="lineNum">   25879 </span>            :   /* Output the DIEs to represent all of the data objects and typedefs
<span class="lineNum">   25880 </span>            :      declared directly within this block but not within any nested
<span class="lineNum">   25881 </span>            :      sub-blocks.  Also, nested function and tag DIEs have been
<span class="lineNum">   25882 </span>            :      generated with a parent of NULL; fix that up now.  We don't
<span class="lineNum">   25883 </span>            :      have to do this if we're at -g1.  */
<span class="lineNum">   25884 </span><span class="lineCov">    9648037 :   if (debug_info_level &gt; DINFO_LEVEL_TERSE)</span>
<span class="lineNum">   25885 </span>            :     {
<span class="lineNum">   25886 </span><span class="lineCov">   18187250 :       for (decl = BLOCK_VARS (stmt); decl != NULL; decl = DECL_CHAIN (decl))</span>
<span class="lineNum">   25887 </span><span class="lineCov">    8561545 :         process_scope_var (stmt, decl, NULL_TREE, context_die);</span>
<span class="lineNum">   25888 </span>            :       /* BLOCK_NONLOCALIZED_VARs simply generate DIE stubs with abstract
<span class="lineNum">   25889 </span>            :          origin - avoid doing this twice as we have no good way to see
<span class="lineNum">   25890 </span>            :          if we've done it once already.  */
<span class="lineNum">   25891 </span><span class="lineCov">    9625705 :       if (! early_dwarf)</span>
<span class="lineNum">   25892 </span><span class="lineCov">    6573686 :         for (i = 0; i &lt; BLOCK_NUM_NONLOCALIZED_VARS (stmt); i++)</span>
<span class="lineNum">   25893 </span>            :           {
<span class="lineNum">   25894 </span><span class="lineCov">      63320 :             decl = BLOCK_NONLOCALIZED_VAR (stmt, i);</span>
<span class="lineNum">   25895 </span><span class="lineCov">      31660 :             if (decl == current_function_decl)</span>
<span class="lineNum">   25896 </span>            :               /* Ignore declarations of the current function, while they
<span class="lineNum">   25897 </span>            :                  are declarations, gen_subprogram_die would treat them
<span class="lineNum">   25898 </span>            :                  as definitions again, because they are equal to
<span class="lineNum">   25899 </span>            :                  current_function_decl and endlessly recurse.  */;
<span class="lineNum">   25900 </span><span class="lineCov">      31656 :             else if (TREE_CODE (decl) == FUNCTION_DECL)</span>
<span class="lineNum">   25901 </span><span class="lineCov">       1403 :               process_scope_var (stmt, decl, NULL_TREE, context_die);</span>
<span class="lineNum">   25902 </span>            :             else
<span class="lineNum">   25903 </span><span class="lineCov">      30253 :               process_scope_var (stmt, NULL_TREE, decl, context_die);</span>
<span class="lineNum">   25904 </span>            :           }
<span class="lineNum">   25905 </span>            :     }
<span class="lineNum">   25906 </span>            : 
<span class="lineNum">   25907 </span>            :   /* Even if we're at -g1, we need to process the subblocks in order to get
<span class="lineNum">   25908 </span>            :      inlined call information.  */
<span class="lineNum">   25909 </span>            : 
<span class="lineNum">   25910 </span>            :   /* Output the DIEs to represent all sub-blocks (and the items declared
<span class="lineNum">   25911 </span>            :      therein) of this block.  */
<span class="lineNum">   25912 </span><span class="lineCov">    9648037 :   for (subblocks = BLOCK_SUBBLOCKS (stmt);</span>
<span class="lineNum">   25913 </span><span class="lineCov">   22810980 :        subblocks != NULL;</span>
<span class="lineNum">   25914 </span><span class="lineCov">   13162943 :        subblocks = BLOCK_CHAIN (subblocks))</span>
<span class="lineNum">   25915 </span><span class="lineCov">   13162943 :     gen_block_die (subblocks, context_die);</span>
<span class="lineNum">   25916 </span>            : }
<span class="lineNum">   25917 </span>            : 
<span class="lineNum">   25918 </span>            : /* Is this a typedef we can avoid emitting?  */
<a name="25919"><span class="lineNum">   25919 </span>            : </a>
<span class="lineNum">   25920 </span>            : static bool
<span class="lineNum">   25921 </span><span class="lineCov">  192938377 : is_redundant_typedef (const_tree decl)</span>
<span class="lineNum">   25922 </span>            : {
<span class="lineNum">   25923 </span><span class="lineCov">  192938377 :   if (TYPE_DECL_IS_STUB (decl))</span>
<span class="lineNum">   25924 </span>            :     return true;
<span class="lineNum">   25925 </span>            : 
<span class="lineNum">   25926 </span><span class="lineCov">   49256271 :   if (DECL_ARTIFICIAL (decl)</span>
<span class="lineNum">   25927 </span><span class="lineCov">   56454974 :       &amp;&amp; DECL_CONTEXT (decl)</span>
<span class="lineNum">   25928 </span><span class="lineCov">   31640106 :       &amp;&amp; is_tagged_type (DECL_CONTEXT (decl))</span>
<span class="lineNum">   25929 </span><span class="lineCov">   31639948 :       &amp;&amp; TREE_CODE (TYPE_NAME (DECL_CONTEXT (decl))) == TYPE_DECL</span>
<span class="lineNum">   25930 </span><span class="lineCov">  112536167 :       &amp;&amp; DECL_NAME (decl) == DECL_NAME (TYPE_NAME (DECL_CONTEXT (decl))))</span>
<span class="lineNum">   25931 </span>            :     /* Also ignore the artificial member typedef for the class name.  */
<span class="lineNum">   25932 </span><span class="lineCov">   15819958 :     return true;</span>
<span class="lineNum">   25933 </span>            : 
<span class="lineNum">   25934 </span>            :   return false;
<span class="lineNum">   25935 </span>            : }
<span class="lineNum">   25936 </span>            : 
<span class="lineNum">   25937 </span>            : /* Return TRUE if TYPE is a typedef that names a type for linkage
<span class="lineNum">   25938 </span>            :    purposes. This kind of typedefs is produced by the C++ FE for
<span class="lineNum">   25939 </span>            :    constructs like:
<span class="lineNum">   25940 </span>            : 
<span class="lineNum">   25941 </span>            :    typedef struct {...} foo;
<span class="lineNum">   25942 </span>            : 
<span class="lineNum">   25943 </span>            :    In that case, there is no typedef variant type produced for foo.
<span class="lineNum">   25944 </span>            :    Rather, the TREE_TYPE of the TYPE_DECL of foo is the anonymous
<span class="lineNum">   25945 </span>            :    struct type.  */
<a name="25946"><span class="lineNum">   25946 </span>            : </a>
<span class="lineNum">   25947 </span>            : static bool
<span class="lineNum">   25948 </span><span class="lineCov">  106863435 : is_naming_typedef_decl (const_tree decl)</span>
<span class="lineNum">   25949 </span>            : {
<span class="lineNum">   25950 </span><span class="lineCov">  106863435 :   if (decl == NULL_TREE</span>
<span class="lineNum">   25951 </span><span class="lineCov">   93184487 :       || TREE_CODE (decl) != TYPE_DECL</span>
<span class="lineNum">   25952 </span><span class="lineCov">   92836718 :       || DECL_NAMELESS (decl)</span>
<span class="lineNum">   25953 </span><span class="lineCov">   92835886 :       || !is_tagged_type (TREE_TYPE (decl))</span>
<span class="lineNum">   25954 </span><span class="lineCov">  224982984 :       || DECL_IS_BUILTIN (decl)</span>
<span class="lineNum">   25955 </span><span class="lineCov">   74980339 :       || is_redundant_typedef (decl)</span>
<span class="lineNum">   25956 </span>            :       /* It looks like Ada produces TYPE_DECLs that are very similar
<span class="lineNum">   25957 </span>            :          to C++ naming typedefs but that have different
<span class="lineNum">   25958 </span>            :          semantics. Let's be specific to c++ for now.  */
<span class="lineNum">   25959 </span><span class="lineCov">  110397642 :       || !is_cxx (decl))</span>
<span class="lineNum">   25960 </span><span class="lineCov">  103585090 :     return FALSE;</span>
<span class="lineNum">   25961 </span>            : 
<span class="lineNum">   25962 </span><span class="lineCov">    3278345 :   return (DECL_ORIGINAL_TYPE (decl) == NULL_TREE</span>
<span class="lineNum">   25963 </span><span class="lineCov">     103553 :           &amp;&amp; TYPE_NAME (TREE_TYPE (decl)) == decl</span>
<span class="lineNum">   25964 </span><span class="lineCov">    3588986 :           &amp;&amp; (TYPE_STUB_DECL (TREE_TYPE (decl))</span>
<span class="lineNum">   25965 </span><span class="lineCov">     310641 :               != TYPE_NAME (TREE_TYPE (decl))));</span>
<span class="lineNum">   25966 </span>            : }
<span class="lineNum">   25967 </span>            : 
<span class="lineNum">   25968 </span>            : /* Looks up the DIE for a context.  */
<a name="25969"><span class="lineNum">   25969 </span>            : </a>
<span class="lineNum">   25970 </span>            : static inline dw_die_ref
<span class="lineNum">   25971 </span><span class="lineCov">     234719 : lookup_context_die (tree context)</span>
<span class="lineNum">   25972 </span>            : {
<span class="lineNum">   25973 </span><span class="lineCov">     234719 :   if (context)</span>
<span class="lineNum">   25974 </span>            :     {
<span class="lineNum">   25975 </span>            :       /* Find die that represents this context.  */
<span class="lineNum">   25976 </span><span class="lineCov">      56084 :       if (TYPE_P (context))</span>
<span class="lineNum">   25977 </span>            :         {
<span class="lineNum">   25978 </span><span class="lineCov">       6603 :           context = TYPE_MAIN_VARIANT (context);</span>
<span class="lineNum">   25979 </span><span class="lineCov">       6603 :           dw_die_ref ctx = lookup_type_die (context);</span>
<span class="lineNum">   25980 </span><span class="lineCov">       6603 :           if (!ctx)</span>
<span class="lineNum">   25981 </span>            :             return NULL;
<span class="lineNum">   25982 </span><span class="lineCov">       6528 :           return strip_naming_typedef (context, ctx);</span>
<span class="lineNum">   25983 </span>            :         }
<span class="lineNum">   25984 </span>            :       else
<span class="lineNum">   25985 </span><span class="lineCov">      49481 :         return lookup_decl_die (context);</span>
<span class="lineNum">   25986 </span>            :     }
<span class="lineNum">   25987 </span><span class="lineCov">     178635 :   return comp_unit_die ();</span>
<span class="lineNum">   25988 </span>            : }
<span class="lineNum">   25989 </span>            : 
<span class="lineNum">   25990 </span>            : /* Returns the DIE for a context.  */
<a name="25991"><span class="lineNum">   25991 </span>            : </a>
<span class="lineNum">   25992 </span>            : static inline dw_die_ref
<span class="lineNum">   25993 </span><span class="lineCov">   11651245 : get_context_die (tree context)</span>
<span class="lineNum">   25994 </span>            : {
<span class="lineNum">   25995 </span><span class="lineCov">   11651245 :   if (context)</span>
<span class="lineNum">   25996 </span>            :     {
<span class="lineNum">   25997 </span>            :       /* Find die that represents this context.  */
<span class="lineNum">   25998 </span><span class="lineCov">   11614378 :       if (TYPE_P (context))</span>
<span class="lineNum">   25999 </span>            :         {
<span class="lineNum">   26000 </span><span class="lineCov">    1870469 :           context = TYPE_MAIN_VARIANT (context);</span>
<span class="lineNum">   26001 </span><span class="lineCov">    1870469 :           return strip_naming_typedef (context, force_type_die (context));</span>
<span class="lineNum">   26002 </span>            :         }
<span class="lineNum">   26003 </span>            :       else
<span class="lineNum">   26004 </span><span class="lineCov">    9743909 :         return force_decl_die (context);</span>
<span class="lineNum">   26005 </span>            :     }
<span class="lineNum">   26006 </span><span class="lineCov">      36867 :   return comp_unit_die ();</span>
<span class="lineNum">   26007 </span>            : }
<span class="lineNum">   26008 </span>            : 
<span class="lineNum">   26009 </span>            : /* Returns the DIE for decl.  A DIE will always be returned.  */
<a name="26010"><span class="lineNum">   26010 </span>            : </a>
<span class="lineNum">   26011 </span>            : static dw_die_ref
<span class="lineNum">   26012 </span><span class="lineCov">   30716814 : force_decl_die (tree decl)</span>
<span class="lineNum">   26013 </span>            : {
<span class="lineNum">   26014 </span><span class="lineCov">   30716814 :   dw_die_ref decl_die;</span>
<span class="lineNum">   26015 </span><span class="lineCov">   30716814 :   unsigned saved_external_flag;</span>
<span class="lineNum">   26016 </span><span class="lineCov">   30716814 :   tree save_fn = NULL_TREE;</span>
<span class="lineNum">   26017 </span><span class="lineCov">   30716814 :   decl_die = lookup_decl_die (decl);</span>
<span class="lineNum">   26018 </span><span class="lineCov">   30716814 :   if (!decl_die)</span>
<span class="lineNum">   26019 </span>            :     {
<span class="lineNum">   26020 </span><span class="lineCov">     355191 :       dw_die_ref context_die = get_context_die (DECL_CONTEXT (decl));</span>
<span class="lineNum">   26021 </span>            : 
<span class="lineNum">   26022 </span><span class="lineCov">     355191 :       decl_die = lookup_decl_die (decl);</span>
<span class="lineNum">   26023 </span><span class="lineCov">     355191 :       if (decl_die)</span>
<span class="lineNum">   26024 </span>            :         return decl_die;
<span class="lineNum">   26025 </span>            : 
<span class="lineNum">   26026 </span><span class="lineCov">     355191 :       switch (TREE_CODE (decl))</span>
<span class="lineNum">   26027 </span>            :         {
<span class="lineNum">   26028 </span><span class="lineCov">     315736 :         case FUNCTION_DECL:</span>
<span class="lineNum">   26029 </span>            :           /* Clear current_function_decl, so that gen_subprogram_die thinks
<span class="lineNum">   26030 </span>            :              that this is a declaration. At this point, we just want to force
<span class="lineNum">   26031 </span>            :              declaration die.  */
<span class="lineNum">   26032 </span><span class="lineCov">     315736 :           save_fn = current_function_decl;</span>
<span class="lineNum">   26033 </span><span class="lineCov">     315736 :           current_function_decl = NULL_TREE;</span>
<span class="lineNum">   26034 </span><span class="lineCov">     315736 :           gen_subprogram_die (decl, context_die);</span>
<span class="lineNum">   26035 </span><span class="lineCov">     315736 :           current_function_decl = save_fn;</span>
<span class="lineNum">   26036 </span><span class="lineCov">     315736 :           break;</span>
<span class="lineNum">   26037 </span>            : 
<span class="lineNum">   26038 </span><span class="lineCov">        219 :         case VAR_DECL:</span>
<span class="lineNum">   26039 </span>            :           /* Set external flag to force declaration die. Restore it after
<span class="lineNum">   26040 </span>            :            gen_decl_die() call.  */
<span class="lineNum">   26041 </span><span class="lineCov">        219 :           saved_external_flag = DECL_EXTERNAL (decl);</span>
<span class="lineNum">   26042 </span><span class="lineCov">        219 :           DECL_EXTERNAL (decl) = 1;</span>
<span class="lineNum">   26043 </span><span class="lineCov">        219 :           gen_decl_die (decl, NULL, NULL, context_die);</span>
<span class="lineNum">   26044 </span><span class="lineCov">        219 :           DECL_EXTERNAL (decl) = saved_external_flag;</span>
<span class="lineNum">   26045 </span><span class="lineCov">        219 :           break;</span>
<span class="lineNum">   26046 </span>            : 
<span class="lineNum">   26047 </span><span class="lineCov">      39230 :         case NAMESPACE_DECL:</span>
<span class="lineNum">   26048 </span><span class="lineCov">      39230 :           if (dwarf_version &gt;= 3 || !dwarf_strict)</span>
<span class="lineNum">   26049 </span><span class="lineCov">      39230 :             dwarf2out_decl (decl);</span>
<span class="lineNum">   26050 </span>            :           else
<span class="lineNum">   26051 </span>            :             /* DWARF2 has neither DW_TAG_module, nor DW_TAG_namespace.  */
<span class="lineNum">   26052 </span><span class="lineNoCov">          0 :             decl_die = comp_unit_die ();</span>
<span class="lineNum">   26053 </span>            :           break;
<span class="lineNum">   26054 </span>            : 
<span class="lineNum">   26055 </span><span class="lineCov">          6 :         case TRANSLATION_UNIT_DECL:</span>
<span class="lineNum">   26056 </span><span class="lineCov">          6 :           decl_die = comp_unit_die ();</span>
<span class="lineNum">   26057 </span><span class="lineCov">          6 :           break;</span>
<span class="lineNum">   26058 </span>            : 
<span class="lineNum">   26059 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">   26060 </span><span class="lineNoCov">          0 :           gcc_unreachable ();</span>
<span class="lineNum">   26061 </span>            :         }
<span class="lineNum">   26062 </span>            : 
<span class="lineNum">   26063 </span>            :       /* We should be able to find the DIE now.  */
<span class="lineNum">   26064 </span><span class="lineCov">     355191 :       if (!decl_die)</span>
<span class="lineNum">   26065 </span><span class="lineCov">     355185 :         decl_die = lookup_decl_die (decl);</span>
<span class="lineNum">   26066 </span><span class="lineCov">     355191 :       gcc_assert (decl_die);</span>
<span class="lineNum">   26067 </span>            :     }
<span class="lineNum">   26068 </span>            : 
<span class="lineNum">   26069 </span>            :   return decl_die;
<span class="lineNum">   26070 </span>            : }
<span class="lineNum">   26071 </span>            : 
<span class="lineNum">   26072 </span>            : /* Returns the DIE for TYPE, that must not be a base type.  A DIE is
<span class="lineNum">   26073 </span>            :    always returned.  */
<a name="26074"><span class="lineNum">   26074 </span>            : </a>
<span class="lineNum">   26075 </span>            : static dw_die_ref
<span class="lineNum">   26076 </span><span class="lineCov">    1931916 : force_type_die (tree type)</span>
<span class="lineNum">   26077 </span>            : {
<span class="lineNum">   26078 </span><span class="lineCov">    1931916 :   dw_die_ref type_die;</span>
<span class="lineNum">   26079 </span>            : 
<span class="lineNum">   26080 </span><span class="lineCov">    1931916 :   type_die = lookup_type_die (type);</span>
<span class="lineNum">   26081 </span><span class="lineCov">    1931916 :   if (!type_die)</span>
<span class="lineNum">   26082 </span>            :     {
<span class="lineNum">   26083 </span><span class="lineCov">      18117 :       dw_die_ref context_die = get_context_die (TYPE_CONTEXT (type));</span>
<span class="lineNum">   26084 </span>            : 
<span class="lineNum">   26085 </span><span class="lineCov">      18117 :       type_die = modified_type_die (type, TYPE_QUALS_NO_ADDR_SPACE (type),</span>
<span class="lineNum">   26086 </span>            :                                     false, context_die);
<span class="lineNum">   26087 </span><span class="lineCov">      18117 :       gcc_assert (type_die);</span>
<span class="lineNum">   26088 </span>            :     }
<span class="lineNum">   26089 </span><span class="lineCov">    1931916 :   return type_die;</span>
<span class="lineNum">   26090 </span>            : }
<span class="lineNum">   26091 </span>            : 
<span class="lineNum">   26092 </span>            : /* Force out any required namespaces to be able to output DECL,
<span class="lineNum">   26093 </span>            :    and return the new context_die for it, if it's changed.  */
<a name="26094"><span class="lineNum">   26094 </span>            : </a>
<span class="lineNum">   26095 </span>            : static dw_die_ref
<span class="lineNum">   26096 </span><span class="lineCov">   31154466 : setup_namespace_context (tree thing, dw_die_ref context_die)</span>
<span class="lineNum">   26097 </span>            : {
<span class="lineNum">   26098 </span><span class="lineCov">   31154466 :   tree context = (DECL_P (thing)</span>
<span class="lineNum">   26099 </span><span class="lineCov">   31154466 :                   ? DECL_CONTEXT (thing) : TYPE_CONTEXT (thing));</span>
<span class="lineNum">   26100 </span><span class="lineCov">   31154466 :   if (context &amp;&amp; TREE_CODE (context) == NAMESPACE_DECL)</span>
<span class="lineNum">   26101 </span>            :     /* Force out the namespace.  */
<span class="lineNum">   26102 </span><span class="lineCov">   20645780 :     context_die = force_decl_die (context);</span>
<span class="lineNum">   26103 </span>            : 
<span class="lineNum">   26104 </span><span class="lineCov">   31154466 :   return context_die;</span>
<span class="lineNum">   26105 </span>            : }
<span class="lineNum">   26106 </span>            : 
<span class="lineNum">   26107 </span>            : /* Emit a declaration DIE for THING (which is either a DECL or a tagged
<span class="lineNum">   26108 </span>            :    type) within its namespace, if appropriate.
<span class="lineNum">   26109 </span>            : 
<span class="lineNum">   26110 </span>            :    For compatibility with older debuggers, namespace DIEs only contain
<span class="lineNum">   26111 </span>            :    declarations; all definitions are emitted at CU scope, with
<span class="lineNum">   26112 </span>            :    DW_AT_specification pointing to the declaration (like with class
<span class="lineNum">   26113 </span>            :    members).  */
<a name="26114"><span class="lineNum">   26114 </span>            : </a>
<span class="lineNum">   26115 </span>            : static dw_die_ref
<span class="lineNum">   26116 </span><span class="lineCov">   31131000 : declare_in_namespace (tree thing, dw_die_ref context_die)</span>
<span class="lineNum">   26117 </span>            : {
<span class="lineNum">   26118 </span><span class="lineCov">   31131000 :   dw_die_ref ns_context;</span>
<span class="lineNum">   26119 </span>            : 
<span class="lineNum">   26120 </span><span class="lineCov">   31131000 :   if (debug_info_level &lt;= DINFO_LEVEL_TERSE)</span>
<span class="lineNum">   26121 </span>            :     return context_die;
<span class="lineNum">   26122 </span>            : 
<span class="lineNum">   26123 </span>            :   /* External declarations in the local scope only need to be emitted
<span class="lineNum">   26124 </span>            :      once, not once in the namespace and once in the scope.
<span class="lineNum">   26125 </span>            : 
<span class="lineNum">   26126 </span>            :      This avoids declaring the `extern' below in the
<span class="lineNum">   26127 </span>            :      namespace DIE as well as in the innermost scope:
<span class="lineNum">   26128 </span>            : 
<span class="lineNum">   26129 </span>            :           namespace S
<span class="lineNum">   26130 </span>            :           {
<span class="lineNum">   26131 </span>            :             int i=5;
<span class="lineNum">   26132 </span>            :             int foo()
<span class="lineNum">   26133 </span>            :             {
<span class="lineNum">   26134 </span>            :               int i=8;
<span class="lineNum">   26135 </span>            :               extern int i;
<span class="lineNum">   26136 </span>            :               return i;
<span class="lineNum">   26137 </span>            :             }
<span class="lineNum">   26138 </span>            :           }
<span class="lineNum">   26139 </span>            :   */
<span class="lineNum">   26140 </span><span class="lineCov">   37829808 :   if (DECL_P (thing) &amp;&amp; DECL_EXTERNAL (thing) &amp;&amp; local_scope_p (context_die))</span>
<span class="lineNum">   26141 </span>            :     return context_die;
<span class="lineNum">   26142 </span>            : 
<span class="lineNum">   26143 </span>            :   /* If this decl is from an inlined function, then don't try to emit it in its
<span class="lineNum">   26144 </span>            :      namespace, as we will get confused.  It would have already been emitted
<span class="lineNum">   26145 </span>            :      when the abstract instance of the inline function was emitted anyways.  */
<span class="lineNum">   26146 </span><span class="lineCov">   31121007 :   if (DECL_P (thing) &amp;&amp; DECL_ABSTRACT_ORIGIN (thing))</span>
<span class="lineNum">   26147 </span>            :     return context_die;
<span class="lineNum">   26148 </span>            : 
<span class="lineNum">   26149 </span><span class="lineCov">   31114882 :   ns_context = setup_namespace_context (thing, context_die);</span>
<span class="lineNum">   26150 </span>            : 
<span class="lineNum">   26151 </span><span class="lineCov">   31114882 :   if (ns_context != context_die)</span>
<span class="lineNum">   26152 </span>            :     {
<span class="lineNum">   26153 </span><span class="lineCov">   10305958 :       if (is_fortran ())</span>
<span class="lineNum">   26154 </span>            :         return ns_context;
<span class="lineNum">   26155 </span><span class="lineCov">   10299215 :       if (DECL_P (thing))</span>
<span class="lineNum">   26156 </span><span class="lineCov">     354784 :         gen_decl_die (thing, NULL, NULL, ns_context);</span>
<span class="lineNum">   26157 </span>            :       else
<span class="lineNum">   26158 </span><span class="lineCov">    9944431 :         gen_type_die (thing, ns_context);</span>
<span class="lineNum">   26159 </span>            :     }
<span class="lineNum">   26160 </span>            :   return context_die;
<span class="lineNum">   26161 </span>            : }
<span class="lineNum">   26162 </span>            : 
<span class="lineNum">   26163 </span>            : /* Generate a DIE for a namespace or namespace alias.  */
<a name="26164"><span class="lineNum">   26164 </span>            : </a>
<span class="lineNum">   26165 </span>            : static void
<span class="lineNum">   26166 </span><span class="lineCov">      39584 : gen_namespace_die (tree decl, dw_die_ref context_die)</span>
<span class="lineNum">   26167 </span>            : {
<span class="lineNum">   26168 </span><span class="lineCov">      39584 :   dw_die_ref namespace_die;</span>
<span class="lineNum">   26169 </span>            : 
<span class="lineNum">   26170 </span>            :   /* Namespace aliases have a DECL_ABSTRACT_ORIGIN of the namespace
<span class="lineNum">   26171 </span>            :      they are an alias of.  */
<span class="lineNum">   26172 </span><span class="lineCov">      39584 :   if (DECL_ABSTRACT_ORIGIN (decl) == NULL)</span>
<span class="lineNum">   26173 </span>            :     {
<span class="lineNum">   26174 </span>            :       /* Output a real namespace or module.  */
<span class="lineNum">   26175 </span><span class="lineCov">      39230 :       context_die = setup_namespace_context (decl, comp_unit_die ());</span>
<span class="lineNum">   26176 </span><span class="lineCov">      77513 :       namespace_die = new_die (is_fortran ()</span>
<span class="lineNum">   26177 </span>            :                                ? DW_TAG_module : DW_TAG_namespace,
<span class="lineNum">   26178 </span>            :                                context_die, decl);
<span class="lineNum">   26179 </span>            :       /* For Fortran modules defined in different CU don't add src coords.  */
<span class="lineNum">   26180 </span><span class="lineCov">      39230 :       if (namespace_die-&gt;die_tag == DW_TAG_module &amp;&amp; DECL_EXTERNAL (decl))</span>
<span class="lineNum">   26181 </span>            :         {
<span class="lineNum">   26182 </span><span class="lineCov">        106 :           const char *name = dwarf2_name (decl, 0);</span>
<span class="lineNum">   26183 </span><span class="lineCov">        106 :           if (name)</span>
<span class="lineNum">   26184 </span><span class="lineCov">        106 :             add_name_attribute (namespace_die, name);</span>
<span class="lineNum">   26185 </span>            :         }
<span class="lineNum">   26186 </span>            :       else
<span class="lineNum">   26187 </span><span class="lineCov">      39124 :         add_name_and_src_coords_attributes (namespace_die, decl);</span>
<span class="lineNum">   26188 </span><span class="lineCov">      39230 :       if (DECL_EXTERNAL (decl))</span>
<span class="lineNum">   26189 </span><span class="lineCov">        106 :         add_AT_flag (namespace_die, DW_AT_declaration, 1);</span>
<span class="lineNum">   26190 </span><span class="lineCov">      39230 :       equate_decl_number_to_die (decl, namespace_die);</span>
<span class="lineNum">   26191 </span>            :     }
<span class="lineNum">   26192 </span>            :   else
<span class="lineNum">   26193 </span>            :     {
<span class="lineNum">   26194 </span>            :       /* Output a namespace alias.  */
<span class="lineNum">   26195 </span>            : 
<span class="lineNum">   26196 </span>            :       /* Force out the namespace we are an alias of, if necessary.  */
<span class="lineNum">   26197 </span><span class="lineCov">        354 :       dw_die_ref origin_die</span>
<span class="lineNum">   26198 </span><span class="lineCov">        708 :         = force_decl_die (DECL_ABSTRACT_ORIGIN (decl));</span>
<span class="lineNum">   26199 </span>            : 
<span class="lineNum">   26200 </span><span class="lineCov">       1062 :       if (DECL_FILE_SCOPE_P (decl)</span>
<span class="lineNum">   26201 </span><span class="lineCov">        370 :           || TREE_CODE (DECL_CONTEXT (decl)) == NAMESPACE_DECL)</span>
<span class="lineNum">   26202 </span><span class="lineCov">        354 :         context_die = setup_namespace_context (decl, comp_unit_die ());</span>
<span class="lineNum">   26203 </span>            :       /* Now create the namespace alias DIE.  */
<span class="lineNum">   26204 </span><span class="lineCov">        354 :       namespace_die = new_die (DW_TAG_imported_declaration, context_die, decl);</span>
<span class="lineNum">   26205 </span><span class="lineCov">        354 :       add_name_and_src_coords_attributes (namespace_die, decl);</span>
<span class="lineNum">   26206 </span><span class="lineCov">        354 :       add_AT_die_ref (namespace_die, DW_AT_import, origin_die);</span>
<span class="lineNum">   26207 </span><span class="lineCov">        354 :       equate_decl_number_to_die (decl, namespace_die);</span>
<span class="lineNum">   26208 </span>            :     }
<span class="lineNum">   26209 </span><span class="lineCov">      39572 :   if ((dwarf_version &gt;= 5 || !dwarf_strict)</span>
<span class="lineNum">   26210 </span><span class="lineCov">      79156 :       &amp;&amp; lang_hooks.decls.decl_dwarf_attribute (decl,</span>
<span class="lineNum">   26211 </span>            :                                                 DW_AT_export_symbols) == 1)
<span class="lineNum">   26212 </span><span class="lineCov">       8902 :     add_AT_flag (namespace_die, DW_AT_export_symbols, 1);</span>
<span class="lineNum">   26213 </span>            : 
<span class="lineNum">   26214 </span>            :   /* Bypass dwarf2_name's check for DECL_NAMELESS.  */
<span class="lineNum">   26215 </span><span class="lineCov">      79168 :   if (want_pubnames ())</span>
<span class="lineNum">   26216 </span><span class="lineCov">         20 :     add_pubname_string (lang_hooks.dwarf_name (decl, 1), namespace_die);</span>
<span class="lineNum">   26217 </span><span class="lineCov">      39584 : }</span>
<span class="lineNum">   26218 </span>            : 
<span class="lineNum">   26219 </span>            : /* Generate Dwarf debug information for a decl described by DECL.
<span class="lineNum">   26220 </span>            :    The return value is currently only meaningful for PARM_DECLs,
<span class="lineNum">   26221 </span>            :    for all other decls it returns NULL.
<span class="lineNum">   26222 </span>            : 
<span class="lineNum">   26223 </span>            :    If DECL is a FIELD_DECL, CTX is required: see the comment for VLR_CONTEXT.
<span class="lineNum">   26224 </span>            :    It can be NULL otherwise.  */
<a name="26225"><span class="lineNum">   26225 </span>            : </a>
<span class="lineNum">   26226 </span>            : static dw_die_ref
<span class="lineNum">   26227 </span><span class="lineCov">   52157666 : gen_decl_die (tree decl, tree origin, struct vlr_context *ctx,</span>
<span class="lineNum">   26228 </span>            :               dw_die_ref context_die)
<span class="lineNum">   26229 </span>            : {
<span class="lineNum">   26230 </span><span class="lineCov">   52157666 :   tree decl_or_origin = decl ? decl : origin;</span>
<span class="lineNum">   26231 </span><span class="lineCov">   52157666 :   tree class_origin = NULL, ultimate_origin;</span>
<span class="lineNum">   26232 </span>            : 
<span class="lineNum">   26233 </span><span class="lineCov">   52157666 :   if (DECL_P (decl_or_origin) &amp;&amp; DECL_IGNORED_P (decl_or_origin))</span>
<span class="lineNum">   26234 </span>            :     return NULL;
<span class="lineNum">   26235 </span>            : 
<span class="lineNum">   26236 </span><span class="lineCov">   49052175 :   switch (TREE_CODE (decl_or_origin))</span>
<span class="lineNum">   26237 </span>            :     {
<span class="lineNum">   26238 </span>            :     case ERROR_MARK:
<span class="lineNum">   26239 </span>            :       break;
<span class="lineNum">   26240 </span>            : 
<span class="lineNum">   26241 </span><span class="lineCov">     179201 :     case CONST_DECL:</span>
<span class="lineNum">   26242 </span><span class="lineCov">     179201 :       if (!is_fortran () &amp;&amp; !is_ada ())</span>
<span class="lineNum">   26243 </span>            :         {
<span class="lineNum">   26244 </span>            :           /* The individual enumerators of an enum type get output when we output
<span class="lineNum">   26245 </span>            :              the Dwarf representation of the relevant enum type itself.  */
<span class="lineNum">   26246 </span>            :           break;
<span class="lineNum">   26247 </span>            :         }
<span class="lineNum">   26248 </span>            : 
<span class="lineNum">   26249 </span>            :       /* Emit its type.  */
<span class="lineNum">   26250 </span><span class="lineCov">      15121 :       gen_type_die (TREE_TYPE (decl), context_die);</span>
<span class="lineNum">   26251 </span>            : 
<span class="lineNum">   26252 </span>            :       /* And its containing namespace.  */
<span class="lineNum">   26253 </span><span class="lineCov">      15121 :       context_die = declare_in_namespace (decl, context_die);</span>
<span class="lineNum">   26254 </span>            : 
<span class="lineNum">   26255 </span><span class="lineCov">      15121 :       gen_const_die (decl, context_die);</span>
<span class="lineNum">   26256 </span><span class="lineCov">      15121 :       break;</span>
<span class="lineNum">   26257 </span>            : 
<span class="lineNum">   26258 </span><span class="lineCov">    7606085 :     case FUNCTION_DECL:</span>
<span class="lineNum">   26259 </span>            : #if 0
<span class="lineNum">   26260 </span>            :       /* FIXME */
<span class="lineNum">   26261 </span>            :       /* This doesn't work because the C frontend sets DECL_ABSTRACT_ORIGIN
<span class="lineNum">   26262 </span>            :          on local redeclarations of global functions.  That seems broken.  */
<span class="lineNum">   26263 </span>            :       if (current_function_decl != decl)
<span class="lineNum">   26264 </span>            :         /* This is only a declaration.  */;
<span class="lineNum">   26265 </span>            : #endif
<span class="lineNum">   26266 </span>            : 
<span class="lineNum">   26267 </span>            :       /* We should have abstract copies already and should not generate
<span class="lineNum">   26268 </span>            :          stray type DIEs in late LTO dumping.  */
<span class="lineNum">   26269 </span><span class="lineCov">    7606085 :       if (! early_dwarf)</span>
<span class="lineNum">   26270 </span>            :         ;
<span class="lineNum">   26271 </span>            : 
<span class="lineNum">   26272 </span>            :       /* If we're emitting a clone, emit info for the abstract instance.  */
<span class="lineNum">   26273 </span><span class="lineCov">    7261383 :       else if (origin || DECL_ORIGIN (decl) != decl)</span>
<span class="lineNum">   26274 </span><span class="lineCov">     409854 :         dwarf2out_abstract_function (origin</span>
<span class="lineNum">   26275 </span><span class="lineNoCov">          0 :                                      ? DECL_ORIGIN (origin)</span>
<span class="lineNum">   26276 </span><span class="lineCov">     204927 :                                      : DECL_ABSTRACT_ORIGIN (decl));</span>
<span class="lineNum">   26277 </span>            : 
<span class="lineNum">   26278 </span>            :       /* If we're emitting a possibly inlined function emit it as
<span class="lineNum">   26279 </span>            :          abstract instance.  */
<span class="lineNum">   26280 </span><span class="lineCov">    7056456 :       else if (cgraph_function_possibly_inlined_p (decl)</span>
<span class="lineNum">   26281 </span><span class="lineCov">    5813487 :                &amp;&amp; ! DECL_ABSTRACT_P (decl)</span>
<span class="lineNum">   26282 </span><span class="lineCov">    4486473 :                &amp;&amp; ! class_or_namespace_scope_p (context_die)</span>
<span class="lineNum">   26283 </span>            :                /* dwarf2out_abstract_function won't emit a die if this is just
<span class="lineNum">   26284 </span>            :                   a declaration.  We must avoid setting DECL_ABSTRACT_ORIGIN in
<span class="lineNum">   26285 </span>            :                   that case, because that works only if we have a die.  */
<span class="lineNum">   26286 </span><span class="lineCov">    7056456 :                &amp;&amp; DECL_INITIAL (decl) != NULL_TREE)</span>
<span class="lineNum">   26287 </span><span class="lineNoCov">          0 :         dwarf2out_abstract_function (decl);</span>
<span class="lineNum">   26288 </span>            : 
<span class="lineNum">   26289 </span>            :       /* Otherwise we're emitting the primary DIE for this decl.  */
<span class="lineNum">   26290 </span><span class="lineCov">    7056456 :       else if (debug_info_level &gt; DINFO_LEVEL_TERSE)</span>
<span class="lineNum">   26291 </span>            :         {
<span class="lineNum">   26292 </span>            :           /* Before we describe the FUNCTION_DECL itself, make sure that we
<span class="lineNum">   26293 </span>            :              have its containing type.  */
<span class="lineNum">   26294 </span><span class="lineCov">    7053504 :           if (!origin)</span>
<span class="lineNum">   26295 </span><span class="lineCov">    7053504 :             origin = decl_class_context (decl);</span>
<span class="lineNum">   26296 </span><span class="lineCov">    7053504 :           if (origin != NULL_TREE)</span>
<span class="lineNum">   26297 </span><span class="lineCov">    6451200 :             gen_type_die (origin, context_die);</span>
<span class="lineNum">   26298 </span>            : 
<span class="lineNum">   26299 </span>            :           /* And its return type.  */
<span class="lineNum">   26300 </span><span class="lineCov">    7053504 :           gen_type_die (TREE_TYPE (TREE_TYPE (decl)), context_die);</span>
<span class="lineNum">   26301 </span>            : 
<span class="lineNum">   26302 </span>            :           /* And its virtual context.  */
<span class="lineNum">   26303 </span><span class="lineCov">    7053504 :           if (DECL_VINDEX (decl) != NULL_TREE)</span>
<span class="lineNum">   26304 </span><span class="lineCov">     348217 :             gen_type_die (DECL_CONTEXT (decl), context_die);</span>
<span class="lineNum">   26305 </span>            : 
<span class="lineNum">   26306 </span>            :           /* Make sure we have a member DIE for decl.  */
<span class="lineNum">   26307 </span><span class="lineCov">    7053504 :           if (origin != NULL_TREE)</span>
<span class="lineNum">   26308 </span><span class="lineCov">    6451200 :             gen_type_die_for_member (origin, decl, context_die);</span>
<span class="lineNum">   26309 </span>            : 
<span class="lineNum">   26310 </span>            :           /* And its containing namespace.  */
<span class="lineNum">   26311 </span><span class="lineCov">    7053504 :           context_die = declare_in_namespace (decl, context_die);</span>
<span class="lineNum">   26312 </span>            :         }
<span class="lineNum">   26313 </span>            : 
<span class="lineNum">   26314 </span>            :       /* Now output a DIE to represent the function itself.  */
<span class="lineNum">   26315 </span><span class="lineCov">    7606085 :       if (decl)</span>
<span class="lineNum">   26316 </span><span class="lineCov">    7606085 :         gen_subprogram_die (decl, context_die);</span>
<span class="lineNum">   26317 </span>            :       break;
<span class="lineNum">   26318 </span>            : 
<span class="lineNum">   26319 </span><span class="lineCov">   25429223 :     case TYPE_DECL:</span>
<span class="lineNum">   26320 </span>            :       /* If we are in terse mode, don't generate any DIEs to represent any
<span class="lineNum">   26321 </span>            :          actual typedefs.  */
<span class="lineNum">   26322 </span><span class="lineCov">   25429223 :       if (debug_info_level &lt;= DINFO_LEVEL_TERSE)</span>
<span class="lineNum">   26323 </span>            :         break;
<span class="lineNum">   26324 </span>            : 
<span class="lineNum">   26325 </span>            :       /* In the special case of a TYPE_DECL node representing the declaration
<span class="lineNum">   26326 </span>            :          of some type tag, if the given TYPE_DECL is marked as having been
<span class="lineNum">   26327 </span>            :          instantiated from some other (original) TYPE_DECL node (e.g. one which
<span class="lineNum">   26328 </span>            :          was generated within the original definition of an inline function) we
<span class="lineNum">   26329 </span>            :          used to generate a special (abbreviated) DW_TAG_structure_type,
<span class="lineNum">   26330 </span>            :          DW_TAG_union_type, or DW_TAG_enumeration_type DIE here.  But nothing
<span class="lineNum">   26331 </span>            :          should be actually referencing those DIEs, as variable DIEs with that
<span class="lineNum">   26332 </span>            :          type would be emitted already in the abstract origin, so it was always
<span class="lineNum">   26333 </span>            :          removed during unused type prunning.  Don't add anything in this
<span class="lineNum">   26334 </span>            :          case.  */
<span class="lineNum">   26335 </span><span class="lineCov">   25429223 :       if (TYPE_DECL_IS_STUB (decl) &amp;&amp; decl_ultimate_origin (decl) != NULL_TREE)</span>
<span class="lineNum">   26336 </span>            :         break;
<span class="lineNum">   26337 </span>            : 
<span class="lineNum">   26338 </span><span class="lineCov">   25429223 :       if (is_redundant_typedef (decl))</span>
<span class="lineNum">   26339 </span><span class="lineCov">   16601966 :         gen_type_die (TREE_TYPE (decl), context_die);</span>
<span class="lineNum">   26340 </span>            :       else
<span class="lineNum">   26341 </span>            :         /* Output a DIE to represent the typedef itself.  */
<span class="lineNum">   26342 </span><span class="lineCov">    8827257 :         gen_typedef_die (decl, context_die);</span>
<span class="lineNum">   26343 </span>            :       break;
<span class="lineNum">   26344 </span>            : 
<span class="lineNum">   26345 </span><span class="lineCov">       3873 :     case LABEL_DECL:</span>
<span class="lineNum">   26346 </span><span class="lineCov">       3873 :       if (debug_info_level &gt;= DINFO_LEVEL_NORMAL)</span>
<span class="lineNum">   26347 </span><span class="lineCov">       3873 :         gen_label_die (decl, context_die);</span>
<span class="lineNum">   26348 </span>            :       break;
<span class="lineNum">   26349 </span>            : 
<span class="lineNum">   26350 </span><span class="lineCov">   10207050 :     case VAR_DECL:</span>
<span class="lineNum">   26351 </span><span class="lineCov">   10207050 :     case RESULT_DECL:</span>
<span class="lineNum">   26352 </span>            :       /* If we are in terse mode, don't generate any DIEs to represent any
<span class="lineNum">   26353 </span>            :          variable declarations or definitions.  */
<span class="lineNum">   26354 </span><span class="lineCov">   10207050 :       if (debug_info_level &lt;= DINFO_LEVEL_TERSE)</span>
<span class="lineNum">   26355 </span>            :         break;
<span class="lineNum">   26356 </span>            : 
<span class="lineNum">   26357 </span>            :       /* Avoid generating stray type DIEs during late dwarf dumping.
<span class="lineNum">   26358 </span>            :          All types have been dumped early.  */
<span class="lineNum">   26359 </span><span class="lineCov">   10207050 :       if (early_dwarf</span>
<span class="lineNum">   26360 </span>            :           /* ???  But in LTRANS we cannot annotate early created variably
<span class="lineNum">   26361 </span>            :              modified type DIEs without copying them and adjusting all
<span class="lineNum">   26362 </span>            :              references to them.  Dump them again as happens for inlining
<span class="lineNum">   26363 </span>            :              which copies both the decl and the types.  */
<span class="lineNum">   26364 </span>            :           /* ???  And even non-LTO needs to re-visit type DIEs to fill
<span class="lineNum">   26365 </span>            :              in VLA bound information for example.  */
<span class="lineNum">   26366 </span><span class="lineCov">   10207050 :           || (decl &amp;&amp; variably_modified_type_p (TREE_TYPE (decl),</span>
<span class="lineNum">   26367 </span>            :                                                 current_function_decl)))
<span class="lineNum">   26368 </span>            :         {
<span class="lineNum">   26369 </span>            :           /* Output any DIEs that are needed to specify the type of this data
<span class="lineNum">   26370 </span>            :              object.  */
<span class="lineNum">   26371 </span><span class="lineCov">    3156485 :           if (decl_by_reference_p (decl_or_origin))</span>
<span class="lineNum">   26372 </span><span class="lineCov">       1118 :             gen_type_die (TREE_TYPE (TREE_TYPE (decl_or_origin)), context_die);</span>
<span class="lineNum">   26373 </span>            :           else
<span class="lineNum">   26374 </span><span class="lineCov">    3155367 :             gen_type_die (TREE_TYPE (decl_or_origin), context_die);</span>
<span class="lineNum">   26375 </span>            :         }
<span class="lineNum">   26376 </span>            : 
<span class="lineNum">   26377 </span><span class="lineCov">   10207050 :       if (early_dwarf)</span>
<span class="lineNum">   26378 </span>            :         {
<span class="lineNum">   26379 </span>            :           /* And its containing type.  */
<span class="lineNum">   26380 </span><span class="lineCov">    3153863 :           class_origin = decl_class_context (decl_or_origin);</span>
<span class="lineNum">   26381 </span><span class="lineCov">    3153863 :           if (class_origin != NULL_TREE)</span>
<span class="lineNum">   26382 </span><span class="lineCov">    1233236 :             gen_type_die_for_member (class_origin, decl_or_origin, context_die);</span>
<span class="lineNum">   26383 </span>            : 
<span class="lineNum">   26384 </span>            :           /* And its containing namespace.  */
<span class="lineNum">   26385 </span><span class="lineCov">    3153863 :           context_die = declare_in_namespace (decl_or_origin, context_die);</span>
<span class="lineNum">   26386 </span>            :         }
<span class="lineNum">   26387 </span>            : 
<span class="lineNum">   26388 </span>            :       /* Now output the DIE to represent the data object itself.  This gets
<span class="lineNum">   26389 </span>            :          complicated because of the possibility that the VAR_DECL really
<span class="lineNum">   26390 </span>            :          represents an inlined instance of a formal parameter for an inline
<span class="lineNum">   26391 </span>            :          function.  */
<span class="lineNum">   26392 </span><span class="lineCov">   10207050 :       ultimate_origin = decl_ultimate_origin (decl_or_origin);</span>
<span class="lineNum">   26393 </span><span class="lineCov">   10207050 :       if (ultimate_origin != NULL_TREE</span>
<span class="lineNum">   26394 </span><span class="lineCov">    6237964 :           &amp;&amp; TREE_CODE (ultimate_origin) == PARM_DECL)</span>
<span class="lineNum">   26395 </span><span class="lineCov">    5724144 :         gen_formal_parameter_die (decl, origin,</span>
<span class="lineNum">   26396 </span>            :                                   true /* Emit name attribute.  */,
<span class="lineNum">   26397 </span>            :                                   context_die);
<span class="lineNum">   26398 </span>            :       else
<span class="lineNum">   26399 </span><span class="lineCov">    4482906 :         gen_variable_die (decl, origin, context_die);</span>
<span class="lineNum">   26400 </span>            :       break;
<span class="lineNum">   26401 </span>            : 
<span class="lineNum">   26402 </span><span class="lineCov">    2588598 :     case FIELD_DECL:</span>
<span class="lineNum">   26403 </span><span class="lineCov">    2588598 :       gcc_assert (ctx != NULL &amp;&amp; ctx-&gt;struct_type != NULL);</span>
<span class="lineNum">   26404 </span>            :       /* Ignore the nameless fields that are used to skip bits but handle C++
<span class="lineNum">   26405 </span>            :          anonymous unions and structs.  */
<span class="lineNum">   26406 </span><span class="lineCov">    2588598 :       if (DECL_NAME (decl) != NULL_TREE</span>
<span class="lineNum">   26407 </span><span class="lineCov">      52460 :           || TREE_CODE (TREE_TYPE (decl)) == UNION_TYPE</span>
<span class="lineNum">   26408 </span><span class="lineCov">    2641540 :           || TREE_CODE (TREE_TYPE (decl)) == RECORD_TYPE)</span>
<span class="lineNum">   26409 </span>            :         {
<span class="lineNum">   26410 </span><span class="lineCov">    2562521 :           gen_type_die (member_declared_type (decl), context_die);</span>
<span class="lineNum">   26411 </span><span class="lineCov">    2562521 :           gen_field_die (decl, ctx, context_die);</span>
<span class="lineNum">   26412 </span>            :         }
<span class="lineNum">   26413 </span>            :       break;
<span class="lineNum">   26414 </span>            : 
<span class="lineNum">   26415 </span><span class="lineCov">    2997429 :     case PARM_DECL:</span>
<span class="lineNum">   26416 </span>            :       /* Avoid generating stray type DIEs during late dwarf dumping.
<span class="lineNum">   26417 </span>            :          All types have been dumped early.  */
<span class="lineNum">   26418 </span><span class="lineCov">    2997429 :       if (early_dwarf</span>
<span class="lineNum">   26419 </span>            :           /* ???  But in LTRANS we cannot annotate early created variably
<span class="lineNum">   26420 </span>            :              modified type DIEs without copying them and adjusting all
<span class="lineNum">   26421 </span>            :              references to them.  Dump them again as happens for inlining
<span class="lineNum">   26422 </span>            :              which copies both the decl and the types.  */
<span class="lineNum">   26423 </span>            :           /* ???  And even non-LTO needs to re-visit type DIEs to fill
<span class="lineNum">   26424 </span>            :              in VLA bound information for example.  */
<span class="lineNum">   26425 </span><span class="lineCov">    2997429 :           || (decl &amp;&amp; variably_modified_type_p (TREE_TYPE (decl),</span>
<span class="lineNum">   26426 </span>            :                                                 current_function_decl)))
<span class="lineNum">   26427 </span>            :         {
<span class="lineNum">   26428 </span><span class="lineCov">    4671506 :           if (DECL_BY_REFERENCE (decl_or_origin))</span>
<span class="lineNum">   26429 </span><span class="lineCov">      26595 :             gen_type_die (TREE_TYPE (TREE_TYPE (decl_or_origin)), context_die);</span>
<span class="lineNum">   26430 </span>            :           else
<span class="lineNum">   26431 </span><span class="lineCov">    2309158 :             gen_type_die (TREE_TYPE (decl_or_origin), context_die);</span>
<span class="lineNum">   26432 </span>            :         }
<span class="lineNum">   26433 </span><span class="lineCov">    2997429 :       return gen_formal_parameter_die (decl, origin,</span>
<span class="lineNum">   26434 </span>            :                                        true /* Emit name attribute.  */,
<span class="lineNum">   26435 </span><span class="lineCov">    2997429 :                                        context_die);</span>
<span class="lineNum">   26436 </span>            : 
<span class="lineNum">   26437 </span><span class="lineCov">      39584 :     case NAMESPACE_DECL:</span>
<span class="lineNum">   26438 </span><span class="lineCov">      39584 :       if (dwarf_version &gt;= 3 || !dwarf_strict)</span>
<span class="lineNum">   26439 </span><span class="lineCov">      39584 :         gen_namespace_die (decl, context_die);</span>
<span class="lineNum">   26440 </span>            :       break;
<span class="lineNum">   26441 </span>            : 
<span class="lineNum">   26442 </span><span class="lineNoCov">          0 :     case IMPORTED_DECL:</span>
<span class="lineNum">   26443 </span><span class="lineNoCov">          0 :       dwarf2out_imported_module_or_decl_1 (decl, DECL_NAME (decl),</span>
<span class="lineNum">   26444 </span><span class="lineNoCov">          0 :                                            DECL_CONTEXT (decl), context_die);</span>
<span class="lineNum">   26445 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">   26446 </span>            : 
<span class="lineNum">   26447 </span><span class="lineCov">        211 :     case NAMELIST_DECL:</span>
<span class="lineNum">   26448 </span><span class="lineCov">        633 :       gen_namelist_decl (DECL_NAME (decl), context_die,</span>
<span class="lineNum">   26449 </span><span class="lineCov">        211 :                          NAMELIST_DECL_ASSOCIATED_DECL (decl));</span>
<span class="lineNum">   26450 </span><span class="lineCov">        211 :       break;</span>
<span class="lineNum">   26451 </span>            : 
<span class="lineNum">   26452 </span><span class="lineCov">        921 :     default:</span>
<span class="lineNum">   26453 </span>            :       /* Probably some frontend-internal decl.  Assume we don't care.  */
<span class="lineNum">   26454 </span><span class="lineCov">        921 :       gcc_assert ((int)TREE_CODE (decl) &gt; NUM_TREE_CODES);</span>
<span class="lineNum">   26455 </span>            :       break;
<span class="lineNum">   26456 </span>            :     }
<span class="lineNum">   26457 </span>            : 
<span class="lineNum">   26458 </span>            :   return NULL;
<span class="lineNum">   26459 </span>            : }
<span class="lineNum">   26460 </span>            : 
<span class="lineNum">   26461 </span>            : /* Output initial debug information for global DECL.  Called at the
<span class="lineNum">   26462 </span>            :    end of the parsing process.
<span class="lineNum">   26463 </span>            : 
<span class="lineNum">   26464 </span>            :    This is the initial debug generation process.  As such, the DIEs
<span class="lineNum">   26465 </span>            :    generated may be incomplete.  A later debug generation pass
<span class="lineNum">   26466 </span>            :    (dwarf2out_late_global_decl) will augment the information generated
<span class="lineNum">   26467 </span>            :    in this pass (e.g., with complete location info).  */
<a name="26468"><span class="lineNum">   26468 </span>            : </a>
<span class="lineNum">   26469 </span>            : static void
<span class="lineNum">   26470 </span><span class="lineCov">    4332733 : dwarf2out_early_global_decl (tree decl)</span>
<span class="lineNum">   26471 </span>            : {
<span class="lineNum">   26472 </span><span class="lineCov">    4332733 :   set_early_dwarf s;</span>
<span class="lineNum">   26473 </span>            : 
<span class="lineNum">   26474 </span>            :   /* gen_decl_die() will set DECL_ABSTRACT because
<span class="lineNum">   26475 </span>            :      cgraph_function_possibly_inlined_p() returns true.  This is in
<span class="lineNum">   26476 </span>            :      turn will cause DW_AT_inline attributes to be set.
<span class="lineNum">   26477 </span>            : 
<span class="lineNum">   26478 </span>            :      This happens because at early dwarf generation, there is no
<span class="lineNum">   26479 </span>            :      cgraph information, causing cgraph_function_possibly_inlined_p()
<span class="lineNum">   26480 </span>            :      to return true.  Trick cgraph_function_possibly_inlined_p()
<span class="lineNum">   26481 </span>            :      while we generate dwarf early.  */
<span class="lineNum">   26482 </span><span class="lineCov">    4332733 :   bool save = symtab-&gt;global_info_ready;</span>
<span class="lineNum">   26483 </span><span class="lineCov">    4332733 :   symtab-&gt;global_info_ready = true;</span>
<span class="lineNum">   26484 </span>            : 
<span class="lineNum">   26485 </span>            :   /* We don't handle TYPE_DECLs.  If required, they'll be reached via
<span class="lineNum">   26486 </span>            :      other DECLs and they can point to template types or other things
<span class="lineNum">   26487 </span>            :      that dwarf2out can't handle when done via dwarf2out_decl.  */
<span class="lineNum">   26488 </span><span class="lineCov">    8665466 :   if (TREE_CODE (decl) != TYPE_DECL</span>
<span class="lineNum">   26489 </span><span class="lineCov">    4332733 :       &amp;&amp; TREE_CODE (decl) != PARM_DECL)</span>
<span class="lineNum">   26490 </span>            :     {
<span class="lineNum">   26491 </span><span class="lineCov">    2735794 :       if (TREE_CODE (decl) == FUNCTION_DECL)</span>
<span class="lineNum">   26492 </span>            :         {
<span class="lineNum">   26493 </span><span class="lineCov">    1076040 :           tree save_fndecl = current_function_decl;</span>
<span class="lineNum">   26494 </span>            : 
<span class="lineNum">   26495 </span>            :           /* For nested functions, make sure we have DIEs for the parents first
<span class="lineNum">   26496 </span>            :              so that all nested DIEs are generated at the proper scope in the
<span class="lineNum">   26497 </span>            :              first shot.  */
<span class="lineNum">   26498 </span><span class="lineCov">    1076040 :           tree context = decl_function_context (decl);</span>
<span class="lineNum">   26499 </span><span class="lineCov">    1076040 :           if (context != NULL)</span>
<span class="lineNum">   26500 </span>            :             {
<span class="lineNum">   26501 </span><span class="lineCov">       5804 :               dw_die_ref context_die = lookup_decl_die (context);</span>
<span class="lineNum">   26502 </span><span class="lineCov">       5804 :               current_function_decl = context;</span>
<span class="lineNum">   26503 </span>            : 
<span class="lineNum">   26504 </span>            :               /* Avoid emitting DIEs multiple times, but still process CONTEXT
<span class="lineNum">   26505 </span>            :                  enough so that it lands in its own context.  This avoids type
<span class="lineNum">   26506 </span>            :                  pruning issues later on.  */
<span class="lineNum">   26507 </span><span class="lineCov">      11233 :               if (context_die == NULL || is_declaration_die (context_die))</span>
<span class="lineNum">   26508 </span><span class="lineCov">        479 :                 dwarf2out_decl (context);</span>
<span class="lineNum">   26509 </span>            :             }
<span class="lineNum">   26510 </span>            : 
<span class="lineNum">   26511 </span>            :           /* Emit an abstract origin of a function first.  This happens
<span class="lineNum">   26512 </span>            :              with C++ constructor clones for example and makes
<span class="lineNum">   26513 </span>            :              dwarf2out_abstract_function happy which requires the early
<span class="lineNum">   26514 </span>            :              DIE of the abstract instance to be present.  */
<span class="lineNum">   26515 </span><span class="lineCov">    1076040 :           tree origin = DECL_ABSTRACT_ORIGIN (decl);</span>
<span class="lineNum">   26516 </span><span class="lineCov">    1076040 :           dw_die_ref origin_die;</span>
<span class="lineNum">   26517 </span><span class="lineCov">    1076040 :           if (origin != NULL</span>
<span class="lineNum">   26518 </span>            :               /* Do not emit the DIE multiple times but make sure to
<span class="lineNum">   26519 </span>            :                  process it fully here in case we just saw a declaration.  */
<span class="lineNum">   26520 </span><span class="lineCov">    1076040 :               &amp;&amp; ((origin_die = lookup_decl_die (origin)) == NULL</span>
<span class="lineNum">   26521 </span><span class="lineCov">     149952 :                   || is_declaration_die (origin_die)))</span>
<span class="lineNum">   26522 </span>            :             {
<span class="lineNum">   26523 </span><span class="lineCov">     193831 :               current_function_decl = origin;</span>
<span class="lineNum">   26524 </span><span class="lineCov">     193831 :               dwarf2out_decl (origin);</span>
<span class="lineNum">   26525 </span>            :             }
<span class="lineNum">   26526 </span>            : 
<span class="lineNum">   26527 </span>            :           /* Emit the DIE for decl but avoid doing that multiple times.  */
<span class="lineNum">   26528 </span><span class="lineCov">    1076040 :           dw_die_ref old_die;</span>
<span class="lineNum">   26529 </span><span class="lineCov">    1076040 :           if ((old_die = lookup_decl_die (decl)) == NULL</span>
<span class="lineNum">   26530 </span><span class="lineCov">    1422423 :               || is_declaration_die (old_die))</span>
<span class="lineNum">   26531 </span>            :             {
<span class="lineNum">   26532 </span><span class="lineCov">    1074605 :               current_function_decl = decl;</span>
<span class="lineNum">   26533 </span><span class="lineCov">    1074605 :               dwarf2out_decl (decl);</span>
<span class="lineNum">   26534 </span>            :             }
<span class="lineNum">   26535 </span>            : 
<span class="lineNum">   26536 </span><span class="lineCov">    1076040 :           current_function_decl = save_fndecl;</span>
<span class="lineNum">   26537 </span>            :         }
<span class="lineNum">   26538 </span>            :       else
<span class="lineNum">   26539 </span><span class="lineCov">    1659754 :         dwarf2out_decl (decl);</span>
<span class="lineNum">   26540 </span>            :     }
<span class="lineNum">   26541 </span><span class="lineCov">    4332733 :   symtab-&gt;global_info_ready = save;</span>
<span class="lineNum">   26542 </span><span class="lineCov">    4332733 : }</span>
<span class="lineNum">   26543 </span>            : 
<span class="lineNum">   26544 </span>            : /* Return whether EXPR is an expression with the following pattern:
<span class="lineNum">   26545 </span>            :    INDIRECT_REF (NOP_EXPR (INTEGER_CST)).  */
<a name="26546"><span class="lineNum">   26546 </span>            : </a>
<span class="lineNum">   26547 </span>            : static bool
<span class="lineNum">   26548 </span><span class="lineCov">         47 : is_trivial_indirect_ref (tree expr)</span>
<span class="lineNum">   26549 </span>            : {
<span class="lineNum">   26550 </span><span class="lineCov">         47 :   if (expr == NULL_TREE || TREE_CODE (expr) != INDIRECT_REF)</span>
<span class="lineNum">   26551 </span>            :     return false;
<span class="lineNum">   26552 </span>            : 
<span class="lineNum">   26553 </span><span class="lineNoCov">          0 :   tree nop = TREE_OPERAND (expr, 0);</span>
<span class="lineNum">   26554 </span><span class="lineNoCov">          0 :   if (nop == NULL_TREE || TREE_CODE (nop) != NOP_EXPR)</span>
<span class="lineNum">   26555 </span>            :     return false;
<span class="lineNum">   26556 </span>            : 
<span class="lineNum">   26557 </span><span class="lineNoCov">          0 :   tree int_cst = TREE_OPERAND (nop, 0);</span>
<span class="lineNum">   26558 </span><span class="lineNoCov">          0 :   return int_cst != NULL_TREE &amp;&amp; TREE_CODE (int_cst) == INTEGER_CST;</span>
<span class="lineNum">   26559 </span>            : }
<span class="lineNum">   26560 </span>            : 
<span class="lineNum">   26561 </span>            : /* Output debug information for global decl DECL.  Called from
<span class="lineNum">   26562 </span>            :    toplev.c after compilation proper has finished.  */
<a name="26563"><span class="lineNum">   26563 </span>            : </a>
<span class="lineNum">   26564 </span>            : static void
<span class="lineNum">   26565 </span><span class="lineCov">    7890081 : dwarf2out_late_global_decl (tree decl)</span>
<span class="lineNum">   26566 </span>            : {
<span class="lineNum">   26567 </span>            :   /* Fill-in any location information we were unable to determine
<span class="lineNum">   26568 </span>            :      on the first pass.  */
<span class="lineNum">   26569 </span><span class="lineCov">    7890081 :   if (VAR_P (decl))</span>
<span class="lineNum">   26570 </span>            :     {
<span class="lineNum">   26571 </span><span class="lineCov">    7890081 :       dw_die_ref die = lookup_decl_die (decl);</span>
<span class="lineNum">   26572 </span>            : 
<span class="lineNum">   26573 </span>            :       /* We may have to generate early debug late for LTO in case debug
<span class="lineNum">   26574 </span>            :          was not enabled at compile-time or the target doesn't support
<span class="lineNum">   26575 </span>            :          the LTO early debug scheme.  */
<span class="lineNum">   26576 </span><span class="lineCov">    7890081 :       if (! die &amp;&amp; in_lto_p)</span>
<span class="lineNum">   26577 </span>            :         {
<span class="lineNum">   26578 </span><span class="lineCov">        759 :           dwarf2out_decl (decl);</span>
<span class="lineNum">   26579 </span><span class="lineCov">        759 :           die = lookup_decl_die (decl);</span>
<span class="lineNum">   26580 </span>            :         }
<span class="lineNum">   26581 </span>            : 
<span class="lineNum">   26582 </span><span class="lineCov">    7890081 :       if (die)</span>
<span class="lineNum">   26583 </span>            :         {
<span class="lineNum">   26584 </span>            :           /* We get called via the symtab code invoking late_global_decl
<span class="lineNum">   26585 </span>            :              for symbols that are optimized out.
<span class="lineNum">   26586 </span>            : 
<span class="lineNum">   26587 </span>            :              Do not add locations for those, except if they have a
<span class="lineNum">   26588 </span>            :              DECL_VALUE_EXPR, in which case they are relevant for debuggers.
<span class="lineNum">   26589 </span>            :              Still don't add a location if the DECL_VALUE_EXPR is not a trivial
<span class="lineNum">   26590 </span>            :              INDIRECT_REF expression, as this could generate relocations to
<span class="lineNum">   26591 </span>            :              text symbols in LTO object files, which is invalid.  */
<span class="lineNum">   26592 </span><span class="lineCov">    5442925 :           varpool_node *node = varpool_node::get (decl);</span>
<span class="lineNum">   26593 </span><span class="lineCov">    5442925 :           if ((! node || ! node-&gt;definition)</span>
<span class="lineNum">   26594 </span><span class="lineCov">   10681817 :               &amp;&amp; ! (DECL_HAS_VALUE_EXPR_P (decl)</span>
<span class="lineNum">   26595 </span><span class="lineCov">    5238845 :                     &amp;&amp; is_trivial_indirect_ref (DECL_VALUE_EXPR (decl))))</span>
<span class="lineNum">   26596 </span><span class="lineCov">    5238845 :             tree_add_const_value_attribute_for_decl (die, decl);</span>
<span class="lineNum">   26597 </span>            :           else
<span class="lineNum">   26598 </span><span class="lineCov">     204080 :             add_location_or_const_value_attribute (die, decl, false);</span>
<span class="lineNum">   26599 </span>            :         }
<span class="lineNum">   26600 </span>            :     }
<span class="lineNum">   26601 </span><span class="lineCov">    7890081 : }</span>
<span class="lineNum">   26602 </span>            : 
<span class="lineNum">   26603 </span>            : /* Output debug information for type decl DECL.  Called from toplev.c
<a name="26604"><span class="lineNum">   26604 </span>            :    and from language front ends (to record built-in types).  */</a>
<span class="lineNum">   26605 </span>            : static void
<span class="lineNum">   26606 </span><span class="lineCov">   11677438 : dwarf2out_type_decl (tree decl, int local)</span>
<span class="lineNum">   26607 </span>            : {
<span class="lineNum">   26608 </span><span class="lineCov">   11677438 :   if (!local)</span>
<span class="lineNum">   26609 </span>            :     {
<span class="lineNum">   26610 </span><span class="lineCov">   10893484 :       set_early_dwarf s;</span>
<span class="lineNum">   26611 </span><span class="lineCov">   10893484 :       dwarf2out_decl (decl);</span>
<span class="lineNum">   26612 </span>            :     }
<span class="lineNum">   26613 </span><span class="lineCov">   11677438 : }</span>
<span class="lineNum">   26614 </span>            : 
<span class="lineNum">   26615 </span>            : /* Output debug information for imported module or decl DECL.
<span class="lineNum">   26616 </span>            :    NAME is non-NULL name in the lexical block if the decl has been renamed.
<span class="lineNum">   26617 </span>            :    LEXICAL_BLOCK is the lexical block (which TREE_CODE is a BLOCK)
<span class="lineNum">   26618 </span>            :    that DECL belongs to.
<a name="26619"><span class="lineNum">   26619 </span>            :    LEXICAL_BLOCK_DIE is the DIE of LEXICAL_BLOCK.  */</a>
<span class="lineNum">   26620 </span>            : static void
<span class="lineNum">   26621 </span><span class="lineCov">     411453 : dwarf2out_imported_module_or_decl_1 (tree decl,</span>
<span class="lineNum">   26622 </span>            :                                      tree name,
<span class="lineNum">   26623 </span>            :                                      tree lexical_block,
<span class="lineNum">   26624 </span>            :                                      dw_die_ref lexical_block_die)
<span class="lineNum">   26625 </span>            : {
<span class="lineNum">   26626 </span><span class="lineCov">     411453 :   expanded_location xloc;</span>
<span class="lineNum">   26627 </span><span class="lineCov">     411453 :   dw_die_ref imported_die = NULL;</span>
<span class="lineNum">   26628 </span><span class="lineCov">     411453 :   dw_die_ref at_import_die;</span>
<span class="lineNum">   26629 </span>            : 
<span class="lineNum">   26630 </span><span class="lineCov">     411453 :   if (TREE_CODE (decl) == IMPORTED_DECL)</span>
<span class="lineNum">   26631 </span>            :     {
<span class="lineNum">   26632 </span><span class="lineCov">       3876 :       xloc = expand_location (DECL_SOURCE_LOCATION (decl));</span>
<span class="lineNum">   26633 </span><span class="lineCov">       3876 :       decl = IMPORTED_DECL_ASSOCIATED_DECL (decl);</span>
<span class="lineNum">   26634 </span><span class="lineCov">       3876 :       gcc_assert (decl);</span>
<span class="lineNum">   26635 </span>            :     }
<span class="lineNum">   26636 </span>            :   else
<span class="lineNum">   26637 </span><span class="lineCov">     407577 :     xloc = expand_location (input_location);</span>
<span class="lineNum">   26638 </span>            : 
<span class="lineNum">   26639 </span><span class="lineCov">     411453 :   if (TREE_CODE (decl) == TYPE_DECL || TREE_CODE (decl) == CONST_DECL)</span>
<span class="lineNum">   26640 </span>            :     {
<span class="lineNum">   26641 </span><span class="lineCov">      61447 :       at_import_die = force_type_die (TREE_TYPE (decl));</span>
<span class="lineNum">   26642 </span>            :       /* For namespace N { typedef void T; } using N::T; base_type_die
<span class="lineNum">   26643 </span>            :          returns NULL, but DW_TAG_imported_declaration requires
<span class="lineNum">   26644 </span>            :          the DW_AT_import tag.  Force creation of DW_TAG_typedef.  */
<span class="lineNum">   26645 </span><span class="lineCov">      61447 :       if (!at_import_die)</span>
<span class="lineNum">   26646 </span>            :         {
<span class="lineNum">   26647 </span><span class="lineNoCov">          0 :           gcc_assert (TREE_CODE (decl) == TYPE_DECL);</span>
<span class="lineNum">   26648 </span><span class="lineNoCov">          0 :           gen_typedef_die (decl, get_context_die (DECL_CONTEXT (decl)));</span>
<span class="lineNum">   26649 </span><span class="lineNoCov">          0 :           at_import_die = lookup_type_die (TREE_TYPE (decl));</span>
<span class="lineNum">   26650 </span><span class="lineNoCov">          0 :           gcc_assert (at_import_die);</span>
<span class="lineNum">   26651 </span>            :         }
<span class="lineNum">   26652 </span>            :     }
<span class="lineNum">   26653 </span>            :   else
<span class="lineNum">   26654 </span>            :     {
<span class="lineNum">   26655 </span><span class="lineCov">     350006 :       at_import_die = lookup_decl_die (decl);</span>
<span class="lineNum">   26656 </span><span class="lineCov">     350006 :       if (!at_import_die)</span>
<span class="lineNum">   26657 </span>            :         {
<span class="lineNum">   26658 </span>            :           /* If we're trying to avoid duplicate debug info, we may not have
<span class="lineNum">   26659 </span>            :              emitted the member decl for this field.  Emit it now.  */
<span class="lineNum">   26660 </span><span class="lineCov">     228230 :           if (TREE_CODE (decl) == FIELD_DECL)</span>
<span class="lineNum">   26661 </span>            :             {
<span class="lineNum">   26662 </span><span class="lineCov">          6 :               tree type = DECL_CONTEXT (decl);</span>
<span class="lineNum">   26663 </span>            : 
<span class="lineNum">   26664 </span><span class="lineCov">          6 :               if (TYPE_CONTEXT (type)</span>
<span class="lineNum">   26665 </span><span class="lineCov">         12 :                   &amp;&amp; TYPE_P (TYPE_CONTEXT (type))</span>
<span class="lineNum">   26666 </span><span class="lineCov">          6 :                   &amp;&amp; !should_emit_struct_debug (TYPE_CONTEXT (type),</span>
<span class="lineNum">   26667 </span>            :                                                 DINFO_USAGE_DIR_USE))
<span class="lineNum">   26668 </span>            :                 return;
<span class="lineNum">   26669 </span><span class="lineCov">          6 :               gen_type_die_for_member (type, decl,</span>
<span class="lineNum">   26670 </span><span class="lineCov">          6 :                                        get_context_die (TYPE_CONTEXT (type)));</span>
<span class="lineNum">   26671 </span>            :             }
<span class="lineNum">   26672 </span><span class="lineCov">     228230 :           if (TREE_CODE (decl) == NAMELIST_DECL)</span>
<span class="lineNum">   26673 </span><span class="lineCov">          2 :             at_import_die = gen_namelist_decl (DECL_NAME (decl),</span>
<span class="lineNum">   26674 </span><span class="lineCov">          2 :                                          get_context_die (DECL_CONTEXT (decl)),</span>
<span class="lineNum">   26675 </span>            :                                          NULL_TREE);
<span class="lineNum">   26676 </span>            :           else
<span class="lineNum">   26677 </span><span class="lineCov">     228228 :             at_import_die = force_decl_die (decl);</span>
<span class="lineNum">   26678 </span>            :         }
<span class="lineNum">   26679 </span>            :     }
<span class="lineNum">   26680 </span>            : 
<span class="lineNum">   26681 </span><span class="lineCov">     411453 :   if (TREE_CODE (decl) == NAMESPACE_DECL)</span>
<span class="lineNum">   26682 </span>            :     {
<span class="lineNum">   26683 </span><span class="lineCov">      19919 :       if (dwarf_version &gt;= 3 || !dwarf_strict)</span>
<span class="lineNum">   26684 </span><span class="lineCov">      19919 :         imported_die = new_die (DW_TAG_imported_module,</span>
<span class="lineNum">   26685 </span>            :                                 lexical_block_die,
<span class="lineNum">   26686 </span>            :                                 lexical_block);
<span class="lineNum">   26687 </span>            :       else
<span class="lineNum">   26688 </span>            :         return;
<span class="lineNum">   26689 </span>            :     }
<span class="lineNum">   26690 </span>            :   else
<span class="lineNum">   26691 </span><span class="lineCov">     391534 :     imported_die = new_die (DW_TAG_imported_declaration,</span>
<span class="lineNum">   26692 </span>            :                             lexical_block_die,
<span class="lineNum">   26693 </span>            :                             lexical_block);
<span class="lineNum">   26694 </span>            : 
<span class="lineNum">   26695 </span><span class="lineCov">     411453 :   add_AT_file (imported_die, DW_AT_decl_file, lookup_filename (xloc.file));</span>
<span class="lineNum">   26696 </span><span class="lineCov">     411453 :   add_AT_unsigned (imported_die, DW_AT_decl_line, xloc.line);</span>
<span class="lineNum">   26697 </span><span class="lineCov">     411453 :   if (debug_column_info &amp;&amp; xloc.column)</span>
<span class="lineNum">   26698 </span><span class="lineCov">     410442 :     add_AT_unsigned (imported_die, DW_AT_decl_column, xloc.column);</span>
<span class="lineNum">   26699 </span><span class="lineCov">     411453 :   if (name)</span>
<span class="lineNum">   26700 </span><span class="lineCov">         52 :     add_AT_string (imported_die, DW_AT_name,</span>
<span class="lineNum">   26701 </span><span class="lineCov">         26 :                    IDENTIFIER_POINTER (name));</span>
<span class="lineNum">   26702 </span><span class="lineCov">     411453 :   add_AT_die_ref (imported_die, DW_AT_import, at_import_die);</span>
<span class="lineNum">   26703 </span>            : }
<span class="lineNum">   26704 </span>            : 
<span class="lineNum">   26705 </span>            : /* Output debug information for imported module or decl DECL.
<span class="lineNum">   26706 </span>            :    NAME is non-NULL name in context if the decl has been renamed.
<span class="lineNum">   26707 </span>            :    CHILD is true if decl is one of the renamed decls as part of
<span class="lineNum">   26708 </span>            :    importing whole module.
<span class="lineNum">   26709 </span>            :    IMPLICIT is set if this hook is called for an implicit import
<span class="lineNum">   26710 </span>            :    such as inline namespace.  */
<a name="26711"><span class="lineNum">   26711 </span>            : </a>
<span class="lineNum">   26712 </span>            : static void
<span class="lineNum">   26713 </span><span class="lineCov">     407655 : dwarf2out_imported_module_or_decl (tree decl, tree name, tree context,</span>
<span class="lineNum">   26714 </span>            :                                    bool child, bool implicit)
<span class="lineNum">   26715 </span>            : {
<span class="lineNum">   26716 </span>            :   /* dw_die_ref at_import_die;  */
<span class="lineNum">   26717 </span><span class="lineCov">     407655 :   dw_die_ref scope_die;</span>
<span class="lineNum">   26718 </span>            : 
<span class="lineNum">   26719 </span><span class="lineCov">     407655 :   if (debug_info_level &lt;= DINFO_LEVEL_TERSE)</span>
<span class="lineNum">   26720 </span><span class="lineCov">         78 :     return;</span>
<span class="lineNum">   26721 </span>            : 
<span class="lineNum">   26722 </span><span class="lineCov">     407583 :   gcc_assert (decl);</span>
<span class="lineNum">   26723 </span>            : 
<span class="lineNum">   26724 </span>            :   /* For DWARF5, just DW_AT_export_symbols on the DW_TAG_namespace
<span class="lineNum">   26725 </span>            :      should be enough, for DWARF4 and older even if we emit as extension
<span class="lineNum">   26726 </span>            :      DW_AT_export_symbols add the implicit DW_TAG_imported_module anyway
<span class="lineNum">   26727 </span>            :      for the benefit of consumers unaware of DW_AT_export_symbols.  */
<span class="lineNum">   26728 </span><span class="lineCov">     407583 :   if (implicit</span>
<span class="lineNum">   26729 </span><span class="lineCov">       9832 :       &amp;&amp; dwarf_version &gt;= 5</span>
<span class="lineNum">   26730 </span><span class="lineCov">     407589 :       &amp;&amp; lang_hooks.decls.decl_dwarf_attribute (decl,</span>
<span class="lineNum">   26731 </span>            :                                                 DW_AT_export_symbols) == 1)
<span class="lineNum">   26732 </span>            :     return;
<span class="lineNum">   26733 </span>            : 
<span class="lineNum">   26734 </span><span class="lineCov">     407577 :   set_early_dwarf s;</span>
<span class="lineNum">   26735 </span>            : 
<span class="lineNum">   26736 </span>            :   /* To emit DW_TAG_imported_module or DW_TAG_imported_decl, we need two DIEs.
<span class="lineNum">   26737 </span>            :      We need decl DIE for reference and scope die. First, get DIE for the decl
<span class="lineNum">   26738 </span>            :      itself.  */
<span class="lineNum">   26739 </span>            : 
<span class="lineNum">   26740 </span>            :   /* Get the scope die for decl context. Use comp_unit_die for global module
<span class="lineNum">   26741 </span>            :      or decl. If die is not found for non globals, force new die.  */
<span class="lineNum">   26742 </span><span class="lineCov">     407577 :   if (context</span>
<span class="lineNum">   26743 </span><span class="lineCov">     373005 :       &amp;&amp; TYPE_P (context)</span>
<span class="lineNum">   26744 </span><span class="lineCov">     482095 :       &amp;&amp; !should_emit_struct_debug (context, DINFO_USAGE_DIR_USE))</span>
<span class="lineNum">   26745 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">   26746 </span>            : 
<span class="lineNum">   26747 </span><span class="lineCov">     407577 :   scope_die = get_context_die (context);</span>
<span class="lineNum">   26748 </span>            : 
<span class="lineNum">   26749 </span><span class="lineCov">     407577 :   if (child)</span>
<span class="lineNum">   26750 </span>            :     {
<span class="lineNum">   26751 </span>            :       /* DW_TAG_imported_module was introduced in the DWARFv3 specification, so
<span class="lineNum">   26752 </span>            :          there is nothing we can do, here.  */
<span class="lineNum">   26753 </span><span class="lineCov">         16 :       if (dwarf_version &lt; 3 &amp;&amp; dwarf_strict)</span>
<span class="lineNum">   26754 </span>            :         return;
<span class="lineNum">   26755 </span>            : 
<span class="lineNum">   26756 </span><span class="lineCov">         16 :       gcc_assert (scope_die-&gt;die_child);</span>
<span class="lineNum">   26757 </span><span class="lineCov">         16 :       gcc_assert (scope_die-&gt;die_child-&gt;die_tag == DW_TAG_imported_module);</span>
<span class="lineNum">   26758 </span><span class="lineCov">         16 :       gcc_assert (TREE_CODE (decl) != NAMESPACE_DECL);</span>
<span class="lineNum">   26759 </span>            :       scope_die = scope_die-&gt;die_child;
<span class="lineNum">   26760 </span>            :     }
<span class="lineNum">   26761 </span>            : 
<span class="lineNum">   26762 </span>            :   /* OK, now we have DIEs for decl as well as scope. Emit imported die.  */
<span class="lineNum">   26763 </span><span class="lineCov">     407577 :   dwarf2out_imported_module_or_decl_1 (decl, name, context, scope_die);</span>
<span class="lineNum">   26764 </span>            : }
<span class="lineNum">   26765 </span>            : 
<span class="lineNum">   26766 </span>            : /* Output debug information for namelists.   */
<a name="26767"><span class="lineNum">   26767 </span>            : </a>
<span class="lineNum">   26768 </span>            : static dw_die_ref
<span class="lineNum">   26769 </span><span class="lineCov">        213 : gen_namelist_decl (tree name, dw_die_ref scope_die, tree item_decls)</span>
<span class="lineNum">   26770 </span>            : {
<span class="lineNum">   26771 </span><span class="lineCov">        213 :   dw_die_ref nml_die, nml_item_die, nml_item_ref_die;</span>
<span class="lineNum">   26772 </span><span class="lineCov">        213 :   tree value;</span>
<span class="lineNum">   26773 </span><span class="lineCov">        213 :   unsigned i;</span>
<span class="lineNum">   26774 </span>            : 
<span class="lineNum">   26775 </span><span class="lineCov">        213 :   if (debug_info_level &lt;= DINFO_LEVEL_TERSE)</span>
<span class="lineNum">   26776 </span>            :     return NULL;
<span class="lineNum">   26777 </span>            : 
<span class="lineNum">   26778 </span><span class="lineCov">        213 :   gcc_assert (scope_die != NULL);</span>
<span class="lineNum">   26779 </span><span class="lineCov">        213 :   nml_die = new_die (DW_TAG_namelist, scope_die, NULL);</span>
<span class="lineNum">   26780 </span><span class="lineCov">        213 :   add_AT_string (nml_die, DW_AT_name, IDENTIFIER_POINTER (name));</span>
<span class="lineNum">   26781 </span>            : 
<span class="lineNum">   26782 </span>            :   /* If there are no item_decls, we have a nondefining namelist, e.g.
<span class="lineNum">   26783 </span>            :      with USE association; hence, set DW_AT_declaration.  */
<span class="lineNum">   26784 </span><span class="lineCov">        213 :   if (item_decls == NULL_TREE)</span>
<span class="lineNum">   26785 </span>            :     {
<span class="lineNum">   26786 </span><span class="lineCov">          2 :       add_AT_flag (nml_die, DW_AT_declaration, 1);</span>
<span class="lineNum">   26787 </span><span class="lineCov">          2 :       return nml_die;</span>
<span class="lineNum">   26788 </span>            :     }
<span class="lineNum">   26789 </span>            : 
<span class="lineNum">   26790 </span><span class="lineCov">       1516 :   FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (item_decls), i, value)</span>
<span class="lineNum">   26791 </span>            :     {
<span class="lineNum">   26792 </span><span class="lineCov">        547 :       nml_item_ref_die = lookup_decl_die (value);</span>
<span class="lineNum">   26793 </span><span class="lineCov">        547 :       if (!nml_item_ref_die)</span>
<span class="lineNum">   26794 </span><span class="lineCov">        210 :         nml_item_ref_die = force_decl_die (value);</span>
<span class="lineNum">   26795 </span>            : 
<span class="lineNum">   26796 </span><span class="lineCov">        547 :       nml_item_die = new_die (DW_TAG_namelist_item, nml_die, NULL);</span>
<span class="lineNum">   26797 </span><span class="lineCov">        547 :       add_AT_die_ref (nml_item_die, DW_AT_namelist_items, nml_item_ref_die);</span>
<span class="lineNum">   26798 </span>            :     }
<span class="lineNum">   26799 </span>            :   return nml_die;
<span class="lineNum">   26800 </span>            : }
<span class="lineNum">   26801 </span>            : 
<span class="lineNum">   26802 </span>            : 
<span class="lineNum">   26803 </span>            : /* Write the debugging output for DECL and return the DIE.  */
<a name="26804"><span class="lineNum">   26804 </span>            : </a>
<span class="lineNum">   26805 </span>            : static void
<span class="lineNum">   26806 </span><span class="lineCov">   14202035 : dwarf2out_decl (tree decl)</span>
<span class="lineNum">   26807 </span>            : {
<span class="lineNum">   26808 </span><span class="lineCov">   14202035 :   dw_die_ref context_die = comp_unit_die ();</span>
<span class="lineNum">   26809 </span>            : 
<span class="lineNum">   26810 </span><span class="lineCov">   14202035 :   switch (TREE_CODE (decl))</span>
<span class="lineNum">   26811 </span>            :     {
<span class="lineNum">   26812 </span>            :     case ERROR_MARK:
<span class="lineNum">   26813 </span>            :       return;
<span class="lineNum">   26814 </span>            : 
<span class="lineNum">   26815 </span><span class="lineCov">    1608808 :     case FUNCTION_DECL:</span>
<span class="lineNum">   26816 </span>            :       /* If we're a nested function, initially use a parent of NULL; if we're
<span class="lineNum">   26817 </span>            :          a plain function, this will be fixed up in decls_for_scope.  If
<span class="lineNum">   26818 </span>            :          we're a method, it will be ignored, since we already have a DIE.
<span class="lineNum">   26819 </span>            :          Avoid doing this late though since clones of class methods may
<span class="lineNum">   26820 </span>            :          otherwise end up in limbo and create type DIEs late.  */
<span class="lineNum">   26821 </span><span class="lineCov">    1608808 :       if (early_dwarf</span>
<span class="lineNum">   26822 </span><span class="lineCov">    1268915 :           &amp;&amp; decl_function_context (decl)</span>
<span class="lineNum">   26823 </span>            :           /* But if we're in terse mode, we don't care about scope.  */
<span class="lineNum">   26824 </span><span class="lineCov">    1614765 :           &amp;&amp; debug_info_level &gt; DINFO_LEVEL_TERSE)</span>
<span class="lineNum">   26825 </span>            :         context_die = NULL;
<span class="lineNum">   26826 </span>            :       break;
<span class="lineNum">   26827 </span>            : 
<span class="lineNum">   26828 </span><span class="lineCov">    1658608 :     case VAR_DECL:</span>
<span class="lineNum">   26829 </span>            :       /* For local statics lookup proper context die.  */
<span class="lineNum">   26830 </span><span class="lineCov">    1658608 :       if (local_function_static (decl))</span>
<span class="lineNum">   26831 </span><span class="lineCov">         41 :         context_die = lookup_decl_die (DECL_CONTEXT (decl));</span>
<span class="lineNum">   26832 </span>            : 
<span class="lineNum">   26833 </span>            :       /* If we are in terse mode, don't generate any DIEs to represent any
<span class="lineNum">   26834 </span>            :          variable declarations or definitions.  */
<span class="lineNum">   26835 </span><span class="lineCov">    1658608 :       if (debug_info_level &lt;= DINFO_LEVEL_TERSE)</span>
<span class="lineNum">   26836 </span>            :         return;
<span class="lineNum">   26837 </span>            :       break;
<span class="lineNum">   26838 </span>            : 
<span class="lineNum">   26839 </span><span class="lineCov">       1536 :     case CONST_DECL:</span>
<span class="lineNum">   26840 </span><span class="lineCov">       1536 :       if (debug_info_level &lt;= DINFO_LEVEL_TERSE)</span>
<span class="lineNum">   26841 </span>            :         return;
<span class="lineNum">   26842 </span><span class="lineCov">       1536 :       if (!is_fortran () &amp;&amp; !is_ada ())</span>
<span class="lineNum">   26843 </span>            :         return;
<span class="lineNum">   26844 </span><span class="lineCov">       1536 :       if (TREE_STATIC (decl) &amp;&amp; decl_function_context (decl))</span>
<span class="lineNum">   26845 </span><span class="lineCov">       1410 :         context_die = lookup_decl_die (DECL_CONTEXT (decl));</span>
<span class="lineNum">   26846 </span>            :       break;
<span class="lineNum">   26847 </span>            : 
<span class="lineNum">   26848 </span><span class="lineCov">      39587 :     case NAMESPACE_DECL:</span>
<span class="lineNum">   26849 </span><span class="lineCov">      39587 :     case IMPORTED_DECL:</span>
<span class="lineNum">   26850 </span><span class="lineCov">      39587 :       if (debug_info_level &lt;= DINFO_LEVEL_TERSE)</span>
<span class="lineNum">   26851 </span>            :         return;
<span class="lineNum">   26852 </span><span class="lineCov">      39584 :       if (lookup_decl_die (decl) != NULL)</span>
<span class="lineNum">   26853 </span>            :         return;
<span class="lineNum">   26854 </span>            :       break;
<span class="lineNum">   26855 </span>            : 
<span class="lineNum">   26856 </span><span class="lineCov">   10893484 :     case TYPE_DECL:</span>
<span class="lineNum">   26857 </span>            :       /* Don't emit stubs for types unless they are needed by other DIEs.  */
<span class="lineNum">   26858 </span><span class="lineCov">   10893484 :       if (TYPE_DECL_SUPPRESS_DEBUG (decl))</span>
<span class="lineNum">   26859 </span>            :         return;
<span class="lineNum">   26860 </span>            : 
<span class="lineNum">   26861 </span>            :       /* Don't bother trying to generate any DIEs to represent any of the
<span class="lineNum">   26862 </span>            :          normal built-in types for the language we are compiling.  */
<span class="lineNum">   26863 </span><span class="lineCov">   10801007 :       if (DECL_IS_BUILTIN (decl))</span>
<span class="lineNum">   26864 </span>            :         return;
<span class="lineNum">   26865 </span>            : 
<span class="lineNum">   26866 </span>            :       /* If we are in terse mode, don't generate any DIEs for types.  */
<span class="lineNum">   26867 </span><span class="lineCov">    9889833 :       if (debug_info_level &lt;= DINFO_LEVEL_TERSE)</span>
<span class="lineNum">   26868 </span>            :         return;
<span class="lineNum">   26869 </span>            : 
<span class="lineNum">   26870 </span>            :       /* If we're a function-scope tag, initially use a parent of NULL;
<span class="lineNum">   26871 </span>            :          this will be fixed up in decls_for_scope.  */
<span class="lineNum">   26872 </span><span class="lineCov">    9889464 :       if (decl_function_context (decl))</span>
<span class="lineNum">   26873 </span><span class="lineCov">         69 :         context_die = NULL;</span>
<span class="lineNum">   26874 </span>            : 
<span class="lineNum">   26875 </span>            :       break;
<span class="lineNum">   26876 </span>            : 
<span class="lineNum">   26877 </span>            :     case NAMELIST_DECL:
<span class="lineNum">   26878 </span>            :       break;
<span class="lineNum">   26879 </span>            : 
<span class="lineNum">   26880 </span>            :     default:
<span class="lineNum">   26881 </span>            :       return;
<span class="lineNum">   26882 </span>            :     }
<span class="lineNum">   26883 </span>            : 
<span class="lineNum">   26884 </span><span class="lineCov">   13197024 :   gen_decl_die (decl, NULL, NULL, context_die);</span>
<span class="lineNum">   26885 </span>            : 
<span class="lineNum">   26886 </span><span class="lineCov">   13197024 :   if (flag_checking)</span>
<span class="lineNum">   26887 </span>            :     {
<span class="lineNum">   26888 </span><span class="lineCov">   13197016 :       dw_die_ref die = lookup_decl_die (decl);</span>
<span class="lineNum">   26889 </span><span class="lineCov">   13197016 :       if (die)</span>
<span class="lineNum">   26890 </span><span class="lineCov">    2812382 :         check_die (die);</span>
<span class="lineNum">   26891 </span>            :     }
<span class="lineNum">   26892 </span>            : }
<span class="lineNum">   26893 </span>            : 
<span class="lineNum">   26894 </span>            : /* Write the debugging output for DECL.  */
<a name="26895"><span class="lineNum">   26895 </span>            : </a>
<span class="lineNum">   26896 </span>            : static void
<span class="lineNum">   26897 </span><span class="lineCov">     339893 : dwarf2out_function_decl (tree decl)</span>
<span class="lineNum">   26898 </span>            : {
<span class="lineNum">   26899 </span><span class="lineCov">     339893 :   dwarf2out_decl (decl);</span>
<span class="lineNum">   26900 </span><span class="lineCov">     339893 :   call_arg_locations = NULL;</span>
<span class="lineNum">   26901 </span><span class="lineCov">     339893 :   call_arg_loc_last = NULL;</span>
<span class="lineNum">   26902 </span><span class="lineCov">     339893 :   call_site_count = -1;</span>
<span class="lineNum">   26903 </span><span class="lineCov">     339893 :   tail_call_site_count = -1;</span>
<span class="lineNum">   26904 </span><span class="lineCov">     339893 :   decl_loc_table-&gt;empty ();</span>
<span class="lineNum">   26905 </span><span class="lineCov">     339893 :   cached_dw_loc_list_table-&gt;empty ();</span>
<span class="lineNum">   26906 </span><span class="lineCov">     339893 : }</span>
<span class="lineNum">   26907 </span>            : 
<span class="lineNum">   26908 </span>            : /* Output a marker (i.e. a label) for the beginning of the generated code for
<span class="lineNum">   26909 </span>            :    a lexical block.  */
<a name="26910"><span class="lineNum">   26910 </span>            : </a>
<span class="lineNum">   26911 </span>            : static void
<span class="lineNum">   26912 </span><span class="lineCov">   11272794 : dwarf2out_begin_block (unsigned int line ATTRIBUTE_UNUSED,</span>
<span class="lineNum">   26913 </span>            :                        unsigned int blocknum)
<span class="lineNum">   26914 </span>            : {
<span class="lineNum">   26915 </span><span class="lineCov">   11272794 :   switch_to_section (current_function_section ());</span>
<span class="lineNum">   26916 </span><span class="lineCov">   11272794 :   ASM_OUTPUT_DEBUG_LABEL (asm_out_file, BLOCK_BEGIN_LABEL, blocknum);</span>
<span class="lineNum">   26917 </span><span class="lineCov">   11272794 : }</span>
<span class="lineNum">   26918 </span>            : 
<span class="lineNum">   26919 </span>            : /* Output a marker (i.e. a label) for the end of the generated code for a
<span class="lineNum">   26920 </span>            :    lexical block.  */
<a name="26921"><span class="lineNum">   26921 </span>            : </a>
<span class="lineNum">   26922 </span>            : static void
<span class="lineNum">   26923 </span><span class="lineCov">   11272794 : dwarf2out_end_block (unsigned int line ATTRIBUTE_UNUSED, unsigned int blocknum)</span>
<span class="lineNum">   26924 </span>            : {
<span class="lineNum">   26925 </span><span class="lineCov">   11272794 :   switch_to_section (current_function_section ());</span>
<span class="lineNum">   26926 </span><span class="lineCov">   11272794 :   ASM_OUTPUT_DEBUG_LABEL (asm_out_file, BLOCK_END_LABEL, blocknum);</span>
<span class="lineNum">   26927 </span><span class="lineCov">   11272794 : }</span>
<span class="lineNum">   26928 </span>            : 
<span class="lineNum">   26929 </span>            : /* Returns nonzero if it is appropriate not to emit any debugging
<span class="lineNum">   26930 </span>            :    information for BLOCK, because it doesn't contain any instructions.
<span class="lineNum">   26931 </span>            : 
<span class="lineNum">   26932 </span>            :    Don't allow this for blocks with nested functions or local classes
<span class="lineNum">   26933 </span>            :    as we would end up with orphans, and in the presence of scheduling
<span class="lineNum">   26934 </span>            :    we may end up calling them anyway.  */
<a name="26935"><span class="lineNum">   26935 </span>            : </a>
<span class="lineNum">   26936 </span>            : static bool
<span class="lineNum">   26937 </span><span class="lineCov">   33312729 : dwarf2out_ignore_block (const_tree block)</span>
<span class="lineNum">   26938 </span>            : {
<span class="lineNum">   26939 </span><span class="lineCov">   33312729 :   tree decl;</span>
<span class="lineNum">   26940 </span><span class="lineCov">   33312729 :   unsigned int i;</span>
<span class="lineNum">   26941 </span>            : 
<span class="lineNum">   26942 </span><span class="lineCov">   65710393 :   for (decl = BLOCK_VARS (block); decl; decl = DECL_CHAIN (decl))</span>
<span class="lineNum">   26943 </span><span class="lineCov">   32438216 :     if (TREE_CODE (decl) == FUNCTION_DECL</span>
<span class="lineNum">   26944 </span><span class="lineCov">   32438216 :         || (TREE_CODE (decl) == TYPE_DECL &amp;&amp; TYPE_DECL_IS_STUB (decl)))</span>
<span class="lineNum">   26945 </span>            :       return 0;
<span class="lineNum">   26946 </span><span class="lineCov">   66819705 :   for (i = 0; i &lt; BLOCK_NUM_NONLOCALIZED_VARS (block); i++)</span>
<span class="lineNum">   26947 </span>            :     {
<span class="lineNum">   26948 </span><span class="lineCov">     192226 :       decl = BLOCK_NONLOCALIZED_VAR (block, i);</span>
<span class="lineNum">   26949 </span><span class="lineCov">      96113 :       if (TREE_CODE (decl) == FUNCTION_DECL</span>
<span class="lineNum">   26950 </span><span class="lineCov">      96113 :           || (TREE_CODE (decl) == TYPE_DECL &amp;&amp; TYPE_DECL_IS_STUB (decl)))</span>
<span class="lineNum">   26951 </span>            :       return 0;
<span class="lineNum">   26952 </span>            :     }
<span class="lineNum">   26953 </span>            : 
<span class="lineNum">   26954 </span>            :   return 1;
<span class="lineNum">   26955 </span>            : }
<span class="lineNum">   26956 </span>            : 
<span class="lineNum">   26957 </span>            : /* Hash table routines for file_hash.  */
<a name="26958"><span class="lineNum">   26958 </span>            : </a>
<span class="lineNum">   26959 </span>            : bool
<span class="lineNum">   26960 </span><span class="lineCov">   71514412 : dwarf_file_hasher::equal (dwarf_file_data *p1, const char *p2)</span>
<span class="lineNum">   26961 </span>            : {
<span class="lineNum">   26962 </span><span class="lineCov">   71514412 :   return filename_cmp (p1-&gt;filename, p2) == 0;</span>
<span class="lineNum">   26963 </span>            : }
<a name="26964"><span class="lineNum">   26964 </span>            : </a>
<span class="lineNum">   26965 </span>            : hashval_t
<span class="lineNum">   26966 </span><span class="lineCov">     193143 : dwarf_file_hasher::hash (dwarf_file_data *p)</span>
<span class="lineNum">   26967 </span>            : {
<span class="lineNum">   26968 </span><span class="lineCov">     193143 :   return htab_hash_string (p-&gt;filename);</span>
<span class="lineNum">   26969 </span>            : }
<span class="lineNum">   26970 </span>            : 
<span class="lineNum">   26971 </span>            : /* Lookup FILE_NAME (in the list of filenames that we know about here in
<span class="lineNum">   26972 </span>            :    dwarf2out.c) and return its &quot;index&quot;.  The index of each (known) filename is
<span class="lineNum">   26973 </span>            :    just a unique number which is associated with only that one filename.  We
<span class="lineNum">   26974 </span>            :    need such numbers for the sake of generating labels (in the .debug_sfnames
<span class="lineNum">   26975 </span>            :    section) and references to those files numbers (in the .debug_srcinfo
<span class="lineNum">   26976 </span>            :    and .debug_macinfo sections).  If the filename given as an argument is not
<span class="lineNum">   26977 </span>            :    found in our current list, add it to the list and assign it the next
<span class="lineNum">   26978 </span>            :    available unique index number.  */
<a name="26979"><span class="lineNum">   26979 </span>            : </a>
<span class="lineNum">   26980 </span>            : static struct dwarf_file_data *
<span class="lineNum">   26981 </span><span class="lineCov">   51690000 : lookup_filename (const char *file_name)</span>
<span class="lineNum">   26982 </span>            : {
<span class="lineNum">   26983 </span><span class="lineCov">   51690000 :   struct dwarf_file_data * created;</span>
<span class="lineNum">   26984 </span>            : 
<span class="lineNum">   26985 </span><span class="lineCov">   51690000 :   if (!file_name)</span>
<span class="lineNum">   26986 </span>            :     return NULL;
<span class="lineNum">   26987 </span>            : 
<span class="lineNum">   26988 </span><span class="lineCov">   51688172 :   dwarf_file_data **slot</span>
<span class="lineNum">   26989 </span><span class="lineCov">   51688172 :     = file_table-&gt;find_slot_with_hash (file_name, htab_hash_string (file_name),</span>
<span class="lineNum">   26990 </span>            :                                        INSERT);
<span class="lineNum">   26991 </span><span class="lineCov">   51688172 :   if (*slot)</span>
<span class="lineNum">   26992 </span>            :     return *slot;
<span class="lineNum">   26993 </span>            : 
<span class="lineNum">   26994 </span><span class="lineCov">     460147 :   created = ggc_alloc&lt;dwarf_file_data&gt; ();</span>
<span class="lineNum">   26995 </span><span class="lineCov">     460147 :   created-&gt;filename = file_name;</span>
<span class="lineNum">   26996 </span><span class="lineCov">     460147 :   created-&gt;emitted_number = 0;</span>
<span class="lineNum">   26997 </span><span class="lineCov">     460147 :   *slot = created;</span>
<span class="lineNum">   26998 </span><span class="lineCov">     460147 :   return created;</span>
<span class="lineNum">   26999 </span>            : }
<span class="lineNum">   27000 </span>            : 
<span class="lineNum">   27001 </span>            : /* If the assembler will construct the file table, then translate the compiler
<span class="lineNum">   27002 </span>            :    internal file table number into the assembler file table number, and emit
<span class="lineNum">   27003 </span>            :    a .file directive if we haven't already emitted one yet.  The file table
<span class="lineNum">   27004 </span>            :    numbers are different because we prune debug info for unused variables and
<span class="lineNum">   27005 </span>            :    types, which may include filenames.  */
<a name="27006"><span class="lineNum">   27006 </span>            : </a>
<span class="lineNum">   27007 </span>            : static int
<span class="lineNum">   27008 </span><span class="lineCov">  125814118 : maybe_emit_file (struct dwarf_file_data * fd)</span>
<span class="lineNum">   27009 </span>            : {
<span class="lineNum">   27010 </span><span class="lineCov">  125814118 :   if (! fd-&gt;emitted_number)</span>
<span class="lineNum">   27011 </span>            :     {
<span class="lineNum">   27012 </span><span class="lineCov">     792351 :       if (last_emitted_file)</span>
<span class="lineNum">   27013 </span><span class="lineCov">     759136 :         fd-&gt;emitted_number = last_emitted_file-&gt;emitted_number + 1;</span>
<span class="lineNum">   27014 </span>            :       else
<span class="lineNum">   27015 </span><span class="lineCov">      33215 :         fd-&gt;emitted_number = 1;</span>
<span class="lineNum">   27016 </span><span class="lineCov">     792351 :       last_emitted_file = fd;</span>
<span class="lineNum">   27017 </span>            : 
<span class="lineNum">   27018 </span><span class="lineCov">     792351 :       if (output_asm_line_debug_info ())</span>
<span class="lineNum">   27019 </span>            :         {
<span class="lineNum">   27020 </span><span class="lineCov">     792351 :           fprintf (asm_out_file, &quot;\t.file %u &quot;, fd-&gt;emitted_number);</span>
<span class="lineNum">   27021 </span><span class="lineCov">     792351 :           output_quoted_string (asm_out_file,</span>
<span class="lineNum">   27022 </span>            :                                 remap_debug_filename (fd-&gt;filename));
<span class="lineNum">   27023 </span><span class="lineCov">     792351 :           fputc ('\n', asm_out_file);</span>
<span class="lineNum">   27024 </span>            :         }
<span class="lineNum">   27025 </span>            :     }
<span class="lineNum">   27026 </span>            : 
<span class="lineNum">   27027 </span><span class="lineCov">  125814118 :   return fd-&gt;emitted_number;</span>
<span class="lineNum">   27028 </span>            : }
<span class="lineNum">   27029 </span>            : 
<span class="lineNum">   27030 </span>            : /* Schedule generation of a DW_AT_const_value attribute to DIE.
<span class="lineNum">   27031 </span>            :    That generation should happen after function debug info has been
<span class="lineNum">   27032 </span>            :    generated. The value of the attribute is the constant value of ARG.  */
<a name="27033"><span class="lineNum">   27033 </span>            : </a>
<span class="lineNum">   27034 </span>            : static void
<span class="lineNum">   27035 </span><span class="lineCov">    1744056 : append_entry_to_tmpl_value_parm_die_table (dw_die_ref die, tree arg)</span>
<span class="lineNum">   27036 </span>            : {
<span class="lineNum">   27037 </span><span class="lineCov">    1744056 :   die_arg_entry entry;</span>
<span class="lineNum">   27038 </span>            : 
<span class="lineNum">   27039 </span><span class="lineCov">    1744056 :   if (!die || !arg)</span>
<span class="lineNum">   27040 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">   27041 </span>            : 
<span class="lineNum">   27042 </span><span class="lineCov">    1744056 :   gcc_assert (early_dwarf);</span>
<span class="lineNum">   27043 </span>            : 
<span class="lineNum">   27044 </span><span class="lineCov">    1744056 :   if (!tmpl_value_parm_die_table)</span>
<span class="lineNum">   27045 </span><span class="lineCov">       7834 :     vec_alloc (tmpl_value_parm_die_table, 32);</span>
<span class="lineNum">   27046 </span>            : 
<span class="lineNum">   27047 </span><span class="lineCov">    1744056 :   entry.die = die;</span>
<span class="lineNum">   27048 </span><span class="lineCov">    1744056 :   entry.arg = arg;</span>
<span class="lineNum">   27049 </span><span class="lineCov">    1744056 :   vec_safe_push (tmpl_value_parm_die_table, entry);</span>
<span class="lineNum">   27050 </span>            : }
<span class="lineNum">   27051 </span>            : 
<span class="lineNum">   27052 </span>            : /* Return TRUE if T is an instance of generic type, FALSE
<span class="lineNum">   27053 </span>            :    otherwise.  */
<a name="27054"><span class="lineNum">   27054 </span>            : </a>
<span class="lineNum">   27055 </span>            : static bool
<span class="lineNum">   27056 </span><span class="lineNoCov">          0 : generic_type_p (tree t)</span>
<span class="lineNum">   27057 </span>            : {
<span class="lineNum">   27058 </span><span class="lineCov">    8397671 :   if (t == NULL_TREE || !TYPE_P (t))</span>
<span class="lineNum">   27059 </span>            :     return false;
<span class="lineNum">   27060 </span><span class="lineCov">    8397671 :   return lang_hooks.get_innermost_generic_parms (t) != NULL_TREE;</span>
<span class="lineNum">   27061 </span>            : }
<span class="lineNum">   27062 </span>            : 
<span class="lineNum">   27063 </span>            : /* Schedule the generation of the generic parameter dies for the
<span class="lineNum">   27064 </span>            :   instance of generic type T. The proper generation itself is later
<span class="lineNum">   27065 </span>            :   done by gen_scheduled_generic_parms_dies. */
<a name="27066"><span class="lineNum">   27066 </span>            : </a>
<span class="lineNum">   27067 </span>            : static void
<span class="lineNum">   27068 </span><span class="lineCov">    8397671 : schedule_generic_params_dies_gen (tree t)</span>
<span class="lineNum">   27069 </span>            : {
<span class="lineNum">   27070 </span><span class="lineCov">   16795342 :   if (!generic_type_p (t))</span>
<span class="lineNum">   27071 </span><span class="lineCov">     786041 :     return;</span>
<span class="lineNum">   27072 </span>            : 
<span class="lineNum">   27073 </span><span class="lineCov">    7611630 :   gcc_assert (early_dwarf);</span>
<span class="lineNum">   27074 </span>            : 
<span class="lineNum">   27075 </span><span class="lineCov">    7611630 :   if (!generic_type_instances)</span>
<span class="lineNum">   27076 </span><span class="lineCov">       2600 :     vec_alloc (generic_type_instances, 256);</span>
<span class="lineNum">   27077 </span>            : 
<span class="lineNum">   27078 </span><span class="lineCov">    7611630 :   vec_safe_push (generic_type_instances, t);</span>
<span class="lineNum">   27079 </span>            : }
<span class="lineNum">   27080 </span>            : 
<span class="lineNum">   27081 </span>            : /* Add a DW_AT_const_value attribute to DIEs that were scheduled
<span class="lineNum">   27082 </span>            :    by append_entry_to_tmpl_value_parm_die_table. This function must
<span class="lineNum">   27083 </span>            :    be called after function DIEs have been generated.  */
<a name="27084"><span class="lineNum">   27084 </span>            : </a>
<span class="lineNum">   27085 </span>            : static void
<span class="lineNum">   27086 </span><span class="lineCov">      67291 : gen_remaining_tmpl_value_param_die_attribute (void)</span>
<span class="lineNum">   27087 </span>            : {
<span class="lineNum">   27088 </span><span class="lineCov">      67291 :   if (tmpl_value_parm_die_table)</span>
<span class="lineNum">   27089 </span>            :     {
<span class="lineNum">   27090 </span>            :       unsigned i, j;
<span class="lineNum">   27091 </span>            :       die_arg_entry *e;
<span class="lineNum">   27092 </span>            : 
<span class="lineNum">   27093 </span>            :       /* We do this in two phases - first get the cases we can
<span class="lineNum">   27094 </span>            :          handle during early-finish, preserving those we cannot
<span class="lineNum">   27095 </span>            :          (containing symbolic constants where we don't yet know
<span class="lineNum">   27096 </span>            :          whether we are going to output the referenced symbols).
<span class="lineNum">   27097 </span>            :          For those we try again at late-finish.  */
<span class="lineNum">   27098 </span>            :       j = 0;
<span class="lineNum">   27099 </span><span class="lineCov">    1759796 :       FOR_EACH_VEC_ELT (*tmpl_value_parm_die_table, i, e)</span>
<span class="lineNum">   27100 </span>            :         {
<span class="lineNum">   27101 </span><span class="lineCov">    1744150 :           if (!e-&gt;die-&gt;removed</span>
<span class="lineNum">   27102 </span><span class="lineCov">    1744150 :               &amp;&amp; !tree_add_const_value_attribute (e-&gt;die, e-&gt;arg))</span>
<span class="lineNum">   27103 </span>            :             {
<span class="lineNum">   27104 </span><span class="lineCov">        165 :               dw_loc_descr_ref loc = NULL;</span>
<span class="lineNum">   27105 </span><span class="lineCov">        165 :               if (! early_dwarf</span>
<span class="lineNum">   27106 </span><span class="lineCov">         71 :                   &amp;&amp; (dwarf_version &gt;= 5 || !dwarf_strict))</span>
<span class="lineNum">   27107 </span><span class="lineCov">         68 :                 loc = loc_descriptor_from_tree (e-&gt;arg, 2, NULL);</span>
<span class="lineNum">   27108 </span><span class="lineCov">         68 :               if (loc)</span>
<span class="lineNum">   27109 </span><span class="lineCov">         64 :                 add_AT_loc (e-&gt;die, DW_AT_location, loc);</span>
<span class="lineNum">   27110 </span>            :               else
<span class="lineNum">   27111 </span><span class="lineCov">        101 :                 (*tmpl_value_parm_die_table)[j++] = *e;</span>
<span class="lineNum">   27112 </span>            :             }
<span class="lineNum">   27113 </span>            :         }
<span class="lineNum">   27114 </span><span class="lineCov">      15646 :       tmpl_value_parm_die_table-&gt;truncate (j);</span>
<span class="lineNum">   27115 </span>            :     }
<span class="lineNum">   27116 </span><span class="lineCov">      67291 : }</span>
<span class="lineNum">   27117 </span>            : 
<span class="lineNum">   27118 </span>            : /* Generate generic parameters DIEs for instances of generic types
<span class="lineNum">   27119 </span>            :    that have been previously scheduled by
<span class="lineNum">   27120 </span>            :    schedule_generic_params_dies_gen. This function must be called
<span class="lineNum">   27121 </span>            :    after all the types of the CU have been laid out.  */
<a name="27122"><span class="lineNum">   27122 </span>            : </a>
<span class="lineNum">   27123 </span>            : static void
<span class="lineNum">   27124 </span><span class="lineCov">      33604 : gen_scheduled_generic_parms_dies (void)</span>
<span class="lineNum">   27125 </span>            : {
<span class="lineNum">   27126 </span><span class="lineCov">      33604 :   unsigned i;</span>
<span class="lineNum">   27127 </span><span class="lineCov">      33604 :   tree t;</span>
<span class="lineNum">   27128 </span>            : 
<span class="lineNum">   27129 </span><span class="lineCov">      33604 :   if (!generic_type_instances)</span>
<span class="lineNum">   27130 </span>            :     return;
<span class="lineNum">   27131 </span>            :   
<span class="lineNum">   27132 </span><span class="lineCov">   22867310 :   FOR_EACH_VEC_ELT (*generic_type_instances, i, t)</span>
<span class="lineNum">   27133 </span><span class="lineCov">   22858981 :     if (COMPLETE_TYPE_P (t))</span>
<span class="lineNum">   27134 </span><span class="lineCov">   22140167 :       gen_generic_params_dies (t);</span>
<span class="lineNum">   27135 </span>            : 
<span class="lineNum">   27136 </span><span class="lineCov">       8329 :   generic_type_instances = NULL;</span>
<span class="lineNum">   27137 </span>            : }
<span class="lineNum">   27138 </span>            : 
<span class="lineNum">   27139 </span>            : 
<span class="lineNum">   27140 </span>            : /* Replace DW_AT_name for the decl with name.  */
<a name="27141"><span class="lineNum">   27141 </span>            : </a>
<span class="lineNum">   27142 </span>            : static void
<span class="lineNum">   27143 </span><span class="lineNoCov">          0 : dwarf2out_set_name (tree decl, tree name)</span>
<span class="lineNum">   27144 </span>            : {
<span class="lineNum">   27145 </span><span class="lineNoCov">          0 :   dw_die_ref die;</span>
<span class="lineNum">   27146 </span><span class="lineNoCov">          0 :   dw_attr_node *attr;</span>
<span class="lineNum">   27147 </span><span class="lineNoCov">          0 :   const char *dname;</span>
<span class="lineNum">   27148 </span>            : 
<span class="lineNum">   27149 </span><span class="lineNoCov">          0 :   die = TYPE_SYMTAB_DIE (decl);</span>
<span class="lineNum">   27150 </span><span class="lineNoCov">          0 :   if (!die)</span>
<span class="lineNum">   27151 </span>            :     return;
<span class="lineNum">   27152 </span>            : 
<span class="lineNum">   27153 </span><span class="lineNoCov">          0 :   dname = dwarf2_name (name, 0);</span>
<span class="lineNum">   27154 </span><span class="lineNoCov">          0 :   if (!dname)</span>
<span class="lineNum">   27155 </span>            :     return;
<span class="lineNum">   27156 </span>            : 
<span class="lineNum">   27157 </span><span class="lineNoCov">          0 :   attr = get_AT (die, DW_AT_name);</span>
<span class="lineNum">   27158 </span><span class="lineNoCov">          0 :   if (attr)</span>
<span class="lineNum">   27159 </span>            :     {
<span class="lineNum">   27160 </span><span class="lineNoCov">          0 :       struct indirect_string_node *node;</span>
<span class="lineNum">   27161 </span>            : 
<span class="lineNum">   27162 </span><span class="lineNoCov">          0 :       node = find_AT_string (dname);</span>
<span class="lineNum">   27163 </span>            :       /* replace the string.  */
<span class="lineNum">   27164 </span><span class="lineNoCov">          0 :       attr-&gt;dw_attr_val.v.val_str = node;</span>
<span class="lineNum">   27165 </span>            :     }
<span class="lineNum">   27166 </span>            : 
<span class="lineNum">   27167 </span>            :   else
<span class="lineNum">   27168 </span><span class="lineNoCov">          0 :     add_name_attribute (die, dname);</span>
<span class="lineNum">   27169 </span>            : }
<span class="lineNum">   27170 </span>            : 
<span class="lineNum">   27171 </span>            : /* True if before or during processing of the first function being emitted.  */
<span class="lineNum">   27172 </span>            : static bool in_first_function_p = true;
<span class="lineNum">   27173 </span>            : /* True if loc_note during dwarf2out_var_location call might still be
<span class="lineNum">   27174 </span>            :    before first real instruction at address equal to .Ltext0.  */
<span class="lineNum">   27175 </span>            : static bool maybe_at_text_label_p = true;
<span class="lineNum">   27176 </span>            : /* One above highest N where .LVLN label might be equal to .Ltext0 label.  */
<span class="lineNum">   27177 </span>            : static unsigned int first_loclabel_num_not_at_text_label;
<span class="lineNum">   27178 </span>            : 
<span class="lineNum">   27179 </span>            : /* Look ahead for a real insn, or for a begin stmt marker.  */
<a name="27180"><span class="lineNum">   27180 </span>            : </a>
<span class="lineNum">   27181 </span>            : static rtx_insn *
<span class="lineNum">   27182 </span><span class="lineCov">   11893642 : dwarf2out_next_real_insn (rtx_insn *loc_note)</span>
<span class="lineNum">   27183 </span>            : {
<span class="lineNum">   27184 </span><span class="lineCov">   23787284 :   rtx_insn *next_real = NEXT_INSN (loc_note);</span>
<span class="lineNum">   27185 </span>            : 
<span class="lineNum">   27186 </span><span class="lineCov">  258096202 :   while (next_real)</span>
<span class="lineNum">   27187 </span><span class="lineCov">  257940520 :     if (INSN_P (next_real))</span>
<span class="lineNum">   27188 </span>            :       break;
<span class="lineNum">   27189 </span>            :     else
<span class="lineNum">   27190 </span><span class="lineCov">  492405120 :       next_real = NEXT_INSN (next_real);</span>
<span class="lineNum">   27191 </span>            : 
<span class="lineNum">   27192 </span><span class="lineCov">   11893642 :   return next_real;</span>
<span class="lineNum">   27193 </span>            : }
<span class="lineNum">   27194 </span>            : 
<span class="lineNum">   27195 </span>            : /* Called by the final INSN scan whenever we see a var location.  We
<span class="lineNum">   27196 </span>            :    use it to drop labels in the right places, and throw the location in
<span class="lineNum">   27197 </span>            :    our lookup table.  */
<a name="27198"><span class="lineNum">   27198 </span>            : </a>
<span class="lineNum">   27199 </span>            : static void
<span class="lineNum">   27200 </span><span class="lineCov">   68387899 : dwarf2out_var_location (rtx_insn *loc_note)</span>
<span class="lineNum">   27201 </span>            : {
<span class="lineNum">   27202 </span><span class="lineCov">   68387899 :   char loclabel[MAX_ARTIFICIAL_LABEL_BYTES + 2];</span>
<span class="lineNum">   27203 </span><span class="lineCov">   68387899 :   struct var_loc_node *newloc;</span>
<span class="lineNum">   27204 </span><span class="lineCov">   68387899 :   rtx_insn *next_real, *next_note;</span>
<span class="lineNum">   27205 </span><span class="lineCov">   68387899 :   rtx_insn *call_insn = NULL;</span>
<span class="lineNum">   27206 </span><span class="lineCov">   68387899 :   static const char *last_label;</span>
<span class="lineNum">   27207 </span><span class="lineCov">   68387899 :   static const char *last_postcall_label;</span>
<span class="lineNum">   27208 </span><span class="lineCov">   68387899 :   static bool last_in_cold_section_p;</span>
<span class="lineNum">   27209 </span><span class="lineCov">   68387899 :   static rtx_insn *expected_next_loc_note;</span>
<span class="lineNum">   27210 </span><span class="lineCov">   68387899 :   tree decl;</span>
<span class="lineNum">   27211 </span><span class="lineCov">   68387899 :   bool var_loc_p;</span>
<span class="lineNum">   27212 </span><span class="lineCov">   68387899 :   var_loc_view view = 0;</span>
<span class="lineNum">   27213 </span>            : 
<span class="lineNum">   27214 </span><span class="lineCov">   68387899 :   if (!NOTE_P (loc_note))</span>
<span class="lineNum">   27215 </span>            :     {
<span class="lineNum">   27216 </span><span class="lineCov">   25165520 :       if (CALL_P (loc_note))</span>
<span class="lineNum">   27217 </span>            :         {
<span class="lineNum">   27218 </span><span class="lineCov">    2379341 :           maybe_reset_location_view (loc_note, cur_line_info_table);</span>
<span class="lineNum">   27219 </span><span class="lineCov">    2379341 :           call_site_count++;</span>
<span class="lineNum">   27220 </span><span class="lineCov">    2379341 :           if (SIBLING_CALL_P (loc_note))</span>
<span class="lineNum">   27221 </span><span class="lineCov">      35317 :             tail_call_site_count++;</span>
<span class="lineNum">   27222 </span><span class="lineCov">    2379341 :           if (find_reg_note (loc_note, REG_CALL_ARG_LOCATION, NULL_RTX))</span>
<span class="lineNum">   27223 </span>            :             {
<span class="lineNum">   27224 </span><span class="lineCov">    2122049 :               call_insn = loc_note;</span>
<span class="lineNum">   27225 </span><span class="lineCov">    2122049 :               loc_note = NULL;</span>
<span class="lineNum">   27226 </span><span class="lineCov">    2122049 :               var_loc_p = false;</span>
<span class="lineNum">   27227 </span>            : 
<span class="lineNum">   27228 </span><span class="lineCov">    2122049 :               next_real = dwarf2out_next_real_insn (call_insn);</span>
<span class="lineNum">   27229 </span><span class="lineCov">    2122049 :               next_note = NULL;</span>
<span class="lineNum">   27230 </span><span class="lineCov">    2122049 :               cached_next_real_insn = NULL;</span>
<span class="lineNum">   27231 </span><span class="lineCov">    2122049 :               goto create_label;</span>
<span class="lineNum">   27232 </span>            :             }
<span class="lineNum">   27233 </span><span class="lineCov">     257292 :           if (optimize == 0 &amp;&amp; !flag_var_tracking)</span>
<span class="lineNum">   27234 </span>            :             {
<span class="lineNum">   27235 </span>            :               /* When the var-tracking pass is not running, there is no note
<span class="lineNum">   27236 </span>            :                  for indirect calls whose target is compile-time known. In this
<span class="lineNum">   27237 </span>            :                  case, process such calls specifically so that we generate call
<span class="lineNum">   27238 </span>            :                  sites for them anyway.  */
<span class="lineNum">   27239 </span><span class="lineCov">     249784 :               rtx x = PATTERN (loc_note);</span>
<span class="lineNum">   27240 </span><span class="lineCov">     249784 :               if (GET_CODE (x) == PARALLEL)</span>
<span class="lineNum">   27241 </span><span class="lineCov">          1 :                 x = XVECEXP (x, 0, 0);</span>
<span class="lineNum">   27242 </span><span class="lineCov">     249784 :               if (GET_CODE (x) == SET)</span>
<span class="lineNum">   27243 </span><span class="lineCov">      77716 :                 x = SET_SRC (x);</span>
<span class="lineNum">   27244 </span><span class="lineCov">     249784 :               if (GET_CODE (x) == CALL)</span>
<span class="lineNum">   27245 </span><span class="lineCov">     249784 :                 x = XEXP (x, 0);</span>
<span class="lineNum">   27246 </span><span class="lineCov">     249784 :               if (!MEM_P (x)</span>
<span class="lineNum">   27247 </span><span class="lineCov">     249784 :                   || GET_CODE (XEXP (x, 0)) != SYMBOL_REF</span>
<span class="lineNum">   27248 </span><span class="lineCov">     229671 :                   || !SYMBOL_REF_DECL (XEXP (x, 0))</span>
<span class="lineNum">   27249 </span><span class="lineCov">     464537 :                   || (TREE_CODE (SYMBOL_REF_DECL (XEXP (x, 0)))</span>
<span class="lineNum">   27250 </span>            :                       != FUNCTION_DECL))
<span class="lineNum">   27251 </span>            :                 {
<span class="lineNum">   27252 </span><span class="lineCov">      35031 :                   call_insn = loc_note;</span>
<span class="lineNum">   27253 </span><span class="lineCov">      35031 :                   loc_note = NULL;</span>
<span class="lineNum">   27254 </span><span class="lineCov">      35031 :                   var_loc_p = false;</span>
<span class="lineNum">   27255 </span>            : 
<span class="lineNum">   27256 </span><span class="lineCov">      35031 :                   next_real = dwarf2out_next_real_insn (call_insn);</span>
<span class="lineNum">   27257 </span><span class="lineCov">      35031 :                   next_note = NULL;</span>
<span class="lineNum">   27258 </span><span class="lineCov">      35031 :                   cached_next_real_insn = NULL;</span>
<span class="lineNum">   27259 </span><span class="lineCov">      35031 :                   goto create_label;</span>
<span class="lineNum">   27260 </span>            :                 }
<span class="lineNum">   27261 </span>            :             }
<span class="lineNum">   27262 </span>            :         }
<span class="lineNum">   27263 </span><span class="lineCov">   22786179 :       else if (!debug_variable_location_views)</span>
<span class="lineNum">   27264 </span><span class="lineNoCov">          0 :         gcc_unreachable ();</span>
<span class="lineNum">   27265 </span>            :       else
<span class="lineNum">   27266 </span><span class="lineCov">   22786179 :         maybe_reset_location_view (loc_note, cur_line_info_table);</span>
<span class="lineNum">   27267 </span>            : 
<span class="lineNum">   27268 </span><span class="lineCov">   34394129 :       return;</span>
<span class="lineNum">   27269 </span>            :     }
<span class="lineNum">   27270 </span>            : 
<span class="lineNum">   27271 </span><span class="lineCov">   43222379 :   var_loc_p = NOTE_KIND (loc_note) == NOTE_INSN_VAR_LOCATION;</span>
<span class="lineNum">   27272 </span><span class="lineCov">   43222379 :   if (var_loc_p &amp;&amp; !DECL_P (NOTE_VAR_LOCATION_DECL (loc_note)))</span>
<span class="lineNum">   27273 </span>            :     return;
<span class="lineNum">   27274 </span>            : 
<span class="lineNum">   27275 </span>            :   /* Optimize processing a large consecutive sequence of location
<span class="lineNum">   27276 </span>            :      notes so we don't spend too much time in next_real_insn.  If the
<span class="lineNum">   27277 </span>            :      next insn is another location note, remember the next_real_insn
<span class="lineNum">   27278 </span>            :      calculation for next time.  */
<span class="lineNum">   27279 </span><span class="lineCov">   43222379 :   next_real = cached_next_real_insn;</span>
<span class="lineNum">   27280 </span><span class="lineCov">   43222379 :   if (next_real)</span>
<span class="lineNum">   27281 </span>            :     {
<span class="lineNum">   27282 </span><span class="lineCov">   33962320 :       if (expected_next_loc_note != loc_note)</span>
<span class="lineNum">   27283 </span><span class="lineCov">     476503 :         next_real = NULL;</span>
<span class="lineNum">   27284 </span>            :     }
<span class="lineNum">   27285 </span>            : 
<span class="lineNum">   27286 </span><span class="lineCov">   43222379 :   next_note = NEXT_INSN (loc_note);</span>
<span class="lineNum">   27287 </span><span class="lineCov">   43222379 :   if (! next_note</span>
<span class="lineNum">   27288 </span><span class="lineCov">   86444570 :       || next_note-&gt;deleted ()</span>
<span class="lineNum">   27289 </span><span class="lineCov">   43222285 :       || ! NOTE_P (next_note)</span>
<span class="lineNum">   27290 </span><span class="lineCov">   43222379 :       || (NOTE_KIND (next_note) != NOTE_INSN_VAR_LOCATION</span>
<span class="lineNum">   27291 </span>            :           &amp;&amp; NOTE_KIND (next_note) != NOTE_INSN_BEGIN_STMT
<span class="lineNum">   27292 </span><span class="lineCov">   39465531 :           &amp;&amp; NOTE_KIND (next_note) != NOTE_INSN_INLINE_ENTRY))</span>
<span class="lineNum">   27293 </span>            :     next_note = NULL;
<span class="lineNum">   27294 </span>            : 
<span class="lineNum">   27295 </span><span class="lineCov">   43222379 :   if (! next_real)</span>
<span class="lineNum">   27296 </span><span class="lineCov">    9736562 :     next_real = dwarf2out_next_real_insn (loc_note);</span>
<span class="lineNum">   27297 </span>            : 
<span class="lineNum">   27298 </span><span class="lineCov">   43222379 :   if (next_note)</span>
<span class="lineNum">   27299 </span>            :     {
<span class="lineNum">   27300 </span><span class="lineCov">   34050754 :       expected_next_loc_note = next_note;</span>
<span class="lineNum">   27301 </span><span class="lineCov">   34050754 :       cached_next_real_insn = next_real;</span>
<span class="lineNum">   27302 </span>            :     }
<span class="lineNum">   27303 </span>            :   else
<span class="lineNum">   27304 </span><span class="lineCov">    9171625 :     cached_next_real_insn = NULL;</span>
<span class="lineNum">   27305 </span>            : 
<span class="lineNum">   27306 </span>            :   /* If there are no instructions which would be affected by this note,
<span class="lineNum">   27307 </span>            :      don't do anything.  */
<span class="lineNum">   27308 </span><span class="lineCov">   43222379 :   if (var_loc_p</span>
<span class="lineNum">   27309 </span><span class="lineCov">   43222379 :       &amp;&amp; next_real == NULL_RTX</span>
<span class="lineNum">   27310 </span><span class="lineCov">   43222379 :       &amp;&amp; !NOTE_DURING_CALL_P (loc_note))</span>
<span class="lineNum">   27311 </span>            :     return;
<span class="lineNum">   27312 </span>            : 
<span class="lineNum">   27313 </span><span class="lineCov">   45378946 : create_label:</span>
<span class="lineNum">   27314 </span>            : 
<span class="lineNum">   27315 </span><span class="lineCov">   45378946 :   if (next_real == NULL_RTX)</span>
<span class="lineNum">   27316 </span><span class="lineCov">     310338 :     next_real = get_last_insn ();</span>
<span class="lineNum">   27317 </span>            : 
<span class="lineNum">   27318 </span>            :   /* If there were any real insns between note we processed last time
<span class="lineNum">   27319 </span>            :      and this note (or if it is the first note), clear
<span class="lineNum">   27320 </span>            :      last_{,postcall_}label so that they are not reused this time.  */
<span class="lineNum">   27321 </span><span class="lineCov">   45378946 :   if (last_var_location_insn == NULL_RTX</span>
<span class="lineNum">   27322 </span><span class="lineCov">   45063284 :       || last_var_location_insn != next_real</span>
<span class="lineNum">   27323 </span><span class="lineCov">   36693482 :       || last_in_cold_section_p != in_cold_section_p)</span>
<span class="lineNum">   27324 </span>            :     {
<span class="lineNum">   27325 </span><span class="lineCov">    8687638 :       last_label = NULL;</span>
<span class="lineNum">   27326 </span><span class="lineCov">    8687638 :       last_postcall_label = NULL;</span>
<span class="lineNum">   27327 </span>            :     }
<span class="lineNum">   27328 </span>            : 
<span class="lineNum">   27329 </span><span class="lineCov">   45378946 :   if (var_loc_p)</span>
<span class="lineNum">   27330 </span>            :     {
<span class="lineNum">   27331 </span><span class="lineCov">   43221866 :       const char *label</span>
<span class="lineNum">   27332 </span><span class="lineCov">   43221866 :         = NOTE_DURING_CALL_P (loc_note) ? last_postcall_label : last_label;</span>
<span class="lineNum">   27333 </span><span class="lineCov">   43221866 :       view = cur_line_info_table-&gt;view;</span>
<span class="lineNum">   27334 </span><span class="lineCov">   43221866 :       decl = NOTE_VAR_LOCATION_DECL (loc_note);</span>
<span class="lineNum">   27335 </span><span class="lineCov">   43221866 :       newloc = add_var_loc_to_decl (decl, loc_note, label, view);</span>
<span class="lineNum">   27336 </span><span class="lineCov">   43221866 :       if (newloc == NULL)</span>
<span class="lineNum">   27337 </span>            :         return;
<span class="lineNum">   27338 </span>            :     }
<span class="lineNum">   27339 </span>            :   else
<span class="lineNum">   27340 </span>            :     {
<span class="lineNum">   27341 </span>            :       decl = NULL_TREE;
<span class="lineNum">   27342 </span>            :       newloc = NULL;
<span class="lineNum">   27343 </span>            :     }
<span class="lineNum">   27344 </span>            : 
<span class="lineNum">   27345 </span>            :   /* If there were no real insns between note we processed last time
<span class="lineNum">   27346 </span>            :      and this note, use the label we emitted last time.  Otherwise
<span class="lineNum">   27347 </span>            :      create a new label and emit it.  */
<span class="lineNum">   27348 </span><span class="lineCov">   33993770 :   if (last_label == NULL)</span>
<span class="lineNum">   27349 </span>            :     {
<span class="lineNum">   27350 </span><span class="lineCov">    6744497 :       ASM_GENERATE_INTERNAL_LABEL (loclabel, &quot;LVL&quot;, loclabel_num);</span>
<span class="lineNum">   27351 </span><span class="lineCov">    6744497 :       ASM_OUTPUT_DEBUG_LABEL (asm_out_file, &quot;LVL&quot;, loclabel_num);</span>
<span class="lineNum">   27352 </span><span class="lineCov">    6744497 :       loclabel_num++;</span>
<span class="lineNum">   27353 </span><span class="lineCov">    6744497 :       last_label = ggc_strdup (loclabel);</span>
<span class="lineNum">   27354 </span>            :       /* See if loclabel might be equal to .Ltext0.  If yes,
<span class="lineNum">   27355 </span>            :          bump first_loclabel_num_not_at_text_label.  */
<span class="lineNum">   27356 </span><span class="lineCov">    6744497 :       if (!have_multiple_function_sections</span>
<span class="lineNum">   27357 </span><span class="lineCov">    3173075 :           &amp;&amp; in_first_function_p</span>
<span class="lineNum">   27358 </span><span class="lineCov">     192224 :           &amp;&amp; maybe_at_text_label_p)</span>
<span class="lineNum">   27359 </span>            :         {
<span class="lineNum">   27360 </span>            :           static rtx_insn *last_start;
<span class="lineNum">   27361 </span>            :           rtx_insn *insn;
<span class="lineNum">   27362 </span><span class="lineCov">      88665 :           for (insn = loc_note; insn; insn = previous_insn (insn))</span>
<span class="lineNum">   27363 </span><span class="lineCov">      55338 :             if (insn == last_start)</span>
<span class="lineNum">   27364 </span>            :               break;
<span class="lineNum">   27365 </span><span class="lineCov">      55161 :             else if (!NONDEBUG_INSN_P (insn))</span>
<span class="lineNum">   27366 </span>            :               continue;
<span class="lineNum">   27367 </span>            :             else
<span class="lineNum">   27368 </span>            :               {
<span class="lineNum">   27369 </span><span class="lineCov">       8969 :                 rtx body = PATTERN (insn);</span>
<span class="lineNum">   27370 </span><span class="lineCov">       8969 :                 if (GET_CODE (body) == USE || GET_CODE (body) == CLOBBER)</span>
<span class="lineNum">   27371 </span>            :                   continue;
<span class="lineNum">   27372 </span>            :                 /* Inline asm could occupy zero bytes.  */
<span class="lineNum">   27373 </span><span class="lineCov">       8964 :                 else if (GET_CODE (body) == ASM_INPUT</span>
<span class="lineNum">   27374 </span><span class="lineCov">       8964 :                          || asm_noperands (body) &gt;= 0)</span>
<span class="lineNum">   27375 </span><span class="lineCov">        244 :                   continue;</span>
<span class="lineNum">   27376 </span>            : #ifdef HAVE_ATTR_length /* ??? We don't include insn-attr.h.  */
<span class="lineNum">   27377 </span>            :                 else if (HAVE_ATTR_length &amp;&amp; get_attr_min_length (insn) == 0)
<span class="lineNum">   27378 </span>            :                   continue;
<span class="lineNum">   27379 </span>            : #endif
<span class="lineNum">   27380 </span>            :                 else
<span class="lineNum">   27381 </span>            :                   {
<span class="lineNum">   27382 </span>            :                     /* Assume insn has non-zero length.  */
<span class="lineNum">   27383 </span><span class="lineCov">       8720 :                     maybe_at_text_label_p = false;</span>
<span class="lineNum">   27384 </span><span class="lineCov">       8720 :                     break;</span>
<span class="lineNum">   27385 </span>            :                   }
<span class="lineNum">   27386 </span>            :               }
<span class="lineNum">   27387 </span><span class="lineCov">      42224 :           if (maybe_at_text_label_p)</span>
<span class="lineNum">   27388 </span>            :             {
<span class="lineNum">   27389 </span><span class="lineCov">      33504 :               last_start = loc_note;</span>
<span class="lineNum">   27390 </span><span class="lineCov">      33504 :               first_loclabel_num_not_at_text_label = loclabel_num;</span>
<span class="lineNum">   27391 </span>            :             }
<span class="lineNum">   27392 </span>            :         }
<span class="lineNum">   27393 </span>            :     }
<span class="lineNum">   27394 </span>            : 
<span class="lineNum">   27395 </span><span class="lineCov">   33993770 :   gcc_assert ((loc_note == NULL_RTX &amp;&amp; call_insn != NULL_RTX)</span>
<span class="lineNum">   27396 </span>            :               || (loc_note != NULL_RTX &amp;&amp; call_insn == NULL_RTX));
<span class="lineNum">   27397 </span>            : 
<span class="lineNum">   27398 </span><span class="lineCov">   33993770 :   if (!var_loc_p)</span>
<span class="lineNum">   27399 </span>            :     {
<span class="lineNum">   27400 </span><span class="lineCov">    2157080 :       struct call_arg_loc_node *ca_loc</span>
<span class="lineNum">   27401 </span><span class="lineCov">    2157080 :         = ggc_cleared_alloc&lt;call_arg_loc_node&gt; ();</span>
<span class="lineNum">   27402 </span><span class="lineCov">    2157080 :       rtx_insn *prev = call_insn;</span>
<span class="lineNum">   27403 </span>            : 
<span class="lineNum">   27404 </span><span class="lineCov">    2157080 :       ca_loc-&gt;call_arg_loc_note</span>
<span class="lineNum">   27405 </span><span class="lineCov">    2157080 :         = find_reg_note (call_insn, REG_CALL_ARG_LOCATION, NULL_RTX);</span>
<span class="lineNum">   27406 </span><span class="lineCov">    2157080 :       ca_loc-&gt;next = NULL;</span>
<span class="lineNum">   27407 </span><span class="lineCov">    2157080 :       ca_loc-&gt;label = last_label;</span>
<span class="lineNum">   27408 </span><span class="lineCov">    2157080 :       gcc_assert (prev</span>
<span class="lineNum">   27409 </span>            :                   &amp;&amp; (CALL_P (prev)
<span class="lineNum">   27410 </span>            :                       || (NONJUMP_INSN_P (prev)
<span class="lineNum">   27411 </span>            :                           &amp;&amp; GET_CODE (PATTERN (prev)) == SEQUENCE
<span class="lineNum">   27412 </span>            :                           &amp;&amp; CALL_P (XVECEXP (PATTERN (prev), 0, 0)))));
<span class="lineNum">   27413 </span><span class="lineCov">    2157080 :       if (!CALL_P (prev))</span>
<span class="lineNum">   27414 </span><span class="lineNoCov">          0 :         prev = as_a &lt;rtx_sequence *&gt; (PATTERN (prev))-&gt;insn (0);</span>
<span class="lineNum">   27415 </span><span class="lineCov">    2157080 :       ca_loc-&gt;tail_call_p = SIBLING_CALL_P (prev);</span>
<span class="lineNum">   27416 </span>            : 
<span class="lineNum">   27417 </span>            :       /* Look for a SYMBOL_REF in the &quot;prev&quot; instruction.  */
<span class="lineNum">   27418 </span><span class="lineCov">    4314160 :       rtx x = get_call_rtx_from (PATTERN (prev));</span>
<span class="lineNum">   27419 </span><span class="lineCov">    2157080 :       if (x)</span>
<span class="lineNum">   27420 </span>            :         {
<span class="lineNum">   27421 </span>            :           /* Try to get the call symbol, if any.  */
<span class="lineNum">   27422 </span><span class="lineCov">    2157080 :           if (MEM_P (XEXP (x, 0)))</span>
<span class="lineNum">   27423 </span><span class="lineCov">    2157080 :             x = XEXP (x, 0);</span>
<span class="lineNum">   27424 </span>            :           /* First, look for a memory access to a symbol_ref.  */
<span class="lineNum">   27425 </span><span class="lineCov">    2157080 :           if (GET_CODE (XEXP (x, 0)) == SYMBOL_REF</span>
<span class="lineNum">   27426 </span><span class="lineCov">    2053452 :               &amp;&amp; SYMBOL_REF_DECL (XEXP (x, 0))</span>
<span class="lineNum">   27427 </span><span class="lineCov">    4022530 :               &amp;&amp; TREE_CODE (SYMBOL_REF_DECL (XEXP (x, 0))) == FUNCTION_DECL)</span>
<span class="lineNum">   27428 </span><span class="lineCov">    1865447 :             ca_loc-&gt;symbol_ref = XEXP (x, 0);</span>
<span class="lineNum">   27429 </span>            :           /* Otherwise, look at a compile-time known user-level function
<span class="lineNum">   27430 </span>            :              declaration.  */
<span class="lineNum">   27431 </span><span class="lineCov">     291633 :           else if (MEM_P (x)</span>
<span class="lineNum">   27432 </span><span class="lineCov">     481931 :                    &amp;&amp; MEM_EXPR (x)</span>
<span class="lineNum">   27433 </span><span class="lineCov">     494303 :                    &amp;&amp; TREE_CODE (MEM_EXPR (x)) == FUNCTION_DECL)</span>
<span class="lineNum">   27434 </span><span class="lineNoCov">          0 :             ca_loc-&gt;symbol_ref = XEXP (DECL_RTL (MEM_EXPR (x)), 0);</span>
<span class="lineNum">   27435 </span>            :         }
<span class="lineNum">   27436 </span>            : 
<span class="lineNum">   27437 </span><span class="lineCov">    2157080 :       ca_loc-&gt;block = insn_scope (prev);</span>
<span class="lineNum">   27438 </span><span class="lineCov">    2157080 :       if (call_arg_locations)</span>
<span class="lineNum">   27439 </span><span class="lineCov">    1877643 :         call_arg_loc_last-&gt;next = ca_loc;</span>
<span class="lineNum">   27440 </span>            :       else
<span class="lineNum">   27441 </span><span class="lineCov">     279437 :         call_arg_locations = ca_loc;</span>
<span class="lineNum">   27442 </span><span class="lineCov">    2157080 :       call_arg_loc_last = ca_loc;</span>
<span class="lineNum">   27443 </span>            :     }
<span class="lineNum">   27444 </span><span class="lineCov">   31836690 :   else if (loc_note != NULL_RTX &amp;&amp; !NOTE_DURING_CALL_P (loc_note))</span>
<span class="lineNum">   27445 </span>            :     {
<span class="lineNum">   27446 </span><span class="lineCov">   29892917 :       newloc-&gt;label = last_label;</span>
<span class="lineNum">   27447 </span><span class="lineCov">   29892917 :       newloc-&gt;view = view;</span>
<span class="lineNum">   27448 </span>            :     }
<span class="lineNum">   27449 </span>            :   else
<span class="lineNum">   27450 </span>            :     {
<span class="lineNum">   27451 </span><span class="lineCov">    1943773 :       if (!last_postcall_label)</span>
<span class="lineNum">   27452 </span>            :         {
<span class="lineNum">   27453 </span><span class="lineCov">     601477 :           sprintf (loclabel, &quot;%s-1&quot;, last_label);</span>
<span class="lineNum">   27454 </span><span class="lineCov">     601477 :           last_postcall_label = ggc_strdup (loclabel);</span>
<span class="lineNum">   27455 </span>            :         }
<span class="lineNum">   27456 </span><span class="lineCov">    1943773 :       newloc-&gt;label = last_postcall_label;</span>
<span class="lineNum">   27457 </span>            :       /* ??? This view is at last_label, not last_label-1, but we
<span class="lineNum">   27458 </span>            :          could only assume view at last_label-1 is zero if we could
<span class="lineNum">   27459 </span>            :          assume calls always have length greater than one.  This is
<span class="lineNum">   27460 </span>            :          probably true in general, though there might be a rare
<span class="lineNum">   27461 </span>            :          exception to this rule, e.g. if a call insn is optimized out
<span class="lineNum">   27462 </span>            :          by target magic.  Then, even the -1 in the label will be
<span class="lineNum">   27463 </span>            :          wrong, which might invalidate the range.  Anyway, using view,
<span class="lineNum">   27464 </span>            :          though technically possibly incorrect, will work as far as
<span class="lineNum">   27465 </span>            :          ranges go: since L-1 is in the middle of the call insn,
<span class="lineNum">   27466 </span>            :          (L-1).0 and (L-1).V shouldn't make any difference, and having
<span class="lineNum">   27467 </span>            :          the loclist entry refer to the .loc entry might be useful, so
<span class="lineNum">   27468 </span>            :          leave it like this.  */
<span class="lineNum">   27469 </span><span class="lineCov">    1943773 :       newloc-&gt;view = view;</span>
<span class="lineNum">   27470 </span>            :     }
<span class="lineNum">   27471 </span>            : 
<span class="lineNum">   27472 </span><span class="lineCov">   33993770 :   if (var_loc_p &amp;&amp; flag_debug_asm)</span>
<span class="lineNum">   27473 </span>            :     {
<span class="lineNum">   27474 </span><span class="lineCov">        307 :       const char *name, *sep, *patstr;</span>
<span class="lineNum">   27475 </span><span class="lineCov">        307 :       if (decl &amp;&amp; DECL_NAME (decl))</span>
<span class="lineNum">   27476 </span><span class="lineCov">        592 :         name = IDENTIFIER_POINTER (DECL_NAME (decl));</span>
<span class="lineNum">   27477 </span>            :       else
<span class="lineNum">   27478 </span>            :         name = &quot;&quot;;
<span class="lineNum">   27479 </span><span class="lineCov">        307 :       if (NOTE_VAR_LOCATION_LOC (loc_note))</span>
<span class="lineNum">   27480 </span>            :         {
<span class="lineNum">   27481 </span><span class="lineCov">        227 :           sep = &quot; =&gt; &quot;;</span>
<span class="lineNum">   27482 </span><span class="lineCov">        227 :           patstr = str_pattern_slim (NOTE_VAR_LOCATION_LOC (loc_note));</span>
<span class="lineNum">   27483 </span>            :         }
<span class="lineNum">   27484 </span>            :       else
<span class="lineNum">   27485 </span>            :         {
<span class="lineNum">   27486 </span>            :           sep = &quot; &quot;;
<span class="lineNum">   27487 </span>            :           patstr = &quot;RESET&quot;;
<span class="lineNum">   27488 </span>            :         }
<span class="lineNum">   27489 </span><span class="lineCov">        307 :       fprintf (asm_out_file, &quot;\t%s DEBUG %s%s%s\n&quot;, ASM_COMMENT_START,</span>
<span class="lineNum">   27490 </span>            :                name, sep, patstr);
<span class="lineNum">   27491 </span>            :     }
<span class="lineNum">   27492 </span>            : 
<span class="lineNum">   27493 </span><span class="lineCov">   33993770 :   last_var_location_insn = next_real;</span>
<span class="lineNum">   27494 </span><span class="lineCov">   33993770 :   last_in_cold_section_p = in_cold_section_p;</span>
<span class="lineNum">   27495 </span>            : }
<span class="lineNum">   27496 </span>            : 
<span class="lineNum">   27497 </span>            : /* Check whether BLOCK, a lexical block, is nested within OUTER, or is
<span class="lineNum">   27498 </span>            :    OUTER itself.  If BOTHWAYS, check not only that BLOCK can reach
<span class="lineNum">   27499 </span>            :    OUTER through BLOCK_SUPERCONTEXT links, but also that there is a
<span class="lineNum">   27500 </span>            :    path from OUTER to BLOCK through BLOCK_SUBBLOCKs and
<a name="27501"><span class="lineNum">   27501 </span>            :    BLOCK_FRAGMENT_ORIGIN links.  */</a>
<span class="lineNum">   27502 </span>            : static bool
<span class="lineNum">   27503 </span><span class="lineCov">    3240441 : block_within_block_p (tree block, tree outer, bool bothways)</span>
<span class="lineNum">   27504 </span>            : {
<span class="lineNum">   27505 </span><span class="lineCov">    3240441 :   if (block == outer)</span>
<span class="lineNum">   27506 </span>            :     return true;
<span class="lineNum">   27507 </span>            : 
<span class="lineNum">   27508 </span>            :   /* Quickly check that OUTER is up BLOCK's supercontext chain.  */
<span class="lineNum">   27509 </span><span class="lineCov">    3240441 :   for (tree context = BLOCK_SUPERCONTEXT (block);</span>
<span class="lineNum">   27510 </span><span class="lineCov">   21618048 :        context != outer;</span>
<span class="lineNum">   27511 </span><span class="lineCov">   36755214 :        context = BLOCK_SUPERCONTEXT (context))</span>
<span class="lineNum">   27512 </span><span class="lineCov">   18377607 :     if (!context || TREE_CODE (context) != BLOCK)</span>
<span class="lineNum">   27513 </span>            :       return false;
<span class="lineNum">   27514 </span>            : 
<span class="lineNum">   27515 </span><span class="lineCov">    3240441 :   if (!bothways)</span>
<span class="lineNum">   27516 </span>            :     return true;
<span class="lineNum">   27517 </span>            : 
<span class="lineNum">   27518 </span>            :   /* Now check that each block is actually referenced by its
<span class="lineNum">   27519 </span>            :      parent.  */
<span class="lineNum">   27520 </span>            :   for (tree context = BLOCK_SUPERCONTEXT (block); ;
<span class="lineNum">   27521 </span><span class="lineCov">   36755214 :        context = BLOCK_SUPERCONTEXT (context))</span>
<span class="lineNum">   27522 </span>            :     {
<span class="lineNum">   27523 </span><span class="lineCov">   21618048 :       if (BLOCK_FRAGMENT_ORIGIN (context))</span>
<span class="lineNum">   27524 </span>            :         {
<span class="lineNum">   27525 </span><span class="lineCov">    2103064 :           gcc_assert (!BLOCK_SUBBLOCKS (context));</span>
<span class="lineNum">   27526 </span>            :           context = BLOCK_FRAGMENT_ORIGIN (context);
<span class="lineNum">   27527 </span>            :         }
<span class="lineNum">   27528 </span><span class="lineCov">   21618048 :       for (tree sub = BLOCK_SUBBLOCKS (context);</span>
<span class="lineNum">   27529 </span><span class="lineCov">  107138398 :            sub != block;</span>
<span class="lineNum">   27530 </span><span class="lineCov">   85520350 :            sub = BLOCK_CHAIN (sub))</span>
<span class="lineNum">   27531 </span><span class="lineCov">   85520350 :         if (!sub)</span>
<span class="lineNum">   27532 </span>            :           return false;
<span class="lineNum">   27533 </span><span class="lineCov">   21618048 :       if (context == outer)</span>
<span class="lineNum">   27534 </span>            :         return true;
<span class="lineNum">   27535 </span>            :       else
<span class="lineNum">   27536 </span><span class="lineCov">   18377607 :         block = context;</span>
<span class="lineNum">   27537 </span><span class="lineCov">   18377607 :     }</span>
<span class="lineNum">   27538 </span>            : }
<span class="lineNum">   27539 </span>            : 
<span class="lineNum">   27540 </span>            : /* Called during final while assembling the marker of the entry point
<span class="lineNum">   27541 </span>            :    for an inlined function.  */
<a name="27542"><span class="lineNum">   27542 </span>            : </a>
<span class="lineNum">   27543 </span>            : static void
<span class="lineNum">   27544 </span><span class="lineCov">    3240441 : dwarf2out_inline_entry (tree block)</span>
<span class="lineNum">   27545 </span>            : {
<span class="lineNum">   27546 </span><span class="lineCov">    3240441 :   gcc_assert (debug_inline_points);</span>
<span class="lineNum">   27547 </span>            : 
<span class="lineNum">   27548 </span>            :   /* If we can't represent it, don't bother.  */
<span class="lineNum">   27549 </span><span class="lineCov">    3240441 :   if (!(dwarf_version &gt;= 3 || !dwarf_strict))</span>
<span class="lineNum">   27550 </span><span class="lineCov">      90507 :     return;</span>
<span class="lineNum">   27551 </span>            : 
<span class="lineNum">   27552 </span><span class="lineCov">    3240441 :   gcc_assert (DECL_P (block_ultimate_origin (block)));</span>
<span class="lineNum">   27553 </span>            : 
<span class="lineNum">   27554 </span>            :   /* Sanity check the block tree.  This would catch a case in which
<span class="lineNum">   27555 </span>            :      BLOCK got removed from the tree reachable from the outermost
<span class="lineNum">   27556 </span>            :      lexical block, but got retained in markers.  It would still link
<span class="lineNum">   27557 </span>            :      back to its parents, but some ancestor would be missing a link
<span class="lineNum">   27558 </span>            :      down the path to the sub BLOCK.  If the block got removed, its
<span class="lineNum">   27559 </span>            :      BLOCK_NUMBER will not be a usable value.  */
<span class="lineNum">   27560 </span><span class="lineCov">    3240441 :   if (flag_checking)</span>
<span class="lineNum">   27561 </span><span class="lineCov">    3240441 :     gcc_assert (block_within_block_p (block,</span>
<span class="lineNum">   27562 </span>            :                                       DECL_INITIAL (current_function_decl),
<span class="lineNum">   27563 </span>            :                                       true));
<span class="lineNum">   27564 </span>            : 
<span class="lineNum">   27565 </span><span class="lineCov">    3240441 :   gcc_assert (inlined_function_outer_scope_p (block));</span>
<span class="lineNum">   27566 </span><span class="lineCov">    3240441 :   gcc_assert (!BLOCK_DIE (block));</span>
<span class="lineNum">   27567 </span>            : 
<span class="lineNum">   27568 </span><span class="lineCov">    6480882 :   if (BLOCK_FRAGMENT_ORIGIN (block))</span>
<span class="lineNum">   27569 </span><span class="lineNoCov">          0 :     block = BLOCK_FRAGMENT_ORIGIN (block);</span>
<span class="lineNum">   27570 </span>            :   /* Can the entry point ever not be at the beginning of an
<span class="lineNum">   27571 </span>            :      unfragmented lexical block?  */
<span class="lineNum">   27572 </span><span class="lineCov">    6480882 :   else if (!(BLOCK_FRAGMENT_CHAIN (block)</span>
<span class="lineNum">   27573 </span>            :              || (cur_line_info_table
<span class="lineNum">   27574 </span><span class="lineCov">    2098717 :                  &amp;&amp; !ZERO_VIEW_P (cur_line_info_table-&gt;view))))</span>
<span class="lineNum">   27575 </span><span class="lineCov">       1610 :     return;</span>
<span class="lineNum">   27576 </span>            : 
<span class="lineNum">   27577 </span><span class="lineCov">    3238831 :   if (!inline_entry_data_table)</span>
<span class="lineNum">   27578 </span><span class="lineCov">      10281 :     inline_entry_data_table</span>
<span class="lineNum">   27579 </span><span class="lineCov">      10281 :       = hash_table&lt;inline_entry_data_hasher&gt;::create_ggc (10);</span>
<span class="lineNum">   27580 </span>            : 
<span class="lineNum">   27581 </span>            : 
<span class="lineNum">   27582 </span><span class="lineCov">    3238831 :   inline_entry_data **iedp</span>
<span class="lineNum">   27583 </span><span class="lineCov">    3238831 :     = inline_entry_data_table-&gt;find_slot_with_hash (block,</span>
<span class="lineNum">   27584 </span>            :                                                     htab_hash_pointer (block),
<span class="lineNum">   27585 </span>            :                                                     INSERT);
<span class="lineNum">   27586 </span><span class="lineCov">    3238831 :   if (*iedp)</span>
<span class="lineNum">   27587 </span>            :     /* ??? Ideally, we'd record all entry points for the same inlined
<span class="lineNum">   27588 </span>            :        function (some may have been duplicated by e.g. unrolling), but
<span class="lineNum">   27589 </span>            :        we have no way to represent that ATM.  */
<span class="lineNum">   27590 </span>            :     return;
<span class="lineNum">   27591 </span>            : 
<span class="lineNum">   27592 </span><span class="lineCov">    3149934 :   inline_entry_data *ied = *iedp = ggc_cleared_alloc&lt;inline_entry_data&gt; ();</span>
<span class="lineNum">   27593 </span><span class="lineCov">    3149934 :   ied-&gt;block = block;</span>
<span class="lineNum">   27594 </span><span class="lineCov">    3149934 :   ied-&gt;label_pfx = BLOCK_INLINE_ENTRY_LABEL;</span>
<span class="lineNum">   27595 </span><span class="lineCov">    3149934 :   ied-&gt;label_num = BLOCK_NUMBER (block);</span>
<span class="lineNum">   27596 </span><span class="lineCov">    3149934 :   if (cur_line_info_table)</span>
<span class="lineNum">   27597 </span><span class="lineCov">    3149934 :     ied-&gt;view = cur_line_info_table-&gt;view;</span>
<span class="lineNum">   27598 </span>            : 
<span class="lineNum">   27599 </span><span class="lineCov">    3149934 :   char label[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">   27600 </span>            : 
<span class="lineNum">   27601 </span><span class="lineCov">    3149934 :   ASM_GENERATE_INTERNAL_LABEL (label, BLOCK_INLINE_ENTRY_LABEL,</span>
<span class="lineNum">   27602 </span>            :                                BLOCK_NUMBER (block));
<span class="lineNum">   27603 </span><span class="lineCov">    3149934 :   ASM_OUTPUT_LABEL (asm_out_file, label);</span>
<span class="lineNum">   27604 </span>            : }
<span class="lineNum">   27605 </span>            : 
<span class="lineNum">   27606 </span>            : /* Called from finalize_size_functions for size functions so that their body
<span class="lineNum">   27607 </span>            :    can be encoded in the debug info to describe the layout of variable-length
<span class="lineNum">   27608 </span>            :    structures.  */
<a name="27609"><span class="lineNum">   27609 </span>            : </a>
<span class="lineNum">   27610 </span>            : static void
<span class="lineNum">   27611 </span><span class="lineNoCov">          0 : dwarf2out_size_function (tree decl)</span>
<span class="lineNum">   27612 </span>            : {
<span class="lineNum">   27613 </span><span class="lineNoCov">          0 :   function_to_dwarf_procedure (decl);</span>
<span class="lineNum">   27614 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   27615 </span>            : 
<span class="lineNum">   27616 </span>            : /* Note in one location list that text section has changed.  */
<a name="27617"><span class="lineNum">   27617 </span>            : </a>
<span class="lineNum">   27618 </span>            : int
<span class="lineNum">   27619 </span><span class="lineCov">    1541255 : var_location_switch_text_section_1 (var_loc_list **slot, void *)</span>
<span class="lineNum">   27620 </span>            : {
<span class="lineNum">   27621 </span><span class="lineCov">    1541255 :   var_loc_list *list = *slot;</span>
<span class="lineNum">   27622 </span><span class="lineCov">    1541255 :   if (list-&gt;first)</span>
<span class="lineNum">   27623 </span><span class="lineCov">    1541255 :     list-&gt;last_before_switch</span>
<span class="lineNum">   27624 </span><span class="lineCov">    1646836 :       = list-&gt;last-&gt;next ? list-&gt;last-&gt;next : list-&gt;last;</span>
<span class="lineNum">   27625 </span><span class="lineCov">    1541255 :   return 1;</span>
<span class="lineNum">   27626 </span>            : }
<span class="lineNum">   27627 </span>            : 
<span class="lineNum">   27628 </span>            : /* Note in all location lists that text section has changed.  */
<a name="27629"><span class="lineNum">   27629 </span>            : </a>
<span class="lineNum">   27630 </span>            : static void
<span class="lineNum">   27631 </span><span class="lineNoCov">          0 : var_location_switch_text_section (void)</span>
<span class="lineNum">   27632 </span>            : {
<span class="lineNum">   27633 </span><span class="lineCov">      37440 :   if (decl_loc_table == NULL)</span>
<span class="lineNum">   27634 </span>            :     return;
<span class="lineNum">   27635 </span>            : 
<span class="lineNum">   27636 </span><span class="lineCov">       9450 :   decl_loc_table-&gt;traverse&lt;void *, var_location_switch_text_section_1&gt; (NULL);</span>
<span class="lineNum">   27637 </span>            : }
<span class="lineNum">   27638 </span>            : 
<span class="lineNum">   27639 </span>            : /* Create a new line number table.  */
<a name="27640"><span class="lineNum">   27640 </span>            : </a>
<span class="lineNum">   27641 </span>            : static dw_line_info_table *
<span class="lineNum">   27642 </span><span class="lineCov">     166873 : new_line_info_table (void)</span>
<span class="lineNum">   27643 </span>            : {
<span class="lineNum">   27644 </span><span class="lineCov">     166873 :   dw_line_info_table *table;</span>
<span class="lineNum">   27645 </span>            : 
<span class="lineNum">   27646 </span><span class="lineCov">     166873 :   table = ggc_cleared_alloc&lt;dw_line_info_table&gt; ();</span>
<span class="lineNum">   27647 </span><span class="lineCov">     166873 :   table-&gt;file_num = 1;</span>
<span class="lineNum">   27648 </span><span class="lineCov">     166873 :   table-&gt;line_num = 1;</span>
<span class="lineNum">   27649 </span><span class="lineCov">     166873 :   table-&gt;is_stmt = DWARF_LINE_DEFAULT_IS_STMT_START;</span>
<span class="lineNum">   27650 </span><span class="lineCov">     166873 :   FORCE_RESET_NEXT_VIEW (table-&gt;view);</span>
<span class="lineNum">   27651 </span><span class="lineCov">     166873 :   table-&gt;symviews_since_reset = 0;</span>
<span class="lineNum">   27652 </span>            : 
<span class="lineNum">   27653 </span><span class="lineCov">     166873 :   return table;</span>
<span class="lineNum">   27654 </span>            : }
<span class="lineNum">   27655 </span>            : 
<span class="lineNum">   27656 </span>            : /* Lookup the &quot;current&quot; table into which we emit line info, so
<span class="lineNum">   27657 </span>            :    that we don't have to do it for every source line.  */
<a name="27658"><span class="lineNum">   27658 </span>            : </a>
<span class="lineNum">   27659 </span>            : static void
<span class="lineNum">   27660 </span><span class="lineCov">     349403 : set_cur_line_info_table (section *sec)</span>
<span class="lineNum">   27661 </span>            : {
<span class="lineNum">   27662 </span><span class="lineCov">     349403 :   dw_line_info_table *table;</span>
<span class="lineNum">   27663 </span>            : 
<span class="lineNum">   27664 </span><span class="lineCov">     349403 :   if (sec == text_section)</span>
<span class="lineNum">   27665 </span><span class="lineCov">     215034 :     table = text_section_line_info;</span>
<span class="lineNum">   27666 </span><span class="lineCov">     134369 :   else if (sec == cold_text_section)</span>
<span class="lineNum">   27667 </span>            :     {
<span class="lineNum">   27668 </span><span class="lineCov">       6638 :       table = cold_text_section_line_info;</span>
<span class="lineNum">   27669 </span><span class="lineCov">       6638 :       if (!table)</span>
<span class="lineNum">   27670 </span>            :         {
<span class="lineNum">   27671 </span><span class="lineCov">       5444 :           cold_text_section_line_info = table = new_line_info_table ();</span>
<span class="lineNum">   27672 </span><span class="lineCov">       5444 :           table-&gt;end_label = cold_end_label;</span>
<span class="lineNum">   27673 </span>            :         }
<span class="lineNum">   27674 </span>            :     }
<span class="lineNum">   27675 </span>            :   else
<span class="lineNum">   27676 </span>            :     {
<span class="lineNum">   27677 </span><span class="lineCov">     127731 :       const char *end_label;</span>
<span class="lineNum">   27678 </span>            : 
<span class="lineNum">   27679 </span><span class="lineCov">     127731 :       if (crtl-&gt;has_bb_partition)</span>
<span class="lineNum">   27680 </span>            :         {
<span class="lineNum">   27681 </span><span class="lineCov">      10295 :           if (in_cold_section_p)</span>
<span class="lineNum">   27682 </span><span class="lineCov">       2828 :             end_label = crtl-&gt;subsections.cold_section_end_label;</span>
<span class="lineNum">   27683 </span>            :           else
<span class="lineNum">   27684 </span><span class="lineCov">       7467 :             end_label = crtl-&gt;subsections.hot_section_end_label;</span>
<span class="lineNum">   27685 </span>            :         }
<span class="lineNum">   27686 </span>            :       else
<span class="lineNum">   27687 </span>            :         {
<span class="lineNum">   27688 </span><span class="lineCov">     117436 :           char label[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">   27689 </span><span class="lineCov">     117436 :           ASM_GENERATE_INTERNAL_LABEL (label, FUNC_END_LABEL,</span>
<span class="lineNum">   27690 </span>            :                                        current_function_funcdef_no);
<span class="lineNum">   27691 </span><span class="lineCov">     117436 :           end_label = ggc_strdup (label);</span>
<span class="lineNum">   27692 </span>            :         }
<span class="lineNum">   27693 </span>            : 
<span class="lineNum">   27694 </span><span class="lineCov">     127731 :       table = new_line_info_table ();</span>
<span class="lineNum">   27695 </span><span class="lineCov">     127731 :       table-&gt;end_label = end_label;</span>
<span class="lineNum">   27696 </span>            : 
<span class="lineNum">   27697 </span><span class="lineCov">     127731 :       vec_safe_push (separate_line_info, table);</span>
<span class="lineNum">   27698 </span>            :     }
<span class="lineNum">   27699 </span>            : 
<span class="lineNum">   27700 </span><span class="lineCov">     349403 :   if (output_asm_line_debug_info ())</span>
<span class="lineNum">   27701 </span><span class="lineCov">     349403 :     table-&gt;is_stmt = (cur_line_info_table</span>
<span class="lineNum">   27702 </span>            :                       ? cur_line_info_table-&gt;is_stmt
<span class="lineNum">   27703 </span><span class="lineCov">     349403 :                       : DWARF_LINE_DEFAULT_IS_STMT_START);</span>
<span class="lineNum">   27704 </span><span class="lineCov">     349403 :   cur_line_info_table = table;</span>
<span class="lineNum">   27705 </span><span class="lineCov">     349403 : }</span>
<span class="lineNum">   27706 </span>            : 
<span class="lineNum">   27707 </span>            : 
<span class="lineNum">   27708 </span>            : /* We need to reset the locations at the beginning of each
<span class="lineNum">   27709 </span>            :    function. We can't do this in the end_function hook, because the
<span class="lineNum">   27710 </span>            :    declarations that use the locations won't have been output when
<span class="lineNum">   27711 </span>            :    that hook is called.  Also compute have_multiple_function_sections here.  */
<a name="27712"><span class="lineNum">   27712 </span>            : </a>
<span class="lineNum">   27713 </span>            : static void
<span class="lineNum">   27714 </span><span class="lineCov">     339954 : dwarf2out_begin_function (tree fun)</span>
<span class="lineNum">   27715 </span>            : {
<span class="lineNum">   27716 </span><span class="lineCov">     339954 :   section *sec = function_section (fun);</span>
<span class="lineNum">   27717 </span>            : 
<span class="lineNum">   27718 </span><span class="lineCov">     339954 :   if (sec != text_section)</span>
<span class="lineNum">   27719 </span><span class="lineCov">     124920 :     have_multiple_function_sections = true;</span>
<span class="lineNum">   27720 </span>            : 
<span class="lineNum">   27721 </span><span class="lineCov">     339954 :   if (crtl-&gt;has_bb_partition &amp;&amp; !cold_text_section)</span>
<span class="lineNum">   27722 </span>            :     {
<span class="lineNum">   27723 </span><span class="lineCov">       5444 :       gcc_assert (current_function_decl == fun);</span>
<span class="lineNum">   27724 </span><span class="lineCov">       5444 :       cold_text_section = unlikely_text_section ();</span>
<span class="lineNum">   27725 </span><span class="lineCov">       5444 :       switch_to_section (cold_text_section);</span>
<span class="lineNum">   27726 </span><span class="lineCov">       5444 :       ASM_OUTPUT_LABEL (asm_out_file, cold_text_section_label);</span>
<span class="lineNum">   27727 </span><span class="lineCov">       5444 :       switch_to_section (sec);</span>
<span class="lineNum">   27728 </span>            :     }
<span class="lineNum">   27729 </span>            : 
<span class="lineNum">   27730 </span><span class="lineCov">     339954 :   dwarf2out_note_section_used ();</span>
<span class="lineNum">   27731 </span><span class="lineCov">     339954 :   call_site_count = 0;</span>
<span class="lineNum">   27732 </span><span class="lineCov">     339954 :   tail_call_site_count = 0;</span>
<span class="lineNum">   27733 </span>            : 
<span class="lineNum">   27734 </span><span class="lineCov">     339954 :   set_cur_line_info_table (sec);</span>
<span class="lineNum">   27735 </span><span class="lineCov">     339954 :   FORCE_RESET_NEXT_VIEW (cur_line_info_table-&gt;view);</span>
<span class="lineNum">   27736 </span><span class="lineCov">     339954 : }</span>
<span class="lineNum">   27737 </span>            : 
<span class="lineNum">   27738 </span>            : /* Helper function of dwarf2out_end_function, called only after emitting
<span class="lineNum">   27739 </span>            :    the very first function into assembly.  Check if some .debug_loc range
<span class="lineNum">   27740 </span>            :    might end with a .LVL* label that could be equal to .Ltext0.
<span class="lineNum">   27741 </span>            :    In that case we must force using absolute addresses in .debug_loc ranges,
<span class="lineNum">   27742 </span>            :    because this range could be .LVLN-.Ltext0 .. .LVLM-.Ltext0 for
<span class="lineNum">   27743 </span>            :    .LVLN == .LVLM == .Ltext0, thus 0 .. 0, which is a .debug_loc
<span class="lineNum">   27744 </span>            :    list terminator.
<span class="lineNum">   27745 </span>            :    Set have_multiple_function_sections to true in that case and
<span class="lineNum">   27746 </span>            :    terminate htab traversal.  */
<a name="27747"><span class="lineNum">   27747 </span>            : </a>
<span class="lineNum">   27748 </span>            : int
<span class="lineNum">   27749 </span><span class="lineCov">     160152 : find_empty_loc_ranges_at_text_label (var_loc_list **slot, int)</span>
<span class="lineNum">   27750 </span>            : {
<span class="lineNum">   27751 </span><span class="lineCov">     160152 :   var_loc_list *entry = *slot;</span>
<span class="lineNum">   27752 </span><span class="lineCov">     160152 :   struct var_loc_node *node;</span>
<span class="lineNum">   27753 </span>            : 
<span class="lineNum">   27754 </span><span class="lineCov">     160152 :   node = entry-&gt;first;</span>
<span class="lineNum">   27755 </span><span class="lineCov">     160152 :   if (node &amp;&amp; node-&gt;next &amp;&amp; node-&gt;next-&gt;label)</span>
<span class="lineNum">   27756 </span>            :     {
<span class="lineNum">   27757 </span>            :       unsigned int i;
<span class="lineNum">   27758 </span>            :       const char *label = node-&gt;next-&gt;label;
<span class="lineNum">   27759 </span>            :       char loclabel[MAX_ARTIFICIAL_LABEL_BYTES];
<span class="lineNum">   27760 </span>            : 
<span class="lineNum">   27761 </span><span class="lineCov">     104525 :       for (i = 0; i &lt; first_loclabel_num_not_at_text_label; i++)</span>
<span class="lineNum">   27762 </span>            :         {
<span class="lineNum">   27763 </span><span class="lineCov">      62589 :           ASM_GENERATE_INTERNAL_LABEL (loclabel, &quot;LVL&quot;, i);</span>
<span class="lineNum">   27764 </span><span class="lineCov">      62589 :           if (strcmp (label, loclabel) == 0)</span>
<span class="lineNum">   27765 </span>            :             {
<span class="lineNum">   27766 </span><span class="lineCov">        675 :               have_multiple_function_sections = true;</span>
<span class="lineNum">   27767 </span><span class="lineCov">        675 :               return 0;</span>
<span class="lineNum">   27768 </span>            :             }
<span class="lineNum">   27769 </span>            :         }
<span class="lineNum">   27770 </span>            :     }
<span class="lineNum">   27771 </span>            :   return 1;
<span class="lineNum">   27772 </span>            : }
<span class="lineNum">   27773 </span>            : 
<span class="lineNum">   27774 </span>            : /* Hook called after emitting a function into assembly.
<span class="lineNum">   27775 </span>            :    This does something only for the very first function emitted.  */
<a name="27776"><span class="lineNum">   27776 </span>            : </a>
<span class="lineNum">   27777 </span>            : static void
<span class="lineNum">   27778 </span><span class="lineCov">     339954 : dwarf2out_end_function (unsigned int)</span>
<span class="lineNum">   27779 </span>            : {
<span class="lineNum">   27780 </span><span class="lineCov">     339954 :   if (in_first_function_p</span>
<span class="lineNum">   27781 </span><span class="lineCov">      31153 :       &amp;&amp; !have_multiple_function_sections</span>
<span class="lineNum">   27782 </span><span class="lineCov">      16541 :       &amp;&amp; first_loclabel_num_not_at_text_label</span>
<span class="lineNum">   27783 </span><span class="lineCov">      12995 :       &amp;&amp; decl_loc_table)</span>
<span class="lineNum">   27784 </span><span class="lineCov">      12995 :     decl_loc_table-&gt;traverse&lt;int, find_empty_loc_ranges_at_text_label&gt; (0);</span>
<span class="lineNum">   27785 </span><span class="lineCov">     339954 :   in_first_function_p = false;</span>
<span class="lineNum">   27786 </span><span class="lineCov">     339954 :   maybe_at_text_label_p = false;</span>
<span class="lineNum">   27787 </span><span class="lineCov">     339954 : }</span>
<span class="lineNum">   27788 </span>            : 
<span class="lineNum">   27789 </span>            : /* Temporary holder for dwarf2out_register_main_translation_unit.  Used to let
<span class="lineNum">   27790 </span>            :    front-ends register a translation unit even before dwarf2out_init is
<span class="lineNum">   27791 </span>            :    called.  */
<span class="lineNum">   27792 </span>            : static tree main_translation_unit = NULL_TREE;
<span class="lineNum">   27793 </span>            : 
<span class="lineNum">   27794 </span>            : /* Hook called by front-ends after they built their main translation unit.
<span class="lineNum">   27795 </span>            :    Associate comp_unit_die to UNIT.  */
<a name="27796"><span class="lineNum">   27796 </span>            : </a>
<span class="lineNum">   27797 </span>            : static void
<span class="lineNum">   27798 </span><span class="lineCov">      32632 : dwarf2out_register_main_translation_unit (tree unit)</span>
<span class="lineNum">   27799 </span>            : {
<span class="lineNum">   27800 </span><span class="lineCov">      32632 :   gcc_assert (TREE_CODE (unit) == TRANSLATION_UNIT_DECL</span>
<span class="lineNum">   27801 </span>            :               &amp;&amp; main_translation_unit == NULL_TREE);
<span class="lineNum">   27802 </span><span class="lineCov">      32632 :   main_translation_unit = unit;</span>
<span class="lineNum">   27803 </span>            :   /* If dwarf2out_init has not been called yet, it will perform the association
<span class="lineNum">   27804 </span>            :      itself looking at main_translation_unit.  */
<span class="lineNum">   27805 </span><span class="lineCov">      32632 :   if (decl_die_table != NULL)</span>
<span class="lineNum">   27806 </span><span class="lineCov">      19487 :     equate_decl_number_to_die (unit, comp_unit_die ());</span>
<span class="lineNum">   27807 </span><span class="lineCov">      32632 : }</span>
<span class="lineNum">   27808 </span>            : 
<span class="lineNum">   27809 </span>            : /* Add OPCODE+VAL as an entry at the end of the opcode array in TABLE.  */
<a name="27810"><span class="lineNum">   27810 </span>            : </a>
<span class="lineNum">   27811 </span>            : static void
<span class="lineNum">   27812 </span><span class="lineNoCov">          0 : push_dw_line_info_entry (dw_line_info_table *table,</span>
<span class="lineNum">   27813 </span>            :                          enum dw_line_info_opcode opcode, unsigned int val)
<span class="lineNum">   27814 </span>            : {
<span class="lineNum">   27815 </span><span class="lineNoCov">          0 :   dw_line_info_entry e;</span>
<span class="lineNum">   27816 </span><span class="lineNoCov">          0 :   e.opcode = opcode;</span>
<span class="lineNum">   27817 </span><span class="lineNoCov">          0 :   e.val = val;</span>
<span class="lineNum">   27818 </span><span class="lineNoCov">          0 :   vec_safe_push (table-&gt;entries, e);</span>
<span class="lineNum">   27819 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   27820 </span>            : 
<span class="lineNum">   27821 </span>            : /* Output a label to mark the beginning of a source code line entry
<span class="lineNum">   27822 </span>            :    and record information relating to this source line, in
<span class="lineNum">   27823 </span>            :    'line_info_table' for later output of the .debug_line section.  */
<span class="lineNum">   27824 </span>            : /* ??? The discriminator parameter ought to be unsigned.  */
<a name="27825"><span class="lineNum">   27825 </span>            : </a>
<span class="lineNum">   27826 </span>            : static void
<span class="lineNum">   27827 </span><span class="lineCov">   17999034 : dwarf2out_source_line (unsigned int line, unsigned int column,</span>
<span class="lineNum">   27828 </span>            :                        const char *filename,
<span class="lineNum">   27829 </span>            :                        int discriminator, bool is_stmt)
<span class="lineNum">   27830 </span>            : {
<span class="lineNum">   27831 </span><span class="lineCov">   17999034 :   unsigned int file_num;</span>
<span class="lineNum">   27832 </span><span class="lineCov">   17999034 :   dw_line_info_table *table;</span>
<span class="lineNum">   27833 </span><span class="lineCov">   17999034 :   static var_loc_view lvugid;</span>
<span class="lineNum">   27834 </span>            : 
<span class="lineNum">   27835 </span><span class="lineCov">   17999034 :   if (debug_info_level &lt; DINFO_LEVEL_TERSE)</span>
<span class="lineNum">   27836 </span>            :     return;
<span class="lineNum">   27837 </span>            : 
<span class="lineNum">   27838 </span><span class="lineCov">   17999034 :   table = cur_line_info_table;</span>
<span class="lineNum">   27839 </span>            : 
<span class="lineNum">   27840 </span><span class="lineCov">   17999034 :   if (line == 0)</span>
<span class="lineNum">   27841 </span>            :     {
<span class="lineNum">   27842 </span><span class="lineCov">     219315 :       if (debug_variable_location_views</span>
<span class="lineNum">   27843 </span><span class="lineCov">     210976 :           &amp;&amp; output_asm_line_debug_info ()</span>
<span class="lineNum">   27844 </span><span class="lineCov">     430291 :           &amp;&amp; table &amp;&amp; !RESETTING_VIEW_P (table-&gt;view))</span>
<span class="lineNum">   27845 </span>            :         {
<span class="lineNum">   27846 </span>            :           /* If we're using the assembler to compute view numbers, we
<span class="lineNum">   27847 </span>            :              can't issue a .loc directive for line zero, so we can't
<span class="lineNum">   27848 </span>            :              get a view number at this point.  We might attempt to
<span class="lineNum">   27849 </span>            :              compute it from the previous view, or equate it to a
<span class="lineNum">   27850 </span>            :              subsequent view (though it might not be there!), but
<span class="lineNum">   27851 </span>            :              since we're omitting the line number entry, we might as
<span class="lineNum">   27852 </span>            :              well omit the view number as well.  That means pretending
<span class="lineNum">   27853 </span>            :              it's a view number zero, which might very well turn out
<span class="lineNum">   27854 </span>            :              to be correct.  ??? Extend the assembler so that the
<span class="lineNum">   27855 </span>            :              compiler could emit e.g. &quot;.locview .LVU#&quot;, to output a
<span class="lineNum">   27856 </span>            :              view without changing line number information.  We'd then
<span class="lineNum">   27857 </span>            :              have to count it in symviews_since_reset; when it's omitted,
<span class="lineNum">   27858 </span>            :              it doesn't count.  */
<span class="lineNum">   27859 </span><span class="lineCov">       1908 :           if (!zero_view_p)</span>
<span class="lineNum">   27860 </span><span class="lineNoCov">          0 :             zero_view_p = BITMAP_GGC_ALLOC ();</span>
<span class="lineNum">   27861 </span><span class="lineCov">       1908 :           bitmap_set_bit (zero_view_p, table-&gt;view);</span>
<span class="lineNum">   27862 </span><span class="lineCov">       1908 :           if (flag_debug_asm)</span>
<span class="lineNum">   27863 </span>            :             {
<span class="lineNum">   27864 </span><span class="lineNoCov">          0 :               char label[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">   27865 </span><span class="lineNoCov">          0 :               ASM_GENERATE_INTERNAL_LABEL (label, &quot;LVU&quot;, table-&gt;view);</span>
<span class="lineNum">   27866 </span><span class="lineNoCov">          0 :               fprintf (asm_out_file, &quot;\t%s line 0, omitted view &quot;,</span>
<span class="lineNum">   27867 </span>            :                        ASM_COMMENT_START);
<span class="lineNum">   27868 </span><span class="lineNoCov">          0 :               assemble_name (asm_out_file, label);</span>
<span class="lineNum">   27869 </span><span class="lineNoCov">          0 :               putc ('\n', asm_out_file);</span>
<span class="lineNum">   27870 </span>            :             }
<span class="lineNum">   27871 </span><span class="lineCov">       1908 :           table-&gt;view = ++lvugid;</span>
<span class="lineNum">   27872 </span>            :         }
<span class="lineNum">   27873 </span><span class="lineCov">     219315 :       return;</span>
<span class="lineNum">   27874 </span>            :     }
<span class="lineNum">   27875 </span>            : 
<span class="lineNum">   27876 </span>            :   /* The discriminator column was added in dwarf4.  Simplify the below
<span class="lineNum">   27877 </span>            :      by simply removing it if we're not supposed to output it.  */
<span class="lineNum">   27878 </span><span class="lineCov">   17779719 :   if (dwarf_version &lt; 4 &amp;&amp; dwarf_strict)</span>
<span class="lineNum">   27879 </span><span class="lineNoCov">          0 :     discriminator = 0;</span>
<span class="lineNum">   27880 </span>            : 
<span class="lineNum">   27881 </span><span class="lineCov">   17779719 :   if (!debug_column_info)</span>
<span class="lineNum">   27882 </span><span class="lineCov">         68 :     column = 0;</span>
<span class="lineNum">   27883 </span>            : 
<span class="lineNum">   27884 </span><span class="lineCov">   17779719 :   file_num = maybe_emit_file (lookup_filename (filename));</span>
<span class="lineNum">   27885 </span>            : 
<span class="lineNum">   27886 </span>            :   /* ??? TODO: Elide duplicate line number entries.  Traditionally,
<span class="lineNum">   27887 </span>            :      the debugger has used the second (possibly duplicate) line number
<span class="lineNum">   27888 </span>            :      at the beginning of the function to mark the end of the prologue.
<span class="lineNum">   27889 </span>            :      We could eliminate any other duplicates within the function.  For
<span class="lineNum">   27890 </span>            :      Dwarf3, we ought to include the DW_LNS_set_prologue_end mark in
<span class="lineNum">   27891 </span>            :      that second line number entry.  */
<span class="lineNum">   27892 </span>            :   /* Recall that this end-of-prologue indication is *not* the same thing
<span class="lineNum">   27893 </span>            :      as the end_prologue debug hook.  The NOTE_INSN_PROLOGUE_END note,
<span class="lineNum">   27894 </span>            :      to which the hook corresponds, follows the last insn that was 
<span class="lineNum">   27895 </span>            :      emitted by gen_prologue.  What we need is to precede the first insn
<span class="lineNum">   27896 </span>            :      that had been emitted after NOTE_INSN_FUNCTION_BEG, i.e. the first
<span class="lineNum">   27897 </span>            :      insn that corresponds to something the user wrote.  These may be
<span class="lineNum">   27898 </span>            :      very different locations once scheduling is enabled.  */
<span class="lineNum">   27899 </span>            : 
<span class="lineNum">   27900 </span><span class="lineCov">   17779719 :   if (0 &amp;&amp; file_num == table-&gt;file_num</span>
<span class="lineNum">   27901 </span>            :       &amp;&amp; line == table-&gt;line_num
<span class="lineNum">   27902 </span>            :       &amp;&amp; column == table-&gt;column_num
<span class="lineNum">   27903 </span>            :       &amp;&amp; discriminator == table-&gt;discrim_num
<span class="lineNum">   27904 </span>            :       &amp;&amp; is_stmt == table-&gt;is_stmt)
<span class="lineNum">   27905 </span>            :     return;
<span class="lineNum">   27906 </span>            : 
<span class="lineNum">   27907 </span><span class="lineCov">   17779719 :   switch_to_section (current_function_section ());</span>
<span class="lineNum">   27908 </span>            : 
<span class="lineNum">   27909 </span>            :   /* If requested, emit something human-readable.  */
<span class="lineNum">   27910 </span><span class="lineCov">   17779719 :   if (flag_debug_asm)</span>
<span class="lineNum">   27911 </span>            :     {
<span class="lineNum">   27912 </span><span class="lineCov">       5020 :       if (debug_column_info)</span>
<span class="lineNum">   27913 </span><span class="lineCov">       4975 :         fprintf (asm_out_file, &quot;\t%s %s:%d:%d\n&quot;, ASM_COMMENT_START,</span>
<span class="lineNum">   27914 </span>            :                  filename, line, column);
<span class="lineNum">   27915 </span>            :       else
<span class="lineNum">   27916 </span><span class="lineCov">         45 :         fprintf (asm_out_file, &quot;\t%s %s:%d\n&quot;, ASM_COMMENT_START,</span>
<span class="lineNum">   27917 </span>            :                  filename, line);
<span class="lineNum">   27918 </span>            :     }
<span class="lineNum">   27919 </span>            : 
<span class="lineNum">   27920 </span><span class="lineCov">   17779719 :   if (output_asm_line_debug_info ())</span>
<span class="lineNum">   27921 </span>            :     {
<span class="lineNum">   27922 </span>            :       /* Emit the .loc directive understood by GNU as.  */
<span class="lineNum">   27923 </span>            :       /* &quot;\t.loc %u %u 0 is_stmt %u discriminator %u&quot;,
<span class="lineNum">   27924 </span>            :          file_num, line, is_stmt, discriminator */
<span class="lineNum">   27925 </span><span class="lineCov">   17779719 :       fputs (&quot;\t.loc &quot;, asm_out_file);</span>
<span class="lineNum">   27926 </span><span class="lineCov">   17779719 :       fprint_ul (asm_out_file, file_num);</span>
<span class="lineNum">   27927 </span><span class="lineCov">   17779719 :       putc (' ', asm_out_file);</span>
<span class="lineNum">   27928 </span><span class="lineCov">   17779719 :       fprint_ul (asm_out_file, line);</span>
<span class="lineNum">   27929 </span><span class="lineCov">   17779719 :       putc (' ', asm_out_file);</span>
<span class="lineNum">   27930 </span><span class="lineCov">   17779719 :       fprint_ul (asm_out_file, column);</span>
<span class="lineNum">   27931 </span>            : 
<span class="lineNum">   27932 </span><span class="lineCov">   17779719 :       if (is_stmt != table-&gt;is_stmt)</span>
<span class="lineNum">   27933 </span>            :         {
<span class="lineNum">   27934 </span>            : #if HAVE_GAS_LOC_STMT
<span class="lineNum">   27935 </span><span class="lineCov">    6972876 :           fputs (&quot; is_stmt &quot;, asm_out_file);</span>
<span class="lineNum">   27936 </span><span class="lineCov">   10471419 :           putc (is_stmt ? '1' : '0', asm_out_file);</span>
<span class="lineNum">   27937 </span>            : #endif
<span class="lineNum">   27938 </span>            :         }
<span class="lineNum">   27939 </span><span class="lineCov">   17779719 :       if (SUPPORTS_DISCRIMINATOR &amp;&amp; discriminator != 0)</span>
<span class="lineNum">   27940 </span>            :         {
<span class="lineNum">   27941 </span><span class="lineCov">    2250706 :           gcc_assert (discriminator &gt; 0);</span>
<span class="lineNum">   27942 </span><span class="lineCov">    2250706 :           fputs (&quot; discriminator &quot;, asm_out_file);</span>
<span class="lineNum">   27943 </span><span class="lineCov">    2250706 :           fprint_ul (asm_out_file, (unsigned long) discriminator);</span>
<span class="lineNum">   27944 </span>            :         }
<span class="lineNum">   27945 </span><span class="lineCov">   17779719 :       if (debug_variable_location_views)</span>
<span class="lineNum">   27946 </span>            :         {
<span class="lineNum">   27947 </span><span class="lineCov">   17305343 :           if (!RESETTING_VIEW_P (table-&gt;view))</span>
<span class="lineNum">   27948 </span>            :             {
<span class="lineNum">   27949 </span><span class="lineCov">   17032386 :               table-&gt;symviews_since_reset++;</span>
<span class="lineNum">   27950 </span><span class="lineCov">   17032386 :               if (table-&gt;symviews_since_reset &gt; symview_upper_bound)</span>
<span class="lineNum">   27951 </span><span class="lineCov">    4025331 :                 symview_upper_bound = table-&gt;symviews_since_reset;</span>
<span class="lineNum">   27952 </span>            :               /* When we're using the assembler to compute view
<span class="lineNum">   27953 </span>            :                  numbers, we output symbolic labels after &quot;view&quot; in
<span class="lineNum">   27954 </span>            :                  .loc directives, and the assembler will set them for
<span class="lineNum">   27955 </span>            :                  us, so that we can refer to the view numbers in
<span class="lineNum">   27956 </span>            :                  location lists.  The only exceptions are when we know
<span class="lineNum">   27957 </span>            :                  a view will be zero: &quot;-0&quot; is a forced reset, used
<span class="lineNum">   27958 </span>            :                  e.g. in the beginning of functions, whereas &quot;0&quot; tells
<span class="lineNum">   27959 </span>            :                  the assembler to check that there was a PC change
<span class="lineNum">   27960 </span>            :                  since the previous view, in a way that implicitly
<span class="lineNum">   27961 </span>            :                  resets the next view.  */
<span class="lineNum">   27962 </span><span class="lineCov">   17032386 :               fputs (&quot; view &quot;, asm_out_file);</span>
<span class="lineNum">   27963 </span><span class="lineCov">   17032386 :               char label[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">   27964 </span><span class="lineCov">   17032386 :               ASM_GENERATE_INTERNAL_LABEL (label, &quot;LVU&quot;, table-&gt;view);</span>
<span class="lineNum">   27965 </span><span class="lineCov">   17032386 :               assemble_name (asm_out_file, label);</span>
<span class="lineNum">   27966 </span><span class="lineCov">   17032386 :               table-&gt;view = ++lvugid;</span>
<span class="lineNum">   27967 </span>            :             }
<span class="lineNum">   27968 </span>            :           else
<span class="lineNum">   27969 </span>            :             {
<span class="lineNum">   27970 </span><span class="lineCov">     272957 :               table-&gt;symviews_since_reset = 0;</span>
<span class="lineNum">   27971 </span><span class="lineCov">     272957 :               if (FORCE_RESETTING_VIEW_P (table-&gt;view))</span>
<span class="lineNum">   27972 </span><span class="lineCov">     272957 :                 fputs (&quot; view -0&quot;, asm_out_file);</span>
<span class="lineNum">   27973 </span>            :               else
<span class="lineNum">   27974 </span><span class="lineNoCov">          0 :                 fputs (&quot; view 0&quot;, asm_out_file);</span>
<span class="lineNum">   27975 </span>            :               /* Mark the present view as a zero view.  Earlier debug
<span class="lineNum">   27976 </span>            :                  binds may have already added its id to loclists to be
<span class="lineNum">   27977 </span>            :                  emitted later, so we can't reuse the id for something
<span class="lineNum">   27978 </span>            :                  else.  However, it's good to know whether a view is
<span class="lineNum">   27979 </span>            :                  known to be zero, because then we may be able to
<span class="lineNum">   27980 </span>            :                  optimize out locviews that are all zeros, so take
<span class="lineNum">   27981 </span>            :                  note of it in zero_view_p.  */
<span class="lineNum">   27982 </span><span class="lineCov">     272957 :               if (!zero_view_p)</span>
<span class="lineNum">   27983 </span><span class="lineCov">      28634 :                 zero_view_p = BITMAP_GGC_ALLOC ();</span>
<span class="lineNum">   27984 </span><span class="lineCov">     272957 :               bitmap_set_bit (zero_view_p, lvugid);</span>
<span class="lineNum">   27985 </span><span class="lineCov">     272957 :               table-&gt;view = ++lvugid;</span>
<span class="lineNum">   27986 </span>            :             }
<span class="lineNum">   27987 </span>            :         }
<span class="lineNum">   27988 </span><span class="lineCov">   17779719 :       putc ('\n', asm_out_file);</span>
<span class="lineNum">   27989 </span>            :     }
<span class="lineNum">   27990 </span>            :   else
<span class="lineNum">   27991 </span>            :     {
<span class="lineNum">   27992 </span><span class="lineNoCov">          0 :       unsigned int label_num = ++line_info_label_num;</span>
<span class="lineNum">   27993 </span>            : 
<span class="lineNum">   27994 </span><span class="lineNoCov">          0 :       targetm.asm_out.internal_label (asm_out_file, LINE_CODE_LABEL, label_num);</span>
<span class="lineNum">   27995 </span>            : 
<span class="lineNum">   27996 </span><span class="lineNoCov">          0 :       if (debug_variable_location_views &amp;&amp; !RESETTING_VIEW_P (table-&gt;view))</span>
<span class="lineNum">   27997 </span><span class="lineNoCov">          0 :         push_dw_line_info_entry (table, LI_adv_address, label_num);</span>
<span class="lineNum">   27998 </span>            :       else
<span class="lineNum">   27999 </span><span class="lineNoCov">          0 :         push_dw_line_info_entry (table, LI_set_address, label_num);</span>
<span class="lineNum">   28000 </span><span class="lineNoCov">          0 :       if (debug_variable_location_views)</span>
<span class="lineNum">   28001 </span>            :         {
<span class="lineNum">   28002 </span><span class="lineNoCov">          0 :           bool resetting = FORCE_RESETTING_VIEW_P (table-&gt;view);</span>
<span class="lineNum">   28003 </span><span class="lineNoCov">          0 :           if (resetting)</span>
<span class="lineNum">   28004 </span><span class="lineNoCov">          0 :             table-&gt;view = 0;</span>
<span class="lineNum">   28005 </span>            : 
<span class="lineNum">   28006 </span><span class="lineNoCov">          0 :           if (flag_debug_asm)</span>
<span class="lineNum">   28007 </span><span class="lineNoCov">          0 :             fprintf (asm_out_file, &quot;\t%s view %s%d\n&quot;,</span>
<span class="lineNum">   28008 </span>            :                      ASM_COMMENT_START,
<span class="lineNum">   28009 </span>            :                      resetting ? &quot;-&quot; : &quot;&quot;,
<span class="lineNum">   28010 </span>            :                      table-&gt;view);
<span class="lineNum">   28011 </span>            : 
<span class="lineNum">   28012 </span><span class="lineNoCov">          0 :           table-&gt;view++;</span>
<span class="lineNum">   28013 </span>            :         }
<span class="lineNum">   28014 </span><span class="lineNoCov">          0 :       if (file_num != table-&gt;file_num)</span>
<span class="lineNum">   28015 </span><span class="lineNoCov">          0 :         push_dw_line_info_entry (table, LI_set_file, file_num);</span>
<span class="lineNum">   28016 </span><span class="lineNoCov">          0 :       if (discriminator != table-&gt;discrim_num)</span>
<span class="lineNum">   28017 </span><span class="lineNoCov">          0 :         push_dw_line_info_entry (table, LI_set_discriminator, discriminator);</span>
<span class="lineNum">   28018 </span><span class="lineNoCov">          0 :       if (is_stmt != table-&gt;is_stmt)</span>
<span class="lineNum">   28019 </span><span class="lineNoCov">          0 :         push_dw_line_info_entry (table, LI_negate_stmt, 0);</span>
<span class="lineNum">   28020 </span><span class="lineNoCov">          0 :       push_dw_line_info_entry (table, LI_set_line, line);</span>
<span class="lineNum">   28021 </span><span class="lineNoCov">          0 :       if (debug_column_info)</span>
<span class="lineNum">   28022 </span><span class="lineNoCov">          0 :         push_dw_line_info_entry (table, LI_set_column, column);</span>
<span class="lineNum">   28023 </span>            :     }
<span class="lineNum">   28024 </span>            : 
<span class="lineNum">   28025 </span><span class="lineCov">   17779719 :   table-&gt;file_num = file_num;</span>
<span class="lineNum">   28026 </span><span class="lineCov">   17779719 :   table-&gt;line_num = line;</span>
<span class="lineNum">   28027 </span><span class="lineCov">   17779719 :   table-&gt;column_num = column;</span>
<span class="lineNum">   28028 </span><span class="lineCov">   17779719 :   table-&gt;discrim_num = discriminator;</span>
<span class="lineNum">   28029 </span><span class="lineCov">   17779719 :   table-&gt;is_stmt = is_stmt;</span>
<span class="lineNum">   28030 </span><span class="lineCov">   17779719 :   table-&gt;in_use = true;</span>
<span class="lineNum">   28031 </span>            : }
<span class="lineNum">   28032 </span>            : 
<span class="lineNum">   28033 </span>            : /* Record the beginning of a new source file.  */
<a name="28034"><span class="lineNum">   28034 </span>            : </a>
<span class="lineNum">   28035 </span>            : static void
<span class="lineNum">   28036 </span><span class="lineCov">    1118685 : dwarf2out_start_source_file (unsigned int lineno, const char *filename)</span>
<span class="lineNum">   28037 </span>            : {
<span class="lineNum">   28038 </span><span class="lineCov">    1118685 :   if (debug_info_level &gt;= DINFO_LEVEL_VERBOSE)</span>
<span class="lineNum">   28039 </span>            :     {
<span class="lineNum">   28040 </span><span class="lineCov">       1574 :       macinfo_entry e;</span>
<span class="lineNum">   28041 </span><span class="lineCov">       1574 :       e.code = DW_MACINFO_start_file;</span>
<span class="lineNum">   28042 </span><span class="lineCov">       1574 :       e.lineno = lineno;</span>
<span class="lineNum">   28043 </span><span class="lineCov">       1574 :       e.info = ggc_strdup (filename);</span>
<span class="lineNum">   28044 </span><span class="lineCov">       1574 :       vec_safe_push (macinfo_table, e);</span>
<span class="lineNum">   28045 </span>            :     }
<span class="lineNum">   28046 </span><span class="lineCov">    1118685 : }</span>
<span class="lineNum">   28047 </span>            : 
<span class="lineNum">   28048 </span>            : /* Record the end of a source file.  */
<a name="28049"><span class="lineNum">   28049 </span>            : </a>
<span class="lineNum">   28050 </span>            : static void
<span class="lineNum">   28051 </span><span class="lineCov">    1118616 : dwarf2out_end_source_file (unsigned int lineno ATTRIBUTE_UNUSED)</span>
<span class="lineNum">   28052 </span>            : {
<span class="lineNum">   28053 </span><span class="lineCov">    1118616 :   if (debug_info_level &gt;= DINFO_LEVEL_VERBOSE)</span>
<span class="lineNum">   28054 </span>            :     {
<span class="lineNum">   28055 </span><span class="lineCov">       1574 :       macinfo_entry e;</span>
<span class="lineNum">   28056 </span><span class="lineCov">       1574 :       e.code = DW_MACINFO_end_file;</span>
<span class="lineNum">   28057 </span><span class="lineCov">       1574 :       e.lineno = lineno;</span>
<span class="lineNum">   28058 </span><span class="lineCov">       1574 :       e.info = NULL;</span>
<span class="lineNum">   28059 </span><span class="lineCov">       1574 :       vec_safe_push (macinfo_table, e);</span>
<span class="lineNum">   28060 </span>            :     }
<span class="lineNum">   28061 </span><span class="lineCov">    1118616 : }</span>
<span class="lineNum">   28062 </span>            : 
<span class="lineNum">   28063 </span>            : /* Called from debug_define in toplev.c.  The `buffer' parameter contains
<span class="lineNum">   28064 </span>            :    the tail part of the directive line, i.e. the part which is past the
<span class="lineNum">   28065 </span>            :    initial whitespace, #, whitespace, directive-name, whitespace part.  */
<a name="28066"><span class="lineNum">   28066 </span>            : </a>
<span class="lineNum">   28067 </span>            : static void
<span class="lineNum">   28068 </span><span class="lineCov">     168979 : dwarf2out_define (unsigned int lineno ATTRIBUTE_UNUSED,</span>
<span class="lineNum">   28069 </span>            :                   const char *buffer ATTRIBUTE_UNUSED)
<span class="lineNum">   28070 </span>            : {
<span class="lineNum">   28071 </span><span class="lineCov">     168979 :   if (debug_info_level &gt;= DINFO_LEVEL_VERBOSE)</span>
<span class="lineNum">   28072 </span>            :     {
<span class="lineNum">   28073 </span><span class="lineCov">     168979 :       macinfo_entry e;</span>
<span class="lineNum">   28074 </span>            :       /* Insert a dummy first entry to be able to optimize the whole
<span class="lineNum">   28075 </span>            :          predefined macro block using DW_MACRO_import.  */
<span class="lineNum">   28076 </span><span class="lineCov">     168979 :       if (macinfo_table-&gt;is_empty () &amp;&amp; lineno &lt;= 1)</span>
<span class="lineNum">   28077 </span>            :         {
<span class="lineNum">   28078 </span><span class="lineCov">        442 :           e.code = 0;</span>
<span class="lineNum">   28079 </span><span class="lineCov">        442 :           e.lineno = 0;</span>
<span class="lineNum">   28080 </span><span class="lineCov">        442 :           e.info = NULL;</span>
<span class="lineNum">   28081 </span><span class="lineCov">        442 :           vec_safe_push (macinfo_table, e);</span>
<span class="lineNum">   28082 </span>            :         }
<span class="lineNum">   28083 </span><span class="lineCov">     168979 :       e.code = DW_MACINFO_define;</span>
<span class="lineNum">   28084 </span><span class="lineCov">     168979 :       e.lineno = lineno;</span>
<span class="lineNum">   28085 </span><span class="lineCov">     168979 :       e.info = ggc_strdup (buffer);</span>
<span class="lineNum">   28086 </span><span class="lineCov">     168979 :       vec_safe_push (macinfo_table, e);</span>
<span class="lineNum">   28087 </span>            :     }
<span class="lineNum">   28088 </span><span class="lineCov">     168979 : }</span>
<span class="lineNum">   28089 </span>            : 
<span class="lineNum">   28090 </span>            : /* Called from debug_undef in toplev.c.  The `buffer' parameter contains
<span class="lineNum">   28091 </span>            :    the tail part of the directive line, i.e. the part which is past the
<span class="lineNum">   28092 </span>            :    initial whitespace, #, whitespace, directive-name, whitespace part.  */
<a name="28093"><span class="lineNum">   28093 </span>            : </a>
<span class="lineNum">   28094 </span>            : static void
<span class="lineNum">   28095 </span><span class="lineCov">        681 : dwarf2out_undef (unsigned int lineno ATTRIBUTE_UNUSED,</span>
<span class="lineNum">   28096 </span>            :                  const char *buffer ATTRIBUTE_UNUSED)
<span class="lineNum">   28097 </span>            : {
<span class="lineNum">   28098 </span><span class="lineCov">        681 :   if (debug_info_level &gt;= DINFO_LEVEL_VERBOSE)</span>
<span class="lineNum">   28099 </span>            :     {
<span class="lineNum">   28100 </span><span class="lineCov">        681 :       macinfo_entry e;</span>
<span class="lineNum">   28101 </span>            :       /* Insert a dummy first entry to be able to optimize the whole
<span class="lineNum">   28102 </span>            :          predefined macro block using DW_MACRO_import.  */
<span class="lineNum">   28103 </span><span class="lineCov">        681 :       if (macinfo_table-&gt;is_empty () &amp;&amp; lineno &lt;= 1)</span>
<span class="lineNum">   28104 </span>            :         {
<span class="lineNum">   28105 </span><span class="lineNoCov">          0 :           e.code = 0;</span>
<span class="lineNum">   28106 </span><span class="lineNoCov">          0 :           e.lineno = 0;</span>
<span class="lineNum">   28107 </span><span class="lineNoCov">          0 :           e.info = NULL;</span>
<span class="lineNum">   28108 </span><span class="lineNoCov">          0 :           vec_safe_push (macinfo_table, e);</span>
<span class="lineNum">   28109 </span>            :         }
<span class="lineNum">   28110 </span><span class="lineCov">        681 :       e.code = DW_MACINFO_undef;</span>
<span class="lineNum">   28111 </span><span class="lineCov">        681 :       e.lineno = lineno;</span>
<span class="lineNum">   28112 </span><span class="lineCov">        681 :       e.info = ggc_strdup (buffer);</span>
<span class="lineNum">   28113 </span><span class="lineCov">        681 :       vec_safe_push (macinfo_table, e);</span>
<span class="lineNum">   28114 </span>            :     }
<span class="lineNum">   28115 </span><span class="lineCov">        681 : }</span>
<span class="lineNum">   28116 </span>            : 
<span class="lineNum">   28117 </span>            : /* Helpers to manipulate hash table of CUs.  */
<span class="lineNum">   28118 </span>            : 
<span class="lineNum">   28119 </span>            : struct macinfo_entry_hasher : nofree_ptr_hash &lt;macinfo_entry&gt;
<span class="lineNum">   28120 </span>            : {
<span class="lineNum">   28121 </span>            :   static inline hashval_t hash (const macinfo_entry *);
<span class="lineNum">   28122 </span>            :   static inline bool equal (const macinfo_entry *, const macinfo_entry *);
<span class="lineNum">   28123 </span>            : };
<a name="28124"><span class="lineNum">   28124 </span>            : </a>
<span class="lineNum">   28125 </span>            : inline hashval_t
<span class="lineNum">   28126 </span><span class="lineNoCov">          0 : macinfo_entry_hasher::hash (const macinfo_entry *entry)</span>
<span class="lineNum">   28127 </span>            : {
<span class="lineNum">   28128 </span><span class="lineCov">       1930 :   return htab_hash_string (entry-&gt;info);</span>
<span class="lineNum">   28129 </span>            : }
<a name="28130"><span class="lineNum">   28130 </span>            : </a>
<span class="lineNum">   28131 </span>            : inline bool
<span class="lineNum">   28132 </span><span class="lineNoCov">          0 : macinfo_entry_hasher::equal (const macinfo_entry *entry1,</span>
<span class="lineNum">   28133 </span>            :                              const macinfo_entry *entry2)
<span class="lineNum">   28134 </span>            : {
<span class="lineNum">   28135 </span><span class="lineCov">        525 :   return !strcmp (entry1-&gt;info, entry2-&gt;info);</span>
<span class="lineNum">   28136 </span>            : }
<span class="lineNum">   28137 </span>            : 
<span class="lineNum">   28138 </span>            : typedef hash_table&lt;macinfo_entry_hasher&gt; macinfo_hash_type;
<span class="lineNum">   28139 </span>            : 
<span class="lineNum">   28140 </span>            : /* Output a single .debug_macinfo entry.  */
<a name="28141"><span class="lineNum">   28141 </span>            : </a>
<span class="lineNum">   28142 </span>            : static void
<span class="lineNum">   28143 </span><span class="lineCov">     338564 : output_macinfo_op (macinfo_entry *ref)</span>
<span class="lineNum">   28144 </span>            : {
<span class="lineNum">   28145 </span><span class="lineCov">     338564 :   int file_num;</span>
<span class="lineNum">   28146 </span><span class="lineCov">     338564 :   size_t len;</span>
<span class="lineNum">   28147 </span><span class="lineCov">     338564 :   struct indirect_string_node *node;</span>
<span class="lineNum">   28148 </span><span class="lineCov">     338564 :   char label[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">   28149 </span><span class="lineCov">     338564 :   struct dwarf_file_data *fd;</span>
<span class="lineNum">   28150 </span>            : 
<span class="lineNum">   28151 </span><span class="lineCov">     338564 :   switch (ref-&gt;code)</span>
<span class="lineNum">   28152 </span>            :     {
<span class="lineNum">   28153 </span><span class="lineCov">       1562 :     case DW_MACINFO_start_file:</span>
<span class="lineNum">   28154 </span><span class="lineCov">       1562 :       fd = lookup_filename (ref-&gt;info);</span>
<span class="lineNum">   28155 </span><span class="lineCov">       1562 :       file_num = maybe_emit_file (fd);</span>
<span class="lineNum">   28156 </span><span class="lineCov">       1562 :       dw2_asm_output_data (1, DW_MACINFO_start_file, &quot;Start new file&quot;);</span>
<span class="lineNum">   28157 </span><span class="lineCov">       3124 :       dw2_asm_output_data_uleb128 (ref-&gt;lineno,</span>
<span class="lineNum">   28158 </span>            :                                    &quot;Included from line number %lu&quot;, 
<span class="lineNum">   28159 </span><span class="lineCov">       1562 :                                    (unsigned long) ref-&gt;lineno);</span>
<span class="lineNum">   28160 </span><span class="lineCov">       1562 :       dw2_asm_output_data_uleb128 (file_num, &quot;file %s&quot;, ref-&gt;info);</span>
<span class="lineNum">   28161 </span><span class="lineCov">       1562 :       break;</span>
<span class="lineNum">   28162 </span><span class="lineCov">       1562 :     case DW_MACINFO_end_file:</span>
<span class="lineNum">   28163 </span><span class="lineCov">       1562 :       dw2_asm_output_data (1, DW_MACINFO_end_file, &quot;End file&quot;);</span>
<span class="lineNum">   28164 </span><span class="lineCov">       1562 :       break;</span>
<span class="lineNum">   28165 </span><span class="lineCov">     167000 :     case DW_MACINFO_define:</span>
<span class="lineNum">   28166 </span><span class="lineCov">     167000 :     case DW_MACINFO_undef:</span>
<span class="lineNum">   28167 </span><span class="lineCov">     167000 :       len = strlen (ref-&gt;info) + 1;</span>
<span class="lineNum">   28168 </span><span class="lineCov">     167000 :       if (!dwarf_strict</span>
<span class="lineNum">   28169 </span><span class="lineCov">     167000 :           &amp;&amp; len &gt; DWARF_OFFSET_SIZE</span>
<span class="lineNum">   28170 </span>            :           &amp;&amp; !DWARF2_INDIRECT_STRING_SUPPORT_MISSING_ON_TARGET
<span class="lineNum">   28171 </span><span class="lineCov">     166990 :           &amp;&amp; (debug_str_section-&gt;common.flags &amp; SECTION_MERGE) != 0)</span>
<span class="lineNum">   28172 </span>            :         {
<span class="lineNum">   28173 </span><span class="lineCov">     166990 :           ref-&gt;code = ref-&gt;code == DW_MACINFO_define</span>
<span class="lineNum">   28174 </span>            :                       ? DW_MACRO_define_strp : DW_MACRO_undef_strp;
<span class="lineNum">   28175 </span><span class="lineCov">     166990 :           output_macinfo_op (ref);</span>
<span class="lineNum">   28176 </span><span class="lineCov">     166990 :           return;</span>
<span class="lineNum">   28177 </span>            :         }
<span class="lineNum">   28178 </span><span class="lineCov">         18 :       dw2_asm_output_data (1, ref-&gt;code,</span>
<span class="lineNum">   28179 </span>            :                            ref-&gt;code == DW_MACINFO_define
<span class="lineNum">   28180 </span>            :                            ? &quot;Define macro&quot; : &quot;Undefine macro&quot;);
<span class="lineNum">   28181 </span><span class="lineCov">         20 :       dw2_asm_output_data_uleb128 (ref-&gt;lineno, &quot;At line number %lu&quot;, </span>
<span class="lineNum">   28182 </span><span class="lineCov">         10 :                                    (unsigned long) ref-&gt;lineno);</span>
<span class="lineNum">   28183 </span><span class="lineCov">         10 :       dw2_asm_output_nstring (ref-&gt;info, -1, &quot;The macro&quot;);</span>
<span class="lineNum">   28184 </span><span class="lineCov">         10 :       break;</span>
<span class="lineNum">   28185 </span><span class="lineCov">     166990 :     case DW_MACRO_define_strp:</span>
<span class="lineNum">   28186 </span><span class="lineCov">     166990 :     case DW_MACRO_undef_strp:</span>
<span class="lineNum">   28187 </span><span class="lineCov">     166990 :       node = find_AT_string (ref-&gt;info);</span>
<span class="lineNum">   28188 </span><span class="lineCov">     167710 :       gcc_assert (node</span>
<span class="lineNum">   28189 </span>            :                   &amp;&amp; (node-&gt;form == DW_FORM_strp
<span class="lineNum">   28190 </span>            :                       || node-&gt;form == dwarf_FORM (DW_FORM_strx)));
<span class="lineNum">   28191 </span><span class="lineCov">     166990 :       dw2_asm_output_data (1, ref-&gt;code,</span>
<span class="lineNum">   28192 </span><span class="lineCov">     166990 :                            ref-&gt;code == DW_MACRO_define_strp</span>
<span class="lineNum">   28193 </span>            :                            ? &quot;Define macro strp&quot;
<span class="lineNum">   28194 </span>            :                            : &quot;Undefine macro strp&quot;);
<span class="lineNum">   28195 </span><span class="lineCov">     333980 :       dw2_asm_output_data_uleb128 (ref-&gt;lineno, &quot;At line number %lu&quot;,</span>
<span class="lineNum">   28196 </span><span class="lineCov">     166990 :                                    (unsigned long) ref-&gt;lineno);</span>
<span class="lineNum">   28197 </span><span class="lineCov">     166990 :       if (node-&gt;form == DW_FORM_strp)</span>
<span class="lineNum">   28198 </span><span class="lineCov">     166270 :         dw2_asm_output_offset (DWARF_OFFSET_SIZE, node-&gt;label,</span>
<span class="lineNum">   28199 </span>            :                                debug_str_section, &quot;The macro: \&quot;%s\&quot;&quot;,
<span class="lineNum">   28200 </span>            :                                ref-&gt;info);
<span class="lineNum">   28201 </span>            :       else
<span class="lineNum">   28202 </span><span class="lineCov">        720 :         dw2_asm_output_data_uleb128 (node-&gt;index, &quot;The macro: \&quot;%s\&quot;&quot;,</span>
<span class="lineNum">   28203 </span>            :                                      ref-&gt;info);
<span class="lineNum">   28204 </span>            :       break;
<span class="lineNum">   28205 </span><span class="lineCov">       1450 :     case DW_MACRO_import:</span>
<span class="lineNum">   28206 </span><span class="lineCov">       1450 :       dw2_asm_output_data (1, ref-&gt;code, &quot;Import&quot;);</span>
<span class="lineNum">   28207 </span><span class="lineCov">       1450 :       ASM_GENERATE_INTERNAL_LABEL (label,</span>
<span class="lineNum">   28208 </span>            :                                    DEBUG_MACRO_SECTION_LABEL,
<span class="lineNum">   28209 </span>            :                                    ref-&gt;lineno + macinfo_label_base);
<span class="lineNum">   28210 </span><span class="lineCov">       1450 :       dw2_asm_output_offset (DWARF_OFFSET_SIZE, label, NULL, NULL);</span>
<span class="lineNum">   28211 </span><span class="lineCov">       1450 :       break;</span>
<span class="lineNum">   28212 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">   28213 </span><span class="lineNoCov">          0 :       fprintf (asm_out_file, &quot;%s unrecognized macinfo code %lu\n&quot;,</span>
<span class="lineNum">   28214 </span>            :                ASM_COMMENT_START, (unsigned long) ref-&gt;code);
<span class="lineNum">   28215 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">   28216 </span>            :     }
<span class="lineNum">   28217 </span>            : }
<span class="lineNum">   28218 </span>            : 
<span class="lineNum">   28219 </span>            : /* Attempt to make a sequence of define/undef macinfo ops shareable with
<span class="lineNum">   28220 </span>            :    other compilation unit .debug_macinfo sections.  IDX is the first
<span class="lineNum">   28221 </span>            :    index of a define/undef, return the number of ops that should be
<span class="lineNum">   28222 </span>            :    emitted in a comdat .debug_macinfo section and emit
<span class="lineNum">   28223 </span>            :    a DW_MACRO_import entry referencing it.
<span class="lineNum">   28224 </span>            :    If the define/undef entry should be emitted normally, return 0.  */
<a name="28225"><span class="lineNum">   28225 </span>            : </a>
<span class="lineNum">   28226 </span>            : static unsigned
<span class="lineNum">   28227 </span><span class="lineCov">       1774 : optimize_macinfo_range (unsigned int idx, vec&lt;macinfo_entry, va_gc&gt; *files,</span>
<span class="lineNum">   28228 </span>            :                         macinfo_hash_type **macinfo_htab)
<span class="lineNum">   28229 </span>            : {
<span class="lineNum">   28230 </span><span class="lineCov">       1774 :   macinfo_entry *first, *second, *cur, *inc;</span>
<span class="lineNum">   28231 </span><span class="lineCov">       1774 :   char linebuf[sizeof (HOST_WIDE_INT) * 3 + 1];</span>
<span class="lineNum">   28232 </span><span class="lineCov">       1774 :   unsigned char checksum[16];</span>
<span class="lineNum">   28233 </span><span class="lineCov">       1774 :   struct md5_ctx ctx;</span>
<span class="lineNum">   28234 </span><span class="lineCov">       1774 :   char *grp_name, *tail;</span>
<span class="lineNum">   28235 </span><span class="lineCov">       1774 :   const char *base;</span>
<span class="lineNum">   28236 </span><span class="lineCov">       1774 :   unsigned int i, count, encoded_filename_len, linebuf_len;</span>
<span class="lineNum">   28237 </span><span class="lineCov">       1774 :   macinfo_entry **slot;</span>
<span class="lineNum">   28238 </span>            : 
<span class="lineNum">   28239 </span><span class="lineCov">       1774 :   first = &amp;(*macinfo_table)[idx];</span>
<span class="lineNum">   28240 </span><span class="lineCov">       1774 :   second = &amp;(*macinfo_table)[idx + 1];</span>
<span class="lineNum">   28241 </span>            : 
<span class="lineNum">   28242 </span>            :   /* Optimize only if there are at least two consecutive define/undef ops,
<span class="lineNum">   28243 </span>            :      and either all of them are before first DW_MACINFO_start_file
<span class="lineNum">   28244 </span>            :      with lineno {0,1} (i.e. predefined macro block), or all of them are
<span class="lineNum">   28245 </span>            :      in some included header file.  */
<span class="lineNum">   28246 </span><span class="lineCov">       1774 :   if (second-&gt;code != DW_MACINFO_define &amp;&amp; second-&gt;code != DW_MACINFO_undef)</span>
<span class="lineNum">   28247 </span>            :     return 0;
<span class="lineNum">   28248 </span><span class="lineCov">       1450 :   if (vec_safe_is_empty (files))</span>
<span class="lineNum">   28249 </span>            :     {
<span class="lineNum">   28250 </span><span class="lineCov">        436 :       if (first-&gt;lineno &gt; 1 || second-&gt;lineno &gt; 1)</span>
<span class="lineNum">   28251 </span>            :         return 0;
<span class="lineNum">   28252 </span>            :     }
<span class="lineNum">   28253 </span><span class="lineCov">       1014 :   else if (first-&gt;lineno == 0)</span>
<span class="lineNum">   28254 </span>            :     return 0;
<span class="lineNum">   28255 </span>            : 
<span class="lineNum">   28256 </span>            :   /* Find the last define/undef entry that can be grouped together
<span class="lineNum">   28257 </span>            :      with first and at the same time compute md5 checksum of their
<span class="lineNum">   28258 </span>            :      codes, linenumbers and strings.  */
<span class="lineNum">   28259 </span><span class="lineCov">       1450 :   md5_init_ctx (&amp;ctx);</span>
<span class="lineNum">   28260 </span><span class="lineCov">     168402 :   for (i = idx; macinfo_table-&gt;iterate (i, &amp;cur); i++)</span>
<span class="lineNum">   28261 </span><span class="lineCov">     168402 :     if (cur-&gt;code != DW_MACINFO_define &amp;&amp; cur-&gt;code != DW_MACINFO_undef)</span>
<span class="lineNum">   28262 </span>            :       break;
<span class="lineNum">   28263 </span><span class="lineCov">     166952 :     else if (vec_safe_is_empty (files) &amp;&amp; cur-&gt;lineno &gt; 1)</span>
<span class="lineNum">   28264 </span>            :       break;
<span class="lineNum">   28265 </span>            :     else
<span class="lineNum">   28266 </span>            :       {
<span class="lineNum">   28267 </span><span class="lineCov">     166952 :         unsigned char code = cur-&gt;code;</span>
<span class="lineNum">   28268 </span><span class="lineCov">     166952 :         md5_process_bytes (&amp;code, 1, &amp;ctx);</span>
<span class="lineNum">   28269 </span><span class="lineCov">     166952 :         checksum_uleb128 (cur-&gt;lineno, &amp;ctx);</span>
<span class="lineNum">   28270 </span><span class="lineCov">     166952 :         md5_process_bytes (cur-&gt;info, strlen (cur-&gt;info) + 1, &amp;ctx);</span>
<span class="lineNum">   28271 </span>            :       }
<span class="lineNum">   28272 </span><span class="lineCov">       1450 :   md5_finish_ctx (&amp;ctx, checksum);</span>
<span class="lineNum">   28273 </span><span class="lineCov">       1450 :   count = i - idx;</span>
<span class="lineNum">   28274 </span>            : 
<span class="lineNum">   28275 </span>            :   /* From the containing include filename (if any) pick up just
<span class="lineNum">   28276 </span>            :      usable characters from its basename.  */
<span class="lineNum">   28277 </span><span class="lineCov">       1450 :   if (vec_safe_is_empty (files))</span>
<span class="lineNum">   28278 </span>            :     base = &quot;&quot;;
<span class="lineNum">   28279 </span>            :   else
<span class="lineNum">   28280 </span><span class="lineCov">       2028 :     base = lbasename (files-&gt;last ().info);</span>
<span class="lineNum">   28281 </span><span class="lineCov">      12838 :   for (encoded_filename_len = 0, i = 0; base[i]; i++)</span>
<span class="lineNum">   28282 </span><span class="lineCov">      11388 :     if (ISIDNUM (base[i]) || base[i] == '.')</span>
<span class="lineNum">   28283 </span><span class="lineCov">      10850 :       encoded_filename_len++;</span>
<span class="lineNum">   28284 </span>            :   /* Count . at the end.  */
<span class="lineNum">   28285 </span><span class="lineCov">       1450 :   if (encoded_filename_len)</span>
<span class="lineNum">   28286 </span><span class="lineCov">       1014 :     encoded_filename_len++;</span>
<span class="lineNum">   28287 </span>            : 
<span class="lineNum">   28288 </span><span class="lineCov">       1450 :   sprintf (linebuf, HOST_WIDE_INT_PRINT_UNSIGNED, first-&gt;lineno);</span>
<span class="lineNum">   28289 </span><span class="lineCov">       1450 :   linebuf_len = strlen (linebuf);</span>
<span class="lineNum">   28290 </span>            : 
<span class="lineNum">   28291 </span>            :   /* The group name format is: wmN.[&lt;encoded filename&gt;.]&lt;lineno&gt;.&lt;md5sum&gt;  */
<span class="lineNum">   28292 </span><span class="lineCov">       1450 :   grp_name = XALLOCAVEC (char, 4 + encoded_filename_len + linebuf_len + 1</span>
<span class="lineNum">   28293 </span>            :                          + 16 * 2 + 1);
<span class="lineNum">   28294 </span><span class="lineCov">       1450 :   memcpy (grp_name, DWARF_OFFSET_SIZE == 4 ? &quot;wm4.&quot; : &quot;wm8.&quot;, 4);</span>
<span class="lineNum">   28295 </span><span class="lineCov">       1450 :   tail = grp_name + 4;</span>
<span class="lineNum">   28296 </span><span class="lineCov">       1450 :   if (encoded_filename_len)</span>
<span class="lineNum">   28297 </span>            :     {
<span class="lineNum">   28298 </span><span class="lineCov">      12402 :       for (i = 0; base[i]; i++)</span>
<span class="lineNum">   28299 </span><span class="lineCov">      11388 :         if (ISIDNUM (base[i]) || base[i] == '.')</span>
<span class="lineNum">   28300 </span><span class="lineCov">      10850 :           *tail++ = base[i];</span>
<span class="lineNum">   28301 </span><span class="lineCov">       1014 :       *tail++ = '.';</span>
<span class="lineNum">   28302 </span>            :     }
<span class="lineNum">   28303 </span><span class="lineCov">       1450 :   memcpy (tail, linebuf, linebuf_len);</span>
<span class="lineNum">   28304 </span><span class="lineCov">       1450 :   tail += linebuf_len;</span>
<span class="lineNum">   28305 </span><span class="lineCov">       1450 :   *tail++ = '.';</span>
<span class="lineNum">   28306 </span><span class="lineCov">      24650 :   for (i = 0; i &lt; 16; i++)</span>
<span class="lineNum">   28307 </span><span class="lineCov">      23200 :     sprintf (tail + i * 2, &quot;%02x&quot;, checksum[i] &amp; 0xff);</span>
<span class="lineNum">   28308 </span>            : 
<span class="lineNum">   28309 </span>            :   /* Construct a macinfo_entry for DW_MACRO_import
<span class="lineNum">   28310 </span>            :      in the empty vector entry before the first define/undef.  */
<span class="lineNum">   28311 </span><span class="lineCov">       1450 :   inc = &amp;(*macinfo_table)[idx - 1];</span>
<span class="lineNum">   28312 </span><span class="lineCov">       1450 :   inc-&gt;code = DW_MACRO_import;</span>
<span class="lineNum">   28313 </span><span class="lineCov">       1450 :   inc-&gt;lineno = 0;</span>
<span class="lineNum">   28314 </span><span class="lineCov">       1450 :   inc-&gt;info = ggc_strdup (grp_name);</span>
<span class="lineNum">   28315 </span><span class="lineCov">       1450 :   if (!*macinfo_htab)</span>
<span class="lineNum">   28316 </span><span class="lineCov">        437 :     *macinfo_htab = new macinfo_hash_type (10);</span>
<span class="lineNum">   28317 </span>            :   /* Avoid emitting duplicates.  */
<span class="lineNum">   28318 </span><span class="lineCov">       1450 :   slot = (*macinfo_htab)-&gt;find_slot (inc, INSERT);</span>
<span class="lineNum">   28319 </span><span class="lineCov">       1450 :   if (*slot != NULL)</span>
<span class="lineNum">   28320 </span>            :     {
<span class="lineNum">   28321 </span><span class="lineCov">         97 :       inc-&gt;code = 0;</span>
<span class="lineNum">   28322 </span><span class="lineCov">         97 :       inc-&gt;info = NULL;</span>
<span class="lineNum">   28323 </span>            :       /* If such an entry has been used before, just emit
<span class="lineNum">   28324 </span>            :          a DW_MACRO_import op.  */
<span class="lineNum">   28325 </span><span class="lineCov">         97 :       inc = *slot;</span>
<span class="lineNum">   28326 </span><span class="lineCov">         97 :       output_macinfo_op (inc);</span>
<span class="lineNum">   28327 </span>            :       /* And clear all macinfo_entry in the range to avoid emitting them
<span class="lineNum">   28328 </span>            :          in the second pass.  */
<span class="lineNum">   28329 </span><span class="lineCov">        447 :       for (i = idx; macinfo_table-&gt;iterate (i, &amp;cur) &amp;&amp; i &lt; idx + count; i++)</span>
<span class="lineNum">   28330 </span>            :         {
<span class="lineNum">   28331 </span><span class="lineCov">        350 :           cur-&gt;code = 0;</span>
<span class="lineNum">   28332 </span><span class="lineCov">        350 :           cur-&gt;info = NULL;</span>
<span class="lineNum">   28333 </span>            :         }
<span class="lineNum">   28334 </span>            :     }
<span class="lineNum">   28335 </span>            :   else
<span class="lineNum">   28336 </span>            :     {
<span class="lineNum">   28337 </span><span class="lineCov">       1353 :       *slot = inc;</span>
<span class="lineNum">   28338 </span><span class="lineCov">       1353 :       inc-&gt;lineno = (*macinfo_htab)-&gt;elements ();</span>
<span class="lineNum">   28339 </span><span class="lineCov">       1353 :       output_macinfo_op (inc);</span>
<span class="lineNum">   28340 </span>            :     }
<span class="lineNum">   28341 </span>            :   return count;
<span class="lineNum">   28342 </span>            : }
<span class="lineNum">   28343 </span>            : 
<span class="lineNum">   28344 </span>            : /* Save any strings needed by the macinfo table in the debug str
<span class="lineNum">   28345 </span>            :    table.  All strings must be collected into the table by the time
<span class="lineNum">   28346 </span>            :    index_string is called.  */
<a name="28347"><span class="lineNum">   28347 </span>            : </a>
<span class="lineNum">   28348 </span>            : static void
<span class="lineNum">   28349 </span><span class="lineCov">      34495 : save_macinfo_strings (void)</span>
<span class="lineNum">   28350 </span>            : {
<span class="lineNum">   28351 </span><span class="lineCov">      34495 :   unsigned len;</span>
<span class="lineNum">   28352 </span><span class="lineCov">      34495 :   unsigned i;</span>
<span class="lineNum">   28353 </span><span class="lineCov">      34495 :   macinfo_entry *ref;</span>
<span class="lineNum">   28354 </span>            : 
<span class="lineNum">   28355 </span><span class="lineCov">     205405 :   for (i = 0; macinfo_table &amp;&amp; macinfo_table-&gt;iterate (i, &amp;ref); i++)</span>
<span class="lineNum">   28356 </span>            :     {
<span class="lineNum">   28357 </span><span class="lineCov">     170910 :       switch (ref-&gt;code)</span>
<span class="lineNum">   28358 </span>            :         {
<span class="lineNum">   28359 </span>            :           /* Match the logic in output_macinfo_op to decide on
<span class="lineNum">   28360 </span>            :              indirect strings.  */
<span class="lineNum">   28361 </span><span class="lineCov">     167350 :           case DW_MACINFO_define:</span>
<span class="lineNum">   28362 </span><span class="lineCov">     167350 :           case DW_MACINFO_undef:</span>
<span class="lineNum">   28363 </span><span class="lineCov">     167350 :             len = strlen (ref-&gt;info) + 1;</span>
<span class="lineNum">   28364 </span><span class="lineCov">     167350 :             if (!dwarf_strict</span>
<span class="lineNum">   28365 </span><span class="lineCov">     167350 :                 &amp;&amp; len &gt; DWARF_OFFSET_SIZE</span>
<span class="lineNum">   28366 </span>            :                 &amp;&amp; !DWARF2_INDIRECT_STRING_SUPPORT_MISSING_ON_TARGET
<span class="lineNum">   28367 </span><span class="lineCov">     167339 :                 &amp;&amp; (debug_str_section-&gt;common.flags &amp; SECTION_MERGE) != 0)</span>
<span class="lineNum">   28368 </span><span class="lineCov">     167339 :               set_indirect_string (find_AT_string (ref-&gt;info));</span>
<span class="lineNum">   28369 </span>            :             break;
<span class="lineNum">   28370 </span><span class="lineCov">       1562 :           case DW_MACINFO_start_file:</span>
<span class="lineNum">   28371 </span>            :             /* -gsplit-dwarf -g3 will also output filename as indirect
<span class="lineNum">   28372 </span>            :                string.  */
<span class="lineNum">   28373 </span><span class="lineCov">       1562 :             if (!dwarf_split_debug_info)</span>
<span class="lineNum">   28374 </span>            :               break;
<span class="lineNum">   28375 </span>            :             /* Fall through. */
<span class="lineNum">   28376 </span><span class="lineCov">          4 :           case DW_MACRO_define_strp:</span>
<span class="lineNum">   28377 </span><span class="lineCov">          4 :           case DW_MACRO_undef_strp:</span>
<span class="lineNum">   28378 </span><span class="lineCov">          4 :             set_indirect_string (find_AT_string (ref-&gt;info));</span>
<span class="lineNum">   28379 </span><span class="lineCov">          4 :             break;</span>
<span class="lineNum">   28380 </span>            :           default:
<span class="lineNum">   28381 </span>            :             break;
<span class="lineNum">   28382 </span>            :         }
<span class="lineNum">   28383 </span>            :     }
<span class="lineNum">   28384 </span><span class="lineCov">      34495 : }</span>
<span class="lineNum">   28385 </span>            : 
<span class="lineNum">   28386 </span>            : /* Output macinfo section(s).  */
<a name="28387"><span class="lineNum">   28387 </span>            : </a>
<span class="lineNum">   28388 </span>            : static void
<span class="lineNum">   28389 </span><span class="lineCov">        444 : output_macinfo (const char *debug_line_label, bool early_lto_debug)</span>
<span class="lineNum">   28390 </span>            : {
<span class="lineNum">   28391 </span><span class="lineCov">        444 :   unsigned i;</span>
<span class="lineNum">   28392 </span><span class="lineCov">        444 :   unsigned long length = vec_safe_length (macinfo_table);</span>
<span class="lineNum">   28393 </span><span class="lineCov">        444 :   macinfo_entry *ref;</span>
<span class="lineNum">   28394 </span><span class="lineCov">        444 :   vec&lt;macinfo_entry, va_gc&gt; *files = NULL;</span>
<span class="lineNum">   28395 </span><span class="lineCov">        444 :   macinfo_hash_type *macinfo_htab = NULL;</span>
<span class="lineNum">   28396 </span><span class="lineCov">        444 :   char dl_section_ref[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">   28397 </span>            : 
<span class="lineNum">   28398 </span><span class="lineCov">        444 :   if (! length)</span>
<span class="lineNum">   28399 </span><span class="lineCov">          7 :     return;</span>
<span class="lineNum">   28400 </span>            : 
<span class="lineNum">   28401 </span>            :   /* output_macinfo* uses these interchangeably.  */
<span class="lineNum">   28402 </span><span class="lineCov">        444 :   gcc_assert ((int) DW_MACINFO_define == (int) DW_MACRO_define</span>
<span class="lineNum">   28403 </span>            :               &amp;&amp; (int) DW_MACINFO_undef == (int) DW_MACRO_undef
<span class="lineNum">   28404 </span>            :               &amp;&amp; (int) DW_MACINFO_start_file == (int) DW_MACRO_start_file
<span class="lineNum">   28405 </span>            :               &amp;&amp; (int) DW_MACINFO_end_file == (int) DW_MACRO_end_file);
<span class="lineNum">   28406 </span>            : 
<span class="lineNum">   28407 </span>            :   /* AIX Assembler inserts the length, so adjust the reference to match the
<span class="lineNum">   28408 </span>            :      offset expected by debuggers.  */
<span class="lineNum">   28409 </span><span class="lineCov">        444 :   strcpy (dl_section_ref, debug_line_label);</span>
<span class="lineNum">   28410 </span><span class="lineCov">        444 :   if (XCOFF_DEBUGGING_INFO)</span>
<span class="lineNum">   28411 </span>            :     strcat (dl_section_ref, DWARF_INITIAL_LENGTH_SIZE_STR);
<span class="lineNum">   28412 </span>            : 
<span class="lineNum">   28413 </span>            :   /* For .debug_macro emit the section header.  */
<span class="lineNum">   28414 </span><span class="lineCov">        444 :   if (!dwarf_strict || dwarf_version &gt;= 5)</span>
<span class="lineNum">   28415 </span>            :     {
<span class="lineNum">   28416 </span><span class="lineCov">        888 :       dw2_asm_output_data (2, dwarf_version &gt;= 5 ? 5 : 4,</span>
<span class="lineNum">   28417 </span>            :                            &quot;DWARF macro version number&quot;);
<span class="lineNum">   28418 </span><span class="lineCov">        444 :       if (DWARF_OFFSET_SIZE == 8)</span>
<span class="lineNum">   28419 </span>            :         dw2_asm_output_data (1, 3, &quot;Flags: 64-bit, lineptr present&quot;);
<span class="lineNum">   28420 </span>            :       else
<span class="lineNum">   28421 </span><span class="lineCov">        444 :         dw2_asm_output_data (1, 2, &quot;Flags: 32-bit, lineptr present&quot;);</span>
<span class="lineNum">   28422 </span><span class="lineCov">        444 :       dw2_asm_output_offset (DWARF_OFFSET_SIZE, debug_line_label,</span>
<span class="lineNum">   28423 </span>            :                              debug_line_section, NULL);
<span class="lineNum">   28424 </span>            :     }
<span class="lineNum">   28425 </span>            : 
<span class="lineNum">   28426 </span>            :   /* In the first loop, it emits the primary .debug_macinfo section
<span class="lineNum">   28427 </span>            :      and after each emitted op the macinfo_entry is cleared.
<span class="lineNum">   28428 </span>            :      If a longer range of define/undef ops can be optimized using
<span class="lineNum">   28429 </span>            :      DW_MACRO_import, the DW_MACRO_import op is emitted and kept in
<span class="lineNum">   28430 </span>            :      the vector before the first define/undef in the range and the
<span class="lineNum">   28431 </span>            :      whole range of define/undef ops is not emitted and kept.  */
<span class="lineNum">   28432 </span><span class="lineCov">       5852 :   for (i = 0; macinfo_table-&gt;iterate (i, &amp;ref); i++)</span>
<span class="lineNum">   28433 </span>            :     {
<span class="lineNum">   28434 </span><span class="lineCov">       5408 :       switch (ref-&gt;code)</span>
<span class="lineNum">   28435 </span>            :         {
<span class="lineNum">   28436 </span><span class="lineCov">       1562 :         case DW_MACINFO_start_file:</span>
<span class="lineNum">   28437 </span><span class="lineCov">       1562 :           vec_safe_push (files, *ref);</span>
<span class="lineNum">   28438 </span><span class="lineCov">       1562 :           break;</span>
<span class="lineNum">   28439 </span><span class="lineCov">       1562 :         case DW_MACINFO_end_file:</span>
<span class="lineNum">   28440 </span><span class="lineCov">       1562 :           if (!vec_safe_is_empty (files))</span>
<span class="lineNum">   28441 </span><span class="lineCov">       1562 :             files-&gt;pop ();</span>
<span class="lineNum">   28442 </span>            :           break;
<span class="lineNum">   28443 </span><span class="lineCov">       1848 :         case DW_MACINFO_define:</span>
<span class="lineNum">   28444 </span><span class="lineCov">       1848 :         case DW_MACINFO_undef:</span>
<span class="lineNum">   28445 </span><span class="lineNoCov">          0 :           if ((!dwarf_strict || dwarf_version &gt;= 5)</span>
<span class="lineNum">   28446 </span>            :               &amp;&amp; HAVE_COMDAT_GROUP
<span class="lineNum">   28447 </span><span class="lineCov">       1848 :               &amp;&amp; vec_safe_length (files) != 1</span>
<span class="lineNum">   28448 </span><span class="lineCov">       1774 :               &amp;&amp; i &gt; 0</span>
<span class="lineNum">   28449 </span><span class="lineCov">       1774 :               &amp;&amp; i + 1 &lt; length</span>
<span class="lineNum">   28450 </span><span class="lineCov">       3622 :               &amp;&amp; (*macinfo_table)[i - 1].code == 0)</span>
<span class="lineNum">   28451 </span>            :             {
<span class="lineNum">   28452 </span><span class="lineCov">       1774 :               unsigned count = optimize_macinfo_range (i, files, &amp;macinfo_htab);</span>
<span class="lineNum">   28453 </span><span class="lineCov">       1774 :               if (count)</span>
<span class="lineNum">   28454 </span>            :                 {
<span class="lineNum">   28455 </span><span class="lineCov">       1450 :                   i += count - 1;</span>
<span class="lineNum">   28456 </span><span class="lineCov">       1450 :                   continue;</span>
<span class="lineNum">   28457 </span>            :                 }
<span class="lineNum">   28458 </span>            :             }
<span class="lineNum">   28459 </span>            :           break;
<span class="lineNum">   28460 </span><span class="lineCov">        436 :         case 0:</span>
<span class="lineNum">   28461 </span>            :           /* A dummy entry may be inserted at the beginning to be able
<span class="lineNum">   28462 </span>            :              to optimize the whole block of predefined macros.  */
<span class="lineNum">   28463 </span><span class="lineCov">        436 :           if (i == 0)</span>
<span class="lineNum">   28464 </span>            :             continue;
<span class="lineNum">   28465 </span>            :         default:
<span class="lineNum">   28466 </span>            :           break;
<span class="lineNum">   28467 </span>            :         }
<span class="lineNum">   28468 </span><span class="lineCov">       3522 :       output_macinfo_op (ref);</span>
<span class="lineNum">   28469 </span><span class="lineCov">       3522 :       ref-&gt;info = NULL;</span>
<span class="lineNum">   28470 </span><span class="lineCov">       3522 :       ref-&gt;code = 0;</span>
<span class="lineNum">   28471 </span>            :     }
<span class="lineNum">   28472 </span>            : 
<span class="lineNum">   28473 </span><span class="lineCov">        444 :   if (!macinfo_htab)</span>
<span class="lineNum">   28474 </span>            :     return;
<span class="lineNum">   28475 </span>            : 
<span class="lineNum">   28476 </span>            :   /* Save the number of transparent includes so we can adjust the
<span class="lineNum">   28477 </span>            :      label number for the fat LTO object DWARF.  */
<span class="lineNum">   28478 </span><span class="lineCov">        437 :   unsigned macinfo_label_base_adj = macinfo_htab-&gt;elements ();</span>
<span class="lineNum">   28479 </span>            : 
<span class="lineNum">   28480 </span><span class="lineCov">        437 :   delete macinfo_htab;</span>
<span class="lineNum">   28481 </span><span class="lineCov">        437 :   macinfo_htab = NULL;</span>
<span class="lineNum">   28482 </span>            : 
<span class="lineNum">   28483 </span>            :   /* If any DW_MACRO_import were used, on those DW_MACRO_import entries
<span class="lineNum">   28484 </span>            :      terminate the current chain and switch to a new comdat .debug_macinfo
<span class="lineNum">   28485 </span>            :      section and emit the define/undef entries within it.  */
<span class="lineNum">   28486 </span><span class="lineCov">     171323 :   for (i = 0; macinfo_table-&gt;iterate (i, &amp;ref); i++)</span>
<span class="lineNum">   28487 </span><span class="lineCov">     170886 :     switch (ref-&gt;code)</span>
<span class="lineNum">   28488 </span>            :       {
<span class="lineNum">   28489 </span>            :       case 0:
<span class="lineNum">   28490 </span>            :         continue;
<span class="lineNum">   28491 </span><span class="lineCov">       1353 :       case DW_MACRO_import:</span>
<span class="lineNum">   28492 </span><span class="lineCov">       1353 :         {</span>
<span class="lineNum">   28493 </span><span class="lineCov">       1353 :           char label[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">   28494 </span><span class="lineCov">       1353 :           tree comdat_key = get_identifier (ref-&gt;info);</span>
<span class="lineNum">   28495 </span>            :           /* Terminate the previous .debug_macinfo section.  */
<span class="lineNum">   28496 </span><span class="lineCov">       1353 :           dw2_asm_output_data (1, 0, &quot;End compilation unit&quot;);</span>
<span class="lineNum">   28497 </span><span class="lineCov">       2688 :           targetm.asm_out.named_section (debug_macinfo_section_name,</span>
<span class="lineNum">   28498 </span>            :                                          SECTION_DEBUG
<span class="lineNum">   28499 </span>            :                                          | SECTION_LINKONCE
<span class="lineNum">   28500 </span>            :                                          | (early_lto_debug
<span class="lineNum">   28501 </span>            :                                             ? SECTION_EXCLUDE : 0),
<span class="lineNum">   28502 </span>            :                                          comdat_key);
<span class="lineNum">   28503 </span><span class="lineCov">       1353 :           ASM_GENERATE_INTERNAL_LABEL (label,</span>
<span class="lineNum">   28504 </span>            :                                        DEBUG_MACRO_SECTION_LABEL,
<span class="lineNum">   28505 </span>            :                                        ref-&gt;lineno + macinfo_label_base);
<span class="lineNum">   28506 </span><span class="lineCov">       1353 :           ASM_OUTPUT_LABEL (asm_out_file, label);</span>
<span class="lineNum">   28507 </span><span class="lineCov">       1353 :           ref-&gt;code = 0;</span>
<span class="lineNum">   28508 </span><span class="lineCov">       1353 :           ref-&gt;info = NULL;</span>
<span class="lineNum">   28509 </span><span class="lineCov">       2706 :           dw2_asm_output_data (2, dwarf_version &gt;= 5 ? 5 : 4,</span>
<span class="lineNum">   28510 </span>            :                                &quot;DWARF macro version number&quot;);
<span class="lineNum">   28511 </span><span class="lineCov">       1353 :           if (DWARF_OFFSET_SIZE == 8)</span>
<span class="lineNum">   28512 </span>            :             dw2_asm_output_data (1, 1, &quot;Flags: 64-bit&quot;);
<span class="lineNum">   28513 </span>            :           else
<span class="lineNum">   28514 </span><span class="lineCov">       1353 :             dw2_asm_output_data (1, 0, &quot;Flags: 32-bit&quot;);</span>
<span class="lineNum">   28515 </span>            :         }
<span class="lineNum">   28516 </span><span class="lineCov">       1353 :         break;</span>
<span class="lineNum">   28517 </span><span class="lineCov">     166602 :       case DW_MACINFO_define:</span>
<span class="lineNum">   28518 </span><span class="lineCov">     166602 :       case DW_MACINFO_undef:</span>
<span class="lineNum">   28519 </span><span class="lineCov">     166602 :         output_macinfo_op (ref);</span>
<span class="lineNum">   28520 </span><span class="lineCov">     166602 :         ref-&gt;code = 0;</span>
<span class="lineNum">   28521 </span><span class="lineCov">     166602 :         ref-&gt;info = NULL;</span>
<span class="lineNum">   28522 </span><span class="lineCov">     166602 :         break;</span>
<span class="lineNum">   28523 </span><span class="lineNoCov">          0 :       default:</span>
<span class="lineNum">   28524 </span><span class="lineNoCov">          0 :         gcc_unreachable ();</span>
<span class="lineNum">   28525 </span>            :       }
<span class="lineNum">   28526 </span>            : 
<span class="lineNum">   28527 </span><span class="lineCov">        437 :   macinfo_label_base += macinfo_label_base_adj;</span>
<span class="lineNum">   28528 </span>            : }
<span class="lineNum">   28529 </span>            : 
<span class="lineNum">   28530 </span>            : /* Initialize the various sections and labels for dwarf output and prefix
<span class="lineNum">   28531 </span>            :    them with PREFIX if non-NULL.  Returns the generation (zero based
<span class="lineNum">   28532 </span>            :    number of times function was called).  */
<a name="28533"><span class="lineNum">   28533 </span>            : </a>
<span class="lineNum">   28534 </span>            : static unsigned
<span class="lineNum">   28535 </span><span class="lineCov">      34495 : init_sections_and_labels (bool early_lto_debug)</span>
<span class="lineNum">   28536 </span>            : {
<span class="lineNum">   28537 </span>            :   /* As we may get called multiple times have a generation count for
<span class="lineNum">   28538 </span>            :      labels.  */
<span class="lineNum">   28539 </span><span class="lineCov">      34495 :   static unsigned generation = 0;</span>
<span class="lineNum">   28540 </span>            : 
<span class="lineNum">   28541 </span><span class="lineCov">      34495 :   if (early_lto_debug)</span>
<span class="lineNum">   28542 </span>            :     {
<span class="lineNum">   28543 </span><span class="lineCov">        808 :       if (!dwarf_split_debug_info)</span>
<span class="lineNum">   28544 </span>            :         {
<span class="lineNum">   28545 </span><span class="lineCov">        807 :           debug_info_section = get_section (DEBUG_LTO_INFO_SECTION,</span>
<span class="lineNum">   28546 </span>            :                                             SECTION_DEBUG | SECTION_EXCLUDE,
<span class="lineNum">   28547 </span>            :                                             NULL);
<span class="lineNum">   28548 </span><span class="lineCov">        807 :           debug_abbrev_section = get_section (DEBUG_LTO_ABBREV_SECTION,</span>
<span class="lineNum">   28549 </span>            :                                               SECTION_DEBUG | SECTION_EXCLUDE,
<span class="lineNum">   28550 </span>            :                                               NULL);
<span class="lineNum">   28551 </span><span class="lineCov">        807 :           debug_macinfo_section_name</span>
<span class="lineNum">   28552 </span><span class="lineNoCov">          0 :             = ((dwarf_strict &amp;&amp; dwarf_version &lt; 5)</span>
<span class="lineNum">   28553 </span><span class="lineCov">        807 :                ? DEBUG_LTO_MACINFO_SECTION : DEBUG_LTO_MACRO_SECTION);</span>
<span class="lineNum">   28554 </span><span class="lineCov">        807 :           debug_macinfo_section = get_section (debug_macinfo_section_name,</span>
<span class="lineNum">   28555 </span>            :                                                SECTION_DEBUG
<span class="lineNum">   28556 </span>            :                                                | SECTION_EXCLUDE, NULL);
<span class="lineNum">   28557 </span>            :         }
<span class="lineNum">   28558 </span>            :       else
<span class="lineNum">   28559 </span>            :         {
<span class="lineNum">   28560 </span>            :           /* ???  Which of the following do we need early?  */
<span class="lineNum">   28561 </span><span class="lineCov">          1 :           debug_info_section = get_section (DEBUG_LTO_DWO_INFO_SECTION,</span>
<span class="lineNum">   28562 </span>            :                                             SECTION_DEBUG | SECTION_EXCLUDE,
<span class="lineNum">   28563 </span>            :                                             NULL);
<span class="lineNum">   28564 </span><span class="lineCov">          1 :           debug_abbrev_section = get_section (DEBUG_LTO_DWO_ABBREV_SECTION,</span>
<span class="lineNum">   28565 </span>            :                                               SECTION_DEBUG | SECTION_EXCLUDE,
<span class="lineNum">   28566 </span>            :                                               NULL);
<span class="lineNum">   28567 </span><span class="lineCov">          1 :           debug_skeleton_info_section = get_section (DEBUG_LTO_INFO_SECTION,</span>
<span class="lineNum">   28568 </span>            :                                                      SECTION_DEBUG
<span class="lineNum">   28569 </span>            :                                                      | SECTION_EXCLUDE, NULL);
<span class="lineNum">   28570 </span><span class="lineCov">          1 :           debug_skeleton_abbrev_section</span>
<span class="lineNum">   28571 </span><span class="lineCov">          1 :             = get_section (DEBUG_LTO_ABBREV_SECTION,</span>
<span class="lineNum">   28572 </span>            :                            SECTION_DEBUG | SECTION_EXCLUDE, NULL);
<span class="lineNum">   28573 </span><span class="lineCov">          1 :           ASM_GENERATE_INTERNAL_LABEL (debug_skeleton_abbrev_section_label,</span>
<span class="lineNum">   28574 </span>            :                                        DEBUG_SKELETON_ABBREV_SECTION_LABEL,
<span class="lineNum">   28575 </span>            :                                        generation);
<span class="lineNum">   28576 </span>            : 
<span class="lineNum">   28577 </span>            :           /* Somewhat confusing detail: The skeleton_[abbrev|info] sections
<span class="lineNum">   28578 </span>            :              stay in the main .o, but the skeleton_line goes into the split
<span class="lineNum">   28579 </span>            :              off dwo.  */
<span class="lineNum">   28580 </span><span class="lineCov">          1 :           debug_skeleton_line_section</span>
<span class="lineNum">   28581 </span><span class="lineCov">          1 :             = get_section (DEBUG_LTO_LINE_SECTION,</span>
<span class="lineNum">   28582 </span>            :                            SECTION_DEBUG | SECTION_EXCLUDE, NULL);
<span class="lineNum">   28583 </span><span class="lineCov">          1 :           ASM_GENERATE_INTERNAL_LABEL (debug_skeleton_line_section_label,</span>
<span class="lineNum">   28584 </span>            :                                        DEBUG_SKELETON_LINE_SECTION_LABEL,
<span class="lineNum">   28585 </span>            :                                        generation);
<span class="lineNum">   28586 </span><span class="lineCov">          1 :           debug_str_offsets_section</span>
<span class="lineNum">   28587 </span><span class="lineCov">          1 :             = get_section (DEBUG_LTO_DWO_STR_OFFSETS_SECTION,</span>
<span class="lineNum">   28588 </span>            :                            SECTION_DEBUG | SECTION_EXCLUDE,
<span class="lineNum">   28589 </span>            :                            NULL);
<span class="lineNum">   28590 </span><span class="lineCov">          1 :           ASM_GENERATE_INTERNAL_LABEL (debug_skeleton_info_section_label,</span>
<span class="lineNum">   28591 </span>            :                                        DEBUG_SKELETON_INFO_SECTION_LABEL,
<span class="lineNum">   28592 </span>            :                                        generation);
<span class="lineNum">   28593 </span><span class="lineCov">          1 :           debug_str_dwo_section = get_section (DEBUG_LTO_STR_DWO_SECTION,</span>
<span class="lineNum">   28594 </span>            :                                                DEBUG_STR_DWO_SECTION_FLAGS,
<span class="lineNum">   28595 </span>            :                                                NULL);
<span class="lineNum">   28596 </span><span class="lineCov">          1 :           debug_macinfo_section_name</span>
<span class="lineNum">   28597 </span><span class="lineNoCov">          0 :             = ((dwarf_strict &amp;&amp; dwarf_version &lt; 5)</span>
<span class="lineNum">   28598 </span><span class="lineCov">          1 :                ? DEBUG_LTO_DWO_MACINFO_SECTION : DEBUG_LTO_DWO_MACRO_SECTION);</span>
<span class="lineNum">   28599 </span><span class="lineCov">          1 :           debug_macinfo_section = get_section (debug_macinfo_section_name,</span>
<span class="lineNum">   28600 </span>            :                                                SECTION_DEBUG | SECTION_EXCLUDE,
<span class="lineNum">   28601 </span>            :                                                NULL);
<span class="lineNum">   28602 </span>            :         }
<span class="lineNum">   28603 </span>            :       /* For macro info and the file table we have to refer to a
<span class="lineNum">   28604 </span>            :          debug_line section.  */
<span class="lineNum">   28605 </span><span class="lineCov">        808 :       debug_line_section = get_section (DEBUG_LTO_LINE_SECTION,</span>
<span class="lineNum">   28606 </span>            :                                         SECTION_DEBUG | SECTION_EXCLUDE, NULL);
<span class="lineNum">   28607 </span><span class="lineCov">        808 :       ASM_GENERATE_INTERNAL_LABEL (debug_line_section_label,</span>
<span class="lineNum">   28608 </span>            :                                    DEBUG_LINE_SECTION_LABEL, generation);
<span class="lineNum">   28609 </span>            : 
<span class="lineNum">   28610 </span><span class="lineCov">        808 :       debug_str_section = get_section (DEBUG_LTO_STR_SECTION,</span>
<span class="lineNum">   28611 </span><span class="lineCov">        808 :                                        DEBUG_STR_SECTION_FLAGS</span>
<span class="lineNum">   28612 </span>            :                                        | SECTION_EXCLUDE, NULL);
<span class="lineNum">   28613 </span><span class="lineCov">        808 :       if (!dwarf_split_debug_info)</span>
<span class="lineNum">   28614 </span><span class="lineCov">        807 :         debug_line_str_section</span>
<span class="lineNum">   28615 </span><span class="lineCov">        807 :           = get_section (DEBUG_LTO_LINE_STR_SECTION,</span>
<span class="lineNum">   28616 </span><span class="lineCov">        807 :                          DEBUG_STR_SECTION_FLAGS | SECTION_EXCLUDE, NULL);</span>
<span class="lineNum">   28617 </span>            :     }
<span class="lineNum">   28618 </span>            :   else
<span class="lineNum">   28619 </span>            :     {
<span class="lineNum">   28620 </span><span class="lineCov">      33687 :       if (!dwarf_split_debug_info)</span>
<span class="lineNum">   28621 </span>            :         {
<span class="lineNum">   28622 </span><span class="lineCov">      33683 :           debug_info_section = get_section (DEBUG_INFO_SECTION,</span>
<span class="lineNum">   28623 </span>            :                                             SECTION_DEBUG, NULL);
<span class="lineNum">   28624 </span><span class="lineCov">      33683 :           debug_abbrev_section = get_section (DEBUG_ABBREV_SECTION,</span>
<span class="lineNum">   28625 </span>            :                                               SECTION_DEBUG, NULL);
<span class="lineNum">   28626 </span><span class="lineCov">      67351 :           debug_loc_section = get_section (dwarf_version &gt;= 5</span>
<span class="lineNum">   28627 </span>            :                                            ? DEBUG_LOCLISTS_SECTION
<span class="lineNum">   28628 </span>            :                                            : DEBUG_LOC_SECTION,
<span class="lineNum">   28629 </span>            :                                            SECTION_DEBUG, NULL);
<span class="lineNum">   28630 </span><span class="lineCov">      33683 :           debug_macinfo_section_name</span>
<span class="lineNum">   28631 </span><span class="lineCov">          4 :             = ((dwarf_strict &amp;&amp; dwarf_version &lt; 5)</span>
<span class="lineNum">   28632 </span><span class="lineCov">      33683 :                ? DEBUG_MACINFO_SECTION : DEBUG_MACRO_SECTION);</span>
<span class="lineNum">   28633 </span><span class="lineCov">      33683 :           debug_macinfo_section = get_section (debug_macinfo_section_name,</span>
<span class="lineNum">   28634 </span>            :                                                SECTION_DEBUG, NULL);
<span class="lineNum">   28635 </span>            :         }
<span class="lineNum">   28636 </span>            :       else
<span class="lineNum">   28637 </span>            :         {
<span class="lineNum">   28638 </span><span class="lineCov">          4 :           debug_info_section = get_section (DEBUG_DWO_INFO_SECTION,</span>
<span class="lineNum">   28639 </span>            :                                             SECTION_DEBUG | SECTION_EXCLUDE,
<span class="lineNum">   28640 </span>            :                                             NULL);
<span class="lineNum">   28641 </span><span class="lineCov">          4 :           debug_abbrev_section = get_section (DEBUG_DWO_ABBREV_SECTION,</span>
<span class="lineNum">   28642 </span>            :                                               SECTION_DEBUG | SECTION_EXCLUDE,
<span class="lineNum">   28643 </span>            :                                               NULL);
<span class="lineNum">   28644 </span><span class="lineCov">          4 :           debug_addr_section = get_section (DEBUG_ADDR_SECTION,</span>
<span class="lineNum">   28645 </span>            :                                             SECTION_DEBUG, NULL);
<span class="lineNum">   28646 </span><span class="lineCov">          4 :           debug_skeleton_info_section = get_section (DEBUG_INFO_SECTION,</span>
<span class="lineNum">   28647 </span>            :                                                      SECTION_DEBUG, NULL);
<span class="lineNum">   28648 </span><span class="lineCov">          4 :           debug_skeleton_abbrev_section = get_section (DEBUG_ABBREV_SECTION,</span>
<span class="lineNum">   28649 </span>            :                                                        SECTION_DEBUG, NULL);
<span class="lineNum">   28650 </span><span class="lineCov">          4 :           ASM_GENERATE_INTERNAL_LABEL (debug_skeleton_abbrev_section_label,</span>
<span class="lineNum">   28651 </span>            :                                        DEBUG_SKELETON_ABBREV_SECTION_LABEL,
<span class="lineNum">   28652 </span>            :                                        generation);
<span class="lineNum">   28653 </span>            : 
<span class="lineNum">   28654 </span>            :           /* Somewhat confusing detail: The skeleton_[abbrev|info] sections
<span class="lineNum">   28655 </span>            :              stay in the main .o, but the skeleton_line goes into the
<span class="lineNum">   28656 </span>            :              split off dwo.  */
<span class="lineNum">   28657 </span><span class="lineCov">          4 :           debug_skeleton_line_section</span>
<span class="lineNum">   28658 </span><span class="lineCov">          4 :               = get_section (DEBUG_DWO_LINE_SECTION,</span>
<span class="lineNum">   28659 </span>            :                              SECTION_DEBUG | SECTION_EXCLUDE, NULL);
<span class="lineNum">   28660 </span><span class="lineCov">          4 :           ASM_GENERATE_INTERNAL_LABEL (debug_skeleton_line_section_label,</span>
<span class="lineNum">   28661 </span>            :                                        DEBUG_SKELETON_LINE_SECTION_LABEL,
<span class="lineNum">   28662 </span>            :                                        generation);
<span class="lineNum">   28663 </span><span class="lineCov">          4 :           debug_str_offsets_section</span>
<span class="lineNum">   28664 </span><span class="lineCov">          4 :             = get_section (DEBUG_DWO_STR_OFFSETS_SECTION,</span>
<span class="lineNum">   28665 </span>            :                            SECTION_DEBUG | SECTION_EXCLUDE, NULL);
<span class="lineNum">   28666 </span><span class="lineCov">          4 :           ASM_GENERATE_INTERNAL_LABEL (debug_skeleton_info_section_label,</span>
<span class="lineNum">   28667 </span>            :                                        DEBUG_SKELETON_INFO_SECTION_LABEL,
<span class="lineNum">   28668 </span>            :                                        generation);
<span class="lineNum">   28669 </span><span class="lineCov">          8 :           debug_loc_section = get_section (dwarf_version &gt;= 5</span>
<span class="lineNum">   28670 </span>            :                                            ? DEBUG_DWO_LOCLISTS_SECTION
<span class="lineNum">   28671 </span>            :                                            : DEBUG_DWO_LOC_SECTION,
<span class="lineNum">   28672 </span>            :                                            SECTION_DEBUG | SECTION_EXCLUDE,
<span class="lineNum">   28673 </span>            :                                            NULL);
<span class="lineNum">   28674 </span><span class="lineCov">          4 :           debug_str_dwo_section = get_section (DEBUG_STR_DWO_SECTION,</span>
<span class="lineNum">   28675 </span>            :                                                DEBUG_STR_DWO_SECTION_FLAGS,
<span class="lineNum">   28676 </span>            :                                                NULL);
<span class="lineNum">   28677 </span><span class="lineCov">          4 :           debug_macinfo_section_name</span>
<span class="lineNum">   28678 </span><span class="lineNoCov">          0 :             = ((dwarf_strict &amp;&amp; dwarf_version &lt; 5)</span>
<span class="lineNum">   28679 </span><span class="lineCov">          4 :                ? DEBUG_DWO_MACINFO_SECTION : DEBUG_DWO_MACRO_SECTION);</span>
<span class="lineNum">   28680 </span><span class="lineCov">          4 :           debug_macinfo_section = get_section (debug_macinfo_section_name,</span>
<span class="lineNum">   28681 </span>            :                                                SECTION_DEBUG | SECTION_EXCLUDE,
<span class="lineNum">   28682 </span>            :                                                NULL);
<span class="lineNum">   28683 </span>            :         }
<span class="lineNum">   28684 </span><span class="lineCov">      33687 :       debug_aranges_section = get_section (DEBUG_ARANGES_SECTION,</span>
<span class="lineNum">   28685 </span>            :                                            SECTION_DEBUG, NULL);
<span class="lineNum">   28686 </span><span class="lineCov">      33687 :       debug_line_section = get_section (DEBUG_LINE_SECTION,</span>
<span class="lineNum">   28687 </span>            :                                         SECTION_DEBUG, NULL);
<span class="lineNum">   28688 </span><span class="lineCov">      67370 :       debug_pubnames_section = get_section (DEBUG_PUBNAMES_SECTION,</span>
<span class="lineNum">   28689 </span>            :                                             SECTION_DEBUG, NULL);
<span class="lineNum">   28690 </span><span class="lineCov">      67370 :       debug_pubtypes_section = get_section (DEBUG_PUBTYPES_SECTION,</span>
<span class="lineNum">   28691 </span>            :                                             SECTION_DEBUG, NULL);
<span class="lineNum">   28692 </span><span class="lineCov">      33687 :       debug_str_section = get_section (DEBUG_STR_SECTION,</span>
<span class="lineNum">   28693 </span><span class="lineCov">      33687 :                                        DEBUG_STR_SECTION_FLAGS, NULL);</span>
<span class="lineNum">   28694 </span><span class="lineCov">      33687 :       if (!dwarf_split_debug_info &amp;&amp; !output_asm_line_debug_info ())</span>
<span class="lineNum">   28695 </span><span class="lineNoCov">          0 :         debug_line_str_section = get_section (DEBUG_LINE_STR_SECTION,</span>
<span class="lineNum">   28696 </span><span class="lineNoCov">          0 :                                               DEBUG_STR_SECTION_FLAGS, NULL);</span>
<span class="lineNum">   28697 </span>            : 
<span class="lineNum">   28698 </span><span class="lineCov">      67359 :       debug_ranges_section = get_section (dwarf_version &gt;= 5</span>
<span class="lineNum">   28699 </span>            :                                           ? DEBUG_RNGLISTS_SECTION
<span class="lineNum">   28700 </span>            :                                           : DEBUG_RANGES_SECTION,
<span class="lineNum">   28701 </span>            :                                           SECTION_DEBUG, NULL);
<span class="lineNum">   28702 </span><span class="lineCov">      33687 :       debug_frame_section = get_section (DEBUG_FRAME_SECTION,</span>
<span class="lineNum">   28703 </span>            :                                          SECTION_DEBUG, NULL);
<span class="lineNum">   28704 </span>            :     }
<span class="lineNum">   28705 </span>            : 
<span class="lineNum">   28706 </span><span class="lineCov">      34495 :   ASM_GENERATE_INTERNAL_LABEL (abbrev_section_label,</span>
<span class="lineNum">   28707 </span>            :                                DEBUG_ABBREV_SECTION_LABEL, generation);
<span class="lineNum">   28708 </span><span class="lineCov">      34495 :   ASM_GENERATE_INTERNAL_LABEL (debug_info_section_label,</span>
<span class="lineNum">   28709 </span>            :                                DEBUG_INFO_SECTION_LABEL, generation);
<span class="lineNum">   28710 </span><span class="lineCov">      34495 :   info_section_emitted = false;</span>
<span class="lineNum">   28711 </span><span class="lineCov">      34495 :   ASM_GENERATE_INTERNAL_LABEL (debug_line_section_label,</span>
<span class="lineNum">   28712 </span>            :                                DEBUG_LINE_SECTION_LABEL, generation);
<span class="lineNum">   28713 </span>            :   /* There are up to 4 unique ranges labels per generation.
<span class="lineNum">   28714 </span>            :      See also output_rnglists.  */
<span class="lineNum">   28715 </span><span class="lineCov">      34495 :   ASM_GENERATE_INTERNAL_LABEL (ranges_section_label,</span>
<span class="lineNum">   28716 </span>            :                                DEBUG_RANGES_SECTION_LABEL, generation * 4);
<span class="lineNum">   28717 </span><span class="lineCov">      34495 :   if (dwarf_version &gt;= 5 &amp;&amp; dwarf_split_debug_info)</span>
<span class="lineNum">   28718 </span><span class="lineNoCov">          0 :     ASM_GENERATE_INTERNAL_LABEL (ranges_base_label,</span>
<span class="lineNum">   28719 </span>            :                                  DEBUG_RANGES_SECTION_LABEL,
<span class="lineNum">   28720 </span>            :                                  1 + generation * 4);
<span class="lineNum">   28721 </span><span class="lineCov">      34495 :   ASM_GENERATE_INTERNAL_LABEL (debug_addr_section_label,</span>
<span class="lineNum">   28722 </span>            :                                DEBUG_ADDR_SECTION_LABEL, generation);
<span class="lineNum">   28723 </span><span class="lineCov">      68986 :   ASM_GENERATE_INTERNAL_LABEL (macinfo_section_label,</span>
<span class="lineNum">   28724 </span>            :                                (dwarf_strict &amp;&amp; dwarf_version &lt; 5)
<span class="lineNum">   28725 </span>            :                                ? DEBUG_MACINFO_SECTION_LABEL
<span class="lineNum">   28726 </span>            :                                : DEBUG_MACRO_SECTION_LABEL, generation);
<span class="lineNum">   28727 </span><span class="lineCov">      34495 :   ASM_GENERATE_INTERNAL_LABEL (loc_section_label, DEBUG_LOC_SECTION_LABEL,</span>
<span class="lineNum">   28728 </span>            :                                generation);
<span class="lineNum">   28729 </span>            : 
<span class="lineNum">   28730 </span><span class="lineCov">      34495 :   ++generation;</span>
<span class="lineNum">   28731 </span><span class="lineCov">      34495 :   return generation - 1;</span>
<span class="lineNum">   28732 </span>            : }
<span class="lineNum">   28733 </span>            : 
<span class="lineNum">   28734 </span>            : /* Set up for Dwarf output at the start of compilation.  */
<a name="28735"><span class="lineNum">   28735 </span>            : </a>
<span class="lineNum">   28736 </span>            : static void
<span class="lineNum">   28737 </span><span class="lineCov">      35309 : dwarf2out_init (const char *filename ATTRIBUTE_UNUSED)</span>
<span class="lineNum">   28738 </span>            : {
<span class="lineNum">   28739 </span>            :   /* Allocate the file_table.  */
<span class="lineNum">   28740 </span><span class="lineCov">      35309 :   file_table = hash_table&lt;dwarf_file_hasher&gt;::create_ggc (50);</span>
<span class="lineNum">   28741 </span>            : 
<span class="lineNum">   28742 </span>            : #ifndef DWARF2_LINENO_DEBUGGING_INFO
<span class="lineNum">   28743 </span>            :   /* Allocate the decl_die_table.  */
<span class="lineNum">   28744 </span><span class="lineCov">      35309 :   decl_die_table = hash_table&lt;decl_die_hasher&gt;::create_ggc (10);</span>
<span class="lineNum">   28745 </span>            : 
<span class="lineNum">   28746 </span>            :   /* Allocate the decl_loc_table.  */
<span class="lineNum">   28747 </span><span class="lineCov">      35309 :   decl_loc_table = hash_table&lt;decl_loc_hasher&gt;::create_ggc (10);</span>
<span class="lineNum">   28748 </span>            : 
<span class="lineNum">   28749 </span>            :   /* Allocate the cached_dw_loc_list_table.  */
<span class="lineNum">   28750 </span><span class="lineCov">      35309 :   cached_dw_loc_list_table = hash_table&lt;dw_loc_list_hasher&gt;::create_ggc (10);</span>
<span class="lineNum">   28751 </span>            : 
<span class="lineNum">   28752 </span>            :   /* Allocate the initial hunk of the abbrev_die_table.  */
<span class="lineNum">   28753 </span><span class="lineCov">      35309 :   vec_alloc (abbrev_die_table, 256);</span>
<span class="lineNum">   28754 </span>            :   /* Zero-th entry is allocated, but unused.  */
<span class="lineNum">   28755 </span><span class="lineCov">      35309 :   abbrev_die_table-&gt;quick_push (NULL);</span>
<span class="lineNum">   28756 </span>            : 
<span class="lineNum">   28757 </span>            :   /* Allocate the dwarf_proc_stack_usage_map.  */
<span class="lineNum">   28758 </span><span class="lineCov">      35309 :   dwarf_proc_stack_usage_map = new hash_map&lt;dw_die_ref, int&gt;;</span>
<span class="lineNum">   28759 </span>            : 
<span class="lineNum">   28760 </span>            :   /* Allocate the pubtypes and pubnames vectors.  */
<span class="lineNum">   28761 </span><span class="lineCov">      35309 :   vec_alloc (pubname_table, 32);</span>
<span class="lineNum">   28762 </span><span class="lineCov">      35309 :   vec_alloc (pubtype_table, 32);</span>
<span class="lineNum">   28763 </span>            : 
<span class="lineNum">   28764 </span><span class="lineCov">      35309 :   vec_alloc (incomplete_types, 64);</span>
<span class="lineNum">   28765 </span>            : 
<span class="lineNum">   28766 </span><span class="lineCov">      35309 :   vec_alloc (used_rtx_array, 32);</span>
<span class="lineNum">   28767 </span>            : 
<span class="lineNum">   28768 </span><span class="lineCov">      35309 :   if (debug_info_level &gt;= DINFO_LEVEL_VERBOSE)</span>
<span class="lineNum">   28769 </span><span class="lineCov">        453 :     vec_alloc (macinfo_table, 64);</span>
<span class="lineNum">   28770 </span>            : #endif
<span class="lineNum">   28771 </span>            : 
<span class="lineNum">   28772 </span>            :   /* If front-ends already registered a main translation unit but we were not
<span class="lineNum">   28773 </span>            :      ready to perform the association, do this now.  */
<span class="lineNum">   28774 </span><span class="lineCov">      35309 :   if (main_translation_unit != NULL_TREE)</span>
<span class="lineNum">   28775 </span><span class="lineCov">      11790 :     equate_decl_number_to_die (main_translation_unit, comp_unit_die ());</span>
<span class="lineNum">   28776 </span><span class="lineCov">      35309 : }</span>
<span class="lineNum">   28777 </span>            : 
<span class="lineNum">   28778 </span>            : /* Called before compile () starts outputtting functions, variables
<span class="lineNum">   28779 </span>            :    and toplevel asms into assembly.  */
<a name="28780"><span class="lineNum">   28780 </span>            : </a>
<span class="lineNum">   28781 </span>            : static void
<span class="lineNum">   28782 </span><span class="lineCov">      33699 : dwarf2out_assembly_start (void)</span>
<span class="lineNum">   28783 </span>            : {
<span class="lineNum">   28784 </span><span class="lineCov">      33699 :   if (text_section_line_info)</span>
<span class="lineNum">   28785 </span>            :     return;
<span class="lineNum">   28786 </span>            : 
<span class="lineNum">   28787 </span>            : #ifndef DWARF2_LINENO_DEBUGGING_INFO
<span class="lineNum">   28788 </span><span class="lineCov">      33698 :   ASM_GENERATE_INTERNAL_LABEL (text_section_label, TEXT_SECTION_LABEL, 0);</span>
<span class="lineNum">   28789 </span><span class="lineCov">      33698 :   ASM_GENERATE_INTERNAL_LABEL (text_end_label, TEXT_END_LABEL, 0);</span>
<span class="lineNum">   28790 </span><span class="lineCov">      33698 :   ASM_GENERATE_INTERNAL_LABEL (cold_text_section_label,</span>
<span class="lineNum">   28791 </span>            :                                COLD_TEXT_SECTION_LABEL, 0);
<span class="lineNum">   28792 </span><span class="lineCov">      33698 :   ASM_GENERATE_INTERNAL_LABEL (cold_end_label, COLD_END_LABEL, 0);</span>
<span class="lineNum">   28793 </span>            : 
<span class="lineNum">   28794 </span><span class="lineCov">      33698 :   switch_to_section (text_section);</span>
<span class="lineNum">   28795 </span><span class="lineCov">      33698 :   ASM_OUTPUT_LABEL (asm_out_file, text_section_label);</span>
<span class="lineNum">   28796 </span>            : #endif
<span class="lineNum">   28797 </span>            : 
<span class="lineNum">   28798 </span>            :   /* Make sure the line number table for .text always exists.  */
<span class="lineNum">   28799 </span><span class="lineCov">      33698 :   text_section_line_info = new_line_info_table ();</span>
<span class="lineNum">   28800 </span><span class="lineCov">      33698 :   text_section_line_info-&gt;end_label = text_end_label;</span>
<span class="lineNum">   28801 </span>            : 
<span class="lineNum">   28802 </span>            : #ifdef DWARF2_LINENO_DEBUGGING_INFO
<span class="lineNum">   28803 </span>            :   cur_line_info_table = text_section_line_info;
<span class="lineNum">   28804 </span>            : #endif
<span class="lineNum">   28805 </span>            : 
<span class="lineNum">   28806 </span><span class="lineCov">      33698 :   if (HAVE_GAS_CFI_SECTIONS_DIRECTIVE</span>
<span class="lineNum">   28807 </span><span class="lineCov">      33698 :       &amp;&amp; dwarf2out_do_cfi_asm ()</span>
<span class="lineNum">   28808 </span><span class="lineCov">      33698 :       &amp;&amp; !dwarf2out_do_eh_frame ())</span>
<span class="lineNum">   28809 </span><span class="lineCov">          7 :     fprintf (asm_out_file, &quot;\t.cfi_sections\t.debug_frame\n&quot;);</span>
<span class="lineNum">   28810 </span>            : }
<span class="lineNum">   28811 </span>            : 
<span class="lineNum">   28812 </span>            : /* A helper function for dwarf2out_finish called through
<span class="lineNum">   28813 </span>            :    htab_traverse.  Assign a string its index.  All strings must be
<span class="lineNum">   28814 </span>            :    collected into the table by the time index_string is called,
<span class="lineNum">   28815 </span>            :    because the indexing code relies on htab_traverse to traverse nodes
<span class="lineNum">   28816 </span>            :    in the same order for each run. */
<a name="28817"><span class="lineNum">   28817 </span>            : </a>
<span class="lineNum">   28818 </span>            : int
<span class="lineNum">   28819 </span><span class="lineCov">        771 : index_string (indirect_string_node **h, unsigned int *index)</span>
<span class="lineNum">   28820 </span>            : {
<span class="lineNum">   28821 </span><span class="lineCov">        771 :   indirect_string_node *node = *h;</span>
<span class="lineNum">   28822 </span>            : 
<span class="lineNum">   28823 </span><span class="lineCov">        771 :   find_string_form (node);</span>
<span class="lineNum">   28824 </span><span class="lineCov">       1542 :   if (node-&gt;form == dwarf_FORM (DW_FORM_strx) &amp;&amp; node-&gt;refcount &gt; 0)</span>
<span class="lineNum">   28825 </span>            :     {
<span class="lineNum">   28826 </span><span class="lineCov">        743 :       gcc_assert (node-&gt;index == NO_INDEX_ASSIGNED);</span>
<span class="lineNum">   28827 </span><span class="lineCov">        743 :       node-&gt;index = *index;</span>
<span class="lineNum">   28828 </span><span class="lineCov">        743 :       *index += 1;</span>
<span class="lineNum">   28829 </span>            :     }
<span class="lineNum">   28830 </span><span class="lineCov">        771 :   return 1;</span>
<span class="lineNum">   28831 </span>            : }
<span class="lineNum">   28832 </span>            : 
<span class="lineNum">   28833 </span>            : /* A helper function for output_indirect_strings called through
<span class="lineNum">   28834 </span>            :    htab_traverse.  Output the offset to a string and update the
<span class="lineNum">   28835 </span>            :    current offset.  */
<a name="28836"><span class="lineNum">   28836 </span>            : </a>
<span class="lineNum">   28837 </span>            : int
<span class="lineNum">   28838 </span><span class="lineCov">        771 : output_index_string_offset (indirect_string_node **h, unsigned int *offset)</span>
<span class="lineNum">   28839 </span>            : {
<span class="lineNum">   28840 </span><span class="lineCov">        771 :   indirect_string_node *node = *h;</span>
<span class="lineNum">   28841 </span>            : 
<span class="lineNum">   28842 </span><span class="lineCov">       1542 :   if (node-&gt;form == dwarf_FORM (DW_FORM_strx) &amp;&amp; node-&gt;refcount &gt; 0)</span>
<span class="lineNum">   28843 </span>            :     {
<span class="lineNum">   28844 </span>            :       /* Assert that this node has been assigned an index.  */
<span class="lineNum">   28845 </span><span class="lineCov">        743 :       gcc_assert (node-&gt;index != NO_INDEX_ASSIGNED</span>
<span class="lineNum">   28846 </span>            :                   &amp;&amp; node-&gt;index != NOT_INDEXED);
<span class="lineNum">   28847 </span><span class="lineCov">        743 :       dw2_asm_output_data (DWARF_OFFSET_SIZE, *offset,</span>
<span class="lineNum">   28848 </span>            :                            &quot;indexed string 0x%x: %s&quot;, node-&gt;index, node-&gt;str);
<span class="lineNum">   28849 </span><span class="lineCov">        743 :       *offset += strlen (node-&gt;str) + 1;</span>
<span class="lineNum">   28850 </span>            :     }
<span class="lineNum">   28851 </span><span class="lineCov">        771 :   return 1;</span>
<span class="lineNum">   28852 </span>            : }
<span class="lineNum">   28853 </span>            : 
<span class="lineNum">   28854 </span>            : /* A helper function for dwarf2out_finish called through
<span class="lineNum">   28855 </span>            :    htab_traverse.  Output the indexed string.  */
<a name="28856"><span class="lineNum">   28856 </span>            : </a>
<span class="lineNum">   28857 </span>            : int
<span class="lineNum">   28858 </span><span class="lineCov">        771 : output_index_string (indirect_string_node **h, unsigned int *cur_idx)</span>
<span class="lineNum">   28859 </span>            : {
<span class="lineNum">   28860 </span><span class="lineCov">        771 :   struct indirect_string_node *node = *h;</span>
<span class="lineNum">   28861 </span>            : 
<span class="lineNum">   28862 </span><span class="lineCov">       1542 :   if (node-&gt;form == dwarf_FORM (DW_FORM_strx) &amp;&amp; node-&gt;refcount &gt; 0)</span>
<span class="lineNum">   28863 </span>            :     {
<span class="lineNum">   28864 </span>            :       /* Assert that the strings are output in the same order as their
<span class="lineNum">   28865 </span>            :          indexes were assigned.  */
<span class="lineNum">   28866 </span><span class="lineCov">        743 :       gcc_assert (*cur_idx == node-&gt;index);</span>
<span class="lineNum">   28867 </span><span class="lineCov">        743 :       assemble_string (node-&gt;str, strlen (node-&gt;str) + 1);</span>
<span class="lineNum">   28868 </span><span class="lineCov">        743 :       *cur_idx += 1;</span>
<span class="lineNum">   28869 </span>            :     }
<span class="lineNum">   28870 </span><span class="lineCov">        771 :   return 1;</span>
<span class="lineNum">   28871 </span>            : }
<span class="lineNum">   28872 </span>            : 
<span class="lineNum">   28873 </span>            : /* A helper function for output_indirect_strings.  Counts the number
<span class="lineNum">   28874 </span>            :    of index strings offsets.  Must match the logic of the functions
<a name="28875"><span class="lineNum">   28875 </span>            :    output_index_string[_offsets] above.  */</a>
<span class="lineNum">   28876 </span>            : int
<span class="lineNum">   28877 </span><span class="lineNoCov">          0 : count_index_strings (indirect_string_node **h, unsigned int *last_idx)</span>
<span class="lineNum">   28878 </span>            : {
<span class="lineNum">   28879 </span><span class="lineNoCov">          0 :   struct indirect_string_node *node = *h;</span>
<span class="lineNum">   28880 </span>            : 
<span class="lineNum">   28881 </span><span class="lineNoCov">          0 :   if (node-&gt;form == dwarf_FORM (DW_FORM_strx) &amp;&amp; node-&gt;refcount &gt; 0)</span>
<span class="lineNum">   28882 </span><span class="lineNoCov">          0 :     *last_idx += 1;</span>
<span class="lineNum">   28883 </span><span class="lineNoCov">          0 :   return 1;</span>
<span class="lineNum">   28884 </span>            : }
<span class="lineNum">   28885 </span>            : 
<span class="lineNum">   28886 </span>            : /* A helper function for dwarf2out_finish called through
<span class="lineNum">   28887 </span>            :    htab_traverse.  Emit one queued .debug_str string.  */
<a name="28888"><span class="lineNum">   28888 </span>            : </a>
<span class="lineNum">   28889 </span>            : int
<span class="lineNum">   28890 </span><span class="lineCov">   13915392 : output_indirect_string (indirect_string_node **h, enum dwarf_form form)</span>
<span class="lineNum">   28891 </span>            : {
<span class="lineNum">   28892 </span><span class="lineCov">   13915392 :   struct indirect_string_node *node = *h;</span>
<span class="lineNum">   28893 </span>            : 
<span class="lineNum">   28894 </span><span class="lineCov">   13915392 :   node-&gt;form = find_string_form (node);</span>
<span class="lineNum">   28895 </span><span class="lineCov">   13915392 :   if (node-&gt;form == form &amp;&amp; node-&gt;refcount &gt; 0)</span>
<span class="lineNum">   28896 </span>            :     {
<span class="lineNum">   28897 </span><span class="lineCov">   13254150 :       ASM_OUTPUT_LABEL (asm_out_file, node-&gt;label);</span>
<span class="lineNum">   28898 </span><span class="lineCov">   13254150 :       assemble_string (node-&gt;str, strlen (node-&gt;str) + 1);</span>
<span class="lineNum">   28899 </span>            :     }
<span class="lineNum">   28900 </span>            : 
<span class="lineNum">   28901 </span><span class="lineCov">   13915392 :   return 1;</span>
<span class="lineNum">   28902 </span>            : }
<span class="lineNum">   28903 </span>            : 
<span class="lineNum">   28904 </span>            : /* Output the indexed string table.  */
<a name="28905"><span class="lineNum">   28905 </span>            : </a>
<span class="lineNum">   28906 </span>            : static void
<span class="lineNum">   28907 </span><span class="lineCov">      34495 : output_indirect_strings (void)</span>
<span class="lineNum">   28908 </span>            : {
<span class="lineNum">   28909 </span><span class="lineCov">      34495 :   switch_to_section (debug_str_section);</span>
<span class="lineNum">   28910 </span><span class="lineCov">      34495 :   if (!dwarf_split_debug_info)</span>
<span class="lineNum">   28911 </span><span class="lineCov">      34490 :     debug_str_hash-&gt;traverse&lt;enum dwarf_form,</span>
<span class="lineNum">   28912 </span><span class="lineCov">      34490 :                              output_indirect_string&gt; (DW_FORM_strp);</span>
<span class="lineNum">   28913 </span>            :   else
<span class="lineNum">   28914 </span>            :     {
<span class="lineNum">   28915 </span><span class="lineCov">          5 :       unsigned int offset = 0;</span>
<span class="lineNum">   28916 </span><span class="lineCov">          5 :       unsigned int cur_idx = 0;</span>
<span class="lineNum">   28917 </span>            : 
<span class="lineNum">   28918 </span><span class="lineCov">          5 :       if (skeleton_debug_str_hash)</span>
<span class="lineNum">   28919 </span><span class="lineCov">          4 :         skeleton_debug_str_hash-&gt;traverse&lt;enum dwarf_form,</span>
<span class="lineNum">   28920 </span><span class="lineCov">          4 :                                           output_indirect_string&gt; (DW_FORM_strp);</span>
<span class="lineNum">   28921 </span>            : 
<span class="lineNum">   28922 </span><span class="lineCov">          5 :       switch_to_section (debug_str_offsets_section);</span>
<span class="lineNum">   28923 </span>            :       /* For DWARF5 the .debug_str_offsets[.dwo] section needs a unit
<span class="lineNum">   28924 </span>            :          header.  Note that we don't need to generate a label to the
<span class="lineNum">   28925 </span>            :          actual index table following the header here, because this is
<span class="lineNum">   28926 </span>            :          for the split dwarf case only.  In an .dwo file there is only
<span class="lineNum">   28927 </span>            :          one string offsets table (and one debug info section).  But
<span class="lineNum">   28928 </span>            :          if we would start using string offset tables for the main (or
<span class="lineNum">   28929 </span>            :          skeleton) unit, then we have to add a DW_AT_str_offsets_base
<span class="lineNum">   28930 </span>            :          pointing to the actual index after the header.  Split dwarf
<span class="lineNum">   28931 </span>            :          units will never have a string offsets base attribute.  When
<span class="lineNum">   28932 </span>            :          a split unit is moved into a .dwp file the string offsets can
<span class="lineNum">   28933 </span>            :          be found through the .debug_cu_index section table.  */
<span class="lineNum">   28934 </span><span class="lineCov">          5 :       if (dwarf_version &gt;= 5)</span>
<span class="lineNum">   28935 </span>            :         {
<span class="lineNum">   28936 </span><span class="lineNoCov">          0 :           unsigned int last_idx = 0;</span>
<span class="lineNum">   28937 </span><span class="lineNoCov">          0 :           unsigned long str_offsets_length;</span>
<span class="lineNum">   28938 </span>            : 
<span class="lineNum">   28939 </span><span class="lineNoCov">          0 :           debug_str_hash-&gt;traverse_noresize</span>
<span class="lineNum">   28940 </span><span class="lineNoCov">          0 :             &lt;unsigned int *, count_index_strings&gt; (&amp;last_idx);</span>
<span class="lineNum">   28941 </span><span class="lineNoCov">          0 :           str_offsets_length = last_idx * DWARF_OFFSET_SIZE + 4;</span>
<span class="lineNum">   28942 </span><span class="lineNoCov">          0 :           if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)</span>
<span class="lineNum">   28943 </span>            :             dw2_asm_output_data (4, 0xffffffff,
<span class="lineNum">   28944 </span>            :                                  &quot;Escape value for 64-bit DWARF extension&quot;);
<span class="lineNum">   28945 </span><span class="lineNoCov">          0 :           dw2_asm_output_data (DWARF_OFFSET_SIZE, str_offsets_length,</span>
<span class="lineNum">   28946 </span>            :                                &quot;Length of string offsets unit&quot;);
<span class="lineNum">   28947 </span><span class="lineNoCov">          0 :           dw2_asm_output_data (2, 5, &quot;DWARF string offsets version&quot;);</span>
<span class="lineNum">   28948 </span><span class="lineNoCov">          0 :           dw2_asm_output_data (2, 0, &quot;Header zero padding&quot;);</span>
<span class="lineNum">   28949 </span>            :         }
<span class="lineNum">   28950 </span><span class="lineCov">          5 :       debug_str_hash-&gt;traverse_noresize</span>
<span class="lineNum">   28951 </span><span class="lineCov">          5 :         &lt;unsigned int *, output_index_string_offset&gt; (&amp;offset);</span>
<span class="lineNum">   28952 </span><span class="lineCov">          5 :       switch_to_section (debug_str_dwo_section);</span>
<span class="lineNum">   28953 </span><span class="lineCov">          5 :       debug_str_hash-&gt;traverse_noresize&lt;unsigned int *, output_index_string&gt;</span>
<span class="lineNum">   28954 </span><span class="lineCov">          5 :         (&amp;cur_idx);</span>
<span class="lineNum">   28955 </span>            :     }
<span class="lineNum">   28956 </span><span class="lineCov">      34495 : }</span>
<span class="lineNum">   28957 </span>            : 
<span class="lineNum">   28958 </span>            : /* Callback for htab_traverse to assign an index to an entry in the
<span class="lineNum">   28959 </span>            :    table, and to write that entry to the .debug_addr section.  */
<a name="28960"><span class="lineNum">   28960 </span>            : </a>
<span class="lineNum">   28961 </span>            : int
<span class="lineNum">   28962 </span><span class="lineCov">         31 : output_addr_table_entry (addr_table_entry **slot, unsigned int *cur_index)</span>
<span class="lineNum">   28963 </span>            : {
<span class="lineNum">   28964 </span><span class="lineCov">         31 :   addr_table_entry *entry = *slot;</span>
<span class="lineNum">   28965 </span>            : 
<span class="lineNum">   28966 </span><span class="lineCov">         31 :   if (entry-&gt;refcount == 0)</span>
<span class="lineNum">   28967 </span>            :     {
<span class="lineNum">   28968 </span><span class="lineNoCov">          0 :       gcc_assert (entry-&gt;index == NO_INDEX_ASSIGNED</span>
<span class="lineNum">   28969 </span>            :                   || entry-&gt;index == NOT_INDEXED);
<span class="lineNum">   28970 </span>            :       return 1;
<span class="lineNum">   28971 </span>            :     }
<span class="lineNum">   28972 </span>            : 
<span class="lineNum">   28973 </span><span class="lineCov">         31 :   gcc_assert (entry-&gt;index == *cur_index);</span>
<span class="lineNum">   28974 </span><span class="lineCov">         31 :   (*cur_index)++;</span>
<span class="lineNum">   28975 </span>            : 
<span class="lineNum">   28976 </span><span class="lineCov">         31 :   switch (entry-&gt;kind)</span>
<span class="lineNum">   28977 </span>            :     {
<span class="lineNum">   28978 </span><span class="lineCov">         14 :       case ate_kind_rtx:</span>
<span class="lineNum">   28979 </span><span class="lineCov">         14 :         dw2_asm_output_addr_rtx (DWARF2_ADDR_SIZE, entry-&gt;addr.rtl,</span>
<span class="lineNum">   28980 </span>            :                                  &quot;0x%x&quot;, entry-&gt;index);
<span class="lineNum">   28981 </span><span class="lineCov">         14 :         break;</span>
<span class="lineNum">   28982 </span><span class="lineNoCov">          0 :       case ate_kind_rtx_dtprel:</span>
<span class="lineNum">   28983 </span><span class="lineNoCov">          0 :         gcc_assert (targetm.asm_out.output_dwarf_dtprel);</span>
<span class="lineNum">   28984 </span><span class="lineNoCov">          0 :         targetm.asm_out.output_dwarf_dtprel (asm_out_file,</span>
<span class="lineNum">   28985 </span><span class="lineNoCov">          0 :                                              DWARF2_ADDR_SIZE,</span>
<span class="lineNum">   28986 </span>            :                                              entry-&gt;addr.rtl);
<span class="lineNum">   28987 </span><span class="lineNoCov">          0 :         fputc ('\n', asm_out_file);</span>
<span class="lineNum">   28988 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">   28989 </span><span class="lineCov">         17 :       case ate_kind_label:</span>
<span class="lineNum">   28990 </span><span class="lineCov">         17 :         dw2_asm_output_addr (DWARF2_ADDR_SIZE, entry-&gt;addr.label,</span>
<span class="lineNum">   28991 </span>            :                                  &quot;0x%x&quot;, entry-&gt;index);
<span class="lineNum">   28992 </span><span class="lineCov">         17 :         break;</span>
<span class="lineNum">   28993 </span><span class="lineNoCov">          0 :       default:</span>
<span class="lineNum">   28994 </span><span class="lineNoCov">          0 :         gcc_unreachable ();</span>
<span class="lineNum">   28995 </span>            :     }
<span class="lineNum">   28996 </span>            :   return 1;
<span class="lineNum">   28997 </span>            : }
<span class="lineNum">   28998 </span>            : 
<span class="lineNum">   28999 </span>            : /* A helper function for dwarf2out_finish.  Counts the number
<span class="lineNum">   29000 </span>            :    of indexed addresses.  Must match the logic of the functions
<a name="29001"><span class="lineNum">   29001 </span>            :    output_addr_table_entry above.  */</a>
<span class="lineNum">   29002 </span>            : int
<span class="lineNum">   29003 </span><span class="lineNoCov">          0 : count_index_addrs (addr_table_entry **slot, unsigned int *last_idx)</span>
<span class="lineNum">   29004 </span>            : {
<span class="lineNum">   29005 </span><span class="lineNoCov">          0 :   addr_table_entry *entry = *slot;</span>
<span class="lineNum">   29006 </span>            : 
<span class="lineNum">   29007 </span><span class="lineNoCov">          0 :   if (entry-&gt;refcount &gt; 0)</span>
<span class="lineNum">   29008 </span><span class="lineNoCov">          0 :     *last_idx += 1;</span>
<span class="lineNum">   29009 </span><span class="lineNoCov">          0 :   return 1;</span>
<span class="lineNum">   29010 </span>            : }
<span class="lineNum">   29011 </span>            : 
<span class="lineNum">   29012 </span>            : /* Produce the .debug_addr section.  */
<a name="29013"><span class="lineNum">   29013 </span>            : </a>
<span class="lineNum">   29014 </span>            : static void
<span class="lineNum">   29015 </span><span class="lineCov">          4 : output_addr_table (void)</span>
<span class="lineNum">   29016 </span>            : {
<span class="lineNum">   29017 </span><span class="lineCov">          4 :   unsigned int index = 0;</span>
<span class="lineNum">   29018 </span><span class="lineCov">          4 :   if (addr_index_table == NULL || addr_index_table-&gt;size () == 0)</span>
<span class="lineNum">   29019 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">   29020 </span>            : 
<span class="lineNum">   29021 </span><span class="lineCov">          4 :   switch_to_section (debug_addr_section);</span>
<span class="lineNum">   29022 </span><span class="lineCov">          4 :   addr_index_table</span>
<span class="lineNum">   29023 </span><span class="lineCov">          4 :     -&gt;traverse_noresize&lt;unsigned int *, output_addr_table_entry&gt; (&amp;index);</span>
<span class="lineNum">   29024 </span>            : }
<span class="lineNum">   29025 </span>            : 
<span class="lineNum">   29026 </span>            : #if ENABLE_ASSERT_CHECKING
<span class="lineNum">   29027 </span>            : /* Verify that all marks are clear.  */
<a name="29028"><span class="lineNum">   29028 </span>            : </a>
<span class="lineNum">   29029 </span>            : static void
<span class="lineNum">   29030 </span><span class="lineCov">  224385695 : verify_marks_clear (dw_die_ref die)</span>
<span class="lineNum">   29031 </span>            : {
<span class="lineNum">   29032 </span><span class="lineCov">  224385695 :   dw_die_ref c;</span>
<span class="lineNum">   29033 </span>            : 
<span class="lineNum">   29034 </span><span class="lineCov">  224385695 :   gcc_assert (! die-&gt;die_mark);</span>
<span class="lineNum">   29035 </span><span class="lineCov">  389499772 :   FOR_EACH_CHILD (die, c, verify_marks_clear (c));</span>
<span class="lineNum">   29036 </span><span class="lineCov">  224385695 : }</span>
<span class="lineNum">   29037 </span>            : #endif /* ENABLE_ASSERT_CHECKING */
<span class="lineNum">   29038 </span>            : 
<span class="lineNum">   29039 </span>            : /* Clear the marks for a die and its children.
<span class="lineNum">   29040 </span>            :    Be cool if the mark isn't set.  */
<a name="29041"><span class="lineNum">   29041 </span>            : </a>
<span class="lineNum">   29042 </span>            : static void
<span class="lineNum">   29043 </span><span class="lineCov">   32111946 : prune_unmark_dies (dw_die_ref die)</span>
<span class="lineNum">   29044 </span>            : {
<span class="lineNum">   29045 </span><span class="lineCov">   32111946 :   dw_die_ref c;</span>
<span class="lineNum">   29046 </span>            : 
<span class="lineNum">   29047 </span><span class="lineCov">   32111946 :   if (die-&gt;die_mark)</span>
<span class="lineNum">   29048 </span><span class="lineCov">   32111946 :     die-&gt;die_mark = 0;</span>
<span class="lineNum">   29049 </span><span class="lineCov">   64190225 :   FOR_EACH_CHILD (die, c, prune_unmark_dies (c));</span>
<span class="lineNum">   29050 </span><span class="lineCov">   32111946 : }</span>
<span class="lineNum">   29051 </span>            : 
<span class="lineNum">   29052 </span>            : /* Given LOC that is referenced by a DIE we're marking as used, find all
<span class="lineNum">   29053 </span>            :    referenced DWARF procedures it references and mark them as used.  */
<a name="29054"><span class="lineNum">   29054 </span>            : </a>
<span class="lineNum">   29055 </span>            : static void
<span class="lineNum">   29056 </span><span class="lineCov">      58897 : prune_unused_types_walk_loc_descr (dw_loc_descr_ref loc)</span>
<span class="lineNum">   29057 </span>            : {
<span class="lineNum">   29058 </span><span class="lineCov">     197255 :   for (; loc != NULL; loc = loc-&gt;dw_loc_next)</span>
<span class="lineNum">   29059 </span><span class="lineCov">     138358 :     switch (loc-&gt;dw_loc_opc)</span>
<span class="lineNum">   29060 </span>            :       {
<span class="lineNum">   29061 </span><span class="lineNoCov">          0 :       case DW_OP_implicit_pointer:</span>
<span class="lineNum">   29062 </span><span class="lineNoCov">          0 :       case DW_OP_convert:</span>
<span class="lineNum">   29063 </span><span class="lineNoCov">          0 :       case DW_OP_reinterpret:</span>
<span class="lineNum">   29064 </span><span class="lineNoCov">          0 :       case DW_OP_GNU_implicit_pointer:</span>
<span class="lineNum">   29065 </span><span class="lineNoCov">          0 :       case DW_OP_GNU_convert:</span>
<span class="lineNum">   29066 </span><span class="lineNoCov">          0 :       case DW_OP_GNU_reinterpret:</span>
<span class="lineNum">   29067 </span><span class="lineNoCov">          0 :         if (loc-&gt;dw_loc_oprnd1.val_class == dw_val_class_die_ref)</span>
<span class="lineNum">   29068 </span><span class="lineNoCov">          0 :           prune_unused_types_mark (loc-&gt;dw_loc_oprnd1.v.val_die_ref.die, 1);</span>
<span class="lineNum">   29069 </span>            :         break;
<span class="lineNum">   29070 </span><span class="lineCov">       3040 :       case DW_OP_GNU_variable_value:</span>
<span class="lineNum">   29071 </span><span class="lineCov">       3040 :         if (loc-&gt;dw_loc_oprnd1.val_class == dw_val_class_decl_ref)</span>
<span class="lineNum">   29072 </span>            :           {
<span class="lineNum">   29073 </span><span class="lineCov">       1556 :             dw_die_ref ref</span>
<span class="lineNum">   29074 </span><span class="lineCov">       1556 :               = lookup_decl_die (loc-&gt;dw_loc_oprnd1.v.val_decl_ref);</span>
<span class="lineNum">   29075 </span><span class="lineCov">       1556 :             if (ref == NULL)</span>
<span class="lineNum">   29076 </span>            :               break;
<span class="lineNum">   29077 </span><span class="lineCov">       1002 :             loc-&gt;dw_loc_oprnd1.val_class = dw_val_class_die_ref;</span>
<span class="lineNum">   29078 </span><span class="lineCov">       1002 :             loc-&gt;dw_loc_oprnd1.v.val_die_ref.die = ref;</span>
<span class="lineNum">   29079 </span><span class="lineCov">       1002 :             loc-&gt;dw_loc_oprnd1.v.val_die_ref.external = 0;</span>
<span class="lineNum">   29080 </span>            :           }
<span class="lineNum">   29081 </span>            :         /* FALLTHRU */
<span class="lineNum">   29082 </span><span class="lineCov">       2486 :       case DW_OP_call2:</span>
<span class="lineNum">   29083 </span><span class="lineCov">       2486 :       case DW_OP_call4:</span>
<span class="lineNum">   29084 </span><span class="lineCov">       2486 :       case DW_OP_call_ref:</span>
<span class="lineNum">   29085 </span><span class="lineCov">       2486 :       case DW_OP_const_type:</span>
<span class="lineNum">   29086 </span><span class="lineCov">       2486 :       case DW_OP_GNU_const_type:</span>
<span class="lineNum">   29087 </span><span class="lineCov">       2486 :       case DW_OP_GNU_parameter_ref:</span>
<span class="lineNum">   29088 </span><span class="lineCov">       2486 :         gcc_assert (loc-&gt;dw_loc_oprnd1.val_class == dw_val_class_die_ref);</span>
<span class="lineNum">   29089 </span><span class="lineCov">       2486 :         prune_unused_types_mark (loc-&gt;dw_loc_oprnd1.v.val_die_ref.die, 1);</span>
<span class="lineNum">   29090 </span><span class="lineCov">       2486 :         break;</span>
<span class="lineNum">   29091 </span><span class="lineNoCov">          0 :       case DW_OP_regval_type:</span>
<span class="lineNum">   29092 </span><span class="lineNoCov">          0 :       case DW_OP_deref_type:</span>
<span class="lineNum">   29093 </span><span class="lineNoCov">          0 :       case DW_OP_GNU_regval_type:</span>
<span class="lineNum">   29094 </span><span class="lineNoCov">          0 :       case DW_OP_GNU_deref_type:</span>
<span class="lineNum">   29095 </span><span class="lineNoCov">          0 :         gcc_assert (loc-&gt;dw_loc_oprnd2.val_class == dw_val_class_die_ref);</span>
<span class="lineNum">   29096 </span><span class="lineNoCov">          0 :         prune_unused_types_mark (loc-&gt;dw_loc_oprnd2.v.val_die_ref.die, 1);</span>
<span class="lineNum">   29097 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">   29098 </span><span class="lineNoCov">          0 :       case DW_OP_entry_value:</span>
<span class="lineNum">   29099 </span><span class="lineNoCov">          0 :       case DW_OP_GNU_entry_value:</span>
<span class="lineNum">   29100 </span><span class="lineNoCov">          0 :         gcc_assert (loc-&gt;dw_loc_oprnd1.val_class == dw_val_class_loc);</span>
<span class="lineNum">   29101 </span><span class="lineNoCov">          0 :         prune_unused_types_walk_loc_descr (loc-&gt;dw_loc_oprnd1.v.val_loc);</span>
<span class="lineNum">   29102 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">   29103 </span>            :       default:
<span class="lineNum">   29104 </span>            :         break;
<span class="lineNum">   29105 </span>            :       }
<span class="lineNum">   29106 </span><span class="lineCov">      58897 : }</span>
<span class="lineNum">   29107 </span>            : 
<span class="lineNum">   29108 </span>            : /* Given DIE that we're marking as used, find any other dies
<span class="lineNum">   29109 </span>            :    it references as attributes and mark them as used.  */
<a name="29110"><span class="lineNum">   29110 </span>            : </a>
<span class="lineNum">   29111 </span>            : static void
<span class="lineNum">   29112 </span><span class="lineCov">   32111946 : prune_unused_types_walk_attribs (dw_die_ref die)</span>
<span class="lineNum">   29113 </span>            : {
<span class="lineNum">   29114 </span><span class="lineCov">   32111946 :   dw_attr_node *a;</span>
<span class="lineNum">   29115 </span><span class="lineCov">   32111946 :   unsigned ix;</span>
<span class="lineNum">   29116 </span>            : 
<span class="lineNum">   29117 </span><span class="lineCov">  154647278 :   FOR_EACH_VEC_SAFE_ELT (die-&gt;die_attr, ix, a)</span>
<span class="lineNum">   29118 </span>            :     {
<span class="lineNum">   29119 </span><span class="lineCov">  122535332 :       switch (AT_class (a))</span>
<span class="lineNum">   29120 </span>            :         {
<span class="lineNum">   29121 </span>            :         /* Make sure DWARF procedures referenced by location descriptions will
<span class="lineNum">   29122 </span>            :            get emitted.  */
<span class="lineNum">   29123 </span><span class="lineCov">      58897 :         case dw_val_class_loc:</span>
<span class="lineNum">   29124 </span><span class="lineCov">      58897 :           prune_unused_types_walk_loc_descr (AT_loc (a));</span>
<span class="lineNum">   29125 </span><span class="lineCov">      58897 :           break;</span>
<span class="lineNum">   29126 </span><span class="lineNoCov">          0 :         case dw_val_class_loc_list:</span>
<span class="lineNum">   29127 </span><span class="lineNoCov">          0 :           for (dw_loc_list_ref list = AT_loc_list (a);</span>
<span class="lineNum">   29128 </span><span class="lineNoCov">          0 :                list != NULL;</span>
<span class="lineNum">   29129 </span><span class="lineNoCov">          0 :                list = list-&gt;dw_loc_next)</span>
<span class="lineNum">   29130 </span><span class="lineNoCov">          0 :             prune_unused_types_walk_loc_descr (list-&gt;expr);</span>
<span class="lineNum">   29131 </span>            :           break;
<span class="lineNum">   29132 </span>            : 
<span class="lineNum">   29133 </span>            :         case dw_val_class_view_list:
<span class="lineNum">   29134 </span>            :           /* This points to a loc_list in another attribute, so it's
<span class="lineNum">   29135 </span>            :              already covered.  */
<span class="lineNum">   29136 </span>            :           break;
<span class="lineNum">   29137 </span>            : 
<span class="lineNum">   29138 </span><span class="lineCov">   31655257 :         case dw_val_class_die_ref:</span>
<span class="lineNum">   29139 </span>            :           /* A reference to another DIE.
<span class="lineNum">   29140 </span>            :              Make sure that it will get emitted.
<span class="lineNum">   29141 </span>            :              If it was broken out into a comdat group, don't follow it.  */
<span class="lineNum">   29142 </span><span class="lineCov">   31655257 :           if (! AT_ref (a)-&gt;comdat_type_p</span>
<span class="lineNum">   29143 </span><span class="lineCov">   31655257 :               || a-&gt;dw_attr == DW_AT_specification)</span>
<span class="lineNum">   29144 </span><span class="lineCov">   31655088 :             prune_unused_types_mark (a-&gt;dw_attr_val.v.val_die_ref.die, 1);</span>
<span class="lineNum">   29145 </span>            :           break;
<span class="lineNum">   29146 </span>            : 
<span class="lineNum">   29147 </span><span class="lineCov">   20783709 :         case dw_val_class_str:</span>
<span class="lineNum">   29148 </span>            :           /* Set the string's refcount to 0 so that prune_unused_types_mark
<span class="lineNum">   29149 </span>            :              accounts properly for it.  */
<span class="lineNum">   29150 </span><span class="lineCov">   20783709 :           a-&gt;dw_attr_val.v.val_str-&gt;refcount = 0;</span>
<span class="lineNum">   29151 </span><span class="lineCov">   20783709 :           break;</span>
<span class="lineNum">   29152 </span>            : 
<span class="lineNum">   29153 </span>            :         default:
<span class="lineNum">   29154 </span>            :           break;
<span class="lineNum">   29155 </span>            :         }
<span class="lineNum">   29156 </span>            :     }
<span class="lineNum">   29157 </span><span class="lineCov">   32111946 : }</span>
<span class="lineNum">   29158 </span>            : 
<span class="lineNum">   29159 </span>            : /* Mark the generic parameters and arguments children DIEs of DIE.  */
<a name="29160"><span class="lineNum">   29160 </span>            : </a>
<span class="lineNum">   29161 </span>            : static void
<span class="lineNum">   29162 </span><span class="lineCov">   10448644 : prune_unused_types_mark_generic_parms_dies (dw_die_ref die)</span>
<span class="lineNum">   29163 </span>            : {
<span class="lineNum">   29164 </span><span class="lineCov">   10448644 :   dw_die_ref c;</span>
<span class="lineNum">   29165 </span>            : 
<span class="lineNum">   29166 </span><span class="lineCov">   10448644 :   if (die == NULL || die-&gt;die_child == NULL)</span>
<span class="lineNum">   29167 </span>            :     return;
<span class="lineNum">   29168 </span>            :   c = die-&gt;die_child;
<span class="lineNum">   29169 </span><span class="lineCov">   11787410 :   do</span>
<span class="lineNum">   29170 </span>            :     {
<span class="lineNum">   29171 </span><span class="lineCov">   11787410 :       if (is_template_parameter (c))</span>
<span class="lineNum">   29172 </span><span class="lineCov">     875465 :         prune_unused_types_mark (c, 1);</span>
<span class="lineNum">   29173 </span><span class="lineCov">   11787410 :       c = c-&gt;die_sib;</span>
<span class="lineNum">   29174 </span><span class="lineCov">   11787410 :     } while (c &amp;&amp; c != die-&gt;die_child);</span>
<span class="lineNum">   29175 </span>            : }
<span class="lineNum">   29176 </span>            : 
<span class="lineNum">   29177 </span>            : /* Mark DIE as being used.  If DOKIDS is true, then walk down
<span class="lineNum">   29178 </span>            :    to DIE's children.  */
<a name="29179"><span class="lineNum">   29179 </span>            : </a>
<span class="lineNum">   29180 </span>            : static void
<span class="lineNum">   29181 </span><span class="lineCov">   43393086 : prune_unused_types_mark (dw_die_ref die, int dokids)</span>
<span class="lineNum">   29182 </span>            : {
<span class="lineNum">   29183 </span><span class="lineCov">   43393086 :   dw_die_ref c;</span>
<span class="lineNum">   29184 </span>            : 
<span class="lineNum">   29185 </span><span class="lineCov">   43393086 :   if (die-&gt;die_mark == 0)</span>
<span class="lineNum">   29186 </span>            :     {
<span class="lineNum">   29187 </span>            :       /* We haven't done this node yet.  Mark it as used.  */
<span class="lineNum">   29188 </span><span class="lineCov">   10448644 :       die-&gt;die_mark = 1;</span>
<span class="lineNum">   29189 </span>            :       /* If this is the DIE of a generic type instantiation,
<span class="lineNum">   29190 </span>            :          mark the children DIEs that describe its generic parms and
<span class="lineNum">   29191 </span>            :          args.  */
<span class="lineNum">   29192 </span><span class="lineCov">   10448644 :       prune_unused_types_mark_generic_parms_dies (die);</span>
<span class="lineNum">   29193 </span>            : 
<span class="lineNum">   29194 </span>            :       /* We also have to mark its parents as used.
<span class="lineNum">   29195 </span>            :          (But we don't want to mark our parent's kids due to this,
<span class="lineNum">   29196 </span>            :          unless it is a class.)  */
<span class="lineNum">   29197 </span><span class="lineCov">   10448644 :       if (die-&gt;die_parent)</span>
<span class="lineNum">   29198 </span><span class="lineCov">   19378463 :         prune_unused_types_mark (die-&gt;die_parent,</span>
<span class="lineNum">   29199 </span>            :                                  class_scope_p (die-&gt;die_parent));
<span class="lineNum">   29200 </span>            : 
<span class="lineNum">   29201 </span>            :       /* Mark any referenced nodes.  */
<span class="lineNum">   29202 </span><span class="lineCov">   10448644 :       prune_unused_types_walk_attribs (die);</span>
<span class="lineNum">   29203 </span>            : 
<span class="lineNum">   29204 </span>            :       /* If this node is a specification,
<span class="lineNum">   29205 </span>            :          also mark the definition, if it exists.  */
<span class="lineNum">   29206 </span><span class="lineCov">   10448644 :       if (get_AT_flag (die, DW_AT_declaration) &amp;&amp; die-&gt;die_definition)</span>
<span class="lineNum">   29207 </span><span class="lineCov">     255953 :         prune_unused_types_mark (die-&gt;die_definition, 1);</span>
<span class="lineNum">   29208 </span>            :     }
<span class="lineNum">   29209 </span>            : 
<span class="lineNum">   29210 </span><span class="lineCov">   43393086 :   if (dokids &amp;&amp; die-&gt;die_mark != 2)</span>
<span class="lineNum">   29211 </span>            :     {
<span class="lineNum">   29212 </span>            :       /* We need to walk the children, but haven't done so yet.
<span class="lineNum">   29213 </span>            :          Remember that we've walked the kids.  */
<span class="lineNum">   29214 </span><span class="lineCov">    9945296 :       die-&gt;die_mark = 2;</span>
<span class="lineNum">   29215 </span>            : 
<span class="lineNum">   29216 </span>            :       /* If this is an array type, we need to make sure our
<span class="lineNum">   29217 </span>            :          kids get marked, even if they're types.  If we're
<span class="lineNum">   29218 </span>            :          breaking out types into comdat sections, do this
<span class="lineNum">   29219 </span>            :          for all type definitions.  */
<span class="lineNum">   29220 </span><span class="lineCov">    9945296 :       if (die-&gt;die_tag == DW_TAG_array_type</span>
<span class="lineNum">   29221 </span><span class="lineCov">    9945296 :           || (use_debug_types</span>
<span class="lineNum">   29222 </span><span class="lineCov">       1410 :               &amp;&amp; is_type_die (die) &amp;&amp; ! is_declaration_die (die)))</span>
<span class="lineNum">   29223 </span><span class="lineCov">     153017 :         FOR_EACH_CHILD (die, c, prune_unused_types_mark (c, 1));</span>
<span class="lineNum">   29224 </span>            :       else
<span class="lineNum">   29225 </span><span class="lineCov">   18224529 :         FOR_EACH_CHILD (die, c, prune_unused_types_walk (c));</span>
<span class="lineNum">   29226 </span>            :     }
<span class="lineNum">   29227 </span><span class="lineCov">   43393086 : }</span>
<span class="lineNum">   29228 </span>            : 
<span class="lineNum">   29229 </span>            : /* For local classes, look if any static member functions were emitted
<span class="lineNum">   29230 </span>            :    and if so, mark them.  */
<a name="29231"><span class="lineNum">   29231 </span>            : </a>
<span class="lineNum">   29232 </span>            : static void
<span class="lineNum">   29233 </span><span class="lineCov">      24752 : prune_unused_types_walk_local_classes (dw_die_ref die)</span>
<span class="lineNum">   29234 </span>            : {
<span class="lineNum">   29235 </span><span class="lineCov">      24752 :   dw_die_ref c;</span>
<span class="lineNum">   29236 </span>            : 
<span class="lineNum">   29237 </span><span class="lineCov">      24752 :   if (die-&gt;die_mark == 2)</span>
<span class="lineNum">   29238 </span>            :     return;
<span class="lineNum">   29239 </span>            : 
<span class="lineNum">   29240 </span><span class="lineCov">      22249 :   switch (die-&gt;die_tag)</span>
<span class="lineNum">   29241 </span>            :     {
<span class="lineNum">   29242 </span><span class="lineCov">       5179 :     case DW_TAG_structure_type:</span>
<span class="lineNum">   29243 </span><span class="lineCov">       5179 :     case DW_TAG_union_type:</span>
<span class="lineNum">   29244 </span><span class="lineCov">       5179 :     case DW_TAG_class_type:</span>
<span class="lineNum">   29245 </span><span class="lineCov">       5179 :       break;</span>
<span class="lineNum">   29246 </span>            : 
<span class="lineNum">   29247 </span><span class="lineCov">       8165 :     case DW_TAG_subprogram:</span>
<span class="lineNum">   29248 </span><span class="lineCov">       8165 :       if (!get_AT_flag (die, DW_AT_declaration)</span>
<span class="lineNum">   29249 </span><span class="lineCov">       8165 :           || die-&gt;die_definition != NULL)</span>
<span class="lineNum">   29250 </span><span class="lineCov">       2276 :         prune_unused_types_mark (die, 1);</span>
<span class="lineNum">   29251 </span>            :       return;
<span class="lineNum">   29252 </span>            : 
<span class="lineNum">   29253 </span>            :     default:
<span class="lineNum">   29254 </span>            :       return;
<span class="lineNum">   29255 </span>            :     }
<span class="lineNum">   29256 </span>            : 
<span class="lineNum">   29257 </span>            :   /* Mark children.  */
<span class="lineNum">   29258 </span><span class="lineCov">      19608 :   FOR_EACH_CHILD (die, c, prune_unused_types_walk_local_classes (c));</span>
<span class="lineNum">   29259 </span>            : }
<span class="lineNum">   29260 </span>            : 
<span class="lineNum">   29261 </span>            : /* Walk the tree DIE and mark types that we actually use.  */
<a name="29262"><span class="lineNum">   29262 </span>            : </a>
<span class="lineNum">   29263 </span>            : static void
<span class="lineNum">   29264 </span><span class="lineCov">   71524049 : prune_unused_types_walk (dw_die_ref die)</span>
<span class="lineNum">   29265 </span>            : {
<span class="lineNum">   29266 </span><span class="lineCov">   71524049 :   dw_die_ref c;</span>
<span class="lineNum">   29267 </span>            : 
<span class="lineNum">   29268 </span>            :   /* Don't do anything if this node is already marked and
<span class="lineNum">   29269 </span>            :      children have been marked as well.  */
<span class="lineNum">   29270 </span><span class="lineCov">   71524049 :   if (die-&gt;die_mark == 2)</span>
<span class="lineNum">   29271 </span>            :     return;
<span class="lineNum">   29272 </span>            : 
<span class="lineNum">   29273 </span><span class="lineCov">   64131261 :   switch (die-&gt;die_tag)</span>
<span class="lineNum">   29274 </span>            :     {
<span class="lineNum">   29275 </span><span class="lineCov">   24283864 :     case DW_TAG_structure_type:</span>
<span class="lineNum">   29276 </span><span class="lineCov">   24283864 :     case DW_TAG_union_type:</span>
<span class="lineNum">   29277 </span><span class="lineCov">   24283864 :     case DW_TAG_class_type:</span>
<span class="lineNum">   29278 </span><span class="lineCov">   24283864 :       if (die-&gt;die_perennial_p)</span>
<span class="lineNum">   29279 </span>            :         break;
<span class="lineNum">   29280 </span>            : 
<span class="lineNum">   29281 </span><span class="lineCov">   72721501 :       for (c = die-&gt;die_parent; c; c = c-&gt;die_parent)</span>
<span class="lineNum">   29282 </span><span class="lineCov">   48468056 :         if (c-&gt;die_tag == DW_TAG_subprogram)</span>
<span class="lineNum">   29283 </span>            :           break;
<span class="lineNum">   29284 </span>            : 
<span class="lineNum">   29285 </span>            :       /* Finding used static member functions inside of classes
<span class="lineNum">   29286 </span>            :          is needed just for local classes, because for other classes
<span class="lineNum">   29287 </span>            :          static member function DIEs with DW_AT_specification
<span class="lineNum">   29288 </span>            :          are emitted outside of the DW_TAG_*_type.  If we ever change
<span class="lineNum">   29289 </span>            :          it, we'd need to call this even for non-local classes.  */
<span class="lineNum">   29290 </span><span class="lineCov">   24258624 :       if (c)</span>
<span class="lineNum">   29291 </span><span class="lineCov">       5179 :         prune_unused_types_walk_local_classes (die);</span>
<span class="lineNum">   29292 </span>            : 
<span class="lineNum">   29293 </span>            :       /* It's a type node --- don't mark it.  */
<span class="lineNum">   29294 </span>            :       return;
<span class="lineNum">   29295 </span>            : 
<span class="lineNum">   29296 </span><span class="lineCov">   17527855 :     case DW_TAG_const_type:</span>
<span class="lineNum">   29297 </span><span class="lineCov">   17527855 :     case DW_TAG_packed_type:</span>
<span class="lineNum">   29298 </span><span class="lineCov">   17527855 :     case DW_TAG_pointer_type:</span>
<span class="lineNum">   29299 </span><span class="lineCov">   17527855 :     case DW_TAG_reference_type:</span>
<span class="lineNum">   29300 </span><span class="lineCov">   17527855 :     case DW_TAG_rvalue_reference_type:</span>
<span class="lineNum">   29301 </span><span class="lineCov">   17527855 :     case DW_TAG_volatile_type:</span>
<span class="lineNum">   29302 </span><span class="lineCov">   17527855 :     case DW_TAG_typedef:</span>
<span class="lineNum">   29303 </span><span class="lineCov">   17527855 :     case DW_TAG_array_type:</span>
<span class="lineNum">   29304 </span><span class="lineCov">   17527855 :     case DW_TAG_interface_type:</span>
<span class="lineNum">   29305 </span><span class="lineCov">   17527855 :     case DW_TAG_friend:</span>
<span class="lineNum">   29306 </span><span class="lineCov">   17527855 :     case DW_TAG_enumeration_type:</span>
<span class="lineNum">   29307 </span><span class="lineCov">   17527855 :     case DW_TAG_subroutine_type:</span>
<span class="lineNum">   29308 </span><span class="lineCov">   17527855 :     case DW_TAG_string_type:</span>
<span class="lineNum">   29309 </span><span class="lineCov">   17527855 :     case DW_TAG_set_type:</span>
<span class="lineNum">   29310 </span><span class="lineCov">   17527855 :     case DW_TAG_subrange_type:</span>
<span class="lineNum">   29311 </span><span class="lineCov">   17527855 :     case DW_TAG_ptr_to_member_type:</span>
<span class="lineNum">   29312 </span><span class="lineCov">   17527855 :     case DW_TAG_file_type:</span>
<span class="lineNum">   29313 </span>            :       /* Type nodes are useful only when other DIEs reference them --- don't
<span class="lineNum">   29314 </span>            :          mark them.  */
<span class="lineNum">   29315 </span>            :       /* FALLTHROUGH */
<span class="lineNum">   29316 </span>            : 
<span class="lineNum">   29317 </span><span class="lineCov">   17527855 :     case DW_TAG_dwarf_procedure:</span>
<span class="lineNum">   29318 </span>            :       /* Likewise for DWARF procedures.  */
<span class="lineNum">   29319 </span>            : 
<span class="lineNum">   29320 </span><span class="lineCov">   17527855 :       if (die-&gt;die_perennial_p)</span>
<span class="lineNum">   29321 </span>            :         break;
<span class="lineNum">   29322 </span>            : 
<span class="lineNum">   29323 </span>            :       return;
<span class="lineNum">   29324 </span>            : 
<span class="lineNum">   29325 </span>            :     default:
<span class="lineNum">   29326 </span>            :       /* Mark everything else.  */
<span class="lineNum">   29327 </span>            :       break;
<span class="lineNum">   29328 </span>            :   }
<span class="lineNum">   29329 </span>            : 
<span class="lineNum">   29330 </span><span class="lineCov">   22413485 :   if (die-&gt;die_mark == 0)</span>
<span class="lineNum">   29331 </span>            :     {
<span class="lineNum">   29332 </span><span class="lineCov">   21663302 :       die-&gt;die_mark = 1;</span>
<span class="lineNum">   29333 </span>            : 
<span class="lineNum">   29334 </span>            :       /* Now, mark any dies referenced from here.  */
<span class="lineNum">   29335 </span><span class="lineCov">   21663302 :       prune_unused_types_walk_attribs (die);</span>
<span class="lineNum">   29336 </span>            :     }
<span class="lineNum">   29337 </span>            : 
<span class="lineNum">   29338 </span><span class="lineCov">   22413485 :   die-&gt;die_mark = 2;</span>
<span class="lineNum">   29339 </span>            : 
<span class="lineNum">   29340 </span>            :   /* Mark children.  */
<span class="lineNum">   29341 </span><span class="lineCov">   78602205 :   FOR_EACH_CHILD (die, c, prune_unused_types_walk (c));</span>
<span class="lineNum">   29342 </span>            : }
<span class="lineNum">   29343 </span>            : 
<span class="lineNum">   29344 </span>            : /* Increment the string counts on strings referred to from DIE's
<span class="lineNum">   29345 </span>            :    attributes.  */
<a name="29346"><span class="lineNum">   29346 </span>            : </a>
<span class="lineNum">   29347 </span>            : static void
<span class="lineNum">   29348 </span><span class="lineCov">   32111946 : prune_unused_types_update_strings (dw_die_ref die)</span>
<span class="lineNum">   29349 </span>            : {
<span class="lineNum">   29350 </span><span class="lineCov">   32111946 :   dw_attr_node *a;</span>
<span class="lineNum">   29351 </span><span class="lineCov">   32111946 :   unsigned ix;</span>
<span class="lineNum">   29352 </span>            : 
<span class="lineNum">   29353 </span><span class="lineCov">  154647278 :   FOR_EACH_VEC_SAFE_ELT (die-&gt;die_attr, ix, a)</span>
<span class="lineNum">   29354 </span><span class="lineCov">  122535332 :     if (AT_class (a) == dw_val_class_str)</span>
<span class="lineNum">   29355 </span>            :       {
<span class="lineNum">   29356 </span><span class="lineCov">   20783709 :         struct indirect_string_node *s = a-&gt;dw_attr_val.v.val_str;</span>
<span class="lineNum">   29357 </span><span class="lineCov">   20783709 :         s-&gt;refcount++;</span>
<span class="lineNum">   29358 </span>            :         /* Avoid unnecessarily putting strings that are used less than
<span class="lineNum">   29359 </span>            :            twice in the hash table.  */
<span class="lineNum">   29360 </span><span class="lineCov">   20783709 :         if (s-&gt;refcount</span>
<span class="lineNum">   29361 </span><span class="lineCov">   20783709 :             == ((DEBUG_STR_SECTION_FLAGS &amp; SECTION_MERGE) ? 1 : 2))</span>
<span class="lineNum">   29362 </span>            :           {
<span class="lineNum">   29363 </span><span class="lineCov">   13445402 :             indirect_string_node **slot</span>
<span class="lineNum">   29364 </span><span class="lineCov">   13445402 :               = debug_str_hash-&gt;find_slot_with_hash (s-&gt;str,</span>
<span class="lineNum">   29365 </span><span class="lineCov">   13445402 :                                                      htab_hash_string (s-&gt;str),</span>
<span class="lineNum">   29366 </span>            :                                                      INSERT);
<span class="lineNum">   29367 </span><span class="lineCov">   13445402 :             gcc_assert (*slot == NULL);</span>
<span class="lineNum">   29368 </span><span class="lineCov">   13445402 :             *slot = s;</span>
<span class="lineNum">   29369 </span>            :           }
<span class="lineNum">   29370 </span>            :       }
<span class="lineNum">   29371 </span><span class="lineCov">   32111946 : }</span>
<span class="lineNum">   29372 </span>            : 
<span class="lineNum">   29373 </span>            : /* Mark DIE and its children as removed.  */
<a name="29374"><span class="lineNum">   29374 </span>            : </a>
<span class="lineNum">   29375 </span>            : static void
<span class="lineNum">   29376 </span><span class="lineCov">  152811586 : mark_removed (dw_die_ref die)</span>
<span class="lineNum">   29377 </span>            : {
<span class="lineNum">   29378 </span><span class="lineCov">  192273692 :   dw_die_ref c;</span>
<span class="lineNum">   29379 </span><span class="lineCov">  192273692 :   die-&gt;removed = true;</span>
<span class="lineNum">   29380 </span><span class="lineCov">  305623172 :   FOR_EACH_CHILD (die, c, mark_removed (c));</span>
<span class="lineNum">   29381 </span><span class="lineCov">  152811586 : }</span>
<span class="lineNum">   29382 </span>            : 
<span class="lineNum">   29383 </span>            : /* Remove from the tree DIE any dies that aren't marked.  */
<a name="29384"><span class="lineNum">   29384 </span>            : </a>
<span class="lineNum">   29385 </span>            : static void
<span class="lineNum">   29386 </span><span class="lineCov">   32111946 : prune_unused_types_prune (dw_die_ref die)</span>
<span class="lineNum">   29387 </span>            : {
<span class="lineNum">   29388 </span><span class="lineCov">   32111946 :   dw_die_ref c;</span>
<span class="lineNum">   29389 </span>            : 
<span class="lineNum">   29390 </span><span class="lineCov">   32111946 :   gcc_assert (die-&gt;die_mark);</span>
<span class="lineNum">   29391 </span><span class="lineCov">   32111946 :   prune_unused_types_update_strings (die);</span>
<span class="lineNum">   29392 </span>            : 
<span class="lineNum">   29393 </span><span class="lineCov">   32111946 :   if (! die-&gt;die_child)</span>
<span class="lineNum">   29394 </span>            :     return;
<span class="lineNum">   29395 </span>            : 
<span class="lineNum">   29396 </span>            :   c = die-&gt;die_child;
<span class="lineNum">   29397 </span><span class="lineCov">   32195219 :   do {</span>
<span class="lineNum">   29398 </span><span class="lineCov">   32195219 :     dw_die_ref prev = c, next;</span>
<span class="lineNum">   29399 </span><span class="lineCov">   71540385 :     for (c = c-&gt;die_sib; ! c-&gt;die_mark; c = next)</span>
<span class="lineNum">   29400 </span><span class="lineCov">   39462106 :       if (c == die-&gt;die_child)</span>
<span class="lineNum">   29401 </span>            :         {
<span class="lineNum">   29402 </span>            :           /* No marked children between 'prev' and the end of the list.  */
<span class="lineNum">   29403 </span><span class="lineCov">     116940 :           if (prev == c)</span>
<span class="lineNum">   29404 </span>            :             /* No marked children at all.  */
<span class="lineNum">   29405 </span><span class="lineCov">      45625 :             die-&gt;die_child = NULL;</span>
<span class="lineNum">   29406 </span>            :           else
<span class="lineNum">   29407 </span>            :             {
<span class="lineNum">   29408 </span><span class="lineCov">      71315 :               prev-&gt;die_sib = c-&gt;die_sib;</span>
<span class="lineNum">   29409 </span><span class="lineCov">      71315 :               die-&gt;die_child = prev;</span>
<span class="lineNum">   29410 </span>            :             }
<span class="lineNum">   29411 </span><span class="lineCov">     116940 :           c-&gt;die_sib = NULL;</span>
<span class="lineNum">   29412 </span><span class="lineCov">     116940 :           mark_removed (c);</span>
<span class="lineNum">   29413 </span><span class="lineCov">     116940 :           return;</span>
<span class="lineNum">   29414 </span>            :         }
<span class="lineNum">   29415 </span>            :       else
<span class="lineNum">   29416 </span>            :         {
<span class="lineNum">   29417 </span><span class="lineCov">   39345166 :           next = c-&gt;die_sib;</span>
<span class="lineNum">   29418 </span><span class="lineCov">   39345166 :           c-&gt;die_sib = NULL;</span>
<span class="lineNum">   29419 </span><span class="lineCov">   39345166 :           mark_removed (c);</span>
<span class="lineNum">   29420 </span>            :         }
<span class="lineNum">   29421 </span>            : 
<span class="lineNum">   29422 </span><span class="lineCov">   32078279 :     if (c != prev-&gt;die_sib)</span>
<span class="lineNum">   29423 </span><span class="lineCov">    1633761 :       prev-&gt;die_sib = c;</span>
<span class="lineNum">   29424 </span><span class="lineCov">   32078279 :     prune_unused_types_prune (c);</span>
<span class="lineNum">   29425 </span><span class="lineCov">   32078279 :   } while (c != die-&gt;die_child);</span>
<span class="lineNum">   29426 </span>            : }
<span class="lineNum">   29427 </span>            : 
<span class="lineNum">   29428 </span>            : /* Remove dies representing declarations that we never use.  */
<a name="29429"><span class="lineNum">   29429 </span>            : </a>
<span class="lineNum">   29430 </span>            : static void
<span class="lineNum">   29431 </span><span class="lineCov">      33619 : prune_unused_types (void)</span>
<span class="lineNum">   29432 </span>            : {
<span class="lineNum">   29433 </span><span class="lineCov">      33619 :   unsigned int i;</span>
<span class="lineNum">   29434 </span><span class="lineCov">      33619 :   limbo_die_node *node;</span>
<span class="lineNum">   29435 </span><span class="lineCov">      33619 :   comdat_type_node *ctnode;</span>
<span class="lineNum">   29436 </span><span class="lineCov">      33619 :   pubname_entry *pub;</span>
<span class="lineNum">   29437 </span><span class="lineCov">      33619 :   dw_die_ref base_type;</span>
<span class="lineNum">   29438 </span>            : 
<span class="lineNum">   29439 </span>            : #if ENABLE_ASSERT_CHECKING
<span class="lineNum">   29440 </span>            :   /* All the marks should already be clear.  */
<span class="lineNum">   29441 </span><span class="lineCov">      33619 :   verify_marks_clear (comp_unit_die ());</span>
<span class="lineNum">   29442 </span><span class="lineCov">      33634 :   for (node = limbo_die_list; node; node = node-&gt;next)</span>
<span class="lineNum">   29443 </span><span class="lineCov">         15 :     verify_marks_clear (node-&gt;die);</span>
<span class="lineNum">   29444 </span><span class="lineCov">      33667 :   for (ctnode = comdat_type_list; ctnode; ctnode = ctnode-&gt;next)</span>
<span class="lineNum">   29445 </span><span class="lineCov">         48 :     verify_marks_clear (ctnode-&gt;root_die);</span>
<span class="lineNum">   29446 </span>            : #endif /* ENABLE_ASSERT_CHECKING */
<span class="lineNum">   29447 </span>            : 
<span class="lineNum">   29448 </span>            :   /* Mark types that are used in global variables.  */
<span class="lineNum">   29449 </span><span class="lineCov">      33619 :   premark_types_used_by_global_vars ();</span>
<span class="lineNum">   29450 </span>            : 
<span class="lineNum">   29451 </span>            :   /* Set the mark on nodes that are actually used.  */
<span class="lineNum">   29452 </span><span class="lineCov">      33619 :   prune_unused_types_walk (comp_unit_die ());</span>
<span class="lineNum">   29453 </span><span class="lineCov">      33634 :   for (node = limbo_die_list; node; node = node-&gt;next)</span>
<span class="lineNum">   29454 </span><span class="lineCov">         15 :     prune_unused_types_walk (node-&gt;die);</span>
<span class="lineNum">   29455 </span><span class="lineCov">      33667 :   for (ctnode = comdat_type_list; ctnode; ctnode = ctnode-&gt;next)</span>
<span class="lineNum">   29456 </span>            :     {
<span class="lineNum">   29457 </span><span class="lineCov">         48 :       prune_unused_types_walk (ctnode-&gt;root_die);</span>
<span class="lineNum">   29458 </span><span class="lineCov">         48 :       prune_unused_types_mark (ctnode-&gt;type_die, 1);</span>
<span class="lineNum">   29459 </span>            :     }
<span class="lineNum">   29460 </span>            : 
<span class="lineNum">   29461 </span>            :   /* Also set the mark on nodes referenced from the pubname_table.  Enumerators
<span class="lineNum">   29462 </span>            :      are unusual in that they are pubnames that are the children of pubtypes.
<span class="lineNum">   29463 </span>            :      They should only be marked via their parent DW_TAG_enumeration_type die,
<span class="lineNum">   29464 </span>            :      not as roots in themselves.  */
<span class="lineNum">   29465 </span><span class="lineCov">      33883 :   FOR_EACH_VEC_ELT (*pubname_table, i, pub)</span>
<span class="lineNum">   29466 </span><span class="lineCov">        264 :     if (pub-&gt;die-&gt;die_tag != DW_TAG_enumerator)</span>
<span class="lineNum">   29467 </span><span class="lineCov">        228 :       prune_unused_types_mark (pub-&gt;die, 1);</span>
<span class="lineNum">   29468 </span><span class="lineCov">      33619 :   for (i = 0; base_types.iterate (i, &amp;base_type); i++)</span>
<span class="lineNum">   29469 </span><span class="lineNoCov">          0 :     prune_unused_types_mark (base_type, 1);</span>
<span class="lineNum">   29470 </span>            : 
<span class="lineNum">   29471 </span>            :   /* For -fvar-tracking-assignments, also set the mark on nodes that could be
<span class="lineNum">   29472 </span>            :      referenced by DW_TAG_call_site DW_AT_call_origin (i.e. direct call
<span class="lineNum">   29473 </span>            :      callees).  */
<span class="lineNum">   29474 </span><span class="lineCov">      33619 :   cgraph_node *cnode;</span>
<span class="lineNum">   29475 </span><span class="lineCov">    3563448 :   FOR_EACH_FUNCTION (cnode)</span>
<span class="lineNum">   29476 </span><span class="lineCov">    1748105 :     if (cnode-&gt;referred_to_p (false))</span>
<span class="lineNum">   29477 </span>            :       {
<span class="lineNum">   29478 </span><span class="lineCov">    1604047 :         dw_die_ref die = lookup_decl_die (cnode-&gt;decl);</span>
<span class="lineNum">   29479 </span><span class="lineCov">    1604047 :         if (die == NULL || die-&gt;die_mark)</span>
<span class="lineNum">   29480 </span>            :           continue;
<span class="lineNum">   29481 </span><span class="lineCov">        178 :         for (cgraph_edge *e = cnode-&gt;callers; e; e = e-&gt;next_caller)</span>
<span class="lineNum">   29482 </span><span class="lineCov">        178 :           if (e-&gt;caller != cnode</span>
<span class="lineNum">   29483 </span><span class="lineCov">        178 :               &amp;&amp; opt_for_fn (e-&gt;caller-&gt;decl, flag_var_tracking_assignments))</span>
<span class="lineNum">   29484 </span>            :             {
<span class="lineNum">   29485 </span><span class="lineCov">        178 :               prune_unused_types_mark (die, 1);</span>
<span class="lineNum">   29486 </span><span class="lineCov">        178 :               break;</span>
<span class="lineNum">   29487 </span>            :             }
<span class="lineNum">   29488 </span>            :       }
<span class="lineNum">   29489 </span>            : 
<span class="lineNum">   29490 </span><span class="lineCov">      33619 :   if (debug_str_hash)</span>
<span class="lineNum">   29491 </span><span class="lineCov">      33619 :     debug_str_hash-&gt;empty ();</span>
<span class="lineNum">   29492 </span><span class="lineCov">      33619 :   if (skeleton_debug_str_hash)</span>
<span class="lineNum">   29493 </span><span class="lineNoCov">          0 :     skeleton_debug_str_hash-&gt;empty ();</span>
<span class="lineNum">   29494 </span><span class="lineCov">      33619 :   prune_unused_types_prune (comp_unit_die ());</span>
<span class="lineNum">   29495 </span><span class="lineCov">      33634 :   for (limbo_die_node **pnode = &amp;limbo_die_list; *pnode; )</span>
<span class="lineNum">   29496 </span>            :     {
<span class="lineNum">   29497 </span><span class="lineCov">         15 :       node = *pnode;</span>
<span class="lineNum">   29498 </span><span class="lineCov">         15 :       if (!node-&gt;die-&gt;die_mark)</span>
<span class="lineNum">   29499 </span><span class="lineCov">         15 :         *pnode = node-&gt;next;</span>
<span class="lineNum">   29500 </span>            :       else
<span class="lineNum">   29501 </span>            :         {
<span class="lineNum">   29502 </span><span class="lineNoCov">          0 :           prune_unused_types_prune (node-&gt;die);</span>
<span class="lineNum">   29503 </span><span class="lineNoCov">          0 :           pnode = &amp;node-&gt;next;</span>
<span class="lineNum">   29504 </span>            :         }
<span class="lineNum">   29505 </span>            :     }
<span class="lineNum">   29506 </span><span class="lineCov">      33667 :   for (ctnode = comdat_type_list; ctnode; ctnode = ctnode-&gt;next)</span>
<span class="lineNum">   29507 </span><span class="lineCov">         48 :     prune_unused_types_prune (ctnode-&gt;root_die);</span>
<span class="lineNum">   29508 </span>            : 
<span class="lineNum">   29509 </span>            :   /* Leave the marks clear.  */
<span class="lineNum">   29510 </span><span class="lineCov">      33619 :   prune_unmark_dies (comp_unit_die ());</span>
<span class="lineNum">   29511 </span><span class="lineCov">      33619 :   for (node = limbo_die_list; node; node = node-&gt;next)</span>
<span class="lineNum">   29512 </span><span class="lineNoCov">          0 :     prune_unmark_dies (node-&gt;die);</span>
<span class="lineNum">   29513 </span><span class="lineCov">      33667 :   for (ctnode = comdat_type_list; ctnode; ctnode = ctnode-&gt;next)</span>
<span class="lineNum">   29514 </span><span class="lineCov">         48 :     prune_unmark_dies (ctnode-&gt;root_die);</span>
<span class="lineNum">   29515 </span><span class="lineCov">      33619 : }</span>
<span class="lineNum">   29516 </span>            : 
<span class="lineNum">   29517 </span>            : /* Helpers to manipulate hash table of comdat type units.  */
<span class="lineNum">   29518 </span>            : 
<span class="lineNum">   29519 </span>            : struct comdat_type_hasher : nofree_ptr_hash &lt;comdat_type_node&gt;
<span class="lineNum">   29520 </span>            : {
<span class="lineNum">   29521 </span>            :   static inline hashval_t hash (const comdat_type_node *);
<span class="lineNum">   29522 </span>            :   static inline bool equal (const comdat_type_node *, const comdat_type_node *);
<span class="lineNum">   29523 </span>            : };
<span class="lineNum">   29524 </span>            : 
<span class="lineNum">   29525 </span>            : inline hashval_t
<span class="lineNum">   29526 </span>            : comdat_type_hasher::hash (const comdat_type_node *type_node)
<span class="lineNum">   29527 </span>            : {
<span class="lineNum">   29528 </span><span class="lineCov">         48 :   hashval_t h;</span>
<span class="lineNum">   29529 </span><span class="lineCov">         48 :   memcpy (&amp;h, type_node-&gt;signature, sizeof (h));</span>
<span class="lineNum">   29530 </span><span class="lineCov">         48 :   return h;</span>
<span class="lineNum">   29531 </span>            : }
<span class="lineNum">   29532 </span>            : 
<span class="lineNum">   29533 </span>            : inline bool
<span class="lineNum">   29534 </span>            : comdat_type_hasher::equal (const comdat_type_node *type_node_1,
<span class="lineNum">   29535 </span>            :                            const comdat_type_node *type_node_2)
<span class="lineNum">   29536 </span>            : {
<span class="lineNum">   29537 </span><span class="lineNoCov">          0 :   return (! memcmp (type_node_1-&gt;signature, type_node_2-&gt;signature,</span>
<span class="lineNum">   29538 </span>            :                     DWARF_TYPE_SIGNATURE_SIZE));
<span class="lineNum">   29539 </span>            : }
<span class="lineNum">   29540 </span>            : 
<span class="lineNum">   29541 </span>            : /* Move a DW_AT_{,MIPS_}linkage_name attribute just added to dw_die_ref
<span class="lineNum">   29542 </span>            :    to the location it would have been added, should we know its
<span class="lineNum">   29543 </span>            :    DECL_ASSEMBLER_NAME when we added other attributes.  This will
<span class="lineNum">   29544 </span>            :    probably improve compactness of debug info, removing equivalent
<span class="lineNum">   29545 </span>            :    abbrevs, and hide any differences caused by deferring the
<span class="lineNum">   29546 </span>            :    computation of the assembler name, triggered by e.g. PCH.  */
<a name="29547"><span class="lineNum">   29547 </span>            : </a>
<span class="lineNum">   29548 </span>            : static inline void
<span class="lineNum">   29549 </span><span class="lineNoCov">          0 : move_linkage_attr (dw_die_ref die)</span>
<span class="lineNum">   29550 </span>            : {
<span class="lineNum">   29551 </span><span class="lineNoCov">          0 :   unsigned ix = vec_safe_length (die-&gt;die_attr);</span>
<span class="lineNum">   29552 </span><span class="lineNoCov">          0 :   dw_attr_node linkage = (*die-&gt;die_attr)[ix - 1];</span>
<span class="lineNum">   29553 </span>            : 
<span class="lineNum">   29554 </span><span class="lineNoCov">          0 :   gcc_assert (linkage.dw_attr == DW_AT_linkage_name</span>
<span class="lineNum">   29555 </span>            :               || linkage.dw_attr == DW_AT_MIPS_linkage_name);
<span class="lineNum">   29556 </span>            : 
<span class="lineNum">   29557 </span><span class="lineNoCov">          0 :   while (--ix &gt; 0)</span>
<span class="lineNum">   29558 </span>            :     {
<span class="lineNum">   29559 </span><span class="lineNoCov">          0 :       dw_attr_node *prev = &amp;(*die-&gt;die_attr)[ix - 1];</span>
<span class="lineNum">   29560 </span>            : 
<span class="lineNum">   29561 </span><span class="lineNoCov">          0 :       if (prev-&gt;dw_attr == DW_AT_decl_line</span>
<span class="lineNum">   29562 </span><span class="lineNoCov">          0 :           || prev-&gt;dw_attr == DW_AT_decl_column</span>
<span class="lineNum">   29563 </span><span class="lineNoCov">          0 :           || prev-&gt;dw_attr == DW_AT_name)</span>
<span class="lineNum">   29564 </span>            :         break;
<span class="lineNum">   29565 </span>            :     }
<span class="lineNum">   29566 </span>            : 
<span class="lineNum">   29567 </span><span class="lineNoCov">          0 :   if (ix != vec_safe_length (die-&gt;die_attr) - 1)</span>
<span class="lineNum">   29568 </span>            :     {
<span class="lineNum">   29569 </span><span class="lineNoCov">          0 :       die-&gt;die_attr-&gt;pop ();</span>
<span class="lineNum">   29570 </span><span class="lineNoCov">          0 :       die-&gt;die_attr-&gt;quick_insert (ix, linkage);</span>
<span class="lineNum">   29571 </span>            :     }
<span class="lineNum">   29572 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">   29573 </span>            : 
<span class="lineNum">   29574 </span>            : /* Helper function for resolve_addr, mark DW_TAG_base_type nodes
<span class="lineNum">   29575 </span>            :    referenced from typed stack ops and count how often they are used.  */
<a name="29576"><span class="lineNum">   29576 </span>            : </a>
<span class="lineNum">   29577 </span>            : static void
<span class="lineNum">   29578 </span><span class="lineCov">   20905871 : mark_base_types (dw_loc_descr_ref loc)</span>
<span class="lineNum">   29579 </span>            : {
<span class="lineNum">   29580 </span><span class="lineCov">   20905871 :   dw_die_ref base_type = NULL;</span>
<span class="lineNum">   29581 </span>            : 
<span class="lineNum">   29582 </span><span class="lineCov">   56776006 :   for (; loc; loc = loc-&gt;dw_loc_next)</span>
<span class="lineNum">   29583 </span>            :     {
<span class="lineNum">   29584 </span><span class="lineCov">   35870135 :       switch (loc-&gt;dw_loc_opc)</span>
<span class="lineNum">   29585 </span>            :         {
<span class="lineNum">   29586 </span><span class="lineCov">      97285 :         case DW_OP_regval_type:</span>
<span class="lineNum">   29587 </span><span class="lineCov">      97285 :         case DW_OP_deref_type:</span>
<span class="lineNum">   29588 </span><span class="lineCov">      97285 :         case DW_OP_GNU_regval_type:</span>
<span class="lineNum">   29589 </span><span class="lineCov">      97285 :         case DW_OP_GNU_deref_type:</span>
<span class="lineNum">   29590 </span><span class="lineCov">      97285 :           base_type = loc-&gt;dw_loc_oprnd2.v.val_die_ref.die;</span>
<span class="lineNum">   29591 </span><span class="lineCov">      97285 :           break;</span>
<span class="lineNum">   29592 </span><span class="lineCov">      73816 :         case DW_OP_convert:</span>
<span class="lineNum">   29593 </span><span class="lineCov">      73816 :         case DW_OP_reinterpret:</span>
<span class="lineNum">   29594 </span><span class="lineCov">      73816 :         case DW_OP_GNU_convert:</span>
<span class="lineNum">   29595 </span><span class="lineCov">      73816 :         case DW_OP_GNU_reinterpret:</span>
<span class="lineNum">   29596 </span><span class="lineCov">      73816 :           if (loc-&gt;dw_loc_oprnd1.val_class == dw_val_class_unsigned_const)</span>
<span class="lineNum">   29597 </span>            :             continue;
<span class="lineNum">   29598 </span>            :           /* FALLTHRU */
<span class="lineNum">   29599 </span><span class="lineCov">     118910 :         case DW_OP_const_type:</span>
<span class="lineNum">   29600 </span><span class="lineCov">     118910 :         case DW_OP_GNU_const_type:</span>
<span class="lineNum">   29601 </span><span class="lineCov">     118910 :           base_type = loc-&gt;dw_loc_oprnd1.v.val_die_ref.die;</span>
<span class="lineNum">   29602 </span><span class="lineCov">     118910 :           break;</span>
<span class="lineNum">   29603 </span><span class="lineCov">     863804 :         case DW_OP_entry_value:</span>
<span class="lineNum">   29604 </span><span class="lineCov">     863804 :         case DW_OP_GNU_entry_value:</span>
<span class="lineNum">   29605 </span><span class="lineCov">     863804 :           mark_base_types (loc-&gt;dw_loc_oprnd1.v.val_loc);</span>
<span class="lineNum">   29606 </span><span class="lineCov">     863804 :           continue;</span>
<span class="lineNum">   29607 </span>            :         default:
<span class="lineNum">   29608 </span>            :           continue;
<span class="lineNum">   29609 </span>            :         }
<span class="lineNum">   29610 </span><span class="lineCov">     216195 :       gcc_assert (base_type-&gt;die_parent == comp_unit_die ());</span>
<span class="lineNum">   29611 </span><span class="lineCov">     216195 :       if (base_type-&gt;die_mark)</span>
<span class="lineNum">   29612 </span><span class="lineCov">     211358 :         base_type-&gt;die_mark++;</span>
<span class="lineNum">   29613 </span>            :       else
<span class="lineNum">   29614 </span>            :         {
<span class="lineNum">   29615 </span><span class="lineCov">       4837 :           base_types.safe_push (base_type);</span>
<span class="lineNum">   29616 </span><span class="lineCov">       4837 :           base_type-&gt;die_mark = 1;</span>
<span class="lineNum">   29617 </span>            :         }
<span class="lineNum">   29618 </span>            :     }
<span class="lineNum">   29619 </span><span class="lineCov">   20905871 : }</span>
<span class="lineNum">   29620 </span>            : 
<span class="lineNum">   29621 </span>            : /* Comparison function for sorting marked base types.  */
<a name="29622"><span class="lineNum">   29622 </span>            : </a>
<span class="lineNum">   29623 </span>            : static int
<span class="lineNum">   29624 </span><span class="lineCov">      17741 : base_type_cmp (const void *x, const void *y)</span>
<span class="lineNum">   29625 </span>            : {
<span class="lineNum">   29626 </span><span class="lineCov">      17741 :   dw_die_ref dx = *(const dw_die_ref *) x;</span>
<span class="lineNum">   29627 </span><span class="lineCov">      17741 :   dw_die_ref dy = *(const dw_die_ref *) y;</span>
<span class="lineNum">   29628 </span><span class="lineCov">      17741 :   unsigned int byte_size1, byte_size2;</span>
<span class="lineNum">   29629 </span><span class="lineCov">      17741 :   unsigned int encoding1, encoding2;</span>
<span class="lineNum">   29630 </span><span class="lineCov">      17741 :   unsigned int align1, align2;</span>
<span class="lineNum">   29631 </span><span class="lineCov">      17741 :   if (dx-&gt;die_mark &gt; dy-&gt;die_mark)</span>
<span class="lineNum">   29632 </span>            :     return -1;
<span class="lineNum">   29633 </span><span class="lineCov">      12915 :   if (dx-&gt;die_mark &lt; dy-&gt;die_mark)</span>
<span class="lineNum">   29634 </span>            :     return 1;
<span class="lineNum">   29635 </span><span class="lineCov">       9066 :   byte_size1 = get_AT_unsigned (dx, DW_AT_byte_size);</span>
<span class="lineNum">   29636 </span><span class="lineCov">       9066 :   byte_size2 = get_AT_unsigned (dy, DW_AT_byte_size);</span>
<span class="lineNum">   29637 </span><span class="lineCov">       9066 :   if (byte_size1 &lt; byte_size2)</span>
<span class="lineNum">   29638 </span>            :     return 1;
<span class="lineNum">   29639 </span><span class="lineCov">       8662 :   if (byte_size1 &gt; byte_size2)</span>
<span class="lineNum">   29640 </span>            :     return -1;
<span class="lineNum">   29641 </span><span class="lineCov">       7889 :   encoding1 = get_AT_unsigned (dx, DW_AT_encoding);</span>
<span class="lineNum">   29642 </span><span class="lineCov">       7889 :   encoding2 = get_AT_unsigned (dy, DW_AT_encoding);</span>
<span class="lineNum">   29643 </span><span class="lineCov">       7889 :   if (encoding1 &lt; encoding2)</span>
<span class="lineNum">   29644 </span>            :     return 1;
<span class="lineNum">   29645 </span><span class="lineCov">       7738 :   if (encoding1 &gt; encoding2)</span>
<span class="lineNum">   29646 </span>            :     return -1;
<span class="lineNum">   29647 </span><span class="lineCov">       7469 :   align1 = get_AT_unsigned (dx, DW_AT_alignment);</span>
<span class="lineNum">   29648 </span><span class="lineCov">       7469 :   align2 = get_AT_unsigned (dy, DW_AT_alignment);</span>
<span class="lineNum">   29649 </span><span class="lineCov">       7469 :   if (align1 &lt; align2)</span>
<span class="lineNum">   29650 </span>            :     return 1;
<span class="lineNum">   29651 </span><span class="lineCov">       7469 :   if (align1 &gt; align2)</span>
<span class="lineNum">   29652 </span><span class="lineNoCov">          0 :     return -1;</span>
<span class="lineNum">   29653 </span>            :   return 0;
<span class="lineNum">   29654 </span>            : }
<span class="lineNum">   29655 </span>            : 
<span class="lineNum">   29656 </span>            : /* Move base types marked by mark_base_types as early as possible
<span class="lineNum">   29657 </span>            :    in the CU, sorted by decreasing usage count both to make the
<span class="lineNum">   29658 </span>            :    uleb128 references as small as possible and to make sure they
<span class="lineNum">   29659 </span>            :    will have die_offset already computed by calc_die_sizes when
<span class="lineNum">   29660 </span>            :    sizes of typed stack loc ops is computed.  */
<a name="29661"><span class="lineNum">   29661 </span>            : </a>
<span class="lineNum">   29662 </span>            : static void
<span class="lineNum">   29663 </span><span class="lineCov">      33687 : move_marked_base_types (void)</span>
<span class="lineNum">   29664 </span>            : {
<span class="lineNum">   29665 </span><span class="lineCov">      33687 :   unsigned int i;</span>
<span class="lineNum">   29666 </span><span class="lineCov">      33687 :   dw_die_ref base_type, die, c;</span>
<span class="lineNum">   29667 </span>            : 
<span class="lineNum">   29668 </span><span class="lineCov">      33687 :   if (base_types.is_empty ())</span>
<span class="lineNum">   29669 </span>            :     return;
<span class="lineNum">   29670 </span>            : 
<span class="lineNum">   29671 </span>            :   /* Sort by decreasing usage count, they will be added again in that
<span class="lineNum">   29672 </span>            :      order later on.  */
<span class="lineNum">   29673 </span><span class="lineCov">       2116 :   base_types.qsort (base_type_cmp);</span>
<span class="lineNum">   29674 </span><span class="lineCov">       2116 :   die = comp_unit_die ();</span>
<span class="lineNum">   29675 </span><span class="lineCov">       2116 :   c = die-&gt;die_child;</span>
<span class="lineNum">   29676 </span><span class="lineCov">     697015 :   do</span>
<span class="lineNum">   29677 </span>            :     {
<span class="lineNum">   29678 </span><span class="lineCov">     697015 :       dw_die_ref prev = c;</span>
<span class="lineNum">   29679 </span><span class="lineCov">     697015 :       c = c-&gt;die_sib;</span>
<span class="lineNum">   29680 </span><span class="lineCov">     701852 :       while (c-&gt;die_mark)</span>
<span class="lineNum">   29681 </span>            :         {
<span class="lineNum">   29682 </span><span class="lineCov">       4837 :           remove_child_with_prev (c, prev);</span>
<span class="lineNum">   29683 </span>            :           /* As base types got marked, there must be at least
<span class="lineNum">   29684 </span>            :              one node other than DW_TAG_base_type.  */
<span class="lineNum">   29685 </span><span class="lineCov">       4837 :           gcc_assert (die-&gt;die_child != NULL);</span>
<span class="lineNum">   29686 </span><span class="lineCov">       4837 :           c = prev-&gt;die_sib;</span>
<span class="lineNum">   29687 </span>            :         }
<span class="lineNum">   29688 </span>            :     }
<span class="lineNum">   29689 </span><span class="lineCov">     697015 :   while (c != die-&gt;die_child);</span>
<span class="lineNum">   29690 </span>            :   gcc_assert (die-&gt;die_child);
<span class="lineNum">   29691 </span>            :   c = die-&gt;die_child;
<span class="lineNum">   29692 </span><span class="lineCov">       6953 :   for (i = 0; base_types.iterate (i, &amp;base_type); i++)</span>
<span class="lineNum">   29693 </span>            :     {
<span class="lineNum">   29694 </span><span class="lineCov">       4837 :       base_type-&gt;die_mark = 0;</span>
<span class="lineNum">   29695 </span><span class="lineCov">       4837 :       base_type-&gt;die_sib = c-&gt;die_sib;</span>
<span class="lineNum">   29696 </span><span class="lineCov">       4837 :       c-&gt;die_sib = base_type;</span>
<span class="lineNum">   29697 </span><span class="lineCov">       4837 :       c = base_type;</span>
<span class="lineNum">   29698 </span>            :     }
<span class="lineNum">   29699 </span>            : }
<span class="lineNum">   29700 </span>            : 
<span class="lineNum">   29701 </span>            : /* Helper function for resolve_addr, attempt to resolve
<span class="lineNum">   29702 </span>            :    one CONST_STRING, return true if successful.  Similarly verify that
<span class="lineNum">   29703 </span>            :    SYMBOL_REFs refer to variables emitted in the current CU.  */
<a name="29704"><span class="lineNum">   29704 </span>            : </a>
<span class="lineNum">   29705 </span>            : static bool
<span class="lineNum">   29706 </span><span class="lineCov">    1594692 : resolve_one_addr (rtx *addr)</span>
<span class="lineNum">   29707 </span>            : {
<span class="lineNum">   29708 </span><span class="lineCov">    1594692 :   rtx rtl = *addr;</span>
<span class="lineNum">   29709 </span>            : 
<span class="lineNum">   29710 </span><span class="lineCov">    1594692 :   if (GET_CODE (rtl) == CONST_STRING)</span>
<span class="lineNum">   29711 </span>            :     {
<span class="lineNum">   29712 </span><span class="lineCov">     131098 :       size_t len = strlen (XSTR (rtl, 0)) + 1;</span>
<span class="lineNum">   29713 </span><span class="lineCov">     131098 :       tree t = build_string (len, XSTR (rtl, 0));</span>
<span class="lineNum">   29714 </span><span class="lineCov">     262196 :       tree tlen = size_int (len - 1);</span>
<span class="lineNum">   29715 </span><span class="lineCov">     393294 :       TREE_TYPE (t)</span>
<span class="lineNum">   29716 </span><span class="lineCov">     131098 :         = build_array_type (char_type_node, build_index_type (tlen));</span>
<span class="lineNum">   29717 </span><span class="lineCov">     131098 :       rtl = lookup_constant_def (t);</span>
<span class="lineNum">   29718 </span><span class="lineCov">     131098 :       if (!rtl || !MEM_P (rtl))</span>
<span class="lineNum">   29719 </span>            :         return false;
<span class="lineNum">   29720 </span><span class="lineCov">      63152 :       rtl = XEXP (rtl, 0);</span>
<span class="lineNum">   29721 </span><span class="lineCov">      63152 :       if (GET_CODE (rtl) == SYMBOL_REF</span>
<span class="lineNum">   29722 </span><span class="lineCov">      63152 :           &amp;&amp; SYMBOL_REF_DECL (rtl)</span>
<span class="lineNum">   29723 </span><span class="lineCov">     126304 :           &amp;&amp; !TREE_ASM_WRITTEN (SYMBOL_REF_DECL (rtl)))</span>
<span class="lineNum">   29724 </span>            :         return false;
<span class="lineNum">   29725 </span><span class="lineCov">      10004 :       vec_safe_push (used_rtx_array, rtl);</span>
<span class="lineNum">   29726 </span><span class="lineCov">      10004 :       *addr = rtl;</span>
<span class="lineNum">   29727 </span><span class="lineCov">      10004 :       return true;</span>
<span class="lineNum">   29728 </span>            :     }
<span class="lineNum">   29729 </span>            : 
<span class="lineNum">   29730 </span><span class="lineCov">    1463594 :   if (GET_CODE (rtl) == SYMBOL_REF</span>
<span class="lineNum">   29731 </span><span class="lineCov">    1463594 :       &amp;&amp; SYMBOL_REF_DECL (rtl))</span>
<span class="lineNum">   29732 </span>            :     {
<span class="lineNum">   29733 </span><span class="lineCov">    1141628 :       if (TREE_CONSTANT_POOL_ADDRESS_P (rtl))</span>
<span class="lineNum">   29734 </span>            :         {
<span class="lineNum">   29735 </span><span class="lineCov">     327517 :           if (!TREE_ASM_WRITTEN (DECL_INITIAL (SYMBOL_REF_DECL (rtl))))</span>
<span class="lineNum">   29736 </span>            :             return false;
<span class="lineNum">   29737 </span>            :         }
<span class="lineNum">   29738 </span><span class="lineCov">     814111 :       else if (!TREE_ASM_WRITTEN (SYMBOL_REF_DECL (rtl)))</span>
<span class="lineNum">   29739 </span>            :         return false;
<span class="lineNum">   29740 </span>            :     }
<span class="lineNum">   29741 </span>            : 
<span class="lineNum">   29742 </span><span class="lineCov">    1440205 :   if (GET_CODE (rtl) == CONST)</span>
<span class="lineNum">   29743 </span>            :     {
<span class="lineNum">   29744 </span><span class="lineCov">     212680 :       subrtx_ptr_iterator::array_type array;</span>
<span class="lineNum">   29745 </span><span class="lineCov">     425219 :       FOR_EACH_SUBRTX_PTR (iter, array, &amp;XEXP (rtl, 0), ALL)</span>
<span class="lineNum">   29746 </span><span class="lineCov">     319159 :         if (!resolve_one_addr (*iter))</span>
<span class="lineNum">   29747 </span><span class="lineCov">        560 :           return false;</span>
<span class="lineNum">   29748 </span>            :     }
<span class="lineNum">   29749 </span>            : 
<span class="lineNum">   29750 </span>            :   return true;
<span class="lineNum">   29751 </span>            : }
<span class="lineNum">   29752 </span>            : 
<span class="lineNum">   29753 </span>            : /* For STRING_CST, return SYMBOL_REF of its constant pool entry,
<span class="lineNum">   29754 </span>            :    if possible, and create DW_TAG_dwarf_procedure that can be referenced
<span class="lineNum">   29755 </span>            :    from DW_OP_implicit_pointer if the string hasn't been seen yet.  */
<a name="29756"><span class="lineNum">   29756 </span>            : </a>
<span class="lineNum">   29757 </span>            : static rtx
<span class="lineNum">   29758 </span><span class="lineCov">      48415 : string_cst_pool_decl (tree t)</span>
<span class="lineNum">   29759 </span>            : {
<span class="lineNum">   29760 </span><span class="lineCov">      48415 :   rtx rtl = output_constant_def (t, 1);</span>
<span class="lineNum">   29761 </span><span class="lineCov">      48415 :   unsigned char *array;</span>
<span class="lineNum">   29762 </span><span class="lineCov">      48415 :   dw_loc_descr_ref l;</span>
<span class="lineNum">   29763 </span><span class="lineCov">      48415 :   tree decl;</span>
<span class="lineNum">   29764 </span><span class="lineCov">      48415 :   size_t len;</span>
<span class="lineNum">   29765 </span><span class="lineCov">      48415 :   dw_die_ref ref;</span>
<span class="lineNum">   29766 </span>            : 
<span class="lineNum">   29767 </span><span class="lineCov">      48415 :   if (!rtl || !MEM_P (rtl))</span>
<span class="lineNum">   29768 </span>            :     return NULL_RTX;
<span class="lineNum">   29769 </span><span class="lineCov">      48415 :   rtl = XEXP (rtl, 0);</span>
<span class="lineNum">   29770 </span><span class="lineCov">      48415 :   if (GET_CODE (rtl) != SYMBOL_REF</span>
<span class="lineNum">   29771 </span><span class="lineCov">      48415 :       || SYMBOL_REF_DECL (rtl) == NULL_TREE)</span>
<span class="lineNum">   29772 </span>            :     return NULL_RTX;
<span class="lineNum">   29773 </span>            : 
<span class="lineNum">   29774 </span><span class="lineCov">      48415 :   decl = SYMBOL_REF_DECL (rtl);</span>
<span class="lineNum">   29775 </span><span class="lineCov">      48415 :   if (!lookup_decl_die (decl))</span>
<span class="lineNum">   29776 </span>            :     {
<span class="lineNum">   29777 </span><span class="lineCov">       2075 :       len = TREE_STRING_LENGTH (t);</span>
<span class="lineNum">   29778 </span><span class="lineCov">       2075 :       vec_safe_push (used_rtx_array, rtl);</span>
<span class="lineNum">   29779 </span><span class="lineCov">       2075 :       ref = new_die (DW_TAG_dwarf_procedure, comp_unit_die (), decl);</span>
<span class="lineNum">   29780 </span><span class="lineCov">       2075 :       array = ggc_vec_alloc&lt;unsigned char&gt; (len);</span>
<span class="lineNum">   29781 </span><span class="lineCov">       2075 :       memcpy (array, TREE_STRING_POINTER (t), len);</span>
<span class="lineNum">   29782 </span><span class="lineCov">       2075 :       l = new_loc_descr (DW_OP_implicit_value, len, 0);</span>
<span class="lineNum">   29783 </span><span class="lineCov">       2075 :       l-&gt;dw_loc_oprnd2.val_class = dw_val_class_vec;</span>
<span class="lineNum">   29784 </span><span class="lineCov">       2075 :       l-&gt;dw_loc_oprnd2.v.val_vec.length = len;</span>
<span class="lineNum">   29785 </span><span class="lineCov">       2075 :       l-&gt;dw_loc_oprnd2.v.val_vec.elt_size = 1;</span>
<span class="lineNum">   29786 </span><span class="lineCov">       2075 :       l-&gt;dw_loc_oprnd2.v.val_vec.array = array;</span>
<span class="lineNum">   29787 </span><span class="lineCov">       2075 :       add_AT_loc (ref, DW_AT_location, l);</span>
<span class="lineNum">   29788 </span><span class="lineCov">       2075 :       equate_decl_number_to_die (decl, ref);</span>
<span class="lineNum">   29789 </span>            :     }
<span class="lineNum">   29790 </span><span class="lineCov">      48415 :   return rtl;</span>
<span class="lineNum">   29791 </span>            : }
<span class="lineNum">   29792 </span>            : 
<span class="lineNum">   29793 </span>            : /* Helper function of resolve_addr_in_expr.  LOC is
<span class="lineNum">   29794 </span>            :    a DW_OP_addr followed by DW_OP_stack_value, either at the start
<span class="lineNum">   29795 </span>            :    of exprloc or after DW_OP_{,bit_}piece, and val_addr can't be
<span class="lineNum">   29796 </span>            :    resolved.  Replace it (both DW_OP_addr and DW_OP_stack_value)
<span class="lineNum">   29797 </span>            :    with DW_OP_implicit_pointer if possible
<span class="lineNum">   29798 </span>            :    and return true, if unsuccessful, return false.  */
<a name="29799"><span class="lineNum">   29799 </span>            : </a>
<span class="lineNum">   29800 </span>            : static bool
<span class="lineNum">   29801 </span><span class="lineCov">      54285 : optimize_one_addr_into_implicit_ptr (dw_loc_descr_ref loc)</span>
<span class="lineNum">   29802 </span>            : {
<span class="lineNum">   29803 </span><span class="lineCov">      54285 :   rtx rtl = loc-&gt;dw_loc_oprnd1.v.val_addr;</span>
<span class="lineNum">   29804 </span><span class="lineCov">      54285 :   HOST_WIDE_INT offset = 0;</span>
<span class="lineNum">   29805 </span><span class="lineCov">      54285 :   dw_die_ref ref = NULL;</span>
<span class="lineNum">   29806 </span><span class="lineCov">      54285 :   tree decl;</span>
<span class="lineNum">   29807 </span>            : 
<span class="lineNum">   29808 </span><span class="lineCov">      54285 :   if (GET_CODE (rtl) == CONST</span>
<span class="lineNum">   29809 </span><span class="lineCov">        529 :       &amp;&amp; GET_CODE (XEXP (rtl, 0)) == PLUS</span>
<span class="lineNum">   29810 </span><span class="lineCov">        529 :       &amp;&amp; CONST_INT_P (XEXP (XEXP (rtl, 0), 1)))</span>
<span class="lineNum">   29811 </span>            :     {
<span class="lineNum">   29812 </span><span class="lineCov">        529 :       offset = INTVAL (XEXP (XEXP (rtl, 0), 1));</span>
<span class="lineNum">   29813 </span><span class="lineCov">        529 :       rtl = XEXP (XEXP (rtl, 0), 0);</span>
<span class="lineNum">   29814 </span>            :     }
<span class="lineNum">   29815 </span><span class="lineCov">      54285 :   if (GET_CODE (rtl) == CONST_STRING)</span>
<span class="lineNum">   29816 </span>            :     {
<span class="lineNum">   29817 </span><span class="lineCov">      48415 :       size_t len = strlen (XSTR (rtl, 0)) + 1;</span>
<span class="lineNum">   29818 </span><span class="lineCov">      48415 :       tree t = build_string (len, XSTR (rtl, 0));</span>
<span class="lineNum">   29819 </span><span class="lineCov">      96830 :       tree tlen = size_int (len - 1);</span>
<span class="lineNum">   29820 </span>            : 
<span class="lineNum">   29821 </span><span class="lineCov">     145245 :       TREE_TYPE (t)</span>
<span class="lineNum">   29822 </span><span class="lineCov">      48415 :         = build_array_type (char_type_node, build_index_type (tlen));</span>
<span class="lineNum">   29823 </span><span class="lineCov">      48415 :       rtl = string_cst_pool_decl (t);</span>
<span class="lineNum">   29824 </span><span class="lineCov">      48415 :       if (!rtl)</span>
<span class="lineNum">   29825 </span>            :         return false;
<span class="lineNum">   29826 </span>            :     }
<span class="lineNum">   29827 </span><span class="lineCov">      54285 :   if (GET_CODE (rtl) == SYMBOL_REF &amp;&amp; SYMBOL_REF_DECL (rtl))</span>
<span class="lineNum">   29828 </span>            :     {
<span class="lineNum">   29829 </span><span class="lineCov">      54285 :       decl = SYMBOL_REF_DECL (rtl);</span>
<span class="lineNum">   29830 </span><span class="lineCov">      54285 :       if (VAR_P (decl) &amp;&amp; !DECL_EXTERNAL (decl))</span>
<span class="lineNum">   29831 </span>            :         {
<span class="lineNum">   29832 </span><span class="lineCov">      53983 :           ref = lookup_decl_die (decl);</span>
<span class="lineNum">   29833 </span><span class="lineCov">      53983 :           if (ref &amp;&amp; (get_AT (ref, DW_AT_location)</span>
<span class="lineNum">   29834 </span><span class="lineCov">       3976 :                       || get_AT (ref, DW_AT_const_value)))</span>
<span class="lineNum">   29835 </span>            :             {
<span class="lineNum">   29836 </span><span class="lineCov">      52033 :               loc-&gt;dw_loc_opc = dwarf_OP (DW_OP_implicit_pointer);</span>
<span class="lineNum">   29837 </span><span class="lineCov">      52033 :               loc-&gt;dw_loc_oprnd1.val_class = dw_val_class_die_ref;</span>
<span class="lineNum">   29838 </span><span class="lineCov">      52033 :               loc-&gt;dw_loc_oprnd1.val_entry = NULL;</span>
<span class="lineNum">   29839 </span><span class="lineCov">      52033 :               loc-&gt;dw_loc_oprnd1.v.val_die_ref.die = ref;</span>
<span class="lineNum">   29840 </span><span class="lineCov">      52033 :               loc-&gt;dw_loc_oprnd1.v.val_die_ref.external = 0;</span>
<span class="lineNum">   29841 </span><span class="lineCov">      52033 :               loc-&gt;dw_loc_next = loc-&gt;dw_loc_next-&gt;dw_loc_next;</span>
<span class="lineNum">   29842 </span><span class="lineCov">      52033 :               loc-&gt;dw_loc_oprnd2.v.val_int = offset;</span>
<span class="lineNum">   29843 </span><span class="lineCov">      52033 :               return true;</span>
<span class="lineNum">   29844 </span>            :             }
<span class="lineNum">   29845 </span>            :         }
<span class="lineNum">   29846 </span>            :     }
<span class="lineNum">   29847 </span>            :   return false;
<span class="lineNum">   29848 </span>            : }
<span class="lineNum">   29849 </span>            : 
<span class="lineNum">   29850 </span>            : /* Helper function for resolve_addr, handle one location
<span class="lineNum">   29851 </span>            :    expression, return false if at least one CONST_STRING or SYMBOL_REF in
<span class="lineNum">   29852 </span>            :    the location list couldn't be resolved.  */
<a name="29853"><span class="lineNum">   29853 </span>            : </a>
<span class="lineNum">   29854 </span>            : static bool
<span class="lineNum">   29855 </span><span class="lineCov">   21883680 : resolve_addr_in_expr (dw_attr_node *a, dw_loc_descr_ref loc)</span>
<span class="lineNum">   29856 </span>            : {
<span class="lineNum">   29857 </span><span class="lineCov">   21883680 :   dw_loc_descr_ref keep = NULL;</span>
<span class="lineNum">   29858 </span><span class="lineCov">   56888516 :   for (dw_loc_descr_ref prev = NULL; loc; prev = loc, loc = loc-&gt;dw_loc_next)</span>
<span class="lineNum">   29859 </span><span class="lineCov">   36850205 :     switch (loc-&gt;dw_loc_opc)</span>
<span class="lineNum">   29860 </span>            :       {
<span class="lineNum">   29861 </span><span class="lineCov">    1205923 :       case DW_OP_addr:</span>
<span class="lineNum">   29862 </span><span class="lineCov">    1205923 :         if (!resolve_one_addr (&amp;loc-&gt;dw_loc_oprnd1.v.val_addr))</span>
<span class="lineNum">   29863 </span>            :           {
<span class="lineNum">   29864 </span><span class="lineCov">      75559 :             if ((prev == NULL</span>
<span class="lineNum">   29865 </span><span class="lineCov">        133 :                  || prev-&gt;dw_loc_opc == DW_OP_piece</span>
<span class="lineNum">   29866 </span><span class="lineCov">         31 :                  || prev-&gt;dw_loc_opc == DW_OP_bit_piece)</span>
<span class="lineNum">   29867 </span><span class="lineCov">      75528 :                 &amp;&amp; loc-&gt;dw_loc_next</span>
<span class="lineNum">   29868 </span><span class="lineCov">      61115 :                 &amp;&amp; loc-&gt;dw_loc_next-&gt;dw_loc_opc == DW_OP_stack_value</span>
<span class="lineNum">   29869 </span><span class="lineCov">      54285 :                 &amp;&amp; (!dwarf_strict || dwarf_version &gt;= 5)</span>
<span class="lineNum">   29870 </span><span class="lineCov">     129844 :                 &amp;&amp; optimize_one_addr_into_implicit_ptr (loc))</span>
<span class="lineNum">   29871 </span>            :               break;
<span class="lineNum">   29872 </span><span class="lineCov">      23526 :             return false;</span>
<span class="lineNum">   29873 </span>            :           }
<span class="lineNum">   29874 </span>            :         break;
<span class="lineNum">   29875 </span><span class="lineCov">          7 :       case DW_OP_GNU_addr_index:</span>
<span class="lineNum">   29876 </span><span class="lineCov">          7 :       case DW_OP_addrx:</span>
<span class="lineNum">   29877 </span><span class="lineCov">          7 :       case DW_OP_GNU_const_index:</span>
<span class="lineNum">   29878 </span><span class="lineCov">          7 :       case DW_OP_constx:</span>
<span class="lineNum">   29879 </span><span class="lineCov">          7 :         if ((loc-&gt;dw_loc_opc == DW_OP_GNU_addr_index</span>
<span class="lineNum">   29880 </span><span class="lineNoCov">          0 :              || loc-&gt;dw_loc_opc == DW_OP_addrx)</span>
<span class="lineNum">   29881 </span><span class="lineNoCov">          0 :             || ((loc-&gt;dw_loc_opc == DW_OP_GNU_const_index</span>
<span class="lineNum">   29882 </span><span class="lineNoCov">          0 :                  || loc-&gt;dw_loc_opc == DW_OP_constx)</span>
<span class="lineNum">   29883 </span><span class="lineNoCov">          0 :                 &amp;&amp; loc-&gt;dtprel))</span>
<span class="lineNum">   29884 </span>            :           {
<span class="lineNum">   29885 </span><span class="lineCov">          7 :             rtx rtl = loc-&gt;dw_loc_oprnd1.val_entry-&gt;addr.rtl;</span>
<span class="lineNum">   29886 </span><span class="lineCov">          7 :             if (!resolve_one_addr (&amp;rtl))</span>
<span class="lineNum">   29887 </span><span class="lineNoCov">          0 :               return false;</span>
<span class="lineNum">   29888 </span><span class="lineCov">          7 :             remove_addr_table_entry (loc-&gt;dw_loc_oprnd1.val_entry);</span>
<span class="lineNum">   29889 </span><span class="lineCov">          7 :             loc-&gt;dw_loc_oprnd1.val_entry</span>
<span class="lineNum">   29890 </span><span class="lineCov">          7 :               = add_addr_table_entry (rtl, ate_kind_rtx);</span>
<span class="lineNum">   29891 </span>            :           }
<span class="lineNum">   29892 </span>            :         break;
<span class="lineNum">   29893 </span><span class="lineCov">      68189 :       case DW_OP_const4u:</span>
<span class="lineNum">   29894 </span><span class="lineCov">      68189 :       case DW_OP_const8u:</span>
<span class="lineNum">   29895 </span><span class="lineCov">      68189 :         if (loc-&gt;dtprel</span>
<span class="lineNum">   29896 </span><span class="lineCov">      68189 :             &amp;&amp; !resolve_one_addr (&amp;loc-&gt;dw_loc_oprnd1.v.val_addr))</span>
<span class="lineNum">   29897 </span>            :           return false;
<span class="lineNum">   29898 </span>            :         break;
<span class="lineNum">   29899 </span><span class="lineCov">     416815 :       case DW_OP_plus_uconst:</span>
<span class="lineNum">   29900 </span><span class="lineCov">     416815 :         if (size_of_loc_descr (loc)</span>
<span class="lineNum">   29901 </span><span class="lineCov">     416815 :             &gt; size_of_int_loc_descriptor (loc-&gt;dw_loc_oprnd1.v.val_unsigned)</span>
<span class="lineNum">   29902 </span><span class="lineCov">     416815 :               + 1</span>
<span class="lineNum">   29903 </span><span class="lineCov">     416815 :             &amp;&amp; loc-&gt;dw_loc_oprnd1.v.val_unsigned &gt; 0)</span>
<span class="lineNum">   29904 </span>            :           {
<span class="lineNum">   29905 </span><span class="lineCov">      15469 :             dw_loc_descr_ref repl</span>
<span class="lineNum">   29906 </span><span class="lineCov">      30938 :               = int_loc_descriptor (loc-&gt;dw_loc_oprnd1.v.val_unsigned);</span>
<span class="lineNum">   29907 </span><span class="lineCov">      15469 :             add_loc_descr (&amp;repl, new_loc_descr (DW_OP_plus, 0, 0));</span>
<span class="lineNum">   29908 </span><span class="lineCov">      15469 :             add_loc_descr (&amp;repl, loc-&gt;dw_loc_next);</span>
<span class="lineNum">   29909 </span><span class="lineCov">      15469 :             *loc = *repl;</span>
<span class="lineNum">   29910 </span>            :           }
<span class="lineNum">   29911 </span>            :         break;
<span class="lineNum">   29912 </span><span class="lineCov">      69475 :       case DW_OP_implicit_value:</span>
<span class="lineNum">   29913 </span><span class="lineCov">      69475 :         if (loc-&gt;dw_loc_oprnd2.val_class == dw_val_class_addr</span>
<span class="lineNum">   29914 </span><span class="lineCov">      69475 :             &amp;&amp; !resolve_one_addr (&amp;loc-&gt;dw_loc_oprnd2.v.val_addr))</span>
<span class="lineNum">   29915 </span>            :           return false;
<span class="lineNum">   29916 </span>            :         break;
<span class="lineNum">   29917 </span><span class="lineCov">    2385051 :       case DW_OP_implicit_pointer:</span>
<span class="lineNum">   29918 </span><span class="lineCov">    2385051 :       case DW_OP_GNU_implicit_pointer:</span>
<span class="lineNum">   29919 </span><span class="lineCov">    2385051 :       case DW_OP_GNU_parameter_ref:</span>
<span class="lineNum">   29920 </span><span class="lineCov">    2385051 :       case DW_OP_GNU_variable_value:</span>
<span class="lineNum">   29921 </span><span class="lineCov">    2385051 :         if (loc-&gt;dw_loc_oprnd1.val_class == dw_val_class_decl_ref)</span>
<span class="lineNum">   29922 </span>            :           {
<span class="lineNum">   29923 </span><span class="lineCov">    1916746 :             dw_die_ref ref</span>
<span class="lineNum">   29924 </span><span class="lineCov">    1916746 :               = lookup_decl_die (loc-&gt;dw_loc_oprnd1.v.val_decl_ref);</span>
<span class="lineNum">   29925 </span><span class="lineCov">    1916746 :             if (ref == NULL)</span>
<span class="lineNum">   29926 </span>            :               return false;
<span class="lineNum">   29927 </span><span class="lineCov">     100125 :             loc-&gt;dw_loc_oprnd1.val_class = dw_val_class_die_ref;</span>
<span class="lineNum">   29928 </span><span class="lineCov">     100125 :             loc-&gt;dw_loc_oprnd1.v.val_die_ref.die = ref;</span>
<span class="lineNum">   29929 </span><span class="lineCov">     100125 :             loc-&gt;dw_loc_oprnd1.v.val_die_ref.external = 0;</span>
<span class="lineNum">   29930 </span>            :           }
<span class="lineNum">   29931 </span><span class="lineCov">     568430 :         if (loc-&gt;dw_loc_opc == DW_OP_GNU_variable_value)</span>
<span class="lineNum">   29932 </span>            :           {
<span class="lineNum">   29933 </span><span class="lineCov">       2277 :             if (prev == NULL</span>
<span class="lineNum">   29934 </span><span class="lineCov">       2277 :                 &amp;&amp; loc-&gt;dw_loc_next == NULL</span>
<span class="lineNum">   29935 </span><span class="lineCov">       4137 :                 &amp;&amp; AT_class (a) == dw_val_class_loc)</span>
<span class="lineNum">   29936 </span><span class="lineCov">       1860 :               switch (a-&gt;dw_attr)</span>
<span class="lineNum">   29937 </span>            :                 {
<span class="lineNum">   29938 </span>            :                   /* Following attributes allow both exprloc and reference,
<span class="lineNum">   29939 </span>            :                      so if the whole expression is DW_OP_GNU_variable_value
<span class="lineNum">   29940 </span>            :                      alone we could transform it into reference.  */
<span class="lineNum">   29941 </span><span class="lineCov">       1847 :                 case DW_AT_byte_size:</span>
<span class="lineNum">   29942 </span><span class="lineCov">       1847 :                 case DW_AT_bit_size:</span>
<span class="lineNum">   29943 </span><span class="lineCov">       1847 :                 case DW_AT_lower_bound:</span>
<span class="lineNum">   29944 </span><span class="lineCov">       1847 :                 case DW_AT_upper_bound:</span>
<span class="lineNum">   29945 </span><span class="lineCov">       1847 :                 case DW_AT_bit_stride:</span>
<span class="lineNum">   29946 </span><span class="lineCov">       1847 :                 case DW_AT_count:</span>
<span class="lineNum">   29947 </span><span class="lineCov">       1847 :                 case DW_AT_allocated:</span>
<span class="lineNum">   29948 </span><span class="lineCov">       1847 :                 case DW_AT_associated:</span>
<span class="lineNum">   29949 </span><span class="lineCov">       1847 :                 case DW_AT_byte_stride:</span>
<span class="lineNum">   29950 </span><span class="lineCov">       1847 :                   a-&gt;dw_attr_val.val_class = dw_val_class_die_ref;</span>
<span class="lineNum">   29951 </span><span class="lineCov">       1847 :                   a-&gt;dw_attr_val.val_entry = NULL;</span>
<span class="lineNum">   29952 </span><span class="lineCov">       1847 :                   a-&gt;dw_attr_val.v.val_die_ref.die</span>
<span class="lineNum">   29953 </span><span class="lineCov">       1847 :                     = loc-&gt;dw_loc_oprnd1.v.val_die_ref.die;</span>
<span class="lineNum">   29954 </span><span class="lineCov">       1847 :                   a-&gt;dw_attr_val.v.val_die_ref.external = 0;</span>
<span class="lineNum">   29955 </span><span class="lineCov">       1847 :                   return true;</span>
<span class="lineNum">   29956 </span>            :                 default:
<span class="lineNum">   29957 </span>            :                   break;
<span class="lineNum">   29958 </span>            :                 }
<span class="lineNum">   29959 </span><span class="lineCov">        430 :             if (dwarf_strict)</span>
<span class="lineNum">   29960 </span>            :               return false;
<span class="lineNum">   29961 </span>            :           }
<span class="lineNum">   29962 </span>            :         break;
<span class="lineNum">   29963 </span><span class="lineCov">     209852 :       case DW_OP_const_type:</span>
<span class="lineNum">   29964 </span><span class="lineCov">     209852 :       case DW_OP_regval_type:</span>
<span class="lineNum">   29965 </span><span class="lineCov">     209852 :       case DW_OP_deref_type:</span>
<span class="lineNum">   29966 </span><span class="lineCov">     209852 :       case DW_OP_convert:</span>
<span class="lineNum">   29967 </span><span class="lineCov">     209852 :       case DW_OP_reinterpret:</span>
<span class="lineNum">   29968 </span><span class="lineCov">     209852 :       case DW_OP_GNU_const_type:</span>
<span class="lineNum">   29969 </span><span class="lineCov">     209852 :       case DW_OP_GNU_regval_type:</span>
<span class="lineNum">   29970 </span><span class="lineCov">     209852 :       case DW_OP_GNU_deref_type:</span>
<span class="lineNum">   29971 </span><span class="lineCov">     209852 :       case DW_OP_GNU_convert:</span>
<span class="lineNum">   29972 </span><span class="lineCov">     209852 :       case DW_OP_GNU_reinterpret:</span>
<span class="lineNum">   29973 </span><span class="lineCov">     210480 :         while (loc-&gt;dw_loc_next</span>
<span class="lineNum">   29974 </span><span class="lineCov">     209852 :                &amp;&amp; (loc-&gt;dw_loc_next-&gt;dw_loc_opc == DW_OP_convert</span>
<span class="lineNum">   29975 </span><span class="lineCov">     198884 :                    || loc-&gt;dw_loc_next-&gt;dw_loc_opc == DW_OP_GNU_convert))</span>
<span class="lineNum">   29976 </span>            :           {
<span class="lineNum">   29977 </span><span class="lineCov">      33466 :             dw_die_ref base1, base2;</span>
<span class="lineNum">   29978 </span><span class="lineCov">      33466 :             unsigned enc1, enc2, size1, size2;</span>
<span class="lineNum">   29979 </span><span class="lineCov">      66932 :             if (loc-&gt;dw_loc_opc == DW_OP_regval_type</span>
<span class="lineNum">   29980 </span><span class="lineCov">      33466 :                 || loc-&gt;dw_loc_opc == DW_OP_deref_type</span>
<span class="lineNum">   29981 </span><span class="lineCov">      33466 :                 || loc-&gt;dw_loc_opc == DW_OP_GNU_regval_type</span>
<span class="lineNum">   29982 </span><span class="lineCov">      31190 :                 || loc-&gt;dw_loc_opc == DW_OP_GNU_deref_type)</span>
<span class="lineNum">   29983 </span><span class="lineCov">       4959 :               base1 = loc-&gt;dw_loc_oprnd2.v.val_die_ref.die;</span>
<span class="lineNum">   29984 </span><span class="lineCov">      28507 :             else if (loc-&gt;dw_loc_oprnd1.val_class</span>
<span class="lineNum">   29985 </span>            :                      == dw_val_class_unsigned_const)
<span class="lineNum">   29986 </span>            :               break;
<span class="lineNum">   29987 </span>            :             else
<span class="lineNum">   29988 </span><span class="lineCov">      28440 :               base1 = loc-&gt;dw_loc_oprnd1.v.val_die_ref.die;</span>
<span class="lineNum">   29989 </span><span class="lineCov">      33399 :             if (loc-&gt;dw_loc_next-&gt;dw_loc_oprnd1.val_class</span>
<span class="lineNum">   29990 </span>            :                 == dw_val_class_unsigned_const)
<span class="lineNum">   29991 </span>            :               break;
<span class="lineNum">   29992 </span><span class="lineCov">      31436 :             base2 = loc-&gt;dw_loc_next-&gt;dw_loc_oprnd1.v.val_die_ref.die;</span>
<span class="lineNum">   29993 </span><span class="lineCov">      31436 :             gcc_assert (base1-&gt;die_tag == DW_TAG_base_type</span>
<span class="lineNum">   29994 </span>            :                         &amp;&amp; base2-&gt;die_tag == DW_TAG_base_type);
<span class="lineNum">   29995 </span><span class="lineCov">      31436 :             enc1 = get_AT_unsigned (base1, DW_AT_encoding);</span>
<span class="lineNum">   29996 </span><span class="lineCov">      31436 :             enc2 = get_AT_unsigned (base2, DW_AT_encoding);</span>
<span class="lineNum">   29997 </span><span class="lineCov">      31436 :             size1 = get_AT_unsigned (base1, DW_AT_byte_size);</span>
<span class="lineNum">   29998 </span><span class="lineCov">      31436 :             size2 = get_AT_unsigned (base2, DW_AT_byte_size);</span>
<span class="lineNum">   29999 </span><span class="lineCov">      31436 :             if (size1 == size2</span>
<span class="lineNum">   30000 </span><span class="lineCov">       5934 :                 &amp;&amp; (((enc1 == DW_ATE_unsigned || enc1 == DW_ATE_signed)</span>
<span class="lineNum">   30001 </span><span class="lineCov">       5767 :                      &amp;&amp; (enc2 == DW_ATE_unsigned || enc2 == DW_ATE_signed)</span>
<span class="lineNum">   30002 </span><span class="lineCov">        682 :                      &amp;&amp; loc != keep)</span>
<span class="lineNum">   30003 </span><span class="lineCov">       5306 :                     || enc1 == enc2))</span>
<span class="lineNum">   30004 </span>            :               {
<span class="lineNum">   30005 </span>            :                 /* Optimize away next DW_OP_convert after
<span class="lineNum">   30006 </span>            :                    adjusting LOC's base type die reference.  */
<span class="lineNum">   30007 </span><span class="lineCov">       1256 :                 if (loc-&gt;dw_loc_opc == DW_OP_regval_type</span>
<span class="lineNum">   30008 </span>            :                     || loc-&gt;dw_loc_opc == DW_OP_deref_type
<span class="lineNum">   30009 </span><span class="lineCov">        628 :                     || loc-&gt;dw_loc_opc == DW_OP_GNU_regval_type</span>
<span class="lineNum">   30010 </span><span class="lineCov">        494 :                     || loc-&gt;dw_loc_opc == DW_OP_GNU_deref_type)</span>
<span class="lineNum">   30011 </span><span class="lineCov">        385 :                   loc-&gt;dw_loc_oprnd2.v.val_die_ref.die = base2;</span>
<span class="lineNum">   30012 </span>            :                 else
<span class="lineNum">   30013 </span><span class="lineCov">        243 :                   loc-&gt;dw_loc_oprnd1.v.val_die_ref.die = base2;</span>
<span class="lineNum">   30014 </span><span class="lineCov">        628 :                 loc-&gt;dw_loc_next = loc-&gt;dw_loc_next-&gt;dw_loc_next;</span>
<span class="lineNum">   30015 </span><span class="lineCov">        628 :                 continue;</span>
<span class="lineNum">   30016 </span>            :               }
<span class="lineNum">   30017 </span>            :             /* Don't change integer DW_OP_convert after e.g. floating
<span class="lineNum">   30018 </span>            :                point typed stack entry.  */
<span class="lineNum">   30019 </span><span class="lineCov">      30808 :             else if (enc1 != DW_ATE_unsigned &amp;&amp; enc1 != DW_ATE_signed)</span>
<span class="lineNum">   30020 </span><span class="lineCov">      12652 :               keep = loc-&gt;dw_loc_next;</span>
<span class="lineNum">   30021 </span>            :             break;
<span class="lineNum">   30022 </span>            :           }
<span class="lineNum">   30023 </span>            :         break;
<span class="lineNum">   30024 </span>            :       default:
<span class="lineNum">   30025 </span>            :         break;
<span class="lineNum">   30026 </span>            :       }
<span class="lineNum">   30027 </span>            :   return true;
<span class="lineNum">   30028 </span>            : }
<span class="lineNum">   30029 </span>            : 
<span class="lineNum">   30030 </span>            : /* Helper function of resolve_addr.  DIE had DW_AT_location of
<span class="lineNum">   30031 </span>            :    DW_OP_addr alone, which referred to DECL in DW_OP_addr's operand
<span class="lineNum">   30032 </span>            :    and DW_OP_addr couldn't be resolved.  resolve_addr has already
<span class="lineNum">   30033 </span>            :    removed the DW_AT_location attribute.  This function attempts to
<span class="lineNum">   30034 </span>            :    add a new DW_AT_location attribute with DW_OP_implicit_pointer
<span class="lineNum">   30035 </span>            :    to it or DW_AT_const_value attribute, if possible.  */
<a name="30036"><span class="lineNum">   30036 </span>            : </a>
<span class="lineNum">   30037 </span>            : static void
<span class="lineNum">   30038 </span><span class="lineCov">        261 : optimize_location_into_implicit_ptr (dw_die_ref die, tree decl)</span>
<span class="lineNum">   30039 </span>            : {
<span class="lineNum">   30040 </span><span class="lineCov">        261 :   if (!VAR_P (decl)</span>
<span class="lineNum">   30041 </span><span class="lineCov">        261 :       || lookup_decl_die (decl) != die</span>
<span class="lineNum">   30042 </span><span class="lineCov">        261 :       || DECL_EXTERNAL (decl)</span>
<span class="lineNum">   30043 </span><span class="lineCov">        261 :       || !TREE_STATIC (decl)</span>
<span class="lineNum">   30044 </span><span class="lineCov">        522 :       || DECL_INITIAL (decl) == NULL_TREE</span>
<span class="lineNum">   30045 </span><span class="lineCov">        294 :       || DECL_P (DECL_INITIAL (decl))</span>
<span class="lineNum">   30046 </span><span class="lineCov">        408 :       || get_AT (die, DW_AT_const_value))</span>
<span class="lineNum">   30047 </span><span class="lineCov">        114 :     return;</span>
<span class="lineNum">   30048 </span>            : 
<span class="lineNum">   30049 </span><span class="lineCov">        147 :   tree init = DECL_INITIAL (decl);</span>
<span class="lineNum">   30050 </span><span class="lineCov">        147 :   HOST_WIDE_INT offset = 0;</span>
<span class="lineNum">   30051 </span>            :   /* For variables that have been optimized away and thus
<span class="lineNum">   30052 </span>            :      don't have a memory location, see if we can emit
<span class="lineNum">   30053 </span>            :      DW_AT_const_value instead.  */
<span class="lineNum">   30054 </span><span class="lineCov">        147 :   if (tree_add_const_value_attribute (die, init))</span>
<span class="lineNum">   30055 </span>            :     return;
<span class="lineNum">   30056 </span><span class="lineCov">         46 :   if (dwarf_strict &amp;&amp; dwarf_version &lt; 5)</span>
<span class="lineNum">   30057 </span>            :     return;
<span class="lineNum">   30058 </span>            :   /* If init is ADDR_EXPR or POINTER_PLUS_EXPR of ADDR_EXPR,
<span class="lineNum">   30059 </span>            :      and ADDR_EXPR refers to a decl that has DW_AT_location or
<span class="lineNum">   30060 </span>            :      DW_AT_const_value (but isn't addressable, otherwise
<span class="lineNum">   30061 </span>            :      resolving the original DW_OP_addr wouldn't fail), see if
<span class="lineNum">   30062 </span>            :      we can add DW_OP_implicit_pointer.  */
<span class="lineNum">   30063 </span><span class="lineCov">         46 :   STRIP_NOPS (init);</span>
<span class="lineNum">   30064 </span><span class="lineCov">         46 :   if (TREE_CODE (init) == POINTER_PLUS_EXPR</span>
<span class="lineNum">   30065 </span><span class="lineCov">         46 :       &amp;&amp; tree_fits_shwi_p (TREE_OPERAND (init, 1)))</span>
<span class="lineNum">   30066 </span>            :     {
<span class="lineNum">   30067 </span><span class="lineNoCov">          0 :       offset = tree_to_shwi (TREE_OPERAND (init, 1));</span>
<span class="lineNum">   30068 </span><span class="lineNoCov">          0 :       init = TREE_OPERAND (init, 0);</span>
<span class="lineNum">   30069 </span><span class="lineNoCov">          0 :       STRIP_NOPS (init);</span>
<span class="lineNum">   30070 </span>            :     }
<span class="lineNum">   30071 </span><span class="lineCov">         46 :   if (TREE_CODE (init) != ADDR_EXPR)</span>
<span class="lineNum">   30072 </span>            :     return;
<span class="lineNum">   30073 </span><span class="lineCov">          1 :   if ((TREE_CODE (TREE_OPERAND (init, 0)) == STRING_CST</span>
<span class="lineNum">   30074 </span><span class="lineNoCov">          0 :        &amp;&amp; !TREE_ASM_WRITTEN (TREE_OPERAND (init, 0)))</span>
<span class="lineNum">   30075 </span><span class="lineCov">          1 :       || (TREE_CODE (TREE_OPERAND (init, 0)) == VAR_DECL</span>
<span class="lineNum">   30076 </span><span class="lineNoCov">          0 :           &amp;&amp; !DECL_EXTERNAL (TREE_OPERAND (init, 0))</span>
<span class="lineNum">   30077 </span><span class="lineNoCov">          0 :           &amp;&amp; TREE_OPERAND (init, 0) != decl))</span>
<span class="lineNum">   30078 </span>            :     {
<span class="lineNum">   30079 </span><span class="lineNoCov">          0 :       dw_die_ref ref;</span>
<span class="lineNum">   30080 </span><span class="lineNoCov">          0 :       dw_loc_descr_ref l;</span>
<span class="lineNum">   30081 </span>            : 
<span class="lineNum">   30082 </span><span class="lineNoCov">          0 :       if (TREE_CODE (TREE_OPERAND (init, 0)) == STRING_CST)</span>
<span class="lineNum">   30083 </span>            :         {
<span class="lineNum">   30084 </span><span class="lineNoCov">          0 :           rtx rtl = string_cst_pool_decl (TREE_OPERAND (init, 0));</span>
<span class="lineNum">   30085 </span><span class="lineNoCov">          0 :           if (!rtl)</span>
<span class="lineNum">   30086 </span>            :             return;
<span class="lineNum">   30087 </span><span class="lineNoCov">          0 :           decl = SYMBOL_REF_DECL (rtl);</span>
<span class="lineNum">   30088 </span>            :         }
<span class="lineNum">   30089 </span>            :       else
<span class="lineNum">   30090 </span><span class="lineNoCov">          0 :         decl = TREE_OPERAND (init, 0);</span>
<span class="lineNum">   30091 </span><span class="lineNoCov">          0 :       ref = lookup_decl_die (decl);</span>
<span class="lineNum">   30092 </span><span class="lineNoCov">          0 :       if (ref == NULL</span>
<span class="lineNum">   30093 </span><span class="lineNoCov">          0 :           || (!get_AT (ref, DW_AT_location)</span>
<span class="lineNum">   30094 </span><span class="lineNoCov">          0 :               &amp;&amp; !get_AT (ref, DW_AT_const_value)))</span>
<span class="lineNum">   30095 </span>            :         return;
<span class="lineNum">   30096 </span><span class="lineNoCov">          0 :       l = new_loc_descr (dwarf_OP (DW_OP_implicit_pointer), 0, offset);</span>
<span class="lineNum">   30097 </span><span class="lineNoCov">          0 :       l-&gt;dw_loc_oprnd1.val_class = dw_val_class_die_ref;</span>
<span class="lineNum">   30098 </span><span class="lineNoCov">          0 :       l-&gt;dw_loc_oprnd1.v.val_die_ref.die = ref;</span>
<span class="lineNum">   30099 </span><span class="lineNoCov">          0 :       l-&gt;dw_loc_oprnd1.v.val_die_ref.external = 0;</span>
<span class="lineNum">   30100 </span><span class="lineNoCov">          0 :       add_AT_loc (die, DW_AT_location, l);</span>
<span class="lineNum">   30101 </span>            :     }
<span class="lineNum">   30102 </span>            : }
<span class="lineNum">   30103 </span>            : 
<span class="lineNum">   30104 </span>            : /* Return NULL if l is a DWARF expression, or first op that is not
<span class="lineNum">   30105 </span>            :    valid DWARF expression.  */
<a name="30106"><span class="lineNum">   30106 </span>            : </a>
<span class="lineNum">   30107 </span>            : static dw_loc_descr_ref
<span class="lineNum">   30108 </span><span class="lineCov">       1385 : non_dwarf_expression (dw_loc_descr_ref l)</span>
<span class="lineNum">   30109 </span>            : {
<span class="lineNum">   30110 </span><span class="lineCov">       3434 :   while (l)</span>
<span class="lineNum">   30111 </span>            :     {
<span class="lineNum">   30112 </span><span class="lineCov">       3321 :       if (l-&gt;dw_loc_opc &gt;= DW_OP_reg0 &amp;&amp; l-&gt;dw_loc_opc &lt;= DW_OP_reg31)</span>
<span class="lineNum">   30113 </span><span class="lineCov">        754 :         return l;</span>
<span class="lineNum">   30114 </span><span class="lineCov">       2567 :       switch (l-&gt;dw_loc_opc)</span>
<span class="lineNum">   30115 </span>            :         {
<span class="lineNum">   30116 </span>            :         case DW_OP_regx:
<span class="lineNum">   30117 </span>            :         case DW_OP_implicit_value:
<span class="lineNum">   30118 </span>            :         case DW_OP_stack_value:
<span class="lineNum">   30119 </span>            :         case DW_OP_implicit_pointer:
<span class="lineNum">   30120 </span>            :         case DW_OP_GNU_implicit_pointer:
<span class="lineNum">   30121 </span>            :         case DW_OP_GNU_parameter_ref:
<span class="lineNum">   30122 </span>            :         case DW_OP_piece:
<span class="lineNum">   30123 </span>            :         case DW_OP_bit_piece:
<span class="lineNum">   30124 </span>            :           return l;
<span class="lineNum">   30125 </span><span class="lineCov">       2049 :         default:</span>
<span class="lineNum">   30126 </span><span class="lineCov">       2049 :           break;</span>
<span class="lineNum">   30127 </span>            :         }
<span class="lineNum">   30128 </span><span class="lineCov">       2049 :       l = l-&gt;dw_loc_next;</span>
<span class="lineNum">   30129 </span>            :     }
<span class="lineNum">   30130 </span>            :   return NULL;
<span class="lineNum">   30131 </span>            : }
<span class="lineNum">   30132 </span>            : 
<span class="lineNum">   30133 </span>            : /* Return adjusted copy of EXPR:
<span class="lineNum">   30134 </span>            :    If it is empty DWARF expression, return it.
<span class="lineNum">   30135 </span>            :    If it is valid non-empty DWARF expression,
<span class="lineNum">   30136 </span>            :    return copy of EXPR with DW_OP_deref appended to it.
<span class="lineNum">   30137 </span>            :    If it is DWARF expression followed by DW_OP_reg{N,x}, return
<span class="lineNum">   30138 </span>            :    copy of the DWARF expression with DW_OP_breg{N,x} &lt;0&gt; appended.
<span class="lineNum">   30139 </span>            :    If it is DWARF expression followed by DW_OP_stack_value, return
<span class="lineNum">   30140 </span>            :    copy of the DWARF expression without anything appended.
<span class="lineNum">   30141 </span>            :    Otherwise, return NULL.  */
<a name="30142"><span class="lineNum">   30142 </span>            : </a>
<span class="lineNum">   30143 </span>            : static dw_loc_descr_ref
<span class="lineNum">   30144 </span><span class="lineCov">         38 : copy_deref_exprloc (dw_loc_descr_ref expr)</span>
<span class="lineNum">   30145 </span>            : {
<span class="lineNum">   30146 </span><span class="lineCov">         38 :   dw_loc_descr_ref tail = NULL;</span>
<span class="lineNum">   30147 </span>            : 
<span class="lineNum">   30148 </span><span class="lineCov">         38 :   if (expr == NULL)</span>
<span class="lineNum">   30149 </span>            :     return NULL;
<span class="lineNum">   30150 </span>            : 
<span class="lineNum">   30151 </span><span class="lineCov">         38 :   dw_loc_descr_ref l = non_dwarf_expression (expr);</span>
<span class="lineNum">   30152 </span><span class="lineCov">         38 :   if (l &amp;&amp; l-&gt;dw_loc_next)</span>
<span class="lineNum">   30153 </span>            :     return NULL;
<span class="lineNum">   30154 </span>            : 
<span class="lineNum">   30155 </span><span class="lineCov">         38 :   if (l)</span>
<span class="lineNum">   30156 </span>            :     {
<span class="lineNum">   30157 </span><span class="lineCov">         38 :       if (l-&gt;dw_loc_opc &gt;= DW_OP_reg0 &amp;&amp; l-&gt;dw_loc_opc &lt;= DW_OP_reg31)</span>
<span class="lineNum">   30158 </span><span class="lineCov">         58 :         tail = new_loc_descr ((enum dwarf_location_atom)</span>
<span class="lineNum">   30159 </span><span class="lineCov">         29 :                               (DW_OP_breg0 + (l-&gt;dw_loc_opc - DW_OP_reg0)),</span>
<span class="lineNum">   30160 </span>            :                               0, 0);
<span class="lineNum">   30161 </span>            :       else
<span class="lineNum">   30162 </span><span class="lineCov">          9 :         switch (l-&gt;dw_loc_opc)</span>
<span class="lineNum">   30163 </span>            :           {
<span class="lineNum">   30164 </span><span class="lineNoCov">          0 :           case DW_OP_regx:</span>
<span class="lineNum">   30165 </span><span class="lineNoCov">          0 :             tail = new_loc_descr (DW_OP_bregx,</span>
<span class="lineNum">   30166 </span>            :                                   l-&gt;dw_loc_oprnd1.v.val_unsigned, 0);
<span class="lineNum">   30167 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">   30168 </span>            :           case DW_OP_stack_value:
<span class="lineNum">   30169 </span>            :             break;
<span class="lineNum">   30170 </span>            :           default:
<span class="lineNum">   30171 </span>            :             return NULL;
<span class="lineNum">   30172 </span>            :           }
<span class="lineNum">   30173 </span>            :     }
<span class="lineNum">   30174 </span>            :   else
<span class="lineNum">   30175 </span><span class="lineNoCov">          0 :     tail = new_loc_descr (DW_OP_deref, 0, 0);</span>
<span class="lineNum">   30176 </span>            : 
<span class="lineNum">   30177 </span><span class="lineCov">         38 :   dw_loc_descr_ref ret = NULL, *p = &amp;ret;</span>
<span class="lineNum">   30178 </span><span class="lineCov">         47 :   while (expr != l)</span>
<span class="lineNum">   30179 </span>            :     {
<span class="lineNum">   30180 </span><span class="lineCov">          9 :       *p = new_loc_descr (expr-&gt;dw_loc_opc, 0, 0);</span>
<span class="lineNum">   30181 </span><span class="lineCov">          9 :       (*p)-&gt;dw_loc_oprnd1 = expr-&gt;dw_loc_oprnd1;</span>
<span class="lineNum">   30182 </span><span class="lineCov">          9 :       (*p)-&gt;dw_loc_oprnd2 = expr-&gt;dw_loc_oprnd2;</span>
<span class="lineNum">   30183 </span><span class="lineCov">          9 :       p = &amp;(*p)-&gt;dw_loc_next;</span>
<span class="lineNum">   30184 </span><span class="lineCov">          9 :       expr = expr-&gt;dw_loc_next;</span>
<span class="lineNum">   30185 </span>            :     }
<span class="lineNum">   30186 </span><span class="lineCov">         38 :   *p = tail;</span>
<span class="lineNum">   30187 </span><span class="lineCov">         38 :   return ret;</span>
<span class="lineNum">   30188 </span>            : }
<span class="lineNum">   30189 </span>            : 
<span class="lineNum">   30190 </span>            : /* For DW_AT_string_length attribute with DW_OP_GNU_variable_value
<span class="lineNum">   30191 </span>            :    reference to a variable or argument, adjust it if needed and return:
<span class="lineNum">   30192 </span>            :    -1 if the DW_AT_string_length attribute and DW_AT_{string_length_,}byte_size
<span class="lineNum">   30193 </span>            :       attribute if present should be removed
<span class="lineNum">   30194 </span>            :    0 keep the attribute perhaps with minor modifications, no need to rescan
<span class="lineNum">   30195 </span>            :    1 if the attribute has been successfully adjusted.  */
<a name="30196"><span class="lineNum">   30196 </span>            : </a>
<span class="lineNum">   30197 </span>            : static int
<span class="lineNum">   30198 </span><span class="lineCov">        837 : optimize_string_length (dw_attr_node *a)</span>
<span class="lineNum">   30199 </span>            : {
<span class="lineNum">   30200 </span><span class="lineCov">        837 :   dw_loc_descr_ref l = AT_loc (a), lv;</span>
<span class="lineNum">   30201 </span><span class="lineCov">        837 :   dw_die_ref die;</span>
<span class="lineNum">   30202 </span><span class="lineCov">        837 :   if (l-&gt;dw_loc_oprnd1.val_class == dw_val_class_decl_ref)</span>
<span class="lineNum">   30203 </span>            :     {
<span class="lineNum">   30204 </span><span class="lineNoCov">          0 :       tree decl = l-&gt;dw_loc_oprnd1.v.val_decl_ref;</span>
<span class="lineNum">   30205 </span><span class="lineNoCov">          0 :       die = lookup_decl_die (decl);</span>
<span class="lineNum">   30206 </span><span class="lineNoCov">          0 :       if (die)</span>
<span class="lineNum">   30207 </span>            :         {
<span class="lineNum">   30208 </span><span class="lineNoCov">          0 :           l-&gt;dw_loc_oprnd1.val_class = dw_val_class_die_ref;</span>
<span class="lineNum">   30209 </span><span class="lineNoCov">          0 :           l-&gt;dw_loc_oprnd1.v.val_die_ref.die = die;</span>
<span class="lineNum">   30210 </span><span class="lineNoCov">          0 :           l-&gt;dw_loc_oprnd1.v.val_die_ref.external = 0;</span>
<span class="lineNum">   30211 </span>            :         }
<span class="lineNum">   30212 </span>            :       else
<span class="lineNum">   30213 </span>            :         return -1;
<span class="lineNum">   30214 </span>            :     }
<span class="lineNum">   30215 </span>            :   else
<span class="lineNum">   30216 </span><span class="lineCov">        837 :     die = l-&gt;dw_loc_oprnd1.v.val_die_ref.die;</span>
<span class="lineNum">   30217 </span>            : 
<span class="lineNum">   30218 </span>            :   /* DWARF5 allows reference class, so we can then reference the DIE.
<span class="lineNum">   30219 </span>            :      Only do this for DW_OP_GNU_variable_value DW_OP_stack_value.  */
<span class="lineNum">   30220 </span><span class="lineCov">        837 :   if (l-&gt;dw_loc_next != NULL &amp;&amp; dwarf_version &gt;= 5)</span>
<span class="lineNum">   30221 </span>            :     {
<span class="lineNum">   30222 </span><span class="lineNoCov">          0 :       a-&gt;dw_attr_val.val_class = dw_val_class_die_ref;</span>
<span class="lineNum">   30223 </span><span class="lineNoCov">          0 :       a-&gt;dw_attr_val.val_entry = NULL;</span>
<span class="lineNum">   30224 </span><span class="lineNoCov">          0 :       a-&gt;dw_attr_val.v.val_die_ref.die = die;</span>
<span class="lineNum">   30225 </span><span class="lineNoCov">          0 :       a-&gt;dw_attr_val.v.val_die_ref.external = 0;</span>
<span class="lineNum">   30226 </span><span class="lineNoCov">          0 :       return 0;</span>
<span class="lineNum">   30227 </span>            :     }
<span class="lineNum">   30228 </span>            : 
<span class="lineNum">   30229 </span><span class="lineCov">        837 :   dw_attr_node *av = get_AT (die, DW_AT_location);</span>
<span class="lineNum">   30230 </span><span class="lineCov">        837 :   dw_loc_list_ref d;</span>
<span class="lineNum">   30231 </span><span class="lineCov">        837 :   bool non_dwarf_expr = false;</span>
<span class="lineNum">   30232 </span>            : 
<span class="lineNum">   30233 </span><span class="lineCov">        837 :   if (av == NULL)</span>
<span class="lineNum">   30234 </span><span class="lineCov">        854 :     return dwarf_strict ? -1 : 0;</span>
<span class="lineNum">   30235 </span><span class="lineCov">        410 :   switch (AT_class (av))</span>
<span class="lineNum">   30236 </span>            :     {
<span class="lineNum">   30237 </span><span class="lineCov">        320 :     case dw_val_class_loc_list:</span>
<span class="lineNum">   30238 </span><span class="lineCov">       1577 :       for (d = AT_loc_list (av); d != NULL; d = d-&gt;dw_loc_next)</span>
<span class="lineNum">   30239 </span><span class="lineCov">       1257 :         if (d-&gt;expr &amp;&amp; non_dwarf_expression (d-&gt;expr))</span>
<span class="lineNum">   30240 </span>            :           non_dwarf_expr = true;
<span class="lineNum">   30241 </span>            :       break;
<span class="lineNum">   30242 </span><span class="lineNoCov">          0 :     case dw_val_class_view_list:</span>
<span class="lineNum">   30243 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">   30244 </span><span class="lineCov">         90 :     case dw_val_class_loc:</span>
<span class="lineNum">   30245 </span><span class="lineCov">         90 :       lv = AT_loc (av);</span>
<span class="lineNum">   30246 </span><span class="lineCov">         90 :       if (lv == NULL)</span>
<span class="lineNum">   30247 </span><span class="lineNoCov">          0 :         return dwarf_strict ? -1 : 0;</span>
<span class="lineNum">   30248 </span><span class="lineCov">         90 :       if (non_dwarf_expression (lv))</span>
<span class="lineNum">   30249 </span>            :         non_dwarf_expr = true;
<span class="lineNum">   30250 </span>            :       break;
<span class="lineNum">   30251 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">   30252 </span><span class="lineNoCov">          0 :       return dwarf_strict ? -1 : 0;</span>
<span class="lineNum">   30253 </span>            :     }
<span class="lineNum">   30254 </span>            : 
<span class="lineNum">   30255 </span>            :   /* If it is safe to transform DW_OP_GNU_variable_value DW_OP_stack_value
<span class="lineNum">   30256 </span>            :      into DW_OP_call4  or DW_OP_GNU_variable_value into
<span class="lineNum">   30257 </span>            :      DW_OP_call4 DW_OP_deref, do so.  */
<span class="lineNum">   30258 </span><span class="lineCov">        320 :   if (!non_dwarf_expr</span>
<span class="lineNum">   30259 </span><span class="lineCov">        400 :       &amp;&amp; (l-&gt;dw_loc_next != NULL || AT_class (av) == dw_val_class_loc))</span>
<span class="lineNum">   30260 </span>            :     {
<span class="lineNum">   30261 </span><span class="lineCov">         82 :       l-&gt;dw_loc_opc = DW_OP_call4;</span>
<span class="lineNum">   30262 </span><span class="lineCov">         82 :       if (l-&gt;dw_loc_next)</span>
<span class="lineNum">   30263 </span><span class="lineCov">         82 :         l-&gt;dw_loc_next = NULL;</span>
<span class="lineNum">   30264 </span>            :       else
<span class="lineNum">   30265 </span><span class="lineNoCov">          0 :         l-&gt;dw_loc_next = new_loc_descr (DW_OP_deref, 0, 0);</span>
<span class="lineNum">   30266 </span><span class="lineCov">         82 :       return 0;</span>
<span class="lineNum">   30267 </span>            :     }
<span class="lineNum">   30268 </span>            : 
<span class="lineNum">   30269 </span>            :   /* For DW_OP_GNU_variable_value DW_OP_stack_value, we can just
<span class="lineNum">   30270 </span>            :      copy over the DW_AT_location attribute from die to a.  */
<span class="lineNum">   30271 </span><span class="lineCov">        328 :   if (l-&gt;dw_loc_next != NULL)</span>
<span class="lineNum">   30272 </span>            :     {
<span class="lineNum">   30273 </span><span class="lineCov">        323 :       a-&gt;dw_attr_val = av-&gt;dw_attr_val;</span>
<span class="lineNum">   30274 </span><span class="lineCov">        323 :       return 1;</span>
<span class="lineNum">   30275 </span>            :     }
<span class="lineNum">   30276 </span>            : 
<span class="lineNum">   30277 </span><span class="lineCov">          5 :   dw_loc_list_ref list, *p;</span>
<span class="lineNum">   30278 </span><span class="lineCov">          5 :   switch (AT_class (av))</span>
<span class="lineNum">   30279 </span>            :     {
<span class="lineNum">   30280 </span><span class="lineCov">          5 :     case dw_val_class_loc_list:</span>
<span class="lineNum">   30281 </span><span class="lineCov">          5 :       p = &amp;list;</span>
<span class="lineNum">   30282 </span><span class="lineCov">          5 :       list = NULL;</span>
<span class="lineNum">   30283 </span><span class="lineCov">         43 :       for (d = AT_loc_list (av); d != NULL; d = d-&gt;dw_loc_next)</span>
<span class="lineNum">   30284 </span>            :         {
<span class="lineNum">   30285 </span><span class="lineCov">         38 :           lv = copy_deref_exprloc (d-&gt;expr);</span>
<span class="lineNum">   30286 </span><span class="lineCov">         38 :           if (lv)</span>
<span class="lineNum">   30287 </span>            :             {
<span class="lineNum">   30288 </span><span class="lineCov">         38 :               *p = new_loc_list (lv, d-&gt;begin, d-&gt;vbegin, d-&gt;end, d-&gt;vend, d-&gt;section);</span>
<span class="lineNum">   30289 </span><span class="lineCov">         38 :               p = &amp;(*p)-&gt;dw_loc_next;</span>
<span class="lineNum">   30290 </span>            :             }
<span class="lineNum">   30291 </span><span class="lineNoCov">          0 :           else if (!dwarf_strict &amp;&amp; d-&gt;expr)</span>
<span class="lineNum">   30292 </span>            :             return 0;
<span class="lineNum">   30293 </span>            :         }
<span class="lineNum">   30294 </span><span class="lineCov">          5 :       if (list == NULL)</span>
<span class="lineNum">   30295 </span><span class="lineNoCov">          0 :         return dwarf_strict ? -1 : 0;</span>
<span class="lineNum">   30296 </span><span class="lineCov">          5 :       a-&gt;dw_attr_val.val_class = dw_val_class_loc_list;</span>
<span class="lineNum">   30297 </span><span class="lineCov">          5 :       gen_llsym (list);</span>
<span class="lineNum">   30298 </span><span class="lineCov">          5 :       *AT_loc_list_ptr (a) = list;</span>
<span class="lineNum">   30299 </span><span class="lineCov">          5 :       return 1;</span>
<span class="lineNum">   30300 </span><span class="lineNoCov">          0 :     case dw_val_class_loc:</span>
<span class="lineNum">   30301 </span><span class="lineNoCov">          0 :       lv = copy_deref_exprloc (AT_loc (av));</span>
<span class="lineNum">   30302 </span><span class="lineNoCov">          0 :       if (lv == NULL)</span>
<span class="lineNum">   30303 </span><span class="lineNoCov">          0 :         return dwarf_strict ? -1 : 0;</span>
<span class="lineNum">   30304 </span><span class="lineNoCov">          0 :       a-&gt;dw_attr_val.v.val_loc = lv;</span>
<span class="lineNum">   30305 </span><span class="lineNoCov">          0 :       return 1;</span>
<span class="lineNum">   30306 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">   30307 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">   30308 </span>            :     }
<span class="lineNum">   30309 </span>            : }
<span class="lineNum">   30310 </span>            : 
<span class="lineNum">   30311 </span>            : /* Resolve DW_OP_addr and DW_AT_const_value CONST_STRING arguments to
<span class="lineNum">   30312 </span>            :    an address in .rodata section if the string literal is emitted there,
<span class="lineNum">   30313 </span>            :    or remove the containing location list or replace DW_AT_const_value
<span class="lineNum">   30314 </span>            :    with DW_AT_location and empty location expression, if it isn't found
<span class="lineNum">   30315 </span>            :    in .rodata.  Similarly for SYMBOL_REFs, keep only those that refer
<span class="lineNum">   30316 </span>            :    to something that has been emitted in the current CU.  */
<a name="30317"><span class="lineNum">   30317 </span>            : </a>
<span class="lineNum">   30318 </span>            : static void
<span class="lineNum">   30319 </span><span class="lineCov">   46128929 : resolve_addr (dw_die_ref die)</span>
<span class="lineNum">   30320 </span>            : {
<span class="lineNum">   30321 </span><span class="lineCov">   46128929 :   dw_die_ref c;</span>
<span class="lineNum">   30322 </span><span class="lineCov">   46128929 :   dw_attr_node *a;</span>
<span class="lineNum">   30323 </span><span class="lineCov">   46128929 :   dw_loc_list_ref *curr, *start, loc;</span>
<span class="lineNum">   30324 </span><span class="lineCov">   46128929 :   unsigned ix;</span>
<span class="lineNum">   30325 </span><span class="lineCov">   46128929 :   bool remove_AT_byte_size = false;</span>
<span class="lineNum">   30326 </span>            : 
<span class="lineNum">   30327 </span><span class="lineCov">  223941308 :   FOR_EACH_VEC_SAFE_ELT (die-&gt;die_attr, ix, a)</span>
<span class="lineNum">   30328 </span><span class="lineCov">  177812379 :     switch (AT_class (a))</span>
<span class="lineNum">   30329 </span>            :       {
<span class="lineNum">   30330 </span><span class="lineCov">    6136249 :       case dw_val_class_loc_list:</span>
<span class="lineNum">   30331 </span><span class="lineCov">    6136249 :         start = curr = AT_loc_list_ptr (a);</span>
<span class="lineNum">   30332 </span><span class="lineCov">    6136249 :         loc = *curr;</span>
<span class="lineNum">   30333 </span><span class="lineCov">    6136249 :         gcc_assert (loc);</span>
<span class="lineNum">   30334 </span>            :         /* The same list can be referenced more than once.  See if we have
<span class="lineNum">   30335 </span>            :            already recorded the result from a previous pass.  */
<span class="lineNum">   30336 </span><span class="lineCov">    6136249 :         if (loc-&gt;replaced)</span>
<span class="lineNum">   30337 </span><span class="lineNoCov">          0 :           *curr = loc-&gt;dw_loc_next;</span>
<span class="lineNum">   30338 </span><span class="lineCov">    6136249 :         else if (!loc-&gt;resolved_addr)</span>
<span class="lineNum">   30339 </span>            :           {
<span class="lineNum">   30340 </span>            :             /* As things stand, we do not expect or allow one die to
<span class="lineNum">   30341 </span>            :                reference a suffix of another die's location list chain.
<span class="lineNum">   30342 </span>            :                References must be identical or completely separate.
<span class="lineNum">   30343 </span>            :                There is therefore no need to cache the result of this
<span class="lineNum">   30344 </span>            :                pass on any list other than the first; doing so
<span class="lineNum">   30345 </span>            :                would lead to unnecessary writes.  */
<span class="lineNum">   30346 </span><span class="lineCov">   23032538 :             while (*curr)</span>
<span class="lineNum">   30347 </span>            :               {
<span class="lineNum">   30348 </span><span class="lineCov">   16896602 :                 gcc_assert (!(*curr)-&gt;replaced &amp;&amp; !(*curr)-&gt;resolved_addr);</span>
<span class="lineNum">   30349 </span><span class="lineCov">   16896602 :                 if (!resolve_addr_in_expr (a, (*curr)-&gt;expr))</span>
<span class="lineNum">   30350 </span>            :                   {
<span class="lineNum">   30351 </span><span class="lineCov">    1828730 :                     dw_loc_list_ref next = (*curr)-&gt;dw_loc_next;</span>
<span class="lineNum">   30352 </span><span class="lineCov">    1828730 :                     dw_loc_descr_ref l = (*curr)-&gt;expr;</span>
<span class="lineNum">   30353 </span>            : 
<span class="lineNum">   30354 </span><span class="lineCov">    1828730 :                     if (next &amp;&amp; (*curr)-&gt;ll_symbol)</span>
<span class="lineNum">   30355 </span>            :                       {
<span class="lineNum">   30356 </span><span class="lineCov">     905639 :                         gcc_assert (!next-&gt;ll_symbol);</span>
<span class="lineNum">   30357 </span><span class="lineCov">     905639 :                         next-&gt;ll_symbol = (*curr)-&gt;ll_symbol;</span>
<span class="lineNum">   30358 </span><span class="lineCov">     905639 :                         next-&gt;vl_symbol = (*curr)-&gt;vl_symbol;</span>
<span class="lineNum">   30359 </span>            :                       }
<span class="lineNum">   30360 </span><span class="lineCov">    1828730 :                     if (dwarf_split_debug_info)</span>
<span class="lineNum">   30361 </span><span class="lineCov">          1 :                       remove_loc_list_addr_table_entries (l);</span>
<span class="lineNum">   30362 </span><span class="lineCov">    1828730 :                     *curr = next;</span>
<span class="lineNum">   30363 </span>            :                   }
<span class="lineNum">   30364 </span>            :                 else
<span class="lineNum">   30365 </span>            :                   {
<span class="lineNum">   30366 </span><span class="lineCov">   15067872 :                     mark_base_types ((*curr)-&gt;expr);</span>
<span class="lineNum">   30367 </span><span class="lineCov">   15067872 :                     curr = &amp;(*curr)-&gt;dw_loc_next;</span>
<span class="lineNum">   30368 </span>            :                   }
<span class="lineNum">   30369 </span>            :               }
<span class="lineNum">   30370 </span><span class="lineCov">    6135936 :             if (loc == *start)</span>
<span class="lineNum">   30371 </span><span class="lineCov">    5773955 :               loc-&gt;resolved_addr = 1;</span>
<span class="lineNum">   30372 </span>            :             else
<span class="lineNum">   30373 </span>            :               {
<span class="lineNum">   30374 </span><span class="lineCov">     361981 :                 loc-&gt;replaced = 1;</span>
<span class="lineNum">   30375 </span><span class="lineCov">     361981 :                 loc-&gt;dw_loc_next = *start;</span>
<span class="lineNum">   30376 </span>            :               }
<span class="lineNum">   30377 </span>            :           }
<span class="lineNum">   30378 </span><span class="lineCov">    6136249 :         if (!*start)</span>
<span class="lineNum">   30379 </span>            :           {
<span class="lineNum">   30380 </span><span class="lineCov">     344951 :             remove_AT (die, a-&gt;dw_attr);</span>
<span class="lineNum">   30381 </span><span class="lineCov">     344951 :             ix--;</span>
<span class="lineNum">   30382 </span>            :           }
<span class="lineNum">   30383 </span>            :         break;
<span class="lineNum">   30384 </span><span class="lineCov">    6050836 :       case dw_val_class_view_list:</span>
<span class="lineNum">   30385 </span><span class="lineCov">    6050836 :         {</span>
<span class="lineNum">   30386 </span><span class="lineCov">    6050836 :           gcc_checking_assert (a-&gt;dw_attr == DW_AT_GNU_locviews);</span>
<span class="lineNum">   30387 </span><span class="lineCov">    6050836 :           gcc_checking_assert (dwarf2out_locviews_in_attribute ());</span>
<span class="lineNum">   30388 </span><span class="lineCov">    6050836 :           dw_val_node *llnode</span>
<span class="lineNum">   30389 </span><span class="lineCov">    6050836 :             = view_list_to_loc_list_val_node (&amp;a-&gt;dw_attr_val);</span>
<span class="lineNum">   30390 </span>            :           /* If we no longer have a loclist, or it no longer needs
<span class="lineNum">   30391 </span>            :              views, drop this attribute.  */
<span class="lineNum">   30392 </span><span class="lineCov">    6050836 :           if (!llnode || !llnode-&gt;v.val_loc_list-&gt;vl_symbol)</span>
<span class="lineNum">   30393 </span>            :             {
<span class="lineNum">   30394 </span><span class="lineCov">     344951 :               remove_AT (die, a-&gt;dw_attr);</span>
<span class="lineNum">   30395 </span><span class="lineCov">     344951 :               ix--;</span>
<span class="lineNum">   30396 </span>            :             }
<span class="lineNum">   30397 </span>            :           break;
<span class="lineNum">   30398 </span>            :         }
<span class="lineNum">   30399 </span><span class="lineCov">    4989315 :       case dw_val_class_loc:</span>
<span class="lineNum">   30400 </span><span class="lineCov">    4989315 :         {</span>
<span class="lineNum">   30401 </span><span class="lineCov">    4989315 :           dw_loc_descr_ref l = AT_loc (a);</span>
<span class="lineNum">   30402 </span>            :           /* DW_OP_GNU_variable_value DW_OP_stack_value or
<span class="lineNum">   30403 </span>            :              DW_OP_GNU_variable_value in DW_AT_string_length can be converted
<span class="lineNum">   30404 </span>            :              into DW_OP_call4 or DW_OP_call4 DW_OP_deref, which is standard
<span class="lineNum">   30405 </span>            :              DWARF4 unlike DW_OP_GNU_variable_value.  Or for DWARF5
<span class="lineNum">   30406 </span>            :              DW_OP_GNU_variable_value DW_OP_stack_value can be replaced
<span class="lineNum">   30407 </span>            :              with DW_FORM_ref referencing the same DIE as
<span class="lineNum">   30408 </span>            :              DW_OP_GNU_variable_value used to reference.  */
<span class="lineNum">   30409 </span><span class="lineCov">    4989315 :           if (a-&gt;dw_attr == DW_AT_string_length</span>
<span class="lineNum">   30410 </span><span class="lineCov">        859 :               &amp;&amp; l</span>
<span class="lineNum">   30411 </span><span class="lineCov">        859 :               &amp;&amp; l-&gt;dw_loc_opc == DW_OP_GNU_variable_value</span>
<span class="lineNum">   30412 </span><span class="lineCov">        837 :               &amp;&amp; (l-&gt;dw_loc_next == NULL</span>
<span class="lineNum">   30413 </span><span class="lineCov">        819 :                   || (l-&gt;dw_loc_next-&gt;dw_loc_next == NULL</span>
<span class="lineNum">   30414 </span><span class="lineCov">        819 :                       &amp;&amp; l-&gt;dw_loc_next-&gt;dw_loc_opc == DW_OP_stack_value)))</span>
<span class="lineNum">   30415 </span>            :             {
<span class="lineNum">   30416 </span><span class="lineCov">        837 :               switch (optimize_string_length (a))</span>
<span class="lineNum">   30417 </span>            :                 {
<span class="lineNum">   30418 </span><span class="lineNoCov">          0 :                 case -1:</span>
<span class="lineNum">   30419 </span><span class="lineNoCov">          0 :                   remove_AT (die, a-&gt;dw_attr);</span>
<span class="lineNum">   30420 </span><span class="lineNoCov">          0 :                   ix--;</span>
<span class="lineNum">   30421 </span>            :                   /* If we drop DW_AT_string_length, we need to drop also
<span class="lineNum">   30422 </span>            :                      DW_AT_{string_length_,}byte_size.  */
<span class="lineNum">   30423 </span><span class="lineNoCov">          0 :                   remove_AT_byte_size = true;</span>
<span class="lineNum">   30424 </span><span class="lineNoCov">          0 :                   continue;</span>
<span class="lineNum">   30425 </span>            :                 default:
<span class="lineNum">   30426 </span>            :                   break;
<span class="lineNum">   30427 </span><span class="lineCov">        328 :                 case 1:</span>
<span class="lineNum">   30428 </span>            :                   /* Even if we keep the optimized DW_AT_string_length,
<span class="lineNum">   30429 </span>            :                      it might have changed AT_class, so process it again.  */
<span class="lineNum">   30430 </span><span class="lineCov">        328 :                   ix--;</span>
<span class="lineNum">   30431 </span><span class="lineCov">        328 :                   continue;</span>
<span class="lineNum">   30432 </span>            :                 }
<span class="lineNum">   30433 </span>            :             }
<span class="lineNum">   30434 </span>            :           /* For -gdwarf-2 don't attempt to optimize
<span class="lineNum">   30435 </span>            :              DW_AT_data_member_location containing
<span class="lineNum">   30436 </span>            :              DW_OP_plus_uconst - older consumers might
<span class="lineNum">   30437 </span>            :              rely on it being that op instead of a more complex,
<span class="lineNum">   30438 </span>            :              but shorter, location description.  */
<span class="lineNum">   30439 </span><span class="lineCov">    4988987 :           if ((dwarf_version &gt; 2</span>
<span class="lineNum">   30440 </span><span class="lineCov">       7962 :                || a-&gt;dw_attr != DW_AT_data_member_location</span>
<span class="lineNum">   30441 </span><span class="lineCov">       1909 :                || l == NULL</span>
<span class="lineNum">   30442 </span><span class="lineCov">       1909 :                || l-&gt;dw_loc_opc != DW_OP_plus_uconst</span>
<span class="lineNum">   30443 </span><span class="lineCov">       1909 :                || l-&gt;dw_loc_next != NULL)</span>
<span class="lineNum">   30444 </span><span class="lineCov">    4995040 :               &amp;&amp; !resolve_addr_in_expr (a, l))</span>
<span class="lineNum">   30445 </span>            :             {
<span class="lineNum">   30446 </span><span class="lineCov">      14792 :               if (dwarf_split_debug_info)</span>
<span class="lineNum">   30447 </span><span class="lineNoCov">          0 :                 remove_loc_list_addr_table_entries (l);</span>
<span class="lineNum">   30448 </span><span class="lineCov">      14792 :               if (l != NULL</span>
<span class="lineNum">   30449 </span><span class="lineCov">      14792 :                   &amp;&amp; l-&gt;dw_loc_next == NULL</span>
<span class="lineNum">   30450 </span><span class="lineCov">      14501 :                   &amp;&amp; l-&gt;dw_loc_opc == DW_OP_addr</span>
<span class="lineNum">   30451 </span><span class="lineCov">      14379 :                   &amp;&amp; GET_CODE (l-&gt;dw_loc_oprnd1.v.val_addr) == SYMBOL_REF</span>
<span class="lineNum">   30452 </span><span class="lineCov">      14039 :                   &amp;&amp; SYMBOL_REF_DECL (l-&gt;dw_loc_oprnd1.v.val_addr)</span>
<span class="lineNum">   30453 </span><span class="lineCov">      28831 :                   &amp;&amp; a-&gt;dw_attr == DW_AT_location)</span>
<span class="lineNum">   30454 </span>            :                 {
<span class="lineNum">   30455 </span><span class="lineCov">        261 :                   tree decl = SYMBOL_REF_DECL (l-&gt;dw_loc_oprnd1.v.val_addr);</span>
<span class="lineNum">   30456 </span><span class="lineCov">        261 :                   remove_AT (die, a-&gt;dw_attr);</span>
<span class="lineNum">   30457 </span><span class="lineCov">        261 :                   ix--;</span>
<span class="lineNum">   30458 </span><span class="lineCov">        261 :                   optimize_location_into_implicit_ptr (die, decl);</span>
<span class="lineNum">   30459 </span><span class="lineCov">        261 :                   break;</span>
<span class="lineNum">   30460 </span>            :                 }
<span class="lineNum">   30461 </span><span class="lineCov">      14531 :               if (a-&gt;dw_attr == DW_AT_string_length)</span>
<span class="lineNum">   30462 </span>            :                 /* If we drop DW_AT_string_length, we need to drop also
<span class="lineNum">   30463 </span>            :                    DW_AT_{string_length_,}byte_size.  */
<span class="lineNum">   30464 </span><span class="lineNoCov">          0 :                 remove_AT_byte_size = true;</span>
<span class="lineNum">   30465 </span><span class="lineCov">      14531 :               remove_AT (die, a-&gt;dw_attr);</span>
<span class="lineNum">   30466 </span><span class="lineCov">      14531 :               ix--;</span>
<span class="lineNum">   30467 </span>            :             }
<span class="lineNum">   30468 </span>            :           else
<span class="lineNum">   30469 </span><span class="lineCov">    4974195 :             mark_base_types (l);</span>
<span class="lineNum">   30470 </span>            :         }
<span class="lineNum">   30471 </span>            :         break;
<span class="lineNum">   30472 </span><span class="lineCov">    1413022 :       case dw_val_class_addr:</span>
<span class="lineNum">   30473 </span><span class="lineCov">    1413022 :         if (a-&gt;dw_attr == DW_AT_const_value</span>
<span class="lineNum">   30474 </span><span class="lineCov">    1413022 :             &amp;&amp; !resolve_one_addr (&amp;a-&gt;dw_attr_val.v.val_addr))</span>
<span class="lineNum">   30475 </span>            :           {
<span class="lineNum">   30476 </span><span class="lineNoCov">          0 :             if (AT_index (a) != NOT_INDEXED)</span>
<span class="lineNum">   30477 </span><span class="lineNoCov">          0 :               remove_addr_table_entry (a-&gt;dw_attr_val.val_entry);</span>
<span class="lineNum">   30478 </span><span class="lineNoCov">          0 :             remove_AT (die, a-&gt;dw_attr);</span>
<span class="lineNum">   30479 </span><span class="lineNoCov">          0 :             ix--;</span>
<span class="lineNum">   30480 </span>            :           }
<span class="lineNum">   30481 </span><span class="lineCov">    1413022 :         if ((die-&gt;die_tag == DW_TAG_call_site</span>
<span class="lineNum">   30482 </span><span class="lineCov">          3 :              &amp;&amp; a-&gt;dw_attr == DW_AT_call_origin)</span>
<span class="lineNum">   30483 </span><span class="lineCov">    1413019 :             || (die-&gt;die_tag == DW_TAG_GNU_call_site</span>
<span class="lineNum">   30484 </span><span class="lineCov">    1413019 :                 &amp;&amp; a-&gt;dw_attr == DW_AT_abstract_origin))</span>
<span class="lineNum">   30485 </span>            :           {
<span class="lineNum">   30486 </span><span class="lineCov">    1413022 :             tree tdecl = SYMBOL_REF_DECL (a-&gt;dw_attr_val.v.val_addr);</span>
<span class="lineNum">   30487 </span><span class="lineCov">    1413022 :             dw_die_ref tdie = lookup_decl_die (tdecl);</span>
<span class="lineNum">   30488 </span><span class="lineCov">    1413022 :             dw_die_ref cdie;</span>
<span class="lineNum">   30489 </span><span class="lineCov">    1413022 :             if (tdie == NULL</span>
<span class="lineNum">   30490 </span><span class="lineCov">     319085 :                 &amp;&amp; DECL_EXTERNAL (tdecl)</span>
<span class="lineNum">   30491 </span><span class="lineCov">     561500 :                 &amp;&amp; DECL_ABSTRACT_ORIGIN (tdecl) == NULL_TREE</span>
<span class="lineNum">   30492 </span><span class="lineCov">    1647741 :                 &amp;&amp; (cdie = lookup_context_die (DECL_CONTEXT (tdecl))))</span>
<span class="lineNum">   30493 </span>            :               {
<span class="lineNum">   30494 </span>            :                 dw_die_ref pdie = cdie;
<span class="lineNum">   30495 </span>            :                 /* Make sure we don't add these DIEs into type units.
<span class="lineNum">   30496 </span>            :                    We could emit skeleton DIEs for context (namespaces,
<span class="lineNum">   30497 </span>            :                    outer structs/classes) and a skeleton DIE for the
<span class="lineNum">   30498 </span>            :                    innermost context with DW_AT_signature pointing to the
<span class="lineNum">   30499 </span>            :                    type unit.  See PR78835.  */
<span class="lineNum">   30500 </span><span class="lineCov">     495541 :                 while (pdie &amp;&amp; pdie-&gt;die_tag != DW_TAG_type_unit)</span>
<span class="lineNum">   30501 </span><span class="lineCov">     262276 :                   pdie = pdie-&gt;die_parent;</span>
<span class="lineNum">   30502 </span><span class="lineCov">     233265 :                 if (pdie == NULL)</span>
<span class="lineNum">   30503 </span>            :                   {
<span class="lineNum">   30504 </span>            :                     /* Creating a full DIE for tdecl is overly expensive and
<span class="lineNum">   30505 </span>            :                        at this point even wrong when in the LTO phase
<span class="lineNum">   30506 </span>            :                        as it can end up generating new type DIEs we didn't
<span class="lineNum">   30507 </span>            :                        output and thus optimize_external_refs will crash.  */
<span class="lineNum">   30508 </span><span class="lineCov">     233265 :                     tdie = new_die (DW_TAG_subprogram, cdie, NULL_TREE);</span>
<span class="lineNum">   30509 </span><span class="lineCov">     233265 :                     add_AT_flag (tdie, DW_AT_external, 1);</span>
<span class="lineNum">   30510 </span><span class="lineCov">     233265 :                     add_AT_flag (tdie, DW_AT_declaration, 1);</span>
<span class="lineNum">   30511 </span><span class="lineCov">     233265 :                     add_linkage_attr (tdie, tdecl);</span>
<span class="lineNum">   30512 </span><span class="lineCov">     233265 :                     add_name_and_src_coords_attributes (tdie, tdecl, true);</span>
<span class="lineNum">   30513 </span><span class="lineCov">     233265 :                     equate_decl_number_to_die (tdecl, tdie);</span>
<span class="lineNum">   30514 </span>            :                   }
<span class="lineNum">   30515 </span>            :               }
<span class="lineNum">   30516 </span><span class="lineCov">    1413022 :             if (tdie)</span>
<span class="lineNum">   30517 </span>            :               {
<span class="lineNum">   30518 </span><span class="lineCov">    1327202 :                 a-&gt;dw_attr_val.val_class = dw_val_class_die_ref;</span>
<span class="lineNum">   30519 </span><span class="lineCov">    1327202 :                 a-&gt;dw_attr_val.v.val_die_ref.die = tdie;</span>
<span class="lineNum">   30520 </span><span class="lineCov">    1327202 :                 a-&gt;dw_attr_val.v.val_die_ref.external = 0;</span>
<span class="lineNum">   30521 </span>            :               }
<span class="lineNum">   30522 </span>            :             else
<span class="lineNum">   30523 </span>            :               {
<span class="lineNum">   30524 </span><span class="lineCov">      85820 :                 if (AT_index (a) != NOT_INDEXED)</span>
<span class="lineNum">   30525 </span><span class="lineNoCov">          0 :                   remove_addr_table_entry (a-&gt;dw_attr_val.val_entry);</span>
<span class="lineNum">   30526 </span><span class="lineCov">      85820 :                 remove_AT (die, a-&gt;dw_attr);</span>
<span class="lineNum">   30527 </span><span class="lineCov">      85820 :                 ix--;</span>
<span class="lineNum">   30528 </span>            :               }
<span class="lineNum">   30529 </span><span class="lineNoCov">          0 :           }</span>
<span class="lineNum">   30530 </span>            :         break;
<span class="lineNum">   30531 </span>            :       default:
<span class="lineNum">   30532 </span>            :         break;
<span class="lineNum">   30533 </span>            :       }
<span class="lineNum">   30534 </span>            : 
<span class="lineNum">   30535 </span><span class="lineCov">   46128929 :   if (remove_AT_byte_size)</span>
<span class="lineNum">   30536 </span><span class="lineNoCov">          0 :     remove_AT (die, dwarf_version &gt;= 5</span>
<span class="lineNum">   30537 </span>            :                     ? DW_AT_string_length_byte_size
<span class="lineNum">   30538 </span>            :                     : DW_AT_byte_size);
<span class="lineNum">   30539 </span>            : 
<span class="lineNum">   30540 </span><span class="lineCov">   80470123 :   FOR_EACH_CHILD (die, c, resolve_addr (c));</span>
<span class="lineNum">   30541 </span><span class="lineCov">   46128929 : }</span>
<span class="lineNum">   30542 </span>            : 
<span class="lineNum">   30543 </span>            : /* Helper routines for optimize_location_lists.
<span class="lineNum">   30544 </span>            :    This pass tries to share identical local lists in .debug_loc
<span class="lineNum">   30545 </span>            :    section.  */
<span class="lineNum">   30546 </span>            : 
<span class="lineNum">   30547 </span>            : /* Iteratively hash operands of LOC opcode into HSTATE.  */
<a name="30548"><span class="lineNum">   30548 </span>            : </a>
<span class="lineNum">   30549 </span>            : static void
<span class="lineNum">   30550 </span><span class="lineCov">   29725788 : hash_loc_operands (dw_loc_descr_ref loc, inchash::hash &amp;hstate)</span>
<span class="lineNum">   30551 </span>            : {
<span class="lineNum">   30552 </span><span class="lineCov">   29725788 :   dw_val_ref val1 = &amp;loc-&gt;dw_loc_oprnd1;</span>
<span class="lineNum">   30553 </span><span class="lineCov">   29725788 :   dw_val_ref val2 = &amp;loc-&gt;dw_loc_oprnd2;</span>
<span class="lineNum">   30554 </span>            : 
<span class="lineNum">   30555 </span><span class="lineCov">   29725788 :   switch (loc-&gt;dw_loc_opc)</span>
<span class="lineNum">   30556 </span>            :     {
<span class="lineNum">   30557 </span><span class="lineCov">      61769 :     case DW_OP_const4u:</span>
<span class="lineNum">   30558 </span><span class="lineCov">      61769 :     case DW_OP_const8u:</span>
<span class="lineNum">   30559 </span><span class="lineCov">      61769 :       if (loc-&gt;dtprel)</span>
<span class="lineNum">   30560 </span>            :         goto hash_addr;
<span class="lineNum">   30561 </span>            :       /* FALLTHRU */
<span class="lineNum">   30562 </span><span class="lineCov">   10403642 :     case DW_OP_const1u:</span>
<span class="lineNum">   30563 </span><span class="lineCov">   10403642 :     case DW_OP_const1s:</span>
<span class="lineNum">   30564 </span><span class="lineCov">   10403642 :     case DW_OP_const2u:</span>
<span class="lineNum">   30565 </span><span class="lineCov">   10403642 :     case DW_OP_const2s:</span>
<span class="lineNum">   30566 </span><span class="lineCov">   10403642 :     case DW_OP_const4s:</span>
<span class="lineNum">   30567 </span><span class="lineCov">   10403642 :     case DW_OP_const8s:</span>
<span class="lineNum">   30568 </span><span class="lineCov">   10403642 :     case DW_OP_constu:</span>
<span class="lineNum">   30569 </span><span class="lineCov">   10403642 :     case DW_OP_consts:</span>
<span class="lineNum">   30570 </span><span class="lineCov">   10403642 :     case DW_OP_pick:</span>
<span class="lineNum">   30571 </span><span class="lineCov">   10403642 :     case DW_OP_plus_uconst:</span>
<span class="lineNum">   30572 </span><span class="lineCov">   10403642 :     case DW_OP_breg0:</span>
<span class="lineNum">   30573 </span><span class="lineCov">   10403642 :     case DW_OP_breg1:</span>
<span class="lineNum">   30574 </span><span class="lineCov">   10403642 :     case DW_OP_breg2:</span>
<span class="lineNum">   30575 </span><span class="lineCov">   10403642 :     case DW_OP_breg3:</span>
<span class="lineNum">   30576 </span><span class="lineCov">   10403642 :     case DW_OP_breg4:</span>
<span class="lineNum">   30577 </span><span class="lineCov">   10403642 :     case DW_OP_breg5:</span>
<span class="lineNum">   30578 </span><span class="lineCov">   10403642 :     case DW_OP_breg6:</span>
<span class="lineNum">   30579 </span><span class="lineCov">   10403642 :     case DW_OP_breg7:</span>
<span class="lineNum">   30580 </span><span class="lineCov">   10403642 :     case DW_OP_breg8:</span>
<span class="lineNum">   30581 </span><span class="lineCov">   10403642 :     case DW_OP_breg9:</span>
<span class="lineNum">   30582 </span><span class="lineCov">   10403642 :     case DW_OP_breg10:</span>
<span class="lineNum">   30583 </span><span class="lineCov">   10403642 :     case DW_OP_breg11:</span>
<span class="lineNum">   30584 </span><span class="lineCov">   10403642 :     case DW_OP_breg12:</span>
<span class="lineNum">   30585 </span><span class="lineCov">   10403642 :     case DW_OP_breg13:</span>
<span class="lineNum">   30586 </span><span class="lineCov">   10403642 :     case DW_OP_breg14:</span>
<span class="lineNum">   30587 </span><span class="lineCov">   10403642 :     case DW_OP_breg15:</span>
<span class="lineNum">   30588 </span><span class="lineCov">   10403642 :     case DW_OP_breg16:</span>
<span class="lineNum">   30589 </span><span class="lineCov">   10403642 :     case DW_OP_breg17:</span>
<span class="lineNum">   30590 </span><span class="lineCov">   10403642 :     case DW_OP_breg18:</span>
<span class="lineNum">   30591 </span><span class="lineCov">   10403642 :     case DW_OP_breg19:</span>
<span class="lineNum">   30592 </span><span class="lineCov">   10403642 :     case DW_OP_breg20:</span>
<span class="lineNum">   30593 </span><span class="lineCov">   10403642 :     case DW_OP_breg21:</span>
<span class="lineNum">   30594 </span><span class="lineCov">   10403642 :     case DW_OP_breg22:</span>
<span class="lineNum">   30595 </span><span class="lineCov">   10403642 :     case DW_OP_breg23:</span>
<span class="lineNum">   30596 </span><span class="lineCov">   10403642 :     case DW_OP_breg24:</span>
<span class="lineNum">   30597 </span><span class="lineCov">   10403642 :     case DW_OP_breg25:</span>
<span class="lineNum">   30598 </span><span class="lineCov">   10403642 :     case DW_OP_breg26:</span>
<span class="lineNum">   30599 </span><span class="lineCov">   10403642 :     case DW_OP_breg27:</span>
<span class="lineNum">   30600 </span><span class="lineCov">   10403642 :     case DW_OP_breg28:</span>
<span class="lineNum">   30601 </span><span class="lineCov">   10403642 :     case DW_OP_breg29:</span>
<span class="lineNum">   30602 </span><span class="lineCov">   10403642 :     case DW_OP_breg30:</span>
<span class="lineNum">   30603 </span><span class="lineCov">   10403642 :     case DW_OP_breg31:</span>
<span class="lineNum">   30604 </span><span class="lineCov">   10403642 :     case DW_OP_regx:</span>
<span class="lineNum">   30605 </span><span class="lineCov">   10403642 :     case DW_OP_fbreg:</span>
<span class="lineNum">   30606 </span><span class="lineCov">   10403642 :     case DW_OP_piece:</span>
<span class="lineNum">   30607 </span><span class="lineCov">   10403642 :     case DW_OP_deref_size:</span>
<span class="lineNum">   30608 </span><span class="lineCov">   10403642 :     case DW_OP_xderef_size:</span>
<span class="lineNum">   30609 </span><span class="lineCov">   10403642 :       hstate.add_object (val1-&gt;v.val_int);</span>
<span class="lineNum">   30610 </span>            :       break;
<span class="lineNum">   30611 </span><span class="lineCov">      18792 :     case DW_OP_skip:</span>
<span class="lineNum">   30612 </span><span class="lineCov">      18792 :     case DW_OP_bra:</span>
<span class="lineNum">   30613 </span><span class="lineCov">      18792 :       {</span>
<span class="lineNum">   30614 </span><span class="lineCov">      18792 :         int offset;</span>
<span class="lineNum">   30615 </span>            : 
<span class="lineNum">   30616 </span><span class="lineCov">      18792 :         gcc_assert (val1-&gt;val_class == dw_val_class_loc);</span>
<span class="lineNum">   30617 </span><span class="lineCov">      18792 :         offset = val1-&gt;v.val_loc-&gt;dw_loc_addr - (loc-&gt;dw_loc_addr + 3);</span>
<span class="lineNum">   30618 </span><span class="lineCov">      18792 :         hstate.add_object (offset);</span>
<span class="lineNum">   30619 </span>            :       }
<span class="lineNum">   30620 </span><span class="lineCov">      18792 :       break;</span>
<span class="lineNum">   30621 </span><span class="lineCov">      67400 :     case DW_OP_implicit_value:</span>
<span class="lineNum">   30622 </span><span class="lineCov">      67400 :       hstate.add_object (val1-&gt;v.val_unsigned);</span>
<span class="lineNum">   30623 </span><span class="lineCov">      67400 :       switch (val2-&gt;val_class)</span>
<span class="lineNum">   30624 </span>            :         {
<span class="lineNum">   30625 </span><span class="lineCov">      18287 :         case dw_val_class_const:</span>
<span class="lineNum">   30626 </span><span class="lineCov">      18287 :           hstate.add_object (val2-&gt;v.val_int);</span>
<span class="lineNum">   30627 </span>            :           break;
<span class="lineNum">   30628 </span><span class="lineCov">      49035 :         case dw_val_class_vec:</span>
<span class="lineNum">   30629 </span><span class="lineCov">      49035 :           {</span>
<span class="lineNum">   30630 </span><span class="lineCov">      49035 :             unsigned int elt_size = val2-&gt;v.val_vec.elt_size;</span>
<span class="lineNum">   30631 </span><span class="lineCov">      49035 :             unsigned int len = val2-&gt;v.val_vec.length;</span>
<span class="lineNum">   30632 </span>            : 
<span class="lineNum">   30633 </span><span class="lineCov">      49035 :             hstate.add_int (elt_size);</span>
<span class="lineNum">   30634 </span><span class="lineCov">      49035 :             hstate.add_int (len);</span>
<span class="lineNum">   30635 </span><span class="lineCov">      49035 :             hstate.add (val2-&gt;v.val_vec.array, len * elt_size);</span>
<span class="lineNum">   30636 </span>            :           }
<span class="lineNum">   30637 </span>            :           break;
<span class="lineNum">   30638 </span><span class="lineNoCov">          0 :         case dw_val_class_const_double:</span>
<span class="lineNum">   30639 </span><span class="lineNoCov">          0 :           hstate.add_object (val2-&gt;v.val_double.low);</span>
<span class="lineNum">   30640 </span><span class="lineNoCov">          0 :           hstate.add_object (val2-&gt;v.val_double.high);</span>
<span class="lineNum">   30641 </span>            :           break;
<span class="lineNum">   30642 </span><span class="lineCov">         78 :         case dw_val_class_wide_int:</span>
<span class="lineNum">   30643 </span><span class="lineCov">         78 :           hstate.add (val2-&gt;v.val_wide-&gt;get_val (),</span>
<span class="lineNum">   30644 </span><span class="lineCov">         78 :                       get_full_len (*val2-&gt;v.val_wide)</span>
<span class="lineNum">   30645 </span><span class="lineCov">         78 :                       * HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR);</span>
<span class="lineNum">   30646 </span>            :           break;
<span class="lineNum">   30647 </span><span class="lineNoCov">          0 :         case dw_val_class_addr: </span>
<span class="lineNum">   30648 </span><span class="lineNoCov">          0 :           inchash::add_rtx (val2-&gt;v.val_addr, hstate);</span>
<span class="lineNum">   30649 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   30650 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">   30651 </span><span class="lineNoCov">          0 :           gcc_unreachable ();</span>
<span class="lineNum">   30652 </span>            :         }
<span class="lineNum">   30653 </span>            :       break;
<span class="lineNum">   30654 </span><span class="lineCov">       2229 :     case DW_OP_bregx:</span>
<span class="lineNum">   30655 </span><span class="lineCov">       2229 :     case DW_OP_bit_piece:</span>
<span class="lineNum">   30656 </span><span class="lineCov">       2229 :       hstate.add_object (val1-&gt;v.val_int);</span>
<span class="lineNum">   30657 </span><span class="lineCov">       2229 :       hstate.add_object (val2-&gt;v.val_int);</span>
<span class="lineNum">   30658 </span>            :       break;
<span class="lineNum">   30659 </span><span class="lineCov">     427162 :     case DW_OP_addr:</span>
<span class="lineNum">   30660 </span><span class="lineCov">     854324 :     hash_addr:</span>
<span class="lineNum">   30661 </span><span class="lineCov">     427162 :       if (loc-&gt;dtprel)</span>
<span class="lineNum">   30662 </span>            :         {
<span class="lineNum">   30663 </span><span class="lineCov">        241 :           unsigned char dtprel = 0xd1;</span>
<span class="lineNum">   30664 </span><span class="lineCov">        241 :           hstate.add_object (dtprel);</span>
<span class="lineNum">   30665 </span>            :         }
<span class="lineNum">   30666 </span><span class="lineCov">     427162 :       inchash::add_rtx (val1-&gt;v.val_addr, hstate);</span>
<span class="lineNum">   30667 </span><span class="lineCov">     427162 :       break;</span>
<span class="lineNum">   30668 </span><span class="lineCov">          7 :     case DW_OP_GNU_addr_index:</span>
<span class="lineNum">   30669 </span><span class="lineCov">          7 :     case DW_OP_addrx:</span>
<span class="lineNum">   30670 </span><span class="lineCov">          7 :     case DW_OP_GNU_const_index:</span>
<span class="lineNum">   30671 </span><span class="lineCov">          7 :     case DW_OP_constx:</span>
<span class="lineNum">   30672 </span><span class="lineCov">          7 :       {</span>
<span class="lineNum">   30673 </span><span class="lineCov">          7 :         if (loc-&gt;dtprel)</span>
<span class="lineNum">   30674 </span>            :           {
<span class="lineNum">   30675 </span><span class="lineNoCov">          0 :             unsigned char dtprel = 0xd1;</span>
<span class="lineNum">   30676 </span><span class="lineNoCov">          0 :             hstate.add_object (dtprel);</span>
<span class="lineNum">   30677 </span>            :           }
<span class="lineNum">   30678 </span><span class="lineCov">          7 :         inchash::add_rtx (val1-&gt;val_entry-&gt;addr.rtl, hstate);</span>
<span class="lineNum">   30679 </span>            :       }
<span class="lineNum">   30680 </span><span class="lineCov">          7 :       break;</span>
<span class="lineNum">   30681 </span><span class="lineCov">     612412 :     case DW_OP_implicit_pointer:</span>
<span class="lineNum">   30682 </span><span class="lineCov">     612412 :     case DW_OP_GNU_implicit_pointer:</span>
<span class="lineNum">   30683 </span><span class="lineCov">     612412 :       hstate.add_int (val2-&gt;v.val_int);</span>
<span class="lineNum">   30684 </span>            :       break;
<span class="lineNum">   30685 </span><span class="lineCov">     821740 :     case DW_OP_entry_value:</span>
<span class="lineNum">   30686 </span><span class="lineCov">     821740 :     case DW_OP_GNU_entry_value:</span>
<span class="lineNum">   30687 </span><span class="lineCov">     821740 :       hstate.add_object (val1-&gt;v.val_loc);</span>
<span class="lineNum">   30688 </span>            :       break;
<span class="lineNum">   30689 </span><span class="lineCov">      80776 :     case DW_OP_regval_type:</span>
<span class="lineNum">   30690 </span><span class="lineCov">      80776 :     case DW_OP_deref_type:</span>
<span class="lineNum">   30691 </span><span class="lineCov">      80776 :     case DW_OP_GNU_regval_type:</span>
<span class="lineNum">   30692 </span><span class="lineCov">      80776 :     case DW_OP_GNU_deref_type:</span>
<span class="lineNum">   30693 </span><span class="lineCov">      80776 :       {</span>
<span class="lineNum">   30694 </span><span class="lineCov">      80776 :         unsigned int byte_size</span>
<span class="lineNum">   30695 </span><span class="lineCov">      80776 :           = get_AT_unsigned (val2-&gt;v.val_die_ref.die, DW_AT_byte_size);</span>
<span class="lineNum">   30696 </span><span class="lineCov">      80776 :         unsigned int encoding</span>
<span class="lineNum">   30697 </span><span class="lineCov">      80776 :           = get_AT_unsigned (val2-&gt;v.val_die_ref.die, DW_AT_encoding);</span>
<span class="lineNum">   30698 </span><span class="lineCov">      80776 :         hstate.add_object (val1-&gt;v.val_int);</span>
<span class="lineNum">   30699 </span><span class="lineCov">      80776 :         hstate.add_object (byte_size);</span>
<span class="lineNum">   30700 </span><span class="lineCov">      80776 :         hstate.add_object (encoding);</span>
<span class="lineNum">   30701 </span>            :       }
<span class="lineNum">   30702 </span><span class="lineCov">      80776 :       break;</span>
<span class="lineNum">   30703 </span><span class="lineCov">      73513 :     case DW_OP_convert:</span>
<span class="lineNum">   30704 </span><span class="lineCov">      73513 :     case DW_OP_reinterpret:</span>
<span class="lineNum">   30705 </span><span class="lineCov">      73513 :     case DW_OP_GNU_convert:</span>
<span class="lineNum">   30706 </span><span class="lineCov">      73513 :     case DW_OP_GNU_reinterpret:</span>
<span class="lineNum">   30707 </span><span class="lineCov">      73513 :       if (val1-&gt;val_class == dw_val_class_unsigned_const)</span>
<span class="lineNum">   30708 </span>            :         {
<span class="lineNum">   30709 </span><span class="lineCov">       3409 :           hstate.add_object (val1-&gt;v.val_unsigned);</span>
<span class="lineNum">   30710 </span>            :           break;
<span class="lineNum">   30711 </span>            :         }
<span class="lineNum">   30712 </span>            :       /* FALLTHRU */
<span class="lineNum">   30713 </span><span class="lineCov">     111767 :     case DW_OP_const_type:</span>
<span class="lineNum">   30714 </span><span class="lineCov">     111767 :     case DW_OP_GNU_const_type:</span>
<span class="lineNum">   30715 </span><span class="lineCov">     111767 :       {</span>
<span class="lineNum">   30716 </span><span class="lineCov">     111767 :         unsigned int byte_size</span>
<span class="lineNum">   30717 </span><span class="lineCov">     111767 :           = get_AT_unsigned (val1-&gt;v.val_die_ref.die, DW_AT_byte_size);</span>
<span class="lineNum">   30718 </span><span class="lineCov">     111767 :         unsigned int encoding</span>
<span class="lineNum">   30719 </span><span class="lineCov">     111767 :           = get_AT_unsigned (val1-&gt;v.val_die_ref.die, DW_AT_encoding);</span>
<span class="lineNum">   30720 </span><span class="lineCov">     111767 :         hstate.add_object (byte_size);</span>
<span class="lineNum">   30721 </span><span class="lineCov">     111767 :         hstate.add_object (encoding);</span>
<span class="lineNum">   30722 </span><span class="lineCov">     111767 :         if (loc-&gt;dw_loc_opc != DW_OP_const_type</span>
<span class="lineNum">   30723 </span><span class="lineCov">     111767 :             &amp;&amp; loc-&gt;dw_loc_opc != DW_OP_GNU_const_type)</span>
<span class="lineNum">   30724 </span>            :           break;
<span class="lineNum">   30725 </span><span class="lineCov">      41663 :         hstate.add_object (val2-&gt;val_class);</span>
<span class="lineNum">   30726 </span><span class="lineCov">      41663 :         switch (val2-&gt;val_class)</span>
<span class="lineNum">   30727 </span>            :           {
<span class="lineNum">   30728 </span><span class="lineCov">       3785 :           case dw_val_class_const:</span>
<span class="lineNum">   30729 </span><span class="lineCov">       3785 :             hstate.add_object (val2-&gt;v.val_int);</span>
<span class="lineNum">   30730 </span>            :             break;
<span class="lineNum">   30731 </span><span class="lineCov">      37813 :           case dw_val_class_vec:</span>
<span class="lineNum">   30732 </span><span class="lineCov">      37813 :             {</span>
<span class="lineNum">   30733 </span><span class="lineCov">      37813 :               unsigned int elt_size = val2-&gt;v.val_vec.elt_size;</span>
<span class="lineNum">   30734 </span><span class="lineCov">      37813 :               unsigned int len = val2-&gt;v.val_vec.length;</span>
<span class="lineNum">   30735 </span>            : 
<span class="lineNum">   30736 </span><span class="lineCov">      37813 :               hstate.add_object (elt_size);</span>
<span class="lineNum">   30737 </span><span class="lineCov">      37813 :               hstate.add_object (len);</span>
<span class="lineNum">   30738 </span><span class="lineCov">      37813 :               hstate.add (val2-&gt;v.val_vec.array, len * elt_size);</span>
<span class="lineNum">   30739 </span>            :             }
<span class="lineNum">   30740 </span><span class="lineCov">      37813 :             break;</span>
<span class="lineNum">   30741 </span><span class="lineCov">          7 :           case dw_val_class_const_double:</span>
<span class="lineNum">   30742 </span><span class="lineCov">          7 :             hstate.add_object (val2-&gt;v.val_double.low);</span>
<span class="lineNum">   30743 </span><span class="lineCov">          7 :             hstate.add_object (val2-&gt;v.val_double.high);</span>
<span class="lineNum">   30744 </span>            :             break;
<span class="lineNum">   30745 </span><span class="lineCov">         58 :           case dw_val_class_wide_int:</span>
<span class="lineNum">   30746 </span><span class="lineCov">         58 :             hstate.add (val2-&gt;v.val_wide-&gt;get_val (),</span>
<span class="lineNum">   30747 </span><span class="lineCov">         58 :                         get_full_len (*val2-&gt;v.val_wide)</span>
<span class="lineNum">   30748 </span><span class="lineCov">         58 :                         * HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR);</span>
<span class="lineNum">   30749 </span>            :             break;
<span class="lineNum">   30750 </span><span class="lineNoCov">          0 :           default:</span>
<span class="lineNum">   30751 </span><span class="lineNoCov">          0 :             gcc_unreachable ();</span>
<span class="lineNum">   30752 </span><span class="lineCov">      70104 :           }</span>
<span class="lineNum">   30753 </span>            :       }
<span class="lineNum">   30754 </span><span class="lineCov">      41663 :       break;</span>
<span class="lineNum">   30755 </span>            : 
<span class="lineNum">   30756 </span>            :     default:
<span class="lineNum">   30757 </span>            :       /* Other codes have no operands.  */
<span class="lineNum">   30758 </span>            :       break;
<span class="lineNum">   30759 </span>            :     }
<span class="lineNum">   30760 </span><span class="lineCov">   29725788 : }</span>
<span class="lineNum">   30761 </span>            : 
<span class="lineNum">   30762 </span>            : /* Iteratively hash the whole DWARF location expression LOC into HSTATE.  */
<a name="30763"><span class="lineNum">   30763 </span>            : </a>
<span class="lineNum">   30764 </span>            : static inline void
<span class="lineNum">   30765 </span><span class="lineCov">   15069085 : hash_locs (dw_loc_descr_ref loc, inchash::hash &amp;hstate)</span>
<span class="lineNum">   30766 </span>            : {
<span class="lineNum">   30767 </span><span class="lineCov">   15069085 :   dw_loc_descr_ref l;</span>
<span class="lineNum">   30768 </span><span class="lineCov">   15069085 :   bool sizes_computed = false;</span>
<span class="lineNum">   30769 </span>            :   /* Compute sizes, so that DW_OP_skip/DW_OP_bra can be checksummed.  */
<span class="lineNum">   30770 </span><span class="lineCov">   15069085 :   size_of_locs (loc);</span>
<span class="lineNum">   30771 </span>            : 
<span class="lineNum">   30772 </span><span class="lineCov">   44794313 :   for (l = loc; l != NULL; l = l-&gt;dw_loc_next)</span>
<span class="lineNum">   30773 </span>            :     {
<span class="lineNum">   30774 </span><span class="lineCov">   29725228 :       enum dwarf_location_atom opc = l-&gt;dw_loc_opc;</span>
<span class="lineNum">   30775 </span><span class="lineCov">   29725228 :       hstate.add_object (opc);</span>
<span class="lineNum">   30776 </span><span class="lineCov">   29725228 :       if ((opc == DW_OP_skip || opc == DW_OP_bra) &amp;&amp; !sizes_computed)</span>
<span class="lineNum">   30777 </span>            :         {
<span class="lineNum">   30778 </span><span class="lineCov">      13537 :           size_of_locs (loc);</span>
<span class="lineNum">   30779 </span><span class="lineCov">      13537 :           sizes_computed = true;</span>
<span class="lineNum">   30780 </span>            :         }
<span class="lineNum">   30781 </span><span class="lineCov">   29725228 :       hash_loc_operands (l, hstate);</span>
<span class="lineNum">   30782 </span>            :     }
<span class="lineNum">   30783 </span><span class="lineCov">   15069085 : }</span>
<span class="lineNum">   30784 </span>            : 
<span class="lineNum">   30785 </span>            : /* Compute hash of the whole location list LIST_HEAD.  */
<a name="30786"><span class="lineNum">   30786 </span>            : </a>
<span class="lineNum">   30787 </span>            : static inline void
<span class="lineNum">   30788 </span><span class="lineCov">    5791298 : hash_loc_list (dw_loc_list_ref list_head)</span>
<span class="lineNum">   30789 </span>            : {
<span class="lineNum">   30790 </span><span class="lineCov">    5791298 :   dw_loc_list_ref curr = list_head;</span>
<span class="lineNum">   30791 </span><span class="lineCov">    5791298 :   inchash::hash hstate;</span>
<span class="lineNum">   30792 </span>            : 
<span class="lineNum">   30793 </span><span class="lineCov">   20860383 :   for (curr = list_head; curr != NULL; curr = curr-&gt;dw_loc_next)</span>
<span class="lineNum">   30794 </span>            :     {
<span class="lineNum">   30795 </span><span class="lineCov">   15069085 :       hstate.add (curr-&gt;begin, strlen (curr-&gt;begin) + 1);</span>
<span class="lineNum">   30796 </span><span class="lineCov">   15069085 :       hstate.add (curr-&gt;end, strlen (curr-&gt;end) + 1);</span>
<span class="lineNum">   30797 </span><span class="lineCov">   15069085 :       hstate.add_object (curr-&gt;vbegin);</span>
<span class="lineNum">   30798 </span><span class="lineCov">   15069085 :       hstate.add_object (curr-&gt;vend);</span>
<span class="lineNum">   30799 </span><span class="lineCov">   15069085 :       if (curr-&gt;section)</span>
<span class="lineNum">   30800 </span><span class="lineCov">   15069085 :         hstate.add (curr-&gt;section, strlen (curr-&gt;section) + 1);</span>
<span class="lineNum">   30801 </span><span class="lineCov">   15069085 :       hash_locs (curr-&gt;expr, hstate);</span>
<span class="lineNum">   30802 </span>            :     }
<span class="lineNum">   30803 </span><span class="lineCov">   11582596 :   list_head-&gt;hash = hstate.end ();</span>
<span class="lineNum">   30804 </span><span class="lineCov">    5791298 : }</span>
<span class="lineNum">   30805 </span>            : 
<span class="lineNum">   30806 </span>            : /* Return true if X and Y opcodes have the same operands.  */
<a name="30807"><span class="lineNum">   30807 </span>            : </a>
<span class="lineNum">   30808 </span>            : static inline bool
<span class="lineNum">   30809 </span><span class="lineCov">     631508 : compare_loc_operands (dw_loc_descr_ref x, dw_loc_descr_ref y)</span>
<span class="lineNum">   30810 </span>            : {
<span class="lineNum">   30811 </span><span class="lineCov">     631508 :   dw_val_ref valx1 = &amp;x-&gt;dw_loc_oprnd1;</span>
<span class="lineNum">   30812 </span><span class="lineCov">     631508 :   dw_val_ref valx2 = &amp;x-&gt;dw_loc_oprnd2;</span>
<span class="lineNum">   30813 </span><span class="lineCov">     631508 :   dw_val_ref valy1 = &amp;y-&gt;dw_loc_oprnd1;</span>
<span class="lineNum">   30814 </span><span class="lineCov">     631508 :   dw_val_ref valy2 = &amp;y-&gt;dw_loc_oprnd2;</span>
<span class="lineNum">   30815 </span>            : 
<span class="lineNum">   30816 </span><span class="lineCov">     631508 :   switch (x-&gt;dw_loc_opc)</span>
<span class="lineNum">   30817 </span>            :     {
<span class="lineNum">   30818 </span><span class="lineCov">         41 :     case DW_OP_const4u:</span>
<span class="lineNum">   30819 </span><span class="lineCov">         41 :     case DW_OP_const8u:</span>
<span class="lineNum">   30820 </span><span class="lineCov">         41 :       if (x-&gt;dtprel)</span>
<span class="lineNum">   30821 </span>            :         goto hash_addr;
<span class="lineNum">   30822 </span>            :       /* FALLTHRU */
<span class="lineNum">   30823 </span><span class="lineCov">     187901 :     case DW_OP_const1u:</span>
<span class="lineNum">   30824 </span><span class="lineCov">     187901 :     case DW_OP_const1s:</span>
<span class="lineNum">   30825 </span><span class="lineCov">     187901 :     case DW_OP_const2u:</span>
<span class="lineNum">   30826 </span><span class="lineCov">     187901 :     case DW_OP_const2s:</span>
<span class="lineNum">   30827 </span><span class="lineCov">     187901 :     case DW_OP_const4s:</span>
<span class="lineNum">   30828 </span><span class="lineCov">     187901 :     case DW_OP_const8s:</span>
<span class="lineNum">   30829 </span><span class="lineCov">     187901 :     case DW_OP_constu:</span>
<span class="lineNum">   30830 </span><span class="lineCov">     187901 :     case DW_OP_consts:</span>
<span class="lineNum">   30831 </span><span class="lineCov">     187901 :     case DW_OP_pick:</span>
<span class="lineNum">   30832 </span><span class="lineCov">     187901 :     case DW_OP_plus_uconst:</span>
<span class="lineNum">   30833 </span><span class="lineCov">     187901 :     case DW_OP_breg0:</span>
<span class="lineNum">   30834 </span><span class="lineCov">     187901 :     case DW_OP_breg1:</span>
<span class="lineNum">   30835 </span><span class="lineCov">     187901 :     case DW_OP_breg2:</span>
<span class="lineNum">   30836 </span><span class="lineCov">     187901 :     case DW_OP_breg3:</span>
<span class="lineNum">   30837 </span><span class="lineCov">     187901 :     case DW_OP_breg4:</span>
<span class="lineNum">   30838 </span><span class="lineCov">     187901 :     case DW_OP_breg5:</span>
<span class="lineNum">   30839 </span><span class="lineCov">     187901 :     case DW_OP_breg6:</span>
<span class="lineNum">   30840 </span><span class="lineCov">     187901 :     case DW_OP_breg7:</span>
<span class="lineNum">   30841 </span><span class="lineCov">     187901 :     case DW_OP_breg8:</span>
<span class="lineNum">   30842 </span><span class="lineCov">     187901 :     case DW_OP_breg9:</span>
<span class="lineNum">   30843 </span><span class="lineCov">     187901 :     case DW_OP_breg10:</span>
<span class="lineNum">   30844 </span><span class="lineCov">     187901 :     case DW_OP_breg11:</span>
<span class="lineNum">   30845 </span><span class="lineCov">     187901 :     case DW_OP_breg12:</span>
<span class="lineNum">   30846 </span><span class="lineCov">     187901 :     case DW_OP_breg13:</span>
<span class="lineNum">   30847 </span><span class="lineCov">     187901 :     case DW_OP_breg14:</span>
<span class="lineNum">   30848 </span><span class="lineCov">     187901 :     case DW_OP_breg15:</span>
<span class="lineNum">   30849 </span><span class="lineCov">     187901 :     case DW_OP_breg16:</span>
<span class="lineNum">   30850 </span><span class="lineCov">     187901 :     case DW_OP_breg17:</span>
<span class="lineNum">   30851 </span><span class="lineCov">     187901 :     case DW_OP_breg18:</span>
<span class="lineNum">   30852 </span><span class="lineCov">     187901 :     case DW_OP_breg19:</span>
<span class="lineNum">   30853 </span><span class="lineCov">     187901 :     case DW_OP_breg20:</span>
<span class="lineNum">   30854 </span><span class="lineCov">     187901 :     case DW_OP_breg21:</span>
<span class="lineNum">   30855 </span><span class="lineCov">     187901 :     case DW_OP_breg22:</span>
<span class="lineNum">   30856 </span><span class="lineCov">     187901 :     case DW_OP_breg23:</span>
<span class="lineNum">   30857 </span><span class="lineCov">     187901 :     case DW_OP_breg24:</span>
<span class="lineNum">   30858 </span><span class="lineCov">     187901 :     case DW_OP_breg25:</span>
<span class="lineNum">   30859 </span><span class="lineCov">     187901 :     case DW_OP_breg26:</span>
<span class="lineNum">   30860 </span><span class="lineCov">     187901 :     case DW_OP_breg27:</span>
<span class="lineNum">   30861 </span><span class="lineCov">     187901 :     case DW_OP_breg28:</span>
<span class="lineNum">   30862 </span><span class="lineCov">     187901 :     case DW_OP_breg29:</span>
<span class="lineNum">   30863 </span><span class="lineCov">     187901 :     case DW_OP_breg30:</span>
<span class="lineNum">   30864 </span><span class="lineCov">     187901 :     case DW_OP_breg31:</span>
<span class="lineNum">   30865 </span><span class="lineCov">     187901 :     case DW_OP_regx:</span>
<span class="lineNum">   30866 </span><span class="lineCov">     187901 :     case DW_OP_fbreg:</span>
<span class="lineNum">   30867 </span><span class="lineCov">     187901 :     case DW_OP_piece:</span>
<span class="lineNum">   30868 </span><span class="lineCov">     187901 :     case DW_OP_deref_size:</span>
<span class="lineNum">   30869 </span><span class="lineCov">     187901 :     case DW_OP_xderef_size:</span>
<span class="lineNum">   30870 </span><span class="lineCov">     187901 :       return valx1-&gt;v.val_int == valy1-&gt;v.val_int;</span>
<span class="lineNum">   30871 </span><span class="lineCov">        127 :     case DW_OP_skip:</span>
<span class="lineNum">   30872 </span><span class="lineCov">        127 :     case DW_OP_bra:</span>
<span class="lineNum">   30873 </span>            :       /* If splitting debug info, the use of DW_OP_GNU_addr_index
<span class="lineNum">   30874 </span>            :         can cause irrelevant differences in dw_loc_addr.  */
<span class="lineNum">   30875 </span><span class="lineCov">        127 :       gcc_assert (valx1-&gt;val_class == dw_val_class_loc</span>
<span class="lineNum">   30876 </span>            :                   &amp;&amp; valy1-&gt;val_class == dw_val_class_loc
<span class="lineNum">   30877 </span>            :                   &amp;&amp; (dwarf_split_debug_info
<span class="lineNum">   30878 </span>            :                       || x-&gt;dw_loc_addr == y-&gt;dw_loc_addr));
<span class="lineNum">   30879 </span><span class="lineCov">        127 :       return valx1-&gt;v.val_loc-&gt;dw_loc_addr == valy1-&gt;v.val_loc-&gt;dw_loc_addr;</span>
<span class="lineNum">   30880 </span><span class="lineCov">        716 :     case DW_OP_implicit_value:</span>
<span class="lineNum">   30881 </span><span class="lineCov">        716 :       if (valx1-&gt;v.val_unsigned != valy1-&gt;v.val_unsigned</span>
<span class="lineNum">   30882 </span><span class="lineCov">        716 :           || valx2-&gt;val_class != valy2-&gt;val_class)</span>
<span class="lineNum">   30883 </span>            :         return false;
<span class="lineNum">   30884 </span><span class="lineCov">        716 :       switch (valx2-&gt;val_class)</span>
<span class="lineNum">   30885 </span>            :         {
<span class="lineNum">   30886 </span><span class="lineCov">         76 :         case dw_val_class_const:</span>
<span class="lineNum">   30887 </span><span class="lineCov">         76 :           return valx2-&gt;v.val_int == valy2-&gt;v.val_int;</span>
<span class="lineNum">   30888 </span><span class="lineCov">        640 :         case dw_val_class_vec:</span>
<span class="lineNum">   30889 </span><span class="lineCov">        640 :           return valx2-&gt;v.val_vec.elt_size == valy2-&gt;v.val_vec.elt_size</span>
<span class="lineNum">   30890 </span><span class="lineCov">        640 :                  &amp;&amp; valx2-&gt;v.val_vec.length == valy2-&gt;v.val_vec.length</span>
<span class="lineNum">   30891 </span><span class="lineCov">        640 :                  &amp;&amp; memcmp (valx2-&gt;v.val_vec.array, valy2-&gt;v.val_vec.array,</span>
<span class="lineNum">   30892 </span><span class="lineCov">        640 :                             valx2-&gt;v.val_vec.elt_size</span>
<span class="lineNum">   30893 </span><span class="lineCov">        640 :                             * valx2-&gt;v.val_vec.length) == 0;</span>
<span class="lineNum">   30894 </span><span class="lineNoCov">          0 :         case dw_val_class_const_double:</span>
<span class="lineNum">   30895 </span><span class="lineNoCov">          0 :           return valx2-&gt;v.val_double.low == valy2-&gt;v.val_double.low</span>
<span class="lineNum">   30896 </span><span class="lineNoCov">          0 :                  &amp;&amp; valx2-&gt;v.val_double.high == valy2-&gt;v.val_double.high;</span>
<span class="lineNum">   30897 </span><span class="lineNoCov">          0 :         case dw_val_class_wide_int:</span>
<span class="lineNum">   30898 </span><span class="lineNoCov">          0 :           return *valx2-&gt;v.val_wide == *valy2-&gt;v.val_wide;</span>
<span class="lineNum">   30899 </span><span class="lineNoCov">          0 :         case dw_val_class_addr:</span>
<span class="lineNum">   30900 </span><span class="lineNoCov">          0 :           return rtx_equal_p (valx2-&gt;v.val_addr, valy2-&gt;v.val_addr);</span>
<span class="lineNum">   30901 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">   30902 </span><span class="lineNoCov">          0 :           gcc_unreachable ();</span>
<span class="lineNum">   30903 </span>            :         }
<span class="lineNum">   30904 </span><span class="lineNoCov">          0 :     case DW_OP_bregx:</span>
<span class="lineNum">   30905 </span><span class="lineNoCov">          0 :     case DW_OP_bit_piece:</span>
<span class="lineNum">   30906 </span><span class="lineNoCov">          0 :       return valx1-&gt;v.val_int == valy1-&gt;v.val_int</span>
<span class="lineNum">   30907 </span><span class="lineNoCov">          0 :              &amp;&amp; valx2-&gt;v.val_int == valy2-&gt;v.val_int;</span>
<span class="lineNum">   30908 </span><span class="lineCov">      14298 :     case DW_OP_addr:</span>
<span class="lineNum">   30909 </span><span class="lineCov">      28596 :     hash_addr:</span>
<span class="lineNum">   30910 </span><span class="lineCov">      14298 :       return rtx_equal_p (valx1-&gt;v.val_addr, valy1-&gt;v.val_addr);</span>
<span class="lineNum">   30911 </span><span class="lineNoCov">          0 :     case DW_OP_GNU_addr_index:</span>
<span class="lineNum">   30912 </span><span class="lineNoCov">          0 :     case DW_OP_addrx:</span>
<span class="lineNum">   30913 </span><span class="lineNoCov">          0 :     case DW_OP_GNU_const_index:</span>
<span class="lineNum">   30914 </span><span class="lineNoCov">          0 :     case DW_OP_constx:</span>
<span class="lineNum">   30915 </span><span class="lineNoCov">          0 :       {</span>
<span class="lineNum">   30916 </span><span class="lineNoCov">          0 :         rtx ax1 = valx1-&gt;val_entry-&gt;addr.rtl;</span>
<span class="lineNum">   30917 </span><span class="lineNoCov">          0 :         rtx ay1 = valy1-&gt;val_entry-&gt;addr.rtl;</span>
<span class="lineNum">   30918 </span><span class="lineNoCov">          0 :         return rtx_equal_p (ax1, ay1);</span>
<span class="lineNum">   30919 </span>            :       }
<span class="lineNum">   30920 </span><span class="lineCov">      98513 :     case DW_OP_implicit_pointer:</span>
<span class="lineNum">   30921 </span><span class="lineCov">      98513 :     case DW_OP_GNU_implicit_pointer:</span>
<span class="lineNum">   30922 </span><span class="lineCov">      98513 :       return valx1-&gt;val_class == dw_val_class_die_ref</span>
<span class="lineNum">   30923 </span><span class="lineCov">      98513 :              &amp;&amp; valx1-&gt;val_class == valy1-&gt;val_class</span>
<span class="lineNum">   30924 </span><span class="lineCov">      98513 :              &amp;&amp; valx1-&gt;v.val_die_ref.die == valy1-&gt;v.val_die_ref.die</span>
<span class="lineNum">   30925 </span><span class="lineCov">     184078 :              &amp;&amp; valx2-&gt;v.val_int == valy2-&gt;v.val_int;</span>
<span class="lineNum">   30926 </span><span class="lineNoCov">          0 :     case DW_OP_entry_value:</span>
<span class="lineNum">   30927 </span><span class="lineNoCov">          0 :     case DW_OP_GNU_entry_value:</span>
<span class="lineNum">   30928 </span><span class="lineNoCov">          0 :       return compare_loc_operands (valx1-&gt;v.val_loc, valy1-&gt;v.val_loc);</span>
<span class="lineNum">   30929 </span><span class="lineCov">         33 :     case DW_OP_const_type:</span>
<span class="lineNum">   30930 </span><span class="lineCov">         33 :     case DW_OP_GNU_const_type:</span>
<span class="lineNum">   30931 </span><span class="lineCov">         33 :       if (valx1-&gt;v.val_die_ref.die != valy1-&gt;v.val_die_ref.die</span>
<span class="lineNum">   30932 </span><span class="lineCov">         33 :           || valx2-&gt;val_class != valy2-&gt;val_class)</span>
<span class="lineNum">   30933 </span>            :         return false;
<span class="lineNum">   30934 </span><span class="lineCov">         33 :       switch (valx2-&gt;val_class)</span>
<span class="lineNum">   30935 </span>            :         {
<span class="lineNum">   30936 </span><span class="lineCov">          7 :         case dw_val_class_const:</span>
<span class="lineNum">   30937 </span><span class="lineCov">          7 :           return valx2-&gt;v.val_int == valy2-&gt;v.val_int;</span>
<span class="lineNum">   30938 </span><span class="lineCov">         26 :         case dw_val_class_vec:</span>
<span class="lineNum">   30939 </span><span class="lineCov">         26 :           return valx2-&gt;v.val_vec.elt_size == valy2-&gt;v.val_vec.elt_size</span>
<span class="lineNum">   30940 </span><span class="lineCov">         26 :                  &amp;&amp; valx2-&gt;v.val_vec.length == valy2-&gt;v.val_vec.length</span>
<span class="lineNum">   30941 </span><span class="lineCov">         26 :                  &amp;&amp; memcmp (valx2-&gt;v.val_vec.array, valy2-&gt;v.val_vec.array,</span>
<span class="lineNum">   30942 </span><span class="lineCov">         26 :                             valx2-&gt;v.val_vec.elt_size</span>
<span class="lineNum">   30943 </span><span class="lineCov">         26 :                             * valx2-&gt;v.val_vec.length) == 0;</span>
<span class="lineNum">   30944 </span><span class="lineNoCov">          0 :         case dw_val_class_const_double:</span>
<span class="lineNum">   30945 </span><span class="lineNoCov">          0 :           return valx2-&gt;v.val_double.low == valy2-&gt;v.val_double.low</span>
<span class="lineNum">   30946 </span><span class="lineNoCov">          0 :                  &amp;&amp; valx2-&gt;v.val_double.high == valy2-&gt;v.val_double.high;</span>
<span class="lineNum">   30947 </span><span class="lineNoCov">          0 :         case dw_val_class_wide_int:</span>
<span class="lineNum">   30948 </span><span class="lineNoCov">          0 :           return *valx2-&gt;v.val_wide == *valy2-&gt;v.val_wide;</span>
<span class="lineNum">   30949 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">   30950 </span><span class="lineNoCov">          0 :           gcc_unreachable ();</span>
<span class="lineNum">   30951 </span>            :         }
<span class="lineNum">   30952 </span><span class="lineCov">        281 :     case DW_OP_regval_type:</span>
<span class="lineNum">   30953 </span><span class="lineCov">        281 :     case DW_OP_deref_type:</span>
<span class="lineNum">   30954 </span><span class="lineCov">        281 :     case DW_OP_GNU_regval_type:</span>
<span class="lineNum">   30955 </span><span class="lineCov">        281 :     case DW_OP_GNU_deref_type:</span>
<span class="lineNum">   30956 </span><span class="lineCov">        281 :       return valx1-&gt;v.val_int == valy1-&gt;v.val_int</span>
<span class="lineNum">   30957 </span><span class="lineCov">        281 :              &amp;&amp; valx2-&gt;v.val_die_ref.die == valy2-&gt;v.val_die_ref.die;</span>
<span class="lineNum">   30958 </span><span class="lineCov">        125 :     case DW_OP_convert:</span>
<span class="lineNum">   30959 </span><span class="lineCov">        125 :     case DW_OP_reinterpret:</span>
<span class="lineNum">   30960 </span><span class="lineCov">        125 :     case DW_OP_GNU_convert:</span>
<span class="lineNum">   30961 </span><span class="lineCov">        125 :     case DW_OP_GNU_reinterpret:</span>
<span class="lineNum">   30962 </span><span class="lineCov">        125 :       if (valx1-&gt;val_class != valy1-&gt;val_class)</span>
<span class="lineNum">   30963 </span>            :         return false;
<span class="lineNum">   30964 </span><span class="lineCov">        125 :       if (valx1-&gt;val_class == dw_val_class_unsigned_const)</span>
<span class="lineNum">   30965 </span><span class="lineCov">          2 :         return valx1-&gt;v.val_unsigned == valy1-&gt;v.val_unsigned;</span>
<span class="lineNum">   30966 </span><span class="lineCov">        123 :       return valx1-&gt;v.val_die_ref.die == valy1-&gt;v.val_die_ref.die;</span>
<span class="lineNum">   30967 </span><span class="lineCov">        484 :     case DW_OP_GNU_parameter_ref:</span>
<span class="lineNum">   30968 </span><span class="lineCov">        484 :       return valx1-&gt;val_class == dw_val_class_die_ref</span>
<span class="lineNum">   30969 </span><span class="lineCov">        484 :              &amp;&amp; valx1-&gt;val_class == valy1-&gt;val_class</span>
<span class="lineNum">   30970 </span><span class="lineCov">        968 :              &amp;&amp; valx1-&gt;v.val_die_ref.die == valy1-&gt;v.val_die_ref.die;</span>
<span class="lineNum">   30971 </span>            :     default:
<span class="lineNum">   30972 </span>            :       /* Other codes have no operands.  */
<span class="lineNum">   30973 </span>            :       return true;
<span class="lineNum">   30974 </span>            :     }
<span class="lineNum">   30975 </span>            : }
<span class="lineNum">   30976 </span>            : 
<span class="lineNum">   30977 </span>            : /* Return true if DWARF location expressions X and Y are the same.  */
<a name="30978"><span class="lineNum">   30978 </span>            : </a>
<span class="lineNum">   30979 </span>            : static inline bool
<span class="lineNum">   30980 </span><span class="lineCov">     400689 : compare_locs (dw_loc_descr_ref x, dw_loc_descr_ref y)</span>
<span class="lineNum">   30981 </span>            : {
<span class="lineNum">   30982 </span><span class="lineCov">    1018767 :   for (; x != NULL &amp;&amp; y != NULL; x = x-&gt;dw_loc_next, y = y-&gt;dw_loc_next)</span>
<span class="lineNum">   30983 </span><span class="lineCov">     631508 :     if (x-&gt;dw_loc_opc != y-&gt;dw_loc_opc</span>
<span class="lineNum">   30984 </span><span class="lineCov">     631508 :         || x-&gt;dtprel != y-&gt;dtprel</span>
<span class="lineNum">   30985 </span><span class="lineCov">    1263016 :         || !compare_loc_operands (x, y))</span>
<span class="lineNum">   30986 </span>            :       break;
<span class="lineNum">   30987 </span><span class="lineCov">     400689 :   return x == NULL &amp;&amp; y == NULL;</span>
<span class="lineNum">   30988 </span>            : }
<span class="lineNum">   30989 </span>            : 
<span class="lineNum">   30990 </span>            : /* Hashtable helpers.  */
<span class="lineNum">   30991 </span>            : 
<span class="lineNum">   30992 </span>            : struct loc_list_hasher : nofree_ptr_hash &lt;dw_loc_list_struct&gt;
<span class="lineNum">   30993 </span>            : {
<span class="lineNum">   30994 </span>            :   static inline hashval_t hash (const dw_loc_list_struct *);
<span class="lineNum">   30995 </span>            :   static inline bool equal (const dw_loc_list_struct *,
<span class="lineNum">   30996 </span>            :                             const dw_loc_list_struct *);
<span class="lineNum">   30997 </span>            : };
<span class="lineNum">   30998 </span>            : 
<span class="lineNum">   30999 </span>            : /* Return precomputed hash of location list X.  */
<a name="31000"><span class="lineNum">   31000 </span>            : </a>
<span class="lineNum">   31001 </span>            : inline hashval_t
<span class="lineNum">   31002 </span><span class="lineNoCov">          0 : loc_list_hasher::hash (const dw_loc_list_struct *x)</span>
<span class="lineNum">   31003 </span>            : {
<span class="lineNum">   31004 </span><span class="lineCov">    6284416 :   return x-&gt;hash;</span>
<span class="lineNum">   31005 </span>            : }
<span class="lineNum">   31006 </span>            : 
<span class="lineNum">   31007 </span>            : /* Return true if location lists A and B are the same.  */
<a name="31008"><span class="lineNum">   31008 </span>            : </a>
<span class="lineNum">   31009 </span>            : inline bool
<span class="lineNum">   31010 </span><span class="lineCov">    6532647 : loc_list_hasher::equal (const dw_loc_list_struct *a,</span>
<span class="lineNum">   31011 </span>            :                         const dw_loc_list_struct *b)
<span class="lineNum">   31012 </span>            : {
<span class="lineNum">   31013 </span><span class="lineCov">    6532647 :   if (a == b)</span>
<span class="lineNum">   31014 </span>            :     return 1;
<span class="lineNum">   31015 </span><span class="lineCov">    6532334 :   if (a-&gt;hash != b-&gt;hash)</span>
<span class="lineNum">   31016 </span>            :     return 0;
<span class="lineNum">   31017 </span><span class="lineCov">     503165 :   for (; a != NULL &amp;&amp; b != NULL; a = a-&gt;dw_loc_next, b = b-&gt;dw_loc_next)</span>
<span class="lineNum">   31018 </span><span class="lineCov">     400694 :     if (strcmp (a-&gt;begin, b-&gt;begin) != 0</span>
<span class="lineNum">   31019 </span><span class="lineCov">     400689 :         || strcmp (a-&gt;end, b-&gt;end) != 0</span>
<span class="lineNum">   31020 </span><span class="lineCov">     400689 :         || (a-&gt;section == NULL) != (b-&gt;section == NULL)</span>
<span class="lineNum">   31021 </span><span class="lineCov">     400689 :         || (a-&gt;section &amp;&amp; strcmp (a-&gt;section, b-&gt;section) != 0)</span>
<span class="lineNum">   31022 </span><span class="lineCov">     400689 :         || a-&gt;vbegin != b-&gt;vbegin || a-&gt;vend != b-&gt;vend</span>
<span class="lineNum">   31023 </span><span class="lineCov">     801383 :         || !compare_locs (a-&gt;expr, b-&gt;expr))</span>
<span class="lineNum">   31024 </span>            :       break;
<span class="lineNum">   31025 </span><span class="lineCov">     115906 :   return a == NULL &amp;&amp; b == NULL;</span>
<span class="lineNum">   31026 </span>            : }
<span class="lineNum">   31027 </span>            : 
<span class="lineNum">   31028 </span>            : typedef hash_table&lt;loc_list_hasher&gt; loc_list_hash_type;
<span class="lineNum">   31029 </span>            : 
<span class="lineNum">   31030 </span>            : 
<span class="lineNum">   31031 </span>            : /* Recursively optimize location lists referenced from DIE
<span class="lineNum">   31032 </span>            :    children and share them whenever possible.  */
<a name="31033"><span class="lineNum">   31033 </span>            : </a>
<span class="lineNum">   31034 </span>            : static void
<span class="lineNum">   31035 </span><span class="lineCov">   41796677 : optimize_location_lists_1 (dw_die_ref die, loc_list_hash_type *htab)</span>
<span class="lineNum">   31036 </span>            : {
<span class="lineNum">   31037 </span><span class="lineCov">   41796677 :   dw_die_ref c;</span>
<span class="lineNum">   31038 </span><span class="lineCov">   41796677 :   dw_attr_node *a;</span>
<span class="lineNum">   31039 </span><span class="lineCov">   41796677 :   unsigned ix;</span>
<span class="lineNum">   31040 </span><span class="lineCov">   41796677 :   dw_loc_list_struct **slot;</span>
<span class="lineNum">   31041 </span><span class="lineCov">   41796677 :   bool drop_locviews = false;</span>
<span class="lineNum">   31042 </span><span class="lineCov">   41796677 :   bool has_locviews = false;</span>
<span class="lineNum">   31043 </span>            : 
<span class="lineNum">   31044 </span><span class="lineCov">  209124931 :   FOR_EACH_VEC_SAFE_ELT (die-&gt;die_attr, ix, a)</span>
<span class="lineNum">   31045 </span><span class="lineCov">  167328254 :     if (AT_class (a) == dw_val_class_loc_list)</span>
<span class="lineNum">   31046 </span>            :       {
<span class="lineNum">   31047 </span><span class="lineCov">   11582596 :         dw_loc_list_ref list = AT_loc_list (a);</span>
<span class="lineNum">   31048 </span>            :         /* TODO: perform some optimizations here, before hashing
<span class="lineNum">   31049 </span>            :            it and storing into the hash table.  */
<span class="lineNum">   31050 </span><span class="lineCov">    5791298 :         hash_loc_list (list);</span>
<span class="lineNum">   31051 </span><span class="lineCov">    5791298 :         slot = htab-&gt;find_slot_with_hash (list, list-&gt;hash, INSERT);</span>
<span class="lineNum">   31052 </span><span class="lineCov">    5791298 :         if (*slot == NULL)</span>
<span class="lineNum">   31053 </span>            :           {
<span class="lineNum">   31054 </span><span class="lineCov">    5688514 :             *slot = list;</span>
<span class="lineNum">   31055 </span><span class="lineCov">    5688514 :             if (loc_list_has_views (list))</span>
<span class="lineNum">   31056 </span><span class="lineCov">    5604029 :               gcc_assert (list-&gt;vl_symbol);</span>
<span class="lineNum">   31057 </span><span class="lineCov">      84485 :             else if (list-&gt;vl_symbol)</span>
<span class="lineNum">   31058 </span>            :               {
<span class="lineNum">   31059 </span><span class="lineNoCov">          0 :                 drop_locviews = true;</span>
<span class="lineNum">   31060 </span><span class="lineNoCov">          0 :                 list-&gt;vl_symbol = NULL;</span>
<span class="lineNum">   31061 </span>            :               }
<span class="lineNum">   31062 </span>            :           }
<span class="lineNum">   31063 </span>            :         else
<span class="lineNum">   31064 </span>            :           {
<span class="lineNum">   31065 </span><span class="lineCov">     102784 :             if (list-&gt;vl_symbol &amp;&amp; !(*slot)-&gt;vl_symbol)</span>
<span class="lineNum">   31066 </span><span class="lineNoCov">          0 :               drop_locviews = true;</span>
<span class="lineNum">   31067 </span><span class="lineCov">     102784 :             a-&gt;dw_attr_val.v.val_loc_list = *slot;</span>
<span class="lineNum">   31068 </span>            :           }
<span class="lineNum">   31069 </span>            :       }
<span class="lineNum">   31070 </span><span class="lineCov">  161536956 :     else if (AT_class (a) == dw_val_class_view_list)</span>
<span class="lineNum">   31071 </span>            :       {
<span class="lineNum">   31072 </span><span class="lineCov">    5705885 :         gcc_checking_assert (a-&gt;dw_attr == DW_AT_GNU_locviews);</span>
<span class="lineNum">   31073 </span>            :         has_locviews = true;
<span class="lineNum">   31074 </span>            :       }
<span class="lineNum">   31075 </span>            : 
<span class="lineNum">   31076 </span>            : 
<span class="lineNum">   31077 </span><span class="lineCov">   41796677 :   if (drop_locviews &amp;&amp; has_locviews)</span>
<span class="lineNum">   31078 </span><span class="lineNoCov">          0 :     remove_AT (die, DW_AT_GNU_locviews);</span>
<span class="lineNum">   31079 </span>            : 
<span class="lineNum">   31080 </span><span class="lineCov">   83570641 :   FOR_EACH_CHILD (die, c, optimize_location_lists_1 (c, htab));</span>
<span class="lineNum">   31081 </span><span class="lineCov">   41796677 : }</span>
<span class="lineNum">   31082 </span>            : 
<span class="lineNum">   31083 </span>            : 
<span class="lineNum">   31084 </span>            : /* Recursively assign each location list a unique index into the debug_addr
<span class="lineNum">   31085 </span>            :    section.  */
<a name="31086"><span class="lineNum">   31086 </span>            : </a>
<span class="lineNum">   31087 </span>            : static void
<span class="lineNum">   31088 </span><span class="lineCov">         52 : index_location_lists (dw_die_ref die)</span>
<span class="lineNum">   31089 </span>            : {
<span class="lineNum">   31090 </span><span class="lineCov">         52 :   dw_die_ref c;</span>
<span class="lineNum">   31091 </span><span class="lineCov">         52 :   dw_attr_node *a;</span>
<span class="lineNum">   31092 </span><span class="lineCov">         52 :   unsigned ix;</span>
<span class="lineNum">   31093 </span>            : 
<span class="lineNum">   31094 </span><span class="lineCov">        276 :   FOR_EACH_VEC_SAFE_ELT (die-&gt;die_attr, ix, a)</span>
<span class="lineNum">   31095 </span><span class="lineCov">        224 :     if (AT_class (a) == dw_val_class_loc_list)</span>
<span class="lineNum">   31096 </span>            :       {
<span class="lineNum">   31097 </span><span class="lineCov">          6 :         dw_loc_list_ref list = AT_loc_list (a);</span>
<span class="lineNum">   31098 </span><span class="lineCov">          3 :         dw_loc_list_ref curr;</span>
<span class="lineNum">   31099 </span><span class="lineCov">          8 :         for (curr = list; curr != NULL; curr = curr-&gt;dw_loc_next)</span>
<span class="lineNum">   31100 </span>            :           {
<span class="lineNum">   31101 </span>            :             /* Don't index an entry that has already been indexed
<span class="lineNum">   31102 </span>            :                or won't be output.  Make sure skip_loc_list_entry doesn't
<span class="lineNum">   31103 </span>            :                call size_of_locs, because that might cause circular dependency,
<span class="lineNum">   31104 </span>            :                index_location_lists requiring address table indexes to be
<span class="lineNum">   31105 </span>            :                computed, but adding new indexes through add_addr_table_entry
<span class="lineNum">   31106 </span>            :                and address table index computation requiring no new additions
<span class="lineNum">   31107 </span>            :                to the hash table.  In the rare case of DWARF[234] &gt;= 64KB
<span class="lineNum">   31108 </span>            :                location expression, we'll just waste unused address table entry
<span class="lineNum">   31109 </span>            :                for it.  */
<span class="lineNum">   31110 </span><span class="lineCov">          5 :             if (curr-&gt;begin_entry != NULL</span>
<span class="lineNum">   31111 </span><span class="lineCov">          5 :                 || skip_loc_list_entry (curr))</span>
<span class="lineNum">   31112 </span><span class="lineNoCov">          0 :               continue;</span>
<span class="lineNum">   31113 </span>            : 
<span class="lineNum">   31114 </span><span class="lineCov">          5 :             curr-&gt;begin_entry</span>
<span class="lineNum">   31115 </span><span class="lineCov">          5 :               = add_addr_table_entry (xstrdup (curr-&gt;begin), ate_kind_label);</span>
<span class="lineNum">   31116 </span>            :           }
<span class="lineNum">   31117 </span>            :       }
<span class="lineNum">   31118 </span>            : 
<span class="lineNum">   31119 </span><span class="lineCov">         87 :   FOR_EACH_CHILD (die, c, index_location_lists (c));</span>
<span class="lineNum">   31120 </span><span class="lineCov">         52 : }</span>
<span class="lineNum">   31121 </span>            : 
<span class="lineNum">   31122 </span>            : /* Optimize location lists referenced from DIE
<span class="lineNum">   31123 </span>            :    children and share them whenever possible.  */
<a name="31124"><span class="lineNum">   31124 </span>            : </a>
<span class="lineNum">   31125 </span>            : static void
<span class="lineNum">   31126 </span><span class="lineCov">      22713 : optimize_location_lists (dw_die_ref die)</span>
<span class="lineNum">   31127 </span>            : {
<span class="lineNum">   31128 </span><span class="lineCov">      45426 :   loc_list_hash_type htab (500);</span>
<span class="lineNum">   31129 </span><span class="lineCov">      22713 :   optimize_location_lists_1 (die, &amp;htab);</span>
<span class="lineNum">   31130 </span><span class="lineCov">      22713 : }</span>
<span class="lineNum">   31131 </span>            : 
<span class="lineNum">   31132 </span>            : /* Traverse the limbo die list, and add parent/child links.  The only
<span class="lineNum">   31133 </span>            :    dies without parents that should be here are concrete instances of
<span class="lineNum">   31134 </span>            :    inline functions, and the comp_unit_die.  We can ignore the comp_unit_die.
<span class="lineNum">   31135 </span>            :    For concrete instances, we can get the parent die from the abstract
<span class="lineNum">   31136 </span>            :    instance.  */
<a name="31137"><span class="lineNum">   31137 </span>            : </a>
<span class="lineNum">   31138 </span>            : static void
<span class="lineNum">   31139 </span><span class="lineCov">      67291 : flush_limbo_die_list (void)</span>
<span class="lineNum">   31140 </span>            : {
<span class="lineNum">   31141 </span><span class="lineCov">     106861 :   limbo_die_node *node;</span>
<span class="lineNum">   31142 </span>            : 
<span class="lineNum">   31143 </span>            :   /* get_context_die calls force_decl_die, which can put new DIEs on the
<span class="lineNum">   31144 </span>            :      limbo list in LTO mode when nested functions are put in a different
<span class="lineNum">   31145 </span>            :      partition than that of their parent function.  */
<span class="lineNum">   31146 </span><span class="lineCov">     106861 :   while ((node = limbo_die_list))</span>
<span class="lineNum">   31147 </span>            :     {
<span class="lineNum">   31148 </span><span class="lineCov">      39570 :       dw_die_ref die = node-&gt;die;</span>
<span class="lineNum">   31149 </span><span class="lineCov">      39570 :       limbo_die_list = node-&gt;next;</span>
<span class="lineNum">   31150 </span>            : 
<span class="lineNum">   31151 </span><span class="lineCov">      39570 :       if (die-&gt;die_parent == NULL)</span>
<span class="lineNum">   31152 </span>            :         {
<span class="lineNum">   31153 </span><span class="lineCov">      36517 :           dw_die_ref origin = get_AT_ref (die, DW_AT_abstract_origin);</span>
<span class="lineNum">   31154 </span>            : 
<span class="lineNum">   31155 </span><span class="lineCov">      36517 :           if (origin &amp;&amp; origin-&gt;die_parent)</span>
<span class="lineNum">   31156 </span><span class="lineCov">        305 :             add_child_die (origin-&gt;die_parent, die);</span>
<span class="lineNum">   31157 </span><span class="lineCov">      36212 :           else if (is_cu_die (die))</span>
<span class="lineNum">   31158 </span>            :             ;
<span class="lineNum">   31159 </span><span class="lineCov">       2080 :           else if (seen_error ())</span>
<span class="lineNum">   31160 </span>            :             /* It's OK to be confused by errors in the input.  */
<span class="lineNum">   31161 </span><span class="lineNoCov">          0 :             add_child_die (comp_unit_die (), die);</span>
<span class="lineNum">   31162 </span>            :           else
<span class="lineNum">   31163 </span>            :             {
<span class="lineNum">   31164 </span>            :               /* In certain situations, the lexical block containing a
<span class="lineNum">   31165 </span>            :                  nested function can be optimized away, which results
<span class="lineNum">   31166 </span>            :                  in the nested function die being orphaned.  Likewise
<span class="lineNum">   31167 </span>            :                  with the return type of that nested function.  Force
<span class="lineNum">   31168 </span>            :                  this to be a child of the containing function.
<span class="lineNum">   31169 </span>            : 
<span class="lineNum">   31170 </span>            :                  It may happen that even the containing function got fully
<span class="lineNum">   31171 </span>            :                  inlined and optimized out.  In that case we are lost and
<span class="lineNum">   31172 </span>            :                  assign the empty child.  This should not be big issue as
<span class="lineNum">   31173 </span>            :                  the function is likely unreachable too.  */
<span class="lineNum">   31174 </span><span class="lineCov">       2080 :               gcc_assert (node-&gt;created_for);</span>
<span class="lineNum">   31175 </span>            : 
<span class="lineNum">   31176 </span><span class="lineCov">       2080 :               if (DECL_P (node-&gt;created_for))</span>
<span class="lineNum">   31177 </span><span class="lineCov">       2048 :                 origin = get_context_die (DECL_CONTEXT (node-&gt;created_for));</span>
<span class="lineNum">   31178 </span><span class="lineCov">         32 :               else if (TYPE_P (node-&gt;created_for))</span>
<span class="lineNum">   31179 </span><span class="lineCov">         32 :                 origin = scope_die_for (node-&gt;created_for, comp_unit_die ());</span>
<span class="lineNum">   31180 </span>            :               else
<span class="lineNum">   31181 </span><span class="lineNoCov">          0 :                 origin = comp_unit_die ();</span>
<span class="lineNum">   31182 </span>            : 
<span class="lineNum">   31183 </span><span class="lineCov">       2080 :               add_child_die (origin, die);</span>
<span class="lineNum">   31184 </span>            :             }
<span class="lineNum">   31185 </span>            :         }
<span class="lineNum">   31186 </span>            :     }
<span class="lineNum">   31187 </span><span class="lineCov">      67291 : }</span>
<span class="lineNum">   31188 </span>            : 
<span class="lineNum">   31189 </span>            : /* Reset DIEs so we can output them again.  */
<a name="31190"><span class="lineNum">   31190 </span>            : </a>
<span class="lineNum">   31191 </span>            : static void
<span class="lineNum">   31192 </span><span class="lineCov">      28723 : reset_dies (dw_die_ref die)</span>
<span class="lineNum">   31193 </span>            : {
<span class="lineNum">   31194 </span><span class="lineCov">      28723 :   dw_die_ref c;</span>
<span class="lineNum">   31195 </span>            : 
<span class="lineNum">   31196 </span>            :   /* Remove stuff we re-generate.  */
<span class="lineNum">   31197 </span><span class="lineCov">      28723 :   die-&gt;die_mark = 0;</span>
<span class="lineNum">   31198 </span><span class="lineCov">      28723 :   die-&gt;die_offset = 0;</span>
<span class="lineNum">   31199 </span><span class="lineCov">      28723 :   die-&gt;die_abbrev = 0;</span>
<span class="lineNum">   31200 </span><span class="lineCov">      28723 :   remove_AT (die, DW_AT_sibling);</span>
<span class="lineNum">   31201 </span>            : 
<span class="lineNum">   31202 </span><span class="lineCov">      57071 :   FOR_EACH_CHILD (die, c, reset_dies (c));</span>
<span class="lineNum">   31203 </span><span class="lineCov">      28723 : }</span>
<span class="lineNum">   31204 </span>            : 
<span class="lineNum">   31205 </span>            : /* Output stuff that dwarf requires at the end of every file,
<span class="lineNum">   31206 </span>            :    and generate the DWARF-2 debugging info.  */
<a name="31207"><span class="lineNum">   31207 </span>            : </a>
<span class="lineNum">   31208 </span>            : static void
<span class="lineNum">   31209 </span><span class="lineCov">      33687 : dwarf2out_finish (const char *filename)</span>
<span class="lineNum">   31210 </span>            : {
<span class="lineNum">   31211 </span><span class="lineCov">      33687 :   comdat_type_node *ctnode;</span>
<span class="lineNum">   31212 </span><span class="lineCov">      33687 :   dw_die_ref main_comp_unit_die;</span>
<span class="lineNum">   31213 </span><span class="lineCov">      33687 :   unsigned char checksum[16];</span>
<span class="lineNum">   31214 </span><span class="lineCov">      33687 :   char dl_section_ref[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">   31215 </span>            : 
<span class="lineNum">   31216 </span>            :   /* Flush out any latecomers to the limbo party.  */
<span class="lineNum">   31217 </span><span class="lineCov">      33687 :   flush_limbo_die_list ();</span>
<span class="lineNum">   31218 </span>            : 
<span class="lineNum">   31219 </span><span class="lineCov">      33687 :   if (inline_entry_data_table)</span>
<span class="lineNum">   31220 </span><span class="lineCov">      10281 :     gcc_assert (inline_entry_data_table-&gt;elements () == 0);</span>
<span class="lineNum">   31221 </span>            : 
<span class="lineNum">   31222 </span><span class="lineCov">      33687 :   if (flag_checking)</span>
<span class="lineNum">   31223 </span>            :     {
<span class="lineNum">   31224 </span><span class="lineCov">      33686 :       verify_die (comp_unit_die ());</span>
<span class="lineNum">   31225 </span><span class="lineCov">      33686 :       for (limbo_die_node *node = cu_die_list; node; node = node-&gt;next)</span>
<span class="lineNum">   31226 </span><span class="lineNoCov">          0 :         verify_die (node-&gt;die);</span>
<span class="lineNum">   31227 </span>            :     }
<span class="lineNum">   31228 </span>            : 
<span class="lineNum">   31229 </span>            :   /* We shouldn't have any symbols with delayed asm names for
<span class="lineNum">   31230 </span>            :      DIEs generated after early finish.  */
<span class="lineNum">   31231 </span><span class="lineCov">      33687 :   gcc_assert (deferred_asm_name == NULL);</span>
<span class="lineNum">   31232 </span>            : 
<span class="lineNum">   31233 </span><span class="lineCov">      33687 :   gen_remaining_tmpl_value_param_die_attribute ();</span>
<span class="lineNum">   31234 </span>            : 
<span class="lineNum">   31235 </span><span class="lineCov">      33687 :   if (flag_generate_lto || flag_generate_offload)</span>
<span class="lineNum">   31236 </span>            :     {
<span class="lineNum">   31237 </span><span class="lineCov">        375 :       gcc_assert (flag_fat_lto_objects || flag_generate_offload);</span>
<span class="lineNum">   31238 </span>            : 
<span class="lineNum">   31239 </span>            :       /* Prune stuff so that dwarf2out_finish runs successfully
<span class="lineNum">   31240 </span>            :          for the fat part of the object.  */
<span class="lineNum">   31241 </span><span class="lineCov">        375 :       reset_dies (comp_unit_die ());</span>
<span class="lineNum">   31242 </span><span class="lineCov">        375 :       for (limbo_die_node *node = cu_die_list; node; node = node-&gt;next)</span>
<span class="lineNum">   31243 </span><span class="lineNoCov">          0 :         reset_dies (node-&gt;die);</span>
<span class="lineNum">   31244 </span>            : 
<span class="lineNum">   31245 </span><span class="lineCov">        750 :       hash_table&lt;comdat_type_hasher&gt; comdat_type_table (100);</span>
<span class="lineNum">   31246 </span><span class="lineCov">        375 :       for (ctnode = comdat_type_list; ctnode != NULL; ctnode = ctnode-&gt;next)</span>
<span class="lineNum">   31247 </span>            :         {
<span class="lineNum">   31248 </span><span class="lineNoCov">          0 :           comdat_type_node **slot</span>
<span class="lineNum">   31249 </span><span class="lineNoCov">          0 :               = comdat_type_table.find_slot (ctnode, INSERT);</span>
<span class="lineNum">   31250 </span>            : 
<span class="lineNum">   31251 </span>            :           /* Don't reset types twice.  */
<span class="lineNum">   31252 </span><span class="lineNoCov">          0 :           if (*slot != HTAB_EMPTY_ENTRY)</span>
<span class="lineNum">   31253 </span>            :             continue;
<span class="lineNum">   31254 </span>            : 
<span class="lineNum">   31255 </span>            :           /* Remove the pointer to the line table.  */
<span class="lineNum">   31256 </span><span class="lineNoCov">          0 :           remove_AT (ctnode-&gt;root_die, DW_AT_stmt_list);</span>
<span class="lineNum">   31257 </span>            : 
<span class="lineNum">   31258 </span><span class="lineNoCov">          0 :           if (debug_info_level &gt;= DINFO_LEVEL_TERSE)</span>
<span class="lineNum">   31259 </span><span class="lineNoCov">          0 :             reset_dies (ctnode-&gt;root_die);</span>
<span class="lineNum">   31260 </span>            : 
<span class="lineNum">   31261 </span><span class="lineNoCov">          0 :           *slot = ctnode;</span>
<span class="lineNum">   31262 </span>            :         }
<span class="lineNum">   31263 </span>            : 
<span class="lineNum">   31264 </span>            :       /* Reset die CU symbol so we don't output it twice.  */
<span class="lineNum">   31265 </span><span class="lineCov">        375 :       comp_unit_die ()-&gt;die_id.die_symbol = NULL;</span>
<span class="lineNum">   31266 </span>            : 
<span class="lineNum">   31267 </span>            :       /* Remove DW_AT_macro and DW_AT_stmt_list from the early output.  */
<span class="lineNum">   31268 </span><span class="lineCov">        375 :       remove_AT (comp_unit_die (), DW_AT_stmt_list);</span>
<span class="lineNum">   31269 </span><span class="lineCov">        375 :       if (have_macinfo)</span>
<span class="lineNum">   31270 </span><span class="lineNoCov">          0 :         remove_AT (comp_unit_die (), DEBUG_MACRO_ATTRIBUTE);</span>
<span class="lineNum">   31271 </span>            : 
<span class="lineNum">   31272 </span>            :       /* Remove indirect string decisions.  */
<span class="lineNum">   31273 </span><span class="lineCov">        375 :       debug_str_hash-&gt;traverse&lt;void *, reset_indirect_string&gt; (NULL);</span>
<span class="lineNum">   31274 </span><span class="lineCov">        375 :       if (debug_line_str_hash)</span>
<span class="lineNum">   31275 </span>            :         {
<span class="lineNum">   31276 </span><span class="lineCov">          3 :           debug_line_str_hash-&gt;traverse&lt;void *, reset_indirect_string&gt; (NULL);</span>
<span class="lineNum">   31277 </span><span class="lineCov">          3 :           debug_line_str_hash = NULL;</span>
<span class="lineNum">   31278 </span>            :         }
<span class="lineNum">   31279 </span>            :     }
<span class="lineNum">   31280 </span>            : 
<span class="lineNum">   31281 </span>            : #if ENABLE_ASSERT_CHECKING
<span class="lineNum">   31282 </span><span class="lineCov">      33687 :   {</span>
<span class="lineNum">   31283 </span><span class="lineCov">      33687 :     dw_die_ref die = comp_unit_die (), c;</span>
<span class="lineNum">   31284 </span><span class="lineCov">    6861668 :     FOR_EACH_CHILD (die, c, gcc_assert (! c-&gt;die_mark));</span>
<span class="lineNum">   31285 </span>            :   }
<span class="lineNum">   31286 </span>            : #endif
<span class="lineNum">   31287 </span><span class="lineCov">      33687 :   resolve_addr (comp_unit_die ());</span>
<span class="lineNum">   31288 </span><span class="lineCov">      33687 :   move_marked_base_types ();</span>
<span class="lineNum">   31289 </span>            : 
<span class="lineNum">   31290 </span><span class="lineCov">      33687 :   if (dump_file)</span>
<span class="lineNum">   31291 </span>            :     {
<span class="lineNum">   31292 </span><span class="lineCov">          4 :       fprintf (dump_file, &quot;DWARF for %s\n&quot;, filename);</span>
<span class="lineNum">   31293 </span><span class="lineCov">          4 :       print_die (comp_unit_die (), dump_file);</span>
<span class="lineNum">   31294 </span>            :     }
<span class="lineNum">   31295 </span>            : 
<span class="lineNum">   31296 </span>            :   /* Initialize sections and labels used for actual assembler output.  */
<span class="lineNum">   31297 </span><span class="lineCov">      33687 :   unsigned generation = init_sections_and_labels (false);</span>
<span class="lineNum">   31298 </span>            : 
<span class="lineNum">   31299 </span>            :   /* Traverse the DIE's and add sibling attributes to those DIE's that
<span class="lineNum">   31300 </span>            :      have children.  */
<span class="lineNum">   31301 </span><span class="lineCov">      33687 :   add_sibling_attributes (comp_unit_die ());</span>
<span class="lineNum">   31302 </span><span class="lineCov">      33687 :   limbo_die_node *node;</span>
<span class="lineNum">   31303 </span><span class="lineCov">      33687 :   for (node = cu_die_list; node; node = node-&gt;next)</span>
<span class="lineNum">   31304 </span><span class="lineNoCov">          0 :     add_sibling_attributes (node-&gt;die);</span>
<span class="lineNum">   31305 </span><span class="lineCov">      33735 :   for (ctnode = comdat_type_list; ctnode != NULL; ctnode = ctnode-&gt;next)</span>
<span class="lineNum">   31306 </span><span class="lineCov">         48 :     add_sibling_attributes (ctnode-&gt;root_die);</span>
<span class="lineNum">   31307 </span>            : 
<span class="lineNum">   31308 </span>            :   /* When splitting DWARF info, we put some attributes in the
<span class="lineNum">   31309 </span>            :      skeleton compile_unit DIE that remains in the .o, while
<span class="lineNum">   31310 </span>            :      most attributes go in the DWO compile_unit_die.  */
<span class="lineNum">   31311 </span><span class="lineCov">      33687 :   if (dwarf_split_debug_info)</span>
<span class="lineNum">   31312 </span>            :     {
<span class="lineNum">   31313 </span><span class="lineCov">          4 :       limbo_die_node *cu;</span>
<span class="lineNum">   31314 </span><span class="lineCov">          4 :       main_comp_unit_die = gen_compile_unit_die (NULL);</span>
<span class="lineNum">   31315 </span><span class="lineCov">          4 :       if (dwarf_version &gt;= 5)</span>
<span class="lineNum">   31316 </span><span class="lineNoCov">          0 :         main_comp_unit_die-&gt;die_tag = DW_TAG_skeleton_unit;</span>
<span class="lineNum">   31317 </span><span class="lineCov">          4 :       cu = limbo_die_list;</span>
<span class="lineNum">   31318 </span><span class="lineCov">          4 :       gcc_assert (cu-&gt;die == main_comp_unit_die);</span>
<span class="lineNum">   31319 </span><span class="lineCov">          4 :       limbo_die_list = limbo_die_list-&gt;next;</span>
<span class="lineNum">   31320 </span><span class="lineCov">          4 :       cu-&gt;next = cu_die_list;</span>
<span class="lineNum">   31321 </span><span class="lineCov">          4 :       cu_die_list = cu;</span>
<span class="lineNum">   31322 </span>            :     }
<span class="lineNum">   31323 </span>            :   else
<span class="lineNum">   31324 </span><span class="lineCov">      33683 :     main_comp_unit_die = comp_unit_die ();</span>
<span class="lineNum">   31325 </span>            : 
<span class="lineNum">   31326 </span>            :   /* Output a terminator label for the .text section.  */
<span class="lineNum">   31327 </span><span class="lineCov">      33687 :   switch_to_section (text_section);</span>
<span class="lineNum">   31328 </span><span class="lineCov">      33687 :   targetm.asm_out.internal_label (asm_out_file, TEXT_END_LABEL, 0);</span>
<span class="lineNum">   31329 </span><span class="lineCov">      33687 :   if (cold_text_section)</span>
<span class="lineNum">   31330 </span>            :     {
<span class="lineNum">   31331 </span><span class="lineCov">       5444 :       switch_to_section (cold_text_section);</span>
<span class="lineNum">   31332 </span><span class="lineCov">       5444 :       targetm.asm_out.internal_label (asm_out_file, COLD_END_LABEL, 0);</span>
<span class="lineNum">   31333 </span>            :     }
<span class="lineNum">   31334 </span>            : 
<span class="lineNum">   31335 </span>            :   /* We can only use the low/high_pc attributes if all of the code was
<span class="lineNum">   31336 </span>            :      in .text.  */
<span class="lineNum">   31337 </span><span class="lineCov">      33687 :   if (!have_multiple_function_sections </span>
<span class="lineNum">   31338 </span><span class="lineCov">      20330 :       || (dwarf_version &lt; 3 &amp;&amp; dwarf_strict))</span>
<span class="lineNum">   31339 </span>            :     {
<span class="lineNum">   31340 </span>            :       /* Don't add if the CU has no associated code.  */
<span class="lineNum">   31341 </span><span class="lineCov">      13357 :       if (text_section_used)</span>
<span class="lineNum">   31342 </span><span class="lineCov">      11186 :         add_AT_low_high_pc (main_comp_unit_die, text_section_label,</span>
<span class="lineNum">   31343 </span>            :                             text_end_label, true);
<span class="lineNum">   31344 </span>            :     }
<span class="lineNum">   31345 </span>            :   else
<span class="lineNum">   31346 </span>            :     {
<span class="lineNum">   31347 </span><span class="lineCov">      20330 :       unsigned fde_idx;</span>
<span class="lineNum">   31348 </span><span class="lineCov">      20330 :       dw_fde_ref fde;</span>
<span class="lineNum">   31349 </span><span class="lineCov">      20330 :       bool range_list_added = false;</span>
<span class="lineNum">   31350 </span>            : 
<span class="lineNum">   31351 </span><span class="lineCov">      20330 :       if (text_section_used)</span>
<span class="lineNum">   31352 </span><span class="lineCov">       6829 :         add_ranges_by_labels (main_comp_unit_die, text_section_label,</span>
<span class="lineNum">   31353 </span>            :                               text_end_label, &amp;range_list_added, true);
<span class="lineNum">   31354 </span><span class="lineCov">      20330 :       if (cold_text_section_used)</span>
<span class="lineNum">   31355 </span><span class="lineCov">       5444 :         add_ranges_by_labels (main_comp_unit_die, cold_text_section_label,</span>
<span class="lineNum">   31356 </span>            :                               cold_end_label, &amp;range_list_added, true);
<span class="lineNum">   31357 </span>            : 
<span class="lineNum">   31358 </span><span class="lineCov">     180067 :       FOR_EACH_VEC_ELT (*fde_vec, fde_idx, fde)</span>
<span class="lineNum">   31359 </span>            :         {
<span class="lineNum">   31360 </span><span class="lineCov">     159737 :           if (DECL_IGNORED_P (fde-&gt;decl))</span>
<span class="lineNum">   31361 </span>            :             continue;
<span class="lineNum">   31362 </span><span class="lineCov">     154133 :           if (!fde-&gt;in_std_section)</span>
<span class="lineNum">   31363 </span><span class="lineCov">     124903 :             add_ranges_by_labels (main_comp_unit_die, fde-&gt;dw_fde_begin,</span>
<span class="lineNum">   31364 </span>            :                                   fde-&gt;dw_fde_end, &amp;range_list_added,
<span class="lineNum">   31365 </span>            :                                   true);
<span class="lineNum">   31366 </span><span class="lineCov">     154133 :           if (fde-&gt;dw_fde_second_begin &amp;&amp; !fde-&gt;second_in_std_section)</span>
<span class="lineNum">   31367 </span><span class="lineCov">       2828 :             add_ranges_by_labels (main_comp_unit_die, fde-&gt;dw_fde_second_begin,</span>
<span class="lineNum">   31368 </span>            :                                   fde-&gt;dw_fde_second_end, &amp;range_list_added,
<span class="lineNum">   31369 </span>            :                                   true);
<span class="lineNum">   31370 </span>            :         }
<span class="lineNum">   31371 </span>            : 
<span class="lineNum">   31372 </span><span class="lineCov">      20330 :       if (range_list_added)</span>
<span class="lineNum">   31373 </span>            :         {
<span class="lineNum">   31374 </span>            :           /* We need to give .debug_loc and .debug_ranges an appropriate
<span class="lineNum">   31375 </span>            :              &quot;base address&quot;.  Use zero so that these addresses become
<span class="lineNum">   31376 </span>            :              absolute.  Historically, we've emitted the unexpected
<span class="lineNum">   31377 </span>            :              DW_AT_entry_pc instead of DW_AT_low_pc for this purpose.
<span class="lineNum">   31378 </span>            :              Emit both to give time for other tools to adapt.  */
<span class="lineNum">   31379 </span><span class="lineCov">      20330 :           add_AT_addr (main_comp_unit_die, DW_AT_low_pc, const0_rtx, true);</span>
<span class="lineNum">   31380 </span><span class="lineCov">      20330 :           if (! dwarf_strict &amp;&amp; dwarf_version &lt; 4)</span>
<span class="lineNum">   31381 </span><span class="lineCov">        335 :             add_AT_addr (main_comp_unit_die, DW_AT_entry_pc, const0_rtx, true);</span>
<span class="lineNum">   31382 </span>            : 
<span class="lineNum">   31383 </span><span class="lineCov">      20330 :           add_ranges (NULL);</span>
<span class="lineNum">   31384 </span>            :         }
<span class="lineNum">   31385 </span>            :     }
<span class="lineNum">   31386 </span>            : 
<span class="lineNum">   31387 </span>            :   /* AIX Assembler inserts the length, so adjust the reference to match the
<span class="lineNum">   31388 </span>            :      offset expected by debuggers.  */
<span class="lineNum">   31389 </span><span class="lineCov">      33687 :   strcpy (dl_section_ref, debug_line_section_label);</span>
<span class="lineNum">   31390 </span><span class="lineCov">      33687 :   if (XCOFF_DEBUGGING_INFO)</span>
<span class="lineNum">   31391 </span>            :     strcat (dl_section_ref, DWARF_INITIAL_LENGTH_SIZE_STR);
<span class="lineNum">   31392 </span>            : 
<span class="lineNum">   31393 </span><span class="lineCov">      33687 :   if (debug_info_level &gt;= DINFO_LEVEL_TERSE)</span>
<span class="lineNum">   31394 </span><span class="lineCov">      33687 :     add_AT_lineptr (main_comp_unit_die, DW_AT_stmt_list,</span>
<span class="lineNum">   31395 </span>            :                     dl_section_ref);
<span class="lineNum">   31396 </span>            : 
<span class="lineNum">   31397 </span><span class="lineCov">      33687 :   if (have_macinfo)</span>
<span class="lineNum">   31398 </span><span class="lineCov">        870 :     add_AT_macptr (comp_unit_die (), DEBUG_MACRO_ATTRIBUTE,</span>
<span class="lineNum">   31399 </span>            :                    macinfo_section_label);
<span class="lineNum">   31400 </span>            : 
<span class="lineNum">   31401 </span><span class="lineCov">      33687 :   if (dwarf_split_debug_info)</span>
<span class="lineNum">   31402 </span>            :     {
<span class="lineNum">   31403 </span><span class="lineCov">          4 :       if (have_location_lists)</span>
<span class="lineNum">   31404 </span>            :         {
<span class="lineNum">   31405 </span>            :           /* Since we generate the loclists in the split DWARF .dwo
<span class="lineNum">   31406 </span>            :              file itself, we don't need to generate a loclists_base
<span class="lineNum">   31407 </span>            :              attribute for the split compile unit DIE.  That attribute
<span class="lineNum">   31408 </span>            :              (and using relocatable sec_offset FORMs) isn't allowed
<span class="lineNum">   31409 </span>            :              for a split compile unit.  Only if the .debug_loclists
<span class="lineNum">   31410 </span>            :              section was in the main file, would we need to generate a
<span class="lineNum">   31411 </span>            :              loclists_base attribute here (for the full or skeleton
<span class="lineNum">   31412 </span>            :              unit DIE).  */
<span class="lineNum">   31413 </span>            : 
<span class="lineNum">   31414 </span>            :           /* optimize_location_lists calculates the size of the lists,
<span class="lineNum">   31415 </span>            :              so index them first, and assign indices to the entries.
<span class="lineNum">   31416 </span>            :              Although optimize_location_lists will remove entries from
<span class="lineNum">   31417 </span>            :              the table, it only does so for duplicates, and therefore
<span class="lineNum">   31418 </span>            :              only reduces ref_counts to 1.  */
<span class="lineNum">   31419 </span><span class="lineCov">          3 :           index_location_lists (comp_unit_die ());</span>
<span class="lineNum">   31420 </span>            :         }
<span class="lineNum">   31421 </span>            : 
<span class="lineNum">   31422 </span><span class="lineCov">          4 :       if (addr_index_table != NULL)</span>
<span class="lineNum">   31423 </span>            :         {
<span class="lineNum">   31424 </span><span class="lineCov">          4 :           unsigned int index = 0;</span>
<span class="lineNum">   31425 </span><span class="lineCov">          4 :           addr_index_table</span>
<span class="lineNum">   31426 </span>            :             -&gt;traverse_noresize&lt;unsigned int *, index_addr_table_entry&gt;
<span class="lineNum">   31427 </span><span class="lineCov">          4 :             (&amp;index);</span>
<span class="lineNum">   31428 </span>            :         }
<span class="lineNum">   31429 </span>            :     }
<span class="lineNum">   31430 </span>            : 
<span class="lineNum">   31431 </span><span class="lineCov">      33687 :   loc_list_idx = 0;</span>
<span class="lineNum">   31432 </span><span class="lineCov">      33687 :   if (have_location_lists)</span>
<span class="lineNum">   31433 </span>            :     {
<span class="lineNum">   31434 </span><span class="lineCov">      22713 :       optimize_location_lists (comp_unit_die ());</span>
<span class="lineNum">   31435 </span>            :       /* And finally assign indexes to the entries for -gsplit-dwarf.  */
<span class="lineNum">   31436 </span><span class="lineCov">      22713 :       if (dwarf_version &gt;= 5 &amp;&amp; dwarf_split_debug_info)</span>
<span class="lineNum">   31437 </span><span class="lineNoCov">          0 :         assign_location_list_indexes (comp_unit_die ());</span>
<span class="lineNum">   31438 </span>            :     }
<span class="lineNum">   31439 </span>            : 
<span class="lineNum">   31440 </span><span class="lineCov">      33687 :   save_macinfo_strings ();</span>
<span class="lineNum">   31441 </span>            : 
<span class="lineNum">   31442 </span><span class="lineCov">      33687 :   if (dwarf_split_debug_info)</span>
<span class="lineNum">   31443 </span>            :     {
<span class="lineNum">   31444 </span><span class="lineCov">          4 :       unsigned int index = 0;</span>
<span class="lineNum">   31445 </span>            : 
<span class="lineNum">   31446 </span>            :       /* Add attributes common to skeleton compile_units and
<span class="lineNum">   31447 </span>            :          type_units.  Because these attributes include strings, it
<span class="lineNum">   31448 </span>            :          must be done before freezing the string table.  Top-level
<span class="lineNum">   31449 </span>            :          skeleton die attrs are added when the skeleton type unit is
<span class="lineNum">   31450 </span>            :          created, so ensure it is created by this point.  */
<span class="lineNum">   31451 </span><span class="lineCov">          4 :       add_top_level_skeleton_die_attrs (main_comp_unit_die);</span>
<span class="lineNum">   31452 </span><span class="lineCov">          4 :       debug_str_hash-&gt;traverse_noresize&lt;unsigned int *, index_string&gt; (&amp;index);</span>
<span class="lineNum">   31453 </span>            :     }
<span class="lineNum">   31454 </span>            : 
<span class="lineNum">   31455 </span>            :   /* Output all of the compilation units.  We put the main one last so that
<span class="lineNum">   31456 </span>            :      the offsets are available to output_pubnames.  */
<span class="lineNum">   31457 </span><span class="lineCov">      33691 :   for (node = cu_die_list; node; node = node-&gt;next)</span>
<span class="lineNum">   31458 </span><span class="lineCov">          4 :     output_comp_unit (node-&gt;die, 0, NULL);</span>
<span class="lineNum">   31459 </span>            : 
<span class="lineNum">   31460 </span><span class="lineCov">      67374 :   hash_table&lt;comdat_type_hasher&gt; comdat_type_table (100);</span>
<span class="lineNum">   31461 </span><span class="lineCov">      33735 :   for (ctnode = comdat_type_list; ctnode != NULL; ctnode = ctnode-&gt;next)</span>
<span class="lineNum">   31462 </span>            :     {
<span class="lineNum">   31463 </span><span class="lineCov">         48 :       comdat_type_node **slot = comdat_type_table.find_slot (ctnode, INSERT);</span>
<span class="lineNum">   31464 </span>            : 
<span class="lineNum">   31465 </span>            :       /* Don't output duplicate types.  */
<span class="lineNum">   31466 </span><span class="lineCov">         48 :       if (*slot != HTAB_EMPTY_ENTRY)</span>
<span class="lineNum">   31467 </span>            :         continue;
<span class="lineNum">   31468 </span>            : 
<span class="lineNum">   31469 </span>            :       /* Add a pointer to the line table for the main compilation unit
<span class="lineNum">   31470 </span>            :          so that the debugger can make sense of DW_AT_decl_file
<span class="lineNum">   31471 </span>            :          attributes.  */
<span class="lineNum">   31472 </span><span class="lineCov">         48 :       if (debug_info_level &gt;= DINFO_LEVEL_TERSE)</span>
<span class="lineNum">   31473 </span><span class="lineCov">         48 :         add_AT_lineptr (ctnode-&gt;root_die, DW_AT_stmt_list,</span>
<span class="lineNum">   31474 </span><span class="lineCov">         48 :                         (!dwarf_split_debug_info</span>
<span class="lineNum">   31475 </span>            :                          ? dl_section_ref
<span class="lineNum">   31476 </span>            :                          : debug_skeleton_line_section_label));
<span class="lineNum">   31477 </span>            : 
<span class="lineNum">   31478 </span><span class="lineCov">         48 :       output_comdat_type_unit (ctnode);</span>
<span class="lineNum">   31479 </span><span class="lineCov">         48 :       *slot = ctnode;</span>
<span class="lineNum">   31480 </span>            :     }
<span class="lineNum">   31481 </span>            : 
<span class="lineNum">   31482 </span><span class="lineCov">      33687 :   if (dwarf_split_debug_info)</span>
<span class="lineNum">   31483 </span>            :     {
<span class="lineNum">   31484 </span><span class="lineCov">          4 :       int mark;</span>
<span class="lineNum">   31485 </span><span class="lineCov">          4 :       struct md5_ctx ctx;</span>
<span class="lineNum">   31486 </span>            : 
<span class="lineNum">   31487 </span><span class="lineCov">          4 :       if (dwarf_version &gt;= 5 &amp;&amp; !vec_safe_is_empty (ranges_table))</span>
<span class="lineNum">   31488 </span>            :         index_rnglists ();
<span class="lineNum">   31489 </span>            : 
<span class="lineNum">   31490 </span>            :       /* Compute a checksum of the comp_unit to use as the dwo_id.  */
<span class="lineNum">   31491 </span><span class="lineCov">          4 :       md5_init_ctx (&amp;ctx);</span>
<span class="lineNum">   31492 </span><span class="lineCov">          4 :       mark = 0;</span>
<span class="lineNum">   31493 </span><span class="lineCov">          4 :       die_checksum (comp_unit_die (), &amp;ctx, &amp;mark);</span>
<span class="lineNum">   31494 </span><span class="lineCov">          4 :       unmark_all_dies (comp_unit_die ());</span>
<span class="lineNum">   31495 </span><span class="lineCov">          4 :       md5_finish_ctx (&amp;ctx, checksum);</span>
<span class="lineNum">   31496 </span>            : 
<span class="lineNum">   31497 </span><span class="lineCov">          4 :       if (dwarf_version &lt; 5)</span>
<span class="lineNum">   31498 </span>            :         {
<span class="lineNum">   31499 </span>            :           /* Use the first 8 bytes of the checksum as the dwo_id,
<span class="lineNum">   31500 </span>            :              and add it to both comp-unit DIEs.  */
<span class="lineNum">   31501 </span><span class="lineCov">          4 :           add_AT_data8 (main_comp_unit_die, DW_AT_GNU_dwo_id, checksum);</span>
<span class="lineNum">   31502 </span><span class="lineCov">          4 :           add_AT_data8 (comp_unit_die (), DW_AT_GNU_dwo_id, checksum);</span>
<span class="lineNum">   31503 </span>            :         }
<span class="lineNum">   31504 </span>            : 
<span class="lineNum">   31505 </span>            :       /* Add the base offset of the ranges table to the skeleton
<span class="lineNum">   31506 </span>            :         comp-unit DIE.  */
<span class="lineNum">   31507 </span><span class="lineCov">          4 :       if (!vec_safe_is_empty (ranges_table))</span>
<span class="lineNum">   31508 </span>            :         {
<span class="lineNum">   31509 </span><span class="lineCov">          2 :           if (dwarf_version &gt;= 5)</span>
<span class="lineNum">   31510 </span><span class="lineNoCov">          0 :             add_AT_lineptr (main_comp_unit_die, DW_AT_rnglists_base,</span>
<span class="lineNum">   31511 </span>            :                             ranges_base_label);
<span class="lineNum">   31512 </span>            :           else
<span class="lineNum">   31513 </span><span class="lineCov">          2 :             add_AT_lineptr (main_comp_unit_die, DW_AT_GNU_ranges_base,</span>
<span class="lineNum">   31514 </span>            :                             ranges_section_label);
<span class="lineNum">   31515 </span>            :         }
<span class="lineNum">   31516 </span>            : 
<span class="lineNum">   31517 </span><span class="lineCov">          4 :       switch_to_section (debug_addr_section);</span>
<span class="lineNum">   31518 </span>            :       /* GNU DebugFission https://gcc.gnu.org/wiki/DebugFission
<span class="lineNum">   31519 </span>            :          which GCC uses to implement -gsplit-dwarf as DWARF GNU extension
<span class="lineNum">   31520 </span>            :          before DWARF5, didn't have a header for .debug_addr units.
<span class="lineNum">   31521 </span>            :          DWARF5 specifies a small header when address tables are used.  */
<span class="lineNum">   31522 </span><span class="lineCov">          4 :       if (dwarf_version &gt;= 5)</span>
<span class="lineNum">   31523 </span>            :         {
<span class="lineNum">   31524 </span><span class="lineNoCov">          0 :           unsigned int last_idx = 0;</span>
<span class="lineNum">   31525 </span><span class="lineNoCov">          0 :           unsigned long addrs_length;</span>
<span class="lineNum">   31526 </span>            : 
<span class="lineNum">   31527 </span><span class="lineNoCov">          0 :           addr_index_table-&gt;traverse_noresize</span>
<span class="lineNum">   31528 </span><span class="lineNoCov">          0 :             &lt;unsigned int *, count_index_addrs&gt; (&amp;last_idx);</span>
<span class="lineNum">   31529 </span><span class="lineNoCov">          0 :           addrs_length = last_idx * DWARF2_ADDR_SIZE + 4;</span>
<span class="lineNum">   31530 </span>            : 
<span class="lineNum">   31531 </span><span class="lineNoCov">          0 :           if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)</span>
<span class="lineNum">   31532 </span>            :             dw2_asm_output_data (4, 0xffffffff,
<span class="lineNum">   31533 </span>            :                                  &quot;Escape value for 64-bit DWARF extension&quot;);
<span class="lineNum">   31534 </span><span class="lineNoCov">          0 :           dw2_asm_output_data (DWARF_OFFSET_SIZE, addrs_length,</span>
<span class="lineNum">   31535 </span>            :                                &quot;Length of Address Unit&quot;);
<span class="lineNum">   31536 </span><span class="lineNoCov">          0 :           dw2_asm_output_data (2, 5, &quot;DWARF addr version&quot;);</span>
<span class="lineNum">   31537 </span><span class="lineNoCov">          0 :           dw2_asm_output_data (1, DWARF2_ADDR_SIZE, &quot;Size of Address&quot;);</span>
<span class="lineNum">   31538 </span><span class="lineNoCov">          0 :           dw2_asm_output_data (1, 0, &quot;Size of Segment Descriptor&quot;);</span>
<span class="lineNum">   31539 </span>            :         }
<span class="lineNum">   31540 </span><span class="lineCov">          4 :       ASM_OUTPUT_LABEL (asm_out_file, debug_addr_section_label);</span>
<span class="lineNum">   31541 </span><span class="lineCov">          4 :       output_addr_table ();</span>
<span class="lineNum">   31542 </span>            :     }
<span class="lineNum">   31543 </span>            : 
<span class="lineNum">   31544 </span>            :   /* Output the main compilation unit if non-empty or if .debug_macinfo
<span class="lineNum">   31545 </span>            :      or .debug_macro will be emitted.  */
<span class="lineNum">   31546 </span><span class="lineCov">      33690 :   output_comp_unit (comp_unit_die (), have_macinfo,</span>
<span class="lineNum">   31547 </span><span class="lineCov">      33687 :                     dwarf_split_debug_info ? checksum : NULL);</span>
<span class="lineNum">   31548 </span>            : 
<span class="lineNum">   31549 </span><span class="lineCov">      33687 :   if (dwarf_split_debug_info &amp;&amp; info_section_emitted)</span>
<span class="lineNum">   31550 </span><span class="lineCov">          4 :     output_skeleton_debug_sections (main_comp_unit_die, checksum);</span>
<span class="lineNum">   31551 </span>            : 
<span class="lineNum">   31552 </span>            :   /* Output the abbreviation table.  */
<span class="lineNum">   31553 </span><span class="lineCov">      33687 :   if (vec_safe_length (abbrev_die_table) != 1)</span>
<span class="lineNum">   31554 </span>            :     {
<span class="lineNum">   31555 </span><span class="lineCov">      33302 :       switch_to_section (debug_abbrev_section);</span>
<span class="lineNum">   31556 </span><span class="lineCov">      33302 :       ASM_OUTPUT_LABEL (asm_out_file, abbrev_section_label);</span>
<span class="lineNum">   31557 </span><span class="lineCov">      33302 :       output_abbrev_section ();</span>
<span class="lineNum">   31558 </span>            :     }
<span class="lineNum">   31559 </span>            : 
<span class="lineNum">   31560 </span>            :   /* Output location list section if necessary.  */
<span class="lineNum">   31561 </span><span class="lineCov">      33687 :   if (have_location_lists)</span>
<span class="lineNum">   31562 </span>            :     {
<span class="lineNum">   31563 </span><span class="lineCov">      22713 :       char l1[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">   31564 </span><span class="lineCov">      22713 :       char l2[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">   31565 </span>            :       /* Output the location lists info.  */
<span class="lineNum">   31566 </span><span class="lineCov">      22713 :       switch_to_section (debug_loc_section);</span>
<span class="lineNum">   31567 </span><span class="lineCov">      22713 :       if (dwarf_version &gt;= 5)</span>
<span class="lineNum">   31568 </span>            :         {
<span class="lineNum">   31569 </span><span class="lineCov">          5 :           ASM_GENERATE_INTERNAL_LABEL (l1, DEBUG_LOC_SECTION_LABEL, 2);</span>
<span class="lineNum">   31570 </span><span class="lineCov">          5 :           ASM_GENERATE_INTERNAL_LABEL (l2, DEBUG_LOC_SECTION_LABEL, 3);</span>
<span class="lineNum">   31571 </span><span class="lineCov">          5 :           if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)</span>
<span class="lineNum">   31572 </span>            :             dw2_asm_output_data (4, 0xffffffff,
<span class="lineNum">   31573 </span>            :                                  &quot;Initial length escape value indicating &quot;
<span class="lineNum">   31574 </span>            :                                  &quot;64-bit DWARF extension&quot;);
<span class="lineNum">   31575 </span><span class="lineCov">          5 :           dw2_asm_output_delta (DWARF_OFFSET_SIZE, l2, l1,</span>
<span class="lineNum">   31576 </span>            :                             &quot;Length of Location Lists&quot;);
<span class="lineNum">   31577 </span><span class="lineCov">          5 :           ASM_OUTPUT_LABEL (asm_out_file, l1);</span>
<span class="lineNum">   31578 </span><span class="lineCov">          5 :           output_dwarf_version ();</span>
<span class="lineNum">   31579 </span><span class="lineCov">          5 :           dw2_asm_output_data (1, DWARF2_ADDR_SIZE, &quot;Address Size&quot;);</span>
<span class="lineNum">   31580 </span><span class="lineCov">          5 :           dw2_asm_output_data (1, 0, &quot;Segment Size&quot;);</span>
<span class="lineNum">   31581 </span><span class="lineCov">          5 :           dw2_asm_output_data (4, dwarf_split_debug_info ? loc_list_idx : 0,</span>
<span class="lineNum">   31582 </span>            :                                &quot;Offset Entry Count&quot;);
<span class="lineNum">   31583 </span>            :         }
<span class="lineNum">   31584 </span><span class="lineCov">      22713 :       ASM_OUTPUT_LABEL (asm_out_file, loc_section_label);</span>
<span class="lineNum">   31585 </span><span class="lineCov">      22713 :       if (dwarf_version &gt;= 5 &amp;&amp; dwarf_split_debug_info)</span>
<span class="lineNum">   31586 </span>            :         {
<span class="lineNum">   31587 </span><span class="lineNoCov">          0 :           unsigned int save_loc_list_idx = loc_list_idx;</span>
<span class="lineNum">   31588 </span><span class="lineNoCov">          0 :           loc_list_idx = 0;</span>
<span class="lineNum">   31589 </span><span class="lineNoCov">          0 :           output_loclists_offsets (comp_unit_die ());</span>
<span class="lineNum">   31590 </span><span class="lineNoCov">          0 :           gcc_assert (save_loc_list_idx == loc_list_idx);</span>
<span class="lineNum">   31591 </span>            :         }
<span class="lineNum">   31592 </span><span class="lineCov">      22713 :       output_location_lists (comp_unit_die ());</span>
<span class="lineNum">   31593 </span><span class="lineCov">      22713 :       if (dwarf_version &gt;= 5)</span>
<span class="lineNum">   31594 </span><span class="lineCov">          5 :         ASM_OUTPUT_LABEL (asm_out_file, l2);</span>
<span class="lineNum">   31595 </span>            :     }
<span class="lineNum">   31596 </span>            : 
<span class="lineNum">   31597 </span><span class="lineCov">      33687 :   output_pubtables ();</span>
<span class="lineNum">   31598 </span>            : 
<span class="lineNum">   31599 </span>            :   /* Output the address range information if a CU (.debug_info section)
<span class="lineNum">   31600 </span>            :      was emitted.  We output an empty table even if we had no functions
<span class="lineNum">   31601 </span>            :      to put in it.  This because the consumer has no way to tell the
<span class="lineNum">   31602 </span>            :      difference between an empty table that we omitted and failure to
<span class="lineNum">   31603 </span>            :      generate a table that would have contained data.  */
<span class="lineNum">   31604 </span><span class="lineCov">      33687 :   if (info_section_emitted)</span>
<span class="lineNum">   31605 </span>            :     {
<span class="lineNum">   31606 </span><span class="lineCov">      33302 :       switch_to_section (debug_aranges_section);</span>
<span class="lineNum">   31607 </span><span class="lineCov">      33302 :       output_aranges ();</span>
<span class="lineNum">   31608 </span>            :     }
<span class="lineNum">   31609 </span>            : 
<span class="lineNum">   31610 </span>            :   /* Output ranges section if necessary.  */
<span class="lineNum">   31611 </span><span class="lineCov">      33687 :   if (!vec_safe_is_empty (ranges_table))</span>
<span class="lineNum">   31612 </span>            :     {
<span class="lineNum">   31613 </span><span class="lineCov">      23683 :       if (dwarf_version &gt;= 5)</span>
<span class="lineNum">   31614 </span><span class="lineCov">          5 :         output_rnglists (generation);</span>
<span class="lineNum">   31615 </span>            :       else
<span class="lineNum">   31616 </span><span class="lineCov">      23678 :         output_ranges ();</span>
<span class="lineNum">   31617 </span>            :     }
<span class="lineNum">   31618 </span>            : 
<span class="lineNum">   31619 </span>            :   /* Have to end the macro section.  */
<span class="lineNum">   31620 </span><span class="lineCov">      33687 :   if (have_macinfo)</span>
<span class="lineNum">   31621 </span>            :     {
<span class="lineNum">   31622 </span><span class="lineCov">        435 :       switch_to_section (debug_macinfo_section);</span>
<span class="lineNum">   31623 </span><span class="lineCov">        435 :       ASM_OUTPUT_LABEL (asm_out_file, macinfo_section_label);</span>
<span class="lineNum">   31624 </span><span class="lineCov">        437 :       output_macinfo (!dwarf_split_debug_info ? debug_line_section_label</span>
<span class="lineNum">   31625 </span>            :                       : debug_skeleton_line_section_label, false);
<span class="lineNum">   31626 </span><span class="lineCov">        435 :       dw2_asm_output_data (1, 0, &quot;End compilation unit&quot;);</span>
<span class="lineNum">   31627 </span>            :     }
<span class="lineNum">   31628 </span>            : 
<span class="lineNum">   31629 </span>            :   /* Output the source line correspondence table.  We must do this
<span class="lineNum">   31630 </span>            :      even if there is no line information.  Otherwise, on an empty
<span class="lineNum">   31631 </span>            :      translation unit, we will generate a present, but empty,
<span class="lineNum">   31632 </span>            :      .debug_info section.  IRIX 6.5 `nm' will then complain when
<span class="lineNum">   31633 </span>            :      examining the file.  This is done late so that any filenames
<span class="lineNum">   31634 </span>            :      used by the debug_info section are marked as 'used'.  */
<span class="lineNum">   31635 </span><span class="lineCov">      33687 :   switch_to_section (debug_line_section);</span>
<span class="lineNum">   31636 </span><span class="lineCov">      33687 :   ASM_OUTPUT_LABEL (asm_out_file, debug_line_section_label);</span>
<span class="lineNum">   31637 </span><span class="lineCov">      33687 :   if (! output_asm_line_debug_info ())</span>
<span class="lineNum">   31638 </span><span class="lineNoCov">          0 :     output_line_info (false);</span>
<span class="lineNum">   31639 </span>            : 
<span class="lineNum">   31640 </span><span class="lineCov">      33687 :   if (dwarf_split_debug_info &amp;&amp; info_section_emitted)</span>
<span class="lineNum">   31641 </span>            :     {
<span class="lineNum">   31642 </span><span class="lineCov">          4 :       switch_to_section (debug_skeleton_line_section);</span>
<span class="lineNum">   31643 </span><span class="lineCov">          4 :       ASM_OUTPUT_LABEL (asm_out_file, debug_skeleton_line_section_label);</span>
<span class="lineNum">   31644 </span><span class="lineCov">          4 :       output_line_info (true);</span>
<span class="lineNum">   31645 </span>            :     }
<span class="lineNum">   31646 </span>            : 
<span class="lineNum">   31647 </span>            :   /* If we emitted any indirect strings, output the string table too.  */
<span class="lineNum">   31648 </span><span class="lineCov">      33687 :   if (debug_str_hash || skeleton_debug_str_hash)</span>
<span class="lineNum">   31649 </span><span class="lineCov">      33687 :     output_indirect_strings ();</span>
<span class="lineNum">   31650 </span><span class="lineCov">      33687 :   if (debug_line_str_hash)</span>
<span class="lineNum">   31651 </span>            :     {
<span class="lineNum">   31652 </span><span class="lineNoCov">          0 :       switch_to_section (debug_line_str_section);</span>
<span class="lineNum">   31653 </span><span class="lineNoCov">          0 :       const enum dwarf_form form = DW_FORM_line_strp;</span>
<span class="lineNum">   31654 </span><span class="lineNoCov">          0 :       debug_line_str_hash-&gt;traverse&lt;enum dwarf_form,</span>
<span class="lineNum">   31655 </span><span class="lineNoCov">          0 :                                     output_indirect_string&gt; (form);</span>
<span class="lineNum">   31656 </span>            :     }
<span class="lineNum">   31657 </span>            : 
<span class="lineNum">   31658 </span>            :   /* ??? Move lvugid out of dwarf2out_source_line and reset it too?  */
<span class="lineNum">   31659 </span><span class="lineCov">      33687 :   symview_upper_bound = 0;</span>
<span class="lineNum">   31660 </span><span class="lineCov">      33687 :   if (zero_view_p)</span>
<span class="lineNum">   31661 </span><span class="lineCov">      28739 :     bitmap_clear (zero_view_p);</span>
<span class="lineNum">   31662 </span><span class="lineCov">      33687 : }</span>
<span class="lineNum">   31663 </span>            : 
<span class="lineNum">   31664 </span>            : /* Returns a hash value for X (which really is a variable_value_struct).  */
<a name="31665"><span class="lineNum">   31665 </span>            : </a>
<span class="lineNum">   31666 </span>            : inline hashval_t
<span class="lineNum">   31667 </span><span class="lineNoCov">          0 : variable_value_hasher::hash (variable_value_struct *x)</span>
<span class="lineNum">   31668 </span>            : {
<span class="lineNum">   31669 </span><span class="lineCov">         20 :   return (hashval_t) x-&gt;decl_id;</span>
<span class="lineNum">   31670 </span>            : }
<span class="lineNum">   31671 </span>            : 
<span class="lineNum">   31672 </span>            : /* Return nonzero if decl_id of variable_value_struct X is the same as
<span class="lineNum">   31673 </span>            :    UID of decl Y.  */
<a name="31674"><span class="lineNum">   31674 </span>            : </a>
<span class="lineNum">   31675 </span>            : inline bool
<span class="lineNum">   31676 </span><span class="lineNoCov">          0 : variable_value_hasher::equal (variable_value_struct *x, tree y)</span>
<span class="lineNum">   31677 </span>            : {
<span class="lineNum">   31678 </span><span class="lineCov">        606 :   return x-&gt;decl_id == DECL_UID (y);</span>
<span class="lineNum">   31679 </span>            : }
<span class="lineNum">   31680 </span>            : 
<span class="lineNum">   31681 </span>            : /* Helper function for resolve_variable_value, handle
<span class="lineNum">   31682 </span>            :    DW_OP_GNU_variable_value in one location expression.
<span class="lineNum">   31683 </span>            :    Return true if exprloc has been changed into loclist.  */
<a name="31684"><span class="lineNum">   31684 </span>            : </a>
<span class="lineNum">   31685 </span>            : static bool
<span class="lineNum">   31686 </span><span class="lineCov">        454 : resolve_variable_value_in_expr (dw_attr_node *a, dw_loc_descr_ref loc)</span>
<span class="lineNum">   31687 </span>            : {
<span class="lineNum">   31688 </span><span class="lineCov">        454 :   dw_loc_descr_ref next;</span>
<span class="lineNum">   31689 </span><span class="lineCov">       1533 :   for (dw_loc_descr_ref prev = NULL; loc; prev = loc, loc = next)</span>
<span class="lineNum">   31690 </span>            :     {
<span class="lineNum">   31691 </span><span class="lineCov">       1079 :       next = loc-&gt;dw_loc_next;</span>
<span class="lineNum">   31692 </span><span class="lineCov">       1079 :       if (loc-&gt;dw_loc_opc != DW_OP_GNU_variable_value</span>
<span class="lineNum">   31693 </span><span class="lineCov">        454 :           || loc-&gt;dw_loc_oprnd1.val_class != dw_val_class_decl_ref)</span>
<span class="lineNum">   31694 </span>            :         continue;
<span class="lineNum">   31695 </span>            : 
<span class="lineNum">   31696 </span><span class="lineCov">        454 :       tree decl = loc-&gt;dw_loc_oprnd1.v.val_decl_ref;</span>
<span class="lineNum">   31697 </span><span class="lineCov">        454 :       if (DECL_CONTEXT (decl) != current_function_decl)</span>
<span class="lineNum">   31698 </span>            :         continue;
<span class="lineNum">   31699 </span>            : 
<span class="lineNum">   31700 </span><span class="lineCov">        454 :       dw_die_ref ref = lookup_decl_die (decl);</span>
<span class="lineNum">   31701 </span><span class="lineCov">        454 :       if (ref)</span>
<span class="lineNum">   31702 </span>            :         {
<span class="lineNum">   31703 </span><span class="lineNoCov">          0 :           loc-&gt;dw_loc_oprnd1.val_class = dw_val_class_die_ref;</span>
<span class="lineNum">   31704 </span><span class="lineNoCov">          0 :           loc-&gt;dw_loc_oprnd1.v.val_die_ref.die = ref;</span>
<span class="lineNum">   31705 </span><span class="lineNoCov">          0 :           loc-&gt;dw_loc_oprnd1.v.val_die_ref.external = 0;</span>
<span class="lineNum">   31706 </span><span class="lineNoCov">          0 :           continue;</span>
<span class="lineNum">   31707 </span>            :         }
<span class="lineNum">   31708 </span><span class="lineCov">        454 :       dw_loc_list_ref l = loc_list_from_tree (decl, 0, NULL);</span>
<span class="lineNum">   31709 </span><span class="lineCov">        454 :       if (l == NULL)</span>
<span class="lineNum">   31710 </span>            :         continue;
<span class="lineNum">   31711 </span><span class="lineCov">        372 :       if (l-&gt;dw_loc_next)</span>
<span class="lineNum">   31712 </span>            :         {
<span class="lineNum">   31713 </span><span class="lineCov">        176 :           if (AT_class (a) != dw_val_class_loc)</span>
<span class="lineNum">   31714 </span>            :             continue;
<span class="lineNum">   31715 </span><span class="lineCov">        176 :           switch (a-&gt;dw_attr)</span>
<span class="lineNum">   31716 </span>            :             {
<span class="lineNum">   31717 </span>            :             /* Following attributes allow both exprloc and loclist
<span class="lineNum">   31718 </span>            :                classes, so we can change them into a loclist.  */
<span class="lineNum">   31719 </span><span class="lineNoCov">          0 :             case DW_AT_location:</span>
<span class="lineNum">   31720 </span><span class="lineNoCov">          0 :             case DW_AT_string_length:</span>
<span class="lineNum">   31721 </span><span class="lineNoCov">          0 :             case DW_AT_return_addr:</span>
<span class="lineNum">   31722 </span><span class="lineNoCov">          0 :             case DW_AT_data_member_location:</span>
<span class="lineNum">   31723 </span><span class="lineNoCov">          0 :             case DW_AT_frame_base:</span>
<span class="lineNum">   31724 </span><span class="lineNoCov">          0 :             case DW_AT_segment:</span>
<span class="lineNum">   31725 </span><span class="lineNoCov">          0 :             case DW_AT_static_link:</span>
<span class="lineNum">   31726 </span><span class="lineNoCov">          0 :             case DW_AT_use_location:</span>
<span class="lineNum">   31727 </span><span class="lineNoCov">          0 :             case DW_AT_vtable_elem_location:</span>
<span class="lineNum">   31728 </span><span class="lineNoCov">          0 :               if (prev)</span>
<span class="lineNum">   31729 </span>            :                 {
<span class="lineNum">   31730 </span><span class="lineNoCov">          0 :                   prev-&gt;dw_loc_next = NULL;</span>
<span class="lineNum">   31731 </span><span class="lineNoCov">          0 :                   prepend_loc_descr_to_each (l, AT_loc (a));</span>
<span class="lineNum">   31732 </span>            :                 }
<span class="lineNum">   31733 </span><span class="lineNoCov">          0 :               if (next)</span>
<span class="lineNum">   31734 </span><span class="lineNoCov">          0 :                 add_loc_descr_to_each (l, next);</span>
<span class="lineNum">   31735 </span><span class="lineNoCov">          0 :               a-&gt;dw_attr_val.val_class = dw_val_class_loc_list;</span>
<span class="lineNum">   31736 </span><span class="lineNoCov">          0 :               a-&gt;dw_attr_val.val_entry = NULL;</span>
<span class="lineNum">   31737 </span><span class="lineNoCov">          0 :               a-&gt;dw_attr_val.v.val_loc_list = l;</span>
<span class="lineNum">   31738 </span><span class="lineNoCov">          0 :               have_location_lists = true;</span>
<span class="lineNum">   31739 </span><span class="lineNoCov">          0 :               return true;</span>
<span class="lineNum">   31740 </span>            :             /* Following attributes allow both exprloc and reference,
<span class="lineNum">   31741 </span>            :                so if the whole expression is DW_OP_GNU_variable_value alone
<span class="lineNum">   31742 </span>            :                we could transform it into reference.  */
<span class="lineNum">   31743 </span><span class="lineCov">        176 :             case DW_AT_byte_size:</span>
<span class="lineNum">   31744 </span><span class="lineCov">        176 :             case DW_AT_bit_size:</span>
<span class="lineNum">   31745 </span><span class="lineCov">        176 :             case DW_AT_lower_bound:</span>
<span class="lineNum">   31746 </span><span class="lineCov">        176 :             case DW_AT_upper_bound:</span>
<span class="lineNum">   31747 </span><span class="lineCov">        176 :             case DW_AT_bit_stride:</span>
<span class="lineNum">   31748 </span><span class="lineCov">        176 :             case DW_AT_count:</span>
<span class="lineNum">   31749 </span><span class="lineCov">        176 :             case DW_AT_allocated:</span>
<span class="lineNum">   31750 </span><span class="lineCov">        176 :             case DW_AT_associated:</span>
<span class="lineNum">   31751 </span><span class="lineCov">        176 :             case DW_AT_byte_stride:</span>
<span class="lineNum">   31752 </span><span class="lineCov">        176 :               if (prev == NULL &amp;&amp; next == NULL)</span>
<span class="lineNum">   31753 </span>            :                 break;
<span class="lineNum">   31754 </span>            :               /* FALLTHRU */
<span class="lineNum">   31755 </span><span class="lineNoCov">          0 :             default:</span>
<span class="lineNum">   31756 </span><span class="lineNoCov">          0 :               if (dwarf_strict)</span>
<span class="lineNum">   31757 </span>            :                 continue;
<span class="lineNum">   31758 </span>            :               break;
<span class="lineNum">   31759 </span>            :             }
<span class="lineNum">   31760 </span>            :           /* Create DW_TAG_variable that we can refer to.  */
<span class="lineNum">   31761 </span><span class="lineCov">        176 :           gen_decl_die (decl, NULL_TREE, NULL,</span>
<span class="lineNum">   31762 </span>            :                         lookup_decl_die (current_function_decl));
<span class="lineNum">   31763 </span><span class="lineCov">        176 :           ref = lookup_decl_die (decl);</span>
<span class="lineNum">   31764 </span><span class="lineCov">        176 :           if (ref)</span>
<span class="lineNum">   31765 </span>            :             {
<span class="lineNum">   31766 </span><span class="lineCov">        176 :               loc-&gt;dw_loc_oprnd1.val_class = dw_val_class_die_ref;</span>
<span class="lineNum">   31767 </span><span class="lineCov">        176 :               loc-&gt;dw_loc_oprnd1.v.val_die_ref.die = ref;</span>
<span class="lineNum">   31768 </span><span class="lineCov">        176 :               loc-&gt;dw_loc_oprnd1.v.val_die_ref.external = 0;</span>
<span class="lineNum">   31769 </span>            :             }
<span class="lineNum">   31770 </span><span class="lineCov">        176 :           continue;</span>
<span class="lineNum">   31771 </span>            :         }
<span class="lineNum">   31772 </span><span class="lineCov">        196 :       if (prev)</span>
<span class="lineNum">   31773 </span>            :         {
<span class="lineNum">   31774 </span><span class="lineNoCov">          0 :           prev-&gt;dw_loc_next = l-&gt;expr;</span>
<span class="lineNum">   31775 </span><span class="lineNoCov">          0 :           add_loc_descr (&amp;prev-&gt;dw_loc_next, next);</span>
<span class="lineNum">   31776 </span><span class="lineNoCov">          0 :           free_loc_descr (loc, NULL);</span>
<span class="lineNum">   31777 </span><span class="lineNoCov">          0 :           next = prev-&gt;dw_loc_next;</span>
<span class="lineNum">   31778 </span>            :         }
<span class="lineNum">   31779 </span>            :       else
<span class="lineNum">   31780 </span>            :         {
<span class="lineNum">   31781 </span><span class="lineCov">        196 :           memcpy (loc, l-&gt;expr, sizeof (dw_loc_descr_node));</span>
<span class="lineNum">   31782 </span><span class="lineCov">        196 :           add_loc_descr (&amp;loc, next);</span>
<span class="lineNum">   31783 </span><span class="lineCov">        196 :           next = loc;</span>
<span class="lineNum">   31784 </span>            :         }
<span class="lineNum">   31785 </span><span class="lineCov">        196 :       loc = prev;</span>
<span class="lineNum">   31786 </span>            :     }
<span class="lineNum">   31787 </span>            :   return false;
<span class="lineNum">   31788 </span>            : }
<span class="lineNum">   31789 </span>            : 
<span class="lineNum">   31790 </span>            : /* Attempt to resolve DW_OP_GNU_variable_value using loc_list_from_tree.  */
<a name="31791"><span class="lineNum">   31791 </span>            : </a>
<span class="lineNum">   31792 </span>            : static void
<span class="lineNum">   31793 </span><span class="lineCov">        454 : resolve_variable_value (dw_die_ref die)</span>
<span class="lineNum">   31794 </span>            : {
<span class="lineNum">   31795 </span><span class="lineCov">        454 :   dw_attr_node *a;</span>
<span class="lineNum">   31796 </span><span class="lineCov">        454 :   dw_loc_list_ref loc;</span>
<span class="lineNum">   31797 </span><span class="lineCov">        454 :   unsigned ix;</span>
<span class="lineNum">   31798 </span>            : 
<span class="lineNum">   31799 </span><span class="lineCov">       1362 :   FOR_EACH_VEC_SAFE_ELT (die-&gt;die_attr, ix, a)</span>
<span class="lineNum">   31800 </span><span class="lineCov">        908 :     switch (AT_class (a))</span>
<span class="lineNum">   31801 </span>            :       {
<span class="lineNum">   31802 </span><span class="lineCov">        454 :       case dw_val_class_loc:</span>
<span class="lineNum">   31803 </span><span class="lineCov">        454 :         if (!resolve_variable_value_in_expr (a, AT_loc (a)))</span>
<span class="lineNum">   31804 </span>            :           break;
<span class="lineNum">   31805 </span>            :         /* FALLTHRU */
<span class="lineNum">   31806 </span><span class="lineNoCov">          0 :       case dw_val_class_loc_list:</span>
<span class="lineNum">   31807 </span><span class="lineNoCov">          0 :         loc = AT_loc_list (a);</span>
<span class="lineNum">   31808 </span><span class="lineNoCov">          0 :         gcc_assert (loc);</span>
<span class="lineNum">   31809 </span><span class="lineNoCov">          0 :         for (; loc; loc = loc-&gt;dw_loc_next)</span>
<span class="lineNum">   31810 </span><span class="lineNoCov">          0 :           resolve_variable_value_in_expr (a, loc-&gt;expr);</span>
<span class="lineNum">   31811 </span>            :         break;
<span class="lineNum">   31812 </span>            :       default:
<span class="lineNum">   31813 </span>            :         break;
<span class="lineNum">   31814 </span>            :       }
<span class="lineNum">   31815 </span><span class="lineCov">        454 : }</span>
<span class="lineNum">   31816 </span>            : 
<span class="lineNum">   31817 </span>            : /* Attempt to optimize DW_OP_GNU_variable_value refering to
<span class="lineNum">   31818 </span>            :    temporaries in the current function.  */
<a name="31819"><span class="lineNum">   31819 </span>            : </a>
<span class="lineNum">   31820 </span>            : static void
<span class="lineNum">   31821 </span><span class="lineCov">     339893 : resolve_variable_values (void)</span>
<span class="lineNum">   31822 </span>            : {
<span class="lineNum">   31823 </span><span class="lineCov">     339893 :   if (!variable_value_hash || !current_function_decl)</span>
<span class="lineNum">   31824 </span>            :     return;
<span class="lineNum">   31825 </span>            : 
<span class="lineNum">   31826 </span><span class="lineCov">       1115 :   struct variable_value_struct *node</span>
<span class="lineNum">   31827 </span>            :     = variable_value_hash-&gt;find_with_hash (current_function_decl,
<span class="lineNum">   31828 </span><span class="lineCov">       1115 :                                            DECL_UID (current_function_decl));</span>
<span class="lineNum">   31829 </span>            : 
<span class="lineNum">   31830 </span><span class="lineCov">       1115 :   if (node == NULL)</span>
<span class="lineNum">   31831 </span>            :     return;
<span class="lineNum">   31832 </span>            : 
<span class="lineNum">   31833 </span>            :   unsigned int i;
<span class="lineNum">   31834 </span>            :   dw_die_ref die;
<span class="lineNum">   31835 </span><span class="lineCov">        829 :   FOR_EACH_VEC_SAFE_ELT (node-&gt;dies, i, die)</span>
<span class="lineNum">   31836 </span><span class="lineCov">        454 :     resolve_variable_value (die);</span>
<span class="lineNum">   31837 </span>            : }
<span class="lineNum">   31838 </span>            : 
<span class="lineNum">   31839 </span>            : /* Helper function for note_variable_value, handle one location
<span class="lineNum">   31840 </span>            :    expression.  */
<a name="31841"><span class="lineNum">   31841 </span>            : </a>
<span class="lineNum">   31842 </span>            : static void
<span class="lineNum">   31843 </span><span class="lineCov">      58903 : note_variable_value_in_expr (dw_die_ref die, dw_loc_descr_ref loc)</span>
<span class="lineNum">   31844 </span>            : {
<span class="lineNum">   31845 </span><span class="lineCov">     197267 :   for (; loc; loc = loc-&gt;dw_loc_next)</span>
<span class="lineNum">   31846 </span><span class="lineCov">     138364 :     if (loc-&gt;dw_loc_opc == DW_OP_GNU_variable_value</span>
<span class="lineNum">   31847 </span><span class="lineCov">       3040 :         &amp;&amp; loc-&gt;dw_loc_oprnd1.val_class == dw_val_class_decl_ref)</span>
<span class="lineNum">   31848 </span>            :       {
<span class="lineNum">   31849 </span><span class="lineCov">        554 :         tree decl = loc-&gt;dw_loc_oprnd1.v.val_decl_ref;</span>
<span class="lineNum">   31850 </span><span class="lineCov">        554 :         dw_die_ref ref = lookup_decl_die (decl);</span>
<span class="lineNum">   31851 </span><span class="lineCov">        554 :         if (! ref &amp;&amp; (flag_generate_lto || flag_generate_offload))</span>
<span class="lineNum">   31852 </span>            :           {
<span class="lineNum">   31853 </span>            :             /* ???  This is somewhat a hack because we do not create DIEs
<span class="lineNum">   31854 </span>            :                for variables not in BLOCK trees early but when generating
<span class="lineNum">   31855 </span>            :                early LTO output we need the dw_val_class_decl_ref to be
<span class="lineNum">   31856 </span>            :                fully resolved.  For fat LTO objects we'd also like to
<span class="lineNum">   31857 </span>            :                undo this after LTO dwarf output.  */
<span class="lineNum">   31858 </span><span class="lineCov">         61 :             gcc_assert (DECL_CONTEXT (decl));</span>
<span class="lineNum">   31859 </span><span class="lineCov">        122 :             dw_die_ref ctx = lookup_decl_die (DECL_CONTEXT (decl));</span>
<span class="lineNum">   31860 </span><span class="lineCov">         61 :             gcc_assert (ctx != NULL);</span>
<span class="lineNum">   31861 </span><span class="lineCov">         61 :             gen_decl_die (decl, NULL_TREE, NULL, ctx);</span>
<span class="lineNum">   31862 </span><span class="lineCov">         61 :             ref = lookup_decl_die (decl);</span>
<span class="lineNum">   31863 </span><span class="lineCov">         61 :             gcc_assert (ref != NULL);</span>
<span class="lineNum">   31864 </span>            :           }
<span class="lineNum">   31865 </span><span class="lineCov">        554 :         if (ref)</span>
<span class="lineNum">   31866 </span>            :           {
<span class="lineNum">   31867 </span><span class="lineCov">         61 :             loc-&gt;dw_loc_oprnd1.val_class = dw_val_class_die_ref;</span>
<span class="lineNum">   31868 </span><span class="lineCov">         61 :             loc-&gt;dw_loc_oprnd1.v.val_die_ref.die = ref;</span>
<span class="lineNum">   31869 </span><span class="lineCov">         61 :             loc-&gt;dw_loc_oprnd1.v.val_die_ref.external = 0;</span>
<span class="lineNum">   31870 </span><span class="lineCov">         61 :             continue;</span>
<span class="lineNum">   31871 </span>            :           }
<span class="lineNum">   31872 </span><span class="lineCov">        493 :         if (VAR_P (decl)</span>
<span class="lineNum">   31873 </span><span class="lineCov">        493 :             &amp;&amp; DECL_CONTEXT (decl)</span>
<span class="lineNum">   31874 </span><span class="lineCov">        986 :             &amp;&amp; TREE_CODE (DECL_CONTEXT (decl)) == FUNCTION_DECL</span>
<span class="lineNum">   31875 </span><span class="lineCov">       1479 :             &amp;&amp; lookup_decl_die (DECL_CONTEXT (decl)))</span>
<span class="lineNum">   31876 </span>            :           {
<span class="lineNum">   31877 </span><span class="lineCov">        493 :             if (!variable_value_hash)</span>
<span class="lineNum">   31878 </span><span class="lineCov">        331 :               variable_value_hash</span>
<span class="lineNum">   31879 </span><span class="lineCov">        331 :                 = hash_table&lt;variable_value_hasher&gt;::create_ggc (10);</span>
<span class="lineNum">   31880 </span>            : 
<span class="lineNum">   31881 </span><span class="lineCov">        493 :             tree fndecl = DECL_CONTEXT (decl);</span>
<span class="lineNum">   31882 </span><span class="lineCov">        493 :             struct variable_value_struct *node;</span>
<span class="lineNum">   31883 </span><span class="lineCov">        493 :             struct variable_value_struct **slot</span>
<span class="lineNum">   31884 </span><span class="lineCov">       1479 :               = variable_value_hash-&gt;find_slot_with_hash (fndecl,</span>
<span class="lineNum">   31885 </span><span class="lineCov">        493 :                                                           DECL_UID (fndecl),</span>
<span class="lineNum">   31886 </span>            :                                                           INSERT);
<span class="lineNum">   31887 </span><span class="lineCov">        493 :             if (*slot == NULL)</span>
<span class="lineNum">   31888 </span>            :               {
<span class="lineNum">   31889 </span><span class="lineCov">        410 :                 node = ggc_cleared_alloc&lt;variable_value_struct&gt; ();</span>
<span class="lineNum">   31890 </span><span class="lineCov">        410 :                 node-&gt;decl_id = DECL_UID (fndecl);</span>
<span class="lineNum">   31891 </span><span class="lineCov">        410 :                 *slot = node;</span>
<span class="lineNum">   31892 </span>            :               }
<span class="lineNum">   31893 </span>            :             else
<span class="lineNum">   31894 </span>            :               node = *slot;
<span class="lineNum">   31895 </span>            : 
<span class="lineNum">   31896 </span><span class="lineCov">        493 :             vec_safe_push (node-&gt;dies, die);</span>
<span class="lineNum">   31897 </span>            :           }
<span class="lineNum">   31898 </span>            :       }
<span class="lineNum">   31899 </span><span class="lineCov">      58903 : }</span>
<span class="lineNum">   31900 </span>            : 
<span class="lineNum">   31901 </span>            : /* Walk the tree DIE and note DIEs with DW_OP_GNU_variable_value still
<span class="lineNum">   31902 </span>            :    with dw_val_class_decl_ref operand.  */
<a name="31903"><span class="lineNum">   31903 </span>            : </a>
<span class="lineNum">   31904 </span>            : static void
<span class="lineNum">   31905 </span><span class="lineCov">   32111159 : note_variable_value (dw_die_ref die)</span>
<span class="lineNum">   31906 </span>            : {
<span class="lineNum">   31907 </span><span class="lineCov">   32111159 :   dw_die_ref c;</span>
<span class="lineNum">   31908 </span><span class="lineCov">   32111159 :   dw_attr_node *a;</span>
<span class="lineNum">   31909 </span><span class="lineCov">   32111159 :   dw_loc_list_ref loc;</span>
<span class="lineNum">   31910 </span><span class="lineCov">   32111159 :   unsigned ix;</span>
<span class="lineNum">   31911 </span>            : 
<span class="lineNum">   31912 </span><span class="lineCov">  154643836 :   FOR_EACH_VEC_SAFE_ELT (die-&gt;die_attr, ix, a)</span>
<span class="lineNum">   31913 </span><span class="lineCov">  122532677 :     switch (AT_class (a))</span>
<span class="lineNum">   31914 </span>            :       {
<span class="lineNum">   31915 </span><span class="lineNoCov">          0 :       case dw_val_class_loc_list:</span>
<span class="lineNum">   31916 </span><span class="lineNoCov">          0 :         loc = AT_loc_list (a);</span>
<span class="lineNum">   31917 </span><span class="lineNoCov">          0 :         gcc_assert (loc);</span>
<span class="lineNum">   31918 </span><span class="lineNoCov">          0 :         if (!loc-&gt;noted_variable_value)</span>
<span class="lineNum">   31919 </span>            :           {
<span class="lineNum">   31920 </span><span class="lineNoCov">          0 :             loc-&gt;noted_variable_value = 1;</span>
<span class="lineNum">   31921 </span><span class="lineNoCov">          0 :             for (; loc; loc = loc-&gt;dw_loc_next)</span>
<span class="lineNum">   31922 </span><span class="lineNoCov">          0 :               note_variable_value_in_expr (die, loc-&gt;expr);</span>
<span class="lineNum">   31923 </span>            :           }
<span class="lineNum">   31924 </span>            :         break;
<span class="lineNum">   31925 </span><span class="lineCov">      58903 :       case dw_val_class_loc:</span>
<span class="lineNum">   31926 </span><span class="lineCov">      58903 :         note_variable_value_in_expr (die, AT_loc (a));</span>
<span class="lineNum">   31927 </span><span class="lineCov">      58903 :         break;</span>
<span class="lineNum">   31928 </span>            :       default:
<span class="lineNum">   31929 </span>            :         break;
<span class="lineNum">   31930 </span>            :       }
<span class="lineNum">   31931 </span>            : 
<span class="lineNum">   31932 </span>            :   /* Mark children.  */
<span class="lineNum">   31933 </span><span class="lineCov">   64188666 :   FOR_EACH_CHILD (die, c, note_variable_value (c));</span>
<span class="lineNum">   31934 </span><span class="lineCov">   32111159 : }</span>
<span class="lineNum">   31935 </span>            : 
<span class="lineNum">   31936 </span>            : /* Perform any cleanups needed after the early debug generation pass
<span class="lineNum">   31937 </span>            :    has run.  */
<a name="31938"><span class="lineNum">   31938 </span>            : </a>
<span class="lineNum">   31939 </span>            : static void
<span class="lineNum">   31940 </span><span class="lineCov">      34141 : dwarf2out_early_finish (const char *filename)</span>
<span class="lineNum">   31941 </span>            : {
<span class="lineNum">   31942 </span><span class="lineCov">      34141 :   set_early_dwarf s;</span>
<span class="lineNum">   31943 </span><span class="lineCov">      34141 :   char dl_section_ref[MAX_ARTIFICIAL_LABEL_BYTES];</span>
<span class="lineNum">   31944 </span>            : 
<span class="lineNum">   31945 </span>            :   /* PCH might result in DW_AT_producer string being restored from the
<span class="lineNum">   31946 </span>            :      header compilation, so always fill it with empty string initially
<span class="lineNum">   31947 </span>            :      and overwrite only here.  */
<span class="lineNum">   31948 </span><span class="lineCov">      34237 :   dw_attr_node *producer = get_AT (comp_unit_die (), DW_AT_producer);</span>
<span class="lineNum">   31949 </span><span class="lineCov">      34141 :   producer_string = gen_producer_string ();</span>
<span class="lineNum">   31950 </span><span class="lineCov">      34141 :   producer-&gt;dw_attr_val.v.val_str-&gt;refcount--;</span>
<span class="lineNum">   31951 </span><span class="lineCov">      34141 :   producer-&gt;dw_attr_val.v.val_str = find_AT_string (producer_string);</span>
<span class="lineNum">   31952 </span>            : 
<span class="lineNum">   31953 </span>            :   /* Add the name for the main input file now.  We delayed this from
<span class="lineNum">   31954 </span>            :      dwarf2out_init to avoid complications with PCH.  */
<span class="lineNum">   31955 </span><span class="lineCov">      34141 :   add_name_attribute (comp_unit_die (), remap_debug_filename (filename));</span>
<span class="lineNum">   31956 </span><span class="lineCov">      34141 :   add_comp_dir_attribute (comp_unit_die ());</span>
<span class="lineNum">   31957 </span>            : 
<span class="lineNum">   31958 </span>            :   /* When emitting DWARF5 .debug_line_str, move DW_AT_name and
<span class="lineNum">   31959 </span>            :      DW_AT_comp_dir into .debug_line_str section.  */
<span class="lineNum">   31960 </span><span class="lineCov">      34141 :   if (!output_asm_line_debug_info ()</span>
<span class="lineNum">   31961 </span><span class="lineNoCov">          0 :       &amp;&amp; dwarf_version &gt;= 5</span>
<span class="lineNum">   31962 </span><span class="lineNoCov">          0 :       &amp;&amp; DWARF5_USE_DEBUG_LINE_STR)</span>
<span class="lineNum">   31963 </span>            :     {
<span class="lineNum">   31964 </span><span class="lineNoCov">          0 :       for (int i = 0; i &lt; 2; i++)</span>
<span class="lineNum">   31965 </span>            :         {
<span class="lineNum">   31966 </span><span class="lineNoCov">          0 :           dw_attr_node *a = get_AT (comp_unit_die (),</span>
<span class="lineNum">   31967 </span>            :                                     i ? DW_AT_comp_dir : DW_AT_name);
<span class="lineNum">   31968 </span><span class="lineNoCov">          0 :           if (a == NULL</span>
<span class="lineNum">   31969 </span><span class="lineNoCov">          0 :               || AT_class (a) != dw_val_class_str</span>
<span class="lineNum">   31970 </span><span class="lineNoCov">          0 :               || strlen (AT_string (a)) + 1 &lt;= DWARF_OFFSET_SIZE)</span>
<span class="lineNum">   31971 </span>            :             continue;
<span class="lineNum">   31972 </span>            : 
<span class="lineNum">   31973 </span><span class="lineNoCov">          0 :           if (! debug_line_str_hash)</span>
<span class="lineNum">   31974 </span><span class="lineNoCov">          0 :             debug_line_str_hash</span>
<span class="lineNum">   31975 </span><span class="lineNoCov">          0 :               = hash_table&lt;indirect_string_hasher&gt;::create_ggc (10);</span>
<span class="lineNum">   31976 </span>            : 
<span class="lineNum">   31977 </span><span class="lineNoCov">          0 :           struct indirect_string_node *node</span>
<span class="lineNum">   31978 </span><span class="lineNoCov">          0 :             = find_AT_string_in_table (AT_string (a), debug_line_str_hash);</span>
<span class="lineNum">   31979 </span><span class="lineNoCov">          0 :           set_indirect_string (node);</span>
<span class="lineNum">   31980 </span><span class="lineNoCov">          0 :           node-&gt;form = DW_FORM_line_strp;</span>
<span class="lineNum">   31981 </span><span class="lineNoCov">          0 :           a-&gt;dw_attr_val.v.val_str-&gt;refcount--;</span>
<span class="lineNum">   31982 </span><span class="lineNoCov">          0 :           a-&gt;dw_attr_val.v.val_str = node;</span>
<span class="lineNum">   31983 </span>            :         }
<span class="lineNum">   31984 </span>            :     }
<span class="lineNum">   31985 </span>            : 
<span class="lineNum">   31986 </span>            :   /* With LTO early dwarf was really finished at compile-time, so make
<span class="lineNum">   31987 </span>            :      sure to adjust the phase after annotating the LTRANS CU DIE.  */
<span class="lineNum">   31988 </span><span class="lineCov">      34141 :   if (in_lto_p)</span>
<span class="lineNum">   31989 </span>            :     {
<span class="lineNum">   31990 </span><span class="lineCov">        537 :       early_dwarf_finished = true;</span>
<span class="lineNum">   31991 </span><span class="lineCov">        537 :       if (dump_file)</span>
<span class="lineNum">   31992 </span>            :         {
<span class="lineNum">   31993 </span><span class="lineNoCov">          0 :           fprintf (dump_file, &quot;LTO EARLY DWARF for %s\n&quot;, filename);</span>
<span class="lineNum">   31994 </span><span class="lineNoCov">          0 :           print_die (comp_unit_die (), dump_file);</span>
<span class="lineNum">   31995 </span>            :         }
<span class="lineNum">   31996 </span><span class="lineCov">      33333 :       return;</span>
<span class="lineNum">   31997 </span>            :     }
<span class="lineNum">   31998 </span>            : 
<span class="lineNum">   31999 </span>            :   /* Walk through the list of incomplete types again, trying once more to
<span class="lineNum">   32000 </span>            :      emit full debugging info for them.  */
<span class="lineNum">   32001 </span><span class="lineCov">      33604 :   retry_incomplete_types ();</span>
<span class="lineNum">   32002 </span>            : 
<span class="lineNum">   32003 </span>            :   /* The point here is to flush out the limbo list so that it is empty
<span class="lineNum">   32004 </span>            :      and we don't need to stream it for LTO.  */
<span class="lineNum">   32005 </span><span class="lineCov">      33604 :   flush_limbo_die_list ();</span>
<span class="lineNum">   32006 </span>            : 
<span class="lineNum">   32007 </span><span class="lineCov">      33604 :   gen_scheduled_generic_parms_dies ();</span>
<span class="lineNum">   32008 </span><span class="lineCov">      33604 :   gen_remaining_tmpl_value_param_die_attribute ();</span>
<span class="lineNum">   32009 </span>            : 
<span class="lineNum">   32010 </span>            :   /* Add DW_AT_linkage_name for all deferred DIEs.  */
<span class="lineNum">   32011 </span><span class="lineCov">   33951659 :   for (limbo_die_node *node = deferred_asm_name; node; node = node-&gt;next)</span>
<span class="lineNum">   32012 </span>            :     {
<span class="lineNum">   32013 </span><span class="lineCov">   33918055 :       tree decl = node-&gt;created_for;</span>
<span class="lineNum">   32014 </span><span class="lineCov">   33918055 :       if (DECL_ASSEMBLER_NAME (decl) != DECL_NAME (decl)</span>
<span class="lineNum">   32015 </span>            :           /* A missing DECL_ASSEMBLER_NAME can be a constant DIE that
<span class="lineNum">   32016 </span>            :              ended up in deferred_asm_name before we knew it was
<span class="lineNum">   32017 </span>            :              constant and never written to disk.  */
<span class="lineNum">   32018 </span><span class="lineCov">   33918055 :           &amp;&amp; DECL_ASSEMBLER_NAME (decl))</span>
<span class="lineNum">   32019 </span>            :         {
<span class="lineNum">   32020 </span><span class="lineCov">   32587877 :           add_linkage_attr (node-&gt;die, decl);</span>
<span class="lineNum">   32021 </span><span class="lineCov">   32587877 :           move_linkage_attr (node-&gt;die);</span>
<span class="lineNum">   32022 </span>            :         }
<span class="lineNum">   32023 </span>            :     }
<span class="lineNum">   32024 </span><span class="lineCov">      33604 :   deferred_asm_name = NULL;</span>
<span class="lineNum">   32025 </span>            : 
<span class="lineNum">   32026 </span><span class="lineCov">      33604 :   if (flag_eliminate_unused_debug_types)</span>
<span class="lineNum">   32027 </span><span class="lineCov">      33601 :     prune_unused_types ();</span>
<span class="lineNum">   32028 </span>            : 
<span class="lineNum">   32029 </span>            :   /* Generate separate COMDAT sections for type DIEs. */
<span class="lineNum">   32030 </span><span class="lineCov">      33604 :   if (use_debug_types)</span>
<span class="lineNum">   32031 </span>            :     {
<span class="lineNum">   32032 </span><span class="lineCov">         18 :       break_out_comdat_types (comp_unit_die ());</span>
<span class="lineNum">   32033 </span>            : 
<span class="lineNum">   32034 </span>            :       /* Each new type_unit DIE was added to the limbo die list when created.
<span class="lineNum">   32035 </span>            :          Since these have all been added to comdat_type_list, clear the
<span class="lineNum">   32036 </span>            :          limbo die list.  */
<span class="lineNum">   32037 </span><span class="lineCov">         18 :       limbo_die_list = NULL;</span>
<span class="lineNum">   32038 </span>            : 
<span class="lineNum">   32039 </span>            :       /* For each new comdat type unit, copy declarations for incomplete
<span class="lineNum">   32040 </span>            :          types to make the new unit self-contained (i.e., no direct
<span class="lineNum">   32041 </span>            :          references to the main compile unit).  */
<span class="lineNum">   32042 </span><span class="lineCov">         18 :       for (comdat_type_node *ctnode = comdat_type_list;</span>
<span class="lineNum">   32043 </span><span class="lineCov">         66 :            ctnode != NULL; ctnode = ctnode-&gt;next)</span>
<span class="lineNum">   32044 </span><span class="lineCov">         48 :         copy_decls_for_unworthy_types (ctnode-&gt;root_die);</span>
<span class="lineNum">   32045 </span><span class="lineCov">         18 :       copy_decls_for_unworthy_types (comp_unit_die ());</span>
<span class="lineNum">   32046 </span>            : 
<span class="lineNum">   32047 </span>            :       /* In the process of copying declarations from one unit to another,
<span class="lineNum">   32048 </span>            :          we may have left some declarations behind that are no longer
<span class="lineNum">   32049 </span>            :          referenced.  Prune them.  */
<span class="lineNum">   32050 </span><span class="lineCov">         18 :       prune_unused_types ();</span>
<span class="lineNum">   32051 </span>            :     }
<span class="lineNum">   32052 </span>            : 
<span class="lineNum">   32053 </span>            :   /* Traverse the DIE's and note DIEs with DW_OP_GNU_variable_value still
<span class="lineNum">   32054 </span>            :      with dw_val_class_decl_ref operand.  */
<span class="lineNum">   32055 </span><span class="lineCov">      33604 :   note_variable_value (comp_unit_die ());</span>
<span class="lineNum">   32056 </span><span class="lineCov">      33604 :   for (limbo_die_node *node = cu_die_list; node; node = node-&gt;next)</span>
<span class="lineNum">   32057 </span><span class="lineNoCov">          0 :     note_variable_value (node-&gt;die);</span>
<span class="lineNum">   32058 </span><span class="lineCov">      33652 :   for (comdat_type_node *ctnode = comdat_type_list; ctnode != NULL;</span>
<span class="lineNum">   32059 </span><span class="lineCov">         48 :        ctnode = ctnode-&gt;next)</span>
<span class="lineNum">   32060 </span><span class="lineCov">         48 :     note_variable_value (ctnode-&gt;root_die);</span>
<span class="lineNum">   32061 </span><span class="lineCov">      33604 :   for (limbo_die_node *node = limbo_die_list; node; node = node-&gt;next)</span>
<span class="lineNum">   32062 </span><span class="lineNoCov">          0 :     note_variable_value (node-&gt;die);</span>
<span class="lineNum">   32063 </span>            : 
<span class="lineNum">   32064 </span>            :   /* The AT_pubnames attribute needs to go in all skeleton dies, including
<span class="lineNum">   32065 </span>            :      both the main_cu and all skeleton TUs.  Making this call unconditional
<span class="lineNum">   32066 </span>            :      would end up either adding a second copy of the AT_pubnames attribute, or
<span class="lineNum">   32067 </span>            :      requiring a special case in add_top_level_skeleton_die_attrs.  */
<span class="lineNum">   32068 </span><span class="lineCov">      33604 :   if (!dwarf_split_debug_info)</span>
<span class="lineNum">   32069 </span><span class="lineCov">      33599 :     add_AT_pubnames (comp_unit_die ());</span>
<span class="lineNum">   32070 </span>            : 
<span class="lineNum">   32071 </span>            :   /* The early debug phase is now finished.  */
<span class="lineNum">   32072 </span><span class="lineCov">      33604 :   early_dwarf_finished = true;</span>
<span class="lineNum">   32073 </span><span class="lineCov">      33604 :   if (dump_file)</span>
<span class="lineNum">   32074 </span>            :     {
<span class="lineNum">   32075 </span><span class="lineCov">          4 :       fprintf (dump_file, &quot;EARLY DWARF for %s\n&quot;, filename);</span>
<span class="lineNum">   32076 </span><span class="lineCov">          4 :       print_die (comp_unit_die (), dump_file);</span>
<span class="lineNum">   32077 </span>            :     }
<span class="lineNum">   32078 </span>            : 
<span class="lineNum">   32079 </span>            :   /* Do not generate DWARF assembler now when not producing LTO bytecode.  */
<span class="lineNum">   32080 </span><span class="lineCov">      33604 :   if ((!flag_generate_lto &amp;&amp; !flag_generate_offload)</span>
<span class="lineNum">   32081 </span>            :       /* FIXME: Disable debug info generation for (PE-)COFF targets since the
<span class="lineNum">   32082 </span>            :          copy_lto_debug_sections operation of the simple object support in
<span class="lineNum">   32083 </span>            :          libiberty is not implemented for them yet.  */
<span class="lineNum">   32084 </span>            :       || TARGET_PECOFF || TARGET_COFF)
<span class="lineNum">   32085 </span>            :     return;
<span class="lineNum">   32086 </span>            : 
<span class="lineNum">   32087 </span>            :   /* Now as we are going to output for LTO initialize sections and labels
<span class="lineNum">   32088 </span>            :      to the LTO variants.  We don't need a random-seed postfix as other
<span class="lineNum">   32089 </span>            :      LTO sections as linking the LTO debug sections into one in a partial
<span class="lineNum">   32090 </span>            :      link is fine.  */
<span class="lineNum">   32091 </span><span class="lineCov">        808 :   init_sections_and_labels (true);</span>
<span class="lineNum">   32092 </span>            : 
<span class="lineNum">   32093 </span>            :   /* The output below is modeled after dwarf2out_finish with all
<span class="lineNum">   32094 </span>            :      location related output removed and some LTO specific changes.
<span class="lineNum">   32095 </span>            :      Some refactoring might make both smaller and easier to match up.  */
<span class="lineNum">   32096 </span>            : 
<span class="lineNum">   32097 </span>            :   /* Traverse the DIE's and add add sibling attributes to those DIE's
<span class="lineNum">   32098 </span>            :      that have children.  */
<span class="lineNum">   32099 </span><span class="lineCov">        808 :   add_sibling_attributes (comp_unit_die ());</span>
<span class="lineNum">   32100 </span><span class="lineCov">        808 :   for (limbo_die_node *node = limbo_die_list; node; node = node-&gt;next)</span>
<span class="lineNum">   32101 </span><span class="lineNoCov">          0 :     add_sibling_attributes (node-&gt;die);</span>
<span class="lineNum">   32102 </span><span class="lineCov">        808 :   for (comdat_type_node *ctnode = comdat_type_list;</span>
<span class="lineNum">   32103 </span><span class="lineCov">        808 :        ctnode != NULL; ctnode = ctnode-&gt;next)</span>
<span class="lineNum">   32104 </span><span class="lineNoCov">          0 :     add_sibling_attributes (ctnode-&gt;root_die);</span>
<span class="lineNum">   32105 </span>            : 
<span class="lineNum">   32106 </span>            :   /* AIX Assembler inserts the length, so adjust the reference to match the
<span class="lineNum">   32107 </span>            :      offset expected by debuggers.  */
<span class="lineNum">   32108 </span><span class="lineCov">        808 :   strcpy (dl_section_ref, debug_line_section_label);</span>
<span class="lineNum">   32109 </span><span class="lineCov">        808 :   if (XCOFF_DEBUGGING_INFO)</span>
<span class="lineNum">   32110 </span>            :     strcat (dl_section_ref, DWARF_INITIAL_LENGTH_SIZE_STR);
<span class="lineNum">   32111 </span>            : 
<span class="lineNum">   32112 </span><span class="lineCov">        808 :   if (debug_info_level &gt;= DINFO_LEVEL_TERSE)</span>
<span class="lineNum">   32113 </span><span class="lineCov">        808 :     add_AT_lineptr (comp_unit_die (), DW_AT_stmt_list, dl_section_ref);</span>
<span class="lineNum">   32114 </span>            : 
<span class="lineNum">   32115 </span><span class="lineCov">        808 :   if (have_macinfo)</span>
<span class="lineNum">   32116 </span><span class="lineCov">         18 :     add_AT_macptr (comp_unit_die (), DEBUG_MACRO_ATTRIBUTE,</span>
<span class="lineNum">   32117 </span>            :                    macinfo_section_label);
<span class="lineNum">   32118 </span>            : 
<span class="lineNum">   32119 </span><span class="lineCov">        808 :   save_macinfo_strings ();</span>
<span class="lineNum">   32120 </span>            : 
<span class="lineNum">   32121 </span><span class="lineCov">        808 :   if (dwarf_split_debug_info)</span>
<span class="lineNum">   32122 </span>            :     {
<span class="lineNum">   32123 </span><span class="lineCov">          1 :       unsigned int index = 0;</span>
<span class="lineNum">   32124 </span><span class="lineCov">          1 :       debug_str_hash-&gt;traverse_noresize&lt;unsigned int *, index_string&gt; (&amp;index);</span>
<span class="lineNum">   32125 </span>            :     }
<span class="lineNum">   32126 </span>            : 
<span class="lineNum">   32127 </span>            :   /* Output all of the compilation units.  We put the main one last so that
<span class="lineNum">   32128 </span>            :      the offsets are available to output_pubnames.  */
<span class="lineNum">   32129 </span><span class="lineCov">        808 :   for (limbo_die_node *node = limbo_die_list; node; node = node-&gt;next)</span>
<span class="lineNum">   32130 </span><span class="lineNoCov">          0 :     output_comp_unit (node-&gt;die, 0, NULL);</span>
<span class="lineNum">   32131 </span>            : 
<span class="lineNum">   32132 </span><span class="lineCov">       1616 :   hash_table&lt;comdat_type_hasher&gt; comdat_type_table (100);</span>
<span class="lineNum">   32133 </span><span class="lineCov">        808 :   for (comdat_type_node *ctnode = comdat_type_list;</span>
<span class="lineNum">   32134 </span><span class="lineCov">        808 :        ctnode != NULL; ctnode = ctnode-&gt;next)</span>
<span class="lineNum">   32135 </span>            :     {
<span class="lineNum">   32136 </span><span class="lineNoCov">          0 :       comdat_type_node **slot = comdat_type_table.find_slot (ctnode, INSERT);</span>
<span class="lineNum">   32137 </span>            : 
<span class="lineNum">   32138 </span>            :       /* Don't output duplicate types.  */
<span class="lineNum">   32139 </span><span class="lineNoCov">          0 :       if (*slot != HTAB_EMPTY_ENTRY)</span>
<span class="lineNum">   32140 </span>            :         continue;
<span class="lineNum">   32141 </span>            : 
<span class="lineNum">   32142 </span>            :       /* Add a pointer to the line table for the main compilation unit
<span class="lineNum">   32143 </span>            :          so that the debugger can make sense of DW_AT_decl_file
<span class="lineNum">   32144 </span>            :          attributes.  */
<span class="lineNum">   32145 </span><span class="lineNoCov">          0 :       if (debug_info_level &gt;= DINFO_LEVEL_TERSE)</span>
<span class="lineNum">   32146 </span><span class="lineNoCov">          0 :         add_AT_lineptr (ctnode-&gt;root_die, DW_AT_stmt_list,</span>
<span class="lineNum">   32147 </span><span class="lineNoCov">          0 :                         (!dwarf_split_debug_info</span>
<span class="lineNum">   32148 </span>            :                          ? debug_line_section_label
<span class="lineNum">   32149 </span>            :                          : debug_skeleton_line_section_label));
<span class="lineNum">   32150 </span>            : 
<span class="lineNum">   32151 </span><span class="lineNoCov">          0 :       output_comdat_type_unit (ctnode);</span>
<span class="lineNum">   32152 </span><span class="lineNoCov">          0 :       *slot = ctnode;</span>
<span class="lineNum">   32153 </span>            :     }
<span class="lineNum">   32154 </span>            : 
<span class="lineNum">   32155 </span>            :   /* Stick a unique symbol to the main debuginfo section.  */
<span class="lineNum">   32156 </span><span class="lineCov">        808 :   compute_comp_unit_symbol (comp_unit_die ());</span>
<span class="lineNum">   32157 </span>            : 
<span class="lineNum">   32158 </span>            :   /* Output the main compilation unit.  We always need it if only for
<span class="lineNum">   32159 </span>            :      the CU symbol.  */
<span class="lineNum">   32160 </span><span class="lineCov">        808 :   output_comp_unit (comp_unit_die (), true, NULL);</span>
<span class="lineNum">   32161 </span>            : 
<span class="lineNum">   32162 </span>            :   /* Output the abbreviation table.  */
<span class="lineNum">   32163 </span><span class="lineCov">        808 :   if (vec_safe_length (abbrev_die_table) != 1)</span>
<span class="lineNum">   32164 </span>            :     {
<span class="lineNum">   32165 </span><span class="lineCov">        808 :       switch_to_section (debug_abbrev_section);</span>
<span class="lineNum">   32166 </span><span class="lineCov">        808 :       ASM_OUTPUT_LABEL (asm_out_file, abbrev_section_label);</span>
<span class="lineNum">   32167 </span><span class="lineCov">        808 :       output_abbrev_section ();</span>
<span class="lineNum">   32168 </span>            :     }
<span class="lineNum">   32169 </span>            : 
<span class="lineNum">   32170 </span>            :   /* Have to end the macro section.  */
<span class="lineNum">   32171 </span><span class="lineCov">        808 :   if (have_macinfo)</span>
<span class="lineNum">   32172 </span>            :     {
<span class="lineNum">   32173 </span>            :       /* We have to save macinfo state if we need to output it again
<span class="lineNum">   32174 </span>            :          for the FAT part of the object.  */
<span class="lineNum">   32175 </span><span class="lineCov">          9 :       vec&lt;macinfo_entry, va_gc&gt; *saved_macinfo_table = macinfo_table;</span>
<span class="lineNum">   32176 </span><span class="lineCov">          9 :       if (flag_fat_lto_objects)</span>
<span class="lineNum">   32177 </span><span class="lineNoCov">          0 :         macinfo_table = macinfo_table-&gt;copy ();</span>
<span class="lineNum">   32178 </span>            : 
<span class="lineNum">   32179 </span><span class="lineCov">          9 :       switch_to_section (debug_macinfo_section);</span>
<span class="lineNum">   32180 </span><span class="lineCov">          9 :       ASM_OUTPUT_LABEL (asm_out_file, macinfo_section_label);</span>
<span class="lineNum">   32181 </span><span class="lineCov">          9 :       output_macinfo (debug_line_section_label, true);</span>
<span class="lineNum">   32182 </span><span class="lineCov">          9 :       dw2_asm_output_data (1, 0, &quot;End compilation unit&quot;);</span>
<span class="lineNum">   32183 </span>            : 
<span class="lineNum">   32184 </span><span class="lineCov">          9 :       if (flag_fat_lto_objects)</span>
<span class="lineNum">   32185 </span>            :         {
<span class="lineNum">   32186 </span><span class="lineNoCov">          0 :           vec_free (macinfo_table);</span>
<span class="lineNum">   32187 </span><span class="lineNoCov">          0 :           macinfo_table = saved_macinfo_table;</span>
<span class="lineNum">   32188 </span>            :         }
<span class="lineNum">   32189 </span>            :     }
<span class="lineNum">   32190 </span>            : 
<span class="lineNum">   32191 </span>            :   /* Emit a skeleton debug_line section.  */
<span class="lineNum">   32192 </span><span class="lineCov">        808 :   switch_to_section (debug_line_section);</span>
<span class="lineNum">   32193 </span><span class="lineCov">        808 :   ASM_OUTPUT_LABEL (asm_out_file, debug_line_section_label);</span>
<span class="lineNum">   32194 </span><span class="lineCov">        808 :   output_line_info (true);</span>
<span class="lineNum">   32195 </span>            : 
<span class="lineNum">   32196 </span>            :   /* If we emitted any indirect strings, output the string table too.  */
<span class="lineNum">   32197 </span><span class="lineCov">        808 :   if (debug_str_hash || skeleton_debug_str_hash)</span>
<span class="lineNum">   32198 </span><span class="lineCov">        808 :     output_indirect_strings ();</span>
<span class="lineNum">   32199 </span><span class="lineCov">        808 :   if (debug_line_str_hash)</span>
<span class="lineNum">   32200 </span>            :     {
<span class="lineNum">   32201 </span><span class="lineCov">          3 :       switch_to_section (debug_line_str_section);</span>
<span class="lineNum">   32202 </span><span class="lineCov">          3 :       const enum dwarf_form form = DW_FORM_line_strp;</span>
<span class="lineNum">   32203 </span><span class="lineCov">          3 :       debug_line_str_hash-&gt;traverse&lt;enum dwarf_form,</span>
<span class="lineNum">   32204 </span><span class="lineCov">          3 :                                     output_indirect_string&gt; (form);</span>
<span class="lineNum">   32205 </span>            :     }
<span class="lineNum">   32206 </span>            : 
<span class="lineNum">   32207 </span>            :   /* Switch back to the text section.  */
<span class="lineNum">   32208 </span><span class="lineCov">        808 :   switch_to_section (text_section);</span>
<span class="lineNum">   32209 </span>            : }
<span class="lineNum">   32210 </span>            : 
<span class="lineNum">   32211 </span>            : /* Reset all state within dwarf2out.c so that we can rerun the compiler
<span class="lineNum">   32212 </span>            :    within the same process.  For use by toplev::finalize.  */
<a name="32213"><span class="lineNum">   32213 </span>            : </a>
<span class="lineNum">   32214 </span>            : void
<span class="lineNum">   32215 </span><span class="lineCov">        853 : dwarf2out_c_finalize (void)</span>
<span class="lineNum">   32216 </span>            : {
<span class="lineNum">   32217 </span><span class="lineCov">        853 :   last_var_location_insn = NULL;</span>
<span class="lineNum">   32218 </span><span class="lineCov">        853 :   cached_next_real_insn = NULL;</span>
<span class="lineNum">   32219 </span><span class="lineCov">        853 :   used_rtx_array = NULL;</span>
<span class="lineNum">   32220 </span><span class="lineCov">        853 :   incomplete_types = NULL;</span>
<span class="lineNum">   32221 </span><span class="lineCov">        853 :   debug_info_section = NULL;</span>
<span class="lineNum">   32222 </span><span class="lineCov">        853 :   debug_skeleton_info_section = NULL;</span>
<span class="lineNum">   32223 </span><span class="lineCov">        853 :   debug_abbrev_section = NULL;</span>
<span class="lineNum">   32224 </span><span class="lineCov">        853 :   debug_skeleton_abbrev_section = NULL;</span>
<span class="lineNum">   32225 </span><span class="lineCov">        853 :   debug_aranges_section = NULL;</span>
<span class="lineNum">   32226 </span><span class="lineCov">        853 :   debug_addr_section = NULL;</span>
<span class="lineNum">   32227 </span><span class="lineCov">        853 :   debug_macinfo_section = NULL;</span>
<span class="lineNum">   32228 </span><span class="lineCov">        853 :   debug_line_section = NULL;</span>
<span class="lineNum">   32229 </span><span class="lineCov">        853 :   debug_skeleton_line_section = NULL;</span>
<span class="lineNum">   32230 </span><span class="lineCov">        853 :   debug_loc_section = NULL;</span>
<span class="lineNum">   32231 </span><span class="lineCov">        853 :   debug_pubnames_section = NULL;</span>
<span class="lineNum">   32232 </span><span class="lineCov">        853 :   debug_pubtypes_section = NULL;</span>
<span class="lineNum">   32233 </span><span class="lineCov">        853 :   debug_str_section = NULL;</span>
<span class="lineNum">   32234 </span><span class="lineCov">        853 :   debug_line_str_section = NULL;</span>
<span class="lineNum">   32235 </span><span class="lineCov">        853 :   debug_str_dwo_section = NULL;</span>
<span class="lineNum">   32236 </span><span class="lineCov">        853 :   debug_str_offsets_section = NULL;</span>
<span class="lineNum">   32237 </span><span class="lineCov">        853 :   debug_ranges_section = NULL;</span>
<span class="lineNum">   32238 </span><span class="lineCov">        853 :   debug_frame_section = NULL;</span>
<span class="lineNum">   32239 </span><span class="lineCov">        853 :   fde_vec = NULL;</span>
<span class="lineNum">   32240 </span><span class="lineCov">        853 :   debug_str_hash = NULL;</span>
<span class="lineNum">   32241 </span><span class="lineCov">        853 :   debug_line_str_hash = NULL;</span>
<span class="lineNum">   32242 </span><span class="lineCov">        853 :   skeleton_debug_str_hash = NULL;</span>
<span class="lineNum">   32243 </span><span class="lineCov">        853 :   dw2_string_counter = 0;</span>
<span class="lineNum">   32244 </span><span class="lineCov">        853 :   have_multiple_function_sections = false;</span>
<span class="lineNum">   32245 </span><span class="lineCov">        853 :   text_section_used = false;</span>
<span class="lineNum">   32246 </span><span class="lineCov">        853 :   cold_text_section_used = false;</span>
<span class="lineNum">   32247 </span><span class="lineCov">        853 :   cold_text_section = NULL;</span>
<span class="lineNum">   32248 </span><span class="lineCov">        853 :   current_unit_personality = NULL;</span>
<span class="lineNum">   32249 </span>            : 
<span class="lineNum">   32250 </span><span class="lineCov">        853 :   early_dwarf = false;</span>
<span class="lineNum">   32251 </span><span class="lineCov">        853 :   early_dwarf_finished = false;</span>
<span class="lineNum">   32252 </span>            : 
<span class="lineNum">   32253 </span><span class="lineCov">        853 :   next_die_offset = 0;</span>
<span class="lineNum">   32254 </span><span class="lineCov">        853 :   single_comp_unit_die = NULL;</span>
<span class="lineNum">   32255 </span><span class="lineCov">        853 :   comdat_type_list = NULL;</span>
<span class="lineNum">   32256 </span><span class="lineCov">        853 :   limbo_die_list = NULL;</span>
<span class="lineNum">   32257 </span><span class="lineCov">        853 :   file_table = NULL;</span>
<span class="lineNum">   32258 </span><span class="lineCov">        853 :   decl_die_table = NULL;</span>
<span class="lineNum">   32259 </span><span class="lineCov">        853 :   common_block_die_table = NULL;</span>
<span class="lineNum">   32260 </span><span class="lineCov">        853 :   decl_loc_table = NULL;</span>
<span class="lineNum">   32261 </span><span class="lineCov">        853 :   call_arg_locations = NULL;</span>
<span class="lineNum">   32262 </span><span class="lineCov">        853 :   call_arg_loc_last = NULL;</span>
<span class="lineNum">   32263 </span><span class="lineCov">        853 :   call_site_count = -1;</span>
<span class="lineNum">   32264 </span><span class="lineCov">        853 :   tail_call_site_count = -1;</span>
<span class="lineNum">   32265 </span><span class="lineCov">        853 :   cached_dw_loc_list_table = NULL;</span>
<span class="lineNum">   32266 </span><span class="lineCov">        853 :   abbrev_die_table = NULL;</span>
<span class="lineNum">   32267 </span><span class="lineCov">        853 :   delete dwarf_proc_stack_usage_map;</span>
<span class="lineNum">   32268 </span><span class="lineCov">        853 :   dwarf_proc_stack_usage_map = NULL;</span>
<span class="lineNum">   32269 </span><span class="lineCov">        853 :   line_info_label_num = 0;</span>
<span class="lineNum">   32270 </span><span class="lineCov">        853 :   cur_line_info_table = NULL;</span>
<span class="lineNum">   32271 </span><span class="lineCov">        853 :   text_section_line_info = NULL;</span>
<span class="lineNum">   32272 </span><span class="lineCov">        853 :   cold_text_section_line_info = NULL;</span>
<span class="lineNum">   32273 </span><span class="lineCov">        853 :   separate_line_info = NULL;</span>
<span class="lineNum">   32274 </span><span class="lineCov">        853 :   info_section_emitted = false;</span>
<span class="lineNum">   32275 </span><span class="lineCov">        853 :   pubname_table = NULL;</span>
<span class="lineNum">   32276 </span><span class="lineCov">        853 :   pubtype_table = NULL;</span>
<span class="lineNum">   32277 </span><span class="lineCov">        853 :   macinfo_table = NULL;</span>
<span class="lineNum">   32278 </span><span class="lineCov">        853 :   ranges_table = NULL;</span>
<span class="lineNum">   32279 </span><span class="lineCov">        853 :   ranges_by_label = NULL;</span>
<span class="lineNum">   32280 </span><span class="lineCov">        853 :   rnglist_idx = 0;</span>
<span class="lineNum">   32281 </span><span class="lineCov">        853 :   have_location_lists = false;</span>
<span class="lineNum">   32282 </span><span class="lineCov">        853 :   loclabel_num = 0;</span>
<span class="lineNum">   32283 </span><span class="lineCov">        853 :   poc_label_num = 0;</span>
<span class="lineNum">   32284 </span><span class="lineCov">        853 :   last_emitted_file = NULL;</span>
<span class="lineNum">   32285 </span><span class="lineCov">        853 :   label_num = 0;</span>
<span class="lineNum">   32286 </span><span class="lineCov">        853 :   tmpl_value_parm_die_table = NULL;</span>
<span class="lineNum">   32287 </span><span class="lineCov">        853 :   generic_type_instances = NULL;</span>
<span class="lineNum">   32288 </span><span class="lineCov">        853 :   frame_pointer_fb_offset = 0;</span>
<span class="lineNum">   32289 </span><span class="lineCov">        853 :   frame_pointer_fb_offset_valid = false;</span>
<span class="lineNum">   32290 </span><span class="lineCov">        853 :   base_types.release ();</span>
<span class="lineNum">   32291 </span><span class="lineCov">        853 :   XDELETEVEC (producer_string);</span>
<span class="lineNum">   32292 </span><span class="lineCov">        853 :   producer_string = NULL;</span>
<span class="lineNum">   32293 </span><span class="lineCov">        853 : }</span>
<span class="lineNum">   32294 </span>            : 
<span class="lineNum">   32295 </span>            : #include &quot;gt-dwarf2out.h&quot;
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.0</a></td></tr>
  </table>
  <br>
<h3>LCOV profile is generated on x86_64 machine using following configure options: configure --disable-bootstrap --enable-coverage=opt --enable-languages=c,c++,fortran,go,jit,lto --enable-host-shared. GCC test suite is run with the built compiler.</h3></body></html>
