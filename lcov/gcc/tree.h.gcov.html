<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - gcc.info - gcc/tree.h</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">gcc</a> - tree.h<span style="font-size: 80%;"> (source / <a href="tree.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">gcc.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">495</td>
            <td class="headerCovTableEntry">619</td>
            <td class="headerCovTableEntryMed">80.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-09-22 10:58:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">85</td>
            <td class="headerCovTableEntry">114</td>
            <td class="headerCovTableEntryLo">74.6 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Definitions for the ubiquitous 'tree' type for GNU compilers.</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 1989-2018 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            : This file is part of GCC.
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : GCC is free software; you can redistribute it and/or modify it under
<span class="lineNum">       7 </span>            : the terms of the GNU General Public License as published by the Free
<span class="lineNum">       8 </span>            : Software Foundation; either version 3, or (at your option) any later
<span class="lineNum">       9 </span>            : version.
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : GCC is distributed in the hope that it will be useful, but WITHOUT ANY
<span class="lineNum">      12 </span>            : WARRANTY; without even the implied warranty of MERCHANTABILITY or
<span class="lineNum">      13 </span>            : FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
<span class="lineNum">      14 </span>            : for more details.
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : You should have received a copy of the GNU General Public License
<span class="lineNum">      17 </span>            : along with GCC; see the file COPYING3.  If not see
<span class="lineNum">      18 </span>            : &lt;http://www.gnu.org/licenses/&gt;.  */
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : #ifndef GCC_TREE_H
<span class="lineNum">      21 </span>            : #define GCC_TREE_H
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            : #include &quot;tree-core.h&quot;
<span class="lineNum">      24 </span>            : 
<span class="lineNum">      25 </span>            : /* Convert a target-independent built-in function code to a combined_fn.  */
<span class="lineNum">      26 </span>            : 
<span class="lineNum">      27 </span>            : inline combined_fn
<span class="lineNum">      28 </span>            : as_combined_fn (built_in_function fn)
<span class="lineNum">      29 </span>            : {
<span class="lineNum">      30 </span><span class="lineCov">   22030491 :   return combined_fn (int (fn));</span>
<span class="lineNum">      31 </span>            : }
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span>            : /* Convert an internal function code to a combined_fn.  */
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : inline combined_fn
<span class="lineNum">      36 </span>            : as_combined_fn (internal_fn fn)
<span class="lineNum">      37 </span>            : {
<span class="lineNum">      38 </span><span class="lineCov">    2888525 :   return combined_fn (int (fn) + int (END_BUILTINS));</span>
<span class="lineNum">      39 </span>            : }
<span class="lineNum">      40 </span>            : 
<span class="lineNum">      41 </span>            : /* Return true if CODE is a target-independent built-in function.  */
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            : inline bool
<span class="lineNum">      44 </span>            : builtin_fn_p (combined_fn code)
<span class="lineNum">      45 </span>            : {
<span class="lineNum">      46 </span><span class="lineCov">       7555 :   return int (code) &lt; int (END_BUILTINS);</span>
<span class="lineNum">      47 </span>            : }
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            : /* Return the target-independent built-in function represented by CODE.
<span class="lineNum">      50 </span>            :    Only valid if builtin_fn_p (CODE).  */
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            : inline built_in_function
<span class="lineNum">      53 </span>            : as_builtin_fn (combined_fn code)
<span class="lineNum">      54 </span>            : {
<span class="lineNum">      55 </span><span class="lineCov">      12468 :   gcc_checking_assert (builtin_fn_p (code));</span>
<span class="lineNum">      56 </span><span class="lineCov">       6234 :   return built_in_function (int (code));</span>
<span class="lineNum">      57 </span>            : }
<span class="lineNum">      58 </span>            : 
<span class="lineNum">      59 </span>            : /* Return true if CODE is an internal function.  */
<span class="lineNum">      60 </span>            : 
<span class="lineNum">      61 </span>            : inline bool
<span class="lineNum">      62 </span>            : internal_fn_p (combined_fn code)
<span class="lineNum">      63 </span>            : {
<span class="lineNum">      64 </span><span class="lineCov">    6483071 :   return int (code) &gt;= int (END_BUILTINS);</span>
<span class="lineNum">      65 </span>            : }
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span>            : /* Return the internal function represented by CODE.  Only valid if
<span class="lineNum">      68 </span>            :    internal_fn_p (CODE).  */
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span>            : inline internal_fn
<span class="lineNum">      71 </span>            : as_internal_fn (combined_fn code)
<span class="lineNum">      72 </span>            : {
<span class="lineNum">      73 </span><span class="lineCov">    2387640 :   gcc_checking_assert (internal_fn_p (code));</span>
<span class="lineNum">      74 </span><span class="lineCov">    1193820 :   return internal_fn (int (code) - int (END_BUILTINS));</span>
<span class="lineNum">      75 </span>            : }
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span>            : /* Macros for initializing `tree_contains_struct'.  */
<span class="lineNum">      78 </span>            : #define MARK_TS_BASE(C)                                 \
<span class="lineNum">      79 </span>            :   (tree_contains_struct[C][TS_BASE] = true)
<span class="lineNum">      80 </span>            : 
<span class="lineNum">      81 </span>            : #define MARK_TS_TYPED(C)                                \
<span class="lineNum">      82 </span>            :   (MARK_TS_BASE (C),                                    \
<span class="lineNum">      83 </span>            :    tree_contains_struct[C][TS_TYPED] = true)
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span>            : #define MARK_TS_COMMON(C)                               \
<span class="lineNum">      86 </span>            :   (MARK_TS_TYPED (C),                                   \
<span class="lineNum">      87 </span>            :    tree_contains_struct[C][TS_COMMON] = true)
<span class="lineNum">      88 </span>            : 
<span class="lineNum">      89 </span>            : #define MARK_TS_TYPE_COMMON(C)                          \
<span class="lineNum">      90 </span>            :   (MARK_TS_COMMON (C),                                  \
<span class="lineNum">      91 </span>            :    tree_contains_struct[C][TS_TYPE_COMMON] = true)
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span>            : #define MARK_TS_TYPE_WITH_LANG_SPECIFIC(C)              \
<span class="lineNum">      94 </span>            :   (MARK_TS_TYPE_COMMON (C),                             \
<span class="lineNum">      95 </span>            :    tree_contains_struct[C][TS_TYPE_WITH_LANG_SPECIFIC] = true)
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span>            : #define MARK_TS_DECL_MINIMAL(C)                         \
<span class="lineNum">      98 </span>            :   (MARK_TS_COMMON (C),                                  \
<span class="lineNum">      99 </span>            :    tree_contains_struct[C][TS_DECL_MINIMAL] = true)
<span class="lineNum">     100 </span>            : 
<span class="lineNum">     101 </span>            : #define MARK_TS_DECL_COMMON(C)                          \
<span class="lineNum">     102 </span>            :   (MARK_TS_DECL_MINIMAL (C),                            \
<span class="lineNum">     103 </span>            :    tree_contains_struct[C][TS_DECL_COMMON] = true)
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span>            : #define MARK_TS_DECL_WRTL(C)                            \
<span class="lineNum">     106 </span>            :   (MARK_TS_DECL_COMMON (C),                             \
<span class="lineNum">     107 </span>            :    tree_contains_struct[C][TS_DECL_WRTL] = true)
<span class="lineNum">     108 </span>            : 
<span class="lineNum">     109 </span>            : #define MARK_TS_DECL_WITH_VIS(C)                        \
<span class="lineNum">     110 </span>            :   (MARK_TS_DECL_WRTL (C),                               \
<span class="lineNum">     111 </span>            :    tree_contains_struct[C][TS_DECL_WITH_VIS] = true)
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span>            : #define MARK_TS_DECL_NON_COMMON(C)                      \
<span class="lineNum">     114 </span>            :   (MARK_TS_DECL_WITH_VIS (C),                           \
<span class="lineNum">     115 </span>            :    tree_contains_struct[C][TS_DECL_NON_COMMON] = true)
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span>            : /* Returns the string representing CLASS.  */
<span class="lineNum">     118 </span>            : 
<span class="lineNum">     119 </span>            : #define TREE_CODE_CLASS_STRING(CLASS)\
<span class="lineNum">     120 </span>            :         tree_code_class_strings[(int) (CLASS)]
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span>            : #define TREE_CODE_CLASS(CODE)   tree_code_type[(int) (CODE)]
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span>            : /* Nonzero if NODE represents an exceptional code.  */
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span>            : #define EXCEPTIONAL_CLASS_P(NODE)\
<span class="lineNum">     127 </span>            :         (TREE_CODE_CLASS (TREE_CODE (NODE)) == tcc_exceptional)
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span>            : /* Nonzero if NODE represents a constant.  */
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span>            : #define CONSTANT_CLASS_P(NODE)\
<span class="lineNum">     132 </span>            :         (TREE_CODE_CLASS (TREE_CODE (NODE)) == tcc_constant)
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span>            : /* Nonzero if NODE represents a type.  */
<span class="lineNum">     135 </span>            : 
<span class="lineNum">     136 </span>            : #define TYPE_P(NODE)\
<span class="lineNum">     137 </span>            :         (TREE_CODE_CLASS (TREE_CODE (NODE)) == tcc_type)
<span class="lineNum">     138 </span>            : 
<span class="lineNum">     139 </span>            : /* Nonzero if NODE represents a declaration.  */
<span class="lineNum">     140 </span>            : 
<span class="lineNum">     141 </span>            : #define DECL_P(NODE)\
<span class="lineNum">     142 </span>            :         (TREE_CODE_CLASS (TREE_CODE (NODE)) == tcc_declaration)
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span>            : /* True if NODE designates a variable declaration.  */
<span class="lineNum">     145 </span>            : #define VAR_P(NODE) \
<span class="lineNum">     146 </span>            :   (TREE_CODE (NODE) == VAR_DECL)
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span>            : /* Nonzero if DECL represents a VAR_DECL or FUNCTION_DECL.  */
<span class="lineNum">     149 </span>            : 
<span class="lineNum">     150 </span>            : #define VAR_OR_FUNCTION_DECL_P(DECL)\
<span class="lineNum">     151 </span>            :   (TREE_CODE (DECL) == VAR_DECL || TREE_CODE (DECL) == FUNCTION_DECL)
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span>            : /* Nonzero if NODE represents a INDIRECT_REF.  Keep these checks in
<span class="lineNum">     154 </span>            :    ascending code order.  */
<span class="lineNum">     155 </span>            : 
<span class="lineNum">     156 </span>            : #define INDIRECT_REF_P(NODE)\
<span class="lineNum">     157 </span>            :   (TREE_CODE (NODE) == INDIRECT_REF)
<span class="lineNum">     158 </span>            : 
<span class="lineNum">     159 </span>            : /* Nonzero if NODE represents a reference.  */
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span>            : #define REFERENCE_CLASS_P(NODE)\
<span class="lineNum">     162 </span>            :         (TREE_CODE_CLASS (TREE_CODE (NODE)) == tcc_reference)
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            : /* Nonzero if NODE represents a comparison.  */
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span>            : #define COMPARISON_CLASS_P(NODE)\
<span class="lineNum">     167 </span>            :         (TREE_CODE_CLASS (TREE_CODE (NODE)) == tcc_comparison)
<span class="lineNum">     168 </span>            : 
<span class="lineNum">     169 </span>            : /* Nonzero if NODE represents a unary arithmetic expression.  */
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span>            : #define UNARY_CLASS_P(NODE)\
<span class="lineNum">     172 </span>            :         (TREE_CODE_CLASS (TREE_CODE (NODE)) == tcc_unary)
<span class="lineNum">     173 </span>            : 
<span class="lineNum">     174 </span>            : /* Nonzero if NODE represents a binary arithmetic expression.  */
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span>            : #define BINARY_CLASS_P(NODE)\
<span class="lineNum">     177 </span>            :         (TREE_CODE_CLASS (TREE_CODE (NODE)) == tcc_binary)
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span>            : /* Nonzero if NODE represents a statement expression.  */
<span class="lineNum">     180 </span>            : 
<span class="lineNum">     181 </span>            : #define STATEMENT_CLASS_P(NODE)\
<span class="lineNum">     182 </span>            :         (TREE_CODE_CLASS (TREE_CODE (NODE)) == tcc_statement)
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span>            : /* Nonzero if NODE represents a function call-like expression with a
<span class="lineNum">     185 </span>            :    variable-length operand vector.  */
<span class="lineNum">     186 </span>            : 
<span class="lineNum">     187 </span>            : #define VL_EXP_CLASS_P(NODE)\
<span class="lineNum">     188 </span>            :         (TREE_CODE_CLASS (TREE_CODE (NODE)) == tcc_vl_exp)
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span>            : /* Nonzero if NODE represents any other expression.  */
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span>            : #define EXPRESSION_CLASS_P(NODE)\
<span class="lineNum">     193 </span>            :         (TREE_CODE_CLASS (TREE_CODE (NODE)) == tcc_expression)
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span>            : /* Returns nonzero iff NODE represents a type or declaration.  */
<span class="lineNum">     196 </span>            : 
<span class="lineNum">     197 </span>            : #define IS_TYPE_OR_DECL_P(NODE)\
<span class="lineNum">     198 </span>            :         (TYPE_P (NODE) || DECL_P (NODE))
<span class="lineNum">     199 </span>            : 
<span class="lineNum">     200 </span>            : /* Returns nonzero iff CLASS is the tree-code class of an
<span class="lineNum">     201 </span>            :    expression.  */
<span class="lineNum">     202 </span>            : 
<span class="lineNum">     203 </span>            : #define IS_EXPR_CODE_CLASS(CLASS)\
<span class="lineNum">     204 </span>            :         ((CLASS) &gt;= tcc_reference &amp;&amp; (CLASS) &lt;= tcc_expression)
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span>            : /* Returns nonzero iff NODE is an expression of some kind.  */
<span class="lineNum">     207 </span>            : 
<span class="lineNum">     208 </span>            : #define EXPR_P(NODE) IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (NODE)))
<span class="lineNum">     209 </span>            : 
<span class="lineNum">     210 </span>            : #define TREE_CODE_LENGTH(CODE)  tree_code_length[(int) (CODE)]
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span>            : 
<span class="lineNum">     213 </span>            : /* Helper macros for math builtins.  */
<span class="lineNum">     214 </span>            : 
<span class="lineNum">     215 </span>            : #define CASE_FLT_FN(FN) case FN: case FN##F: case FN##L
<span class="lineNum">     216 </span>            : #define CASE_FLT_FN_FLOATN_NX(FN)                          \
<span class="lineNum">     217 </span>            :   case FN##F16: case FN##F32: case FN##F64: case FN##F128: \
<span class="lineNum">     218 </span>            :   case FN##F32X: case FN##F64X: case FN##F128X
<span class="lineNum">     219 </span>            : #define CASE_FLT_FN_REENT(FN) case FN##_R: case FN##F_R: case FN##L_R
<span class="lineNum">     220 </span>            : #define CASE_INT_FN(FN) case FN: case FN##L: case FN##LL: case FN##IMAX
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span>            : #define NULL_TREE (tree) NULL
<span class="lineNum">     223 </span>            : 
<span class="lineNum">     224 </span>            : /* Define accessors for the fields that all tree nodes have
<span class="lineNum">     225 </span>            :    (though some fields are not used for all kinds of nodes).  */
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span>            : /* The tree-code says what kind of node it is.
<span class="lineNum">     228 </span>            :    Codes are defined in tree.def.  */
<span class="lineNum">     229 </span>            : #define TREE_CODE(NODE) ((enum tree_code) (NODE)-&gt;base.code)
<span class="lineNum">     230 </span>            : #define TREE_SET_CODE(NODE, VALUE) ((NODE)-&gt;base.code = (VALUE))
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span>            : /* When checking is enabled, errors will be generated if a tree node
<span class="lineNum">     233 </span>            :    is accessed incorrectly. The macros die with a fatal error.  */
<span class="lineNum">     234 </span>            : #if defined ENABLE_TREE_CHECKING &amp;&amp; (GCC_VERSION &gt;= 2007)
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span>            : #define TREE_CHECK(T, CODE) \
<span class="lineNum">     237 </span>            : (tree_check ((T), __FILE__, __LINE__, __FUNCTION__, (CODE)))
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span>            : #define TREE_NOT_CHECK(T, CODE) \
<span class="lineNum">     240 </span>            : (tree_not_check ((T), __FILE__, __LINE__, __FUNCTION__, (CODE)))
<span class="lineNum">     241 </span>            : 
<span class="lineNum">     242 </span>            : #define TREE_CHECK2(T, CODE1, CODE2) \
<span class="lineNum">     243 </span>            : (tree_check2 ((T), __FILE__, __LINE__, __FUNCTION__, (CODE1), (CODE2)))
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span>            : #define TREE_NOT_CHECK2(T, CODE1, CODE2) \
<span class="lineNum">     246 </span>            : (tree_not_check2 ((T), __FILE__, __LINE__, __FUNCTION__, (CODE1), (CODE2)))
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span>            : #define TREE_CHECK3(T, CODE1, CODE2, CODE3) \
<span class="lineNum">     249 </span>            : (tree_check3 ((T), __FILE__, __LINE__, __FUNCTION__, (CODE1), (CODE2), (CODE3)))
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span>            : #define TREE_NOT_CHECK3(T, CODE1, CODE2, CODE3) \
<span class="lineNum">     252 </span>            : (tree_not_check3 ((T), __FILE__, __LINE__, __FUNCTION__, \
<span class="lineNum">     253 </span>            :                                (CODE1), (CODE2), (CODE3)))
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span>            : #define TREE_CHECK4(T, CODE1, CODE2, CODE3, CODE4) \
<span class="lineNum">     256 </span>            : (tree_check4 ((T), __FILE__, __LINE__, __FUNCTION__, \
<span class="lineNum">     257 </span>            :                            (CODE1), (CODE2), (CODE3), (CODE4)))
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span>            : #define TREE_NOT_CHECK4(T, CODE1, CODE2, CODE3, CODE4) \
<span class="lineNum">     260 </span>            : (tree_not_check4 ((T), __FILE__, __LINE__, __FUNCTION__, \
<span class="lineNum">     261 </span>            :                                (CODE1), (CODE2), (CODE3), (CODE4)))
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span>            : #define TREE_CHECK5(T, CODE1, CODE2, CODE3, CODE4, CODE5) \
<span class="lineNum">     264 </span>            : (tree_check5 ((T), __FILE__, __LINE__, __FUNCTION__, \
<span class="lineNum">     265 </span>            :                            (CODE1), (CODE2), (CODE3), (CODE4), (CODE5)))
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span>            : #define TREE_NOT_CHECK5(T, CODE1, CODE2, CODE3, CODE4, CODE5) \
<span class="lineNum">     268 </span>            : (tree_not_check5 ((T), __FILE__, __LINE__, __FUNCTION__, \
<span class="lineNum">     269 </span>            :                                (CODE1), (CODE2), (CODE3), (CODE4), (CODE5)))
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span>            : #define CONTAINS_STRUCT_CHECK(T, STRUCT) \
<span class="lineNum">     272 </span>            : (contains_struct_check ((T), (STRUCT), __FILE__, __LINE__, __FUNCTION__))
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span>            : #define TREE_CLASS_CHECK(T, CLASS) \
<span class="lineNum">     275 </span>            : (tree_class_check ((T), (CLASS), __FILE__, __LINE__, __FUNCTION__))
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span>            : #define TREE_RANGE_CHECK(T, CODE1, CODE2) \
<span class="lineNum">     278 </span>            : (tree_range_check ((T), (CODE1), (CODE2), __FILE__, __LINE__, __FUNCTION__))
<span class="lineNum">     279 </span>            : 
<span class="lineNum">     280 </span>            : #define OMP_CLAUSE_SUBCODE_CHECK(T, CODE) \
<span class="lineNum">     281 </span>            : (omp_clause_subcode_check ((T), (CODE), __FILE__, __LINE__, __FUNCTION__))
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span>            : #define OMP_CLAUSE_RANGE_CHECK(T, CODE1, CODE2) \
<span class="lineNum">     284 </span>            : (omp_clause_range_check ((T), (CODE1), (CODE2), \
<span class="lineNum">     285 </span>            :                                       __FILE__, __LINE__, __FUNCTION__))
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span>            : /* These checks have to be special cased.  */
<span class="lineNum">     288 </span>            : #define EXPR_CHECK(T) \
<span class="lineNum">     289 </span>            : (expr_check ((T), __FILE__, __LINE__, __FUNCTION__))
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span>            : /* These checks have to be special cased.  */
<span class="lineNum">     292 </span>            : #define NON_TYPE_CHECK(T) \
<span class="lineNum">     293 </span>            : (non_type_check ((T), __FILE__, __LINE__, __FUNCTION__))
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span>            : /* These checks have to be special cased.  */
<span class="lineNum">     296 </span>            : #define ANY_INTEGRAL_TYPE_CHECK(T) \
<span class="lineNum">     297 </span>            : (any_integral_type_check ((T), __FILE__, __LINE__, __FUNCTION__))
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span>            : #define TREE_INT_CST_ELT_CHECK(T, I) \
<span class="lineNum">     300 </span>            : (*tree_int_cst_elt_check ((T), (I), __FILE__, __LINE__, __FUNCTION__))
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span>            : #define TREE_VEC_ELT_CHECK(T, I) \
<span class="lineNum">     303 </span>            : (*(CONST_CAST2 (tree *, typeof (T)*, \
<span class="lineNum">     304 </span>            :      tree_vec_elt_check ((T), (I), __FILE__, __LINE__, __FUNCTION__))))
<span class="lineNum">     305 </span>            : 
<span class="lineNum">     306 </span>            : #define OMP_CLAUSE_ELT_CHECK(T, I) \
<span class="lineNum">     307 </span>            : (*(omp_clause_elt_check ((T), (I), __FILE__, __LINE__, __FUNCTION__)))
<span class="lineNum">     308 </span>            : 
<span class="lineNum">     309 </span>            : /* Special checks for TREE_OPERANDs.  */
<span class="lineNum">     310 </span>            : #define TREE_OPERAND_CHECK(T, I) \
<span class="lineNum">     311 </span>            : (*(CONST_CAST2 (tree*, typeof (T)*, \
<span class="lineNum">     312 </span>            :      tree_operand_check ((T), (I), __FILE__, __LINE__, __FUNCTION__))))
<span class="lineNum">     313 </span>            : 
<span class="lineNum">     314 </span>            : #define TREE_OPERAND_CHECK_CODE(T, CODE, I) \
<span class="lineNum">     315 </span>            : (*(tree_operand_check_code ((T), (CODE), (I), \
<span class="lineNum">     316 </span>            :                                          __FILE__, __LINE__, __FUNCTION__)))
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span>            : /* Nodes are chained together for many purposes.
<span class="lineNum">     319 </span>            :    Types are chained together to record them for being output to the debugger
<span class="lineNum">     320 </span>            :    (see the function `chain_type').
<span class="lineNum">     321 </span>            :    Decls in the same scope are chained together to record the contents
<span class="lineNum">     322 </span>            :    of the scope.
<span class="lineNum">     323 </span>            :    Statement nodes for successive statements used to be chained together.
<span class="lineNum">     324 </span>            :    Often lists of things are represented by TREE_LIST nodes that
<span class="lineNum">     325 </span>            :    are chained together.  */
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span>            : #define TREE_CHAIN(NODE) \
<span class="lineNum">     328 </span>            : (CONTAINS_STRUCT_CHECK (NODE, TS_COMMON)-&gt;common.chain)
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span>            : /* In all nodes that are expressions, this is the data type of the expression.
<span class="lineNum">     331 </span>            :    In POINTER_TYPE nodes, this is the type that the pointer points to.
<span class="lineNum">     332 </span>            :    In ARRAY_TYPE nodes, this is the type of the elements.
<span class="lineNum">     333 </span>            :    In VECTOR_TYPE nodes, this is the type of the elements.  */
<span class="lineNum">     334 </span>            : #define TREE_TYPE(NODE) \
<span class="lineNum">     335 </span>            : (CONTAINS_STRUCT_CHECK (NODE, TS_TYPED)-&gt;typed.type)
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span>            : extern void tree_contains_struct_check_failed (const_tree,
<span class="lineNum">     338 </span>            :                                                const enum tree_node_structure_enum,
<span class="lineNum">     339 </span>            :                                                const char *, int, const char *)
<span class="lineNum">     340 </span>            :   ATTRIBUTE_NORETURN ATTRIBUTE_COLD;
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span>            : extern void tree_check_failed (const_tree, const char *, int, const char *,
<span class="lineNum">     343 </span>            :                                ...) ATTRIBUTE_NORETURN ATTRIBUTE_COLD;
<span class="lineNum">     344 </span>            : extern void tree_not_check_failed (const_tree, const char *, int, const char *,
<span class="lineNum">     345 </span>            :                                    ...) ATTRIBUTE_NORETURN ATTRIBUTE_COLD;
<span class="lineNum">     346 </span>            : extern void tree_class_check_failed (const_tree, const enum tree_code_class,
<span class="lineNum">     347 </span>            :                                      const char *, int, const char *)
<span class="lineNum">     348 </span>            :     ATTRIBUTE_NORETURN ATTRIBUTE_COLD;
<span class="lineNum">     349 </span>            : extern void tree_range_check_failed (const_tree, const char *, int,
<span class="lineNum">     350 </span>            :                                      const char *, enum tree_code,
<span class="lineNum">     351 </span>            :                                      enum tree_code)
<span class="lineNum">     352 </span>            :     ATTRIBUTE_NORETURN ATTRIBUTE_COLD;
<span class="lineNum">     353 </span>            : extern void tree_not_class_check_failed (const_tree,
<span class="lineNum">     354 </span>            :                                          const enum tree_code_class,
<span class="lineNum">     355 </span>            :                                          const char *, int, const char *)
<span class="lineNum">     356 </span>            :     ATTRIBUTE_NORETURN ATTRIBUTE_COLD;
<span class="lineNum">     357 </span>            : extern void tree_int_cst_elt_check_failed (int, int, const char *,
<span class="lineNum">     358 </span>            :                                            int, const char *)
<span class="lineNum">     359 </span>            :     ATTRIBUTE_NORETURN ATTRIBUTE_COLD;
<span class="lineNum">     360 </span>            : extern void tree_vec_elt_check_failed (int, int, const char *,
<span class="lineNum">     361 </span>            :                                        int, const char *)
<span class="lineNum">     362 </span>            :     ATTRIBUTE_NORETURN ATTRIBUTE_COLD;
<span class="lineNum">     363 </span>            : extern void phi_node_elt_check_failed (int, int, const char *,
<span class="lineNum">     364 </span>            :                                        int, const char *)
<span class="lineNum">     365 </span>            :     ATTRIBUTE_NORETURN ATTRIBUTE_COLD;
<span class="lineNum">     366 </span>            : extern void tree_operand_check_failed (int, const_tree,
<span class="lineNum">     367 </span>            :                                        const char *, int, const char *)
<span class="lineNum">     368 </span>            :     ATTRIBUTE_NORETURN ATTRIBUTE_COLD;
<span class="lineNum">     369 </span>            : extern void omp_clause_check_failed (const_tree, const char *, int,
<span class="lineNum">     370 </span>            :                                      const char *, enum omp_clause_code)
<span class="lineNum">     371 </span>            :     ATTRIBUTE_NORETURN ATTRIBUTE_COLD;
<span class="lineNum">     372 </span>            : extern void omp_clause_operand_check_failed (int, const_tree, const char *,
<span class="lineNum">     373 </span>            :                                              int, const char *)
<span class="lineNum">     374 </span>            :     ATTRIBUTE_NORETURN ATTRIBUTE_COLD;
<span class="lineNum">     375 </span>            : extern void omp_clause_range_check_failed (const_tree, const char *, int,
<span class="lineNum">     376 </span>            :                                const char *, enum omp_clause_code,
<span class="lineNum">     377 </span>            :                                enum omp_clause_code)
<span class="lineNum">     378 </span>            :     ATTRIBUTE_NORETURN ATTRIBUTE_COLD;
<span class="lineNum">     379 </span>            : 
<span class="lineNum">     380 </span>            : #else /* not ENABLE_TREE_CHECKING, or not gcc */
<span class="lineNum">     381 </span>            : 
<span class="lineNum">     382 </span>            : #define CONTAINS_STRUCT_CHECK(T, ENUM)          (T)
<span class="lineNum">     383 </span>            : #define TREE_CHECK(T, CODE)                     (T)
<span class="lineNum">     384 </span>            : #define TREE_NOT_CHECK(T, CODE)                 (T)
<span class="lineNum">     385 </span>            : #define TREE_CHECK2(T, CODE1, CODE2)            (T)
<span class="lineNum">     386 </span>            : #define TREE_NOT_CHECK2(T, CODE1, CODE2)        (T)
<span class="lineNum">     387 </span>            : #define TREE_CHECK3(T, CODE1, CODE2, CODE3)     (T)
<span class="lineNum">     388 </span>            : #define TREE_NOT_CHECK3(T, CODE1, CODE2, CODE3) (T)
<span class="lineNum">     389 </span>            : #define TREE_CHECK4(T, CODE1, CODE2, CODE3, CODE4) (T)
<span class="lineNum">     390 </span>            : #define TREE_NOT_CHECK4(T, CODE1, CODE2, CODE3, CODE4) (T)
<span class="lineNum">     391 </span>            : #define TREE_CHECK5(T, CODE1, CODE2, CODE3, CODE4, CODE5) (T)
<span class="lineNum">     392 </span>            : #define TREE_NOT_CHECK5(T, CODE1, CODE2, CODE3, CODE4, CODE5) (T)
<span class="lineNum">     393 </span>            : #define TREE_CLASS_CHECK(T, CODE)               (T)
<span class="lineNum">     394 </span>            : #define TREE_RANGE_CHECK(T, CODE1, CODE2)       (T)
<span class="lineNum">     395 </span>            : #define EXPR_CHECK(T)                           (T)
<span class="lineNum">     396 </span>            : #define NON_TYPE_CHECK(T)                       (T)
<span class="lineNum">     397 </span>            : #define TREE_INT_CST_ELT_CHECK(T, I)            ((T)-&gt;int_cst.val[I])
<span class="lineNum">     398 </span>            : #define TREE_VEC_ELT_CHECK(T, I)                ((T)-&gt;vec.a[I])
<span class="lineNum">     399 </span>            : #define TREE_OPERAND_CHECK(T, I)                ((T)-&gt;exp.operands[I])
<span class="lineNum">     400 </span>            : #define TREE_OPERAND_CHECK_CODE(T, CODE, I)     ((T)-&gt;exp.operands[I])
<span class="lineNum">     401 </span>            : #define OMP_CLAUSE_ELT_CHECK(T, i)              ((T)-&gt;omp_clause.ops[i])
<span class="lineNum">     402 </span>            : #define OMP_CLAUSE_RANGE_CHECK(T, CODE1, CODE2) (T)
<span class="lineNum">     403 </span>            : #define OMP_CLAUSE_SUBCODE_CHECK(T, CODE)       (T)
<span class="lineNum">     404 </span>            : #define ANY_INTEGRAL_TYPE_CHECK(T)              (T)
<span class="lineNum">     405 </span>            : 
<span class="lineNum">     406 </span>            : #define TREE_CHAIN(NODE) ((NODE)-&gt;common.chain)
<span class="lineNum">     407 </span>            : #define TREE_TYPE(NODE) ((NODE)-&gt;typed.type)
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span>            : #endif
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span>            : #define TREE_BLOCK(NODE)                (tree_block (NODE))
<span class="lineNum">     412 </span>            : #define TREE_SET_BLOCK(T, B)            (tree_set_block ((T), (B)))
<span class="lineNum">     413 </span>            : 
<span class="lineNum">     414 </span>            : #include &quot;tree-check.h&quot;
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span>            : #define TYPE_CHECK(T)           TREE_CLASS_CHECK (T, tcc_type)
<span class="lineNum">     417 </span>            : #define DECL_MINIMAL_CHECK(T)   CONTAINS_STRUCT_CHECK (T, TS_DECL_MINIMAL)
<span class="lineNum">     418 </span>            : #define DECL_COMMON_CHECK(T)    CONTAINS_STRUCT_CHECK (T, TS_DECL_COMMON)
<span class="lineNum">     419 </span>            : #define DECL_WRTL_CHECK(T)      CONTAINS_STRUCT_CHECK (T, TS_DECL_WRTL)
<span class="lineNum">     420 </span>            : #define DECL_WITH_VIS_CHECK(T)  CONTAINS_STRUCT_CHECK (T, TS_DECL_WITH_VIS)
<span class="lineNum">     421 </span>            : #define DECL_NON_COMMON_CHECK(T) CONTAINS_STRUCT_CHECK (T, TS_DECL_NON_COMMON)
<span class="lineNum">     422 </span>            : #define CST_CHECK(T)            TREE_CLASS_CHECK (T, tcc_constant)
<span class="lineNum">     423 </span>            : #define STMT_CHECK(T)           TREE_CLASS_CHECK (T, tcc_statement)
<span class="lineNum">     424 </span>            : #define VL_EXP_CHECK(T)         TREE_CLASS_CHECK (T, tcc_vl_exp)
<span class="lineNum">     425 </span>            : #define FUNC_OR_METHOD_CHECK(T) TREE_CHECK2 (T, FUNCTION_TYPE, METHOD_TYPE)
<span class="lineNum">     426 </span>            : #define PTR_OR_REF_CHECK(T)     TREE_CHECK2 (T, POINTER_TYPE, REFERENCE_TYPE)
<span class="lineNum">     427 </span>            : 
<span class="lineNum">     428 </span>            : #define RECORD_OR_UNION_CHECK(T)        \
<span class="lineNum">     429 </span>            :   TREE_CHECK3 (T, RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE)
<span class="lineNum">     430 </span>            : #define NOT_RECORD_OR_UNION_CHECK(T) \
<span class="lineNum">     431 </span>            :   TREE_NOT_CHECK3 (T, RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE)
<span class="lineNum">     432 </span>            : 
<span class="lineNum">     433 </span>            : #define NUMERICAL_TYPE_CHECK(T)                                 \
<span class="lineNum">     434 </span>            :   TREE_CHECK5 (T, INTEGER_TYPE, ENUMERAL_TYPE, BOOLEAN_TYPE, REAL_TYPE, \
<span class="lineNum">     435 </span>            :                FIXED_POINT_TYPE)
<span class="lineNum">     436 </span>            : 
<span class="lineNum">     437 </span>            : /* Here is how primitive or already-canonicalized types' hash codes
<span class="lineNum">     438 </span>            :    are made.  */
<span class="lineNum">     439 </span>            : #define TYPE_HASH(TYPE) (TYPE_UID (TYPE))
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span>            : /* A simple hash function for an arbitrary tree node.  This must not be
<span class="lineNum">     442 </span>            :    used in hash tables which are saved to a PCH.  */
<span class="lineNum">     443 </span>            : #define TREE_HASH(NODE) ((size_t) (NODE) &amp; 0777777)
<span class="lineNum">     444 </span>            : 
<span class="lineNum">     445 </span>            : /* Tests if CODE is a conversion expr (NOP_EXPR or CONVERT_EXPR).  */
<span class="lineNum">     446 </span>            : #define CONVERT_EXPR_CODE_P(CODE)                               \
<span class="lineNum">     447 </span>            :   ((CODE) == NOP_EXPR || (CODE) == CONVERT_EXPR)
<span class="lineNum">     448 </span>            : 
<span class="lineNum">     449 </span>            : /* Similarly, but accept an expression instead of a tree code.  */
<span class="lineNum">     450 </span>            : #define CONVERT_EXPR_P(EXP)     CONVERT_EXPR_CODE_P (TREE_CODE (EXP))
<span class="lineNum">     451 </span>            : 
<span class="lineNum">     452 </span>            : /* Generate case for NOP_EXPR, CONVERT_EXPR.  */
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span>            : #define CASE_CONVERT                                            \
<span class="lineNum">     455 </span>            :   case NOP_EXPR:                                                \
<span class="lineNum">     456 </span>            :   case CONVERT_EXPR
<span class="lineNum">     457 </span>            : 
<span class="lineNum">     458 </span>            : /* Given an expression as a tree, strip any conversion that generates
<span class="lineNum">     459 </span>            :    no instruction.  Accepts both tree and const_tree arguments since
<span class="lineNum">     460 </span>            :    we are not modifying the tree itself.  */
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span>            : #define STRIP_NOPS(EXP) \
<span class="lineNum">     463 </span>            :   (EXP) = tree_strip_nop_conversions (CONST_CAST_TREE (EXP))
<span class="lineNum">     464 </span>            : 
<span class="lineNum">     465 </span>            : /* Like STRIP_NOPS, but don't let the signedness change either.  */
<span class="lineNum">     466 </span>            : 
<span class="lineNum">     467 </span>            : #define STRIP_SIGN_NOPS(EXP) \
<span class="lineNum">     468 </span>            :   (EXP) = tree_strip_sign_nop_conversions (CONST_CAST_TREE (EXP))
<span class="lineNum">     469 </span>            : 
<span class="lineNum">     470 </span>            : /* Like STRIP_NOPS, but don't alter the TREE_TYPE either.  */
<span class="lineNum">     471 </span>            : 
<span class="lineNum">     472 </span>            : #define STRIP_TYPE_NOPS(EXP) \
<span class="lineNum">     473 </span>            :   while ((CONVERT_EXPR_P (EXP)                                  \
<span class="lineNum">     474 </span>            :           || TREE_CODE (EXP) == NON_LVALUE_EXPR)                \
<span class="lineNum">     475 </span>            :          &amp;&amp; TREE_OPERAND (EXP, 0) != error_mark_node            \
<span class="lineNum">     476 </span>            :          &amp;&amp; (TREE_TYPE (EXP)                                    \
<span class="lineNum">     477 </span>            :              == TREE_TYPE (TREE_OPERAND (EXP, 0))))             \
<span class="lineNum">     478 </span>            :     (EXP) = TREE_OPERAND (EXP, 0)
<span class="lineNum">     479 </span>            : 
<span class="lineNum">     480 </span>            : /* Remove unnecessary type conversions according to
<span class="lineNum">     481 </span>            :    tree_ssa_useless_type_conversion.  */
<span class="lineNum">     482 </span>            : 
<span class="lineNum">     483 </span>            : #define STRIP_USELESS_TYPE_CONVERSION(EXP) \
<span class="lineNum">     484 </span>            :   (EXP) = tree_ssa_strip_useless_type_conversions (EXP)
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span>            : /* Remove any VIEW_CONVERT_EXPR or NON_LVALUE_EXPR that's purely
<span class="lineNum">     487 </span>            :    in use to provide a location_t.  */
<span class="lineNum">     488 </span>            : 
<span class="lineNum">     489 </span>            : #define STRIP_ANY_LOCATION_WRAPPER(EXP) \
<span class="lineNum">     490 </span>            :   (EXP) = tree_strip_any_location_wrapper (CONST_CAST_TREE (EXP))
<span class="lineNum">     491 </span>            : 
<span class="lineNum">     492 </span>            : /* Nonzero if TYPE represents a vector type.  */
<span class="lineNum">     493 </span>            : 
<span class="lineNum">     494 </span>            : #define VECTOR_TYPE_P(TYPE) (TREE_CODE (TYPE) == VECTOR_TYPE)
<span class="lineNum">     495 </span>            : 
<span class="lineNum">     496 </span>            : /* Nonzero if TYPE represents a vector of booleans.  */
<span class="lineNum">     497 </span>            : 
<span class="lineNum">     498 </span>            : #define VECTOR_BOOLEAN_TYPE_P(TYPE)                             \
<span class="lineNum">     499 </span>            :   (TREE_CODE (TYPE) == VECTOR_TYPE                      \
<span class="lineNum">     500 </span>            :    &amp;&amp; TREE_CODE (TREE_TYPE (TYPE)) == BOOLEAN_TYPE)
<span class="lineNum">     501 </span>            : 
<span class="lineNum">     502 </span>            : /* Nonzero if TYPE represents an integral type.  Note that we do not
<span class="lineNum">     503 </span>            :    include COMPLEX types here.  Keep these checks in ascending code
<span class="lineNum">     504 </span>            :    order.  */
<span class="lineNum">     505 </span>            : 
<span class="lineNum">     506 </span>            : #define INTEGRAL_TYPE_P(TYPE)  \
<span class="lineNum">     507 </span>            :   (TREE_CODE (TYPE) == ENUMERAL_TYPE  \
<span class="lineNum">     508 </span>            :    || TREE_CODE (TYPE) == BOOLEAN_TYPE \
<span class="lineNum">     509 </span>            :    || TREE_CODE (TYPE) == INTEGER_TYPE)
<span class="lineNum">     510 </span>            : 
<span class="lineNum">     511 </span>            : /* Nonzero if TYPE represents an integral type, including complex
<span class="lineNum">     512 </span>            :    and vector integer types.  */
<span class="lineNum">     513 </span>            : 
<span class="lineNum">     514 </span>            : #define ANY_INTEGRAL_TYPE_P(TYPE)               \
<span class="lineNum">     515 </span>            :   (INTEGRAL_TYPE_P (TYPE)                       \
<span class="lineNum">     516 </span>            :    || ((TREE_CODE (TYPE) == COMPLEX_TYPE        \
<span class="lineNum">     517 </span>            :         || VECTOR_TYPE_P (TYPE))                \
<span class="lineNum">     518 </span>            :        &amp;&amp; INTEGRAL_TYPE_P (TREE_TYPE (TYPE))))
<span class="lineNum">     519 </span>            : 
<span class="lineNum">     520 </span>            : /* Nonzero if TYPE represents a non-saturating fixed-point type.  */
<span class="lineNum">     521 </span>            : 
<span class="lineNum">     522 </span>            : #define NON_SAT_FIXED_POINT_TYPE_P(TYPE) \
<span class="lineNum">     523 </span>            :   (TREE_CODE (TYPE) == FIXED_POINT_TYPE &amp;&amp; !TYPE_SATURATING (TYPE))
<span class="lineNum">     524 </span>            : 
<span class="lineNum">     525 </span>            : /* Nonzero if TYPE represents a saturating fixed-point type.  */
<span class="lineNum">     526 </span>            : 
<span class="lineNum">     527 </span>            : #define SAT_FIXED_POINT_TYPE_P(TYPE) \
<span class="lineNum">     528 </span>            :   (TREE_CODE (TYPE) == FIXED_POINT_TYPE &amp;&amp; TYPE_SATURATING (TYPE))
<span class="lineNum">     529 </span>            : 
<span class="lineNum">     530 </span>            : /* Nonzero if TYPE represents a fixed-point type.  */
<span class="lineNum">     531 </span>            : 
<span class="lineNum">     532 </span>            : #define FIXED_POINT_TYPE_P(TYPE)        (TREE_CODE (TYPE) == FIXED_POINT_TYPE)
<span class="lineNum">     533 </span>            : 
<span class="lineNum">     534 </span>            : /* Nonzero if TYPE represents a scalar floating-point type.  */
<span class="lineNum">     535 </span>            : 
<span class="lineNum">     536 </span>            : #define SCALAR_FLOAT_TYPE_P(TYPE) (TREE_CODE (TYPE) == REAL_TYPE)
<span class="lineNum">     537 </span>            : 
<span class="lineNum">     538 </span>            : /* Nonzero if TYPE represents a complex floating-point type.  */
<span class="lineNum">     539 </span>            : 
<span class="lineNum">     540 </span>            : #define COMPLEX_FLOAT_TYPE_P(TYPE)      \
<span class="lineNum">     541 </span>            :   (TREE_CODE (TYPE) == COMPLEX_TYPE     \
<span class="lineNum">     542 </span>            :    &amp;&amp; TREE_CODE (TREE_TYPE (TYPE)) == REAL_TYPE)
<span class="lineNum">     543 </span>            : 
<span class="lineNum">     544 </span>            : /* Nonzero if TYPE represents a vector integer type.  */
<span class="lineNum">     545 </span>            :                 
<span class="lineNum">     546 </span>            : #define VECTOR_INTEGER_TYPE_P(TYPE)                     \
<span class="lineNum">     547 </span>            :   (VECTOR_TYPE_P (TYPE)                                 \
<span class="lineNum">     548 </span>            :    &amp;&amp; TREE_CODE (TREE_TYPE (TYPE)) == INTEGER_TYPE)
<span class="lineNum">     549 </span>            : 
<span class="lineNum">     550 </span>            : 
<span class="lineNum">     551 </span>            : /* Nonzero if TYPE represents a vector floating-point type.  */
<span class="lineNum">     552 </span>            : 
<span class="lineNum">     553 </span>            : #define VECTOR_FLOAT_TYPE_P(TYPE)       \
<span class="lineNum">     554 </span>            :   (VECTOR_TYPE_P (TYPE)                 \
<span class="lineNum">     555 </span>            :    &amp;&amp; TREE_CODE (TREE_TYPE (TYPE)) == REAL_TYPE)
<span class="lineNum">     556 </span>            : 
<span class="lineNum">     557 </span>            : /* Nonzero if TYPE represents a floating-point type, including complex
<span class="lineNum">     558 </span>            :    and vector floating-point types.  The vector and complex check does
<span class="lineNum">     559 </span>            :    not use the previous two macros to enable early folding.  */
<span class="lineNum">     560 </span>            : 
<span class="lineNum">     561 </span>            : #define FLOAT_TYPE_P(TYPE)                      \
<span class="lineNum">     562 </span>            :   (SCALAR_FLOAT_TYPE_P (TYPE)                   \
<span class="lineNum">     563 </span>            :    || ((TREE_CODE (TYPE) == COMPLEX_TYPE        \
<span class="lineNum">     564 </span>            :         || VECTOR_TYPE_P (TYPE))                \
<span class="lineNum">     565 </span>            :        &amp;&amp; SCALAR_FLOAT_TYPE_P (TREE_TYPE (TYPE))))
<span class="lineNum">     566 </span>            : 
<span class="lineNum">     567 </span>            : /* Nonzero if TYPE represents a decimal floating-point type.  */
<span class="lineNum">     568 </span>            : #define DECIMAL_FLOAT_TYPE_P(TYPE)              \
<span class="lineNum">     569 </span>            :   (SCALAR_FLOAT_TYPE_P (TYPE)                   \
<span class="lineNum">     570 </span>            :    &amp;&amp; DECIMAL_FLOAT_MODE_P (TYPE_MODE (TYPE)))
<span class="lineNum">     571 </span>            : 
<span class="lineNum">     572 </span>            : /* Nonzero if TYPE is a record or union type.  */
<span class="lineNum">     573 </span>            : #define RECORD_OR_UNION_TYPE_P(TYPE)            \
<span class="lineNum">     574 </span>            :   (TREE_CODE (TYPE) == RECORD_TYPE              \
<span class="lineNum">     575 </span>            :    || TREE_CODE (TYPE) == UNION_TYPE            \
<span class="lineNum">     576 </span>            :    || TREE_CODE (TYPE) == QUAL_UNION_TYPE)
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span>            : /* Nonzero if TYPE represents an aggregate (multi-component) type.
<span class="lineNum">     579 </span>            :    Keep these checks in ascending code order.  */
<span class="lineNum">     580 </span>            : 
<span class="lineNum">     581 </span>            : #define AGGREGATE_TYPE_P(TYPE) \
<span class="lineNum">     582 </span>            :   (TREE_CODE (TYPE) == ARRAY_TYPE || RECORD_OR_UNION_TYPE_P (TYPE))
<span class="lineNum">     583 </span>            : 
<span class="lineNum">     584 </span>            : /* Nonzero if TYPE represents a pointer or reference type.
<span class="lineNum">     585 </span>            :    (It should be renamed to INDIRECT_TYPE_P.)  Keep these checks in
<span class="lineNum">     586 </span>            :    ascending code order.  */
<span class="lineNum">     587 </span>            : 
<span class="lineNum">     588 </span>            : #define POINTER_TYPE_P(TYPE) \
<span class="lineNum">     589 </span>            :   (TREE_CODE (TYPE) == POINTER_TYPE || TREE_CODE (TYPE) == REFERENCE_TYPE)
<span class="lineNum">     590 </span>            : 
<span class="lineNum">     591 </span>            : /* Nonzero if TYPE represents a pointer to function.  */
<span class="lineNum">     592 </span>            : #define FUNCTION_POINTER_TYPE_P(TYPE) \
<span class="lineNum">     593 </span>            :   (POINTER_TYPE_P (TYPE) &amp;&amp; TREE_CODE (TREE_TYPE (TYPE)) == FUNCTION_TYPE)
<span class="lineNum">     594 </span>            : 
<span class="lineNum">     595 </span>            : /* Nonzero if this type is a complete type.  */
<span class="lineNum">     596 </span>            : #define COMPLETE_TYPE_P(NODE) (TYPE_SIZE (NODE) != NULL_TREE)
<span class="lineNum">     597 </span>            : 
<span class="lineNum">     598 </span>            : /* Nonzero if this type is the (possibly qualified) void type.  */
<span class="lineNum">     599 </span>            : #define VOID_TYPE_P(NODE) (TREE_CODE (NODE) == VOID_TYPE)
<span class="lineNum">     600 </span>            : 
<span class="lineNum">     601 </span>            : /* Nonzero if this type is complete or is cv void.  */
<span class="lineNum">     602 </span>            : #define COMPLETE_OR_VOID_TYPE_P(NODE) \
<span class="lineNum">     603 </span>            :   (COMPLETE_TYPE_P (NODE) || VOID_TYPE_P (NODE))
<span class="lineNum">     604 </span>            : 
<span class="lineNum">     605 </span>            : /* Nonzero if this type is complete or is an array with unspecified bound.  */
<span class="lineNum">     606 </span>            : #define COMPLETE_OR_UNBOUND_ARRAY_TYPE_P(NODE) \
<span class="lineNum">     607 </span>            :   (COMPLETE_TYPE_P (TREE_CODE (NODE) == ARRAY_TYPE ? TREE_TYPE (NODE) : (NODE)))
<span class="lineNum">     608 </span>            : 
<span class="lineNum">     609 </span>            : #define FUNC_OR_METHOD_TYPE_P(NODE) \
<span class="lineNum">     610 </span>            :   (TREE_CODE (NODE) == FUNCTION_TYPE || TREE_CODE (NODE) == METHOD_TYPE)
<span class="lineNum">     611 </span>            : 
<span class="lineNum">     612 </span>            : /* Define many boolean fields that all tree nodes have.  */
<span class="lineNum">     613 </span>            : 
<span class="lineNum">     614 </span>            : /* In VAR_DECL, PARM_DECL and RESULT_DECL nodes, nonzero means address
<span class="lineNum">     615 </span>            :    of this is needed.  So it cannot be in a register.
<span class="lineNum">     616 </span>            :    In a FUNCTION_DECL it has no meaning.
<span class="lineNum">     617 </span>            :    In LABEL_DECL nodes, it means a goto for this label has been seen
<span class="lineNum">     618 </span>            :    from a place outside all binding contours that restore stack levels.
<span class="lineNum">     619 </span>            :    In an artificial SSA_NAME that points to a stack partition with at least
<span class="lineNum">     620 </span>            :    two variables, it means that at least one variable has TREE_ADDRESSABLE.
<span class="lineNum">     621 </span>            :    In ..._TYPE nodes, it means that objects of this type must be fully
<span class="lineNum">     622 </span>            :    addressable.  This means that pieces of this object cannot go into
<span class="lineNum">     623 </span>            :    register parameters, for example.  If this a function type, this
<span class="lineNum">     624 </span>            :    means that the value must be returned in memory.
<span class="lineNum">     625 </span>            :    In CONSTRUCTOR nodes, it means object constructed must be in memory.
<span class="lineNum">     626 </span>            :    In IDENTIFIER_NODEs, this means that some extern decl for this name
<span class="lineNum">     627 </span>            :    had its address taken.  That matters for inline functions.
<span class="lineNum">     628 </span>            :    In a STMT_EXPR, it means we want the result of the enclosed expression.  */
<span class="lineNum">     629 </span>            : #define TREE_ADDRESSABLE(NODE) ((NODE)-&gt;base.addressable_flag)
<span class="lineNum">     630 </span>            : 
<span class="lineNum">     631 </span>            : /* Set on a CALL_EXPR if the call is in a tail position, ie. just before the
<span class="lineNum">     632 </span>            :    exit of a function.  Calls for which this is true are candidates for tail
<span class="lineNum">     633 </span>            :    call optimizations.  */
<span class="lineNum">     634 </span>            : #define CALL_EXPR_TAILCALL(NODE) \
<span class="lineNum">     635 </span>            :   (CALL_EXPR_CHECK (NODE)-&gt;base.addressable_flag)
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span>            : /* Set on a CALL_EXPR if the call has been marked as requiring tail call
<span class="lineNum">     638 </span>            :    optimization for correctness.  */
<span class="lineNum">     639 </span>            : #define CALL_EXPR_MUST_TAIL_CALL(NODE) \
<span class="lineNum">     640 </span>            :   (CALL_EXPR_CHECK (NODE)-&gt;base.static_flag)
<span class="lineNum">     641 </span>            : 
<span class="lineNum">     642 </span>            : /* Used as a temporary field on a CASE_LABEL_EXPR to indicate that the
<span class="lineNum">     643 </span>            :    CASE_LOW operand has been processed.  */
<span class="lineNum">     644 </span>            : #define CASE_LOW_SEEN(NODE) \
<span class="lineNum">     645 </span>            :   (CASE_LABEL_EXPR_CHECK (NODE)-&gt;base.addressable_flag)
<span class="lineNum">     646 </span>            : 
<span class="lineNum">     647 </span>            : #define PREDICT_EXPR_OUTCOME(NODE) \
<span class="lineNum">     648 </span>            :   ((enum prediction) (PREDICT_EXPR_CHECK (NODE)-&gt;base.addressable_flag))
<span class="lineNum">     649 </span>            : #define SET_PREDICT_EXPR_OUTCOME(NODE, OUTCOME) \
<span class="lineNum">     650 </span>            :   (PREDICT_EXPR_CHECK (NODE)-&gt;base.addressable_flag = (int) OUTCOME)
<span class="lineNum">     651 </span>            : #define PREDICT_EXPR_PREDICTOR(NODE) \
<span class="lineNum">     652 </span>            :   ((enum br_predictor)tree_to_shwi (TREE_OPERAND (PREDICT_EXPR_CHECK (NODE), 0)))
<span class="lineNum">     653 </span>            : 
<span class="lineNum">     654 </span>            : /* In a VAR_DECL, nonzero means allocate static storage.
<span class="lineNum">     655 </span>            :    In a FUNCTION_DECL, nonzero if function has been defined.
<span class="lineNum">     656 </span>            :    In a CONSTRUCTOR, nonzero means allocate static storage.  */
<span class="lineNum">     657 </span>            : #define TREE_STATIC(NODE) ((NODE)-&gt;base.static_flag)
<span class="lineNum">     658 </span>            : 
<span class="lineNum">     659 </span>            : /* In an ADDR_EXPR, nonzero means do not use a trampoline.  */
<span class="lineNum">     660 </span>            : #define TREE_NO_TRAMPOLINE(NODE) (ADDR_EXPR_CHECK (NODE)-&gt;base.static_flag)
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span>            : /* In a TARGET_EXPR or WITH_CLEANUP_EXPR, means that the pertinent cleanup
<span class="lineNum">     663 </span>            :    should only be executed if an exception is thrown, not on normal exit
<span class="lineNum">     664 </span>            :    of its scope.  */
<span class="lineNum">     665 </span>            : #define CLEANUP_EH_ONLY(NODE) ((NODE)-&gt;base.static_flag)
<span class="lineNum">     666 </span>            : 
<span class="lineNum">     667 </span>            : /* In a TRY_CATCH_EXPR, means that the handler should be considered a
<span class="lineNum">     668 </span>            :    separate cleanup in honor_protect_cleanup_actions.  */
<span class="lineNum">     669 </span>            : #define TRY_CATCH_IS_CLEANUP(NODE) \
<span class="lineNum">     670 </span>            :   (TRY_CATCH_EXPR_CHECK (NODE)-&gt;base.static_flag)
<span class="lineNum">     671 </span>            : 
<span class="lineNum">     672 </span>            : /* Used as a temporary field on a CASE_LABEL_EXPR to indicate that the
<span class="lineNum">     673 </span>            :    CASE_HIGH operand has been processed.  */
<span class="lineNum">     674 </span>            : #define CASE_HIGH_SEEN(NODE) \
<span class="lineNum">     675 </span>            :   (CASE_LABEL_EXPR_CHECK (NODE)-&gt;base.static_flag)
<span class="lineNum">     676 </span>            : 
<span class="lineNum">     677 </span>            : /* Used to mark scoped enums.  */
<span class="lineNum">     678 </span>            : #define ENUM_IS_SCOPED(NODE) (ENUMERAL_TYPE_CHECK (NODE)-&gt;base.static_flag)
<span class="lineNum">     679 </span>            : 
<span class="lineNum">     680 </span>            : /* Determines whether an ENUMERAL_TYPE has defined the list of constants. */
<span class="lineNum">     681 </span>            : #define ENUM_IS_OPAQUE(NODE) (ENUMERAL_TYPE_CHECK (NODE)-&gt;base.private_flag)
<span class="lineNum">     682 </span>            : 
<span class="lineNum">     683 </span>            : /* In an expr node (usually a conversion) this means the node was made
<span class="lineNum">     684 </span>            :    implicitly and should not lead to any sort of warning.  In a decl node,
<span class="lineNum">     685 </span>            :    warnings concerning the decl should be suppressed.  This is used at
<span class="lineNum">     686 </span>            :    least for used-before-set warnings, and it set after one warning is
<span class="lineNum">     687 </span>            :    emitted.  */
<span class="lineNum">     688 </span>            : #define TREE_NO_WARNING(NODE) ((NODE)-&gt;base.nowarning_flag)
<span class="lineNum">     689 </span>            : 
<span class="lineNum">     690 </span>            : /* Nonzero if we should warn about the change in empty class parameter
<span class="lineNum">     691 </span>            :    passing ABI in this TU.  */
<span class="lineNum">     692 </span>            : #define TRANSLATION_UNIT_WARN_EMPTY_P(NODE) \
<span class="lineNum">     693 </span>            :   (TRANSLATION_UNIT_DECL_CHECK (NODE)-&gt;decl_common.decl_flag_0)
<span class="lineNum">     694 </span>            : 
<span class="lineNum">     695 </span>            : /* Nonzero if this type is &quot;empty&quot; according to the particular psABI.  */
<span class="lineNum">     696 </span>            : #define TYPE_EMPTY_P(NODE) (TYPE_CHECK (NODE)-&gt;type_common.empty_flag)
<span class="lineNum">     697 </span>            : 
<span class="lineNum">     698 </span>            : /* Used to indicate that this TYPE represents a compiler-generated entity.  */
<span class="lineNum">     699 </span>            : #define TYPE_ARTIFICIAL(NODE) (TYPE_CHECK (NODE)-&gt;base.nowarning_flag)
<span class="lineNum">     700 </span>            : 
<span class="lineNum">     701 </span>            : /* In an IDENTIFIER_NODE, this means that assemble_name was called with
<span class="lineNum">     702 </span>            :    this string as an argument.  */
<span class="lineNum">     703 </span>            : #define TREE_SYMBOL_REFERENCED(NODE) \
<span class="lineNum">     704 </span>            :   (IDENTIFIER_NODE_CHECK (NODE)-&gt;base.static_flag)
<span class="lineNum">     705 </span>            : 
<span class="lineNum">     706 </span>            : /* Nonzero in a pointer or reference type means the data pointed to
<span class="lineNum">     707 </span>            :    by this type can alias anything.  */
<span class="lineNum">     708 </span>            : #define TYPE_REF_CAN_ALIAS_ALL(NODE) \
<span class="lineNum">     709 </span>            :   (PTR_OR_REF_CHECK (NODE)-&gt;base.static_flag)
<span class="lineNum">     710 </span>            : 
<span class="lineNum">     711 </span>            : /* In an INTEGER_CST, REAL_CST, COMPLEX_CST, or VECTOR_CST, this means
<span class="lineNum">     712 </span>            :    there was an overflow in folding.  */
<span class="lineNum">     713 </span>            : 
<span class="lineNum">     714 </span>            : #define TREE_OVERFLOW(NODE) (CST_CHECK (NODE)-&gt;base.public_flag)
<span class="lineNum">     715 </span>            : 
<span class="lineNum">     716 </span>            : /* TREE_OVERFLOW can only be true for EXPR of CONSTANT_CLASS_P.  */
<span class="lineNum">     717 </span>            : 
<span class="lineNum">     718 </span>            : #define TREE_OVERFLOW_P(EXPR) \
<span class="lineNum">     719 </span>            :  (CONSTANT_CLASS_P (EXPR) &amp;&amp; TREE_OVERFLOW (EXPR))
<span class="lineNum">     720 </span>            : 
<span class="lineNum">     721 </span>            : /* In a VAR_DECL, FUNCTION_DECL, NAMESPACE_DECL or TYPE_DECL,
<span class="lineNum">     722 </span>            :    nonzero means name is to be accessible from outside this translation unit.
<span class="lineNum">     723 </span>            :    In an IDENTIFIER_NODE, nonzero means an external declaration
<span class="lineNum">     724 </span>            :    accessible from outside this translation unit was previously seen
<span class="lineNum">     725 </span>            :    for this name in an inner scope.  */
<span class="lineNum">     726 </span>            : #define TREE_PUBLIC(NODE) ((NODE)-&gt;base.public_flag)
<span class="lineNum">     727 </span>            : 
<span class="lineNum">     728 </span>            : /* In a _TYPE, indicates whether TYPE_CACHED_VALUES contains a vector
<span class="lineNum">     729 </span>            :    of cached values, or is something else.  */
<span class="lineNum">     730 </span>            : #define TYPE_CACHED_VALUES_P(NODE) (TYPE_CHECK (NODE)-&gt;base.public_flag)
<span class="lineNum">     731 </span>            : 
<span class="lineNum">     732 </span>            : /* In a SAVE_EXPR, indicates that the original expression has already
<span class="lineNum">     733 </span>            :    been substituted with a VAR_DECL that contains the value.  */
<span class="lineNum">     734 </span>            : #define SAVE_EXPR_RESOLVED_P(NODE) \
<span class="lineNum">     735 </span>            :   (SAVE_EXPR_CHECK (NODE)-&gt;base.public_flag)
<span class="lineNum">     736 </span>            : 
<span class="lineNum">     737 </span>            : /* Set on a CALL_EXPR if this stdarg call should be passed the argument
<span class="lineNum">     738 </span>            :    pack.  */
<span class="lineNum">     739 </span>            : #define CALL_EXPR_VA_ARG_PACK(NODE) \
<span class="lineNum">     740 </span>            :   (CALL_EXPR_CHECK (NODE)-&gt;base.public_flag)
<span class="lineNum">     741 </span>            : 
<span class="lineNum">     742 </span>            : /* In any expression, decl, or constant, nonzero means it has side effects or
<span class="lineNum">     743 </span>            :    reevaluation of the whole expression could produce a different value.
<span class="lineNum">     744 </span>            :    This is set if any subexpression is a function call, a side effect or a
<span class="lineNum">     745 </span>            :    reference to a volatile variable.  In a ..._DECL, this is set only if the
<span class="lineNum">     746 </span>            :    declaration said `volatile'.  This will never be set for a constant.  */
<span class="lineNum">     747 </span>            : #define TREE_SIDE_EFFECTS(NODE) \
<span class="lineNum">     748 </span>            :   (NON_TYPE_CHECK (NODE)-&gt;base.side_effects_flag)
<span class="lineNum">     749 </span>            : 
<span class="lineNum">     750 </span>            : /* In a LABEL_DECL, nonzero means this label had its address taken
<span class="lineNum">     751 </span>            :    and therefore can never be deleted and is a jump target for
<span class="lineNum">     752 </span>            :    computed gotos.  */
<span class="lineNum">     753 </span>            : #define FORCED_LABEL(NODE) (LABEL_DECL_CHECK (NODE)-&gt;base.side_effects_flag)
<span class="lineNum">     754 </span>            : 
<span class="lineNum">     755 </span>            : /* Whether a case or a user-defined label is allowed to fall through to.
<span class="lineNum">     756 </span>            :    This is used to implement -Wimplicit-fallthrough.  */
<span class="lineNum">     757 </span>            : #define FALLTHROUGH_LABEL_P(NODE) \
<span class="lineNum">     758 </span>            :   (LABEL_DECL_CHECK (NODE)-&gt;base.private_flag)
<span class="lineNum">     759 </span>            : 
<span class="lineNum">     760 </span>            : /* Set on the artificial label created for break; stmt from a switch.
<span class="lineNum">     761 </span>            :    This is used to implement -Wimplicit-fallthrough.  */
<span class="lineNum">     762 </span>            : #define SWITCH_BREAK_LABEL_P(NODE) \
<span class="lineNum">     763 </span>            :   (LABEL_DECL_CHECK (NODE)-&gt;base.protected_flag)
<span class="lineNum">     764 </span>            : 
<span class="lineNum">     765 </span>            : /* Nonzero means this expression is volatile in the C sense:
<span class="lineNum">     766 </span>            :    its address should be of type `volatile WHATEVER *'.
<span class="lineNum">     767 </span>            :    In other words, the declared item is volatile qualified.
<span class="lineNum">     768 </span>            :    This is used in _DECL nodes and _REF nodes.
<span class="lineNum">     769 </span>            :    On a FUNCTION_DECL node, this means the function does not
<span class="lineNum">     770 </span>            :    return normally.  This is the same effect as setting
<span class="lineNum">     771 </span>            :    the attribute noreturn on the function in C.
<span class="lineNum">     772 </span>            : 
<span class="lineNum">     773 </span>            :    In a ..._TYPE node, means this type is volatile-qualified.
<span class="lineNum">     774 </span>            :    But use TYPE_VOLATILE instead of this macro when the node is a type,
<span class="lineNum">     775 </span>            :    because eventually we may make that a different bit.
<span class="lineNum">     776 </span>            : 
<span class="lineNum">     777 </span>            :    If this bit is set in an expression, so is TREE_SIDE_EFFECTS.  */
<span class="lineNum">     778 </span>            : #define TREE_THIS_VOLATILE(NODE) ((NODE)-&gt;base.volatile_flag)
<span class="lineNum">     779 </span>            : 
<span class="lineNum">     780 </span>            : /* Nonzero means this node will not trap.  In an INDIRECT_REF, means
<span class="lineNum">     781 </span>            :    accessing the memory pointed to won't generate a trap.  However,
<span class="lineNum">     782 </span>            :    this only applies to an object when used appropriately: it doesn't
<span class="lineNum">     783 </span>            :    mean that writing a READONLY mem won't trap.
<span class="lineNum">     784 </span>            : 
<span class="lineNum">     785 </span>            :    In ARRAY_REF and ARRAY_RANGE_REF means that we know that the index
<span class="lineNum">     786 </span>            :    (or slice of the array) always belongs to the range of the array.
<span class="lineNum">     787 </span>            :    I.e. that the access will not trap, provided that the access to
<span class="lineNum">     788 </span>            :    the base to the array will not trap.  */
<span class="lineNum">     789 </span>            : #define TREE_THIS_NOTRAP(NODE) \
<span class="lineNum">     790 </span>            :   (TREE_CHECK5 (NODE, INDIRECT_REF, MEM_REF, TARGET_MEM_REF, ARRAY_REF, \
<span class="lineNum">     791 </span>            :                 ARRAY_RANGE_REF)-&gt;base.nothrow_flag)
<span class="lineNum">     792 </span>            : 
<span class="lineNum">     793 </span>            : /* In a VAR_DECL, PARM_DECL or FIELD_DECL, or any kind of ..._REF node,
<span class="lineNum">     794 </span>            :    nonzero means it may not be the lhs of an assignment.
<span class="lineNum">     795 </span>            :    Nonzero in a FUNCTION_DECL means this function should be treated
<span class="lineNum">     796 </span>            :    as &quot;const&quot; function (can only read its arguments).  */
<span class="lineNum">     797 </span>            : #define TREE_READONLY(NODE) (NON_TYPE_CHECK (NODE)-&gt;base.readonly_flag)
<span class="lineNum">     798 </span>            : 
<span class="lineNum">     799 </span>            : /* Value of expression is constant.  Always on in all ..._CST nodes.  May
<span class="lineNum">     800 </span>            :    also appear in an expression or decl where the value is constant.  */
<span class="lineNum">     801 </span>            : #define TREE_CONSTANT(NODE) (NON_TYPE_CHECK (NODE)-&gt;base.constant_flag)
<span class="lineNum">     802 </span>            : 
<span class="lineNum">     803 </span>            : /* Nonzero if NODE, a type, has had its sizes gimplified.  */
<span class="lineNum">     804 </span>            : #define TYPE_SIZES_GIMPLIFIED(NODE) \
<span class="lineNum">     805 </span>            :   (TYPE_CHECK (NODE)-&gt;base.constant_flag)
<span class="lineNum">     806 </span>            : 
<span class="lineNum">     807 </span>            : /* In a decl (most significantly a FIELD_DECL), means an unsigned field.  */
<span class="lineNum">     808 </span>            : #define DECL_UNSIGNED(NODE) \
<span class="lineNum">     809 </span>            :   (DECL_COMMON_CHECK (NODE)-&gt;base.u.bits.unsigned_flag)
<span class="lineNum">     810 </span>            : 
<span class="lineNum">     811 </span>            : /* In integral and pointer types, means an unsigned type.  */
<span class="lineNum">     812 </span>            : #define TYPE_UNSIGNED(NODE) (TYPE_CHECK (NODE)-&gt;base.u.bits.unsigned_flag)
<span class="lineNum">     813 </span>            : 
<span class="lineNum">     814 </span>            : /* Same as TYPE_UNSIGNED but converted to SIGNOP.  */
<span class="lineNum">     815 </span>            : #define TYPE_SIGN(NODE) ((signop) TYPE_UNSIGNED (NODE))
<span class="lineNum">     816 </span>            : 
<span class="lineNum">     817 </span>            : /* True if overflow wraps around for the given integral or pointer type.  That
<span class="lineNum">     818 </span>            :    is, TYPE_MAX + 1 == TYPE_MIN.  */
<span class="lineNum">     819 </span>            : #define TYPE_OVERFLOW_WRAPS(TYPE) \
<span class="lineNum">     820 </span>            :   (POINTER_TYPE_P (TYPE)                                        \
<span class="lineNum">     821 </span>            :    ? flag_wrapv_pointer                                         \
<span class="lineNum">     822 </span>            :    : (ANY_INTEGRAL_TYPE_CHECK(TYPE)-&gt;base.u.bits.unsigned_flag       \
<span class="lineNum">     823 </span>            :       || flag_wrapv))
<span class="lineNum">     824 </span>            : 
<span class="lineNum">     825 </span>            : /* True if overflow is undefined for the given integral or pointer type.
<span class="lineNum">     826 </span>            :    We may optimize on the assumption that values in the type never overflow.
<span class="lineNum">     827 </span>            : 
<span class="lineNum">     828 </span>            :    IMPORTANT NOTE: Any optimization based on TYPE_OVERFLOW_UNDEFINED
<span class="lineNum">     829 </span>            :    must issue a warning based on warn_strict_overflow.  In some cases
<span class="lineNum">     830 </span>            :    it will be appropriate to issue the warning immediately, and in
<span class="lineNum">     831 </span>            :    other cases it will be appropriate to simply set a flag and let the
<span class="lineNum">     832 </span>            :    caller decide whether a warning is appropriate or not.  */
<span class="lineNum">     833 </span>            : #define TYPE_OVERFLOW_UNDEFINED(TYPE)                           \
<span class="lineNum">     834 </span>            :   (POINTER_TYPE_P (TYPE)                                        \
<span class="lineNum">     835 </span>            :    ? !flag_wrapv_pointer                                        \
<span class="lineNum">     836 </span>            :    : (!ANY_INTEGRAL_TYPE_CHECK(TYPE)-&gt;base.u.bits.unsigned_flag      \
<span class="lineNum">     837 </span>            :       &amp;&amp; !flag_wrapv &amp;&amp; !flag_trapv))
<span class="lineNum">     838 </span>            : 
<span class="lineNum">     839 </span>            : /* True if overflow for the given integral type should issue a
<span class="lineNum">     840 </span>            :    trap.  */
<span class="lineNum">     841 </span>            : #define TYPE_OVERFLOW_TRAPS(TYPE) \
<span class="lineNum">     842 </span>            :   (!ANY_INTEGRAL_TYPE_CHECK(TYPE)-&gt;base.u.bits.unsigned_flag &amp;&amp; flag_trapv)
<span class="lineNum">     843 </span>            : 
<span class="lineNum">     844 </span>            : /* True if an overflow is to be preserved for sanitization.  */
<span class="lineNum">     845 </span>            : #define TYPE_OVERFLOW_SANITIZED(TYPE)                   \
<span class="lineNum">     846 </span>            :   (INTEGRAL_TYPE_P (TYPE)                               \
<span class="lineNum">     847 </span>            :    &amp;&amp; !TYPE_OVERFLOW_WRAPS (TYPE)                       \
<span class="lineNum">     848 </span>            :    &amp;&amp; (flag_sanitize &amp; SANITIZE_SI_OVERFLOW))
<span class="lineNum">     849 </span>            : 
<span class="lineNum">     850 </span>            : /* Nonzero in a VAR_DECL or STRING_CST means assembler code has been written.
<span class="lineNum">     851 </span>            :    Nonzero in a FUNCTION_DECL means that the function has been compiled.
<span class="lineNum">     852 </span>            :    This is interesting in an inline function, since it might not need
<span class="lineNum">     853 </span>            :    to be compiled separately.
<span class="lineNum">     854 </span>            :    Nonzero in a RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE, ENUMERAL_TYPE
<span class="lineNum">     855 </span>            :    or TYPE_DECL if the debugging info for the type has been written.
<span class="lineNum">     856 </span>            :    In a BLOCK node, nonzero if reorder_blocks has already seen this block.
<span class="lineNum">     857 </span>            :    In an SSA_NAME node, nonzero if the SSA_NAME occurs in an abnormal
<span class="lineNum">     858 </span>            :    PHI node.  */
<span class="lineNum">     859 </span>            : #define TREE_ASM_WRITTEN(NODE) ((NODE)-&gt;base.asm_written_flag)
<span class="lineNum">     860 </span>            : 
<span class="lineNum">     861 </span>            : /* Nonzero in a _DECL if the name is used in its scope.
<span class="lineNum">     862 </span>            :    Nonzero in an expr node means inhibit warning if value is unused.
<span class="lineNum">     863 </span>            :    In IDENTIFIER_NODEs, this means that some extern decl for this name
<span class="lineNum">     864 </span>            :    was used.
<span class="lineNum">     865 </span>            :    In a BLOCK, this means that the block contains variables that are used.  */
<span class="lineNum">     866 </span>            : #define TREE_USED(NODE) ((NODE)-&gt;base.used_flag)
<span class="lineNum">     867 </span>            : 
<span class="lineNum">     868 </span>            : /* In a FUNCTION_DECL, nonzero means a call to the function cannot
<span class="lineNum">     869 </span>            :    throw an exception.  In a CALL_EXPR, nonzero means the call cannot
<span class="lineNum">     870 </span>            :    throw.  We can't easily check the node type here as the C++
<span class="lineNum">     871 </span>            :    frontend also uses this flag (for AGGR_INIT_EXPR).  */
<span class="lineNum">     872 </span>            : #define TREE_NOTHROW(NODE) ((NODE)-&gt;base.nothrow_flag)
<span class="lineNum">     873 </span>            : 
<span class="lineNum">     874 </span>            : /* In a CALL_EXPR, means that it's safe to use the target of the call
<span class="lineNum">     875 </span>            :    expansion as the return slot for a call that returns in memory.  */
<span class="lineNum">     876 </span>            : #define CALL_EXPR_RETURN_SLOT_OPT(NODE) \
<span class="lineNum">     877 </span>            :   (CALL_EXPR_CHECK (NODE)-&gt;base.private_flag)
<span class="lineNum">     878 </span>            : 
<span class="lineNum">     879 </span>            : /* In a RESULT_DECL, PARM_DECL and VAR_DECL, means that it is
<span class="lineNum">     880 </span>            :    passed by invisible reference (and the TREE_TYPE is a pointer to the true
<span class="lineNum">     881 </span>            :    type).  */
<span class="lineNum">     882 </span>            : #define DECL_BY_REFERENCE(NODE) \
<span class="lineNum">     883 </span>            :   (TREE_CHECK3 (NODE, VAR_DECL, PARM_DECL, \
<span class="lineNum">     884 </span>            :                 RESULT_DECL)-&gt;decl_common.decl_by_reference_flag)
<span class="lineNum">     885 </span>            : 
<span class="lineNum">     886 </span>            : /* In VAR_DECL and PARM_DECL, set when the decl has been used except for
<span class="lineNum">     887 </span>            :    being set.  */
<span class="lineNum">     888 </span>            : #define DECL_READ_P(NODE) \
<span class="lineNum">     889 </span>            :   (TREE_CHECK2 (NODE, VAR_DECL, PARM_DECL)-&gt;decl_common.decl_read_flag)
<span class="lineNum">     890 </span>            : 
<span class="lineNum">     891 </span>            : /* In VAR_DECL or RESULT_DECL, set when significant code movement precludes
<span class="lineNum">     892 </span>            :    attempting to share the stack slot with some other variable.  */
<span class="lineNum">     893 </span>            : #define DECL_NONSHAREABLE(NODE) \
<span class="lineNum">     894 </span>            :   (TREE_CHECK2 (NODE, VAR_DECL, \
<span class="lineNum">     895 </span>            :                 RESULT_DECL)-&gt;decl_common.decl_nonshareable_flag)
<span class="lineNum">     896 </span>            : 
<span class="lineNum">     897 </span>            : /* In a CALL_EXPR, means that the call is the jump from a thunk to the
<span class="lineNum">     898 </span>            :    thunked-to function.  */
<span class="lineNum">     899 </span>            : #define CALL_FROM_THUNK_P(NODE) (CALL_EXPR_CHECK (NODE)-&gt;base.protected_flag)
<span class="lineNum">     900 </span>            : 
<span class="lineNum">     901 </span>            : /* In a CALL_EXPR, if the function being called is BUILT_IN_ALLOCA, means that
<span class="lineNum">     902 </span>            :    it has been built for the declaration of a variable-sized object.  */
<span class="lineNum">     903 </span>            : #define CALL_ALLOCA_FOR_VAR_P(NODE) \
<span class="lineNum">     904 </span>            :   (CALL_EXPR_CHECK (NODE)-&gt;base.protected_flag)
<span class="lineNum">     905 </span>            : 
<span class="lineNum">     906 </span>            : /* Used in classes in C++.  */
<span class="lineNum">     907 </span>            : #define TREE_PRIVATE(NODE) ((NODE)-&gt;base.private_flag)
<span class="lineNum">     908 </span>            : /* Used in classes in C++. */
<span class="lineNum">     909 </span>            : #define TREE_PROTECTED(NODE) ((NODE)-&gt;base.protected_flag)
<span class="lineNum">     910 </span>            : 
<span class="lineNum">     911 </span>            : /* True if reference type NODE is a C++ rvalue reference.  */
<span class="lineNum">     912 </span>            : #define TYPE_REF_IS_RVALUE(NODE) \
<span class="lineNum">     913 </span>            :   (REFERENCE_TYPE_CHECK (NODE)-&gt;base.private_flag)
<span class="lineNum">     914 </span>            : 
<span class="lineNum">     915 </span>            : /* Nonzero in a _DECL if the use of the name is defined as a
<span class="lineNum">     916 </span>            :    deprecated feature by __attribute__((deprecated)).  */
<span class="lineNum">     917 </span>            : #define TREE_DEPRECATED(NODE) \
<span class="lineNum">     918 </span>            :   ((NODE)-&gt;base.deprecated_flag)
<span class="lineNum">     919 </span>            : 
<span class="lineNum">     920 </span>            : /* Nonzero in an IDENTIFIER_NODE if the name is a local alias, whose
<span class="lineNum">     921 </span>            :    uses are to be substituted for uses of the TREE_CHAINed identifier.  */
<span class="lineNum">     922 </span>            : #define IDENTIFIER_TRANSPARENT_ALIAS(NODE) \
<span class="lineNum">     923 </span>            :   (IDENTIFIER_NODE_CHECK (NODE)-&gt;base.deprecated_flag)
<span class="lineNum">     924 </span>            : 
<span class="lineNum">     925 </span>            : /* In an aggregate type, indicates that the scalar fields of the type are
<span class="lineNum">     926 </span>            :    stored in reverse order from the target order.  This effectively
<span class="lineNum">     927 </span>            :    toggles BYTES_BIG_ENDIAN and WORDS_BIG_ENDIAN within the type.  */
<span class="lineNum">     928 </span>            : #define TYPE_REVERSE_STORAGE_ORDER(NODE) \
<span class="lineNum">     929 </span>            :   (TREE_CHECK4 (NODE, RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE, ARRAY_TYPE)-&gt;base.u.bits.saturating_flag)
<span class="lineNum">     930 </span>            : 
<span class="lineNum">     931 </span>            : /* In a non-aggregate type, indicates a saturating type.  */
<span class="lineNum">     932 </span>            : #define TYPE_SATURATING(NODE) \
<span class="lineNum">     933 </span>            :   (TREE_NOT_CHECK4 (NODE, RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE, ARRAY_TYPE)-&gt;base.u.bits.saturating_flag)
<span class="lineNum">     934 </span>            : 
<span class="lineNum">     935 </span>            : /* In a BIT_FIELD_REF and MEM_REF, indicates that the reference is to a group
<span class="lineNum">     936 </span>            :    of bits stored in reverse order from the target order.  This effectively
<span class="lineNum">     937 </span>            :    toggles both BYTES_BIG_ENDIAN and WORDS_BIG_ENDIAN for the reference.
<span class="lineNum">     938 </span>            : 
<span class="lineNum">     939 </span>            :    The overall strategy is to preserve the invariant that every scalar in
<span class="lineNum">     940 </span>            :    memory is associated with a single storage order, i.e. all accesses to
<span class="lineNum">     941 </span>            :    this scalar are done with the same storage order.  This invariant makes
<span class="lineNum">     942 </span>            :    it possible to factor out the storage order in most transformations, as
<span class="lineNum">     943 </span>            :    only the address and/or the value (in target order) matter for them.
<span class="lineNum">     944 </span>            :    But, of course, the storage order must be preserved when the accesses
<span class="lineNum">     945 </span>            :    themselves are rewritten or transformed.  */
<span class="lineNum">     946 </span>            : #define REF_REVERSE_STORAGE_ORDER(NODE) \
<span class="lineNum">     947 </span>            :   (TREE_CHECK2 (NODE, BIT_FIELD_REF, MEM_REF)-&gt;base.default_def_flag)
<span class="lineNum">     948 </span>            : 
<span class="lineNum">     949 </span>            :   /* In an ADDR_EXPR, indicates that this is a pointer to nested function
<span class="lineNum">     950 </span>            :    represented by a descriptor instead of a trampoline.  */
<span class="lineNum">     951 </span>            : #define FUNC_ADDR_BY_DESCRIPTOR(NODE) \
<span class="lineNum">     952 </span>            :   (TREE_CHECK (NODE, ADDR_EXPR)-&gt;base.default_def_flag)
<span class="lineNum">     953 </span>            : 
<span class="lineNum">     954 </span>            : /* In a CALL_EXPR, indicates that this is an indirect call for which
<span class="lineNum">     955 </span>            :    pointers to nested function are descriptors instead of trampolines.  */
<span class="lineNum">     956 </span>            : #define CALL_EXPR_BY_DESCRIPTOR(NODE) \
<span class="lineNum">     957 </span>            :   (TREE_CHECK (NODE, CALL_EXPR)-&gt;base.default_def_flag)
<span class="lineNum">     958 </span>            : 
<span class="lineNum">     959 </span>            : /* These flags are available for each language front end to use internally.  */
<span class="lineNum">     960 </span>            : #define TREE_LANG_FLAG_0(NODE) \
<span class="lineNum">     961 </span>            :   (TREE_NOT_CHECK2 (NODE, TREE_VEC, SSA_NAME)-&gt;base.u.bits.lang_flag_0)
<span class="lineNum">     962 </span>            : #define TREE_LANG_FLAG_1(NODE) \
<span class="lineNum">     963 </span>            :   (TREE_NOT_CHECK2 (NODE, TREE_VEC, SSA_NAME)-&gt;base.u.bits.lang_flag_1)
<span class="lineNum">     964 </span>            : #define TREE_LANG_FLAG_2(NODE) \
<span class="lineNum">     965 </span>            :   (TREE_NOT_CHECK2 (NODE, TREE_VEC, SSA_NAME)-&gt;base.u.bits.lang_flag_2)
<span class="lineNum">     966 </span>            : #define TREE_LANG_FLAG_3(NODE) \
<span class="lineNum">     967 </span>            :   (TREE_NOT_CHECK2 (NODE, TREE_VEC, SSA_NAME)-&gt;base.u.bits.lang_flag_3)
<span class="lineNum">     968 </span>            : #define TREE_LANG_FLAG_4(NODE) \
<span class="lineNum">     969 </span>            :   (TREE_NOT_CHECK2 (NODE, TREE_VEC, SSA_NAME)-&gt;base.u.bits.lang_flag_4)
<span class="lineNum">     970 </span>            : #define TREE_LANG_FLAG_5(NODE) \
<span class="lineNum">     971 </span>            :   (TREE_NOT_CHECK2 (NODE, TREE_VEC, SSA_NAME)-&gt;base.u.bits.lang_flag_5)
<span class="lineNum">     972 </span>            : #define TREE_LANG_FLAG_6(NODE) \
<span class="lineNum">     973 </span>            :   (TREE_NOT_CHECK2 (NODE, TREE_VEC, SSA_NAME)-&gt;base.u.bits.lang_flag_6)
<span class="lineNum">     974 </span>            : 
<span class="lineNum">     975 </span>            : /* Define additional fields and accessors for nodes representing constants.  */
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span>            : #define TREE_INT_CST_NUNITS(NODE) \
<span class="lineNum">     978 </span>            :   (INTEGER_CST_CHECK (NODE)-&gt;base.u.int_length.unextended)
<span class="lineNum">     979 </span>            : #define TREE_INT_CST_EXT_NUNITS(NODE) \
<span class="lineNum">     980 </span>            :   (INTEGER_CST_CHECK (NODE)-&gt;base.u.int_length.extended)
<span class="lineNum">     981 </span>            : #define TREE_INT_CST_OFFSET_NUNITS(NODE) \
<span class="lineNum">     982 </span>            :   (INTEGER_CST_CHECK (NODE)-&gt;base.u.int_length.offset)
<span class="lineNum">     983 </span>            : #define TREE_INT_CST_ELT(NODE, I) TREE_INT_CST_ELT_CHECK (NODE, I)
<span class="lineNum">     984 </span>            : #define TREE_INT_CST_LOW(NODE) \
<span class="lineNum">     985 </span>            :   ((unsigned HOST_WIDE_INT) TREE_INT_CST_ELT (NODE, 0))
<span class="lineNum">     986 </span>            : 
<span class="lineNum">     987 </span>            : /* Return true if NODE is a POLY_INT_CST.  This is only ever true on
<span class="lineNum">     988 </span>            :    targets with variable-sized modes.  */
<span class="lineNum">     989 </span>            : #define POLY_INT_CST_P(NODE) \
<span class="lineNum">     990 </span>            :   (NUM_POLY_INT_COEFFS &gt; 1 &amp;&amp; TREE_CODE (NODE) == POLY_INT_CST)
<span class="lineNum">     991 </span>            : 
<span class="lineNum">     992 </span>            : /* In a POLY_INT_CST node.  */
<span class="lineNum">     993 </span>            : #define POLY_INT_CST_COEFF(NODE, I) \
<span class="lineNum">     994 </span>            :   (POLY_INT_CST_CHECK (NODE)-&gt;poly_int_cst.coeffs[I])
<span class="lineNum">     995 </span>            : 
<span class="lineNum">     996 </span>            : #define TREE_REAL_CST_PTR(NODE) (REAL_CST_CHECK (NODE)-&gt;real_cst.real_cst_ptr)
<span class="lineNum">     997 </span>            : #define TREE_REAL_CST(NODE) (*TREE_REAL_CST_PTR (NODE))
<span class="lineNum">     998 </span>            : 
<span class="lineNum">     999 </span>            : #define TREE_FIXED_CST_PTR(NODE) \
<span class="lineNum">    1000 </span>            :   (FIXED_CST_CHECK (NODE)-&gt;fixed_cst.fixed_cst_ptr)
<span class="lineNum">    1001 </span>            : #define TREE_FIXED_CST(NODE) (*TREE_FIXED_CST_PTR (NODE))
<span class="lineNum">    1002 </span>            : 
<span class="lineNum">    1003 </span>            : /* In a STRING_CST */
<span class="lineNum">    1004 </span>            : /* In C terms, this is sizeof, not strlen.  */
<span class="lineNum">    1005 </span>            : #define TREE_STRING_LENGTH(NODE) (STRING_CST_CHECK (NODE)-&gt;string.length)
<span class="lineNum">    1006 </span>            : #define TREE_STRING_POINTER(NODE) \
<span class="lineNum">    1007 </span>            :   ((const char *)(STRING_CST_CHECK (NODE)-&gt;string.str))
<span class="lineNum">    1008 </span>            : 
<span class="lineNum">    1009 </span>            : /* In a COMPLEX_CST node.  */
<span class="lineNum">    1010 </span>            : #define TREE_REALPART(NODE) (COMPLEX_CST_CHECK (NODE)-&gt;complex.real)
<span class="lineNum">    1011 </span>            : #define TREE_IMAGPART(NODE) (COMPLEX_CST_CHECK (NODE)-&gt;complex.imag)
<span class="lineNum">    1012 </span>            : 
<span class="lineNum">    1013 </span>            : /* In a VECTOR_CST node.  See generic.texi for details.  */
<span class="lineNum">    1014 </span>            : #define VECTOR_CST_NELTS(NODE) (TYPE_VECTOR_SUBPARTS (TREE_TYPE (NODE)))
<span class="lineNum">    1015 </span>            : #define VECTOR_CST_ELT(NODE,IDX) vector_cst_elt (NODE, IDX)
<span class="lineNum">    1016 </span>            : 
<span class="lineNum">    1017 </span>            : #define VECTOR_CST_LOG2_NPATTERNS(NODE) \
<span class="lineNum">    1018 </span>            :   (VECTOR_CST_CHECK (NODE)-&gt;base.u.vector_cst.log2_npatterns)
<span class="lineNum">    1019 </span>            : #define VECTOR_CST_NPATTERNS(NODE) \
<span class="lineNum">    1020 </span>            :   (1U &lt;&lt; VECTOR_CST_LOG2_NPATTERNS (NODE))
<span class="lineNum">    1021 </span>            : #define VECTOR_CST_NELTS_PER_PATTERN(NODE) \
<span class="lineNum">    1022 </span>            :   (VECTOR_CST_CHECK (NODE)-&gt;base.u.vector_cst.nelts_per_pattern)
<span class="lineNum">    1023 </span>            : #define VECTOR_CST_DUPLICATE_P(NODE) \
<span class="lineNum">    1024 </span>            :   (VECTOR_CST_NELTS_PER_PATTERN (NODE) == 1)
<span class="lineNum">    1025 </span>            : #define VECTOR_CST_STEPPED_P(NODE) \
<span class="lineNum">    1026 </span>            :   (VECTOR_CST_NELTS_PER_PATTERN (NODE) == 3)
<span class="lineNum">    1027 </span>            : #define VECTOR_CST_ENCODED_ELTS(NODE) \
<span class="lineNum">    1028 </span>            :   (VECTOR_CST_CHECK (NODE)-&gt;vector.elts)
<span class="lineNum">    1029 </span>            : #define VECTOR_CST_ENCODED_ELT(NODE, ELT) \
<span class="lineNum">    1030 </span>            :   (VECTOR_CST_CHECK (NODE)-&gt;vector.elts[ELT])
<span class="lineNum">    1031 </span>            : 
<span class="lineNum">    1032 </span>            : /* Define fields and accessors for some special-purpose tree nodes.  */
<span class="lineNum">    1033 </span>            : 
<span class="lineNum">    1034 </span>            : #define IDENTIFIER_LENGTH(NODE) \
<span class="lineNum">    1035 </span>            :   (IDENTIFIER_NODE_CHECK (NODE)-&gt;identifier.id.len)
<span class="lineNum">    1036 </span>            : #define IDENTIFIER_POINTER(NODE) \
<span class="lineNum">    1037 </span>            :   ((const char *) IDENTIFIER_NODE_CHECK (NODE)-&gt;identifier.id.str)
<span class="lineNum">    1038 </span>            : #define IDENTIFIER_HASH_VALUE(NODE) \
<span class="lineNum">    1039 </span>            :   (IDENTIFIER_NODE_CHECK (NODE)-&gt;identifier.id.hash_value)
<span class="lineNum">    1040 </span>            : 
<span class="lineNum">    1041 </span>            : /* Translate a hash table identifier pointer to a tree_identifier
<span class="lineNum">    1042 </span>            :    pointer, and vice versa.  */
<span class="lineNum">    1043 </span>            : 
<span class="lineNum">    1044 </span>            : #define HT_IDENT_TO_GCC_IDENT(NODE) \
<span class="lineNum">    1045 </span>            :   ((tree) ((char *) (NODE) - sizeof (struct tree_common)))
<span class="lineNum">    1046 </span>            : #define GCC_IDENT_TO_HT_IDENT(NODE) (&amp;((struct tree_identifier *) (NODE))-&gt;id)
<span class="lineNum">    1047 </span>            : 
<span class="lineNum">    1048 </span>            : /* In a TREE_LIST node.  */
<span class="lineNum">    1049 </span>            : #define TREE_PURPOSE(NODE) (TREE_LIST_CHECK (NODE)-&gt;list.purpose)
<span class="lineNum">    1050 </span>            : #define TREE_VALUE(NODE) (TREE_LIST_CHECK (NODE)-&gt;list.value)
<span class="lineNum">    1051 </span>            : 
<span class="lineNum">    1052 </span>            : /* In a TREE_VEC node.  */
<span class="lineNum">    1053 </span>            : #define TREE_VEC_LENGTH(NODE) (TREE_VEC_CHECK (NODE)-&gt;base.u.length)
<span class="lineNum">    1054 </span>            : #define TREE_VEC_END(NODE) \
<span class="lineNum">    1055 </span>            :   ((void) TREE_VEC_CHECK (NODE), &amp;((NODE)-&gt;vec.a[(NODE)-&gt;vec.base.u.length]))
<span class="lineNum">    1056 </span>            : 
<span class="lineNum">    1057 </span>            : #define TREE_VEC_ELT(NODE,I) TREE_VEC_ELT_CHECK (NODE, I)
<span class="lineNum">    1058 </span>            : 
<span class="lineNum">    1059 </span>            : /* In a CONSTRUCTOR node.  */
<span class="lineNum">    1060 </span>            : #define CONSTRUCTOR_ELTS(NODE) (CONSTRUCTOR_CHECK (NODE)-&gt;constructor.elts)
<span class="lineNum">    1061 </span>            : #define CONSTRUCTOR_ELT(NODE,IDX) \
<span class="lineNum">    1062 </span>            :   (&amp;(*CONSTRUCTOR_ELTS (NODE))[IDX])
<span class="lineNum">    1063 </span>            : #define CONSTRUCTOR_NELTS(NODE) \
<span class="lineNum">    1064 </span>            :   (vec_safe_length (CONSTRUCTOR_ELTS (NODE)))
<span class="lineNum">    1065 </span>            : #define CONSTRUCTOR_NO_CLEARING(NODE) \
<span class="lineNum">    1066 </span>            :   (CONSTRUCTOR_CHECK (NODE)-&gt;base.public_flag)
<span class="lineNum">    1067 </span>            : 
<span class="lineNum">    1068 </span>            : /* Iterate through the vector V of CONSTRUCTOR_ELT elements, yielding the
<span class="lineNum">    1069 </span>            :    value of each element (stored within VAL). IX must be a scratch variable
<span class="lineNum">    1070 </span>            :    of unsigned integer type.  */
<span class="lineNum">    1071 </span>            : #define FOR_EACH_CONSTRUCTOR_VALUE(V, IX, VAL) \
<span class="lineNum">    1072 </span>            :   for (IX = 0; (IX &gt;= vec_safe_length (V)) \
<span class="lineNum">    1073 </span>            :                ? false \
<span class="lineNum">    1074 </span>            :                : ((VAL = (*(V))[IX].value), \
<span class="lineNum">    1075 </span>            :                true); \
<span class="lineNum">    1076 </span>            :        (IX)++)
<span class="lineNum">    1077 </span>            : 
<span class="lineNum">    1078 </span>            : /* Iterate through the vector V of CONSTRUCTOR_ELT elements, yielding both
<span class="lineNum">    1079 </span>            :    the value of each element (stored within VAL) and its index (stored
<span class="lineNum">    1080 </span>            :    within INDEX). IX must be a scratch variable of unsigned integer type.  */
<span class="lineNum">    1081 </span>            : #define FOR_EACH_CONSTRUCTOR_ELT(V, IX, INDEX, VAL) \
<span class="lineNum">    1082 </span>            :   for (IX = 0; (IX &gt;= vec_safe_length (V)) \
<span class="lineNum">    1083 </span>            :                ? false \
<span class="lineNum">    1084 </span>            :                : (((void) (VAL = (*V)[IX].value)), \
<span class="lineNum">    1085 </span>            :                   (INDEX = (*V)[IX].index), \
<span class="lineNum">    1086 </span>            :                   true); \
<span class="lineNum">    1087 </span>            :        (IX)++)
<span class="lineNum">    1088 </span>            : 
<span class="lineNum">    1089 </span>            : /* Append a new constructor element to V, with the specified INDEX and VAL.  */
<span class="lineNum">    1090 </span>            : #define CONSTRUCTOR_APPEND_ELT(V, INDEX, VALUE) \
<span class="lineNum">    1091 </span>            :   do { \
<span class="lineNum">    1092 </span>            :     constructor_elt _ce___ = {INDEX, VALUE}; \
<span class="lineNum">    1093 </span>            :     vec_safe_push ((V), _ce___); \
<span class="lineNum">    1094 </span>            :   } while (0)
<span class="lineNum">    1095 </span>            : 
<span class="lineNum">    1096 </span>            : /* True if NODE, a FIELD_DECL, is to be processed as a bitfield for
<span class="lineNum">    1097 </span>            :    constructor output purposes.  */
<span class="lineNum">    1098 </span>            : #define CONSTRUCTOR_BITFIELD_P(NODE) \
<span class="lineNum">    1099 </span>            :   (DECL_BIT_FIELD (FIELD_DECL_CHECK (NODE)) &amp;&amp; DECL_MODE (NODE) != BLKmode)
<span class="lineNum">    1100 </span>            : 
<span class="lineNum">    1101 </span>            : /* True if NODE is a clobber right hand side, an expression of indeterminate
<span class="lineNum">    1102 </span>            :    value that clobbers the LHS in a copy instruction.  We use a volatile
<span class="lineNum">    1103 </span>            :    empty CONSTRUCTOR for this, as it matches most of the necessary semantic.
<span class="lineNum">    1104 </span>            :    In particular the volatile flag causes us to not prematurely remove
<span class="lineNum">    1105 </span>            :    such clobber instructions.  */
<span class="lineNum">    1106 </span>            : #define TREE_CLOBBER_P(NODE) \
<span class="lineNum">    1107 </span>            :   (TREE_CODE (NODE) == CONSTRUCTOR &amp;&amp; TREE_THIS_VOLATILE (NODE))
<span class="lineNum">    1108 </span>            : 
<span class="lineNum">    1109 </span>            : /* Define fields and accessors for some nodes that represent expressions.  */
<span class="lineNum">    1110 </span>            : 
<span class="lineNum">    1111 </span>            : /* Nonzero if NODE is an empty statement (NOP_EXPR &lt;0&gt;).  */
<span class="lineNum">    1112 </span>            : #define IS_EMPTY_STMT(NODE)     (TREE_CODE (NODE) == NOP_EXPR \
<span class="lineNum">    1113 </span>            :                                  &amp;&amp; VOID_TYPE_P (TREE_TYPE (NODE)) \
<span class="lineNum">    1114 </span>            :                                  &amp;&amp; integer_zerop (TREE_OPERAND (NODE, 0)))
<span class="lineNum">    1115 </span>            : 
<span class="lineNum">    1116 </span>            : /* In ordinary expression nodes.  */
<span class="lineNum">    1117 </span>            : #define TREE_OPERAND_LENGTH(NODE) tree_operand_length (NODE)
<span class="lineNum">    1118 </span>            : #define TREE_OPERAND(NODE, I) TREE_OPERAND_CHECK (NODE, I)
<span class="lineNum">    1119 </span>            : 
<span class="lineNum">    1120 </span>            : /* In a tcc_vl_exp node, operand 0 is an INT_CST node holding the operand
<span class="lineNum">    1121 </span>            :    length.  Its value includes the length operand itself; that is,
<span class="lineNum">    1122 </span>            :    the minimum valid length is 1.
<span class="lineNum">    1123 </span>            :    Note that we have to bypass the use of TREE_OPERAND to access
<span class="lineNum">    1124 </span>            :    that field to avoid infinite recursion in expanding the macros.  */
<span class="lineNum">    1125 </span>            : #define VL_EXP_OPERAND_LENGTH(NODE) \
<span class="lineNum">    1126 </span>            :   ((int)TREE_INT_CST_LOW (VL_EXP_CHECK (NODE)-&gt;exp.operands[0]))
<span class="lineNum">    1127 </span>            : 
<span class="lineNum">    1128 </span>            : /* Nonzero if gimple_debug_nonbind_marker_p() may possibly hold.  */
<span class="lineNum">    1129 </span>            : #define MAY_HAVE_DEBUG_MARKER_STMTS debug_nonbind_markers_p
<span class="lineNum">    1130 </span>            : /* Nonzero if gimple_debug_bind_p() (and thus
<span class="lineNum">    1131 </span>            :    gimple_debug_source_bind_p()) may possibly hold.  */
<span class="lineNum">    1132 </span>            : #define MAY_HAVE_DEBUG_BIND_STMTS flag_var_tracking_assignments
<span class="lineNum">    1133 </span>            : /* Nonzero if is_gimple_debug() may possibly hold.  */
<span class="lineNum">    1134 </span>            : #define MAY_HAVE_DEBUG_STMTS                                    \
<span class="lineNum">    1135 </span>            :   (MAY_HAVE_DEBUG_MARKER_STMTS || MAY_HAVE_DEBUG_BIND_STMTS)
<span class="lineNum">    1136 </span>            : 
<span class="lineNum">    1137 </span>            : /* In a LOOP_EXPR node.  */
<span class="lineNum">    1138 </span>            : #define LOOP_EXPR_BODY(NODE) TREE_OPERAND_CHECK_CODE (NODE, LOOP_EXPR, 0)
<span class="lineNum">    1139 </span>            : 
<span class="lineNum">    1140 </span>            : /* The source location of this expression.  Non-tree_exp nodes such as
<span class="lineNum">    1141 </span>            :    decls and constants can be shared among multiple locations, so
<span class="lineNum">    1142 </span>            :    return nothing.  */
<span class="lineNum">    1143 </span>            : #define EXPR_LOCATION(NODE) \
<span class="lineNum">    1144 </span>            :   (CAN_HAVE_LOCATION_P ((NODE)) ? (NODE)-&gt;exp.locus : UNKNOWN_LOCATION)
<span class="lineNum">    1145 </span>            : #define SET_EXPR_LOCATION(NODE, LOCUS) EXPR_CHECK ((NODE))-&gt;exp.locus = (LOCUS)
<span class="lineNum">    1146 </span>            : #define EXPR_HAS_LOCATION(NODE) (LOCATION_LOCUS (EXPR_LOCATION (NODE))  \
<span class="lineNum">    1147 </span>            :   != UNKNOWN_LOCATION)
<span class="lineNum">    1148 </span>            : /* The location to be used in a diagnostic about this expression.  Do not
<span class="lineNum">    1149 </span>            :    use this macro if the location will be assigned to other expressions.  */
<span class="lineNum">    1150 </span>            : #define EXPR_LOC_OR_LOC(NODE, LOCUS) (EXPR_HAS_LOCATION (NODE) \
<span class="lineNum">    1151 </span>            :                                       ? (NODE)-&gt;exp.locus : (LOCUS))
<span class="lineNum">    1152 </span>            : #define EXPR_FILENAME(NODE) LOCATION_FILE (EXPR_CHECK ((NODE))-&gt;exp.locus)
<span class="lineNum">    1153 </span>            : #define EXPR_LINENO(NODE) LOCATION_LINE (EXPR_CHECK (NODE)-&gt;exp.locus)
<span class="lineNum">    1154 </span>            : 
<span class="lineNum">    1155 </span>            : #define CAN_HAVE_RANGE_P(NODE) (CAN_HAVE_LOCATION_P (NODE))
<span class="lineNum">    1156 </span>            : #define EXPR_LOCATION_RANGE(NODE) (get_expr_source_range (EXPR_CHECK ((NODE))))
<span class="lineNum">    1157 </span>            : 
<span class="lineNum">    1158 </span>            : #define EXPR_HAS_RANGE(NODE) \
<span class="lineNum">    1159 </span>            :     (CAN_HAVE_RANGE_P (NODE) \
<span class="lineNum">    1160 </span>            :      ? EXPR_LOCATION_RANGE (NODE).m_start != UNKNOWN_LOCATION \
<span class="lineNum">    1161 </span>            :      : false)
<span class="lineNum">    1162 </span>            : 
<span class="lineNum">    1163 </span>            : /* True if a tree is an expression or statement that can have a
<span class="lineNum">    1164 </span>            :    location.  */
<span class="lineNum">    1165 </span>            : #define CAN_HAVE_LOCATION_P(NODE) ((NODE) &amp;&amp; EXPR_P (NODE))
<a name="1166"><span class="lineNum">    1166 </span>            : </a>
<span class="lineNum">    1167 </span>            : static inline source_range
<span class="lineNum">    1168 </span><span class="lineCov">  132090770 : get_expr_source_range (tree expr)</span>
<span class="lineNum">    1169 </span>            : {
<span class="lineNum">    1170 </span><span class="lineCov">  132090770 :   location_t loc = EXPR_LOCATION (expr);</span>
<span class="lineNum">    1171 </span><span class="lineCov">  132090770 :   return get_range_from_loc (line_table, loc);</span>
<span class="lineNum">    1172 </span>            : }
<span class="lineNum">    1173 </span>            : 
<span class="lineNum">    1174 </span>            : extern void protected_set_expr_location (tree, location_t);
<span class="lineNum">    1175 </span>            : 
<span class="lineNum">    1176 </span>            : extern tree maybe_wrap_with_location (tree, location_t);
<span class="lineNum">    1177 </span>            : 
<span class="lineNum">    1178 </span>            : /* In a TARGET_EXPR node.  */
<span class="lineNum">    1179 </span>            : #define TARGET_EXPR_SLOT(NODE) TREE_OPERAND_CHECK_CODE (NODE, TARGET_EXPR, 0)
<span class="lineNum">    1180 </span>            : #define TARGET_EXPR_INITIAL(NODE) TREE_OPERAND_CHECK_CODE (NODE, TARGET_EXPR, 1)
<span class="lineNum">    1181 </span>            : #define TARGET_EXPR_CLEANUP(NODE) TREE_OPERAND_CHECK_CODE (NODE, TARGET_EXPR, 2)
<span class="lineNum">    1182 </span>            : /* Don't elide the initialization of TARGET_EXPR_SLOT for this TARGET_EXPR
<span class="lineNum">    1183 </span>            :    on rhs of MODIFY_EXPR.  */
<span class="lineNum">    1184 </span>            : #define TARGET_EXPR_NO_ELIDE(NODE) (TARGET_EXPR_CHECK (NODE)-&gt;base.private_flag)
<span class="lineNum">    1185 </span>            : 
<span class="lineNum">    1186 </span>            : /* DECL_EXPR accessor. This gives access to the DECL associated with
<span class="lineNum">    1187 </span>            :    the given declaration statement.  */
<span class="lineNum">    1188 </span>            : #define DECL_EXPR_DECL(NODE)    TREE_OPERAND (DECL_EXPR_CHECK (NODE), 0)
<span class="lineNum">    1189 </span>            : 
<span class="lineNum">    1190 </span>            : #define EXIT_EXPR_COND(NODE)         TREE_OPERAND (EXIT_EXPR_CHECK (NODE), 0)
<span class="lineNum">    1191 </span>            : 
<span class="lineNum">    1192 </span>            : /* COMPOUND_LITERAL_EXPR accessors.  */
<span class="lineNum">    1193 </span>            : #define COMPOUND_LITERAL_EXPR_DECL_EXPR(NODE)           \
<span class="lineNum">    1194 </span>            :   TREE_OPERAND (COMPOUND_LITERAL_EXPR_CHECK (NODE), 0)
<span class="lineNum">    1195 </span>            : #define COMPOUND_LITERAL_EXPR_DECL(NODE)                        \
<span class="lineNum">    1196 </span>            :   DECL_EXPR_DECL (COMPOUND_LITERAL_EXPR_DECL_EXPR (NODE))
<span class="lineNum">    1197 </span>            : 
<span class="lineNum">    1198 </span>            : /* SWITCH_EXPR accessors. These give access to the condition and body.  */
<span class="lineNum">    1199 </span>            : #define SWITCH_COND(NODE)       TREE_OPERAND (SWITCH_EXPR_CHECK (NODE), 0)
<span class="lineNum">    1200 </span>            : #define SWITCH_BODY(NODE)       TREE_OPERAND (SWITCH_EXPR_CHECK (NODE), 1)
<span class="lineNum">    1201 </span>            : /* True if there are case labels for all possible values of SWITCH_COND, either
<span class="lineNum">    1202 </span>            :    because there is a default: case label or because the case label ranges cover
<span class="lineNum">    1203 </span>            :    all values.  */
<span class="lineNum">    1204 </span>            : #define SWITCH_ALL_CASES_P(NODE) (SWITCH_EXPR_CHECK (NODE)-&gt;base.private_flag)
<span class="lineNum">    1205 </span>            : 
<span class="lineNum">    1206 </span>            : /* CASE_LABEL_EXPR accessors. These give access to the high and low values
<span class="lineNum">    1207 </span>            :    of a case label, respectively.  */
<span class="lineNum">    1208 </span>            : #define CASE_LOW(NODE)                  TREE_OPERAND (CASE_LABEL_EXPR_CHECK (NODE), 0)
<span class="lineNum">    1209 </span>            : #define CASE_HIGH(NODE)                 TREE_OPERAND (CASE_LABEL_EXPR_CHECK (NODE), 1)
<span class="lineNum">    1210 </span>            : #define CASE_LABEL(NODE)                TREE_OPERAND (CASE_LABEL_EXPR_CHECK (NODE), 2)
<span class="lineNum">    1211 </span>            : #define CASE_CHAIN(NODE)                TREE_OPERAND (CASE_LABEL_EXPR_CHECK (NODE), 3)
<span class="lineNum">    1212 </span>            : 
<span class="lineNum">    1213 </span>            : /* The operands of a TARGET_MEM_REF.  Operands 0 and 1 have to match
<span class="lineNum">    1214 </span>            :    corresponding MEM_REF operands.  */
<span class="lineNum">    1215 </span>            : #define TMR_BASE(NODE) (TREE_OPERAND (TARGET_MEM_REF_CHECK (NODE), 0))
<span class="lineNum">    1216 </span>            : #define TMR_OFFSET(NODE) (TREE_OPERAND (TARGET_MEM_REF_CHECK (NODE), 1))
<span class="lineNum">    1217 </span>            : #define TMR_INDEX(NODE) (TREE_OPERAND (TARGET_MEM_REF_CHECK (NODE), 2))
<span class="lineNum">    1218 </span>            : #define TMR_STEP(NODE) (TREE_OPERAND (TARGET_MEM_REF_CHECK (NODE), 3))
<span class="lineNum">    1219 </span>            : #define TMR_INDEX2(NODE) (TREE_OPERAND (TARGET_MEM_REF_CHECK (NODE), 4))
<span class="lineNum">    1220 </span>            : 
<span class="lineNum">    1221 </span>            : #define MR_DEPENDENCE_CLIQUE(NODE) \
<span class="lineNum">    1222 </span>            :   (TREE_CHECK2 (NODE, MEM_REF, TARGET_MEM_REF)-&gt;base.u.dependence_info.clique)
<span class="lineNum">    1223 </span>            : #define MR_DEPENDENCE_BASE(NODE) \
<span class="lineNum">    1224 </span>            :   (TREE_CHECK2 (NODE, MEM_REF, TARGET_MEM_REF)-&gt;base.u.dependence_info.base)
<span class="lineNum">    1225 </span>            : 
<span class="lineNum">    1226 </span>            : /* The operands of a BIND_EXPR.  */
<span class="lineNum">    1227 </span>            : #define BIND_EXPR_VARS(NODE) (TREE_OPERAND (BIND_EXPR_CHECK (NODE), 0))
<span class="lineNum">    1228 </span>            : #define BIND_EXPR_BODY(NODE) (TREE_OPERAND (BIND_EXPR_CHECK (NODE), 1))
<span class="lineNum">    1229 </span>            : #define BIND_EXPR_BLOCK(NODE) (TREE_OPERAND (BIND_EXPR_CHECK (NODE), 2))
<span class="lineNum">    1230 </span>            : 
<span class="lineNum">    1231 </span>            : /* GOTO_EXPR accessor. This gives access to the label associated with
<span class="lineNum">    1232 </span>            :    a goto statement.  */
<span class="lineNum">    1233 </span>            : #define GOTO_DESTINATION(NODE)  TREE_OPERAND (GOTO_EXPR_CHECK (NODE), 0)
<span class="lineNum">    1234 </span>            : 
<span class="lineNum">    1235 </span>            : /* ASM_EXPR accessors. ASM_STRING returns a STRING_CST for the
<span class="lineNum">    1236 </span>            :    instruction (e.g., &quot;mov x, y&quot;). ASM_OUTPUTS, ASM_INPUTS, and
<span class="lineNum">    1237 </span>            :    ASM_CLOBBERS represent the outputs, inputs, and clobbers for the
<span class="lineNum">    1238 </span>            :    statement.  */
<span class="lineNum">    1239 </span>            : #define ASM_STRING(NODE)        TREE_OPERAND (ASM_EXPR_CHECK (NODE), 0)
<span class="lineNum">    1240 </span>            : #define ASM_OUTPUTS(NODE)       TREE_OPERAND (ASM_EXPR_CHECK (NODE), 1)
<span class="lineNum">    1241 </span>            : #define ASM_INPUTS(NODE)        TREE_OPERAND (ASM_EXPR_CHECK (NODE), 2)
<span class="lineNum">    1242 </span>            : #define ASM_CLOBBERS(NODE)      TREE_OPERAND (ASM_EXPR_CHECK (NODE), 3)
<span class="lineNum">    1243 </span>            : #define ASM_LABELS(NODE)        TREE_OPERAND (ASM_EXPR_CHECK (NODE), 4)
<span class="lineNum">    1244 </span>            : /* Nonzero if we want to create an ASM_INPUT instead of an
<span class="lineNum">    1245 </span>            :    ASM_OPERAND with no operands.  */
<span class="lineNum">    1246 </span>            : #define ASM_INPUT_P(NODE) (ASM_EXPR_CHECK (NODE)-&gt;base.static_flag)
<span class="lineNum">    1247 </span>            : #define ASM_VOLATILE_P(NODE) (ASM_EXPR_CHECK (NODE)-&gt;base.public_flag)
<span class="lineNum">    1248 </span>            : 
<span class="lineNum">    1249 </span>            : /* COND_EXPR accessors.  */
<span class="lineNum">    1250 </span>            : #define COND_EXPR_COND(NODE)    (TREE_OPERAND (COND_EXPR_CHECK (NODE), 0))
<span class="lineNum">    1251 </span>            : #define COND_EXPR_THEN(NODE)    (TREE_OPERAND (COND_EXPR_CHECK (NODE), 1))
<span class="lineNum">    1252 </span>            : #define COND_EXPR_ELSE(NODE)    (TREE_OPERAND (COND_EXPR_CHECK (NODE), 2))
<span class="lineNum">    1253 </span>            : 
<span class="lineNum">    1254 </span>            : /* Accessors for the chains of recurrences.  */
<span class="lineNum">    1255 </span>            : #define CHREC_LEFT(NODE)          TREE_OPERAND (POLYNOMIAL_CHREC_CHECK (NODE), 0)
<span class="lineNum">    1256 </span>            : #define CHREC_RIGHT(NODE)         TREE_OPERAND (POLYNOMIAL_CHREC_CHECK (NODE), 1)
<span class="lineNum">    1257 </span>            : #define CHREC_VARIABLE(NODE)      POLYNOMIAL_CHREC_CHECK (NODE)-&gt;base.u.chrec_var
<span class="lineNum">    1258 </span>            : 
<span class="lineNum">    1259 </span>            : /* LABEL_EXPR accessor. This gives access to the label associated with
<span class="lineNum">    1260 </span>            :    the given label expression.  */
<span class="lineNum">    1261 </span>            : #define LABEL_EXPR_LABEL(NODE)  TREE_OPERAND (LABEL_EXPR_CHECK (NODE), 0)
<span class="lineNum">    1262 </span>            : 
<span class="lineNum">    1263 </span>            : /* CATCH_EXPR accessors.  */
<span class="lineNum">    1264 </span>            : #define CATCH_TYPES(NODE)       TREE_OPERAND (CATCH_EXPR_CHECK (NODE), 0)
<span class="lineNum">    1265 </span>            : #define CATCH_BODY(NODE)        TREE_OPERAND (CATCH_EXPR_CHECK (NODE), 1)
<span class="lineNum">    1266 </span>            : 
<span class="lineNum">    1267 </span>            : /* EH_FILTER_EXPR accessors.  */
<span class="lineNum">    1268 </span>            : #define EH_FILTER_TYPES(NODE)   TREE_OPERAND (EH_FILTER_EXPR_CHECK (NODE), 0)
<span class="lineNum">    1269 </span>            : #define EH_FILTER_FAILURE(NODE) TREE_OPERAND (EH_FILTER_EXPR_CHECK (NODE), 1)
<span class="lineNum">    1270 </span>            : 
<span class="lineNum">    1271 </span>            : /* OBJ_TYPE_REF accessors.  */
<span class="lineNum">    1272 </span>            : #define OBJ_TYPE_REF_EXPR(NODE)   TREE_OPERAND (OBJ_TYPE_REF_CHECK (NODE), 0)
<span class="lineNum">    1273 </span>            : #define OBJ_TYPE_REF_OBJECT(NODE) TREE_OPERAND (OBJ_TYPE_REF_CHECK (NODE), 1)
<span class="lineNum">    1274 </span>            : #define OBJ_TYPE_REF_TOKEN(NODE)  TREE_OPERAND (OBJ_TYPE_REF_CHECK (NODE), 2)
<span class="lineNum">    1275 </span>            : 
<span class="lineNum">    1276 </span>            : /* ASSERT_EXPR accessors.  */
<span class="lineNum">    1277 </span>            : #define ASSERT_EXPR_VAR(NODE)   TREE_OPERAND (ASSERT_EXPR_CHECK (NODE), 0)
<span class="lineNum">    1278 </span>            : #define ASSERT_EXPR_COND(NODE)  TREE_OPERAND (ASSERT_EXPR_CHECK (NODE), 1)
<span class="lineNum">    1279 </span>            : 
<span class="lineNum">    1280 </span>            : /* CALL_EXPR accessors.  */
<span class="lineNum">    1281 </span>            : #define CALL_EXPR_FN(NODE) TREE_OPERAND (CALL_EXPR_CHECK (NODE), 1)
<span class="lineNum">    1282 </span>            : #define CALL_EXPR_STATIC_CHAIN(NODE) TREE_OPERAND (CALL_EXPR_CHECK (NODE), 2)
<span class="lineNum">    1283 </span>            : #define CALL_EXPR_ARG(NODE, I) TREE_OPERAND (CALL_EXPR_CHECK (NODE), (I) + 3)
<span class="lineNum">    1284 </span>            : #define call_expr_nargs(NODE) (VL_EXP_OPERAND_LENGTH (NODE) - 3)
<span class="lineNum">    1285 </span>            : #define CALL_EXPR_IFN(NODE) (CALL_EXPR_CHECK (NODE)-&gt;base.u.ifn)
<span class="lineNum">    1286 </span>            : 
<span class="lineNum">    1287 </span>            : /* CALL_EXPR_ARGP returns a pointer to the argument vector for NODE.
<span class="lineNum">    1288 </span>            :    We can't use &amp;CALL_EXPR_ARG (NODE, 0) because that will complain if
<span class="lineNum">    1289 </span>            :    the argument count is zero when checking is enabled.  Instead, do
<span class="lineNum">    1290 </span>            :    the pointer arithmetic to advance past the 3 fixed operands in a
<span class="lineNum">    1291 </span>            :    CALL_EXPR.  That produces a valid pointer to just past the end of the
<span class="lineNum">    1292 </span>            :    operand array, even if it's not valid to dereference it.  */
<span class="lineNum">    1293 </span>            : #define CALL_EXPR_ARGP(NODE) \
<span class="lineNum">    1294 </span>            :   (&amp;(TREE_OPERAND (CALL_EXPR_CHECK (NODE), 0)) + 3)
<span class="lineNum">    1295 </span>            : 
<span class="lineNum">    1296 </span>            : /* TM directives and accessors.  */
<span class="lineNum">    1297 </span>            : #define TRANSACTION_EXPR_BODY(NODE) \
<span class="lineNum">    1298 </span>            :   TREE_OPERAND (TRANSACTION_EXPR_CHECK (NODE), 0)
<span class="lineNum">    1299 </span>            : #define TRANSACTION_EXPR_OUTER(NODE) \
<span class="lineNum">    1300 </span>            :   (TRANSACTION_EXPR_CHECK (NODE)-&gt;base.static_flag)
<span class="lineNum">    1301 </span>            : #define TRANSACTION_EXPR_RELAXED(NODE) \
<span class="lineNum">    1302 </span>            :   (TRANSACTION_EXPR_CHECK (NODE)-&gt;base.public_flag)
<span class="lineNum">    1303 </span>            : 
<span class="lineNum">    1304 </span>            : /* OpenMP and OpenACC directive and clause accessors.  */
<span class="lineNum">    1305 </span>            : 
<span class="lineNum">    1306 </span>            : /* Generic accessors for OMP nodes that keep the body as operand 0, and clauses
<span class="lineNum">    1307 </span>            :    as operand 1.  */
<span class="lineNum">    1308 </span>            : #define OMP_BODY(NODE) \
<span class="lineNum">    1309 </span>            :   TREE_OPERAND (TREE_RANGE_CHECK (NODE, OACC_PARALLEL, OMP_TASKGROUP), 0)
<span class="lineNum">    1310 </span>            : #define OMP_CLAUSES(NODE) \
<span class="lineNum">    1311 </span>            :   TREE_OPERAND (TREE_RANGE_CHECK (NODE, OACC_PARALLEL, OMP_SINGLE), 1)
<span class="lineNum">    1312 </span>            : 
<span class="lineNum">    1313 </span>            : /* Generic accessors for OMP nodes that keep clauses as operand 0.  */
<span class="lineNum">    1314 </span>            : #define OMP_STANDALONE_CLAUSES(NODE) \
<span class="lineNum">    1315 </span>            :   TREE_OPERAND (TREE_RANGE_CHECK (NODE, OACC_CACHE, OMP_TARGET_EXIT_DATA), 0)
<span class="lineNum">    1316 </span>            : 
<span class="lineNum">    1317 </span>            : #define OACC_DATA_BODY(NODE) \
<span class="lineNum">    1318 </span>            :   TREE_OPERAND (OACC_DATA_CHECK (NODE), 0)
<span class="lineNum">    1319 </span>            : #define OACC_DATA_CLAUSES(NODE) \
<span class="lineNum">    1320 </span>            :   TREE_OPERAND (OACC_DATA_CHECK (NODE), 1)
<span class="lineNum">    1321 </span>            : 
<span class="lineNum">    1322 </span>            : #define OACC_HOST_DATA_BODY(NODE) \
<span class="lineNum">    1323 </span>            :   TREE_OPERAND (OACC_HOST_DATA_CHECK (NODE), 0)
<span class="lineNum">    1324 </span>            : #define OACC_HOST_DATA_CLAUSES(NODE) \
<span class="lineNum">    1325 </span>            :   TREE_OPERAND (OACC_HOST_DATA_CHECK (NODE), 1)
<span class="lineNum">    1326 </span>            : 
<span class="lineNum">    1327 </span>            : #define OACC_CACHE_CLAUSES(NODE) \
<span class="lineNum">    1328 </span>            :   TREE_OPERAND (OACC_CACHE_CHECK (NODE), 0)
<span class="lineNum">    1329 </span>            : 
<span class="lineNum">    1330 </span>            : #define OACC_DECLARE_CLAUSES(NODE) \
<span class="lineNum">    1331 </span>            :   TREE_OPERAND (OACC_DECLARE_CHECK (NODE), 0)
<span class="lineNum">    1332 </span>            : 
<span class="lineNum">    1333 </span>            : #define OACC_ENTER_DATA_CLAUSES(NODE) \
<span class="lineNum">    1334 </span>            :   TREE_OPERAND (OACC_ENTER_DATA_CHECK (NODE), 0)
<span class="lineNum">    1335 </span>            : 
<span class="lineNum">    1336 </span>            : #define OACC_EXIT_DATA_CLAUSES(NODE) \
<span class="lineNum">    1337 </span>            :   TREE_OPERAND (OACC_EXIT_DATA_CHECK (NODE), 0)
<span class="lineNum">    1338 </span>            : 
<span class="lineNum">    1339 </span>            : #define OACC_UPDATE_CLAUSES(NODE) \
<span class="lineNum">    1340 </span>            :   TREE_OPERAND (OACC_UPDATE_CHECK (NODE), 0)
<span class="lineNum">    1341 </span>            : 
<span class="lineNum">    1342 </span>            : #define OMP_PARALLEL_BODY(NODE)    TREE_OPERAND (OMP_PARALLEL_CHECK (NODE), 0)
<span class="lineNum">    1343 </span>            : #define OMP_PARALLEL_CLAUSES(NODE) TREE_OPERAND (OMP_PARALLEL_CHECK (NODE), 1)
<span class="lineNum">    1344 </span>            : 
<span class="lineNum">    1345 </span>            : #define OMP_TASK_BODY(NODE)        TREE_OPERAND (OMP_TASK_CHECK (NODE), 0)
<span class="lineNum">    1346 </span>            : #define OMP_TASK_CLAUSES(NODE)     TREE_OPERAND (OMP_TASK_CHECK (NODE), 1)
<span class="lineNum">    1347 </span>            : 
<span class="lineNum">    1348 </span>            : #define OMP_TASKREG_CHECK(NODE)   TREE_RANGE_CHECK (NODE, OMP_PARALLEL, OMP_TASK)
<span class="lineNum">    1349 </span>            : #define OMP_TASKREG_BODY(NODE)    TREE_OPERAND (OMP_TASKREG_CHECK (NODE), 0)
<span class="lineNum">    1350 </span>            : #define OMP_TASKREG_CLAUSES(NODE) TREE_OPERAND (OMP_TASKREG_CHECK (NODE), 1)
<span class="lineNum">    1351 </span>            : 
<span class="lineNum">    1352 </span>            : #define OMP_LOOP_CHECK(NODE) TREE_RANGE_CHECK (NODE, OMP_FOR, OACC_LOOP)
<span class="lineNum">    1353 </span>            : #define OMP_FOR_BODY(NODE)         TREE_OPERAND (OMP_LOOP_CHECK (NODE), 0)
<span class="lineNum">    1354 </span>            : #define OMP_FOR_CLAUSES(NODE)      TREE_OPERAND (OMP_LOOP_CHECK (NODE), 1)
<span class="lineNum">    1355 </span>            : #define OMP_FOR_INIT(NODE)         TREE_OPERAND (OMP_LOOP_CHECK (NODE), 2)
<span class="lineNum">    1356 </span>            : #define OMP_FOR_COND(NODE)         TREE_OPERAND (OMP_LOOP_CHECK (NODE), 3)
<span class="lineNum">    1357 </span>            : #define OMP_FOR_INCR(NODE)         TREE_OPERAND (OMP_LOOP_CHECK (NODE), 4)
<span class="lineNum">    1358 </span>            : #define OMP_FOR_PRE_BODY(NODE)     TREE_OPERAND (OMP_LOOP_CHECK (NODE), 5)
<span class="lineNum">    1359 </span>            : #define OMP_FOR_ORIG_DECLS(NODE)   TREE_OPERAND (OMP_LOOP_CHECK (NODE), 6)
<span class="lineNum">    1360 </span>            : 
<span class="lineNum">    1361 </span>            : #define OMP_SECTIONS_BODY(NODE)    TREE_OPERAND (OMP_SECTIONS_CHECK (NODE), 0)
<span class="lineNum">    1362 </span>            : #define OMP_SECTIONS_CLAUSES(NODE) TREE_OPERAND (OMP_SECTIONS_CHECK (NODE), 1)
<span class="lineNum">    1363 </span>            : 
<span class="lineNum">    1364 </span>            : #define OMP_SECTION_BODY(NODE)     TREE_OPERAND (OMP_SECTION_CHECK (NODE), 0)
<span class="lineNum">    1365 </span>            : 
<span class="lineNum">    1366 </span>            : #define OMP_SINGLE_BODY(NODE)      TREE_OPERAND (OMP_SINGLE_CHECK (NODE), 0)
<span class="lineNum">    1367 </span>            : #define OMP_SINGLE_CLAUSES(NODE)   TREE_OPERAND (OMP_SINGLE_CHECK (NODE), 1)
<span class="lineNum">    1368 </span>            : 
<span class="lineNum">    1369 </span>            : #define OMP_MASTER_BODY(NODE)      TREE_OPERAND (OMP_MASTER_CHECK (NODE), 0)
<span class="lineNum">    1370 </span>            : 
<span class="lineNum">    1371 </span>            : #define OMP_TASKGROUP_BODY(NODE)   TREE_OPERAND (OMP_TASKGROUP_CHECK (NODE), 0)
<span class="lineNum">    1372 </span>            : 
<span class="lineNum">    1373 </span>            : #define OMP_ORDERED_BODY(NODE)     TREE_OPERAND (OMP_ORDERED_CHECK (NODE), 0)
<span class="lineNum">    1374 </span>            : #define OMP_ORDERED_CLAUSES(NODE)  TREE_OPERAND (OMP_ORDERED_CHECK (NODE), 1)
<span class="lineNum">    1375 </span>            : 
<span class="lineNum">    1376 </span>            : #define OMP_CRITICAL_BODY(NODE)    TREE_OPERAND (OMP_CRITICAL_CHECK (NODE), 0)
<span class="lineNum">    1377 </span>            : #define OMP_CRITICAL_CLAUSES(NODE) TREE_OPERAND (OMP_CRITICAL_CHECK (NODE), 1)
<span class="lineNum">    1378 </span>            : #define OMP_CRITICAL_NAME(NODE)    TREE_OPERAND (OMP_CRITICAL_CHECK (NODE), 2)
<span class="lineNum">    1379 </span>            : 
<span class="lineNum">    1380 </span>            : #define OMP_TEAMS_BODY(NODE)       TREE_OPERAND (OMP_TEAMS_CHECK (NODE), 0)
<span class="lineNum">    1381 </span>            : #define OMP_TEAMS_CLAUSES(NODE)    TREE_OPERAND (OMP_TEAMS_CHECK (NODE), 1)
<span class="lineNum">    1382 </span>            : 
<span class="lineNum">    1383 </span>            : #define OMP_TARGET_DATA_BODY(NODE) \
<span class="lineNum">    1384 </span>            :   TREE_OPERAND (OMP_TARGET_DATA_CHECK (NODE), 0)
<span class="lineNum">    1385 </span>            : #define OMP_TARGET_DATA_CLAUSES(NODE)\
<span class="lineNum">    1386 </span>            :   TREE_OPERAND (OMP_TARGET_DATA_CHECK (NODE), 1)
<span class="lineNum">    1387 </span>            : 
<span class="lineNum">    1388 </span>            : #define OMP_TARGET_BODY(NODE)      TREE_OPERAND (OMP_TARGET_CHECK (NODE), 0)
<span class="lineNum">    1389 </span>            : #define OMP_TARGET_CLAUSES(NODE)   TREE_OPERAND (OMP_TARGET_CHECK (NODE), 1)
<span class="lineNum">    1390 </span>            : 
<span class="lineNum">    1391 </span>            : #define OMP_TARGET_UPDATE_CLAUSES(NODE)\
<span class="lineNum">    1392 </span>            :   TREE_OPERAND (OMP_TARGET_UPDATE_CHECK (NODE), 0)
<span class="lineNum">    1393 </span>            : 
<span class="lineNum">    1394 </span>            : #define OMP_TARGET_ENTER_DATA_CLAUSES(NODE)\
<span class="lineNum">    1395 </span>            :   TREE_OPERAND (OMP_TARGET_ENTER_DATA_CHECK (NODE), 0)
<span class="lineNum">    1396 </span>            : 
<span class="lineNum">    1397 </span>            : #define OMP_TARGET_EXIT_DATA_CLAUSES(NODE)\
<span class="lineNum">    1398 </span>            :   TREE_OPERAND (OMP_TARGET_EXIT_DATA_CHECK (NODE), 0)
<span class="lineNum">    1399 </span>            : 
<span class="lineNum">    1400 </span>            : #define OMP_CLAUSE_SIZE(NODE)                                           \
<span class="lineNum">    1401 </span>            :   OMP_CLAUSE_OPERAND (OMP_CLAUSE_RANGE_CHECK (OMP_CLAUSE_CHECK (NODE),  \
<span class="lineNum">    1402 </span>            :                                               OMP_CLAUSE_FROM,          \
<span class="lineNum">    1403 </span>            :                                               OMP_CLAUSE__CACHE_), 1)
<span class="lineNum">    1404 </span>            : 
<span class="lineNum">    1405 </span>            : #define OMP_CLAUSE_CHAIN(NODE)     TREE_CHAIN (OMP_CLAUSE_CHECK (NODE))
<span class="lineNum">    1406 </span>            : #define OMP_CLAUSE_DECL(NODE)                                           \
<span class="lineNum">    1407 </span>            :   OMP_CLAUSE_OPERAND (OMP_CLAUSE_RANGE_CHECK (OMP_CLAUSE_CHECK (NODE),  \
<span class="lineNum">    1408 </span>            :                                               OMP_CLAUSE_PRIVATE,       \
<span class="lineNum">    1409 </span>            :                                               OMP_CLAUSE__LOOPTEMP_), 0)
<span class="lineNum">    1410 </span>            : #define OMP_CLAUSE_HAS_LOCATION(NODE) \
<span class="lineNum">    1411 </span>            :   (LOCATION_LOCUS ((OMP_CLAUSE_CHECK (NODE))-&gt;omp_clause.locus)              \
<span class="lineNum">    1412 </span>            :   != UNKNOWN_LOCATION)
<span class="lineNum">    1413 </span>            : #define OMP_CLAUSE_LOCATION(NODE)  (OMP_CLAUSE_CHECK (NODE))-&gt;omp_clause.locus
<span class="lineNum">    1414 </span>            : 
<span class="lineNum">    1415 </span>            : /* True on an OMP_SECTION statement that was the last lexical member.
<span class="lineNum">    1416 </span>            :    This status is meaningful in the implementation of lastprivate.  */
<span class="lineNum">    1417 </span>            : #define OMP_SECTION_LAST(NODE) \
<span class="lineNum">    1418 </span>            :   (OMP_SECTION_CHECK (NODE)-&gt;base.private_flag)
<span class="lineNum">    1419 </span>            : 
<span class="lineNum">    1420 </span>            : /* True on an OMP_PARALLEL statement if it represents an explicit
<span class="lineNum">    1421 </span>            :    combined parallel work-sharing constructs.  */
<span class="lineNum">    1422 </span>            : #define OMP_PARALLEL_COMBINED(NODE) \
<span class="lineNum">    1423 </span>            :   (OMP_PARALLEL_CHECK (NODE)-&gt;base.private_flag)
<span class="lineNum">    1424 </span>            : 
<span class="lineNum">    1425 </span>            : /* True on an OMP_TEAMS statement if it represents an explicit
<span class="lineNum">    1426 </span>            :    combined teams distribute constructs.  */
<span class="lineNum">    1427 </span>            : #define OMP_TEAMS_COMBINED(NODE) \
<span class="lineNum">    1428 </span>            :   (OMP_TEAMS_CHECK (NODE)-&gt;base.private_flag)
<span class="lineNum">    1429 </span>            : 
<span class="lineNum">    1430 </span>            : /* True on an OMP_TARGET statement if it represents explicit
<span class="lineNum">    1431 </span>            :    combined target teams, target parallel or target simd constructs.  */
<span class="lineNum">    1432 </span>            : #define OMP_TARGET_COMBINED(NODE) \
<span class="lineNum">    1433 </span>            :   (OMP_TARGET_CHECK (NODE)-&gt;base.private_flag)
<span class="lineNum">    1434 </span>            : 
<span class="lineNum">    1435 </span>            : /* True if OMP_ATOMIC* is supposed to be sequentially consistent
<span class="lineNum">    1436 </span>            :    as opposed to relaxed.  */
<span class="lineNum">    1437 </span>            : #define OMP_ATOMIC_SEQ_CST(NODE) \
<span class="lineNum">    1438 </span>            :   (TREE_RANGE_CHECK (NODE, OMP_ATOMIC, \
<span class="lineNum">    1439 </span>            :                      OMP_ATOMIC_CAPTURE_NEW)-&gt;base.private_flag)
<span class="lineNum">    1440 </span>            : 
<span class="lineNum">    1441 </span>            : /* True on a PRIVATE clause if its decl is kept around for debugging
<span class="lineNum">    1442 </span>            :    information only and its DECL_VALUE_EXPR is supposed to point
<span class="lineNum">    1443 </span>            :    to what it has been remapped to.  */
<span class="lineNum">    1444 </span>            : #define OMP_CLAUSE_PRIVATE_DEBUG(NODE) \
<span class="lineNum">    1445 </span>            :   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_PRIVATE)-&gt;base.public_flag)
<span class="lineNum">    1446 </span>            : 
<span class="lineNum">    1447 </span>            : /* True on a PRIVATE clause if ctor needs access to outer region's
<span class="lineNum">    1448 </span>            :    variable.  */
<span class="lineNum">    1449 </span>            : #define OMP_CLAUSE_PRIVATE_OUTER_REF(NODE) \
<span class="lineNum">    1450 </span>            :   TREE_PRIVATE (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_PRIVATE))
<span class="lineNum">    1451 </span>            : 
<span class="lineNum">    1452 </span>            : /* True if a PRIVATE clause is for a C++ class IV on taskloop construct
<span class="lineNum">    1453 </span>            :    (thus should be private on the outer taskloop and firstprivate on
<span class="lineNum">    1454 </span>            :    task).  */
<span class="lineNum">    1455 </span>            : #define OMP_CLAUSE_PRIVATE_TASKLOOP_IV(NODE) \
<span class="lineNum">    1456 </span>            :   TREE_PROTECTED (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_PRIVATE))
<span class="lineNum">    1457 </span>            : 
<span class="lineNum">    1458 </span>            : /* True on a FIRSTPRIVATE clause if it has been added implicitly.  */
<span class="lineNum">    1459 </span>            : #define OMP_CLAUSE_FIRSTPRIVATE_IMPLICIT(NODE) \
<span class="lineNum">    1460 </span>            :   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_FIRSTPRIVATE)-&gt;base.public_flag)
<span class="lineNum">    1461 </span>            : 
<span class="lineNum">    1462 </span>            : /* True on a LASTPRIVATE clause if a FIRSTPRIVATE clause for the same
<span class="lineNum">    1463 </span>            :    decl is present in the chain.  */
<span class="lineNum">    1464 </span>            : #define OMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE(NODE) \
<span class="lineNum">    1465 </span>            :   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LASTPRIVATE)-&gt;base.public_flag)
<span class="lineNum">    1466 </span>            : #define OMP_CLAUSE_LASTPRIVATE_STMT(NODE) \
<span class="lineNum">    1467 </span>            :   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE,                   \
<span class="lineNum">    1468 </span>            :                                                 OMP_CLAUSE_LASTPRIVATE),\
<span class="lineNum">    1469 </span>            :                       1)
<span class="lineNum">    1470 </span>            : #define OMP_CLAUSE_LASTPRIVATE_GIMPLE_SEQ(NODE) \
<span class="lineNum">    1471 </span>            :   (OMP_CLAUSE_CHECK (NODE))-&gt;omp_clause.gimple_reduction_init
<span class="lineNum">    1472 </span>            : 
<span class="lineNum">    1473 </span>            : /* True if a LASTPRIVATE clause is for a C++ class IV on taskloop construct
<span class="lineNum">    1474 </span>            :    (thus should be lastprivate on the outer taskloop and firstprivate on
<span class="lineNum">    1475 </span>            :    task).  */
<span class="lineNum">    1476 </span>            : #define OMP_CLAUSE_LASTPRIVATE_TASKLOOP_IV(NODE) \
<span class="lineNum">    1477 </span>            :   TREE_PROTECTED (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LASTPRIVATE))
<span class="lineNum">    1478 </span>            : 
<span class="lineNum">    1479 </span>            : /* True on a SHARED clause if a FIRSTPRIVATE clause for the same
<span class="lineNum">    1480 </span>            :    decl is present in the chain (this can happen only for taskloop
<span class="lineNum">    1481 </span>            :    with FIRSTPRIVATE/LASTPRIVATE on it originally.  */
<span class="lineNum">    1482 </span>            : #define OMP_CLAUSE_SHARED_FIRSTPRIVATE(NODE) \
<span class="lineNum">    1483 </span>            :   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_SHARED)-&gt;base.public_flag)
<span class="lineNum">    1484 </span>            : 
<span class="lineNum">    1485 </span>            : /* True on a SHARED clause if a scalar is not modified in the body and
<span class="lineNum">    1486 </span>            :    thus could be optimized as firstprivate.  */
<span class="lineNum">    1487 </span>            : #define OMP_CLAUSE_SHARED_READONLY(NODE) \
<span class="lineNum">    1488 </span>            :   TREE_PRIVATE (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_SHARED))
<span class="lineNum">    1489 </span>            : 
<span class="lineNum">    1490 </span>            : #define OMP_CLAUSE_IF_MODIFIER(NODE)    \
<span class="lineNum">    1491 </span>            :   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_IF)-&gt;omp_clause.subcode.if_modifier)
<span class="lineNum">    1492 </span>            : 
<span class="lineNum">    1493 </span>            : #define OMP_CLAUSE_FINAL_EXPR(NODE) \
<span class="lineNum">    1494 </span>            :   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_FINAL), 0)
<span class="lineNum">    1495 </span>            : #define OMP_CLAUSE_IF_EXPR(NODE) \
<span class="lineNum">    1496 </span>            :   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_IF), 0)
<span class="lineNum">    1497 </span>            : #define OMP_CLAUSE_NUM_THREADS_EXPR(NODE) \
<span class="lineNum">    1498 </span>            :   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_NUM_THREADS),0)
<span class="lineNum">    1499 </span>            : #define OMP_CLAUSE_SCHEDULE_CHUNK_EXPR(NODE) \
<span class="lineNum">    1500 </span>            :   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_SCHEDULE), 0)
<span class="lineNum">    1501 </span>            : #define OMP_CLAUSE_NUM_TASKS_EXPR(NODE) \
<span class="lineNum">    1502 </span>            :   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_NUM_TASKS), 0)
<span class="lineNum">    1503 </span>            : #define OMP_CLAUSE_HINT_EXPR(NODE) \
<span class="lineNum">    1504 </span>            :   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_HINT), 0)
<span class="lineNum">    1505 </span>            : 
<span class="lineNum">    1506 </span>            : #define OMP_CLAUSE_GRAINSIZE_EXPR(NODE) \
<span class="lineNum">    1507 </span>            :   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_GRAINSIZE),0)
<span class="lineNum">    1508 </span>            : 
<span class="lineNum">    1509 </span>            : #define OMP_CLAUSE_PRIORITY_EXPR(NODE) \
<span class="lineNum">    1510 </span>            :   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_PRIORITY),0)
<span class="lineNum">    1511 </span>            : 
<span class="lineNum">    1512 </span>            : /* OpenACC clause expressions  */
<span class="lineNum">    1513 </span>            : #define OMP_CLAUSE_EXPR(NODE, CLAUSE) \
<span class="lineNum">    1514 </span>            :   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, CLAUSE), 0)
<span class="lineNum">    1515 </span>            : #define OMP_CLAUSE_GANG_EXPR(NODE) \
<span class="lineNum">    1516 </span>            :   OMP_CLAUSE_OPERAND ( \
<span class="lineNum">    1517 </span>            :     OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_GANG), 0)
<span class="lineNum">    1518 </span>            : #define OMP_CLAUSE_GANG_STATIC_EXPR(NODE) \
<span class="lineNum">    1519 </span>            :   OMP_CLAUSE_OPERAND ( \
<span class="lineNum">    1520 </span>            :     OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_GANG), 1)
<span class="lineNum">    1521 </span>            : #define OMP_CLAUSE_ASYNC_EXPR(NODE) \
<span class="lineNum">    1522 </span>            :   OMP_CLAUSE_OPERAND ( \
<span class="lineNum">    1523 </span>            :     OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_ASYNC), 0)
<span class="lineNum">    1524 </span>            : #define OMP_CLAUSE_WAIT_EXPR(NODE) \
<span class="lineNum">    1525 </span>            :   OMP_CLAUSE_OPERAND ( \
<span class="lineNum">    1526 </span>            :     OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_WAIT), 0)
<span class="lineNum">    1527 </span>            : #define OMP_CLAUSE_VECTOR_EXPR(NODE) \
<span class="lineNum">    1528 </span>            :   OMP_CLAUSE_OPERAND ( \
<span class="lineNum">    1529 </span>            :     OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_VECTOR), 0)
<span class="lineNum">    1530 </span>            : #define OMP_CLAUSE_WORKER_EXPR(NODE) \
<span class="lineNum">    1531 </span>            :   OMP_CLAUSE_OPERAND ( \
<span class="lineNum">    1532 </span>            :     OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_WORKER), 0)
<span class="lineNum">    1533 </span>            : #define OMP_CLAUSE_NUM_GANGS_EXPR(NODE) \
<span class="lineNum">    1534 </span>            :   OMP_CLAUSE_OPERAND ( \
<span class="lineNum">    1535 </span>            :     OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_NUM_GANGS), 0)
<span class="lineNum">    1536 </span>            : #define OMP_CLAUSE_NUM_WORKERS_EXPR(NODE) \
<span class="lineNum">    1537 </span>            :   OMP_CLAUSE_OPERAND ( \
<span class="lineNum">    1538 </span>            :     OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_NUM_WORKERS), 0)
<span class="lineNum">    1539 </span>            : #define OMP_CLAUSE_VECTOR_LENGTH_EXPR(NODE) \
<span class="lineNum">    1540 </span>            :   OMP_CLAUSE_OPERAND ( \
<span class="lineNum">    1541 </span>            :     OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_VECTOR_LENGTH), 0)
<span class="lineNum">    1542 </span>            : 
<span class="lineNum">    1543 </span>            : #define OMP_CLAUSE_DEPEND_KIND(NODE) \
<span class="lineNum">    1544 </span>            :   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_DEPEND)-&gt;omp_clause.subcode.depend_kind)
<span class="lineNum">    1545 </span>            : 
<span class="lineNum">    1546 </span>            : #define OMP_CLAUSE_DEPEND_SINK_NEGATIVE(NODE) \
<span class="lineNum">    1547 </span>            :   TREE_PUBLIC (TREE_LIST_CHECK (NODE))
<span class="lineNum">    1548 </span>            : 
<span class="lineNum">    1549 </span>            : #define OMP_CLAUSE_MAP_KIND(NODE) \
<span class="lineNum">    1550 </span>            :   ((enum gomp_map_kind) OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_MAP)-&gt;omp_clause.subcode.map_kind)
<span class="lineNum">    1551 </span>            : #define OMP_CLAUSE_SET_MAP_KIND(NODE, MAP_KIND) \
<span class="lineNum">    1552 </span>            :   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_MAP)-&gt;omp_clause.subcode.map_kind \
<span class="lineNum">    1553 </span>            :    = (unsigned int) (MAP_KIND))
<span class="lineNum">    1554 </span>            : 
<span class="lineNum">    1555 </span>            : /* Nonzero if this map clause is for array (rather than pointer) based array
<span class="lineNum">    1556 </span>            :    section with zero bias.  Both the non-decl OMP_CLAUSE_MAP and corresponding
<span class="lineNum">    1557 </span>            :    OMP_CLAUSE_MAP with GOMP_MAP_POINTER are marked with this flag.  */
<span class="lineNum">    1558 </span>            : #define OMP_CLAUSE_MAP_ZERO_BIAS_ARRAY_SECTION(NODE) \
<span class="lineNum">    1559 </span>            :   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_MAP)-&gt;base.public_flag)
<span class="lineNum">    1560 </span>            : /* Nonzero if this is a mapped array section, that might need special
<span class="lineNum">    1561 </span>            :    treatment if OMP_CLAUSE_SIZE is zero.  */
<span class="lineNum">    1562 </span>            : #define OMP_CLAUSE_MAP_MAYBE_ZERO_LENGTH_ARRAY_SECTION(NODE) \
<span class="lineNum">    1563 </span>            :   TREE_PROTECTED (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_MAP))
<span class="lineNum">    1564 </span>            : /* Nonzero if this map clause is for an ACC parallel reduction variable.  */
<span class="lineNum">    1565 </span>            : #define OMP_CLAUSE_MAP_IN_REDUCTION(NODE) \
<span class="lineNum">    1566 </span>            :   TREE_PRIVATE (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_MAP))
<span class="lineNum">    1567 </span>            : 
<span class="lineNum">    1568 </span>            : #define OMP_CLAUSE_PROC_BIND_KIND(NODE) \
<span class="lineNum">    1569 </span>            :   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_PROC_BIND)-&gt;omp_clause.subcode.proc_bind_kind)
<span class="lineNum">    1570 </span>            : 
<span class="lineNum">    1571 </span>            : #define OMP_CLAUSE_COLLAPSE_EXPR(NODE) \
<span class="lineNum">    1572 </span>            :   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_COLLAPSE), 0)
<span class="lineNum">    1573 </span>            : #define OMP_CLAUSE_COLLAPSE_ITERVAR(NODE) \
<span class="lineNum">    1574 </span>            :   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_COLLAPSE), 1)
<span class="lineNum">    1575 </span>            : #define OMP_CLAUSE_COLLAPSE_COUNT(NODE) \
<span class="lineNum">    1576 </span>            :   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_COLLAPSE), 2)
<span class="lineNum">    1577 </span>            : 
<span class="lineNum">    1578 </span>            : #define OMP_CLAUSE_ORDERED_EXPR(NODE) \
<span class="lineNum">    1579 </span>            :   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_ORDERED), 0)
<span class="lineNum">    1580 </span>            : 
<span class="lineNum">    1581 </span>            : #define OMP_CLAUSE_REDUCTION_CODE(NODE) \
<span class="lineNum">    1582 </span>            :   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_REDUCTION)-&gt;omp_clause.subcode.reduction_code)
<span class="lineNum">    1583 </span>            : #define OMP_CLAUSE_REDUCTION_INIT(NODE) \
<span class="lineNum">    1584 </span>            :   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_REDUCTION), 1)
<span class="lineNum">    1585 </span>            : #define OMP_CLAUSE_REDUCTION_MERGE(NODE) \
<span class="lineNum">    1586 </span>            :   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_REDUCTION), 2)
<span class="lineNum">    1587 </span>            : #define OMP_CLAUSE_REDUCTION_GIMPLE_INIT(NODE) \
<span class="lineNum">    1588 </span>            :   (OMP_CLAUSE_CHECK (NODE))-&gt;omp_clause.gimple_reduction_init
<span class="lineNum">    1589 </span>            : #define OMP_CLAUSE_REDUCTION_GIMPLE_MERGE(NODE) \
<span class="lineNum">    1590 </span>            :   (OMP_CLAUSE_CHECK (NODE))-&gt;omp_clause.gimple_reduction_merge
<span class="lineNum">    1591 </span>            : #define OMP_CLAUSE_REDUCTION_PLACEHOLDER(NODE) \
<span class="lineNum">    1592 </span>            :   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_REDUCTION), 3)
<span class="lineNum">    1593 </span>            : #define OMP_CLAUSE_REDUCTION_DECL_PLACEHOLDER(NODE) \
<span class="lineNum">    1594 </span>            :   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_REDUCTION), 4)
<span class="lineNum">    1595 </span>            : 
<span class="lineNum">    1596 </span>            : /* True if a REDUCTION clause may reference the original list item (omp_orig)
<span class="lineNum">    1597 </span>            :    in its OMP_CLAUSE_REDUCTION_{,GIMPLE_}INIT.  */
<span class="lineNum">    1598 </span>            : #define OMP_CLAUSE_REDUCTION_OMP_ORIG_REF(NODE) \
<span class="lineNum">    1599 </span>            :   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_REDUCTION)-&gt;base.public_flag)
<span class="lineNum">    1600 </span>            : 
<span class="lineNum">    1601 </span>            : /* True if a LINEAR clause doesn't need copy in.  True for iterator vars which
<span class="lineNum">    1602 </span>            :    are always initialized inside of the loop construct, false otherwise.  */
<span class="lineNum">    1603 </span>            : #define OMP_CLAUSE_LINEAR_NO_COPYIN(NODE) \
<span class="lineNum">    1604 </span>            :   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LINEAR)-&gt;base.public_flag)
<span class="lineNum">    1605 </span>            : 
<span class="lineNum">    1606 </span>            : /* True if a LINEAR clause doesn't need copy out.  True for iterator vars which
<span class="lineNum">    1607 </span>            :    are declared inside of the simd construct.  */
<span class="lineNum">    1608 </span>            : #define OMP_CLAUSE_LINEAR_NO_COPYOUT(NODE) \
<span class="lineNum">    1609 </span>            :   TREE_PRIVATE (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LINEAR))
<span class="lineNum">    1610 </span>            : 
<span class="lineNum">    1611 </span>            : /* True if a LINEAR clause has a stride that is variable.  */
<span class="lineNum">    1612 </span>            : #define OMP_CLAUSE_LINEAR_VARIABLE_STRIDE(NODE) \
<span class="lineNum">    1613 </span>            :   TREE_PROTECTED (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LINEAR))
<span class="lineNum">    1614 </span>            : 
<span class="lineNum">    1615 </span>            : /* True if a LINEAR clause is for an array or allocatable variable that
<span class="lineNum">    1616 </span>            :    needs special handling by the frontend.  */
<span class="lineNum">    1617 </span>            : #define OMP_CLAUSE_LINEAR_ARRAY(NODE) \
<span class="lineNum">    1618 </span>            :   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LINEAR)-&gt;base.deprecated_flag)
<span class="lineNum">    1619 </span>            : 
<span class="lineNum">    1620 </span>            : #define OMP_CLAUSE_LINEAR_STEP(NODE) \
<span class="lineNum">    1621 </span>            :   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LINEAR), 1)
<span class="lineNum">    1622 </span>            : 
<span class="lineNum">    1623 </span>            : #define OMP_CLAUSE_LINEAR_STMT(NODE) \
<span class="lineNum">    1624 </span>            :   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LINEAR), 2)
<span class="lineNum">    1625 </span>            : 
<span class="lineNum">    1626 </span>            : #define OMP_CLAUSE_LINEAR_GIMPLE_SEQ(NODE) \
<span class="lineNum">    1627 </span>            :   (OMP_CLAUSE_CHECK (NODE))-&gt;omp_clause.gimple_reduction_init
<span class="lineNum">    1628 </span>            : 
<span class="lineNum">    1629 </span>            : #define OMP_CLAUSE_LINEAR_KIND(NODE) \
<span class="lineNum">    1630 </span>            :   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LINEAR)-&gt;omp_clause.subcode.linear_kind)
<span class="lineNum">    1631 </span>            : 
<span class="lineNum">    1632 </span>            : #define OMP_CLAUSE_ALIGNED_ALIGNMENT(NODE) \
<span class="lineNum">    1633 </span>            :   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_ALIGNED), 1)
<span class="lineNum">    1634 </span>            : 
<span class="lineNum">    1635 </span>            : #define OMP_CLAUSE_NUM_TEAMS_EXPR(NODE) \
<span class="lineNum">    1636 </span>            :   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_NUM_TEAMS), 0)
<span class="lineNum">    1637 </span>            : 
<span class="lineNum">    1638 </span>            : #define OMP_CLAUSE_THREAD_LIMIT_EXPR(NODE) \
<span class="lineNum">    1639 </span>            :   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, \
<span class="lineNum">    1640 </span>            :                                                 OMP_CLAUSE_THREAD_LIMIT), 0)
<span class="lineNum">    1641 </span>            : 
<span class="lineNum">    1642 </span>            : #define OMP_CLAUSE_DEVICE_ID(NODE) \
<span class="lineNum">    1643 </span>            :   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_DEVICE), 0)
<span class="lineNum">    1644 </span>            : 
<span class="lineNum">    1645 </span>            : #define OMP_CLAUSE_DIST_SCHEDULE_CHUNK_EXPR(NODE) \
<span class="lineNum">    1646 </span>            :   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, \
<span class="lineNum">    1647 </span>            :                                                 OMP_CLAUSE_DIST_SCHEDULE), 0)
<span class="lineNum">    1648 </span>            : 
<span class="lineNum">    1649 </span>            : #define OMP_CLAUSE_SAFELEN_EXPR(NODE) \
<span class="lineNum">    1650 </span>            :   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_SAFELEN), 0)
<span class="lineNum">    1651 </span>            : 
<span class="lineNum">    1652 </span>            : #define OMP_CLAUSE_SIMDLEN_EXPR(NODE) \
<span class="lineNum">    1653 </span>            :   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_SIMDLEN), 0)
<span class="lineNum">    1654 </span>            : 
<span class="lineNum">    1655 </span>            : #define OMP_CLAUSE__SIMDUID__DECL(NODE) \
<span class="lineNum">    1656 </span>            :   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE__SIMDUID_), 0)
<span class="lineNum">    1657 </span>            : 
<span class="lineNum">    1658 </span>            : #define OMP_CLAUSE_SCHEDULE_KIND(NODE) \
<span class="lineNum">    1659 </span>            :   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_SCHEDULE)-&gt;omp_clause.subcode.schedule_kind)
<span class="lineNum">    1660 </span>            : 
<span class="lineNum">    1661 </span>            : /* True if a SCHEDULE clause has the simd modifier on it.  */
<span class="lineNum">    1662 </span>            : #define OMP_CLAUSE_SCHEDULE_SIMD(NODE) \
<span class="lineNum">    1663 </span>            :   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_SCHEDULE)-&gt;base.public_flag)
<span class="lineNum">    1664 </span>            : 
<span class="lineNum">    1665 </span>            : #define OMP_CLAUSE_DEFAULT_KIND(NODE) \
<span class="lineNum">    1666 </span>            :   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_DEFAULT)-&gt;omp_clause.subcode.default_kind)
<span class="lineNum">    1667 </span>            : 
<span class="lineNum">    1668 </span>            : #define OMP_CLAUSE_TILE_LIST(NODE) \
<span class="lineNum">    1669 </span>            :   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_TILE), 0)
<span class="lineNum">    1670 </span>            : #define OMP_CLAUSE_TILE_ITERVAR(NODE) \
<span class="lineNum">    1671 </span>            :   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_TILE), 1)
<span class="lineNum">    1672 </span>            : #define OMP_CLAUSE_TILE_COUNT(NODE) \
<span class="lineNum">    1673 </span>            :   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_TILE), 2)
<span class="lineNum">    1674 </span>            : 
<span class="lineNum">    1675 </span>            : #define OMP_CLAUSE__GRIDDIM__DIMENSION(NODE) \
<span class="lineNum">    1676 </span>            :   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE__GRIDDIM_)\
<span class="lineNum">    1677 </span>            :    -&gt;omp_clause.subcode.dimension)
<span class="lineNum">    1678 </span>            : #define OMP_CLAUSE__GRIDDIM__SIZE(NODE) \
<span class="lineNum">    1679 </span>            :   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE__GRIDDIM_), 0)
<span class="lineNum">    1680 </span>            : #define OMP_CLAUSE__GRIDDIM__GROUP(NODE) \
<span class="lineNum">    1681 </span>            :   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE__GRIDDIM_), 1)
<span class="lineNum">    1682 </span>            : 
<span class="lineNum">    1683 </span>            : /* SSA_NAME accessors.  */
<span class="lineNum">    1684 </span>            : 
<span class="lineNum">    1685 </span>            : /* Whether SSA_NAME NODE is a virtual operand.  This simply caches the
<span class="lineNum">    1686 </span>            :    information in the underlying SSA_NAME_VAR for efficiency.  */
<span class="lineNum">    1687 </span>            : #define SSA_NAME_IS_VIRTUAL_OPERAND(NODE) \
<span class="lineNum">    1688 </span>            :   SSA_NAME_CHECK (NODE)-&gt;base.public_flag
<span class="lineNum">    1689 </span>            : 
<span class="lineNum">    1690 </span>            : /* Returns the IDENTIFIER_NODE giving the SSA name a name or NULL_TREE
<span class="lineNum">    1691 </span>            :    if there is no name associated with it.  */
<span class="lineNum">    1692 </span>            : #define SSA_NAME_IDENTIFIER(NODE)                               \
<span class="lineNum">    1693 </span>            :   (SSA_NAME_CHECK (NODE)-&gt;ssa_name.var != NULL_TREE          \
<span class="lineNum">    1694 </span>            :    ? (TREE_CODE ((NODE)-&gt;ssa_name.var) == IDENTIFIER_NODE    \
<span class="lineNum">    1695 </span>            :       ? (NODE)-&gt;ssa_name.var                                 \
<span class="lineNum">    1696 </span>            :       : DECL_NAME ((NODE)-&gt;ssa_name.var))                    \
<span class="lineNum">    1697 </span>            :    : NULL_TREE)
<span class="lineNum">    1698 </span>            : 
<span class="lineNum">    1699 </span>            : /* Returns the variable being referenced.  This can be NULL_TREE for
<span class="lineNum">    1700 </span>            :    temporaries not associated with any user variable.
<span class="lineNum">    1701 </span>            :    Once released, this is the only field that can be relied upon.  */
<span class="lineNum">    1702 </span>            : #define SSA_NAME_VAR(NODE)                                      \
<span class="lineNum">    1703 </span>            :   (SSA_NAME_CHECK (NODE)-&gt;ssa_name.var == NULL_TREE          \
<span class="lineNum">    1704 </span>            :    || TREE_CODE ((NODE)-&gt;ssa_name.var) == IDENTIFIER_NODE    \
<span class="lineNum">    1705 </span>            :    ? NULL_TREE : (NODE)-&gt;ssa_name.var)
<span class="lineNum">    1706 </span>            : 
<span class="lineNum">    1707 </span>            : #define SET_SSA_NAME_VAR_OR_IDENTIFIER(NODE,VAR) \
<span class="lineNum">    1708 </span>            :   do \
<span class="lineNum">    1709 </span>            :     { \
<span class="lineNum">    1710 </span>            :       tree var_ = (VAR); \
<span class="lineNum">    1711 </span>            :       SSA_NAME_CHECK (NODE)-&gt;ssa_name.var = var_; \
<span class="lineNum">    1712 </span>            :       SSA_NAME_IS_VIRTUAL_OPERAND (NODE) \
<span class="lineNum">    1713 </span>            :         = (var_ \
<span class="lineNum">    1714 </span>            :            &amp;&amp; TREE_CODE (var_) == VAR_DECL \
<span class="lineNum">    1715 </span>            :            &amp;&amp; VAR_DECL_IS_VIRTUAL_OPERAND (var_)); \
<span class="lineNum">    1716 </span>            :     } \
<span class="lineNum">    1717 </span>            :   while (0)
<span class="lineNum">    1718 </span>            : 
<span class="lineNum">    1719 </span>            : /* Returns the statement which defines this SSA name.  */
<span class="lineNum">    1720 </span>            : #define SSA_NAME_DEF_STMT(NODE) SSA_NAME_CHECK (NODE)-&gt;ssa_name.def_stmt
<span class="lineNum">    1721 </span>            : 
<span class="lineNum">    1722 </span>            : /* Returns the SSA version number of this SSA name.  Note that in
<span class="lineNum">    1723 </span>            :    tree SSA, version numbers are not per variable and may be recycled.  */
<span class="lineNum">    1724 </span>            : #define SSA_NAME_VERSION(NODE)  SSA_NAME_CHECK (NODE)-&gt;base.u.version
<span class="lineNum">    1725 </span>            : 
<span class="lineNum">    1726 </span>            : /* Nonzero if this SSA name occurs in an abnormal PHI.  SSA_NAMES are
<span class="lineNum">    1727 </span>            :    never output, so we can safely use the ASM_WRITTEN_FLAG for this
<span class="lineNum">    1728 </span>            :    status bit.  */
<span class="lineNum">    1729 </span>            : #define SSA_NAME_OCCURS_IN_ABNORMAL_PHI(NODE) \
<span class="lineNum">    1730 </span>            :     SSA_NAME_CHECK (NODE)-&gt;base.asm_written_flag
<span class="lineNum">    1731 </span>            : 
<span class="lineNum">    1732 </span>            : /* Nonzero if this SSA_NAME expression is currently on the free list of
<span class="lineNum">    1733 </span>            :    SSA_NAMES.  Using NOTHROW_FLAG seems reasonably safe since throwing
<span class="lineNum">    1734 </span>            :    has no meaning for an SSA_NAME.  */
<span class="lineNum">    1735 </span>            : #define SSA_NAME_IN_FREE_LIST(NODE) \
<span class="lineNum">    1736 </span>            :     SSA_NAME_CHECK (NODE)-&gt;base.nothrow_flag
<span class="lineNum">    1737 </span>            : 
<span class="lineNum">    1738 </span>            : /* Nonzero if this SSA_NAME is the default definition for the
<span class="lineNum">    1739 </span>            :    underlying symbol.  A default SSA name is created for symbol S if
<span class="lineNum">    1740 </span>            :    the very first reference to S in the function is a read operation.
<span class="lineNum">    1741 </span>            :    Default definitions are always created by an empty statement and
<span class="lineNum">    1742 </span>            :    belong to no basic block.  */
<span class="lineNum">    1743 </span>            : #define SSA_NAME_IS_DEFAULT_DEF(NODE) \
<span class="lineNum">    1744 </span>            :     SSA_NAME_CHECK (NODE)-&gt;base.default_def_flag
<span class="lineNum">    1745 </span>            : 
<span class="lineNum">    1746 </span>            : /* Nonzero if this SSA_NAME is known to point to memory that may not
<span class="lineNum">    1747 </span>            :    be written to.  This is set for default defs of function parameters
<span class="lineNum">    1748 </span>            :    that have a corresponding r or R specification in the functions
<span class="lineNum">    1749 </span>            :    fn spec attribute.  This is used by alias analysis.  */
<span class="lineNum">    1750 </span>            : #define SSA_NAME_POINTS_TO_READONLY_MEMORY(NODE) \
<span class="lineNum">    1751 </span>            :     SSA_NAME_CHECK (NODE)-&gt;base.deprecated_flag
<span class="lineNum">    1752 </span>            : 
<span class="lineNum">    1753 </span>            : /* Attributes for SSA_NAMEs for pointer-type variables.  */
<span class="lineNum">    1754 </span>            : #define SSA_NAME_PTR_INFO(N) \
<span class="lineNum">    1755 </span>            :    SSA_NAME_CHECK (N)-&gt;ssa_name.info.ptr_info
<span class="lineNum">    1756 </span>            : 
<span class="lineNum">    1757 </span>            : /* True if SSA_NAME_RANGE_INFO describes an anti-range.  */
<span class="lineNum">    1758 </span>            : #define SSA_NAME_ANTI_RANGE_P(N) \
<span class="lineNum">    1759 </span>            :     SSA_NAME_CHECK (N)-&gt;base.static_flag
<span class="lineNum">    1760 </span>            : 
<span class="lineNum">    1761 </span>            : /* The type of range described by SSA_NAME_RANGE_INFO.  */
<span class="lineNum">    1762 </span>            : #define SSA_NAME_RANGE_TYPE(N) \
<span class="lineNum">    1763 </span>            :     (SSA_NAME_ANTI_RANGE_P (N) ? VR_ANTI_RANGE : VR_RANGE)
<span class="lineNum">    1764 </span>            : 
<span class="lineNum">    1765 </span>            : /* Value range info attributes for SSA_NAMEs of non pointer-type variables.  */
<span class="lineNum">    1766 </span>            : #define SSA_NAME_RANGE_INFO(N) \
<span class="lineNum">    1767 </span>            :     SSA_NAME_CHECK (N)-&gt;ssa_name.info.range_info
<span class="lineNum">    1768 </span>            : 
<span class="lineNum">    1769 </span>            : /* Return the immediate_use information for an SSA_NAME. */
<span class="lineNum">    1770 </span>            : #define SSA_NAME_IMM_USE_NODE(NODE) SSA_NAME_CHECK (NODE)-&gt;ssa_name.imm_uses
<span class="lineNum">    1771 </span>            : 
<span class="lineNum">    1772 </span>            : #define OMP_CLAUSE_CODE(NODE)                                   \
<span class="lineNum">    1773 </span>            :         (OMP_CLAUSE_CHECK (NODE))-&gt;omp_clause.code
<span class="lineNum">    1774 </span>            : 
<span class="lineNum">    1775 </span>            : #define OMP_CLAUSE_SET_CODE(NODE, CODE)                         \
<span class="lineNum">    1776 </span>            :         ((OMP_CLAUSE_CHECK (NODE))-&gt;omp_clause.code = (CODE))
<span class="lineNum">    1777 </span>            : 
<span class="lineNum">    1778 </span>            : #define OMP_CLAUSE_OPERAND(NODE, I)                             \
<span class="lineNum">    1779 </span>            :         OMP_CLAUSE_ELT_CHECK (NODE, I)
<span class="lineNum">    1780 </span>            : 
<span class="lineNum">    1781 </span>            : /* In a BLOCK node.  */
<span class="lineNum">    1782 </span>            : #define BLOCK_VARS(NODE) (BLOCK_CHECK (NODE)-&gt;block.vars)
<span class="lineNum">    1783 </span>            : #define BLOCK_NONLOCALIZED_VARS(NODE) \
<span class="lineNum">    1784 </span>            :   (BLOCK_CHECK (NODE)-&gt;block.nonlocalized_vars)
<span class="lineNum">    1785 </span>            : #define BLOCK_NUM_NONLOCALIZED_VARS(NODE) \
<span class="lineNum">    1786 </span>            :   vec_safe_length (BLOCK_NONLOCALIZED_VARS (NODE))
<span class="lineNum">    1787 </span>            : #define BLOCK_NONLOCALIZED_VAR(NODE,N) (*BLOCK_NONLOCALIZED_VARS (NODE))[N]
<span class="lineNum">    1788 </span>            : #define BLOCK_SUBBLOCKS(NODE) (BLOCK_CHECK (NODE)-&gt;block.subblocks)
<span class="lineNum">    1789 </span>            : #define BLOCK_SUPERCONTEXT(NODE) (BLOCK_CHECK (NODE)-&gt;block.supercontext)
<span class="lineNum">    1790 </span>            : #define BLOCK_CHAIN(NODE) (BLOCK_CHECK (NODE)-&gt;block.chain)
<span class="lineNum">    1791 </span>            : #define BLOCK_ABSTRACT_ORIGIN(NODE) (BLOCK_CHECK (NODE)-&gt;block.abstract_origin)
<span class="lineNum">    1792 </span>            : #define BLOCK_ABSTRACT(NODE) (BLOCK_CHECK (NODE)-&gt;block.abstract_flag)
<span class="lineNum">    1793 </span>            : #define BLOCK_DIE(NODE) (BLOCK_CHECK (NODE)-&gt;block.die)
<span class="lineNum">    1794 </span>            : 
<span class="lineNum">    1795 </span>            : /* True if BLOCK has the same ranges as its BLOCK_SUPERCONTEXT.  */
<span class="lineNum">    1796 </span>            : #define BLOCK_SAME_RANGE(NODE) (BLOCK_CHECK (NODE)-&gt;base.u.bits.nameless_flag)
<span class="lineNum">    1797 </span>            : 
<span class="lineNum">    1798 </span>            : /* True if BLOCK appears in cold section.  */
<span class="lineNum">    1799 </span>            : #define BLOCK_IN_COLD_SECTION_P(NODE) \
<span class="lineNum">    1800 </span>            :   (BLOCK_CHECK (NODE)-&gt;base.u.bits.atomic_flag)
<span class="lineNum">    1801 </span>            : 
<span class="lineNum">    1802 </span>            : /* An index number for this block.  These values are not guaranteed to
<span class="lineNum">    1803 </span>            :    be unique across functions -- whether or not they are depends on
<span class="lineNum">    1804 </span>            :    the debugging output format in use.  */
<span class="lineNum">    1805 </span>            : #define BLOCK_NUMBER(NODE) (BLOCK_CHECK (NODE)-&gt;block.block_num)
<span class="lineNum">    1806 </span>            : 
<span class="lineNum">    1807 </span>            : /* If block reordering splits a lexical block into discontiguous
<span class="lineNum">    1808 </span>            :    address ranges, we'll make a copy of the original block.
<span class="lineNum">    1809 </span>            : 
<span class="lineNum">    1810 </span>            :    Note that this is logically distinct from BLOCK_ABSTRACT_ORIGIN.
<span class="lineNum">    1811 </span>            :    In that case, we have one source block that has been replicated
<span class="lineNum">    1812 </span>            :    (through inlining or unrolling) into many logical blocks, and that
<span class="lineNum">    1813 </span>            :    these logical blocks have different physical variables in them.
<span class="lineNum">    1814 </span>            : 
<span class="lineNum">    1815 </span>            :    In this case, we have one logical block split into several
<span class="lineNum">    1816 </span>            :    non-contiguous address ranges.  Most debug formats can't actually
<span class="lineNum">    1817 </span>            :    represent this idea directly, so we fake it by creating multiple
<span class="lineNum">    1818 </span>            :    logical blocks with the same variables in them.  However, for those
<span class="lineNum">    1819 </span>            :    that do support non-contiguous regions, these allow the original
<span class="lineNum">    1820 </span>            :    logical block to be reconstructed, along with the set of address
<span class="lineNum">    1821 </span>            :    ranges.
<span class="lineNum">    1822 </span>            : 
<span class="lineNum">    1823 </span>            :    One of the logical block fragments is arbitrarily chosen to be
<span class="lineNum">    1824 </span>            :    the ORIGIN.  The other fragments will point to the origin via
<span class="lineNum">    1825 </span>            :    BLOCK_FRAGMENT_ORIGIN; the origin itself will have this pointer
<span class="lineNum">    1826 </span>            :    be null.  The list of fragments will be chained through
<span class="lineNum">    1827 </span>            :    BLOCK_FRAGMENT_CHAIN from the origin.  */
<span class="lineNum">    1828 </span>            : 
<span class="lineNum">    1829 </span>            : #define BLOCK_FRAGMENT_ORIGIN(NODE) (BLOCK_CHECK (NODE)-&gt;block.fragment_origin)
<span class="lineNum">    1830 </span>            : #define BLOCK_FRAGMENT_CHAIN(NODE) (BLOCK_CHECK (NODE)-&gt;block.fragment_chain)
<span class="lineNum">    1831 </span>            : 
<span class="lineNum">    1832 </span>            : /* For an inlined function, this gives the location where it was called
<span class="lineNum">    1833 </span>            :    from.  This is only set in the top level block, which corresponds to the
<span class="lineNum">    1834 </span>            :    inlined function scope.  This is used in the debug output routines.  */
<span class="lineNum">    1835 </span>            : 
<span class="lineNum">    1836 </span>            : #define BLOCK_SOURCE_LOCATION(NODE) (BLOCK_CHECK (NODE)-&gt;block.locus)
<span class="lineNum">    1837 </span>            : 
<span class="lineNum">    1838 </span>            : /* This gives the location of the end of the block, useful to attach
<span class="lineNum">    1839 </span>            :    code implicitly generated for outgoing paths.  */
<span class="lineNum">    1840 </span>            : 
<span class="lineNum">    1841 </span>            : #define BLOCK_SOURCE_END_LOCATION(NODE) (BLOCK_CHECK (NODE)-&gt;block.end_locus)
<span class="lineNum">    1842 </span>            : 
<span class="lineNum">    1843 </span>            : /* Define fields and accessors for nodes representing data types.  */
<span class="lineNum">    1844 </span>            : 
<span class="lineNum">    1845 </span>            : /* See tree.def for documentation of the use of these fields.
<span class="lineNum">    1846 </span>            :    Look at the documentation of the various ..._TYPE tree codes.
<span class="lineNum">    1847 </span>            : 
<span class="lineNum">    1848 </span>            :    Note that the type.values, type.minval, and type.maxval fields are
<span class="lineNum">    1849 </span>            :    overloaded and used for different macros in different kinds of types.
<span class="lineNum">    1850 </span>            :    Each macro must check to ensure the tree node is of the proper kind of
<span class="lineNum">    1851 </span>            :    type.  Note also that some of the front-ends also overload these fields,
<span class="lineNum">    1852 </span>            :    so they must be checked as well.  */
<span class="lineNum">    1853 </span>            : 
<span class="lineNum">    1854 </span>            : #define TYPE_UID(NODE) (TYPE_CHECK (NODE)-&gt;type_common.uid)
<span class="lineNum">    1855 </span>            : #define TYPE_SIZE(NODE) (TYPE_CHECK (NODE)-&gt;type_common.size)
<span class="lineNum">    1856 </span>            : #define TYPE_SIZE_UNIT(NODE) (TYPE_CHECK (NODE)-&gt;type_common.size_unit)
<span class="lineNum">    1857 </span>            : #define TYPE_POINTER_TO(NODE) (TYPE_CHECK (NODE)-&gt;type_common.pointer_to)
<span class="lineNum">    1858 </span>            : #define TYPE_REFERENCE_TO(NODE) (TYPE_CHECK (NODE)-&gt;type_common.reference_to)
<span class="lineNum">    1859 </span>            : #define TYPE_PRECISION(NODE) (TYPE_CHECK (NODE)-&gt;type_common.precision)
<span class="lineNum">    1860 </span>            : #define TYPE_NAME(NODE) (TYPE_CHECK (NODE)-&gt;type_common.name)
<span class="lineNum">    1861 </span>            : #define TYPE_NEXT_VARIANT(NODE) (TYPE_CHECK (NODE)-&gt;type_common.next_variant)
<span class="lineNum">    1862 </span>            : #define TYPE_MAIN_VARIANT(NODE) (TYPE_CHECK (NODE)-&gt;type_common.main_variant)
<span class="lineNum">    1863 </span>            : #define TYPE_CONTEXT(NODE) (TYPE_CHECK (NODE)-&gt;type_common.context)
<span class="lineNum">    1864 </span>            : 
<span class="lineNum">    1865 </span>            : #define TYPE_MODE_RAW(NODE) (TYPE_CHECK (NODE)-&gt;type_common.mode)
<span class="lineNum">    1866 </span>            : #define TYPE_MODE(NODE) \
<span class="lineNum">    1867 </span>            :   (VECTOR_TYPE_P (TYPE_CHECK (NODE)) \
<span class="lineNum">    1868 </span>            :    ? vector_type_mode (NODE) : (NODE)-&gt;type_common.mode)
<span class="lineNum">    1869 </span>            : #define SCALAR_TYPE_MODE(NODE) \
<span class="lineNum">    1870 </span>            :   (as_a &lt;scalar_mode&gt; (TYPE_CHECK (NODE)-&gt;type_common.mode))
<span class="lineNum">    1871 </span>            : #define SCALAR_INT_TYPE_MODE(NODE) \
<span class="lineNum">    1872 </span>            :   (as_a &lt;scalar_int_mode&gt; (TYPE_CHECK (NODE)-&gt;type_common.mode))
<span class="lineNum">    1873 </span>            : #define SCALAR_FLOAT_TYPE_MODE(NODE) \
<span class="lineNum">    1874 </span>            :   (as_a &lt;scalar_float_mode&gt; (TYPE_CHECK (NODE)-&gt;type_common.mode))
<span class="lineNum">    1875 </span>            : #define SET_TYPE_MODE(NODE, MODE) \
<span class="lineNum">    1876 </span>            :   (TYPE_CHECK (NODE)-&gt;type_common.mode = (MODE))
<span class="lineNum">    1877 </span>            : 
<span class="lineNum">    1878 </span>            : extern machine_mode element_mode (const_tree);
<span class="lineNum">    1879 </span>            : extern machine_mode vector_type_mode (const_tree);
<span class="lineNum">    1880 </span>            : 
<span class="lineNum">    1881 </span>            : /* The &quot;canonical&quot; type for this type node, which is used by frontends to
<span class="lineNum">    1882 </span>            :    compare the type for equality with another type.  If two types are
<span class="lineNum">    1883 </span>            :    equal (based on the semantics of the language), then they will have
<span class="lineNum">    1884 </span>            :    equivalent TYPE_CANONICAL entries.
<span class="lineNum">    1885 </span>            : 
<span class="lineNum">    1886 </span>            :    As a special case, if TYPE_CANONICAL is NULL_TREE, and thus
<span class="lineNum">    1887 </span>            :    TYPE_STRUCTURAL_EQUALITY_P is true, then it cannot
<span class="lineNum">    1888 </span>            :    be used for comparison against other types.  Instead, the type is
<span class="lineNum">    1889 </span>            :    said to require structural equality checks, described in
<span class="lineNum">    1890 </span>            :    TYPE_STRUCTURAL_EQUALITY_P.
<span class="lineNum">    1891 </span>            : 
<span class="lineNum">    1892 </span>            :    For unqualified aggregate and function types the middle-end relies on
<span class="lineNum">    1893 </span>            :    TYPE_CANONICAL to tell whether two variables can be assigned
<span class="lineNum">    1894 </span>            :    to each other without a conversion.  The middle-end also makes sure
<span class="lineNum">    1895 </span>            :    to assign the same alias-sets to the type partition with equal
<span class="lineNum">    1896 </span>            :    TYPE_CANONICAL of their unqualified variants.  */
<span class="lineNum">    1897 </span>            : #define TYPE_CANONICAL(NODE) (TYPE_CHECK (NODE)-&gt;type_common.canonical)
<span class="lineNum">    1898 </span>            : /* Indicates that the type node requires structural equality
<span class="lineNum">    1899 </span>            :    checks.  The compiler will need to look at the composition of the
<span class="lineNum">    1900 </span>            :    type to determine whether it is equal to another type, rather than
<span class="lineNum">    1901 </span>            :    just comparing canonical type pointers.  For instance, we would need
<span class="lineNum">    1902 </span>            :    to look at the return and parameter types of a FUNCTION_TYPE
<span class="lineNum">    1903 </span>            :    node.  */
<span class="lineNum">    1904 </span>            : #define TYPE_STRUCTURAL_EQUALITY_P(NODE) (TYPE_CANONICAL (NODE) == NULL_TREE)
<span class="lineNum">    1905 </span>            : /* Sets the TYPE_CANONICAL field to NULL_TREE, indicating that the
<span class="lineNum">    1906 </span>            :    type node requires structural equality.  */
<span class="lineNum">    1907 </span>            : #define SET_TYPE_STRUCTURAL_EQUALITY(NODE) (TYPE_CANONICAL (NODE) = NULL_TREE)
<span class="lineNum">    1908 </span>            : 
<span class="lineNum">    1909 </span>            : #define TYPE_IBIT(NODE) (GET_MODE_IBIT (TYPE_MODE (NODE)))
<span class="lineNum">    1910 </span>            : #define TYPE_FBIT(NODE) (GET_MODE_FBIT (TYPE_MODE (NODE)))
<span class="lineNum">    1911 </span>            : 
<span class="lineNum">    1912 </span>            : /* The (language-specific) typed-based alias set for this type.
<span class="lineNum">    1913 </span>            :    Objects whose TYPE_ALIAS_SETs are different cannot alias each
<span class="lineNum">    1914 </span>            :    other.  If the TYPE_ALIAS_SET is -1, no alias set has yet been
<span class="lineNum">    1915 </span>            :    assigned to this type.  If the TYPE_ALIAS_SET is 0, objects of this
<span class="lineNum">    1916 </span>            :    type can alias objects of any type.  */
<span class="lineNum">    1917 </span>            : #define TYPE_ALIAS_SET(NODE) (TYPE_CHECK (NODE)-&gt;type_common.alias_set)
<span class="lineNum">    1918 </span>            : 
<span class="lineNum">    1919 </span>            : /* Nonzero iff the typed-based alias set for this type has been
<span class="lineNum">    1920 </span>            :    calculated.  */
<span class="lineNum">    1921 </span>            : #define TYPE_ALIAS_SET_KNOWN_P(NODE) \
<span class="lineNum">    1922 </span>            :   (TYPE_CHECK (NODE)-&gt;type_common.alias_set != -1)
<span class="lineNum">    1923 </span>            : 
<span class="lineNum">    1924 </span>            : /* A TREE_LIST of IDENTIFIER nodes of the attributes that apply
<span class="lineNum">    1925 </span>            :    to this type.  */
<span class="lineNum">    1926 </span>            : #define TYPE_ATTRIBUTES(NODE) (TYPE_CHECK (NODE)-&gt;type_common.attributes)
<span class="lineNum">    1927 </span>            : 
<span class="lineNum">    1928 </span>            : /* The alignment necessary for objects of this type.
<span class="lineNum">    1929 </span>            :    The value is an int, measured in bits and must be a power of two.
<span class="lineNum">    1930 </span>            :    We support also an &quot;alignment&quot; of zero.  */
<span class="lineNum">    1931 </span>            : #define TYPE_ALIGN(NODE) \
<span class="lineNum">    1932 </span>            :     (TYPE_CHECK (NODE)-&gt;type_common.align \
<span class="lineNum">    1933 </span>            :      ? ((unsigned)1) &lt;&lt; ((NODE)-&gt;type_common.align - 1) : 0)
<span class="lineNum">    1934 </span>            : 
<span class="lineNum">    1935 </span>            : /* Specify that TYPE_ALIGN(NODE) is X.  */
<span class="lineNum">    1936 </span>            : #define SET_TYPE_ALIGN(NODE, X) \
<span class="lineNum">    1937 </span>            :     (TYPE_CHECK (NODE)-&gt;type_common.align = ffs_hwi (X))
<span class="lineNum">    1938 </span>            : 
<span class="lineNum">    1939 </span>            : /* 1 if the alignment for this type was requested by &quot;aligned&quot; attribute,
<span class="lineNum">    1940 </span>            :    0 if it is the default for this type.  */
<span class="lineNum">    1941 </span>            : #define TYPE_USER_ALIGN(NODE) (TYPE_CHECK (NODE)-&gt;base.u.bits.user_align)
<span class="lineNum">    1942 </span>            : 
<span class="lineNum">    1943 </span>            : /* The alignment for NODE, in bytes.  */
<span class="lineNum">    1944 </span>            : #define TYPE_ALIGN_UNIT(NODE) (TYPE_ALIGN (NODE) / BITS_PER_UNIT)
<span class="lineNum">    1945 </span>            : 
<span class="lineNum">    1946 </span>            : /* The minimum alignment necessary for objects of this type without
<span class="lineNum">    1947 </span>            :    warning.  The value is an int, measured in bits.  */
<span class="lineNum">    1948 </span>            : #define TYPE_WARN_IF_NOT_ALIGN(NODE) \
<span class="lineNum">    1949 </span>            :     (TYPE_CHECK (NODE)-&gt;type_common.warn_if_not_align \
<span class="lineNum">    1950 </span>            :      ? ((unsigned)1) &lt;&lt; ((NODE)-&gt;type_common.warn_if_not_align - 1) : 0)
<span class="lineNum">    1951 </span>            : 
<span class="lineNum">    1952 </span>            : /* Specify that TYPE_WARN_IF_NOT_ALIGN(NODE) is X.  */
<span class="lineNum">    1953 </span>            : #define SET_TYPE_WARN_IF_NOT_ALIGN(NODE, X) \
<span class="lineNum">    1954 </span>            :     (TYPE_CHECK (NODE)-&gt;type_common.warn_if_not_align = ffs_hwi (X))
<span class="lineNum">    1955 </span>            : 
<span class="lineNum">    1956 </span>            : /* If your language allows you to declare types, and you want debug info
<span class="lineNum">    1957 </span>            :    for them, then you need to generate corresponding TYPE_DECL nodes.
<span class="lineNum">    1958 </span>            :    These &quot;stub&quot; TYPE_DECL nodes have no name, and simply point at the
<span class="lineNum">    1959 </span>            :    type node.  You then set the TYPE_STUB_DECL field of the type node
<span class="lineNum">    1960 </span>            :    to point back at the TYPE_DECL node.  This allows the debug routines
<span class="lineNum">    1961 </span>            :    to know that the two nodes represent the same type, so that we only
<span class="lineNum">    1962 </span>            :    get one debug info record for them.  */
<span class="lineNum">    1963 </span>            : #define TYPE_STUB_DECL(NODE) (TREE_CHAIN (TYPE_CHECK (NODE)))
<span class="lineNum">    1964 </span>            : 
<span class="lineNum">    1965 </span>            : /* In a RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE or ARRAY_TYPE, it means
<span class="lineNum">    1966 </span>            :    the type has BLKmode only because it lacks the alignment required for
<span class="lineNum">    1967 </span>            :    its size.  */
<span class="lineNum">    1968 </span>            : #define TYPE_NO_FORCE_BLK(NODE) \
<span class="lineNum">    1969 </span>            :   (TYPE_CHECK (NODE)-&gt;type_common.no_force_blk_flag)
<span class="lineNum">    1970 </span>            : 
<span class="lineNum">    1971 </span>            : /* Nonzero in a type considered volatile as a whole.  */
<span class="lineNum">    1972 </span>            : #define TYPE_VOLATILE(NODE) (TYPE_CHECK (NODE)-&gt;base.volatile_flag)
<span class="lineNum">    1973 </span>            : 
<span class="lineNum">    1974 </span>            : /* Nonzero in a type considered atomic as a whole.  */
<span class="lineNum">    1975 </span>            : #define TYPE_ATOMIC(NODE) (TYPE_CHECK (NODE)-&gt;base.u.bits.atomic_flag)
<span class="lineNum">    1976 </span>            : 
<span class="lineNum">    1977 </span>            : /* Means this type is const-qualified.  */
<span class="lineNum">    1978 </span>            : #define TYPE_READONLY(NODE) (TYPE_CHECK (NODE)-&gt;base.readonly_flag)
<span class="lineNum">    1979 </span>            : 
<span class="lineNum">    1980 </span>            : /* If nonzero, this type is `restrict'-qualified, in the C sense of
<span class="lineNum">    1981 </span>            :    the term.  */
<span class="lineNum">    1982 </span>            : #define TYPE_RESTRICT(NODE) (TYPE_CHECK (NODE)-&gt;type_common.restrict_flag)
<span class="lineNum">    1983 </span>            : 
<span class="lineNum">    1984 </span>            : /* If nonzero, type's name shouldn't be emitted into debug info.  */
<span class="lineNum">    1985 </span>            : #define TYPE_NAMELESS(NODE) (TYPE_CHECK (NODE)-&gt;base.u.bits.nameless_flag)
<span class="lineNum">    1986 </span>            : 
<span class="lineNum">    1987 </span>            : /* The address space the type is in.  */
<span class="lineNum">    1988 </span>            : #define TYPE_ADDR_SPACE(NODE) (TYPE_CHECK (NODE)-&gt;base.u.bits.address_space)
<span class="lineNum">    1989 </span>            : 
<span class="lineNum">    1990 </span>            : /* Encode/decode the named memory support as part of the qualifier.  If more
<span class="lineNum">    1991 </span>            :    than 8 qualifiers are added, these macros need to be adjusted.  */
<span class="lineNum">    1992 </span>            : #define ENCODE_QUAL_ADDR_SPACE(NUM) ((NUM &amp; 0xFF) &lt;&lt; 8)
<span class="lineNum">    1993 </span>            : #define DECODE_QUAL_ADDR_SPACE(X) (((X) &gt;&gt; 8) &amp; 0xFF)
<span class="lineNum">    1994 </span>            : 
<span class="lineNum">    1995 </span>            : /* Return all qualifiers except for the address space qualifiers.  */
<span class="lineNum">    1996 </span>            : #define CLEAR_QUAL_ADDR_SPACE(X) ((X) &amp; ~0xFF00)
<span class="lineNum">    1997 </span>            : 
<span class="lineNum">    1998 </span>            : /* Only keep the address space out of the qualifiers and discard the other
<span class="lineNum">    1999 </span>            :    qualifiers.  */
<span class="lineNum">    2000 </span>            : #define KEEP_QUAL_ADDR_SPACE(X) ((X) &amp; 0xFF00)
<span class="lineNum">    2001 </span>            : 
<span class="lineNum">    2002 </span>            : /* The set of type qualifiers for this type.  */
<span class="lineNum">    2003 </span>            : #define TYPE_QUALS(NODE)                                        \
<span class="lineNum">    2004 </span>            :   ((int) ((TYPE_READONLY (NODE) * TYPE_QUAL_CONST)              \
<span class="lineNum">    2005 </span>            :           | (TYPE_VOLATILE (NODE) * TYPE_QUAL_VOLATILE)         \
<span class="lineNum">    2006 </span>            :           | (TYPE_ATOMIC (NODE) * TYPE_QUAL_ATOMIC)             \
<span class="lineNum">    2007 </span>            :           | (TYPE_RESTRICT (NODE) * TYPE_QUAL_RESTRICT)         \
<span class="lineNum">    2008 </span>            :           | (ENCODE_QUAL_ADDR_SPACE (TYPE_ADDR_SPACE (NODE)))))
<span class="lineNum">    2009 </span>            : 
<span class="lineNum">    2010 </span>            : /* The same as TYPE_QUALS without the address space qualifications.  */
<span class="lineNum">    2011 </span>            : #define TYPE_QUALS_NO_ADDR_SPACE(NODE)                          \
<span class="lineNum">    2012 </span>            :   ((int) ((TYPE_READONLY (NODE) * TYPE_QUAL_CONST)              \
<span class="lineNum">    2013 </span>            :           | (TYPE_VOLATILE (NODE) * TYPE_QUAL_VOLATILE)         \
<span class="lineNum">    2014 </span>            :           | (TYPE_ATOMIC (NODE) * TYPE_QUAL_ATOMIC)             \
<span class="lineNum">    2015 </span>            :           | (TYPE_RESTRICT (NODE) * TYPE_QUAL_RESTRICT)))
<span class="lineNum">    2016 </span>            : 
<span class="lineNum">    2017 </span>            : /* The same as TYPE_QUALS without the address space and atomic 
<span class="lineNum">    2018 </span>            :    qualifications.  */
<span class="lineNum">    2019 </span>            : #define TYPE_QUALS_NO_ADDR_SPACE_NO_ATOMIC(NODE)                \
<span class="lineNum">    2020 </span>            :   ((int) ((TYPE_READONLY (NODE) * TYPE_QUAL_CONST)              \
<span class="lineNum">    2021 </span>            :           | (TYPE_VOLATILE (NODE) * TYPE_QUAL_VOLATILE)         \
<span class="lineNum">    2022 </span>            :           | (TYPE_RESTRICT (NODE) * TYPE_QUAL_RESTRICT)))
<span class="lineNum">    2023 </span>            : 
<span class="lineNum">    2024 </span>            : /* These flags are available for each language front end to use internally.  */
<span class="lineNum">    2025 </span>            : #define TYPE_LANG_FLAG_0(NODE) (TYPE_CHECK (NODE)-&gt;type_common.lang_flag_0)
<span class="lineNum">    2026 </span>            : #define TYPE_LANG_FLAG_1(NODE) (TYPE_CHECK (NODE)-&gt;type_common.lang_flag_1)
<span class="lineNum">    2027 </span>            : #define TYPE_LANG_FLAG_2(NODE) (TYPE_CHECK (NODE)-&gt;type_common.lang_flag_2)
<span class="lineNum">    2028 </span>            : #define TYPE_LANG_FLAG_3(NODE) (TYPE_CHECK (NODE)-&gt;type_common.lang_flag_3)
<span class="lineNum">    2029 </span>            : #define TYPE_LANG_FLAG_4(NODE) (TYPE_CHECK (NODE)-&gt;type_common.lang_flag_4)
<span class="lineNum">    2030 </span>            : #define TYPE_LANG_FLAG_5(NODE) (TYPE_CHECK (NODE)-&gt;type_common.lang_flag_5)
<span class="lineNum">    2031 </span>            : #define TYPE_LANG_FLAG_6(NODE) (TYPE_CHECK (NODE)-&gt;type_common.lang_flag_6)
<span class="lineNum">    2032 </span>            : #define TYPE_LANG_FLAG_7(NODE) (TYPE_CHECK (NODE)-&gt;type_common.lang_flag_7)
<span class="lineNum">    2033 </span>            : 
<span class="lineNum">    2034 </span>            : /* Used to keep track of visited nodes in tree traversals.  This is set to
<span class="lineNum">    2035 </span>            :    0 by copy_node and make_node.  */
<span class="lineNum">    2036 </span>            : #define TREE_VISITED(NODE) ((NODE)-&gt;base.visited)
<span class="lineNum">    2037 </span>            : 
<span class="lineNum">    2038 </span>            : /* If set in an ARRAY_TYPE, indicates a string type (for languages
<span class="lineNum">    2039 </span>            :    that distinguish string from array of char).
<span class="lineNum">    2040 </span>            :    If set in a INTEGER_TYPE, indicates a character type.  */
<span class="lineNum">    2041 </span>            : #define TYPE_STRING_FLAG(NODE) (TYPE_CHECK (NODE)-&gt;type_common.string_flag)
<span class="lineNum">    2042 </span>            : 
<span class="lineNum">    2043 </span>            : /* Nonzero in a VECTOR_TYPE if the frontends should not emit warnings
<span class="lineNum">    2044 </span>            :    about missing conversions to other vector types of the same size.  */
<span class="lineNum">    2045 </span>            : #define TYPE_VECTOR_OPAQUE(NODE) \
<span class="lineNum">    2046 </span>            :   (VECTOR_TYPE_CHECK (NODE)-&gt;base.default_def_flag)
<span class="lineNum">    2047 </span>            : 
<span class="lineNum">    2048 </span>            : /* Indicates that objects of this type must be initialized by calling a
<span class="lineNum">    2049 </span>            :    function when they are created.  */
<span class="lineNum">    2050 </span>            : #define TYPE_NEEDS_CONSTRUCTING(NODE) \
<span class="lineNum">    2051 </span>            :   (TYPE_CHECK (NODE)-&gt;type_common.needs_constructing_flag)
<span class="lineNum">    2052 </span>            : 
<span class="lineNum">    2053 </span>            : /* Indicates that a UNION_TYPE object should be passed the same way that
<span class="lineNum">    2054 </span>            :    the first union alternative would be passed, or that a RECORD_TYPE
<span class="lineNum">    2055 </span>            :    object should be passed the same way that the first (and only) member
<span class="lineNum">    2056 </span>            :    would be passed.  */
<span class="lineNum">    2057 </span>            : #define TYPE_TRANSPARENT_AGGR(NODE) \
<span class="lineNum">    2058 </span>            :   (RECORD_OR_UNION_CHECK (NODE)-&gt;type_common.transparent_aggr_flag)
<span class="lineNum">    2059 </span>            : 
<span class="lineNum">    2060 </span>            : /* For an ARRAY_TYPE, indicates that it is not permitted to take the
<span class="lineNum">    2061 </span>            :    address of a component of the type.  This is the counterpart of
<span class="lineNum">    2062 </span>            :    DECL_NONADDRESSABLE_P for arrays, see the definition of this flag.  */
<span class="lineNum">    2063 </span>            : #define TYPE_NONALIASED_COMPONENT(NODE) \
<span class="lineNum">    2064 </span>            :   (ARRAY_TYPE_CHECK (NODE)-&gt;type_common.transparent_aggr_flag)
<span class="lineNum">    2065 </span>            : 
<span class="lineNum">    2066 </span>            : /* For an ARRAY_TYPE, a RECORD_TYPE, a UNION_TYPE or a QUAL_UNION_TYPE
<span class="lineNum">    2067 </span>            :    whether the array is typeless storage or the type contains a member
<span class="lineNum">    2068 </span>            :    with this flag set.  Such types are exempt from type-based alias
<span class="lineNum">    2069 </span>            :    analysis.  For ARRAY_TYPEs with AGGREGATE_TYPE_P element types
<span class="lineNum">    2070 </span>            :    the flag should be inherited from the element type, can change
<span class="lineNum">    2071 </span>            :    when type is finalized and because of that should not be used in
<span class="lineNum">    2072 </span>            :    type hashing.  For ARRAY_TYPEs with non-AGGREGATE_TYPE_P element types
<span class="lineNum">    2073 </span>            :    the flag should not be changed after the array is created and should
<span class="lineNum">    2074 </span>            :    be used in type hashing.  */
<span class="lineNum">    2075 </span>            : #define TYPE_TYPELESS_STORAGE(NODE) \
<span class="lineNum">    2076 </span>            :   (TREE_CHECK4 (NODE, RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE, \
<span class="lineNum">    2077 </span>            :                 ARRAY_TYPE)-&gt;type_common.typeless_storage)
<span class="lineNum">    2078 </span>            : 
<span class="lineNum">    2079 </span>            : /* Indicated that objects of this type should be laid out in as
<span class="lineNum">    2080 </span>            :    compact a way as possible.  */
<span class="lineNum">    2081 </span>            : #define TYPE_PACKED(NODE) (TYPE_CHECK (NODE)-&gt;base.u.bits.packed_flag)
<span class="lineNum">    2082 </span>            : 
<span class="lineNum">    2083 </span>            : /* Used by type_contains_placeholder_p to avoid recomputation.
<span class="lineNum">    2084 </span>            :    Values are: 0 (unknown), 1 (false), 2 (true).  Never access
<span class="lineNum">    2085 </span>            :    this field directly.  */
<span class="lineNum">    2086 </span>            : #define TYPE_CONTAINS_PLACEHOLDER_INTERNAL(NODE) \
<span class="lineNum">    2087 </span>            :   (TYPE_CHECK (NODE)-&gt;type_common.contains_placeholder_bits)
<span class="lineNum">    2088 </span>            : 
<span class="lineNum">    2089 </span>            : /* Nonzero if RECORD_TYPE represents a final derivation of class.  */
<span class="lineNum">    2090 </span>            : #define TYPE_FINAL_P(NODE) \
<span class="lineNum">    2091 </span>            :   (RECORD_OR_UNION_CHECK (NODE)-&gt;base.default_def_flag)
<span class="lineNum">    2092 </span>            : 
<span class="lineNum">    2093 </span>            : /* The debug output functions use the symtab union field to store
<span class="lineNum">    2094 </span>            :    information specific to the debugging format.  The different debug
<span class="lineNum">    2095 </span>            :    output hooks store different types in the union field.  These three
<span class="lineNum">    2096 </span>            :    macros are used to access different fields in the union.  The debug
<span class="lineNum">    2097 </span>            :    hooks are responsible for consistently using only a specific
<span class="lineNum">    2098 </span>            :    macro.  */
<span class="lineNum">    2099 </span>            : 
<span class="lineNum">    2100 </span>            : /* Symtab field as an integer.  Used by stabs generator in dbxout.c to
<span class="lineNum">    2101 </span>            :    hold the type's number in the generated stabs.  */
<span class="lineNum">    2102 </span>            : #define TYPE_SYMTAB_ADDRESS(NODE) \
<span class="lineNum">    2103 </span>            :   (TYPE_CHECK (NODE)-&gt;type_common.symtab.address)
<span class="lineNum">    2104 </span>            : 
<span class="lineNum">    2105 </span>            : /* Symtab field as a pointer to a DWARF DIE.  Used by DWARF generator
<span class="lineNum">    2106 </span>            :    in dwarf2out.c to point to the DIE generated for the type.  */
<span class="lineNum">    2107 </span>            : #define TYPE_SYMTAB_DIE(NODE) \
<span class="lineNum">    2108 </span>            :   (TYPE_CHECK (NODE)-&gt;type_common.symtab.die)
<span class="lineNum">    2109 </span>            : 
<span class="lineNum">    2110 </span>            : /* The garbage collector needs to know the interpretation of the
<span class="lineNum">    2111 </span>            :    symtab field.  These constants represent the different types in the
<span class="lineNum">    2112 </span>            :    union.  */
<span class="lineNum">    2113 </span>            : 
<span class="lineNum">    2114 </span>            : #define TYPE_SYMTAB_IS_ADDRESS (0)
<span class="lineNum">    2115 </span>            : #define TYPE_SYMTAB_IS_DIE (1)
<span class="lineNum">    2116 </span>            : 
<span class="lineNum">    2117 </span>            : #define TYPE_LANG_SPECIFIC(NODE) \
<span class="lineNum">    2118 </span>            :   (TYPE_CHECK (NODE)-&gt;type_with_lang_specific.lang_specific)
<span class="lineNum">    2119 </span>            : 
<span class="lineNum">    2120 </span>            : #define TYPE_VALUES(NODE) (ENUMERAL_TYPE_CHECK (NODE)-&gt;type_non_common.values)
<span class="lineNum">    2121 </span>            : #define TYPE_DOMAIN(NODE) (ARRAY_TYPE_CHECK (NODE)-&gt;type_non_common.values)
<span class="lineNum">    2122 </span>            : #define TYPE_FIELDS(NODE)                               \
<span class="lineNum">    2123 </span>            :   (RECORD_OR_UNION_CHECK (NODE)-&gt;type_non_common.values)
<span class="lineNum">    2124 </span>            : #define TYPE_CACHED_VALUES(NODE) (TYPE_CHECK (NODE)-&gt;type_non_common.values)
<span class="lineNum">    2125 </span>            : #define TYPE_ARG_TYPES(NODE)                            \
<span class="lineNum">    2126 </span>            :   (FUNC_OR_METHOD_CHECK (NODE)-&gt;type_non_common.values)
<span class="lineNum">    2127 </span>            : #define TYPE_VALUES_RAW(NODE) (TYPE_CHECK (NODE)-&gt;type_non_common.values)
<span class="lineNum">    2128 </span>            : 
<span class="lineNum">    2129 </span>            : #define TYPE_MIN_VALUE(NODE)                            \
<span class="lineNum">    2130 </span>            :   (NUMERICAL_TYPE_CHECK (NODE)-&gt;type_non_common.minval)
<span class="lineNum">    2131 </span>            : #define TYPE_NEXT_PTR_TO(NODE)                          \
<span class="lineNum">    2132 </span>            :   (POINTER_TYPE_CHECK (NODE)-&gt;type_non_common.minval)
<span class="lineNum">    2133 </span>            : #define TYPE_NEXT_REF_TO(NODE)                          \
<span class="lineNum">    2134 </span>            :   (REFERENCE_TYPE_CHECK (NODE)-&gt;type_non_common.minval)
<span class="lineNum">    2135 </span>            : #define TYPE_VFIELD(NODE)                               \
<span class="lineNum">    2136 </span>            :   (RECORD_OR_UNION_CHECK (NODE)-&gt;type_non_common.minval)
<span class="lineNum">    2137 </span>            : #define TYPE_MIN_VALUE_RAW(NODE) (TYPE_CHECK (NODE)-&gt;type_non_common.minval)
<span class="lineNum">    2138 </span>            : 
<span class="lineNum">    2139 </span>            : #define TYPE_MAX_VALUE(NODE) \
<span class="lineNum">    2140 </span>            :   (NUMERICAL_TYPE_CHECK (NODE)-&gt;type_non_common.maxval)
<span class="lineNum">    2141 </span>            : #define TYPE_METHOD_BASETYPE(NODE)                      \
<span class="lineNum">    2142 </span>            :   (FUNC_OR_METHOD_CHECK (NODE)-&gt;type_non_common.maxval)
<span class="lineNum">    2143 </span>            : #define TYPE_OFFSET_BASETYPE(NODE)                      \
<span class="lineNum">    2144 </span>            :   (OFFSET_TYPE_CHECK (NODE)-&gt;type_non_common.maxval)
<span class="lineNum">    2145 </span>            : /* If non-NULL, this is an upper bound of the size (in bytes) of an
<span class="lineNum">    2146 </span>            :    object of the given ARRAY_TYPE_NON_COMMON.  This allows temporaries to be
<span class="lineNum">    2147 </span>            :    allocated.  */
<span class="lineNum">    2148 </span>            : #define TYPE_ARRAY_MAX_SIZE(ARRAY_TYPE) \
<span class="lineNum">    2149 </span>            :   (ARRAY_TYPE_CHECK (ARRAY_TYPE)-&gt;type_non_common.maxval)
<span class="lineNum">    2150 </span>            : #define TYPE_MAX_VALUE_RAW(NODE) (TYPE_CHECK (NODE)-&gt;type_non_common.maxval)
<span class="lineNum">    2151 </span>            : /* For record and union types, information about this type, as a base type
<span class="lineNum">    2152 </span>            :    for itself.  */
<span class="lineNum">    2153 </span>            : #define TYPE_BINFO(NODE) (RECORD_OR_UNION_CHECK (NODE)-&gt;type_non_common.maxval)
<span class="lineNum">    2154 </span>            : 
<span class="lineNum">    2155 </span>            : /* For types, used in a language-dependent way.  */
<span class="lineNum">    2156 </span>            : #define TYPE_LANG_SLOT_1(NODE) \
<span class="lineNum">    2157 </span>            :   (TYPE_CHECK (NODE)-&gt;type_non_common.lang_1)
<span class="lineNum">    2158 </span>            : 
<span class="lineNum">    2159 </span>            : /* Define accessor macros for information about type inheritance
<span class="lineNum">    2160 </span>            :    and basetypes.
<span class="lineNum">    2161 </span>            : 
<span class="lineNum">    2162 </span>            :    A &quot;basetype&quot; means a particular usage of a data type for inheritance
<span class="lineNum">    2163 </span>            :    in another type.  Each such basetype usage has its own &quot;binfo&quot;
<span class="lineNum">    2164 </span>            :    object to describe it.  The binfo object is a TREE_VEC node.
<span class="lineNum">    2165 </span>            : 
<span class="lineNum">    2166 </span>            :    Inheritance is represented by the binfo nodes allocated for a
<span class="lineNum">    2167 </span>            :    given type.  For example, given types C and D, such that D is
<span class="lineNum">    2168 </span>            :    inherited by C, 3 binfo nodes will be allocated: one for describing
<span class="lineNum">    2169 </span>            :    the binfo properties of C, similarly one for D, and one for
<span class="lineNum">    2170 </span>            :    describing the binfo properties of D as a base type for C.
<span class="lineNum">    2171 </span>            :    Thus, given a pointer to class C, one can get a pointer to the binfo
<span class="lineNum">    2172 </span>            :    of D acting as a basetype for C by looking at C's binfo's basetypes.  */
<span class="lineNum">    2173 </span>            : 
<span class="lineNum">    2174 </span>            : /* BINFO specific flags.  */
<span class="lineNum">    2175 </span>            : 
<span class="lineNum">    2176 </span>            : /* Nonzero means that the derivation chain is via a `virtual' declaration.  */
<span class="lineNum">    2177 </span>            : #define BINFO_VIRTUAL_P(NODE) (TREE_BINFO_CHECK (NODE)-&gt;base.static_flag)
<span class="lineNum">    2178 </span>            : 
<span class="lineNum">    2179 </span>            : /* Flags for language dependent use.  */
<span class="lineNum">    2180 </span>            : #define BINFO_FLAG_0(NODE) TREE_LANG_FLAG_0 (TREE_BINFO_CHECK (NODE))
<span class="lineNum">    2181 </span>            : #define BINFO_FLAG_1(NODE) TREE_LANG_FLAG_1 (TREE_BINFO_CHECK (NODE))
<span class="lineNum">    2182 </span>            : #define BINFO_FLAG_2(NODE) TREE_LANG_FLAG_2 (TREE_BINFO_CHECK (NODE))
<span class="lineNum">    2183 </span>            : #define BINFO_FLAG_3(NODE) TREE_LANG_FLAG_3 (TREE_BINFO_CHECK (NODE))
<span class="lineNum">    2184 </span>            : #define BINFO_FLAG_4(NODE) TREE_LANG_FLAG_4 (TREE_BINFO_CHECK (NODE))
<span class="lineNum">    2185 </span>            : #define BINFO_FLAG_5(NODE) TREE_LANG_FLAG_5 (TREE_BINFO_CHECK (NODE))
<span class="lineNum">    2186 </span>            : #define BINFO_FLAG_6(NODE) TREE_LANG_FLAG_6 (TREE_BINFO_CHECK (NODE))
<span class="lineNum">    2187 </span>            : 
<span class="lineNum">    2188 </span>            : /* The actual data type node being inherited in this basetype.  */
<span class="lineNum">    2189 </span>            : #define BINFO_TYPE(NODE) TREE_TYPE (TREE_BINFO_CHECK (NODE))
<span class="lineNum">    2190 </span>            : 
<span class="lineNum">    2191 </span>            : /* The offset where this basetype appears in its containing type.
<span class="lineNum">    2192 </span>            :    BINFO_OFFSET slot holds the offset (in bytes)
<span class="lineNum">    2193 </span>            :    from the base of the complete object to the base of the part of the
<span class="lineNum">    2194 </span>            :    object that is allocated on behalf of this `type'.
<span class="lineNum">    2195 </span>            :    This is always 0 except when there is multiple inheritance.  */
<span class="lineNum">    2196 </span>            : 
<span class="lineNum">    2197 </span>            : #define BINFO_OFFSET(NODE) (TREE_BINFO_CHECK (NODE)-&gt;binfo.offset)
<span class="lineNum">    2198 </span>            : #define BINFO_OFFSET_ZEROP(NODE) (integer_zerop (BINFO_OFFSET (NODE)))
<span class="lineNum">    2199 </span>            : 
<span class="lineNum">    2200 </span>            : /* The virtual function table belonging to this basetype.  Virtual
<span class="lineNum">    2201 </span>            :    function tables provide a mechanism for run-time method dispatching.
<span class="lineNum">    2202 </span>            :    The entries of a virtual function table are language-dependent.  */
<span class="lineNum">    2203 </span>            : 
<span class="lineNum">    2204 </span>            : #define BINFO_VTABLE(NODE) (TREE_BINFO_CHECK (NODE)-&gt;binfo.vtable)
<span class="lineNum">    2205 </span>            : 
<span class="lineNum">    2206 </span>            : /* The virtual functions in the virtual function table.  This is
<span class="lineNum">    2207 </span>            :    a TREE_LIST that is used as an initial approximation for building
<span class="lineNum">    2208 </span>            :    a virtual function table for this basetype.  */
<span class="lineNum">    2209 </span>            : #define BINFO_VIRTUALS(NODE) (TREE_BINFO_CHECK (NODE)-&gt;binfo.virtuals)
<span class="lineNum">    2210 </span>            : 
<span class="lineNum">    2211 </span>            : /* A vector of binfos for the direct basetypes inherited by this
<span class="lineNum">    2212 </span>            :    basetype.
<span class="lineNum">    2213 </span>            : 
<span class="lineNum">    2214 </span>            :    If this basetype describes type D as inherited in C, and if the
<span class="lineNum">    2215 </span>            :    basetypes of D are E and F, then this vector contains binfos for
<span class="lineNum">    2216 </span>            :    inheritance of E and F by C.  */
<span class="lineNum">    2217 </span>            : #define BINFO_BASE_BINFOS(NODE) (&amp;TREE_BINFO_CHECK (NODE)-&gt;binfo.base_binfos)
<span class="lineNum">    2218 </span>            : 
<span class="lineNum">    2219 </span>            : /* The number of basetypes for NODE.  */
<span class="lineNum">    2220 </span>            : #define BINFO_N_BASE_BINFOS(NODE) (BINFO_BASE_BINFOS (NODE)-&gt;length ())
<span class="lineNum">    2221 </span>            : 
<span class="lineNum">    2222 </span>            : /* Accessor macro to get to the Nth base binfo of this binfo.  */
<span class="lineNum">    2223 </span>            : #define BINFO_BASE_BINFO(NODE,N) \
<span class="lineNum">    2224 </span>            :  ((*BINFO_BASE_BINFOS (NODE))[(N)])
<span class="lineNum">    2225 </span>            : #define BINFO_BASE_ITERATE(NODE,N,B) \
<span class="lineNum">    2226 </span>            :  (BINFO_BASE_BINFOS (NODE)-&gt;iterate ((N), &amp;(B)))
<span class="lineNum">    2227 </span>            : #define BINFO_BASE_APPEND(NODE,T) \
<span class="lineNum">    2228 </span>            :  (BINFO_BASE_BINFOS (NODE)-&gt;quick_push ((T)))
<span class="lineNum">    2229 </span>            : 
<span class="lineNum">    2230 </span>            : /* For a BINFO record describing a virtual base class, i.e., one where
<span class="lineNum">    2231 </span>            :    TREE_VIA_VIRTUAL is set, this field assists in locating the virtual
<span class="lineNum">    2232 </span>            :    base.  The actual contents are language-dependent.  In the C++
<span class="lineNum">    2233 </span>            :    front-end this field is an INTEGER_CST giving an offset into the
<span class="lineNum">    2234 </span>            :    vtable where the offset to the virtual base can be found.  */
<span class="lineNum">    2235 </span>            : #define BINFO_VPTR_FIELD(NODE) (TREE_BINFO_CHECK (NODE)-&gt;binfo.vptr_field)
<span class="lineNum">    2236 </span>            : 
<span class="lineNum">    2237 </span>            : /* Indicates the accesses this binfo has to its bases. The values are
<span class="lineNum">    2238 </span>            :    access_public_node, access_protected_node or access_private_node.
<span class="lineNum">    2239 </span>            :    If this array is not present, public access is implied.  */
<span class="lineNum">    2240 </span>            : #define BINFO_BASE_ACCESSES(NODE) \
<span class="lineNum">    2241 </span>            :   (TREE_BINFO_CHECK (NODE)-&gt;binfo.base_accesses)
<span class="lineNum">    2242 </span>            : 
<span class="lineNum">    2243 </span>            : #define BINFO_BASE_ACCESS(NODE,N) \
<span class="lineNum">    2244 </span>            :   (*BINFO_BASE_ACCESSES (NODE))[(N)]
<span class="lineNum">    2245 </span>            : #define BINFO_BASE_ACCESS_APPEND(NODE,T) \
<span class="lineNum">    2246 </span>            :   BINFO_BASE_ACCESSES (NODE)-&gt;quick_push ((T))
<span class="lineNum">    2247 </span>            : 
<span class="lineNum">    2248 </span>            : /* The index in the VTT where this subobject's sub-VTT can be found.
<span class="lineNum">    2249 </span>            :    NULL_TREE if there is no sub-VTT.  */
<span class="lineNum">    2250 </span>            : #define BINFO_SUBVTT_INDEX(NODE) (TREE_BINFO_CHECK (NODE)-&gt;binfo.vtt_subvtt)
<span class="lineNum">    2251 </span>            : 
<span class="lineNum">    2252 </span>            : /* The index in the VTT where the vptr for this subobject can be
<span class="lineNum">    2253 </span>            :    found.  NULL_TREE if there is no secondary vptr in the VTT.  */
<span class="lineNum">    2254 </span>            : #define BINFO_VPTR_INDEX(NODE) (TREE_BINFO_CHECK (NODE)-&gt;binfo.vtt_vptr)
<span class="lineNum">    2255 </span>            : 
<span class="lineNum">    2256 </span>            : /* The BINFO_INHERITANCE_CHAIN points at the binfo for the base
<span class="lineNum">    2257 </span>            :    inheriting this base for non-virtual bases. For virtual bases it
<span class="lineNum">    2258 </span>            :    points either to the binfo for which this is a primary binfo, or to
<span class="lineNum">    2259 </span>            :    the binfo of the most derived type.  */
<span class="lineNum">    2260 </span>            : #define BINFO_INHERITANCE_CHAIN(NODE) \
<span class="lineNum">    2261 </span>            :         (TREE_BINFO_CHECK (NODE)-&gt;binfo.inheritance)
<span class="lineNum">    2262 </span>            : 
<span class="lineNum">    2263 </span>            : 
<span class="lineNum">    2264 </span>            : /* Define fields and accessors for nodes representing declared names.  */
<span class="lineNum">    2265 </span>            : 
<span class="lineNum">    2266 </span>            : /* Nonzero if DECL represents an SSA name or a variable that can possibly
<span class="lineNum">    2267 </span>            :    have an associated SSA name.  */
<span class="lineNum">    2268 </span>            : #define SSA_VAR_P(DECL)                                                 \
<span class="lineNum">    2269 </span>            :         (TREE_CODE (DECL) == VAR_DECL                                   \
<span class="lineNum">    2270 </span>            :          || TREE_CODE (DECL) == PARM_DECL                               \
<span class="lineNum">    2271 </span>            :          || TREE_CODE (DECL) == RESULT_DECL                             \
<span class="lineNum">    2272 </span>            :          || TREE_CODE (DECL) == SSA_NAME)
<span class="lineNum">    2273 </span>            : 
<span class="lineNum">    2274 </span>            : 
<span class="lineNum">    2275 </span>            : #define DECL_CHAIN(NODE) (TREE_CHAIN (DECL_MINIMAL_CHECK (NODE)))
<span class="lineNum">    2276 </span>            : 
<span class="lineNum">    2277 </span>            : /* This is the name of the object as written by the user.
<span class="lineNum">    2278 </span>            :    It is an IDENTIFIER_NODE.  */
<span class="lineNum">    2279 </span>            : #define DECL_NAME(NODE) (DECL_MINIMAL_CHECK (NODE)-&gt;decl_minimal.name)
<span class="lineNum">    2280 </span>            : 
<span class="lineNum">    2281 </span>            : /* The IDENTIFIER_NODE associated with the TYPE_NAME field.  */
<span class="lineNum">    2282 </span>            : #define TYPE_IDENTIFIER(NODE) \
<span class="lineNum">    2283 </span>            :   (TYPE_NAME (NODE) &amp;&amp; DECL_P (TYPE_NAME (NODE)) \
<span class="lineNum">    2284 </span>            :    ? DECL_NAME (TYPE_NAME (NODE)) : TYPE_NAME (NODE))
<span class="lineNum">    2285 </span>            : 
<span class="lineNum">    2286 </span>            : /* Every ..._DECL node gets a unique number.  */
<span class="lineNum">    2287 </span>            : #define DECL_UID(NODE) (DECL_MINIMAL_CHECK (NODE)-&gt;decl_minimal.uid)
<span class="lineNum">    2288 </span>            : 
<span class="lineNum">    2289 </span>            : /* DEBUG_EXPR_DECLs get negative UID numbers, to catch erroneous
<span class="lineNum">    2290 </span>            :    uses.  */
<span class="lineNum">    2291 </span>            : #define DEBUG_TEMP_UID(NODE) (-DECL_UID (TREE_CHECK ((NODE), DEBUG_EXPR_DECL)))
<span class="lineNum">    2292 </span>            : 
<span class="lineNum">    2293 </span>            : /* Every ..._DECL node gets a unique number that stays the same even
<span class="lineNum">    2294 </span>            :    when the decl is copied by the inliner once it is set.  */
<span class="lineNum">    2295 </span>            : #define DECL_PT_UID(NODE) \
<span class="lineNum">    2296 </span>            :   (DECL_COMMON_CHECK (NODE)-&gt;decl_common.pt_uid == -1u \
<span class="lineNum">    2297 </span>            :    ? (NODE)-&gt;decl_minimal.uid : (NODE)-&gt;decl_common.pt_uid)
<span class="lineNum">    2298 </span>            : /* Initialize the ..._DECL node pt-uid to the decls uid.  */
<span class="lineNum">    2299 </span>            : #define SET_DECL_PT_UID(NODE, UID) \
<span class="lineNum">    2300 </span>            :   (DECL_COMMON_CHECK (NODE)-&gt;decl_common.pt_uid = (UID))
<span class="lineNum">    2301 </span>            : /* Whether the ..._DECL node pt-uid has been initialized and thus needs to
<span class="lineNum">    2302 </span>            :    be preserved when copyin the decl.  */
<span class="lineNum">    2303 </span>            : #define DECL_PT_UID_SET_P(NODE) \
<span class="lineNum">    2304 </span>            :   (DECL_COMMON_CHECK (NODE)-&gt;decl_common.pt_uid != -1u)
<span class="lineNum">    2305 </span>            : 
<span class="lineNum">    2306 </span>            : /* These two fields describe where in the source code the declaration
<span class="lineNum">    2307 </span>            :    was.  If the declaration appears in several places (as for a C
<span class="lineNum">    2308 </span>            :    function that is declared first and then defined later), this
<span class="lineNum">    2309 </span>            :    information should refer to the definition.  */
<span class="lineNum">    2310 </span>            : #define DECL_SOURCE_LOCATION(NODE) \
<span class="lineNum">    2311 </span>            :   (DECL_MINIMAL_CHECK (NODE)-&gt;decl_minimal.locus)
<span class="lineNum">    2312 </span>            : #define DECL_SOURCE_FILE(NODE) LOCATION_FILE (DECL_SOURCE_LOCATION (NODE))
<span class="lineNum">    2313 </span>            : #define DECL_SOURCE_LINE(NODE) LOCATION_LINE (DECL_SOURCE_LOCATION (NODE))
<span class="lineNum">    2314 </span>            : #define DECL_SOURCE_COLUMN(NODE) LOCATION_COLUMN (DECL_SOURCE_LOCATION (NODE))
<span class="lineNum">    2315 </span>            : /* This accessor returns TRUE if the decl it operates on was created
<span class="lineNum">    2316 </span>            :    by a front-end or back-end rather than by user code.  In this case
<span class="lineNum">    2317 </span>            :    builtin-ness is indicated by source location.  */
<span class="lineNum">    2318 </span>            : #define DECL_IS_BUILTIN(DECL) \
<span class="lineNum">    2319 </span>            :   (LOCATION_LOCUS (DECL_SOURCE_LOCATION (DECL)) &lt;= BUILTINS_LOCATION)
<span class="lineNum">    2320 </span>            : 
<span class="lineNum">    2321 </span>            : /*  For FIELD_DECLs, this is the RECORD_TYPE, UNION_TYPE, or
<span class="lineNum">    2322 </span>            :     QUAL_UNION_TYPE node that the field is a member of.  For VAR_DECL,
<span class="lineNum">    2323 </span>            :     PARM_DECL, FUNCTION_DECL, LABEL_DECL, RESULT_DECL, and CONST_DECL
<span class="lineNum">    2324 </span>            :     nodes, this points to either the FUNCTION_DECL for the containing
<span class="lineNum">    2325 </span>            :     function, the RECORD_TYPE or UNION_TYPE for the containing type, or
<span class="lineNum">    2326 </span>            :     NULL_TREE or a TRANSLATION_UNIT_DECL if the given decl has &quot;file
<span class="lineNum">    2327 </span>            :     scope&quot;.  In particular, for VAR_DECLs which are virtual table pointers
<span class="lineNum">    2328 </span>            :     (they have DECL_VIRTUAL set), we use DECL_CONTEXT to determine the type
<span class="lineNum">    2329 </span>            :     they belong to.  */
<span class="lineNum">    2330 </span>            : #define DECL_CONTEXT(NODE) (DECL_MINIMAL_CHECK (NODE)-&gt;decl_minimal.context)
<span class="lineNum">    2331 </span>            : #define DECL_FIELD_CONTEXT(NODE) \
<span class="lineNum">    2332 </span>            :   (FIELD_DECL_CHECK (NODE)-&gt;decl_minimal.context)
<span class="lineNum">    2333 </span>            : 
<span class="lineNum">    2334 </span>            : /* If nonzero, decl's name shouldn't be emitted into debug info.  */
<span class="lineNum">    2335 </span>            : #define DECL_NAMELESS(NODE) (DECL_MINIMAL_CHECK (NODE)-&gt;base.u.bits.nameless_flag)
<span class="lineNum">    2336 </span>            : 
<span class="lineNum">    2337 </span>            : /* For any sort of a ..._DECL node, this points to the original (abstract)
<span class="lineNum">    2338 </span>            :    decl node which this decl is an inlined/cloned instance of, or else it
<span class="lineNum">    2339 </span>            :    is NULL indicating that this decl is not an instance of some other decl.
<span class="lineNum">    2340 </span>            : 
<span class="lineNum">    2341 </span>            :    The C front-end also uses this in a nested declaration of an inline
<span class="lineNum">    2342 </span>            :    function, to point back to the definition.  */
<span class="lineNum">    2343 </span>            : #define DECL_ABSTRACT_ORIGIN(NODE) \
<span class="lineNum">    2344 </span>            :   (DECL_COMMON_CHECK (NODE)-&gt;decl_common.abstract_origin)
<span class="lineNum">    2345 </span>            : 
<span class="lineNum">    2346 </span>            : /* Like DECL_ABSTRACT_ORIGIN, but returns NODE if there's no abstract
<span class="lineNum">    2347 </span>            :    origin.  This is useful when setting the DECL_ABSTRACT_ORIGIN.  */
<span class="lineNum">    2348 </span>            : #define DECL_ORIGIN(NODE) \
<span class="lineNum">    2349 </span>            :   (DECL_ABSTRACT_ORIGIN (NODE) ? DECL_ABSTRACT_ORIGIN (NODE) : (NODE))
<span class="lineNum">    2350 </span>            : 
<span class="lineNum">    2351 </span>            : /* Nonzero for any sort of ..._DECL node means this decl node represents an
<span class="lineNum">    2352 </span>            :    inline instance of some original (abstract) decl from an inline function;
<span class="lineNum">    2353 </span>            :    suppress any warnings about shadowing some other variable.  FUNCTION_DECL
<span class="lineNum">    2354 </span>            :    nodes can also have their abstract origin set to themselves.  */
<span class="lineNum">    2355 </span>            : #define DECL_FROM_INLINE(NODE) \
<span class="lineNum">    2356 </span>            :   (DECL_ABSTRACT_ORIGIN (NODE) != NULL_TREE \
<span class="lineNum">    2357 </span>            :    &amp;&amp; DECL_ABSTRACT_ORIGIN (NODE) != (NODE))
<span class="lineNum">    2358 </span>            : 
<span class="lineNum">    2359 </span>            : /* In a DECL this is the field where attributes are stored.  */
<span class="lineNum">    2360 </span>            : #define DECL_ATTRIBUTES(NODE) \
<span class="lineNum">    2361 </span>            :   (DECL_COMMON_CHECK (NODE)-&gt;decl_common.attributes)
<span class="lineNum">    2362 </span>            : 
<span class="lineNum">    2363 </span>            : /* For a FUNCTION_DECL, holds the tree of BINDINGs.
<span class="lineNum">    2364 </span>            :    For a TRANSLATION_UNIT_DECL, holds the namespace's BLOCK.
<span class="lineNum">    2365 </span>            :    For a VAR_DECL, holds the initial value.
<span class="lineNum">    2366 </span>            :    For a PARM_DECL, used for DECL_ARG_TYPE--default
<span class="lineNum">    2367 </span>            :    values for parameters are encoded in the type of the function,
<span class="lineNum">    2368 </span>            :    not in the PARM_DECL slot.
<span class="lineNum">    2369 </span>            :    For a FIELD_DECL, this is used for enumeration values and the C
<span class="lineNum">    2370 </span>            :    frontend uses it for temporarily storing bitwidth of bitfields.
<span class="lineNum">    2371 </span>            : 
<span class="lineNum">    2372 </span>            :    ??? Need to figure out some way to check this isn't a PARM_DECL.  */
<span class="lineNum">    2373 </span>            : #define DECL_INITIAL(NODE) (DECL_COMMON_CHECK (NODE)-&gt;decl_common.initial)
<span class="lineNum">    2374 </span>            : 
<span class="lineNum">    2375 </span>            : /* Holds the size of the datum, in bits, as a tree expression.
<span class="lineNum">    2376 </span>            :    Need not be constant.  */
<span class="lineNum">    2377 </span>            : #define DECL_SIZE(NODE) (DECL_COMMON_CHECK (NODE)-&gt;decl_common.size)
<span class="lineNum">    2378 </span>            : /* Likewise for the size in bytes.  */
<span class="lineNum">    2379 </span>            : #define DECL_SIZE_UNIT(NODE) (DECL_COMMON_CHECK (NODE)-&gt;decl_common.size_unit)
<span class="lineNum">    2380 </span>            : /* Returns the alignment required for the datum, in bits.  It must
<span class="lineNum">    2381 </span>            :    be a power of two, but an &quot;alignment&quot; of zero is supported
<span class="lineNum">    2382 </span>            :    (e.g. as &quot;uninitialized&quot; sentinel).  */
<span class="lineNum">    2383 </span>            : #define DECL_ALIGN(NODE) \
<span class="lineNum">    2384 </span>            :     (DECL_COMMON_CHECK (NODE)-&gt;decl_common.align \
<span class="lineNum">    2385 </span>            :      ? ((unsigned)1) &lt;&lt; ((NODE)-&gt;decl_common.align - 1) : 0)
<span class="lineNum">    2386 </span>            : /* Specify that DECL_ALIGN(NODE) is X.  */
<span class="lineNum">    2387 </span>            : #define SET_DECL_ALIGN(NODE, X) \
<span class="lineNum">    2388 </span>            :     (DECL_COMMON_CHECK (NODE)-&gt;decl_common.align = ffs_hwi (X))
<span class="lineNum">    2389 </span>            : 
<span class="lineNum">    2390 </span>            : /* The minimum alignment necessary for the datum, in bits, without
<span class="lineNum">    2391 </span>            :    warning.  */
<span class="lineNum">    2392 </span>            : #define DECL_WARN_IF_NOT_ALIGN(NODE) \
<span class="lineNum">    2393 </span>            :     (DECL_COMMON_CHECK (NODE)-&gt;decl_common.warn_if_not_align \
<span class="lineNum">    2394 </span>            :      ? ((unsigned)1) &lt;&lt; ((NODE)-&gt;decl_common.warn_if_not_align - 1) : 0)
<span class="lineNum">    2395 </span>            : 
<span class="lineNum">    2396 </span>            : /* Specify that DECL_WARN_IF_NOT_ALIGN(NODE) is X.  */
<span class="lineNum">    2397 </span>            : #define SET_DECL_WARN_IF_NOT_ALIGN(NODE, X) \
<span class="lineNum">    2398 </span>            :     (DECL_COMMON_CHECK (NODE)-&gt;decl_common.warn_if_not_align = ffs_hwi (X))
<span class="lineNum">    2399 </span>            : 
<span class="lineNum">    2400 </span>            : /* The alignment of NODE, in bytes.  */
<span class="lineNum">    2401 </span>            : #define DECL_ALIGN_UNIT(NODE) (DECL_ALIGN (NODE) / BITS_PER_UNIT)
<span class="lineNum">    2402 </span>            : /* Set if the alignment of this DECL has been set by the user, for
<span class="lineNum">    2403 </span>            :    example with an 'aligned' attribute.  */
<span class="lineNum">    2404 </span>            : #define DECL_USER_ALIGN(NODE) \
<span class="lineNum">    2405 </span>            :   (DECL_COMMON_CHECK (NODE)-&gt;base.u.bits.user_align)
<span class="lineNum">    2406 </span>            : /* Holds the machine mode corresponding to the declaration of a variable or
<span class="lineNum">    2407 </span>            :    field.  Always equal to TYPE_MODE (TREE_TYPE (decl)) except for a
<span class="lineNum">    2408 </span>            :    FIELD_DECL.  */
<span class="lineNum">    2409 </span>            : #define DECL_MODE(NODE) (DECL_COMMON_CHECK (NODE)-&gt;decl_common.mode)
<span class="lineNum">    2410 </span>            : #define SET_DECL_MODE(NODE, MODE) \
<span class="lineNum">    2411 </span>            :   (DECL_COMMON_CHECK (NODE)-&gt;decl_common.mode = (MODE))
<span class="lineNum">    2412 </span>            : 
<span class="lineNum">    2413 </span>            : /* For FUNCTION_DECL, if it is built-in, this identifies which built-in
<span class="lineNum">    2414 </span>            :    operation it is.  Note, however, that this field is overloaded, with
<span class="lineNum">    2415 </span>            :    DECL_BUILT_IN_CLASS as the discriminant, so the latter must always be
<span class="lineNum">    2416 </span>            :    checked before any access to the former.  */
<span class="lineNum">    2417 </span>            : #define DECL_FUNCTION_CODE(NODE) \
<span class="lineNum">    2418 </span>            :   (FUNCTION_DECL_CHECK (NODE)-&gt;function_decl.function_code)
<span class="lineNum">    2419 </span>            : 
<span class="lineNum">    2420 </span>            : /* Test if FCODE is a function code for an alloca operation.  */
<span class="lineNum">    2421 </span>            : #define ALLOCA_FUNCTION_CODE_P(FCODE)                           \
<span class="lineNum">    2422 </span>            :   ((FCODE) == BUILT_IN_ALLOCA                                   \
<span class="lineNum">    2423 </span>            :    || (FCODE) == BUILT_IN_ALLOCA_WITH_ALIGN                     \
<span class="lineNum">    2424 </span>            :    || (FCODE) == BUILT_IN_ALLOCA_WITH_ALIGN_AND_MAX)
<span class="lineNum">    2425 </span>            : 
<span class="lineNum">    2426 </span>            : /* Generate case for an alloca operation.  */
<span class="lineNum">    2427 </span>            : #define CASE_BUILT_IN_ALLOCA                    \
<span class="lineNum">    2428 </span>            :   case BUILT_IN_ALLOCA:                         \
<span class="lineNum">    2429 </span>            :   case BUILT_IN_ALLOCA_WITH_ALIGN:              \
<span class="lineNum">    2430 </span>            :   case BUILT_IN_ALLOCA_WITH_ALIGN_AND_MAX
<span class="lineNum">    2431 </span>            : 
<span class="lineNum">    2432 </span>            : #define DECL_FUNCTION_PERSONALITY(NODE) \
<span class="lineNum">    2433 </span>            :   (FUNCTION_DECL_CHECK (NODE)-&gt;function_decl.personality)
<span class="lineNum">    2434 </span>            : 
<span class="lineNum">    2435 </span>            : /* Nonzero for a given ..._DECL node means that the name of this node should
<span class="lineNum">    2436 </span>            :    be ignored for symbolic debug purposes.  For a TYPE_DECL, this means that
<span class="lineNum">    2437 </span>            :    the associated type should be ignored.  For a FUNCTION_DECL, the body of
<span class="lineNum">    2438 </span>            :    the function should also be ignored.  */
<span class="lineNum">    2439 </span>            : #define DECL_IGNORED_P(NODE) \
<span class="lineNum">    2440 </span>            :   (DECL_COMMON_CHECK (NODE)-&gt;decl_common.ignored_flag)
<span class="lineNum">    2441 </span>            : 
<span class="lineNum">    2442 </span>            : /* Nonzero for a given ..._DECL node means that this node represents an
<span class="lineNum">    2443 </span>            :    &quot;abstract instance&quot; of the given declaration (e.g. in the original
<span class="lineNum">    2444 </span>            :    declaration of an inline function).  When generating symbolic debugging
<span class="lineNum">    2445 </span>            :    information, we mustn't try to generate any address information for nodes
<span class="lineNum">    2446 </span>            :    marked as &quot;abstract instances&quot; because we don't actually generate
<span class="lineNum">    2447 </span>            :    any code or allocate any data space for such instances.  */
<span class="lineNum">    2448 </span>            : #define DECL_ABSTRACT_P(NODE) \
<span class="lineNum">    2449 </span>            :   (DECL_COMMON_CHECK (NODE)-&gt;decl_common.abstract_flag)
<span class="lineNum">    2450 </span>            : 
<span class="lineNum">    2451 </span>            : /* Language-specific decl information.  */
<span class="lineNum">    2452 </span>            : #define DECL_LANG_SPECIFIC(NODE) \
<span class="lineNum">    2453 </span>            :   (DECL_COMMON_CHECK (NODE)-&gt;decl_common.lang_specific)
<span class="lineNum">    2454 </span>            : 
<span class="lineNum">    2455 </span>            : /* In a VAR_DECL or FUNCTION_DECL, nonzero means external reference:
<span class="lineNum">    2456 </span>            :    do not allocate storage, and refer to a definition elsewhere.  Note that
<span class="lineNum">    2457 </span>            :    this does not necessarily imply the entity represented by NODE
<span class="lineNum">    2458 </span>            :    has no program source-level definition in this translation unit.  For
<span class="lineNum">    2459 </span>            :    example, for a FUNCTION_DECL, DECL_SAVED_TREE may be non-NULL and
<span class="lineNum">    2460 </span>            :    DECL_EXTERNAL may be true simultaneously; that can be the case for
<span class="lineNum">    2461 </span>            :    a C99 &quot;extern inline&quot; function.  */
<span class="lineNum">    2462 </span>            : #define DECL_EXTERNAL(NODE) (DECL_COMMON_CHECK (NODE)-&gt;decl_common.decl_flag_1)
<span class="lineNum">    2463 </span>            : 
<span class="lineNum">    2464 </span>            : /* Nonzero in a ..._DECL means this variable is ref'd from a nested function.
<span class="lineNum">    2465 </span>            :    For VAR_DECL nodes, PARM_DECL nodes, and FUNCTION_DECL nodes.
<span class="lineNum">    2466 </span>            : 
<span class="lineNum">    2467 </span>            :    For LABEL_DECL nodes, nonzero if nonlocal gotos to the label are permitted.
<span class="lineNum">    2468 </span>            : 
<span class="lineNum">    2469 </span>            :    Also set in some languages for variables, etc., outside the normal
<span class="lineNum">    2470 </span>            :    lexical scope, such as class instance variables.  */
<span class="lineNum">    2471 </span>            : #define DECL_NONLOCAL(NODE) \
<span class="lineNum">    2472 </span>            :   (DECL_COMMON_CHECK (NODE)-&gt;decl_common.nonlocal_flag)
<span class="lineNum">    2473 </span>            : 
<span class="lineNum">    2474 </span>            : /* Used in VAR_DECLs to indicate that the variable is a vtable.
<span class="lineNum">    2475 </span>            :    Used in FIELD_DECLs for vtable pointers.
<span class="lineNum">    2476 </span>            :    Used in FUNCTION_DECLs to indicate that the function is virtual.  */
<span class="lineNum">    2477 </span>            : #define DECL_VIRTUAL_P(NODE) \
<span class="lineNum">    2478 </span>            :   (DECL_COMMON_CHECK (NODE)-&gt;decl_common.virtual_flag)
<span class="lineNum">    2479 </span>            : 
<span class="lineNum">    2480 </span>            : /* Used to indicate that this DECL represents a compiler-generated entity.  */
<span class="lineNum">    2481 </span>            : #define DECL_ARTIFICIAL(NODE) \
<span class="lineNum">    2482 </span>            :   (DECL_COMMON_CHECK (NODE)-&gt;decl_common.artificial_flag)
<span class="lineNum">    2483 </span>            : 
<span class="lineNum">    2484 </span>            : /* Additional flags for language-specific uses.  */
<span class="lineNum">    2485 </span>            : #define DECL_LANG_FLAG_0(NODE) \
<span class="lineNum">    2486 </span>            :   (DECL_COMMON_CHECK (NODE)-&gt;decl_common.lang_flag_0)
<span class="lineNum">    2487 </span>            : #define DECL_LANG_FLAG_1(NODE) \
<span class="lineNum">    2488 </span>            :   (DECL_COMMON_CHECK (NODE)-&gt;decl_common.lang_flag_1)
<span class="lineNum">    2489 </span>            : #define DECL_LANG_FLAG_2(NODE) \
<span class="lineNum">    2490 </span>            :   (DECL_COMMON_CHECK (NODE)-&gt;decl_common.lang_flag_2)
<span class="lineNum">    2491 </span>            : #define DECL_LANG_FLAG_3(NODE) \
<span class="lineNum">    2492 </span>            :   (DECL_COMMON_CHECK (NODE)-&gt;decl_common.lang_flag_3)
<span class="lineNum">    2493 </span>            : #define DECL_LANG_FLAG_4(NODE) \
<span class="lineNum">    2494 </span>            :   (DECL_COMMON_CHECK (NODE)-&gt;decl_common.lang_flag_4)
<span class="lineNum">    2495 </span>            : #define DECL_LANG_FLAG_5(NODE) \
<span class="lineNum">    2496 </span>            :   (DECL_COMMON_CHECK (NODE)-&gt;decl_common.lang_flag_5)
<span class="lineNum">    2497 </span>            : #define DECL_LANG_FLAG_6(NODE) \
<span class="lineNum">    2498 </span>            :   (DECL_COMMON_CHECK (NODE)-&gt;decl_common.lang_flag_6)
<span class="lineNum">    2499 </span>            : #define DECL_LANG_FLAG_7(NODE) \
<span class="lineNum">    2500 </span>            :   (DECL_COMMON_CHECK (NODE)-&gt;decl_common.lang_flag_7)
<span class="lineNum">    2501 </span>            : #define DECL_LANG_FLAG_8(NODE) \
<span class="lineNum">    2502 </span>            :   (DECL_COMMON_CHECK (NODE)-&gt;decl_common.lang_flag_8)
<span class="lineNum">    2503 </span>            : 
<span class="lineNum">    2504 </span>            : /* Nonzero for a scope which is equal to file scope.  */
<span class="lineNum">    2505 </span>            : #define SCOPE_FILE_SCOPE_P(EXP) \
<span class="lineNum">    2506 </span>            :   (! (EXP) || TREE_CODE (EXP) == TRANSLATION_UNIT_DECL)
<span class="lineNum">    2507 </span>            : /* Nonzero for a decl which is at file scope.  */
<span class="lineNum">    2508 </span>            : #define DECL_FILE_SCOPE_P(EXP) SCOPE_FILE_SCOPE_P (DECL_CONTEXT (EXP))
<span class="lineNum">    2509 </span>            : /* Nonzero for a type which is at file scope.  */
<span class="lineNum">    2510 </span>            : #define TYPE_FILE_SCOPE_P(EXP) SCOPE_FILE_SCOPE_P (TYPE_CONTEXT (EXP))
<span class="lineNum">    2511 </span>            : 
<span class="lineNum">    2512 </span>            : /* Nonzero for a decl that is decorated using attribute used.
<span class="lineNum">    2513 </span>            :    This indicates to compiler tools that this decl needs to be preserved.  */
<span class="lineNum">    2514 </span>            : #define DECL_PRESERVE_P(DECL) \
<span class="lineNum">    2515 </span>            :   DECL_COMMON_CHECK (DECL)-&gt;decl_common.preserve_flag
<span class="lineNum">    2516 </span>            : 
<span class="lineNum">    2517 </span>            : /* For function local variables of COMPLEX and VECTOR types,
<span class="lineNum">    2518 </span>            :    indicates that the variable is not aliased, and that all
<span class="lineNum">    2519 </span>            :    modifications to the variable have been adjusted so that
<span class="lineNum">    2520 </span>            :    they are killing assignments.  Thus the variable may now
<span class="lineNum">    2521 </span>            :    be treated as a GIMPLE register, and use real instead of
<span class="lineNum">    2522 </span>            :    virtual ops in SSA form.  */
<span class="lineNum">    2523 </span>            : #define DECL_GIMPLE_REG_P(DECL) \
<span class="lineNum">    2524 </span>            :   DECL_COMMON_CHECK (DECL)-&gt;decl_common.gimple_reg_flag
<span class="lineNum">    2525 </span>            : 
<span class="lineNum">    2526 </span>            : extern tree decl_value_expr_lookup (tree);
<span class="lineNum">    2527 </span>            : extern void decl_value_expr_insert (tree, tree);
<span class="lineNum">    2528 </span>            : 
<span class="lineNum">    2529 </span>            : /* In a VAR_DECL or PARM_DECL, the location at which the value may be found,
<span class="lineNum">    2530 </span>            :    if transformations have made this more complicated than evaluating the
<span class="lineNum">    2531 </span>            :    decl itself.  */
<span class="lineNum">    2532 </span>            : #define DECL_HAS_VALUE_EXPR_P(NODE) \
<span class="lineNum">    2533 </span>            :   (TREE_CHECK3 (NODE, VAR_DECL, PARM_DECL, RESULT_DECL) \
<span class="lineNum">    2534 </span>            :    -&gt;decl_common.decl_flag_2)
<span class="lineNum">    2535 </span>            : #define DECL_VALUE_EXPR(NODE) \
<span class="lineNum">    2536 </span>            :   (decl_value_expr_lookup (DECL_WRTL_CHECK (NODE)))
<span class="lineNum">    2537 </span>            : #define SET_DECL_VALUE_EXPR(NODE, VAL) \
<span class="lineNum">    2538 </span>            :   (decl_value_expr_insert (DECL_WRTL_CHECK (NODE), VAL))
<span class="lineNum">    2539 </span>            : 
<span class="lineNum">    2540 </span>            : /* Holds the RTL expression for the value of a variable or function.
<span class="lineNum">    2541 </span>            :    This value can be evaluated lazily for functions, variables with
<span class="lineNum">    2542 </span>            :    static storage duration, and labels.  */
<span class="lineNum">    2543 </span>            : #define DECL_RTL(NODE)                                  \
<span class="lineNum">    2544 </span>            :   (DECL_WRTL_CHECK (NODE)-&gt;decl_with_rtl.rtl         \
<span class="lineNum">    2545 </span>            :    ? (NODE)-&gt;decl_with_rtl.rtl                                       \
<span class="lineNum">    2546 </span>            :    : (make_decl_rtl (NODE), (NODE)-&gt;decl_with_rtl.rtl))
<span class="lineNum">    2547 </span>            : 
<span class="lineNum">    2548 </span>            : /* Set the DECL_RTL for NODE to RTL.  */
<span class="lineNum">    2549 </span>            : #define SET_DECL_RTL(NODE, RTL) set_decl_rtl (NODE, RTL)
<span class="lineNum">    2550 </span>            : 
<span class="lineNum">    2551 </span>            : /* Returns nonzero if NODE is a tree node that can contain RTL.  */
<span class="lineNum">    2552 </span>            : #define HAS_RTL_P(NODE) (CODE_CONTAINS_STRUCT (TREE_CODE (NODE), TS_DECL_WRTL))
<span class="lineNum">    2553 </span>            : 
<span class="lineNum">    2554 </span>            : /* Returns nonzero if the DECL_RTL for NODE has already been set.  */
<span class="lineNum">    2555 </span>            : #define DECL_RTL_SET_P(NODE) \
<span class="lineNum">    2556 </span>            :   (HAS_RTL_P (NODE) &amp;&amp; DECL_WRTL_CHECK (NODE)-&gt;decl_with_rtl.rtl != NULL)
<span class="lineNum">    2557 </span>            : 
<span class="lineNum">    2558 </span>            : /* Copy the RTL from SRC_DECL to DST_DECL.  If the RTL was not set for
<span class="lineNum">    2559 </span>            :    SRC_DECL, it will not be set for DST_DECL; this is a lazy copy.  */
<span class="lineNum">    2560 </span>            : #define COPY_DECL_RTL(SRC_DECL, DST_DECL) \
<span class="lineNum">    2561 </span>            :   (DECL_WRTL_CHECK (DST_DECL)-&gt;decl_with_rtl.rtl \
<span class="lineNum">    2562 </span>            :    = DECL_WRTL_CHECK (SRC_DECL)-&gt;decl_with_rtl.rtl)
<span class="lineNum">    2563 </span>            : 
<span class="lineNum">    2564 </span>            : /* The DECL_RTL for NODE, if it is set, or NULL, if it is not set.  */
<span class="lineNum">    2565 </span>            : #define DECL_RTL_IF_SET(NODE) (DECL_RTL_SET_P (NODE) ? DECL_RTL (NODE) : NULL)
<span class="lineNum">    2566 </span>            : 
<span class="lineNum">    2567 </span>            : #if (GCC_VERSION &gt;= 2007)
<span class="lineNum">    2568 </span>            : #define DECL_RTL_KNOWN_SET(decl) __extension__                          \
<span class="lineNum">    2569 </span>            : ({  tree const __d = (decl);                                            \
<span class="lineNum">    2570 </span>            :     gcc_checking_assert (DECL_RTL_SET_P (__d));                         \
<span class="lineNum">    2571 </span>            :     /* Dereference it so the compiler knows it can't be NULL even       \
<span class="lineNum">    2572 </span>            :        without assertion checking.  */                                  \
<span class="lineNum">    2573 </span>            :     &amp;*DECL_RTL_IF_SET (__d); })
<span class="lineNum">    2574 </span>            : #else
<span class="lineNum">    2575 </span>            : #define DECL_RTL_KNOWN_SET(decl) (&amp;*DECL_RTL_IF_SET (decl))
<span class="lineNum">    2576 </span>            : #endif
<span class="lineNum">    2577 </span>            : 
<span class="lineNum">    2578 </span>            : /* In VAR_DECL and PARM_DECL nodes, nonzero means declared `register'.  */
<span class="lineNum">    2579 </span>            : #define DECL_REGISTER(NODE) (DECL_WRTL_CHECK (NODE)-&gt;decl_common.decl_flag_0)
<span class="lineNum">    2580 </span>            : 
<span class="lineNum">    2581 </span>            : /* In a FIELD_DECL, this is the field position, counting in bytes, of the
<span class="lineNum">    2582 </span>            :    DECL_OFFSET_ALIGN-bit-sized word containing the bit closest to the beginning
<span class="lineNum">    2583 </span>            :    of the structure.  */
<span class="lineNum">    2584 </span>            : #define DECL_FIELD_OFFSET(NODE) (FIELD_DECL_CHECK (NODE)-&gt;field_decl.offset)
<span class="lineNum">    2585 </span>            : 
<span class="lineNum">    2586 </span>            : /* In a FIELD_DECL, this is the offset, in bits, of the first bit of the
<span class="lineNum">    2587 </span>            :    field from DECL_FIELD_OFFSET.  This field may be nonzero even for fields
<span class="lineNum">    2588 </span>            :    that are not bit fields (since DECL_OFFSET_ALIGN may be larger than the
<span class="lineNum">    2589 </span>            :    natural alignment of the field's type).  */
<span class="lineNum">    2590 </span>            : #define DECL_FIELD_BIT_OFFSET(NODE) \
<span class="lineNum">    2591 </span>            :   (FIELD_DECL_CHECK (NODE)-&gt;field_decl.bit_offset)
<span class="lineNum">    2592 </span>            : 
<span class="lineNum">    2593 </span>            : /* In a FIELD_DECL, this indicates whether the field was a bit-field and
<span class="lineNum">    2594 </span>            :    if so, the type that was originally specified for it.
<span class="lineNum">    2595 </span>            :    TREE_TYPE may have been modified (in finish_struct).  */
<span class="lineNum">    2596 </span>            : #define DECL_BIT_FIELD_TYPE(NODE) \
<span class="lineNum">    2597 </span>            :   (FIELD_DECL_CHECK (NODE)-&gt;field_decl.bit_field_type)
<span class="lineNum">    2598 </span>            : 
<span class="lineNum">    2599 </span>            : /* In a FIELD_DECL of a RECORD_TYPE, this is a pointer to the storage
<span class="lineNum">    2600 </span>            :    representative FIELD_DECL.  */
<span class="lineNum">    2601 </span>            : #define DECL_BIT_FIELD_REPRESENTATIVE(NODE) \
<span class="lineNum">    2602 </span>            :   (FIELD_DECL_CHECK (NODE)-&gt;field_decl.qualifier)
<span class="lineNum">    2603 </span>            : 
<span class="lineNum">    2604 </span>            : /* For a FIELD_DECL in a QUAL_UNION_TYPE, records the expression, which
<span class="lineNum">    2605 </span>            :    if nonzero, indicates that the field occupies the type.  */
<span class="lineNum">    2606 </span>            : #define DECL_QUALIFIER(NODE) (FIELD_DECL_CHECK (NODE)-&gt;field_decl.qualifier)
<span class="lineNum">    2607 </span>            : 
<span class="lineNum">    2608 </span>            : /* For FIELD_DECLs, off_align holds the number of low-order bits of
<span class="lineNum">    2609 </span>            :    DECL_FIELD_OFFSET which are known to be always zero.
<span class="lineNum">    2610 </span>            :    DECL_OFFSET_ALIGN thus returns the alignment that DECL_FIELD_OFFSET
<span class="lineNum">    2611 </span>            :    has.  */
<span class="lineNum">    2612 </span>            : #define DECL_OFFSET_ALIGN(NODE) \
<span class="lineNum">    2613 </span>            :   (((unsigned HOST_WIDE_INT)1) &lt;&lt; FIELD_DECL_CHECK (NODE)-&gt;decl_common.off_align)
<span class="lineNum">    2614 </span>            : 
<span class="lineNum">    2615 </span>            : /* Specify that DECL_OFFSET_ALIGN(NODE) is X.  */
<span class="lineNum">    2616 </span>            : #define SET_DECL_OFFSET_ALIGN(NODE, X) \
<span class="lineNum">    2617 </span>            :   (FIELD_DECL_CHECK (NODE)-&gt;decl_common.off_align = ffs_hwi (X) - 1)
<span class="lineNum">    2618 </span>            : 
<span class="lineNum">    2619 </span>            : /* For FIELD_DECLS, DECL_FCONTEXT is the *first* baseclass in
<span class="lineNum">    2620 </span>            :    which this FIELD_DECL is defined.  This information is needed when
<span class="lineNum">    2621 </span>            :    writing debugging information about vfield and vbase decls for C++.  */
<span class="lineNum">    2622 </span>            : #define DECL_FCONTEXT(NODE) (FIELD_DECL_CHECK (NODE)-&gt;field_decl.fcontext)
<span class="lineNum">    2623 </span>            : 
<span class="lineNum">    2624 </span>            : /* In a FIELD_DECL, indicates this field should be bit-packed.  */
<span class="lineNum">    2625 </span>            : #define DECL_PACKED(NODE) (FIELD_DECL_CHECK (NODE)-&gt;base.u.bits.packed_flag)
<span class="lineNum">    2626 </span>            : 
<span class="lineNum">    2627 </span>            : /* Nonzero in a FIELD_DECL means it is a bit field, and must be accessed
<span class="lineNum">    2628 </span>            :    specially.  */
<span class="lineNum">    2629 </span>            : #define DECL_BIT_FIELD(NODE) (FIELD_DECL_CHECK (NODE)-&gt;decl_common.decl_flag_1)
<span class="lineNum">    2630 </span>            : 
<span class="lineNum">    2631 </span>            : /* Used in a FIELD_DECL to indicate that we cannot form the address of
<span class="lineNum">    2632 </span>            :    this component.  This makes it possible for Type-Based Alias Analysis
<span class="lineNum">    2633 </span>            :    to disambiguate accesses to this field with indirect accesses using
<span class="lineNum">    2634 </span>            :    the field's type:
<span class="lineNum">    2635 </span>            : 
<span class="lineNum">    2636 </span>            :      struct S { int i; } s;
<span class="lineNum">    2637 </span>            :      int *p;
<span class="lineNum">    2638 </span>            : 
<span class="lineNum">    2639 </span>            :    If the flag is set on 'i', TBAA computes that s.i and *p never conflict.
<span class="lineNum">    2640 </span>            : 
<span class="lineNum">    2641 </span>            :    From the implementation's viewpoint, the alias set of the type of the
<span class="lineNum">    2642 </span>            :    field 'i' (int) will not be recorded as a subset of that of the type of
<span class="lineNum">    2643 </span>            :    's' (struct S) in record_component_aliases.  The counterpart is that
<span class="lineNum">    2644 </span>            :    accesses to s.i must not be given the alias set of the type of 'i'
<span class="lineNum">    2645 </span>            :    (int) but instead directly that of the type of 's' (struct S).  */
<span class="lineNum">    2646 </span>            : #define DECL_NONADDRESSABLE_P(NODE) \
<span class="lineNum">    2647 </span>            :   (FIELD_DECL_CHECK (NODE)-&gt;decl_common.decl_flag_2)
<span class="lineNum">    2648 </span>            : 
<span class="lineNum">    2649 </span>            : /* Used in a FIELD_DECL to indicate that this field is padding.  */
<span class="lineNum">    2650 </span>            : #define DECL_PADDING_P(NODE) \
<span class="lineNum">    2651 </span>            :   (FIELD_DECL_CHECK (NODE)-&gt;decl_common.decl_flag_3)
<span class="lineNum">    2652 </span>            : 
<span class="lineNum">    2653 </span>            : /* A numeric unique identifier for a LABEL_DECL.  The UID allocation is
<span class="lineNum">    2654 </span>            :    dense, unique within any one function, and may be used to index arrays.
<span class="lineNum">    2655 </span>            :    If the value is -1, then no UID has been assigned.  */
<span class="lineNum">    2656 </span>            : #define LABEL_DECL_UID(NODE) \
<span class="lineNum">    2657 </span>            :   (LABEL_DECL_CHECK (NODE)-&gt;label_decl.label_decl_uid)
<span class="lineNum">    2658 </span>            : 
<span class="lineNum">    2659 </span>            : /* In a LABEL_DECL, the EH region number for which the label is the
<span class="lineNum">    2660 </span>            :    post_landing_pad.  */
<span class="lineNum">    2661 </span>            : #define EH_LANDING_PAD_NR(NODE) \
<span class="lineNum">    2662 </span>            :   (LABEL_DECL_CHECK (NODE)-&gt;label_decl.eh_landing_pad_nr)
<span class="lineNum">    2663 </span>            : 
<span class="lineNum">    2664 </span>            : /* For a PARM_DECL, records the data type used to pass the argument,
<span class="lineNum">    2665 </span>            :    which may be different from the type seen in the program.  */
<span class="lineNum">    2666 </span>            : #define DECL_ARG_TYPE(NODE) (PARM_DECL_CHECK (NODE)-&gt;decl_common.initial)
<span class="lineNum">    2667 </span>            : 
<span class="lineNum">    2668 </span>            : /* For PARM_DECL, holds an RTL for the stack slot or register
<span class="lineNum">    2669 </span>            :    where the data was actually passed.  */
<span class="lineNum">    2670 </span>            : #define DECL_INCOMING_RTL(NODE) \
<span class="lineNum">    2671 </span>            :   (PARM_DECL_CHECK (NODE)-&gt;parm_decl.incoming_rtl)
<span class="lineNum">    2672 </span>            : 
<span class="lineNum">    2673 </span>            : /* Nonzero for a given ..._DECL node means that no warnings should be
<span class="lineNum">    2674 </span>            :    generated just because this node is unused.  */
<span class="lineNum">    2675 </span>            : #define DECL_IN_SYSTEM_HEADER(NODE) \
<span class="lineNum">    2676 </span>            :   (in_system_header_at (DECL_SOURCE_LOCATION (NODE)))
<span class="lineNum">    2677 </span>            : 
<span class="lineNum">    2678 </span>            : /* Used to indicate that the linkage status of this DECL is not yet known,
<span class="lineNum">    2679 </span>            :    so it should not be output now.  */
<span class="lineNum">    2680 </span>            : #define DECL_DEFER_OUTPUT(NODE) \
<span class="lineNum">    2681 </span>            :   (DECL_WITH_VIS_CHECK (NODE)-&gt;decl_with_vis.defer_output)
<span class="lineNum">    2682 </span>            : 
<span class="lineNum">    2683 </span>            : /* In a VAR_DECL that's static,
<span class="lineNum">    2684 </span>            :    nonzero if the space is in the text section.  */
<span class="lineNum">    2685 </span>            : #define DECL_IN_TEXT_SECTION(NODE) \
<span class="lineNum">    2686 </span>            :   (VAR_DECL_CHECK (NODE)-&gt;decl_with_vis.in_text_section)
<span class="lineNum">    2687 </span>            : 
<span class="lineNum">    2688 </span>            : /* In a VAR_DECL that's static,
<span class="lineNum">    2689 </span>            :    nonzero if it belongs to the global constant pool.  */
<span class="lineNum">    2690 </span>            : #define DECL_IN_CONSTANT_POOL(NODE) \
<span class="lineNum">    2691 </span>            :   (VAR_DECL_CHECK (NODE)-&gt;decl_with_vis.in_constant_pool)
<span class="lineNum">    2692 </span>            : 
<span class="lineNum">    2693 </span>            : /* Nonzero for a given ..._DECL node means that this node should be
<span class="lineNum">    2694 </span>            :    put in .common, if possible.  If a DECL_INITIAL is given, and it
<span class="lineNum">    2695 </span>            :    is not error_mark_node, then the decl cannot be put in .common.  */
<span class="lineNum">    2696 </span>            : #define DECL_COMMON(NODE) \
<span class="lineNum">    2697 </span>            :   (DECL_WITH_VIS_CHECK (NODE)-&gt;decl_with_vis.common_flag)
<span class="lineNum">    2698 </span>            : 
<span class="lineNum">    2699 </span>            : /* In a VAR_DECL, nonzero if the decl is a register variable with
<span class="lineNum">    2700 </span>            :    an explicit asm specification.  */
<span class="lineNum">    2701 </span>            : #define DECL_HARD_REGISTER(NODE)  \
<span class="lineNum">    2702 </span>            :   (VAR_DECL_CHECK (NODE)-&gt;decl_with_vis.hard_register)
<span class="lineNum">    2703 </span>            : 
<span class="lineNum">    2704 </span>            :   /* Used to indicate that this DECL has weak linkage.  */
<span class="lineNum">    2705 </span>            : #define DECL_WEAK(NODE) (DECL_WITH_VIS_CHECK (NODE)-&gt;decl_with_vis.weak_flag)
<span class="lineNum">    2706 </span>            : 
<span class="lineNum">    2707 </span>            : /* Used to indicate that the DECL is a dllimport.  */
<span class="lineNum">    2708 </span>            : #define DECL_DLLIMPORT_P(NODE) \
<span class="lineNum">    2709 </span>            :   (DECL_WITH_VIS_CHECK (NODE)-&gt;decl_with_vis.dllimport_flag)
<span class="lineNum">    2710 </span>            : 
<span class="lineNum">    2711 </span>            : /* Used in a DECL to indicate that, even if it TREE_PUBLIC, it need
<span class="lineNum">    2712 </span>            :    not be put out unless it is needed in this translation unit.
<span class="lineNum">    2713 </span>            :    Entities like this are shared across translation units (like weak
<span class="lineNum">    2714 </span>            :    entities), but are guaranteed to be generated by any translation
<span class="lineNum">    2715 </span>            :    unit that needs them, and therefore need not be put out anywhere
<span class="lineNum">    2716 </span>            :    where they are not needed.  DECL_COMDAT is just a hint to the
<span class="lineNum">    2717 </span>            :    back-end; it is up to front-ends which set this flag to ensure
<span class="lineNum">    2718 </span>            :    that there will never be any harm, other than bloat, in putting out
<span class="lineNum">    2719 </span>            :    something which is DECL_COMDAT.  */
<span class="lineNum">    2720 </span>            : #define DECL_COMDAT(NODE) \
<span class="lineNum">    2721 </span>            :   (DECL_WITH_VIS_CHECK (NODE)-&gt;decl_with_vis.comdat_flag)
<span class="lineNum">    2722 </span>            : 
<span class="lineNum">    2723 </span>            : #define DECL_COMDAT_GROUP(NODE) \
<span class="lineNum">    2724 </span>            :   decl_comdat_group (NODE)
<span class="lineNum">    2725 </span>            : 
<span class="lineNum">    2726 </span>            : /* Used in TREE_PUBLIC decls to indicate that copies of this DECL in
<span class="lineNum">    2727 </span>            :    multiple translation units should be merged.  */
<span class="lineNum">    2728 </span>            : #define DECL_ONE_ONLY(NODE) (DECL_COMDAT_GROUP (NODE) != NULL_TREE \
<span class="lineNum">    2729 </span>            :                              &amp;&amp; (TREE_PUBLIC (NODE) || DECL_EXTERNAL (NODE)))
<span class="lineNum">    2730 </span>            : 
<span class="lineNum">    2731 </span>            : /* The name of the object as the assembler will see it (but before any
<span class="lineNum">    2732 </span>            :    translations made by ASM_OUTPUT_LABELREF).  Often this is the same
<span class="lineNum">    2733 </span>            :    as DECL_NAME.  It is an IDENTIFIER_NODE.
<span class="lineNum">    2734 </span>            : 
<span class="lineNum">    2735 </span>            :    ASSEMBLER_NAME of TYPE_DECLS may store global name of type used for
<span class="lineNum">    2736 </span>            :    One Definition Rule based type merging at LTO.  It is computed only for
<span class="lineNum">    2737 </span>            :    LTO compilation and C++.  */
<span class="lineNum">    2738 </span>            : #define DECL_ASSEMBLER_NAME(NODE) decl_assembler_name (NODE)
<span class="lineNum">    2739 </span>            : 
<span class="lineNum">    2740 </span>            : /* Raw accessor for DECL_ASSEMBLE_NAME.  */
<span class="lineNum">    2741 </span>            : #define DECL_ASSEMBLER_NAME_RAW(NODE) \
<span class="lineNum">    2742 </span>            :   (DECL_WITH_VIS_CHECK (NODE)-&gt;decl_with_vis.assembler_name)
<span class="lineNum">    2743 </span>            : 
<span class="lineNum">    2744 </span>            : /* Return true if NODE is a NODE that can contain a DECL_ASSEMBLER_NAME.
<span class="lineNum">    2745 </span>            :    This is true of all DECL nodes except FIELD_DECL.  */
<span class="lineNum">    2746 </span>            : #define HAS_DECL_ASSEMBLER_NAME_P(NODE) \
<span class="lineNum">    2747 </span>            :   (CODE_CONTAINS_STRUCT (TREE_CODE (NODE), TS_DECL_WITH_VIS))
<span class="lineNum">    2748 </span>            : 
<span class="lineNum">    2749 </span>            : /* Returns nonzero if the DECL_ASSEMBLER_NAME for NODE has been set.  If zero,
<span class="lineNum">    2750 </span>            :    the NODE might still have a DECL_ASSEMBLER_NAME -- it just hasn't been set
<span class="lineNum">    2751 </span>            :    yet.  */
<span class="lineNum">    2752 </span>            : #define DECL_ASSEMBLER_NAME_SET_P(NODE) \
<span class="lineNum">    2753 </span>            :   (DECL_ASSEMBLER_NAME_RAW (NODE) != NULL_TREE)
<span class="lineNum">    2754 </span>            : 
<span class="lineNum">    2755 </span>            : /* Set the DECL_ASSEMBLER_NAME for NODE to NAME.  */
<span class="lineNum">    2756 </span>            : #define SET_DECL_ASSEMBLER_NAME(NODE, NAME) \
<span class="lineNum">    2757 </span>            :   overwrite_decl_assembler_name (NODE, NAME)
<span class="lineNum">    2758 </span>            : 
<span class="lineNum">    2759 </span>            : /* Copy the DECL_ASSEMBLER_NAME from SRC_DECL to DST_DECL.  Note that
<span class="lineNum">    2760 </span>            :    if SRC_DECL's DECL_ASSEMBLER_NAME has not yet been set, using this
<span class="lineNum">    2761 </span>            :    macro will not cause the DECL_ASSEMBLER_NAME to be set, but will
<span class="lineNum">    2762 </span>            :    clear DECL_ASSEMBLER_NAME of DST_DECL, if it was already set.  In
<span class="lineNum">    2763 </span>            :    other words, the semantics of using this macro, are different than
<span class="lineNum">    2764 </span>            :    saying:
<span class="lineNum">    2765 </span>            : 
<span class="lineNum">    2766 </span>            :      SET_DECL_ASSEMBLER_NAME(DST_DECL, DECL_ASSEMBLER_NAME (SRC_DECL))
<span class="lineNum">    2767 </span>            : 
<span class="lineNum">    2768 </span>            :    which will try to set the DECL_ASSEMBLER_NAME for SRC_DECL.  */
<span class="lineNum">    2769 </span>            : 
<span class="lineNum">    2770 </span>            : #define COPY_DECL_ASSEMBLER_NAME(SRC_DECL, DST_DECL)                    \
<span class="lineNum">    2771 </span>            :   SET_DECL_ASSEMBLER_NAME (DST_DECL, DECL_ASSEMBLER_NAME_RAW (SRC_DECL))
<span class="lineNum">    2772 </span>            : 
<span class="lineNum">    2773 </span>            : /* Records the section name in a section attribute.  Used to pass
<span class="lineNum">    2774 </span>            :    the name from decl_attributes to make_function_rtl and make_decl_rtl.  */
<span class="lineNum">    2775 </span>            : #define DECL_SECTION_NAME(NODE) decl_section_name (NODE)
<span class="lineNum">    2776 </span>            : 
<span class="lineNum">    2777 </span>            : /* Nonzero in a decl means that the gimplifier has seen (or placed)
<span class="lineNum">    2778 </span>            :    this variable in a BIND_EXPR.  */
<span class="lineNum">    2779 </span>            : #define DECL_SEEN_IN_BIND_EXPR_P(NODE) \
<span class="lineNum">    2780 </span>            :   (DECL_WITH_VIS_CHECK (NODE)-&gt;decl_with_vis.seen_in_bind_expr)
<span class="lineNum">    2781 </span>            : 
<span class="lineNum">    2782 </span>            : /* Value of the decls's visibility attribute */
<span class="lineNum">    2783 </span>            : #define DECL_VISIBILITY(NODE) \
<span class="lineNum">    2784 </span>            :   (DECL_WITH_VIS_CHECK (NODE)-&gt;decl_with_vis.visibility)
<span class="lineNum">    2785 </span>            : 
<span class="lineNum">    2786 </span>            : /* Nonzero means that the decl had its visibility specified rather than
<span class="lineNum">    2787 </span>            :    being inferred.  */
<span class="lineNum">    2788 </span>            : #define DECL_VISIBILITY_SPECIFIED(NODE) \
<span class="lineNum">    2789 </span>            :   (DECL_WITH_VIS_CHECK (NODE)-&gt;decl_with_vis.visibility_specified)
<span class="lineNum">    2790 </span>            : 
<span class="lineNum">    2791 </span>            : /* In a VAR_DECL, the model to use if the data should be allocated from
<span class="lineNum">    2792 </span>            :    thread-local storage.  */
<span class="lineNum">    2793 </span>            : #define DECL_TLS_MODEL(NODE) decl_tls_model (NODE)
<span class="lineNum">    2794 </span>            : 
<span class="lineNum">    2795 </span>            : /* In a VAR_DECL, nonzero if the data should be allocated from
<span class="lineNum">    2796 </span>            :    thread-local storage.  */
<span class="lineNum">    2797 </span>            : #define DECL_THREAD_LOCAL_P(NODE) \
<span class="lineNum">    2798 </span>            :   ((TREE_STATIC (NODE) || DECL_EXTERNAL (NODE)) &amp;&amp; decl_tls_model (NODE) &gt;= TLS_MODEL_REAL)
<span class="lineNum">    2799 </span>            : 
<span class="lineNum">    2800 </span>            : /* In a non-local VAR_DECL with static storage duration, true if the
<span class="lineNum">    2801 </span>            :    variable has an initialization priority.  If false, the variable
<span class="lineNum">    2802 </span>            :    will be initialized at the DEFAULT_INIT_PRIORITY.  */
<span class="lineNum">    2803 </span>            : #define DECL_HAS_INIT_PRIORITY_P(NODE) \
<span class="lineNum">    2804 </span>            :   (VAR_DECL_CHECK (NODE)-&gt;decl_with_vis.init_priority_p)
<span class="lineNum">    2805 </span>            : 
<span class="lineNum">    2806 </span>            : extern tree decl_debug_expr_lookup (tree);
<span class="lineNum">    2807 </span>            : extern void decl_debug_expr_insert (tree, tree);
<span class="lineNum">    2808 </span>            : 
<span class="lineNum">    2809 </span>            : /* For VAR_DECL, this is set to an expression that it was split from.  */
<span class="lineNum">    2810 </span>            : #define DECL_HAS_DEBUG_EXPR_P(NODE) \
<span class="lineNum">    2811 </span>            :   (VAR_DECL_CHECK (NODE)-&gt;decl_common.debug_expr_is_from)
<span class="lineNum">    2812 </span>            : #define DECL_DEBUG_EXPR(NODE) \
<span class="lineNum">    2813 </span>            :   (decl_debug_expr_lookup (VAR_DECL_CHECK (NODE)))
<span class="lineNum">    2814 </span>            : 
<span class="lineNum">    2815 </span>            : #define SET_DECL_DEBUG_EXPR(NODE, VAL) \
<span class="lineNum">    2816 </span>            :   (decl_debug_expr_insert (VAR_DECL_CHECK (NODE), VAL))
<span class="lineNum">    2817 </span>            : 
<span class="lineNum">    2818 </span>            : extern priority_type decl_init_priority_lookup (tree);
<span class="lineNum">    2819 </span>            : extern priority_type decl_fini_priority_lookup (tree);
<span class="lineNum">    2820 </span>            : extern void decl_init_priority_insert (tree, priority_type);
<span class="lineNum">    2821 </span>            : extern void decl_fini_priority_insert (tree, priority_type);
<span class="lineNum">    2822 </span>            : 
<span class="lineNum">    2823 </span>            : /* For a VAR_DECL or FUNCTION_DECL the initialization priority of
<span class="lineNum">    2824 </span>            :    NODE.  */
<span class="lineNum">    2825 </span>            : #define DECL_INIT_PRIORITY(NODE) \
<span class="lineNum">    2826 </span>            :   (decl_init_priority_lookup (NODE))
<span class="lineNum">    2827 </span>            : /* Set the initialization priority for NODE to VAL.  */
<span class="lineNum">    2828 </span>            : #define SET_DECL_INIT_PRIORITY(NODE, VAL) \
<span class="lineNum">    2829 </span>            :   (decl_init_priority_insert (NODE, VAL))
<span class="lineNum">    2830 </span>            : 
<span class="lineNum">    2831 </span>            : /* For a FUNCTION_DECL the finalization priority of NODE.  */
<span class="lineNum">    2832 </span>            : #define DECL_FINI_PRIORITY(NODE) \
<span class="lineNum">    2833 </span>            :   (decl_fini_priority_lookup (NODE))
<span class="lineNum">    2834 </span>            : /* Set the finalization priority for NODE to VAL.  */
<span class="lineNum">    2835 </span>            : #define SET_DECL_FINI_PRIORITY(NODE, VAL) \
<span class="lineNum">    2836 </span>            :   (decl_fini_priority_insert (NODE, VAL))
<span class="lineNum">    2837 </span>            : 
<span class="lineNum">    2838 </span>            : /* The initialization priority for entities for which no explicit
<span class="lineNum">    2839 </span>            :    initialization priority has been specified.  */
<span class="lineNum">    2840 </span>            : #define DEFAULT_INIT_PRIORITY 65535
<span class="lineNum">    2841 </span>            : 
<span class="lineNum">    2842 </span>            : /* The maximum allowed initialization priority.  */
<span class="lineNum">    2843 </span>            : #define MAX_INIT_PRIORITY 65535
<span class="lineNum">    2844 </span>            : 
<span class="lineNum">    2845 </span>            : /* The largest priority value reserved for use by system runtime
<span class="lineNum">    2846 </span>            :    libraries.  */
<span class="lineNum">    2847 </span>            : #define MAX_RESERVED_INIT_PRIORITY 100
<span class="lineNum">    2848 </span>            : 
<span class="lineNum">    2849 </span>            : /* In a VAR_DECL, nonzero if this is a global variable for VOPs.  */
<span class="lineNum">    2850 </span>            : #define VAR_DECL_IS_VIRTUAL_OPERAND(NODE) \
<span class="lineNum">    2851 </span>            :   (VAR_DECL_CHECK (NODE)-&gt;base.u.bits.saturating_flag)
<span class="lineNum">    2852 </span>            : 
<span class="lineNum">    2853 </span>            : /* In a VAR_DECL, nonzero if this is a non-local frame structure.  */
<span class="lineNum">    2854 </span>            : #define DECL_NONLOCAL_FRAME(NODE)  \
<span class="lineNum">    2855 </span>            :   (VAR_DECL_CHECK (NODE)-&gt;base.default_def_flag)
<span class="lineNum">    2856 </span>            : 
<span class="lineNum">    2857 </span>            : /* In a VAR_DECL, nonzero if this variable is not aliased by any pointer.  */
<span class="lineNum">    2858 </span>            : #define DECL_NONALIASED(NODE) \
<span class="lineNum">    2859 </span>            :   (VAR_DECL_CHECK (NODE)-&gt;base.nothrow_flag)
<span class="lineNum">    2860 </span>            : 
<span class="lineNum">    2861 </span>            : /* This field is used to reference anything in decl.result and is meant only
<span class="lineNum">    2862 </span>            :    for use by the garbage collector.  */
<span class="lineNum">    2863 </span>            : #define DECL_RESULT_FLD(NODE) \
<span class="lineNum">    2864 </span>            :   (DECL_NON_COMMON_CHECK (NODE)-&gt;decl_non_common.result)
<span class="lineNum">    2865 </span>            : 
<span class="lineNum">    2866 </span>            : /* The DECL_VINDEX is used for FUNCTION_DECLS in two different ways.
<span class="lineNum">    2867 </span>            :    Before the struct containing the FUNCTION_DECL is laid out,
<span class="lineNum">    2868 </span>            :    DECL_VINDEX may point to a FUNCTION_DECL in a base class which
<span class="lineNum">    2869 </span>            :    is the FUNCTION_DECL which this FUNCTION_DECL will replace as a virtual
<span class="lineNum">    2870 </span>            :    function.  When the class is laid out, this pointer is changed
<span class="lineNum">    2871 </span>            :    to an INTEGER_CST node which is suitable for use as an index
<span class="lineNum">    2872 </span>            :    into the virtual function table. */
<span class="lineNum">    2873 </span>            : #define DECL_VINDEX(NODE) \
<span class="lineNum">    2874 </span>            :   (FUNCTION_DECL_CHECK (NODE)-&gt;function_decl.vindex)
<span class="lineNum">    2875 </span>            : 
<span class="lineNum">    2876 </span>            : /* In FUNCTION_DECL, holds the decl for the return value.  */
<span class="lineNum">    2877 </span>            : #define DECL_RESULT(NODE) (FUNCTION_DECL_CHECK (NODE)-&gt;decl_non_common.result)
<span class="lineNum">    2878 </span>            : 
<span class="lineNum">    2879 </span>            : /* In a FUNCTION_DECL, nonzero if the function cannot be inlined.  */
<span class="lineNum">    2880 </span>            : #define DECL_UNINLINABLE(NODE) \
<span class="lineNum">    2881 </span>            :   (FUNCTION_DECL_CHECK (NODE)-&gt;function_decl.uninlinable)
<span class="lineNum">    2882 </span>            : 
<span class="lineNum">    2883 </span>            : /* In a FUNCTION_DECL, the saved representation of the body of the
<span class="lineNum">    2884 </span>            :    entire function.  */
<span class="lineNum">    2885 </span>            : #define DECL_SAVED_TREE(NODE) \
<span class="lineNum">    2886 </span>            :   (FUNCTION_DECL_CHECK (NODE)-&gt;function_decl.saved_tree)
<span class="lineNum">    2887 </span>            : 
<span class="lineNum">    2888 </span>            : /* Nonzero in a FUNCTION_DECL means this function should be treated
<span class="lineNum">    2889 </span>            :    as if it were a malloc, meaning it returns a pointer that is
<span class="lineNum">    2890 </span>            :    not an alias.  */
<span class="lineNum">    2891 </span>            : #define DECL_IS_MALLOC(NODE) \
<span class="lineNum">    2892 </span>            :   (FUNCTION_DECL_CHECK (NODE)-&gt;function_decl.malloc_flag)
<span class="lineNum">    2893 </span>            : 
<span class="lineNum">    2894 </span>            : /* Nonzero in a FUNCTION_DECL means this function should be treated as
<span class="lineNum">    2895 </span>            :    C++ operator new, meaning that it returns a pointer for which we
<span class="lineNum">    2896 </span>            :    should not use type based aliasing.  */
<span class="lineNum">    2897 </span>            : #define DECL_IS_OPERATOR_NEW(NODE) \
<span class="lineNum">    2898 </span>            :   (FUNCTION_DECL_CHECK (NODE)-&gt;function_decl.operator_new_flag)
<span class="lineNum">    2899 </span>            : 
<span class="lineNum">    2900 </span>            : /* Nonzero in a FUNCTION_DECL means this function may return more
<span class="lineNum">    2901 </span>            :    than once.  */
<span class="lineNum">    2902 </span>            : #define DECL_IS_RETURNS_TWICE(NODE) \
<span class="lineNum">    2903 </span>            :   (FUNCTION_DECL_CHECK (NODE)-&gt;function_decl.returns_twice_flag)
<span class="lineNum">    2904 </span>            : 
<span class="lineNum">    2905 </span>            : /* Nonzero in a FUNCTION_DECL means this function should be treated
<span class="lineNum">    2906 </span>            :    as &quot;pure&quot; function (like const function, but may read global memory).  */
<span class="lineNum">    2907 </span>            : #define DECL_PURE_P(NODE) (FUNCTION_DECL_CHECK (NODE)-&gt;function_decl.pure_flag)
<span class="lineNum">    2908 </span>            : 
<span class="lineNum">    2909 </span>            : /* Nonzero only if one of TREE_READONLY or DECL_PURE_P is nonzero AND
<span class="lineNum">    2910 </span>            :    the const or pure function may not terminate.  When this is nonzero
<span class="lineNum">    2911 </span>            :    for a const or pure function, it can be dealt with by cse passes
<span class="lineNum">    2912 </span>            :    but cannot be removed by dce passes since you are not allowed to
<span class="lineNum">    2913 </span>            :    change an infinite looping program into one that terminates without
<span class="lineNum">    2914 </span>            :    error.  */
<span class="lineNum">    2915 </span>            : #define DECL_LOOPING_CONST_OR_PURE_P(NODE) \
<span class="lineNum">    2916 </span>            :   (FUNCTION_DECL_CHECK (NODE)-&gt;function_decl.looping_const_or_pure_flag)
<span class="lineNum">    2917 </span>            : 
<span class="lineNum">    2918 </span>            : /* Nonzero in a FUNCTION_DECL means this function should be treated
<span class="lineNum">    2919 </span>            :    as &quot;novops&quot; function (function that does not read global memory,
<span class="lineNum">    2920 </span>            :    but may have arbitrary side effects).  */
<span class="lineNum">    2921 </span>            : #define DECL_IS_NOVOPS(NODE) \
<span class="lineNum">    2922 </span>            :   (FUNCTION_DECL_CHECK (NODE)-&gt;function_decl.novops_flag)
<span class="lineNum">    2923 </span>            : 
<span class="lineNum">    2924 </span>            : /* Used in FUNCTION_DECLs to indicate that they should be run automatically
<span class="lineNum">    2925 </span>            :    at the beginning or end of execution.  */
<span class="lineNum">    2926 </span>            : #define DECL_STATIC_CONSTRUCTOR(NODE) \
<span class="lineNum">    2927 </span>            :   (FUNCTION_DECL_CHECK (NODE)-&gt;function_decl.static_ctor_flag)
<span class="lineNum">    2928 </span>            : 
<span class="lineNum">    2929 </span>            : #define DECL_STATIC_DESTRUCTOR(NODE) \
<span class="lineNum">    2930 </span>            : (FUNCTION_DECL_CHECK (NODE)-&gt;function_decl.static_dtor_flag)
<span class="lineNum">    2931 </span>            : 
<span class="lineNum">    2932 </span>            : /* Used in FUNCTION_DECLs to indicate that function entry and exit should
<span class="lineNum">    2933 </span>            :    be instrumented with calls to support routines.  */
<span class="lineNum">    2934 </span>            : #define DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT(NODE) \
<span class="lineNum">    2935 </span>            :   (FUNCTION_DECL_CHECK (NODE)-&gt;function_decl.no_instrument_function_entry_exit)
<span class="lineNum">    2936 </span>            : 
<span class="lineNum">    2937 </span>            : /* Used in FUNCTION_DECLs to indicate that limit-stack-* should be
<span class="lineNum">    2938 </span>            :    disabled in this function.  */
<span class="lineNum">    2939 </span>            : #define DECL_NO_LIMIT_STACK(NODE) \
<span class="lineNum">    2940 </span>            :   (FUNCTION_DECL_CHECK (NODE)-&gt;function_decl.no_limit_stack)
<span class="lineNum">    2941 </span>            : 
<span class="lineNum">    2942 </span>            : /* In a FUNCTION_DECL indicates that a static chain is needed.  */
<span class="lineNum">    2943 </span>            : #define DECL_STATIC_CHAIN(NODE) \
<span class="lineNum">    2944 </span>            :   (FUNCTION_DECL_CHECK (NODE)-&gt;decl_with_vis.regdecl_flag)
<span class="lineNum">    2945 </span>            : 
<span class="lineNum">    2946 </span>            : /* Nonzero for a decl that cgraph has decided should be inlined into
<span class="lineNum">    2947 </span>            :    at least one call site.  It is not meaningful to look at this
<span class="lineNum">    2948 </span>            :    directly; always use cgraph_function_possibly_inlined_p.  */
<span class="lineNum">    2949 </span>            : #define DECL_POSSIBLY_INLINED(DECL) \
<span class="lineNum">    2950 </span>            :   FUNCTION_DECL_CHECK (DECL)-&gt;function_decl.possibly_inlined
<span class="lineNum">    2951 </span>            : 
<span class="lineNum">    2952 </span>            : /* Nonzero in a FUNCTION_DECL means that this function was declared inline,
<span class="lineNum">    2953 </span>            :    such as via the `inline' keyword in C/C++.  This flag controls the linkage
<span class="lineNum">    2954 </span>            :    semantics of 'inline'  */
<span class="lineNum">    2955 </span>            : #define DECL_DECLARED_INLINE_P(NODE) \
<span class="lineNum">    2956 </span>            :   (FUNCTION_DECL_CHECK (NODE)-&gt;function_decl.declared_inline_flag)
<span class="lineNum">    2957 </span>            : 
<span class="lineNum">    2958 </span>            : /* Nonzero in a FUNCTION_DECL means this function should not get
<span class="lineNum">    2959 </span>            :    -Winline warnings.  */
<span class="lineNum">    2960 </span>            : #define DECL_NO_INLINE_WARNING_P(NODE) \
<span class="lineNum">    2961 </span>            :   (FUNCTION_DECL_CHECK (NODE)-&gt;function_decl.no_inline_warning_flag)
<span class="lineNum">    2962 </span>            : 
<span class="lineNum">    2963 </span>            : /* Nonzero if a FUNCTION_CODE is a TM load/store.  */
<span class="lineNum">    2964 </span>            : #define BUILTIN_TM_LOAD_STORE_P(FN) \
<span class="lineNum">    2965 </span>            :   ((FN) &gt;= BUILT_IN_TM_STORE_1 &amp;&amp; (FN) &lt;= BUILT_IN_TM_LOAD_RFW_LDOUBLE)
<span class="lineNum">    2966 </span>            : 
<span class="lineNum">    2967 </span>            : /* Nonzero if a FUNCTION_CODE is a TM load.  */
<span class="lineNum">    2968 </span>            : #define BUILTIN_TM_LOAD_P(FN) \
<span class="lineNum">    2969 </span>            :   ((FN) &gt;= BUILT_IN_TM_LOAD_1 &amp;&amp; (FN) &lt;= BUILT_IN_TM_LOAD_RFW_LDOUBLE)
<span class="lineNum">    2970 </span>            : 
<span class="lineNum">    2971 </span>            : /* Nonzero if a FUNCTION_CODE is a TM store.  */
<span class="lineNum">    2972 </span>            : #define BUILTIN_TM_STORE_P(FN) \
<span class="lineNum">    2973 </span>            :   ((FN) &gt;= BUILT_IN_TM_STORE_1 &amp;&amp; (FN) &lt;= BUILT_IN_TM_STORE_WAW_LDOUBLE)
<span class="lineNum">    2974 </span>            : 
<span class="lineNum">    2975 </span>            : #define CASE_BUILT_IN_TM_LOAD(FN)       \
<span class="lineNum">    2976 </span>            :   case BUILT_IN_TM_LOAD_##FN:           \
<span class="lineNum">    2977 </span>            :   case BUILT_IN_TM_LOAD_RAR_##FN:       \
<span class="lineNum">    2978 </span>            :   case BUILT_IN_TM_LOAD_RAW_##FN:       \
<span class="lineNum">    2979 </span>            :   case BUILT_IN_TM_LOAD_RFW_##FN
<span class="lineNum">    2980 </span>            : 
<span class="lineNum">    2981 </span>            : #define CASE_BUILT_IN_TM_STORE(FN)      \
<span class="lineNum">    2982 </span>            :   case BUILT_IN_TM_STORE_##FN:          \
<span class="lineNum">    2983 </span>            :   case BUILT_IN_TM_STORE_WAR_##FN:      \
<span class="lineNum">    2984 </span>            :   case BUILT_IN_TM_STORE_WAW_##FN
<span class="lineNum">    2985 </span>            : 
<span class="lineNum">    2986 </span>            : /* Nonzero in a FUNCTION_DECL that should be always inlined by the inliner
<span class="lineNum">    2987 </span>            :    disregarding size and cost heuristics.  This is equivalent to using
<span class="lineNum">    2988 </span>            :    the always_inline attribute without the required diagnostics if the
<span class="lineNum">    2989 </span>            :    function cannot be inlined.  */
<span class="lineNum">    2990 </span>            : #define DECL_DISREGARD_INLINE_LIMITS(NODE) \
<span class="lineNum">    2991 </span>            :   (FUNCTION_DECL_CHECK (NODE)-&gt;function_decl.disregard_inline_limits)
<span class="lineNum">    2992 </span>            : 
<span class="lineNum">    2993 </span>            : extern vec&lt;tree, va_gc&gt; **decl_debug_args_lookup (tree);
<span class="lineNum">    2994 </span>            : extern vec&lt;tree, va_gc&gt; **decl_debug_args_insert (tree);
<span class="lineNum">    2995 </span>            : 
<span class="lineNum">    2996 </span>            : /* Nonzero if a FUNCTION_DECL has DEBUG arguments attached to it.  */
<span class="lineNum">    2997 </span>            : #define DECL_HAS_DEBUG_ARGS_P(NODE) \
<span class="lineNum">    2998 </span>            :   (FUNCTION_DECL_CHECK (NODE)-&gt;function_decl.has_debug_args_flag)
<span class="lineNum">    2999 </span>            : 
<span class="lineNum">    3000 </span>            : /* For FUNCTION_DECL, this holds a pointer to a structure (&quot;struct function&quot;)
<span class="lineNum">    3001 </span>            :    that describes the status of this function.  */
<span class="lineNum">    3002 </span>            : #define DECL_STRUCT_FUNCTION(NODE) \
<span class="lineNum">    3003 </span>            :   (FUNCTION_DECL_CHECK (NODE)-&gt;function_decl.f)
<span class="lineNum">    3004 </span>            : 
<span class="lineNum">    3005 </span>            : 
<span class="lineNum">    3006 </span>            : /* For a builtin function, identify which part of the compiler defined it.  */
<span class="lineNum">    3007 </span>            : #define DECL_BUILT_IN_CLASS(NODE) \
<span class="lineNum">    3008 </span>            :    (FUNCTION_DECL_CHECK (NODE)-&gt;function_decl.built_in_class)
<span class="lineNum">    3009 </span>            : 
<span class="lineNum">    3010 </span>            : /* In FUNCTION_DECL, a chain of ..._DECL nodes.  */
<span class="lineNum">    3011 </span>            : #define DECL_ARGUMENTS(NODE) \
<span class="lineNum">    3012 </span>            :    (FUNCTION_DECL_CHECK (NODE)-&gt;function_decl.arguments)
<span class="lineNum">    3013 </span>            : 
<span class="lineNum">    3014 </span>            : /* In FUNCTION_DECL, the function specific target options to use when compiling
<span class="lineNum">    3015 </span>            :    this function.  */
<span class="lineNum">    3016 </span>            : #define DECL_FUNCTION_SPECIFIC_TARGET(NODE) \
<span class="lineNum">    3017 </span>            :    (FUNCTION_DECL_CHECK (NODE)-&gt;function_decl.function_specific_target)
<span class="lineNum">    3018 </span>            : 
<span class="lineNum">    3019 </span>            : /* In FUNCTION_DECL, the function specific optimization options to use when
<span class="lineNum">    3020 </span>            :    compiling this function.  */
<span class="lineNum">    3021 </span>            : #define DECL_FUNCTION_SPECIFIC_OPTIMIZATION(NODE) \
<span class="lineNum">    3022 </span>            :    (FUNCTION_DECL_CHECK (NODE)-&gt;function_decl.function_specific_optimization)
<span class="lineNum">    3023 </span>            : 
<span class="lineNum">    3024 </span>            : /* In FUNCTION_DECL, this is set if this function has other versions generated
<span class="lineNum">    3025 </span>            :    using &quot;target&quot; attributes.  The default version is the one which does not
<span class="lineNum">    3026 </span>            :    have any &quot;target&quot; attribute set. */
<span class="lineNum">    3027 </span>            : #define DECL_FUNCTION_VERSIONED(NODE)\
<span class="lineNum">    3028 </span>            :    (FUNCTION_DECL_CHECK (NODE)-&gt;function_decl.versioned_function)
<span class="lineNum">    3029 </span>            : 
<span class="lineNum">    3030 </span>            : /* In FUNCTION_DECL, this is set if this function is a C++ constructor.
<span class="lineNum">    3031 </span>            :    Devirtualization machinery uses this knowledge for determing type of the
<span class="lineNum">    3032 </span>            :    object constructed.  Also we assume that constructor address is not
<span class="lineNum">    3033 </span>            :    important.  */
<span class="lineNum">    3034 </span>            : #define DECL_CXX_CONSTRUCTOR_P(NODE)\
<span class="lineNum">    3035 </span>            :    (FUNCTION_DECL_CHECK (NODE)-&gt;decl_with_vis.cxx_constructor)
<span class="lineNum">    3036 </span>            : 
<span class="lineNum">    3037 </span>            : /* In FUNCTION_DECL, this is set if this function is a C++ destructor.
<span class="lineNum">    3038 </span>            :    Devirtualization machinery uses this to track types in destruction.  */
<span class="lineNum">    3039 </span>            : #define DECL_CXX_DESTRUCTOR_P(NODE)\
<span class="lineNum">    3040 </span>            :    (FUNCTION_DECL_CHECK (NODE)-&gt;decl_with_vis.cxx_destructor)
<span class="lineNum">    3041 </span>            : 
<span class="lineNum">    3042 </span>            : /* In FUNCTION_DECL that represent an virtual method this is set when
<span class="lineNum">    3043 </span>            :    the method is final.  */
<span class="lineNum">    3044 </span>            : #define DECL_FINAL_P(NODE)\
<span class="lineNum">    3045 </span>            :    (FUNCTION_DECL_CHECK (NODE)-&gt;decl_with_vis.final)
<span class="lineNum">    3046 </span>            : 
<span class="lineNum">    3047 </span>            : /* The source language of the translation-unit.  */
<span class="lineNum">    3048 </span>            : #define TRANSLATION_UNIT_LANGUAGE(NODE) \
<span class="lineNum">    3049 </span>            :   (TRANSLATION_UNIT_DECL_CHECK (NODE)-&gt;translation_unit_decl.language)
<span class="lineNum">    3050 </span>            : 
<span class="lineNum">    3051 </span>            : /* TRANSLATION_UNIT_DECL inherits from DECL_MINIMAL.  */
<span class="lineNum">    3052 </span>            : 
<span class="lineNum">    3053 </span>            : /* For a TYPE_DECL, holds the &quot;original&quot; type.  (TREE_TYPE has the copy.) */
<span class="lineNum">    3054 </span>            : #define DECL_ORIGINAL_TYPE(NODE) \
<span class="lineNum">    3055 </span>            :   (TYPE_DECL_CHECK (NODE)-&gt;decl_non_common.result)
<span class="lineNum">    3056 </span>            : 
<span class="lineNum">    3057 </span>            : /* In a TYPE_DECL nonzero means the detail info about this type is not dumped
<span class="lineNum">    3058 </span>            :    into stabs.  Instead it will generate cross reference ('x') of names.
<span class="lineNum">    3059 </span>            :    This uses the same flag as DECL_EXTERNAL.  */
<span class="lineNum">    3060 </span>            : #define TYPE_DECL_SUPPRESS_DEBUG(NODE) \
<span class="lineNum">    3061 </span>            :   (TYPE_DECL_CHECK (NODE)-&gt;decl_common.decl_flag_1)
<span class="lineNum">    3062 </span>            : 
<span class="lineNum">    3063 </span>            : /* Getter of the imported declaration associated to the
<span class="lineNum">    3064 </span>            :    IMPORTED_DECL node.  */
<span class="lineNum">    3065 </span>            : #define IMPORTED_DECL_ASSOCIATED_DECL(NODE) \
<span class="lineNum">    3066 </span>            : (DECL_INITIAL (IMPORTED_DECL_CHECK (NODE)))
<span class="lineNum">    3067 </span>            : 
<span class="lineNum">    3068 </span>            : /* Getter of the symbol declaration associated with the
<span class="lineNum">    3069 </span>            :    NAMELIST_DECL node.  */
<span class="lineNum">    3070 </span>            : #define NAMELIST_DECL_ASSOCIATED_DECL(NODE) \
<span class="lineNum">    3071 </span>            :   (DECL_INITIAL (NODE))
<span class="lineNum">    3072 </span>            : 
<span class="lineNum">    3073 </span>            : /* A STATEMENT_LIST chains statements together in GENERIC and GIMPLE.
<span class="lineNum">    3074 </span>            :    To reduce overhead, the nodes containing the statements are not trees.
<span class="lineNum">    3075 </span>            :    This avoids the overhead of tree_common on all linked list elements.
<span class="lineNum">    3076 </span>            : 
<span class="lineNum">    3077 </span>            :    Use the interface in tree-iterator.h to access this node.  */
<span class="lineNum">    3078 </span>            : 
<span class="lineNum">    3079 </span>            : #define STATEMENT_LIST_HEAD(NODE) \
<span class="lineNum">    3080 </span>            :   (STATEMENT_LIST_CHECK (NODE)-&gt;stmt_list.head)
<span class="lineNum">    3081 </span>            : #define STATEMENT_LIST_TAIL(NODE) \
<span class="lineNum">    3082 </span>            :   (STATEMENT_LIST_CHECK (NODE)-&gt;stmt_list.tail)
<span class="lineNum">    3083 </span>            : 
<span class="lineNum">    3084 </span>            : #define TREE_OPTIMIZATION(NODE) \
<span class="lineNum">    3085 </span>            :   (OPTIMIZATION_NODE_CHECK (NODE)-&gt;optimization.opts)
<span class="lineNum">    3086 </span>            : 
<span class="lineNum">    3087 </span>            : #define TREE_OPTIMIZATION_OPTABS(NODE) \
<span class="lineNum">    3088 </span>            :   (OPTIMIZATION_NODE_CHECK (NODE)-&gt;optimization.optabs)
<span class="lineNum">    3089 </span>            : 
<span class="lineNum">    3090 </span>            : #define TREE_OPTIMIZATION_BASE_OPTABS(NODE) \
<span class="lineNum">    3091 </span>            :   (OPTIMIZATION_NODE_CHECK (NODE)-&gt;optimization.base_optabs)
<span class="lineNum">    3092 </span>            : 
<span class="lineNum">    3093 </span>            : /* Return a tree node that encapsulates the optimization options in OPTS.  */
<span class="lineNum">    3094 </span>            : extern tree build_optimization_node (struct gcc_options *opts);
<span class="lineNum">    3095 </span>            : 
<span class="lineNum">    3096 </span>            : #define TREE_TARGET_OPTION(NODE) \
<span class="lineNum">    3097 </span>            :   (TARGET_OPTION_NODE_CHECK (NODE)-&gt;target_option.opts)
<span class="lineNum">    3098 </span>            : 
<span class="lineNum">    3099 </span>            : #define TREE_TARGET_GLOBALS(NODE) \
<span class="lineNum">    3100 </span>            :   (TARGET_OPTION_NODE_CHECK (NODE)-&gt;target_option.globals)
<span class="lineNum">    3101 </span>            : 
<span class="lineNum">    3102 </span>            : /* Return a tree node that encapsulates the target options in OPTS.  */
<span class="lineNum">    3103 </span>            : extern tree build_target_option_node (struct gcc_options *opts);
<span class="lineNum">    3104 </span>            : 
<span class="lineNum">    3105 </span>            : extern void prepare_target_option_nodes_for_pch (void);
<span class="lineNum">    3106 </span>            : 
<span class="lineNum">    3107 </span>            : #if defined ENABLE_TREE_CHECKING &amp;&amp; (GCC_VERSION &gt;= 2007)
<a name="3108"><span class="lineNum">    3108 </span>            : </a>
<span class="lineNum">    3109 </span>            : inline tree
<span class="lineNum">    3110 </span><span class="lineCov">   70631048 : tree_check (tree __t, const char *__f, int __l, const char *__g, tree_code __c)</span>
<span class="lineNum">    3111 </span>            : {
<span class="lineNum">    3112 </span><span class="lineCov">>10686*10^7 :   if (TREE_CODE (__t) != __c)</span>
<span class="lineNum">    3113 </span><span class="lineNoCov">          0 :     tree_check_failed (__t, __f, __l, __g, __c, 0);</span>
<span class="lineNum">    3114 </span><span class="lineCov">>18606*10^7 :   return __t;</span>
<span class="lineNum">    3115 </span>            : }
<span class="lineNum">    3116 </span>            : 
<span class="lineNum">    3117 </span>            : inline tree
<span class="lineNum">    3118 </span>            : tree_not_check (tree __t, const char *__f, int __l, const char *__g,
<span class="lineNum">    3119 </span>            :                 enum tree_code __c)
<span class="lineNum">    3120 </span>            : {
<span class="lineNum">    3121 </span>            :   if (TREE_CODE (__t) == __c)
<span class="lineNum">    3122 </span>            :     tree_not_check_failed (__t, __f, __l, __g, __c, 0);
<span class="lineNum">    3123 </span>            :   return __t;
<span class="lineNum">    3124 </span>            : }
<a name="3125"><span class="lineNum">    3125 </span>            : </a>
<span class="lineNum">    3126 </span>            : inline tree
<span class="lineNum">    3127 </span><span class="lineCov">    5386253 : tree_check2 (tree __t, const char *__f, int __l, const char *__g,</span>
<span class="lineNum">    3128 </span>            :              enum tree_code __c1, enum tree_code __c2)
<span class="lineNum">    3129 </span>            : {
<span class="lineNum">    3130 </span><span class="lineCov"> 3791691177 :   if (TREE_CODE (__t) != __c1</span>
<span class="lineNum">    3131 </span><span class="lineCov"> 1832591114 :       &amp;&amp; TREE_CODE (__t) != __c2)</span>
<span class="lineNum">    3132 </span><span class="lineNoCov">          0 :     tree_check_failed (__t, __f, __l, __g, __c1, __c2, 0);</span>
<span class="lineNum">    3133 </span><span class="lineCov"> 3944620070 :   return __t;</span>
<span class="lineNum">    3134 </span>            : }
<span class="lineNum">    3135 </span>            : 
<span class="lineNum">    3136 </span>            : inline tree
<span class="lineNum">    3137 </span>            : tree_not_check2 (tree __t, const char *__f, int __l, const char *__g,
<span class="lineNum">    3138 </span>            :                  enum tree_code __c1, enum tree_code __c2)
<span class="lineNum">    3139 </span>            : {
<span class="lineNum">    3140 </span><span class="lineCov"> 1726829916 :   if (TREE_CODE (__t) == __c1</span>
<span class="lineNum">    3141 </span><span class="lineCov"> 1506532340 :       || TREE_CODE (__t) == __c2)</span>
<span class="lineNum">    3142 </span><span class="lineNoCov">          0 :     tree_not_check_failed (__t, __f, __l, __g, __c1, __c2, 0);</span>
<span class="lineNum">    3143 </span><span class="lineCov"> 9334642120 :   return __t;</span>
<span class="lineNum">    3144 </span>            : }
<a name="3145"><span class="lineNum">    3145 </span>            : </a>
<span class="lineNum">    3146 </span>            : inline tree
<span class="lineNum">    3147 </span><span class="lineCov">    1859635 : tree_check3 (tree __t, const char *__f, int __l, const char *__g,</span>
<span class="lineNum">    3148 </span>            :              enum tree_code __c1, enum tree_code __c2, enum tree_code __c3)
<span class="lineNum">    3149 </span>            : {
<span class="lineNum">    3150 </span><span class="lineCov"> 7819812245 :   if (TREE_CODE (__t) != __c1</span>
<span class="lineNum">    3151 </span><span class="lineCov">  849678934 :       &amp;&amp; TREE_CODE (__t) != __c2</span>
<span class="lineNum">    3152 </span><span class="lineCov">  609296310 :       &amp;&amp; TREE_CODE (__t) != __c3)</span>
<span class="lineNum">    3153 </span><span class="lineNoCov">          0 :     tree_check_failed (__t, __f, __l, __g, __c1, __c2, __c3, 0);</span>
<span class="lineNum">    3154 </span><span class="lineCov"> 8817571074 :   return __t;</span>
<span class="lineNum">    3155 </span>            : }
<span class="lineNum">    3156 </span>            : 
<span class="lineNum">    3157 </span>            : inline tree
<span class="lineNum">    3158 </span>            : tree_not_check3 (tree __t, const char *__f, int __l, const char *__g,
<span class="lineNum">    3159 </span>            :                  enum tree_code __c1, enum tree_code __c2, enum tree_code __c3)
<span class="lineNum">    3160 </span>            : {
<span class="lineNum">    3161 </span>            :   if (TREE_CODE (__t) == __c1
<span class="lineNum">    3162 </span>            :       || TREE_CODE (__t) == __c2
<span class="lineNum">    3163 </span>            :       || TREE_CODE (__t) == __c3)
<span class="lineNum">    3164 </span>            :     tree_not_check_failed (__t, __f, __l, __g, __c1, __c2, __c3, 0);
<span class="lineNum">    3165 </span>            :   return __t;
<span class="lineNum">    3166 </span>            : }
<a name="3167"><span class="lineNum">    3167 </span>            : </a>
<span class="lineNum">    3168 </span>            : inline tree
<span class="lineNum">    3169 </span><span class="lineCov"> 1281061837 : tree_check4 (tree __t, const char *__f, int __l, const char *__g,</span>
<span class="lineNum">    3170 </span>            :              enum tree_code __c1, enum tree_code __c2, enum tree_code __c3,
<span class="lineNum">    3171 </span>            :              enum tree_code __c4)
<span class="lineNum">    3172 </span>            : {
<span class="lineNum">    3173 </span><span class="lineCov"> 1281061837 :   if (TREE_CODE (__t) != __c1</span>
<span class="lineNum">    3174 </span><span class="lineCov">  302384634 :       &amp;&amp; TREE_CODE (__t) != __c2</span>
<span class="lineNum">    3175 </span><span class="lineCov">  271667694 :       &amp;&amp; TREE_CODE (__t) != __c3</span>
<span class="lineNum">    3176 </span><span class="lineCov">  261555006 :       &amp;&amp; TREE_CODE (__t) != __c4)</span>
<span class="lineNum">    3177 </span><span class="lineNoCov">          0 :     tree_check_failed (__t, __f, __l, __g, __c1, __c2, __c3, __c4, 0);</span>
<span class="lineNum">    3178 </span><span class="lineCov"> 1281061837 :   return __t;</span>
<span class="lineNum">    3179 </span>            : }
<a name="3180"><span class="lineNum">    3180 </span>            : </a>
<span class="lineNum">    3181 </span>            : inline tree
<span class="lineNum">    3182 </span><span class="lineCov">  243137604 : tree_not_check4 (tree __t, const char *__f, int __l, const char *__g,</span>
<span class="lineNum">    3183 </span>            :                  enum tree_code __c1, enum tree_code __c2, enum tree_code __c3,
<span class="lineNum">    3184 </span>            :                  enum tree_code __c4)
<span class="lineNum">    3185 </span>            : {
<span class="lineNum">    3186 </span><span class="lineCov">  243137604 :   if (TREE_CODE (__t) == __c1</span>
<span class="lineNum">    3187 </span><span class="lineCov">  243137604 :       || TREE_CODE (__t) == __c2</span>
<span class="lineNum">    3188 </span><span class="lineCov">  243137604 :       || TREE_CODE (__t) == __c3</span>
<span class="lineNum">    3189 </span><span class="lineCov">  243137604 :       || TREE_CODE (__t) == __c4)</span>
<span class="lineNum">    3190 </span><span class="lineNoCov">          0 :     tree_not_check_failed (__t, __f, __l, __g, __c1, __c2, __c3, __c4, 0);</span>
<span class="lineNum">    3191 </span><span class="lineCov">  243137604 :   return __t;</span>
<span class="lineNum">    3192 </span>            : }
<a name="3193"><span class="lineNum">    3193 </span>            : </a>
<span class="lineNum">    3194 </span>            : inline tree
<span class="lineNum">    3195 </span><span class="lineCov"> 3699088859 : tree_check5 (tree __t, const char *__f, int __l, const char *__g,</span>
<span class="lineNum">    3196 </span>            :              enum tree_code __c1, enum tree_code __c2, enum tree_code __c3,
<span class="lineNum">    3197 </span>            :              enum tree_code __c4, enum tree_code __c5)
<span class="lineNum">    3198 </span>            : {
<span class="lineNum">    3199 </span><span class="lineCov"> 3699088859 :   if (TREE_CODE (__t) != __c1</span>
<span class="lineNum">    3200 </span><span class="lineCov"> 1831558613 :       &amp;&amp; TREE_CODE (__t) != __c2</span>
<span class="lineNum">    3201 </span><span class="lineCov"> 1411385684 :       &amp;&amp; TREE_CODE (__t) != __c3</span>
<span class="lineNum">    3202 </span><span class="lineCov">  619080679 :       &amp;&amp; TREE_CODE (__t) != __c4</span>
<span class="lineNum">    3203 </span><span class="lineCov">  401693383 :       &amp;&amp; TREE_CODE (__t) != __c5)</span>
<span class="lineNum">    3204 </span><span class="lineNoCov">          0 :     tree_check_failed (__t, __f, __l, __g, __c1, __c2, __c3, __c4, __c5, 0);</span>
<span class="lineNum">    3205 </span><span class="lineCov"> 3699088859 :   return __t;</span>
<span class="lineNum">    3206 </span>            : }
<span class="lineNum">    3207 </span>            : 
<span class="lineNum">    3208 </span>            : inline tree
<span class="lineNum">    3209 </span>            : tree_not_check5 (tree __t, const char *__f, int __l, const char *__g,
<span class="lineNum">    3210 </span>            :                  enum tree_code __c1, enum tree_code __c2, enum tree_code __c3,
<span class="lineNum">    3211 </span>            :                  enum tree_code __c4, enum tree_code __c5)
<span class="lineNum">    3212 </span>            : {
<span class="lineNum">    3213 </span>            :   if (TREE_CODE (__t) == __c1
<span class="lineNum">    3214 </span>            :       || TREE_CODE (__t) == __c2
<span class="lineNum">    3215 </span>            :       || TREE_CODE (__t) == __c3
<span class="lineNum">    3216 </span>            :       || TREE_CODE (__t) == __c4
<span class="lineNum">    3217 </span>            :       || TREE_CODE (__t) == __c5)
<span class="lineNum">    3218 </span>            :     tree_not_check_failed (__t, __f, __l, __g, __c1, __c2, __c3, __c4, __c5, 0);
<span class="lineNum">    3219 </span>            :   return __t;
<span class="lineNum">    3220 </span>            : }
<a name="3221"><span class="lineNum">    3221 </span>            : </a>
<span class="lineNum">    3222 </span>            : inline tree
<span class="lineNum">    3223 </span><span class="lineCov"> 2041027830 : contains_struct_check (tree __t, const enum tree_node_structure_enum __s,</span>
<span class="lineNum">    3224 </span>            :                        const char *__f, int __l, const char *__g)
<span class="lineNum">    3225 </span>            : {
<span class="lineNum">    3226 </span><span class="lineCov">>16554*10^7 :   if (tree_contains_struct[TREE_CODE (__t)][__s] != 1)</span>
<span class="lineNum">    3227 </span><span class="lineNoCov">          0 :       tree_contains_struct_check_failed (__t, __s, __f, __l, __g);</span>
<span class="lineNum">    3228 </span><span class="lineCov">>17924*10^7 :   return __t;</span>
<span class="lineNum">    3229 </span>            : }
<a name="3230"><span class="lineNum">    3230 </span>            : </a>
<span class="lineNum">    3231 </span>            : inline tree
<span class="lineNum">    3232 </span><span class="lineCov"> 2494055615 : tree_class_check (tree __t, const enum tree_code_class __class,</span>
<span class="lineNum">    3233 </span>            :                   const char *__f, int __l, const char *__g)
<span class="lineNum">    3234 </span>            : {
<span class="lineNum">    3235 </span><span class="lineCov">82198803230 :   if (TREE_CODE_CLASS (TREE_CODE (__t)) != __class)</span>
<span class="lineNum">    3236 </span><span class="lineNoCov">          0 :     tree_class_check_failed (__t, __class, __f, __l, __g);</span>
<span class="lineNum">    3237 </span><span class="lineCov">>10243*10^7 :   return __t;</span>
<span class="lineNum">    3238 </span>            : }
<span class="lineNum">    3239 </span>            : 
<span class="lineNum">    3240 </span>            : inline tree
<span class="lineNum">    3241 </span>            : tree_range_check (tree __t,
<span class="lineNum">    3242 </span>            :                   enum tree_code __code1, enum tree_code __code2,
<span class="lineNum">    3243 </span>            :                   const char *__f, int __l, const char *__g)
<span class="lineNum">    3244 </span>            : {
<span class="lineNum">    3245 </span><span class="lineCov">    1018022 :   if (TREE_CODE (__t) &lt; __code1 || TREE_CODE (__t) &gt; __code2)</span>
<span class="lineNum">    3246 </span><span class="lineNoCov">          0 :     tree_range_check_failed (__t, __f, __l, __g, __code1, __code2);</span>
<span class="lineNum">    3247 </span><span class="lineCov">    1276610 :   return __t;</span>
<span class="lineNum">    3248 </span>            : }
<a name="3249"><span class="lineNum">    3249 </span>            : </a>
<span class="lineNum">    3250 </span>            : inline tree
<span class="lineNum">    3251 </span><span class="lineCov">    1441763 : omp_clause_subcode_check (tree __t, enum omp_clause_code __code,</span>
<span class="lineNum">    3252 </span>            :                           const char *__f, int __l, const char *__g)
<span class="lineNum">    3253 </span>            : {
<span class="lineNum">    3254 </span><span class="lineCov">    1441763 :   if (TREE_CODE (__t) != OMP_CLAUSE)</span>
<span class="lineNum">    3255 </span><span class="lineNoCov">          0 :     tree_check_failed (__t, __f, __l, __g, OMP_CLAUSE, 0);</span>
<span class="lineNum">    3256 </span><span class="lineCov">    1441763 :   if (__t-&gt;omp_clause.code != __code)</span>
<span class="lineNum">    3257 </span><span class="lineNoCov">          0 :     omp_clause_check_failed (__t, __f, __l, __g, __code);</span>
<span class="lineNum">    3258 </span><span class="lineCov">    1441763 :   return __t;</span>
<span class="lineNum">    3259 </span>            : }
<a name="3260"><span class="lineNum">    3260 </span>            : </a>
<span class="lineNum">    3261 </span>            : inline tree
<span class="lineNum">    3262 </span><span class="lineCov">    1472107 : omp_clause_range_check (tree __t,</span>
<span class="lineNum">    3263 </span>            :                         enum omp_clause_code __code1,
<span class="lineNum">    3264 </span>            :                         enum omp_clause_code __code2,
<span class="lineNum">    3265 </span>            :                         const char *__f, int __l, const char *__g)
<span class="lineNum">    3266 </span>            : {
<span class="lineNum">    3267 </span><span class="lineCov">    1472107 :   if (TREE_CODE (__t) != OMP_CLAUSE)</span>
<span class="lineNum">    3268 </span><span class="lineNoCov">          0 :     tree_check_failed (__t, __f, __l, __g, OMP_CLAUSE, 0);</span>
<span class="lineNum">    3269 </span><span class="lineCov">    1472107 :   if ((int) __t-&gt;omp_clause.code &lt; (int) __code1</span>
<span class="lineNum">    3270 </span><span class="lineCov">    1472107 :       || (int) __t-&gt;omp_clause.code &gt; (int) __code2)</span>
<span class="lineNum">    3271 </span><span class="lineNoCov">          0 :     omp_clause_range_check_failed (__t, __f, __l, __g, __code1, __code2);</span>
<span class="lineNum">    3272 </span><span class="lineCov">    1472107 :   return __t;</span>
<span class="lineNum">    3273 </span>            : }
<span class="lineNum">    3274 </span>            : 
<span class="lineNum">    3275 </span>            : /* These checks have to be special cased.  */
<span class="lineNum">    3276 </span>            : 
<span class="lineNum">    3277 </span>            : inline tree
<span class="lineNum">    3278 </span>            : expr_check (tree __t, const char *__f, int __l, const char *__g)
<span class="lineNum">    3279 </span>            : {
<span class="lineNum">    3280 </span><span class="lineCov">55086230766 :   char const __c = TREE_CODE_CLASS (TREE_CODE (__t));</span>
<span class="lineNum">    3281 </span><span class="lineCov">20583072033 :   if (!IS_EXPR_CODE_CLASS (__c))</span>
<span class="lineNum">    3282 </span><span class="lineNoCov">          0 :     tree_class_check_failed (__t, tcc_expression, __f, __l, __g);</span>
<span class="lineNum">    3283 </span><span class="lineCov">20590516223 :   return __t;</span>
<span class="lineNum">    3284 </span>            : }
<span class="lineNum">    3285 </span>            : 
<span class="lineNum">    3286 </span>            : /* These checks have to be special cased.  */
<a name="3287"><span class="lineNum">    3287 </span>            : </a>
<span class="lineNum">    3288 </span>            : inline tree
<span class="lineNum">    3289 </span><span class="lineCov">    2801950 : non_type_check (tree __t, const char *__f, int __l, const char *__g)</span>
<span class="lineNum">    3290 </span>            : {
<span class="lineNum">    3291 </span><span class="lineCov"> 7152716659 :   if (TYPE_P (__t))</span>
<span class="lineNum">    3292 </span><span class="lineNoCov">          0 :     tree_not_class_check_failed (__t, tcc_type, __f, __l, __g);</span>
<span class="lineNum">    3293 </span><span class="lineCov"> 9061741792 :   return __t;</span>
<span class="lineNum">    3294 </span>            : }
<a name="3295"><span class="lineNum">    3295 </span>            : </a>
<span class="lineNum">    3296 </span>            : inline const HOST_WIDE_INT *
<span class="lineNum">    3297 </span><span class="lineCov">16839660981 : tree_int_cst_elt_check (const_tree __t, int __i,</span>
<span class="lineNum">    3298 </span>            :                         const char *__f, int __l, const char *__g)
<span class="lineNum">    3299 </span>            : {
<span class="lineNum">    3300 </span><span class="lineCov">16839660981 :   if (TREE_CODE (__t) != INTEGER_CST)</span>
<span class="lineNum">    3301 </span><span class="lineNoCov">          0 :     tree_check_failed (__t, __f, __l, __g, INTEGER_CST, 0);</span>
<span class="lineNum">    3302 </span><span class="lineCov">16839660981 :   if (__i &lt; 0 || __i &gt;= __t-&gt;base.u.int_length.extended)</span>
<span class="lineNum">    3303 </span><span class="lineNoCov">          0 :     tree_int_cst_elt_check_failed (__i, __t-&gt;base.u.int_length.extended,</span>
<span class="lineNum">    3304 </span>            :                                    __f, __l, __g);
<span class="lineNum">    3305 </span><span class="lineCov">16839660981 :   return &amp;CONST_CAST_TREE (__t)-&gt;int_cst.val[__i];</span>
<span class="lineNum">    3306 </span>            : }
<a name="3307"><span class="lineNum">    3307 </span>            : </a>
<span class="lineNum">    3308 </span>            : inline HOST_WIDE_INT *
<span class="lineNum">    3309 </span><span class="lineCov"> 4933074036 : tree_int_cst_elt_check (tree __t, int __i,</span>
<span class="lineNum">    3310 </span>            :                         const char *__f, int __l, const char *__g)
<span class="lineNum">    3311 </span>            : {
<span class="lineNum">    3312 </span><span class="lineCov"> 4933074036 :   if (TREE_CODE (__t) != INTEGER_CST)</span>
<span class="lineNum">    3313 </span><span class="lineNoCov">          0 :     tree_check_failed (__t, __f, __l, __g, INTEGER_CST, 0);</span>
<span class="lineNum">    3314 </span><span class="lineCov"> 4933074036 :   if (__i &lt; 0 || __i &gt;= __t-&gt;base.u.int_length.extended)</span>
<span class="lineNum">    3315 </span><span class="lineNoCov">          0 :     tree_int_cst_elt_check_failed (__i, __t-&gt;base.u.int_length.extended,</span>
<span class="lineNum">    3316 </span>            :                                    __f, __l, __g);
<span class="lineNum">    3317 </span><span class="lineCov"> 4933074036 :   return &amp;CONST_CAST_TREE (__t)-&gt;int_cst.val[__i];</span>
<span class="lineNum">    3318 </span>            : }
<span class="lineNum">    3319 </span>            : 
<span class="lineNum">    3320 </span>            : /* Workaround -Wstrict-overflow false positive during profiledbootstrap.  */
<span class="lineNum">    3321 </span>            : 
<span class="lineNum">    3322 </span>            : # if GCC_VERSION &gt;= 4006
<span class="lineNum">    3323 </span>            : #pragma GCC diagnostic push
<span class="lineNum">    3324 </span>            : #pragma GCC diagnostic ignored &quot;-Wstrict-overflow&quot;
<span class="lineNum">    3325 </span>            : #endif
<a name="3326"><span class="lineNum">    3326 </span>            : </a>
<span class="lineNum">    3327 </span>            : inline tree *
<span class="lineNum">    3328 </span><span class="lineCov">13103060016 : tree_vec_elt_check (tree __t, int __i,</span>
<span class="lineNum">    3329 </span>            :                     const char *__f, int __l, const char *__g)
<span class="lineNum">    3330 </span>            : {
<span class="lineNum">    3331 </span><span class="lineCov">13103060016 :   if (TREE_CODE (__t) != TREE_VEC)</span>
<span class="lineNum">    3332 </span><span class="lineNoCov">          0 :     tree_check_failed (__t, __f, __l, __g, TREE_VEC, 0);</span>
<span class="lineNum">    3333 </span><span class="lineCov">13103060016 :   if (__i &lt; 0 || __i &gt;= __t-&gt;base.u.length)</span>
<span class="lineNum">    3334 </span><span class="lineNoCov">          0 :     tree_vec_elt_check_failed (__i, __t-&gt;base.u.length, __f, __l, __g);</span>
<span class="lineNum">    3335 </span><span class="lineCov">13103060016 :   return &amp;CONST_CAST_TREE (__t)-&gt;vec.a[__i];</span>
<span class="lineNum">    3336 </span>            : }
<span class="lineNum">    3337 </span>            : 
<span class="lineNum">    3338 </span>            : # if GCC_VERSION &gt;= 4006
<span class="lineNum">    3339 </span>            : #pragma GCC diagnostic pop
<span class="lineNum">    3340 </span>            : #endif
<a name="3341"><span class="lineNum">    3341 </span>            : </a>
<span class="lineNum">    3342 </span>            : inline tree *
<span class="lineNum">    3343 </span><span class="lineCov">    2385880 : omp_clause_elt_check (tree __t, int __i,</span>
<span class="lineNum">    3344 </span>            :                       const char *__f, int __l, const char *__g)
<span class="lineNum">    3345 </span>            : {
<span class="lineNum">    3346 </span><span class="lineCov">    2385880 :   if (TREE_CODE (__t) != OMP_CLAUSE)</span>
<span class="lineNum">    3347 </span><span class="lineNoCov">          0 :     tree_check_failed (__t, __f, __l, __g, OMP_CLAUSE, 0);</span>
<span class="lineNum">    3348 </span><span class="lineCov">    2385880 :   if (__i &lt; 0 || __i &gt;= omp_clause_num_ops [__t-&gt;omp_clause.code])</span>
<span class="lineNum">    3349 </span><span class="lineNoCov">          0 :     omp_clause_operand_check_failed (__i, __t, __f, __l, __g);</span>
<span class="lineNum">    3350 </span><span class="lineCov">    2385880 :   return &amp;__t-&gt;omp_clause.ops[__i];</span>
<span class="lineNum">    3351 </span>            : }
<span class="lineNum">    3352 </span>            : 
<span class="lineNum">    3353 </span>            : /* These checks have to be special cased.  */
<a name="3354"><span class="lineNum">    3354 </span>            : </a>
<span class="lineNum">    3355 </span>            : inline tree
<span class="lineNum">    3356 </span><span class="lineCov"> 2169130052 : any_integral_type_check (tree __t, const char *__f, int __l, const char *__g)</span>
<span class="lineNum">    3357 </span>            : {
<span class="lineNum">    3358 </span><span class="lineCov"> 2169130052 :   if (!ANY_INTEGRAL_TYPE_P (__t))</span>
<span class="lineNum">    3359 </span><span class="lineNoCov">          0 :     tree_check_failed (__t, __f, __l, __g, BOOLEAN_TYPE, ENUMERAL_TYPE,</span>
<span class="lineNum">    3360 </span>            :                        INTEGER_TYPE, 0);
<span class="lineNum">    3361 </span><span class="lineCov"> 2169130052 :   return __t;</span>
<span class="lineNum">    3362 </span>            : }
<a name="3363"><span class="lineNum">    3363 </span>            : </a>
<span class="lineNum">    3364 </span>            : inline const_tree
<span class="lineNum">    3365 </span><span class="lineCov">       2815 : tree_check (const_tree __t, const char *__f, int __l, const char *__g,</span>
<span class="lineNum">    3366 </span>            :             tree_code __c)
<span class="lineNum">    3367 </span>            : {
<span class="lineNum">    3368 </span><span class="lineCov">22408062275 :   if (TREE_CODE (__t) != __c)</span>
<span class="lineNum">    3369 </span><span class="lineNoCov">          0 :     tree_check_failed (__t, __f, __l, __g, __c, 0);</span>
<span class="lineNum">    3370 </span><span class="lineCov">34714277077 :   return __t;</span>
<span class="lineNum">    3371 </span>            : }
<span class="lineNum">    3372 </span>            : 
<span class="lineNum">    3373 </span>            : inline const_tree
<span class="lineNum">    3374 </span>            : tree_not_check (const_tree __t, const char *__f, int __l, const char *__g,
<span class="lineNum">    3375 </span>            :                 enum tree_code __c)
<span class="lineNum">    3376 </span>            : {
<span class="lineNum">    3377 </span>            :   if (TREE_CODE (__t) == __c)
<span class="lineNum">    3378 </span>            :     tree_not_check_failed (__t, __f, __l, __g, __c, 0);
<span class="lineNum">    3379 </span>            :   return __t;
<span class="lineNum">    3380 </span>            : }
<span class="lineNum">    3381 </span>            : 
<span class="lineNum">    3382 </span>            : inline const_tree
<span class="lineNum">    3383 </span>            : tree_check2 (const_tree __t, const char *__f, int __l, const char *__g,
<span class="lineNum">    3384 </span>            :              enum tree_code __c1, enum tree_code __c2)
<span class="lineNum">    3385 </span>            : {
<span class="lineNum">    3386 </span><span class="lineCov"> 1063655469 :   if (TREE_CODE (__t) != __c1</span>
<span class="lineNum">    3387 </span><span class="lineCov">  279218527 :       &amp;&amp; TREE_CODE (__t) != __c2)</span>
<span class="lineNum">    3388 </span><span class="lineNoCov">          0 :     tree_check_failed (__t, __f, __l, __g, __c1, __c2, 0);</span>
<span class="lineNum">    3389 </span><span class="lineCov"> 1165352029 :   return __t;</span>
<span class="lineNum">    3390 </span>            : }
<span class="lineNum">    3391 </span>            : 
<span class="lineNum">    3392 </span>            : inline const_tree
<span class="lineNum">    3393 </span>            : tree_not_check2 (const_tree __t, const char *__f, int __l, const char *__g,
<span class="lineNum">    3394 </span>            :                  enum tree_code __c1, enum tree_code __c2)
<span class="lineNum">    3395 </span>            : {
<span class="lineNum">    3396 </span><span class="lineCov">  326542839 :   if (TREE_CODE (__t) == __c1</span>
<span class="lineNum">    3397 </span>            :       || TREE_CODE (__t) == __c2)
<span class="lineNum">    3398 </span>            :     tree_not_check_failed (__t, __f, __l, __g, __c1, __c2, 0);
<span class="lineNum">    3399 </span><span class="lineCov">  325229196 :   return __t;</span>
<span class="lineNum">    3400 </span>            : }
<a name="3401"><span class="lineNum">    3401 </span>            : </a>
<span class="lineNum">    3402 </span>            : inline const_tree
<span class="lineNum">    3403 </span><span class="lineCov">    5352291 : tree_check3 (const_tree __t, const char *__f, int __l, const char *__g,</span>
<span class="lineNum">    3404 </span>            :              enum tree_code __c1, enum tree_code __c2, enum tree_code __c3)
<span class="lineNum">    3405 </span>            : {
<span class="lineNum">    3406 </span><span class="lineCov">  998701134 :   if (TREE_CODE (__t) != __c1</span>
<span class="lineNum">    3407 </span><span class="lineCov">   54715672 :       &amp;&amp; TREE_CODE (__t) != __c2</span>
<span class="lineNum">    3408 </span><span class="lineCov">   35179489 :       &amp;&amp; TREE_CODE (__t) != __c3)</span>
<span class="lineNum">    3409 </span><span class="lineNoCov">          0 :     tree_check_failed (__t, __f, __l, __g, __c1, __c2, __c3, 0);</span>
<span class="lineNum">    3410 </span><span class="lineCov"> 1252209059 :   return __t;</span>
<span class="lineNum">    3411 </span>            : }
<span class="lineNum">    3412 </span>            : 
<span class="lineNum">    3413 </span>            : inline const_tree
<span class="lineNum">    3414 </span>            : tree_not_check3 (const_tree __t, const char *__f, int __l, const char *__g,
<span class="lineNum">    3415 </span>            :                  enum tree_code __c1, enum tree_code __c2, enum tree_code __c3)
<span class="lineNum">    3416 </span>            : {
<span class="lineNum">    3417 </span>            :   if (TREE_CODE (__t) == __c1
<span class="lineNum">    3418 </span>            :       || TREE_CODE (__t) == __c2
<span class="lineNum">    3419 </span>            :       || TREE_CODE (__t) == __c3)
<span class="lineNum">    3420 </span>            :     tree_not_check_failed (__t, __f, __l, __g, __c1, __c2, __c3, 0);
<span class="lineNum">    3421 </span>            :   return __t;
<span class="lineNum">    3422 </span>            : }
<a name="3423"><span class="lineNum">    3423 </span>            : </a>
<span class="lineNum">    3424 </span>            : inline const_tree
<span class="lineNum">    3425 </span><span class="lineCov">   47285538 : tree_check4 (const_tree __t, const char *__f, int __l, const char *__g,</span>
<span class="lineNum">    3426 </span>            :              enum tree_code __c1, enum tree_code __c2, enum tree_code __c3,
<span class="lineNum">    3427 </span>            :              enum tree_code __c4)
<span class="lineNum">    3428 </span>            : {
<span class="lineNum">    3429 </span><span class="lineCov">   47285538 :   if (TREE_CODE (__t) != __c1</span>
<span class="lineNum">    3430 </span><span class="lineCov">     822282 :       &amp;&amp; TREE_CODE (__t) != __c2</span>
<span class="lineNum">    3431 </span><span class="lineCov">     527545 :       &amp;&amp; TREE_CODE (__t) != __c3</span>
<span class="lineNum">    3432 </span><span class="lineCov">     527545 :       &amp;&amp; TREE_CODE (__t) != __c4)</span>
<span class="lineNum">    3433 </span><span class="lineNoCov">          0 :     tree_check_failed (__t, __f, __l, __g, __c1, __c2, __c3, __c4, 0);</span>
<span class="lineNum">    3434 </span><span class="lineCov">   47285538 :   return __t;</span>
<span class="lineNum">    3435 </span>            : }
<a name="3436"><span class="lineNum">    3436 </span>            : </a>
<span class="lineNum">    3437 </span>            : inline const_tree
<span class="lineNum">    3438 </span><span class="lineCov">   10222873 : tree_not_check4 (const_tree __t, const char *__f, int __l, const char *__g,</span>
<span class="lineNum">    3439 </span>            :                  enum tree_code __c1, enum tree_code __c2, enum tree_code __c3,
<span class="lineNum">    3440 </span>            :                  enum tree_code __c4)
<span class="lineNum">    3441 </span>            : {
<span class="lineNum">    3442 </span><span class="lineCov">   10222873 :   if (TREE_CODE (__t) == __c1</span>
<span class="lineNum">    3443 </span><span class="lineCov">   10222873 :       || TREE_CODE (__t) == __c2</span>
<span class="lineNum">    3444 </span><span class="lineCov">   10222873 :       || TREE_CODE (__t) == __c3</span>
<span class="lineNum">    3445 </span><span class="lineCov">   10222873 :       || TREE_CODE (__t) == __c4)</span>
<span class="lineNum">    3446 </span><span class="lineNoCov">          0 :     tree_not_check_failed (__t, __f, __l, __g, __c1, __c2, __c3, __c4, 0);</span>
<span class="lineNum">    3447 </span><span class="lineCov">   10222873 :   return __t;</span>
<span class="lineNum">    3448 </span>            : }
<a name="3449"><span class="lineNum">    3449 </span>            : </a>
<span class="lineNum">    3450 </span>            : inline const_tree
<span class="lineNum">    3451 </span><span class="lineCov">  359443488 : tree_check5 (const_tree __t, const char *__f, int __l, const char *__g,</span>
<span class="lineNum">    3452 </span>            :              enum tree_code __c1, enum tree_code __c2, enum tree_code __c3,
<span class="lineNum">    3453 </span>            :              enum tree_code __c4, enum tree_code __c5)
<span class="lineNum">    3454 </span>            : {
<span class="lineNum">    3455 </span><span class="lineCov">  359443488 :   if (TREE_CODE (__t) != __c1</span>
<span class="lineNum">    3456 </span><span class="lineCov">  159050301 :       &amp;&amp; TREE_CODE (__t) != __c2</span>
<span class="lineNum">    3457 </span><span class="lineCov">  157410917 :       &amp;&amp; TREE_CODE (__t) != __c3</span>
<span class="lineNum">    3458 </span><span class="lineCov">     250466 :       &amp;&amp; TREE_CODE (__t) != __c4</span>
<span class="lineNum">    3459 </span><span class="lineNoCov">          0 :       &amp;&amp; TREE_CODE (__t) != __c5)</span>
<span class="lineNum">    3460 </span><span class="lineNoCov">          0 :     tree_check_failed (__t, __f, __l, __g, __c1, __c2, __c3, __c4, __c5, 0);</span>
<span class="lineNum">    3461 </span><span class="lineCov">  359443488 :   return __t;</span>
<span class="lineNum">    3462 </span>            : }
<span class="lineNum">    3463 </span>            : 
<span class="lineNum">    3464 </span>            : inline const_tree
<span class="lineNum">    3465 </span>            : tree_not_check5 (const_tree __t, const char *__f, int __l, const char *__g,
<span class="lineNum">    3466 </span>            :                  enum tree_code __c1, enum tree_code __c2, enum tree_code __c3,
<span class="lineNum">    3467 </span>            :                  enum tree_code __c4, enum tree_code __c5)
<span class="lineNum">    3468 </span>            : {
<span class="lineNum">    3469 </span>            :   if (TREE_CODE (__t) == __c1
<span class="lineNum">    3470 </span>            :       || TREE_CODE (__t) == __c2
<span class="lineNum">    3471 </span>            :       || TREE_CODE (__t) == __c3
<span class="lineNum">    3472 </span>            :       || TREE_CODE (__t) == __c4
<span class="lineNum">    3473 </span>            :       || TREE_CODE (__t) == __c5)
<span class="lineNum">    3474 </span>            :     tree_not_check_failed (__t, __f, __l, __g, __c1, __c2, __c3, __c4, __c5, 0);
<span class="lineNum">    3475 </span>            :   return __t;
<span class="lineNum">    3476 </span>            : }
<a name="3477"><span class="lineNum">    3477 </span>            : </a>
<span class="lineNum">    3478 </span>            : inline const_tree
<span class="lineNum">    3479 </span><span class="lineCov">     425574 : contains_struct_check (const_tree __t, const enum tree_node_structure_enum __s,</span>
<span class="lineNum">    3480 </span>            :                        const char *__f, int __l, const char *__g)
<span class="lineNum">    3481 </span>            : {
<span class="lineNum">    3482 </span><span class="lineCov">27627539431 :   if (tree_contains_struct[TREE_CODE (__t)][__s] != 1)</span>
<span class="lineNum">    3483 </span><span class="lineNoCov">          0 :       tree_contains_struct_check_failed (__t, __s, __f, __l, __g);</span>
<span class="lineNum">    3484 </span><span class="lineCov">32312574203 :   return __t;</span>
<span class="lineNum">    3485 </span>            : }
<a name="3486"><span class="lineNum">    3486 </span>            : </a>
<span class="lineNum">    3487 </span>            : inline const_tree
<span class="lineNum">    3488 </span><span class="lineCov">   18624140 : tree_class_check (const_tree __t, const enum tree_code_class __class,</span>
<span class="lineNum">    3489 </span>            :                   const char *__f, int __l, const char *__g)
<span class="lineNum">    3490 </span>            : {
<span class="lineNum">    3491 </span><span class="lineCov">18170004943 :   if (TREE_CODE_CLASS (TREE_CODE (__t)) != __class)</span>
<span class="lineNum">    3492 </span><span class="lineNoCov">          0 :     tree_class_check_failed (__t, __class, __f, __l, __g);</span>
<span class="lineNum">    3493 </span><span class="lineCov">47683982391 :   return __t;</span>
<span class="lineNum">    3494 </span>            : }
<span class="lineNum">    3495 </span>            : 
<span class="lineNum">    3496 </span>            : inline const_tree
<span class="lineNum">    3497 </span>            : tree_range_check (const_tree __t,
<span class="lineNum">    3498 </span>            :                   enum tree_code __code1, enum tree_code __code2,
<span class="lineNum">    3499 </span>            :                   const char *__f, int __l, const char *__g)
<span class="lineNum">    3500 </span>            : {
<span class="lineNum">    3501 </span>            :   if (TREE_CODE (__t) &lt; __code1 || TREE_CODE (__t) &gt; __code2)
<span class="lineNum">    3502 </span>            :     tree_range_check_failed (__t, __f, __l, __g, __code1, __code2);
<span class="lineNum">    3503 </span>            :   return __t;
<span class="lineNum">    3504 </span>            : }
<span class="lineNum">    3505 </span>            : 
<span class="lineNum">    3506 </span>            : inline const_tree
<span class="lineNum">    3507 </span>            : omp_clause_subcode_check (const_tree __t, enum omp_clause_code __code,
<span class="lineNum">    3508 </span>            :                           const char *__f, int __l, const char *__g)
<span class="lineNum">    3509 </span>            : {
<span class="lineNum">    3510 </span>            :   if (TREE_CODE (__t) != OMP_CLAUSE)
<span class="lineNum">    3511 </span>            :     tree_check_failed (__t, __f, __l, __g, OMP_CLAUSE, 0);
<span class="lineNum">    3512 </span>            :   if (__t-&gt;omp_clause.code != __code)
<span class="lineNum">    3513 </span>            :     omp_clause_check_failed (__t, __f, __l, __g, __code);
<span class="lineNum">    3514 </span>            :   return __t;
<span class="lineNum">    3515 </span>            : }
<span class="lineNum">    3516 </span>            : 
<span class="lineNum">    3517 </span>            : inline const_tree
<span class="lineNum">    3518 </span>            : omp_clause_range_check (const_tree __t,
<span class="lineNum">    3519 </span>            :                         enum omp_clause_code __code1,
<span class="lineNum">    3520 </span>            :                         enum omp_clause_code __code2,
<span class="lineNum">    3521 </span>            :                         const char *__f, int __l, const char *__g)
<span class="lineNum">    3522 </span>            : {
<span class="lineNum">    3523 </span>            :   if (TREE_CODE (__t) != OMP_CLAUSE)
<span class="lineNum">    3524 </span>            :     tree_check_failed (__t, __f, __l, __g, OMP_CLAUSE, 0);
<span class="lineNum">    3525 </span>            :   if ((int) __t-&gt;omp_clause.code &lt; (int) __code1
<span class="lineNum">    3526 </span>            :       || (int) __t-&gt;omp_clause.code &gt; (int) __code2)
<span class="lineNum">    3527 </span>            :     omp_clause_range_check_failed (__t, __f, __l, __g, __code1, __code2);
<span class="lineNum">    3528 </span>            :   return __t;
<span class="lineNum">    3529 </span>            : }
<span class="lineNum">    3530 </span>            : 
<span class="lineNum">    3531 </span>            : inline const_tree
<span class="lineNum">    3532 </span>            : expr_check (const_tree __t, const char *__f, int __l, const char *__g)
<span class="lineNum">    3533 </span>            : {
<span class="lineNum">    3534 </span><span class="lineCov">10955556187 :   char const __c = TREE_CODE_CLASS (TREE_CODE (__t));</span>
<span class="lineNum">    3535 </span><span class="lineCov">10955556187 :   if (!IS_EXPR_CODE_CLASS (__c))</span>
<span class="lineNum">    3536 </span><span class="lineNoCov">          0 :     tree_class_check_failed (__t, tcc_expression, __f, __l, __g);</span>
<span class="lineNum">    3537 </span><span class="lineCov">10955556187 :   return __t;</span>
<span class="lineNum">    3538 </span>            : }
<span class="lineNum">    3539 </span>            : 
<span class="lineNum">    3540 </span>            : inline const_tree
<span class="lineNum">    3541 </span>            : non_type_check (const_tree __t, const char *__f, int __l, const char *__g)
<span class="lineNum">    3542 </span>            : {
<span class="lineNum">    3543 </span><span class="lineCov"> 2942875661 :   if (TYPE_P (__t))</span>
<span class="lineNum">    3544 </span><span class="lineNoCov">          0 :     tree_not_class_check_failed (__t, tcc_type, __f, __l, __g);</span>
<span class="lineNum">    3545 </span><span class="lineCov"> 2999932929 :   return __t;</span>
<span class="lineNum">    3546 </span>            : }
<span class="lineNum">    3547 </span>            : 
<span class="lineNum">    3548 </span>            : # if GCC_VERSION &gt;= 4006
<span class="lineNum">    3549 </span>            : #pragma GCC diagnostic push
<span class="lineNum">    3550 </span>            : #pragma GCC diagnostic ignored &quot;-Wstrict-overflow&quot;
<span class="lineNum">    3551 </span>            : #endif
<a name="3552"><span class="lineNum">    3552 </span>            : </a>
<span class="lineNum">    3553 </span>            : inline const_tree *
<span class="lineNum">    3554 </span><span class="lineCov"> 1293044254 : tree_vec_elt_check (const_tree __t, int __i,</span>
<span class="lineNum">    3555 </span>            :                     const char *__f, int __l, const char *__g)
<span class="lineNum">    3556 </span>            : {
<span class="lineNum">    3557 </span><span class="lineCov"> 1293044254 :   if (TREE_CODE (__t) != TREE_VEC)</span>
<span class="lineNum">    3558 </span><span class="lineNoCov">          0 :     tree_check_failed (__t, __f, __l, __g, TREE_VEC, 0);</span>
<span class="lineNum">    3559 </span><span class="lineCov"> 1293044254 :   if (__i &lt; 0 || __i &gt;= __t-&gt;base.u.length)</span>
<span class="lineNum">    3560 </span><span class="lineNoCov">          0 :     tree_vec_elt_check_failed (__i, __t-&gt;base.u.length, __f, __l, __g);</span>
<span class="lineNum">    3561 </span><span class="lineCov"> 1293044254 :   return CONST_CAST (const_tree *, &amp;__t-&gt;vec.a[__i]);</span>
<span class="lineNum">    3562 </span>            :   //return &amp;__t-&gt;vec.a[__i];
<span class="lineNum">    3563 </span>            : }
<span class="lineNum">    3564 </span>            : 
<span class="lineNum">    3565 </span>            : # if GCC_VERSION &gt;= 4006
<span class="lineNum">    3566 </span>            : #pragma GCC diagnostic pop
<span class="lineNum">    3567 </span>            : #endif
<span class="lineNum">    3568 </span>            : 
<span class="lineNum">    3569 </span>            : inline const_tree *
<span class="lineNum">    3570 </span>            : omp_clause_elt_check (const_tree __t, int __i,
<span class="lineNum">    3571 </span>            :                       const char *__f, int __l, const char *__g)
<span class="lineNum">    3572 </span>            : {
<span class="lineNum">    3573 </span>            :   if (TREE_CODE (__t) != OMP_CLAUSE)
<span class="lineNum">    3574 </span>            :     tree_check_failed (__t, __f, __l, __g, OMP_CLAUSE, 0);
<span class="lineNum">    3575 </span>            :   if (__i &lt; 0 || __i &gt;= omp_clause_num_ops [__t-&gt;omp_clause.code])
<span class="lineNum">    3576 </span>            :     omp_clause_operand_check_failed (__i, __t, __f, __l, __g);
<span class="lineNum">    3577 </span>            :   return CONST_CAST (const_tree *, &amp;__t-&gt;omp_clause.ops[__i]);
<span class="lineNum">    3578 </span>            : }
<a name="3579"><span class="lineNum">    3579 </span>            : </a>
<span class="lineNum">    3580 </span>            : inline const_tree
<span class="lineNum">    3581 </span><span class="lineCov">    1733924 : any_integral_type_check (const_tree __t, const char *__f, int __l,</span>
<span class="lineNum">    3582 </span>            :                          const char *__g)
<span class="lineNum">    3583 </span>            : {
<span class="lineNum">    3584 </span><span class="lineCov">    1733924 :   if (!ANY_INTEGRAL_TYPE_P (__t))</span>
<span class="lineNum">    3585 </span><span class="lineNoCov">          0 :     tree_check_failed (__t, __f, __l, __g, BOOLEAN_TYPE, ENUMERAL_TYPE,</span>
<span class="lineNum">    3586 </span>            :                        INTEGER_TYPE, 0);
<span class="lineNum">    3587 </span><span class="lineCov">    1733924 :   return __t;</span>
<span class="lineNum">    3588 </span>            : }
<span class="lineNum">    3589 </span>            : 
<span class="lineNum">    3590 </span>            : #endif
<span class="lineNum">    3591 </span>            : 
<span class="lineNum">    3592 </span>            : /* Compute the number of operands in an expression node NODE.  For
<span class="lineNum">    3593 </span>            :    tcc_vl_exp nodes like CALL_EXPRs, this is stored in the node itself,
<a name="3594"><span class="lineNum">    3594 </span>            :    otherwise it is looked up from the node's code.  */</a>
<span class="lineNum">    3595 </span>            : static inline int
<span class="lineNum">    3596 </span><span class="lineCov">73149026973 : tree_operand_length (const_tree node)</span>
<span class="lineNum">    3597 </span>            : {
<span class="lineNum">    3598 </span><span class="lineCov">73149026973 :   if (VL_EXP_CLASS_P (node))</span>
<span class="lineNum">    3599 </span><span class="lineCov"> 1636369058 :     return VL_EXP_OPERAND_LENGTH (node);</span>
<span class="lineNum">    3600 </span>            :   else
<span class="lineNum">    3601 </span><span class="lineCov">71512657915 :     return TREE_CODE_LENGTH (TREE_CODE (node));</span>
<span class="lineNum">    3602 </span>            : }
<span class="lineNum">    3603 </span>            : 
<span class="lineNum">    3604 </span>            : #if defined ENABLE_TREE_CHECKING &amp;&amp; (GCC_VERSION &gt;= 2007)
<span class="lineNum">    3605 </span>            : 
<a name="3606"><span class="lineNum">    3606 </span>            : /* Special checks for TREE_OPERANDs.  */</a>
<span class="lineNum">    3607 </span>            : inline tree *
<span class="lineNum">    3608 </span><span class="lineCov">53524816867 : tree_operand_check (tree __t, int __i,</span>
<span class="lineNum">    3609 </span>            :                     const char *__f, int __l, const char *__g)
<span class="lineNum">    3610 </span>            : {
<span class="lineNum">    3611 </span><span class="lineCov">53524816867 :   const_tree __u = EXPR_CHECK (__t);</span>
<span class="lineNum">    3612 </span><span class="lineCov">53524816867 :   if (__i &lt; 0 || __i &gt;= TREE_OPERAND_LENGTH (__u))</span>
<span class="lineNum">    3613 </span><span class="lineNoCov">          0 :     tree_operand_check_failed (__i, __u, __f, __l, __g);</span>
<span class="lineNum">    3614 </span><span class="lineCov">53524816867 :   return &amp;CONST_CAST_TREE (__u)-&gt;exp.operands[__i];</span>
<span class="lineNum">    3615 </span>            : }
<a name="3616"><span class="lineNum">    3616 </span>            : </a>
<span class="lineNum">    3617 </span>            : inline tree *
<span class="lineNum">    3618 </span><span class="lineCov">    7208470 : tree_operand_check_code (tree __t, enum tree_code __code, int __i,</span>
<span class="lineNum">    3619 </span>            :                          const char *__f, int __l, const char *__g)
<span class="lineNum">    3620 </span>            : {
<span class="lineNum">    3621 </span><span class="lineCov">    7208470 :   if (TREE_CODE (__t) != __code)</span>
<span class="lineNum">    3622 </span><span class="lineNoCov">          0 :     tree_check_failed (__t, __f, __l, __g, __code, 0);</span>
<span class="lineNum">    3623 </span><span class="lineCov">    7208470 :   if (__i &lt; 0 || __i &gt;= TREE_OPERAND_LENGTH (__t))</span>
<span class="lineNum">    3624 </span><span class="lineNoCov">          0 :     tree_operand_check_failed (__i, __t, __f, __l, __g);</span>
<span class="lineNum">    3625 </span><span class="lineCov">    7208470 :   return &amp;__t-&gt;exp.operands[__i];</span>
<span class="lineNum">    3626 </span>            : }
<a name="3627"><span class="lineNum">    3627 </span>            : </a>
<span class="lineNum">    3628 </span>            : inline const_tree *
<span class="lineNum">    3629 </span><span class="lineCov">10955556185 : tree_operand_check (const_tree __t, int __i,</span>
<span class="lineNum">    3630 </span>            :                     const char *__f, int __l, const char *__g)
<span class="lineNum">    3631 </span>            : {
<span class="lineNum">    3632 </span><span class="lineCov">10955556185 :   const_tree __u = EXPR_CHECK (__t);</span>
<span class="lineNum">    3633 </span><span class="lineCov">10955556185 :   if (__i &lt; 0 || __i &gt;= TREE_OPERAND_LENGTH (__u))</span>
<span class="lineNum">    3634 </span><span class="lineNoCov">          0 :     tree_operand_check_failed (__i, __u, __f, __l, __g);</span>
<span class="lineNum">    3635 </span><span class="lineCov">10955556185 :   return CONST_CAST (const_tree *, &amp;__u-&gt;exp.operands[__i]);</span>
<span class="lineNum">    3636 </span>            : }
<a name="3637"><span class="lineNum">    3637 </span>            : </a>
<span class="lineNum">    3638 </span>            : inline const_tree *
<span class="lineNum">    3639 </span><span class="lineCov">         22 : tree_operand_check_code (const_tree __t, enum tree_code __code, int __i,</span>
<span class="lineNum">    3640 </span>            :                          const char *__f, int __l, const char *__g)
<span class="lineNum">    3641 </span>            : {
<span class="lineNum">    3642 </span><span class="lineCov">         22 :   if (TREE_CODE (__t) != __code)</span>
<span class="lineNum">    3643 </span><span class="lineNoCov">          0 :     tree_check_failed (__t, __f, __l, __g, __code, 0);</span>
<span class="lineNum">    3644 </span><span class="lineCov">         22 :   if (__i &lt; 0 || __i &gt;= TREE_OPERAND_LENGTH (__t))</span>
<span class="lineNum">    3645 </span><span class="lineNoCov">          0 :     tree_operand_check_failed (__i, __t, __f, __l, __g);</span>
<span class="lineNum">    3646 </span><span class="lineCov">         22 :   return CONST_CAST (const_tree *, &amp;__t-&gt;exp.operands[__i]);</span>
<span class="lineNum">    3647 </span>            : }
<span class="lineNum">    3648 </span>            : 
<span class="lineNum">    3649 </span>            : #endif
<span class="lineNum">    3650 </span>            : 
<span class="lineNum">    3651 </span>            : /* True iff an identifier matches a C string.  */
<a name="3652"><span class="lineNum">    3652 </span>            : </a>
<span class="lineNum">    3653 </span>            : inline bool
<span class="lineNum">    3654 </span><span class="lineCov">    7165044 : id_equal (const_tree id, const char *str)</span>
<span class="lineNum">    3655 </span>            : {
<span class="lineNum">    3656 </span><span class="lineCov">    7165044 :   return !strcmp (IDENTIFIER_POINTER (id), str);</span>
<span class="lineNum">    3657 </span>            : }
<span class="lineNum">    3658 </span>            : 
<span class="lineNum">    3659 </span>            : inline bool
<span class="lineNum">    3660 </span>            : id_equal (const char *str, const_tree id)
<span class="lineNum">    3661 </span>            : {
<span class="lineNum">    3662 </span>            :   return !strcmp (str, IDENTIFIER_POINTER (id));
<span class="lineNum">    3663 </span>            : }
<span class="lineNum">    3664 </span>            : 
<span class="lineNum">    3665 </span>            : /* Return the number of elements in the VECTOR_TYPE given by NODE.  */
<a name="3666"><span class="lineNum">    3666 </span>            : </a>
<span class="lineNum">    3667 </span>            : inline poly_uint64
<span class="lineNum">    3668 </span><span class="lineCov">   75124393 : TYPE_VECTOR_SUBPARTS (const_tree node)</span>
<span class="lineNum">    3669 </span>            : {
<span class="lineNum">    3670 </span><span class="lineCov">   75124393 :   STATIC_ASSERT (NUM_POLY_INT_COEFFS &lt;= 2);</span>
<span class="lineNum">    3671 </span><span class="lineCov">   75124393 :   unsigned int precision = VECTOR_TYPE_CHECK (node)-&gt;type_common.precision;</span>
<span class="lineNum">    3672 </span><span class="lineCov">   75124393 :   if (NUM_POLY_INT_COEFFS == 2)</span>
<span class="lineNum">    3673 </span>            :     {
<span class="lineNum">    3674 </span>            :       poly_uint64 res = 0;
<span class="lineNum">    3675 </span>            :       res.coeffs[0] = 1 &lt;&lt; (precision &amp; 0xff);
<span class="lineNum">    3676 </span>            :       if (precision &amp; 0x100)
<span class="lineNum">    3677 </span>            :         res.coeffs[1] = 1 &lt;&lt; (precision &amp; 0xff);
<span class="lineNum">    3678 </span>            :       return res;
<span class="lineNum">    3679 </span>            :     }
<span class="lineNum">    3680 </span>            :   else
<span class="lineNum">    3681 </span><span class="lineCov">  150248786 :     return 1 &lt;&lt; precision;</span>
<span class="lineNum">    3682 </span>            : }
<span class="lineNum">    3683 </span>            : 
<span class="lineNum">    3684 </span>            : /* Set the number of elements in VECTOR_TYPE NODE to SUBPARTS, which must
<span class="lineNum">    3685 </span>            :    satisfy valid_vector_subparts_p.  */
<a name="3686"><span class="lineNum">    3686 </span>            : </a>
<span class="lineNum">    3687 </span>            : inline void
<span class="lineNum">    3688 </span><span class="lineCov">    6779574 : SET_TYPE_VECTOR_SUBPARTS (tree node, poly_uint64 subparts)</span>
<span class="lineNum">    3689 </span>            : {
<span class="lineNum">    3690 </span><span class="lineCov">    6779574 :   STATIC_ASSERT (NUM_POLY_INT_COEFFS &lt;= 2);</span>
<span class="lineNum">    3691 </span><span class="lineCov">    6779574 :   unsigned HOST_WIDE_INT coeff0 = subparts.coeffs[0];</span>
<span class="lineNum">    3692 </span><span class="lineCov">    6779574 :   int index = exact_log2 (coeff0);</span>
<span class="lineNum">    3693 </span><span class="lineNoCov">          0 :   gcc_assert (index &gt;= 0);</span>
<span class="lineNum">    3694 </span><span class="lineCov">    6779574 :   if (NUM_POLY_INT_COEFFS == 2)</span>
<span class="lineNum">    3695 </span>            :     {
<span class="lineNum">    3696 </span>            :       unsigned HOST_WIDE_INT coeff1 = subparts.coeffs[1];
<span class="lineNum">    3697 </span>            :       gcc_assert (coeff1 == 0 || coeff1 == coeff0);
<span class="lineNum">    3698 </span>            :       VECTOR_TYPE_CHECK (node)-&gt;type_common.precision
<span class="lineNum">    3699 </span>            :         = index + (coeff1 != 0 ? 0x100 : 0);
<span class="lineNum">    3700 </span>            :     }
<span class="lineNum">    3701 </span>            :   else
<span class="lineNum">    3702 </span><span class="lineCov">    6779574 :     VECTOR_TYPE_CHECK (node)-&gt;type_common.precision = index;</span>
<span class="lineNum">    3703 </span><span class="lineCov">    6779574 : }</span>
<span class="lineNum">    3704 </span>            : 
<span class="lineNum">    3705 </span>            : /* Return true if we can construct vector types with the given number
<span class="lineNum">    3706 </span>            :    of subparts.  */
<a name="3707"><span class="lineNum">    3707 </span>            : </a>
<span class="lineNum">    3708 </span>            : static inline bool
<span class="lineNum">    3709 </span><span class="lineCov">       7660 : valid_vector_subparts_p (poly_uint64 subparts)</span>
<span class="lineNum">    3710 </span>            : {
<span class="lineNum">    3711 </span><span class="lineCov">       7930 :   unsigned HOST_WIDE_INT coeff0 = subparts.coeffs[0];</span>
<span class="lineNum">    3712 </span><span class="lineCov">       7930 :   if (!pow2p_hwi (coeff0))</span>
<span class="lineNum">    3713 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    3714 </span>            :   if (NUM_POLY_INT_COEFFS == 2)
<span class="lineNum">    3715 </span>            :     {
<span class="lineNum">    3716 </span>            :       unsigned HOST_WIDE_INT coeff1 = subparts.coeffs[1];
<span class="lineNum">    3717 </span>            :       if (coeff1 != 0 &amp;&amp; coeff1 != coeff0)
<span class="lineNum">    3718 </span>            :         return false;
<span class="lineNum">    3719 </span>            :     }
<span class="lineNum">    3720 </span>            :   return true;
<span class="lineNum">    3721 </span>            : }
<span class="lineNum">    3722 </span>            : 
<span class="lineNum">    3723 </span>            : /* In NON_LVALUE_EXPR and VIEW_CONVERT_EXPR, set when this node is merely a
<span class="lineNum">    3724 </span>            :    wrapper added to express a location_t on behalf of the node's child
<span class="lineNum">    3725 </span>            :    (e.g. by maybe_wrap_with_location).  */
<span class="lineNum">    3726 </span>            : 
<span class="lineNum">    3727 </span>            : #define EXPR_LOCATION_WRAPPER_P(NODE) \
<span class="lineNum">    3728 </span>            :   (TREE_CHECK2(NODE, NON_LVALUE_EXPR, VIEW_CONVERT_EXPR)-&gt;base.public_flag)
<span class="lineNum">    3729 </span>            : 
<span class="lineNum">    3730 </span>            : /* Test if EXP is merely a wrapper node, added to express a location_t
<span class="lineNum">    3731 </span>            :    on behalf of the node's child (e.g. by maybe_wrap_with_location).  */
<a name="3732"><span class="lineNum">    3732 </span>            : </a>
<span class="lineNum">    3733 </span>            : inline bool
<span class="lineNum">    3734 </span><span class="lineCov"> 7533784141 : location_wrapper_p (const_tree exp)</span>
<span class="lineNum">    3735 </span>            : {
<span class="lineNum">    3736 </span>            :   /* A wrapper node has code NON_LVALUE_EXPR or VIEW_CONVERT_EXPR, and
<span class="lineNum">    3737 </span>            :      the flag EXPR_LOCATION_WRAPPER_P is set.
<span class="lineNum">    3738 </span>            :      It normally has the same type as its operand, but it can have a
<span class="lineNum">    3739 </span>            :      different one if the type of the operand has changed (e.g. when
<span class="lineNum">    3740 </span>            :      merging duplicate decls).
<span class="lineNum">    3741 </span>            : 
<span class="lineNum">    3742 </span>            :      NON_LVALUE_EXPR is used for wrapping constants, apart from STRING_CST.
<span class="lineNum">    3743 </span>            :      VIEW_CONVERT_EXPR is used for wrapping non-constants and STRING_CST.  */
<span class="lineNum">    3744 </span><span class="lineCov"> 7533784141 :   if ((TREE_CODE (exp) == NON_LVALUE_EXPR</span>
<span class="lineNum">    3745 </span><span class="lineCov"> 7533784141 :        || TREE_CODE (exp) == VIEW_CONVERT_EXPR)</span>
<span class="lineNum">    3746 </span><span class="lineCov"> 7603598271 :       &amp;&amp; EXPR_LOCATION_WRAPPER_P (exp))</span>
<span class="lineNum">    3747 </span><span class="lineCov">   51995039 :     return true;</span>
<span class="lineNum">    3748 </span>            :   return false;
<span class="lineNum">    3749 </span>            : }
<span class="lineNum">    3750 </span>            : 
<span class="lineNum">    3751 </span>            : /* Implementation of STRIP_ANY_LOCATION_WRAPPER.  */
<a name="3752"><span class="lineNum">    3752 </span>            : </a>
<span class="lineNum">    3753 </span>            : inline tree
<span class="lineNum">    3754 </span><span class="lineCov">  832640705 : tree_strip_any_location_wrapper (tree exp)</span>
<span class="lineNum">    3755 </span>            : {
<span class="lineNum">    3756 </span><span class="lineCov">  832640705 :   if (location_wrapper_p (exp))</span>
<span class="lineNum">    3757 </span><span class="lineCov">   34181424 :     return TREE_OPERAND (exp, 0);</span>
<span class="lineNum">    3758 </span>            :   else
<span class="lineNum">    3759 </span>            :     return exp;
<span class="lineNum">    3760 </span>            : }
<span class="lineNum">    3761 </span>            : 
<span class="lineNum">    3762 </span>            : #define error_mark_node                 global_trees[TI_ERROR_MARK]
<span class="lineNum">    3763 </span>            : 
<span class="lineNum">    3764 </span>            : #define intQI_type_node                 global_trees[TI_INTQI_TYPE]
<span class="lineNum">    3765 </span>            : #define intHI_type_node                 global_trees[TI_INTHI_TYPE]
<span class="lineNum">    3766 </span>            : #define intSI_type_node                 global_trees[TI_INTSI_TYPE]
<span class="lineNum">    3767 </span>            : #define intDI_type_node                 global_trees[TI_INTDI_TYPE]
<span class="lineNum">    3768 </span>            : #define intTI_type_node                 global_trees[TI_INTTI_TYPE]
<span class="lineNum">    3769 </span>            : 
<span class="lineNum">    3770 </span>            : #define unsigned_intQI_type_node        global_trees[TI_UINTQI_TYPE]
<span class="lineNum">    3771 </span>            : #define unsigned_intHI_type_node        global_trees[TI_UINTHI_TYPE]
<span class="lineNum">    3772 </span>            : #define unsigned_intSI_type_node        global_trees[TI_UINTSI_TYPE]
<span class="lineNum">    3773 </span>            : #define unsigned_intDI_type_node        global_trees[TI_UINTDI_TYPE]
<span class="lineNum">    3774 </span>            : #define unsigned_intTI_type_node        global_trees[TI_UINTTI_TYPE]
<span class="lineNum">    3775 </span>            : 
<span class="lineNum">    3776 </span>            : #define atomicQI_type_node      global_trees[TI_ATOMICQI_TYPE]
<span class="lineNum">    3777 </span>            : #define atomicHI_type_node      global_trees[TI_ATOMICHI_TYPE]
<span class="lineNum">    3778 </span>            : #define atomicSI_type_node      global_trees[TI_ATOMICSI_TYPE]
<span class="lineNum">    3779 </span>            : #define atomicDI_type_node      global_trees[TI_ATOMICDI_TYPE]
<span class="lineNum">    3780 </span>            : #define atomicTI_type_node      global_trees[TI_ATOMICTI_TYPE]
<span class="lineNum">    3781 </span>            : 
<span class="lineNum">    3782 </span>            : #define uint16_type_node                global_trees[TI_UINT16_TYPE]
<span class="lineNum">    3783 </span>            : #define uint32_type_node                global_trees[TI_UINT32_TYPE]
<span class="lineNum">    3784 </span>            : #define uint64_type_node                global_trees[TI_UINT64_TYPE]
<span class="lineNum">    3785 </span>            : 
<span class="lineNum">    3786 </span>            : #define void_node                       global_trees[TI_VOID]
<span class="lineNum">    3787 </span>            : 
<span class="lineNum">    3788 </span>            : #define integer_zero_node               global_trees[TI_INTEGER_ZERO]
<span class="lineNum">    3789 </span>            : #define integer_one_node                global_trees[TI_INTEGER_ONE]
<span class="lineNum">    3790 </span>            : #define integer_three_node              global_trees[TI_INTEGER_THREE]
<span class="lineNum">    3791 </span>            : #define integer_minus_one_node          global_trees[TI_INTEGER_MINUS_ONE]
<span class="lineNum">    3792 </span>            : #define size_zero_node                  global_trees[TI_SIZE_ZERO]
<span class="lineNum">    3793 </span>            : #define size_one_node                   global_trees[TI_SIZE_ONE]
<span class="lineNum">    3794 </span>            : #define bitsize_zero_node               global_trees[TI_BITSIZE_ZERO]
<span class="lineNum">    3795 </span>            : #define bitsize_one_node                global_trees[TI_BITSIZE_ONE]
<span class="lineNum">    3796 </span>            : #define bitsize_unit_node               global_trees[TI_BITSIZE_UNIT]
<span class="lineNum">    3797 </span>            : 
<span class="lineNum">    3798 </span>            : /* Base access nodes.  */
<span class="lineNum">    3799 </span>            : #define access_public_node              global_trees[TI_PUBLIC]
<span class="lineNum">    3800 </span>            : #define access_protected_node           global_trees[TI_PROTECTED]
<span class="lineNum">    3801 </span>            : #define access_private_node             global_trees[TI_PRIVATE]
<span class="lineNum">    3802 </span>            : 
<span class="lineNum">    3803 </span>            : #define null_pointer_node               global_trees[TI_NULL_POINTER]
<span class="lineNum">    3804 </span>            : 
<span class="lineNum">    3805 </span>            : #define float_type_node                 global_trees[TI_FLOAT_TYPE]
<span class="lineNum">    3806 </span>            : #define double_type_node                global_trees[TI_DOUBLE_TYPE]
<span class="lineNum">    3807 </span>            : #define long_double_type_node           global_trees[TI_LONG_DOUBLE_TYPE]
<span class="lineNum">    3808 </span>            : 
<span class="lineNum">    3809 </span>            : /* Nodes for particular _FloatN and _FloatNx types in sequence.  */
<span class="lineNum">    3810 </span>            : #define FLOATN_TYPE_NODE(IDX)           global_trees[TI_FLOATN_TYPE_FIRST + (IDX)]
<span class="lineNum">    3811 </span>            : #define FLOATN_NX_TYPE_NODE(IDX)        global_trees[TI_FLOATN_NX_TYPE_FIRST + (IDX)]
<span class="lineNum">    3812 </span>            : #define FLOATNX_TYPE_NODE(IDX)          global_trees[TI_FLOATNX_TYPE_FIRST + (IDX)]
<span class="lineNum">    3813 </span>            : 
<span class="lineNum">    3814 </span>            : /* Names for individual types (code should normally iterate over all
<span class="lineNum">    3815 </span>            :    such types; these are only for back-end use, or in contexts such as
<span class="lineNum">    3816 </span>            :    *.def where iteration is not possible).  */
<span class="lineNum">    3817 </span>            : #define float16_type_node               global_trees[TI_FLOAT16_TYPE]
<span class="lineNum">    3818 </span>            : #define float32_type_node               global_trees[TI_FLOAT32_TYPE]
<span class="lineNum">    3819 </span>            : #define float64_type_node               global_trees[TI_FLOAT64_TYPE]
<span class="lineNum">    3820 </span>            : #define float128_type_node              global_trees[TI_FLOAT128_TYPE]
<span class="lineNum">    3821 </span>            : #define float32x_type_node              global_trees[TI_FLOAT32X_TYPE]
<span class="lineNum">    3822 </span>            : #define float64x_type_node              global_trees[TI_FLOAT64X_TYPE]
<span class="lineNum">    3823 </span>            : #define float128x_type_node             global_trees[TI_FLOAT128X_TYPE]
<span class="lineNum">    3824 </span>            : 
<span class="lineNum">    3825 </span>            : #define float_ptr_type_node             global_trees[TI_FLOAT_PTR_TYPE]
<span class="lineNum">    3826 </span>            : #define double_ptr_type_node            global_trees[TI_DOUBLE_PTR_TYPE]
<span class="lineNum">    3827 </span>            : #define long_double_ptr_type_node       global_trees[TI_LONG_DOUBLE_PTR_TYPE]
<span class="lineNum">    3828 </span>            : #define integer_ptr_type_node           global_trees[TI_INTEGER_PTR_TYPE]
<span class="lineNum">    3829 </span>            : 
<span class="lineNum">    3830 </span>            : #define complex_integer_type_node       global_trees[TI_COMPLEX_INTEGER_TYPE]
<span class="lineNum">    3831 </span>            : #define complex_float_type_node         global_trees[TI_COMPLEX_FLOAT_TYPE]
<span class="lineNum">    3832 </span>            : #define complex_double_type_node        global_trees[TI_COMPLEX_DOUBLE_TYPE]
<span class="lineNum">    3833 </span>            : #define complex_long_double_type_node   global_trees[TI_COMPLEX_LONG_DOUBLE_TYPE]
<span class="lineNum">    3834 </span>            : 
<span class="lineNum">    3835 </span>            : #define COMPLEX_FLOATN_NX_TYPE_NODE(IDX)        global_trees[TI_COMPLEX_FLOATN_NX_TYPE_FIRST + (IDX)]
<span class="lineNum">    3836 </span>            : 
<span class="lineNum">    3837 </span>            : #define void_type_node                  global_trees[TI_VOID_TYPE]
<span class="lineNum">    3838 </span>            : /* The C type `void *'.  */
<span class="lineNum">    3839 </span>            : #define ptr_type_node                   global_trees[TI_PTR_TYPE]
<span class="lineNum">    3840 </span>            : /* The C type `const void *'.  */
<span class="lineNum">    3841 </span>            : #define const_ptr_type_node             global_trees[TI_CONST_PTR_TYPE]
<span class="lineNum">    3842 </span>            : /* The C type `size_t'.  */
<span class="lineNum">    3843 </span>            : #define size_type_node                  global_trees[TI_SIZE_TYPE]
<span class="lineNum">    3844 </span>            : #define pid_type_node                   global_trees[TI_PID_TYPE]
<span class="lineNum">    3845 </span>            : #define ptrdiff_type_node               global_trees[TI_PTRDIFF_TYPE]
<span class="lineNum">    3846 </span>            : #define va_list_type_node               global_trees[TI_VA_LIST_TYPE]
<span class="lineNum">    3847 </span>            : #define va_list_gpr_counter_field       global_trees[TI_VA_LIST_GPR_COUNTER_FIELD]
<span class="lineNum">    3848 </span>            : #define va_list_fpr_counter_field       global_trees[TI_VA_LIST_FPR_COUNTER_FIELD]
<span class="lineNum">    3849 </span>            : /* The C type `FILE *'.  */
<span class="lineNum">    3850 </span>            : #define fileptr_type_node               global_trees[TI_FILEPTR_TYPE]
<span class="lineNum">    3851 </span>            : /* The C type `const struct tm *'.  */
<span class="lineNum">    3852 </span>            : #define const_tm_ptr_type_node          global_trees[TI_CONST_TM_PTR_TYPE]
<span class="lineNum">    3853 </span>            : /* The C type `fenv_t *'.  */
<span class="lineNum">    3854 </span>            : #define fenv_t_ptr_type_node            global_trees[TI_FENV_T_PTR_TYPE]
<span class="lineNum">    3855 </span>            : #define const_fenv_t_ptr_type_node      global_trees[TI_CONST_FENV_T_PTR_TYPE]
<span class="lineNum">    3856 </span>            : /* The C type `fexcept_t *'.  */
<span class="lineNum">    3857 </span>            : #define fexcept_t_ptr_type_node         global_trees[TI_FEXCEPT_T_PTR_TYPE]
<span class="lineNum">    3858 </span>            : #define const_fexcept_t_ptr_type_node   global_trees[TI_CONST_FEXCEPT_T_PTR_TYPE]
<span class="lineNum">    3859 </span>            : #define pointer_sized_int_node          global_trees[TI_POINTER_SIZED_TYPE]
<span class="lineNum">    3860 </span>            : 
<span class="lineNum">    3861 </span>            : #define boolean_type_node               global_trees[TI_BOOLEAN_TYPE]
<span class="lineNum">    3862 </span>            : #define boolean_false_node              global_trees[TI_BOOLEAN_FALSE]
<span class="lineNum">    3863 </span>            : #define boolean_true_node               global_trees[TI_BOOLEAN_TRUE]
<span class="lineNum">    3864 </span>            : 
<span class="lineNum">    3865 </span>            : /* The decimal floating point types. */
<span class="lineNum">    3866 </span>            : #define dfloat32_type_node              global_trees[TI_DFLOAT32_TYPE]
<span class="lineNum">    3867 </span>            : #define dfloat64_type_node              global_trees[TI_DFLOAT64_TYPE]
<span class="lineNum">    3868 </span>            : #define dfloat128_type_node             global_trees[TI_DFLOAT128_TYPE]
<span class="lineNum">    3869 </span>            : #define dfloat32_ptr_type_node          global_trees[TI_DFLOAT32_PTR_TYPE]
<span class="lineNum">    3870 </span>            : #define dfloat64_ptr_type_node          global_trees[TI_DFLOAT64_PTR_TYPE]
<span class="lineNum">    3871 </span>            : #define dfloat128_ptr_type_node         global_trees[TI_DFLOAT128_PTR_TYPE]
<span class="lineNum">    3872 </span>            : 
<span class="lineNum">    3873 </span>            : /* The fixed-point types.  */
<span class="lineNum">    3874 </span>            : #define sat_short_fract_type_node       global_trees[TI_SAT_SFRACT_TYPE]
<span class="lineNum">    3875 </span>            : #define sat_fract_type_node             global_trees[TI_SAT_FRACT_TYPE]
<span class="lineNum">    3876 </span>            : #define sat_long_fract_type_node        global_trees[TI_SAT_LFRACT_TYPE]
<span class="lineNum">    3877 </span>            : #define sat_long_long_fract_type_node   global_trees[TI_SAT_LLFRACT_TYPE]
<span class="lineNum">    3878 </span>            : #define sat_unsigned_short_fract_type_node \
<span class="lineNum">    3879 </span>            :                                         global_trees[TI_SAT_USFRACT_TYPE]
<span class="lineNum">    3880 </span>            : #define sat_unsigned_fract_type_node    global_trees[TI_SAT_UFRACT_TYPE]
<span class="lineNum">    3881 </span>            : #define sat_unsigned_long_fract_type_node \
<span class="lineNum">    3882 </span>            :                                         global_trees[TI_SAT_ULFRACT_TYPE]
<span class="lineNum">    3883 </span>            : #define sat_unsigned_long_long_fract_type_node \
<span class="lineNum">    3884 </span>            :                                         global_trees[TI_SAT_ULLFRACT_TYPE]
<span class="lineNum">    3885 </span>            : #define short_fract_type_node           global_trees[TI_SFRACT_TYPE]
<span class="lineNum">    3886 </span>            : #define fract_type_node                 global_trees[TI_FRACT_TYPE]
<span class="lineNum">    3887 </span>            : #define long_fract_type_node            global_trees[TI_LFRACT_TYPE]
<span class="lineNum">    3888 </span>            : #define long_long_fract_type_node       global_trees[TI_LLFRACT_TYPE]
<span class="lineNum">    3889 </span>            : #define unsigned_short_fract_type_node  global_trees[TI_USFRACT_TYPE]
<span class="lineNum">    3890 </span>            : #define unsigned_fract_type_node        global_trees[TI_UFRACT_TYPE]
<span class="lineNum">    3891 </span>            : #define unsigned_long_fract_type_node   global_trees[TI_ULFRACT_TYPE]
<span class="lineNum">    3892 </span>            : #define unsigned_long_long_fract_type_node \
<span class="lineNum">    3893 </span>            :                                         global_trees[TI_ULLFRACT_TYPE]
<span class="lineNum">    3894 </span>            : #define sat_short_accum_type_node       global_trees[TI_SAT_SACCUM_TYPE]
<span class="lineNum">    3895 </span>            : #define sat_accum_type_node             global_trees[TI_SAT_ACCUM_TYPE]
<span class="lineNum">    3896 </span>            : #define sat_long_accum_type_node        global_trees[TI_SAT_LACCUM_TYPE]
<span class="lineNum">    3897 </span>            : #define sat_long_long_accum_type_node   global_trees[TI_SAT_LLACCUM_TYPE]
<span class="lineNum">    3898 </span>            : #define sat_unsigned_short_accum_type_node \
<span class="lineNum">    3899 </span>            :                                         global_trees[TI_SAT_USACCUM_TYPE]
<span class="lineNum">    3900 </span>            : #define sat_unsigned_accum_type_node    global_trees[TI_SAT_UACCUM_TYPE]
<span class="lineNum">    3901 </span>            : #define sat_unsigned_long_accum_type_node \
<span class="lineNum">    3902 </span>            :                                         global_trees[TI_SAT_ULACCUM_TYPE]
<span class="lineNum">    3903 </span>            : #define sat_unsigned_long_long_accum_type_node \
<span class="lineNum">    3904 </span>            :                                         global_trees[TI_SAT_ULLACCUM_TYPE]
<span class="lineNum">    3905 </span>            : #define short_accum_type_node           global_trees[TI_SACCUM_TYPE]
<span class="lineNum">    3906 </span>            : #define accum_type_node                 global_trees[TI_ACCUM_TYPE]
<span class="lineNum">    3907 </span>            : #define long_accum_type_node            global_trees[TI_LACCUM_TYPE]
<span class="lineNum">    3908 </span>            : #define long_long_accum_type_node       global_trees[TI_LLACCUM_TYPE]
<span class="lineNum">    3909 </span>            : #define unsigned_short_accum_type_node  global_trees[TI_USACCUM_TYPE]
<span class="lineNum">    3910 </span>            : #define unsigned_accum_type_node        global_trees[TI_UACCUM_TYPE]
<span class="lineNum">    3911 </span>            : #define unsigned_long_accum_type_node   global_trees[TI_ULACCUM_TYPE]
<span class="lineNum">    3912 </span>            : #define unsigned_long_long_accum_type_node \
<span class="lineNum">    3913 </span>            :                                         global_trees[TI_ULLACCUM_TYPE]
<span class="lineNum">    3914 </span>            : #define qq_type_node                    global_trees[TI_QQ_TYPE]
<span class="lineNum">    3915 </span>            : #define hq_type_node                    global_trees[TI_HQ_TYPE]
<span class="lineNum">    3916 </span>            : #define sq_type_node                    global_trees[TI_SQ_TYPE]
<span class="lineNum">    3917 </span>            : #define dq_type_node                    global_trees[TI_DQ_TYPE]
<span class="lineNum">    3918 </span>            : #define tq_type_node                    global_trees[TI_TQ_TYPE]
<span class="lineNum">    3919 </span>            : #define uqq_type_node                   global_trees[TI_UQQ_TYPE]
<span class="lineNum">    3920 </span>            : #define uhq_type_node                   global_trees[TI_UHQ_TYPE]
<span class="lineNum">    3921 </span>            : #define usq_type_node                   global_trees[TI_USQ_TYPE]
<span class="lineNum">    3922 </span>            : #define udq_type_node                   global_trees[TI_UDQ_TYPE]
<span class="lineNum">    3923 </span>            : #define utq_type_node                   global_trees[TI_UTQ_TYPE]
<span class="lineNum">    3924 </span>            : #define sat_qq_type_node                global_trees[TI_SAT_QQ_TYPE]
<span class="lineNum">    3925 </span>            : #define sat_hq_type_node                global_trees[TI_SAT_HQ_TYPE]
<span class="lineNum">    3926 </span>            : #define sat_sq_type_node                global_trees[TI_SAT_SQ_TYPE]
<span class="lineNum">    3927 </span>            : #define sat_dq_type_node                global_trees[TI_SAT_DQ_TYPE]
<span class="lineNum">    3928 </span>            : #define sat_tq_type_node                global_trees[TI_SAT_TQ_TYPE]
<span class="lineNum">    3929 </span>            : #define sat_uqq_type_node               global_trees[TI_SAT_UQQ_TYPE]
<span class="lineNum">    3930 </span>            : #define sat_uhq_type_node               global_trees[TI_SAT_UHQ_TYPE]
<span class="lineNum">    3931 </span>            : #define sat_usq_type_node               global_trees[TI_SAT_USQ_TYPE]
<span class="lineNum">    3932 </span>            : #define sat_udq_type_node               global_trees[TI_SAT_UDQ_TYPE]
<span class="lineNum">    3933 </span>            : #define sat_utq_type_node               global_trees[TI_SAT_UTQ_TYPE]
<span class="lineNum">    3934 </span>            : #define ha_type_node                    global_trees[TI_HA_TYPE]
<span class="lineNum">    3935 </span>            : #define sa_type_node                    global_trees[TI_SA_TYPE]
<span class="lineNum">    3936 </span>            : #define da_type_node                    global_trees[TI_DA_TYPE]
<span class="lineNum">    3937 </span>            : #define ta_type_node                    global_trees[TI_TA_TYPE]
<span class="lineNum">    3938 </span>            : #define uha_type_node                   global_trees[TI_UHA_TYPE]
<span class="lineNum">    3939 </span>            : #define usa_type_node                   global_trees[TI_USA_TYPE]
<span class="lineNum">    3940 </span>            : #define uda_type_node                   global_trees[TI_UDA_TYPE]
<span class="lineNum">    3941 </span>            : #define uta_type_node                   global_trees[TI_UTA_TYPE]
<span class="lineNum">    3942 </span>            : #define sat_ha_type_node                global_trees[TI_SAT_HA_TYPE]
<span class="lineNum">    3943 </span>            : #define sat_sa_type_node                global_trees[TI_SAT_SA_TYPE]
<span class="lineNum">    3944 </span>            : #define sat_da_type_node                global_trees[TI_SAT_DA_TYPE]
<span class="lineNum">    3945 </span>            : #define sat_ta_type_node                global_trees[TI_SAT_TA_TYPE]
<span class="lineNum">    3946 </span>            : #define sat_uha_type_node               global_trees[TI_SAT_UHA_TYPE]
<span class="lineNum">    3947 </span>            : #define sat_usa_type_node               global_trees[TI_SAT_USA_TYPE]
<span class="lineNum">    3948 </span>            : #define sat_uda_type_node               global_trees[TI_SAT_UDA_TYPE]
<span class="lineNum">    3949 </span>            : #define sat_uta_type_node               global_trees[TI_SAT_UTA_TYPE]
<span class="lineNum">    3950 </span>            : 
<span class="lineNum">    3951 </span>            : /* The node that should be placed at the end of a parameter list to
<span class="lineNum">    3952 </span>            :    indicate that the function does not take a variable number of
<span class="lineNum">    3953 </span>            :    arguments.  The TREE_VALUE will be void_type_node and there will be
<span class="lineNum">    3954 </span>            :    no TREE_CHAIN.  Language-independent code should not assume
<span class="lineNum">    3955 </span>            :    anything else about this node.  */
<span class="lineNum">    3956 </span>            : #define void_list_node                  global_trees[TI_VOID_LIST_NODE]
<span class="lineNum">    3957 </span>            : 
<span class="lineNum">    3958 </span>            : #define main_identifier_node            global_trees[TI_MAIN_IDENTIFIER]
<span class="lineNum">    3959 </span>            : #define MAIN_NAME_P(NODE) \
<span class="lineNum">    3960 </span>            :   (IDENTIFIER_NODE_CHECK (NODE) == main_identifier_node)
<span class="lineNum">    3961 </span>            : 
<span class="lineNum">    3962 </span>            : /* Optimization options (OPTIMIZATION_NODE) to use for default and current
<span class="lineNum">    3963 </span>            :    functions.  */
<span class="lineNum">    3964 </span>            : #define optimization_default_node       global_trees[TI_OPTIMIZATION_DEFAULT]
<span class="lineNum">    3965 </span>            : #define optimization_current_node       global_trees[TI_OPTIMIZATION_CURRENT]
<span class="lineNum">    3966 </span>            : 
<span class="lineNum">    3967 </span>            : /* Default/current target options (TARGET_OPTION_NODE).  */
<span class="lineNum">    3968 </span>            : #define target_option_default_node      global_trees[TI_TARGET_OPTION_DEFAULT]
<span class="lineNum">    3969 </span>            : #define target_option_current_node      global_trees[TI_TARGET_OPTION_CURRENT]
<span class="lineNum">    3970 </span>            : 
<span class="lineNum">    3971 </span>            : /* Default tree list option(), optimize() pragmas to be linked into the
<span class="lineNum">    3972 </span>            :    attribute list.  */
<span class="lineNum">    3973 </span>            : #define current_target_pragma           global_trees[TI_CURRENT_TARGET_PRAGMA]
<span class="lineNum">    3974 </span>            : #define current_optimize_pragma         global_trees[TI_CURRENT_OPTIMIZE_PRAGMA]
<span class="lineNum">    3975 </span>            : 
<span class="lineNum">    3976 </span>            : #define char_type_node                  integer_types[itk_char]
<span class="lineNum">    3977 </span>            : #define signed_char_type_node           integer_types[itk_signed_char]
<span class="lineNum">    3978 </span>            : #define unsigned_char_type_node         integer_types[itk_unsigned_char]
<span class="lineNum">    3979 </span>            : #define short_integer_type_node         integer_types[itk_short]
<span class="lineNum">    3980 </span>            : #define short_unsigned_type_node        integer_types[itk_unsigned_short]
<span class="lineNum">    3981 </span>            : #define integer_type_node               integer_types[itk_int]
<span class="lineNum">    3982 </span>            : #define unsigned_type_node              integer_types[itk_unsigned_int]
<span class="lineNum">    3983 </span>            : #define long_integer_type_node          integer_types[itk_long]
<span class="lineNum">    3984 </span>            : #define long_unsigned_type_node         integer_types[itk_unsigned_long]
<span class="lineNum">    3985 </span>            : #define long_long_integer_type_node     integer_types[itk_long_long]
<span class="lineNum">    3986 </span>            : #define long_long_unsigned_type_node    integer_types[itk_unsigned_long_long]
<span class="lineNum">    3987 </span>            : 
<span class="lineNum">    3988 </span>            : /* True if NODE is an erroneous expression.  */
<span class="lineNum">    3989 </span>            : 
<span class="lineNum">    3990 </span>            : #define error_operand_p(NODE)                                   \
<span class="lineNum">    3991 </span>            :   ((NODE) == error_mark_node                                    \
<span class="lineNum">    3992 </span>            :    || ((NODE) &amp;&amp; TREE_TYPE ((NODE)) == error_mark_node))
<span class="lineNum">    3993 </span>            : 
<span class="lineNum">    3994 </span>            : /* Return the number of elements encoded directly in a VECTOR_CST.  */
<a name="3995"><span class="lineNum">    3995 </span>            : </a>
<span class="lineNum">    3996 </span>            : inline unsigned int
<span class="lineNum">    3997 </span><span class="lineCov">    4458723 : vector_cst_encoded_nelts (const_tree t)</span>
<span class="lineNum">    3998 </span>            : {
<span class="lineNum">    3999 </span><span class="lineCov">    4458723 :   return VECTOR_CST_NPATTERNS (t) * VECTOR_CST_NELTS_PER_PATTERN (t);</span>
<span class="lineNum">    4000 </span>            : }
<span class="lineNum">    4001 </span>            : 
<span class="lineNum">    4002 </span>            : extern tree decl_assembler_name (tree);
<span class="lineNum">    4003 </span>            : extern void overwrite_decl_assembler_name (tree decl, tree name);
<span class="lineNum">    4004 </span>            : extern tree decl_comdat_group (const_tree);
<span class="lineNum">    4005 </span>            : extern tree decl_comdat_group_id (const_tree);
<span class="lineNum">    4006 </span>            : extern const char *decl_section_name (const_tree);
<span class="lineNum">    4007 </span>            : extern void set_decl_section_name (tree, const char *);
<span class="lineNum">    4008 </span>            : extern enum tls_model decl_tls_model (const_tree);
<span class="lineNum">    4009 </span>            : extern void set_decl_tls_model (tree, enum tls_model);
<span class="lineNum">    4010 </span>            : 
<span class="lineNum">    4011 </span>            : /* Compute the number of bytes occupied by 'node'.  This routine only
<span class="lineNum">    4012 </span>            :    looks at TREE_CODE and, if the code is TREE_VEC, TREE_VEC_LENGTH.  */
<span class="lineNum">    4013 </span>            : 
<span class="lineNum">    4014 </span>            : extern size_t tree_size (const_tree);
<span class="lineNum">    4015 </span>            : 
<span class="lineNum">    4016 </span>            : /* Compute the number of bytes occupied by a tree with code CODE.
<span class="lineNum">    4017 </span>            :    This function cannot be used for TREE_VEC or INTEGER_CST nodes,
<span class="lineNum">    4018 </span>            :    which are of variable length.  */
<span class="lineNum">    4019 </span>            : extern size_t tree_code_size (enum tree_code);
<span class="lineNum">    4020 </span>            : 
<span class="lineNum">    4021 </span>            : /* Allocate and return a new UID from the DECL_UID namespace.  */
<span class="lineNum">    4022 </span>            : extern int allocate_decl_uid (void);
<span class="lineNum">    4023 </span>            : 
<span class="lineNum">    4024 </span>            : /* Lowest level primitive for allocating a node.
<span class="lineNum">    4025 </span>            :    The TREE_CODE is the only argument.  Contents are initialized
<span class="lineNum">    4026 </span>            :    to zero except for a few of the common fields.  */
<span class="lineNum">    4027 </span>            : 
<span class="lineNum">    4028 </span>            : extern tree make_node (enum tree_code CXX_MEM_STAT_INFO);
<span class="lineNum">    4029 </span>            : 
<span class="lineNum">    4030 </span>            : /* Free tree node.  */
<span class="lineNum">    4031 </span>            : 
<span class="lineNum">    4032 </span>            : extern void free_node (tree);
<span class="lineNum">    4033 </span>            : 
<span class="lineNum">    4034 </span>            : /* Make a copy of a node, with all the same contents.  */
<span class="lineNum">    4035 </span>            : 
<span class="lineNum">    4036 </span>            : extern tree copy_node (tree CXX_MEM_STAT_INFO);
<span class="lineNum">    4037 </span>            : 
<span class="lineNum">    4038 </span>            : /* Make a copy of a chain of TREE_LIST nodes.  */
<span class="lineNum">    4039 </span>            : 
<span class="lineNum">    4040 </span>            : extern tree copy_list (tree);
<span class="lineNum">    4041 </span>            : 
<span class="lineNum">    4042 </span>            : /* Make a CASE_LABEL_EXPR.  */
<span class="lineNum">    4043 </span>            : 
<span class="lineNum">    4044 </span>            : extern tree build_case_label (tree, tree, tree);
<span class="lineNum">    4045 </span>            : 
<span class="lineNum">    4046 </span>            : /* Make a BINFO.  */
<span class="lineNum">    4047 </span>            : extern tree make_tree_binfo (unsigned CXX_MEM_STAT_INFO);
<span class="lineNum">    4048 </span>            : 
<span class="lineNum">    4049 </span>            : /* Make an INTEGER_CST.  */
<span class="lineNum">    4050 </span>            : 
<span class="lineNum">    4051 </span>            : extern tree make_int_cst (int, int CXX_MEM_STAT_INFO);
<span class="lineNum">    4052 </span>            : 
<span class="lineNum">    4053 </span>            : /* Make a TREE_VEC.  */
<span class="lineNum">    4054 </span>            : 
<span class="lineNum">    4055 </span>            : extern tree make_tree_vec (int CXX_MEM_STAT_INFO);
<span class="lineNum">    4056 </span>            : 
<span class="lineNum">    4057 </span>            : /* Grow a TREE_VEC.  */
<span class="lineNum">    4058 </span>            : 
<span class="lineNum">    4059 </span>            : extern tree grow_tree_vec (tree v, int CXX_MEM_STAT_INFO);
<span class="lineNum">    4060 </span>            : 
<span class="lineNum">    4061 </span>            : /* Construct various types of nodes.  */
<span class="lineNum">    4062 </span>            : 
<span class="lineNum">    4063 </span>            : extern tree build_nt (enum tree_code, ...);
<span class="lineNum">    4064 </span>            : extern tree build_nt_call_vec (tree, vec&lt;tree, va_gc&gt; *);
<span class="lineNum">    4065 </span>            : 
<span class="lineNum">    4066 </span>            : extern tree build0 (enum tree_code, tree CXX_MEM_STAT_INFO);
<span class="lineNum">    4067 </span>            : extern tree build1 (enum tree_code, tree, tree CXX_MEM_STAT_INFO);
<span class="lineNum">    4068 </span>            : extern tree build2 (enum tree_code, tree, tree, tree CXX_MEM_STAT_INFO);
<span class="lineNum">    4069 </span>            : extern tree build3 (enum tree_code, tree, tree, tree, tree CXX_MEM_STAT_INFO);
<span class="lineNum">    4070 </span>            : extern tree build4 (enum tree_code, tree, tree, tree, tree,
<span class="lineNum">    4071 </span>            :                     tree CXX_MEM_STAT_INFO);
<span class="lineNum">    4072 </span>            : extern tree build5 (enum tree_code, tree, tree, tree, tree, tree,
<span class="lineNum">    4073 </span>            :                     tree CXX_MEM_STAT_INFO);
<span class="lineNum">    4074 </span>            : 
<span class="lineNum">    4075 </span>            : /* _loc versions of build[1-5].  */
<span class="lineNum">    4076 </span>            : 
<span class="lineNum">    4077 </span>            : static inline tree
<span class="lineNum">    4078 </span>            : build1_loc (location_t loc, enum tree_code code, tree type,
<span class="lineNum">    4079 </span>            :             tree arg1 CXX_MEM_STAT_INFO)
<span class="lineNum">    4080 </span>            : {
<span class="lineNum">    4081 </span><span class="lineCov">  271799127 :   tree t = build1 (code, type, arg1 PASS_MEM_STAT);</span>
<span class="lineNum">    4082 </span><span class="lineCov">  271799127 :   if (CAN_HAVE_LOCATION_P (t))</span>
<span class="lineNum">    4083 </span><span class="lineCov">  271799127 :     SET_EXPR_LOCATION (t, loc);</span>
<span class="lineNum">    4084 </span><span class="lineCov">   15161366 :   return t;</span>
<span class="lineNum">    4085 </span>            : }
<a name="4086"><span class="lineNum">    4086 </span>            : </a>
<span class="lineNum">    4087 </span>            : static inline tree
<span class="lineNum">    4088 </span><span class="lineNoCov">          0 : build2_loc (location_t loc, enum tree_code code, tree type, tree arg0,</span>
<span class="lineNum">    4089 </span>            :             tree arg1 CXX_MEM_STAT_INFO)
<span class="lineNum">    4090 </span>            : {
<span class="lineNum">    4091 </span><span class="lineCov">  145639569 :   tree t = build2 (code, type, arg0, arg1 PASS_MEM_STAT);</span>
<span class="lineNum">    4092 </span><span class="lineCov">  145639569 :   if (CAN_HAVE_LOCATION_P (t))</span>
<span class="lineNum">    4093 </span><span class="lineCov">  145639569 :     SET_EXPR_LOCATION (t, loc);</span>
<span class="lineNum">    4094 </span><span class="lineCov">   30347879 :   return t;</span>
<span class="lineNum">    4095 </span>            : }
<span class="lineNum">    4096 </span>            : 
<span class="lineNum">    4097 </span>            : static inline tree
<span class="lineNum">    4098 </span>            : build3_loc (location_t loc, enum tree_code code, tree type, tree arg0,
<span class="lineNum">    4099 </span>            :             tree arg1, tree arg2 CXX_MEM_STAT_INFO)
<span class="lineNum">    4100 </span>            : {
<span class="lineNum">    4101 </span><span class="lineCov">   14833195 :   tree t = build3 (code, type, arg0, arg1, arg2 PASS_MEM_STAT);</span>
<span class="lineNum">    4102 </span><span class="lineCov">   14833195 :   if (CAN_HAVE_LOCATION_P (t))</span>
<span class="lineNum">    4103 </span><span class="lineCov">   14833195 :     SET_EXPR_LOCATION (t, loc);</span>
<span class="lineNum">    4104 </span><span class="lineCov">    8993164 :   return t;</span>
<span class="lineNum">    4105 </span>            : }
<span class="lineNum">    4106 </span>            : 
<span class="lineNum">    4107 </span>            : static inline tree
<span class="lineNum">    4108 </span>            : build4_loc (location_t loc, enum tree_code code, tree type, tree arg0,
<span class="lineNum">    4109 </span>            :             tree arg1, tree arg2, tree arg3 CXX_MEM_STAT_INFO)
<span class="lineNum">    4110 </span>            : {
<span class="lineNum">    4111 </span><span class="lineCov">     972998 :   tree t = build4 (code, type, arg0, arg1, arg2, arg3 PASS_MEM_STAT);</span>
<span class="lineNum">    4112 </span><span class="lineCov">     972998 :   if (CAN_HAVE_LOCATION_P (t))</span>
<span class="lineNum">    4113 </span><span class="lineCov">     972998 :     SET_EXPR_LOCATION (t, loc);</span>
<span class="lineNum">    4114 </span><span class="lineCov">     257411 :   return t;</span>
<span class="lineNum">    4115 </span>            : }
<span class="lineNum">    4116 </span>            : 
<span class="lineNum">    4117 </span>            : static inline tree
<span class="lineNum">    4118 </span>            : build5_loc (location_t loc, enum tree_code code, tree type, tree arg0,
<span class="lineNum">    4119 </span>            :             tree arg1, tree arg2, tree arg3, tree arg4 CXX_MEM_STAT_INFO)
<span class="lineNum">    4120 </span>            : {
<span class="lineNum">    4121 </span><span class="lineCov">       2230 :   tree t = build5 (code, type, arg0, arg1, arg2, arg3,</span>
<span class="lineNum">    4122 </span><span class="lineCov">       2230 :                         arg4 PASS_MEM_STAT);</span>
<span class="lineNum">    4123 </span><span class="lineCov">       2230 :   if (CAN_HAVE_LOCATION_P (t))</span>
<span class="lineNum">    4124 </span><span class="lineCov">       2230 :     SET_EXPR_LOCATION (t, loc);</span>
<span class="lineNum">    4125 </span><span class="lineCov">       2230 :   return t;</span>
<span class="lineNum">    4126 </span>            : }
<span class="lineNum">    4127 </span>            : 
<span class="lineNum">    4128 </span>            : /* Constructs double_int from tree CST.  */
<span class="lineNum">    4129 </span>            : 
<span class="lineNum">    4130 </span>            : extern tree double_int_to_tree (tree, double_int);
<span class="lineNum">    4131 </span>            : 
<span class="lineNum">    4132 </span>            : extern tree wide_int_to_tree (tree type, const poly_wide_int_ref &amp;cst);
<span class="lineNum">    4133 </span>            : extern tree force_fit_type (tree, const poly_wide_int_ref &amp;, int, bool);
<span class="lineNum">    4134 </span>            : 
<span class="lineNum">    4135 </span>            : /* Create an INT_CST node with a CST value zero extended.  */
<span class="lineNum">    4136 </span>            : 
<span class="lineNum">    4137 </span>            : /* static inline */
<span class="lineNum">    4138 </span>            : extern tree build_int_cst (tree, poly_int64);
<span class="lineNum">    4139 </span>            : extern tree build_int_cstu (tree type, poly_uint64);
<span class="lineNum">    4140 </span>            : extern tree build_int_cst_type (tree, poly_int64);
<span class="lineNum">    4141 </span>            : extern tree make_vector (unsigned, unsigned CXX_MEM_STAT_INFO);
<span class="lineNum">    4142 </span>            : extern tree build_vector_from_ctor (tree, vec&lt;constructor_elt, va_gc&gt; *);
<span class="lineNum">    4143 </span>            : extern tree build_vector_from_val (tree, tree);
<span class="lineNum">    4144 </span>            : extern tree build_vec_series (tree, tree, tree);
<span class="lineNum">    4145 </span>            : extern tree build_index_vector (tree, poly_uint64, poly_uint64);
<span class="lineNum">    4146 </span>            : extern void recompute_constructor_flags (tree);
<span class="lineNum">    4147 </span>            : extern void verify_constructor_flags (tree);
<span class="lineNum">    4148 </span>            : extern tree build_constructor (tree, vec&lt;constructor_elt, va_gc&gt; *);
<span class="lineNum">    4149 </span>            : extern tree build_constructor_single (tree, tree, tree);
<span class="lineNum">    4150 </span>            : extern tree build_constructor_from_list (tree, tree);
<span class="lineNum">    4151 </span>            : extern tree build_constructor_va (tree, int, ...);
<span class="lineNum">    4152 </span>            : extern tree build_clobber (tree);
<span class="lineNum">    4153 </span>            : extern tree build_real_from_int_cst (tree, const_tree);
<span class="lineNum">    4154 </span>            : extern tree build_complex (tree, tree, tree);
<span class="lineNum">    4155 </span>            : extern tree build_complex_inf (tree, bool);
<span class="lineNum">    4156 </span>            : extern tree build_each_one_cst (tree);
<span class="lineNum">    4157 </span>            : extern tree build_one_cst (tree);
<span class="lineNum">    4158 </span>            : extern tree build_minus_one_cst (tree);
<span class="lineNum">    4159 </span>            : extern tree build_all_ones_cst (tree);
<span class="lineNum">    4160 </span>            : extern tree build_zero_cst (tree);
<span class="lineNum">    4161 </span>            : extern tree build_string (int, const char *);
<span class="lineNum">    4162 </span>            : extern tree build_poly_int_cst (tree, const poly_wide_int_ref &amp;);
<span class="lineNum">    4163 </span>            : extern tree build_tree_list (tree, tree CXX_MEM_STAT_INFO);
<span class="lineNum">    4164 </span>            : extern tree build_tree_list_vec (const vec&lt;tree, va_gc&gt; * CXX_MEM_STAT_INFO);
<span class="lineNum">    4165 </span>            : extern tree build_decl (location_t, enum tree_code,
<span class="lineNum">    4166 </span>            :                         tree, tree CXX_MEM_STAT_INFO);
<span class="lineNum">    4167 </span>            : extern tree build_fn_decl (const char *, tree);
<span class="lineNum">    4168 </span>            : extern tree build_translation_unit_decl (tree);
<span class="lineNum">    4169 </span>            : extern tree build_block (tree, tree, tree, tree);
<span class="lineNum">    4170 </span>            : extern tree build_empty_stmt (location_t);
<span class="lineNum">    4171 </span>            : extern tree build_omp_clause (location_t, enum omp_clause_code);
<span class="lineNum">    4172 </span>            : 
<span class="lineNum">    4173 </span>            : extern tree build_vl_exp (enum tree_code, int CXX_MEM_STAT_INFO);
<span class="lineNum">    4174 </span>            : 
<span class="lineNum">    4175 </span>            : extern tree build_call_nary (tree, tree, int, ...);
<span class="lineNum">    4176 </span>            : extern tree build_call_valist (tree, tree, int, va_list);
<span class="lineNum">    4177 </span>            : #define build_call_array(T1,T2,N,T3)\
<span class="lineNum">    4178 </span>            :    build_call_array_loc (UNKNOWN_LOCATION, T1, T2, N, T3)
<span class="lineNum">    4179 </span>            : extern tree build_call_array_loc (location_t, tree, tree, int, const tree *);
<span class="lineNum">    4180 </span>            : extern tree build_call_vec (tree, tree, vec&lt;tree, va_gc&gt; *);
<span class="lineNum">    4181 </span>            : extern tree build_call_expr_loc_array (location_t, tree, int, tree *);
<span class="lineNum">    4182 </span>            : extern tree build_call_expr_loc_vec (location_t, tree, vec&lt;tree, va_gc&gt; *);
<span class="lineNum">    4183 </span>            : extern tree build_call_expr_loc (location_t, tree, int, ...);
<span class="lineNum">    4184 </span>            : extern tree build_call_expr (tree, int, ...);
<span class="lineNum">    4185 </span>            : extern tree build_call_expr_internal_loc (location_t, enum internal_fn,
<span class="lineNum">    4186 </span>            :                                           tree, int, ...);
<span class="lineNum">    4187 </span>            : extern tree build_call_expr_internal_loc_array (location_t, enum internal_fn,
<span class="lineNum">    4188 </span>            :                                                 tree, int, const tree *);
<span class="lineNum">    4189 </span>            : extern tree maybe_build_call_expr_loc (location_t, combined_fn, tree,
<span class="lineNum">    4190 </span>            :                                        int, ...);
<span class="lineNum">    4191 </span>            : extern tree build_alloca_call_expr (tree, unsigned int, HOST_WIDE_INT);
<span class="lineNum">    4192 </span>            : extern tree build_string_literal (int, const char *);
<span class="lineNum">    4193 </span>            : 
<span class="lineNum">    4194 </span>            : /* Construct various nodes representing data types.  */
<span class="lineNum">    4195 </span>            : 
<span class="lineNum">    4196 </span>            : extern tree signed_or_unsigned_type_for (int, tree);
<span class="lineNum">    4197 </span>            : extern tree signed_type_for (tree);
<span class="lineNum">    4198 </span>            : extern tree unsigned_type_for (tree);
<span class="lineNum">    4199 </span>            : extern tree truth_type_for (tree);
<span class="lineNum">    4200 </span>            : extern tree build_pointer_type_for_mode (tree, machine_mode, bool);
<span class="lineNum">    4201 </span>            : extern tree build_pointer_type (tree);
<span class="lineNum">    4202 </span>            : extern tree build_reference_type_for_mode (tree, machine_mode, bool);
<span class="lineNum">    4203 </span>            : extern tree build_reference_type (tree);
<span class="lineNum">    4204 </span>            : extern tree build_vector_type_for_mode (tree, machine_mode);
<span class="lineNum">    4205 </span>            : extern tree build_vector_type (tree, poly_int64);
<span class="lineNum">    4206 </span>            : extern tree build_truth_vector_type (poly_uint64, poly_uint64);
<span class="lineNum">    4207 </span>            : extern tree build_same_sized_truth_vector_type (tree vectype);
<span class="lineNum">    4208 </span>            : extern tree build_opaque_vector_type (tree, poly_int64);
<span class="lineNum">    4209 </span>            : extern tree build_index_type (tree);
<span class="lineNum">    4210 </span>            : extern tree build_array_type (tree, tree, bool = false);
<span class="lineNum">    4211 </span>            : extern tree build_nonshared_array_type (tree, tree);
<span class="lineNum">    4212 </span>            : extern tree build_array_type_nelts (tree, poly_uint64);
<span class="lineNum">    4213 </span>            : extern tree build_function_type (tree, tree);
<span class="lineNum">    4214 </span>            : extern tree build_function_type_list (tree, ...);
<span class="lineNum">    4215 </span>            : extern tree build_varargs_function_type_list (tree, ...);
<span class="lineNum">    4216 </span>            : extern tree build_function_type_array (tree, int, tree *);
<span class="lineNum">    4217 </span>            : extern tree build_varargs_function_type_array (tree, int, tree *);
<span class="lineNum">    4218 </span>            : #define build_function_type_vec(RET, V) \
<span class="lineNum">    4219 </span>            :   build_function_type_array (RET, vec_safe_length (V), vec_safe_address (V))
<span class="lineNum">    4220 </span>            : #define build_varargs_function_type_vec(RET, V) \
<span class="lineNum">    4221 </span>            :   build_varargs_function_type_array (RET, vec_safe_length (V), \
<span class="lineNum">    4222 </span>            :                                      vec_safe_address (V))
<span class="lineNum">    4223 </span>            : extern tree build_method_type_directly (tree, tree, tree);
<span class="lineNum">    4224 </span>            : extern tree build_method_type (tree, tree);
<span class="lineNum">    4225 </span>            : extern tree build_offset_type (tree, tree);
<span class="lineNum">    4226 </span>            : extern tree build_complex_type (tree, bool named = false);
<span class="lineNum">    4227 </span>            : extern tree array_type_nelts (const_tree);
<span class="lineNum">    4228 </span>            : 
<span class="lineNum">    4229 </span>            : extern tree value_member (tree, tree);
<span class="lineNum">    4230 </span>            : extern tree purpose_member (const_tree, tree);
<span class="lineNum">    4231 </span>            : extern bool vec_member (const_tree, vec&lt;tree, va_gc&gt; *);
<span class="lineNum">    4232 </span>            : extern tree chain_index (int, tree);
<span class="lineNum">    4233 </span>            : 
<span class="lineNum">    4234 </span>            : extern int tree_int_cst_equal (const_tree, const_tree);
<span class="lineNum">    4235 </span>            : 
<span class="lineNum">    4236 </span>            : extern bool tree_fits_shwi_p (const_tree) ATTRIBUTE_PURE;
<span class="lineNum">    4237 </span>            : extern bool tree_fits_poly_int64_p (const_tree) ATTRIBUTE_PURE;
<span class="lineNum">    4238 </span>            : extern bool tree_fits_uhwi_p (const_tree) ATTRIBUTE_PURE;
<span class="lineNum">    4239 </span>            : extern bool tree_fits_poly_uint64_p (const_tree) ATTRIBUTE_PURE;
<span class="lineNum">    4240 </span>            : extern HOST_WIDE_INT tree_to_shwi (const_tree);
<span class="lineNum">    4241 </span>            : extern poly_int64 tree_to_poly_int64 (const_tree);
<span class="lineNum">    4242 </span>            : extern unsigned HOST_WIDE_INT tree_to_uhwi (const_tree);
<span class="lineNum">    4243 </span>            : extern poly_uint64 tree_to_poly_uint64 (const_tree);
<span class="lineNum">    4244 </span>            : #if !defined ENABLE_TREE_CHECKING &amp;&amp; (GCC_VERSION &gt;= 4003)
<span class="lineNum">    4245 </span>            : extern inline __attribute__ ((__gnu_inline__)) HOST_WIDE_INT
<span class="lineNum">    4246 </span>            : tree_to_shwi (const_tree t)
<span class="lineNum">    4247 </span>            : {
<span class="lineNum">    4248 </span>            :   gcc_assert (tree_fits_shwi_p (t));
<span class="lineNum">    4249 </span>            :   return TREE_INT_CST_LOW (t);
<span class="lineNum">    4250 </span>            : }
<span class="lineNum">    4251 </span>            : 
<span class="lineNum">    4252 </span>            : extern inline __attribute__ ((__gnu_inline__)) unsigned HOST_WIDE_INT
<span class="lineNum">    4253 </span>            : tree_to_uhwi (const_tree t)
<span class="lineNum">    4254 </span>            : {
<span class="lineNum">    4255 </span>            :   gcc_assert (tree_fits_uhwi_p (t));
<span class="lineNum">    4256 </span>            :   return TREE_INT_CST_LOW (t);
<span class="lineNum">    4257 </span>            : }
<span class="lineNum">    4258 </span>            : #if NUM_POLY_INT_COEFFS == 1
<span class="lineNum">    4259 </span>            : extern inline __attribute__ ((__gnu_inline__)) poly_int64
<span class="lineNum">    4260 </span>            : tree_to_poly_int64 (const_tree t)
<span class="lineNum">    4261 </span>            : {
<span class="lineNum">    4262 </span>            :   gcc_assert (tree_fits_poly_int64_p (t));
<span class="lineNum">    4263 </span>            :   return TREE_INT_CST_LOW (t);
<span class="lineNum">    4264 </span>            : }
<span class="lineNum">    4265 </span>            : 
<span class="lineNum">    4266 </span>            : extern inline __attribute__ ((__gnu_inline__)) poly_uint64
<span class="lineNum">    4267 </span>            : tree_to_poly_uint64 (const_tree t)
<span class="lineNum">    4268 </span>            : {
<span class="lineNum">    4269 </span>            :   gcc_assert (tree_fits_poly_uint64_p (t));
<span class="lineNum">    4270 </span>            :   return TREE_INT_CST_LOW (t);
<span class="lineNum">    4271 </span>            : }
<span class="lineNum">    4272 </span>            : #endif
<span class="lineNum">    4273 </span>            : #endif
<span class="lineNum">    4274 </span>            : extern int tree_int_cst_sgn (const_tree);
<span class="lineNum">    4275 </span>            : extern int tree_int_cst_sign_bit (const_tree);
<span class="lineNum">    4276 </span>            : extern unsigned int tree_int_cst_min_precision (tree, signop);
<span class="lineNum">    4277 </span>            : extern tree strip_array_types (tree);
<span class="lineNum">    4278 </span>            : extern tree excess_precision_type (tree);
<span class="lineNum">    4279 </span>            : extern bool valid_constant_size_p (const_tree);
<span class="lineNum">    4280 </span>            : 
<span class="lineNum">    4281 </span>            : /* Return true if T holds a value that can be represented as a poly_int64
<span class="lineNum">    4282 </span>            :    without loss of precision.  Store the value in *VALUE if so.  */
<a name="4283"><span class="lineNum">    4283 </span>            : </a>
<span class="lineNum">    4284 </span>            : inline bool
<span class="lineNum">    4285 </span><span class="lineNoCov">          0 : poly_int_tree_p (const_tree t, poly_int64_pod *value)</span>
<span class="lineNum">    4286 </span>            : {
<span class="lineNum">    4287 </span><span class="lineNoCov">          0 :   if (tree_fits_poly_int64_p (t))</span>
<span class="lineNum">    4288 </span>            :     {
<span class="lineNum">    4289 </span><span class="lineNoCov">          0 :       *value = tree_to_poly_int64 (t);</span>
<span class="lineNum">    4290 </span><span class="lineNoCov">          0 :       return true;</span>
<span class="lineNum">    4291 </span>            :     }
<span class="lineNum">    4292 </span>            :   return false;
<span class="lineNum">    4293 </span>            : }
<span class="lineNum">    4294 </span>            : 
<span class="lineNum">    4295 </span>            : /* Return true if T holds a value that can be represented as a poly_uint64
<span class="lineNum">    4296 </span>            :    without loss of precision.  Store the value in *VALUE if so.  */
<a name="4297"><span class="lineNum">    4297 </span>            : </a>
<span class="lineNum">    4298 </span>            : inline bool
<span class="lineNum">    4299 </span><span class="lineNoCov">          0 : poly_int_tree_p (const_tree t, poly_uint64_pod *value)</span>
<span class="lineNum">    4300 </span>            : {
<span class="lineNum">    4301 </span><span class="lineNoCov">          0 :   if (tree_fits_poly_uint64_p (t))</span>
<span class="lineNum">    4302 </span>            :     {
<span class="lineNum">    4303 </span><span class="lineNoCov">          0 :       *value = tree_to_poly_uint64 (t);</span>
<span class="lineNum">    4304 </span><span class="lineNoCov">          0 :       return true;</span>
<span class="lineNum">    4305 </span>            :     }
<span class="lineNum">    4306 </span>            :   return false;
<span class="lineNum">    4307 </span>            : }
<span class="lineNum">    4308 </span>            : 
<span class="lineNum">    4309 </span>            : /* From expmed.c.  Since rtl.h is included after tree.h, we can't
<span class="lineNum">    4310 </span>            :    put the prototype here.  Rtl.h does declare the prototype if
<span class="lineNum">    4311 </span>            :    tree.h had been included.  */
<span class="lineNum">    4312 </span>            : 
<span class="lineNum">    4313 </span>            : extern tree make_tree (tree, rtx);
<span class="lineNum">    4314 </span>            : 
<span class="lineNum">    4315 </span>            : /* Returns true iff CAND and BASE have equivalent language-specific
<span class="lineNum">    4316 </span>            :    qualifiers.  */
<span class="lineNum">    4317 </span>            : 
<span class="lineNum">    4318 </span>            : extern bool check_lang_type (const_tree cand, const_tree base);
<span class="lineNum">    4319 </span>            : 
<span class="lineNum">    4320 </span>            : /* Returns true iff unqualified CAND and BASE are equivalent.  */
<span class="lineNum">    4321 </span>            : 
<span class="lineNum">    4322 </span>            : extern bool check_base_type (const_tree cand, const_tree base);
<span class="lineNum">    4323 </span>            : 
<span class="lineNum">    4324 </span>            : /* Check whether CAND is suitable to be returned from get_qualified_type
<span class="lineNum">    4325 </span>            :    (BASE, TYPE_QUALS).  */
<span class="lineNum">    4326 </span>            : 
<span class="lineNum">    4327 </span>            : extern bool check_qualified_type (const_tree, const_tree, int);
<span class="lineNum">    4328 </span>            : 
<span class="lineNum">    4329 </span>            : /* Return a version of the TYPE, qualified as indicated by the
<span class="lineNum">    4330 </span>            :    TYPE_QUALS, if one exists.  If no qualified version exists yet,
<span class="lineNum">    4331 </span>            :    return NULL_TREE.  */
<span class="lineNum">    4332 </span>            : 
<span class="lineNum">    4333 </span>            : extern tree get_qualified_type (tree, int);
<span class="lineNum">    4334 </span>            : 
<span class="lineNum">    4335 </span>            : /* Like get_qualified_type, but creates the type if it does not
<span class="lineNum">    4336 </span>            :    exist.  This function never returns NULL_TREE.  */
<span class="lineNum">    4337 </span>            : 
<span class="lineNum">    4338 </span>            : extern tree build_qualified_type (tree, int CXX_MEM_STAT_INFO);
<span class="lineNum">    4339 </span>            : 
<span class="lineNum">    4340 </span>            : /* Create a variant of type T with alignment ALIGN.  */
<span class="lineNum">    4341 </span>            : 
<span class="lineNum">    4342 </span>            : extern tree build_aligned_type (tree, unsigned int);
<span class="lineNum">    4343 </span>            : 
<span class="lineNum">    4344 </span>            : /* Like build_qualified_type, but only deals with the `const' and
<span class="lineNum">    4345 </span>            :    `volatile' qualifiers.  This interface is retained for backwards
<span class="lineNum">    4346 </span>            :    compatibility with the various front-ends; new code should use
<span class="lineNum">    4347 </span>            :    build_qualified_type instead.  */
<span class="lineNum">    4348 </span>            : 
<span class="lineNum">    4349 </span>            : #define build_type_variant(TYPE, CONST_P, VOLATILE_P)                   \
<span class="lineNum">    4350 </span>            :   build_qualified_type ((TYPE),                                         \
<span class="lineNum">    4351 </span>            :                         ((CONST_P) ? TYPE_QUAL_CONST : 0)               \
<span class="lineNum">    4352 </span>            :                         | ((VOLATILE_P) ? TYPE_QUAL_VOLATILE : 0))
<span class="lineNum">    4353 </span>            : 
<span class="lineNum">    4354 </span>            : /* Make a copy of a type node.  */
<span class="lineNum">    4355 </span>            : 
<span class="lineNum">    4356 </span>            : extern tree build_distinct_type_copy (tree CXX_MEM_STAT_INFO);
<span class="lineNum">    4357 </span>            : extern tree build_variant_type_copy (tree CXX_MEM_STAT_INFO);
<span class="lineNum">    4358 </span>            : 
<span class="lineNum">    4359 </span>            : /* Given a hashcode and a ..._TYPE node (for which the hashcode was made),
<span class="lineNum">    4360 </span>            :    return a canonicalized ..._TYPE node, so that duplicates are not made.
<span class="lineNum">    4361 </span>            :    How the hash code is computed is up to the caller, as long as any two
<span class="lineNum">    4362 </span>            :    callers that could hash identical-looking type nodes agree.  */
<span class="lineNum">    4363 </span>            : 
<span class="lineNum">    4364 </span>            : extern hashval_t type_hash_canon_hash (tree);
<span class="lineNum">    4365 </span>            : extern tree type_hash_canon (unsigned int, tree);
<span class="lineNum">    4366 </span>            : 
<span class="lineNum">    4367 </span>            : extern tree convert (tree, tree);
<span class="lineNum">    4368 </span>            : extern unsigned int expr_align (const_tree);
<span class="lineNum">    4369 </span>            : extern tree size_in_bytes_loc (location_t, const_tree);
<span class="lineNum">    4370 </span>            : inline tree
<span class="lineNum">    4371 </span>            : size_in_bytes (const_tree t)
<span class="lineNum">    4372 </span>            : {
<span class="lineNum">    4373 </span><span class="lineCov">   11432269 :   return size_in_bytes_loc (input_location, t);</span>
<span class="lineNum">    4374 </span>            : }
<span class="lineNum">    4375 </span>            : 
<span class="lineNum">    4376 </span>            : extern HOST_WIDE_INT int_size_in_bytes (const_tree);
<span class="lineNum">    4377 </span>            : extern HOST_WIDE_INT max_int_size_in_bytes (const_tree);
<span class="lineNum">    4378 </span>            : extern tree bit_position (const_tree);
<span class="lineNum">    4379 </span>            : extern tree byte_position (const_tree);
<span class="lineNum">    4380 </span>            : extern HOST_WIDE_INT int_byte_position (const_tree);
<span class="lineNum">    4381 </span>            : 
<span class="lineNum">    4382 </span>            : /* Type for sizes of data-type.  */
<span class="lineNum">    4383 </span>            : 
<span class="lineNum">    4384 </span>            : #define sizetype sizetype_tab[(int) stk_sizetype]
<span class="lineNum">    4385 </span>            : #define bitsizetype sizetype_tab[(int) stk_bitsizetype]
<span class="lineNum">    4386 </span>            : #define ssizetype sizetype_tab[(int) stk_ssizetype]
<span class="lineNum">    4387 </span>            : #define sbitsizetype sizetype_tab[(int) stk_sbitsizetype]
<span class="lineNum">    4388 </span>            : #define size_int(L) size_int_kind (L, stk_sizetype)
<span class="lineNum">    4389 </span>            : #define ssize_int(L) size_int_kind (L, stk_ssizetype)
<span class="lineNum">    4390 </span>            : #define bitsize_int(L) size_int_kind (L, stk_bitsizetype)
<span class="lineNum">    4391 </span>            : #define sbitsize_int(L) size_int_kind (L, stk_sbitsizetype)
<span class="lineNum">    4392 </span>            : 
<span class="lineNum">    4393 </span>            : /* Log2 of BITS_PER_UNIT.  */
<span class="lineNum">    4394 </span>            : 
<span class="lineNum">    4395 </span>            : #if BITS_PER_UNIT == 8
<span class="lineNum">    4396 </span>            : #define LOG2_BITS_PER_UNIT 3
<span class="lineNum">    4397 </span>            : #elif BITS_PER_UNIT == 16
<span class="lineNum">    4398 </span>            : #define LOG2_BITS_PER_UNIT 4
<span class="lineNum">    4399 </span>            : #else
<span class="lineNum">    4400 </span>            : #error Unknown BITS_PER_UNIT
<span class="lineNum">    4401 </span>            : #endif
<span class="lineNum">    4402 </span>            : 
<span class="lineNum">    4403 </span>            : /* Concatenate two lists (chains of TREE_LIST nodes) X and Y
<span class="lineNum">    4404 </span>            :    by making the last node in X point to Y.
<span class="lineNum">    4405 </span>            :    Returns X, except if X is 0 returns Y.  */
<span class="lineNum">    4406 </span>            : 
<span class="lineNum">    4407 </span>            : extern tree chainon (tree, tree);
<span class="lineNum">    4408 </span>            : 
<span class="lineNum">    4409 </span>            : /* Make a new TREE_LIST node from specified PURPOSE, VALUE and CHAIN.  */
<span class="lineNum">    4410 </span>            : 
<span class="lineNum">    4411 </span>            : extern tree tree_cons (tree, tree, tree CXX_MEM_STAT_INFO);
<span class="lineNum">    4412 </span>            : 
<span class="lineNum">    4413 </span>            : /* Return the last tree node in a chain.  */
<span class="lineNum">    4414 </span>            : 
<span class="lineNum">    4415 </span>            : extern tree tree_last (tree);
<span class="lineNum">    4416 </span>            : 
<span class="lineNum">    4417 </span>            : /* Reverse the order of elements in a chain, and return the new head.  */
<span class="lineNum">    4418 </span>            : 
<span class="lineNum">    4419 </span>            : extern tree nreverse (tree);
<span class="lineNum">    4420 </span>            : 
<span class="lineNum">    4421 </span>            : /* Returns the length of a chain of nodes
<span class="lineNum">    4422 </span>            :    (number of chain pointers to follow before reaching a null pointer).  */
<span class="lineNum">    4423 </span>            : 
<span class="lineNum">    4424 </span>            : extern int list_length (const_tree);
<span class="lineNum">    4425 </span>            : 
<span class="lineNum">    4426 </span>            : /* Returns the first FIELD_DECL in a type.  */
<span class="lineNum">    4427 </span>            : 
<span class="lineNum">    4428 </span>            : extern tree first_field (const_tree);
<span class="lineNum">    4429 </span>            : 
<span class="lineNum">    4430 </span>            : /* Given an initializer INIT, return TRUE if INIT is zero or some
<span class="lineNum">    4431 </span>            :    aggregate of zeros.  Otherwise return FALSE.  If NONZERO is not
<span class="lineNum">    4432 </span>            :    null, set *NONZERO if and only if INIT is known not to be all
<span class="lineNum">    4433 </span>            :    zeros.  The combination of return value of false and *NONZERO
<span class="lineNum">    4434 </span>            :    false implies that INIT may but need not be all zeros.  Other
<span class="lineNum">    4435 </span>            :    combinations indicate definitive answers.  */
<span class="lineNum">    4436 </span>            : 
<span class="lineNum">    4437 </span>            : extern bool initializer_zerop (const_tree, bool * = NULL);
<span class="lineNum">    4438 </span>            : 
<span class="lineNum">    4439 </span>            : extern wide_int vector_cst_int_elt (const_tree, unsigned int);
<span class="lineNum">    4440 </span>            : extern tree vector_cst_elt (const_tree, unsigned int);
<span class="lineNum">    4441 </span>            : 
<span class="lineNum">    4442 </span>            : /* Given a vector VEC, return its first element if all elements are
<span class="lineNum">    4443 </span>            :    the same.  Otherwise return NULL_TREE.  */
<span class="lineNum">    4444 </span>            : 
<span class="lineNum">    4445 </span>            : extern tree uniform_vector_p (const_tree);
<span class="lineNum">    4446 </span>            : 
<span class="lineNum">    4447 </span>            : /* Given a CONSTRUCTOR CTOR, return the element values as a vector.  */
<span class="lineNum">    4448 </span>            : 
<span class="lineNum">    4449 </span>            : extern vec&lt;tree, va_gc&gt; *ctor_to_vec (tree);
<span class="lineNum">    4450 </span>            : 
<span class="lineNum">    4451 </span>            : /* zerop (tree x) is nonzero if X is a constant of value 0.  */
<span class="lineNum">    4452 </span>            : 
<span class="lineNum">    4453 </span>            : extern int zerop (const_tree);
<span class="lineNum">    4454 </span>            : 
<span class="lineNum">    4455 </span>            : /* integer_zerop (tree x) is nonzero if X is an integer constant of value 0.  */
<span class="lineNum">    4456 </span>            : 
<span class="lineNum">    4457 </span>            : extern int integer_zerop (const_tree);
<span class="lineNum">    4458 </span>            : 
<span class="lineNum">    4459 </span>            : /* integer_onep (tree x) is nonzero if X is an integer constant of value 1.  */
<span class="lineNum">    4460 </span>            : 
<span class="lineNum">    4461 </span>            : extern int integer_onep (const_tree);
<span class="lineNum">    4462 </span>            : 
<span class="lineNum">    4463 </span>            : /* integer_onep (tree x) is nonzero if X is an integer constant of value 1, or
<span class="lineNum">    4464 </span>            :    a vector or complex where each part is 1.  */
<span class="lineNum">    4465 </span>            : 
<span class="lineNum">    4466 </span>            : extern int integer_each_onep (const_tree);
<span class="lineNum">    4467 </span>            : 
<span class="lineNum">    4468 </span>            : /* integer_all_onesp (tree x) is nonzero if X is an integer constant
<span class="lineNum">    4469 </span>            :    all of whose significant bits are 1.  */
<span class="lineNum">    4470 </span>            : 
<span class="lineNum">    4471 </span>            : extern int integer_all_onesp (const_tree);
<span class="lineNum">    4472 </span>            : 
<span class="lineNum">    4473 </span>            : /* integer_minus_onep (tree x) is nonzero if X is an integer constant of
<span class="lineNum">    4474 </span>            :    value -1.  */
<span class="lineNum">    4475 </span>            : 
<span class="lineNum">    4476 </span>            : extern int integer_minus_onep (const_tree);
<span class="lineNum">    4477 </span>            : 
<span class="lineNum">    4478 </span>            : /* integer_pow2p (tree x) is nonzero is X is an integer constant with
<span class="lineNum">    4479 </span>            :    exactly one bit 1.  */
<span class="lineNum">    4480 </span>            : 
<span class="lineNum">    4481 </span>            : extern int integer_pow2p (const_tree);
<span class="lineNum">    4482 </span>            : 
<span class="lineNum">    4483 </span>            : /* integer_nonzerop (tree x) is nonzero if X is an integer constant
<span class="lineNum">    4484 </span>            :    with a nonzero value.  */
<span class="lineNum">    4485 </span>            : 
<span class="lineNum">    4486 </span>            : extern int integer_nonzerop (const_tree);
<span class="lineNum">    4487 </span>            : 
<span class="lineNum">    4488 </span>            : /* integer_truep (tree x) is nonzero if X is an integer constant of value 1 or
<span class="lineNum">    4489 </span>            :    a vector where each element is an integer constant of value -1.  */
<span class="lineNum">    4490 </span>            : 
<span class="lineNum">    4491 </span>            : extern int integer_truep (const_tree);
<span class="lineNum">    4492 </span>            : 
<span class="lineNum">    4493 </span>            : extern bool cst_and_fits_in_hwi (const_tree);
<span class="lineNum">    4494 </span>            : extern tree num_ending_zeros (const_tree);
<span class="lineNum">    4495 </span>            : 
<span class="lineNum">    4496 </span>            : /* fixed_zerop (tree x) is nonzero if X is a fixed-point constant of
<span class="lineNum">    4497 </span>            :    value 0.  */
<span class="lineNum">    4498 </span>            : 
<span class="lineNum">    4499 </span>            : extern int fixed_zerop (const_tree);
<span class="lineNum">    4500 </span>            : 
<span class="lineNum">    4501 </span>            : /* staticp (tree x) is nonzero if X is a reference to data allocated
<span class="lineNum">    4502 </span>            :    at a fixed address in memory.  Returns the outermost data.  */
<span class="lineNum">    4503 </span>            : 
<span class="lineNum">    4504 </span>            : extern tree staticp (tree);
<span class="lineNum">    4505 </span>            : 
<span class="lineNum">    4506 </span>            : /* save_expr (EXP) returns an expression equivalent to EXP
<span class="lineNum">    4507 </span>            :    but it can be used multiple times within context CTX
<span class="lineNum">    4508 </span>            :    and only evaluate EXP once.  */
<span class="lineNum">    4509 </span>            : 
<span class="lineNum">    4510 </span>            : extern tree save_expr (tree);
<span class="lineNum">    4511 </span>            : 
<span class="lineNum">    4512 </span>            : /* Return true if T is function-invariant.  */
<span class="lineNum">    4513 </span>            : 
<span class="lineNum">    4514 </span>            : extern bool tree_invariant_p (tree);
<span class="lineNum">    4515 </span>            : 
<span class="lineNum">    4516 </span>            : /* Look inside EXPR into any simple arithmetic operations.  Return the
<span class="lineNum">    4517 </span>            :    outermost non-arithmetic or non-invariant node.  */
<span class="lineNum">    4518 </span>            : 
<span class="lineNum">    4519 </span>            : extern tree skip_simple_arithmetic (tree);
<span class="lineNum">    4520 </span>            : 
<span class="lineNum">    4521 </span>            : /* Look inside EXPR into simple arithmetic operations involving constants.
<span class="lineNum">    4522 </span>            :    Return the outermost non-arithmetic or non-constant node.  */
<span class="lineNum">    4523 </span>            : 
<span class="lineNum">    4524 </span>            : extern tree skip_simple_constant_arithmetic (tree);
<span class="lineNum">    4525 </span>            : 
<span class="lineNum">    4526 </span>            : /* Return which tree structure is used by T.  */
<span class="lineNum">    4527 </span>            : 
<span class="lineNum">    4528 </span>            : enum tree_node_structure_enum tree_node_structure (const_tree);
<span class="lineNum">    4529 </span>            : 
<span class="lineNum">    4530 </span>            : /* Return true if EXP contains a PLACEHOLDER_EXPR, i.e. if it represents a
<span class="lineNum">    4531 </span>            :    size or offset that depends on a field within a record.  */
<span class="lineNum">    4532 </span>            : 
<span class="lineNum">    4533 </span>            : extern bool contains_placeholder_p (const_tree);
<span class="lineNum">    4534 </span>            : 
<span class="lineNum">    4535 </span>            : /* This macro calls the above function but short-circuits the common
<span class="lineNum">    4536 </span>            :    case of a constant to save time.  Also check for null.  */
<span class="lineNum">    4537 </span>            : 
<span class="lineNum">    4538 </span>            : #define CONTAINS_PLACEHOLDER_P(EXP) \
<span class="lineNum">    4539 </span>            :   ((EXP) != 0 &amp;&amp; ! TREE_CONSTANT (EXP) &amp;&amp; contains_placeholder_p (EXP))
<span class="lineNum">    4540 </span>            : 
<span class="lineNum">    4541 </span>            : /* Return true if any part of the structure of TYPE involves a PLACEHOLDER_EXPR
<span class="lineNum">    4542 </span>            :    directly.  This includes size, bounds, qualifiers (for QUAL_UNION_TYPE) and
<span class="lineNum">    4543 </span>            :    field positions.  */
<span class="lineNum">    4544 </span>            : 
<span class="lineNum">    4545 </span>            : extern bool type_contains_placeholder_p (tree);
<span class="lineNum">    4546 </span>            : 
<span class="lineNum">    4547 </span>            : /* Given a tree EXP, find all occurrences of references to fields
<span class="lineNum">    4548 </span>            :    in a PLACEHOLDER_EXPR and place them in vector REFS without
<span class="lineNum">    4549 </span>            :    duplicates.  Also record VAR_DECLs and CONST_DECLs.  Note that
<span class="lineNum">    4550 </span>            :    we assume here that EXP contains only arithmetic expressions
<span class="lineNum">    4551 </span>            :    or CALL_EXPRs with PLACEHOLDER_EXPRs occurring only in their
<span class="lineNum">    4552 </span>            :    argument list.  */
<span class="lineNum">    4553 </span>            : 
<span class="lineNum">    4554 </span>            : extern void find_placeholder_in_expr (tree, vec&lt;tree&gt; *);
<span class="lineNum">    4555 </span>            : 
<span class="lineNum">    4556 </span>            : /* This macro calls the above function but short-circuits the common
<span class="lineNum">    4557 </span>            :    case of a constant to save time and also checks for NULL.  */
<span class="lineNum">    4558 </span>            : 
<span class="lineNum">    4559 </span>            : #define FIND_PLACEHOLDER_IN_EXPR(EXP, V) \
<span class="lineNum">    4560 </span>            : do {                                     \
<span class="lineNum">    4561 </span>            :   if((EXP) &amp;&amp; !TREE_CONSTANT (EXP))      \
<span class="lineNum">    4562 </span>            :     find_placeholder_in_expr (EXP, V);   \
<span class="lineNum">    4563 </span>            : } while (0)
<span class="lineNum">    4564 </span>            : 
<span class="lineNum">    4565 </span>            : /* Given a tree EXP, a FIELD_DECL F, and a replacement value R,
<span class="lineNum">    4566 </span>            :    return a tree with all occurrences of references to F in a
<span class="lineNum">    4567 </span>            :    PLACEHOLDER_EXPR replaced by R.  Also handle VAR_DECLs and
<span class="lineNum">    4568 </span>            :    CONST_DECLs.  Note that we assume here that EXP contains only
<span class="lineNum">    4569 </span>            :    arithmetic expressions or CALL_EXPRs with PLACEHOLDER_EXPRs
<span class="lineNum">    4570 </span>            :    occurring only in their argument list.  */
<span class="lineNum">    4571 </span>            : 
<span class="lineNum">    4572 </span>            : extern tree substitute_in_expr (tree, tree, tree);
<span class="lineNum">    4573 </span>            : 
<span class="lineNum">    4574 </span>            : /* This macro calls the above function but short-circuits the common
<span class="lineNum">    4575 </span>            :    case of a constant to save time and also checks for NULL.  */
<span class="lineNum">    4576 </span>            : 
<span class="lineNum">    4577 </span>            : #define SUBSTITUTE_IN_EXPR(EXP, F, R) \
<span class="lineNum">    4578 </span>            :   ((EXP) == 0 || TREE_CONSTANT (EXP) ? (EXP) : substitute_in_expr (EXP, F, R))
<span class="lineNum">    4579 </span>            : 
<span class="lineNum">    4580 </span>            : /* Similar, but look for a PLACEHOLDER_EXPR in EXP and find a replacement
<span class="lineNum">    4581 </span>            :    for it within OBJ, a tree that is an object or a chain of references.  */
<span class="lineNum">    4582 </span>            : 
<span class="lineNum">    4583 </span>            : extern tree substitute_placeholder_in_expr (tree, tree);
<span class="lineNum">    4584 </span>            : 
<span class="lineNum">    4585 </span>            : /* This macro calls the above function but short-circuits the common
<span class="lineNum">    4586 </span>            :    case of a constant to save time and also checks for NULL.  */
<span class="lineNum">    4587 </span>            : 
<span class="lineNum">    4588 </span>            : #define SUBSTITUTE_PLACEHOLDER_IN_EXPR(EXP, OBJ) \
<span class="lineNum">    4589 </span>            :   ((EXP) == 0 || TREE_CONSTANT (EXP) ? (EXP)    \
<span class="lineNum">    4590 </span>            :    : substitute_placeholder_in_expr (EXP, OBJ))
<span class="lineNum">    4591 </span>            : 
<span class="lineNum">    4592 </span>            : 
<span class="lineNum">    4593 </span>            : /* stabilize_reference (EXP) returns a reference equivalent to EXP
<span class="lineNum">    4594 </span>            :    but it can be used multiple times
<span class="lineNum">    4595 </span>            :    and only evaluate the subexpressions once.  */
<span class="lineNum">    4596 </span>            : 
<span class="lineNum">    4597 </span>            : extern tree stabilize_reference (tree);
<span class="lineNum">    4598 </span>            : 
<span class="lineNum">    4599 </span>            : /* Return EXP, stripped of any conversions to wider types
<span class="lineNum">    4600 </span>            :    in such a way that the result of converting to type FOR_TYPE
<span class="lineNum">    4601 </span>            :    is the same as if EXP were converted to FOR_TYPE.
<span class="lineNum">    4602 </span>            :    If FOR_TYPE is 0, it signifies EXP's type.  */
<span class="lineNum">    4603 </span>            : 
<span class="lineNum">    4604 </span>            : extern tree get_unwidened (tree, tree);
<span class="lineNum">    4605 </span>            : 
<span class="lineNum">    4606 </span>            : /* Return OP or a simpler expression for a narrower value
<span class="lineNum">    4607 </span>            :    which can be sign-extended or zero-extended to give back OP.
<span class="lineNum">    4608 </span>            :    Store in *UNSIGNEDP_PTR either 1 if the value should be zero-extended
<span class="lineNum">    4609 </span>            :    or 0 if the value should be sign-extended.  */
<span class="lineNum">    4610 </span>            : 
<span class="lineNum">    4611 </span>            : extern tree get_narrower (tree, int *);
<span class="lineNum">    4612 </span>            : 
<span class="lineNum">    4613 </span>            : /* Return true if T is an expression that get_inner_reference handles.  */
<a name="4614"><span class="lineNum">    4614 </span>            : </a>
<span class="lineNum">    4615 </span>            : static inline bool
<span class="lineNum">    4616 </span><span class="lineCov">   11275048 : handled_component_p (const_tree t)</span>
<span class="lineNum">    4617 </span>            : {
<span class="lineNum">    4618 </span><span class="lineCov">14746901524 :   switch (TREE_CODE (t))</span>
<span class="lineNum">    4619 </span>            :     {
<span class="lineNum">    4620 </span>            :     case COMPONENT_REF:
<span class="lineNum">    4621 </span>            :     case BIT_FIELD_REF:
<span class="lineNum">    4622 </span>            :     case ARRAY_REF:
<span class="lineNum">    4623 </span>            :     case ARRAY_RANGE_REF:
<span class="lineNum">    4624 </span>            :     case REALPART_EXPR:
<span class="lineNum">    4625 </span>            :     case IMAGPART_EXPR:
<span class="lineNum">    4626 </span>            :     case VIEW_CONVERT_EXPR:
<span class="lineNum">    4627 </span>            :       return true;
<span class="lineNum">    4628 </span>            : 
<span class="lineNum">    4629 </span><span class="lineCov"> 7394973621 :     default:</span>
<span class="lineNum">    4630 </span><span class="lineCov"> 7394973621 :       return false;</span>
<span class="lineNum">    4631 </span>            :     }
<span class="lineNum">    4632 </span>            : }
<span class="lineNum">    4633 </span>            : 
<span class="lineNum">    4634 </span>            : /* Return true T is a component with reverse storage order.  */
<a name="4635"><span class="lineNum">    4635 </span>            : </a>
<span class="lineNum">    4636 </span>            : static inline bool
<span class="lineNum">    4637 </span><span class="lineCov"> 1573796204 : reverse_storage_order_for_component_p (tree t)</span>
<span class="lineNum">    4638 </span>            : {
<span class="lineNum">    4639 </span>            :   /* The storage order only applies to scalar components.  */
<span class="lineNum">    4640 </span><span class="lineCov"> 1573796204 :   if (AGGREGATE_TYPE_P (TREE_TYPE (t)) || VECTOR_TYPE_P (TREE_TYPE (t)))</span>
<span class="lineNum">    4641 </span>            :     return false;
<span class="lineNum">    4642 </span>            : 
<span class="lineNum">    4643 </span><span class="lineCov"> 1284810358 :   if (TREE_CODE (t) == REALPART_EXPR || TREE_CODE (t) == IMAGPART_EXPR)</span>
<span class="lineNum">    4644 </span><span class="lineCov">    3322892 :     t = TREE_OPERAND (t, 0);</span>
<span class="lineNum">    4645 </span>            : 
<span class="lineNum">    4646 </span><span class="lineCov"> 1284810358 :   switch (TREE_CODE (t))</span>
<span class="lineNum">    4647 </span>            :     {
<span class="lineNum">    4648 </span><span class="lineCov">  669791450 :     case ARRAY_REF:</span>
<span class="lineNum">    4649 </span><span class="lineCov">  669791450 :     case COMPONENT_REF:</span>
<span class="lineNum">    4650 </span>            :       /* ??? Fortran can take COMPONENT_REF of a VOID_TYPE.  */
<span class="lineNum">    4651 </span>            :       /* ??? UBSan can take COMPONENT_REF of a REFERENCE_TYPE.  */
<span class="lineNum">    4652 </span><span class="lineCov"> 1233826215 :       return AGGREGATE_TYPE_P (TREE_TYPE (TREE_OPERAND (t, 0)))</span>
<span class="lineNum">    4653 </span><span class="lineCov"> 1233825918 :              &amp;&amp; TYPE_REVERSE_STORAGE_ORDER (TREE_TYPE (TREE_OPERAND (t, 0)));</span>
<span class="lineNum">    4654 </span>            : 
<span class="lineNum">    4655 </span><span class="lineCov">  485877343 :     case BIT_FIELD_REF:</span>
<span class="lineNum">    4656 </span><span class="lineCov">  485877343 :     case MEM_REF:</span>
<span class="lineNum">    4657 </span><span class="lineCov">  970888686 :       return REF_REVERSE_STORAGE_ORDER (t);</span>
<span class="lineNum">    4658 </span>            : 
<span class="lineNum">    4659 </span>            :     case ARRAY_RANGE_REF:
<span class="lineNum">    4660 </span>            :     case VIEW_CONVERT_EXPR:
<span class="lineNum">    4661 </span>            :     default:
<span class="lineNum">    4662 </span>            :       return false;
<span class="lineNum">    4663 </span>            :     }
<span class="lineNum">    4664 </span>            : 
<span class="lineNum">    4665 </span>            :   gcc_unreachable ();
<span class="lineNum">    4666 </span>            : }
<span class="lineNum">    4667 </span>            : 
<span class="lineNum">    4668 </span>            : /* Return true if T is a storage order barrier, i.e. a VIEW_CONVERT_EXPR
<span class="lineNum">    4669 </span>            :    that can modify the storage order of objects.  Note that, even if the
<span class="lineNum">    4670 </span>            :    TYPE_REVERSE_STORAGE_ORDER flag is set on both the inner type and the
<span class="lineNum">    4671 </span>            :    outer type, a VIEW_CONVERT_EXPR can modify the storage order because
<span class="lineNum">    4672 </span>            :    it can change the partition of the aggregate object into scalars.  */
<a name="4673"><span class="lineNum">    4673 </span>            : </a>
<span class="lineNum">    4674 </span>            : static inline bool
<span class="lineNum">    4675 </span><span class="lineCov">   40757189 : storage_order_barrier_p (const_tree t)</span>
<span class="lineNum">    4676 </span>            : {
<span class="lineNum">    4677 </span><span class="lineCov">   40757189 :   if (TREE_CODE (t) != VIEW_CONVERT_EXPR)</span>
<span class="lineNum">    4678 </span>            :     return false;
<span class="lineNum">    4679 </span>            : 
<span class="lineNum">    4680 </span><span class="lineCov">    2059384 :   if (AGGREGATE_TYPE_P (TREE_TYPE (t))</span>
<span class="lineNum">    4681 </span><span class="lineCov">    2009424 :       &amp;&amp; TYPE_REVERSE_STORAGE_ORDER (TREE_TYPE (t)))</span>
<span class="lineNum">    4682 </span>            :     return true;
<span class="lineNum">    4683 </span>            : 
<span class="lineNum">    4684 </span><span class="lineCov">    1063976 :   tree op = TREE_OPERAND (t, 0);</span>
<span class="lineNum">    4685 </span>            : 
<span class="lineNum">    4686 </span><span class="lineCov">    2119020 :   if (AGGREGATE_TYPE_P (TREE_TYPE (op))</span>
<span class="lineNum">    4687 </span><span class="lineCov">    2013907 :       &amp;&amp; TYPE_REVERSE_STORAGE_ORDER (TREE_TYPE (op)))</span>
<span class="lineNum">    4688 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    4689 </span>            : 
<span class="lineNum">    4690 </span>            :   return false;
<span class="lineNum">    4691 </span>            : }
<span class="lineNum">    4692 </span>            : 
<span class="lineNum">    4693 </span>            : /* Given a DECL or TYPE, return the scope in which it was declared, or
<span class="lineNum">    4694 </span>            :    NUL_TREE if there is no containing scope.  */
<span class="lineNum">    4695 </span>            : 
<span class="lineNum">    4696 </span>            : extern tree get_containing_scope (const_tree);
<span class="lineNum">    4697 </span>            : 
<span class="lineNum">    4698 </span>            : /* Returns the ultimate TRANSLATION_UNIT_DECL context of DECL or NULL.  */
<span class="lineNum">    4699 </span>            : 
<span class="lineNum">    4700 </span>            : extern const_tree get_ultimate_context (const_tree);
<span class="lineNum">    4701 </span>            : 
<span class="lineNum">    4702 </span>            : /* Return the FUNCTION_DECL which provides this _DECL with its context,
<span class="lineNum">    4703 </span>            :    or zero if none.  */
<span class="lineNum">    4704 </span>            : extern tree decl_function_context (const_tree);
<span class="lineNum">    4705 </span>            : 
<span class="lineNum">    4706 </span>            : /* Return the RECORD_TYPE, UNION_TYPE, or QUAL_UNION_TYPE which provides
<span class="lineNum">    4707 </span>            :    this _DECL with its context, or zero if none.  */
<span class="lineNum">    4708 </span>            : extern tree decl_type_context (const_tree);
<span class="lineNum">    4709 </span>            : 
<span class="lineNum">    4710 </span>            : /* Return 1 if EXPR is the real constant zero.  */
<span class="lineNum">    4711 </span>            : extern int real_zerop (const_tree);
<span class="lineNum">    4712 </span>            : 
<span class="lineNum">    4713 </span>            : /* Initialize the iterator I with arguments from function FNDECL  */
<a name="4714"><span class="lineNum">    4714 </span>            : </a>
<span class="lineNum">    4715 </span>            : static inline void
<span class="lineNum">    4716 </span><span class="lineNoCov">          0 : function_args_iter_init (function_args_iterator *i, const_tree fntype)</span>
<span class="lineNum">    4717 </span>            : {
<span class="lineNum">    4718 </span><span class="lineNoCov">          0 :   i-&gt;next = TYPE_ARG_TYPES (fntype);</span>
<span class="lineNum">    4719 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4720 </span>            : 
<span class="lineNum">    4721 </span>            : /* Return a pointer that holds the next argument if there are more arguments to
<span class="lineNum">    4722 </span>            :    handle, otherwise return NULL.  */
<span class="lineNum">    4723 </span>            : 
<span class="lineNum">    4724 </span>            : static inline tree *
<span class="lineNum">    4725 </span>            : function_args_iter_cond_ptr (function_args_iterator *i)
<span class="lineNum">    4726 </span>            : {
<span class="lineNum">    4727 </span>            :   return (i-&gt;next) ? &amp;TREE_VALUE (i-&gt;next) : NULL;
<span class="lineNum">    4728 </span>            : }
<span class="lineNum">    4729 </span>            : 
<span class="lineNum">    4730 </span>            : /* Return the next argument if there are more arguments to handle, otherwise
<span class="lineNum">    4731 </span>            :    return NULL.  */
<a name="4732"><span class="lineNum">    4732 </span>            : </a>
<span class="lineNum">    4733 </span>            : static inline tree
<span class="lineNum">    4734 </span><span class="lineNoCov">          0 : function_args_iter_cond (function_args_iterator *i)</span>
<span class="lineNum">    4735 </span>            : {
<span class="lineNum">    4736 </span><span class="lineNoCov">          0 :   return (i-&gt;next) ? TREE_VALUE (i-&gt;next) : NULL_TREE;</span>
<span class="lineNum">    4737 </span>            : }
<span class="lineNum">    4738 </span>            : 
<a name="4739"><span class="lineNum">    4739 </span>            : /* Advance to the next argument.  */</a>
<span class="lineNum">    4740 </span>            : static inline void
<span class="lineNum">    4741 </span><span class="lineNoCov">          0 : function_args_iter_next (function_args_iterator *i)</span>
<span class="lineNum">    4742 </span>            : {
<span class="lineNum">    4743 </span><span class="lineNoCov">          0 :   gcc_assert (i-&gt;next != NULL_TREE);</span>
<span class="lineNum">    4744 </span><span class="lineNoCov">          0 :   i-&gt;next = TREE_CHAIN (i-&gt;next);</span>
<span class="lineNum">    4745 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4746 </span>            : 
<span class="lineNum">    4747 </span>            : /* We set BLOCK_SOURCE_LOCATION only to inlined function entry points.  */
<a name="4748"><span class="lineNum">    4748 </span>            : </a>
<span class="lineNum">    4749 </span>            : static inline bool
<span class="lineNum">    4750 </span><span class="lineCov">   23026098 : inlined_function_outer_scope_p (const_tree block)</span>
<span class="lineNum">    4751 </span>            : {
<span class="lineNum">    4752 </span><span class="lineCov">   23026098 :  return LOCATION_LOCUS (BLOCK_SOURCE_LOCATION (block)) != UNKNOWN_LOCATION;</span>
<span class="lineNum">    4753 </span>            : }
<span class="lineNum">    4754 </span>            : 
<span class="lineNum">    4755 </span>            : /* Loop over all function arguments of FNTYPE.  In each iteration, PTR is set
<span class="lineNum">    4756 </span>            :    to point to the next tree element.  ITER is an instance of
<span class="lineNum">    4757 </span>            :    function_args_iterator used to iterate the arguments.  */
<span class="lineNum">    4758 </span>            : #define FOREACH_FUNCTION_ARGS_PTR(FNTYPE, PTR, ITER)                    \
<span class="lineNum">    4759 </span>            :   for (function_args_iter_init (&amp;(ITER), (FNTYPE));                 \
<span class="lineNum">    4760 </span>            :        (PTR = function_args_iter_cond_ptr (&amp;(ITER))) != NULL;               \
<span class="lineNum">    4761 </span>            :        function_args_iter_next (&amp;(ITER)))
<span class="lineNum">    4762 </span>            : 
<span class="lineNum">    4763 </span>            : /* Loop over all function arguments of FNTYPE.  In each iteration, TREE is set
<span class="lineNum">    4764 </span>            :    to the next tree element.  ITER is an instance of function_args_iterator
<span class="lineNum">    4765 </span>            :    used to iterate the arguments.  */
<span class="lineNum">    4766 </span>            : #define FOREACH_FUNCTION_ARGS(FNTYPE, TREE, ITER)                       \
<span class="lineNum">    4767 </span>            :   for (function_args_iter_init (&amp;(ITER), (FNTYPE));                 \
<span class="lineNum">    4768 </span>            :        (TREE = function_args_iter_cond (&amp;(ITER))) != NULL_TREE;             \
<span class="lineNum">    4769 </span>            :        function_args_iter_next (&amp;(ITER)))
<span class="lineNum">    4770 </span>            : 
<span class="lineNum">    4771 </span>            : /* In tree.c */
<span class="lineNum">    4772 </span>            : extern unsigned crc32_unsigned_n (unsigned, unsigned, unsigned);
<span class="lineNum">    4773 </span>            : extern unsigned crc32_string (unsigned, const char *);
<span class="lineNum">    4774 </span>            : inline unsigned
<span class="lineNum">    4775 </span>            : crc32_unsigned (unsigned chksum, unsigned value)
<span class="lineNum">    4776 </span>            : {
<span class="lineNum">    4777 </span><span class="lineCov">         93 :   return crc32_unsigned_n (chksum, value, 4);</span>
<span class="lineNum">    4778 </span>            : }
<span class="lineNum">    4779 </span>            : inline unsigned
<span class="lineNum">    4780 </span>            : crc32_byte (unsigned chksum, char byte)
<span class="lineNum">    4781 </span>            : {
<span class="lineNum">    4782 </span><span class="lineCov">   13662831 :   return crc32_unsigned_n (chksum, byte, 1);</span>
<span class="lineNum">    4783 </span>            : }
<span class="lineNum">    4784 </span>            : extern void clean_symbol_name (char *);
<span class="lineNum">    4785 </span>            : extern tree get_file_function_name (const char *);
<span class="lineNum">    4786 </span>            : extern tree get_callee_fndecl (const_tree);
<span class="lineNum">    4787 </span>            : extern combined_fn get_call_combined_fn (const_tree);
<span class="lineNum">    4788 </span>            : extern int type_num_arguments (const_tree);
<span class="lineNum">    4789 </span>            : extern bool associative_tree_code (enum tree_code);
<span class="lineNum">    4790 </span>            : extern bool commutative_tree_code (enum tree_code);
<span class="lineNum">    4791 </span>            : extern bool commutative_ternary_tree_code (enum tree_code);
<span class="lineNum">    4792 </span>            : extern bool operation_can_overflow (enum tree_code);
<span class="lineNum">    4793 </span>            : extern bool operation_no_trapping_overflow (tree, enum tree_code);
<span class="lineNum">    4794 </span>            : extern tree upper_bound_in_type (tree, tree);
<span class="lineNum">    4795 </span>            : extern tree lower_bound_in_type (tree, tree);
<span class="lineNum">    4796 </span>            : extern int operand_equal_for_phi_arg_p (const_tree, const_tree);
<span class="lineNum">    4797 </span>            : extern tree create_artificial_label (location_t);
<span class="lineNum">    4798 </span>            : extern const char *get_name (tree);
<span class="lineNum">    4799 </span>            : extern bool stdarg_p (const_tree);
<span class="lineNum">    4800 </span>            : extern bool prototype_p (const_tree);
<span class="lineNum">    4801 </span>            : extern bool is_typedef_decl (const_tree x);
<span class="lineNum">    4802 </span>            : extern bool typedef_variant_p (const_tree);
<span class="lineNum">    4803 </span>            : extern bool auto_var_in_fn_p (const_tree, const_tree);
<span class="lineNum">    4804 </span>            : extern tree build_low_bits_mask (tree, unsigned);
<span class="lineNum">    4805 </span>            : extern bool tree_nop_conversion_p (const_tree, const_tree);
<span class="lineNum">    4806 </span>            : extern tree tree_strip_nop_conversions (tree);
<span class="lineNum">    4807 </span>            : extern tree tree_strip_sign_nop_conversions (tree);
<span class="lineNum">    4808 </span>            : extern const_tree strip_invariant_refs (const_tree);
<span class="lineNum">    4809 </span>            : extern tree lhd_gcc_personality (void);
<span class="lineNum">    4810 </span>            : extern void assign_assembler_name_if_needed (tree);
<span class="lineNum">    4811 </span>            : extern bool warn_deprecated_use (tree, tree);
<span class="lineNum">    4812 </span>            : extern void cache_integer_cst (tree);
<span class="lineNum">    4813 </span>            : extern const char *combined_fn_name (combined_fn);
<span class="lineNum">    4814 </span>            : 
<span class="lineNum">    4815 </span>            : /* Compare and hash for any structure which begins with a canonical
<span class="lineNum">    4816 </span>            :    pointer.  Assumes all pointers are interchangeable, which is sort
<span class="lineNum">    4817 </span>            :    of already assumed by gcc elsewhere IIRC.  */
<span class="lineNum">    4818 </span>            : 
<span class="lineNum">    4819 </span>            : static inline int
<span class="lineNum">    4820 </span>            : struct_ptr_eq (const void *a, const void *b)
<span class="lineNum">    4821 </span>            : {
<span class="lineNum">    4822 </span>            :   const void * const * x = (const void * const *) a;
<span class="lineNum">    4823 </span>            :   const void * const * y = (const void * const *) b;
<span class="lineNum">    4824 </span>            :   return *x == *y;
<span class="lineNum">    4825 </span>            : }
<span class="lineNum">    4826 </span>            : 
<span class="lineNum">    4827 </span>            : static inline hashval_t
<span class="lineNum">    4828 </span>            : struct_ptr_hash (const void *a)
<span class="lineNum">    4829 </span>            : {
<span class="lineNum">    4830 </span>            :   const void * const * x = (const void * const *) a;
<span class="lineNum">    4831 </span>            :   return (intptr_t)*x &gt;&gt; 4;
<span class="lineNum">    4832 </span>            : }
<span class="lineNum">    4833 </span>            : 
<span class="lineNum">    4834 </span>            : /* Return nonzero if CODE is a tree code that represents a truth value.  */
<span class="lineNum">    4835 </span>            : static inline bool
<span class="lineNum">    4836 </span>            : truth_value_p (enum tree_code code)
<span class="lineNum">    4837 </span>            : {
<span class="lineNum">    4838 </span><span class="lineCov">  105133548 :   return (TREE_CODE_CLASS (code) == tcc_comparison</span>
<span class="lineNum">    4839 </span><span class="lineCov">  101143738 :           || code == TRUTH_AND_EXPR || code == TRUTH_ANDIF_EXPR</span>
<span class="lineNum">    4840 </span><span class="lineCov">  101116811 :           || code == TRUTH_OR_EXPR || code == TRUTH_ORIF_EXPR</span>
<span class="lineNum">    4841 </span><span class="lineCov">  165268178 :           || code == TRUTH_XOR_EXPR || code == TRUTH_NOT_EXPR);</span>
<span class="lineNum">    4842 </span>            : }
<span class="lineNum">    4843 </span>            : 
<span class="lineNum">    4844 </span>            : /* Return whether TYPE is a type suitable for an offset for
<a name="4845"><span class="lineNum">    4845 </span>            :    a POINTER_PLUS_EXPR.  */</a>
<span class="lineNum">    4846 </span>            : static inline bool
<span class="lineNum">    4847 </span><span class="lineCov">   82264989 : ptrofftype_p (tree type)</span>
<span class="lineNum">    4848 </span>            : {
<span class="lineNum">    4849 </span><span class="lineCov">   82264989 :   return (INTEGRAL_TYPE_P (type)</span>
<span class="lineNum">    4850 </span><span class="lineCov">   82264989 :           &amp;&amp; TYPE_PRECISION (type) == TYPE_PRECISION (sizetype)</span>
<span class="lineNum">    4851 </span><span class="lineCov">  164529978 :           &amp;&amp; TYPE_UNSIGNED (type) == TYPE_UNSIGNED (sizetype));</span>
<span class="lineNum">    4852 </span>            : }
<span class="lineNum">    4853 </span>            : 
<span class="lineNum">    4854 </span>            : /* Return true if the argument is a complete type or an array
<span class="lineNum">    4855 </span>            :    of unknown bound (whose type is incomplete but) whose elements
<a name="4856"><span class="lineNum">    4856 </span>            :    have complete type.  */</a>
<span class="lineNum">    4857 </span>            : static inline bool
<span class="lineNum">    4858 </span><span class="lineCov">     685839 : complete_or_array_type_p (const_tree type)</span>
<span class="lineNum">    4859 </span>            : {
<span class="lineNum">    4860 </span><span class="lineCov">     685839 :   return COMPLETE_TYPE_P (type)</span>
<span class="lineNum">    4861 </span><span class="lineCov">     685839 :          || (TREE_CODE (type) == ARRAY_TYPE</span>
<span class="lineNum">    4862 </span><span class="lineCov">      40571 :              &amp;&amp; COMPLETE_TYPE_P (TREE_TYPE (type)));</span>
<span class="lineNum">    4863 </span>            : }
<span class="lineNum">    4864 </span>            : 
<span class="lineNum">    4865 </span>            : /* Return true if the value of T could be represented as a poly_widest_int.  */
<span class="lineNum">    4866 </span>            : 
<span class="lineNum">    4867 </span>            : inline bool
<span class="lineNum">    4868 </span>            : poly_int_tree_p (const_tree t)
<span class="lineNum">    4869 </span>            : {
<span class="lineNum">    4870 </span><span class="lineCov"> 3911779983 :   return (TREE_CODE (t) == INTEGER_CST || POLY_INT_CST_P (t));</span>
<span class="lineNum">    4871 </span>            : }
<span class="lineNum">    4872 </span>            : 
<span class="lineNum">    4873 </span>            : /* Return the bit size of BIT_FIELD_REF T, in cases where it is known
<span class="lineNum">    4874 </span>            :    to be a poly_uint64.  (This is always true at the gimple level.)  */
<a name="4875"><span class="lineNum">    4875 </span>            : </a>
<span class="lineNum">    4876 </span>            : inline poly_uint64
<span class="lineNum">    4877 </span><span class="lineCov">      30636 : bit_field_size (const_tree t)</span>
<span class="lineNum">    4878 </span>            : {
<span class="lineNum">    4879 </span><span class="lineCov">      30636 :   return tree_to_poly_uint64 (TREE_OPERAND (t, 1));</span>
<span class="lineNum">    4880 </span>            : }
<span class="lineNum">    4881 </span>            : 
<span class="lineNum">    4882 </span>            : /* Return the starting bit offset of BIT_FIELD_REF T, in cases where it is
<span class="lineNum">    4883 </span>            :    known to be a poly_uint64.  (This is always true at the gimple level.)  */
<a name="4884"><span class="lineNum">    4884 </span>            : </a>
<span class="lineNum">    4885 </span>            : inline poly_uint64
<span class="lineNum">    4886 </span><span class="lineCov">     124854 : bit_field_offset (const_tree t)</span>
<span class="lineNum">    4887 </span>            : {
<span class="lineNum">    4888 </span><span class="lineCov">     124854 :   return tree_to_poly_uint64 (TREE_OPERAND (t, 2));</span>
<span class="lineNum">    4889 </span>            : }
<span class="lineNum">    4890 </span>            : 
<span class="lineNum">    4891 </span>            : extern tree strip_float_extensions (tree);
<span class="lineNum">    4892 </span>            : extern int really_constant_p (const_tree);
<span class="lineNum">    4893 </span>            : extern bool ptrdiff_tree_p (const_tree, poly_int64_pod *);
<span class="lineNum">    4894 </span>            : extern bool decl_address_invariant_p (const_tree);
<span class="lineNum">    4895 </span>            : extern bool decl_address_ip_invariant_p (const_tree);
<span class="lineNum">    4896 </span>            : extern bool int_fits_type_p (const_tree, const_tree);
<span class="lineNum">    4897 </span>            : #ifndef GENERATOR_FILE
<span class="lineNum">    4898 </span>            : extern void get_type_static_bounds (const_tree, mpz_t, mpz_t);
<span class="lineNum">    4899 </span>            : #endif
<span class="lineNum">    4900 </span>            : extern bool variably_modified_type_p (tree, tree);
<span class="lineNum">    4901 </span>            : extern int tree_log2 (const_tree);
<span class="lineNum">    4902 </span>            : extern int tree_floor_log2 (const_tree);
<span class="lineNum">    4903 </span>            : extern unsigned int tree_ctz (const_tree);
<span class="lineNum">    4904 </span>            : extern int simple_cst_equal (const_tree, const_tree);
<span class="lineNum">    4905 </span>            : 
<span class="lineNum">    4906 </span>            : namespace inchash
<span class="lineNum">    4907 </span>            : {
<span class="lineNum">    4908 </span>            : 
<span class="lineNum">    4909 </span>            : extern void add_expr (const_tree, hash &amp;, unsigned int = 0);
<span class="lineNum">    4910 </span>            : 
<span class="lineNum">    4911 </span>            : }
<span class="lineNum">    4912 </span>            : 
<span class="lineNum">    4913 </span>            : /* Compat version until all callers are converted. Return hash for
<span class="lineNum">    4914 </span>            :    TREE with SEED.  */
<span class="lineNum">    4915 </span>            : static inline hashval_t iterative_hash_expr(const_tree tree, hashval_t seed)
<span class="lineNum">    4916 </span>            : {
<span class="lineNum">    4917 </span><span class="lineCov">   72788737 :   inchash::hash hstate (seed);</span>
<span class="lineNum">    4918 </span><span class="lineCov">   72788737 :   inchash::add_expr (tree, hstate);</span>
<span class="lineNum">    4919 </span><span class="lineCov">   72788737 :   return hstate.end ();</span>
<span class="lineNum">    4920 </span>            : }
<span class="lineNum">    4921 </span>            : 
<span class="lineNum">    4922 </span>            : extern int compare_tree_int (const_tree, unsigned HOST_WIDE_INT);
<span class="lineNum">    4923 </span>            : extern int type_list_equal (const_tree, const_tree);
<span class="lineNum">    4924 </span>            : extern int chain_member (const_tree, const_tree);
<span class="lineNum">    4925 </span>            : extern void dump_tree_statistics (void);
<span class="lineNum">    4926 </span>            : extern void recompute_tree_invariant_for_addr_expr (tree);
<span class="lineNum">    4927 </span>            : extern bool needs_to_live_in_memory (const_tree);
<span class="lineNum">    4928 </span>            : extern tree reconstruct_complex_type (tree, tree);
<span class="lineNum">    4929 </span>            : extern int real_onep (const_tree);
<span class="lineNum">    4930 </span>            : extern int real_minus_onep (const_tree);
<span class="lineNum">    4931 </span>            : extern void init_ttree (void);
<span class="lineNum">    4932 </span>            : extern void build_common_tree_nodes (bool);
<span class="lineNum">    4933 </span>            : extern void build_common_builtin_nodes (void);
<span class="lineNum">    4934 </span>            : extern tree build_nonstandard_integer_type (unsigned HOST_WIDE_INT, int);
<span class="lineNum">    4935 </span>            : extern tree build_nonstandard_boolean_type (unsigned HOST_WIDE_INT);
<span class="lineNum">    4936 </span>            : extern tree build_range_type (tree, tree, tree);
<span class="lineNum">    4937 </span>            : extern tree build_nonshared_range_type (tree, tree, tree);
<span class="lineNum">    4938 </span>            : extern bool subrange_type_for_debug_p (const_tree, tree *, tree *);
<span class="lineNum">    4939 </span>            : extern HOST_WIDE_INT int_cst_value (const_tree);
<span class="lineNum">    4940 </span>            : extern tree tree_block (tree);
<span class="lineNum">    4941 </span>            : extern void tree_set_block (tree, tree);
<span class="lineNum">    4942 </span>            : extern location_t *block_nonartificial_location (tree);
<span class="lineNum">    4943 </span>            : extern location_t tree_nonartificial_location (tree);
<span class="lineNum">    4944 </span>            : extern tree block_ultimate_origin (const_tree);
<span class="lineNum">    4945 </span>            : extern tree get_binfo_at_offset (tree, poly_int64, tree);
<span class="lineNum">    4946 </span>            : extern bool virtual_method_call_p (const_tree);
<span class="lineNum">    4947 </span>            : extern tree obj_type_ref_class (const_tree ref);
<span class="lineNum">    4948 </span>            : extern bool types_same_for_odr (const_tree type1, const_tree type2,
<span class="lineNum">    4949 </span>            :                                 bool strict=false);
<span class="lineNum">    4950 </span>            : extern bool contains_bitfld_component_ref_p (const_tree);
<span class="lineNum">    4951 </span>            : extern bool block_may_fallthru (const_tree);
<span class="lineNum">    4952 </span>            : extern void using_eh_for_cleanups (void);
<span class="lineNum">    4953 </span>            : extern bool using_eh_for_cleanups_p (void);
<span class="lineNum">    4954 </span>            : extern const char *get_tree_code_name (enum tree_code);
<span class="lineNum">    4955 </span>            : extern void set_call_expr_flags (tree, int);
<span class="lineNum">    4956 </span>            : extern tree walk_tree_1 (tree*, walk_tree_fn, void*, hash_set&lt;tree&gt;*,
<span class="lineNum">    4957 </span>            :                          walk_tree_lh);
<span class="lineNum">    4958 </span>            : extern tree walk_tree_without_duplicates_1 (tree*, walk_tree_fn, void*,
<span class="lineNum">    4959 </span>            :                                             walk_tree_lh);
<span class="lineNum">    4960 </span>            : #define walk_tree(a,b,c,d) \
<span class="lineNum">    4961 </span>            :         walk_tree_1 (a, b, c, d, NULL)
<span class="lineNum">    4962 </span>            : #define walk_tree_without_duplicates(a,b,c) \
<span class="lineNum">    4963 </span>            :         walk_tree_without_duplicates_1 (a, b, c, NULL)
<span class="lineNum">    4964 </span>            : 
<span class="lineNum">    4965 </span>            : extern tree drop_tree_overflow (tree);
<span class="lineNum">    4966 </span>            : 
<span class="lineNum">    4967 </span>            : /* Given a memory reference expression T, return its base address.
<span class="lineNum">    4968 </span>            :    The base address of a memory reference expression is the main
<span class="lineNum">    4969 </span>            :    object being referenced.  */
<span class="lineNum">    4970 </span>            : extern tree get_base_address (tree t);
<span class="lineNum">    4971 </span>            : 
<span class="lineNum">    4972 </span>            : /* Return a tree of sizetype representing the size, in bytes, of the element
<span class="lineNum">    4973 </span>            :    of EXP, an ARRAY_REF or an ARRAY_RANGE_REF.  */
<span class="lineNum">    4974 </span>            : extern tree array_ref_element_size (tree);
<span class="lineNum">    4975 </span>            : 
<span class="lineNum">    4976 </span>            : /* Return a tree representing the upper bound of the array mentioned in
<span class="lineNum">    4977 </span>            :    EXP, an ARRAY_REF or an ARRAY_RANGE_REF.  */
<span class="lineNum">    4978 </span>            : extern tree array_ref_up_bound (tree);
<span class="lineNum">    4979 </span>            : 
<span class="lineNum">    4980 </span>            : /* Return a tree representing the lower bound of the array mentioned in
<span class="lineNum">    4981 </span>            :    EXP, an ARRAY_REF or an ARRAY_RANGE_REF.  */
<span class="lineNum">    4982 </span>            : extern tree array_ref_low_bound (tree);
<span class="lineNum">    4983 </span>            : 
<span class="lineNum">    4984 </span>            : /* Returns true if REF is an array reference or a component reference
<span class="lineNum">    4985 </span>            :    to an array at the end of a structure.  If this is the case, the array
<span class="lineNum">    4986 </span>            :    may be allocated larger than its upper bound implies.  */
<span class="lineNum">    4987 </span>            : extern bool array_at_struct_end_p (tree);
<span class="lineNum">    4988 </span>            : 
<span class="lineNum">    4989 </span>            : /* Return a tree representing the offset, in bytes, of the field referenced
<span class="lineNum">    4990 </span>            :    by EXP.  This does not include any offset in DECL_FIELD_BIT_OFFSET.  */
<span class="lineNum">    4991 </span>            : extern tree component_ref_field_offset (tree);
<span class="lineNum">    4992 </span>            : 
<span class="lineNum">    4993 </span>            : extern int tree_map_base_eq (const void *, const void *);
<span class="lineNum">    4994 </span>            : extern unsigned int tree_map_base_hash (const void *);
<span class="lineNum">    4995 </span>            : extern int tree_map_base_marked_p (const void *);
<span class="lineNum">    4996 </span>            : extern void DEBUG_FUNCTION verify_type (const_tree t);
<span class="lineNum">    4997 </span>            : extern bool gimple_canonical_types_compatible_p (const_tree, const_tree,
<span class="lineNum">    4998 </span>            :                                                  bool trust_type_canonical = true);
<span class="lineNum">    4999 </span>            : extern bool type_with_interoperable_signedness (const_tree);
<span class="lineNum">    5000 </span>            : extern bitmap get_nonnull_args (const_tree);
<span class="lineNum">    5001 </span>            : extern int get_range_pos_neg (tree);
<span class="lineNum">    5002 </span>            : 
<span class="lineNum">    5003 </span>            : /* Return simplified tree code of type that is used for canonical type
<span class="lineNum">    5004 </span>            :    merging.  */
<span class="lineNum">    5005 </span>            : inline enum tree_code
<span class="lineNum">    5006 </span>            : tree_code_for_canonical_type_merging (enum tree_code code)
<span class="lineNum">    5007 </span>            : {
<span class="lineNum">    5008 </span>            :   /* By C standard, each enumerated type shall be compatible with char,
<span class="lineNum">    5009 </span>            :      a signed integer, or an unsigned integer.  The choice of type is
<span class="lineNum">    5010 </span>            :      implementation defined (in our case it depends on -fshort-enum).
<span class="lineNum">    5011 </span>            : 
<span class="lineNum">    5012 </span>            :      For this reason we make no distinction between ENUMERAL_TYPE and INTEGER
<span class="lineNum">    5013 </span>            :      type and compare only by their signedness and precision.  */
<span class="lineNum">    5014 </span><span class="lineCov">   71402969 :   if (code == ENUMERAL_TYPE)</span>
<span class="lineNum">    5015 </span>            :     return INTEGER_TYPE;
<span class="lineNum">    5016 </span>            :   /* To allow inter-operability between languages having references and
<span class="lineNum">    5017 </span>            :      C, we consider reference types and pointers alike.  Note that this is
<span class="lineNum">    5018 </span>            :      not strictly necessary for C-Fortran 2008 interoperability because
<span class="lineNum">    5019 </span>            :      Fortran define C_PTR type that needs to be compatible with C pointers
<span class="lineNum">    5020 </span>            :      and we handle this one as ptr_type_node.  */
<span class="lineNum">    5021 </span><span class="lineCov">   70907790 :   if (code == REFERENCE_TYPE)</span>
<span class="lineNum">    5022 </span><span class="lineCov">    3305967 :     return POINTER_TYPE;</span>
<span class="lineNum">    5023 </span>            :   return code;
<span class="lineNum">    5024 </span>            : }
<span class="lineNum">    5025 </span>            : 
<span class="lineNum">    5026 </span>            : /* Return ture if get_alias_set care about TYPE_CANONICAL of given type.
<span class="lineNum">    5027 </span>            :    We don't define the types for pointers, arrays and vectors.  The reason is
<span class="lineNum">    5028 </span>            :    that pointers are handled specially: ptr_type_node accesses conflict with
<span class="lineNum">    5029 </span>            :    accesses to all other pointers.  This is done by alias.c.
<span class="lineNum">    5030 </span>            :    Because alias sets of arrays and vectors are the same as types of their
<span class="lineNum">    5031 </span>            :    elements, we can't compute canonical type either.  Otherwise we could go
<span class="lineNum">    5032 </span>            :    form void *[10] to int *[10] (because they are equivalent for canonical type
<span class="lineNum">    5033 </span>            :    machinery) and get wrong TBAA.  */
<span class="lineNum">    5034 </span>            : 
<span class="lineNum">    5035 </span>            : inline bool
<span class="lineNum">    5036 </span>            : canonical_type_used_p (const_tree t)
<span class="lineNum">    5037 </span>            : {
<span class="lineNum">    5038 </span><span class="lineCov">   95107789 :   return !(POINTER_TYPE_P (t)</span>
<span class="lineNum">    5039 </span><span class="lineCov">  116077720 :            || TREE_CODE (t) == ARRAY_TYPE</span>
<span class="lineNum">    5040 </span>            :            || TREE_CODE (t) == VECTOR_TYPE);
<span class="lineNum">    5041 </span>            : }
<span class="lineNum">    5042 </span>            : 
<span class="lineNum">    5043 </span>            : #define tree_map_eq tree_map_base_eq
<span class="lineNum">    5044 </span>            : extern unsigned int tree_map_hash (const void *);
<span class="lineNum">    5045 </span>            : #define tree_map_marked_p tree_map_base_marked_p
<span class="lineNum">    5046 </span>            : 
<span class="lineNum">    5047 </span>            : #define tree_decl_map_eq tree_map_base_eq
<span class="lineNum">    5048 </span>            : extern unsigned int tree_decl_map_hash (const void *);
<span class="lineNum">    5049 </span>            : #define tree_decl_map_marked_p tree_map_base_marked_p
<span class="lineNum">    5050 </span>            : 
<span class="lineNum">    5051 </span>            : struct tree_decl_map_cache_hasher : ggc_cache_ptr_hash&lt;tree_decl_map&gt;
<span class="lineNum">    5052 </span>            : {
<span class="lineNum">    5053 </span><span class="lineCov">     204699 :   static hashval_t hash (tree_decl_map *m) { return tree_decl_map_hash (m); }</span>
<span class="lineNum">    5054 </span>            :   static bool
<span class="lineNum">    5055 </span>            :   equal (tree_decl_map *a, tree_decl_map *b)
<span class="lineNum">    5056 </span>            :   {
<span class="lineNum">    5057 </span><span class="lineCov">  248190913 :     return tree_decl_map_eq (a, b);</span>
<span class="lineNum">    5058 </span>            :   }
<a name="5059"><span class="lineNum">    5059 </span>            : </a>
<span class="lineNum">    5060 </span>            :   static int
<span class="lineNum">    5061 </span><span class="lineNoCov">          0 :   keep_cache_entry (tree_decl_map *&amp;m)</span>
<span class="lineNum">    5062 </span>            :   {
<span class="lineNum">    5063 </span><span class="lineCov">    2885296 :     return ggc_marked_p (m-&gt;base.from);</span>
<span class="lineNum">    5064 </span>            :   }
<span class="lineNum">    5065 </span>            : };
<span class="lineNum">    5066 </span>            : 
<span class="lineNum">    5067 </span>            : #define tree_int_map_eq tree_map_base_eq
<span class="lineNum">    5068 </span>            : #define tree_int_map_hash tree_map_base_hash
<span class="lineNum">    5069 </span>            : #define tree_int_map_marked_p tree_map_base_marked_p
<span class="lineNum">    5070 </span>            : 
<span class="lineNum">    5071 </span>            : #define tree_vec_map_eq tree_map_base_eq
<span class="lineNum">    5072 </span>            : #define tree_vec_map_hash tree_decl_map_hash
<span class="lineNum">    5073 </span>            : #define tree_vec_map_marked_p tree_map_base_marked_p
<span class="lineNum">    5074 </span>            : 
<span class="lineNum">    5075 </span>            : /* A hash_map of two trees for use with GTY((cache)).  Garbage collection for
<span class="lineNum">    5076 </span>            :    such a map will not mark keys, and will mark values if the key is already
<span class="lineNum">    5077 </span>            :    marked.  */
<span class="lineNum">    5078 </span>            : struct tree_cache_traits
<span class="lineNum">    5079 </span>            :   : simple_cache_map_traits&lt;default_hash_traits&lt;tree&gt;, tree&gt; { };
<span class="lineNum">    5080 </span>            : typedef hash_map&lt;tree,tree,tree_cache_traits&gt; tree_cache_map;
<span class="lineNum">    5081 </span>            : 
<span class="lineNum">    5082 </span>            : /* Initialize the abstract argument list iterator object ITER with the
<a name="5083"><span class="lineNum">    5083 </span>            :    arguments from CALL_EXPR node EXP.  */</a>
<span class="lineNum">    5084 </span>            : static inline void
<span class="lineNum">    5085 </span><span class="lineCov">    7227225 : init_call_expr_arg_iterator (tree exp, call_expr_arg_iterator *iter)</span>
<span class="lineNum">    5086 </span>            : {
<span class="lineNum">    5087 </span><span class="lineCov">    7227225 :   iter-&gt;t = exp;</span>
<span class="lineNum">    5088 </span><span class="lineCov">    7227225 :   iter-&gt;n = call_expr_nargs (exp);</span>
<span class="lineNum">    5089 </span><span class="lineCov">    7227225 :   iter-&gt;i = 0;</span>
<span class="lineNum">    5090 </span><span class="lineCov">    7227225 : }</span>
<a name="5091"><span class="lineNum">    5091 </span>            : </a>
<span class="lineNum">    5092 </span>            : static inline void
<span class="lineNum">    5093 </span><span class="lineCov">     496234 : init_const_call_expr_arg_iterator (const_tree exp, const_call_expr_arg_iterator *iter)</span>
<span class="lineNum">    5094 </span>            : {
<span class="lineNum">    5095 </span><span class="lineCov">     496234 :   iter-&gt;t = exp;</span>
<span class="lineNum">    5096 </span><span class="lineCov">     496234 :   iter-&gt;n = call_expr_nargs (exp);</span>
<span class="lineNum">    5097 </span><span class="lineCov">     496234 :   iter-&gt;i = 0;</span>
<span class="lineNum">    5098 </span><span class="lineCov">     496234 : }</span>
<span class="lineNum">    5099 </span>            : 
<span class="lineNum">    5100 </span>            : /* Return the next argument from abstract argument list iterator object ITER,
<a name="5101"><span class="lineNum">    5101 </span>            :    and advance its state.  Return NULL_TREE if there are no more arguments.  */</a>
<span class="lineNum">    5102 </span>            : static inline tree
<span class="lineNum">    5103 </span><span class="lineCov">   18179561 : next_call_expr_arg (call_expr_arg_iterator *iter)</span>
<span class="lineNum">    5104 </span>            : {
<span class="lineNum">    5105 </span><span class="lineCov">   18179561 :   tree result;</span>
<span class="lineNum">    5106 </span><span class="lineCov">   18179561 :   if (iter-&gt;i &gt;= iter-&gt;n)</span>
<span class="lineNum">    5107 </span>            :     return NULL_TREE;
<span class="lineNum">    5108 </span><span class="lineCov">   10954115 :   result = CALL_EXPR_ARG (iter-&gt;t, iter-&gt;i);</span>
<span class="lineNum">    5109 </span><span class="lineCov">   10954115 :   iter-&gt;i++;</span>
<span class="lineNum">    5110 </span><span class="lineCov">   10954115 :   return result;</span>
<span class="lineNum">    5111 </span>            : }
<a name="5112"><span class="lineNum">    5112 </span>            : </a>
<span class="lineNum">    5113 </span>            : static inline const_tree
<span class="lineNum">    5114 </span><span class="lineCov">     989800 : next_const_call_expr_arg (const_call_expr_arg_iterator *iter)</span>
<span class="lineNum">    5115 </span>            : {
<span class="lineNum">    5116 </span><span class="lineCov">     989800 :   const_tree result;</span>
<span class="lineNum">    5117 </span><span class="lineCov">     989800 :   if (iter-&gt;i &gt;= iter-&gt;n)</span>
<span class="lineNum">    5118 </span>            :     return NULL_TREE;
<span class="lineNum">    5119 </span><span class="lineCov">     791065 :   result = CALL_EXPR_ARG (iter-&gt;t, iter-&gt;i);</span>
<span class="lineNum">    5120 </span><span class="lineCov">     791065 :   iter-&gt;i++;</span>
<span class="lineNum">    5121 </span><span class="lineCov">     791065 :   return result;</span>
<span class="lineNum">    5122 </span>            : }
<span class="lineNum">    5123 </span>            : 
<span class="lineNum">    5124 </span>            : /* Initialize the abstract argument list iterator object ITER, then advance
<span class="lineNum">    5125 </span>            :    past and return the first argument.  Useful in for expressions, e.g.
<span class="lineNum">    5126 </span>            :      for (arg = first_call_expr_arg (exp, &amp;iter); arg;
<span class="lineNum">    5127 </span>            :           arg = next_call_expr_arg (&amp;iter))   */
<span class="lineNum">    5128 </span>            : static inline tree
<span class="lineNum">    5129 </span>            : first_call_expr_arg (tree exp, call_expr_arg_iterator *iter)
<span class="lineNum">    5130 </span>            : {
<span class="lineNum">    5131 </span><span class="lineCov">    7227225 :   init_call_expr_arg_iterator (exp, iter);</span>
<span class="lineNum">    5132 </span><span class="lineCov">    7227225 :   return next_call_expr_arg (iter);</span>
<span class="lineNum">    5133 </span>            : }
<span class="lineNum">    5134 </span>            : 
<span class="lineNum">    5135 </span>            : static inline const_tree
<span class="lineNum">    5136 </span>            : first_const_call_expr_arg (const_tree exp, const_call_expr_arg_iterator *iter)
<span class="lineNum">    5137 </span>            : {
<span class="lineNum">    5138 </span><span class="lineCov">     236453 :   init_const_call_expr_arg_iterator (exp, iter);</span>
<span class="lineNum">    5139 </span><span class="lineCov">     236453 :   return next_const_call_expr_arg (iter);</span>
<span class="lineNum">    5140 </span>            : }
<span class="lineNum">    5141 </span>            : 
<span class="lineNum">    5142 </span>            : /* Test whether there are more arguments in abstract argument list iterator
<a name="5143"><span class="lineNum">    5143 </span>            :    ITER, without changing its state.  */</a>
<span class="lineNum">    5144 </span>            : static inline bool
<span class="lineNum">    5145 </span><span class="lineNoCov">          0 : more_call_expr_args_p (const call_expr_arg_iterator *iter)</span>
<span class="lineNum">    5146 </span>            : {
<span class="lineNum">    5147 </span><span class="lineCov">      54322 :   return (iter-&gt;i &lt; iter-&gt;n);</span>
<span class="lineNum">    5148 </span>            : }
<span class="lineNum">    5149 </span>            : 
<span class="lineNum">    5150 </span>            : /* Iterate through each argument ARG of CALL_EXPR CALL, using variable ITER
<span class="lineNum">    5151 </span>            :    (of type call_expr_arg_iterator) to hold the iteration state.  */
<span class="lineNum">    5152 </span>            : #define FOR_EACH_CALL_EXPR_ARG(arg, iter, call)                 \
<span class="lineNum">    5153 </span>            :   for ((arg) = first_call_expr_arg ((call), &amp;(iter)); (arg);        \
<span class="lineNum">    5154 </span>            :        (arg) = next_call_expr_arg (&amp;(iter)))
<span class="lineNum">    5155 </span>            : 
<span class="lineNum">    5156 </span>            : #define FOR_EACH_CONST_CALL_EXPR_ARG(arg, iter, call)                   \
<span class="lineNum">    5157 </span>            :   for ((arg) = first_const_call_expr_arg ((call), &amp;(iter)); (arg);  \
<span class="lineNum">    5158 </span>            :        (arg) = next_const_call_expr_arg (&amp;(iter)))
<span class="lineNum">    5159 </span>            : 
<span class="lineNum">    5160 </span>            : /* Return true if tree node T is a language-specific node.  */
<span class="lineNum">    5161 </span>            : static inline bool
<span class="lineNum">    5162 </span>            : is_lang_specific (const_tree t)
<span class="lineNum">    5163 </span>            : {
<span class="lineNum">    5164 </span><span class="lineCov">   78353702 :   return TREE_CODE (t) == LANG_TYPE || TREE_CODE (t) &gt;= NUM_TREE_CODES;</span>
<span class="lineNum">    5165 </span>            : }
<span class="lineNum">    5166 </span>            : 
<span class="lineNum">    5167 </span>            : /* Valid builtin number.  */
<span class="lineNum">    5168 </span>            : #define BUILTIN_VALID_P(FNCODE) \
<span class="lineNum">    5169 </span>            :   (IN_RANGE ((int)FNCODE, ((int)BUILT_IN_NONE) + 1, ((int) END_BUILTINS) - 1))
<span class="lineNum">    5170 </span>            : 
<span class="lineNum">    5171 </span>            : /* Return the tree node for an explicit standard builtin function or NULL.  */
<span class="lineNum">    5172 </span>            : static inline tree
<span class="lineNum">    5173 </span>            : builtin_decl_explicit (enum built_in_function fncode)
<span class="lineNum">    5174 </span>            : {
<span class="lineNum">    5175 </span><span class="lineCov">   10317879 :   gcc_checking_assert (BUILTIN_VALID_P (fncode));</span>
<span class="lineNum">    5176 </span>            : 
<span class="lineNum">    5177 </span><span class="lineCov">   13163736 :   return builtin_info[(size_t)fncode].decl;</span>
<span class="lineNum">    5178 </span>            : }
<span class="lineNum">    5179 </span>            : 
<a name="5180"><span class="lineNum">    5180 </span>            : /* Return the tree node for an implicit builtin function or NULL.  */</a>
<span class="lineNum">    5181 </span>            : static inline tree
<span class="lineNum">    5182 </span><span class="lineCov">      33591 : builtin_decl_implicit (enum built_in_function fncode)</span>
<span class="lineNum">    5183 </span>            : {
<span class="lineNum">    5184 </span><span class="lineCov">     538797 :   size_t uns_fncode = (size_t)fncode;</span>
<span class="lineNum">    5185 </span><span class="lineCov">     381678 :   gcc_checking_assert (BUILTIN_VALID_P (fncode));</span>
<span class="lineNum">    5186 </span>            : 
<span class="lineNum">    5187 </span><span class="lineCov">     538797 :   if (!builtin_info[uns_fncode].implicit_p)</span>
<span class="lineNum">    5188 </span>            :     return NULL_TREE;
<span class="lineNum">    5189 </span>            : 
<span class="lineNum">    5190 </span><span class="lineCov">     538581 :   return builtin_info[uns_fncode].decl;</span>
<span class="lineNum">    5191 </span>            : }
<span class="lineNum">    5192 </span>            : 
<span class="lineNum">    5193 </span>            : /* Set explicit builtin function nodes and whether it is an implicit
<span class="lineNum">    5194 </span>            :    function.  */
<a name="5195"><span class="lineNum">    5195 </span>            : </a>
<span class="lineNum">    5196 </span>            : static inline void
<span class="lineNum">    5197 </span><span class="lineCov">  144713874 : set_builtin_decl (enum built_in_function fncode, tree decl, bool implicit_p)</span>
<span class="lineNum">    5198 </span>            : {
<span class="lineNum">    5199 </span><span class="lineCov">  144715138 :   size_t ufncode = (size_t)fncode;</span>
<span class="lineNum">    5200 </span>            : 
<span class="lineNum">    5201 </span><span class="lineCov">  144715138 :   gcc_checking_assert (BUILTIN_VALID_P (fncode)</span>
<span class="lineNum">    5202 </span>            :                        &amp;&amp; (decl != NULL_TREE || !implicit_p));
<span class="lineNum">    5203 </span>            : 
<span class="lineNum">    5204 </span><span class="lineCov">  144715138 :   builtin_info[ufncode].decl = decl;</span>
<span class="lineNum">    5205 </span><span class="lineCov">  144715138 :   builtin_info[ufncode].implicit_p = implicit_p;</span>
<span class="lineNum">    5206 </span><span class="lineCov">  144715138 :   builtin_info[ufncode].declared_p = false;</span>
<span class="lineNum">    5207 </span><span class="lineCov">  144713874 : }</span>
<span class="lineNum">    5208 </span>            : 
<span class="lineNum">    5209 </span>            : /* Set the implicit flag for a builtin function.  */
<a name="5210"><span class="lineNum">    5210 </span>            : </a>
<span class="lineNum">    5211 </span>            : static inline void
<span class="lineNum">    5212 </span><span class="lineCov">     515299 : set_builtin_decl_implicit_p (enum built_in_function fncode, bool implicit_p)</span>
<span class="lineNum">    5213 </span>            : {
<span class="lineNum">    5214 </span><span class="lineCov">     515299 :   size_t uns_fncode = (size_t)fncode;</span>
<span class="lineNum">    5215 </span>            : 
<span class="lineNum">    5216 </span><span class="lineCov">     515299 :   gcc_checking_assert (BUILTIN_VALID_P (fncode)</span>
<span class="lineNum">    5217 </span>            :                        &amp;&amp; builtin_info[uns_fncode].decl != NULL_TREE);
<span class="lineNum">    5218 </span>            : 
<span class="lineNum">    5219 </span><span class="lineCov">     515299 :   builtin_info[uns_fncode].implicit_p = implicit_p;</span>
<span class="lineNum">    5220 </span><span class="lineCov">     515299 : }</span>
<span class="lineNum">    5221 </span>            : 
<span class="lineNum">    5222 </span>            : /* Set the declared flag for a builtin function.  */
<a name="5223"><span class="lineNum">    5223 </span>            : </a>
<span class="lineNum">    5224 </span>            : static inline void
<span class="lineNum">    5225 </span><span class="lineCov">    1896823 : set_builtin_decl_declared_p (enum built_in_function fncode, bool declared_p)</span>
<span class="lineNum">    5226 </span>            : {
<span class="lineNum">    5227 </span><span class="lineCov">    1896823 :   size_t uns_fncode = (size_t)fncode;</span>
<span class="lineNum">    5228 </span>            : 
<span class="lineNum">    5229 </span><span class="lineCov">    1896823 :   gcc_checking_assert (BUILTIN_VALID_P (fncode)</span>
<span class="lineNum">    5230 </span>            :                        &amp;&amp; builtin_info[uns_fncode].decl != NULL_TREE);
<span class="lineNum">    5231 </span>            : 
<span class="lineNum">    5232 </span><span class="lineCov">    1896823 :   builtin_info[uns_fncode].declared_p = declared_p;</span>
<span class="lineNum">    5233 </span><span class="lineCov">    1896823 : }</span>
<span class="lineNum">    5234 </span>            : 
<span class="lineNum">    5235 </span>            : /* Return whether the standard builtin function can be used as an explicit
<span class="lineNum">    5236 </span>            :    function.  */
<span class="lineNum">    5237 </span>            : 
<span class="lineNum">    5238 </span>            : static inline bool
<span class="lineNum">    5239 </span>            : builtin_decl_explicit_p (enum built_in_function fncode)
<span class="lineNum">    5240 </span>            : {
<span class="lineNum">    5241 </span><span class="lineCov">    5671652 :   gcc_checking_assert (BUILTIN_VALID_P (fncode));</span>
<span class="lineNum">    5242 </span><span class="lineCov">    6532914 :   return (builtin_info[(size_t)fncode].decl != NULL_TREE);</span>
<span class="lineNum">    5243 </span>            : }
<span class="lineNum">    5244 </span>            : 
<span class="lineNum">    5245 </span>            : /* Return whether the standard builtin function can be used implicitly.  */
<a name="5246"><span class="lineNum">    5246 </span>            : </a>
<span class="lineNum">    5247 </span>            : static inline bool
<span class="lineNum">    5248 </span><span class="lineCov">      17193 : builtin_decl_implicit_p (enum built_in_function fncode)</span>
<span class="lineNum">    5249 </span>            : {
<span class="lineNum">    5250 </span><span class="lineCov">      64956 :   size_t uns_fncode = (size_t)fncode;</span>
<span class="lineNum">    5251 </span>            : 
<span class="lineNum">    5252 </span><span class="lineCov">      64956 :   gcc_checking_assert (BUILTIN_VALID_P (fncode));</span>
<span class="lineNum">    5253 </span><span class="lineCov">      64956 :   return (builtin_info[uns_fncode].decl != NULL_TREE</span>
<span class="lineNum">    5254 </span><span class="lineCov">      64956 :           &amp;&amp; builtin_info[uns_fncode].implicit_p);</span>
<span class="lineNum">    5255 </span>            : }
<span class="lineNum">    5256 </span>            : 
<span class="lineNum">    5257 </span>            : /* Return whether the standard builtin function was declared.  */
<a name="5258"><span class="lineNum">    5258 </span>            : </a>
<span class="lineNum">    5259 </span>            : static inline bool
<span class="lineNum">    5260 </span><span class="lineCov">    2007220 : builtin_decl_declared_p (enum built_in_function fncode)</span>
<span class="lineNum">    5261 </span>            : {
<span class="lineNum">    5262 </span><span class="lineCov">    2007220 :   size_t uns_fncode = (size_t)fncode;</span>
<span class="lineNum">    5263 </span>            : 
<span class="lineNum">    5264 </span><span class="lineCov">    2007220 :   gcc_checking_assert (BUILTIN_VALID_P (fncode));</span>
<span class="lineNum">    5265 </span><span class="lineCov">    2007220 :   return (builtin_info[uns_fncode].decl != NULL_TREE</span>
<span class="lineNum">    5266 </span><span class="lineCov">    2007220 :           &amp;&amp; builtin_info[uns_fncode].declared_p);</span>
<span class="lineNum">    5267 </span>            : }
<span class="lineNum">    5268 </span>            : 
<span class="lineNum">    5269 </span>            : /* Return true if T (assumed to be a DECL) is a global variable.
<span class="lineNum">    5270 </span>            :    A variable is considered global if its storage is not automatic.  */
<a name="5271"><span class="lineNum">    5271 </span>            : </a>
<span class="lineNum">    5272 </span>            : static inline bool
<span class="lineNum">    5273 </span><span class="lineCov"> 1242865072 : is_global_var (const_tree t)</span>
<span class="lineNum">    5274 </span>            : {
<span class="lineNum">    5275 </span><span class="lineCov"> 1242865072 :   return (TREE_STATIC (t) || DECL_EXTERNAL (t));</span>
<span class="lineNum">    5276 </span>            : }
<span class="lineNum">    5277 </span>            : 
<span class="lineNum">    5278 </span>            : /* Return true if VAR may be aliased.  A variable is considered as
<span class="lineNum">    5279 </span>            :    maybe aliased if it has its address taken by the local TU
<span class="lineNum">    5280 </span>            :    or possibly by another TU and might be modified through a pointer.  */
<a name="5281"><span class="lineNum">    5281 </span>            : </a>
<span class="lineNum">    5282 </span>            : static inline bool
<span class="lineNum">    5283 </span><span class="lineCov">  356783795 : may_be_aliased (const_tree var)</span>
<span class="lineNum">    5284 </span>            : {
<span class="lineNum">    5285 </span><span class="lineCov">  356783795 :   return (TREE_CODE (var) != CONST_DECL</span>
<span class="lineNum">    5286 </span><span class="lineCov">  356224180 :           &amp;&amp; (TREE_PUBLIC (var)</span>
<span class="lineNum">    5287 </span><span class="lineCov">  356224180 :               || DECL_EXTERNAL (var)</span>
<span class="lineNum">    5288 </span><span class="lineCov">  345120159 :               || TREE_ADDRESSABLE (var))</span>
<span class="lineNum">    5289 </span><span class="lineCov">  446703834 :           &amp;&amp; !((TREE_STATIC (var) || TREE_PUBLIC (var) || DECL_EXTERNAL (var))</span>
<span class="lineNum">    5290 </span><span class="lineCov">   16843182 :                &amp;&amp; ((TREE_READONLY (var)</span>
<span class="lineNum">    5291 </span><span class="lineCov">   16843182 :                     &amp;&amp; !TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (var)))</span>
<span class="lineNum">    5292 </span><span class="lineCov">   14215804 :                    || (TREE_CODE (var) == VAR_DECL</span>
<span class="lineNum">    5293 </span><span class="lineCov">   13401029 :                        &amp;&amp; DECL_NONALIASED (var)))));</span>
<span class="lineNum">    5294 </span>            : }
<span class="lineNum">    5295 </span>            : 
<a name="5296"><span class="lineNum">    5296 </span>            : /* Return pointer to optimization flags of FNDECL.  */</a>
<span class="lineNum">    5297 </span>            : static inline struct cl_optimization *
<span class="lineNum">    5298 </span><span class="lineCov"> 1216730788 : opts_for_fn (const_tree fndecl)</span>
<span class="lineNum">    5299 </span>            : {
<span class="lineNum">    5300 </span><span class="lineCov"> 1216730788 :   tree fn_opts = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (fndecl);</span>
<span class="lineNum">    5301 </span><span class="lineCov"> 1216730788 :   if (fn_opts == NULL_TREE)</span>
<span class="lineNum">    5302 </span><span class="lineCov"> 1147631443 :     fn_opts = optimization_default_node;</span>
<span class="lineNum">    5303 </span><span class="lineCov"> 1216730788 :   return TREE_OPTIMIZATION (fn_opts);</span>
<span class="lineNum">    5304 </span>            : }
<span class="lineNum">    5305 </span>            : 
<a name="5306"><span class="lineNum">    5306 </span>            : /* Return pointer to target flags of FNDECL.  */</a>
<span class="lineNum">    5307 </span>            : static inline cl_target_option *
<span class="lineNum">    5308 </span><span class="lineCov">    1408482 : target_opts_for_fn (const_tree fndecl)</span>
<span class="lineNum">    5309 </span>            : {
<span class="lineNum">    5310 </span><span class="lineCov">    1408482 :   tree fn_opts = DECL_FUNCTION_SPECIFIC_TARGET (fndecl);</span>
<span class="lineNum">    5311 </span><span class="lineCov">    1408482 :   if (fn_opts == NULL_TREE)</span>
<span class="lineNum">    5312 </span><span class="lineCov">    1165653 :     fn_opts = target_option_default_node;</span>
<span class="lineNum">    5313 </span><span class="lineCov">    1408482 :   return fn_opts == NULL_TREE ? NULL : TREE_TARGET_OPTION (fn_opts);</span>
<span class="lineNum">    5314 </span>            : }
<span class="lineNum">    5315 </span>            : 
<span class="lineNum">    5316 </span>            : /* opt flag for function FNDECL, e.g. opts_for_fn (fndecl, optimize) is
<span class="lineNum">    5317 </span>            :    the optimization level of function fndecl.  */
<span class="lineNum">    5318 </span>            : #define opt_for_fn(fndecl, opt) (opts_for_fn (fndecl)-&gt;x_##opt)
<span class="lineNum">    5319 </span>            : 
<span class="lineNum">    5320 </span>            : /* For anonymous aggregate types, we need some sort of name to
<span class="lineNum">    5321 </span>            :    hold on to.  In practice, this should not appear, but it should
<span class="lineNum">    5322 </span>            :    not be harmful if it does.  */
<span class="lineNum">    5323 </span>            : extern const char *anon_aggrname_format();
<span class="lineNum">    5324 </span>            : extern bool anon_aggrname_p (const_tree);
<span class="lineNum">    5325 </span>            : 
<span class="lineNum">    5326 </span>            : /* The tree and const_tree overload templates.   */
<span class="lineNum">    5327 </span>            : namespace wi
<span class="lineNum">    5328 </span>            : {
<span class="lineNum">    5329 </span>            :   class unextended_tree
<span class="lineNum">    5330 </span>            :   {
<span class="lineNum">    5331 </span>            :   private:
<span class="lineNum">    5332 </span>            :     const_tree m_t;
<span class="lineNum">    5333 </span>            : 
<span class="lineNum">    5334 </span>            :   public:
<span class="lineNum">    5335 </span>            :     unextended_tree () {}
<span class="lineNum">    5336 </span>            :     unextended_tree (const_tree t) : m_t (t) {}
<span class="lineNum">    5337 </span>            : 
<span class="lineNum">    5338 </span>            :     unsigned int get_precision () const;
<a name="5339"><span class="lineNum">    5339 </span>            :     const HOST_WIDE_INT *get_val () const;</a>
<span class="lineNum">    5340 </span>            :     unsigned int get_len () const;
<span class="lineNum">    5341 </span><span class="lineNoCov">          0 :     const_tree get_tree () const { return m_t; }</span>
<span class="lineNum">    5342 </span>            :   };
<span class="lineNum">    5343 </span>            : 
<span class="lineNum">    5344 </span>            :   template &lt;&gt;
<span class="lineNum">    5345 </span>            :   struct int_traits &lt;unextended_tree&gt;
<span class="lineNum">    5346 </span>            :   {
<span class="lineNum">    5347 </span>            :     static const enum precision_type precision_type = VAR_PRECISION;
<span class="lineNum">    5348 </span>            :     static const bool host_dependent_precision = false;
<span class="lineNum">    5349 </span>            :     static const bool is_sign_extended = false;
<span class="lineNum">    5350 </span>            :   };
<span class="lineNum">    5351 </span>            : 
<span class="lineNum">    5352 </span>            :   template &lt;int N&gt;
<span class="lineNum">    5353 </span>            :   class extended_tree
<span class="lineNum">    5354 </span>            :   {
<span class="lineNum">    5355 </span>            :   private:
<span class="lineNum">    5356 </span>            :     const_tree m_t;
<span class="lineNum">    5357 </span>            : 
<span class="lineNum">    5358 </span>            :   public:
<span class="lineNum">    5359 </span>            :     extended_tree () {}
<span class="lineNum">    5360 </span>            :     extended_tree (const_tree);
<span class="lineNum">    5361 </span>            : 
<span class="lineNum">    5362 </span>            :     unsigned int get_precision () const;
<a name="5363"><span class="lineNum">    5363 </span>            :     const HOST_WIDE_INT *get_val () const;</a>
<span class="lineNum">    5364 </span>            :     unsigned int get_len () const;
<span class="lineNum">    5365 </span><span class="lineNoCov">          0 :     const_tree get_tree () const { return m_t; }</span>
<span class="lineNum">    5366 </span>            :   };
<span class="lineNum">    5367 </span>            : 
<span class="lineNum">    5368 </span>            :   template &lt;int N&gt;
<span class="lineNum">    5369 </span>            :   struct int_traits &lt;extended_tree &lt;N&gt; &gt;
<span class="lineNum">    5370 </span>            :   {
<span class="lineNum">    5371 </span>            :     static const enum precision_type precision_type = CONST_PRECISION;
<span class="lineNum">    5372 </span>            :     static const bool host_dependent_precision = false;
<span class="lineNum">    5373 </span>            :     static const bool is_sign_extended = true;
<span class="lineNum">    5374 </span>            :     static const unsigned int precision = N;
<span class="lineNum">    5375 </span>            :   };
<span class="lineNum">    5376 </span>            : 
<span class="lineNum">    5377 </span>            :   typedef extended_tree &lt;WIDE_INT_MAX_PRECISION&gt; widest_extended_tree;
<span class="lineNum">    5378 </span>            :   typedef extended_tree &lt;ADDR_MAX_PRECISION&gt; offset_extended_tree;
<span class="lineNum">    5379 </span>            : 
<span class="lineNum">    5380 </span>            :   typedef const generic_wide_int &lt;widest_extended_tree&gt; tree_to_widest_ref;
<span class="lineNum">    5381 </span>            :   typedef const generic_wide_int &lt;offset_extended_tree&gt; tree_to_offset_ref;
<span class="lineNum">    5382 </span>            :   typedef const generic_wide_int&lt;wide_int_ref_storage&lt;false, false&gt; &gt;
<span class="lineNum">    5383 </span>            :     tree_to_wide_ref;
<span class="lineNum">    5384 </span>            : 
<span class="lineNum">    5385 </span>            :   tree_to_widest_ref to_widest (const_tree);
<span class="lineNum">    5386 </span>            :   tree_to_offset_ref to_offset (const_tree);
<span class="lineNum">    5387 </span>            :   tree_to_wide_ref to_wide (const_tree);
<span class="lineNum">    5388 </span>            :   wide_int to_wide (const_tree, unsigned int);
<span class="lineNum">    5389 </span>            : 
<span class="lineNum">    5390 </span>            :   typedef const poly_int &lt;NUM_POLY_INT_COEFFS,
<span class="lineNum">    5391 </span>            :                           generic_wide_int &lt;widest_extended_tree&gt; &gt;
<span class="lineNum">    5392 </span>            :     tree_to_poly_widest_ref;
<span class="lineNum">    5393 </span>            :   typedef const poly_int &lt;NUM_POLY_INT_COEFFS,
<span class="lineNum">    5394 </span>            :                           generic_wide_int &lt;offset_extended_tree&gt; &gt;
<span class="lineNum">    5395 </span>            :     tree_to_poly_offset_ref;
<span class="lineNum">    5396 </span>            :   typedef const poly_int &lt;NUM_POLY_INT_COEFFS,
<span class="lineNum">    5397 </span>            :                           generic_wide_int &lt;unextended_tree&gt; &gt;
<span class="lineNum">    5398 </span>            :     tree_to_poly_wide_ref;
<span class="lineNum">    5399 </span>            : 
<span class="lineNum">    5400 </span>            :   tree_to_poly_widest_ref to_poly_widest (const_tree);
<span class="lineNum">    5401 </span>            :   tree_to_poly_offset_ref to_poly_offset (const_tree);
<span class="lineNum">    5402 </span>            :   tree_to_poly_wide_ref to_poly_wide (const_tree);
<span class="lineNum">    5403 </span>            : 
<span class="lineNum">    5404 </span>            :   template &lt;int N&gt;
<span class="lineNum">    5405 </span>            :   struct ints_for &lt;generic_wide_int &lt;extended_tree &lt;N&gt; &gt;, CONST_PRECISION&gt;
<span class="lineNum">    5406 </span>            :   {
<span class="lineNum">    5407 </span>            :     typedef generic_wide_int &lt;extended_tree &lt;N&gt; &gt; extended;
<span class="lineNum">    5408 </span>            :     static extended zero (const extended &amp;);
<span class="lineNum">    5409 </span>            :   };
<span class="lineNum">    5410 </span>            : 
<span class="lineNum">    5411 </span>            :   template &lt;&gt;
<span class="lineNum">    5412 </span>            :   struct ints_for &lt;generic_wide_int &lt;unextended_tree&gt;, VAR_PRECISION&gt;
<span class="lineNum">    5413 </span>            :   {
<span class="lineNum">    5414 </span>            :     typedef generic_wide_int &lt;unextended_tree&gt; unextended;
<span class="lineNum">    5415 </span>            :     static unextended zero (const unextended &amp;);
<span class="lineNum">    5416 </span>            :   };
<span class="lineNum">    5417 </span>            : }
<span class="lineNum">    5418 </span>            : 
<span class="lineNum">    5419 </span>            : /* Used to convert a tree to a widest2_int like this:
<span class="lineNum">    5420 </span>            :    widest2_int foo = widest2_int_cst (some_tree).  */
<span class="lineNum">    5421 </span>            : typedef generic_wide_int &lt;wi::extended_tree &lt;WIDE_INT_MAX_PRECISION * 2&gt; &gt;
<span class="lineNum">    5422 </span>            :   widest2_int_cst;
<span class="lineNum">    5423 </span>            : 
<span class="lineNum">    5424 </span>            : /* Refer to INTEGER_CST T as though it were a widest_int.
<span class="lineNum">    5425 </span>            : 
<span class="lineNum">    5426 </span>            :    This function gives T's actual numerical value, influenced by the
<span class="lineNum">    5427 </span>            :    signedness of its type.  For example, a signed byte with just the
<span class="lineNum">    5428 </span>            :    top bit set would be -128 while an unsigned byte with the same
<span class="lineNum">    5429 </span>            :    bit pattern would be 128.
<span class="lineNum">    5430 </span>            : 
<span class="lineNum">    5431 </span>            :    This is the right choice when operating on groups of INTEGER_CSTs
<span class="lineNum">    5432 </span>            :    that might have different signedness or precision.  It is also the
<span class="lineNum">    5433 </span>            :    right choice in code that specifically needs an approximation of
<span class="lineNum">    5434 </span>            :    infinite-precision arithmetic instead of normal modulo arithmetic.
<span class="lineNum">    5435 </span>            : 
<span class="lineNum">    5436 </span>            :    The approximation of infinite precision is good enough for realistic
<span class="lineNum">    5437 </span>            :    numbers of additions and subtractions of INTEGER_CSTs (where
<span class="lineNum">    5438 </span>            :    &quot;realistic&quot; includes any number less than 1 &lt;&lt; 31) but it cannot
<span class="lineNum">    5439 </span>            :    represent the result of multiplying the two largest supported
<span class="lineNum">    5440 </span>            :    INTEGER_CSTs.  The overflow-checking form of wi::mul provides a way
<span class="lineNum">    5441 </span>            :    of multiplying two arbitrary INTEGER_CSTs and checking that the
<span class="lineNum">    5442 </span>            :    result is representable as a widest_int.
<span class="lineNum">    5443 </span>            : 
<span class="lineNum">    5444 </span>            :    Note that any overflow checking done on these values is relative to
<span class="lineNum">    5445 </span>            :    the range of widest_int rather than the range of a TREE_TYPE.
<span class="lineNum">    5446 </span>            : 
<span class="lineNum">    5447 </span>            :    Calling this function should have no overhead in release builds,
<span class="lineNum">    5448 </span>            :    so it is OK to call it several times for the same tree.  If it is
<span class="lineNum">    5449 </span>            :    useful for readability reasons to reduce the number of calls,
<span class="lineNum">    5450 </span>            :    it is more efficient to use:
<span class="lineNum">    5451 </span>            : 
<span class="lineNum">    5452 </span>            :      wi::tree_to_widest_ref wt = wi::to_widest (t);
<span class="lineNum">    5453 </span>            : 
<span class="lineNum">    5454 </span>            :    instead of:
<span class="lineNum">    5455 </span>            : 
<span class="lineNum">    5456 </span>            :      widest_int wt = wi::to_widest (t).  */
<span class="lineNum">    5457 </span>            : 
<span class="lineNum">    5458 </span>            : inline wi::tree_to_widest_ref
<span class="lineNum">    5459 </span>            : wi::to_widest (const_tree t)
<span class="lineNum">    5460 </span>            : {
<span class="lineNum">    5461 </span><span class="lineCov"> 5023651109 :   return t;</span>
<span class="lineNum">    5462 </span>            : }
<span class="lineNum">    5463 </span>            : 
<span class="lineNum">    5464 </span>            : /* Refer to INTEGER_CST T as though it were an offset_int.
<span class="lineNum">    5465 </span>            : 
<span class="lineNum">    5466 </span>            :    This function is an optimisation of wi::to_widest for cases
<span class="lineNum">    5467 </span>            :    in which T is known to be a bit or byte count in the range
<span class="lineNum">    5468 </span>            :    (-(2 ^ (N + BITS_PER_UNIT)), 2 ^ (N + BITS_PER_UNIT)), where N is
<span class="lineNum">    5469 </span>            :    the target's address size in bits.
<span class="lineNum">    5470 </span>            : 
<span class="lineNum">    5471 </span>            :    This is the right choice when operating on bit or byte counts as
<span class="lineNum">    5472 </span>            :    untyped numbers rather than M-bit values.  The wi::to_widest comments
<span class="lineNum">    5473 </span>            :    about addition, subtraction and multiplication apply here: sequences
<span class="lineNum">    5474 </span>            :    of 1 &lt;&lt; 31 additions and subtractions do not induce overflow, but
<span class="lineNum">    5475 </span>            :    multiplying the largest sizes might.  Again,
<span class="lineNum">    5476 </span>            : 
<span class="lineNum">    5477 </span>            :      wi::tree_to_offset_ref wt = wi::to_offset (t);
<span class="lineNum">    5478 </span>            : 
<span class="lineNum">    5479 </span>            :    is more efficient than:
<span class="lineNum">    5480 </span>            : 
<span class="lineNum">    5481 </span>            :      offset_int wt = wi::to_offset (t).  */
<span class="lineNum">    5482 </span>            : 
<span class="lineNum">    5483 </span>            : inline wi::tree_to_offset_ref
<span class="lineNum">    5484 </span>            : wi::to_offset (const_tree t)
<span class="lineNum">    5485 </span>            : {
<span class="lineNum">    5486 </span><span class="lineCov"> 1308058403 :   return t;</span>
<span class="lineNum">    5487 </span>            : }
<span class="lineNum">    5488 </span>            : 
<span class="lineNum">    5489 </span>            : /* Refer to INTEGER_CST T as though it were a wide_int.
<span class="lineNum">    5490 </span>            : 
<span class="lineNum">    5491 </span>            :    In contrast to the approximation of infinite-precision numbers given
<span class="lineNum">    5492 </span>            :    by wi::to_widest and wi::to_offset, this function treats T as a
<span class="lineNum">    5493 </span>            :    signless collection of N bits, where N is the precision of T's type.
<span class="lineNum">    5494 </span>            :    As with machine registers, signedness is determined by the operation
<span class="lineNum">    5495 </span>            :    rather than the operands; for example, there is a distinction between
<span class="lineNum">    5496 </span>            :    signed and unsigned division.
<span class="lineNum">    5497 </span>            : 
<span class="lineNum">    5498 </span>            :    This is the right choice when operating on values with the same type
<span class="lineNum">    5499 </span>            :    using normal modulo arithmetic.  The overflow-checking forms of things
<span class="lineNum">    5500 </span>            :    like wi::add check whether the result can be represented in T's type.
<span class="lineNum">    5501 </span>            : 
<span class="lineNum">    5502 </span>            :    Calling this function should have no overhead in release builds,
<span class="lineNum">    5503 </span>            :    so it is OK to call it several times for the same tree.  If it is
<span class="lineNum">    5504 </span>            :    useful for readability reasons to reduce the number of calls,
<span class="lineNum">    5505 </span>            :    it is more efficient to use:
<span class="lineNum">    5506 </span>            : 
<span class="lineNum">    5507 </span>            :      wi::tree_to_wide_ref wt = wi::to_wide (t);
<span class="lineNum">    5508 </span>            : 
<span class="lineNum">    5509 </span>            :    instead of:
<span class="lineNum">    5510 </span>            : 
<span class="lineNum">    5511 </span>            :      wide_int wt = wi::to_wide (t).  */
<a name="5512"><span class="lineNum">    5512 </span>            : </a>
<span class="lineNum">    5513 </span>            : inline wi::tree_to_wide_ref
<span class="lineNum">    5514 </span><span class="lineCov"> 3942500225 : wi::to_wide (const_tree t)</span>
<span class="lineNum">    5515 </span>            : {
<span class="lineNum">    5516 </span><span class="lineCov"> 3942500225 :   return wi::storage_ref (&amp;TREE_INT_CST_ELT (t, 0), TREE_INT_CST_NUNITS (t),</span>
<span class="lineNum">    5517 </span><span class="lineCov"> 3942500225 :                           TYPE_PRECISION (TREE_TYPE (t)));</span>
<span class="lineNum">    5518 </span>            : }
<span class="lineNum">    5519 </span>            : 
<span class="lineNum">    5520 </span>            : /* Convert INTEGER_CST T to a wide_int of precision PREC, extending or
<span class="lineNum">    5521 </span>            :    truncating as necessary.  When extending, use sign extension if T's
<span class="lineNum">    5522 </span>            :    type is signed and zero extension if T's type is unsigned.  */
<a name="5523"><span class="lineNum">    5523 </span>            : </a>
<span class="lineNum">    5524 </span>            : inline wide_int
<span class="lineNum">    5525 </span><span class="lineCov">  386981343 : wi::to_wide (const_tree t, unsigned int prec)</span>
<span class="lineNum">    5526 </span>            : {
<span class="lineNum">    5527 </span><span class="lineCov">  386981343 :   return wide_int::from (wi::to_wide (t), prec, TYPE_SIGN (TREE_TYPE (t)));</span>
<span class="lineNum">    5528 </span>            : }
<a name="5529"><span class="lineNum">    5529 </span>            : </a>
<span class="lineNum">    5530 </span>            : template &lt;int N&gt;
<span class="lineNum">    5531 </span><span class="lineCov"> 9671467295 : inline wi::extended_tree &lt;N&gt;::extended_tree (const_tree t)</span>
<span class="lineNum">    5532 </span><span class="lineCov"> 9671467295 :   : m_t (t)</span>
<span class="lineNum">    5533 </span>            : {
<span class="lineNum">    5534 </span><span class="lineCov"> 9671467295 :   gcc_checking_assert (TYPE_PRECISION (TREE_TYPE (t)) &lt;= N);</span>
<span class="lineNum">    5535 </span><span class="lineCov"> 9671467295 : }</span>
<span class="lineNum">    5536 </span><span class="lineCov">  669631597 : </span>
<a name="5537"><span class="lineNum">    5537 </span><span class="lineCov">  669631597 : template &lt;int N&gt;</span></a>
<span class="lineNum">    5538 </span>            : inline unsigned int
<span class="lineNum">    5539 </span><span class="lineCov">  669631597 : wi::extended_tree &lt;N&gt;::get_precision () const</span>
<span class="lineNum">    5540 </span><span class="lineCov">  669631597 : {</span>
<span class="lineNum">    5541 </span><span class="lineCov"> 5096756376 :   return N;</span>
<span class="lineNum">    5542 </span><span class="lineCov"> 5096756376 : }</span>
<span class="lineNum">    5543 </span>            : 
<a name="5544"><span class="lineNum">    5544 </span><span class="lineCov"> 5096756376 : template &lt;int N&gt;</span></a>
<span class="lineNum">    5545 </span><span class="lineCov"> 5096756376 : inline const HOST_WIDE_INT *</span>
<span class="lineNum">    5546 </span><span class="lineCov">     431210 : wi::extended_tree &lt;N&gt;::get_val () const</span>
<span class="lineNum">    5547 </span><span class="lineCov">     431210 : {</span>
<span class="lineNum">    5548 </span><span class="lineCov"> 4229641159 :   return &amp;TREE_INT_CST_ELT (m_t, 0);</span>
<span class="lineNum">    5549 </span><span class="lineCov">     431210 : }</span>
<span class="lineNum">    5550 </span><span class="lineCov">     431210 : </span>
<a name="5551"><span class="lineNum">    5551 </span><span class="lineNoCov">          0 : template &lt;int N&gt;</span></a>
<span class="lineNum">    5552 </span>            : inline unsigned int
<span class="lineNum">    5553 </span><span class="lineNoCov">          0 : wi::extended_tree &lt;N&gt;::get_len () const</span>
<span class="lineNum">    5554 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">    5555 </span><span class="lineNoCov">          0 :   if (N == ADDR_MAX_PRECISION)</span>
<span class="lineNum">    5556 </span><span class="lineCov"> 3267796885 :     return TREE_INT_CST_OFFSET_NUNITS (m_t);</span>
<span class="lineNum">    5557 </span><span class="lineNoCov">          0 :   else if (N &gt;= WIDE_INT_MAX_PRECISION)</span>
<span class="lineNum">    5558 </span><span class="lineCov">  963474247 :     return TREE_INT_CST_EXT_NUNITS (m_t);</span>
<span class="lineNum">    5559 </span><span class="lineNoCov">          0 :   else</span>
<span class="lineNum">    5560 </span><span class="lineNoCov">          0 :     /* This class is designed to be used for specific output precisions</span>
<span class="lineNum">    5561 </span>            :        and needs to be as fast as possible, so there is no fallback for
<span class="lineNum">    5562 </span><span class="lineNoCov">          0 :        other casees.  */</span>
<span class="lineNum">    5563 </span>            :     gcc_unreachable ();
<span class="lineNum">    5564 </span><span class="lineNoCov">          0 : }</span>
<a name="5565"><span class="lineNum">    5565 </span>            : </a>
<span class="lineNum">    5566 </span><span class="lineCov"> 5398120518 : inline unsigned int</span>
<span class="lineNum">    5567 </span><span class="lineNoCov">          0 : wi::unextended_tree::get_precision () const</span>
<span class="lineNum">    5568 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">    5569 </span><span class="lineNoCov">          0 :   return TYPE_PRECISION (TREE_TYPE (m_t));</span>
<span class="lineNum">    5570 </span><span class="lineNoCov">          0 : }</span>
<a name="5571"><span class="lineNum">    5571 </span>            : </a>
<span class="lineNum">    5572 </span><span class="lineNoCov">          0 : inline const HOST_WIDE_INT *</span>
<span class="lineNum">    5573 </span><span class="lineNoCov">          0 : wi::unextended_tree::get_val () const</span>
<span class="lineNum">    5574 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">    5575 </span><span class="lineCov">   78574007 :   return &amp;TREE_INT_CST_ELT (m_t, 0);</span>
<span class="lineNum">    5576 </span>            : }
<a name="5577"><span class="lineNum">    5577 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">    5578 </span>            : inline unsigned int
<span class="lineNum">    5579 </span><span class="lineNoCov">          0 : wi::unextended_tree::get_len () const</span>
<span class="lineNum">    5580 </span>            : {
<span class="lineNum">    5581 </span><span class="lineCov">   11830886 :   return TREE_INT_CST_NUNITS (m_t);</span>
<span class="lineNum">    5582 </span><span class="lineCov">  487917117 : }</span>
<span class="lineNum">    5583 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    5584 </span><span class="lineCov"> 4910156543 : /* Return the value of a POLY_INT_CST in its native precision.  */</span>
<a name="5585"><span class="lineNum">    5585 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">    5586 </span>            : inline wi::tree_to_poly_wide_ref
<span class="lineNum">    5587 </span><span class="lineNoCov">          0 : poly_int_cst_value (const_tree x)</span>
<span class="lineNum">    5588 </span>            : {
<span class="lineNum">    5589 </span><span class="lineNoCov">          0 :   poly_int &lt;NUM_POLY_INT_COEFFS, generic_wide_int &lt;wi::unextended_tree&gt; &gt; res;</span>
<span class="lineNum">    5590 </span><span class="lineNoCov">          0 :   for (unsigned int i = 0; i &lt; NUM_POLY_INT_COEFFS; ++i)</span>
<span class="lineNum">    5591 </span><span class="lineNoCov">          0 :     res.coeffs[i] = POLY_INT_CST_COEFF (x, i);</span>
<span class="lineNum">    5592 </span><span class="lineNoCov">          0 :   return res;</span>
<span class="lineNum">    5593 </span>            : }
<span class="lineNum">    5594 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    5595 </span><span class="lineCov">   63905708 : /* Access INTEGER_CST or POLY_INT_CST tree T as if it were a</span>
<span class="lineNum">    5596 </span>            :    poly_widest_int.  See wi::to_widest for more details.  */
<span class="lineNum">    5597 </span><span class="lineCov">    2837413 : </span>
<span class="lineNum">    5598 </span>            : inline wi::tree_to_poly_widest_ref
<span class="lineNum">    5599 </span>            : wi::to_poly_widest (const_tree t)
<span class="lineNum">    5600 </span>            : {
<span class="lineNum">    5601 </span><span class="lineCov">   17932021 :   if (POLY_INT_CST_P (t))</span>
<span class="lineNum">    5602 </span>            :     {
<span class="lineNum">    5603 </span><span class="lineNoCov">          0 :       poly_int &lt;NUM_POLY_INT_COEFFS,</span>
<span class="lineNum">    5604 </span><span class="lineNoCov">          0 :                 generic_wide_int &lt;widest_extended_tree&gt; &gt; res;</span>
<span class="lineNum">    5605 </span>            :       for (unsigned int i = 0; i &lt; NUM_POLY_INT_COEFFS; ++i)
<span class="lineNum">    5606 </span>            :         res.coeffs[i] = POLY_INT_CST_COEFF (t, i);
<span class="lineNum">    5607 </span>            :       return res;
<span class="lineNum">    5608 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    5609 </span><span class="lineCov">   17932021 :   return t;</span>
<span class="lineNum">    5610 </span>            : }
<span class="lineNum">    5611 </span>            : 
<span class="lineNum">    5612 </span>            : /* Access INTEGER_CST or POLY_INT_CST tree T as if it were a
<span class="lineNum">    5613 </span>            :    poly_offset_int.  See wi::to_offset for more details.  */
<span class="lineNum">    5614 </span>            : 
<span class="lineNum">    5615 </span>            : inline wi::tree_to_poly_offset_ref
<span class="lineNum">    5616 </span><span class="lineNoCov">          0 : wi::to_poly_offset (const_tree t)</span>
<span class="lineNum">    5617 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">    5618 </span><span class="lineCov"> 2175904160 :   if (POLY_INT_CST_P (t))</span>
<span class="lineNum">    5619 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">    5620 </span>            :       poly_int &lt;NUM_POLY_INT_COEFFS,
<span class="lineNum">    5621 </span>            :                 generic_wide_int &lt;offset_extended_tree&gt; &gt; res;
<span class="lineNum">    5622 </span>            :       for (unsigned int i = 0; i &lt; NUM_POLY_INT_COEFFS; ++i)
<span class="lineNum">    5623 </span><span class="lineNoCov">          0 :         res.coeffs[i] = POLY_INT_CST_COEFF (t, i);</span>
<span class="lineNum">    5624 </span>            :       return res;
<span class="lineNum">    5625 </span><span class="lineCov">  854293858 :     }</span>
<span class="lineNum">    5626 </span><span class="lineCov"> 1940849371 :   return t;</span>
<span class="lineNum">    5627 </span>            : }
<span class="lineNum">    5628 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    5629 </span><span class="lineNoCov">          0 : /* Access INTEGER_CST or POLY_INT_CST tree T as if it were a</span>
<span class="lineNum">    5630 </span>            :    poly_wide_int.  See wi::to_wide for more details.  */
<span class="lineNum">    5631 </span><span class="lineCov">  854293858 : </span>
<span class="lineNum">    5632 </span>            : inline wi::tree_to_poly_wide_ref
<span class="lineNum">    5633 </span><span class="lineNoCov">          0 : wi::to_poly_wide (const_tree t)</span>
<span class="lineNum">    5634 </span>            : {
<span class="lineNum">    5635 </span><span class="lineCov">   11830886 :   if (POLY_INT_CST_P (t))</span>
<span class="lineNum">    5636 </span>            :     return poly_int_cst_value (t);
<span class="lineNum">    5637 </span><span class="lineCov">   23661772 :   return t;</span>
<span class="lineNum">    5638 </span>            : }
<span class="lineNum">    5639 </span><span class="lineNoCov">          0 : </span>
<a name="5640"><span class="lineNum">    5640 </span><span class="lineNoCov">          0 : template &lt;int N&gt;</span></a>
<span class="lineNum">    5641 </span><span class="lineNoCov">          0 : inline generic_wide_int &lt;wi::extended_tree &lt;N&gt; &gt;</span>
<span class="lineNum">    5642 </span><span class="lineNoCov">          0 : wi::ints_for &lt;generic_wide_int &lt;wi::extended_tree &lt;N&gt; &gt;,</span>
<span class="lineNum">    5643 </span>            :               wi::CONST_PRECISION&gt;::zero (const extended &amp;x)
<span class="lineNum">    5644 </span>            : {
<span class="lineNum">    5645 </span><span class="lineNoCov">          0 :   return build_zero_cst (TREE_TYPE (x.get_tree ()));</span>
<span class="lineNum">    5646 </span>            : }
<a name="5647"><span class="lineNum">    5647 </span>            : </a>
<span class="lineNum">    5648 </span>            : inline generic_wide_int &lt;wi::unextended_tree&gt;
<span class="lineNum">    5649 </span><span class="lineNoCov">          0 : wi::ints_for &lt;generic_wide_int &lt;wi::unextended_tree&gt;,</span>
<span class="lineNum">    5650 </span>            :               wi::VAR_PRECISION&gt;::zero (const unextended &amp;x)
<span class="lineNum">    5651 </span><span class="lineCov">    2217926 : {</span>
<span class="lineNum">    5652 </span><span class="lineNoCov">          0 :   return build_zero_cst (TREE_TYPE (x.get_tree ()));</span>
<span class="lineNum">    5653 </span>            : }
<span class="lineNum">    5654 </span>            : 
<span class="lineNum">    5655 </span>            : namespace wi
<span class="lineNum">    5656 </span>            : {
<span class="lineNum">    5657 </span>            :   template &lt;typename T&gt;
<span class="lineNum">    5658 </span>            :   bool fits_to_boolean_p (const T &amp;x, const_tree);
<span class="lineNum">    5659 </span><span class="lineCov">    2217926 : </span>
<span class="lineNum">    5660 </span>            :   template &lt;typename T&gt;
<span class="lineNum">    5661 </span>            :   bool fits_to_tree_p (const T &amp;x, const_tree);
<span class="lineNum">    5662 </span>            : 
<span class="lineNum">    5663 </span>            :   wide_int min_value (const_tree);
<span class="lineNum">    5664 </span>            :   wide_int max_value (const_tree);
<span class="lineNum">    5665 </span>            :   wide_int from_mpz (const_tree, mpz_t, bool);
<span class="lineNum">    5666 </span><span class="lineCov">    4339470 : }</span>
<span class="lineNum">    5667 </span>            : 
<a name="5668"><span class="lineNum">    5668 </span><span class="lineCov">  354588459 : template &lt;typename T&gt;</span></a>
<span class="lineNum">    5669 </span>            : bool
<span class="lineNum">    5670 </span><span class="lineCov">          9 : wi::fits_to_boolean_p (const T &amp;x, const_tree type)</span>
<span class="lineNum">    5671 </span>            : {
<span class="lineNum">    5672 </span>            :   typedef typename poly_int_traits&lt;T&gt;::int_type int_type;
<span class="lineNum">    5673 </span><span class="lineCov">          9 :   return (known_eq (x, int_type (0))</span>
<span class="lineNum">    5674 </span><span class="lineCov">          9 :           || known_eq (x, int_type (TYPE_UNSIGNED (type) ? 1 : -1)));</span>
<span class="lineNum">    5675 </span>            : }
<span class="lineNum">    5676 </span><span class="lineCov">  354566532 : </span>
<a name="5677"><span class="lineNum">    5677 </span>            : template &lt;typename T&gt;</a>
<span class="lineNum">    5678 </span>            : bool
<span class="lineNum">    5679 </span><span class="lineCov">    1906627 : wi::fits_to_tree_p (const T &amp;x, const_tree type)</span>
<span class="lineNum">    5680 </span>            : {
<span class="lineNum">    5681 </span>            :   /* Non-standard boolean types can have arbitrary precision but various
<span class="lineNum">    5682 </span>            :      transformations assume that they can only take values 0 and +/-1.  */
<span class="lineNum">    5683 </span><span class="lineCov">    1906627 :   if (TREE_CODE (type) == BOOLEAN_TYPE)</span>
<span class="lineNum">    5684 </span><span class="lineCov">          9 :     return fits_to_boolean_p (x, type);</span>
<span class="lineNum">    5685 </span><span class="lineCov">  844188125 : </span>
<span class="lineNum">    5686 </span><span class="lineCov">    1906618 :   if (TYPE_UNSIGNED (type))</span>
<span class="lineNum">    5687 </span><span class="lineCov"> 1689017873 :     return known_eq (x, zext (x, TYPE_PRECISION (type)));</span>
<span class="lineNum">    5688 </span>            :   else
<span class="lineNum">    5689 </span><span class="lineCov">    3151812 :     return known_eq (x, sext (x, TYPE_PRECISION (type)));</span>
<span class="lineNum">    5690 </span>            : }
<span class="lineNum">    5691 </span>            : 
<span class="lineNum">    5692 </span><span class="lineNoCov">          0 : /* Produce the smallest number that is represented in TYPE.  The precision</span>
<a name="5693"><span class="lineNum">    5693 </span><span class="lineCov">    2045496 :    and sign are taken from TYPE.  */</span></a>
<span class="lineNum">    5694 </span>            : inline wide_int
<span class="lineNum">    5695 </span><span class="lineCov">    4617681 : wi::min_value (const_tree type)</span>
<span class="lineNum">    5696 </span>            : {
<span class="lineNum">    5697 </span><span class="lineCov">    4617681 :   return min_value (TYPE_PRECISION (type), TYPE_SIGN (type));</span>
<span class="lineNum">    5698 </span>            : }
<span class="lineNum">    5699 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    5700 </span>            : /* Produce the largest number that is represented in TYPE.  The precision
<a name="5701"><span class="lineNum">    5701 </span><span class="lineCov">    1022748 :    and sign are taken from TYPE.  */</span></a>
<span class="lineNum">    5702 </span><span class="lineNoCov">          0 : inline wide_int</span>
<span class="lineNum">    5703 </span><span class="lineCov">    4633678 : wi::max_value (const_tree type)</span>
<span class="lineNum">    5704 </span>            : {
<span class="lineNum">    5705 </span><span class="lineCov">    4633678 :   return max_value (TYPE_PRECISION (type), TYPE_SIGN (type));</span>
<span class="lineNum">    5706 </span>            : }
<span class="lineNum">    5707 </span>            : 
<span class="lineNum">    5708 </span>            : /* Return true if INTEGER_CST T1 is less than INTEGER_CST T2,
<span class="lineNum">    5709 </span>            :    extending both according to their respective TYPE_SIGNs.  */
<a name="5710"><span class="lineNum">    5710 </span>            : </a>
<span class="lineNum">    5711 </span>            : inline bool
<span class="lineNum">    5712 </span><span class="lineCov">  312269135 : tree_int_cst_lt (const_tree t1, const_tree t2)</span>
<span class="lineNum">    5713 </span>            : {
<span class="lineNum">    5714 </span><span class="lineCov">  312269135 :   return wi::to_widest (t1) &lt; wi::to_widest (t2);</span>
<span class="lineNum">    5715 </span>            : }
<span class="lineNum">    5716 </span>            : 
<span class="lineNum">    5717 </span><span class="lineNoCov">          0 : /* Return true if INTEGER_CST T1 is less than or equal to INTEGER_CST T2,</span>
<span class="lineNum">    5718 </span>            :    extending both according to their respective TYPE_SIGNs.  */
<a name="5719"><span class="lineNum">    5719 </span>            : </a>
<span class="lineNum">    5720 </span><span class="lineCov">    2946447 : inline bool</span>
<span class="lineNum">    5721 </span><span class="lineCov">       6689 : tree_int_cst_le (const_tree t1, const_tree t2)</span>
<span class="lineNum">    5722 </span>            : {
<span class="lineNum">    5723 </span><span class="lineCov">    2953136 :   return wi::to_widest (t1) &lt;= wi::to_widest (t2);</span>
<span class="lineNum">    5724 </span><span class="lineCov">    2946782 : }</span>
<span class="lineNum">    5725 </span>            : 
<span class="lineNum">    5726 </span><span class="lineCov">    2438378 : /* Returns -1 if T1 &lt; T2, 0 if T1 == T2, and 1 if T1 &gt; T2.  T1 and T2</span>
<span class="lineNum">    5727 </span>            :    are both INTEGER_CSTs and their values are extended according to their
<span class="lineNum">    5728 </span>            :    respective TYPE_SIGNs.  */
<a name="5729"><span class="lineNum">    5729 </span><span class="lineCov">    8006276 : </span></a>
<span class="lineNum">    5730 </span><span class="lineCov">    2438713 : inline int</span>
<span class="lineNum">    5731 </span><span class="lineCov">   27777185 : tree_int_cst_compare (const_tree t1, const_tree t2)</span>
<span class="lineNum">    5732 </span><span class="lineCov">     508069 : {</span>
<span class="lineNum">    5733 </span><span class="lineCov">   33345083 :   return wi::cmps (wi::to_widest (t1), wi::to_widest (t2));</span>
<span class="lineNum">    5734 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    5735 </span><span class="lineCov">     508069 : </span>
<span class="lineNum">    5736 </span><span class="lineCov">    6075967 : /* FIXME - These declarations belong in builtins.h, expr.h and emit-rtl.h,</span>
<span class="lineNum">    5737 </span><span class="lineCov">   10288359 :    but none of these files are allowed to be included from front ends.</span>
<span class="lineNum">    5738 </span>            :    They should be split in two. One suitable for the FEs, the other suitable
<span class="lineNum">    5739 </span><span class="lineCov">     826455 :    for the BE.  */</span>
<span class="lineNum">    5740 </span>            : 
<span class="lineNum">    5741 </span><span class="lineCov">  652254658 : /* Assign the RTX to declaration.  */</span>
<span class="lineNum">    5742 </span>            : extern void set_decl_rtl (tree, rtx);
<span class="lineNum">    5743 </span>            : extern bool complete_ctor_at_level_p (const_tree, HOST_WIDE_INT, const_tree);
<span class="lineNum">    5744 </span>            : 
<span class="lineNum">    5745 </span><span class="lineCov">  710722582 : /* Given an expression EXP that is a handled_component_p,</span>
<span class="lineNum">    5746 </span><span class="lineCov">    2438378 :    look for the ultimate containing object, which is returned and specify</span>
<span class="lineNum">    5747 </span><span class="lineCov">   58467924 :    the access position and size.  */</span>
<span class="lineNum">    5748 </span><span class="lineCov">  649816280 : extern tree get_inner_reference (tree, poly_int64_pod *, poly_int64_pod *,</span>
<span class="lineNum">    5749 </span><span class="lineCov">  543438047 :                                  tree *, machine_mode *, int *, int *, int *);</span>
<span class="lineNum">    5750 </span>            : 
<span class="lineNum">    5751 </span><span class="lineCov">  106378233 : extern tree build_personality_function (const char *);</span>
<span class="lineNum">    5752 </span>            : 
<span class="lineNum">    5753 </span><span class="lineCov">   58939523 : struct GTY(()) int_n_trees_t {</span>
<span class="lineNum">    5754 </span>            :   /* These parts are initialized at runtime */
<span class="lineNum">    5755 </span><span class="lineCov">   58939523 :   tree signed_type;</span>
<span class="lineNum">    5756 </span>            :   tree unsigned_type;
<span class="lineNum">    5757 </span><span class="lineNoCov">          0 : };</span>
<span class="lineNum">    5758 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    5759 </span>            : /* This is also in machmode.h */
<span class="lineNum">    5760 </span><span class="lineNoCov">          0 : extern bool int_n_enabled_p[NUM_INT_N_ENTS];</span>
<span class="lineNum">    5761 </span><span class="lineNoCov">          0 : extern GTY(()) struct int_n_trees_t int_n_trees[NUM_INT_N_ENTS];</span>
<span class="lineNum">    5762 </span><span class="lineCov">  122211987 : </span>
<span class="lineNum">    5763 </span><span class="lineNoCov">          0 : /* Like bit_position, but return as an integer.  It must be representable in</span>
<span class="lineNum">    5764 </span><span class="lineCov">  122211987 :    that way (since it could be a signed value, we don't have the</span>
<span class="lineNum">    5765 </span><span class="lineCov">  652254658 :    option of returning -1 like int_size_in_byte can.  */</span>
<a name="5766"><span class="lineNum">    5766 </span>            : </a>
<span class="lineNum">    5767 </span>            : inline HOST_WIDE_INT
<span class="lineNum">    5768 </span><span class="lineCov">     558069 : int_bit_position (const_tree field)</span>
<span class="lineNum">    5769 </span><span class="lineCov">  652254658 : {</span>
<span class="lineNum">    5770 </span><span class="lineCov">    2996447 :   return ((wi::to_offset (DECL_FIELD_OFFSET (field)) &lt;&lt; LOG2_BITS_PER_UNIT)</span>
<span class="lineNum">    5771 </span><span class="lineCov">    1161717 :           + wi::to_offset (DECL_FIELD_BIT_OFFSET (field))).to_shwi ();</span>
<span class="lineNum">    5772 </span><span class="lineCov">  649816280 : }</span>
<span class="lineNum">    5773 </span><span class="lineCov">  543483626 : </span>
<span class="lineNum">    5774 </span>            : /* Return true if it makes sense to consider alias set for a type T.  */
<a name="5775"><span class="lineNum">    5775 </span><span class="lineCov">  106378233 : </span></a>
<span class="lineNum">    5776 </span>            : inline bool
<span class="lineNum">    5777 </span><span class="lineCov">   17202229 : type_with_alias_set_p (const_tree t)</span>
<span class="lineNum">    5778 </span>            : {
<span class="lineNum">    5779 </span>            :   /* Function and method types are never accessed as memory locations.  */
<span class="lineNum">    5780 </span><span class="lineCov">   17202229 :   if (TREE_CODE (t) == FUNCTION_TYPE || TREE_CODE (t) == METHOD_TYPE)</span>
<span class="lineNum">    5781 </span><span class="lineCov">  356444377 :     return false;</span>
<span class="lineNum">    5782 </span>            : 
<span class="lineNum">    5783 </span><span class="lineCov">  373291221 :   if (COMPLETE_TYPE_P (t))</span>
<span class="lineNum">    5784 </span>            :     return true;
<span class="lineNum">    5785 </span>            : 
<span class="lineNum">    5786 </span>            :   /* Incomplete types can not be accessed in general except for arrays
<span class="lineNum">    5787 </span><span class="lineNoCov">          0 :      where we can fetch its element despite we have no array bounds.  */</span>
<span class="lineNum">    5788 </span><span class="lineCov">     584873 :   if (TREE_CODE (t) == ARRAY_TYPE &amp;&amp; COMPLETE_TYPE_P (TREE_TYPE (t)))</span>
<span class="lineNum">    5789 </span><span class="lineCov">       2976 :     return true;</span>
<span class="lineNum">    5790 </span>            : 
<span class="lineNum">    5791 </span>            :   return false;
<span class="lineNum">    5792 </span>            : }
<span class="lineNum">    5793 </span>            : 
<span class="lineNum">    5794 </span>            : extern location_t set_block (location_t loc, tree block);
<span class="lineNum">    5795 </span>            : 
<span class="lineNum">    5796 </span><span class="lineCov">     162989 : extern void gt_ggc_mx (tree &amp;);</span>
<span class="lineNum">    5797 </span>            : extern void gt_pch_nx (tree &amp;);
<span class="lineNum">    5798 </span><span class="lineCov">   55996060 : extern void gt_pch_nx (tree &amp;, gt_pointer_operator, void *);</span>
<span class="lineNum">    5799 </span>            : 
<span class="lineNum">    5800 </span><span class="lineCov">   55833071 : extern bool nonnull_arg_p (const_tree);</span>
<span class="lineNum">    5801 </span>            : extern bool default_is_empty_record (const_tree);
<span class="lineNum">    5802 </span>            : extern HOST_WIDE_INT arg_int_size_in_bytes (const_tree);
<span class="lineNum">    5803 </span>            : extern tree arg_size_in_bytes (const_tree);
<span class="lineNum">    5804 </span>            : extern bool expr_type_first_operand_type_p (tree_code);
<span class="lineNum">    5805 </span>            : 
<span class="lineNum">    5806 </span><span class="lineCov">      52616 : extern location_t</span>
<span class="lineNum">    5807 </span>            : set_source_range (tree expr, location_t start, location_t finish);
<span class="lineNum">    5808 </span><span class="lineCov">      52616 : </span>
<span class="lineNum">    5809 </span>            : extern location_t
<span class="lineNum">    5810 </span>            : set_source_range (tree expr, source_range src_range);
<span class="lineNum">    5811 </span>            : 
<a name="5812"><span class="lineNum">    5812 </span>            : /* Return true if it makes sense to promote/demote from_type to to_type. */</a>
<span class="lineNum">    5813 </span>            : inline bool
<span class="lineNum">    5814 </span><span class="lineCov">     167157 : desired_pro_or_demotion_p (const_tree to_type, const_tree from_type)</span>
<span class="lineNum">    5815 </span>            : {
<span class="lineNum">    5816 </span><span class="lineCov">     167157 :   unsigned int to_type_precision = TYPE_PRECISION (to_type);</span>
<span class="lineNum">    5817 </span>            : 
<span class="lineNum">    5818 </span><span class="lineCov">   21734966 :   /* OK to promote if to_type is no bigger than word_mode. */</span>
<span class="lineNum">    5819 </span><span class="lineCov">     334314 :   if (to_type_precision &lt;= GET_MODE_PRECISION (word_mode))</span>
<span class="lineNum">    5820 </span><span class="lineCov">   21734966 :     return true;</span>
<span class="lineNum">    5821 </span><span class="lineCov">   43469932 : </span>
<span class="lineNum">    5822 </span>            :   /* Otherwise, allow only if narrowing or same precision conversions. */
<span class="lineNum">    5823 </span><span class="lineCov">      15566 :   return to_type_precision &lt;= TYPE_PRECISION (from_type);</span>
<span class="lineNum">    5824 </span>            : }
<span class="lineNum">    5825 </span>            : 
<span class="lineNum">    5826 </span>            : /* Pointer type used to declare builtins before we have seen its real
<span class="lineNum">    5827 </span>            :    declaration.  */
<span class="lineNum">    5828 </span>            : struct builtin_structptr_type
<span class="lineNum">    5829 </span>            : {
<span class="lineNum">    5830 </span>            :   tree&amp; node;
<span class="lineNum">    5831 </span>            :   tree&amp; base;
<span class="lineNum">    5832 </span>            :   const char *str;
<span class="lineNum">    5833 </span>            : };
<span class="lineNum">    5834 </span>            : extern const builtin_structptr_type builtin_structptr_types[6];
<span class="lineNum">    5835 </span>            : 
<span class="lineNum">    5836 </span>            : /* Return true if type T has the same precision as its underlying mode.  */
<a name="5837"><span class="lineNum">    5837 </span>            : </a>
<span class="lineNum">    5838 </span>            : inline bool
<span class="lineNum">    5839 </span><span class="lineCov">   29081639 : type_has_mode_precision_p (const_tree t)</span>
<span class="lineNum">    5840 </span>            : {
<span class="lineNum">    5841 </span><span class="lineCov">   29081639 :   return known_eq (TYPE_PRECISION (t), GET_MODE_PRECISION (TYPE_MODE (t)));</span>
<span class="lineNum">    5842 </span>            : }
<span class="lineNum">    5843 </span>            : 
<span class="lineNum">    5844 </span>            : /* Return true if a FUNCTION_DECL NODE is a GCC built-in function.
<span class="lineNum">    5845 </span>            : 
<span class="lineNum">    5846 </span>            :    Note that it is different from the DECL_IS_BUILTIN accessor.  For
<span class="lineNum">    5847 </span>            :    instance, user declared prototypes of C library functions are not
<span class="lineNum">    5848 </span>            :    DECL_IS_BUILTIN but may be DECL_BUILT_IN.  */
<a name="5849"><span class="lineNum">    5849 </span>            : </a>
<span class="lineNum">    5850 </span>            : inline bool
<span class="lineNum">    5851 </span><span class="lineCov"> 1420310422 : fndecl_built_in_p (const_tree node)</span>
<span class="lineNum">    5852 </span>            : {
<span class="lineNum">    5853 </span><span class="lineCov"> 1420310422 :   return (DECL_BUILT_IN_CLASS (node) != NOT_BUILT_IN);</span>
<span class="lineNum">    5854 </span><span class="lineCov">     169337 : }</span>
<span class="lineNum">    5855 </span>            : 
<span class="lineNum">    5856 </span><span class="lineCov">     169337 : /* Return true if a FUNCTION_DECL NODE is a GCC built-in function</span>
<span class="lineNum">    5857 </span><span class="lineCov">     338674 :    of class KLASS.  */</span>
<a name="5858"><span class="lineNum">    5858 </span>            : </a>
<span class="lineNum">    5859 </span>            : inline bool
<span class="lineNum">    5860 </span><span class="lineCov"> 1203739925 : fndecl_built_in_p (const_tree node, built_in_class klass)</span>
<span class="lineNum">    5861 </span>            : {
<span class="lineNum">    5862 </span><span class="lineCov"> 1203739925 :   return (fndecl_built_in_p (node) &amp;&amp; DECL_BUILT_IN_CLASS (node) == klass);</span>
<span class="lineNum">    5863 </span><span class="lineCov">   18963471 : }</span>
<span class="lineNum">    5864 </span>            : 
<span class="lineNum">    5865 </span>            : /* Return true if a FUNCTION_DECL NODE is a GCC built-in function
<span class="lineNum">    5866 </span><span class="lineCov">   18963471 :    of class KLASS with name equal to NAME.  */</span>
<a name="5867"><span class="lineNum">    5867 </span>            : </a>
<span class="lineNum">    5868 </span>            : inline bool
<span class="lineNum">    5869 </span><span class="lineCov">   53957309 : fndecl_built_in_p (const_tree node, int name, built_in_class klass)</span>
<span class="lineNum">    5870 </span>            : {
<span class="lineNum">    5871 </span><span class="lineCov">   35062668 :   return (fndecl_built_in_p (node, klass) &amp;&amp; DECL_FUNCTION_CODE (node) == name);</span>
<span class="lineNum">    5872 </span>            : }
<span class="lineNum">    5873 </span>            : 
<span class="lineNum">    5874 </span><span class="lineCov">     626248 : /* Return true if a FUNCTION_DECL NODE is a GCC built-in function</span>
<span class="lineNum">    5875 </span><span class="lineCov">      18110 :    of BUILT_IN_NORMAL class with name equal to NAME.  */</span>
<a name="5876"><span class="lineNum">    5876 </span>            : </a>
<span class="lineNum">    5877 </span>            : inline bool
<span class="lineNum">    5878 </span><span class="lineCov">  495831835 : fndecl_built_in_p (const_tree node, built_in_function name)</span>
<span class="lineNum">    5879 </span>            : {
<span class="lineNum">    5880 </span><span class="lineCov">  495831835 :   return (fndecl_built_in_p (node, BUILT_IN_NORMAL)</span>
<span class="lineNum">    5881 </span><span class="lineCov">  495831835 :           &amp;&amp; DECL_FUNCTION_CODE (node) == name);</span>
<span class="lineNum">    5882 </span>            : }
<span class="lineNum">    5883 </span>            : 
<span class="lineNum">    5884 </span>            : #endif  /* GCC_TREE_H  */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.0</a></td></tr>
  </table>
  <br>
<h3>LCOV profile is generated on x86_64 machine using following configure options: configure --disable-bootstrap --enable-coverage=opt --enable-languages=c,c++,fortran,go,jit,lto --enable-host-shared. GCC test suite is run with the built compiler.</h3></body></html>
