<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - gcc.info - gcc/tree-eh.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">gcc</a> - tree-eh.c<span style="font-size: 80%;"> (source / <a href="tree-eh.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">gcc.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">1933</td>
            <td class="headerCovTableEntry">2162</td>
            <td class="headerCovTableEntryMed">89.4 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-09-22 10:58:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">98</td>
            <td class="headerCovTableEntry">105</td>
            <td class="headerCovTableEntryHi">93.3 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Exception handling semantics and decomposition for trees.</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 2003-2018 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            : This file is part of GCC.
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : GCC is free software; you can redistribute it and/or modify
<span class="lineNum">       7 </span>            : it under the terms of the GNU General Public License as published by
<span class="lineNum">       8 </span>            : the Free Software Foundation; either version 3, or (at your option)
<span class="lineNum">       9 </span>            : any later version.
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : GCC is distributed in the hope that it will be useful,
<span class="lineNum">      12 </span>            : but WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      13 </span>            : MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<span class="lineNum">      14 </span>            : GNU General Public License for more details.
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : You should have received a copy of the GNU General Public License
<span class="lineNum">      17 </span>            : along with GCC; see the file COPYING3.  If not see
<span class="lineNum">      18 </span>            : &lt;http://www.gnu.org/licenses/&gt;.  */
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : #include &quot;config.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;system.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;coretypes.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;backend.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;rtl.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;tree.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;gimple.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;cfghooks.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;tree-pass.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;ssa.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;cgraph.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;diagnostic-core.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;fold-const.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;calls.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;except.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;cfganal.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;cfgcleanup.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;tree-eh.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;gimple-iterator.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;tree-cfg.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;tree-into-ssa.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;tree-ssa.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;tree-inline.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;langhooks.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;cfgloop.h&quot;
<span class="lineNum">      45 </span>            : #include &quot;gimple-low.h&quot;
<span class="lineNum">      46 </span>            : #include &quot;stringpool.h&quot;
<span class="lineNum">      47 </span>            : #include &quot;attribs.h&quot;
<span class="lineNum">      48 </span>            : #include &quot;asan.h&quot;
<span class="lineNum">      49 </span>            : #include &quot;gimplify.h&quot;
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : /* In some instances a tree and a gimple need to be stored in a same table,
<span class="lineNum">      52 </span>            :    i.e. in hash tables. This is a structure to do this. */
<span class="lineNum">      53 </span>            : typedef union {tree *tp; tree t; gimple *g;} treemple;
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            : /* Misc functions used in this file.  */
<span class="lineNum">      56 </span>            : 
<span class="lineNum">      57 </span>            : /* Remember and lookup EH landing pad data for arbitrary statements.
<span class="lineNum">      58 </span>            :    Really this means any statement that could_throw_p.  We could
<span class="lineNum">      59 </span>            :    stuff this information into the stmt_ann data structure, but:
<span class="lineNum">      60 </span>            : 
<span class="lineNum">      61 </span>            :    (1) We absolutely rely on this information being kept until
<span class="lineNum">      62 </span>            :    we get to rtl.  Once we're done with lowering here, if we lose
<span class="lineNum">      63 </span>            :    the information there's no way to recover it!
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span>            :    (2) There are many more statements that *cannot* throw as
<span class="lineNum">      66 </span>            :    compared to those that can.  We should be saving some amount
<span class="lineNum">      67 </span>            :    of space by only allocating memory for those that can throw.  */
<span class="lineNum">      68 </span>            : 
<span class="lineNum">      69 </span>            : /* Add statement T in function IFUN to landing pad NUM.  */
<a name="70"><span class="lineNum">      70 </span>            : </a>
<span class="lineNum">      71 </span>            : static void
<span class="lineNum">      72 </span><span class="lineCov">    3683756 : add_stmt_to_eh_lp_fn (struct function *ifun, gimple *t, int num)</span>
<span class="lineNum">      73 </span>            : {
<span class="lineNum">      74 </span><span class="lineCov">    3683756 :   gcc_assert (num != 0);</span>
<span class="lineNum">      75 </span>            : 
<span class="lineNum">      76 </span><span class="lineCov">    3683756 :   if (!get_eh_throw_stmt_table (ifun))</span>
<span class="lineNum">      77 </span><span class="lineCov">     236211 :     set_eh_throw_stmt_table (ifun, hash_map&lt;gimple *, int&gt;::create_ggc (31));</span>
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span><span class="lineCov">    3683756 :   gcc_assert (!get_eh_throw_stmt_table (ifun)-&gt;put (t, num));</span>
<span class="lineNum">      80 </span><span class="lineCov">    3683756 : }</span>
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span>            : /* Add statement T in the current function (cfun) to EH landing pad NUM.  */
<a name="83"><span class="lineNum">      83 </span>            : </a>
<span class="lineNum">      84 </span>            : void
<span class="lineNum">      85 </span><span class="lineCov">    1325393 : add_stmt_to_eh_lp (gimple *t, int num)</span>
<span class="lineNum">      86 </span>            : {
<span class="lineNum">      87 </span><span class="lineCov">    1325393 :   add_stmt_to_eh_lp_fn (cfun, t, num);</span>
<span class="lineNum">      88 </span><span class="lineCov">    1325393 : }</span>
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span>            : /* Add statement T to the single EH landing pad in REGION.  */
<a name="91"><span class="lineNum">      91 </span>            : </a>
<span class="lineNum">      92 </span>            : static void
<span class="lineNum">      93 </span><span class="lineCov">    1903244 : record_stmt_eh_region (eh_region region, gimple *t)</span>
<span class="lineNum">      94 </span>            : {
<span class="lineNum">      95 </span><span class="lineCov">    1903244 :   if (region == NULL)</span>
<span class="lineNum">      96 </span>            :     return;
<span class="lineNum">      97 </span><span class="lineCov">    1903244 :   if (region-&gt;type == ERT_MUST_NOT_THROW)</span>
<span class="lineNum">      98 </span><span class="lineCov">      71852 :     add_stmt_to_eh_lp_fn (cfun, t, -region-&gt;index);</span>
<span class="lineNum">      99 </span>            :   else
<span class="lineNum">     100 </span>            :     {
<span class="lineNum">     101 </span><span class="lineCov">    1831392 :       eh_landing_pad lp = region-&gt;landing_pads;</span>
<span class="lineNum">     102 </span><span class="lineCov">    1831392 :       if (lp == NULL)</span>
<span class="lineNum">     103 </span><span class="lineCov">     482784 :         lp = gen_eh_landing_pad (region);</span>
<span class="lineNum">     104 </span>            :       else
<span class="lineNum">     105 </span><span class="lineCov">    1348608 :         gcc_assert (lp-&gt;next_lp == NULL);</span>
<span class="lineNum">     106 </span><span class="lineCov">    1831392 :       add_stmt_to_eh_lp_fn (cfun, t, lp-&gt;index);</span>
<span class="lineNum">     107 </span>            :     }
<span class="lineNum">     108 </span>            : }
<span class="lineNum">     109 </span>            : 
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span>            : /* Remove statement T in function IFUN from its EH landing pad.  */
<a name="112"><span class="lineNum">     112 </span>            : </a>
<span class="lineNum">     113 </span>            : bool
<span class="lineNum">     114 </span><span class="lineCov">  359882010 : remove_stmt_from_eh_lp_fn (struct function *ifun, gimple *t)</span>
<span class="lineNum">     115 </span>            : {
<span class="lineNum">     116 </span><span class="lineCov">  359882010 :   if (!get_eh_throw_stmt_table (ifun))</span>
<span class="lineNum">     117 </span>            :     return false;
<span class="lineNum">     118 </span>            : 
<span class="lineNum">     119 </span><span class="lineCov">  171983338 :   if (!get_eh_throw_stmt_table (ifun)-&gt;get (t))</span>
<span class="lineNum">     120 </span>            :     return false;
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span><span class="lineCov">    3118162 :   get_eh_throw_stmt_table (ifun)-&gt;remove (t);</span>
<span class="lineNum">     123 </span><span class="lineCov">    3118162 :       return true;</span>
<span class="lineNum">     124 </span>            : }
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span>            : /* Remove statement T in the current function (cfun) from its
<span class="lineNum">     128 </span>            :    EH landing pad.  */
<a name="129"><span class="lineNum">     129 </span>            : </a>
<span class="lineNum">     130 </span>            : bool
<span class="lineNum">     131 </span><span class="lineCov">   58671526 : remove_stmt_from_eh_lp (gimple *t)</span>
<span class="lineNum">     132 </span>            : {
<span class="lineNum">     133 </span><span class="lineCov">   58671526 :   return remove_stmt_from_eh_lp_fn (cfun, t);</span>
<span class="lineNum">     134 </span>            : }
<span class="lineNum">     135 </span>            : 
<span class="lineNum">     136 </span>            : /* Determine if statement T is inside an EH region in function IFUN.
<span class="lineNum">     137 </span>            :    Positive numbers indicate a landing pad index; negative numbers
<span class="lineNum">     138 </span>            :    indicate a MUST_NOT_THROW region index; zero indicates that the
<span class="lineNum">     139 </span>            :    statement is not recorded in the region table.  */
<a name="140"><span class="lineNum">     140 </span>            : </a>
<span class="lineNum">     141 </span>            : int
<span class="lineNum">     142 </span><span class="lineCov"> 7974300836 : lookup_stmt_eh_lp_fn (struct function *ifun, gimple *t)</span>
<span class="lineNum">     143 </span>            : {
<span class="lineNum">     144 </span><span class="lineCov"> 7974300836 :   if (ifun-&gt;eh-&gt;throw_stmt_table == NULL)</span>
<span class="lineNum">     145 </span>            :     return 0;
<span class="lineNum">     146 </span>            : 
<span class="lineNum">     147 </span><span class="lineCov"> 4428634466 :   int *lp_nr = ifun-&gt;eh-&gt;throw_stmt_table-&gt;get (t);</span>
<span class="lineNum">     148 </span><span class="lineCov">  417179803 :   return lp_nr ? *lp_nr : 0;</span>
<span class="lineNum">     149 </span>            : }
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span>            : /* Likewise, but always use the current function.  */
<a name="152"><span class="lineNum">     152 </span>            : </a>
<span class="lineNum">     153 </span>            : int
<span class="lineNum">     154 </span><span class="lineCov"> 7968447507 : lookup_stmt_eh_lp (gimple *t)</span>
<span class="lineNum">     155 </span>            : {
<span class="lineNum">     156 </span>            :   /* We can get called from initialized data when -fnon-call-exceptions
<span class="lineNum">     157 </span>            :      is on; prevent crash.  */
<span class="lineNum">     158 </span><span class="lineCov"> 7968447507 :   if (!cfun)</span>
<span class="lineNum">     159 </span>            :     return 0;
<span class="lineNum">     160 </span><span class="lineCov"> 7968344943 :   return lookup_stmt_eh_lp_fn (cfun, t);</span>
<span class="lineNum">     161 </span>            : }
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span>            : /* First pass of EH node decomposition.  Build up a tree of GIMPLE_TRY_FINALLY
<span class="lineNum">     164 </span>            :    nodes and LABEL_DECL nodes.  We will use this during the second phase to
<span class="lineNum">     165 </span>            :    determine if a goto leaves the body of a TRY_FINALLY_EXPR node.  */
<span class="lineNum">     166 </span>            : 
<span class="lineNum">     167 </span>            : struct finally_tree_node
<span class="lineNum">     168 </span>            : {
<span class="lineNum">     169 </span>            :   /* When storing a GIMPLE_TRY, we have to record a gimple.  However
<span class="lineNum">     170 </span>            :      when deciding whether a GOTO to a certain LABEL_DECL (which is a
<span class="lineNum">     171 </span>            :      tree) leaves the TRY block, its necessary to record a tree in
<span class="lineNum">     172 </span>            :      this field.  Thus a treemple is used. */
<span class="lineNum">     173 </span>            :   treemple child;
<span class="lineNum">     174 </span>            :   gtry *parent;
<span class="lineNum">     175 </span>            : };
<span class="lineNum">     176 </span>            : 
<span class="lineNum">     177 </span>            : /* Hashtable helpers.  */
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span>            : struct finally_tree_hasher : free_ptr_hash &lt;finally_tree_node&gt;
<span class="lineNum">     180 </span>            : {
<span class="lineNum">     181 </span>            :   static inline hashval_t hash (const finally_tree_node *);
<span class="lineNum">     182 </span>            :   static inline bool equal (const finally_tree_node *,
<span class="lineNum">     183 </span>            :                             const finally_tree_node *);
<span class="lineNum">     184 </span>            : };
<a name="185"><span class="lineNum">     185 </span>            : </a>
<span class="lineNum">     186 </span>            : inline hashval_t
<span class="lineNum">     187 </span><span class="lineNoCov">          0 : finally_tree_hasher::hash (const finally_tree_node *v)</span>
<span class="lineNum">     188 </span>            : {
<span class="lineNum">     189 </span><span class="lineCov">   23395417 :   return (intptr_t)v-&gt;child.t &gt;&gt; 4;</span>
<span class="lineNum">     190 </span>            : }
<a name="191"><span class="lineNum">     191 </span>            : </a>
<span class="lineNum">     192 </span>            : inline bool
<span class="lineNum">     193 </span><span class="lineNoCov">          0 : finally_tree_hasher::equal (const finally_tree_node *v,</span>
<span class="lineNum">     194 </span>            :                             const finally_tree_node *c)
<span class="lineNum">     195 </span>            : {
<span class="lineNum">     196 </span><span class="lineCov">   13933237 :   return v-&gt;child.t == c-&gt;child.t;</span>
<span class="lineNum">     197 </span>            : }
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span>            : /* Note that this table is *not* marked GTY.  It is short-lived.  */
<span class="lineNum">     200 </span>            : static hash_table&lt;finally_tree_hasher&gt; *finally_tree;
<a name="201"><span class="lineNum">     201 </span>            : </a>
<span class="lineNum">     202 </span>            : static void
<span class="lineNum">     203 </span><span class="lineCov">   10344170 : record_in_finally_tree (treemple child, gtry *parent)</span>
<span class="lineNum">     204 </span>            : {
<span class="lineNum">     205 </span><span class="lineCov">   10344170 :   struct finally_tree_node *n;</span>
<span class="lineNum">     206 </span><span class="lineCov">   10344170 :   finally_tree_node **slot;</span>
<span class="lineNum">     207 </span>            : 
<span class="lineNum">     208 </span><span class="lineCov">   10344170 :   n = XNEW (struct finally_tree_node);</span>
<span class="lineNum">     209 </span><span class="lineCov">   10344170 :   n-&gt;child = child;</span>
<span class="lineNum">     210 </span><span class="lineCov">   10344170 :   n-&gt;parent = parent;</span>
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span><span class="lineCov">   10344170 :   slot = finally_tree-&gt;find_slot (n, INSERT);</span>
<span class="lineNum">     213 </span><span class="lineCov">   10344170 :   gcc_assert (!*slot);</span>
<span class="lineNum">     214 </span><span class="lineCov">   10344170 :   *slot = n;</span>
<span class="lineNum">     215 </span><span class="lineCov">   10344170 : }</span>
<span class="lineNum">     216 </span>            : 
<span class="lineNum">     217 </span>            : static void
<span class="lineNum">     218 </span>            : collect_finally_tree (gimple *stmt, gtry *region);
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span>            : /* Go through the gimple sequence.  Works with collect_finally_tree to
<span class="lineNum">     221 </span>            :    record all GIMPLE_LABEL and GIMPLE_TRY statements. */
<a name="222"><span class="lineNum">     222 </span>            : </a>
<span class="lineNum">     223 </span>            : static void
<span class="lineNum">     224 </span><span class="lineCov">    2882534 : collect_finally_tree_1 (gimple_seq seq, gtry *region)</span>
<span class="lineNum">     225 </span>            : {
<span class="lineNum">     226 </span><span class="lineCov">    5068981 :   gimple_stmt_iterator gsi;</span>
<span class="lineNum">     227 </span>            : 
<span class="lineNum">     228 </span><span class="lineCov">   58322615 :   for (gsi = gsi_start (seq); !gsi_end_p (gsi); gsi_next (&amp;gsi))</span>
<span class="lineNum">     229 </span><span class="lineCov">  100742200 :     collect_finally_tree (gsi_stmt (gsi), region);</span>
<span class="lineNum">     230 </span><span class="lineCov">    2882534 : }</span>
<a name="231"><span class="lineNum">     231 </span>            : </a>
<span class="lineNum">     232 </span>            : static void
<span class="lineNum">     233 </span><span class="lineCov">   50371100 : collect_finally_tree (gimple *stmt, gtry *region)</span>
<span class="lineNum">     234 </span>            : {
<span class="lineNum">     235 </span><span class="lineCov">   50371100 :   treemple temp;</span>
<span class="lineNum">     236 </span>            : 
<span class="lineNum">     237 </span><span class="lineCov">  100742200 :   switch (gimple_code (stmt))</span>
<span class="lineNum">     238 </span>            :     {
<span class="lineNum">     239 </span><span class="lineCov">    9405445 :     case GIMPLE_LABEL:</span>
<span class="lineNum">     240 </span><span class="lineCov">    9405445 :       temp.t = gimple_label_label (as_a &lt;glabel *&gt; (stmt));</span>
<span class="lineNum">     241 </span><span class="lineCov">    9405445 :       record_in_finally_tree (temp, region);</span>
<span class="lineNum">     242 </span><span class="lineCov">    9405445 :       break;</span>
<span class="lineNum">     243 </span>            : 
<span class="lineNum">     244 </span><span class="lineCov">    1413816 :     case GIMPLE_TRY:</span>
<span class="lineNum">     245 </span><span class="lineCov">    1413816 :       if (gimple_try_kind (stmt) == GIMPLE_TRY_FINALLY)</span>
<span class="lineNum">     246 </span>            :         {
<span class="lineNum">     247 </span><span class="lineCov">     905573 :           temp.g = stmt;</span>
<span class="lineNum">     248 </span><span class="lineCov">     905573 :           record_in_finally_tree (temp, region);</span>
<span class="lineNum">     249 </span><span class="lineCov">     905573 :           collect_finally_tree_1 (gimple_try_eval (stmt),</span>
<span class="lineNum">     250 </span>            :                                   as_a &lt;gtry *&gt; (stmt));
<span class="lineNum">     251 </span><span class="lineCov">     905573 :           collect_finally_tree_1 (gimple_try_cleanup (stmt), region);</span>
<span class="lineNum">     252 </span>            :         }
<span class="lineNum">     253 </span><span class="lineCov">     508243 :       else if (gimple_try_kind (stmt) == GIMPLE_TRY_CATCH)</span>
<span class="lineNum">     254 </span>            :         {
<span class="lineNum">     255 </span><span class="lineCov">     508243 :           collect_finally_tree_1 (gimple_try_eval (stmt), region);</span>
<span class="lineNum">     256 </span><span class="lineCov">     508243 :           collect_finally_tree_1 (gimple_try_cleanup (stmt), region);</span>
<span class="lineNum">     257 </span>            :         }
<span class="lineNum">     258 </span>            :       break;
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span><span class="lineCov">      45826 :     case GIMPLE_CATCH:</span>
<span class="lineNum">     261 </span><span class="lineCov">      45826 :       collect_finally_tree_1 (gimple_catch_handler (</span>
<span class="lineNum">     262 </span>            :                                  as_a &lt;gcatch *&gt; (stmt)),
<span class="lineNum">     263 </span>            :                               region);
<span class="lineNum">     264 </span><span class="lineCov">      45826 :       break;</span>
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span><span class="lineCov">       8070 :     case GIMPLE_EH_FILTER:</span>
<span class="lineNum">     267 </span><span class="lineCov">       8070 :       collect_finally_tree_1 (gimple_eh_filter_failure (stmt), region);</span>
<span class="lineNum">     268 </span><span class="lineCov">       8070 :       break;</span>
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span><span class="lineCov">        503 :     case GIMPLE_EH_ELSE:</span>
<span class="lineNum">     271 </span><span class="lineCov">        503 :       {</span>
<span class="lineNum">     272 </span><span class="lineCov">        503 :         geh_else *eh_else_stmt = as_a &lt;geh_else *&gt; (stmt);</span>
<span class="lineNum">     273 </span><span class="lineCov">       1006 :         collect_finally_tree_1 (gimple_eh_else_n_body (eh_else_stmt), region);</span>
<span class="lineNum">     274 </span><span class="lineCov">        503 :         collect_finally_tree_1 (gimple_eh_else_e_body (eh_else_stmt), region);</span>
<span class="lineNum">     275 </span>            :       }
<span class="lineNum">     276 </span><span class="lineCov">        503 :       break;</span>
<span class="lineNum">     277 </span>            : 
<span class="lineNum">     278 </span>            :     default:
<span class="lineNum">     279 </span>            :       /* A type, a decl, or some kind of statement that we're not
<span class="lineNum">     280 </span>            :          interested in.  Don't walk them.  */
<span class="lineNum">     281 </span>            :       break;
<span class="lineNum">     282 </span>            :     }
<span class="lineNum">     283 </span><span class="lineCov">   50371100 : }</span>
<span class="lineNum">     284 </span>            : 
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span>            : /* Use the finally tree to determine if a jump from START to TARGET
<span class="lineNum">     287 </span>            :    would leave the try_finally node that START lives in.  */
<a name="288"><span class="lineNum">     288 </span>            : </a>
<span class="lineNum">     289 </span>            : static bool
<span class="lineNum">     290 </span><span class="lineCov">    4974559 : outside_finally_tree (treemple start, gimple *target)</span>
<span class="lineNum">     291 </span>            : {
<span class="lineNum">     292 </span><span class="lineCov">    5372459 :   struct finally_tree_node n, *p;</span>
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span><span class="lineCov">    5372459 :   do</span>
<span class="lineNum">     295 </span>            :     {
<span class="lineNum">     296 </span><span class="lineCov">    5372459 :       n.child = start;</span>
<span class="lineNum">     297 </span><span class="lineCov">    5372459 :       p = finally_tree-&gt;find (&amp;n);</span>
<span class="lineNum">     298 </span><span class="lineCov">    5372459 :       if (!p)</span>
<span class="lineNum">     299 </span>            :         return true;
<span class="lineNum">     300 </span><span class="lineCov">    4993056 :       start.g = p-&gt;parent;</span>
<span class="lineNum">     301 </span>            :     }
<span class="lineNum">     302 </span><span class="lineCov">    4993056 :   while (start.g != target);</span>
<span class="lineNum">     303 </span>            : 
<span class="lineNum">     304 </span>            :   return false;
<span class="lineNum">     305 </span>            : }
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span>            : /* Second pass of EH node decomposition.  Actually transform the GIMPLE_TRY
<span class="lineNum">     308 </span>            :    nodes into a set of gotos, magic labels, and eh regions.
<span class="lineNum">     309 </span>            :    The eh region creation is straight-forward, but frobbing all the gotos
<span class="lineNum">     310 </span>            :    and such into shape isn't.  */
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span>            : /* The sequence into which we record all EH stuff.  This will be
<span class="lineNum">     313 </span>            :    placed at the end of the function when we're all done.  */
<span class="lineNum">     314 </span>            : static gimple_seq eh_seq;
<span class="lineNum">     315 </span>            : 
<span class="lineNum">     316 </span>            : /* Record whether an EH region contains something that can throw,
<span class="lineNum">     317 </span>            :    indexed by EH region number.  */
<span class="lineNum">     318 </span>            : static bitmap eh_region_may_contain_throw_map;
<span class="lineNum">     319 </span>            : 
<span class="lineNum">     320 </span>            : /* The GOTO_QUEUE is an array of GIMPLE_GOTO and GIMPLE_RETURN
<span class="lineNum">     321 </span>            :    statements that are seen to escape this GIMPLE_TRY_FINALLY node.
<span class="lineNum">     322 </span>            :    The idea is to record a gimple statement for everything except for
<span class="lineNum">     323 </span>            :    the conditionals, which get their labels recorded. Since labels are
<span class="lineNum">     324 </span>            :    of type 'tree', we need this node to store both gimple and tree
<span class="lineNum">     325 </span>            :    objects.  REPL_STMT is the sequence used to replace the goto/return
<span class="lineNum">     326 </span>            :    statement.  CONT_STMT is used to store the statement that allows
<span class="lineNum">     327 </span>            :    the return/goto to jump to the original destination. */
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span>            : struct goto_queue_node
<span class="lineNum">     330 </span>            : {
<span class="lineNum">     331 </span>            :   treemple stmt;
<span class="lineNum">     332 </span>            :   location_t location;
<span class="lineNum">     333 </span>            :   gimple_seq repl_stmt;
<span class="lineNum">     334 </span>            :   gimple *cont_stmt;
<span class="lineNum">     335 </span>            :   int index;
<span class="lineNum">     336 </span>            :   /* This is used when index &gt;= 0 to indicate that stmt is a label (as
<span class="lineNum">     337 </span>            :      opposed to a goto stmt).  */
<span class="lineNum">     338 </span>            :   int is_label;
<span class="lineNum">     339 </span>            : };
<span class="lineNum">     340 </span>            : 
<span class="lineNum">     341 </span>            : /* State of the world while lowering.  */
<span class="lineNum">     342 </span>            : 
<span class="lineNum">     343 </span>            : struct leh_state
<span class="lineNum">     344 </span>            : {
<span class="lineNum">     345 </span>            :   /* What's &quot;current&quot; while constructing the eh region tree.  These
<span class="lineNum">     346 </span>            :      correspond to variables of the same name in cfun-&gt;eh, which we
<span class="lineNum">     347 </span>            :      don't have easy access to.  */
<span class="lineNum">     348 </span>            :   eh_region cur_region;
<span class="lineNum">     349 </span>            : 
<span class="lineNum">     350 </span>            :   /* What's &quot;current&quot; for the purposes of __builtin_eh_pointer.  For
<span class="lineNum">     351 </span>            :      a CATCH, this is the associated TRY.  For an EH_FILTER, this is
<span class="lineNum">     352 </span>            :      the associated ALLOWED_EXCEPTIONS, etc.  */
<span class="lineNum">     353 </span>            :   eh_region ehp_region;
<span class="lineNum">     354 </span>            : 
<span class="lineNum">     355 </span>            :   /* Processing of TRY_FINALLY requires a bit more state.  This is
<span class="lineNum">     356 </span>            :      split out into a separate structure so that we don't have to
<span class="lineNum">     357 </span>            :      copy so much when processing other nodes.  */
<span class="lineNum">     358 </span>            :   struct leh_tf_state *tf;
<span class="lineNum">     359 </span>            : };
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span>            : struct leh_tf_state
<span class="lineNum">     362 </span>            : {
<span class="lineNum">     363 </span>            :   /* Pointer to the GIMPLE_TRY_FINALLY node under discussion.  The
<span class="lineNum">     364 </span>            :      try_finally_expr is the original GIMPLE_TRY_FINALLY.  We need to retain
<span class="lineNum">     365 </span>            :      this so that outside_finally_tree can reliably reference the tree used
<span class="lineNum">     366 </span>            :      in the collect_finally_tree data structures.  */
<span class="lineNum">     367 </span>            :   gtry *try_finally_expr;
<span class="lineNum">     368 </span>            :   gtry *top_p;
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span>            :   /* While lowering a top_p usually it is expanded into multiple statements,
<span class="lineNum">     371 </span>            :      thus we need the following field to store them. */
<span class="lineNum">     372 </span>            :   gimple_seq top_p_seq;
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span>            :   /* The state outside this try_finally node.  */
<span class="lineNum">     375 </span>            :   struct leh_state *outer;
<span class="lineNum">     376 </span>            : 
<span class="lineNum">     377 </span>            :   /* The exception region created for it.  */
<span class="lineNum">     378 </span>            :   eh_region region;
<span class="lineNum">     379 </span>            : 
<span class="lineNum">     380 </span>            :   /* The goto queue.  */
<span class="lineNum">     381 </span>            :   struct goto_queue_node *goto_queue;
<span class="lineNum">     382 </span>            :   size_t goto_queue_size;
<span class="lineNum">     383 </span>            :   size_t goto_queue_active;
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span>            :   /* Pointer map to help in searching goto_queue when it is large.  */
<span class="lineNum">     386 </span>            :   hash_map&lt;gimple *, goto_queue_node *&gt; *goto_queue_map;
<span class="lineNum">     387 </span>            : 
<span class="lineNum">     388 </span>            :   /* The set of unique labels seen as entries in the goto queue.  */
<span class="lineNum">     389 </span>            :   vec&lt;tree&gt; dest_array;
<span class="lineNum">     390 </span>            : 
<span class="lineNum">     391 </span>            :   /* A label to be added at the end of the completed transformed
<span class="lineNum">     392 </span>            :      sequence.  It will be set if may_fallthru was true *at one time*,
<span class="lineNum">     393 </span>            :      though subsequent transformations may have cleared that flag.  */
<span class="lineNum">     394 </span>            :   tree fallthru_label;
<span class="lineNum">     395 </span>            : 
<span class="lineNum">     396 </span>            :   /* True if it is possible to fall out the bottom of the try block.
<span class="lineNum">     397 </span>            :      Cleared if the fallthru is converted to a goto.  */
<span class="lineNum">     398 </span>            :   bool may_fallthru;
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span>            :   /* True if any entry in goto_queue is a GIMPLE_RETURN.  */
<span class="lineNum">     401 </span>            :   bool may_return;
<span class="lineNum">     402 </span>            : 
<span class="lineNum">     403 </span>            :   /* True if the finally block can receive an exception edge.
<span class="lineNum">     404 </span>            :      Cleared if the exception case is handled by code duplication.  */
<span class="lineNum">     405 </span>            :   bool may_throw;
<span class="lineNum">     406 </span>            : };
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span>            : static gimple_seq lower_eh_must_not_throw (struct leh_state *, gtry *);
<span class="lineNum">     409 </span>            : 
<span class="lineNum">     410 </span>            : /* Search for STMT in the goto queue.  Return the replacement,
<span class="lineNum">     411 </span>            :    or null if the statement isn't in the queue.  */
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span>            : #define LARGE_GOTO_QUEUE 20
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span>            : static void lower_eh_constructs_1 (struct leh_state *state, gimple_seq *seq);
<a name="416"><span class="lineNum">     416 </span>            : </a>
<span class="lineNum">     417 </span>            : static gimple_seq
<span class="lineNum">     418 </span><span class="lineCov">    4150249 : find_goto_replacement (struct leh_tf_state *tf, treemple stmt)</span>
<span class="lineNum">     419 </span>            : {
<span class="lineNum">     420 </span><span class="lineCov">    4150249 :   unsigned int i;</span>
<span class="lineNum">     421 </span>            : 
<span class="lineNum">     422 </span><span class="lineCov">    4150249 :   if (tf-&gt;goto_queue_active &lt; LARGE_GOTO_QUEUE)</span>
<span class="lineNum">     423 </span>            :     {
<span class="lineNum">     424 </span><span class="lineCov">   12853179 :       for (i = 0; i &lt; tf-&gt;goto_queue_active; i++)</span>
<span class="lineNum">     425 </span><span class="lineCov">    9125742 :         if ( tf-&gt;goto_queue[i].stmt.g == stmt.g)</span>
<span class="lineNum">     426 </span><span class="lineCov">     374357 :           return tf-&gt;goto_queue[i].repl_stmt;</span>
<span class="lineNum">     427 </span>            :       return NULL;
<span class="lineNum">     428 </span>            :     }
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span>            :   /* If we have a large number of entries in the goto_queue, create a
<span class="lineNum">     431 </span>            :      pointer map and use that for searching.  */
<span class="lineNum">     432 </span>            : 
<span class="lineNum">     433 </span><span class="lineCov">      48455 :   if (!tf-&gt;goto_queue_map)</span>
<span class="lineNum">     434 </span>            :     {
<span class="lineNum">     435 </span><span class="lineCov">        204 :       tf-&gt;goto_queue_map = new hash_map&lt;gimple *, goto_queue_node *&gt;;</span>
<span class="lineNum">     436 </span><span class="lineCov">       5250 :       for (i = 0; i &lt; tf-&gt;goto_queue_active; i++)</span>
<span class="lineNum">     437 </span>            :         {
<span class="lineNum">     438 </span><span class="lineCov">      15138 :           bool existed = tf-&gt;goto_queue_map-&gt;put (tf-&gt;goto_queue[i].stmt.g,</span>
<span class="lineNum">     439 </span><span class="lineCov">       5046 :                                                   &amp;tf-&gt;goto_queue[i]);</span>
<span class="lineNum">     440 </span><span class="lineCov">       5046 :           gcc_assert (!existed);</span>
<span class="lineNum">     441 </span>            :         }
<span class="lineNum">     442 </span>            :     }
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span><span class="lineCov">      48455 :   goto_queue_node **slot = tf-&gt;goto_queue_map-&gt;get (stmt.g);</span>
<span class="lineNum">     445 </span><span class="lineCov">       5046 :   if (slot != NULL)</span>
<span class="lineNum">     446 </span><span class="lineCov">       5046 :     return ((*slot)-&gt;repl_stmt);</span>
<span class="lineNum">     447 </span>            : 
<span class="lineNum">     448 </span>            :   return NULL;
<span class="lineNum">     449 </span>            : }
<span class="lineNum">     450 </span>            : 
<span class="lineNum">     451 </span>            : /* A subroutine of replace_goto_queue_1.  Handles the sub-clauses of a
<span class="lineNum">     452 </span>            :    lowered GIMPLE_COND.  If, by chance, the replacement is a simple goto,
<span class="lineNum">     453 </span>            :    then we can just splat it in, otherwise we add the new stmts immediately
<span class="lineNum">     454 </span>            :    after the GIMPLE_COND and redirect.  */
<a name="455"><span class="lineNum">     455 </span>            : </a>
<span class="lineNum">     456 </span>            : static void
<span class="lineNum">     457 </span><span class="lineCov">    2934894 : replace_goto_queue_cond_clause (tree *tp, struct leh_tf_state *tf,</span>
<span class="lineNum">     458 </span>            :                                 gimple_stmt_iterator *gsi)
<span class="lineNum">     459 </span>            : {
<span class="lineNum">     460 </span><span class="lineCov">    2934894 :   tree label;</span>
<span class="lineNum">     461 </span><span class="lineCov">    2934894 :   gimple_seq new_seq;</span>
<span class="lineNum">     462 </span><span class="lineCov">    2934894 :   treemple temp;</span>
<span class="lineNum">     463 </span><span class="lineCov">    5869788 :   location_t loc = gimple_location (gsi_stmt (*gsi));</span>
<span class="lineNum">     464 </span>            : 
<span class="lineNum">     465 </span><span class="lineCov">    2934894 :   temp.tp = tp;</span>
<span class="lineNum">     466 </span><span class="lineCov">    2934894 :   new_seq = find_goto_replacement (tf, temp);</span>
<span class="lineNum">     467 </span><span class="lineCov">    2934894 :   if (!new_seq)</span>
<span class="lineNum">     468 </span><span class="lineCov">    2934885 :     return;</span>
<span class="lineNum">     469 </span>            : 
<span class="lineNum">     470 </span><span class="lineCov">       1096 :   if (gimple_seq_singleton_p (new_seq)</span>
<span class="lineNum">     471 </span><span class="lineCov">       3261 :       &amp;&amp; gimple_code (gimple_seq_first_stmt (new_seq)) == GIMPLE_GOTO)</span>
<span class="lineNum">     472 </span>            :     {
<span class="lineNum">     473 </span><span class="lineCov">       2174 :       *tp = gimple_goto_dest (gimple_seq_first_stmt (new_seq));</span>
<span class="lineNum">     474 </span><span class="lineCov">       1087 :       return;</span>
<span class="lineNum">     475 </span>            :     }
<span class="lineNum">     476 </span>            : 
<span class="lineNum">     477 </span><span class="lineCov">          9 :   label = create_artificial_label (loc);</span>
<span class="lineNum">     478 </span>            :   /* Set the new label for the GIMPLE_COND */
<span class="lineNum">     479 </span><span class="lineCov">          9 :   *tp = label;</span>
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span><span class="lineCov">          9 :   gsi_insert_after (gsi, gimple_build_label (label), GSI_CONTINUE_LINKING);</span>
<span class="lineNum">     482 </span><span class="lineCov">          9 :   gsi_insert_seq_after (gsi, gimple_seq_copy (new_seq), GSI_CONTINUE_LINKING);</span>
<span class="lineNum">     483 </span>            : }
<span class="lineNum">     484 </span>            : 
<span class="lineNum">     485 </span>            : /* The real work of replace_goto_queue.  Returns with TSI updated to
<span class="lineNum">     486 </span>            :    point to the next statement.  */
<span class="lineNum">     487 </span>            : 
<span class="lineNum">     488 </span>            : static void replace_goto_queue_stmt_list (gimple_seq *, struct leh_tf_state *);
<a name="489"><span class="lineNum">     489 </span>            : </a>
<span class="lineNum">     490 </span>            : static void
<span class="lineNum">     491 </span><span class="lineCov">   19440753 : replace_goto_queue_1 (gimple *stmt, struct leh_tf_state *tf,</span>
<span class="lineNum">     492 </span>            :                       gimple_stmt_iterator *gsi)
<span class="lineNum">     493 </span>            : {
<span class="lineNum">     494 </span><span class="lineCov">   19440753 :   gimple_seq seq;</span>
<span class="lineNum">     495 </span><span class="lineCov">   19440753 :   treemple temp;</span>
<span class="lineNum">     496 </span><span class="lineCov">   19440753 :   temp.g = NULL;</span>
<span class="lineNum">     497 </span>            : 
<span class="lineNum">     498 </span><span class="lineCov">   38881506 :   switch (gimple_code (stmt))</span>
<span class="lineNum">     499 </span>            :     {
<span class="lineNum">     500 </span><span class="lineCov">    1215355 :     case GIMPLE_GOTO:</span>
<span class="lineNum">     501 </span><span class="lineCov">    1215355 :     case GIMPLE_RETURN:</span>
<span class="lineNum">     502 </span><span class="lineCov">    1215355 :       temp.g = stmt;</span>
<span class="lineNum">     503 </span><span class="lineCov">    1215355 :       seq = find_goto_replacement (tf, temp);</span>
<span class="lineNum">     504 </span><span class="lineCov">    1215355 :       if (seq)</span>
<span class="lineNum">     505 </span>            :         {
<span class="lineNum">     506 </span><span class="lineCov">     378307 :           gsi_insert_seq_before (gsi, gimple_seq_copy (seq), GSI_SAME_STMT);</span>
<span class="lineNum">     507 </span><span class="lineCov">     378307 :           gsi_remove (gsi, false);</span>
<span class="lineNum">     508 </span><span class="lineCov">     378307 :           return;</span>
<span class="lineNum">     509 </span>            :         }
<span class="lineNum">     510 </span>            :       break;
<span class="lineNum">     511 </span>            : 
<span class="lineNum">     512 </span><span class="lineCov">    1467447 :     case GIMPLE_COND:</span>
<span class="lineNum">     513 </span><span class="lineCov">    1467447 :       replace_goto_queue_cond_clause (gimple_op_ptr (stmt, 2), tf, gsi);</span>
<span class="lineNum">     514 </span><span class="lineCov">    1467447 :       replace_goto_queue_cond_clause (gimple_op_ptr (stmt, 3), tf, gsi);</span>
<span class="lineNum">     515 </span><span class="lineCov">    1467447 :       break;</span>
<span class="lineNum">     516 </span>            : 
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :     case GIMPLE_TRY:</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :       replace_goto_queue_stmt_list (gimple_try_eval_ptr (stmt), tf);</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :       replace_goto_queue_stmt_list (gimple_try_cleanup_ptr (stmt), tf);</span>
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :     case GIMPLE_CATCH:</span>
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :       replace_goto_queue_stmt_list (gimple_catch_handler_ptr (</span>
<span class="lineNum">     523 </span>            :                                       as_a &lt;gcatch *&gt; (stmt)),
<span class="lineNum">     524 </span>            :                                     tf);
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :     case GIMPLE_EH_FILTER:</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :       replace_goto_queue_stmt_list (gimple_eh_filter_failure_ptr (stmt), tf);</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :     case GIMPLE_EH_ELSE:</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :       {</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :         geh_else *eh_else_stmt = as_a &lt;geh_else *&gt; (stmt);</span>
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :         replace_goto_queue_stmt_list (gimple_eh_else_n_body_ptr (eh_else_stmt),</span>
<span class="lineNum">     533 </span>            :                                       tf);
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :         replace_goto_queue_stmt_list (gimple_eh_else_e_body_ptr (eh_else_stmt),</span>
<span class="lineNum">     535 </span>            :                                       tf);
<span class="lineNum">     536 </span>            :       }
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     538 </span>            : 
<span class="lineNum">     539 </span>            :     default:
<span class="lineNum">     540 </span>            :       /* These won't have gotos in them.  */
<span class="lineNum">     541 </span>            :       break;
<span class="lineNum">     542 </span>            :     }
<span class="lineNum">     543 </span>            : 
<span class="lineNum">     544 </span><span class="lineCov">   19062446 :   gsi_next (gsi);</span>
<span class="lineNum">     545 </span>            : }
<span class="lineNum">     546 </span>            : 
<span class="lineNum">     547 </span>            : /* A subroutine of replace_goto_queue.  Handles GIMPLE_SEQ.  */
<a name="548"><span class="lineNum">     548 </span>            : </a>
<span class="lineNum">     549 </span>            : static void
<span class="lineNum">     550 </span><span class="lineCov">     559414 : replace_goto_queue_stmt_list (gimple_seq *seq, struct leh_tf_state *tf)</span>
<span class="lineNum">     551 </span>            : {
<span class="lineNum">     552 </span><span class="lineCov">     559414 :   gimple_stmt_iterator gsi = gsi_start (*seq);</span>
<span class="lineNum">     553 </span>            : 
<span class="lineNum">     554 </span><span class="lineCov">   20559581 :   while (!gsi_end_p (gsi))</span>
<span class="lineNum">     555 </span><span class="lineCov">   38881506 :     replace_goto_queue_1 (gsi_stmt (gsi), tf, &amp;gsi);</span>
<span class="lineNum">     556 </span><span class="lineCov">     559414 : }</span>
<span class="lineNum">     557 </span>            : 
<span class="lineNum">     558 </span>            : /* Replace all goto queue members.  */
<a name="559"><span class="lineNum">     559 </span>            : </a>
<span class="lineNum">     560 </span>            : static void
<span class="lineNum">     561 </span><span class="lineCov">     279713 : replace_goto_queue (struct leh_tf_state *tf)</span>
<span class="lineNum">     562 </span>            : {
<span class="lineNum">     563 </span><span class="lineCov">     279713 :   if (tf-&gt;goto_queue_active == 0)</span>
<span class="lineNum">     564 </span>            :     return;
<span class="lineNum">     565 </span><span class="lineCov">     279707 :   replace_goto_queue_stmt_list (&amp;tf-&gt;top_p_seq, tf);</span>
<span class="lineNum">     566 </span><span class="lineCov">     279707 :   replace_goto_queue_stmt_list (&amp;eh_seq, tf);</span>
<span class="lineNum">     567 </span>            : }
<span class="lineNum">     568 </span>            : 
<span class="lineNum">     569 </span>            : /* Add a new record to the goto queue contained in TF. NEW_STMT is the
<span class="lineNum">     570 </span>            :    data to be added, IS_LABEL indicates whether NEW_STMT is a label or
<span class="lineNum">     571 </span>            :    a gimple return. */
<a name="572"><span class="lineNum">     572 </span>            : </a>
<span class="lineNum">     573 </span>            : static void
<span class="lineNum">     574 </span><span class="lineCov">     379403 : record_in_goto_queue (struct leh_tf_state *tf,</span>
<span class="lineNum">     575 </span>            :                       treemple new_stmt,
<span class="lineNum">     576 </span>            :                       int index,
<span class="lineNum">     577 </span>            :                       bool is_label,
<span class="lineNum">     578 </span>            :                       location_t location)
<span class="lineNum">     579 </span>            : {
<span class="lineNum">     580 </span><span class="lineCov">     379403 :   size_t active, size;</span>
<span class="lineNum">     581 </span><span class="lineCov">     379403 :   struct goto_queue_node *q;</span>
<span class="lineNum">     582 </span>            : 
<span class="lineNum">     583 </span><span class="lineCov">     379403 :   gcc_assert (!tf-&gt;goto_queue_map);</span>
<span class="lineNum">     584 </span>            : 
<span class="lineNum">     585 </span><span class="lineCov">     379403 :   active = tf-&gt;goto_queue_active;</span>
<span class="lineNum">     586 </span><span class="lineCov">     379403 :   size = tf-&gt;goto_queue_size;</span>
<span class="lineNum">     587 </span><span class="lineCov">     379403 :   if (active &gt;= size)</span>
<span class="lineNum">     588 </span>            :     {
<span class="lineNum">     589 </span><span class="lineCov">     279715 :       size = (size ? size * 2 : 32);</span>
<span class="lineNum">     590 </span><span class="lineCov">     279715 :       tf-&gt;goto_queue_size = size;</span>
<span class="lineNum">     591 </span><span class="lineCov">     279715 :       tf-&gt;goto_queue</span>
<span class="lineNum">     592 </span><span class="lineCov">     279715 :          = XRESIZEVEC (struct goto_queue_node, tf-&gt;goto_queue, size);</span>
<span class="lineNum">     593 </span>            :     }
<span class="lineNum">     594 </span>            : 
<span class="lineNum">     595 </span><span class="lineCov">     379403 :   q = &amp;tf-&gt;goto_queue[active];</span>
<span class="lineNum">     596 </span><span class="lineCov">     379403 :   tf-&gt;goto_queue_active = active + 1;</span>
<span class="lineNum">     597 </span>            : 
<span class="lineNum">     598 </span><span class="lineCov">     379403 :   memset (q, 0, sizeof (*q));</span>
<span class="lineNum">     599 </span><span class="lineCov">     379403 :   q-&gt;stmt = new_stmt;</span>
<span class="lineNum">     600 </span><span class="lineCov">     379403 :   q-&gt;index = index;</span>
<span class="lineNum">     601 </span><span class="lineCov">     379403 :   q-&gt;location = location;</span>
<span class="lineNum">     602 </span><span class="lineCov">     379403 :   q-&gt;is_label = is_label;</span>
<span class="lineNum">     603 </span><span class="lineCov">     379403 : }</span>
<span class="lineNum">     604 </span>            : 
<span class="lineNum">     605 </span>            : /* Record the LABEL label in the goto queue contained in TF.
<span class="lineNum">     606 </span>            :    TF is not null.  */
<a name="607"><span class="lineNum">     607 </span>            : </a>
<span class="lineNum">     608 </span>            : static void
<span class="lineNum">     609 </span><span class="lineCov">    4868511 : record_in_goto_queue_label (struct leh_tf_state *tf, treemple stmt, tree label,</span>
<span class="lineNum">     610 </span>            :                             location_t location)
<span class="lineNum">     611 </span>            : {
<span class="lineNum">     612 </span><span class="lineCov">    4868511 :   int index;</span>
<span class="lineNum">     613 </span><span class="lineCov">    4868511 :   treemple temp, new_stmt;</span>
<span class="lineNum">     614 </span>            : 
<span class="lineNum">     615 </span><span class="lineCov">    4868511 :   if (!label)</span>
<span class="lineNum">     616 </span><span class="lineCov">    4489108 :     return;</span>
<span class="lineNum">     617 </span>            : 
<span class="lineNum">     618 </span>            :   /* Computed and non-local gotos do not get processed.  Given
<span class="lineNum">     619 </span>            :      their nature we can neither tell whether we've escaped the
<span class="lineNum">     620 </span>            :      finally block nor redirect them if we knew.  */
<span class="lineNum">     621 </span><span class="lineCov">    4868511 :   if (TREE_CODE (label) != LABEL_DECL)</span>
<span class="lineNum">     622 </span>            :     return;
<span class="lineNum">     623 </span>            : 
<span class="lineNum">     624 </span>            :   /* No need to record gotos that don't leave the try block.  */
<span class="lineNum">     625 </span><span class="lineCov">    4868365 :   temp.t = label;</span>
<span class="lineNum">     626 </span><span class="lineCov">    4868365 :   if (!outside_finally_tree (temp, tf-&gt;try_finally_expr))</span>
<span class="lineNum">     627 </span>            :     return;
<span class="lineNum">     628 </span>            : 
<span class="lineNum">     629 </span><span class="lineCov">     379403 :   if (! tf-&gt;dest_array.exists ())</span>
<span class="lineNum">     630 </span>            :     {
<span class="lineNum">     631 </span><span class="lineCov">     279707 :       tf-&gt;dest_array.create (10);</span>
<span class="lineNum">     632 </span><span class="lineCov">     279707 :       tf-&gt;dest_array.quick_push (label);</span>
<span class="lineNum">     633 </span><span class="lineCov">     279707 :       index = 0;</span>
<span class="lineNum">     634 </span>            :     }
<span class="lineNum">     635 </span>            :   else
<span class="lineNum">     636 </span>            :     {
<span class="lineNum">     637 </span><span class="lineCov">      99696 :       int n = tf-&gt;dest_array.length ();</span>
<span class="lineNum">     638 </span><span class="lineCov">     103432 :       for (index = 0; index &lt; n; ++index)</span>
<span class="lineNum">     639 </span><span class="lineCov">     101558 :         if (tf-&gt;dest_array[index] == label)</span>
<span class="lineNum">     640 </span>            :           break;
<span class="lineNum">     641 </span><span class="lineCov">      99696 :       if (index == n)</span>
<span class="lineNum">     642 </span><span class="lineCov">       1874 :         tf-&gt;dest_array.safe_push (label);</span>
<span class="lineNum">     643 </span>            :     }
<span class="lineNum">     644 </span>            : 
<span class="lineNum">     645 </span>            :   /* In the case of a GOTO we want to record the destination label,
<span class="lineNum">     646 </span>            :      since with a GIMPLE_COND we have an easy access to the then/else
<span class="lineNum">     647 </span>            :      labels. */
<span class="lineNum">     648 </span><span class="lineCov">     379403 :   new_stmt = stmt;</span>
<span class="lineNum">     649 </span><span class="lineCov">     379403 :   record_in_goto_queue (tf, new_stmt, index, true, location);</span>
<span class="lineNum">     650 </span>            : }
<span class="lineNum">     651 </span>            : 
<span class="lineNum">     652 </span>            : /* For any GIMPLE_GOTO or GIMPLE_RETURN, decide whether it leaves a try_finally
<span class="lineNum">     653 </span>            :    node, and if so record that fact in the goto queue associated with that
<span class="lineNum">     654 </span>            :    try_finally node.  */
<a name="655"><span class="lineNum">     655 </span>            : </a>
<span class="lineNum">     656 </span>            : static void
<span class="lineNum">     657 </span><span class="lineCov">    7880678 : maybe_record_in_goto_queue (struct leh_state *state, gimple *stmt)</span>
<span class="lineNum">     658 </span>            : {
<span class="lineNum">     659 </span><span class="lineCov">    7880678 :   struct leh_tf_state *tf = state-&gt;tf;</span>
<span class="lineNum">     660 </span><span class="lineCov">    7880678 :   treemple new_stmt;</span>
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span><span class="lineCov">    7880678 :   if (!tf)</span>
<span class="lineNum">     663 </span>            :     return;
<span class="lineNum">     664 </span>            : 
<span class="lineNum">     665 </span><span class="lineCov">    6108274 :   switch (gimple_code (stmt))</span>
<span class="lineNum">     666 </span>            :     {
<span class="lineNum">     667 </span><span class="lineCov">    1814374 :     case GIMPLE_COND:</span>
<span class="lineNum">     668 </span><span class="lineCov">    1814374 :       {</span>
<span class="lineNum">     669 </span><span class="lineCov">    1814374 :         gcond *cond_stmt = as_a &lt;gcond *&gt; (stmt);</span>
<span class="lineNum">     670 </span><span class="lineCov">    1814374 :         new_stmt.tp = gimple_op_ptr (cond_stmt, 2);</span>
<span class="lineNum">     671 </span><span class="lineCov">    3628748 :         record_in_goto_queue_label (tf, new_stmt,</span>
<span class="lineNum">     672 </span>            :                                     gimple_cond_true_label (cond_stmt),
<span class="lineNum">     673 </span><span class="lineCov">    1814374 :                                     EXPR_LOCATION (*new_stmt.tp));</span>
<span class="lineNum">     674 </span><span class="lineCov">    1814374 :         new_stmt.tp = gimple_op_ptr (cond_stmt, 3);</span>
<span class="lineNum">     675 </span><span class="lineCov">    1814374 :         record_in_goto_queue_label (tf, new_stmt,</span>
<span class="lineNum">     676 </span>            :                                     gimple_cond_false_label (cond_stmt),
<span class="lineNum">     677 </span><span class="lineCov">    1814374 :                                     EXPR_LOCATION (*new_stmt.tp));</span>
<span class="lineNum">     678 </span>            :       }
<span class="lineNum">     679 </span><span class="lineCov">    1814374 :       break;</span>
<span class="lineNum">     680 </span><span class="lineCov">    1239763 :     case GIMPLE_GOTO:</span>
<span class="lineNum">     681 </span><span class="lineCov">    1239763 :       new_stmt.g = stmt;</span>
<span class="lineNum">     682 </span><span class="lineCov">    2479526 :       record_in_goto_queue_label (tf, new_stmt, gimple_goto_dest (stmt),</span>
<span class="lineNum">     683 </span>            :                                   gimple_location (stmt));
<span class="lineNum">     684 </span><span class="lineCov">    1239763 :       break;</span>
<span class="lineNum">     685 </span>            : 
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :     case GIMPLE_RETURN:</span>
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :       tf-&gt;may_return = true;</span>
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :       new_stmt.g = stmt;</span>
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :       record_in_goto_queue (tf, new_stmt, -1, false, gimple_location (stmt));</span>
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">     694 </span>            :     }
<span class="lineNum">     695 </span>            : }
<span class="lineNum">     696 </span>            : 
<span class="lineNum">     697 </span>            : 
<span class="lineNum">     698 </span>            : #if CHECKING_P
<span class="lineNum">     699 </span>            : /* We do not process GIMPLE_SWITCHes for now.  As long as the original source
<span class="lineNum">     700 </span>            :    was in fact structured, and we've not yet done jump threading, then none
<span class="lineNum">     701 </span>            :    of the labels will leave outer GIMPLE_TRY_FINALLY nodes. Verify this.  */
<a name="702"><span class="lineNum">     702 </span>            : </a>
<span class="lineNum">     703 </span>            : static void
<span class="lineNum">     704 </span><span class="lineCov">      25466 : verify_norecord_switch_expr (struct leh_state *state,</span>
<span class="lineNum">     705 </span>            :                              gswitch *switch_expr)
<span class="lineNum">     706 </span>            : {
<span class="lineNum">     707 </span><span class="lineCov">      25466 :   struct leh_tf_state *tf = state-&gt;tf;</span>
<span class="lineNum">     708 </span><span class="lineCov">      25466 :   size_t i, n;</span>
<span class="lineNum">     709 </span>            : 
<span class="lineNum">     710 </span><span class="lineCov">      25466 :   if (!tf)</span>
<span class="lineNum">     711 </span>            :     return;
<span class="lineNum">     712 </span>            : 
<span class="lineNum">     713 </span><span class="lineCov">      13621 :   n = gimple_switch_num_labels (switch_expr);</span>
<span class="lineNum">     714 </span>            : 
<span class="lineNum">     715 </span><span class="lineCov">     119815 :   for (i = 0; i &lt; n; ++i)</span>
<span class="lineNum">     716 </span>            :     {
<span class="lineNum">     717 </span><span class="lineCov">     106194 :       treemple temp;</span>
<span class="lineNum">     718 </span><span class="lineCov">     106194 :       tree lab = CASE_LABEL (gimple_switch_label (switch_expr, i));</span>
<span class="lineNum">     719 </span><span class="lineCov">     106194 :       temp.t = lab;</span>
<span class="lineNum">     720 </span><span class="lineCov">     106194 :       gcc_assert (!outside_finally_tree (temp, tf-&gt;try_finally_expr));</span>
<span class="lineNum">     721 </span>            :     }
<span class="lineNum">     722 </span>            : }
<span class="lineNum">     723 </span>            : #else
<span class="lineNum">     724 </span>            : #define verify_norecord_switch_expr(state, switch_expr)
<span class="lineNum">     725 </span>            : #endif
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span>            : /* Redirect a RETURN_EXPR pointed to by Q to FINLAB.  If MOD is
<span class="lineNum">     728 </span>            :    non-null, insert it before the new branch.  */
<a name="729"><span class="lineNum">     729 </span>            : </a>
<span class="lineNum">     730 </span>            : static void
<span class="lineNum">     731 </span><span class="lineNoCov">          0 : do_return_redirection (struct goto_queue_node *q, tree finlab, gimple_seq mod)</span>
<span class="lineNum">     732 </span>            : {
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :   gimple *x;</span>
<span class="lineNum">     734 </span>            : 
<span class="lineNum">     735 </span>            :   /* In the case of a return, the queue node must be a gimple statement.  */
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :   gcc_assert (!q-&gt;is_label);</span>
<span class="lineNum">     737 </span>            : 
<span class="lineNum">     738 </span>            :   /* Note that the return value may have already been computed, e.g.,
<span class="lineNum">     739 </span>            : 
<span class="lineNum">     740 </span>            :         int x;
<span class="lineNum">     741 </span>            :         int foo (void)
<span class="lineNum">     742 </span>            :         {
<span class="lineNum">     743 </span>            :           x = 0;
<span class="lineNum">     744 </span>            :           try {
<span class="lineNum">     745 </span>            :             return x;
<span class="lineNum">     746 </span>            :           } finally {
<span class="lineNum">     747 </span>            :             x++;
<span class="lineNum">     748 </span>            :           }
<span class="lineNum">     749 </span>            :         }
<span class="lineNum">     750 </span>            : 
<span class="lineNum">     751 </span>            :      should return 0, not 1.  We don't have to do anything to make
<span class="lineNum">     752 </span>            :      this happens because the return value has been placed in the
<span class="lineNum">     753 </span>            :      RESULT_DECL already.  */
<span class="lineNum">     754 </span>            : 
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :   q-&gt;cont_stmt = q-&gt;stmt.g;</span>
<span class="lineNum">     756 </span>            : 
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :   if (mod)</span>
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :     gimple_seq_add_seq (&amp;q-&gt;repl_stmt, mod);</span>
<span class="lineNum">     759 </span>            : 
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :   x = gimple_build_goto (finlab);</span>
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :   gimple_set_location (x, q-&gt;location);</span>
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :   gimple_seq_add_stmt (&amp;q-&gt;repl_stmt, x);</span>
<span class="lineNum">     763 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     764 </span>            : 
<span class="lineNum">     765 </span>            : /* Similar, but easier, for GIMPLE_GOTO.  */
<a name="766"><span class="lineNum">     766 </span>            : </a>
<span class="lineNum">     767 </span>            : static void
<span class="lineNum">     768 </span><span class="lineCov">     379403 : do_goto_redirection (struct goto_queue_node *q, tree finlab, gimple_seq mod,</span>
<span class="lineNum">     769 </span>            :                      struct leh_tf_state *tf)
<span class="lineNum">     770 </span>            : {
<span class="lineNum">     771 </span><span class="lineCov">     379403 :   ggoto *x;</span>
<span class="lineNum">     772 </span>            : 
<span class="lineNum">     773 </span><span class="lineCov">     379403 :   gcc_assert (q-&gt;is_label);</span>
<span class="lineNum">     774 </span>            : 
<span class="lineNum">     775 </span><span class="lineCov">     379403 :   q-&gt;cont_stmt = gimple_build_goto (tf-&gt;dest_array[q-&gt;index]);</span>
<span class="lineNum">     776 </span>            : 
<span class="lineNum">     777 </span><span class="lineCov">     379403 :   if (mod)</span>
<span class="lineNum">     778 </span><span class="lineCov">        377 :     gimple_seq_add_seq (&amp;q-&gt;repl_stmt, mod);</span>
<span class="lineNum">     779 </span>            : 
<span class="lineNum">     780 </span><span class="lineCov">     379403 :   x = gimple_build_goto (finlab);</span>
<span class="lineNum">     781 </span><span class="lineCov">     379403 :   gimple_set_location (x, q-&gt;location);</span>
<span class="lineNum">     782 </span><span class="lineCov">     379403 :   gimple_seq_add_stmt (&amp;q-&gt;repl_stmt, x);</span>
<span class="lineNum">     783 </span><span class="lineCov">     379403 : }</span>
<span class="lineNum">     784 </span>            : 
<span class="lineNum">     785 </span>            : /* Emit a standard landing pad sequence into SEQ for REGION.  */
<a name="786"><span class="lineNum">     786 </span>            : </a>
<span class="lineNum">     787 </span>            : static void
<span class="lineNum">     788 </span><span class="lineCov">     482784 : emit_post_landing_pad (gimple_seq *seq, eh_region region)</span>
<span class="lineNum">     789 </span>            : {
<span class="lineNum">     790 </span><span class="lineCov">     482784 :   eh_landing_pad lp = region-&gt;landing_pads;</span>
<span class="lineNum">     791 </span><span class="lineCov">     482784 :   glabel *x;</span>
<span class="lineNum">     792 </span>            : 
<span class="lineNum">     793 </span><span class="lineCov">     482784 :   if (lp == NULL)</span>
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :     lp = gen_eh_landing_pad (region);</span>
<span class="lineNum">     795 </span>            : 
<span class="lineNum">     796 </span><span class="lineCov">     482784 :   lp-&gt;post_landing_pad = create_artificial_label (UNKNOWN_LOCATION);</span>
<span class="lineNum">     797 </span><span class="lineCov">     482784 :   EH_LANDING_PAD_NR (lp-&gt;post_landing_pad) = lp-&gt;index;</span>
<span class="lineNum">     798 </span>            : 
<span class="lineNum">     799 </span><span class="lineCov">     482784 :   x = gimple_build_label (lp-&gt;post_landing_pad);</span>
<span class="lineNum">     800 </span><span class="lineCov">     482784 :   gimple_seq_add_stmt (seq, x);</span>
<span class="lineNum">     801 </span><span class="lineCov">     482784 : }</span>
<span class="lineNum">     802 </span>            : 
<span class="lineNum">     803 </span>            : /* Emit a RESX statement into SEQ for REGION.  */
<a name="804"><span class="lineNum">     804 </span>            : </a>
<span class="lineNum">     805 </span>            : static void
<span class="lineNum">     806 </span><span class="lineCov">     482784 : emit_resx (gimple_seq *seq, eh_region region)</span>
<span class="lineNum">     807 </span>            : {
<span class="lineNum">     808 </span><span class="lineCov">     482784 :   gresx *x = gimple_build_resx (region-&gt;index);</span>
<span class="lineNum">     809 </span><span class="lineCov">     482784 :   gimple_seq_add_stmt (seq, x);</span>
<span class="lineNum">     810 </span><span class="lineCov">     482784 :   if (region-&gt;outer)</span>
<span class="lineNum">     811 </span><span class="lineCov">     261120 :     record_stmt_eh_region (region-&gt;outer, x);</span>
<span class="lineNum">     812 </span><span class="lineCov">     482784 : }</span>
<span class="lineNum">     813 </span>            : 
<span class="lineNum">     814 </span>            : /* Emit an EH_DISPATCH statement into SEQ for REGION.  */
<a name="815"><span class="lineNum">     815 </span>            : </a>
<span class="lineNum">     816 </span>            : static void
<span class="lineNum">     817 </span><span class="lineNoCov">          0 : emit_eh_dispatch (gimple_seq *seq, eh_region region)</span>
<span class="lineNum">     818 </span>            : {
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :   geh_dispatch *x = gimple_build_eh_dispatch (region-&gt;index);</span>
<span class="lineNum">     820 </span><span class="lineCov">      37967 :   gimple_seq_add_stmt (seq, x);</span>
<span class="lineNum">     821 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     822 </span>            : 
<span class="lineNum">     823 </span>            : /* Note that the current EH region may contain a throw, or a
<span class="lineNum">     824 </span>            :    call to a function which itself may contain a throw.  */
<a name="825"><span class="lineNum">     825 </span>            : </a>
<span class="lineNum">     826 </span>            : static void
<span class="lineNum">     827 </span><span class="lineCov">    1642124 : note_eh_region_may_contain_throw (eh_region region)</span>
<span class="lineNum">     828 </span>            : {
<span class="lineNum">     829 </span><span class="lineCov">    1903244 :   while (bitmap_set_bit (eh_region_may_contain_throw_map, region-&gt;index))</span>
<span class="lineNum">     830 </span>            :     {
<span class="lineNum">     831 </span><span class="lineCov">     534897 :       if (region-&gt;type == ERT_MUST_NOT_THROW)</span>
<span class="lineNum">     832 </span>            :         break;
<span class="lineNum">     833 </span><span class="lineCov">     482784 :       region = region-&gt;outer;</span>
<span class="lineNum">     834 </span><span class="lineCov">     482784 :       if (region == NULL)</span>
<span class="lineNum">     835 </span>            :         break;
<span class="lineNum">     836 </span>            :     }
<span class="lineNum">     837 </span><span class="lineCov">    1642124 : }</span>
<span class="lineNum">     838 </span>            : 
<span class="lineNum">     839 </span>            : /* Check if REGION has been marked as containing a throw.  If REGION is
<span class="lineNum">     840 </span>            :    NULL, this predicate is false.  */
<span class="lineNum">     841 </span>            : 
<span class="lineNum">     842 </span>            : static inline bool
<span class="lineNum">     843 </span>            : eh_region_may_contain_throw (eh_region r)
<span class="lineNum">     844 </span>            : {
<span class="lineNum">     845 </span><span class="lineCov">     740962 :   return r &amp;&amp; bitmap_bit_p (eh_region_may_contain_throw_map, r-&gt;index);</span>
<span class="lineNum">     846 </span>            : }
<span class="lineNum">     847 </span>            : 
<span class="lineNum">     848 </span>            : /* We want to transform
<span class="lineNum">     849 </span>            :         try { body; } catch { stuff; }
<span class="lineNum">     850 </span>            :    to
<span class="lineNum">     851 </span>            :         normal_sequence:
<span class="lineNum">     852 </span>            :           body;
<span class="lineNum">     853 </span>            :           over:
<span class="lineNum">     854 </span>            :         eh_sequence:
<span class="lineNum">     855 </span>            :           landing_pad:
<span class="lineNum">     856 </span>            :           stuff;
<span class="lineNum">     857 </span>            :           goto over;
<span class="lineNum">     858 </span>            : 
<span class="lineNum">     859 </span>            :    TP is a GIMPLE_TRY node.  REGION is the region whose post_landing_pad
<span class="lineNum">     860 </span>            :    should be placed before the second operand, or NULL.  OVER is
<span class="lineNum">     861 </span>            :    an existing label that should be put at the exit, or NULL.  */
<a name="862"><span class="lineNum">     862 </span>            : </a>
<span class="lineNum">     863 </span>            : static gimple_seq
<span class="lineNum">     864 </span><span class="lineCov">      37967 : frob_into_branch_around (gtry *tp, eh_region region, tree over)</span>
<span class="lineNum">     865 </span>            : {
<span class="lineNum">     866 </span><span class="lineCov">      37967 :   gimple *x;</span>
<span class="lineNum">     867 </span><span class="lineCov">      37967 :   gimple_seq cleanup, result;</span>
<span class="lineNum">     868 </span><span class="lineCov">      37967 :   location_t loc = gimple_location (tp);</span>
<span class="lineNum">     869 </span>            : 
<span class="lineNum">     870 </span><span class="lineCov">      37967 :   cleanup = gimple_try_cleanup (tp);</span>
<span class="lineNum">     871 </span><span class="lineCov">      37967 :   result = gimple_try_eval (tp);</span>
<span class="lineNum">     872 </span>            : 
<span class="lineNum">     873 </span><span class="lineCov">      37967 :   if (region)</span>
<span class="lineNum">     874 </span><span class="lineCov">      37967 :     emit_post_landing_pad (&amp;eh_seq, region);</span>
<span class="lineNum">     875 </span>            : 
<span class="lineNum">     876 </span><span class="lineCov">      37967 :   if (gimple_seq_may_fallthru (cleanup))</span>
<span class="lineNum">     877 </span>            :     {
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :       if (!over)</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :         over = create_artificial_label (loc);</span>
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :       x = gimple_build_goto (over);</span>
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :       gimple_set_location (x, loc);</span>
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :       gimple_seq_add_stmt (&amp;cleanup, x);</span>
<span class="lineNum">     883 </span>            :     }
<span class="lineNum">     884 </span><span class="lineCov">      37967 :   gimple_seq_add_seq (&amp;eh_seq, cleanup);</span>
<span class="lineNum">     885 </span>            : 
<span class="lineNum">     886 </span><span class="lineCov">      37967 :   if (over)</span>
<span class="lineNum">     887 </span>            :     {
<span class="lineNum">     888 </span><span class="lineCov">       7382 :       x = gimple_build_label (over);</span>
<span class="lineNum">     889 </span><span class="lineCov">       7382 :       gimple_seq_add_stmt (&amp;result, x);</span>
<span class="lineNum">     890 </span>            :     }
<span class="lineNum">     891 </span><span class="lineCov">      37967 :   return result;</span>
<span class="lineNum">     892 </span>            : }
<span class="lineNum">     893 </span>            : 
<span class="lineNum">     894 </span>            : /* A subroutine of lower_try_finally.  Duplicate the tree rooted at T.
<span class="lineNum">     895 </span>            :    Make sure to record all new labels found.  */
<a name="896"><span class="lineNum">     896 </span>            : </a>
<span class="lineNum">     897 </span>            : static gimple_seq
<span class="lineNum">     898 </span><span class="lineCov">     554919 : lower_try_finally_dup_block (gimple_seq seq, struct leh_state *outer_state,</span>
<span class="lineNum">     899 </span>            :                              location_t loc)
<span class="lineNum">     900 </span>            : {
<span class="lineNum">     901 </span><span class="lineCov">     554919 :   gtry *region = NULL;</span>
<span class="lineNum">     902 </span><span class="lineCov">     554919 :   gimple_seq new_seq;</span>
<span class="lineNum">     903 </span><span class="lineCov">     554919 :   gimple_stmt_iterator gsi;</span>
<span class="lineNum">     904 </span>            : 
<span class="lineNum">     905 </span><span class="lineCov">     554919 :   new_seq = copy_gimple_seq_and_replace_locals (seq);</span>
<span class="lineNum">     906 </span>            : 
<span class="lineNum">     907 </span><span class="lineCov">    1836815 :   for (gsi = gsi_start (new_seq); !gsi_end_p (gsi); gsi_next (&amp;gsi))</span>
<span class="lineNum">     908 </span>            :     {
<span class="lineNum">     909 </span><span class="lineCov">     726977 :       gimple *stmt = gsi_stmt (gsi);</span>
<span class="lineNum">     910 </span>            :       /* We duplicate __builtin_stack_restore at -O0 in the hope of eliminating
<span class="lineNum">     911 </span>            :          it on the EH paths.  When it is not eliminated, make it transparent in
<span class="lineNum">     912 </span>            :          the debug info.  */
<span class="lineNum">     913 </span><span class="lineCov">     726977 :       if (gimple_call_builtin_p (stmt, BUILT_IN_STACK_RESTORE))</span>
<span class="lineNum">     914 </span><span class="lineCov">        479 :         gimple_set_location (stmt, UNKNOWN_LOCATION);</span>
<span class="lineNum">     915 </span><span class="lineCov">    2179494 :       else if (LOCATION_LOCUS (gimple_location (stmt)) == UNKNOWN_LOCATION)</span>
<span class="lineNum">     916 </span>            :         {
<span class="lineNum">     917 </span><span class="lineCov">     513580 :           tree block = gimple_block (stmt);</span>
<span class="lineNum">     918 </span><span class="lineCov">     513580 :           gimple_set_location (stmt, loc);</span>
<span class="lineNum">     919 </span><span class="lineCov">     513580 :           gimple_set_block (stmt, block);</span>
<span class="lineNum">     920 </span>            :         }
<span class="lineNum">     921 </span>            :     }
<span class="lineNum">     922 </span>            : 
<span class="lineNum">     923 </span><span class="lineCov">     554919 :   if (outer_state-&gt;tf)</span>
<span class="lineNum">     924 </span><span class="lineCov">     275940 :     region = outer_state-&gt;tf-&gt;try_finally_expr;</span>
<span class="lineNum">     925 </span><span class="lineCov">     554919 :   collect_finally_tree_1 (new_seq, region);</span>
<span class="lineNum">     926 </span>            : 
<span class="lineNum">     927 </span><span class="lineCov">     554919 :   return new_seq;</span>
<span class="lineNum">     928 </span>            : }
<span class="lineNum">     929 </span>            : 
<span class="lineNum">     930 </span>            : /* A subroutine of lower_try_finally.  Create a fallthru label for
<span class="lineNum">     931 </span>            :    the given try_finally state.  The only tricky bit here is that
<span class="lineNum">     932 </span>            :    we have to make sure to record the label in our outer context.  */
<a name="933"><span class="lineNum">     933 </span>            : </a>
<span class="lineNum">     934 </span>            : static tree
<span class="lineNum">     935 </span><span class="lineCov">      67033 : lower_try_finally_fallthru_label (struct leh_tf_state *tf)</span>
<span class="lineNum">     936 </span>            : {
<span class="lineNum">     937 </span><span class="lineCov">      67033 :   tree label = tf-&gt;fallthru_label;</span>
<span class="lineNum">     938 </span><span class="lineCov">      67033 :   treemple temp;</span>
<span class="lineNum">     939 </span>            : 
<span class="lineNum">     940 </span><span class="lineCov">      67033 :   if (!label)</span>
<span class="lineNum">     941 </span>            :     {
<span class="lineNum">     942 </span><span class="lineCov">     134066 :       label = create_artificial_label (gimple_location (tf-&gt;try_finally_expr));</span>
<span class="lineNum">     943 </span><span class="lineCov">      67033 :       tf-&gt;fallthru_label = label;</span>
<span class="lineNum">     944 </span><span class="lineCov">      67033 :       if (tf-&gt;outer-&gt;tf)</span>
<span class="lineNum">     945 </span>            :         {
<span class="lineNum">     946 </span><span class="lineCov">      33152 :           temp.t = label;</span>
<span class="lineNum">     947 </span><span class="lineCov">      33152 :           record_in_finally_tree (temp, tf-&gt;outer-&gt;tf-&gt;try_finally_expr);</span>
<span class="lineNum">     948 </span>            :         }
<span class="lineNum">     949 </span>            :     }
<span class="lineNum">     950 </span><span class="lineCov">      67033 :   return label;</span>
<span class="lineNum">     951 </span>            : }
<span class="lineNum">     952 </span>            : 
<span class="lineNum">     953 </span>            : /* A subroutine of lower_try_finally.  If FINALLY consits of a
<span class="lineNum">     954 </span>            :    GIMPLE_EH_ELSE node, return it.  */
<span class="lineNum">     955 </span>            : 
<span class="lineNum">     956 </span>            : static inline geh_else *
<span class="lineNum">     957 </span>            : get_eh_else (gimple_seq finally)
<span class="lineNum">     958 </span>            : {
<span class="lineNum">     959 </span><span class="lineCov">    2912218 :   gimple *x = gimple_seq_first_stmt (finally);</span>
<span class="lineNum">     960 </span><span class="lineCov">    2912218 :   if (gimple_code (x) == GIMPLE_EH_ELSE)</span>
<span class="lineNum">     961 </span>            :     {
<span class="lineNum">     962 </span><span class="lineCov">        512 :       gcc_assert (gimple_seq_singleton_p (finally));</span>
<span class="lineNum">     963 </span>            :       return as_a &lt;geh_else *&gt; (x);
<span class="lineNum">     964 </span>            :     }
<span class="lineNum">     965 </span>            :   return NULL;
<span class="lineNum">     966 </span>            : }
<span class="lineNum">     967 </span>            : 
<span class="lineNum">     968 </span>            : /* A subroutine of lower_try_finally.  If the eh_protect_cleanup_actions
<span class="lineNum">     969 </span>            :    langhook returns non-null, then the language requires that the exception
<span class="lineNum">     970 </span>            :    path out of a try_finally be treated specially.  To wit: the code within
<span class="lineNum">     971 </span>            :    the finally block may not itself throw an exception.  We have two choices
<span class="lineNum">     972 </span>            :    here. First we can duplicate the finally block and wrap it in a
<span class="lineNum">     973 </span>            :    must_not_throw region.  Second, we can generate code like
<span class="lineNum">     974 </span>            : 
<span class="lineNum">     975 </span>            :         try {
<span class="lineNum">     976 </span>            :           finally_block;
<span class="lineNum">     977 </span>            :         } catch {
<span class="lineNum">     978 </span>            :           if (fintmp == eh_edge)
<span class="lineNum">     979 </span>            :             protect_cleanup_actions;
<span class="lineNum">     980 </span>            :         }
<span class="lineNum">     981 </span>            : 
<span class="lineNum">     982 </span>            :    where &quot;fintmp&quot; is the temporary used in the switch statement generation
<span class="lineNum">     983 </span>            :    alternative considered below.  For the nonce, we always choose the first
<span class="lineNum">     984 </span>            :    option.
<span class="lineNum">     985 </span>            : 
<span class="lineNum">     986 </span>            :    THIS_STATE may be null if this is a try-cleanup, not a try-finally.  */
<a name="987"><span class="lineNum">     987 </span>            : </a>
<span class="lineNum">     988 </span>            : static void
<span class="lineNum">     989 </span><span class="lineCov">     444817 : honor_protect_cleanup_actions (struct leh_state *outer_state,</span>
<span class="lineNum">     990 </span>            :                                struct leh_state *this_state,
<span class="lineNum">     991 </span>            :                                struct leh_tf_state *tf)
<span class="lineNum">     992 </span>            : {
<span class="lineNum">     993 </span><span class="lineCov">     444817 :   gimple_seq finally = gimple_try_cleanup (tf-&gt;top_p);</span>
<span class="lineNum">     994 </span>            : 
<span class="lineNum">     995 </span>            :   /* EH_ELSE doesn't come from user code; only compiler generated stuff.
<span class="lineNum">     996 </span>            :      It does need to be handled here, so as to separate the (different)
<span class="lineNum">     997 </span>            :      EH path from the normal path.  But we should not attempt to wrap
<span class="lineNum">     998 </span>            :      it with a must-not-throw node (which indeed gets in the way).  */
<span class="lineNum">     999 </span><span class="lineCov">     444817 :   if (geh_else *eh_else = get_eh_else (finally))</span>
<span class="lineNum">    1000 </span>            :     {
<span class="lineNum">    1001 </span><span class="lineCov">        484 :       gimple_try_set_cleanup (tf-&gt;top_p, gimple_eh_else_n_body (eh_else));</span>
<span class="lineNum">    1002 </span><span class="lineCov">        242 :       finally = gimple_eh_else_e_body (eh_else);</span>
<span class="lineNum">    1003 </span>            : 
<span class="lineNum">    1004 </span>            :       /* Let the ELSE see the exception that's being processed.  */
<span class="lineNum">    1005 </span><span class="lineCov">        242 :       eh_region save_ehp = this_state-&gt;ehp_region;</span>
<span class="lineNum">    1006 </span><span class="lineCov">        242 :       this_state-&gt;ehp_region = this_state-&gt;cur_region;</span>
<span class="lineNum">    1007 </span><span class="lineCov">        242 :       lower_eh_constructs_1 (this_state, &amp;finally);</span>
<span class="lineNum">    1008 </span><span class="lineCov">        242 :       this_state-&gt;ehp_region = save_ehp;</span>
<span class="lineNum">    1009 </span>            :     }
<span class="lineNum">    1010 </span>            :   else
<span class="lineNum">    1011 </span>            :     {
<span class="lineNum">    1012 </span>            :       /* First check for nothing to do.  */
<span class="lineNum">    1013 </span><span class="lineCov">     444575 :       if (lang_hooks.eh_protect_cleanup_actions == NULL)</span>
<span class="lineNum">    1014 </span><span class="lineCov">     114766 :         return;</span>
<span class="lineNum">    1015 </span><span class="lineCov">     329809 :       tree actions = lang_hooks.eh_protect_cleanup_actions ();</span>
<span class="lineNum">    1016 </span><span class="lineCov">     329809 :       if (actions == NULL)</span>
<span class="lineNum">    1017 </span>            :         return;
<span class="lineNum">    1018 </span>            : 
<span class="lineNum">    1019 </span><span class="lineCov">     329809 :       if (this_state)</span>
<span class="lineNum">    1020 </span><span class="lineCov">     277161 :         finally = lower_try_finally_dup_block (finally, outer_state,</span>
<span class="lineNum">    1021 </span><span class="lineCov">     277161 :           gimple_location (tf-&gt;try_finally_expr));</span>
<span class="lineNum">    1022 </span>            : 
<span class="lineNum">    1023 </span>            :       /* If this cleanup consists of a TRY_CATCH_EXPR with TRY_CATCH_IS_CLEANUP
<span class="lineNum">    1024 </span>            :          set, the handler of the TRY_CATCH_EXPR is another cleanup which ought
<span class="lineNum">    1025 </span>            :          to be in an enclosing scope, but needs to be implemented at this level
<span class="lineNum">    1026 </span>            :          to avoid a nesting violation (see wrap_temporary_cleanups in
<span class="lineNum">    1027 </span>            :          cp/decl.c).  Since it's logically at an outer level, we should call
<span class="lineNum">    1028 </span>            :          terminate before we get to it, so strip it away before adding the
<span class="lineNum">    1029 </span>            :          MUST_NOT_THROW filter.  */
<span class="lineNum">    1030 </span><span class="lineCov">     329809 :       gimple_stmt_iterator gsi = gsi_start (finally);</span>
<span class="lineNum">    1031 </span><span class="lineCov">     329809 :       gimple *x = gsi_stmt (gsi);</span>
<span class="lineNum">    1032 </span><span class="lineCov">     329809 :       if (gimple_code (x) == GIMPLE_TRY</span>
<span class="lineNum">    1033 </span><span class="lineCov">      13206 :           &amp;&amp; gimple_try_kind (x) == GIMPLE_TRY_CATCH</span>
<span class="lineNum">    1034 </span><span class="lineCov">     343015 :           &amp;&amp; gimple_try_catch_is_cleanup (x))</span>
<span class="lineNum">    1035 </span>            :         {
<span class="lineNum">    1036 </span><span class="lineCov">      17010 :           gsi_insert_seq_before (&amp;gsi, gimple_try_eval (x), GSI_SAME_STMT);</span>
<span class="lineNum">    1037 </span><span class="lineCov">       8505 :           gsi_remove (&amp;gsi, false);</span>
<span class="lineNum">    1038 </span>            :         }
<span class="lineNum">    1039 </span>            : 
<span class="lineNum">    1040 </span>            :       /* Wrap the block with protect_cleanup_actions as the action.  */
<span class="lineNum">    1041 </span><span class="lineCov">     329809 :       geh_mnt *eh_mnt = gimple_build_eh_must_not_throw (actions);</span>
<span class="lineNum">    1042 </span><span class="lineCov">     329809 :       gtry *try_stmt = gimple_build_try (finally,</span>
<span class="lineNum">    1043 </span>            :                                          gimple_seq_alloc_with_stmt (eh_mnt),
<span class="lineNum">    1044 </span>            :                                          GIMPLE_TRY_CATCH);
<span class="lineNum">    1045 </span><span class="lineCov">     329809 :       finally = lower_eh_must_not_throw (outer_state, try_stmt);</span>
<span class="lineNum">    1046 </span>            :     }
<span class="lineNum">    1047 </span>            : 
<span class="lineNum">    1048 </span>            :   /* Drop all of this into the exception sequence.  */
<span class="lineNum">    1049 </span><span class="lineCov">     330051 :   emit_post_landing_pad (&amp;eh_seq, tf-&gt;region);</span>
<span class="lineNum">    1050 </span><span class="lineCov">     330051 :   gimple_seq_add_seq (&amp;eh_seq, finally);</span>
<span class="lineNum">    1051 </span><span class="lineCov">     330051 :   if (gimple_seq_may_fallthru (finally))</span>
<span class="lineNum">    1052 </span><span class="lineCov">     330051 :     emit_resx (&amp;eh_seq, tf-&gt;region);</span>
<span class="lineNum">    1053 </span>            : 
<span class="lineNum">    1054 </span>            :   /* Having now been handled, EH isn't to be considered with
<span class="lineNum">    1055 </span>            :      the rest of the outgoing edges.  */
<span class="lineNum">    1056 </span><span class="lineCov">     330051 :   tf-&gt;may_throw = false;</span>
<span class="lineNum">    1057 </span>            : }
<span class="lineNum">    1058 </span>            : 
<span class="lineNum">    1059 </span>            : /* A subroutine of lower_try_finally.  We have determined that there is
<span class="lineNum">    1060 </span>            :    no fallthru edge out of the finally block.  This means that there is
<span class="lineNum">    1061 </span>            :    no outgoing edge corresponding to any incoming edge.  Restructure the
<span class="lineNum">    1062 </span>            :    try_finally node for this special case.  */
<a name="1063"><span class="lineNum">    1063 </span>            : </a>
<span class="lineNum">    1064 </span>            : static void
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 : lower_try_finally_nofallthru (struct leh_state *state,</span>
<span class="lineNum">    1066 </span>            :                               struct leh_tf_state *tf)
<span class="lineNum">    1067 </span>            : {
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :   tree lab;</span>
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :   gimple *x;</span>
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :   geh_else *eh_else;</span>
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :   gimple_seq finally;</span>
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :   struct goto_queue_node *q, *qe;</span>
<span class="lineNum">    1073 </span>            : 
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :   lab = create_artificial_label (gimple_location (tf-&gt;try_finally_expr));</span>
<span class="lineNum">    1075 </span>            : 
<span class="lineNum">    1076 </span>            :   /* We expect that tf-&gt;top_p is a GIMPLE_TRY. */
<span class="lineNum">    1077 </span><span class="lineNoCov">          0 :   finally = gimple_try_cleanup (tf-&gt;top_p);</span>
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :   tf-&gt;top_p_seq = gimple_try_eval (tf-&gt;top_p);</span>
<span class="lineNum">    1079 </span>            : 
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :   x = gimple_build_label (lab);</span>
<span class="lineNum">    1081 </span><span class="lineNoCov">          0 :   gimple_seq_add_stmt (&amp;tf-&gt;top_p_seq, x);</span>
<span class="lineNum">    1082 </span>            : 
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 :   q = tf-&gt;goto_queue;</span>
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :   qe = q + tf-&gt;goto_queue_active;</span>
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :   for (; q &lt; qe; ++q)</span>
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :     if (q-&gt;index &lt; 0)</span>
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :       do_return_redirection (q, lab, NULL);</span>
<span class="lineNum">    1088 </span>            :     else
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :       do_goto_redirection (q, lab, NULL, tf);</span>
<span class="lineNum">    1090 </span>            : 
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 :   replace_goto_queue (tf);</span>
<span class="lineNum">    1092 </span>            : 
<span class="lineNum">    1093 </span>            :   /* Emit the finally block into the stream.  Lower EH_ELSE at this time.  */
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :   eh_else = get_eh_else (finally);</span>
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :   if (eh_else)</span>
<span class="lineNum">    1096 </span>            :     {
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :       finally = gimple_eh_else_n_body (eh_else);</span>
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :       lower_eh_constructs_1 (state, &amp;finally);</span>
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :       gimple_seq_add_seq (&amp;tf-&gt;top_p_seq, finally);</span>
<span class="lineNum">    1100 </span>            : 
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :       if (tf-&gt;may_throw)</span>
<span class="lineNum">    1102 </span>            :         {
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :           finally = gimple_eh_else_e_body (eh_else);</span>
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :           lower_eh_constructs_1 (state, &amp;finally);</span>
<span class="lineNum">    1105 </span>            : 
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :           emit_post_landing_pad (&amp;eh_seq, tf-&gt;region);</span>
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :           gimple_seq_add_seq (&amp;eh_seq, finally);</span>
<span class="lineNum">    1108 </span>            :         }
<span class="lineNum">    1109 </span>            :     }
<span class="lineNum">    1110 </span>            :   else
<span class="lineNum">    1111 </span>            :     {
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :       lower_eh_constructs_1 (state, &amp;finally);</span>
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :       gimple_seq_add_seq (&amp;tf-&gt;top_p_seq, finally);</span>
<span class="lineNum">    1114 </span>            : 
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :       if (tf-&gt;may_throw)</span>
<span class="lineNum">    1116 </span>            :         {
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :           emit_post_landing_pad (&amp;eh_seq, tf-&gt;region);</span>
<span class="lineNum">    1118 </span>            : 
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :           x = gimple_build_goto (lab);</span>
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :           gimple_set_location (x, gimple_location (tf-&gt;try_finally_expr));</span>
<span class="lineNum">    1121 </span><span class="lineNoCov">          0 :           gimple_seq_add_stmt (&amp;eh_seq, x);</span>
<span class="lineNum">    1122 </span>            :         }
<span class="lineNum">    1123 </span>            :     }
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1125 </span>            : 
<span class="lineNum">    1126 </span>            : /* A subroutine of lower_try_finally.  We have determined that there is
<span class="lineNum">    1127 </span>            :    exactly one destination of the finally block.  Restructure the
<span class="lineNum">    1128 </span>            :    try_finally node for this special case.  */
<a name="1129"><span class="lineNum">    1129 </span>            : </a>
<span class="lineNum">    1130 </span>            : static void
<span class="lineNum">    1131 </span><span class="lineCov">     751786 : lower_try_finally_onedest (struct leh_state *state, struct leh_tf_state *tf)</span>
<span class="lineNum">    1132 </span>            : {
<span class="lineNum">    1133 </span><span class="lineCov">     751786 :   struct goto_queue_node *q, *qe;</span>
<span class="lineNum">    1134 </span><span class="lineCov">     751786 :   geh_else *eh_else;</span>
<span class="lineNum">    1135 </span><span class="lineCov">     751786 :   glabel *label_stmt;</span>
<span class="lineNum">    1136 </span><span class="lineCov">     751786 :   gimple *x;</span>
<span class="lineNum">    1137 </span><span class="lineCov">     751786 :   gimple_seq finally;</span>
<span class="lineNum">    1138 </span><span class="lineCov">     751786 :   gimple_stmt_iterator gsi;</span>
<span class="lineNum">    1139 </span><span class="lineCov">     751786 :   tree finally_label;</span>
<span class="lineNum">    1140 </span><span class="lineCov">     751786 :   location_t loc = gimple_location (tf-&gt;try_finally_expr);</span>
<span class="lineNum">    1141 </span>            : 
<span class="lineNum">    1142 </span><span class="lineCov">     751786 :   finally = gimple_try_cleanup (tf-&gt;top_p);</span>
<span class="lineNum">    1143 </span><span class="lineCov">     751786 :   tf-&gt;top_p_seq = gimple_try_eval (tf-&gt;top_p);</span>
<span class="lineNum">    1144 </span>            : 
<span class="lineNum">    1145 </span>            :   /* Since there's only one destination, and the destination edge can only
<span class="lineNum">    1146 </span>            :      either be EH or non-EH, that implies that all of our incoming edges
<span class="lineNum">    1147 </span>            :      are of the same type.  Therefore we can lower EH_ELSE immediately.  */
<span class="lineNum">    1148 </span><span class="lineCov">     751786 :   eh_else = get_eh_else (finally);</span>
<span class="lineNum">    1149 </span><span class="lineCov">        246 :   if (eh_else)</span>
<span class="lineNum">    1150 </span>            :     {
<span class="lineNum">    1151 </span><span class="lineCov">        246 :       if (tf-&gt;may_throw)</span>
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :         finally = gimple_eh_else_e_body (eh_else);</span>
<span class="lineNum">    1153 </span>            :       else
<span class="lineNum">    1154 </span><span class="lineCov">        492 :         finally = gimple_eh_else_n_body (eh_else);</span>
<span class="lineNum">    1155 </span>            :     }
<span class="lineNum">    1156 </span>            : 
<span class="lineNum">    1157 </span><span class="lineCov">     751786 :   lower_eh_constructs_1 (state, &amp;finally);</span>
<span class="lineNum">    1158 </span>            : 
<span class="lineNum">    1159 </span><span class="lineCov">    2547919 :   for (gsi = gsi_start (finally); !gsi_end_p (gsi); gsi_next (&amp;gsi))</span>
<span class="lineNum">    1160 </span>            :     {
<span class="lineNum">    1161 </span><span class="lineCov">    1044347 :       gimple *stmt = gsi_stmt (gsi);</span>
<span class="lineNum">    1162 </span><span class="lineCov">    3133041 :       if (LOCATION_LOCUS (gimple_location (stmt)) == UNKNOWN_LOCATION)</span>
<span class="lineNum">    1163 </span>            :         {
<span class="lineNum">    1164 </span><span class="lineCov">     623796 :           tree block = gimple_block (stmt);</span>
<span class="lineNum">    1165 </span><span class="lineCov">    1247592 :           gimple_set_location (stmt, gimple_location (tf-&gt;try_finally_expr));</span>
<span class="lineNum">    1166 </span><span class="lineCov">     623796 :           gimple_set_block (stmt, block);</span>
<span class="lineNum">    1167 </span>            :         }
<span class="lineNum">    1168 </span>            :     }
<span class="lineNum">    1169 </span>            : 
<span class="lineNum">    1170 </span><span class="lineCov">     751786 :   if (tf-&gt;may_throw)</span>
<span class="lineNum">    1171 </span>            :     {
<span class="lineNum">    1172 </span>            :       /* Only reachable via the exception edge.  Add the given label to
<span class="lineNum">    1173 </span>            :          the head of the FINALLY block.  Append a RESX at the end.  */
<span class="lineNum">    1174 </span><span class="lineCov">        411 :       emit_post_landing_pad (&amp;eh_seq, tf-&gt;region);</span>
<span class="lineNum">    1175 </span><span class="lineCov">        411 :       gimple_seq_add_seq (&amp;eh_seq, finally);</span>
<span class="lineNum">    1176 </span><span class="lineCov">        411 :       emit_resx (&amp;eh_seq, tf-&gt;region);</span>
<span class="lineNum">    1177 </span><span class="lineCov">     567002 :       return;</span>
<span class="lineNum">    1178 </span>            :     }
<span class="lineNum">    1179 </span>            : 
<span class="lineNum">    1180 </span><span class="lineCov">     751375 :   if (tf-&gt;may_fallthru)</span>
<span class="lineNum">    1181 </span>            :     {
<span class="lineNum">    1182 </span>            :       /* Only reachable via the fallthru edge.  Do nothing but let
<span class="lineNum">    1183 </span>            :          the two blocks run together; we'll fall out the bottom.  */
<span class="lineNum">    1184 </span><span class="lineCov">     566591 :       gimple_seq_add_seq (&amp;tf-&gt;top_p_seq, finally);</span>
<span class="lineNum">    1185 </span><span class="lineCov">     566591 :       return;</span>
<span class="lineNum">    1186 </span>            :     }
<span class="lineNum">    1187 </span>            : 
<span class="lineNum">    1188 </span><span class="lineCov">     184784 :   finally_label = create_artificial_label (loc);</span>
<span class="lineNum">    1189 </span><span class="lineCov">     184784 :   label_stmt = gimple_build_label (finally_label);</span>
<span class="lineNum">    1190 </span><span class="lineCov">     184784 :   gimple_seq_add_stmt (&amp;tf-&gt;top_p_seq, label_stmt);</span>
<span class="lineNum">    1191 </span>            : 
<span class="lineNum">    1192 </span><span class="lineCov">     184784 :   gimple_seq_add_seq (&amp;tf-&gt;top_p_seq, finally);</span>
<span class="lineNum">    1193 </span>            : 
<span class="lineNum">    1194 </span><span class="lineCov">     184784 :   q = tf-&gt;goto_queue;</span>
<span class="lineNum">    1195 </span><span class="lineCov">     184784 :   qe = q + tf-&gt;goto_queue_active;</span>
<span class="lineNum">    1196 </span>            : 
<span class="lineNum">    1197 </span><span class="lineCov">     184784 :   if (tf-&gt;may_return)</span>
<span class="lineNum">    1198 </span>            :     {
<span class="lineNum">    1199 </span>            :       /* Reachable by return expressions only.  Redirect them.  */
<span class="lineNum">    1200 </span><span class="lineNoCov">          0 :       for (; q &lt; qe; ++q)</span>
<span class="lineNum">    1201 </span><span class="lineNoCov">          0 :         do_return_redirection (q, finally_label, NULL);</span>
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :       replace_goto_queue (tf);</span>
<span class="lineNum">    1203 </span>            :     }
<span class="lineNum">    1204 </span>            :   else
<span class="lineNum">    1205 </span>            :     {
<span class="lineNum">    1206 </span>            :       /* Reachable by goto expressions only.  Redirect them.  */
<span class="lineNum">    1207 </span><span class="lineCov">     400721 :       for (; q &lt; qe; ++q)</span>
<span class="lineNum">    1208 </span><span class="lineCov">     215937 :         do_goto_redirection (q, finally_label, NULL, tf);</span>
<span class="lineNum">    1209 </span><span class="lineCov">     184784 :       replace_goto_queue (tf);</span>
<span class="lineNum">    1210 </span>            : 
<span class="lineNum">    1211 </span><span class="lineCov">     184784 :       if (tf-&gt;dest_array[0] == tf-&gt;fallthru_label)</span>
<span class="lineNum">    1212 </span>            :         {
<span class="lineNum">    1213 </span>            :           /* Reachable by goto to fallthru label only.  Redirect it
<span class="lineNum">    1214 </span>            :              to the new label (already created, sadly), and do not
<span class="lineNum">    1215 </span>            :              emit the final branch out, or the fallthru label.  */
<span class="lineNum">    1216 </span><span class="lineNoCov">          0 :           tf-&gt;fallthru_label = NULL;</span>
<span class="lineNum">    1217 </span><span class="lineNoCov">          0 :           return;</span>
<span class="lineNum">    1218 </span>            :         }
<span class="lineNum">    1219 </span>            :     }
<span class="lineNum">    1220 </span>            : 
<span class="lineNum">    1221 </span>            :   /* Place the original return/goto to the original destination
<span class="lineNum">    1222 </span>            :      immediately after the finally block. */
<span class="lineNum">    1223 </span><span class="lineCov">     184784 :   x = tf-&gt;goto_queue[0].cont_stmt;</span>
<span class="lineNum">    1224 </span><span class="lineCov">     184784 :   gimple_seq_add_stmt (&amp;tf-&gt;top_p_seq, x);</span>
<span class="lineNum">    1225 </span><span class="lineCov">     184784 :   maybe_record_in_goto_queue (state, x);</span>
<span class="lineNum">    1226 </span>            : }
<span class="lineNum">    1227 </span>            : 
<span class="lineNum">    1228 </span>            : /* A subroutine of lower_try_finally.  There are multiple edges incoming
<span class="lineNum">    1229 </span>            :    and outgoing from the finally block.  Implement this by duplicating the
<span class="lineNum">    1230 </span>            :    finally block for every destination.  */
<a name="1231"><span class="lineNum">    1231 </span>            : </a>
<span class="lineNum">    1232 </span>            : static void
<span class="lineNum">    1233 </span><span class="lineCov">     129540 : lower_try_finally_copy (struct leh_state *state, struct leh_tf_state *tf)</span>
<span class="lineNum">    1234 </span>            : {
<span class="lineNum">    1235 </span><span class="lineCov">     129540 :   gimple_seq finally;</span>
<span class="lineNum">    1236 </span><span class="lineCov">     129540 :   gimple_seq new_stmt;</span>
<span class="lineNum">    1237 </span><span class="lineCov">     129540 :   gimple_seq seq;</span>
<span class="lineNum">    1238 </span><span class="lineCov">     129540 :   gimple *x;</span>
<span class="lineNum">    1239 </span><span class="lineCov">     129540 :   geh_else *eh_else;</span>
<span class="lineNum">    1240 </span><span class="lineCov">     129540 :   tree tmp;</span>
<span class="lineNum">    1241 </span><span class="lineCov">     129540 :   location_t tf_loc = gimple_location (tf-&gt;try_finally_expr);</span>
<span class="lineNum">    1242 </span>            : 
<span class="lineNum">    1243 </span><span class="lineCov">     129540 :   finally = gimple_try_cleanup (tf-&gt;top_p);</span>
<span class="lineNum">    1244 </span>            : 
<span class="lineNum">    1245 </span>            :   /* Notice EH_ELSE, and simplify some of the remaining code
<span class="lineNum">    1246 </span>            :      by considering FINALLY to be the normal return path only.  */
<span class="lineNum">    1247 </span><span class="lineCov">     129540 :   eh_else = get_eh_else (finally);</span>
<span class="lineNum">    1248 </span><span class="lineCov">          6 :   if (eh_else)</span>
<span class="lineNum">    1249 </span><span class="lineCov">         12 :     finally = gimple_eh_else_n_body (eh_else);</span>
<span class="lineNum">    1250 </span>            : 
<span class="lineNum">    1251 </span><span class="lineCov">     129540 :   tf-&gt;top_p_seq = gimple_try_eval (tf-&gt;top_p);</span>
<span class="lineNum">    1252 </span><span class="lineCov">     129540 :   new_stmt = NULL;</span>
<span class="lineNum">    1253 </span>            : 
<span class="lineNum">    1254 </span><span class="lineCov">     129540 :   if (tf-&gt;may_fallthru)</span>
<span class="lineNum">    1255 </span>            :     {
<span class="lineNum">    1256 </span><span class="lineCov">      66830 :       seq = lower_try_finally_dup_block (finally, state, tf_loc);</span>
<span class="lineNum">    1257 </span><span class="lineCov">      66830 :       lower_eh_constructs_1 (state, &amp;seq);</span>
<span class="lineNum">    1258 </span><span class="lineCov">      66830 :       gimple_seq_add_seq (&amp;new_stmt, seq);</span>
<span class="lineNum">    1259 </span>            : 
<span class="lineNum">    1260 </span><span class="lineCov">      66830 :       tmp = lower_try_finally_fallthru_label (tf);</span>
<span class="lineNum">    1261 </span><span class="lineCov">      66830 :       x = gimple_build_goto (tmp);</span>
<span class="lineNum">    1262 </span><span class="lineCov">      66830 :       gimple_set_location (x, tf_loc);</span>
<span class="lineNum">    1263 </span><span class="lineCov">      66830 :       gimple_seq_add_stmt (&amp;new_stmt, x);</span>
<span class="lineNum">    1264 </span>            :     }
<span class="lineNum">    1265 </span>            : 
<span class="lineNum">    1266 </span><span class="lineCov">     129540 :   if (tf-&gt;may_throw)</span>
<span class="lineNum">    1267 </span>            :     {
<span class="lineNum">    1268 </span>            :       /* We don't need to copy the EH path of EH_ELSE,
<span class="lineNum">    1269 </span>            :          since it is only emitted once.  */
<span class="lineNum">    1270 </span><span class="lineCov">     114348 :       if (eh_else)</span>
<span class="lineNum">    1271 </span><span class="lineNoCov">          0 :         seq = gimple_eh_else_e_body (eh_else);</span>
<span class="lineNum">    1272 </span>            :       else
<span class="lineNum">    1273 </span><span class="lineCov">     114348 :         seq = lower_try_finally_dup_block (finally, state, tf_loc);</span>
<span class="lineNum">    1274 </span><span class="lineCov">     114348 :       lower_eh_constructs_1 (state, &amp;seq);</span>
<span class="lineNum">    1275 </span>            : 
<span class="lineNum">    1276 </span><span class="lineCov">     114348 :       emit_post_landing_pad (&amp;eh_seq, tf-&gt;region);</span>
<span class="lineNum">    1277 </span><span class="lineCov">     114348 :       gimple_seq_add_seq (&amp;eh_seq, seq);</span>
<span class="lineNum">    1278 </span><span class="lineCov">     114348 :       emit_resx (&amp;eh_seq, tf-&gt;region);</span>
<span class="lineNum">    1279 </span>            :     }
<span class="lineNum">    1280 </span>            : 
<span class="lineNum">    1281 </span><span class="lineCov">     129540 :   if (tf-&gt;goto_queue)</span>
<span class="lineNum">    1282 </span>            :     {
<span class="lineNum">    1283 </span><span class="lineCov">      94716 :       struct goto_queue_node *q, *qe;</span>
<span class="lineNum">    1284 </span><span class="lineCov">      94716 :       int return_index, index;</span>
<span class="lineNum">    1285 </span><span class="lineCov">      94716 :       struct labels_s</span>
<span class="lineNum">    1286 </span>            :       {
<span class="lineNum">    1287 </span>            :         struct goto_queue_node *q;
<span class="lineNum">    1288 </span>            :         tree label;
<span class="lineNum">    1289 </span>            :       } *labels;
<span class="lineNum">    1290 </span>            : 
<span class="lineNum">    1291 </span><span class="lineCov">      94716 :       return_index = tf-&gt;dest_array.length ();</span>
<span class="lineNum">    1292 </span><span class="lineCov">      94716 :       labels = XCNEWVEC (struct labels_s, return_index + 1);</span>
<span class="lineNum">    1293 </span>            : 
<span class="lineNum">    1294 </span><span class="lineCov">      94716 :       q = tf-&gt;goto_queue;</span>
<span class="lineNum">    1295 </span><span class="lineCov">      94716 :       qe = q + tf-&gt;goto_queue_active;</span>
<span class="lineNum">    1296 </span><span class="lineCov">     257805 :       for (; q &lt; qe; q++)</span>
<span class="lineNum">    1297 </span>            :         {
<span class="lineNum">    1298 </span><span class="lineCov">     163089 :           index = q-&gt;index &lt; 0 ? return_index : q-&gt;index;</span>
<span class="lineNum">    1299 </span>            : 
<span class="lineNum">    1300 </span><span class="lineCov">     163089 :           if (!labels[index].q)</span>
<span class="lineNum">    1301 </span><span class="lineCov">      96580 :             labels[index].q = q;</span>
<span class="lineNum">    1302 </span>            :         }
<span class="lineNum">    1303 </span>            : 
<span class="lineNum">    1304 </span><span class="lineCov">     286012 :       for (index = 0; index &lt; return_index + 1; index++)</span>
<span class="lineNum">    1305 </span>            :         {
<span class="lineNum">    1306 </span><span class="lineCov">     191296 :           tree lab;</span>
<span class="lineNum">    1307 </span>            : 
<span class="lineNum">    1308 </span><span class="lineCov">     191296 :           q = labels[index].q;</span>
<span class="lineNum">    1309 </span><span class="lineCov">     191296 :           if (! q)</span>
<span class="lineNum">    1310 </span>            :             continue;
<span class="lineNum">    1311 </span>            : 
<span class="lineNum">    1312 </span><span class="lineCov">     193160 :           lab = labels[index].label</span>
<span class="lineNum">    1313 </span><span class="lineCov">      96580 :             = create_artificial_label (tf_loc);</span>
<span class="lineNum">    1314 </span>            : 
<span class="lineNum">    1315 </span><span class="lineCov">      96580 :           if (index == return_index)</span>
<span class="lineNum">    1316 </span><span class="lineNoCov">          0 :             do_return_redirection (q, lab, NULL);</span>
<span class="lineNum">    1317 </span>            :           else
<span class="lineNum">    1318 </span><span class="lineCov">      96580 :             do_goto_redirection (q, lab, NULL, tf);</span>
<span class="lineNum">    1319 </span>            : 
<span class="lineNum">    1320 </span><span class="lineCov">      96580 :           x = gimple_build_label (lab);</span>
<span class="lineNum">    1321 </span><span class="lineCov">      96580 :           gimple_seq_add_stmt (&amp;new_stmt, x);</span>
<span class="lineNum">    1322 </span>            : 
<span class="lineNum">    1323 </span><span class="lineCov">      96580 :           seq = lower_try_finally_dup_block (finally, state, q-&gt;location);</span>
<span class="lineNum">    1324 </span><span class="lineCov">      96580 :           lower_eh_constructs_1 (state, &amp;seq);</span>
<span class="lineNum">    1325 </span><span class="lineCov">      96580 :           gimple_seq_add_seq (&amp;new_stmt, seq);</span>
<span class="lineNum">    1326 </span>            : 
<span class="lineNum">    1327 </span><span class="lineCov">      96580 :           gimple_seq_add_stmt (&amp;new_stmt, q-&gt;cont_stmt);</span>
<span class="lineNum">    1328 </span><span class="lineCov">      96580 :           maybe_record_in_goto_queue (state, q-&gt;cont_stmt);</span>
<span class="lineNum">    1329 </span>            :         }
<span class="lineNum">    1330 </span>            : 
<span class="lineNum">    1331 </span><span class="lineCov">     257805 :       for (q = tf-&gt;goto_queue; q &lt; qe; q++)</span>
<span class="lineNum">    1332 </span>            :         {
<span class="lineNum">    1333 </span><span class="lineCov">     163089 :           tree lab;</span>
<span class="lineNum">    1334 </span>            : 
<span class="lineNum">    1335 </span><span class="lineCov">     163089 :           index = q-&gt;index &lt; 0 ? return_index : q-&gt;index;</span>
<span class="lineNum">    1336 </span>            : 
<span class="lineNum">    1337 </span><span class="lineCov">     163089 :           if (labels[index].q == q)</span>
<span class="lineNum">    1338 </span>            :             continue;
<span class="lineNum">    1339 </span>            : 
<span class="lineNum">    1340 </span><span class="lineCov">      66509 :           lab = labels[index].label;</span>
<span class="lineNum">    1341 </span>            : 
<span class="lineNum">    1342 </span><span class="lineCov">      66509 :           if (index == return_index)</span>
<span class="lineNum">    1343 </span><span class="lineNoCov">          0 :             do_return_redirection (q, lab, NULL);</span>
<span class="lineNum">    1344 </span>            :           else
<span class="lineNum">    1345 </span><span class="lineCov">      66509 :             do_goto_redirection (q, lab, NULL, tf);</span>
<span class="lineNum">    1346 </span>            :         }
<span class="lineNum">    1347 </span>            : 
<span class="lineNum">    1348 </span><span class="lineCov">      94716 :       replace_goto_queue (tf);</span>
<span class="lineNum">    1349 </span><span class="lineCov">      94716 :       free (labels);</span>
<span class="lineNum">    1350 </span>            :     }
<span class="lineNum">    1351 </span>            : 
<span class="lineNum">    1352 </span>            :   /* Need to link new stmts after running replace_goto_queue due
<span class="lineNum">    1353 </span>            :      to not wanting to process the same goto stmts twice.  */
<span class="lineNum">    1354 </span><span class="lineCov">     129540 :   gimple_seq_add_seq (&amp;tf-&gt;top_p_seq, new_stmt);</span>
<span class="lineNum">    1355 </span><span class="lineCov">     129540 : }</span>
<span class="lineNum">    1356 </span>            : 
<span class="lineNum">    1357 </span>            : /* A subroutine of lower_try_finally.  There are multiple edges incoming
<span class="lineNum">    1358 </span>            :    and outgoing from the finally block.  Implement this by instrumenting
<span class="lineNum">    1359 </span>            :    each incoming edge and creating a switch statement at the end of the
<span class="lineNum">    1360 </span>            :    finally block that branches to the appropriate destination.  */
<a name="1361"><span class="lineNum">    1361 </span>            : </a>
<span class="lineNum">    1362 </span>            : static void
<span class="lineNum">    1363 </span><span class="lineCov">        213 : lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)</span>
<span class="lineNum">    1364 </span>            : {
<span class="lineNum">    1365 </span><span class="lineCov">        213 :   struct goto_queue_node *q, *qe;</span>
<span class="lineNum">    1366 </span><span class="lineCov">        213 :   tree finally_tmp, finally_label;</span>
<span class="lineNum">    1367 </span><span class="lineCov">        213 :   int return_index, eh_index, fallthru_index;</span>
<span class="lineNum">    1368 </span><span class="lineCov">        213 :   int nlabels, ndests, j, last_case_index;</span>
<span class="lineNum">    1369 </span><span class="lineCov">        213 :   tree last_case;</span>
<span class="lineNum">    1370 </span><span class="lineCov">        213 :   auto_vec&lt;tree&gt; case_label_vec;</span>
<span class="lineNum">    1371 </span><span class="lineCov">        213 :   gimple_seq switch_body = NULL;</span>
<span class="lineNum">    1372 </span><span class="lineCov">        213 :   gimple *x;</span>
<span class="lineNum">    1373 </span><span class="lineCov">        213 :   geh_else *eh_else;</span>
<span class="lineNum">    1374 </span><span class="lineCov">        213 :   tree tmp;</span>
<span class="lineNum">    1375 </span><span class="lineCov">        213 :   gimple *switch_stmt;</span>
<span class="lineNum">    1376 </span><span class="lineCov">        213 :   gimple_seq finally;</span>
<span class="lineNum">    1377 </span><span class="lineCov">        213 :   hash_map&lt;tree, gimple *&gt; *cont_map = NULL;</span>
<span class="lineNum">    1378 </span>            :   /* The location of the TRY_FINALLY stmt.  */
<span class="lineNum">    1379 </span><span class="lineCov">        213 :   location_t tf_loc = gimple_location (tf-&gt;try_finally_expr);</span>
<span class="lineNum">    1380 </span>            :   /* The location of the finally block.  */
<span class="lineNum">    1381 </span><span class="lineCov">        213 :   location_t finally_loc;</span>
<span class="lineNum">    1382 </span>            : 
<span class="lineNum">    1383 </span><span class="lineCov">        213 :   finally = gimple_try_cleanup (tf-&gt;top_p);</span>
<span class="lineNum">    1384 </span><span class="lineCov">        213 :   eh_else = get_eh_else (finally);</span>
<span class="lineNum">    1385 </span>            : 
<span class="lineNum">    1386 </span>            :   /* Mash the TRY block to the head of the chain.  */
<span class="lineNum">    1387 </span><span class="lineCov">        213 :   tf-&gt;top_p_seq = gimple_try_eval (tf-&gt;top_p);</span>
<span class="lineNum">    1388 </span>            : 
<span class="lineNum">    1389 </span>            :   /* The location of the finally is either the last stmt in the finally
<span class="lineNum">    1390 </span>            :      block or the location of the TRY_FINALLY itself.  */
<span class="lineNum">    1391 </span><span class="lineCov">        213 :   x = gimple_seq_last_stmt (finally);</span>
<span class="lineNum">    1392 </span><span class="lineCov">        213 :   finally_loc = x ? gimple_location (x) : tf_loc;</span>
<span class="lineNum">    1393 </span>            : 
<span class="lineNum">    1394 </span>            :   /* Prepare for switch statement generation.  */
<span class="lineNum">    1395 </span><span class="lineCov">        213 :   nlabels = tf-&gt;dest_array.length ();</span>
<span class="lineNum">    1396 </span><span class="lineCov">        213 :   return_index = nlabels;</span>
<span class="lineNum">    1397 </span><span class="lineCov">        213 :   eh_index = return_index + tf-&gt;may_return;</span>
<span class="lineNum">    1398 </span><span class="lineCov">        213 :   fallthru_index = eh_index + (tf-&gt;may_throw &amp;&amp; !eh_else);</span>
<span class="lineNum">    1399 </span><span class="lineCov">        213 :   ndests = fallthru_index + tf-&gt;may_fallthru;</span>
<span class="lineNum">    1400 </span>            : 
<span class="lineNum">    1401 </span><span class="lineCov">        213 :   finally_tmp = create_tmp_var (integer_type_node, &quot;finally_tmp&quot;);</span>
<span class="lineNum">    1402 </span><span class="lineCov">        213 :   finally_label = create_artificial_label (finally_loc);</span>
<span class="lineNum">    1403 </span>            : 
<span class="lineNum">    1404 </span>            :   /* We use vec::quick_push on case_label_vec throughout this function,
<span class="lineNum">    1405 </span>            :      since we know the size in advance and allocate precisely as muce
<span class="lineNum">    1406 </span>            :      space as needed.  */
<span class="lineNum">    1407 </span><span class="lineCov">        213 :   case_label_vec.create (ndests);</span>
<span class="lineNum">    1408 </span><span class="lineCov">        213 :   last_case = NULL;</span>
<span class="lineNum">    1409 </span><span class="lineCov">        213 :   last_case_index = 0;</span>
<span class="lineNum">    1410 </span>            : 
<span class="lineNum">    1411 </span>            :   /* Begin inserting code for getting to the finally block.  Things
<span class="lineNum">    1412 </span>            :      are done in this order to correspond to the sequence the code is
<span class="lineNum">    1413 </span>            :      laid out.  */
<span class="lineNum">    1414 </span>            : 
<span class="lineNum">    1415 </span><span class="lineCov">        213 :   if (tf-&gt;may_fallthru)</span>
<span class="lineNum">    1416 </span>            :     {
<span class="lineNum">    1417 </span><span class="lineCov">        406 :       x = gimple_build_assign (finally_tmp,</span>
<span class="lineNum">    1418 </span>            :                                build_int_cst (integer_type_node,
<span class="lineNum">    1419 </span>            :                                               fallthru_index));
<span class="lineNum">    1420 </span><span class="lineCov">        203 :       gimple_set_location (x, finally_loc);</span>
<span class="lineNum">    1421 </span><span class="lineCov">        203 :       gimple_seq_add_stmt (&amp;tf-&gt;top_p_seq, x);</span>
<span class="lineNum">    1422 </span>            : 
<span class="lineNum">    1423 </span><span class="lineCov">        406 :       tmp = build_int_cst (integer_type_node, fallthru_index);</span>
<span class="lineNum">    1424 </span><span class="lineCov">        203 :       last_case = build_case_label (tmp, NULL,</span>
<span class="lineNum">    1425 </span>            :                                     create_artificial_label (finally_loc));
<span class="lineNum">    1426 </span><span class="lineCov">        203 :       case_label_vec.quick_push (last_case);</span>
<span class="lineNum">    1427 </span><span class="lineCov">        203 :       last_case_index++;</span>
<span class="lineNum">    1428 </span>            : 
<span class="lineNum">    1429 </span><span class="lineCov">        203 :       x = gimple_build_label (CASE_LABEL (last_case));</span>
<span class="lineNum">    1430 </span><span class="lineCov">        203 :       gimple_seq_add_stmt (&amp;switch_body, x);</span>
<span class="lineNum">    1431 </span>            : 
<span class="lineNum">    1432 </span><span class="lineCov">        203 :       tmp = lower_try_finally_fallthru_label (tf);</span>
<span class="lineNum">    1433 </span><span class="lineCov">        203 :       x = gimple_build_goto (tmp);</span>
<span class="lineNum">    1434 </span><span class="lineCov">        203 :       gimple_set_location (x, finally_loc);</span>
<span class="lineNum">    1435 </span><span class="lineCov">        203 :       gimple_seq_add_stmt (&amp;switch_body, x);</span>
<span class="lineNum">    1436 </span>            :     }
<span class="lineNum">    1437 </span>            : 
<span class="lineNum">    1438 </span>            :   /* For EH_ELSE, emit the exception path (plus resx) now, then
<span class="lineNum">    1439 </span>            :      subsequently we only need consider the normal path.  */
<span class="lineNum">    1440 </span><span class="lineCov">        213 :   if (eh_else)</span>
<span class="lineNum">    1441 </span>            :     {
<span class="lineNum">    1442 </span><span class="lineCov">          6 :       if (tf-&gt;may_throw)</span>
<span class="lineNum">    1443 </span>            :         {
<span class="lineNum">    1444 </span><span class="lineNoCov">          0 :           finally = gimple_eh_else_e_body (eh_else);</span>
<span class="lineNum">    1445 </span><span class="lineNoCov">          0 :           lower_eh_constructs_1 (state, &amp;finally);</span>
<span class="lineNum">    1446 </span>            : 
<span class="lineNum">    1447 </span><span class="lineNoCov">          0 :           emit_post_landing_pad (&amp;eh_seq, tf-&gt;region);</span>
<span class="lineNum">    1448 </span><span class="lineNoCov">          0 :           gimple_seq_add_seq (&amp;eh_seq, finally);</span>
<span class="lineNum">    1449 </span><span class="lineNoCov">          0 :           emit_resx (&amp;eh_seq, tf-&gt;region);</span>
<span class="lineNum">    1450 </span>            :         }
<span class="lineNum">    1451 </span>            : 
<span class="lineNum">    1452 </span><span class="lineCov">         12 :       finally = gimple_eh_else_n_body (eh_else);</span>
<span class="lineNum">    1453 </span>            :     }
<span class="lineNum">    1454 </span><span class="lineCov">        207 :   else if (tf-&gt;may_throw)</span>
<span class="lineNum">    1455 </span>            :     {
<span class="lineNum">    1456 </span><span class="lineCov">          7 :       emit_post_landing_pad (&amp;eh_seq, tf-&gt;region);</span>
<span class="lineNum">    1457 </span>            : 
<span class="lineNum">    1458 </span><span class="lineCov">         14 :       x = gimple_build_assign (finally_tmp,</span>
<span class="lineNum">    1459 </span>            :                                build_int_cst (integer_type_node, eh_index));
<span class="lineNum">    1460 </span><span class="lineCov">          7 :       gimple_seq_add_stmt (&amp;eh_seq, x);</span>
<span class="lineNum">    1461 </span>            : 
<span class="lineNum">    1462 </span><span class="lineCov">          7 :       x = gimple_build_goto (finally_label);</span>
<span class="lineNum">    1463 </span><span class="lineCov">          7 :       gimple_set_location (x, tf_loc);</span>
<span class="lineNum">    1464 </span><span class="lineCov">          7 :       gimple_seq_add_stmt (&amp;eh_seq, x);</span>
<span class="lineNum">    1465 </span>            : 
<span class="lineNum">    1466 </span><span class="lineCov">         14 :       tmp = build_int_cst (integer_type_node, eh_index);</span>
<span class="lineNum">    1467 </span><span class="lineCov">          7 :       last_case = build_case_label (tmp, NULL,</span>
<span class="lineNum">    1468 </span>            :                                     create_artificial_label (tf_loc));
<span class="lineNum">    1469 </span><span class="lineCov">          7 :       case_label_vec.quick_push (last_case);</span>
<span class="lineNum">    1470 </span><span class="lineCov">          7 :       last_case_index++;</span>
<span class="lineNum">    1471 </span>            : 
<span class="lineNum">    1472 </span><span class="lineCov">          7 :       x = gimple_build_label (CASE_LABEL (last_case));</span>
<span class="lineNum">    1473 </span><span class="lineCov">          7 :       gimple_seq_add_stmt (&amp;eh_seq, x);</span>
<span class="lineNum">    1474 </span><span class="lineCov">          7 :       emit_resx (&amp;eh_seq, tf-&gt;region);</span>
<span class="lineNum">    1475 </span>            :     }
<span class="lineNum">    1476 </span>            : 
<span class="lineNum">    1477 </span><span class="lineCov">        213 :   x = gimple_build_label (finally_label);</span>
<span class="lineNum">    1478 </span><span class="lineCov">        213 :   gimple_seq_add_stmt (&amp;tf-&gt;top_p_seq, x);</span>
<span class="lineNum">    1479 </span>            : 
<span class="lineNum">    1480 </span><span class="lineCov">        213 :   lower_eh_constructs_1 (state, &amp;finally);</span>
<span class="lineNum">    1481 </span><span class="lineCov">        213 :   gimple_seq_add_seq (&amp;tf-&gt;top_p_seq, finally);</span>
<span class="lineNum">    1482 </span>            : 
<span class="lineNum">    1483 </span>            :   /* Redirect each incoming goto edge.  */
<span class="lineNum">    1484 </span><span class="lineCov">        213 :   q = tf-&gt;goto_queue;</span>
<span class="lineNum">    1485 </span><span class="lineCov">        213 :   qe = q + tf-&gt;goto_queue_active;</span>
<span class="lineNum">    1486 </span><span class="lineCov">        213 :   j = last_case_index + tf-&gt;may_return;</span>
<span class="lineNum">    1487 </span>            :   /* Prepare the assignments to finally_tmp that are executed upon the
<span class="lineNum">    1488 </span>            :      entrance through a particular edge. */
<span class="lineNum">    1489 </span><span class="lineCov">        590 :   for (; q &lt; qe; ++q)</span>
<span class="lineNum">    1490 </span>            :     {
<span class="lineNum">    1491 </span><span class="lineCov">        377 :       gimple_seq mod = NULL;</span>
<span class="lineNum">    1492 </span><span class="lineCov">        377 :       int switch_id;</span>
<span class="lineNum">    1493 </span><span class="lineCov">        377 :       unsigned int case_index;</span>
<span class="lineNum">    1494 </span>            : 
<span class="lineNum">    1495 </span><span class="lineCov">        377 :       if (q-&gt;index &lt; 0)</span>
<span class="lineNum">    1496 </span>            :         {
<span class="lineNum">    1497 </span><span class="lineNoCov">          0 :           x = gimple_build_assign (finally_tmp,</span>
<span class="lineNum">    1498 </span>            :                                    build_int_cst (integer_type_node,
<span class="lineNum">    1499 </span>            :                                                   return_index));
<span class="lineNum">    1500 </span><span class="lineNoCov">          0 :           gimple_seq_add_stmt (&amp;mod, x);</span>
<span class="lineNum">    1501 </span><span class="lineNoCov">          0 :           do_return_redirection (q, finally_label, mod);</span>
<span class="lineNum">    1502 </span><span class="lineNoCov">          0 :           switch_id = return_index;</span>
<span class="lineNum">    1503 </span>            :         }
<span class="lineNum">    1504 </span>            :       else
<span class="lineNum">    1505 </span>            :         {
<span class="lineNum">    1506 </span><span class="lineCov">        377 :           x = gimple_build_assign (finally_tmp,</span>
<span class="lineNum">    1507 </span><span class="lineCov">        377 :                                    build_int_cst (integer_type_node, q-&gt;index));</span>
<span class="lineNum">    1508 </span><span class="lineCov">        377 :           gimple_seq_add_stmt (&amp;mod, x);</span>
<span class="lineNum">    1509 </span><span class="lineCov">        377 :           do_goto_redirection (q, finally_label, mod, tf);</span>
<span class="lineNum">    1510 </span><span class="lineCov">        377 :           switch_id = q-&gt;index;</span>
<span class="lineNum">    1511 </span>            :         }
<span class="lineNum">    1512 </span>            : 
<span class="lineNum">    1513 </span><span class="lineCov">        377 :       case_index = j + q-&gt;index;</span>
<span class="lineNum">    1514 </span><span class="lineCov">        754 :       if (case_label_vec.length () &lt;= case_index || !case_label_vec[case_index])</span>
<span class="lineNum">    1515 </span>            :         {
<span class="lineNum">    1516 </span><span class="lineCov">        217 :           tree case_lab;</span>
<span class="lineNum">    1517 </span><span class="lineCov">        434 :           tmp = build_int_cst (integer_type_node, switch_id);</span>
<span class="lineNum">    1518 </span><span class="lineCov">        217 :           case_lab = build_case_label (tmp, NULL,</span>
<span class="lineNum">    1519 </span>            :                                        create_artificial_label (tf_loc));
<span class="lineNum">    1520 </span>            :           /* We store the cont_stmt in the pointer map, so that we can recover
<span class="lineNum">    1521 </span>            :              it in the loop below.  */
<span class="lineNum">    1522 </span><span class="lineCov">        217 :           if (!cont_map)</span>
<span class="lineNum">    1523 </span><span class="lineCov">        207 :             cont_map = new hash_map&lt;tree, gimple *&gt;;</span>
<span class="lineNum">    1524 </span><span class="lineCov">        217 :           cont_map-&gt;put (case_lab, q-&gt;cont_stmt);</span>
<span class="lineNum">    1525 </span><span class="lineCov">        217 :           case_label_vec.quick_push (case_lab);</span>
<span class="lineNum">    1526 </span>            :         }
<span class="lineNum">    1527 </span>            :     }
<span class="lineNum">    1528 </span><span class="lineCov">        430 :   for (j = last_case_index; j &lt; last_case_index + nlabels; j++)</span>
<span class="lineNum">    1529 </span>            :     {
<span class="lineNum">    1530 </span><span class="lineCov">        217 :       gimple *cont_stmt;</span>
<span class="lineNum">    1531 </span>            : 
<span class="lineNum">    1532 </span><span class="lineCov">        217 :       last_case = case_label_vec[j];</span>
<span class="lineNum">    1533 </span>            : 
<span class="lineNum">    1534 </span><span class="lineCov">        217 :       gcc_assert (last_case);</span>
<span class="lineNum">    1535 </span><span class="lineCov">        217 :       gcc_assert (cont_map);</span>
<span class="lineNum">    1536 </span>            : 
<span class="lineNum">    1537 </span><span class="lineCov">        217 :       cont_stmt = *cont_map-&gt;get (last_case);</span>
<span class="lineNum">    1538 </span>            : 
<span class="lineNum">    1539 </span><span class="lineCov">        217 :       x = gimple_build_label (CASE_LABEL (last_case));</span>
<span class="lineNum">    1540 </span><span class="lineCov">        217 :       gimple_seq_add_stmt (&amp;switch_body, x);</span>
<span class="lineNum">    1541 </span><span class="lineCov">        217 :       gimple_seq_add_stmt (&amp;switch_body, cont_stmt);</span>
<span class="lineNum">    1542 </span><span class="lineCov">        217 :       maybe_record_in_goto_queue (state, cont_stmt);</span>
<span class="lineNum">    1543 </span>            :     }
<span class="lineNum">    1544 </span><span class="lineCov">        213 :   if (cont_map)</span>
<span class="lineNum">    1545 </span><span class="lineCov">        207 :     delete cont_map;</span>
<span class="lineNum">    1546 </span>            : 
<span class="lineNum">    1547 </span><span class="lineCov">        213 :   replace_goto_queue (tf);</span>
<span class="lineNum">    1548 </span>            : 
<span class="lineNum">    1549 </span>            :   /* Make sure that the last case is the default label, as one is required.
<span class="lineNum">    1550 </span>            :      Then sort the labels, which is also required in GIMPLE.  */
<span class="lineNum">    1551 </span><span class="lineCov">        213 :   CASE_LOW (last_case) = NULL;</span>
<span class="lineNum">    1552 </span><span class="lineCov">        213 :   tree tem = case_label_vec.pop ();</span>
<span class="lineNum">    1553 </span><span class="lineCov">        213 :   gcc_assert (tem == last_case);</span>
<span class="lineNum">    1554 </span><span class="lineCov">        213 :   sort_case_labels (case_label_vec);</span>
<span class="lineNum">    1555 </span>            : 
<span class="lineNum">    1556 </span>            :   /* Build the switch statement, setting last_case to be the default
<span class="lineNum">    1557 </span>            :      label.  */
<span class="lineNum">    1558 </span><span class="lineCov">        213 :   switch_stmt = gimple_build_switch (finally_tmp, last_case,</span>
<span class="lineNum">    1559 </span>            :                                      case_label_vec);
<span class="lineNum">    1560 </span><span class="lineCov">        213 :   gimple_set_location (switch_stmt, finally_loc);</span>
<span class="lineNum">    1561 </span>            : 
<span class="lineNum">    1562 </span>            :   /* Need to link SWITCH_STMT after running replace_goto_queue
<span class="lineNum">    1563 </span>            :      due to not wanting to process the same goto stmts twice.  */
<span class="lineNum">    1564 </span><span class="lineCov">        213 :   gimple_seq_add_stmt (&amp;tf-&gt;top_p_seq, switch_stmt);</span>
<span class="lineNum">    1565 </span><span class="lineCov">        213 :   gimple_seq_add_seq (&amp;tf-&gt;top_p_seq, switch_body);</span>
<span class="lineNum">    1566 </span><span class="lineCov">        213 : }</span>
<span class="lineNum">    1567 </span>            : 
<span class="lineNum">    1568 </span>            : /* Decide whether or not we are going to duplicate the finally block.
<span class="lineNum">    1569 </span>            :    There are several considerations.
<span class="lineNum">    1570 </span>            : 
<span class="lineNum">    1571 </span>            :    Second, we'd like to prevent egregious code growth.  One way to
<span class="lineNum">    1572 </span>            :    do this is to estimate the size of the finally block, multiply
<span class="lineNum">    1573 </span>            :    that by the number of copies we'd need to make, and compare against
<span class="lineNum">    1574 </span>            :    the estimate of the size of the switch machinery we'd have to add.  */
<a name="1575"><span class="lineNum">    1575 </span>            : </a>
<span class="lineNum">    1576 </span>            : static bool
<span class="lineNum">    1577 </span><span class="lineCov">     129753 : decide_copy_try_finally (int ndests, bool may_throw, gimple_seq finally)</span>
<span class="lineNum">    1578 </span>            : {
<span class="lineNum">    1579 </span><span class="lineCov">     129753 :   int f_estimate, sw_estimate;</span>
<span class="lineNum">    1580 </span><span class="lineCov">     129753 :   geh_else *eh_else;</span>
<span class="lineNum">    1581 </span>            : 
<span class="lineNum">    1582 </span>            :   /* If there's an EH_ELSE involved, the exception path is separate
<span class="lineNum">    1583 </span>            :      and really doesn't come into play for this computation.  */
<span class="lineNum">    1584 </span><span class="lineCov">     129753 :   eh_else = get_eh_else (finally);</span>
<span class="lineNum">    1585 </span><span class="lineCov">         12 :   if (eh_else)</span>
<span class="lineNum">    1586 </span>            :     {
<span class="lineNum">    1587 </span><span class="lineCov">         12 :       ndests -= may_throw;</span>
<span class="lineNum">    1588 </span><span class="lineCov">         24 :       finally = gimple_eh_else_n_body (eh_else);</span>
<span class="lineNum">    1589 </span>            :     }
<span class="lineNum">    1590 </span>            : 
<span class="lineNum">    1591 </span><span class="lineCov">     129753 :   if (!optimize)</span>
<span class="lineNum">    1592 </span>            :     {
<span class="lineNum">    1593 </span><span class="lineCov">      10548 :       gimple_stmt_iterator gsi;</span>
<span class="lineNum">    1594 </span>            : 
<span class="lineNum">    1595 </span><span class="lineCov">      10548 :       if (ndests == 1)</span>
<span class="lineNum">    1596 </span>            :         return true;
<span class="lineNum">    1597 </span>            : 
<span class="lineNum">    1598 </span><span class="lineCov">      33548 :       for (gsi = gsi_start (finally); !gsi_end_p (gsi); gsi_next (&amp;gsi))</span>
<span class="lineNum">    1599 </span>            :         {
<span class="lineNum">    1600 </span>            :           /* Duplicate __builtin_stack_restore in the hope of eliminating it
<span class="lineNum">    1601 </span>            :              on the EH paths and, consequently, useless cleanups.  */
<span class="lineNum">    1602 </span><span class="lineCov">      12662 :           gimple *stmt = gsi_stmt (gsi);</span>
<span class="lineNum">    1603 </span><span class="lineCov">      12662 :           if (!is_gimple_debug (stmt)</span>
<span class="lineNum">    1604 </span><span class="lineCov">      12662 :               &amp;&amp; !gimple_clobber_p (stmt)</span>
<span class="lineNum">    1605 </span><span class="lineCov">      12980 :               &amp;&amp; !gimple_call_builtin_p (stmt, BUILT_IN_STACK_RESTORE))</span>
<span class="lineNum">    1606 </span>            :             return false;
<span class="lineNum">    1607 </span>            :         }
<span class="lineNum">    1608 </span>            :       return true;
<span class="lineNum">    1609 </span>            :     }
<span class="lineNum">    1610 </span>            : 
<span class="lineNum">    1611 </span>            :   /* Finally estimate N times, plus N gotos.  */
<span class="lineNum">    1612 </span><span class="lineCov">     119205 :   f_estimate = estimate_num_insns_seq (finally, &amp;eni_size_weights);</span>
<span class="lineNum">    1613 </span><span class="lineCov">     119205 :   f_estimate = (f_estimate + 1) * ndests;</span>
<span class="lineNum">    1614 </span>            : 
<span class="lineNum">    1615 </span>            :   /* Switch statement (cost 10), N variable assignments, N gotos.  */
<span class="lineNum">    1616 </span><span class="lineCov">     119205 :   sw_estimate = 10 + 2 * ndests;</span>
<span class="lineNum">    1617 </span>            : 
<span class="lineNum">    1618 </span>            :   /* Optimize for size clearly wants our best guess.  */
<span class="lineNum">    1619 </span><span class="lineCov">     119205 :   if (optimize_function_for_size_p (cfun))</span>
<span class="lineNum">    1620 </span><span class="lineCov">        329 :     return f_estimate &lt; sw_estimate;</span>
<span class="lineNum">    1621 </span>            : 
<span class="lineNum">    1622 </span>            :   /* ??? These numbers are completely made up so far.  */
<span class="lineNum">    1623 </span><span class="lineCov">     118876 :   if (optimize &gt; 1)</span>
<span class="lineNum">    1624 </span><span class="lineCov">     118275 :     return f_estimate &lt; 100 || f_estimate &lt; sw_estimate * 2;</span>
<span class="lineNum">    1625 </span>            :   else
<span class="lineNum">    1626 </span><span class="lineCov">        603 :     return f_estimate &lt; 40 || f_estimate * 2 &lt; sw_estimate * 3;</span>
<span class="lineNum">    1627 </span>            : }
<span class="lineNum">    1628 </span>            : 
<span class="lineNum">    1629 </span>            : /* REG is the enclosing region for a possible cleanup region, or the region
<span class="lineNum">    1630 </span>            :    itself.  Returns TRUE if such a region would be unreachable.
<span class="lineNum">    1631 </span>            : 
<span class="lineNum">    1632 </span>            :    Cleanup regions within a must-not-throw region aren't actually reachable
<span class="lineNum">    1633 </span>            :    even if there are throwing stmts within them, because the personality
<span class="lineNum">    1634 </span>            :    routine will call terminate before unwinding.  */
<a name="1635"><span class="lineNum">    1635 </span>            : </a>
<span class="lineNum">    1636 </span>            : static bool
<span class="lineNum">    1637 </span><span class="lineNoCov">          0 : cleanup_is_dead_in (eh_region reg)</span>
<span class="lineNum">    1638 </span>            : {
<span class="lineNum">    1639 </span><span class="lineCov">   25769014 :   while (reg &amp;&amp; reg-&gt;type == ERT_CLEANUP)</span>
<span class="lineNum">    1640 </span><span class="lineCov">   24959298 :     reg = reg-&gt;outer;</span>
<span class="lineNum">    1641 </span><span class="lineCov">     809716 :   return (reg &amp;&amp; reg-&gt;type == ERT_MUST_NOT_THROW);</span>
<span class="lineNum">    1642 </span>            : }
<span class="lineNum">    1643 </span>            : 
<span class="lineNum">    1644 </span>            : /* A subroutine of lower_eh_constructs_1.  Lower a GIMPLE_TRY_FINALLY nodes
<span class="lineNum">    1645 </span>            :    to a sequence of labels and blocks, plus the exception region trees
<span class="lineNum">    1646 </span>            :    that record all the magic.  This is complicated by the need to
<span class="lineNum">    1647 </span>            :    arrange for the FINALLY block to be executed on all exits.  */
<a name="1648"><span class="lineNum">    1648 </span>            : </a>
<span class="lineNum">    1649 </span>            : static gimple_seq
<span class="lineNum">    1650 </span><span class="lineCov">     903312 : lower_try_finally (struct leh_state *state, gtry *tp)</span>
<span class="lineNum">    1651 </span>            : {
<span class="lineNum">    1652 </span><span class="lineCov">     903312 :   struct leh_tf_state this_tf;</span>
<span class="lineNum">    1653 </span><span class="lineCov">     903312 :   struct leh_state this_state;</span>
<span class="lineNum">    1654 </span><span class="lineCov">     903312 :   int ndests;</span>
<span class="lineNum">    1655 </span><span class="lineCov">     903312 :   gimple_seq old_eh_seq;</span>
<span class="lineNum">    1656 </span>            : 
<span class="lineNum">    1657 </span>            :   /* Process the try block.  */
<span class="lineNum">    1658 </span>            : 
<span class="lineNum">    1659 </span><span class="lineCov">     903312 :   memset (&amp;this_tf, 0, sizeof (this_tf));</span>
<span class="lineNum">    1660 </span><span class="lineCov">     903312 :   this_tf.try_finally_expr = tp;</span>
<span class="lineNum">    1661 </span><span class="lineCov">     903312 :   this_tf.top_p = tp;</span>
<span class="lineNum">    1662 </span><span class="lineCov">     903312 :   this_tf.outer = state;</span>
<span class="lineNum">    1663 </span><span class="lineCov">     903312 :   if (using_eh_for_cleanups_p () &amp;&amp; !cleanup_is_dead_in (state-&gt;cur_region))</span>
<span class="lineNum">    1664 </span>            :     {
<span class="lineNum">    1665 </span><span class="lineCov">     582188 :       this_tf.region = gen_eh_region_cleanup (state-&gt;cur_region);</span>
<span class="lineNum">    1666 </span><span class="lineCov">     582188 :       this_state.cur_region = this_tf.region;</span>
<span class="lineNum">    1667 </span>            :     }
<span class="lineNum">    1668 </span>            :   else
<span class="lineNum">    1669 </span>            :     {
<span class="lineNum">    1670 </span><span class="lineCov">     321124 :       this_tf.region = NULL;</span>
<span class="lineNum">    1671 </span><span class="lineCov">     321124 :       this_state.cur_region = state-&gt;cur_region;</span>
<span class="lineNum">    1672 </span>            :     }
<span class="lineNum">    1673 </span>            : 
<span class="lineNum">    1674 </span><span class="lineCov">     903312 :   this_state.ehp_region = state-&gt;ehp_region;</span>
<span class="lineNum">    1675 </span><span class="lineCov">     903312 :   this_state.tf = &amp;this_tf;</span>
<span class="lineNum">    1676 </span>            : 
<span class="lineNum">    1677 </span><span class="lineCov">     903312 :   old_eh_seq = eh_seq;</span>
<span class="lineNum">    1678 </span><span class="lineCov">     903312 :   eh_seq = NULL;</span>
<span class="lineNum">    1679 </span>            : 
<span class="lineNum">    1680 </span><span class="lineCov">     903312 :   lower_eh_constructs_1 (&amp;this_state, gimple_try_eval_ptr (tp));</span>
<span class="lineNum">    1681 </span>            : 
<span class="lineNum">    1682 </span>            :   /* Determine if the try block is escaped through the bottom.  */
<span class="lineNum">    1683 </span><span class="lineCov">     903312 :   this_tf.may_fallthru = gimple_seq_may_fallthru (gimple_try_eval (tp));</span>
<span class="lineNum">    1684 </span>            : 
<span class="lineNum">    1685 </span>            :   /* Determine if any exceptions are possible within the try block.  */
<span class="lineNum">    1686 </span><span class="lineCov">     903312 :   if (this_tf.region)</span>
<span class="lineNum">    1687 </span><span class="lineCov">    1164376 :     this_tf.may_throw = eh_region_may_contain_throw (this_tf.region);</span>
<span class="lineNum">    1688 </span><span class="lineCov">     903312 :   if (this_tf.may_throw)</span>
<span class="lineNum">    1689 </span><span class="lineCov">     392169 :     honor_protect_cleanup_actions (state, &amp;this_state, &amp;this_tf);</span>
<span class="lineNum">    1690 </span>            : 
<span class="lineNum">    1691 </span>            :   /* Determine how many edges (still) reach the finally block.  Or rather,
<span class="lineNum">    1692 </span>            :      how many destinations are reached by the finally block.  Use this to
<span class="lineNum">    1693 </span>            :      determine how we process the finally block itself.  */
<span class="lineNum">    1694 </span>            : 
<span class="lineNum">    1695 </span><span class="lineCov">     903312 :   ndests = this_tf.dest_array.length ();</span>
<span class="lineNum">    1696 </span><span class="lineCov">     903312 :   ndests += this_tf.may_fallthru;</span>
<span class="lineNum">    1697 </span><span class="lineCov">     903312 :   ndests += this_tf.may_return;</span>
<span class="lineNum">    1698 </span><span class="lineCov">     903312 :   ndests += this_tf.may_throw;</span>
<span class="lineNum">    1699 </span>            : 
<span class="lineNum">    1700 </span>            :   /* If the FINALLY block is not reachable, dike it out.  */
<span class="lineNum">    1701 </span><span class="lineCov">     903312 :   if (ndests == 0)</span>
<span class="lineNum">    1702 </span>            :     {
<span class="lineNum">    1703 </span><span class="lineCov">      21773 :       gimple_seq_add_seq (&amp;this_tf.top_p_seq, gimple_try_eval (tp));</span>
<span class="lineNum">    1704 </span><span class="lineCov">      21773 :       gimple_try_set_cleanup (tp, NULL);</span>
<span class="lineNum">    1705 </span>            :     }
<span class="lineNum">    1706 </span>            :   /* If the finally block doesn't fall through, then any destination
<span class="lineNum">    1707 </span>            :      we might try to impose there isn't reached either.  There may be
<span class="lineNum">    1708 </span>            :      some minor amount of cleanup and redirection still needed.  */
<span class="lineNum">    1709 </span><span class="lineCov">     881539 :   else if (!gimple_seq_may_fallthru (gimple_try_cleanup (tp)))</span>
<span class="lineNum">    1710 </span><span class="lineNoCov">          0 :     lower_try_finally_nofallthru (state, &amp;this_tf);</span>
<span class="lineNum">    1711 </span>            : 
<span class="lineNum">    1712 </span>            :   /* We can easily special-case redirection to a single destination.  */
<span class="lineNum">    1713 </span><span class="lineCov">     881539 :   else if (ndests == 1)</span>
<span class="lineNum">    1714 </span><span class="lineCov">     751786 :     lower_try_finally_onedest (state, &amp;this_tf);</span>
<span class="lineNum">    1715 </span><span class="lineCov">     129753 :   else if (decide_copy_try_finally (ndests, this_tf.may_throw,</span>
<span class="lineNum">    1716 </span>            :                                     gimple_try_cleanup (tp)))
<span class="lineNum">    1717 </span><span class="lineCov">     129540 :     lower_try_finally_copy (state, &amp;this_tf);</span>
<span class="lineNum">    1718 </span>            :   else
<span class="lineNum">    1719 </span><span class="lineCov">        213 :     lower_try_finally_switch (state, &amp;this_tf);</span>
<span class="lineNum">    1720 </span>            : 
<span class="lineNum">    1721 </span>            :   /* If someone requested we add a label at the end of the transformed
<span class="lineNum">    1722 </span>            :      block, do so.  */
<span class="lineNum">    1723 </span><span class="lineCov">     903312 :   if (this_tf.fallthru_label)</span>
<span class="lineNum">    1724 </span>            :     {
<span class="lineNum">    1725 </span>            :       /* This must be reached only if ndests == 0. */
<span class="lineNum">    1726 </span><span class="lineCov">      67033 :       gimple *x = gimple_build_label (this_tf.fallthru_label);</span>
<span class="lineNum">    1727 </span><span class="lineCov">      67033 :       gimple_seq_add_stmt (&amp;this_tf.top_p_seq, x);</span>
<span class="lineNum">    1728 </span>            :     }
<span class="lineNum">    1729 </span>            : 
<span class="lineNum">    1730 </span><span class="lineCov">     903312 :   this_tf.dest_array.release ();</span>
<span class="lineNum">    1731 </span><span class="lineCov">     903312 :   free (this_tf.goto_queue);</span>
<span class="lineNum">    1732 </span><span class="lineCov">     903312 :   if (this_tf.goto_queue_map)</span>
<span class="lineNum">    1733 </span><span class="lineCov">        204 :     delete this_tf.goto_queue_map;</span>
<span class="lineNum">    1734 </span>            : 
<span class="lineNum">    1735 </span>            :   /* If there was an old (aka outer) eh_seq, append the current eh_seq.
<span class="lineNum">    1736 </span>            :      If there was no old eh_seq, then the append is trivially already done.  */
<span class="lineNum">    1737 </span><span class="lineCov">     903312 :   if (old_eh_seq)</span>
<span class="lineNum">    1738 </span>            :     {
<span class="lineNum">    1739 </span><span class="lineCov">      57441 :       if (eh_seq == NULL)</span>
<span class="lineNum">    1740 </span><span class="lineCov">       6774 :         eh_seq = old_eh_seq;</span>
<span class="lineNum">    1741 </span>            :       else
<span class="lineNum">    1742 </span>            :         {
<span class="lineNum">    1743 </span><span class="lineCov">      50667 :           gimple_seq new_eh_seq = eh_seq;</span>
<span class="lineNum">    1744 </span><span class="lineCov">      50667 :           eh_seq = old_eh_seq;</span>
<span class="lineNum">    1745 </span><span class="lineCov">      50667 :           gimple_seq_add_seq (&amp;eh_seq, new_eh_seq);</span>
<span class="lineNum">    1746 </span>            :         }
<span class="lineNum">    1747 </span>            :     }
<span class="lineNum">    1748 </span>            : 
<span class="lineNum">    1749 </span><span class="lineCov">     903312 :   return this_tf.top_p_seq;</span>
<span class="lineNum">    1750 </span>            : }
<span class="lineNum">    1751 </span>            : 
<span class="lineNum">    1752 </span>            : /* A subroutine of lower_eh_constructs_1.  Lower a GIMPLE_TRY_CATCH with a
<span class="lineNum">    1753 </span>            :    list of GIMPLE_CATCH to a sequence of labels and blocks, plus the
<span class="lineNum">    1754 </span>            :    exception region trees that records all the magic.  */
<a name="1755"><span class="lineNum">    1755 </span>            : </a>
<span class="lineNum">    1756 </span>            : static gimple_seq
<span class="lineNum">    1757 </span><span class="lineCov">      37247 : lower_catch (struct leh_state *state, gtry *tp)</span>
<span class="lineNum">    1758 </span>            : {
<span class="lineNum">    1759 </span><span class="lineCov">      37247 :   eh_region try_region = NULL;</span>
<span class="lineNum">    1760 </span><span class="lineCov">      37247 :   struct leh_state this_state = *state;</span>
<span class="lineNum">    1761 </span><span class="lineCov">      37247 :   gimple_stmt_iterator gsi;</span>
<span class="lineNum">    1762 </span><span class="lineCov">      37247 :   tree out_label;</span>
<span class="lineNum">    1763 </span><span class="lineCov">      37247 :   gimple_seq new_seq, cleanup;</span>
<span class="lineNum">    1764 </span><span class="lineCov">      37247 :   gimple *x;</span>
<span class="lineNum">    1765 </span><span class="lineCov">      37247 :   location_t try_catch_loc = gimple_location (tp);</span>
<span class="lineNum">    1766 </span>            : 
<span class="lineNum">    1767 </span><span class="lineCov">      37247 :   if (flag_exceptions)</span>
<span class="lineNum">    1768 </span>            :     {
<span class="lineNum">    1769 </span><span class="lineCov">      37244 :       try_region = gen_eh_region_try (state-&gt;cur_region);</span>
<span class="lineNum">    1770 </span><span class="lineCov">      37244 :       this_state.cur_region = try_region;</span>
<span class="lineNum">    1771 </span>            :     }
<span class="lineNum">    1772 </span>            : 
<span class="lineNum">    1773 </span><span class="lineCov">      37247 :   lower_eh_constructs_1 (&amp;this_state, gimple_try_eval_ptr (tp));</span>
<span class="lineNum">    1774 </span>            : 
<span class="lineNum">    1775 </span><span class="lineCov">      37247 :   if (!eh_region_may_contain_throw (try_region))</span>
<span class="lineNum">    1776 </span><span class="lineCov">       2005 :     return gimple_try_eval (tp);</span>
<span class="lineNum">    1777 </span>            : 
<span class="lineNum">    1778 </span><span class="lineCov">      35242 :   new_seq = NULL;</span>
<span class="lineNum">    1779 </span><span class="lineCov">      35242 :   emit_eh_dispatch (&amp;new_seq, try_region);</span>
<span class="lineNum">    1780 </span><span class="lineCov">      35242 :   emit_resx (&amp;new_seq, try_region);</span>
<span class="lineNum">    1781 </span>            : 
<span class="lineNum">    1782 </span><span class="lineCov">      35242 :   this_state.cur_region = state-&gt;cur_region;</span>
<span class="lineNum">    1783 </span><span class="lineCov">      35242 :   this_state.ehp_region = try_region;</span>
<span class="lineNum">    1784 </span>            : 
<span class="lineNum">    1785 </span>            :   /* Add eh_seq from lowering EH in the cleanup sequence after the cleanup
<span class="lineNum">    1786 </span>            :      itself, so that e.g. for coverage purposes the nested cleanups don't
<span class="lineNum">    1787 </span>            :      appear before the cleanup body.  See PR64634 for details.  */
<span class="lineNum">    1788 </span><span class="lineCov">      35242 :   gimple_seq old_eh_seq = eh_seq;</span>
<span class="lineNum">    1789 </span><span class="lineCov">      35242 :   eh_seq = NULL;</span>
<span class="lineNum">    1790 </span>            : 
<span class="lineNum">    1791 </span><span class="lineCov">      35242 :   out_label = NULL;</span>
<span class="lineNum">    1792 </span><span class="lineCov">      35242 :   cleanup = gimple_try_cleanup (tp);</span>
<span class="lineNum">    1793 </span><span class="lineCov">      70484 :   for (gsi = gsi_start (cleanup);</span>
<span class="lineNum">    1794 </span><span class="lineCov">      79278 :        !gsi_end_p (gsi);</span>
<span class="lineNum">    1795 </span><span class="lineCov">       4397 :        gsi_next (&amp;gsi))</span>
<span class="lineNum">    1796 </span>            :     {
<span class="lineNum">    1797 </span><span class="lineCov">      37762 :       eh_catch c;</span>
<span class="lineNum">    1798 </span><span class="lineCov">      37762 :       gcatch *catch_stmt;</span>
<span class="lineNum">    1799 </span><span class="lineCov">      37762 :       gimple_seq handler;</span>
<span class="lineNum">    1800 </span>            : 
<span class="lineNum">    1801 </span><span class="lineCov">      75524 :       catch_stmt = as_a &lt;gcatch *&gt; (gsi_stmt (gsi));</span>
<span class="lineNum">    1802 </span><span class="lineCov">      75524 :       c = gen_eh_region_catch (try_region, gimple_catch_types (catch_stmt));</span>
<span class="lineNum">    1803 </span>            : 
<span class="lineNum">    1804 </span><span class="lineCov">      37762 :       handler = gimple_catch_handler (catch_stmt);</span>
<span class="lineNum">    1805 </span><span class="lineCov">      37762 :       lower_eh_constructs_1 (&amp;this_state, &amp;handler);</span>
<span class="lineNum">    1806 </span>            : 
<span class="lineNum">    1807 </span><span class="lineCov">      37762 :       c-&gt;label = create_artificial_label (UNKNOWN_LOCATION);</span>
<span class="lineNum">    1808 </span><span class="lineCov">      37762 :       x = gimple_build_label (c-&gt;label);</span>
<span class="lineNum">    1809 </span><span class="lineCov">      37762 :       gimple_seq_add_stmt (&amp;new_seq, x);</span>
<span class="lineNum">    1810 </span>            : 
<span class="lineNum">    1811 </span><span class="lineCov">      37762 :       gimple_seq_add_seq (&amp;new_seq, handler);</span>
<span class="lineNum">    1812 </span>            : 
<span class="lineNum">    1813 </span><span class="lineCov">      37762 :       if (gimple_seq_may_fallthru (new_seq))</span>
<span class="lineNum">    1814 </span>            :         {
<span class="lineNum">    1815 </span><span class="lineCov">       7741 :           if (!out_label)</span>
<span class="lineNum">    1816 </span><span class="lineCov">       7382 :             out_label = create_artificial_label (try_catch_loc);</span>
<span class="lineNum">    1817 </span>            : 
<span class="lineNum">    1818 </span><span class="lineCov">       7741 :           x = gimple_build_goto (out_label);</span>
<span class="lineNum">    1819 </span><span class="lineCov">       7741 :           gimple_seq_add_stmt (&amp;new_seq, x);</span>
<span class="lineNum">    1820 </span>            :         }
<span class="lineNum">    1821 </span><span class="lineCov">      37762 :       if (!c-&gt;type_list)</span>
<span class="lineNum">    1822 </span>            :         break;
<span class="lineNum">    1823 </span>            :     }
<span class="lineNum">    1824 </span>            : 
<span class="lineNum">    1825 </span><span class="lineCov">      35242 :   gimple_try_set_cleanup (tp, new_seq);</span>
<span class="lineNum">    1826 </span>            : 
<span class="lineNum">    1827 </span><span class="lineCov">      35242 :   gimple_seq new_eh_seq = eh_seq;</span>
<span class="lineNum">    1828 </span><span class="lineCov">      35242 :   eh_seq = old_eh_seq;</span>
<span class="lineNum">    1829 </span><span class="lineCov">      35242 :   gimple_seq ret_seq = frob_into_branch_around (tp, try_region, out_label);</span>
<span class="lineNum">    1830 </span><span class="lineCov">      35242 :   gimple_seq_add_seq (&amp;eh_seq, new_eh_seq);</span>
<span class="lineNum">    1831 </span><span class="lineCov">      35242 :   return ret_seq;</span>
<span class="lineNum">    1832 </span>            : }
<span class="lineNum">    1833 </span>            : 
<span class="lineNum">    1834 </span>            : /* A subroutine of lower_eh_constructs_1.  Lower a GIMPLE_TRY with a
<span class="lineNum">    1835 </span>            :    GIMPLE_EH_FILTER to a sequence of labels and blocks, plus the exception
<span class="lineNum">    1836 </span>            :    region trees that record all the magic.  */
<a name="1837"><span class="lineNum">    1837 </span>            : </a>
<span class="lineNum">    1838 </span>            : static gimple_seq
<span class="lineNum">    1839 </span><span class="lineCov">       8070 : lower_eh_filter (struct leh_state *state, gtry *tp)</span>
<span class="lineNum">    1840 </span>            : {
<span class="lineNum">    1841 </span><span class="lineCov">       8070 :   struct leh_state this_state = *state;</span>
<span class="lineNum">    1842 </span><span class="lineCov">       8070 :   eh_region this_region = NULL;</span>
<span class="lineNum">    1843 </span><span class="lineCov">       8070 :   gimple *inner, *x;</span>
<span class="lineNum">    1844 </span><span class="lineCov">       8070 :   gimple_seq new_seq;</span>
<span class="lineNum">    1845 </span>            : 
<span class="lineNum">    1846 </span><span class="lineCov">       8070 :   inner = gimple_seq_first_stmt (gimple_try_cleanup (tp));</span>
<span class="lineNum">    1847 </span>            : 
<span class="lineNum">    1848 </span><span class="lineCov">       8070 :   if (flag_exceptions)</span>
<span class="lineNum">    1849 </span>            :     {
<span class="lineNum">    1850 </span><span class="lineCov">       8070 :       this_region = gen_eh_region_allowed (state-&gt;cur_region,</span>
<span class="lineNum">    1851 </span>            :                                            gimple_eh_filter_types (inner));
<span class="lineNum">    1852 </span><span class="lineCov">       8070 :       this_state.cur_region = this_region;</span>
<span class="lineNum">    1853 </span>            :     }
<span class="lineNum">    1854 </span>            : 
<span class="lineNum">    1855 </span><span class="lineCov">       8070 :   lower_eh_constructs_1 (&amp;this_state, gimple_try_eval_ptr (tp));</span>
<span class="lineNum">    1856 </span>            : 
<span class="lineNum">    1857 </span><span class="lineCov">       8070 :   if (!eh_region_may_contain_throw (this_region))</span>
<span class="lineNum">    1858 </span><span class="lineCov">       5345 :     return gimple_try_eval (tp);</span>
<span class="lineNum">    1859 </span>            : 
<span class="lineNum">    1860 </span><span class="lineCov">       2725 :   new_seq = NULL;</span>
<span class="lineNum">    1861 </span><span class="lineCov">       2725 :   this_state.cur_region = state-&gt;cur_region;</span>
<span class="lineNum">    1862 </span><span class="lineCov">       2725 :   this_state.ehp_region = this_region;</span>
<span class="lineNum">    1863 </span>            : 
<span class="lineNum">    1864 </span><span class="lineCov">       2725 :   emit_eh_dispatch (&amp;new_seq, this_region);</span>
<span class="lineNum">    1865 </span><span class="lineCov">       2725 :   emit_resx (&amp;new_seq, this_region);</span>
<span class="lineNum">    1866 </span>            : 
<span class="lineNum">    1867 </span><span class="lineCov">       2725 :   this_region-&gt;u.allowed.label = create_artificial_label (UNKNOWN_LOCATION);</span>
<span class="lineNum">    1868 </span><span class="lineCov">       2725 :   x = gimple_build_label (this_region-&gt;u.allowed.label);</span>
<span class="lineNum">    1869 </span><span class="lineCov">       2725 :   gimple_seq_add_stmt (&amp;new_seq, x);</span>
<span class="lineNum">    1870 </span>            : 
<span class="lineNum">    1871 </span><span class="lineCov">       2725 :   lower_eh_constructs_1 (&amp;this_state, gimple_eh_filter_failure_ptr (inner));</span>
<span class="lineNum">    1872 </span><span class="lineCov">       2725 :   gimple_seq_add_seq (&amp;new_seq, gimple_eh_filter_failure (inner));</span>
<span class="lineNum">    1873 </span>            : 
<span class="lineNum">    1874 </span><span class="lineCov">       2725 :   gimple_try_set_cleanup (tp, new_seq);</span>
<span class="lineNum">    1875 </span>            : 
<span class="lineNum">    1876 </span><span class="lineCov">       2725 :   return frob_into_branch_around (tp, this_region, NULL);</span>
<span class="lineNum">    1877 </span>            : }
<span class="lineNum">    1878 </span>            : 
<span class="lineNum">    1879 </span>            : /* A subroutine of lower_eh_constructs_1.  Lower a GIMPLE_TRY with
<span class="lineNum">    1880 </span>            :    an GIMPLE_EH_MUST_NOT_THROW to a sequence of labels and blocks,
<span class="lineNum">    1881 </span>            :    plus the exception region trees that record all the magic.  */
<a name="1882"><span class="lineNum">    1882 </span>            : </a>
<span class="lineNum">    1883 </span>            : static gimple_seq
<span class="lineNum">    1884 </span><span class="lineCov">     638434 : lower_eh_must_not_throw (struct leh_state *state, gtry *tp)</span>
<span class="lineNum">    1885 </span>            : {
<span class="lineNum">    1886 </span><span class="lineCov">     638434 :   struct leh_state this_state = *state;</span>
<span class="lineNum">    1887 </span>            : 
<span class="lineNum">    1888 </span><span class="lineCov">     638434 :   if (flag_exceptions)</span>
<span class="lineNum">    1889 </span>            :     {
<span class="lineNum">    1890 </span><span class="lineCov">     638434 :       gimple *inner = gimple_seq_first_stmt (gimple_try_cleanup (tp));</span>
<span class="lineNum">    1891 </span><span class="lineCov">     638434 :       eh_region this_region;</span>
<span class="lineNum">    1892 </span>            : 
<span class="lineNum">    1893 </span><span class="lineCov">     638434 :       this_region = gen_eh_region_must_not_throw (state-&gt;cur_region);</span>
<span class="lineNum">    1894 </span><span class="lineCov">     638434 :       this_region-&gt;u.must_not_throw.failure_decl</span>
<span class="lineNum">    1895 </span><span class="lineCov">     638434 :         = gimple_eh_must_not_throw_fndecl (</span>
<span class="lineNum">    1896 </span>            :             as_a &lt;geh_mnt *&gt; (inner));
<span class="lineNum">    1897 </span><span class="lineCov">     638434 :       this_region-&gt;u.must_not_throw.failure_loc</span>
<span class="lineNum">    1898 </span><span class="lineCov">    1915302 :         = LOCATION_LOCUS (gimple_location (tp));</span>
<span class="lineNum">    1899 </span>            : 
<span class="lineNum">    1900 </span>            :       /* In order to get mangling applied to this decl, we must mark it
<span class="lineNum">    1901 </span>            :          used now.  Otherwise, pass_ipa_free_lang_data won't think it
<span class="lineNum">    1902 </span>            :          needs to happen.  */
<span class="lineNum">    1903 </span><span class="lineCov">     638434 :       TREE_USED (this_region-&gt;u.must_not_throw.failure_decl) = 1;</span>
<span class="lineNum">    1904 </span>            : 
<span class="lineNum">    1905 </span><span class="lineCov">     638434 :       this_state.cur_region = this_region;</span>
<span class="lineNum">    1906 </span>            :     }
<span class="lineNum">    1907 </span>            : 
<span class="lineNum">    1908 </span><span class="lineCov">     638434 :   lower_eh_constructs_1 (&amp;this_state, gimple_try_eval_ptr (tp));</span>
<span class="lineNum">    1909 </span>            : 
<span class="lineNum">    1910 </span><span class="lineCov">     638434 :   return gimple_try_eval (tp);</span>
<span class="lineNum">    1911 </span>            : }
<span class="lineNum">    1912 </span>            : 
<span class="lineNum">    1913 </span>            : /* Implement a cleanup expression.  This is similar to try-finally,
<span class="lineNum">    1914 </span>            :    except that we only execute the cleanup block for exception edges.  */
<a name="1915"><span class="lineNum">    1915 </span>            : </a>
<span class="lineNum">    1916 </span>            : static gimple_seq
<span class="lineNum">    1917 </span><span class="lineCov">     139383 : lower_cleanup (struct leh_state *state, gtry *tp)</span>
<span class="lineNum">    1918 </span>            : {
<span class="lineNum">    1919 </span><span class="lineCov">     139383 :   struct leh_state this_state = *state;</span>
<span class="lineNum">    1920 </span><span class="lineCov">     139383 :   eh_region this_region = NULL;</span>
<span class="lineNum">    1921 </span><span class="lineCov">     139383 :   struct leh_tf_state fake_tf;</span>
<span class="lineNum">    1922 </span><span class="lineCov">     139383 :   gimple_seq result;</span>
<span class="lineNum">    1923 </span><span class="lineCov">     139383 :   bool cleanup_dead = cleanup_is_dead_in (state-&gt;cur_region);</span>
<span class="lineNum">    1924 </span>            : 
<span class="lineNum">    1925 </span><span class="lineCov">     139383 :   if (flag_exceptions &amp;&amp; !cleanup_dead)</span>
<span class="lineNum">    1926 </span>            :     {
<span class="lineNum">    1927 </span><span class="lineCov">     113460 :       this_region = gen_eh_region_cleanup (state-&gt;cur_region);</span>
<span class="lineNum">    1928 </span><span class="lineCov">     113460 :       this_state.cur_region = this_region;</span>
<span class="lineNum">    1929 </span>            :     }
<span class="lineNum">    1930 </span>            : 
<span class="lineNum">    1931 </span><span class="lineCov">     139383 :   lower_eh_constructs_1 (&amp;this_state, gimple_try_eval_ptr (tp));</span>
<span class="lineNum">    1932 </span>            : 
<span class="lineNum">    1933 </span><span class="lineCov">     139383 :   if (cleanup_dead || !eh_region_may_contain_throw (this_region))</span>
<span class="lineNum">    1934 </span><span class="lineCov">      86735 :     return gimple_try_eval (tp);</span>
<span class="lineNum">    1935 </span>            : 
<span class="lineNum">    1936 </span>            :   /* Build enough of a try-finally state so that we can reuse
<span class="lineNum">    1937 </span>            :      honor_protect_cleanup_actions.  */
<span class="lineNum">    1938 </span><span class="lineCov">      52648 :   memset (&amp;fake_tf, 0, sizeof (fake_tf));</span>
<span class="lineNum">    1939 </span><span class="lineCov">      52648 :   fake_tf.top_p = fake_tf.try_finally_expr = tp;</span>
<span class="lineNum">    1940 </span><span class="lineCov">      52648 :   fake_tf.outer = state;</span>
<span class="lineNum">    1941 </span><span class="lineCov">      52648 :   fake_tf.region = this_region;</span>
<span class="lineNum">    1942 </span><span class="lineCov">      52648 :   fake_tf.may_fallthru = gimple_seq_may_fallthru (gimple_try_eval (tp));</span>
<span class="lineNum">    1943 </span><span class="lineCov">      52648 :   fake_tf.may_throw = true;</span>
<span class="lineNum">    1944 </span>            : 
<span class="lineNum">    1945 </span><span class="lineCov">      52648 :   honor_protect_cleanup_actions (state, NULL, &amp;fake_tf);</span>
<span class="lineNum">    1946 </span>            : 
<span class="lineNum">    1947 </span><span class="lineCov">      52648 :   if (fake_tf.may_throw)</span>
<span class="lineNum">    1948 </span>            :     {
<span class="lineNum">    1949 </span>            :       /* In this case honor_protect_cleanup_actions had nothing to do,
<span class="lineNum">    1950 </span>            :          and we should process this normally.  */
<span class="lineNum">    1951 </span><span class="lineNoCov">          0 :       lower_eh_constructs_1 (state, gimple_try_cleanup_ptr (tp));</span>
<span class="lineNum">    1952 </span><span class="lineNoCov">          0 :       result = frob_into_branch_around (tp, this_region,</span>
<span class="lineNum">    1953 </span>            :                                         fake_tf.fallthru_label);
<span class="lineNum">    1954 </span>            :     }
<span class="lineNum">    1955 </span>            :   else
<span class="lineNum">    1956 </span>            :     {
<span class="lineNum">    1957 </span>            :       /* In this case honor_protect_cleanup_actions did nearly all of
<span class="lineNum">    1958 </span>            :          the work.  All we have left is to append the fallthru_label.  */
<span class="lineNum">    1959 </span>            : 
<span class="lineNum">    1960 </span><span class="lineCov">      52648 :       result = gimple_try_eval (tp);</span>
<span class="lineNum">    1961 </span><span class="lineCov">      52648 :       if (fake_tf.fallthru_label)</span>
<span class="lineNum">    1962 </span>            :         {
<span class="lineNum">    1963 </span><span class="lineNoCov">          0 :           gimple *x = gimple_build_label (fake_tf.fallthru_label);</span>
<span class="lineNum">    1964 </span><span class="lineNoCov">          0 :           gimple_seq_add_stmt (&amp;result, x);</span>
<span class="lineNum">    1965 </span>            :         }
<span class="lineNum">    1966 </span>            :     }
<span class="lineNum">    1967 </span><span class="lineCov">      52648 :   return result;</span>
<span class="lineNum">    1968 </span>            : }
<span class="lineNum">    1969 </span>            : 
<span class="lineNum">    1970 </span>            : /* Main loop for lowering eh constructs. Also moves gsi to the next
<span class="lineNum">    1971 </span>            :    statement. */
<a name="1972"><span class="lineNum">    1972 </span>            : </a>
<span class="lineNum">    1973 </span>            : static void
<span class="lineNum">    1974 </span><span class="lineCov">   50611561 : lower_eh_constructs_2 (struct leh_state *state, gimple_stmt_iterator *gsi)</span>
<span class="lineNum">    1975 </span>            : {
<span class="lineNum">    1976 </span><span class="lineCov">   50611561 :   gimple_seq replace;</span>
<span class="lineNum">    1977 </span><span class="lineCov">   50611561 :   gimple *x;</span>
<span class="lineNum">    1978 </span><span class="lineCov">   50611561 :   gimple *stmt = gsi_stmt (*gsi);</span>
<span class="lineNum">    1979 </span>            : 
<span class="lineNum">    1980 </span><span class="lineCov">  101223122 :   switch (gimple_code (stmt))</span>
<span class="lineNum">    1981 </span>            :     {
<span class="lineNum">    1982 </span><span class="lineCov">    6287342 :     case GIMPLE_CALL:</span>
<span class="lineNum">    1983 </span><span class="lineCov">    6287342 :       {</span>
<span class="lineNum">    1984 </span><span class="lineCov">    6287342 :         tree fndecl = gimple_call_fndecl (stmt);</span>
<span class="lineNum">    1985 </span><span class="lineCov">    6287342 :         tree rhs, lhs;</span>
<span class="lineNum">    1986 </span>            : 
<span class="lineNum">    1987 </span><span class="lineCov">    6287342 :         if (fndecl &amp;&amp; fndecl_built_in_p (fndecl, BUILT_IN_NORMAL))</span>
<span class="lineNum">    1988 </span><span class="lineCov">    1157016 :           switch (DECL_FUNCTION_CODE (fndecl))</span>
<span class="lineNum">    1989 </span>            :             {
<span class="lineNum">    1990 </span><span class="lineCov">      22482 :             case BUILT_IN_EH_POINTER:</span>
<span class="lineNum">    1991 </span>            :               /* The front end may have generated a call to
<span class="lineNum">    1992 </span>            :                  __builtin_eh_pointer (0) within a catch region.  Replace
<span class="lineNum">    1993 </span>            :                  this zero argument with the current catch region number.  */
<span class="lineNum">    1994 </span><span class="lineCov">      22482 :               if (state-&gt;ehp_region)</span>
<span class="lineNum">    1995 </span>            :                 {
<span class="lineNum">    1996 </span><span class="lineCov">      22482 :                   tree nr = build_int_cst (integer_type_node,</span>
<span class="lineNum">    1997 </span><span class="lineCov">      22482 :                                            state-&gt;ehp_region-&gt;index);</span>
<span class="lineNum">    1998 </span><span class="lineCov">      22482 :                   gimple_call_set_arg (stmt, 0, nr);</span>
<span class="lineNum">    1999 </span>            :                 }
<span class="lineNum">    2000 </span>            :               else
<span class="lineNum">    2001 </span>            :                 {
<span class="lineNum">    2002 </span>            :                   /* The user has dome something silly.  Remove it.  */
<span class="lineNum">    2003 </span><span class="lineNoCov">          0 :                   rhs = null_pointer_node;</span>
<span class="lineNum">    2004 </span><span class="lineNoCov">          0 :                   goto do_replace;</span>
<span class="lineNum">    2005 </span>            :                 }
<span class="lineNum">    2006 </span><span class="lineCov">      22482 :               break;</span>
<span class="lineNum">    2007 </span>            : 
<span class="lineNum">    2008 </span><span class="lineNoCov">          0 :             case BUILT_IN_EH_FILTER:</span>
<span class="lineNum">    2009 </span>            :               /* ??? This should never appear, but since it's a builtin it
<span class="lineNum">    2010 </span>            :                  is accessible to abuse by users.  Just remove it and
<span class="lineNum">    2011 </span>            :                  replace the use with the arbitrary value zero.  */
<span class="lineNum">    2012 </span><span class="lineNoCov">          0 :               rhs = build_int_cst (TREE_TYPE (TREE_TYPE (fndecl)), 0);</span>
<span class="lineNum">    2013 </span><span class="lineNoCov">          0 :             do_replace:</span>
<span class="lineNum">    2014 </span><span class="lineNoCov">          0 :               lhs = gimple_call_lhs (stmt);</span>
<span class="lineNum">    2015 </span><span class="lineNoCov">          0 :               x = gimple_build_assign (lhs, rhs);</span>
<span class="lineNum">    2016 </span><span class="lineNoCov">          0 :               gsi_insert_before (gsi, x, GSI_SAME_STMT);</span>
<span class="lineNum">    2017 </span>            :               /* FALLTHRU */
<span class="lineNum">    2018 </span>            : 
<span class="lineNum">    2019 </span><span class="lineNoCov">          0 :             case BUILT_IN_EH_COPY_VALUES:</span>
<span class="lineNum">    2020 </span>            :               /* Likewise this should not appear.  Remove it.  */
<span class="lineNum">    2021 </span><span class="lineNoCov">          0 :               gsi_remove (gsi, true);</span>
<span class="lineNum">    2022 </span><span class="lineNoCov">          0 :               return;</span>
<span class="lineNum">    2023 </span>            : 
<span class="lineNum">    2024 </span>            :             default:
<span class="lineNum">    2025 </span>            :               break;
<span class="lineNum">    2026 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">    2027 </span>            :       }
<span class="lineNum">    2028 </span>            :       /* FALLTHRU */
<span class="lineNum">    2029 </span>            : 
<span class="lineNum">    2030 </span><span class="lineCov">   30055572 :     case GIMPLE_ASSIGN:</span>
<span class="lineNum">    2031 </span>            :       /* If the stmt can throw, use a new temporary for the assignment
<span class="lineNum">    2032 </span>            :          to a LHS.  This makes sure the old value of the LHS is
<span class="lineNum">    2033 </span>            :          available on the EH edge.  Only do so for statements that
<span class="lineNum">    2034 </span>            :          potentially fall through (no noreturn calls e.g.), otherwise
<span class="lineNum">    2035 </span>            :          this new assignment might create fake fallthru regions.  */
<span class="lineNum">    2036 </span><span class="lineCov">   30055572 :       if (stmt_could_throw_p (stmt)</span>
<span class="lineNum">    2037 </span><span class="lineCov">    4995437 :           &amp;&amp; gimple_has_lhs (stmt)</span>
<span class="lineNum">    2038 </span><span class="lineCov">    1453960 :           &amp;&amp; gimple_stmt_may_fallthru (stmt)</span>
<span class="lineNum">    2039 </span><span class="lineCov">    1453957 :           &amp;&amp; !tree_could_throw_p (gimple_get_lhs (stmt))</span>
<span class="lineNum">    2040 </span><span class="lineCov">   31389433 :           &amp;&amp; is_gimple_reg_type (TREE_TYPE (gimple_get_lhs (stmt))))</span>
<span class="lineNum">    2041 </span>            :         {
<span class="lineNum">    2042 </span><span class="lineCov">    1016755 :           tree lhs = gimple_get_lhs (stmt);</span>
<span class="lineNum">    2043 </span><span class="lineCov">    1016755 :           tree tmp = create_tmp_var (TREE_TYPE (lhs));</span>
<span class="lineNum">    2044 </span><span class="lineCov">    1016755 :           gimple *s = gimple_build_assign (lhs, tmp);</span>
<span class="lineNum">    2045 </span><span class="lineCov">    2033510 :           gimple_set_location (s, gimple_location (stmt));</span>
<span class="lineNum">    2046 </span><span class="lineCov">    2033510 :           gimple_set_block (s, gimple_block (stmt));</span>
<span class="lineNum">    2047 </span><span class="lineCov">    1016755 :           gimple_set_lhs (stmt, tmp);</span>
<span class="lineNum">    2048 </span><span class="lineCov">    1016755 :           if (TREE_CODE (TREE_TYPE (tmp)) == COMPLEX_TYPE</span>
<span class="lineNum">    2049 </span><span class="lineCov">    1016755 :               || TREE_CODE (TREE_TYPE (tmp)) == VECTOR_TYPE)</span>
<span class="lineNum">    2050 </span><span class="lineCov">       1587 :             DECL_GIMPLE_REG_P (tmp) = 1;</span>
<span class="lineNum">    2051 </span><span class="lineCov">    1016755 :           gsi_insert_after (gsi, s, GSI_SAME_STMT);</span>
<span class="lineNum">    2052 </span>            :         }
<span class="lineNum">    2053 </span>            :       /* Look for things that can throw exceptions, and record them.  */
<span class="lineNum">    2054 </span><span class="lineCov">   30055572 :       if (state-&gt;cur_region &amp;&amp; stmt_could_throw_p (stmt))</span>
<span class="lineNum">    2055 </span>            :         {
<span class="lineNum">    2056 </span><span class="lineCov">    1642124 :           record_stmt_eh_region (state-&gt;cur_region, stmt);</span>
<span class="lineNum">    2057 </span><span class="lineCov">    1642124 :           note_eh_region_may_contain_throw (state-&gt;cur_region);</span>
<span class="lineNum">    2058 </span>            :         }
<span class="lineNum">    2059 </span>            :       break;
<span class="lineNum">    2060 </span>            : 
<span class="lineNum">    2061 </span><span class="lineCov">    7599097 :     case GIMPLE_COND:</span>
<span class="lineNum">    2062 </span><span class="lineCov">    7599097 :     case GIMPLE_GOTO:</span>
<span class="lineNum">    2063 </span><span class="lineCov">    7599097 :     case GIMPLE_RETURN:</span>
<span class="lineNum">    2064 </span><span class="lineCov">    7599097 :       maybe_record_in_goto_queue (state, stmt);</span>
<span class="lineNum">    2065 </span><span class="lineCov">    7599097 :       break;</span>
<span class="lineNum">    2066 </span>            : 
<span class="lineNum">    2067 </span><span class="lineCov">      25466 :     case GIMPLE_SWITCH:</span>
<span class="lineNum">    2068 </span><span class="lineCov">      25466 :       verify_norecord_switch_expr (state, as_a &lt;gswitch *&gt; (stmt));</span>
<span class="lineNum">    2069 </span><span class="lineCov">      25466 :       break;</span>
<span class="lineNum">    2070 </span>            : 
<span class="lineNum">    2071 </span><span class="lineCov">    1397074 :     case GIMPLE_TRY:</span>
<span class="lineNum">    2072 </span><span class="lineCov">    1397074 :       {</span>
<span class="lineNum">    2073 </span><span class="lineCov">    1397074 :         gtry *try_stmt = as_a &lt;gtry *&gt; (stmt);</span>
<span class="lineNum">    2074 </span><span class="lineCov">    1397074 :         if (gimple_try_kind (try_stmt) == GIMPLE_TRY_FINALLY)</span>
<span class="lineNum">    2075 </span><span class="lineCov">     903312 :           replace = lower_try_finally (state, try_stmt);</span>
<span class="lineNum">    2076 </span>            :         else
<span class="lineNum">    2077 </span>            :           {
<span class="lineNum">    2078 </span><span class="lineCov">     987524 :             x = gimple_seq_first_stmt (gimple_try_cleanup (try_stmt));</span>
<span class="lineNum">    2079 </span><span class="lineCov">     493762 :             if (!x)</span>
<span class="lineNum">    2080 </span>            :               {
<span class="lineNum">    2081 </span><span class="lineCov">        437 :                 replace = gimple_try_eval (try_stmt);</span>
<span class="lineNum">    2082 </span><span class="lineCov">        437 :                 lower_eh_constructs_1 (state, &amp;replace);</span>
<span class="lineNum">    2083 </span>            :               }
<span class="lineNum">    2084 </span>            :             else
<span class="lineNum">    2085 </span><span class="lineCov">     986650 :               switch (gimple_code (x))</span>
<span class="lineNum">    2086 </span>            :                 {
<span class="lineNum">    2087 </span><span class="lineCov">      37247 :                 case GIMPLE_CATCH:</span>
<span class="lineNum">    2088 </span><span class="lineCov">      37247 :                   replace = lower_catch (state, try_stmt);</span>
<span class="lineNum">    2089 </span><span class="lineCov">      37247 :                   break;</span>
<span class="lineNum">    2090 </span><span class="lineCov">       8070 :                 case GIMPLE_EH_FILTER:</span>
<span class="lineNum">    2091 </span><span class="lineCov">       8070 :                   replace = lower_eh_filter (state, try_stmt);</span>
<span class="lineNum">    2092 </span><span class="lineCov">       8070 :                   break;</span>
<span class="lineNum">    2093 </span><span class="lineCov">     308625 :                 case GIMPLE_EH_MUST_NOT_THROW:</span>
<span class="lineNum">    2094 </span><span class="lineCov">     308625 :                   replace = lower_eh_must_not_throw (state, try_stmt);</span>
<span class="lineNum">    2095 </span><span class="lineCov">     308625 :                   break;</span>
<span class="lineNum">    2096 </span><span class="lineNoCov">          0 :                 case GIMPLE_EH_ELSE:</span>
<span class="lineNum">    2097 </span>            :                   /* This code is only valid with GIMPLE_TRY_FINALLY.  */
<span class="lineNum">    2098 </span><span class="lineNoCov">          0 :                   gcc_unreachable ();</span>
<span class="lineNum">    2099 </span><span class="lineCov">     139383 :                 default:</span>
<span class="lineNum">    2100 </span><span class="lineCov">     139383 :                   replace = lower_cleanup (state, try_stmt);</span>
<span class="lineNum">    2101 </span><span class="lineCov">     139383 :                   break;</span>
<span class="lineNum">    2102 </span>            :                 }
<span class="lineNum">    2103 </span>            :           }
<span class="lineNum">    2104 </span>            :       }
<span class="lineNum">    2105 </span>            : 
<span class="lineNum">    2106 </span>            :       /* Remove the old stmt and insert the transformed sequence
<span class="lineNum">    2107 </span>            :          instead. */
<span class="lineNum">    2108 </span><span class="lineCov">    1397074 :       gsi_insert_seq_before (gsi, replace, GSI_SAME_STMT);</span>
<span class="lineNum">    2109 </span><span class="lineCov">    1397074 :       gsi_remove (gsi, true);</span>
<span class="lineNum">    2110 </span>            : 
<span class="lineNum">    2111 </span>            :       /* Return since we don't want gsi_next () */
<span class="lineNum">    2112 </span><span class="lineCov">    1397074 :       return;</span>
<span class="lineNum">    2113 </span>            : 
<span class="lineNum">    2114 </span><span class="lineNoCov">          0 :     case GIMPLE_EH_ELSE:</span>
<span class="lineNum">    2115 </span>            :       /* We should be eliminating this in lower_try_finally et al.  */
<span class="lineNum">    2116 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">    2117 </span>            : 
<span class="lineNum">    2118 </span>            :     default:
<span class="lineNum">    2119 </span>            :       /* A type, a decl, or some kind of statement that we're not
<span class="lineNum">    2120 </span>            :          interested in.  Don't walk them.  */
<span class="lineNum">    2121 </span>            :       break;
<span class="lineNum">    2122 </span>            :     }
<span class="lineNum">    2123 </span>            : 
<span class="lineNum">    2124 </span><span class="lineCov">   49214487 :   gsi_next (gsi);</span>
<span class="lineNum">    2125 </span>            : }
<span class="lineNum">    2126 </span>            : 
<span class="lineNum">    2127 </span>            : /* A helper to unwrap a gimple_seq and feed stmts to lower_eh_constructs_2. */
<a name="2128"><span class="lineNum">    2128 </span>            : </a>
<span class="lineNum">    2129 </span>            : static void
<span class="lineNum">    2130 </span><span class="lineCov">    4428897 : lower_eh_constructs_1 (struct leh_state *state, gimple_seq *pseq)</span>
<span class="lineNum">    2131 </span>            : {
<span class="lineNum">    2132 </span><span class="lineCov">    4428897 :   gimple_stmt_iterator gsi;</span>
<span class="lineNum">    2133 </span><span class="lineCov">   59370890 :   for (gsi = gsi_start (*pseq); !gsi_end_p (gsi);)</span>
<span class="lineNum">    2134 </span><span class="lineCov">   50611561 :     lower_eh_constructs_2 (state, &amp;gsi);</span>
<span class="lineNum">    2135 </span><span class="lineCov">    4428897 : }</span>
<span class="lineNum">    2136 </span>            : 
<span class="lineNum">    2137 </span>            : namespace {
<span class="lineNum">    2138 </span>            : 
<span class="lineNum">    2139 </span>            : const pass_data pass_data_lower_eh =
<span class="lineNum">    2140 </span>            : {
<span class="lineNum">    2141 </span>            :   GIMPLE_PASS, /* type */
<span class="lineNum">    2142 </span>            :   &quot;eh&quot;, /* name */
<span class="lineNum">    2143 </span>            :   OPTGROUP_NONE, /* optinfo_flags */
<span class="lineNum">    2144 </span>            :   TV_TREE_EH, /* tv_id */
<span class="lineNum">    2145 </span>            :   PROP_gimple_lcf, /* properties_required */
<span class="lineNum">    2146 </span>            :   PROP_gimple_leh, /* properties_provided */
<span class="lineNum">    2147 </span>            :   0, /* properties_destroyed */
<span class="lineNum">    2148 </span>            :   0, /* todo_flags_start */
<span class="lineNum">    2149 </span>            :   0, /* todo_flags_finish */
<span class="lineNum">    2150 </span>            : };
<span class="lineNum">    2151 </span>            : 
<span class="lineNum">    2152 </span>            : class pass_lower_eh : public gimple_opt_pass
<span class="lineNum">    2153 </span>            : {
<span class="lineNum">    2154 </span>            : public:
<span class="lineNum">    2155 </span>            :   pass_lower_eh (gcc::context *ctxt)
<span class="lineNum">    2156 </span><span class="lineCov">     340624 :     : gimple_opt_pass (pass_data_lower_eh, ctxt)</span>
<span class="lineNum">    2157 </span>            :   {}
<span class="lineNum">    2158 </span>            : 
<span class="lineNum">    2159 </span>            :   /* opt_pass methods: */
<span class="lineNum">    2160 </span>            :   virtual unsigned int execute (function *);
<span class="lineNum">    2161 </span>            : 
<span class="lineNum">    2162 </span>            : }; // class pass_lower_eh
<a name="2163"><span class="lineNum">    2163 </span>            : </a>
<span class="lineNum">    2164 </span>            : unsigned int
<span class="lineNum">    2165 </span><span class="lineCov">    1631528 : pass_lower_eh::execute (function *fun)</span>
<span class="lineNum">    2166 </span>            : {
<span class="lineNum">    2167 </span><span class="lineCov">    1631528 :   struct leh_state null_state;</span>
<span class="lineNum">    2168 </span><span class="lineCov">    1631528 :   gimple_seq bodyp;</span>
<span class="lineNum">    2169 </span>            : 
<span class="lineNum">    2170 </span><span class="lineCov">    1631528 :   bodyp = gimple_body (current_function_decl);</span>
<span class="lineNum">    2171 </span><span class="lineCov">    1631528 :   if (bodyp == NULL)</span>
<span class="lineNum">    2172 </span>            :     return 0;
<span class="lineNum">    2173 </span>            : 
<span class="lineNum">    2174 </span><span class="lineCov">    1631528 :   finally_tree = new hash_table&lt;finally_tree_hasher&gt; (31);</span>
<span class="lineNum">    2175 </span><span class="lineCov">    1631528 :   eh_region_may_contain_throw_map = BITMAP_ALLOC (NULL);</span>
<span class="lineNum">    2176 </span><span class="lineCov">    1631528 :   memset (&amp;null_state, 0, sizeof (null_state));</span>
<span class="lineNum">    2177 </span>            : 
<span class="lineNum">    2178 </span><span class="lineCov">    1631528 :   collect_finally_tree_1 (bodyp, NULL);</span>
<span class="lineNum">    2179 </span><span class="lineCov">    1631528 :   lower_eh_constructs_1 (&amp;null_state, &amp;bodyp);</span>
<span class="lineNum">    2180 </span><span class="lineCov">    1631528 :   gimple_set_body (current_function_decl, bodyp);</span>
<span class="lineNum">    2181 </span>            : 
<span class="lineNum">    2182 </span>            :   /* We assume there's a return statement, or something, at the end of
<span class="lineNum">    2183 </span>            :      the function, and thus ploping the EH sequence afterward won't
<span class="lineNum">    2184 </span>            :      change anything.  */
<span class="lineNum">    2185 </span><span class="lineCov">    1631528 :   gcc_assert (!gimple_seq_may_fallthru (bodyp));</span>
<span class="lineNum">    2186 </span><span class="lineCov">    1631528 :   gimple_seq_add_seq (&amp;bodyp, eh_seq);</span>
<span class="lineNum">    2187 </span>            : 
<span class="lineNum">    2188 </span>            :   /* We assume that since BODYP already existed, adding EH_SEQ to it
<span class="lineNum">    2189 </span>            :      didn't change its value, and we don't have to re-set the function.  */
<span class="lineNum">    2190 </span><span class="lineCov">    1631528 :   gcc_assert (bodyp == gimple_body (current_function_decl));</span>
<span class="lineNum">    2191 </span>            : 
<span class="lineNum">    2192 </span><span class="lineCov">    1631528 :   delete finally_tree;</span>
<span class="lineNum">    2193 </span><span class="lineCov">    1631528 :   finally_tree = NULL;</span>
<span class="lineNum">    2194 </span><span class="lineCov">    1631528 :   BITMAP_FREE (eh_region_may_contain_throw_map);</span>
<span class="lineNum">    2195 </span><span class="lineCov">    1631528 :   eh_seq = NULL;</span>
<span class="lineNum">    2196 </span>            : 
<span class="lineNum">    2197 </span>            :   /* If this function needs a language specific EH personality routine
<span class="lineNum">    2198 </span>            :      and the frontend didn't already set one do so now.  */
<span class="lineNum">    2199 </span><span class="lineCov">    1631528 :   if (function_needs_eh_personality (fun) == eh_personality_lang</span>
<span class="lineNum">    2200 </span><span class="lineCov">    1631528 :       &amp;&amp; !DECL_FUNCTION_PERSONALITY (current_function_decl))</span>
<span class="lineNum">    2201 </span><span class="lineCov">    1252392 :     DECL_FUNCTION_PERSONALITY (current_function_decl)</span>
<span class="lineNum">    2202 </span><span class="lineCov">     834928 :       = lang_hooks.eh_personality ();</span>
<span class="lineNum">    2203 </span>            : 
<span class="lineNum">    2204 </span>            :   return 0;
<span class="lineNum">    2205 </span>            : }
<span class="lineNum">    2206 </span>            : 
<span class="lineNum">    2207 </span>            : } // anon namespace
<a name="2208"><span class="lineNum">    2208 </span>            : </a>
<span class="lineNum">    2209 </span>            : gimple_opt_pass *
<span class="lineNum">    2210 </span><span class="lineCov">     170312 : make_pass_lower_eh (gcc::context *ctxt)</span>
<span class="lineNum">    2211 </span>            : {
<span class="lineNum">    2212 </span><span class="lineCov">     170312 :   return new pass_lower_eh (ctxt);</span>
<span class="lineNum">    2213 </span>            : }
<span class="lineNum">    2214 </span>            : 
<span class="lineNum">    2215 </span>            : /* Create the multiple edges from an EH_DISPATCH statement to all of
<span class="lineNum">    2216 </span>            :    the possible handlers for its EH region.  Return true if there's
<span class="lineNum">    2217 </span>            :    no fallthru edge; false if there is.  */
<a name="2218"><span class="lineNum">    2218 </span>            : </a>
<span class="lineNum">    2219 </span>            : bool
<span class="lineNum">    2220 </span><span class="lineCov">      46232 : make_eh_dispatch_edges (geh_dispatch *stmt)</span>
<span class="lineNum">    2221 </span>            : {
<span class="lineNum">    2222 </span><span class="lineCov">      46232 :   eh_region r;</span>
<span class="lineNum">    2223 </span><span class="lineCov">      46232 :   eh_catch c;</span>
<span class="lineNum">    2224 </span><span class="lineCov">      46232 :   basic_block src, dst;</span>
<span class="lineNum">    2225 </span>            : 
<span class="lineNum">    2226 </span><span class="lineCov">      92464 :   r = get_eh_region_from_number (gimple_eh_dispatch_region (stmt));</span>
<span class="lineNum">    2227 </span><span class="lineCov">      46232 :   src = gimple_bb (stmt);</span>
<span class="lineNum">    2228 </span>            : 
<span class="lineNum">    2229 </span><span class="lineCov">      46232 :   switch (r-&gt;type)</span>
<span class="lineNum">    2230 </span>            :     {
<span class="lineNum">    2231 </span><span class="lineCov">      42345 :     case ERT_TRY:</span>
<span class="lineNum">    2232 </span><span class="lineCov">      47060 :       for (c = r-&gt;u.eh_try.first_catch; c ; c = c-&gt;next_catch)</span>
<span class="lineNum">    2233 </span>            :         {
<span class="lineNum">    2234 </span><span class="lineCov">      44924 :           dst = label_to_block (cfun, c-&gt;label);</span>
<span class="lineNum">    2235 </span><span class="lineCov">      44924 :           make_edge (src, dst, 0);</span>
<span class="lineNum">    2236 </span>            : 
<span class="lineNum">    2237 </span>            :           /* A catch-all handler doesn't have a fallthru.  */
<span class="lineNum">    2238 </span><span class="lineCov">      44924 :           if (c-&gt;type_list == NULL)</span>
<span class="lineNum">    2239 </span>            :             return false;
<span class="lineNum">    2240 </span>            :         }
<span class="lineNum">    2241 </span>            :       break;
<span class="lineNum">    2242 </span>            : 
<span class="lineNum">    2243 </span><span class="lineCov">       3887 :     case ERT_ALLOWED_EXCEPTIONS:</span>
<span class="lineNum">    2244 </span><span class="lineCov">       3887 :       dst = label_to_block (cfun, r-&gt;u.allowed.label);</span>
<span class="lineNum">    2245 </span><span class="lineCov">       3887 :       make_edge (src, dst, 0);</span>
<span class="lineNum">    2246 </span><span class="lineCov">       3887 :       break;</span>
<span class="lineNum">    2247 </span>            : 
<span class="lineNum">    2248 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">    2249 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">    2250 </span>            :     }
<span class="lineNum">    2251 </span>            : 
<span class="lineNum">    2252 </span>            :   return true;
<span class="lineNum">    2253 </span>            : }
<span class="lineNum">    2254 </span>            : 
<span class="lineNum">    2255 </span>            : /* Create the single EH edge from STMT to its nearest landing pad,
<span class="lineNum">    2256 </span>            :    if there is such a landing pad within the current function.  */
<a name="2257"><span class="lineNum">    2257 </span>            : </a>
<span class="lineNum">    2258 </span>            : void
<span class="lineNum">    2259 </span><span class="lineCov">    3485252 : make_eh_edges (gimple *stmt)</span>
<span class="lineNum">    2260 </span>            : {
<span class="lineNum">    2261 </span><span class="lineCov">    3485252 :   basic_block src, dst;</span>
<span class="lineNum">    2262 </span><span class="lineCov">    3485252 :   eh_landing_pad lp;</span>
<span class="lineNum">    2263 </span><span class="lineCov">    3485252 :   int lp_nr;</span>
<span class="lineNum">    2264 </span>            : 
<span class="lineNum">    2265 </span><span class="lineCov">    3485252 :   lp_nr = lookup_stmt_eh_lp (stmt);</span>
<span class="lineNum">    2266 </span><span class="lineCov">    3485252 :   if (lp_nr &lt;= 0)</span>
<span class="lineNum">    2267 </span>            :     return;
<span class="lineNum">    2268 </span>            : 
<span class="lineNum">    2269 </span><span class="lineCov">    2240590 :   lp = get_eh_landing_pad_from_number (lp_nr);</span>
<span class="lineNum">    2270 </span><span class="lineCov">    2240590 :   gcc_assert (lp != NULL);</span>
<span class="lineNum">    2271 </span>            : 
<span class="lineNum">    2272 </span><span class="lineCov">    2240590 :   src = gimple_bb (stmt);</span>
<span class="lineNum">    2273 </span><span class="lineCov">    2240590 :   dst = label_to_block (cfun, lp-&gt;post_landing_pad);</span>
<span class="lineNum">    2274 </span><span class="lineCov">    2240590 :   make_edge (src, dst, EDGE_EH);</span>
<span class="lineNum">    2275 </span>            : }
<span class="lineNum">    2276 </span>            : 
<span class="lineNum">    2277 </span>            : /* Do the work in redirecting EDGE_IN to NEW_BB within the EH region tree;
<span class="lineNum">    2278 </span>            :    do not actually perform the final edge redirection.
<span class="lineNum">    2279 </span>            : 
<span class="lineNum">    2280 </span>            :    CHANGE_REGION is true when we're being called from cleanup_empty_eh and
<span class="lineNum">    2281 </span>            :    we intend to change the destination EH region as well; this means
<span class="lineNum">    2282 </span>            :    EH_LANDING_PAD_NR must already be set on the destination block label.
<span class="lineNum">    2283 </span>            :    If false, we're being called from generic cfg manipulation code and we
<span class="lineNum">    2284 </span>            :    should preserve our place within the region tree.  */
<a name="2285"><span class="lineNum">    2285 </span>            : </a>
<span class="lineNum">    2286 </span>            : static void
<span class="lineNum">    2287 </span><span class="lineCov">    1446123 : redirect_eh_edge_1 (edge edge_in, basic_block new_bb, bool change_region)</span>
<span class="lineNum">    2288 </span>            : {
<span class="lineNum">    2289 </span><span class="lineCov">    1446123 :   eh_landing_pad old_lp, new_lp;</span>
<span class="lineNum">    2290 </span><span class="lineCov">    1446123 :   basic_block old_bb;</span>
<span class="lineNum">    2291 </span><span class="lineCov">    1446123 :   gimple *throw_stmt;</span>
<span class="lineNum">    2292 </span><span class="lineCov">    1446123 :   int old_lp_nr, new_lp_nr;</span>
<span class="lineNum">    2293 </span><span class="lineCov">    1446123 :   tree old_label, new_label;</span>
<span class="lineNum">    2294 </span><span class="lineCov">    1446123 :   edge_iterator ei;</span>
<span class="lineNum">    2295 </span><span class="lineCov">    1446123 :   edge e;</span>
<span class="lineNum">    2296 </span>            : 
<span class="lineNum">    2297 </span><span class="lineCov">    1446123 :   old_bb = edge_in-&gt;dest;</span>
<span class="lineNum">    2298 </span><span class="lineCov">    1446123 :   old_label = gimple_block_label (old_bb);</span>
<span class="lineNum">    2299 </span><span class="lineCov">    1446123 :   old_lp_nr = EH_LANDING_PAD_NR (old_label);</span>
<span class="lineNum">    2300 </span><span class="lineCov">    1446123 :   gcc_assert (old_lp_nr &gt; 0);</span>
<span class="lineNum">    2301 </span><span class="lineCov">    1446123 :   old_lp = get_eh_landing_pad_from_number (old_lp_nr);</span>
<span class="lineNum">    2302 </span>            : 
<span class="lineNum">    2303 </span><span class="lineCov">    1446123 :   throw_stmt = last_stmt (edge_in-&gt;src);</span>
<span class="lineNum">    2304 </span><span class="lineCov">    1446123 :   gcc_assert (lookup_stmt_eh_lp (throw_stmt) == old_lp_nr);</span>
<span class="lineNum">    2305 </span>            : 
<span class="lineNum">    2306 </span><span class="lineCov">    1446123 :   new_label = gimple_block_label (new_bb);</span>
<span class="lineNum">    2307 </span>            : 
<span class="lineNum">    2308 </span>            :   /* Look for an existing region that might be using NEW_BB already.  */
<span class="lineNum">    2309 </span><span class="lineCov">    1446123 :   new_lp_nr = EH_LANDING_PAD_NR (new_label);</span>
<span class="lineNum">    2310 </span><span class="lineCov">    1446123 :   if (new_lp_nr)</span>
<span class="lineNum">    2311 </span>            :     {
<span class="lineNum">    2312 </span><span class="lineCov">     751007 :       new_lp = get_eh_landing_pad_from_number (new_lp_nr);</span>
<span class="lineNum">    2313 </span><span class="lineCov">     751007 :       gcc_assert (new_lp);</span>
<span class="lineNum">    2314 </span>            : 
<span class="lineNum">    2315 </span>            :       /* Unless CHANGE_REGION is true, the new and old landing pad
<span class="lineNum">    2316 </span>            :          had better be associated with the same EH region.  */
<span class="lineNum">    2317 </span><span class="lineCov">     751007 :       gcc_assert (change_region || new_lp-&gt;region == old_lp-&gt;region);</span>
<span class="lineNum">    2318 </span>            :     }
<span class="lineNum">    2319 </span>            :   else
<span class="lineNum">    2320 </span>            :     {
<span class="lineNum">    2321 </span><span class="lineCov">     695116 :       new_lp = NULL;</span>
<span class="lineNum">    2322 </span><span class="lineCov">     695116 :       gcc_assert (!change_region);</span>
<span class="lineNum">    2323 </span>            :     }
<span class="lineNum">    2324 </span>            : 
<span class="lineNum">    2325 </span>            :   /* Notice when we redirect the last EH edge away from OLD_BB.  */
<span class="lineNum">    2326 </span><span class="lineCov">    6418316 :   FOR_EACH_EDGE (e, ei, old_bb-&gt;preds)</span>
<span class="lineNum">    2327 </span><span class="lineCov">    4211414 :     if (e != edge_in &amp;&amp; (e-&gt;flags &amp; EDGE_EH))</span>
<span class="lineNum">    2328 </span>            :       break;
<span class="lineNum">    2329 </span>            : 
<span class="lineNum">    2330 </span><span class="lineCov">    1446123 :   if (new_lp)</span>
<span class="lineNum">    2331 </span>            :     {
<span class="lineNum">    2332 </span>            :       /* NEW_LP already exists.  If there are still edges into OLD_LP,
<span class="lineNum">    2333 </span>            :          there's nothing to do with the EH tree.  If there are no more
<span class="lineNum">    2334 </span>            :          edges into OLD_LP, then we want to remove OLD_LP as it is unused.
<span class="lineNum">    2335 </span>            :          If CHANGE_REGION is true, then our caller is expecting to remove
<span class="lineNum">    2336 </span>            :          the landing pad.  */
<span class="lineNum">    2337 </span><span class="lineCov">     751007 :       if (e == NULL &amp;&amp; !change_region)</span>
<span class="lineNum">    2338 </span><span class="lineCov">     517541 :         remove_eh_landing_pad (old_lp);</span>
<span class="lineNum">    2339 </span>            :     }
<span class="lineNum">    2340 </span>            :   else
<span class="lineNum">    2341 </span>            :     {
<span class="lineNum">    2342 </span>            :       /* No correct landing pad exists.  If there are no more edges
<span class="lineNum">    2343 </span>            :          into OLD_LP, then we can simply re-use the existing landing pad.
<span class="lineNum">    2344 </span>            :          Otherwise, we have to create a new landing pad.  */
<span class="lineNum">    2345 </span><span class="lineCov">     695116 :       if (e == NULL)</span>
<span class="lineNum">    2346 </span>            :         {
<span class="lineNum">    2347 </span><span class="lineCov">     164332 :           EH_LANDING_PAD_NR (old_lp-&gt;post_landing_pad) = 0;</span>
<span class="lineNum">    2348 </span><span class="lineCov">     164332 :           new_lp = old_lp;</span>
<span class="lineNum">    2349 </span>            :         }
<span class="lineNum">    2350 </span>            :       else
<span class="lineNum">    2351 </span><span class="lineCov">     530784 :         new_lp = gen_eh_landing_pad (old_lp-&gt;region);</span>
<span class="lineNum">    2352 </span><span class="lineCov">     695116 :       new_lp-&gt;post_landing_pad = new_label;</span>
<span class="lineNum">    2353 </span><span class="lineCov">     695116 :       EH_LANDING_PAD_NR (new_label) = new_lp-&gt;index;</span>
<span class="lineNum">    2354 </span>            :     }
<span class="lineNum">    2355 </span>            : 
<span class="lineNum">    2356 </span>            :   /* Maybe move the throwing statement to the new region.  */
<span class="lineNum">    2357 </span><span class="lineCov">    1446123 :   if (old_lp != new_lp)</span>
<span class="lineNum">    2358 </span>            :     {
<span class="lineNum">    2359 </span><span class="lineCov">    1281791 :       remove_stmt_from_eh_lp (throw_stmt);</span>
<span class="lineNum">    2360 </span><span class="lineCov">    1281791 :       add_stmt_to_eh_lp (throw_stmt, new_lp-&gt;index);</span>
<span class="lineNum">    2361 </span>            :     }
<span class="lineNum">    2362 </span><span class="lineCov">    1446123 : }</span>
<span class="lineNum">    2363 </span>            : 
<span class="lineNum">    2364 </span>            : /* Redirect EH edge E to NEW_BB.  */
<a name="2365"><span class="lineNum">    2365 </span>            : </a>
<span class="lineNum">    2366 </span>            : edge
<span class="lineNum">    2367 </span><span class="lineCov">     613131 : redirect_eh_edge (edge edge_in, basic_block new_bb)</span>
<span class="lineNum">    2368 </span>            : {
<span class="lineNum">    2369 </span><span class="lineCov">     613131 :   redirect_eh_edge_1 (edge_in, new_bb, false);</span>
<span class="lineNum">    2370 </span><span class="lineCov">     613131 :   return ssa_redirect_edge (edge_in, new_bb);</span>
<span class="lineNum">    2371 </span>            : }
<span class="lineNum">    2372 </span>            : 
<span class="lineNum">    2373 </span>            : /* This is a subroutine of gimple_redirect_edge_and_branch.  Update the
<span class="lineNum">    2374 </span>            :    labels for redirecting a non-fallthru EH_DISPATCH edge E to NEW_BB.
<span class="lineNum">    2375 </span>            :    The actual edge update will happen in the caller.  */
<a name="2376"><span class="lineNum">    2376 </span>            : </a>
<span class="lineNum">    2377 </span>            : void
<span class="lineNum">    2378 </span><span class="lineNoCov">          0 : redirect_eh_dispatch_edge (geh_dispatch *stmt, edge e, basic_block new_bb)</span>
<span class="lineNum">    2379 </span>            : {
<span class="lineNum">    2380 </span><span class="lineNoCov">          0 :   tree new_lab = gimple_block_label (new_bb);</span>
<span class="lineNum">    2381 </span><span class="lineNoCov">          0 :   bool any_changed = false;</span>
<span class="lineNum">    2382 </span><span class="lineNoCov">          0 :   basic_block old_bb;</span>
<span class="lineNum">    2383 </span><span class="lineNoCov">          0 :   eh_region r;</span>
<span class="lineNum">    2384 </span><span class="lineNoCov">          0 :   eh_catch c;</span>
<span class="lineNum">    2385 </span>            : 
<span class="lineNum">    2386 </span><span class="lineNoCov">          0 :   r = get_eh_region_from_number (gimple_eh_dispatch_region (stmt));</span>
<span class="lineNum">    2387 </span><span class="lineNoCov">          0 :   switch (r-&gt;type)</span>
<span class="lineNum">    2388 </span>            :     {
<span class="lineNum">    2389 </span><span class="lineNoCov">          0 :     case ERT_TRY:</span>
<span class="lineNum">    2390 </span><span class="lineNoCov">          0 :       for (c = r-&gt;u.eh_try.first_catch; c ; c = c-&gt;next_catch)</span>
<span class="lineNum">    2391 </span>            :         {
<span class="lineNum">    2392 </span><span class="lineNoCov">          0 :           old_bb = label_to_block (cfun, c-&gt;label);</span>
<span class="lineNum">    2393 </span><span class="lineNoCov">          0 :           if (old_bb == e-&gt;dest)</span>
<span class="lineNum">    2394 </span>            :             {
<span class="lineNum">    2395 </span><span class="lineNoCov">          0 :               c-&gt;label = new_lab;</span>
<span class="lineNum">    2396 </span><span class="lineNoCov">          0 :               any_changed = true;</span>
<span class="lineNum">    2397 </span>            :             }
<span class="lineNum">    2398 </span>            :         }
<span class="lineNum">    2399 </span>            :       break;
<span class="lineNum">    2400 </span>            : 
<span class="lineNum">    2401 </span><span class="lineNoCov">          0 :     case ERT_ALLOWED_EXCEPTIONS:</span>
<span class="lineNum">    2402 </span><span class="lineNoCov">          0 :       old_bb = label_to_block (cfun, r-&gt;u.allowed.label);</span>
<span class="lineNum">    2403 </span><span class="lineNoCov">          0 :       gcc_assert (old_bb == e-&gt;dest);</span>
<span class="lineNum">    2404 </span><span class="lineNoCov">          0 :       r-&gt;u.allowed.label = new_lab;</span>
<span class="lineNum">    2405 </span><span class="lineNoCov">          0 :       any_changed = true;</span>
<span class="lineNum">    2406 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2407 </span>            : 
<span class="lineNum">    2408 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">    2409 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">    2410 </span>            :     }
<span class="lineNum">    2411 </span>            : 
<span class="lineNum">    2412 </span><span class="lineNoCov">          0 :   gcc_assert (any_changed);</span>
<span class="lineNum">    2413 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2414 </span>            : 
<span class="lineNum">    2415 </span>            : /* Helper function for operation_could_trap_p and stmt_could_throw_p.  */
<a name="2416"><span class="lineNum">    2416 </span>            : </a>
<span class="lineNum">    2417 </span>            : bool
<span class="lineNum">    2418 </span><span class="lineCov">  892130663 : operation_could_trap_helper_p (enum tree_code op,</span>
<span class="lineNum">    2419 </span>            :                                bool fp_operation,
<span class="lineNum">    2420 </span>            :                                bool honor_trapv,
<span class="lineNum">    2421 </span>            :                                bool honor_nans,
<span class="lineNum">    2422 </span>            :                                bool honor_snans,
<span class="lineNum">    2423 </span>            :                                tree divisor,
<span class="lineNum">    2424 </span>            :                                bool *handled)
<span class="lineNum">    2425 </span>            : {
<span class="lineNum">    2426 </span><span class="lineCov">  892130663 :   *handled = true;</span>
<span class="lineNum">    2427 </span><span class="lineCov">  892130663 :   switch (op)</span>
<span class="lineNum">    2428 </span>            :     {
<span class="lineNum">    2429 </span><span class="lineCov">    1636971 :     case TRUNC_DIV_EXPR:</span>
<span class="lineNum">    2430 </span><span class="lineCov">    1636971 :     case CEIL_DIV_EXPR:</span>
<span class="lineNum">    2431 </span><span class="lineCov">    1636971 :     case FLOOR_DIV_EXPR:</span>
<span class="lineNum">    2432 </span><span class="lineCov">    1636971 :     case ROUND_DIV_EXPR:</span>
<span class="lineNum">    2433 </span><span class="lineCov">    1636971 :     case EXACT_DIV_EXPR:</span>
<span class="lineNum">    2434 </span><span class="lineCov">    1636971 :     case CEIL_MOD_EXPR:</span>
<span class="lineNum">    2435 </span><span class="lineCov">    1636971 :     case FLOOR_MOD_EXPR:</span>
<span class="lineNum">    2436 </span><span class="lineCov">    1636971 :     case ROUND_MOD_EXPR:</span>
<span class="lineNum">    2437 </span><span class="lineCov">    1636971 :     case TRUNC_MOD_EXPR:</span>
<span class="lineNum">    2438 </span><span class="lineCov">    1636971 :     case RDIV_EXPR:</span>
<span class="lineNum">    2439 </span><span class="lineCov">    1636971 :       if (honor_snans)</span>
<span class="lineNum">    2440 </span>            :         return true;
<span class="lineNum">    2441 </span><span class="lineCov">    1636767 :       if (fp_operation)</span>
<span class="lineNum">    2442 </span><span class="lineCov">     273117 :         return flag_trapping_math;</span>
<span class="lineNum">    2443 </span><span class="lineCov">    1363650 :       if (!TREE_CONSTANT (divisor) || integer_zerop (divisor))</span>
<span class="lineNum">    2444 </span><span class="lineCov">     476062 :         return true;</span>
<span class="lineNum">    2445 </span>            :       return false;
<span class="lineNum">    2446 </span>            : 
<span class="lineNum">    2447 </span>            :     case LT_EXPR:
<span class="lineNum">    2448 </span>            :     case LE_EXPR:
<span class="lineNum">    2449 </span>            :     case GT_EXPR:
<span class="lineNum">    2450 </span>            :     case GE_EXPR:
<span class="lineNum">    2451 </span>            :     case LTGT_EXPR:
<span class="lineNum">    2452 </span>            :       /* Some floating point comparisons may trap.  */
<span class="lineNum">    2453 </span>            :       return honor_nans;
<span class="lineNum">    2454 </span>            : 
<span class="lineNum">    2455 </span><span class="lineCov">   32364880 :     case EQ_EXPR:</span>
<span class="lineNum">    2456 </span><span class="lineCov">   32364880 :     case NE_EXPR:</span>
<span class="lineNum">    2457 </span><span class="lineCov">   32364880 :     case UNORDERED_EXPR:</span>
<span class="lineNum">    2458 </span><span class="lineCov">   32364880 :     case ORDERED_EXPR:</span>
<span class="lineNum">    2459 </span><span class="lineCov">   32364880 :     case UNLT_EXPR:</span>
<span class="lineNum">    2460 </span><span class="lineCov">   32364880 :     case UNLE_EXPR:</span>
<span class="lineNum">    2461 </span><span class="lineCov">   32364880 :     case UNGT_EXPR:</span>
<span class="lineNum">    2462 </span><span class="lineCov">   32364880 :     case UNGE_EXPR:</span>
<span class="lineNum">    2463 </span><span class="lineCov">   32364880 :     case UNEQ_EXPR:</span>
<span class="lineNum">    2464 </span><span class="lineCov">   32364880 :       return honor_snans;</span>
<span class="lineNum">    2465 </span>            : 
<span class="lineNum">    2466 </span><span class="lineCov">     710504 :     case NEGATE_EXPR:</span>
<span class="lineNum">    2467 </span><span class="lineCov">     710504 :     case ABS_EXPR:</span>
<span class="lineNum">    2468 </span><span class="lineCov">     710504 :     case CONJ_EXPR:</span>
<span class="lineNum">    2469 </span>            :       /* These operations don't trap with floating point.  */
<span class="lineNum">    2470 </span><span class="lineCov">     710504 :       if (honor_trapv)</span>
<span class="lineNum">    2471 </span><span class="lineCov">        240 :         return true;</span>
<span class="lineNum">    2472 </span>            :       return false;
<span class="lineNum">    2473 </span>            : 
<span class="lineNum">    2474 </span><span class="lineCov">        259 :     case ABSU_EXPR:</span>
<span class="lineNum">    2475 </span>            :       /* ABSU_EXPR never traps.  */
<span class="lineNum">    2476 </span><span class="lineCov">        259 :       return false;</span>
<span class="lineNum">    2477 </span>            : 
<span class="lineNum">    2478 </span><span class="lineCov">   46156798 :     case PLUS_EXPR:</span>
<span class="lineNum">    2479 </span><span class="lineCov">   46156798 :     case MINUS_EXPR:</span>
<span class="lineNum">    2480 </span><span class="lineCov">   46156798 :     case MULT_EXPR:</span>
<span class="lineNum">    2481 </span>            :       /* Any floating arithmetic may trap.  */
<span class="lineNum">    2482 </span><span class="lineCov">   46156798 :       if (fp_operation &amp;&amp; flag_trapping_math)</span>
<span class="lineNum">    2483 </span>            :         return true;
<span class="lineNum">    2484 </span><span class="lineCov">   45349587 :       if (honor_trapv)</span>
<span class="lineNum">    2485 </span><span class="lineCov">       9780 :         return true;</span>
<span class="lineNum">    2486 </span>            :       return false;
<span class="lineNum">    2487 </span>            : 
<span class="lineNum">    2488 </span><span class="lineCov">    6739078 :     case COMPLEX_EXPR:</span>
<span class="lineNum">    2489 </span><span class="lineCov">    6739078 :     case CONSTRUCTOR:</span>
<span class="lineNum">    2490 </span>            :       /* Constructing an object cannot trap.  */
<span class="lineNum">    2491 </span><span class="lineCov">    6739078 :       return false;</span>
<span class="lineNum">    2492 </span>            : 
<span class="lineNum">    2493 </span><span class="lineCov">  779553204 :     default:</span>
<span class="lineNum">    2494 </span>            :       /* Any floating arithmetic may trap.  */
<span class="lineNum">    2495 </span><span class="lineCov">  779553204 :       if (fp_operation &amp;&amp; flag_trapping_math)</span>
<span class="lineNum">    2496 </span>            :         return true;
<span class="lineNum">    2497 </span>            : 
<span class="lineNum">    2498 </span><span class="lineCov">  778453461 :       *handled = false;</span>
<span class="lineNum">    2499 </span><span class="lineCov">  778453461 :       return false;</span>
<span class="lineNum">    2500 </span>            :     }
<span class="lineNum">    2501 </span>            : }
<span class="lineNum">    2502 </span>            : 
<span class="lineNum">    2503 </span>            : /* Return true if operation OP may trap.  FP_OPERATION is true if OP is applied
<span class="lineNum">    2504 </span>            :    on floating-point values.  HONOR_TRAPV is true if OP is applied on integer
<span class="lineNum">    2505 </span>            :    type operands that may trap.  If OP is a division operator, DIVISOR contains
<span class="lineNum">    2506 </span>            :    the value of the divisor.  */
<a name="2507"><span class="lineNum">    2507 </span>            : </a>
<span class="lineNum">    2508 </span>            : bool
<span class="lineNum">    2509 </span><span class="lineCov"> 2074816832 : operation_could_trap_p (enum tree_code op, bool fp_operation, bool honor_trapv,</span>
<span class="lineNum">    2510 </span>            :                         tree divisor)
<span class="lineNum">    2511 </span>            : {
<span class="lineNum">    2512 </span><span class="lineCov">   19431317 :   bool honor_nans = (fp_operation &amp;&amp; flag_trapping_math</span>
<span class="lineNum">    2513 </span><span class="lineCov"> 2087040332 :                      &amp;&amp; !flag_finite_math_only);</span>
<span class="lineNum">    2514 </span><span class="lineCov"> 2074816832 :   bool honor_snans = fp_operation &amp;&amp; flag_signaling_nans != 0;</span>
<span class="lineNum">    2515 </span><span class="lineCov"> 2074816832 :   bool handled;</span>
<span class="lineNum">    2516 </span>            : 
<span class="lineNum">    2517 </span><span class="lineCov"> 4149633664 :   if (TREE_CODE_CLASS (op) != tcc_comparison</span>
<span class="lineNum">    2518 </span>            :       &amp;&amp; TREE_CODE_CLASS (op) != tcc_unary
<span class="lineNum">    2519 </span><span class="lineCov"> 2074816832 :       &amp;&amp; TREE_CODE_CLASS (op) != tcc_binary)</span>
<span class="lineNum">    2520 </span>            :     return false;
<span class="lineNum">    2521 </span>            : 
<span class="lineNum">    2522 </span><span class="lineCov">   49722259 :   return operation_could_trap_helper_p (op, fp_operation, honor_trapv,</span>
<span class="lineNum">    2523 </span>            :                                         honor_nans, honor_snans, divisor,
<span class="lineNum">    2524 </span><span class="lineCov">   49722259 :                                         &amp;handled);</span>
<span class="lineNum">    2525 </span>            : }
<span class="lineNum">    2526 </span>            : 
<span class="lineNum">    2527 </span>            : 
<span class="lineNum">    2528 </span>            : /* Returns true if it is possible to prove that the index of
<span class="lineNum">    2529 </span>            :    an array access REF (an ARRAY_REF expression) falls into the
<span class="lineNum">    2530 </span>            :    array bounds.  */
<a name="2531"><span class="lineNum">    2531 </span>            : </a>
<span class="lineNum">    2532 </span>            : static bool
<span class="lineNum">    2533 </span><span class="lineCov">   64000681 : in_array_bounds_p (tree ref)</span>
<span class="lineNum">    2534 </span>            : {
<span class="lineNum">    2535 </span><span class="lineCov">   64000681 :   tree idx = TREE_OPERAND (ref, 1);</span>
<span class="lineNum">    2536 </span><span class="lineCov">   64000681 :   tree min, max;</span>
<span class="lineNum">    2537 </span>            : 
<span class="lineNum">    2538 </span><span class="lineCov">   64000681 :   if (TREE_CODE (idx) != INTEGER_CST)</span>
<span class="lineNum">    2539 </span>            :     return false;
<span class="lineNum">    2540 </span>            : 
<span class="lineNum">    2541 </span><span class="lineCov">   60406672 :   min = array_ref_low_bound (ref);</span>
<span class="lineNum">    2542 </span><span class="lineCov">   60406672 :   max = array_ref_up_bound (ref);</span>
<span class="lineNum">    2543 </span><span class="lineCov">  120813344 :   if (!min</span>
<span class="lineNum">    2544 </span><span class="lineCov">   60406672 :       || !max</span>
<span class="lineNum">    2545 </span><span class="lineCov">   60404843 :       || TREE_CODE (min) != INTEGER_CST</span>
<span class="lineNum">    2546 </span><span class="lineCov">   60404843 :       || TREE_CODE (max) != INTEGER_CST)</span>
<span class="lineNum">    2547 </span>            :     return false;
<span class="lineNum">    2548 </span>            : 
<span class="lineNum">    2549 </span><span class="lineCov">   60401131 :   if (tree_int_cst_lt (idx, min)</span>
<span class="lineNum">    2550 </span><span class="lineCov">   60401131 :       || tree_int_cst_lt (max, idx))</span>
<span class="lineNum">    2551 </span><span class="lineCov">      28385 :     return false;</span>
<span class="lineNum">    2552 </span>            : 
<span class="lineNum">    2553 </span>            :   return true;
<span class="lineNum">    2554 </span>            : }
<span class="lineNum">    2555 </span>            : 
<span class="lineNum">    2556 </span>            : /* Returns true if it is possible to prove that the range of
<span class="lineNum">    2557 </span>            :    an array access REF (an ARRAY_RANGE_REF expression) falls
<span class="lineNum">    2558 </span>            :    into the array bounds.  */
<a name="2559"><span class="lineNum">    2559 </span>            : </a>
<span class="lineNum">    2560 </span>            : static bool
<span class="lineNum">    2561 </span><span class="lineCov">        210 : range_in_array_bounds_p (tree ref)</span>
<span class="lineNum">    2562 </span>            : {
<span class="lineNum">    2563 </span><span class="lineCov">        210 :   tree domain_type = TYPE_DOMAIN (TREE_TYPE (ref));</span>
<span class="lineNum">    2564 </span><span class="lineCov">        210 :   tree range_min, range_max, min, max;</span>
<span class="lineNum">    2565 </span>            : 
<span class="lineNum">    2566 </span><span class="lineCov">        210 :   range_min = TYPE_MIN_VALUE (domain_type);</span>
<span class="lineNum">    2567 </span><span class="lineCov">        210 :   range_max = TYPE_MAX_VALUE (domain_type);</span>
<span class="lineNum">    2568 </span><span class="lineCov">        420 :   if (!range_min</span>
<span class="lineNum">    2569 </span><span class="lineCov">        210 :       || !range_max</span>
<span class="lineNum">    2570 </span><span class="lineCov">        210 :       || TREE_CODE (range_min) != INTEGER_CST</span>
<span class="lineNum">    2571 </span><span class="lineCov">        210 :       || TREE_CODE (range_max) != INTEGER_CST)</span>
<span class="lineNum">    2572 </span>            :     return false;
<span class="lineNum">    2573 </span>            : 
<span class="lineNum">    2574 </span><span class="lineCov">        210 :   min = array_ref_low_bound (ref);</span>
<span class="lineNum">    2575 </span><span class="lineCov">        210 :   max = array_ref_up_bound (ref);</span>
<span class="lineNum">    2576 </span><span class="lineCov">        420 :   if (!min</span>
<span class="lineNum">    2577 </span><span class="lineCov">        210 :       || !max</span>
<span class="lineNum">    2578 </span><span class="lineCov">        210 :       || TREE_CODE (min) != INTEGER_CST</span>
<span class="lineNum">    2579 </span><span class="lineCov">        210 :       || TREE_CODE (max) != INTEGER_CST)</span>
<span class="lineNum">    2580 </span>            :     return false;
<span class="lineNum">    2581 </span>            : 
<span class="lineNum">    2582 </span><span class="lineCov">        210 :   if (tree_int_cst_lt (range_min, min)</span>
<span class="lineNum">    2583 </span><span class="lineCov">        210 :       || tree_int_cst_lt (max, range_max))</span>
<span class="lineNum">    2584 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2585 </span>            : 
<span class="lineNum">    2586 </span>            :   return true;
<span class="lineNum">    2587 </span>            : }
<span class="lineNum">    2588 </span>            : 
<span class="lineNum">    2589 </span>            : /* Return true if EXPR can trap, as in dereferencing an invalid pointer
<span class="lineNum">    2590 </span>            :    location or floating point arithmetic.  C.f. the rtl version, may_trap_p.
<span class="lineNum">    2591 </span>            :    This routine expects only GIMPLE lhs or rhs input.  */
<a name="2592"><span class="lineNum">    2592 </span>            : </a>
<span class="lineNum">    2593 </span>            : bool
<span class="lineNum">    2594 </span><span class="lineCov"> 2023418327 : tree_could_trap_p (tree expr)</span>
<span class="lineNum">    2595 </span>            : {
<span class="lineNum">    2596 </span><span class="lineCov"> 2023418327 :   enum tree_code code;</span>
<span class="lineNum">    2597 </span><span class="lineCov"> 2023418327 :   bool fp_operation = false;</span>
<span class="lineNum">    2598 </span><span class="lineCov"> 2023418327 :   bool honor_trapv = false;</span>
<span class="lineNum">    2599 </span><span class="lineCov"> 2023418327 :   tree t, base, div = NULL_TREE;</span>
<span class="lineNum">    2600 </span>            : 
<span class="lineNum">    2601 </span><span class="lineCov"> 2023418327 :   if (!expr)</span>
<span class="lineNum">    2602 </span>            :     return false;
<span class="lineNum">    2603 </span>            : 
<span class="lineNum">    2604 </span><span class="lineCov"> 2022232667 :   code = TREE_CODE (expr);</span>
<span class="lineNum">    2605 </span><span class="lineCov"> 2022232667 :   t = TREE_TYPE (expr);</span>
<span class="lineNum">    2606 </span>            : 
<span class="lineNum">    2607 </span><span class="lineCov"> 2022232667 :   if (t)</span>
<span class="lineNum">    2608 </span>            :     {
<span class="lineNum">    2609 </span><span class="lineCov"> 2022180806 :       if (COMPARISON_CLASS_P (expr))</span>
<span class="lineNum">    2610 </span><span class="lineCov">    1747728 :         fp_operation = FLOAT_TYPE_P (TREE_TYPE (TREE_OPERAND (expr, 0)));</span>
<span class="lineNum">    2611 </span>            :       else
<span class="lineNum">    2612 </span><span class="lineCov"> 2020433078 :         fp_operation = FLOAT_TYPE_P (t);</span>
<span class="lineNum">    2613 </span><span class="lineCov"> 2022180806 :       honor_trapv = INTEGRAL_TYPE_P (t) &amp;&amp; TYPE_OVERFLOW_TRAPS (t);</span>
<span class="lineNum">    2614 </span>            :     }
<span class="lineNum">    2615 </span>            : 
<span class="lineNum">    2616 </span><span class="lineCov"> 2022232667 :   if (TREE_CODE_CLASS (code) == tcc_binary)</span>
<span class="lineNum">    2617 </span><span class="lineCov">       5794 :     div = TREE_OPERAND (expr, 1);</span>
<span class="lineNum">    2618 </span><span class="lineCov"> 2022232667 :   if (operation_could_trap_p (code, fp_operation, honor_trapv, div))</span>
<span class="lineNum">    2619 </span>            :     return true;
<span class="lineNum">    2620 </span>            : 
<span class="lineNum">    2621 </span><span class="lineCov"> 2022145041 :  restart:</span>
<span class="lineNum">    2622 </span><span class="lineCov"> 2348903172 :   switch (code)</span>
<span class="lineNum">    2623 </span>            :     {
<span class="lineNum">    2624 </span><span class="lineCov">  326758131 :     case COMPONENT_REF:</span>
<span class="lineNum">    2625 </span><span class="lineCov">  326758131 :     case REALPART_EXPR:</span>
<span class="lineNum">    2626 </span><span class="lineCov">  326758131 :     case IMAGPART_EXPR:</span>
<span class="lineNum">    2627 </span><span class="lineCov">  326758131 :     case BIT_FIELD_REF:</span>
<span class="lineNum">    2628 </span><span class="lineCov">  326758131 :     case VIEW_CONVERT_EXPR:</span>
<span class="lineNum">    2629 </span><span class="lineCov">  326758131 :     case WITH_SIZE_EXPR:</span>
<span class="lineNum">    2630 </span><span class="lineCov">  326758131 :       expr = TREE_OPERAND (expr, 0);</span>
<span class="lineNum">    2631 </span><span class="lineCov">  326758131 :       code = TREE_CODE (expr);</span>
<span class="lineNum">    2632 </span><span class="lineCov">  326758131 :       goto restart;</span>
<span class="lineNum">    2633 </span>            : 
<span class="lineNum">    2634 </span><span class="lineCov">        268 :     case ARRAY_RANGE_REF:</span>
<span class="lineNum">    2635 </span><span class="lineCov">        268 :       base = TREE_OPERAND (expr, 0);</span>
<span class="lineNum">    2636 </span><span class="lineCov">        268 :       if (tree_could_trap_p (base))</span>
<span class="lineNum">    2637 </span>            :         return true;
<span class="lineNum">    2638 </span><span class="lineCov">        210 :       if (TREE_THIS_NOTRAP (expr))</span>
<span class="lineNum">    2639 </span>            :         return false;
<span class="lineNum">    2640 </span><span class="lineCov">        210 :       return !range_in_array_bounds_p (expr);</span>
<span class="lineNum">    2641 </span>            : 
<span class="lineNum">    2642 </span><span class="lineCov">   67214275 :     case ARRAY_REF:</span>
<span class="lineNum">    2643 </span><span class="lineCov">   67214275 :       base = TREE_OPERAND (expr, 0);</span>
<span class="lineNum">    2644 </span><span class="lineCov">   67214275 :       if (tree_could_trap_p (base))</span>
<span class="lineNum">    2645 </span>            :         return true;
<span class="lineNum">    2646 </span><span class="lineCov">   64000681 :       if (TREE_THIS_NOTRAP (expr))</span>
<span class="lineNum">    2647 </span>            :         return false;
<span class="lineNum">    2648 </span><span class="lineCov">   64000681 :       return !in_array_bounds_p (expr);</span>
<span class="lineNum">    2649 </span>            : 
<span class="lineNum">    2650 </span><span class="lineCov">  407303557 :     case TARGET_MEM_REF:</span>
<span class="lineNum">    2651 </span><span class="lineCov">  407303557 :     case MEM_REF:</span>
<span class="lineNum">    2652 </span><span class="lineCov">  407303557 :       if (TREE_CODE (TREE_OPERAND (expr, 0)) == ADDR_EXPR</span>
<span class="lineNum">    2653 </span><span class="lineCov">  407303557 :           &amp;&amp; tree_could_trap_p (TREE_OPERAND (TREE_OPERAND (expr, 0), 0)))</span>
<span class="lineNum">    2654 </span>            :         return true;
<span class="lineNum">    2655 </span><span class="lineCov">  407303557 :       if (TREE_THIS_NOTRAP (expr))</span>
<span class="lineNum">    2656 </span>            :         return false;
<span class="lineNum">    2657 </span>            :       /* We cannot prove that the access is in-bounds when we have
<span class="lineNum">    2658 </span>            :          variable-index TARGET_MEM_REFs.  */
<span class="lineNum">    2659 </span><span class="lineCov">  371961784 :       if (code == TARGET_MEM_REF</span>
<span class="lineNum">    2660 </span><span class="lineCov">  371961784 :           &amp;&amp; (TMR_INDEX (expr) || TMR_INDEX2 (expr)))</span>
<span class="lineNum">    2661 </span>            :         return true;
<span class="lineNum">    2662 </span><span class="lineCov">  368713133 :       if (TREE_CODE (TREE_OPERAND (expr, 0)) == ADDR_EXPR)</span>
<span class="lineNum">    2663 </span>            :         {
<span class="lineNum">    2664 </span><span class="lineCov">  230310925 :           tree base = TREE_OPERAND (TREE_OPERAND (expr, 0), 0);</span>
<span class="lineNum">    2665 </span><span class="lineCov">  230310925 :           poly_offset_int off = mem_ref_offset (expr);</span>
<span class="lineNum">    2666 </span><span class="lineCov">  460621850 :           if (maybe_lt (off, 0))</span>
<span class="lineNum">    2667 </span>            :             return true;
<span class="lineNum">    2668 </span><span class="lineCov">  230310592 :           if (TREE_CODE (base) == STRING_CST)</span>
<span class="lineNum">    2669 </span><span class="lineCov">     109956 :             return maybe_le (TREE_STRING_LENGTH (base), off);</span>
<span class="lineNum">    2670 </span><span class="lineCov">  230273940 :           tree size = DECL_SIZE_UNIT (base);</span>
<span class="lineNum">    2671 </span><span class="lineCov">  230273940 :           if (size == NULL_TREE</span>
<span class="lineNum">    2672 </span><span class="lineCov">  460515872 :               || !poly_int_tree_p (size)</span>
<span class="lineNum">    2673 </span><span class="lineCov">  460531866 :               || maybe_le (wi::to_poly_offset (size), off))</span>
<span class="lineNum">    2674 </span><span class="lineCov">      21646 :             return true;</span>
<span class="lineNum">    2675 </span>            :           /* Now we are sure the first byte of the access is inside
<span class="lineNum">    2676 </span>            :              the object.  */
<span class="lineNum">    2677 </span><span class="lineCov">  230252294 :           return false;</span>
<span class="lineNum">    2678 </span><span class="lineCov">  138402208 :         }</span>
<span class="lineNum">    2679 </span>            :       return true;
<span class="lineNum">    2680 </span>            : 
<span class="lineNum">    2681 </span><span class="lineCov">       4607 :     case INDIRECT_REF:</span>
<span class="lineNum">    2682 </span><span class="lineCov">       4607 :       return !TREE_THIS_NOTRAP (expr);</span>
<span class="lineNum">    2683 </span>            : 
<span class="lineNum">    2684 </span><span class="lineNoCov">          0 :     case ASM_EXPR:</span>
<span class="lineNum">    2685 </span><span class="lineNoCov">          0 :       return TREE_THIS_VOLATILE (expr);</span>
<span class="lineNum">    2686 </span>            : 
<span class="lineNum">    2687 </span><span class="lineCov">        688 :     case CALL_EXPR:</span>
<span class="lineNum">    2688 </span><span class="lineCov">        688 :       t = get_callee_fndecl (expr);</span>
<span class="lineNum">    2689 </span>            :       /* Assume that calls to weak functions may trap.  */
<span class="lineNum">    2690 </span><span class="lineCov">        688 :       if (!t || !DECL_P (t))</span>
<span class="lineNum">    2691 </span>            :         return true;
<span class="lineNum">    2692 </span><span class="lineCov">        688 :       if (DECL_WEAK (t))</span>
<span class="lineNum">    2693 </span><span class="lineNoCov">          0 :         return tree_could_trap_p (t);</span>
<span class="lineNum">    2694 </span>            :       return false;
<span class="lineNum">    2695 </span>            : 
<span class="lineNum">    2696 </span><span class="lineCov">         75 :     case FUNCTION_DECL:</span>
<span class="lineNum">    2697 </span>            :       /* Assume that accesses to weak functions may trap, unless we know
<span class="lineNum">    2698 </span>            :          they are certainly defined in current TU or in some other
<span class="lineNum">    2699 </span>            :          LTO partition.  */
<span class="lineNum">    2700 </span><span class="lineCov">         75 :       if (DECL_WEAK (expr) &amp;&amp; !DECL_COMDAT (expr) &amp;&amp; DECL_EXTERNAL (expr))</span>
<span class="lineNum">    2701 </span>            :         {
<span class="lineNum">    2702 </span><span class="lineNoCov">          0 :           cgraph_node *node = cgraph_node::get (expr);</span>
<span class="lineNum">    2703 </span><span class="lineNoCov">          0 :           if (node)</span>
<span class="lineNum">    2704 </span><span class="lineNoCov">          0 :             node = node-&gt;function_symbol ();</span>
<span class="lineNum">    2705 </span><span class="lineNoCov">          0 :           return !(node &amp;&amp; node-&gt;in_other_partition);</span>
<span class="lineNum">    2706 </span>            :         }
<span class="lineNum">    2707 </span>            :       return false;
<span class="lineNum">    2708 </span>            : 
<span class="lineNum">    2709 </span><span class="lineCov">  570972824 :     case VAR_DECL:</span>
<span class="lineNum">    2710 </span>            :       /* Assume that accesses to weak vars may trap, unless we know
<span class="lineNum">    2711 </span>            :          they are certainly defined in current TU or in some other
<span class="lineNum">    2712 </span>            :          LTO partition.  */
<span class="lineNum">    2713 </span><span class="lineCov">  570972824 :       if (DECL_WEAK (expr) &amp;&amp; !DECL_COMDAT (expr) &amp;&amp; DECL_EXTERNAL (expr))</span>
<span class="lineNum">    2714 </span>            :         {
<span class="lineNum">    2715 </span><span class="lineCov">       2268 :           varpool_node *node = varpool_node::get (expr);</span>
<span class="lineNum">    2716 </span><span class="lineCov">       2268 :           if (node)</span>
<span class="lineNum">    2717 </span><span class="lineCov">       2268 :             node = node-&gt;ultimate_alias_target ();</span>
<span class="lineNum">    2718 </span><span class="lineCov">       2268 :           return !(node &amp;&amp; node-&gt;in_other_partition);</span>
<span class="lineNum">    2719 </span>            :         }
<span class="lineNum">    2720 </span>            :       return false;
<span class="lineNum">    2721 </span>            : 
<span class="lineNum">    2722 </span>            :     default:
<span class="lineNum">    2723 </span>            :       return false;
<span class="lineNum">    2724 </span>            :     }
<span class="lineNum">    2725 </span>            : }
<span class="lineNum">    2726 </span>            : 
<span class="lineNum">    2727 </span>            : /* Return non-NULL if there is an integer operation with trapping overflow
<span class="lineNum">    2728 </span>            :    we can rewrite into non-trapping.  Called via walk_tree from
<span class="lineNum">    2729 </span>            :    rewrite_to_non_trapping_overflow.  */
<a name="2730"><span class="lineNum">    2730 </span>            : </a>
<span class="lineNum">    2731 </span>            : static tree
<span class="lineNum">    2732 </span><span class="lineCov">         43 : find_trapping_overflow (tree *tp, int *walk_subtrees, void *data)</span>
<span class="lineNum">    2733 </span>            : {
<span class="lineNum">    2734 </span><span class="lineCov">         43 :   if (EXPR_P (*tp)</span>
<span class="lineNum">    2735 </span><span class="lineCov">         24 :       &amp;&amp; ANY_INTEGRAL_TYPE_P (TREE_TYPE (*tp))</span>
<span class="lineNum">    2736 </span><span class="lineCov">         85 :       &amp;&amp; !operation_no_trapping_overflow (TREE_TYPE (*tp), TREE_CODE (*tp)))</span>
<span class="lineNum">    2737 </span><span class="lineCov">          5 :     return *tp;</span>
<span class="lineNum">    2738 </span><span class="lineCov">         38 :   if (IS_TYPE_OR_DECL_P (*tp)</span>
<span class="lineNum">    2739 </span><span class="lineCov">         37 :       || (TREE_CODE (*tp) == SAVE_EXPR &amp;&amp; data == NULL))</span>
<span class="lineNum">    2740 </span><span class="lineCov">          1 :     *walk_subtrees = 0;</span>
<span class="lineNum">    2741 </span>            :   return NULL_TREE;
<span class="lineNum">    2742 </span>            : }
<span class="lineNum">    2743 </span>            : 
<span class="lineNum">    2744 </span>            : /* Rewrite selected operations into unsigned arithmetics, so that they
<span class="lineNum">    2745 </span>            :    don't trap on overflow.  */
<a name="2746"><span class="lineNum">    2746 </span>            : </a>
<span class="lineNum">    2747 </span>            : static tree
<span class="lineNum">    2748 </span><span class="lineCov">         16 : replace_trapping_overflow (tree *tp, int *walk_subtrees, void *data)</span>
<span class="lineNum">    2749 </span>            : {
<span class="lineNum">    2750 </span><span class="lineCov">         16 :   if (find_trapping_overflow (tp, walk_subtrees, data))</span>
<span class="lineNum">    2751 </span>            :     {
<span class="lineNum">    2752 </span><span class="lineCov">          3 :       tree type = TREE_TYPE (*tp);</span>
<span class="lineNum">    2753 </span><span class="lineCov">          3 :       tree utype = unsigned_type_for (type);</span>
<span class="lineNum">    2754 </span><span class="lineCov">          3 :       *walk_subtrees = 0;</span>
<span class="lineNum">    2755 </span><span class="lineCov">          3 :       int len = TREE_OPERAND_LENGTH (*tp);</span>
<span class="lineNum">    2756 </span><span class="lineCov">          9 :       for (int i = 0; i &lt; len; ++i)</span>
<span class="lineNum">    2757 </span><span class="lineCov">          6 :         walk_tree (&amp;TREE_OPERAND (*tp, i), replace_trapping_overflow,</span>
<span class="lineNum">    2758 </span>            :                    data, (hash_set&lt;tree&gt; *) data);
<span class="lineNum">    2759 </span>            : 
<span class="lineNum">    2760 </span><span class="lineCov">          3 :       if (TREE_CODE (*tp) == ABS_EXPR)</span>
<span class="lineNum">    2761 </span>            :         {
<span class="lineNum">    2762 </span><span class="lineNoCov">          0 :           tree op = TREE_OPERAND (*tp, 0);</span>
<span class="lineNum">    2763 </span><span class="lineNoCov">          0 :           op = save_expr (op);</span>
<span class="lineNum">    2764 </span>            :           /* save_expr skips simple arithmetics, which is undesirable
<span class="lineNum">    2765 </span>            :              here, if it might trap due to flag_trapv.  We need to
<span class="lineNum">    2766 </span>            :              force a SAVE_EXPR in the COND_EXPR condition, to evaluate
<span class="lineNum">    2767 </span>            :              it before the comparison.  */
<span class="lineNum">    2768 </span><span class="lineNoCov">          0 :           if (EXPR_P (op)</span>
<span class="lineNum">    2769 </span><span class="lineNoCov">          0 :               &amp;&amp; TREE_CODE (op) != SAVE_EXPR</span>
<span class="lineNum">    2770 </span><span class="lineNoCov">          0 :               &amp;&amp; walk_tree (&amp;op, find_trapping_overflow, NULL, NULL))</span>
<span class="lineNum">    2771 </span>            :             {
<span class="lineNum">    2772 </span><span class="lineNoCov">          0 :               op = build1_loc (EXPR_LOCATION (op), SAVE_EXPR, type, op);</span>
<span class="lineNum">    2773 </span><span class="lineNoCov">          0 :               TREE_SIDE_EFFECTS (op) = 1;</span>
<span class="lineNum">    2774 </span>            :             }
<span class="lineNum">    2775 </span>            :           /* Change abs (op) to op &lt; 0 ? -op : op and handle the NEGATE_EXPR
<span class="lineNum">    2776 </span>            :              like other signed integer trapping operations.  */
<span class="lineNum">    2777 </span><span class="lineNoCov">          0 :           tree cond = fold_build2 (LT_EXPR, boolean_type_node,</span>
<span class="lineNum">    2778 </span>            :                                    op, build_int_cst (type, 0));
<span class="lineNum">    2779 </span><span class="lineNoCov">          0 :           tree neg = fold_build1 (NEGATE_EXPR, utype,</span>
<span class="lineNum">    2780 </span>            :                                   fold_convert (utype, op));
<span class="lineNum">    2781 </span><span class="lineNoCov">          0 :           *tp = fold_build3 (COND_EXPR, type, cond,</span>
<span class="lineNum">    2782 </span>            :                              fold_convert (type, neg), op);
<span class="lineNum">    2783 </span>            :         }
<span class="lineNum">    2784 </span>            :       else
<span class="lineNum">    2785 </span>            :         {
<span class="lineNum">    2786 </span><span class="lineCov">          3 :           TREE_TYPE (*tp) = utype;</span>
<span class="lineNum">    2787 </span><span class="lineCov">          3 :           len = TREE_OPERAND_LENGTH (*tp);</span>
<span class="lineNum">    2788 </span><span class="lineCov">          9 :           for (int i = 0; i &lt; len; ++i)</span>
<span class="lineNum">    2789 </span><span class="lineCov">         12 :             TREE_OPERAND (*tp, i)</span>
<span class="lineNum">    2790 </span><span class="lineCov">          6 :               = fold_convert (utype, TREE_OPERAND (*tp, i));</span>
<span class="lineNum">    2791 </span><span class="lineCov">          3 :           *tp = fold_convert (type, *tp);</span>
<span class="lineNum">    2792 </span>            :         }
<span class="lineNum">    2793 </span>            :     }
<span class="lineNum">    2794 </span><span class="lineCov">         16 :   return NULL_TREE;</span>
<span class="lineNum">    2795 </span>            : }
<span class="lineNum">    2796 </span>            : 
<span class="lineNum">    2797 </span>            : /* If any subexpression of EXPR can trap due to -ftrapv, rewrite it
<span class="lineNum">    2798 </span>            :    using unsigned arithmetics to avoid traps in it.  */
<a name="2799"><span class="lineNum">    2799 </span>            : </a>
<span class="lineNum">    2800 </span>            : tree
<span class="lineNum">    2801 </span><span class="lineCov">       9268 : rewrite_to_non_trapping_overflow (tree expr)</span>
<span class="lineNum">    2802 </span>            : {
<span class="lineNum">    2803 </span><span class="lineCov">       9268 :   if (!flag_trapv)</span>
<span class="lineNum">    2804 </span><span class="lineCov">       9258 :     return expr;</span>
<span class="lineNum">    2805 </span><span class="lineCov">         20 :   hash_set&lt;tree&gt; pset;</span>
<span class="lineNum">    2806 </span><span class="lineCov">         10 :   if (!walk_tree (&amp;expr, find_trapping_overflow, &amp;pset, &amp;pset))</span>
<span class="lineNum">    2807 </span><span class="lineCov">          8 :     return expr;</span>
<span class="lineNum">    2808 </span><span class="lineCov">          2 :   expr = unshare_expr (expr);</span>
<span class="lineNum">    2809 </span><span class="lineCov">          2 :   pset.empty ();</span>
<span class="lineNum">    2810 </span><span class="lineCov">          2 :   walk_tree (&amp;expr, replace_trapping_overflow, &amp;pset, &amp;pset);</span>
<span class="lineNum">    2811 </span><span class="lineCov">          2 :   return expr;</span>
<span class="lineNum">    2812 </span>            : }
<span class="lineNum">    2813 </span>            : 
<span class="lineNum">    2814 </span>            : /* Helper for stmt_could_throw_p.  Return true if STMT (assumed to be a
<span class="lineNum">    2815 </span>            :    an assignment or a conditional) may throw.  */
<a name="2816"><span class="lineNum">    2816 </span>            : </a>
<span class="lineNum">    2817 </span>            : static bool
<span class="lineNum">    2818 </span><span class="lineCov">  871529081 : stmt_could_throw_1_p (gassign *stmt)</span>
<span class="lineNum">    2819 </span>            : {
<span class="lineNum">    2820 </span><span class="lineCov">  871529081 :   enum tree_code code = gimple_assign_rhs_code (stmt);</span>
<span class="lineNum">    2821 </span><span class="lineCov">  871529081 :   bool honor_nans = false;</span>
<span class="lineNum">    2822 </span><span class="lineCov">  871529081 :   bool honor_snans = false;</span>
<span class="lineNum">    2823 </span><span class="lineCov">  871529081 :   bool fp_operation = false;</span>
<span class="lineNum">    2824 </span><span class="lineCov">  871529081 :   bool honor_trapv = false;</span>
<span class="lineNum">    2825 </span><span class="lineCov">  871529081 :   tree t;</span>
<span class="lineNum">    2826 </span><span class="lineCov">  871529081 :   size_t i;</span>
<span class="lineNum">    2827 </span><span class="lineCov">  871529081 :   bool handled, ret;</span>
<span class="lineNum">    2828 </span>            : 
<span class="lineNum">    2829 </span><span class="lineCov"> 1743058162 :   if (TREE_CODE_CLASS (code) == tcc_comparison</span>
<span class="lineNum">    2830 </span>            :       || TREE_CODE_CLASS (code) == tcc_unary
<span class="lineNum">    2831 </span><span class="lineCov">  871529081 :       || TREE_CODE_CLASS (code) == tcc_binary)</span>
<span class="lineNum">    2832 </span>            :     {
<span class="lineNum">    2833 </span><span class="lineCov">  127722419 :       if (TREE_CODE_CLASS (code) == tcc_comparison)</span>
<span class="lineNum">    2834 </span><span class="lineCov">   34480010 :         t = TREE_TYPE (gimple_assign_rhs1 (stmt));</span>
<span class="lineNum">    2835 </span>            :       else
<span class="lineNum">    2836 </span><span class="lineCov">  110482414 :         t = gimple_expr_type (stmt);</span>
<span class="lineNum">    2837 </span><span class="lineCov">  127722419 :       fp_operation = FLOAT_TYPE_P (t);</span>
<span class="lineNum">    2838 </span><span class="lineCov">  127722419 :       if (fp_operation)</span>
<span class="lineNum">    2839 </span>            :         {
<span class="lineNum">    2840 </span><span class="lineCov">    4744352 :           honor_nans = flag_trapping_math &amp;&amp; !flag_finite_math_only;</span>
<span class="lineNum">    2841 </span><span class="lineCov">    4744352 :           honor_snans = flag_signaling_nans != 0;</span>
<span class="lineNum">    2842 </span>            :         }
<span class="lineNum">    2843 </span><span class="lineCov">  122978067 :       else if (INTEGRAL_TYPE_P (t) &amp;&amp; TYPE_OVERFLOW_TRAPS (t))</span>
<span class="lineNum">    2844 </span>            :         honor_trapv = true;
<span class="lineNum">    2845 </span>            :     }
<span class="lineNum">    2846 </span>            : 
<span class="lineNum">    2847 </span>            :   /* First check the LHS.  */
<span class="lineNum">    2848 </span><span class="lineCov"> 1743058162 :   if (tree_could_trap_p (gimple_assign_lhs (stmt)))</span>
<span class="lineNum">    2849 </span>            :     return true;
<span class="lineNum">    2850 </span>            : 
<span class="lineNum">    2851 </span>            :   /* Check if the main expression may trap.  */
<span class="lineNum">    2852 </span><span class="lineCov">  927145988 :   ret = operation_could_trap_helper_p (code, fp_operation, honor_trapv,</span>
<span class="lineNum">    2853 </span>            :                                        honor_nans, honor_snans,
<span class="lineNum">    2854 </span>            :                                        gimple_assign_rhs2 (stmt),
<span class="lineNum">    2855 </span>            :                                        &amp;handled);
<span class="lineNum">    2856 </span><span class="lineCov">  840971938 :   if (handled)</span>
<span class="lineNum">    2857 </span>            :     return ret;
<span class="lineNum">    2858 </span>            : 
<span class="lineNum">    2859 </span>            :   /* If the expression does not trap, see if any of the individual operands may
<span class="lineNum">    2860 </span>            :      trap.  */
<span class="lineNum">    2861 </span><span class="lineCov"> 2237188324 :   for (i = 1; i &lt; gimple_num_ops (stmt); i++)</span>
<span class="lineNum">    2862 </span><span class="lineCov">  798604023 :     if (tree_could_trap_p (gimple_op (stmt, i)))</span>
<span class="lineNum">    2863 </span>            :       return true;
<span class="lineNum">    2864 </span>            : 
<span class="lineNum">    2865 </span>            :   return false;
<span class="lineNum">    2866 </span>            : }
<span class="lineNum">    2867 </span>            : 
<span class="lineNum">    2868 </span>            : 
<span class="lineNum">    2869 </span>            : /* Return true if statement STMT could throw an exception.  */
<a name="2870"><span class="lineNum">    2870 </span>            : </a>
<span class="lineNum">    2871 </span>            : bool
<span class="lineNum">    2872 </span><span class="lineCov"> 8824279671 : stmt_could_throw_p (gimple *stmt)</span>
<span class="lineNum">    2873 </span>            : {
<span class="lineNum">    2874 </span><span class="lineCov"> 8824279671 :   if (!flag_exceptions)</span>
<span class="lineNum">    2875 </span>            :     return false;
<span class="lineNum">    2876 </span>            : 
<span class="lineNum">    2877 </span>            :   /* The only statements that can throw an exception are assignments,
<span class="lineNum">    2878 </span>            :      conditionals, calls, resx, and asms.  */
<span class="lineNum">    2879 </span><span class="lineCov">13143410700 :   switch (gimple_code (stmt))</span>
<span class="lineNum">    2880 </span>            :     {
<span class="lineNum">    2881 </span>            :     case GIMPLE_RESX:
<span class="lineNum">    2882 </span>            :       return true;
<span class="lineNum">    2883 </span>            : 
<span class="lineNum">    2884 </span><span class="lineCov">  617201773 :     case GIMPLE_CALL:</span>
<span class="lineNum">    2885 </span><span class="lineCov">  617201773 :       return !gimple_call_nothrow_p (as_a &lt;gcall *&gt; (stmt));</span>
<span class="lineNum">    2886 </span>            : 
<span class="lineNum">    2887 </span><span class="lineCov">   79761338 :     case GIMPLE_COND:</span>
<span class="lineNum">    2888 </span><span class="lineCov">   79761338 :       {</span>
<span class="lineNum">    2889 </span><span class="lineCov">   79761338 :         if (!cfun-&gt;can_throw_non_call_exceptions)</span>
<span class="lineNum">    2890 </span>            :           return false;
<span class="lineNum">    2891 </span><span class="lineCov">   34182968 :         gcond *cond = as_a &lt;gcond *&gt; (stmt);</span>
<span class="lineNum">    2892 </span><span class="lineCov">   34182968 :         tree lhs = gimple_cond_lhs (cond);</span>
<span class="lineNum">    2893 </span><span class="lineCov">   68365936 :         return operation_could_trap_p (gimple_cond_code (cond),</span>
<span class="lineNum">    2894 </span><span class="lineCov">   34182968 :                                        FLOAT_TYPE_P (TREE_TYPE (lhs)),</span>
<span class="lineNum">    2895 </span><span class="lineCov">   34182968 :                                        false, NULL_TREE);</span>
<span class="lineNum">    2896 </span>            :       }
<span class="lineNum">    2897 </span>            : 
<span class="lineNum">    2898 </span><span class="lineCov"> 1795324265 :     case GIMPLE_ASSIGN:</span>
<span class="lineNum">    2899 </span><span class="lineCov"> 1795324265 :       if (!cfun-&gt;can_throw_non_call_exceptions</span>
<span class="lineNum">    2900 </span><span class="lineCov"> 1795324265 :           || gimple_clobber_p (stmt))</span>
<span class="lineNum">    2901 </span>            :         return false;
<span class="lineNum">    2902 </span><span class="lineCov">  871529081 :       return stmt_could_throw_1_p (as_a &lt;gassign *&gt; (stmt));</span>
<span class="lineNum">    2903 </span>            : 
<span class="lineNum">    2904 </span><span class="lineCov">     630203 :     case GIMPLE_ASM:</span>
<span class="lineNum">    2905 </span><span class="lineCov">     630203 :       if (!cfun-&gt;can_throw_non_call_exceptions)</span>
<span class="lineNum">    2906 </span>            :         return false;
<span class="lineNum">    2907 </span><span class="lineCov">      45676 :       return gimple_asm_volatile_p (as_a &lt;gasm *&gt; (stmt));</span>
<span class="lineNum">    2908 </span>            : 
<span class="lineNum">    2909 </span><span class="lineCov"> 4043547456 :     default:</span>
<span class="lineNum">    2910 </span><span class="lineCov"> 4043547456 :       return false;</span>
<span class="lineNum">    2911 </span>            :     }
<span class="lineNum">    2912 </span>            : }
<span class="lineNum">    2913 </span>            : 
<span class="lineNum">    2914 </span>            : 
<span class="lineNum">    2915 </span>            : /* Return true if expression T could throw an exception.  */
<a name="2916"><span class="lineNum">    2916 </span>            : </a>
<span class="lineNum">    2917 </span>            : bool
<span class="lineNum">    2918 </span><span class="lineCov">   20905720 : tree_could_throw_p (tree t)</span>
<span class="lineNum">    2919 </span>            : {
<span class="lineNum">    2920 </span><span class="lineCov">   20905720 :   if (!flag_exceptions)</span>
<span class="lineNum">    2921 </span>            :     return false;
<span class="lineNum">    2922 </span><span class="lineCov">   17735021 :   if (TREE_CODE (t) == MODIFY_EXPR)</span>
<span class="lineNum">    2923 </span>            :     {
<span class="lineNum">    2924 </span><span class="lineNoCov">          0 :       if (cfun-&gt;can_throw_non_call_exceptions</span>
<span class="lineNum">    2925 </span><span class="lineNoCov">          0 :           &amp;&amp; tree_could_trap_p (TREE_OPERAND (t, 0)))</span>
<span class="lineNum">    2926 </span>            :         return true;
<span class="lineNum">    2927 </span><span class="lineNoCov">          0 :       t = TREE_OPERAND (t, 1);</span>
<span class="lineNum">    2928 </span>            :     }
<span class="lineNum">    2929 </span>            : 
<span class="lineNum">    2930 </span><span class="lineCov">   17735021 :   if (TREE_CODE (t) == WITH_SIZE_EXPR)</span>
<span class="lineNum">    2931 </span><span class="lineNoCov">          0 :     t = TREE_OPERAND (t, 0);</span>
<span class="lineNum">    2932 </span><span class="lineCov">   17735021 :   if (TREE_CODE (t) == CALL_EXPR)</span>
<span class="lineNum">    2933 </span><span class="lineNoCov">          0 :     return (call_expr_flags (t) &amp; ECF_NOTHROW) == 0;</span>
<span class="lineNum">    2934 </span><span class="lineCov">   17735021 :   if (cfun-&gt;can_throw_non_call_exceptions)</span>
<span class="lineNum">    2935 </span><span class="lineCov">   11948152 :     return tree_could_trap_p (t);</span>
<span class="lineNum">    2936 </span>            :   return false;
<span class="lineNum">    2937 </span>            : }
<span class="lineNum">    2938 </span>            : 
<span class="lineNum">    2939 </span>            : /* Return true if STMT can throw an exception that is not caught within
<span class="lineNum">    2940 </span>            :    the current function (CFUN).  */
<a name="2941"><span class="lineNum">    2941 </span>            : </a>
<span class="lineNum">    2942 </span>            : bool
<span class="lineNum">    2943 </span><span class="lineCov">  266046121 : stmt_can_throw_external (gimple *stmt)</span>
<span class="lineNum">    2944 </span>            : {
<span class="lineNum">    2945 </span><span class="lineCov">  266046121 :   int lp_nr;</span>
<span class="lineNum">    2946 </span>            : 
<span class="lineNum">    2947 </span><span class="lineCov">  266046121 :   if (!stmt_could_throw_p (stmt))</span>
<span class="lineNum">    2948 </span>            :     return false;
<span class="lineNum">    2949 </span>            : 
<span class="lineNum">    2950 </span><span class="lineCov">   20762714 :   lp_nr = lookup_stmt_eh_lp (stmt);</span>
<span class="lineNum">    2951 </span><span class="lineCov">   20762714 :   return lp_nr == 0;</span>
<span class="lineNum">    2952 </span>            : }
<span class="lineNum">    2953 </span>            : 
<span class="lineNum">    2954 </span>            : /* Return true if STMT can throw an exception that is caught within
<span class="lineNum">    2955 </span>            :    the current function (CFUN).  */
<a name="2956"><span class="lineNum">    2956 </span>            : </a>
<span class="lineNum">    2957 </span>            : bool
<span class="lineNum">    2958 </span><span class="lineCov"> 7621062709 : stmt_can_throw_internal (gimple *stmt)</span>
<span class="lineNum">    2959 </span>            : {
<span class="lineNum">    2960 </span><span class="lineCov"> 7621062709 :   int lp_nr;</span>
<span class="lineNum">    2961 </span>            : 
<span class="lineNum">    2962 </span><span class="lineCov"> 7621062709 :   if (!stmt_could_throw_p (stmt))</span>
<span class="lineNum">    2963 </span>            :     return false;
<span class="lineNum">    2964 </span>            : 
<span class="lineNum">    2965 </span><span class="lineCov">  335995474 :   lp_nr = lookup_stmt_eh_lp (stmt);</span>
<span class="lineNum">    2966 </span><span class="lineCov">  335995474 :   return lp_nr &gt; 0;</span>
<span class="lineNum">    2967 </span>            : }
<span class="lineNum">    2968 </span>            : 
<span class="lineNum">    2969 </span>            : /* Given a statement STMT in IFUN, if STMT can no longer throw, then
<span class="lineNum">    2970 </span>            :    remove any entry it might have from the EH table.  Return true if
<span class="lineNum">    2971 </span>            :    any change was made.  */
<a name="2972"><span class="lineNum">    2972 </span>            : </a>
<span class="lineNum">    2973 </span>            : bool
<span class="lineNum">    2974 </span><span class="lineCov">  315831034 : maybe_clean_eh_stmt_fn (struct function *ifun, gimple *stmt)</span>
<span class="lineNum">    2975 </span>            : {
<span class="lineNum">    2976 </span><span class="lineCov">  315831034 :   if (stmt_could_throw_p (stmt))</span>
<span class="lineNum">    2977 </span>            :     return false;
<span class="lineNum">    2978 </span><span class="lineCov">  300252844 :   return remove_stmt_from_eh_lp_fn (ifun, stmt);</span>
<span class="lineNum">    2979 </span>            : }
<span class="lineNum">    2980 </span>            : 
<span class="lineNum">    2981 </span>            : /* Likewise, but always use the current function.  */
<a name="2982"><span class="lineNum">    2982 </span>            : </a>
<span class="lineNum">    2983 </span>            : bool
<span class="lineNum">    2984 </span><span class="lineCov">  315346255 : maybe_clean_eh_stmt (gimple *stmt)</span>
<span class="lineNum">    2985 </span>            : {
<span class="lineNum">    2986 </span><span class="lineCov">  315346255 :   return maybe_clean_eh_stmt_fn (cfun, stmt);</span>
<span class="lineNum">    2987 </span>            : }
<span class="lineNum">    2988 </span>            : 
<span class="lineNum">    2989 </span>            : /* Given a statement OLD_STMT and a new statement NEW_STMT that has replaced
<span class="lineNum">    2990 </span>            :    OLD_STMT in the function, remove OLD_STMT from the EH table and put NEW_STMT
<span class="lineNum">    2991 </span>            :    in the table if it should be in there.  Return TRUE if a replacement was
<span class="lineNum">    2992 </span>            :    done that my require an EH edge purge.  */
<a name="2993"><span class="lineNum">    2993 </span>            : </a>
<span class="lineNum">    2994 </span>            : bool
<span class="lineNum">    2995 </span><span class="lineCov">   25606054 : maybe_clean_or_replace_eh_stmt (gimple *old_stmt, gimple *new_stmt)</span>
<span class="lineNum">    2996 </span>            : {
<span class="lineNum">    2997 </span><span class="lineCov">   25606054 :   int lp_nr = lookup_stmt_eh_lp (old_stmt);</span>
<span class="lineNum">    2998 </span>            : 
<span class="lineNum">    2999 </span><span class="lineCov">   25606054 :   if (lp_nr != 0)</span>
<span class="lineNum">    3000 </span>            :     {
<span class="lineNum">    3001 </span><span class="lineCov">     774311 :       bool new_stmt_could_throw = stmt_could_throw_p (new_stmt);</span>
<span class="lineNum">    3002 </span>            : 
<span class="lineNum">    3003 </span><span class="lineCov">     774311 :       if (new_stmt == old_stmt &amp;&amp; new_stmt_could_throw)</span>
<span class="lineNum">    3004 </span>            :         return false;
<span class="lineNum">    3005 </span>            : 
<span class="lineNum">    3006 </span><span class="lineCov">     121182 :       remove_stmt_from_eh_lp (old_stmt);</span>
<span class="lineNum">    3007 </span><span class="lineCov">     121182 :       if (new_stmt_could_throw)</span>
<span class="lineNum">    3008 </span>            :         {
<span class="lineNum">    3009 </span><span class="lineCov">      32711 :           add_stmt_to_eh_lp (new_stmt, lp_nr);</span>
<span class="lineNum">    3010 </span><span class="lineCov">      32711 :           return false;</span>
<span class="lineNum">    3011 </span>            :         }
<span class="lineNum">    3012 </span>            :       else
<span class="lineNum">    3013 </span>            :         return true;
<span class="lineNum">    3014 </span>            :     }
<span class="lineNum">    3015 </span>            : 
<span class="lineNum">    3016 </span>            :   return false;
<span class="lineNum">    3017 </span>            : }
<span class="lineNum">    3018 </span>            : 
<span class="lineNum">    3019 </span>            : /* Given a statement OLD_STMT in OLD_FUN and a duplicate statement NEW_STMT
<span class="lineNum">    3020 </span>            :    in NEW_FUN, copy the EH table data from OLD_STMT to NEW_STMT.  The MAP
<span class="lineNum">    3021 </span>            :    operand is the return value of duplicate_eh_regions.  */
<a name="3022"><span class="lineNum">    3022 </span>            : </a>
<span class="lineNum">    3023 </span>            : bool
<span class="lineNum">    3024 </span><span class="lineCov">   49968610 : maybe_duplicate_eh_stmt_fn (struct function *new_fun, gimple *new_stmt,</span>
<span class="lineNum">    3025 </span>            :                             struct function *old_fun, gimple *old_stmt,
<span class="lineNum">    3026 </span>            :                             hash_map&lt;void *, void *&gt; *map,
<span class="lineNum">    3027 </span>            :                             int default_lp_nr)
<span class="lineNum">    3028 </span>            : {
<span class="lineNum">    3029 </span><span class="lineCov">   49968610 :   int old_lp_nr, new_lp_nr;</span>
<span class="lineNum">    3030 </span>            : 
<span class="lineNum">    3031 </span><span class="lineCov">   49968610 :   if (!stmt_could_throw_p (new_stmt))</span>
<span class="lineNum">    3032 </span>            :     return false;
<span class="lineNum">    3033 </span>            : 
<span class="lineNum">    3034 </span><span class="lineCov">     849070 :   old_lp_nr = lookup_stmt_eh_lp_fn (old_fun, old_stmt);</span>
<span class="lineNum">    3035 </span><span class="lineCov">     849070 :   if (old_lp_nr == 0)</span>
<span class="lineNum">    3036 </span>            :     {
<span class="lineNum">    3037 </span><span class="lineCov">     695969 :       if (default_lp_nr == 0)</span>
<span class="lineNum">    3038 </span>            :         return false;
<span class="lineNum">    3039 </span>            :       new_lp_nr = default_lp_nr;
<span class="lineNum">    3040 </span>            :     }
<span class="lineNum">    3041 </span><span class="lineCov">     153101 :   else if (old_lp_nr &gt; 0)</span>
<span class="lineNum">    3042 </span>            :     {
<span class="lineNum">    3043 </span><span class="lineCov">     118748 :       eh_landing_pad old_lp, new_lp;</span>
<span class="lineNum">    3044 </span>            : 
<span class="lineNum">    3045 </span><span class="lineCov">     118748 :       old_lp = (*old_fun-&gt;eh-&gt;lp_array)[old_lp_nr];</span>
<span class="lineNum">    3046 </span><span class="lineCov">     118748 :       new_lp = static_cast&lt;eh_landing_pad&gt; (*map-&gt;get (old_lp));</span>
<span class="lineNum">    3047 </span><span class="lineCov">     118748 :       new_lp_nr = new_lp-&gt;index;</span>
<span class="lineNum">    3048 </span>            :     }
<span class="lineNum">    3049 </span>            :   else
<span class="lineNum">    3050 </span>            :     {
<span class="lineNum">    3051 </span><span class="lineCov">      34353 :       eh_region old_r, new_r;</span>
<span class="lineNum">    3052 </span>            : 
<span class="lineNum">    3053 </span><span class="lineCov">      34353 :       old_r = (*old_fun-&gt;eh-&gt;region_array)[-old_lp_nr];</span>
<span class="lineNum">    3054 </span><span class="lineCov">      34353 :       new_r = static_cast&lt;eh_region&gt; (*map-&gt;get (old_r));</span>
<span class="lineNum">    3055 </span><span class="lineCov">      34353 :       new_lp_nr = -new_r-&gt;index;</span>
<span class="lineNum">    3056 </span>            :     }
<span class="lineNum">    3057 </span>            : 
<span class="lineNum">    3058 </span><span class="lineCov">     455119 :   add_stmt_to_eh_lp_fn (new_fun, new_stmt, new_lp_nr);</span>
<span class="lineNum">    3059 </span><span class="lineCov">     455119 :   return true;</span>
<span class="lineNum">    3060 </span>            : }
<span class="lineNum">    3061 </span>            : 
<span class="lineNum">    3062 </span>            : /* Similar, but both OLD_STMT and NEW_STMT are within the current function,
<span class="lineNum">    3063 </span>            :    and thus no remapping is required.  */
<a name="3064"><span class="lineNum">    3064 </span>            : </a>
<span class="lineNum">    3065 </span>            : bool
<span class="lineNum">    3066 </span><span class="lineCov">    6567201 : maybe_duplicate_eh_stmt (gimple *new_stmt, gimple *old_stmt)</span>
<span class="lineNum">    3067 </span>            : {
<span class="lineNum">    3068 </span><span class="lineCov">    6567201 :   int lp_nr;</span>
<span class="lineNum">    3069 </span>            : 
<span class="lineNum">    3070 </span><span class="lineCov">    6567201 :   if (!stmt_could_throw_p (new_stmt))</span>
<span class="lineNum">    3071 </span>            :     return false;
<span class="lineNum">    3072 </span>            : 
<span class="lineNum">    3073 </span><span class="lineCov">      20918 :   lp_nr = lookup_stmt_eh_lp (old_stmt);</span>
<span class="lineNum">    3074 </span><span class="lineCov">      20918 :   if (lp_nr == 0)</span>
<span class="lineNum">    3075 </span>            :     return false;
<span class="lineNum">    3076 </span>            : 
<span class="lineNum">    3077 </span><span class="lineCov">        916 :   add_stmt_to_eh_lp (new_stmt, lp_nr);</span>
<span class="lineNum">    3078 </span><span class="lineCov">        916 :   return true;</span>
<span class="lineNum">    3079 </span>            : }
<span class="lineNum">    3080 </span>            : 
<span class="lineNum">    3081 </span>            : /* Returns TRUE if oneh and twoh are exception handlers (gimple_try_cleanup of
<span class="lineNum">    3082 </span>            :    GIMPLE_TRY) that are similar enough to be considered the same.  Currently
<span class="lineNum">    3083 </span>            :    this only handles handlers consisting of a single call, as that's the
<span class="lineNum">    3084 </span>            :    important case for C++: a destructor call for a particular object showing
<span class="lineNum">    3085 </span>            :    up in multiple handlers.  */
<a name="3086"><span class="lineNum">    3086 </span>            : </a>
<span class="lineNum">    3087 </span>            : static bool
<span class="lineNum">    3088 </span><span class="lineCov">        437 : same_handler_p (gimple_seq oneh, gimple_seq twoh)</span>
<span class="lineNum">    3089 </span>            : {
<span class="lineNum">    3090 </span><span class="lineCov">        437 :   gimple_stmt_iterator gsi;</span>
<span class="lineNum">    3091 </span><span class="lineCov">        437 :   gimple *ones, *twos;</span>
<span class="lineNum">    3092 </span><span class="lineCov">        437 :   unsigned int ai;</span>
<span class="lineNum">    3093 </span>            : 
<span class="lineNum">    3094 </span><span class="lineCov">        437 :   gsi = gsi_start (oneh);</span>
<span class="lineNum">    3095 </span><span class="lineCov">        437 :   if (!gsi_one_before_end_p (gsi))</span>
<span class="lineNum">    3096 </span>            :     return false;
<span class="lineNum">    3097 </span><span class="lineCov">        437 :   ones = gsi_stmt (gsi);</span>
<span class="lineNum">    3098 </span>            : 
<span class="lineNum">    3099 </span><span class="lineCov">        437 :   gsi = gsi_start (twoh);</span>
<span class="lineNum">    3100 </span><span class="lineCov">        437 :   if (!gsi_one_before_end_p (gsi))</span>
<span class="lineNum">    3101 </span>            :     return false;
<span class="lineNum">    3102 </span><span class="lineCov">        437 :   twos = gsi_stmt (gsi);</span>
<span class="lineNum">    3103 </span>            : 
<span class="lineNum">    3104 </span><span class="lineCov">        437 :   if (!is_gimple_call (ones)</span>
<span class="lineNum">    3105 </span><span class="lineCov">        874 :       || !is_gimple_call (twos)</span>
<span class="lineNum">    3106 </span><span class="lineCov">        874 :       || gimple_call_lhs (ones)</span>
<span class="lineNum">    3107 </span><span class="lineCov">        874 :       || gimple_call_lhs (twos)</span>
<span class="lineNum">    3108 </span><span class="lineCov">        874 :       || gimple_call_chain (ones)</span>
<span class="lineNum">    3109 </span><span class="lineCov">        874 :       || gimple_call_chain (twos)</span>
<span class="lineNum">    3110 </span><span class="lineCov">        437 :       || !gimple_call_same_target_p (ones, twos)</span>
<span class="lineNum">    3111 </span><span class="lineCov">        874 :       || gimple_call_num_args (ones) != gimple_call_num_args (twos))</span>
<span class="lineNum">    3112 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    3113 </span>            : 
<span class="lineNum">    3114 </span><span class="lineCov">        874 :   for (ai = 0; ai &lt; gimple_call_num_args (ones); ++ai)</span>
<span class="lineNum">    3115 </span><span class="lineCov">        437 :     if (!operand_equal_p (gimple_call_arg (ones, ai),</span>
<span class="lineNum">    3116 </span><span class="lineCov">        437 :                           gimple_call_arg (twos, ai), 0))</span>
<span class="lineNum">    3117 </span>            :       return false;
<span class="lineNum">    3118 </span>            : 
<span class="lineNum">    3119 </span>            :   return true;
<span class="lineNum">    3120 </span>            : }
<span class="lineNum">    3121 </span>            : 
<span class="lineNum">    3122 </span>            : /* Optimize
<span class="lineNum">    3123 </span>            :     try { A() } finally { try { ~B() } catch { ~A() } }
<span class="lineNum">    3124 </span>            :     try { ... } finally { ~A() }
<span class="lineNum">    3125 </span>            :    into
<span class="lineNum">    3126 </span>            :     try { A() } catch { ~B() }
<span class="lineNum">    3127 </span>            :     try { ~B() ... } finally { ~A() }
<span class="lineNum">    3128 </span>            : 
<span class="lineNum">    3129 </span>            :    This occurs frequently in C++, where A is a local variable and B is a
<span class="lineNum">    3130 </span>            :    temporary used in the initializer for A.  */
<a name="3131"><span class="lineNum">    3131 </span>            : </a>
<span class="lineNum">    3132 </span>            : static void
<span class="lineNum">    3133 </span><span class="lineCov">      14027 : optimize_double_finally (gtry *one, gtry *two)</span>
<span class="lineNum">    3134 </span>            : {
<span class="lineNum">    3135 </span><span class="lineCov">      14027 :   gimple *oneh;</span>
<span class="lineNum">    3136 </span><span class="lineCov">      14027 :   gimple_stmt_iterator gsi;</span>
<span class="lineNum">    3137 </span><span class="lineCov">      14027 :   gimple_seq cleanup;</span>
<span class="lineNum">    3138 </span>            : 
<span class="lineNum">    3139 </span><span class="lineCov">      14027 :   cleanup = gimple_try_cleanup (one);</span>
<span class="lineNum">    3140 </span><span class="lineCov">      14027 :   gsi = gsi_start (cleanup);</span>
<span class="lineNum">    3141 </span><span class="lineCov">      14027 :   if (!gsi_one_before_end_p (gsi))</span>
<span class="lineNum">    3142 </span><span class="lineCov">      13590 :     return;</span>
<span class="lineNum">    3143 </span>            : 
<span class="lineNum">    3144 </span><span class="lineCov">      13553 :   oneh = gsi_stmt (gsi);</span>
<span class="lineNum">    3145 </span><span class="lineCov">      13553 :   if (gimple_code (oneh) != GIMPLE_TRY</span>
<span class="lineNum">    3146 </span><span class="lineCov">      13553 :       || gimple_try_kind (oneh) != GIMPLE_TRY_CATCH)</span>
<span class="lineNum">    3147 </span>            :     return;
<span class="lineNum">    3148 </span>            : 
<span class="lineNum">    3149 </span><span class="lineCov">        437 :   if (same_handler_p (gimple_try_cleanup (oneh), gimple_try_cleanup (two)))</span>
<span class="lineNum">    3150 </span>            :     {
<span class="lineNum">    3151 </span><span class="lineCov">        437 :       gimple_seq seq = gimple_try_eval (oneh);</span>
<span class="lineNum">    3152 </span>            : 
<span class="lineNum">    3153 </span><span class="lineCov">        437 :       gimple_try_set_cleanup (one, seq);</span>
<span class="lineNum">    3154 </span><span class="lineCov">        437 :       gimple_try_set_kind (one, GIMPLE_TRY_CATCH);</span>
<span class="lineNum">    3155 </span><span class="lineCov">        437 :       seq = copy_gimple_seq_and_replace_locals (seq);</span>
<span class="lineNum">    3156 </span><span class="lineCov">        437 :       gimple_seq_add_seq (&amp;seq, gimple_try_eval (two));</span>
<span class="lineNum">    3157 </span><span class="lineCov">        874 :       gimple_try_set_eval (two, seq);</span>
<span class="lineNum">    3158 </span>            :     }
<span class="lineNum">    3159 </span>            : }
<span class="lineNum">    3160 </span>            : 
<span class="lineNum">    3161 </span>            : /* Perform EH refactoring optimizations that are simpler to do when code
<span class="lineNum">    3162 </span>            :    flow has been lowered but EH structures haven't.  */
<a name="3163"><span class="lineNum">    3163 </span>            : </a>
<span class="lineNum">    3164 </span>            : static void
<span class="lineNum">    3165 </span><span class="lineCov">    3533078 : refactor_eh_r (gimple_seq seq)</span>
<span class="lineNum">    3166 </span>            : {
<span class="lineNum">    3167 </span><span class="lineCov">    3533078 :   gimple_stmt_iterator gsi;</span>
<span class="lineNum">    3168 </span><span class="lineCov">    3533078 :   gimple *one, *two;</span>
<span class="lineNum">    3169 </span>            : 
<span class="lineNum">    3170 </span><span class="lineCov">    3533078 :   one = NULL;</span>
<span class="lineNum">    3171 </span><span class="lineCov">    3533078 :   two = NULL;</span>
<span class="lineNum">    3172 </span><span class="lineCov">    7066156 :   gsi = gsi_start (seq);</span>
<span class="lineNum">    3173 </span><span class="lineCov">   30506758 :   while (1)</span>
<span class="lineNum">    3174 </span>            :     {
<span class="lineNum">    3175 </span><span class="lineCov">   30506758 :       one = two;</span>
<span class="lineNum">    3176 </span><span class="lineCov">   61013516 :       if (gsi_end_p (gsi))</span>
<span class="lineNum">    3177 </span>            :         two = NULL;
<span class="lineNum">    3178 </span>            :       else
<span class="lineNum">    3179 </span><span class="lineCov">   53947360 :         two = gsi_stmt (gsi);</span>
<span class="lineNum">    3180 </span><span class="lineCov">   30506758 :       if (one &amp;&amp; two)</span>
<span class="lineNum">    3181 </span><span class="lineCov">   23536444 :         if (gtry *try_one = dyn_cast &lt;gtry *&gt; (one))</span>
<span class="lineNum">    3182 </span><span class="lineCov">     791705 :           if (gtry *try_two = dyn_cast &lt;gtry *&gt; (two))</span>
<span class="lineNum">    3183 </span><span class="lineCov">      22240 :             if (gimple_try_kind (try_one) == GIMPLE_TRY_FINALLY</span>
<span class="lineNum">    3184 </span><span class="lineCov">      22240 :                 &amp;&amp; gimple_try_kind (try_two) == GIMPLE_TRY_FINALLY)</span>
<span class="lineNum">    3185 </span><span class="lineCov">      14027 :               optimize_double_finally (try_one, try_two);</span>
<span class="lineNum">    3186 </span><span class="lineCov">   30506758 :       if (one)</span>
<span class="lineNum">    3187 </span><span class="lineCov">   53947360 :         switch (gimple_code (one))</span>
<span class="lineNum">    3188 </span>            :           {
<span class="lineNum">    3189 </span><span class="lineCov">    1154775 :           case GIMPLE_TRY:</span>
<span class="lineNum">    3190 </span><span class="lineCov">    1154775 :             refactor_eh_r (gimple_try_eval (one));</span>
<span class="lineNum">    3191 </span><span class="lineCov">    1154775 :             refactor_eh_r (gimple_try_cleanup (one));</span>
<span class="lineNum">    3192 </span><span class="lineCov">    1154775 :             break;</span>
<span class="lineNum">    3193 </span><span class="lineCov">      33325 :           case GIMPLE_CATCH:</span>
<span class="lineNum">    3194 </span><span class="lineCov">      33325 :             refactor_eh_r (gimple_catch_handler (as_a &lt;gcatch *&gt; (one)));</span>
<span class="lineNum">    3195 </span><span class="lineCov">      33325 :             break;</span>
<span class="lineNum">    3196 </span><span class="lineCov">       8070 :           case GIMPLE_EH_FILTER:</span>
<span class="lineNum">    3197 </span><span class="lineCov">       8070 :             refactor_eh_r (gimple_eh_filter_failure (one));</span>
<span class="lineNum">    3198 </span><span class="lineCov">       8070 :             break;</span>
<span class="lineNum">    3199 </span><span class="lineCov">        503 :           case GIMPLE_EH_ELSE:</span>
<span class="lineNum">    3200 </span><span class="lineCov">        503 :             {</span>
<span class="lineNum">    3201 </span><span class="lineCov">        503 :               geh_else *eh_else_stmt = as_a &lt;geh_else *&gt; (one);</span>
<span class="lineNum">    3202 </span><span class="lineCov">       1006 :               refactor_eh_r (gimple_eh_else_n_body (eh_else_stmt));</span>
<span class="lineNum">    3203 </span><span class="lineCov">        503 :               refactor_eh_r (gimple_eh_else_e_body (eh_else_stmt));</span>
<span class="lineNum">    3204 </span>            :             }
<span class="lineNum">    3205 </span><span class="lineCov">        503 :             break;</span>
<span class="lineNum">    3206 </span>            :           default:
<span class="lineNum">    3207 </span>            :             break;
<span class="lineNum">    3208 </span>            :           }
<span class="lineNum">    3209 </span><span class="lineCov">   30506758 :       if (two)</span>
<span class="lineNum">    3210 </span><span class="lineCov">   26973680 :         gsi_next (&amp;gsi);</span>
<span class="lineNum">    3211 </span>            :       else
<span class="lineNum">    3212 </span>            :         break;
<span class="lineNum">    3213 </span>            :     }
<span class="lineNum">    3214 </span><span class="lineCov">    3533078 : }</span>
<span class="lineNum">    3215 </span>            : 
<span class="lineNum">    3216 </span>            : namespace {
<span class="lineNum">    3217 </span>            : 
<span class="lineNum">    3218 </span>            : const pass_data pass_data_refactor_eh =
<span class="lineNum">    3219 </span>            : {
<span class="lineNum">    3220 </span>            :   GIMPLE_PASS, /* type */
<span class="lineNum">    3221 </span>            :   &quot;ehopt&quot;, /* name */
<span class="lineNum">    3222 </span>            :   OPTGROUP_NONE, /* optinfo_flags */
<span class="lineNum">    3223 </span>            :   TV_TREE_EH, /* tv_id */
<span class="lineNum">    3224 </span>            :   PROP_gimple_lcf, /* properties_required */
<span class="lineNum">    3225 </span>            :   0, /* properties_provided */
<span class="lineNum">    3226 </span>            :   0, /* properties_destroyed */
<span class="lineNum">    3227 </span>            :   0, /* todo_flags_start */
<span class="lineNum">    3228 </span>            :   0, /* todo_flags_finish */
<span class="lineNum">    3229 </span>            : };
<span class="lineNum">    3230 </span>            : 
<span class="lineNum">    3231 </span>            : class pass_refactor_eh : public gimple_opt_pass
<span class="lineNum">    3232 </span>            : {
<span class="lineNum">    3233 </span>            : public:
<span class="lineNum">    3234 </span>            :   pass_refactor_eh (gcc::context *ctxt)
<span class="lineNum">    3235 </span><span class="lineCov">     340624 :     : gimple_opt_pass (pass_data_refactor_eh, ctxt)</span>
<span class="lineNum">    3236 </span>            :   {}
<a name="3237"><span class="lineNum">    3237 </span>            : </a>
<a name="3238"><span class="lineNum">    3238 </span>            :   /* opt_pass methods: */</a>
<span class="lineNum">    3239 </span><span class="lineCov">    1631529 :   virtual bool gate (function *) { return flag_exceptions != 0; }</span>
<span class="lineNum">    3240 </span><span class="lineCov">    1181127 :   virtual unsigned int execute (function *)</span>
<span class="lineNum">    3241 </span>            :     {
<span class="lineNum">    3242 </span><span class="lineCov">    1181127 :       refactor_eh_r (gimple_body (current_function_decl));</span>
<span class="lineNum">    3243 </span><span class="lineCov">    1181127 :       return 0;</span>
<span class="lineNum">    3244 </span>            :     }
<span class="lineNum">    3245 </span>            : 
<span class="lineNum">    3246 </span>            : }; // class pass_refactor_eh
<span class="lineNum">    3247 </span>            : 
<span class="lineNum">    3248 </span>            : } // anon namespace
<a name="3249"><span class="lineNum">    3249 </span>            : </a>
<span class="lineNum">    3250 </span>            : gimple_opt_pass *
<span class="lineNum">    3251 </span><span class="lineCov">     170312 : make_pass_refactor_eh (gcc::context *ctxt)</span>
<span class="lineNum">    3252 </span>            : {
<span class="lineNum">    3253 </span><span class="lineCov">     170312 :   return new pass_refactor_eh (ctxt);</span>
<span class="lineNum">    3254 </span>            : }
<span class="lineNum">    3255 </span>            : 
<span class="lineNum">    3256 </span>            : /* At the end of gimple optimization, we can lower RESX.  */
<a name="3257"><span class="lineNum">    3257 </span>            : </a>
<span class="lineNum">    3258 </span>            : static bool
<span class="lineNum">    3259 </span><span class="lineCov">     118006 : lower_resx (basic_block bb, gresx *stmt,</span>
<span class="lineNum">    3260 </span>            :             hash_map&lt;eh_region, tree&gt; *mnt_map)
<span class="lineNum">    3261 </span>            : {
<span class="lineNum">    3262 </span><span class="lineCov">     118006 :   int lp_nr;</span>
<span class="lineNum">    3263 </span><span class="lineCov">     118006 :   eh_region src_r, dst_r;</span>
<span class="lineNum">    3264 </span><span class="lineCov">     118006 :   gimple_stmt_iterator gsi;</span>
<span class="lineNum">    3265 </span><span class="lineCov">     118006 :   gimple *x;</span>
<span class="lineNum">    3266 </span><span class="lineCov">     118006 :   tree fn, src_nr;</span>
<span class="lineNum">    3267 </span><span class="lineCov">     118006 :   bool ret = false;</span>
<span class="lineNum">    3268 </span>            : 
<span class="lineNum">    3269 </span><span class="lineCov">     118006 :   lp_nr = lookup_stmt_eh_lp (stmt);</span>
<span class="lineNum">    3270 </span><span class="lineCov">     118006 :   if (lp_nr != 0)</span>
<span class="lineNum">    3271 </span><span class="lineCov">      72189 :     dst_r = get_eh_region_from_lp_number (lp_nr);</span>
<span class="lineNum">    3272 </span>            :   else
<span class="lineNum">    3273 </span><span class="lineCov">      45817 :     dst_r = NULL;</span>
<span class="lineNum">    3274 </span>            : 
<span class="lineNum">    3275 </span><span class="lineCov">     236012 :   src_r = get_eh_region_from_number (gimple_resx_region (stmt));</span>
<span class="lineNum">    3276 </span><span class="lineCov">     118006 :   gsi = gsi_last_bb (bb);</span>
<span class="lineNum">    3277 </span>            : 
<span class="lineNum">    3278 </span><span class="lineCov">     118006 :   if (src_r == NULL)</span>
<span class="lineNum">    3279 </span>            :     {
<span class="lineNum">    3280 </span>            :       /* We can wind up with no source region when pass_cleanup_eh shows
<span class="lineNum">    3281 </span>            :          that there are no entries into an eh region and deletes it, but
<span class="lineNum">    3282 </span>            :          then the block that contains the resx isn't removed.  This can
<span class="lineNum">    3283 </span>            :          happen without optimization when the switch statement created by
<span class="lineNum">    3284 </span>            :          lower_try_finally_switch isn't simplified to remove the eh case.
<span class="lineNum">    3285 </span>            : 
<span class="lineNum">    3286 </span>            :          Resolve this by expanding the resx node to an abort.  */
<span class="lineNum">    3287 </span>            : 
<span class="lineNum">    3288 </span><span class="lineNoCov">          0 :       fn = builtin_decl_implicit (BUILT_IN_TRAP);</span>
<span class="lineNum">    3289 </span><span class="lineNoCov">          0 :       x = gimple_build_call (fn, 0);</span>
<span class="lineNum">    3290 </span><span class="lineNoCov">          0 :       gsi_insert_before (&amp;gsi, x, GSI_SAME_STMT);</span>
<span class="lineNum">    3291 </span>            : 
<span class="lineNum">    3292 </span><span class="lineNoCov">          0 :       while (EDGE_COUNT (bb-&gt;succs) &gt; 0)</span>
<span class="lineNum">    3293 </span><span class="lineNoCov">          0 :         remove_edge (EDGE_SUCC (bb, 0));</span>
<span class="lineNum">    3294 </span>            :     }
<span class="lineNum">    3295 </span><span class="lineCov">     118006 :   else if (dst_r)</span>
<span class="lineNum">    3296 </span>            :     {
<span class="lineNum">    3297 </span>            :       /* When we have a destination region, we resolve this by copying
<span class="lineNum">    3298 </span>            :          the excptr and filter values into place, and changing the edge
<span class="lineNum">    3299 </span>            :          to immediately after the landing pad.  */
<span class="lineNum">    3300 </span><span class="lineCov">      72189 :       edge e;</span>
<span class="lineNum">    3301 </span>            : 
<span class="lineNum">    3302 </span><span class="lineCov">      72189 :       if (lp_nr &lt; 0)</span>
<span class="lineNum">    3303 </span>            :         {
<span class="lineNum">    3304 </span><span class="lineCov">       1981 :           basic_block new_bb;</span>
<span class="lineNum">    3305 </span><span class="lineCov">       1981 :           tree lab;</span>
<span class="lineNum">    3306 </span>            : 
<span class="lineNum">    3307 </span>            :           /* We are resuming into a MUST_NOT_CALL region.  Expand a call to
<span class="lineNum">    3308 </span>            :              the failure decl into a new block, if needed.  */
<span class="lineNum">    3309 </span><span class="lineCov">       1981 :           gcc_assert (dst_r-&gt;type == ERT_MUST_NOT_THROW);</span>
<span class="lineNum">    3310 </span>            : 
<span class="lineNum">    3311 </span><span class="lineCov">       1981 :           tree *slot = mnt_map-&gt;get (dst_r);</span>
<span class="lineNum">    3312 </span><span class="lineCov">       1080 :           if (slot == NULL)</span>
<span class="lineNum">    3313 </span>            :             {
<span class="lineNum">    3314 </span><span class="lineCov">        901 :               gimple_stmt_iterator gsi2;</span>
<span class="lineNum">    3315 </span>            : 
<span class="lineNum">    3316 </span><span class="lineCov">        901 :               new_bb = create_empty_bb (bb);</span>
<span class="lineNum">    3317 </span><span class="lineCov">        901 :               new_bb-&gt;count = bb-&gt;count;</span>
<span class="lineNum">    3318 </span><span class="lineCov">        901 :               add_bb_to_loop (new_bb, bb-&gt;loop_father);</span>
<span class="lineNum">    3319 </span><span class="lineCov">        901 :               lab = gimple_block_label (new_bb);</span>
<span class="lineNum">    3320 </span><span class="lineCov">        901 :               gsi2 = gsi_start_bb (new_bb);</span>
<span class="lineNum">    3321 </span>            : 
<span class="lineNum">    3322 </span><span class="lineCov">        901 :               fn = dst_r-&gt;u.must_not_throw.failure_decl;</span>
<span class="lineNum">    3323 </span><span class="lineCov">        901 :               x = gimple_build_call (fn, 0);</span>
<span class="lineNum">    3324 </span><span class="lineCov">        901 :               gimple_set_location (x, dst_r-&gt;u.must_not_throw.failure_loc);</span>
<span class="lineNum">    3325 </span><span class="lineCov">        901 :               gsi_insert_after (&amp;gsi2, x, GSI_CONTINUE_LINKING);</span>
<span class="lineNum">    3326 </span>            : 
<span class="lineNum">    3327 </span><span class="lineCov">        901 :               mnt_map-&gt;put (dst_r, lab);</span>
<span class="lineNum">    3328 </span>            :             }
<span class="lineNum">    3329 </span>            :           else
<span class="lineNum">    3330 </span>            :             {
<span class="lineNum">    3331 </span><span class="lineCov">       1080 :               lab = *slot;</span>
<span class="lineNum">    3332 </span><span class="lineCov">       1080 :               new_bb = label_to_block (cfun, lab);</span>
<span class="lineNum">    3333 </span>            :             }
<span class="lineNum">    3334 </span>            : 
<span class="lineNum">    3335 </span><span class="lineCov">       1981 :           gcc_assert (EDGE_COUNT (bb-&gt;succs) == 0);</span>
<span class="lineNum">    3336 </span><span class="lineCov">       1981 :           e = make_single_succ_edge (bb, new_bb, EDGE_FALLTHRU);</span>
<span class="lineNum">    3337 </span>            :         }
<span class="lineNum">    3338 </span>            :       else
<span class="lineNum">    3339 </span>            :         {
<span class="lineNum">    3340 </span><span class="lineCov">      70208 :           edge_iterator ei;</span>
<span class="lineNum">    3341 </span><span class="lineCov">     140416 :           tree dst_nr = build_int_cst (integer_type_node, dst_r-&gt;index);</span>
<span class="lineNum">    3342 </span>            : 
<span class="lineNum">    3343 </span><span class="lineCov">      70208 :           fn = builtin_decl_implicit (BUILT_IN_EH_COPY_VALUES);</span>
<span class="lineNum">    3344 </span><span class="lineCov">     140416 :           src_nr = build_int_cst (integer_type_node, src_r-&gt;index);</span>
<span class="lineNum">    3345 </span><span class="lineCov">      70208 :           x = gimple_build_call (fn, 2, dst_nr, src_nr);</span>
<span class="lineNum">    3346 </span><span class="lineCov">      70208 :           gsi_insert_before (&amp;gsi, x, GSI_SAME_STMT);</span>
<span class="lineNum">    3347 </span>            : 
<span class="lineNum">    3348 </span>            :           /* Update the flags for the outgoing edge.  */
<span class="lineNum">    3349 </span><span class="lineCov">      70208 :           e = single_succ_edge (bb);</span>
<span class="lineNum">    3350 </span><span class="lineCov">      70208 :           gcc_assert (e-&gt;flags &amp; EDGE_EH);</span>
<span class="lineNum">    3351 </span><span class="lineCov">      70208 :           e-&gt;flags = (e-&gt;flags &amp; ~EDGE_EH) | EDGE_FALLTHRU;</span>
<span class="lineNum">    3352 </span><span class="lineCov">      70208 :           e-&gt;probability = profile_probability::always ();</span>
<span class="lineNum">    3353 </span>            : 
<span class="lineNum">    3354 </span>            :           /* If there are no more EH users of the landing pad, delete it.  */
<span class="lineNum">    3355 </span><span class="lineCov">     170531 :           FOR_EACH_EDGE (e, ei, e-&gt;dest-&gt;preds)</span>
<span class="lineNum">    3356 </span><span class="lineCov">      84218 :             if (e-&gt;flags &amp; EDGE_EH)</span>
<span class="lineNum">    3357 </span>            :               break;
<span class="lineNum">    3358 </span><span class="lineCov">      70208 :           if (e == NULL)</span>
<span class="lineNum">    3359 </span>            :             {
<span class="lineNum">    3360 </span><span class="lineCov">      16105 :               eh_landing_pad lp = get_eh_landing_pad_from_number (lp_nr);</span>
<span class="lineNum">    3361 </span><span class="lineCov">      16105 :               remove_eh_landing_pad (lp);</span>
<span class="lineNum">    3362 </span>            :             }
<span class="lineNum">    3363 </span>            :         }
<span class="lineNum">    3364 </span>            : 
<span class="lineNum">    3365 </span><span class="lineCov">      72189 :       ret = true;</span>
<span class="lineNum">    3366 </span>            :     }
<span class="lineNum">    3367 </span>            :   else
<span class="lineNum">    3368 </span>            :     {
<span class="lineNum">    3369 </span><span class="lineCov">      45817 :       tree var;</span>
<span class="lineNum">    3370 </span>            : 
<span class="lineNum">    3371 </span>            :       /* When we don't have a destination region, this exception escapes
<span class="lineNum">    3372 </span>            :          up the call chain.  We resolve this by generating a call to the
<span class="lineNum">    3373 </span>            :          _Unwind_Resume library function.  */
<span class="lineNum">    3374 </span>            : 
<span class="lineNum">    3375 </span>            :       /* The ARM EABI redefines _Unwind_Resume as __cxa_end_cleanup
<span class="lineNum">    3376 </span>            :          with no arguments for C++.  Check for that.  */
<span class="lineNum">    3377 </span><span class="lineCov">      45817 :       if (src_r-&gt;use_cxa_end_cleanup)</span>
<span class="lineNum">    3378 </span>            :         {
<span class="lineNum">    3379 </span><span class="lineNoCov">          0 :           fn = builtin_decl_implicit (BUILT_IN_CXA_END_CLEANUP);</span>
<span class="lineNum">    3380 </span><span class="lineNoCov">          0 :           x = gimple_build_call (fn, 0);</span>
<span class="lineNum">    3381 </span><span class="lineNoCov">          0 :           gsi_insert_before (&amp;gsi, x, GSI_SAME_STMT);</span>
<span class="lineNum">    3382 </span>            :         }
<span class="lineNum">    3383 </span>            :       else
<span class="lineNum">    3384 </span>            :         {
<span class="lineNum">    3385 </span><span class="lineCov">      45817 :           fn = builtin_decl_implicit (BUILT_IN_EH_POINTER);</span>
<span class="lineNum">    3386 </span><span class="lineCov">      91634 :           src_nr = build_int_cst (integer_type_node, src_r-&gt;index);</span>
<span class="lineNum">    3387 </span><span class="lineCov">      45817 :           x = gimple_build_call (fn, 1, src_nr);</span>
<span class="lineNum">    3388 </span><span class="lineCov">      45817 :           var = create_tmp_var (ptr_type_node);</span>
<span class="lineNum">    3389 </span><span class="lineCov">      45817 :           var = make_ssa_name (var, x);</span>
<span class="lineNum">    3390 </span><span class="lineCov">      45817 :           gimple_call_set_lhs (x, var);</span>
<span class="lineNum">    3391 </span><span class="lineCov">      45817 :           gsi_insert_before (&amp;gsi, x, GSI_SAME_STMT);</span>
<span class="lineNum">    3392 </span>            : 
<span class="lineNum">    3393 </span>            :           /* When exception handling is delegated to a caller function, we
<span class="lineNum">    3394 </span>            :              have to guarantee that shadow memory variables living on stack
<span class="lineNum">    3395 </span>            :              will be cleaner before control is given to a parent function.  */
<span class="lineNum">    3396 </span><span class="lineCov">      45817 :           if (sanitize_flags_p (SANITIZE_ADDRESS))</span>
<span class="lineNum">    3397 </span>            :             {
<span class="lineNum">    3398 </span><span class="lineCov">        229 :               tree decl</span>
<span class="lineNum">    3399 </span><span class="lineCov">        229 :                 = builtin_decl_implicit (BUILT_IN_ASAN_HANDLE_NO_RETURN);</span>
<span class="lineNum">    3400 </span><span class="lineCov">        229 :               gimple *g = gimple_build_call (decl, 0);</span>
<span class="lineNum">    3401 </span><span class="lineCov">        458 :               gimple_set_location (g, gimple_location (stmt));</span>
<span class="lineNum">    3402 </span><span class="lineCov">        229 :               gsi_insert_before (&amp;gsi, g, GSI_SAME_STMT);</span>
<span class="lineNum">    3403 </span>            :             }
<span class="lineNum">    3404 </span>            : 
<span class="lineNum">    3405 </span><span class="lineCov">      45817 :           fn = builtin_decl_implicit (BUILT_IN_UNWIND_RESUME);</span>
<span class="lineNum">    3406 </span><span class="lineCov">      45817 :           x = gimple_build_call (fn, 1, var);</span>
<span class="lineNum">    3407 </span><span class="lineCov">      45817 :           gsi_insert_before (&amp;gsi, x, GSI_SAME_STMT);</span>
<span class="lineNum">    3408 </span>            :         }
<span class="lineNum">    3409 </span>            : 
<span class="lineNum">    3410 </span><span class="lineCov">      45817 :       gcc_assert (EDGE_COUNT (bb-&gt;succs) == 0);</span>
<span class="lineNum">    3411 </span>            :     }
<span class="lineNum">    3412 </span>            : 
<span class="lineNum">    3413 </span><span class="lineCov">     118006 :   gsi_remove (&amp;gsi, true);</span>
<span class="lineNum">    3414 </span>            : 
<span class="lineNum">    3415 </span><span class="lineCov">     118006 :   return ret;</span>
<span class="lineNum">    3416 </span>            : }
<span class="lineNum">    3417 </span>            : 
<span class="lineNum">    3418 </span>            : namespace {
<span class="lineNum">    3419 </span>            : 
<span class="lineNum">    3420 </span>            : const pass_data pass_data_lower_resx =
<span class="lineNum">    3421 </span>            : {
<span class="lineNum">    3422 </span>            :   GIMPLE_PASS, /* type */
<span class="lineNum">    3423 </span>            :   &quot;resx&quot;, /* name */
<span class="lineNum">    3424 </span>            :   OPTGROUP_NONE, /* optinfo_flags */
<span class="lineNum">    3425 </span>            :   TV_TREE_EH, /* tv_id */
<span class="lineNum">    3426 </span>            :   PROP_gimple_lcf, /* properties_required */
<span class="lineNum">    3427 </span>            :   0, /* properties_provided */
<span class="lineNum">    3428 </span>            :   0, /* properties_destroyed */
<span class="lineNum">    3429 </span>            :   0, /* todo_flags_start */
<span class="lineNum">    3430 </span>            :   0, /* todo_flags_finish */
<span class="lineNum">    3431 </span>            : };
<span class="lineNum">    3432 </span>            : 
<span class="lineNum">    3433 </span>            : class pass_lower_resx : public gimple_opt_pass
<span class="lineNum">    3434 </span>            : {
<span class="lineNum">    3435 </span>            : public:
<span class="lineNum">    3436 </span>            :   pass_lower_resx (gcc::context *ctxt)
<span class="lineNum">    3437 </span><span class="lineCov">     340624 :     : gimple_opt_pass (pass_data_lower_resx, ctxt)</span>
<span class="lineNum">    3438 </span>            :   {}
<a name="3439"><span class="lineNum">    3439 </span>            : </a>
<span class="lineNum">    3440 </span>            :   /* opt_pass methods: */
<span class="lineNum">    3441 </span><span class="lineCov">     832898 :   virtual bool gate (function *) { return flag_exceptions != 0; }</span>
<span class="lineNum">    3442 </span>            :   virtual unsigned int execute (function *);
<span class="lineNum">    3443 </span>            : 
<span class="lineNum">    3444 </span>            : }; // class pass_lower_resx
<a name="3445"><span class="lineNum">    3445 </span>            : </a>
<span class="lineNum">    3446 </span>            : unsigned
<span class="lineNum">    3447 </span><span class="lineCov">     435374 : pass_lower_resx::execute (function *fun)</span>
<span class="lineNum">    3448 </span>            : {
<span class="lineNum">    3449 </span><span class="lineCov">     435374 :   basic_block bb;</span>
<span class="lineNum">    3450 </span><span class="lineCov">     435374 :   bool dominance_invalidated = false;</span>
<span class="lineNum">    3451 </span><span class="lineCov">     435374 :   bool any_rewritten = false;</span>
<span class="lineNum">    3452 </span>            : 
<span class="lineNum">    3453 </span><span class="lineCov">     435374 :   hash_map&lt;eh_region, tree&gt; mnt_map;</span>
<span class="lineNum">    3454 </span>            : 
<span class="lineNum">    3455 </span><span class="lineCov">    5023977 :   FOR_EACH_BB_FN (bb, fun)</span>
<span class="lineNum">    3456 </span>            :     {
<span class="lineNum">    3457 </span><span class="lineCov">    4588603 :       gimple *last = last_stmt (bb);</span>
<span class="lineNum">    3458 </span><span class="lineCov">    4588603 :       if (last &amp;&amp; is_gimple_resx (last))</span>
<span class="lineNum">    3459 </span>            :         {
<span class="lineNum">    3460 </span><span class="lineCov">     236012 :           dominance_invalidated |=</span>
<span class="lineNum">    3461 </span><span class="lineCov">     236012 :             lower_resx (bb, as_a &lt;gresx *&gt; (last), &amp;mnt_map);</span>
<span class="lineNum">    3462 </span><span class="lineCov">     118006 :           any_rewritten = true;</span>
<span class="lineNum">    3463 </span>            :         }
<span class="lineNum">    3464 </span>            :     }
<span class="lineNum">    3465 </span>            : 
<span class="lineNum">    3466 </span><span class="lineCov">     435374 :   if (dominance_invalidated)</span>
<span class="lineNum">    3467 </span>            :     {
<span class="lineNum">    3468 </span><span class="lineCov">      13413 :       free_dominance_info (CDI_DOMINATORS);</span>
<span class="lineNum">    3469 </span><span class="lineCov">      13413 :       free_dominance_info (CDI_POST_DOMINATORS);</span>
<span class="lineNum">    3470 </span>            :     }
<span class="lineNum">    3471 </span>            : 
<span class="lineNum">    3472 </span><span class="lineCov">     838017 :   return any_rewritten ? TODO_update_ssa_only_virtuals : 0;</span>
<span class="lineNum">    3473 </span>            : }
<span class="lineNum">    3474 </span>            : 
<span class="lineNum">    3475 </span>            : } // anon namespace
<a name="3476"><span class="lineNum">    3476 </span>            : </a>
<span class="lineNum">    3477 </span>            : gimple_opt_pass *
<span class="lineNum">    3478 </span><span class="lineCov">     170312 : make_pass_lower_resx (gcc::context *ctxt)</span>
<span class="lineNum">    3479 </span>            : {
<span class="lineNum">    3480 </span><span class="lineCov">     170312 :   return new pass_lower_resx (ctxt);</span>
<span class="lineNum">    3481 </span>            : }
<span class="lineNum">    3482 </span>            : 
<span class="lineNum">    3483 </span>            : /* Try to optimize var = {v} {CLOBBER} stmts followed just by
<span class="lineNum">    3484 </span>            :    external throw.  */
<a name="3485"><span class="lineNum">    3485 </span>            : </a>
<span class="lineNum">    3486 </span>            : static void
<span class="lineNum">    3487 </span><span class="lineCov">     298331 : optimize_clobbers (basic_block bb)</span>
<span class="lineNum">    3488 </span>            : {
<span class="lineNum">    3489 </span><span class="lineCov">     298331 :   gimple_stmt_iterator gsi = gsi_last_bb (bb);</span>
<span class="lineNum">    3490 </span><span class="lineCov">     298331 :   bool any_clobbers = false;</span>
<span class="lineNum">    3491 </span><span class="lineCov">     298331 :   bool seen_stack_restore = false;</span>
<span class="lineNum">    3492 </span><span class="lineCov">     298331 :   edge_iterator ei;</span>
<span class="lineNum">    3493 </span><span class="lineCov">     298331 :   edge e;</span>
<span class="lineNum">    3494 </span>            : 
<span class="lineNum">    3495 </span>            :   /* Only optimize anything if the bb contains at least one clobber,
<span class="lineNum">    3496 </span>            :      ends with resx (checked by caller), optionally contains some
<span class="lineNum">    3497 </span>            :      debug stmts or labels, or at most one __builtin_stack_restore
<span class="lineNum">    3498 </span>            :      call, and has an incoming EH edge.  */
<span class="lineNum">    3499 </span><span class="lineCov">    3888231 :   for (gsi_prev (&amp;gsi); !gsi_end_p (gsi); gsi_prev (&amp;gsi))</span>
<span class="lineNum">    3500 </span>            :     {
<span class="lineNum">    3501 </span><span class="lineCov">    1277947 :       gimple *stmt = gsi_stmt (gsi);</span>
<span class="lineNum">    3502 </span><span class="lineCov">    2555894 :       if (is_gimple_debug (stmt))</span>
<span class="lineNum">    3503 </span>            :         continue;
<span class="lineNum">    3504 </span><span class="lineCov">     454286 :       if (gimple_clobber_p (stmt))</span>
<span class="lineNum">    3505 </span>            :         {
<span class="lineNum">    3506 </span>            :           any_clobbers = true;
<span class="lineNum">    3507 </span>            :           continue;
<span class="lineNum">    3508 </span>            :         }
<span class="lineNum">    3509 </span><span class="lineCov">     280365 :       if (!seen_stack_restore</span>
<span class="lineNum">    3510 </span><span class="lineCov">     280365 :           &amp;&amp; gimple_call_builtin_p (stmt, BUILT_IN_STACK_RESTORE))</span>
<span class="lineNum">    3511 </span>            :         {
<span class="lineNum">    3512 </span>            :           seen_stack_restore = true;
<span class="lineNum">    3513 </span>            :           continue;
<span class="lineNum">    3514 </span>            :         }
<span class="lineNum">    3515 </span><span class="lineCov">     560402 :       if (gimple_code (stmt) == GIMPLE_LABEL)</span>
<span class="lineNum">    3516 </span>            :         break;
<span class="lineNum">    3517 </span><span class="lineCov">     188382 :       return;</span>
<span class="lineNum">    3518 </span>            :     }
<span class="lineNum">    3519 </span><span class="lineCov">     228366 :   if (!any_clobbers)</span>
<span class="lineNum">    3520 </span>            :     return;
<span class="lineNum">    3521 </span><span class="lineCov">     247728 :   FOR_EACH_EDGE (e, ei, bb-&gt;preds)</span>
<span class="lineNum">    3522 </span><span class="lineCov">     120707 :     if (e-&gt;flags &amp; EDGE_EH)</span>
<span class="lineNum">    3523 </span>            :       break;
<span class="lineNum">    3524 </span><span class="lineCov">     118485 :   if (e == NULL)</span>
<span class="lineNum">    3525 </span>            :     return;
<span class="lineNum">    3526 </span><span class="lineCov">     109949 :   gsi = gsi_last_bb (bb);</span>
<span class="lineNum">    3527 </span><span class="lineCov">    1828956 :   for (gsi_prev (&amp;gsi); !gsi_end_p (gsi); gsi_prev (&amp;gsi))</span>
<span class="lineNum">    3528 </span>            :     {
<span class="lineNum">    3529 </span><span class="lineCov">     499703 :       gimple *stmt = gsi_stmt (gsi);</span>
<span class="lineNum">    3530 </span><span class="lineCov">     499703 :       if (!gimple_clobber_p (stmt))</span>
<span class="lineNum">    3531 </span>            :         continue;
<span class="lineNum">    3532 </span><span class="lineCov">     157490 :       unlink_stmt_vdef (stmt);</span>
<span class="lineNum">    3533 </span><span class="lineCov">     157490 :       gsi_remove (&amp;gsi, true);</span>
<span class="lineNum">    3534 </span><span class="lineCov">     157490 :       release_defs (stmt);</span>
<span class="lineNum">    3535 </span>            :     }
<span class="lineNum">    3536 </span>            : }
<span class="lineNum">    3537 </span>            : 
<span class="lineNum">    3538 </span>            : /* Try to sink var = {v} {CLOBBER} stmts followed just by
<span class="lineNum">    3539 </span>            :    internal throw to successor BB.  */
<a name="3540"><span class="lineNum">    3540 </span>            : </a>
<span class="lineNum">    3541 </span>            : static int
<span class="lineNum">    3542 </span><span class="lineCov">     263968 : sink_clobbers (basic_block bb)</span>
<span class="lineNum">    3543 </span>            : {
<span class="lineNum">    3544 </span><span class="lineCov">     263968 :   edge e;</span>
<span class="lineNum">    3545 </span><span class="lineCov">     263968 :   edge_iterator ei;</span>
<span class="lineNum">    3546 </span><span class="lineCov">     263968 :   gimple_stmt_iterator gsi, dgsi;</span>
<span class="lineNum">    3547 </span><span class="lineCov">     263968 :   basic_block succbb;</span>
<span class="lineNum">    3548 </span><span class="lineCov">     263968 :   bool any_clobbers = false;</span>
<span class="lineNum">    3549 </span><span class="lineCov">     263968 :   unsigned todo = 0;</span>
<span class="lineNum">    3550 </span>            : 
<span class="lineNum">    3551 </span>            :   /* Only optimize if BB has a single EH successor and
<span class="lineNum">    3552 </span>            :      all predecessor edges are EH too.  */
<span class="lineNum">    3553 </span><span class="lineCov">     263968 :   if (!single_succ_p (bb)</span>
<span class="lineNum">    3554 </span><span class="lineCov">     263950 :       || (single_succ_edge (bb)-&gt;flags &amp; EDGE_EH) == 0)</span>
<span class="lineNum">    3555 </span>            :     return 0;
<span class="lineNum">    3556 </span>            : 
<span class="lineNum">    3557 </span><span class="lineCov">    1290594 :   FOR_EACH_EDGE (e, ei, bb-&gt;preds)</span>
<span class="lineNum">    3558 </span>            :     {
<span class="lineNum">    3559 </span><span class="lineCov">     806925 :       if ((e-&gt;flags &amp; EDGE_EH) == 0)</span>
<span class="lineNum">    3560 </span>            :         return 0;
<span class="lineNum">    3561 </span>            :     }
<span class="lineNum">    3562 </span>            : 
<span class="lineNum">    3563 </span>            :   /* And BB contains only CLOBBER stmts before the final
<span class="lineNum">    3564 </span>            :      RESX.  */
<span class="lineNum">    3565 </span><span class="lineCov">     223165 :   gsi = gsi_last_bb (bb);</span>
<span class="lineNum">    3566 </span><span class="lineCov">    2282040 :   for (gsi_prev (&amp;gsi); !gsi_end_p (gsi); gsi_prev (&amp;gsi))</span>
<span class="lineNum">    3567 </span>            :     {
<span class="lineNum">    3568 </span><span class="lineCov">     760680 :       gimple *stmt = gsi_stmt (gsi);</span>
<span class="lineNum">    3569 </span><span class="lineCov">    1521360 :       if (is_gimple_debug (stmt))</span>
<span class="lineNum">    3570 </span>            :         continue;
<span class="lineNum">    3571 </span><span class="lineCov">     653078 :       if (gimple_code (stmt) == GIMPLE_LABEL)</span>
<span class="lineNum">    3572 </span>            :         break;
<span class="lineNum">    3573 </span><span class="lineCov">     213189 :       if (!gimple_clobber_p (stmt))</span>
<span class="lineNum">    3574 </span>            :         return 0;
<span class="lineNum">    3575 </span>            :       any_clobbers = true;
<span class="lineNum">    3576 </span>            :     }
<span class="lineNum">    3577 </span><span class="lineCov">     113350 :   if (!any_clobbers)</span>
<span class="lineNum">    3578 </span>            :     return 0;
<span class="lineNum">    3579 </span>            : 
<span class="lineNum">    3580 </span><span class="lineCov">      63267 :   edge succe = single_succ_edge (bb);</span>
<span class="lineNum">    3581 </span><span class="lineCov">      63267 :   succbb = succe-&gt;dest;</span>
<span class="lineNum">    3582 </span>            : 
<span class="lineNum">    3583 </span>            :   /* See if there is a virtual PHI node to take an updated virtual
<span class="lineNum">    3584 </span>            :      operand from.  */
<span class="lineNum">    3585 </span><span class="lineCov">      63267 :   gphi *vphi = NULL;</span>
<span class="lineNum">    3586 </span><span class="lineCov">      63267 :   tree vuse = NULL_TREE;</span>
<span class="lineNum">    3587 </span><span class="lineCov">      63267 :   for (gphi_iterator gpi = gsi_start_phis (succbb);</span>
<span class="lineNum">    3588 </span><span class="lineCov">     128014 :        !gsi_end_p (gpi); gsi_next (&amp;gpi))</span>
<span class="lineNum">    3589 </span>            :     {
<span class="lineNum">    3590 </span><span class="lineCov">      41265 :       tree res = gimple_phi_result (gpi.phi ());</span>
<span class="lineNum">    3591 </span><span class="lineCov">      82530 :       if (virtual_operand_p (res))</span>
<span class="lineNum">    3592 </span>            :         {
<span class="lineNum">    3593 </span>            :           vphi = gpi.phi ();
<span class="lineNum">    3594 </span>            :           vuse = res;
<span class="lineNum">    3595 </span>            :           break;
<span class="lineNum">    3596 </span>            :         }
<span class="lineNum">    3597 </span>            :     }
<span class="lineNum">    3598 </span>            : 
<span class="lineNum">    3599 </span><span class="lineCov">      63267 :   dgsi = gsi_after_labels (succbb);</span>
<span class="lineNum">    3600 </span><span class="lineCov">      63267 :   gsi = gsi_last_bb (bb);</span>
<span class="lineNum">    3601 </span><span class="lineCov">     809073 :   for (gsi_prev (&amp;gsi); !gsi_end_p (gsi); gsi_prev (&amp;gsi))</span>
<span class="lineNum">    3602 </span>            :     {
<span class="lineNum">    3603 </span><span class="lineCov">     269691 :       gimple *stmt = gsi_stmt (gsi);</span>
<span class="lineNum">    3604 </span><span class="lineCov">     269691 :       tree lhs;</span>
<span class="lineNum">    3605 </span><span class="lineCov">     539382 :       if (is_gimple_debug (stmt))</span>
<span class="lineNum">    3606 </span>            :         continue;
<span class="lineNum">    3607 </span><span class="lineCov">     313378 :       if (gimple_code (stmt) == GIMPLE_LABEL)</span>
<span class="lineNum">    3608 </span>            :         break;
<span class="lineNum">    3609 </span><span class="lineCov">      93422 :       lhs = gimple_assign_lhs (stmt);</span>
<span class="lineNum">    3610 </span>            :       /* Unfortunately we don't have dominance info updated at this
<span class="lineNum">    3611 </span>            :          point, so checking if
<span class="lineNum">    3612 </span>            :          dominated_by_p (CDI_DOMINATORS, succbb,
<span class="lineNum">    3613 </span>            :                          gimple_bb (SSA_NAME_DEF_STMT (TREE_OPERAND (lhs, 0)))
<span class="lineNum">    3614 </span>            :          would be too costly.  Thus, avoid sinking any clobbers that
<span class="lineNum">    3615 </span>            :          refer to non-(D) SSA_NAMEs.  */
<span class="lineNum">    3616 </span><span class="lineCov">      93422 :       if (TREE_CODE (lhs) == MEM_REF</span>
<span class="lineNum">    3617 </span><span class="lineCov">        401 :           &amp;&amp; TREE_CODE (TREE_OPERAND (lhs, 0)) == SSA_NAME</span>
<span class="lineNum">    3618 </span><span class="lineCov">      93691 :           &amp;&amp; !SSA_NAME_IS_DEFAULT_DEF (TREE_OPERAND (lhs, 0)))</span>
<span class="lineNum">    3619 </span>            :         {
<span class="lineNum">    3620 </span><span class="lineCov">          2 :           unlink_stmt_vdef (stmt);</span>
<span class="lineNum">    3621 </span><span class="lineCov">          2 :           gsi_remove (&amp;gsi, true);</span>
<span class="lineNum">    3622 </span><span class="lineCov">          2 :           release_defs (stmt);</span>
<span class="lineNum">    3623 </span><span class="lineCov">          2 :           continue;</span>
<span class="lineNum">    3624 </span>            :         }
<span class="lineNum">    3625 </span>            : 
<span class="lineNum">    3626 </span>            :       /* As we do not change stmt order when sinking across a
<span class="lineNum">    3627 </span>            :          forwarder edge we can keep virtual operands in place.  */
<span class="lineNum">    3628 </span><span class="lineCov">      93420 :       gsi_remove (&amp;gsi, false);</span>
<span class="lineNum">    3629 </span><span class="lineCov">      93420 :       gsi_insert_before (&amp;dgsi, stmt, GSI_NEW_STMT);</span>
<span class="lineNum">    3630 </span>            : 
<span class="lineNum">    3631 </span>            :       /* But adjust virtual operands if we sunk across a PHI node.  */
<span class="lineNum">    3632 </span><span class="lineCov">      93420 :       if (vuse)</span>
<span class="lineNum">    3633 </span>            :         {
<span class="lineNum">    3634 </span><span class="lineCov">      59020 :           gimple *use_stmt;</span>
<span class="lineNum">    3635 </span><span class="lineCov">      59020 :           imm_use_iterator iter;</span>
<span class="lineNum">    3636 </span><span class="lineCov">      59020 :           use_operand_p use_p;</span>
<span class="lineNum">    3637 </span><span class="lineCov">     130925 :           FOR_EACH_IMM_USE_STMT (use_stmt, iter, vuse)</span>
<span class="lineNum">    3638 </span><span class="lineCov">     431454 :             FOR_EACH_IMM_USE_ON_STMT (use_p, iter)</span>
<span class="lineNum">    3639 </span><span class="lineCov">     143834 :               SET_USE (use_p, gimple_vdef (stmt));</span>
<span class="lineNum">    3640 </span><span class="lineCov">      59020 :           if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (vuse))</span>
<span class="lineNum">    3641 </span>            :             {
<span class="lineNum">    3642 </span><span class="lineNoCov">          0 :               SSA_NAME_OCCURS_IN_ABNORMAL_PHI (gimple_vdef (stmt)) = 1;</span>
<span class="lineNum">    3643 </span><span class="lineNoCov">          0 :               SSA_NAME_OCCURS_IN_ABNORMAL_PHI (vuse) = 0;</span>
<span class="lineNum">    3644 </span>            :             }
<span class="lineNum">    3645 </span>            :           /* Adjust the incoming virtual operand.  */
<span class="lineNum">    3646 </span><span class="lineCov">     118040 :           SET_USE (PHI_ARG_DEF_PTR_FROM_EDGE (vphi, succe), gimple_vuse (stmt));</span>
<span class="lineNum">    3647 </span><span class="lineCov">     118040 :           SET_USE (gimple_vuse_op (stmt), vuse);</span>
<span class="lineNum">    3648 </span>            :         }
<span class="lineNum">    3649 </span>            :       /* If there isn't a single predecessor but no virtual PHI node
<span class="lineNum">    3650 </span>            :          arrange for virtual operands to be renamed.  */
<span class="lineNum">    3651 </span><span class="lineCov">      34400 :       else if (gimple_vuse_op (stmt) != NULL_USE_OPERAND_P</span>
<span class="lineNum">    3652 </span><span class="lineCov">      34400 :                &amp;&amp; !single_pred_p (succbb))</span>
<span class="lineNum">    3653 </span>            :         {
<span class="lineNum">    3654 </span>            :           /* In this case there will be no use of the VDEF of this stmt. 
<span class="lineNum">    3655 </span>            :              ???  Unless this is a secondary opportunity and we have not
<span class="lineNum">    3656 </span>            :              removed unreachable blocks yet, so we cannot assert this.  
<span class="lineNum">    3657 </span>            :              Which also means we will end up renaming too many times.  */
<span class="lineNum">    3658 </span><span class="lineCov">       2475 :           SET_USE (gimple_vuse_op (stmt), gimple_vop (cfun));</span>
<span class="lineNum">    3659 </span><span class="lineCov">        825 :           mark_virtual_operands_for_renaming (cfun);</span>
<span class="lineNum">    3660 </span><span class="lineCov">        825 :           todo |= TODO_update_ssa_only_virtuals;</span>
<span class="lineNum">    3661 </span>            :         }
<span class="lineNum">    3662 </span>            :     }
<span class="lineNum">    3663 </span>            : 
<span class="lineNum">    3664 </span><span class="lineCov">      63267 :   return todo;</span>
<span class="lineNum">    3665 </span>            : }
<span class="lineNum">    3666 </span>            : 
<span class="lineNum">    3667 </span>            : /* At the end of inlining, we can lower EH_DISPATCH.  Return true when 
<span class="lineNum">    3668 </span>            :    we have found some duplicate labels and removed some edges.  */
<a name="3669"><span class="lineNum">    3669 </span>            : </a>
<span class="lineNum">    3670 </span>            : static bool
<span class="lineNum">    3671 </span><span class="lineCov">      32507 : lower_eh_dispatch (basic_block src, geh_dispatch *stmt)</span>
<span class="lineNum">    3672 </span>            : {
<span class="lineNum">    3673 </span><span class="lineCov">      32507 :   gimple_stmt_iterator gsi;</span>
<span class="lineNum">    3674 </span><span class="lineCov">      32507 :   int region_nr;</span>
<span class="lineNum">    3675 </span><span class="lineCov">      32507 :   eh_region r;</span>
<span class="lineNum">    3676 </span><span class="lineCov">      32507 :   tree filter, fn;</span>
<span class="lineNum">    3677 </span><span class="lineCov">      32507 :   gimple *x;</span>
<span class="lineNum">    3678 </span><span class="lineCov">      32507 :   bool redirected = false;</span>
<span class="lineNum">    3679 </span>            : 
<span class="lineNum">    3680 </span><span class="lineCov">      32507 :   region_nr = gimple_eh_dispatch_region (stmt);</span>
<span class="lineNum">    3681 </span><span class="lineCov">      32507 :   r = get_eh_region_from_number (region_nr);</span>
<span class="lineNum">    3682 </span>            : 
<span class="lineNum">    3683 </span><span class="lineCov">      32507 :   gsi = gsi_last_bb (src);</span>
<span class="lineNum">    3684 </span>            : 
<span class="lineNum">    3685 </span><span class="lineCov">      32507 :   switch (r-&gt;type)</span>
<span class="lineNum">    3686 </span>            :     {
<span class="lineNum">    3687 </span><span class="lineCov">      31008 :     case ERT_TRY:</span>
<span class="lineNum">    3688 </span><span class="lineCov">      31008 :       {</span>
<span class="lineNum">    3689 </span><span class="lineCov">      31008 :         auto_vec&lt;tree&gt; labels;</span>
<span class="lineNum">    3690 </span><span class="lineCov">      31008 :         tree default_label = NULL;</span>
<span class="lineNum">    3691 </span><span class="lineCov">      31008 :         eh_catch c;</span>
<span class="lineNum">    3692 </span><span class="lineCov">      31008 :         edge_iterator ei;</span>
<span class="lineNum">    3693 </span><span class="lineCov">      31008 :         edge e;</span>
<span class="lineNum">    3694 </span><span class="lineCov">      62016 :         hash_set&lt;tree&gt; seen_values;</span>
<span class="lineNum">    3695 </span>            : 
<span class="lineNum">    3696 </span>            :         /* Collect the labels for a switch.  Zero the post_landing_pad
<span class="lineNum">    3697 </span>            :            field becase we'll no longer have anything keeping these labels
<span class="lineNum">    3698 </span>            :            in existence and the optimizer will be free to merge these
<span class="lineNum">    3699 </span>            :            blocks at will.  */
<span class="lineNum">    3700 </span><span class="lineCov">      35346 :         for (c = r-&gt;u.eh_try.first_catch; c ; c = c-&gt;next_catch)</span>
<span class="lineNum">    3701 </span>            :           {
<span class="lineNum">    3702 </span><span class="lineCov">      33464 :             tree tp_node, flt_node, lab = c-&gt;label;</span>
<span class="lineNum">    3703 </span><span class="lineCov">      33464 :             bool have_label = false;</span>
<span class="lineNum">    3704 </span>            : 
<span class="lineNum">    3705 </span><span class="lineCov">      33464 :             c-&gt;label = NULL;</span>
<span class="lineNum">    3706 </span><span class="lineCov">      33464 :             tp_node = c-&gt;type_list;</span>
<span class="lineNum">    3707 </span><span class="lineCov">      33464 :             flt_node = c-&gt;filter_list;</span>
<span class="lineNum">    3708 </span>            : 
<span class="lineNum">    3709 </span><span class="lineCov">      33464 :             if (tp_node == NULL)</span>
<span class="lineNum">    3710 </span>            :               {
<span class="lineNum">    3711 </span>            :                 default_label = lab;
<span class="lineNum">    3712 </span>            :                 break;
<span class="lineNum">    3713 </span>            :               }
<span class="lineNum">    3714 </span><span class="lineCov">       4338 :             do</span>
<span class="lineNum">    3715 </span>            :               {
<span class="lineNum">    3716 </span>            :                 /* Filter out duplicate labels that arise when this handler 
<span class="lineNum">    3717 </span>            :                    is shadowed by an earlier one.  When no labels are 
<span class="lineNum">    3718 </span>            :                    attached to the handler anymore, we remove 
<span class="lineNum">    3719 </span>            :                    the corresponding edge and then we delete unreachable 
<span class="lineNum">    3720 </span>            :                    blocks at the end of this pass.  */
<span class="lineNum">    3721 </span><span class="lineCov">       4338 :                 if (! seen_values.contains (TREE_VALUE (flt_node)))</span>
<span class="lineNum">    3722 </span>            :                   {
<span class="lineNum">    3723 </span><span class="lineCov">       4329 :                     tree t = build_case_label (TREE_VALUE (flt_node),</span>
<span class="lineNum">    3724 </span><span class="lineCov">       4329 :                                                NULL, lab);</span>
<span class="lineNum">    3725 </span><span class="lineCov">       4329 :                     labels.safe_push (t);</span>
<span class="lineNum">    3726 </span><span class="lineCov">       4329 :                     seen_values.add (TREE_VALUE (flt_node));</span>
<span class="lineNum">    3727 </span><span class="lineCov">       4329 :                     have_label = true;</span>
<span class="lineNum">    3728 </span>            :                   }
<span class="lineNum">    3729 </span>            : 
<span class="lineNum">    3730 </span><span class="lineCov">       4338 :                 tp_node = TREE_CHAIN (tp_node);</span>
<span class="lineNum">    3731 </span><span class="lineCov">       4338 :                 flt_node = TREE_CHAIN (flt_node);</span>
<span class="lineNum">    3732 </span>            :               }
<span class="lineNum">    3733 </span><span class="lineCov">       4338 :             while (tp_node);</span>
<span class="lineNum">    3734 </span><span class="lineCov">       4338 :             if (! have_label)</span>
<span class="lineNum">    3735 </span>            :               {
<span class="lineNum">    3736 </span><span class="lineCov">          9 :                 remove_edge (find_edge (src, label_to_block (cfun, lab)));</span>
<span class="lineNum">    3737 </span><span class="lineCov">          9 :                 redirected = true;</span>
<span class="lineNum">    3738 </span>            :               }
<span class="lineNum">    3739 </span>            :           }
<span class="lineNum">    3740 </span>            : 
<span class="lineNum">    3741 </span>            :         /* Clean up the edge flags.  */
<span class="lineNum">    3742 </span><span class="lineCov">      97353 :         FOR_EACH_EDGE (e, ei, src-&gt;succs)</span>
<span class="lineNum">    3743 </span>            :           {
<span class="lineNum">    3744 </span><span class="lineCov">      35337 :             if (e-&gt;flags &amp; EDGE_FALLTHRU)</span>
<span class="lineNum">    3745 </span>            :               {
<span class="lineNum">    3746 </span>            :                 /* If there was no catch-all, use the fallthru edge.  */
<span class="lineNum">    3747 </span><span class="lineCov">       1882 :                 if (default_label == NULL)</span>
<span class="lineNum">    3748 </span><span class="lineCov">       1882 :                   default_label = gimple_block_label (e-&gt;dest);</span>
<span class="lineNum">    3749 </span><span class="lineCov">       1882 :                 e-&gt;flags &amp;= ~EDGE_FALLTHRU;</span>
<span class="lineNum">    3750 </span>            :               }
<span class="lineNum">    3751 </span>            :           }
<span class="lineNum">    3752 </span><span class="lineCov">      31008 :         gcc_assert (default_label != NULL);</span>
<span class="lineNum">    3753 </span>            : 
<span class="lineNum">    3754 </span>            :         /* Don't generate a switch if there's only a default case.
<span class="lineNum">    3755 </span>            :            This is common in the form of try { A; } catch (...) { B; }.  */
<span class="lineNum">    3756 </span><span class="lineCov">      31008 :         if (!labels.exists ())</span>
<span class="lineNum">    3757 </span>            :           {
<span class="lineNum">    3758 </span><span class="lineCov">      27479 :             e = single_succ_edge (src);</span>
<span class="lineNum">    3759 </span><span class="lineCov">      27479 :             e-&gt;flags |= EDGE_FALLTHRU;</span>
<span class="lineNum">    3760 </span>            :           }
<span class="lineNum">    3761 </span>            :         else
<span class="lineNum">    3762 </span>            :           {
<span class="lineNum">    3763 </span><span class="lineCov">       3529 :             fn = builtin_decl_implicit (BUILT_IN_EH_FILTER);</span>
<span class="lineNum">    3764 </span><span class="lineCov">       7058 :             x = gimple_build_call (fn, 1, build_int_cst (integer_type_node,</span>
<span class="lineNum">    3765 </span>            :                                                          region_nr));
<span class="lineNum">    3766 </span><span class="lineCov">       3529 :             filter = create_tmp_var (TREE_TYPE (TREE_TYPE (fn)));</span>
<span class="lineNum">    3767 </span><span class="lineCov">       3529 :             filter = make_ssa_name (filter, x);</span>
<span class="lineNum">    3768 </span><span class="lineCov">       3529 :             gimple_call_set_lhs (x, filter);</span>
<span class="lineNum">    3769 </span><span class="lineCov">       3529 :             gsi_insert_before (&amp;gsi, x, GSI_SAME_STMT);</span>
<span class="lineNum">    3770 </span>            : 
<span class="lineNum">    3771 </span>            :             /* Turn the default label into a default case.  */
<span class="lineNum">    3772 </span><span class="lineCov">       3529 :             default_label = build_case_label (NULL, NULL, default_label);</span>
<span class="lineNum">    3773 </span><span class="lineCov">       3529 :             sort_case_labels (labels);</span>
<span class="lineNum">    3774 </span>            : 
<span class="lineNum">    3775 </span><span class="lineCov">       3529 :             x = gimple_build_switch (filter, default_label, labels);</span>
<span class="lineNum">    3776 </span><span class="lineCov">       3529 :             gsi_insert_before (&amp;gsi, x, GSI_SAME_STMT);</span>
<span class="lineNum">    3777 </span><span class="lineCov">      31008 :           }</span>
<span class="lineNum">    3778 </span>            :       }
<span class="lineNum">    3779 </span><span class="lineCov">      31008 :       break;</span>
<span class="lineNum">    3780 </span>            : 
<span class="lineNum">    3781 </span><span class="lineCov">       1499 :     case ERT_ALLOWED_EXCEPTIONS:</span>
<span class="lineNum">    3782 </span><span class="lineCov">       1499 :       {</span>
<span class="lineNum">    3783 </span><span class="lineCov">       1499 :         edge b_e = BRANCH_EDGE (src);</span>
<span class="lineNum">    3784 </span><span class="lineCov">       1499 :         edge f_e = FALLTHRU_EDGE (src);</span>
<span class="lineNum">    3785 </span>            : 
<span class="lineNum">    3786 </span><span class="lineCov">       1499 :         fn = builtin_decl_implicit (BUILT_IN_EH_FILTER);</span>
<span class="lineNum">    3787 </span><span class="lineCov">       2998 :         x = gimple_build_call (fn, 1, build_int_cst (integer_type_node,</span>
<span class="lineNum">    3788 </span>            :                                                      region_nr));
<span class="lineNum">    3789 </span><span class="lineCov">       1499 :         filter = create_tmp_var (TREE_TYPE (TREE_TYPE (fn)));</span>
<span class="lineNum">    3790 </span><span class="lineCov">       1499 :         filter = make_ssa_name (filter, x);</span>
<span class="lineNum">    3791 </span><span class="lineCov">       1499 :         gimple_call_set_lhs (x, filter);</span>
<span class="lineNum">    3792 </span><span class="lineCov">       1499 :         gsi_insert_before (&amp;gsi, x, GSI_SAME_STMT);</span>
<span class="lineNum">    3793 </span>            : 
<span class="lineNum">    3794 </span><span class="lineCov">       1499 :         r-&gt;u.allowed.label = NULL;</span>
<span class="lineNum">    3795 </span><span class="lineCov">       1499 :         x = gimple_build_cond (EQ_EXPR, filter,</span>
<span class="lineNum">    3796 </span><span class="lineCov">       1499 :                                build_int_cst (TREE_TYPE (filter),</span>
<span class="lineNum">    3797 </span><span class="lineCov">       1499 :                                               r-&gt;u.allowed.filter),</span>
<span class="lineNum">    3798 </span>            :                                NULL_TREE, NULL_TREE);
<span class="lineNum">    3799 </span><span class="lineCov">       1499 :         gsi_insert_before (&amp;gsi, x, GSI_SAME_STMT);</span>
<span class="lineNum">    3800 </span>            : 
<span class="lineNum">    3801 </span><span class="lineCov">       1499 :         b_e-&gt;flags = b_e-&gt;flags | EDGE_TRUE_VALUE;</span>
<span class="lineNum">    3802 </span><span class="lineCov">       1499 :         f_e-&gt;flags = (f_e-&gt;flags &amp; ~EDGE_FALLTHRU) | EDGE_FALSE_VALUE;</span>
<span class="lineNum">    3803 </span>            :       }
<span class="lineNum">    3804 </span><span class="lineCov">       1499 :       break;</span>
<span class="lineNum">    3805 </span>            : 
<span class="lineNum">    3806 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">    3807 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">    3808 </span>            :     }
<span class="lineNum">    3809 </span>            : 
<span class="lineNum">    3810 </span>            :   /* Replace the EH_DISPATCH with the SWITCH or COND generated above.  */
<span class="lineNum">    3811 </span><span class="lineCov">      32507 :   gsi_remove (&amp;gsi, true);</span>
<span class="lineNum">    3812 </span><span class="lineCov">      32507 :   return redirected;</span>
<span class="lineNum">    3813 </span>            : }
<span class="lineNum">    3814 </span>            : 
<span class="lineNum">    3815 </span>            : namespace {
<span class="lineNum">    3816 </span>            : 
<span class="lineNum">    3817 </span>            : const pass_data pass_data_lower_eh_dispatch =
<span class="lineNum">    3818 </span>            : {
<span class="lineNum">    3819 </span>            :   GIMPLE_PASS, /* type */
<span class="lineNum">    3820 </span>            :   &quot;ehdisp&quot;, /* name */
<span class="lineNum">    3821 </span>            :   OPTGROUP_NONE, /* optinfo_flags */
<span class="lineNum">    3822 </span>            :   TV_TREE_EH, /* tv_id */
<span class="lineNum">    3823 </span>            :   PROP_gimple_lcf, /* properties_required */
<span class="lineNum">    3824 </span>            :   0, /* properties_provided */
<span class="lineNum">    3825 </span>            :   0, /* properties_destroyed */
<span class="lineNum">    3826 </span>            :   0, /* todo_flags_start */
<span class="lineNum">    3827 </span>            :   0, /* todo_flags_finish */
<span class="lineNum">    3828 </span>            : };
<span class="lineNum">    3829 </span>            : 
<span class="lineNum">    3830 </span>            : class pass_lower_eh_dispatch : public gimple_opt_pass
<span class="lineNum">    3831 </span>            : {
<span class="lineNum">    3832 </span>            : public:
<span class="lineNum">    3833 </span>            :   pass_lower_eh_dispatch (gcc::context *ctxt)
<span class="lineNum">    3834 </span><span class="lineCov">     340624 :     : gimple_opt_pass (pass_data_lower_eh_dispatch, ctxt)</span>
<span class="lineNum">    3835 </span>            :   {}
<a name="3836"><span class="lineNum">    3836 </span>            : </a>
<span class="lineNum">    3837 </span>            :   /* opt_pass methods: */
<span class="lineNum">    3838 </span><span class="lineCov">     832898 :   virtual bool gate (function *fun) { return fun-&gt;eh-&gt;region_tree != NULL; }</span>
<span class="lineNum">    3839 </span>            :   virtual unsigned int execute (function *);
<span class="lineNum">    3840 </span>            : 
<span class="lineNum">    3841 </span>            : }; // class pass_lower_eh_dispatch
<a name="3842"><span class="lineNum">    3842 </span>            : </a>
<span class="lineNum">    3843 </span>            : unsigned
<span class="lineNum">    3844 </span><span class="lineCov">      87765 : pass_lower_eh_dispatch::execute (function *fun)</span>
<span class="lineNum">    3845 </span>            : {
<span class="lineNum">    3846 </span><span class="lineCov">      87765 :   basic_block bb;</span>
<span class="lineNum">    3847 </span><span class="lineCov">      87765 :   int flags = 0;</span>
<span class="lineNum">    3848 </span><span class="lineCov">      87765 :   bool redirected = false;</span>
<span class="lineNum">    3849 </span>            : 
<span class="lineNum">    3850 </span><span class="lineCov">      87765 :   assign_filter_values ();</span>
<span class="lineNum">    3851 </span>            : 
<span class="lineNum">    3852 </span><span class="lineCov">    2682300 :   FOR_EACH_BB_FN (bb, fun)</span>
<span class="lineNum">    3853 </span>            :     {
<span class="lineNum">    3854 </span><span class="lineCov">    2594535 :       gimple *last = last_stmt (bb);</span>
<span class="lineNum">    3855 </span><span class="lineCov">    2594535 :       if (last == NULL)</span>
<span class="lineNum">    3856 </span>            :         continue;
<span class="lineNum">    3857 </span><span class="lineCov">    5075228 :       if (gimple_code (last) == GIMPLE_EH_DISPATCH)</span>
<span class="lineNum">    3858 </span>            :         {
<span class="lineNum">    3859 </span><span class="lineCov">      32507 :           redirected |= lower_eh_dispatch (bb,</span>
<span class="lineNum">    3860 </span>            :                                            as_a &lt;geh_dispatch *&gt; (last));
<span class="lineNum">    3861 </span><span class="lineCov">      32507 :           flags |= TODO_update_ssa_only_virtuals;</span>
<span class="lineNum">    3862 </span>            :         }
<span class="lineNum">    3863 </span><span class="lineCov">    5010214 :       else if (gimple_code (last) == GIMPLE_RESX)</span>
<span class="lineNum">    3864 </span>            :         {
<span class="lineNum">    3865 </span><span class="lineCov">     155817 :           if (stmt_can_throw_external (last))</span>
<span class="lineNum">    3866 </span><span class="lineCov">      68700 :             optimize_clobbers (bb);</span>
<span class="lineNum">    3867 </span>            :           else
<span class="lineNum">    3868 </span><span class="lineCov">      87117 :             flags |= sink_clobbers (bb);</span>
<span class="lineNum">    3869 </span>            :         }
<span class="lineNum">    3870 </span>            :     }
<span class="lineNum">    3871 </span>            : 
<span class="lineNum">    3872 </span><span class="lineCov">      87765 :   if (redirected)</span>
<span class="lineNum">    3873 </span>            :     {
<span class="lineNum">    3874 </span><span class="lineCov">          9 :       free_dominance_info (CDI_DOMINATORS);</span>
<span class="lineNum">    3875 </span><span class="lineCov">          9 :       delete_unreachable_blocks ();</span>
<span class="lineNum">    3876 </span>            :     }
<span class="lineNum">    3877 </span><span class="lineCov">      87765 :   return flags;</span>
<span class="lineNum">    3878 </span>            : }
<span class="lineNum">    3879 </span>            : 
<span class="lineNum">    3880 </span>            : } // anon namespace
<a name="3881"><span class="lineNum">    3881 </span>            : </a>
<span class="lineNum">    3882 </span>            : gimple_opt_pass *
<span class="lineNum">    3883 </span><span class="lineCov">     170312 : make_pass_lower_eh_dispatch (gcc::context *ctxt)</span>
<span class="lineNum">    3884 </span>            : {
<span class="lineNum">    3885 </span><span class="lineCov">     170312 :   return new pass_lower_eh_dispatch (ctxt);</span>
<span class="lineNum">    3886 </span>            : }
<span class="lineNum">    3887 </span>            : 
<span class="lineNum">    3888 </span>            : /* Walk statements, see what regions and, optionally, landing pads
<span class="lineNum">    3889 </span>            :    are really referenced.
<span class="lineNum">    3890 </span>            :    
<span class="lineNum">    3891 </span>            :    Returns in R_REACHABLEP an sbitmap with bits set for reachable regions,
<span class="lineNum">    3892 </span>            :    and in LP_REACHABLE an sbitmap with bits set for reachable landing pads.
<span class="lineNum">    3893 </span>            : 
<span class="lineNum">    3894 </span>            :    Passing NULL for LP_REACHABLE is valid, in this case only reachable
<span class="lineNum">    3895 </span>            :    regions are marked.
<span class="lineNum">    3896 </span>            : 
<span class="lineNum">    3897 </span>            :    The caller is responsible for freeing the returned sbitmaps.  */
<a name="3898"><span class="lineNum">    3898 </span>            : </a>
<span class="lineNum">    3899 </span>            : static void
<span class="lineNum">    3900 </span><span class="lineCov">     821240 : mark_reachable_handlers (sbitmap *r_reachablep, sbitmap *lp_reachablep)</span>
<span class="lineNum">    3901 </span>            : {
<span class="lineNum">    3902 </span><span class="lineCov">     821240 :   sbitmap r_reachable, lp_reachable;</span>
<span class="lineNum">    3903 </span><span class="lineCov">     821240 :   basic_block bb;</span>
<span class="lineNum">    3904 </span><span class="lineCov">     821240 :   bool mark_landing_pads = (lp_reachablep != NULL);</span>
<span class="lineNum">    3905 </span><span class="lineCov">     821240 :   gcc_checking_assert (r_reachablep != NULL);</span>
<span class="lineNum">    3906 </span>            : 
<span class="lineNum">    3907 </span><span class="lineCov">     821240 :   r_reachable = sbitmap_alloc (cfun-&gt;eh-&gt;region_array-&gt;length ());</span>
<span class="lineNum">    3908 </span><span class="lineCov">     821240 :   bitmap_clear (r_reachable);</span>
<span class="lineNum">    3909 </span><span class="lineCov">     821240 :   *r_reachablep = r_reachable;</span>
<span class="lineNum">    3910 </span>            : 
<span class="lineNum">    3911 </span><span class="lineCov">     821240 :   if (mark_landing_pads)</span>
<span class="lineNum">    3912 </span>            :     {
<span class="lineNum">    3913 </span><span class="lineCov">     650015 :       lp_reachable = sbitmap_alloc (cfun-&gt;eh-&gt;lp_array-&gt;length ());</span>
<span class="lineNum">    3914 </span><span class="lineCov">     650015 :       bitmap_clear (lp_reachable);</span>
<span class="lineNum">    3915 </span><span class="lineCov">     650015 :       *lp_reachablep = lp_reachable;</span>
<span class="lineNum">    3916 </span>            :     }
<span class="lineNum">    3917 </span>            :   else
<span class="lineNum">    3918 </span>            :     lp_reachable = NULL;
<span class="lineNum">    3919 </span>            : 
<span class="lineNum">    3920 </span><span class="lineCov">   12772868 :   FOR_EACH_BB_FN (bb, cfun)</span>
<span class="lineNum">    3921 </span>            :     {
<span class="lineNum">    3922 </span><span class="lineCov">   11951628 :       gimple_stmt_iterator gsi;</span>
<span class="lineNum">    3923 </span>            : 
<span class="lineNum">    3924 </span><span class="lineCov">  119297861 :       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&amp;gsi))</span>
<span class="lineNum">    3925 </span>            :         {
<span class="lineNum">    3926 </span><span class="lineCov">   95394605 :           gimple *stmt = gsi_stmt (gsi);</span>
<span class="lineNum">    3927 </span>            : 
<span class="lineNum">    3928 </span><span class="lineCov">   95394605 :           if (mark_landing_pads)</span>
<span class="lineNum">    3929 </span>            :             {
<span class="lineNum">    3930 </span><span class="lineCov">   56324791 :               int lp_nr = lookup_stmt_eh_lp (stmt);</span>
<span class="lineNum">    3931 </span>            : 
<span class="lineNum">    3932 </span>            :               /* Negative LP numbers are MUST_NOT_THROW regions which
<span class="lineNum">    3933 </span>            :                  are not considered BB enders.  */
<span class="lineNum">    3934 </span><span class="lineCov">   56324791 :               if (lp_nr &lt; 0)</span>
<span class="lineNum">    3935 </span><span class="lineCov">      68636 :                 bitmap_set_bit (r_reachable, -lp_nr);</span>
<span class="lineNum">    3936 </span>            : 
<span class="lineNum">    3937 </span>            :               /* Positive LP numbers are real landing pads, and BB enders.  */
<span class="lineNum">    3938 </span><span class="lineCov">   56256155 :               else if (lp_nr &gt; 0)</span>
<span class="lineNum">    3939 </span>            :                 {
<span class="lineNum">    3940 </span><span class="lineCov">    2182662 :                   gcc_assert (gsi_one_before_end_p (gsi));</span>
<span class="lineNum">    3941 </span><span class="lineCov">    2182662 :                   eh_region region = get_eh_region_from_lp_number (lp_nr);</span>
<span class="lineNum">    3942 </span><span class="lineCov">    2182662 :                   bitmap_set_bit (r_reachable, region-&gt;index);</span>
<span class="lineNum">    3943 </span><span class="lineCov">    2182662 :                   bitmap_set_bit (lp_reachable, lp_nr);</span>
<span class="lineNum">    3944 </span>            :                 }
<span class="lineNum">    3945 </span>            :             }
<span class="lineNum">    3946 </span>            : 
<span class="lineNum">    3947 </span>            :           /* Avoid removing regions referenced from RESX/EH_DISPATCH.  */
<span class="lineNum">    3948 </span><span class="lineCov">  190789210 :           switch (gimple_code (stmt))</span>
<span class="lineNum">    3949 </span>            :             {
<span class="lineNum">    3950 </span><span class="lineCov">     663622 :             case GIMPLE_RESX:</span>
<span class="lineNum">    3951 </span><span class="lineCov">     663622 :               bitmap_set_bit (r_reachable,</span>
<span class="lineNum">    3952 </span><span class="lineCov">     663622 :                               gimple_resx_region (as_a &lt;gresx *&gt; (stmt)));</span>
<span class="lineNum">    3953 </span>            :               break;
<span class="lineNum">    3954 </span><span class="lineCov">      49663 :             case GIMPLE_EH_DISPATCH:</span>
<span class="lineNum">    3955 </span><span class="lineCov">      49663 :               bitmap_set_bit (r_reachable,</span>
<span class="lineNum">    3956 </span>            :                               gimple_eh_dispatch_region (
<span class="lineNum">    3957 </span><span class="lineCov">      49663 :                                 as_a &lt;geh_dispatch *&gt; (stmt)));</span>
<span class="lineNum">    3958 </span>            :               break;
<span class="lineNum">    3959 </span><span class="lineCov">    4839475 :             case GIMPLE_CALL:</span>
<span class="lineNum">    3960 </span><span class="lineCov">    4839475 :               if (gimple_call_builtin_p (stmt, BUILT_IN_EH_COPY_VALUES))</span>
<span class="lineNum">    3961 </span><span class="lineNoCov">          0 :                 for (int i = 0; i &lt; 2; ++i)</span>
<span class="lineNum">    3962 </span>            :                   {
<span class="lineNum">    3963 </span><span class="lineNoCov">          0 :                     tree rt = gimple_call_arg (stmt, i);</span>
<span class="lineNum">    3964 </span><span class="lineNoCov">          0 :                     HOST_WIDE_INT ri = tree_to_shwi (rt);</span>
<span class="lineNum">    3965 </span>            : 
<span class="lineNum">    3966 </span><span class="lineNoCov">          0 :                     gcc_assert (ri == (int)ri);</span>
<span class="lineNum">    3967 </span><span class="lineNoCov">          0 :                     bitmap_set_bit (r_reachable, ri);</span>
<span class="lineNum">    3968 </span>            :                   }
<span class="lineNum">    3969 </span>            :               break;
<span class="lineNum">    3970 </span>            :             default:
<span class="lineNum">    3971 </span>            :               break;
<span class="lineNum">    3972 </span>            :             }
<span class="lineNum">    3973 </span>            :         }
<span class="lineNum">    3974 </span>            :     }
<span class="lineNum">    3975 </span><span class="lineCov">     821240 : }</span>
<span class="lineNum">    3976 </span>            : 
<span class="lineNum">    3977 </span>            : /* Remove unreachable handlers and unreachable landing pads.  */
<a name="3978"><span class="lineNum">    3978 </span>            : </a>
<span class="lineNum">    3979 </span>            : static void
<span class="lineNum">    3980 </span><span class="lineCov">     650015 : remove_unreachable_handlers (void)</span>
<span class="lineNum">    3981 </span>            : {
<span class="lineNum">    3982 </span><span class="lineCov">     650015 :   sbitmap r_reachable, lp_reachable;</span>
<span class="lineNum">    3983 </span><span class="lineCov">     650015 :   eh_region region;</span>
<span class="lineNum">    3984 </span><span class="lineCov">     650015 :   eh_landing_pad lp;</span>
<span class="lineNum">    3985 </span><span class="lineCov">     650015 :   unsigned i;</span>
<span class="lineNum">    3986 </span>            : 
<span class="lineNum">    3987 </span><span class="lineCov">     650015 :   mark_reachable_handlers (&amp;r_reachable, &amp;lp_reachable);</span>
<span class="lineNum">    3988 </span>            : 
<span class="lineNum">    3989 </span><span class="lineCov">     650015 :   if (dump_file)</span>
<span class="lineNum">    3990 </span>            :     {
<span class="lineNum">    3991 </span><span class="lineCov">          3 :       fprintf (dump_file, &quot;Before removal of unreachable regions:\n&quot;);</span>
<span class="lineNum">    3992 </span><span class="lineCov">          3 :       dump_eh_tree (dump_file, cfun);</span>
<span class="lineNum">    3993 </span><span class="lineCov">          3 :       fprintf (dump_file, &quot;Reachable regions: &quot;);</span>
<span class="lineNum">    3994 </span><span class="lineCov">          3 :       dump_bitmap_file (dump_file, r_reachable);</span>
<span class="lineNum">    3995 </span><span class="lineCov">          3 :       fprintf (dump_file, &quot;Reachable landing pads: &quot;);</span>
<span class="lineNum">    3996 </span><span class="lineCov">          3 :       dump_bitmap_file (dump_file, lp_reachable);</span>
<span class="lineNum">    3997 </span>            :     }
<span class="lineNum">    3998 </span>            : 
<span class="lineNum">    3999 </span><span class="lineCov">     650015 :   if (dump_file)</span>
<span class="lineNum">    4000 </span>            :     {
<span class="lineNum">    4001 </span><span class="lineCov">         18 :       FOR_EACH_VEC_SAFE_ELT (cfun-&gt;eh-&gt;region_array, i, region)</span>
<span class="lineNum">    4002 </span><span class="lineCov">         15 :         if (region &amp;&amp; !bitmap_bit_p (r_reachable, region-&gt;index))</span>
<span class="lineNum">    4003 </span><span class="lineCov">          6 :           fprintf (dump_file,</span>
<span class="lineNum">    4004 </span>            :                    &quot;Removing unreachable region %d\n&quot;,
<span class="lineNum">    4005 </span>            :                    region-&gt;index);
<span class="lineNum">    4006 </span>            :     }
<span class="lineNum">    4007 </span>            : 
<span class="lineNum">    4008 </span><span class="lineCov">     650015 :   remove_unreachable_eh_regions (r_reachable);</span>
<span class="lineNum">    4009 </span>            : 
<span class="lineNum">    4010 </span><span class="lineCov">    2551531 :   FOR_EACH_VEC_SAFE_ELT (cfun-&gt;eh-&gt;lp_array, i, lp)</span>
<span class="lineNum">    4011 </span><span class="lineCov">    1901516 :     if (lp &amp;&amp; !bitmap_bit_p (lp_reachable, lp-&gt;index))</span>
<span class="lineNum">    4012 </span>            :       {
<span class="lineNum">    4013 </span><span class="lineCov">      12045 :         if (dump_file)</span>
<span class="lineNum">    4014 </span><span class="lineNoCov">          0 :           fprintf (dump_file,</span>
<span class="lineNum">    4015 </span>            :                    &quot;Removing unreachable landing pad %d\n&quot;,
<span class="lineNum">    4016 </span>            :                    lp-&gt;index);
<span class="lineNum">    4017 </span><span class="lineCov">      12045 :         remove_eh_landing_pad (lp);</span>
<span class="lineNum">    4018 </span>            :       }
<span class="lineNum">    4019 </span>            : 
<span class="lineNum">    4020 </span><span class="lineCov">     650015 :   if (dump_file)</span>
<span class="lineNum">    4021 </span>            :     {
<span class="lineNum">    4022 </span><span class="lineCov">          3 :       fprintf (dump_file, &quot;\n\nAfter removal of unreachable regions:\n&quot;);</span>
<span class="lineNum">    4023 </span><span class="lineCov">          3 :       dump_eh_tree (dump_file, cfun);</span>
<span class="lineNum">    4024 </span><span class="lineCov">          3 :       fprintf (dump_file, &quot;\n\n&quot;);</span>
<span class="lineNum">    4025 </span>            :     }
<span class="lineNum">    4026 </span>            : 
<span class="lineNum">    4027 </span><span class="lineCov">     650015 :   sbitmap_free (r_reachable);</span>
<span class="lineNum">    4028 </span><span class="lineCov">     650015 :   sbitmap_free (lp_reachable);</span>
<span class="lineNum">    4029 </span>            : 
<span class="lineNum">    4030 </span><span class="lineCov">     650015 :   if (flag_checking)</span>
<span class="lineNum">    4031 </span><span class="lineCov">     650015 :     verify_eh_tree (cfun);</span>
<span class="lineNum">    4032 </span><span class="lineCov">     650015 : }</span>
<span class="lineNum">    4033 </span>            : 
<span class="lineNum">    4034 </span>            : /* Remove unreachable handlers if any landing pads have been removed after
<span class="lineNum">    4035 </span>            :    last ehcleanup pass (due to gimple_purge_dead_eh_edges).  */
<a name="4036"><span class="lineNum">    4036 </span>            : </a>
<span class="lineNum">    4037 </span>            : void
<span class="lineNum">    4038 </span><span class="lineCov">     832896 : maybe_remove_unreachable_handlers (void)</span>
<span class="lineNum">    4039 </span>            : {
<span class="lineNum">    4040 </span><span class="lineCov">     832896 :   eh_landing_pad lp;</span>
<span class="lineNum">    4041 </span><span class="lineCov">     832896 :   unsigned i;</span>
<span class="lineNum">    4042 </span>            : 
<span class="lineNum">    4043 </span><span class="lineCov">     832896 :   if (cfun-&gt;eh == NULL)</span>
<span class="lineNum">    4044 </span>            :     return;
<span class="lineNum">    4045 </span>            :            
<span class="lineNum">    4046 </span><span class="lineCov">    2576662 :   FOR_EACH_VEC_SAFE_ELT (cfun-&gt;eh-&gt;lp_array, i, lp)</span>
<span class="lineNum">    4047 </span><span class="lineCov">    1743766 :     if (lp &amp;&amp; lp-&gt;post_landing_pad)</span>
<span class="lineNum">    4048 </span>            :       {
<span class="lineNum">    4049 </span><span class="lineCov">     134038 :         if (label_to_block (cfun, lp-&gt;post_landing_pad) == NULL)</span>
<span class="lineNum">    4050 </span>            :           {
<span class="lineNum">    4051 </span><span class="lineNoCov">          0 :             remove_unreachable_handlers ();</span>
<span class="lineNum">    4052 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">    4053 </span>            :           }
<span class="lineNum">    4054 </span>            :       }
<span class="lineNum">    4055 </span>            : }
<span class="lineNum">    4056 </span>            : 
<span class="lineNum">    4057 </span>            : /* Remove regions that do not have landing pads.  This assumes
<span class="lineNum">    4058 </span>            :    that remove_unreachable_handlers has already been run, and
<span class="lineNum">    4059 </span>            :    that we've just manipulated the landing pads since then.
<span class="lineNum">    4060 </span>            : 
<span class="lineNum">    4061 </span>            :    Preserve regions with landing pads and regions that prevent
<span class="lineNum">    4062 </span>            :    exceptions from propagating further, even if these regions
<span class="lineNum">    4063 </span>            :    are not reachable.  */
<a name="4064"><span class="lineNum">    4064 </span>            : </a>
<span class="lineNum">    4065 </span>            : static void
<span class="lineNum">    4066 </span><span class="lineCov">     171225 : remove_unreachable_handlers_no_lp (void)</span>
<span class="lineNum">    4067 </span>            : {
<span class="lineNum">    4068 </span><span class="lineCov">     171225 :   eh_region region;</span>
<span class="lineNum">    4069 </span><span class="lineCov">     171225 :   sbitmap r_reachable;</span>
<span class="lineNum">    4070 </span><span class="lineCov">     171225 :   unsigned i;</span>
<span class="lineNum">    4071 </span>            : 
<span class="lineNum">    4072 </span><span class="lineCov">     171225 :   mark_reachable_handlers (&amp;r_reachable, /*lp_reachablep=*/NULL);</span>
<span class="lineNum">    4073 </span>            : 
<span class="lineNum">    4074 </span><span class="lineCov">    1437122 :   FOR_EACH_VEC_SAFE_ELT (cfun-&gt;eh-&gt;region_array, i, region)</span>
<span class="lineNum">    4075 </span>            :     {
<span class="lineNum">    4076 </span><span class="lineCov">    1265897 :       if (! region)</span>
<span class="lineNum">    4077 </span>            :         continue;
<span class="lineNum">    4078 </span>            : 
<span class="lineNum">    4079 </span><span class="lineCov">     527248 :       if (region-&gt;landing_pads != NULL</span>
<span class="lineNum">    4080 </span><span class="lineCov">     308738 :           || region-&gt;type == ERT_MUST_NOT_THROW)</span>
<span class="lineNum">    4081 </span><span class="lineCov">     251562 :         bitmap_set_bit (r_reachable, region-&gt;index);</span>
<span class="lineNum">    4082 </span>            : 
<span class="lineNum">    4083 </span><span class="lineCov">     527248 :       if (dump_file</span>
<span class="lineNum">    4084 </span><span class="lineCov">     527248 :           &amp;&amp; !bitmap_bit_p (r_reachable, region-&gt;index))</span>
<span class="lineNum">    4085 </span><span class="lineCov">          6 :         fprintf (dump_file,</span>
<span class="lineNum">    4086 </span>            :                  &quot;Removing unreachable region %d\n&quot;,
<span class="lineNum">    4087 </span>            :                  region-&gt;index);
<span class="lineNum">    4088 </span>            :     }
<span class="lineNum">    4089 </span>            : 
<span class="lineNum">    4090 </span><span class="lineCov">     171225 :   remove_unreachable_eh_regions (r_reachable);</span>
<span class="lineNum">    4091 </span>            : 
<span class="lineNum">    4092 </span><span class="lineCov">     342450 :   sbitmap_free (r_reachable);</span>
<span class="lineNum">    4093 </span><span class="lineCov">     171225 : }</span>
<span class="lineNum">    4094 </span>            : 
<span class="lineNum">    4095 </span>            : /* Undo critical edge splitting on an EH landing pad.  Earlier, we
<span class="lineNum">    4096 </span>            :    optimisticaly split all sorts of edges, including EH edges.  The
<span class="lineNum">    4097 </span>            :    optimization passes in between may not have needed them; if not,
<span class="lineNum">    4098 </span>            :    we should undo the split.
<span class="lineNum">    4099 </span>            : 
<span class="lineNum">    4100 </span>            :    Recognize this case by having one EH edge incoming to the BB and
<span class="lineNum">    4101 </span>            :    one normal edge outgoing; BB should be empty apart from the
<span class="lineNum">    4102 </span>            :    post_landing_pad label.
<span class="lineNum">    4103 </span>            : 
<span class="lineNum">    4104 </span>            :    Note that this is slightly different from the empty handler case
<span class="lineNum">    4105 </span>            :    handled by cleanup_empty_eh, in that the actual handler may yet
<span class="lineNum">    4106 </span>            :    have actual code but the landing pad has been separated from the
<span class="lineNum">    4107 </span>            :    handler.  As such, cleanup_empty_eh relies on this transformation
<span class="lineNum">    4108 </span>            :    having been done first.  */
<a name="4109"><span class="lineNum">    4109 </span>            : </a>
<span class="lineNum">    4110 </span>            : static bool
<span class="lineNum">    4111 </span><span class="lineCov">    1027703 : unsplit_eh (eh_landing_pad lp)</span>
<span class="lineNum">    4112 </span>            : {
<span class="lineNum">    4113 </span><span class="lineCov">    1027703 :   basic_block bb = label_to_block (cfun, lp-&gt;post_landing_pad);</span>
<span class="lineNum">    4114 </span><span class="lineCov">    1027703 :   gimple_stmt_iterator gsi;</span>
<span class="lineNum">    4115 </span><span class="lineCov">    1027703 :   edge e_in, e_out;</span>
<span class="lineNum">    4116 </span>            : 
<span class="lineNum">    4117 </span>            :   /* Quickly check the edge counts on BB for singularity.  */
<span class="lineNum">    4118 </span><span class="lineCov">    1027703 :   if (!single_pred_p (bb) || !single_succ_p (bb))</span>
<span class="lineNum">    4119 </span>            :     return false;
<span class="lineNum">    4120 </span><span class="lineCov">     752833 :   e_in = single_pred_edge (bb);</span>
<span class="lineNum">    4121 </span><span class="lineCov">     752833 :   e_out = single_succ_edge (bb);</span>
<span class="lineNum">    4122 </span>            : 
<span class="lineNum">    4123 </span>            :   /* Input edge must be EH and output edge must be normal.  */
<span class="lineNum">    4124 </span><span class="lineCov">     752833 :   if ((e_in-&gt;flags &amp; EDGE_EH) == 0 || (e_out-&gt;flags &amp; EDGE_EH) != 0)</span>
<span class="lineNum">    4125 </span>            :     return false;
<span class="lineNum">    4126 </span>            : 
<span class="lineNum">    4127 </span>            :   /* The block must be empty except for the labels and debug insns.  */
<span class="lineNum">    4128 </span><span class="lineCov">     638010 :   gsi = gsi_after_labels (bb);</span>
<span class="lineNum">    4129 </span><span class="lineCov">    1276020 :   if (!gsi_end_p (gsi) &amp;&amp; is_gimple_debug (gsi_stmt (gsi)))</span>
<span class="lineNum">    4130 </span>            :     gsi_next_nondebug (&amp;gsi);
<span class="lineNum">    4131 </span><span class="lineCov">    1276020 :   if (!gsi_end_p (gsi))</span>
<span class="lineNum">    4132 </span>            :     return false;
<span class="lineNum">    4133 </span>            : 
<span class="lineNum">    4134 </span>            :   /* The destination block must not already have a landing pad
<span class="lineNum">    4135 </span>            :      for a different region.  */
<span class="lineNum">    4136 </span><span class="lineCov">    1796792 :   for (gsi = gsi_start_bb (e_out-&gt;dest); !gsi_end_p (gsi); gsi_next (&amp;gsi))</span>
<span class="lineNum">    4137 </span>            :     {
<span class="lineNum">    4138 </span><span class="lineCov">    2394696 :       glabel *label_stmt = dyn_cast &lt;glabel *&gt; (gsi_stmt (gsi));</span>
<span class="lineNum">    4139 </span><span class="lineCov">     598626 :       tree lab;</span>
<span class="lineNum">    4140 </span><span class="lineCov">     598626 :       int lp_nr;</span>
<span class="lineNum">    4141 </span>            : 
<span class="lineNum">    4142 </span><span class="lineCov">     598626 :       if (!label_stmt)</span>
<span class="lineNum">    4143 </span>            :         break;
<span class="lineNum">    4144 </span><span class="lineCov">     598626 :       lab = gimple_label_label (label_stmt);</span>
<span class="lineNum">    4145 </span><span class="lineCov">     598626 :       lp_nr = EH_LANDING_PAD_NR (lab);</span>
<span class="lineNum">    4146 </span><span class="lineCov">     598626 :       if (lp_nr &amp;&amp; get_eh_region_from_lp_number (lp_nr) != lp-&gt;region)</span>
<span class="lineNum">    4147 </span>            :         return false;
<span class="lineNum">    4148 </span>            :     }
<span class="lineNum">    4149 </span>            : 
<span class="lineNum">    4150 </span>            :   /* The new destination block must not already be a destination of
<span class="lineNum">    4151 </span>            :      the source block, lest we merge fallthru and eh edges and get
<span class="lineNum">    4152 </span>            :      all sorts of confused.  */
<span class="lineNum">    4153 </span><span class="lineCov">     599083 :   if (find_edge (e_in-&gt;src, e_out-&gt;dest))</span>
<span class="lineNum">    4154 </span>            :     return false;
<span class="lineNum">    4155 </span>            : 
<span class="lineNum">    4156 </span>            :   /* ??? We can get degenerate phis due to cfg cleanups.  I would have
<span class="lineNum">    4157 </span>            :      thought this should have been cleaned up by a phicprop pass, but
<span class="lineNum">    4158 </span>            :      that doesn't appear to handle virtuals.  Propagate by hand.  */
<span class="lineNum">    4159 </span><span class="lineCov">     599083 :   if (!gimple_seq_empty_p (phi_nodes (bb)))</span>
<span class="lineNum">    4160 </span>            :     {
<span class="lineNum">    4161 </span><span class="lineCov">          2 :       for (gphi_iterator gpi = gsi_start_phis (bb); !gsi_end_p (gpi); )</span>
<span class="lineNum">    4162 </span>            :         {
<span class="lineNum">    4163 </span><span class="lineCov">          1 :           gimple *use_stmt;</span>
<span class="lineNum">    4164 </span><span class="lineCov">          1 :           gphi *phi = gpi.phi ();</span>
<span class="lineNum">    4165 </span><span class="lineCov">          1 :           tree lhs = gimple_phi_result (phi);</span>
<span class="lineNum">    4166 </span><span class="lineCov">          1 :           tree rhs = gimple_phi_arg_def (phi, 0);</span>
<span class="lineNum">    4167 </span><span class="lineCov">          1 :           use_operand_p use_p;</span>
<span class="lineNum">    4168 </span><span class="lineCov">          1 :           imm_use_iterator iter;</span>
<span class="lineNum">    4169 </span>            : 
<span class="lineNum">    4170 </span><span class="lineCov">          4 :           FOR_EACH_IMM_USE_STMT (use_stmt, iter, lhs)</span>
<span class="lineNum">    4171 </span>            :             {
<span class="lineNum">    4172 </span><span class="lineCov">         18 :               FOR_EACH_IMM_USE_ON_STMT (use_p, iter)</span>
<span class="lineNum">    4173 </span><span class="lineCov">          3 :                 SET_USE (use_p, rhs);</span>
<span class="lineNum">    4174 </span>            :             }
<span class="lineNum">    4175 </span>            : 
<span class="lineNum">    4176 </span><span class="lineCov">          1 :           if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (lhs))</span>
<span class="lineNum">    4177 </span><span class="lineNoCov">          0 :             SSA_NAME_OCCURS_IN_ABNORMAL_PHI (rhs) = 1;</span>
<span class="lineNum">    4178 </span>            : 
<span class="lineNum">    4179 </span><span class="lineCov">          1 :           remove_phi_node (&amp;gpi, true);</span>
<span class="lineNum">    4180 </span>            :         }
<span class="lineNum">    4181 </span>            :     }
<span class="lineNum">    4182 </span>            : 
<span class="lineNum">    4183 </span><span class="lineCov">     599083 :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    4184 </span><span class="lineNoCov">          0 :     fprintf (dump_file, &quot;Unsplit EH landing pad %d to block %i.\n&quot;,</span>
<span class="lineNum">    4185 </span><span class="lineNoCov">          0 :              lp-&gt;index, e_out-&gt;dest-&gt;index);</span>
<span class="lineNum">    4186 </span>            : 
<span class="lineNum">    4187 </span>            :   /* Redirect the edge.  Since redirect_eh_edge_1 expects to be moving
<span class="lineNum">    4188 </span>            :      a successor edge, humor it.  But do the real CFG change with the
<span class="lineNum">    4189 </span>            :      predecessor of E_OUT in order to preserve the ordering of arguments
<span class="lineNum">    4190 </span>            :      to the PHI nodes in E_OUT-&gt;DEST.  */
<span class="lineNum">    4191 </span><span class="lineCov">     599083 :   redirect_eh_edge_1 (e_in, e_out-&gt;dest, false);</span>
<span class="lineNum">    4192 </span><span class="lineCov">     599083 :   redirect_edge_pred (e_out, e_in-&gt;src);</span>
<span class="lineNum">    4193 </span><span class="lineCov">     599083 :   e_out-&gt;flags = e_in-&gt;flags;</span>
<span class="lineNum">    4194 </span><span class="lineCov">     599083 :   e_out-&gt;probability = e_in-&gt;probability;</span>
<span class="lineNum">    4195 </span><span class="lineCov">     599083 :   remove_edge (e_in);</span>
<span class="lineNum">    4196 </span>            : 
<span class="lineNum">    4197 </span><span class="lineCov">     599083 :   return true;</span>
<span class="lineNum">    4198 </span>            : }
<span class="lineNum">    4199 </span>            : 
<span class="lineNum">    4200 </span>            : /* Examine each landing pad block and see if it matches unsplit_eh.  */
<a name="4201"><span class="lineNum">    4201 </span>            : </a>
<span class="lineNum">    4202 </span>            : static bool
<span class="lineNum">    4203 </span><span class="lineCov">     189881 : unsplit_all_eh (void)</span>
<span class="lineNum">    4204 </span>            : {
<span class="lineNum">    4205 </span><span class="lineCov">     189881 :   bool changed = false;</span>
<span class="lineNum">    4206 </span><span class="lineCov">     189881 :   eh_landing_pad lp;</span>
<span class="lineNum">    4207 </span><span class="lineCov">     189881 :   int i;</span>
<span class="lineNum">    4208 </span>            : 
<span class="lineNum">    4209 </span><span class="lineCov">    1348423 :   for (i = 1; vec_safe_iterate (cfun-&gt;eh-&gt;lp_array, i, &amp;lp); ++i)</span>
<span class="lineNum">    4210 </span><span class="lineCov">    1158542 :     if (lp)</span>
<span class="lineNum">    4211 </span><span class="lineCov">    1027703 :       changed |= unsplit_eh (lp);</span>
<span class="lineNum">    4212 </span>            : 
<span class="lineNum">    4213 </span><span class="lineCov">     189881 :   return changed;</span>
<span class="lineNum">    4214 </span>            : }
<span class="lineNum">    4215 </span>            : 
<span class="lineNum">    4216 </span>            : /* A subroutine of cleanup_empty_eh.  Redirect all EH edges incoming
<span class="lineNum">    4217 </span>            :    to OLD_BB to NEW_BB; return true on success, false on failure.
<span class="lineNum">    4218 </span>            : 
<span class="lineNum">    4219 </span>            :    OLD_BB_OUT is the edge into NEW_BB from OLD_BB, so if we miss any
<span class="lineNum">    4220 </span>            :    PHI variables from OLD_BB we can pick them up from OLD_BB_OUT.
<span class="lineNum">    4221 </span>            :    Virtual PHIs may be deleted and marked for renaming.  */
<a name="4222"><span class="lineNum">    4222 </span>            : </a>
<span class="lineNum">    4223 </span>            : static bool
<span class="lineNum">    4224 </span><span class="lineCov">     107598 : cleanup_empty_eh_merge_phis (basic_block new_bb, basic_block old_bb,</span>
<span class="lineNum">    4225 </span>            :                              edge old_bb_out, bool change_region)
<span class="lineNum">    4226 </span>            : {
<span class="lineNum">    4227 </span><span class="lineCov">     107598 :   gphi_iterator ngsi, ogsi;</span>
<span class="lineNum">    4228 </span><span class="lineCov">     107598 :   edge_iterator ei;</span>
<span class="lineNum">    4229 </span><span class="lineCov">     107598 :   edge e;</span>
<span class="lineNum">    4230 </span><span class="lineCov">     107598 :   bitmap ophi_handled;</span>
<span class="lineNum">    4231 </span>            : 
<span class="lineNum">    4232 </span>            :   /* The destination block must not be a regular successor for any
<span class="lineNum">    4233 </span>            :      of the preds of the landing pad.  Thus, avoid turning
<span class="lineNum">    4234 </span>            :         &lt;..&gt;
<span class="lineNum">    4235 </span>            :          |  \ EH
<span class="lineNum">    4236 </span>            :          |  &lt;..&gt;
<span class="lineNum">    4237 </span>            :          |  /
<span class="lineNum">    4238 </span>            :         &lt;..&gt;
<span class="lineNum">    4239 </span>            :      into
<span class="lineNum">    4240 </span>            :         &lt;..&gt;
<span class="lineNum">    4241 </span>            :         |  | EH
<span class="lineNum">    4242 </span>            :         &lt;..&gt;
<span class="lineNum">    4243 </span>            :      which CFG verification would choke on.  See PR45172 and PR51089.  */
<span class="lineNum">    4244 </span><span class="lineCov">     698708 :   FOR_EACH_EDGE (e, ei, old_bb-&gt;preds)</span>
<span class="lineNum">    4245 </span><span class="lineCov">     483513 :     if (find_edge (e-&gt;src, new_bb))</span>
<span class="lineNum">    4246 </span>            :       return false;
<span class="lineNum">    4247 </span>            : 
<span class="lineNum">    4248 </span><span class="lineCov">     698705 :   FOR_EACH_EDGE (e, ei, old_bb-&gt;preds)</span>
<span class="lineNum">    4249 </span><span class="lineCov">     483511 :     redirect_edge_var_map_clear (e);</span>
<span class="lineNum">    4250 </span>            : 
<span class="lineNum">    4251 </span><span class="lineCov">     107597 :   ophi_handled = BITMAP_ALLOC (NULL);</span>
<span class="lineNum">    4252 </span>            : 
<span class="lineNum">    4253 </span>            :   /* First, iterate through the PHIs on NEW_BB and set up the edge_var_map
<span class="lineNum">    4254 </span>            :      for the edges we're going to move.  */
<span class="lineNum">    4255 </span><span class="lineCov">     165040 :   for (ngsi = gsi_start_phis (new_bb); !gsi_end_p (ngsi); gsi_next (&amp;ngsi))</span>
<span class="lineNum">    4256 </span>            :     {
<span class="lineNum">    4257 </span><span class="lineCov">      57444 :       gphi *ophi, *nphi = ngsi.phi ();</span>
<span class="lineNum">    4258 </span><span class="lineCov">      57444 :       tree nresult, nop;</span>
<span class="lineNum">    4259 </span>            : 
<span class="lineNum">    4260 </span><span class="lineCov">      57444 :       nresult = gimple_phi_result (nphi);</span>
<span class="lineNum">    4261 </span><span class="lineCov">      57444 :       nop = gimple_phi_arg_def (nphi, old_bb_out-&gt;dest_idx);</span>
<span class="lineNum">    4262 </span>            : 
<span class="lineNum">    4263 </span>            :       /* Find the corresponding PHI in OLD_BB so we can forward-propagate
<span class="lineNum">    4264 </span>            :          the source ssa_name.  */
<span class="lineNum">    4265 </span><span class="lineCov">      57444 :       ophi = NULL;</span>
<span class="lineNum">    4266 </span><span class="lineCov">      61986 :       for (ogsi = gsi_start_phis (old_bb); !gsi_end_p (ogsi); gsi_next (&amp;ogsi))</span>
<span class="lineNum">    4267 </span>            :         {
<span class="lineNum">    4268 </span><span class="lineCov">      20407 :           ophi = ogsi.phi ();</span>
<span class="lineNum">    4269 </span><span class="lineCov">      40814 :           if (gimple_phi_result (ophi) == nop)</span>
<span class="lineNum">    4270 </span>            :             break;
<span class="lineNum">    4271 </span><span class="lineCov">       2271 :           ophi = NULL;</span>
<span class="lineNum">    4272 </span>            :         }
<span class="lineNum">    4273 </span>            : 
<span class="lineNum">    4274 </span>            :       /* If we did find the corresponding PHI, copy those inputs.  */
<span class="lineNum">    4275 </span><span class="lineCov">      57444 :       if (ophi)</span>
<span class="lineNum">    4276 </span>            :         {
<span class="lineNum">    4277 </span>            :           /* If NOP is used somewhere else beyond phis in new_bb, give up.  */
<span class="lineNum">    4278 </span><span class="lineCov">      18136 :           if (!has_single_use (nop))</span>
<span class="lineNum">    4279 </span>            :             {
<span class="lineNum">    4280 </span><span class="lineCov">         72 :               imm_use_iterator imm_iter;</span>
<span class="lineNum">    4281 </span><span class="lineCov">         72 :               use_operand_p use_p;</span>
<span class="lineNum">    4282 </span>            : 
<span class="lineNum">    4283 </span><span class="lineCov">        216 :               FOR_EACH_IMM_USE_FAST (use_p, imm_iter, nop)</span>
<span class="lineNum">    4284 </span>            :                 {
<span class="lineNum">    4285 </span><span class="lineCov">        145 :                   if (!gimple_debug_bind_p (USE_STMT (use_p))</span>
<span class="lineNum">    4286 </span><span class="lineCov">        290 :                       &amp;&amp; (gimple_code (USE_STMT (use_p)) != GIMPLE_PHI</span>
<span class="lineNum">    4287 </span><span class="lineCov">        288 :                           || gimple_bb (USE_STMT (use_p)) != new_bb))</span>
<span class="lineNum">    4288 </span><span class="lineCov">          1 :                     goto fail;</span>
<span class="lineNum">    4289 </span>            :                 }
<span class="lineNum">    4290 </span>            :             }
<span class="lineNum">    4291 </span><span class="lineCov">      18135 :           bitmap_set_bit (ophi_handled, SSA_NAME_VERSION (nop));</span>
<span class="lineNum">    4292 </span><span class="lineCov">     190444 :           FOR_EACH_EDGE (e, ei, old_bb-&gt;preds)</span>
<span class="lineNum">    4293 </span>            :             {
<span class="lineNum">    4294 </span><span class="lineCov">     154174 :               location_t oloc;</span>
<span class="lineNum">    4295 </span><span class="lineCov">     154174 :               tree oop;</span>
<span class="lineNum">    4296 </span>            : 
<span class="lineNum">    4297 </span><span class="lineCov">     154174 :               if ((e-&gt;flags &amp; EDGE_EH) == 0)</span>
<span class="lineNum">    4298 </span>            :                 continue;
<span class="lineNum">    4299 </span><span class="lineCov">     154091 :               oop = gimple_phi_arg_def (ophi, e-&gt;dest_idx);</span>
<span class="lineNum">    4300 </span><span class="lineCov">     154091 :               oloc = gimple_phi_arg_location (ophi, e-&gt;dest_idx);</span>
<span class="lineNum">    4301 </span><span class="lineCov">     154091 :               redirect_edge_var_map_add (e, nresult, oop, oloc);</span>
<span class="lineNum">    4302 </span>            :             }
<span class="lineNum">    4303 </span>            :         }
<span class="lineNum">    4304 </span>            :       /* If we didn't find the PHI, if it's a real variable or a VOP, we know
<span class="lineNum">    4305 </span>            :          from the fact that OLD_BB is tree_empty_eh_handler_p that the
<span class="lineNum">    4306 </span>            :          variable is unchanged from input to the block and we can simply
<span class="lineNum">    4307 </span>            :          re-use the input to NEW_BB from the OLD_BB_OUT edge.  */
<span class="lineNum">    4308 </span>            :       else
<span class="lineNum">    4309 </span>            :         {
<span class="lineNum">    4310 </span><span class="lineCov">      39308 :           location_t nloc</span>
<span class="lineNum">    4311 </span><span class="lineCov">      39308 :             = gimple_phi_arg_location (nphi, old_bb_out-&gt;dest_idx);</span>
<span class="lineNum">    4312 </span><span class="lineCov">     134535 :           FOR_EACH_EDGE (e, ei, old_bb-&gt;preds)</span>
<span class="lineNum">    4313 </span><span class="lineCov">      55919 :             redirect_edge_var_map_add (e, nresult, nop, nloc);</span>
<span class="lineNum">    4314 </span>            :         }
<span class="lineNum">    4315 </span>            :     }
<span class="lineNum">    4316 </span>            : 
<span class="lineNum">    4317 </span>            :   /* Second, verify that all PHIs from OLD_BB have been handled.  If not,
<span class="lineNum">    4318 </span>            :      we don't know what values from the other edges into NEW_BB to use.  */
<span class="lineNum">    4319 </span><span class="lineCov">     125729 :   for (ogsi = gsi_start_phis (old_bb); !gsi_end_p (ogsi); gsi_next (&amp;ogsi))</span>
<span class="lineNum">    4320 </span>            :     {
<span class="lineNum">    4321 </span><span class="lineCov">      42316 :       gphi *ophi = ogsi.phi ();</span>
<span class="lineNum">    4322 </span><span class="lineCov">      42316 :       tree oresult = gimple_phi_result (ophi);</span>
<span class="lineNum">    4323 </span><span class="lineCov">      42316 :       if (!bitmap_bit_p (ophi_handled, SSA_NAME_VERSION (oresult)))</span>
<span class="lineNum">    4324 </span>            :         goto fail;
<span class="lineNum">    4325 </span>            :     }
<span class="lineNum">    4326 </span>            : 
<span class="lineNum">    4327 </span>            :   /* Finally, move the edges and update the PHIs.  */
<span class="lineNum">    4328 </span><span class="lineCov">     405060 :   for (ei = ei_start (old_bb-&gt;preds); (e = ei_safe_edge (ei)); )</span>
<span class="lineNum">    4329 </span><span class="lineCov">     238234 :     if (e-&gt;flags &amp; EDGE_EH)</span>
<span class="lineNum">    4330 </span>            :       {
<span class="lineNum">    4331 </span>            :         /* ???  CFG manipluation routines do not try to update loop
<span class="lineNum">    4332 </span>            :            form on edge redirection.  Do so manually here for now.  */
<span class="lineNum">    4333 </span>            :         /* If we redirect a loop entry or latch edge that will either create
<span class="lineNum">    4334 </span>            :            a multiple entry loop or rotate the loop.  If the loops merge
<span class="lineNum">    4335 </span>            :            we may have created a loop with multiple latches.
<span class="lineNum">    4336 </span>            :            All of this isn't easily fixed thus cancel the affected loop
<span class="lineNum">    4337 </span>            :            and mark the other loop as possibly having multiple latches.  */
<span class="lineNum">    4338 </span><span class="lineCov">     233909 :         if (e-&gt;dest == e-&gt;dest-&gt;loop_father-&gt;header)</span>
<span class="lineNum">    4339 </span>            :           {
<span class="lineNum">    4340 </span><span class="lineNoCov">          0 :             mark_loop_for_removal (e-&gt;dest-&gt;loop_father);</span>
<span class="lineNum">    4341 </span><span class="lineNoCov">          0 :             new_bb-&gt;loop_father-&gt;latch = NULL;</span>
<span class="lineNum">    4342 </span><span class="lineNoCov">          0 :             loops_state_set (LOOPS_MAY_HAVE_MULTIPLE_LATCHES);</span>
<span class="lineNum">    4343 </span>            :           }
<span class="lineNum">    4344 </span><span class="lineCov">     233909 :         redirect_eh_edge_1 (e, new_bb, change_region);</span>
<span class="lineNum">    4345 </span><span class="lineCov">     233909 :         redirect_edge_succ (e, new_bb);</span>
<span class="lineNum">    4346 </span><span class="lineCov">     233909 :         flush_pending_stmts (e);</span>
<span class="lineNum">    4347 </span>            :       }
<span class="lineNum">    4348 </span>            :     else
<span class="lineNum">    4349 </span><span class="lineCov">       4325 :       ei_next (&amp;ei);</span>
<span class="lineNum">    4350 </span>            : 
<span class="lineNum">    4351 </span><span class="lineCov">      83413 :   BITMAP_FREE (ophi_handled);</span>
<span class="lineNum">    4352 </span><span class="lineCov">      83413 :   return true;</span>
<span class="lineNum">    4353 </span>            : 
<span class="lineNum">    4354 </span><span class="lineCov">      24184 :  fail:</span>
<span class="lineNum">    4355 </span><span class="lineCov">     293645 :   FOR_EACH_EDGE (e, ei, old_bb-&gt;preds)</span>
<span class="lineNum">    4356 </span><span class="lineCov">     245277 :     redirect_edge_var_map_clear (e);</span>
<span class="lineNum">    4357 </span><span class="lineCov">      24184 :   BITMAP_FREE (ophi_handled);</span>
<span class="lineNum">    4358 </span><span class="lineCov">      24184 :   return false;</span>
<span class="lineNum">    4359 </span>            : }
<span class="lineNum">    4360 </span>            : 
<span class="lineNum">    4361 </span>            : /* A subroutine of cleanup_empty_eh.  Move a landing pad LP from its
<span class="lineNum">    4362 </span>            :    old region to NEW_REGION at BB.  */
<a name="4363"><span class="lineNum">    4363 </span>            : </a>
<span class="lineNum">    4364 </span>            : static void
<span class="lineNum">    4365 </span><span class="lineCov">      24136 : cleanup_empty_eh_move_lp (basic_block bb, edge e_out,</span>
<span class="lineNum">    4366 </span>            :                           eh_landing_pad lp, eh_region new_region)
<span class="lineNum">    4367 </span>            : {
<span class="lineNum">    4368 </span><span class="lineCov">      24136 :   gimple_stmt_iterator gsi;</span>
<span class="lineNum">    4369 </span><span class="lineCov">      24136 :   eh_landing_pad *pp;</span>
<span class="lineNum">    4370 </span>            : 
<span class="lineNum">    4371 </span><span class="lineCov">      24136 :   for (pp = &amp;lp-&gt;region-&gt;landing_pads; *pp != lp; pp = &amp;(*pp)-&gt;next_lp)</span>
<span class="lineNum">    4372 </span><span class="lineNoCov">          0 :     continue;</span>
<span class="lineNum">    4373 </span><span class="lineCov">      24136 :   *pp = lp-&gt;next_lp;</span>
<span class="lineNum">    4374 </span>            : 
<span class="lineNum">    4375 </span><span class="lineCov">      24136 :   lp-&gt;region = new_region;</span>
<span class="lineNum">    4376 </span><span class="lineCov">      24136 :   lp-&gt;next_lp = new_region-&gt;landing_pads;</span>
<span class="lineNum">    4377 </span><span class="lineCov">      24136 :   new_region-&gt;landing_pads = lp;</span>
<span class="lineNum">    4378 </span>            : 
<span class="lineNum">    4379 </span>            :   /* Delete the RESX that was matched within the empty handler block.  */
<span class="lineNum">    4380 </span><span class="lineCov">      24136 :   gsi = gsi_last_bb (bb);</span>
<span class="lineNum">    4381 </span><span class="lineCov">      48272 :   unlink_stmt_vdef (gsi_stmt (gsi));</span>
<span class="lineNum">    4382 </span><span class="lineCov">      24136 :   gsi_remove (&amp;gsi, true);</span>
<span class="lineNum">    4383 </span>            : 
<span class="lineNum">    4384 </span>            :   /* Clean up E_OUT for the fallthru.  */
<span class="lineNum">    4385 </span><span class="lineCov">      24136 :   e_out-&gt;flags = (e_out-&gt;flags &amp; ~EDGE_EH) | EDGE_FALLTHRU;</span>
<span class="lineNum">    4386 </span><span class="lineCov">      48272 :   e_out-&gt;probability = profile_probability::always ();</span>
<span class="lineNum">    4387 </span><span class="lineCov">      24136 : }</span>
<span class="lineNum">    4388 </span>            : 
<span class="lineNum">    4389 </span>            : /* A subroutine of cleanup_empty_eh.  Handle more complex cases of
<span class="lineNum">    4390 </span>            :    unsplitting than unsplit_eh was prepared to handle, e.g. when
<span class="lineNum">    4391 </span>            :    multiple incoming edges and phis are involved.  */
<a name="4392"><span class="lineNum">    4392 </span>            : </a>
<span class="lineNum">    4393 </span>            : static bool
<span class="lineNum">    4394 </span><span class="lineCov">        265 : cleanup_empty_eh_unsplit (basic_block bb, edge e_out, eh_landing_pad lp)</span>
<span class="lineNum">    4395 </span>            : {
<span class="lineNum">    4396 </span><span class="lineCov">        265 :   gimple_stmt_iterator gsi;</span>
<span class="lineNum">    4397 </span><span class="lineCov">        265 :   tree lab;</span>
<span class="lineNum">    4398 </span>            : 
<span class="lineNum">    4399 </span>            :   /* We really ought not have totally lost everything following
<span class="lineNum">    4400 </span>            :      a landing pad label.  Given that BB is empty, there had better
<span class="lineNum">    4401 </span>            :      be a successor.  */
<span class="lineNum">    4402 </span><span class="lineCov">        265 :   gcc_assert (e_out != NULL);</span>
<span class="lineNum">    4403 </span>            : 
<span class="lineNum">    4404 </span>            :   /* The destination block must not already have a landing pad
<span class="lineNum">    4405 </span>            :      for a different region.  */
<span class="lineNum">    4406 </span><span class="lineCov">        265 :   lab = NULL;</span>
<span class="lineNum">    4407 </span><span class="lineCov">        660 :   for (gsi = gsi_start_bb (e_out-&gt;dest); !gsi_end_p (gsi); gsi_next (&amp;gsi))</span>
<span class="lineNum">    4408 </span>            :     {
<span class="lineNum">    4409 </span><span class="lineCov">        790 :       glabel *stmt = dyn_cast &lt;glabel *&gt; (gsi_stmt (gsi));</span>
<span class="lineNum">    4410 </span><span class="lineCov">        130 :       int lp_nr;</span>
<span class="lineNum">    4411 </span>            : 
<span class="lineNum">    4412 </span><span class="lineCov">        130 :       if (!stmt)</span>
<span class="lineNum">    4413 </span>            :         break;
<span class="lineNum">    4414 </span><span class="lineCov">        130 :       lab = gimple_label_label (stmt);</span>
<span class="lineNum">    4415 </span><span class="lineCov">        130 :       lp_nr = EH_LANDING_PAD_NR (lab);</span>
<span class="lineNum">    4416 </span><span class="lineCov">        130 :       if (lp_nr &amp;&amp; get_eh_region_from_lp_number (lp_nr) != lp-&gt;region)</span>
<span class="lineNum">    4417 </span>            :         return false;
<span class="lineNum">    4418 </span>            :     }
<span class="lineNum">    4419 </span>            : 
<span class="lineNum">    4420 </span>            :   /* Attempt to move the PHIs into the successor block.  */
<span class="lineNum">    4421 </span><span class="lineCov">        265 :   if (cleanup_empty_eh_merge_phis (e_out-&gt;dest, bb, e_out, false))</span>
<span class="lineNum">    4422 </span>            :     {
<span class="lineNum">    4423 </span><span class="lineCov">        262 :       if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    4424 </span><span class="lineNoCov">          0 :         fprintf (dump_file,</span>
<span class="lineNum">    4425 </span>            :                  &quot;Unsplit EH landing pad %d to block %i &quot;
<span class="lineNum">    4426 </span>            :                  &quot;(via cleanup_empty_eh).\n&quot;,
<span class="lineNum">    4427 </span><span class="lineNoCov">          0 :                  lp-&gt;index, e_out-&gt;dest-&gt;index);</span>
<span class="lineNum">    4428 </span><span class="lineCov">        262 :       return true;</span>
<span class="lineNum">    4429 </span>            :     }
<span class="lineNum">    4430 </span>            : 
<span class="lineNum">    4431 </span>            :   return false;
<span class="lineNum">    4432 </span>            : }
<span class="lineNum">    4433 </span>            : 
<span class="lineNum">    4434 </span>            : /* Return true if edge E_FIRST is part of an empty infinite loop
<span class="lineNum">    4435 </span>            :    or leads to such a loop through a series of single successor
<span class="lineNum">    4436 </span>            :    empty bbs.  */
<a name="4437"><span class="lineNum">    4437 </span>            : </a>
<span class="lineNum">    4438 </span>            : static bool
<span class="lineNum">    4439 </span><span class="lineCov">        293 : infinite_empty_loop_p (edge e_first)</span>
<span class="lineNum">    4440 </span>            : {
<span class="lineNum">    4441 </span><span class="lineCov">        293 :   bool inf_loop = false;</span>
<span class="lineNum">    4442 </span><span class="lineCov">        293 :   edge e;</span>
<span class="lineNum">    4443 </span>            : 
<span class="lineNum">    4444 </span><span class="lineCov">        293 :   if (e_first-&gt;dest == e_first-&gt;src)</span>
<span class="lineNum">    4445 </span>            :     return true;
<span class="lineNum">    4446 </span>            : 
<span class="lineNum">    4447 </span><span class="lineCov">        292 :   e_first-&gt;src-&gt;aux = (void *) 1;</span>
<span class="lineNum">    4448 </span><span class="lineCov">        331 :   for (e = e_first; single_succ_p (e-&gt;dest); e = single_succ_edge (e-&gt;dest))</span>
<span class="lineNum">    4449 </span>            :     {
<span class="lineNum">    4450 </span><span class="lineCov">        107 :       gimple_stmt_iterator gsi;</span>
<span class="lineNum">    4451 </span><span class="lineCov">        107 :       if (e-&gt;dest-&gt;aux)</span>
<span class="lineNum">    4452 </span>            :         {
<span class="lineNum">    4453 </span>            :           inf_loop = true;
<span class="lineNum">    4454 </span><span class="lineCov">         68 :           break;</span>
<span class="lineNum">    4455 </span>            :         }
<span class="lineNum">    4456 </span><span class="lineCov">         80 :       e-&gt;dest-&gt;aux = (void *) 1;</span>
<span class="lineNum">    4457 </span><span class="lineCov">         80 :       gsi = gsi_after_labels (e-&gt;dest);</span>
<span class="lineNum">    4458 </span><span class="lineCov">        160 :       if (!gsi_end_p (gsi) &amp;&amp; is_gimple_debug (gsi_stmt (gsi)))</span>
<span class="lineNum">    4459 </span>            :         gsi_next_nondebug (&amp;gsi);
<span class="lineNum">    4460 </span><span class="lineCov">        160 :       if (!gsi_end_p (gsi))</span>
<span class="lineNum">    4461 </span>            :         break;
<span class="lineNum">    4462 </span>            :     }
<span class="lineNum">    4463 </span><span class="lineCov">        292 :   e_first-&gt;src-&gt;aux = NULL;</span>
<span class="lineNum">    4464 </span><span class="lineCov">        372 :   for (e = e_first; e-&gt;dest-&gt;aux; e = single_succ_edge (e-&gt;dest))</span>
<span class="lineNum">    4465 </span><span class="lineCov">         80 :     e-&gt;dest-&gt;aux = NULL;</span>
<span class="lineNum">    4466 </span>            : 
<span class="lineNum">    4467 </span>            :   return inf_loop;
<span class="lineNum">    4468 </span>            : }
<span class="lineNum">    4469 </span>            : 
<span class="lineNum">    4470 </span>            : /* Examine the block associated with LP to determine if it's an empty
<span class="lineNum">    4471 </span>            :    handler for its EH region.  If so, attempt to redirect EH edges to
<span class="lineNum">    4472 </span>            :    an outer region.  Return true the CFG was updated in any way.  This
<span class="lineNum">    4473 </span>            :    is similar to jump forwarding, just across EH edges.  */
<a name="4474"><span class="lineNum">    4474 </span>            : </a>
<span class="lineNum">    4475 </span>            : static bool
<span class="lineNum">    4476 </span><span class="lineCov">     549355 : cleanup_empty_eh (eh_landing_pad lp)</span>
<span class="lineNum">    4477 </span>            : {
<span class="lineNum">    4478 </span><span class="lineCov">     549355 :   basic_block bb = label_to_block (cfun, lp-&gt;post_landing_pad);</span>
<span class="lineNum">    4479 </span><span class="lineCov">     549355 :   gimple_stmt_iterator gsi;</span>
<span class="lineNum">    4480 </span><span class="lineCov">     549355 :   gimple *resx;</span>
<span class="lineNum">    4481 </span><span class="lineCov">     549355 :   eh_region new_region;</span>
<span class="lineNum">    4482 </span><span class="lineCov">     549355 :   edge_iterator ei;</span>
<span class="lineNum">    4483 </span><span class="lineCov">     549355 :   edge e, e_out;</span>
<span class="lineNum">    4484 </span><span class="lineCov">     549355 :   bool has_non_eh_pred;</span>
<span class="lineNum">    4485 </span><span class="lineCov">     549355 :   bool ret = false;</span>
<span class="lineNum">    4486 </span><span class="lineCov">     549355 :   int new_lp_nr;</span>
<span class="lineNum">    4487 </span>            : 
<span class="lineNum">    4488 </span>            :   /* There can be zero or one edges out of BB.  This is the quickest test.  */
<span class="lineNum">    4489 </span><span class="lineCov">     549355 :   switch (EDGE_COUNT (bb-&gt;succs))</span>
<span class="lineNum">    4490 </span>            :     {
<span class="lineNum">    4491 </span>            :     case 0:
<span class="lineNum">    4492 </span>            :       e_out = NULL;
<span class="lineNum">    4493 </span>            :       break;
<span class="lineNum">    4494 </span><span class="lineCov">     224633 :     case 1:</span>
<span class="lineNum">    4495 </span><span class="lineCov">     224633 :       e_out = single_succ_edge (bb);</span>
<span class="lineNum">    4496 </span><span class="lineCov">     224633 :       break;</span>
<span class="lineNum">    4497 </span>            :     default:
<span class="lineNum">    4498 </span>            :       return false;
<span class="lineNum">    4499 </span>            :     }
<span class="lineNum">    4500 </span>            : 
<span class="lineNum">    4501 </span><span class="lineCov">     455871 :   gsi = gsi_last_nondebug_bb (bb);</span>
<span class="lineNum">    4502 </span><span class="lineCov">     455871 :   resx = gsi_stmt (gsi);</span>
<span class="lineNum">    4503 </span><span class="lineCov">     455871 :   if (resx &amp;&amp; is_gimple_resx (resx))</span>
<span class="lineNum">    4504 </span>            :     {
<span class="lineNum">    4505 </span><span class="lineCov">     406482 :       if (stmt_can_throw_external (resx))</span>
<span class="lineNum">    4506 </span><span class="lineCov">     229631 :         optimize_clobbers (bb);</span>
<span class="lineNum">    4507 </span><span class="lineCov">     176851 :       else if (sink_clobbers (bb))</span>
<span class="lineNum">    4508 </span><span class="lineCov">        677 :         ret = true;</span>
<span class="lineNum">    4509 </span>            :     }
<span class="lineNum">    4510 </span>            : 
<span class="lineNum">    4511 </span><span class="lineCov">     455871 :   gsi = gsi_after_labels (bb);</span>
<span class="lineNum">    4512 </span>            : 
<span class="lineNum">    4513 </span>            :   /* Make sure to skip debug statements.  */
<span class="lineNum">    4514 </span><span class="lineCov">     911742 :   if (!gsi_end_p (gsi) &amp;&amp; is_gimple_debug (gsi_stmt (gsi)))</span>
<span class="lineNum">    4515 </span>            :     gsi_next_nondebug (&amp;gsi);
<span class="lineNum">    4516 </span>            : 
<span class="lineNum">    4517 </span>            :   /* If the block is totally empty, look for more unsplitting cases.  */
<span class="lineNum">    4518 </span><span class="lineCov">     911742 :   if (gsi_end_p (gsi))</span>
<span class="lineNum">    4519 </span>            :     {
<span class="lineNum">    4520 </span>            :       /* For the degenerate case of an infinite loop bail out.
<span class="lineNum">    4521 </span>            :          If bb has no successors and is totally empty, which can happen e.g.
<span class="lineNum">    4522 </span>            :          because of incorrect noreturn attribute, bail out too.  */
<span class="lineNum">    4523 </span><span class="lineCov">        293 :       if (e_out == NULL</span>
<span class="lineNum">    4524 </span><span class="lineCov">        293 :           || infinite_empty_loop_p (e_out))</span>
<span class="lineNum">    4525 </span><span class="lineCov">         28 :         return ret;</span>
<span class="lineNum">    4526 </span>            : 
<span class="lineNum">    4527 </span><span class="lineCov">        265 :       return ret | cleanup_empty_eh_unsplit (bb, e_out, lp);</span>
<span class="lineNum">    4528 </span>            :     }
<span class="lineNum">    4529 </span>            : 
<span class="lineNum">    4530 </span>            :   /* The block should consist only of a single RESX statement, modulo a
<span class="lineNum">    4531 </span>            :      preceding call to __builtin_stack_restore if there is no outgoing
<span class="lineNum">    4532 </span>            :      edge, since the call can be eliminated in this case.  */
<span class="lineNum">    4533 </span><span class="lineCov">     455578 :   resx = gsi_stmt (gsi);</span>
<span class="lineNum">    4534 </span><span class="lineCov">     455578 :   if (!e_out &amp;&amp; gimple_call_builtin_p (resx, BUILT_IN_STACK_RESTORE))</span>
<span class="lineNum">    4535 </span>            :     {
<span class="lineNum">    4536 </span>            :       gsi_next_nondebug (&amp;gsi);
<span class="lineNum">    4537 </span>            :       resx = gsi_stmt (gsi);
<span class="lineNum">    4538 </span>            :     }
<span class="lineNum">    4539 </span><span class="lineCov">     911156 :   if (!is_gimple_resx (resx))</span>
<span class="lineNum">    4540 </span>            :     return ret;
<span class="lineNum">    4541 </span><span class="lineCov">     285054 :   gcc_assert (gsi_one_nondebug_before_end_p (gsi));</span>
<span class="lineNum">    4542 </span>            : 
<span class="lineNum">    4543 </span>            :   /* Determine if there are non-EH edges, or resx edges into the handler.  */
<span class="lineNum">    4544 </span><span class="lineCov">     285054 :   has_non_eh_pred = false;</span>
<span class="lineNum">    4545 </span><span class="lineCov">    2067598 :   FOR_EACH_EDGE (e, ei, bb-&gt;preds)</span>
<span class="lineNum">    4546 </span><span class="lineCov">    1497490 :     if (!(e-&gt;flags &amp; EDGE_EH))</span>
<span class="lineNum">    4547 </span><span class="lineCov">       9530 :       has_non_eh_pred = true;</span>
<span class="lineNum">    4548 </span>            : 
<span class="lineNum">    4549 </span>            :   /* Find the handler that's outer of the empty handler by looking at
<span class="lineNum">    4550 </span>            :      where the RESX instruction was vectored.  */
<span class="lineNum">    4551 </span><span class="lineCov">     285054 :   new_lp_nr = lookup_stmt_eh_lp (resx);</span>
<span class="lineNum">    4552 </span><span class="lineCov">     285054 :   new_region = get_eh_region_from_lp_number (new_lp_nr);</span>
<span class="lineNum">    4553 </span>            : 
<span class="lineNum">    4554 </span>            :   /* If there's no destination region within the current function,
<span class="lineNum">    4555 </span>            :      redirection is trivial via removing the throwing statements from
<span class="lineNum">    4556 </span>            :      the EH region, removing the EH edges, and allowing the block
<span class="lineNum">    4557 </span>            :      to go unreachable.  */
<span class="lineNum">    4558 </span><span class="lineCov">     285054 :   if (new_region == NULL)</span>
<span class="lineNum">    4559 </span>            :     {
<span class="lineNum">    4560 </span><span class="lineCov">     177721 :       gcc_assert (e_out == NULL);</span>
<span class="lineNum">    4561 </span><span class="lineCov">    1370228 :       for (ei = ei_start (bb-&gt;preds); (e = ei_safe_edge (ei)); )</span>
<span class="lineNum">    4562 </span><span class="lineCov">    1014786 :         if (e-&gt;flags &amp; EDGE_EH)</span>
<span class="lineNum">    4563 </span>            :           {
<span class="lineNum">    4564 </span><span class="lineCov">    1009639 :             gimple *stmt = last_stmt (e-&gt;src);</span>
<span class="lineNum">    4565 </span><span class="lineCov">    1009639 :             remove_stmt_from_eh_lp (stmt);</span>
<span class="lineNum">    4566 </span><span class="lineCov">    1009639 :             remove_edge (e);</span>
<span class="lineNum">    4567 </span>            :           }
<span class="lineNum">    4568 </span>            :         else
<span class="lineNum">    4569 </span><span class="lineCov">       5147 :           ei_next (&amp;ei);</span>
<span class="lineNum">    4570 </span>            :       goto succeed;
<span class="lineNum">    4571 </span>            :     }
<span class="lineNum">    4572 </span>            : 
<span class="lineNum">    4573 </span>            :   /* If the destination region is a MUST_NOT_THROW, allow the runtime
<span class="lineNum">    4574 </span>            :      to handle the abort and allow the blocks to go unreachable.  */
<span class="lineNum">    4575 </span><span class="lineCov">     107333 :   if (new_region-&gt;type == ERT_MUST_NOT_THROW)</span>
<span class="lineNum">    4576 </span>            :     {
<span class="lineNum">    4577 </span><span class="lineNoCov">          0 :       for (ei = ei_start (bb-&gt;preds); (e = ei_safe_edge (ei)); )</span>
<span class="lineNum">    4578 </span><span class="lineNoCov">          0 :         if (e-&gt;flags &amp; EDGE_EH)</span>
<span class="lineNum">    4579 </span>            :           {
<span class="lineNum">    4580 </span><span class="lineNoCov">          0 :             gimple *stmt = last_stmt (e-&gt;src);</span>
<span class="lineNum">    4581 </span><span class="lineNoCov">          0 :             remove_stmt_from_eh_lp (stmt);</span>
<span class="lineNum">    4582 </span><span class="lineNoCov">          0 :             add_stmt_to_eh_lp (stmt, new_lp_nr);</span>
<span class="lineNum">    4583 </span><span class="lineNoCov">          0 :             remove_edge (e);</span>
<span class="lineNum">    4584 </span>            :           }
<span class="lineNum">    4585 </span>            :         else
<span class="lineNum">    4586 </span><span class="lineNoCov">          0 :           ei_next (&amp;ei);</span>
<span class="lineNum">    4587 </span>            :       goto succeed;
<span class="lineNum">    4588 </span>            :     }
<span class="lineNum">    4589 </span>            : 
<span class="lineNum">    4590 </span>            :   /* Try to redirect the EH edges and merge the PHIs into the destination
<span class="lineNum">    4591 </span>            :      landing pad block.  If the merge succeeds, we'll already have redirected
<span class="lineNum">    4592 </span>            :      all the EH edges.  The handler itself will go unreachable if there were
<span class="lineNum">    4593 </span>            :      no normal edges.  */
<span class="lineNum">    4594 </span><span class="lineCov">     107333 :   if (cleanup_empty_eh_merge_phis (e_out-&gt;dest, bb, e_out, true))</span>
<span class="lineNum">    4595 </span>            :     goto succeed;
<span class="lineNum">    4596 </span>            : 
<span class="lineNum">    4597 </span>            :   /* Finally, if all input edges are EH edges, then we can (potentially)
<span class="lineNum">    4598 </span>            :      reduce the number of transfers from the runtime by moving the landing
<span class="lineNum">    4599 </span>            :      pad from the original region to the new region.  This is a win when
<span class="lineNum">    4600 </span>            :      we remove the last CLEANUP region along a particular exception
<span class="lineNum">    4601 </span>            :      propagation path.  Since nothing changes except for the region with
<span class="lineNum">    4602 </span>            :      which the landing pad is associated, the PHI nodes do not need to be
<span class="lineNum">    4603 </span>            :      adjusted at all.  */
<span class="lineNum">    4604 </span><span class="lineCov">      24182 :   if (!has_non_eh_pred)</span>
<span class="lineNum">    4605 </span>            :     {
<span class="lineNum">    4606 </span><span class="lineCov">      24136 :       cleanup_empty_eh_move_lp (bb, e_out, lp, new_region);</span>
<span class="lineNum">    4607 </span><span class="lineCov">      24136 :       if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    4608 </span><span class="lineNoCov">          0 :         fprintf (dump_file, &quot;Empty EH handler %i moved to EH region %i.\n&quot;,</span>
<span class="lineNum">    4609 </span>            :                  lp-&gt;index, new_region-&gt;index);
<span class="lineNum">    4610 </span>            : 
<span class="lineNum">    4611 </span>            :       /* ??? The CFG didn't change, but we may have rendered the
<span class="lineNum">    4612 </span>            :          old EH region unreachable.  Trigger a cleanup there.  */
<span class="lineNum">    4613 </span><span class="lineCov">      24136 :       return true;</span>
<span class="lineNum">    4614 </span>            :     }
<span class="lineNum">    4615 </span>            : 
<span class="lineNum">    4616 </span>            :   return ret;
<span class="lineNum">    4617 </span>            : 
<span class="lineNum">    4618 </span><span class="lineCov">     260872 :  succeed:</span>
<span class="lineNum">    4619 </span><span class="lineCov">     260872 :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    4620 </span><span class="lineCov">          6 :     fprintf (dump_file, &quot;Empty EH handler %i removed.\n&quot;, lp-&gt;index);</span>
<span class="lineNum">    4621 </span><span class="lineCov">     260872 :   remove_eh_landing_pad (lp);</span>
<span class="lineNum">    4622 </span><span class="lineCov">     260872 :   return true;</span>
<span class="lineNum">    4623 </span>            : }
<span class="lineNum">    4624 </span>            : 
<span class="lineNum">    4625 </span>            : /* Do a post-order traversal of the EH region tree.  Examine each
<span class="lineNum">    4626 </span>            :    post_landing_pad block and see if we can eliminate it as empty.  */
<a name="4627"><span class="lineNum">    4627 </span>            : </a>
<span class="lineNum">    4628 </span>            : static bool
<span class="lineNum">    4629 </span><span class="lineCov">     204568 : cleanup_all_empty_eh (void)</span>
<span class="lineNum">    4630 </span>            : {
<span class="lineNum">    4631 </span><span class="lineCov">     204568 :   bool changed = false;</span>
<span class="lineNum">    4632 </span><span class="lineCov">     204568 :   eh_landing_pad lp;</span>
<span class="lineNum">    4633 </span><span class="lineCov">     204568 :   int i;</span>
<span class="lineNum">    4634 </span>            : 
<span class="lineNum">    4635 </span><span class="lineCov">    1402155 :   for (i = 1; vec_safe_iterate (cfun-&gt;eh-&gt;lp_array, i, &amp;lp); ++i)</span>
<span class="lineNum">    4636 </span><span class="lineCov">    1197587 :     if (lp)</span>
<span class="lineNum">    4637 </span><span class="lineCov">     549355 :       changed |= cleanup_empty_eh (lp);</span>
<span class="lineNum">    4638 </span>            : 
<span class="lineNum">    4639 </span><span class="lineCov">     204568 :   return changed;</span>
<span class="lineNum">    4640 </span>            : }
<span class="lineNum">    4641 </span>            : 
<span class="lineNum">    4642 </span>            : /* Perform cleanups and lowering of exception handling
<span class="lineNum">    4643 </span>            :     1) cleanups regions with handlers doing nothing are optimized out
<span class="lineNum">    4644 </span>            :     2) MUST_NOT_THROW regions that became dead because of 1) are optimized out
<span class="lineNum">    4645 </span>            :     3) Info about regions that are containing instructions, and regions
<span class="lineNum">    4646 </span>            :        reachable via local EH edges is collected
<span class="lineNum">    4647 </span>            :     4) Eh tree is pruned for regions no longer necessary.
<span class="lineNum">    4648 </span>            : 
<span class="lineNum">    4649 </span>            :    TODO: Push MUST_NOT_THROW regions to the root of the EH tree.
<span class="lineNum">    4650 </span>            :          Unify those that have the same failure decl and locus.
<span class="lineNum">    4651 </span>            : */
<a name="4652"><span class="lineNum">    4652 </span>            : </a>
<span class="lineNum">    4653 </span>            : static unsigned int
<span class="lineNum">    4654 </span><span class="lineCov">     650015 : execute_cleanup_eh_1 (void)</span>
<span class="lineNum">    4655 </span>            : {
<span class="lineNum">    4656 </span>            :   /* Do this first: unsplit_all_eh and cleanup_all_empty_eh can die
<span class="lineNum">    4657 </span>            :      looking up unreachable landing pads.  */
<span class="lineNum">    4658 </span><span class="lineCov">     650015 :   remove_unreachable_handlers ();</span>
<span class="lineNum">    4659 </span>            : 
<span class="lineNum">    4660 </span>            :   /* Watch out for the region tree vanishing due to all unreachable.  */
<span class="lineNum">    4661 </span><span class="lineCov">     650015 :   if (cfun-&gt;eh-&gt;region_tree)</span>
<span class="lineNum">    4662 </span>            :     {
<span class="lineNum">    4663 </span><span class="lineCov">     204568 :       bool changed = false;</span>
<span class="lineNum">    4664 </span>            : 
<span class="lineNum">    4665 </span><span class="lineCov">     204568 :       if (optimize)</span>
<span class="lineNum">    4666 </span><span class="lineCov">     189881 :         changed |= unsplit_all_eh ();</span>
<span class="lineNum">    4667 </span><span class="lineCov">     204568 :       changed |= cleanup_all_empty_eh ();</span>
<span class="lineNum">    4668 </span>            : 
<span class="lineNum">    4669 </span><span class="lineCov">     204568 :       if (changed)</span>
<span class="lineNum">    4670 </span>            :         {
<span class="lineNum">    4671 </span><span class="lineCov">     171225 :           free_dominance_info (CDI_DOMINATORS);</span>
<span class="lineNum">    4672 </span><span class="lineCov">     171225 :           free_dominance_info (CDI_POST_DOMINATORS);</span>
<span class="lineNum">    4673 </span>            : 
<span class="lineNum">    4674 </span>            :           /* We delayed all basic block deletion, as we may have performed
<span class="lineNum">    4675 </span>            :              cleanups on EH edges while non-EH edges were still present.  */
<span class="lineNum">    4676 </span><span class="lineCov">     171225 :           delete_unreachable_blocks ();</span>
<span class="lineNum">    4677 </span>            : 
<span class="lineNum">    4678 </span>            :           /* We manipulated the landing pads.  Remove any region that no
<span class="lineNum">    4679 </span>            :              longer has a landing pad.  */
<span class="lineNum">    4680 </span><span class="lineCov">     171225 :           remove_unreachable_handlers_no_lp ();</span>
<span class="lineNum">    4681 </span>            : 
<span class="lineNum">    4682 </span><span class="lineCov">     171225 :           return TODO_cleanup_cfg | TODO_update_ssa_only_virtuals;</span>
<span class="lineNum">    4683 </span>            :         }
<span class="lineNum">    4684 </span>            :     }
<span class="lineNum">    4685 </span>            : 
<span class="lineNum">    4686 </span>            :   return 0;
<span class="lineNum">    4687 </span>            : }
<span class="lineNum">    4688 </span>            : 
<span class="lineNum">    4689 </span>            : namespace {
<span class="lineNum">    4690 </span>            : 
<span class="lineNum">    4691 </span>            : const pass_data pass_data_cleanup_eh =
<span class="lineNum">    4692 </span>            : {
<span class="lineNum">    4693 </span>            :   GIMPLE_PASS, /* type */
<span class="lineNum">    4694 </span>            :   &quot;ehcleanup&quot;, /* name */
<span class="lineNum">    4695 </span>            :   OPTGROUP_NONE, /* optinfo_flags */
<span class="lineNum">    4696 </span>            :   TV_TREE_EH, /* tv_id */
<span class="lineNum">    4697 </span>            :   PROP_gimple_lcf, /* properties_required */
<span class="lineNum">    4698 </span>            :   0, /* properties_provided */
<span class="lineNum">    4699 </span>            :   0, /* properties_destroyed */
<span class="lineNum">    4700 </span>            :   0, /* todo_flags_start */
<span class="lineNum">    4701 </span>            :   0, /* todo_flags_finish */
<span class="lineNum">    4702 </span>            : };
<span class="lineNum">    4703 </span>            : 
<span class="lineNum">    4704 </span>            : class pass_cleanup_eh : public gimple_opt_pass
<span class="lineNum">    4705 </span>            : {
<span class="lineNum">    4706 </span>            : public:
<span class="lineNum">    4707 </span>            :   pass_cleanup_eh (gcc::context *ctxt)
<span class="lineNum">    4708 </span><span class="lineCov">     681248 :     : gimple_opt_pass (pass_data_cleanup_eh, ctxt)</span>
<span class="lineNum">    4709 </span>            :   {}
<a name="4710"><span class="lineNum">    4710 </span>            : </a>
<a name="4711"><span class="lineNum">    4711 </span>            :   /* opt_pass methods: */</a>
<span class="lineNum">    4712 </span><span class="lineCov">     170312 :   opt_pass * clone () { return new pass_cleanup_eh (m_ctxt); }</span>
<span class="lineNum">    4713 </span><span class="lineCov">    2242253 :   virtual bool gate (function *fun)</span>
<span class="lineNum">    4714 </span>            :     {
<span class="lineNum">    4715 </span><span class="lineCov">    2242253 :       return fun-&gt;eh != NULL &amp;&amp; fun-&gt;eh-&gt;region_tree != NULL;</span>
<span class="lineNum">    4716 </span>            :     }
<span class="lineNum">    4717 </span>            : 
<span class="lineNum">    4718 </span>            :   virtual unsigned int execute (function *);
<span class="lineNum">    4719 </span>            : 
<span class="lineNum">    4720 </span>            : }; // class pass_cleanup_eh
<a name="4721"><span class="lineNum">    4721 </span>            : </a>
<span class="lineNum">    4722 </span>            : unsigned int
<span class="lineNum">    4723 </span><span class="lineCov">     650015 : pass_cleanup_eh::execute (function *fun)</span>
<span class="lineNum">    4724 </span>            : {
<span class="lineNum">    4725 </span><span class="lineCov">     650015 :   int ret = execute_cleanup_eh_1 ();</span>
<span class="lineNum">    4726 </span>            : 
<span class="lineNum">    4727 </span>            :   /* If the function no longer needs an EH personality routine
<span class="lineNum">    4728 </span>            :      clear it.  This exposes cross-language inlining opportunities
<span class="lineNum">    4729 </span>            :      and avoids references to a never defined personality routine.  */
<span class="lineNum">    4730 </span><span class="lineCov">     650015 :   if (DECL_FUNCTION_PERSONALITY (current_function_decl)</span>
<span class="lineNum">    4731 </span><span class="lineCov">     650015 :       &amp;&amp; function_needs_eh_personality (fun) != eh_personality_lang)</span>
<span class="lineNum">    4732 </span><span class="lineCov">     385955 :     DECL_FUNCTION_PERSONALITY (current_function_decl) = NULL_TREE;</span>
<span class="lineNum">    4733 </span>            : 
<span class="lineNum">    4734 </span><span class="lineCov">     650015 :   return ret;</span>
<span class="lineNum">    4735 </span>            : }
<span class="lineNum">    4736 </span>            : 
<span class="lineNum">    4737 </span>            : } // anon namespace
<a name="4738"><span class="lineNum">    4738 </span>            : </a>
<span class="lineNum">    4739 </span>            : gimple_opt_pass *
<span class="lineNum">    4740 </span><span class="lineCov">     170312 : make_pass_cleanup_eh (gcc::context *ctxt)</span>
<span class="lineNum">    4741 </span>            : {
<span class="lineNum">    4742 </span><span class="lineCov">     170312 :   return new pass_cleanup_eh (ctxt);</span>
<span class="lineNum">    4743 </span>            : }
<span class="lineNum">    4744 </span>            : 
<span class="lineNum">    4745 </span>            : /* Verify that BB containing STMT as the last statement, has precisely the
<span class="lineNum">    4746 </span>            :    edge that make_eh_edges would create.  */
<a name="4747"><span class="lineNum">    4747 </span>            : </a>
<span class="lineNum">    4748 </span>            : DEBUG_FUNCTION bool
<span class="lineNum">    4749 </span><span class="lineCov">  877768300 : verify_eh_edges (gimple *stmt)</span>
<span class="lineNum">    4750 </span>            : {
<span class="lineNum">    4751 </span><span class="lineCov">  877768300 :   basic_block bb = gimple_bb (stmt);</span>
<span class="lineNum">    4752 </span><span class="lineCov">  877768300 :   eh_landing_pad lp = NULL;</span>
<span class="lineNum">    4753 </span><span class="lineCov">  877768300 :   int lp_nr;</span>
<span class="lineNum">    4754 </span><span class="lineCov">  877768300 :   edge_iterator ei;</span>
<span class="lineNum">    4755 </span><span class="lineCov">  877768300 :   edge e, eh_edge;</span>
<span class="lineNum">    4756 </span>            : 
<span class="lineNum">    4757 </span><span class="lineCov">  877768300 :   lp_nr = lookup_stmt_eh_lp (stmt);</span>
<span class="lineNum">    4758 </span><span class="lineCov">  877768300 :   if (lp_nr &gt; 0)</span>
<span class="lineNum">    4759 </span><span class="lineCov">  125304257 :     lp = get_eh_landing_pad_from_number (lp_nr);</span>
<span class="lineNum">    4760 </span>            : 
<span class="lineNum">    4761 </span><span class="lineCov">  877768300 :   eh_edge = NULL;</span>
<span class="lineNum">    4762 </span><span class="lineCov"> 3027655276 :   FOR_EACH_EDGE (e, ei, bb-&gt;succs)</span>
<span class="lineNum">    4763 </span>            :     {
<span class="lineNum">    4764 </span><span class="lineCov"> 1272118676 :       if (e-&gt;flags &amp; EDGE_EH)</span>
<span class="lineNum">    4765 </span>            :         {
<span class="lineNum">    4766 </span><span class="lineCov">  125304257 :           if (eh_edge)</span>
<span class="lineNum">    4767 </span>            :             {
<span class="lineNum">    4768 </span><span class="lineNoCov">          0 :               error (&quot;BB %i has multiple EH edges&quot;, bb-&gt;index);</span>
<span class="lineNum">    4769 </span><span class="lineNoCov">          0 :               return true;</span>
<span class="lineNum">    4770 </span>            :             }
<span class="lineNum">    4771 </span>            :           else
<span class="lineNum">    4772 </span>            :             eh_edge = e;
<span class="lineNum">    4773 </span>            :         }
<span class="lineNum">    4774 </span>            :     }
<span class="lineNum">    4775 </span>            : 
<span class="lineNum">    4776 </span><span class="lineCov">  877768300 :   if (lp == NULL)</span>
<span class="lineNum">    4777 </span>            :     {
<span class="lineNum">    4778 </span><span class="lineCov">  752464043 :       if (eh_edge)</span>
<span class="lineNum">    4779 </span>            :         {
<span class="lineNum">    4780 </span><span class="lineNoCov">          0 :           error (&quot;BB %i can not throw but has an EH edge&quot;, bb-&gt;index);</span>
<span class="lineNum">    4781 </span><span class="lineNoCov">          0 :           return true;</span>
<span class="lineNum">    4782 </span>            :         }
<span class="lineNum">    4783 </span>            :       return false;
<span class="lineNum">    4784 </span>            :     }
<span class="lineNum">    4785 </span>            : 
<span class="lineNum">    4786 </span><span class="lineCov">  125304257 :   if (!stmt_could_throw_p (stmt))</span>
<span class="lineNum">    4787 </span>            :     {
<span class="lineNum">    4788 </span><span class="lineNoCov">          0 :       error (&quot;BB %i last statement has incorrectly set lp&quot;, bb-&gt;index);</span>
<span class="lineNum">    4789 </span><span class="lineNoCov">          0 :       return true;</span>
<span class="lineNum">    4790 </span>            :     }
<span class="lineNum">    4791 </span>            : 
<span class="lineNum">    4792 </span><span class="lineCov">  125304257 :   if (eh_edge == NULL)</span>
<span class="lineNum">    4793 </span>            :     {
<span class="lineNum">    4794 </span><span class="lineNoCov">          0 :       error (&quot;BB %i is missing an EH edge&quot;, bb-&gt;index);</span>
<span class="lineNum">    4795 </span><span class="lineNoCov">          0 :       return true;</span>
<span class="lineNum">    4796 </span>            :     }
<span class="lineNum">    4797 </span>            : 
<span class="lineNum">    4798 </span><span class="lineCov">  125304257 :   if (eh_edge-&gt;dest != label_to_block (cfun, lp-&gt;post_landing_pad))</span>
<span class="lineNum">    4799 </span>            :     {
<span class="lineNum">    4800 </span><span class="lineNoCov">          0 :       error (&quot;Incorrect EH edge %i-&gt;%i&quot;, bb-&gt;index, eh_edge-&gt;dest-&gt;index);</span>
<span class="lineNum">    4801 </span><span class="lineNoCov">          0 :       return true;</span>
<span class="lineNum">    4802 </span>            :     }
<span class="lineNum">    4803 </span>            : 
<span class="lineNum">    4804 </span>            :   return false;
<span class="lineNum">    4805 </span>            : }
<span class="lineNum">    4806 </span>            : 
<span class="lineNum">    4807 </span>            : /* Similarly, but handle GIMPLE_EH_DISPATCH specifically.  */
<a name="4808"><span class="lineNum">    4808 </span>            : </a>
<span class="lineNum">    4809 </span>            : DEBUG_FUNCTION bool
<span class="lineNum">    4810 </span><span class="lineCov">    1309200 : verify_eh_dispatch_edge (geh_dispatch *stmt)</span>
<span class="lineNum">    4811 </span>            : {
<span class="lineNum">    4812 </span><span class="lineCov">    1309200 :   eh_region r;</span>
<span class="lineNum">    4813 </span><span class="lineCov">    1309200 :   eh_catch c;</span>
<span class="lineNum">    4814 </span><span class="lineCov">    1309200 :   basic_block src, dst;</span>
<span class="lineNum">    4815 </span><span class="lineCov">    1309200 :   bool want_fallthru = true;</span>
<span class="lineNum">    4816 </span><span class="lineCov">    1309200 :   edge_iterator ei;</span>
<span class="lineNum">    4817 </span><span class="lineCov">    1309200 :   edge e, fall_edge;</span>
<span class="lineNum">    4818 </span>            : 
<span class="lineNum">    4819 </span><span class="lineCov">    2618400 :   r = get_eh_region_from_number (gimple_eh_dispatch_region (stmt));</span>
<span class="lineNum">    4820 </span><span class="lineCov">    1309200 :   src = gimple_bb (stmt);</span>
<span class="lineNum">    4821 </span>            : 
<span class="lineNum">    4822 </span><span class="lineCov">    4127049 :   FOR_EACH_EDGE (e, ei, src-&gt;succs)</span>
<span class="lineNum">    4823 </span><span class="lineCov">    1508649 :     gcc_assert (e-&gt;aux == NULL);</span>
<span class="lineNum">    4824 </span>            : 
<span class="lineNum">    4825 </span><span class="lineCov">    1309200 :   switch (r-&gt;type)</span>
<span class="lineNum">    4826 </span>            :     {
<span class="lineNum">    4827 </span><span class="lineCov">    1269628 :     case ERT_TRY:</span>
<span class="lineNum">    4828 </span><span class="lineCov">    1429505 :       for (c = r-&gt;u.eh_try.first_catch; c ; c = c-&gt;next_catch)</span>
<span class="lineNum">    4829 </span>            :         {
<span class="lineNum">    4830 </span><span class="lineCov">    1357146 :           dst = label_to_block (cfun, c-&gt;label);</span>
<span class="lineNum">    4831 </span><span class="lineCov">    1357146 :           e = find_edge (src, dst);</span>
<span class="lineNum">    4832 </span><span class="lineCov">    1357146 :           if (e == NULL)</span>
<span class="lineNum">    4833 </span>            :             {
<span class="lineNum">    4834 </span><span class="lineNoCov">          0 :               error (&quot;BB %i is missing an edge&quot;, src-&gt;index);</span>
<span class="lineNum">    4835 </span><span class="lineNoCov">          0 :               return true;</span>
<span class="lineNum">    4836 </span>            :             }
<span class="lineNum">    4837 </span><span class="lineCov">    1357146 :           e-&gt;aux = (void *)e;</span>
<span class="lineNum">    4838 </span>            : 
<span class="lineNum">    4839 </span>            :           /* A catch-all handler doesn't have a fallthru.  */
<span class="lineNum">    4840 </span><span class="lineCov">    1357146 :           if (c-&gt;type_list == NULL)</span>
<span class="lineNum">    4841 </span>            :             {
<span class="lineNum">    4842 </span>            :               want_fallthru = false;
<span class="lineNum">    4843 </span>            :               break;
<span class="lineNum">    4844 </span>            :             }
<span class="lineNum">    4845 </span>            :         }
<span class="lineNum">    4846 </span>            :       break;
<span class="lineNum">    4847 </span>            : 
<span class="lineNum">    4848 </span><span class="lineCov">      39572 :     case ERT_ALLOWED_EXCEPTIONS:</span>
<span class="lineNum">    4849 </span><span class="lineCov">      39572 :       dst = label_to_block (cfun, r-&gt;u.allowed.label);</span>
<span class="lineNum">    4850 </span><span class="lineCov">      39572 :       e = find_edge (src, dst);</span>
<span class="lineNum">    4851 </span><span class="lineCov">      39572 :       if (e == NULL)</span>
<span class="lineNum">    4852 </span>            :         {
<span class="lineNum">    4853 </span><span class="lineNoCov">          0 :           error (&quot;BB %i is missing an edge&quot;, src-&gt;index);</span>
<span class="lineNum">    4854 </span><span class="lineNoCov">          0 :           return true;</span>
<span class="lineNum">    4855 </span>            :         }
<span class="lineNum">    4856 </span><span class="lineCov">      39572 :       e-&gt;aux = (void *)e;</span>
<span class="lineNum">    4857 </span><span class="lineCov">      39572 :       break;</span>
<span class="lineNum">    4858 </span>            : 
<span class="lineNum">    4859 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">    4860 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">    4861 </span>            :     }
<span class="lineNum">    4862 </span>            : 
<span class="lineNum">    4863 </span><span class="lineCov">    1309200 :   fall_edge = NULL;</span>
<span class="lineNum">    4864 </span><span class="lineCov">    4127049 :   FOR_EACH_EDGE (e, ei, src-&gt;succs)</span>
<span class="lineNum">    4865 </span>            :     {
<span class="lineNum">    4866 </span><span class="lineCov">    1508649 :       if (e-&gt;flags &amp; EDGE_FALLTHRU)</span>
<span class="lineNum">    4867 </span>            :         {
<span class="lineNum">    4868 </span><span class="lineCov">     111931 :           if (fall_edge != NULL)</span>
<span class="lineNum">    4869 </span>            :             {
<span class="lineNum">    4870 </span><span class="lineNoCov">          0 :               error (&quot;BB %i too many fallthru edges&quot;, src-&gt;index);</span>
<span class="lineNum">    4871 </span><span class="lineNoCov">          0 :               return true;</span>
<span class="lineNum">    4872 </span>            :             }
<span class="lineNum">    4873 </span>            :           fall_edge = e;
<span class="lineNum">    4874 </span>            :         }
<span class="lineNum">    4875 </span><span class="lineCov">    1396718 :       else if (e-&gt;aux)</span>
<span class="lineNum">    4876 </span><span class="lineCov">    1396718 :         e-&gt;aux = NULL;</span>
<span class="lineNum">    4877 </span>            :       else
<span class="lineNum">    4878 </span>            :         {
<span class="lineNum">    4879 </span><span class="lineNoCov">          0 :           error (&quot;BB %i has incorrect edge&quot;, src-&gt;index);</span>
<span class="lineNum">    4880 </span><span class="lineNoCov">          0 :           return true;</span>
<span class="lineNum">    4881 </span>            :         }
<span class="lineNum">    4882 </span>            :     }
<span class="lineNum">    4883 </span><span class="lineCov">    1309200 :   if ((fall_edge != NULL) ^ want_fallthru)</span>
<span class="lineNum">    4884 </span>            :     {
<span class="lineNum">    4885 </span><span class="lineNoCov">          0 :       error (&quot;BB %i has incorrect fallthru edge&quot;, src-&gt;index);</span>
<span class="lineNum">    4886 </span><span class="lineNoCov">          0 :       return true;</span>
<span class="lineNum">    4887 </span>            :     }
<span class="lineNum">    4888 </span>            : 
<span class="lineNum">    4889 </span>            :   return false;
<span class="lineNum">    4890 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.0</a></td></tr>
  </table>
  <br>
<h3>LCOV profile is generated on x86_64 machine using following configure options: configure --disable-bootstrap --enable-coverage=opt --enable-languages=c,c++,fortran,go,jit,lto --enable-host-shared. GCC test suite is run with the built compiler.</h3></body></html>
